{
    "sesam": "Presumably solved with your patch?\nhttp://github.com/edruder/chronic/commit/d5bcab6fe9eb18f1a92a491a6f9ca270391f007d\n. Chronic.parse(\"1st DATE of this month\", :guess => false) # works\nChronic.parse(\"1st day of this month\", :guess => false) # returns today (why???)\n. Presumably solved with your patch?\nhttp://github.com/edruder/chronic/commit/d5bcab6fe9eb18f1a92a491a6f9ca270391f007d\n. Chronic.parse(\"1st DATE of this month\", :guess => false) # works\nChronic.parse(\"1st day of this month\", :guess => false) # returns today (why???)\n. ",
    "edruder": "I believe so!\n. I believe so!\n. ",
    "markcap": "I actually ran into this problem as well. It persists as far as I know. I changed the string to \"12:34\" and that parsed to PM correctly.\n. I actually ran into this problem as well. It persists as far as I know. I changed the string to \"12:34\" and that parsed to PM correctly.\n. ",
    "jschank": "Also, when I try to parse 'yesterday at 12am' I get nil back. This used to work. I suspect the problem is due to today being the day after a DST switch. \n. I don't know. I haven't looked. For me the problem isn't too critical. My gem just doesn't work for a week after a DST change. Which for me isn't an issue. But it would be nice if this were fixed. \n. Also, when I try to parse 'yesterday at 12am' I get nil back. This used to work. I suspect the problem is due to today being the day after a DST switch. \n. I don't know. I haven't looked. For me the problem isn't too critical. My gem just doesn't work for a week after a DST change. Which for me isn't an issue. But it would be nice if this were fixed. \n. ",
    "tjoneseng": "It doesn't look like the mojombo codeline is being maintained.  Have any of the forks fixed this bug?\n. It doesn't look like the mojombo codeline is being maintained.  Have any of the forks fixed this bug?\n. ",
    "leejarvis": "Are you guys still having these issues? \n```\n\n\nTime.zone = \"Mountain Time (US & Canada)\"\nChronic.time_class = Time.zone\nChronic.parse('2009-11-01 12:00:00') == Time.zone.parse('2009-11-01 12:00:00')\n=> true\n```\n\n\nThis may have been fixed in 0.3.0. Please let me know if you're still having this issue\n. Closed by 2d420c726204e499d0d1238d2a8aa14838a6544d\n. Bugs related to timezone offsets and Daylight savings were fixed and released in 0.3.0. I can't reproduce this, and haven't been able to with a previous checkout. So I'll assume the 0.3.0 changes fixed this. If you can reproduce please reopen this issue with steps. Thanks!\n. In fact, these changes will help. I'll work on merging this patch and adding some tests\n. Although Time.construct does force this behaviour, this isn't what the problem is. It's exactly what the Ruby time class does.\n```\n\n\nTime.local(2011, 2, 29)\n=> 2011-03-01 00:00:00 +0000\n```\n\n\nI've marked this as a bug, Chronic should of course do the right thing and return February. I'll work on a fix for this\n. closed by efba57737376fb2516474bc0b0f6676252ced62b\n. Fixed by @AaronH closed by 3bbfee96e98764dbb69c0c2cd1a438ac7a141e92\n. I think this would be a great feature, but I'm not sure how often it'll be used or if it's beyond the primary scope of Chronic. A chronic-i18n might be a good solution. Nevertheless I've marked this issue as a feature and I'll leave it open for further discussion.\n. A note on this, it looks like it's already been started https://github.com/nofxx/chronic18n I haven't played with it yet, though\n. After more thought on this, I'm going to close it. It's not something I think we should look into building directly into Chronic. It would be pretty simple to build a 18n wrapper much like nofxx has, doing text substitutions before sending text to Chronic.parse. Thanks!\n. I can't reproduce this on either 1.8.7 or 1.9.2 with Chronic 0.3.0. Please reopen with more information if you can reproduce still\n. I've cherry-picked your relevant changes into master. Thank you\n. What version of Chronic were you running against? Can you reproduce this? Your tests are running green\n. There's been a few fixes to DSL related code before and after the 0.3.0 release. I can't reproduce this and your tests run green so I'll assume it's been fixed. Please re-open if you have a repro. Thanks!\n. I can't reproduce this\n```\n\n\nRUBY_VERSION\n=> \"1.9.2\"\nChronic.parse('last week Monday').strftime(\"%w\")\n=> \"1\"\n```\n\n\n```\n\n\nRUBY_VERSION\n=> \"1.8.7\"\nChronic.parse('last week Monday').strftime(\"%w\")\n=> \"1\"\n```\n\n\nPlease re-open if you can reproduce this with more information\n. I can't reproduce this and we have tests in place which check against parsing tomorrow after noon, please reopen if you have a repro\n. I do plan on implementing this, but I don't want to set a milestone just yet. I'm currently in the process of immigration so I don't have a lot of time on my hands. If anyone wants to take a shot at this feature, you're welcome to. A QuarterRepeater should be fairly trivial to implement, my main focus is on bugs until I have more time, though. It is coming!\n. @JeskTop No, that's why it's still marked as open.\n. Notice these outputs:\n```\n1.8.7\n\nTime        Sun Aug 01 12:00:00 +0100 2010\nTime(AR)    Fri, 01 Aug 0010 12:00:00 UTC +00:00\n1.9.2\nTime        0010-08-01 12:00:00 +0100\nTime(AR)    Sun, 01 Aug 0010 12:00:00 UTC +00:00\n```\nAs you can see, on Ruby 1.9.2, all went as expected. This is because 1.8 handles years differently to 1.9. ActiveRecord is obviously doing something to ensure 1.8 works like 1.9 does.\nI'm going to close this as a duplicate to #40\n. There's currently no way of interpreting last as the end of a month. Chronic doesn't contain a month day lookup table except for when constructing Time objects, which is too low level for this. I've labeled this as a feature though, I think it's a great idea.\n. @jeremywadsack Yeah that was my intention for this. Just haven't found time to get around to it yet. \n. This has been fixed in the latest release of Chronic\n. The TypeError has been fixed. This is a planned feature, though. (Supporting the conversion of ordinal strings). At the moment the string third tuesday this december will ignore the third and instead be parsed as tuesday this september. I'll leave this issue open and mark it as a feature\n. I've taken a quick shot at this, and although it's extremely easy to implement, there's the issue of parsing second as an ordinal when Chronic relies on it being a literal second. With this patch We can work with the following output:\n```\n\n\nChronic::Numerizer.numerize 'thirty first month on day one'\n=> \"31st month on day 1\"\nChronic::Numerizer.numerize 'twenty second day month twelve'\n=> \"22nd day month 12\"\n```\n\n\nIf anyone has any thoughts for dealing with seconds, feel free to discuss it here\n. So I guess parsing 'second' can be a special case, and unless it's suffixed with 'day/month/hour/minute/second' then people probably mean a literal second. I've updated the patch to allow for this. Thoughts? @mojombo?\n. I can't reproduce this on the latest version of Chronic. Closing for now, please reopen if you can reproduce it\n. Are you still having these issues? I can't reproduce on 1.8.7 on Linux or OS X. If you're still having this issue please post your full Ruby version and what platform you're testing against\n. closed by 32fc9024e6e8bdc0b9965a234b8f46c84d973d06\n. Please open a specific feature request if you want to support parsing 'current month first day', but do remember that Chronic is for parsing natural strings, current month first day is certainly not that. 1st day of this month works fine.\n. @fare5 No, this feature is not yet supported in Chronic.\n. Summoning @mojombo on this. Ruby 1.9.2 will handle any double digit years as prefixed with 00. Ruby 1.8.7 however works a little differently. See this gist where [0-3]3 is handled as 2000, [4-6]3 is handled as 0000, and [7-9]3 is handled as 1900. I can patch Chronic::Scalar.scan_for_years to ensure one version behaves the same as the other. Thoughts?\nEDIT On a side note, ActiveSupport is using DateTime.civil_from_format to ensure 1.8 works like 1.9 (where 79 would return 0079)\n. @mojombo Yeah, we could add a configuration option for this. Any thoughts on a name for it? Also, there's already :endian_precedence which solves mm/dd/yyyy vs dd/mm/yyyy if that's what you meant. Overwritten like so:\nruby\nChronic.parse('03/04/2011').strftime(\"%d/%m\") #=> \"04/03\"\nChronic.parse('03/04/2011', :endian_precedence => [:little, :middle]).strftime(\"%d/%m\") #=> \"03/04\"\nThough this could be simplified.\n. Yeah we don't need to allow the user to pass in nil so feel free to simplify this. I would possibly set :now to nil in the DEFAULT_OPTIONS hash for clarity, and perhaps use @now = options.fetch(:now, Chronic.time_class.now)\nI'm also not sure the test case helps much. If a platform has microsecond accuracy then this test will pass regardless (it would have passed before this patch). That's of course not taking into consideration that this test will fail if not compared against microseconds.\n. Looks great. I'll merge this later tonight and push out a bugfix 0.4.1 version. Thanks!\n. This was already merged in #35. @precipice also commented to say you had the fix, but I believe your pull request was closed at the time.\n. What version of Chronic are you testing against?\n```\n\n\nChronic::VERSION\n=> \"0.4.3\"\nChronic.parse('3 months ago', :now => Time.local(2011, 5, 30))\n=> 2011-02-28 00:00:00 +0000\n```\n. I'm going to close this, please re-open if you have a working repro against the latest stable version of Chronic. Thanks!\n. Thanks for reporting this, it's fixed on HEAD. I'll push out a bugfix version later this evening\n. This is specific to 32-bit systems and 1.8s inability to deal with it (which is fixed in 1.9).\n\n\nI remember seeing this a long time ago. I haven't worked on a system which doesn't support this for a long time. I believe there probably should be tests for outside of this range for compatible systems, but I'll merge this and look into that a little more later. Thanks\nSee also Year 2038 problem and this question on Stack Overflow.\n. This is actually because of how the Ruby Time class deals with day overflows. An example:\n```\n\n\nTime.local(2011, 2, 31)\n=> 2011-03-03 00:00:00 +0000\nChronic.parse('31 feb 2011') == Time.local(2011, 2, 31, 12)\n=> true\n```\n\n\nThe Time class raises an ArgumentError when a day is past 31 (of course it's not possible to have a day later than 31 in any month), but if it's later than the last day of said month, the month will be incremented and days will be added from the start of this month. Chronic has always relied on this functionality be it a feature or a hinderance. \nThe internals of Chronic don't actually care what 31 is (in certain sense). It's relative information. In this case 31 represents 31 days from the beginning of February, which of course, if you count it, is 03/03/2011 (unless it's a leap year).\nI'll have a think about this and leave this issue open for discussion, because I do agree with you. Libraries shouldn't rely on this functionality but it's how Chronic has always done it, so there's always that one exception to the rule.\n. Summoning @mojombo on this discussion. We can go one of 3 ways:\n- Return nil when an out of month day is supplied\n- Raise when an out of month day is supplied\n- Add a :strict option, disabled by default, which will raise when an out of month day is supplied\n. I'm not sure I follow. Can you describe exactly what you're trying to do, perhaps with some code examples? Thanks.\n. I would recommend altering your string before sending it to Chronic. You can easily achieve what you're hoping for by appending a at x where x is the hour/minute/second you want to default to. Here's a little example with a wrapper around Chronic.parse:\n``` ruby\ndef parse(timestr, hms)\n  timestr << \" at #{hms}\"\n  Chronic.parse timestr\nend\np parse('today', '00:00')       #=> 2011-07-11 00:00:00 +0100\np parse('tomorrow', '13:37:15') #=> 2011-07-12 13:37:15 +0100\n```\nOf course your situation might mean spending a little more time normalizing the string before sending it to Chronic, but it should do what you're looking to do. The idea of having a default_time option sort of defeats the purpose of Chronics internals. Remember though that Chronic.parse returns a Time object. So you can also alter the hour/minute/second once you're done.\n. Hah, I had most of a reply written out with what you've found  before you commented again :)\nI'm not so keen on the first idea, because essentially doing Chronic.parse('tomorrow', :guess => :beginning) is exactly the same as doing Chronic.parse('tomorrow', :guess => false).begin. Is there any reason you want to avoid using that? The idea of using a lambda might be neat, though\n. Hi Chris, thanks for pointing this out. This should have been fixed by 1a5f041a56a3dc5d9e4a9046b3542c986ffd3fc3 -- I'm yet to release Chronic version 0.6, though. When I push out that gem the latest stable version should work as expected. If you want to be sure, please carry out these steps:\n1) git clone git://github.com/mojombo/chronic\n2) cd chronic && rake console\n3) Chronic.parse(\"2011-07-20 10:00:00 +0100\")\nIf you still have issues please let me know\n. I plan on pushing out before the end of the week. If you need it badly I can push for a Tomorrow/Wednesday release at the earliest\n. Thanks, I'll add tests and bump bugfix version in an hour or two\n. I like this idea, although I don't see many use cases myself. I'm not sure on a Hash with boolean values, though. I think perhaps returning an Array of elements in order would make more sense. The other issue is what constitues a day for example. Maybe using the same naming scheme as Chronic does with repeaters, for example:\n\"2nd of November 1986 at 3:30pm\"\n[ :ordinal_day, :month_name, :year, :hour, :minute, :day_portion ]\nOr something along those lines. I'll mark this as a feature nonetheless\n. Any more updates to this? I'm willing to leave it open as a feature if it's something people want, but I can't find a use case enough to work on this\n. Cool. I'm gonna shut this issue as it's not something I can actively work on myself. If you have any questions feel free to drop me an email or open a pull request with any advancements. Thanks!\n. Assuming all current tests pass, could you possibly add some more tests for these features? That way I can just merge, otherwise I'll look at this some time in the next couple of days and add tests myself.\nThanks a lot!\n. Interesting. Could you post your ruby version and current timezone, please. Thanks for adding those tests!\n. Strange, I can't reproduce this failure, and everyone I've asked can't reproduce it. I'll have a closer look at it tomorrow and merge this pull\n. Hah, nice. Yeah I have a repro on Ubuntu 10.10 on a VPS. I'll look more into this tomorrow. Thanks!\n. Thanks darix, I'm going to look into rebuilding the repeaters using the Date class instead so handling zone offsets should be a little easier.\n. This is intended behaviour, though I agree it's not most common response. Chronic has handlers in place for matching a month/year but not a day/month or month/day, meaning anyone relying on this behaviour will have their libraries break, which of course I'd like to avoid, at least in a patchfix update. Check out the handle_sd_sm branch which will handle '8/15' as the 15th day of the 8th month, or with '8/12', :endian_precedence => :little as the 8th day of the 12th month. I'll build some tests and think when's best to merge this, the handling of month/year can be a fallback when the second operand looks like a year\n. Merged bd9ff2d8336577f9e04ef7da25fe7bccfe9d5680 into master\n. I've managed to get 10 minutes to look at this. This problem is actually a little more widespread than first though. First of all, Chronic ignores context in day portions. Now you can probably see the problem with a patch like this. Parsing, for example, 24th of January at 7pm with a past context will return the 23rd of January. Chronic isn't (yet) clever enough to know when it's parsing a time/day portion and nothing else. Chronic loops through Repeaters and re-uses code where it can, meaning it's clever enough to know that a month in the past means 1 month ago, or a year in the past means 1 year ago, but not that a 6pm in the past means yesterday at 6pm (unless it's later than 6pm today).\nI'll mark this as a bug and try to find some time in the coming days to take a closer look at it. Thanks for reporting\n. OK so I think I need more user input into this issue. I mean, ignoring context for day portions kinda makes sense, but not in all situations. The trouble is, Chronic defaults to a future context when none is supplied, rather than :none, for example. But ignores this for day portions without more textual context. Meaning parsing 2pm at 3pm will return one hour previous, returning tomorrows 2pm would simply make no sense. But I also understand that at 11pm, 7am is more likely to mean tomorrow. There's a couple things we can do about this, either default to a non-specific context, and have the user supply a context when dealing with day portions, or leave it how it is, and assume the user will provide more information (for example 7am tomorrow, 10pm yesterday etc). Or alternatively have a cut off time, but I'm against that because it'll get extremely confusing for users.\n. @dlupu Unless I'm missing something, I can't make much sense of your issue. \nChronic.parse('27/7/2011 00:43:57', :context => :past) returns 2011-07-26 00:43:57 +0200\nSurely, with a past content, this is exactly what you're expecting?\n. Sorry I'm confused, looking at your examples you say that the first one returns 2011-07-27 00:43:57 +0200 and the last one returns 2011-07-26 00:43:57 +0200, these are both different. Am I missing something?\n. Oh wait, sorry I read your message wrong. You expect them to be the same? You didn't tell me what Time.now was to go by :+1:\n. Right, which was what? :P\n. No, you're correct. Context should not affect the date. It doesn't matter if we're in 1959 or 2059, 2011 is still the same year, that with any other attributes you give to Chronic, the date returned is supposed to be contextual, context is useless with an absolute date; or should be, at least.\nTrying to find some time over the holidays to hack on Chronic but I'm finding it hard. I will get around to fixing this!\n. Chronic doesn't know what Eastern Daylight Time is, they're merely words, and that's how it's always been. I can't reproduce a positive result with any previous version of Chronic. If you're able to reproduce the passing example I can look into it a little closer. You're sure you're not using ActiveSupport magic for timezones? As stated in the README, for full timezone support, you'll want to use the TimeZone ActiveSupport provides. \nChronic will however parse EDT for Eastern Daylight Time, but there aren't currently any handlers in place to handle your provided string. I'll keep this issue open and look into that\n. @tomekr I don't see how your issue is related to this one. I've fixed your issue in 1be79748d0899b2586a68b4cb009eb9673dde3d2 and pushed 1.6.3\n. I'll have time to look at this later in the week, but initial feedback; you can drop the comment in e0d7267, judging by the regexps you've added it looks a little too taylor made for this specific use case, and might be better implemented as an independent handler, but I'll see when I have time to look a little closer. Would you mind squashing these commits into one or two (impl/tests), it's a little easier to review that way\nThanks for the contribution!\n. It's no problem, I appreciate the effort! I might have time to squash\nthem myself tomorrow and look a little closer at this, time\npermitting.\nThanks again, keep up the Ruby!\nOn 17 Aug 2011, at 23:40, pauldambra\nreply@reply.github.com\nwrote:\n\nHa, well I've managed to add 2 commits while trying to squash (does it show I'm new to Git? :-)) I'll get some advice tomorrow.\nThanks for the feedback... I'll look at the handlers but that's much more Ruby to get my head around!\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/pull/63#issuecomment-1831538\n. I've merged this into a feature branch and rebased the commits. I'm still not entirely sure if I want to merge this into core or not, but I'll leave the branch there for now to think about and close this pull request. Thanks again!\n. Actually this is intended behaviour. Thinking logically, if someone said to me 2pm -- even if it was 7pm, I wouldn't think of 2pm tomorrow, I'd think of today. A similar one is 10am when it's currently 10pm on the same day, I think it's more likely to be talking about 10am today, not tomorrow.\n\nAnyone want to add thoughts to this?\n. Merging this issue with #60 as the same questions lie with both of them, and I think it needs more discussion, thanks!\n. This is a duplicate of #15. It's not as easy as simply exporting regular expressions. Chronic is built on parsing English strings, and I believe supporting I18n out of the box is far beyond the scope of Chronic. Although this repository hasn't had much love for a while, it's probably a good base to start implementing I18n on top of Chronic - https://github.com/nofxx/chronic18n. \nI'm -1 on supporting I18n out of the box, but I'll leave this issue open for a couple of days in case @mojombo or anyone else would like to chime in.\n. Chronic doesn't understand <year> <month> <ordinal> which is why it's displaying the next occurrence of 22nd May, it'll be the same with any other date. I'll mark this as a feature\n. Thanks, this is quite a major bug and it's a shame it hasn't been covered by tests already, as it's not such a simple fix. Chronic currently checks only if todays month index is less than or equal to the index of the month we're looking for. Meaning it doesn't take days into consideration at all. Parsing '1st Jan' with a future context will always return the previous 1st of January even when the current date is the 28th of January. The problem code is here, I'll have a think about this one, but with some of the latest issues it's telling me the way Chronic sends information to repeaters needs to change\n. Closing this as a duplicate of #60 -- hoping to fix this soon but it involves quite an overhaul. Thanks for reporting\n. master is fine, I haven't outlined it in the README so I can manually manage it. Looks good, thanks. Assuming all other tests pass with this I'll merge it this evening and push out the other bug fixes for a 1.6.4. Thanks again\n. It looks like there isn't a handler in place for parsing this string. I'll look into this tomorrow. Thanks for reporting\n. Odd, I can't reproduce this.\n```\n\n\nTime.now\n=> 2011-10-02 23:55:20 +0100\nChronic.parse 'today'\n=> 2011-10-02 23:30:00 +0100\nChronic.parse 'tomorrow'\n=> 2011-10-03 12:00:00 +0100\nChronic.parse 'yesterday'\n=> 2011-10-01 12:00:00 +0100\n```\n\n\nI'm also on Lion, using 1.9.2 with Chronic 0.6.4\n. Can you try this on another machine to rule it out? There's not much I can do to help without a reproduction I'm afraid \n. Looks perfect. No feedback on your code, it looks good. Pull requests like this (small, with readable changes and full tests) will be merged with no hesitance. Thanks for contributing!\n. The first one has never worked, the second one works fine for me. What version of Chronic are you using?\n```\n\n\nChronic::VERSION\n=> \"0.6.4\"\nChronic.parse '29th of November'\n=> 2011-11-29 12:00:00 -0800\n```\n. @zhon the latter shouldn't have a handler anyway. When you say 'on the current branch' do you mean it works on HEAD but not the latest version of Chronic?\n. Weird, that shouldn't be the case as I tested it on both. I'll be pushing a new version later this week anyway so if this is fixed to you on HEAD you'll see these changes on the next stable release. Thanks for reporting\n. zhon, Chronic ignores any word which doesn't interest its tokenizer. It builds a pattern and executes a method which is mapped to said pattern. Meaning what you're looking for is probably perfectly doable. For example:\n\n\n```\n\n\nChronic.parse 'the 29th of november, 2011, some stuff here etc at 10:30am'\n=> 2011-11-29 10:30:00 -0800\n```\n\n\nBut, altering this string by adding a single word that Chronics tokenizer is interested in, could break if there's no associated handler for this pattern:\n```\n\n\nChronic.parse 'Tuesday the 29th of november, 2011, some stuff here etc at 10:30am'\n=> nil\n```\n\n\nIt's all about having a handler available to match specific patterns. If you have a certain pattern you'd like to match, please feel free to open an issue with the debug information returned by running these commands:\n```\n\n\nChronic.debug = true\nChronic.parse(\"my string here\")\ndebug output here\n```\n\n\nExample:\nChronic.parse 'this string contains something chronic is interested in: 10pm'\n[ this(grabber-this) , interested(timezone) , in:(pointer-future) , 10(repeater-time-36000?) , pm(repeater-dayportion-pm) ]\nSo this tells us building a Handler which responds to [:grabber, :timezone, :pointer, :repeater_time, :repeater_day_portion] means we can parse these values and return some quality information.\nHope that helped\n. You've given a bit of an overload of information here. The '5th Tuesday' of any month is always going to be a future month. Sorry I'm working and have little time to browse over bugs at the moment, anything you can do to point directly to the issue you think is a bug specifically would really help me\n. ```\n\n\nputs %w(January February March April May June July August September October November December).map { |m| [m, Chronic.parse(\"5th tuesday in #{m}\")].join(' => ') }.join(\"\\n\")\nJanuary => 2012-01-31 12:00:00 -0800\nFebruary => \nMarch => \nApril => 2012-05-01 12:00:00 -0700\nMay => 2012-05-29 12:00:00 -0700\nJune => \nJuly => 2012-07-31 12:00:00 -0700\nAugust => \nSeptember => \nOctober => 2011-11-01 12:00:00 -0700\nNovember => 2011-11-29 12:00:00 -0800\nDecember => \n```\n\n\nJust saw your update, yes you're right, I wasn't thinking straight. Interesting results. I'll look into this a little more at the end of the week, thanks for reporting :+1:\n. Please test against latest head and let me know if this is all fixed for you, the test cases pass. Thanks for reporting!\n. This appears to be fixed in the latest revision of Chronic. Please re-open if you can reproduce these errors.\n. Thanks a lot for this, love me some tests <3\n. I planned to push later this weekend, but as far as I'm concerned this is a bugfix, and if you need it, I'll push a new gem now\n. :+1: if there's no gem by the weekend, please shout at me (super busy at the moment). Thanks again!\n. :+1: 58dc69bed9470711889222f968706984c0a6d193\n. Interestingly enough, 14:00pm works correctly. Will dig deeper\n. Actually, it looks like this has been fixed since.\n=> 2013-01-28 16:21:55 +0000\n1.9.3 >> Chronic.parse '5pm'\n=> 2013-01-28 17:00:00 +0000\n1.9.3 >> Chronic.parse '17:00'\n=> 2013-01-28 17:00:00 +0000\nI'm going to close this and if any issues come from it please re-open.\n. Chronic isn't designed for parsing date ranges like this. The only range Chronic will hand you back is the range between now and the date you've specified. If you want a date range, simply parse the dates separately.\n. Shoot, I updated my gh-pages and forgot to ask @mojombo to update this. The URL is http://injekt.github.com/chronic \nThe documentation is due to be rewritten in TomDoc though, so the YARD docs will be going down soon to be (hopefully) replaced with some new docs.\nThanks for reporting, I'll close this issue once @mojombo has had chance to change it\n. This looks great, merging and releasing fixes with a version bump. Thanks a lot Joe!\n. This isn't functionality that should be baked into Chronic. Chronic is for naturally parsing times and dates, and to me someone saying '4' in the context of a date or time would usually mean 4 o'clock on the same day. \nYou can abstract this conditional out before hitting Chronic:\nruby\nChronic.parse(mynumber) unless mynumber =~ /\\A\\d\\z/\n. What version of Chronic are you using?\n```\n\n\nChronic::VERSION\n=> \"0.6.7\"\nChronic.parse 'first day of this month'\n=> 2012-02-16 12:00:00 +0000\nChronic.parse '1st day of this month'\n=> 2012-02-16 12:00:00 +0000\nChronic.pre_normalize '1st day of this month'\n=> \"1st day of this month\"\nChronic.pre_normalize 'first day of this month'\n=> \"1st day of this month\"\n``\n. Yeah, it _should_. I don't think there's a handler for this. I'll leave this issue open for now and look into it when I have time. Thanks\n. Precisely. The problem is here: https://github.com/mojombo/chronic/blob/master/lib/chronic/repeaters/repeater_month.rb#L29 Chronic isn't setup to pass tokens to repeaters, so the repeater RepeaterMonth has no idea the ordinal1stexists. This is a widespread issue and isn't as simple as replacing@now.day + 1with1`.\n. I like this idea, but one could argue we need a context for each element. That is, we may want a specific day or month to be fixed whilst the rest of the information is flexible. I'll leave this open as a feature, as it would be something I'd like to implement. I'm working on a small rewrite of Chronic to get around some of the restrictions which has lead to some of the bugs listed on the tracker. It's certainly not an easy feat, though. This is most likely to fit into the road to version 1.\n. There's not really much way to get around this. Chronic isn't built for extracting times, but rather parsing them. That is, Chronic expects something which represents a string that should return a new Time object. Your time should first be extracted from your string before it's sent to Chronic.\n. Yeah, Chronic should of course not raise an error like that but should\nreturn nil. See the commit I referenced above, with that in place\nchronic will return nil for the string you've provided. It'll be\nreleased soon.\n\n\nOn 1 Jun 2012, at 04:33, Mike Ottum\nreply@reply.github.com\nwrote:\n\nYeah, that makes sense. I'm trying to use Chronic to both extract and parse by splitting a sentence up into its component phrases and attempting to parse each phrase (in order of decreasing length) with Chronic. If Chronic returns nil, the algorithm moves onto the next phrase.\nSo, for this issue, I don't expect Chronic to be able to extract the time from the long phrase, but I would like it to return nil instead of throwing an exception. Does that seem reasonable? If so, I can attempt a fix.\nOn Thursday, May 31, 2012 at 9:51 AM, Lee Jarvis wrote:\n\nThere's not really much way to get around this. Chronic isn't built for extracting times, but rather parsing them. That is, Chronic expects something which represents a string that should return a new Time object. Your time should first be extracted from your string before it's sent to Chronic.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/86#issuecomment-6041230\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/86#issuecomment-6052901\n. Closed by @jeremyf's work in 8d2e4d22ae4a14fbabe46b92006b00609fbffa75\n. @jeremyf My main priority is to solve the issues. I can spend any other time prettying it up. I haven't had much time for Chronic lately as real life and work has been catching up but I do plan on spending time on it soon. This is a massive help. Thank you\n. You're correct. 9:26 will work whilst 09:26 will not (for Post meridiem). I'm hoping to find some time over the weekend to fix this. Thank you for your patience!\n. This is looking great. I can't auto pull without tests though. Unfortunately I'm a little bogged down with startup life which is why I haven't had much time to work on Chronic so I won't be able to write tests for this for a while. If you'd like to take a shot at it please feel free. \n\nCould you also remove the rogue .DS_Store that managed to sneak in there? \nThanks for the hard work! :+1: :metal:\n. This is awesome. Merging into develop before a feature release. Thanks for all the hard work!\n. Chronic doesn't yet parse the first day of the month. This will be added soon\n. If this all passes fine on Ruby 1.8.6+ then I'm happy to do so. Could you knock up a patch and submit a pull, @An0Hit0?\n. Yeah, this would require a new pattern. This isn't something I feel is all that necessary. If you'd like to add it please give it a go and send a pull request. Thanks\n. Chronic doesn't yet understand the first day in the month, nor any other of those strings. Parsing the first day of the month will be added asap. Thanks for reporting\n. This is great. Thanks a lot!\n. This looks good. Although it'll only handle a lowercase a, we should probably support both lower and uppercase. Thanks!\n. Thanks for the change, although can I recommend using /^\\s?an? /i instead as I think it looks a littler clearer. I can work on releasing this as part as the gem before the end of next week. Thanks again\n. Merging and modifying myself. Thanks for the code\n. I would probably rather have this as part of the Repeater class in lib/repeater.rb inside the method scan_for_units, I think you'll see it makes more sense in there rather than in the normalize method. Essentially a 'normalized' string shouldn't have to stray too far from the original string. It's the job of the scanners to implement matching rules and assign tags.\nCould you also add some tests for this, please? Once it's there I can merge it straight away.\nThanks for your work.\n. in test/test_parsing.rb you'll see the method test_parse_guess_gr, inside that you'll see the day portions and everything following those. Somewhere in there with the corresponding tests would be great.\n. Merged. Thanks!\n. Yeah the problem is here. Because 'second' can be ambiguous to Chronic, I catch it (or attempt to catch it) early and convert it to 2nd. Otherwise second will be interpreted as a unit of time. It's difficult to interpret what words are likely to come after second where you would expect to replace it with 2nd. Of course the days of the week are included in these, though.\nAre there any other examples you can think of where this may be the case before I just add week days? \n. If you're having a LoadError it means your program is unable to locate chronic in $LOAD_PATH. \nI'm not sure exactly what you'd like the README to state, but if you're parsing a string via a web form then you just need to handle that inside your controller (for example).\nClosing this as it's not a Chronic issue.\n. Chronic::DEFAULT_OPTIONS[:endian_precedence] = [:little, :middle]\nI don't think setting the default endian precedence per zone makes much sense. Chronic should have the same functionality no matter where you use it and doing so could break apps which could be frustrating for users to troubleshoot (This is coming from someone who also changes the default options all the time as everything I do is also UK based).\n. Chronic is for parsing natural language. That is, you would tell Chronic something that would make sense well you tell your buddy. Saying \"Wednesday\" when today is Wednesday makes little sense. Your last example (which actually returns the correct day, is the one which makes sense. You're telling Chronic to head back to yesterday and then use the string \"this wednesday at 22:00\" which again, would make sense in a conversation (even if 'tomorrow' would be more likely)\n. Chronic wasn't really built for this. But let's dig deeper. Take the documentation of the ambiguous_time_range option:\n#        :ambiguous_time_range - If an Integer is given, ambiguous times\n    #                  (like 5:00) will be assumed to be within the range of\n    #                  that time in the AM to that time in the PM. For\n    #                  example, if you set it to `7`, then the parser will\n    #                  look for the time between 7am and 7pm. In the case of\n    #                  5:00, it would assume that means 5:00pm. If `:none`\n    #                  is given, no assumption will be made, and the first\n    #                  matching instance of that time will be used.\nThis tells us using :none returns the first matching instance of that time. We probably don't want that because although the figure we're providing is not ambiguous to us, it is to Chronic. It also says \"If an Integer is given, ambiguous times (like 5:00) will be assumed to be within the range of that time in the AM to that time in the PM\" so lets try that:\n```\n\n\n1.upto(25) { |i| p Chronic.parse(i.to_s, ambiguous_time_range: 12) }\n2012-07-23 13:00:00 +0100\n2012-07-23 14:00:00 +0100\n2012-07-23 15:00:00 +0100\n2012-07-23 16:00:00 +0100\n2012-07-23 17:00:00 +0100\n2012-07-23 18:00:00 +0100\n2012-07-23 19:00:00 +0100\n2012-07-23 20:00:00 +0100\n2012-07-23 21:00:00 +0100\n2012-07-23 22:00:00 +0100\n2012-07-23 23:00:00 +0100\n2012-07-23 12:00:00 +0100\n2012-07-23 13:00:00 +0100\n2012-07-23 14:00:00 +0100\n2012-07-23 15:00:00 +0100\n2012-07-23 16:00:00 +0100\n2012-07-23 17:00:00 +0100\n2012-07-23 18:00:00 +0100\n2012-07-23 19:00:00 +0100\n2012-07-23 20:00:00 +0100\n2012-07-23 21:00:00 +0100\n2012-07-23 22:00:00 +0100\n2012-07-23 23:00:00 +0100\n2012-07-24 00:00:00 +0100\nnil\n```\n\n\nThe problem with this is that you're telling Chronic to be a little more strict and that your time is not ambiguous (when we all know 1 is ambiguous when it comes to time). If all you really need to do is parse a numeric looking string and return an hour, I would simply recommend using Rubys build in Time class.\n. This has nothing to do with the day. You're comparing completely different strings.\n```\n\n\nChronic.parse '14th this month'\n => nil\nChronic.parse '15th of june 2010'\n=> 2010-06-15 12:00:00 +0100\n```\n\n\nThis tells me Chronic just doesn't support parsing x this month no matter which day it is. Remember, Chronic is for parsing human comprehensible time strings. \"15th of June 2010\" is something someone might say, \"fifteenth this month\" is not so much.\n. Yep, I agree. I'll add it to the list of handlers to implement. Thanks\nOn 26 Jul 2012, at 15:21, Taylor Brooks\nreply@reply.github.com\nwrote:\n\nSorry, I left out the word 'of' should've read:\n``` console\nirb(main):001:0> Chronic.parse('15th of this month')\n=> nil\nThat's a human comprehensible or even '15th day of this month'\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/109#issuecomment-7278896\n``\n. I'm loving your enthusiasm, but is there a point to opening this issue?\n. That's great. I think having something similar to Chronic in any other languages is good. I recommend starting something and asking for contribution once you have a stable and basic structure of code in place. I'm going to close this as it's not an issue with this library, but please let me know via [twitter](http://twitter.com/lee_jarvis) or email how you get on.\n. No, Chronic attempts to _guess_ the date you mean (because you didn't provide it. If you want the 1'st of the month you should pass:guess => falsetoChronic.parseand Chronic will return an instance ofChronic::Span`. You can then fetch the begin/end values of this span:\n\n```\n\n\nChronic.parse('july 2012', guess: false)\n=> 2012-07-01 00:00:00 +0100..2012-08-01 00:00:00 +0100\n_.begin\n=> 2012-07-01 00:00:00 +0100\n```\n. Thanks for all this work. I'm not really sure how I feel about adding this kind of functionality to Chronic but I quite like what you've done. I've merged this into the localization branch as I think it needs a little work and more tests but I'm happy to work towards merging this.\n\n\nThanks a ton\n. @luan Now I've refactored master a little I think this might fit. Could you take a shot at rebasing things against master so we can merge and roll this out? Otherwise I'll take a shot at it when I have some spare time. :metal: \n. @luan Sorry I am planning on finding time for this, I'll rebase the changes against master. I need to fix some of the big bugs on head before this featured is merged upstream. Thanks again for the work on this!\n. Sorry I've been super busy lately. I've merged this locally but I'm having failures I'll need to resolve before merging upstream\n. I've merged this into the localization branch and fixed the conflicts. It's not yet running green though, as there are issues with the numerizer parsing. \n. Yeah I must have missed your comment on that other issue. This looks great, thanks for the pull will merge this straight away.\n. Closed by #113\n. Why not just use Rubys built in Time class for this?\n```\n\n\nTime.at(date +%s.to_i)\n=> 2012-08-14 14:54:10 +0100\n```\n. Yeah I'm with Luan on this one. You can accomplish what you want with something easy like\n\n\nruby\ntime = str =~ /\\A[0-9]{10}\\z/ ? Time.at(str.to_i) : Chronic.parse(str)\nThanks for the suggestion.\n. Chronic replaces all periods with colons. This is because 4.15 is a common alias for 4:15 for example. Supporting floats is going to be difficult. I'm not sure it'll be a popular request, either. I'll leave this open but for me it's on the bottom of the issues/features list. Lots of other things have to be done first. Thanks for the suggestion\n. Sorry but I'm gonna go ahead and close this. There's just so much ambiguity when using floats and the existing parsing system Chronic uses. \n. What you're asking for would be somewhat complicated because there's just so many ways to represent even the simplest of timestamps and that's just in the English language.\nI'm going to close this as it's not related to Chronic. But feel free to update it if you find something that does what you're looking for.\n. I think it would need too many configuration options. Most of which strftime cover. You could start with something simple like this, though:\n``` ruby\n!/usr/bin/env ruby\nclass PrettyTime\n  def self.convert(time)\n    out = ''\n    now = Time.now\nout << ordinalize(time.day)\nout << \" \"\nout << monthify(time.month)\nout << \", \"\n\nif time.year < now.year\n  years_ago = now.year - time.year\n  years_str = years_ago > 1 ? \"#{years_ago} years ago\" : \"last year\"\n  out << years_str\nend\n\nout << \" at \"\n\nhour = time.hour\nout << (hour < 12 ? \"#{hour}am\" : \"#{hour - 12}pm\")\n\nend\ndef self.ordinalize(number)\n    if (11..13).include?(number.to_i.abs % 100)\n      \"#{number}th\"\n    else\n      case number.to_i.abs % 10\n        when 1; \"#{number}st\"\n        when 2; \"#{number}nd\"\n        when 3; \"#{number}rd\"\n        else    \"#{number}th\"\n      end\n    end\n  end\ndef self.monthify(month_int)\n    %w(January February March April May June July\n      August September October November December)[month_int - 1]\n  end\nend\np PrettyTime.convert Time.local(2006, 8, 16, 15, 0, 0, 0) #=> \"16th August, 6 years ago at 3pm\"\n. The problem here is that Chronic doesn't support zone based parsing. Chronic recommends using Active Support to set the time zone with `Chronic.time_class = Time.zone` as noted in the README. So yes, this is likely to create a race condition. It's likely that if the `parse` method accepted a time zone or time class it could instead be grouped with the returning time object and avoid a race condition. Chronic should however, not rely on Active Support but I would consider adding a `:time_zone => 'America/Phoenix'` option to `parse` which would (if set), load Active Support safely. \n. Yep same as #121. Trying to find some Chronic time but struggling a little. How about taking a shot at this if you can, @yfeldblum?\n. What version of Chronic are you using? The second example doesn't work for me.\n.\n\n\nChronic.parse('2012-09-27 10:00:00')\n=> Thu Sep 27 10:00:00 +0100 2012\n```\n\n\nYou're using Chronic version 0.3.0. Please upgrade, there are a lot of bugs with version 0.3.0.\n. ```\n\n\n[RUBY_VERSION, Chronic.parse(Time.now.to_s)]\n=> [\"1.9.3\", 2012-09-28 12:10:21 +0100]\n[RUBY_VERSION, Chronic.parse(Time.now.to_s)]\n=> [\"1.8.7\", Fri Sep 28 12:12:44 +0100 2012]\nChronic.parse('2012-09-27 10:00:00 +0000')\n=> Thu Sep 27 11:00:00 +0100 2012\n```\n\n\nChronic version 0.8.0\n. Looks great, thanks!\n. @EddyKang Please open a separate issue for this feature (it's actually slightly different from this one). Cheers!\n. Thanks and I appreciate you taking a shot at this. I still think however that this is the wrong approach. I would rather encapsulate all of the data into a single instance of a parser class or something similar. It would clean up Chronic in general as well as fixing this issue.\nCheers!\n. > you probably already have the code structured more or less the way you want it, and probably wouldn't want to disturb everything\nVery much the opposite. Chronic has massive space for improvement, and if disturbing the code base is what it takes to achieve this, that's exactly what needs to happen.\n\nOr the logic in Chronic.parse could be split out into a Parser class, which would have an attribute :now. Chronic.parse would simply instantiate a Parser and call \"parse\" on it.\n\nThat's exactly the kind of thing I had in mind. Something similar to this:\n``` ruby\nmodule Chronic\n  def self.parse(text, options = {})\n    Parser.new(options).parse(text)\n  end\nclass Parser\n    def initialize(options)\n      @options = options\n    end\ndef parse(text)\n  # parse into tokens and delegate to tag scanners\n  # passing this parser instance around as and when we need it\nend\n\nend\nend\n```\n. Cool. Looking good so far. Can you move the Parser class into it's own file?\nAlso not sure about all the references to self in the Handlers module, I think I like the idea of including them into the Parser class though but I'm still not entirely sure that's a good idea. I realize if we don't do that then it means we need to pass the parser instance to every handler method which I'm also not happy about. I think your solution is probably better right now.\nGreat work so far!\n. I like this, can you open a new pull request and we can discuss it further in there. Cheers!\n. Thanks. There's an issue here, though. The tests do not pass on your branch but they pass on master.\nCould you also rebase this, there are conflicts between your commits.\n. Looks good, thanks. I'm going to merge this into a development branch and keep master for bugfixes, until we have some more tests for issues #121 and #123 and then I'll merge into master.\nThanks!\n. Yeah, they shouldn't be hard at all. I've merged this pull request into the next branch. Any further work towards this should happen in there.\n. That's fine, I'll review this as is. However we shouldn't need to test differences between MRI and JRuby so I think just containing everything in the Parser class will work as expected.\nThanks for your work on this, good stuff!\n. I don't believe the test is necessary especially if it's dependant on Ruby implementations. If all configuration options are incapsulated into an instance of Chronic::Parser I don't believe we should have any issues. You can just revert that commit and I will merge this PR. Cheers\n. This has limitations just like the parse methods on Time and Date, even Ruby's underlying date parsing algorithm returns 20 as the month and 12 as the month day. \nThe only thing we can really do about this is provide an extra configuration option which adds the Handler scalar_year which will return the year instead of the time\n. That's not what a Chronic::Span object is intended to do, and I believe Chronic shouldn't be designed to take on this kind of feature (it may seem simple, but it involves added a massive set of features). Essentially you should get a Chronic::Span object from every possible timestamp. It looks like you want to return 2 separate timestamps, why not something like:\n``` ruby\ndef get_span(string)\n  if match = string.match(/\\Afrom\\s(.+?)\\s(?:to|until)\\s(.+)\\z/)\n    match.captures.map { |c| Chronic.parse(c) }\n  end\nend\np get_span(\"from 1st December 2009 to 2nd of Jan 2011\") #=> [2009-12-01 12:00:00 +0000, 2011-01-02 12:00:00 +0000]\n``\n. Actually I'm thinking of just rolling back to doing explicit requires. I never really liked autoload, anyway.\n. I can't reproduce this even when changing the current time to a daylight saving zone, it seems like it could be more of an issue with Ruby's Time class. Please re-open if you can reproduce an error specific to Chronic\n. Merged, thanks!\n. No there hasn't, I'm struggling to find time for Chronic at the moment. Hoping to start hitting some of these as soon as possible\n. @markerdmann sorry I hadn't noticed your message until today. I can't reproduce the original issue so it'll probably take me a little longer to fix. Usually I would enable debug mode (Chronic.debug = true) then jump into the method that handles this sequence (inHandlers) then debug things from there. It's not always a quick process and there's a few subtle bugs in Chronic that aren't easy to fix. I do still have a rewrite that's currently in progress but again I'm finding it hard to find work on this at the moment, everything is tied up with work\n. No, there's no way to do this. Right now Chronic discards the tokens it doesn't care about [right here](https://github.com/mojombo/chronic/blob/master/lib/chronic/parser.rb#L219). That is, any token that doesn't contain any tags will be thrown into/dev/null`.\nI don't see the benefits of extracting the non tagged items myself. At least not enough to alter the way Chronic works and store them in memory. There will be a ton of caveats when doing this. For example, the word at will be tokenized and tags will be applied to it. So if you had tomorrow I'll be at the station you'll have I'll be the station returned. \nHere's how you could extract those values, though (see the other_words variable):\nruby\n    def tokenize(text, options)\n      text = pre_normalize(text)\n      tokens = text.split(' ').map { |word| Token.new(word) }\n      [Repeater, Grabber, Pointer, Scalar, Ordinal, Separator, TimeZone].each do |tok|\n        tok.scan(tokens, options)\n      end\n      other_words = tokens.reject(&:tagged?).map(&:word) #=> [\"Go\", \"to\", \"the\", \"doctor's\"]\n      tokens.select { |token| token.tagged? }\n    end\n. Thanks!\n. Yes it's the Numerizers fault. I'd like to eventually drop support for the internal Numerizer and use https://github.com/jduff/numerizer instead. Which was originally extracted from Chronic, but I would like to manage it separately. \n. I should also note that 'second' isn't returned as '2nd' not because this is a bug but because 'second' in Chronic is obviously also a time unit\n. Awesome work, thanks a lot\n. Looks good. Great work! Thanks\n. No there's currently no way to do this, but it does need to be added. We can just accept a time_class option which can be set to Time.zone before parsing, and defaults back to Chronic.time_zone. \n. @burlesona Yeah you wouldn't have to alter Time.zone you could just do this:\nChronic.parse('December 21st at 4PM', :time_class => Time.zone) Chronic would simply use this class to calculate times, it would not alter it in any way.\n. It does make sense, but I think passing in a time_zone as a separate string is beyond the scope of Chronic. Why not do something like this in your model/class/etc:\n``` ruby\ndef parse_time(string, zone)\n  orig_timezone = Time.zone\n  Time.zone = zone\n  Chronic.parse(string, :time_class => Time.zone)\nensure\n  Time.zone = orig_timezone\nend\nparse_time 'Jan 2nd', 'Eastern Time (US & Canada)'\n``\n. Maybe this will create race conditions? The problem is, doing it inside Chronic would make no difference..\n. I'm going to close this, if you have any more opinion on the matter or ideas feel free to re-open and discuss.\n. @dnagir Yes I am; see my comment on #182 \n. :metal: Happy new year to you too!\n. What version of Chronic are you using? Every one of those parses fine for me on 0.9.0\n. Hah I didn't noticed that! :metal:\n. I'm not sure I see the benefit of adding this method to the public API. It's essentially absolutely no different from doing this in your own code:time = Chronic.parse('some string') or raise \"...\"adding bang methods for 'things that raise' has been a Rails-esque thing to do and for someone who's not used to that it could be confusing. Thanks for digging in, though!\n. I appreciate this is something that would be extremely useful to your use-case, but there's just not enough need for this to merge into Chronic. I disagree with thethere can't be many people who haven't used rails at some pointcomment but that's unrelated and isn't the main reason I won't merge this. It's really just too easy to add this method in your own code rather than baking it into a public API where it's unlikely to be used very often.\n. @johari I don't understand why this is a feature request. The reasonparse!is not part of the public API is because it adds absolutely no benefit. First of all, bang methods for something that raises an exception in counter to the non-bang method that would returnnilis a Rails-esque _feature_. Secondly I see no reason why users couldn't just add this check to their own code. If you knowparsereturnsnilyou should check for it in a validation. Alternatively you can add your ownparse!` method.\nI'm open to all feature requests but I don't see a great enough benefit for this.\n. > it seems silly that what most people would expect to be the default case isn't supported at all\nWhat makes you think that? Chronic has been around for 7 years and this is the only occurrence of someone requesting this behaviour.\n. @johari Comparing to strptime probably isn't fare. That method expects a valid format. The reason Chronic doesn't raise is because there isn't such thing as a valid format. Chronic will attempt to extract a time object from any string. Chronic may or may not be able to parse your string and return a time object, and I think raising if it's unable to is a bad idea because your string may very well look like a valid time string, but maybe it does not yet support that format.\nI would of course accept pull requests for documentation improvements.\n. The start date is most definitely correct, but the end date should be course be 2013. Odd, it looks like there's a test to cover this here. I'll have to dig deeper\n. Looks like it's dependant on the current month:\n``` ruby\nChronic.parse(\"last winter\", guess: false, now: Time.local(2013, 4))\n=> 2012-12-22 00:00:00 +0000..2013-03-19 00:00:00 +0000\nChronic.parse(\"last winter\", guess: false, now: Time.local(2013, 3))\n=> 2012-12-22 00:00:00 +0000..2012-03-19 00:00:00 +0000\n```\n. Looks like this patch fixes the issue but that feels a little hack-ish and it's avoiding the underlying reason this doesn't work as it should.\n. What are your current time zone settings? Maybe I can reproduce the failures\nOn 22 Jan 2013, at 15:55, Michel Boaventura notifications@github.com\nwrote:\nOn my gentoo machine running on master with both ruby19 and jruby I got two\nfailures:\n1) Failure:\ntest_guess(TestChronic)\nExpected: 2006-11-16 00:00:00 -0200\n  Actual: 2006-11-16 00:30:00 -0200\n2) Failure:\ntest_parse_guess_r(TestParsing)\nExpected: 2006-11-16 00:00:00 -0200\n  Actual: 2006-11-16 00:30:00 -0200\nBut if I run the tests with \"TZ=UTC\", all the tests passes. Am I doing\nsomething wrong?\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/mojombo/chronic/issues/168.\n. date +%Z should do the trick\n. I can't reproduce this in any way whatsoever, can you reproduce on any other machines? I can't really see what the issue would be.\n. Gonna go ahead and close this until we can reproduce it\n. It's not used directly. Your system should handle setting the TZ variable\nwe just override it for testing in multiple time zones. You can check the\nbehaviour like so:\n$ date\nTue 29 Jan 2013 12:08:00 GMT\n$ TZ=est date\nTue 29 Jan 2013 07:08:00 EST\nhttp://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html\nOn 29 Jan 2013, at 01:26, Michel Boaventura notifications@github.com\nwrote:\nI'm trying to find out why this happens on my machines. I've tried it on\nthree gentoo pcs and all of them have this issue. In which part of the code\nthe TZ variable is used?\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/mojombo/chronic/issues/168#issuecomment-12815707.\n. Sure, I'm happy to do that. I've been meaning to hook up travis for some time now anyway.\n@mojombo can you enable the service hook, please?\n. Sorry for the lack of response on this Ben, I wanted to take time to consume it as it's quite a complex set of features. Great to see you've created something from it though!\n. This is fine but I'd rather avoid having to declare the ivars in initializers. Whilst I also prefer everything to run without warnings I think the undeclared ivar warning is nonsense and can compromise readability and simplicity. I'm happy to merge if you could revert that change. \nThanks!\n. Looks good, thanks!\n. @michelboaventura I can't administrate the hooks on Chronic, waiting for @mojombo on this.\n. Nice thanks! :metal: \n. I can't reproduce the original issue\nirb(main):001:0> Chronic.parse(\"2013-09-30T01:00:00\")\n=> 2013-09-30 01:00:00 +0100\nirb(main):002:0> Chronic.parse(\"2013-09-30T01:00:00-05:00\")\n=> 2013-09-30 07:00:00 +0100\nirb(main):003:0> Chronic.parse(Time.now.in_time_zone(\"America/Los_Angeles\").iso8601)\n=> 2013-05-11 12:37:27 +0100\nThis is with Chronic version 0.9.0. Please re-open with a reproduction.\n. @andrijaperovic Yes, this bug has been fixed. If you can reproduce it on the latest version of Chronic please re-open this issue\n. 4237b1ca5f6988064d5029d4c92b6fc1b3304917\n. That's odd, I can't reproduce that test failure locally or on my VPS (with a range of time zones).\n. Yeah, April23 is considered a spelling error, Chronic doesn't (not probably ever will) handle that. Fixing things like that is a prerequisite for using Chronic, if Chronic started trying to fix spelling errors there would be no end.\n. Yeah I was suggesting that as a change, it's not yet possible. I'll mark this as a feature.\n. It's correct that this is not thread-safe. There is currently no workaround until we build something into Chronic (see the other issues). This shouldn't be so hard now that parse creates a new Chronic::Parser instance. We an feed the time_class option into the Parser class and let it default back to Chronic.time_class. Probably once this option is added Chronic.time_class should be removed to avoid questioning thread safety (it'll never be thread-safe).\nTo clarify and reiterate what @dnagir has said; that SO answer is incorrect. I've commented on it.\n. @dnagir Honestly, I don't. I haven't managed to find time for Chronic for quite a while. As frustrating as it is, I do plan to find some time to work on it (though I am working on a replacement, too). Work is very busy. Please feel free to submit a PR for it. @davispuh is currently managing a lot of the code also so one of us can review. Happy to expand collaborators. Still hoping to move the repo or sort something out so I don't have to bother @mojombo every time.\n. :metal: \n. Thanks for taking a shot at this. Things like this mostly fall into the 'normalization' category. Let's break it down:\n1. a.m. am a.m etc should all behave the same (this tells us we need to 'normalize' the strings\n2. Open up lib/parser.rb in the pre_normalize method. \n3. Modify the last line to p text\n4. Try your example, in this case tomorrow at 4a.m. returns next day at 4 am:m:\n5. Uh oh, that's not right!\n6. Use p to go up the substitute chain until we see where the bad change was introduced. Turns out a.m. is pretty quickly turned into a:m: which we should change!\n7. Enable normalize powers! text.gsub!(/([ap]):m:?/, '\\1m')\n8. Write a test.\n9. Run all existing tests.\n10. :metal:\n. You want Time.zone_offset here's an example from UTC+1 (my timezone) to PST:\nirb(main):002:0> Chronic.parse(\"7pm\") - Time.zone_offset(\"PST\")\n=> 2013-07-31 03:00:00 +0100\n. I don't like the use of instance_variable_defined? everywhere. I'd much rather set these ivars to nil than check this every time. I think the tradeoff for no warnings just isn't worth the mess in the code. \nI'm also happy to use minitest ~> 5.0\n. > I decided against setting them to nil because I was lazy reading the whole inheritance chain. Will try to cover this. Totally agree. :)\nI would be too, it's fairly messy. I don't really mind still having the ivar warnings, but if it's something you'd like to cover, go for it!\n\nI'm a bit pondering about the s.add_development_dependency 'minitest', '~> 5.0' right now. The project does not have a Gemfile, that means the ~> 5.0 declaration only affects a gem install chronic --dev, right? I don't want to install the gem when I just want to work on a fork.\n\nMaybe we should add a Gemfile and start using bundler?\n\nSo how should I assure that the version is actually ~> 5.0?\n\nYou would have to use gem 'minitest', '~> 5.0' before requiring minitest/autorun\n. @tbuehlmann Good stuff. Thanks for the work. \n. >  Is there a better way to set the time zone for each user while still accounting for thread safety?\nCurrently there is not.\nSee #182 and #158 \n. :metal:\n. I'm not really sure how this should be fixed to support both features. Will explore later in the week if I have time. Thanks for reporting.\n. There's no reason other than it hasn't been done. I'll consider this change, thanks!\n. I like this. Thanks for the work, it looks much nicer. One thing, though.. could you change the camelCase variable names to use snake_case? Camel case variables in Ruby are rare and I think they're messy (especially as everything else is snake case) I also think this exception should raise an ArgumentError and should have a test.\nApart from that, this looks great.\n. Could you rebase and squash your commits? I'll merge this in this afternoon. Thanks for the work!\nOn Tue, Jul 30, 2013 at 3:38 PM, D\u0101vis notifications@github.com wrote:\n\nhmm, seems there's merge conflict because @current_time from merged PR (ruby-warnings)\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/pull/195#issuecomment-21794878\n. :bomb: thanks!\n. Nice work, thanks! :bomb: \n. I also don't think this is beneficial enough to be a feature. Thanks for the work though, @ismaelga \n. No, I'm happy to leave it for now, we can consider changing it any time before a full 1.0 is released (some day). I'll merge this later. Thanks for the work!\n. This is really great. Thanks a lot for the work! I pinged @mojombo on Twitter about giving you commit bit (or moving the repo to my account, which might make more sense in the long run), hopefully we can get that actioned at some point.\n. Nice, thanks! :metal:\n. @davispuh Thanks, could you update the changelog with a summary of your changes?\n. Looks like this was broken in dbf2e0cffc2c41c3933d9a500912476785583430. @davispuh is there any reason we can't use time_class.local here? That's used everywhere else. \n\nThanks for reporting, Scott.\n. I'm not sure I see the entire benefit to that. Anyway we should revert to using local so Chronic doesn't break for anyone using ActiveSupport::TimeZone. I'll release a 0.10.1 bugfix\n. The is_a? and partners won't work, it has nothing to do with minitest, I'm not sure how they were working before. time_class is not an instance of Time etc. They're all instances of Class so that would return false for them all anyway, it always needed an explicit test against the class name. \nThanks for the patch\n. Sorry about that! Yeah I'm not a huge fan of dropping 1.8 support so easily (and didn't think we had, until now!). That said, 1.8 is EOL and I always intended to drop support for it eventually. I'll alter the readme to provide better feedback about these incompatible changes. I think it means we can finally clean up a lot of other Chronic code (now we've fixed to >=1.9). I'll also alter our gemspec. \nIn conclusion, if we're sticking to dropping 1.8 support in version 0.10 then we won't ever support 1.8 again. If we choose to revert these changes, we can wait until 0.11 or a solid 1.0. I would rather not have Ruby version constraints that would introduce explicit workarounds in the code. \n. I've released 0.10.2 with 1.8.7 support. This support is due to be dropped in 0.11 but not until then.\n@samg Please fix at ['> 0.10.1', '~> 0.10.2', '< 0.11'] this should give you any new bug fixes but continue 1.8.7 support.\n. Fwiw, Chronic isn't really tailored for parsing the output of Time.now.to_s, that's really just a novelty feature I added and it's probably much slower than doing Time.parse (which Chronic does under the hood after it's processed it). So if you know it's a timestamp from Time#to_s you should feed it to Time.parse\n. I don't think this is necessary. I'd like to add the ability to use debug/time_class configuration values per Parser instance. That would solve the problem of hitting race conditions. Then Chronic.debug and Chronic.time_class can be used as 'global configuration', that is, default values which are overridden by a call to .parse:\nruby\nChronic.parse('next tuesday at 3pm', time_class: Time.zone)\nI'm not too worried about the debug flag, though. If someone has enabled debugging they should expect to see it everywhere.\n. Again I don't think this is necessary. If we are going to go the route of making stuff thread stuff like this, then it should be kept simple:\n``` ruby\nclass Chronic\n  def self.time_class\n    Thread.current[:chronic_time_class] || ::Time\n  end\ndef self.time_class=(klass)\n    Thread.current[:chronic_time_class] = klass\n  end\nend\n```\nThere's no need for the prefixed underscores, or the capitalized class name, it's adding unnecessary complexity to what's essentially a simple subject.\nHowever, I do still believe that we should allow setting the time class per Parser instance, and that having this ability means the global configuration does not have to be thread safe. If there's a per parser instance configuration value for time classes, there's absolutely no reason to mutate the global state, and it could be misleading to do so (for example having a Rails initializer with time_class set when someone could change it per thread)\n. This looks good. Could you rename weeks_start to week_start (singular) and squash these commits? I think week_start makes a little more sense, though I'm open to suggestions/objection to that. Thanks for all the work!\n. :sparkles: :shipit: :sparkles: \n. A license is present.\n. We should start using bundler and fix to a specific version of minitest, this would help out development somewhat. I'd also like to start using travis but it's a little difficult to manage when I don't administrate this repository. I've spoken to @mojombo and he's considering the ramifications of moving it. \n. We have this https://github.com/mojombo/chronic/pull/113 which I'd love to have time to merge into the latest version of Chronic, but I think it needs some work\n. Yeah today is not intended to represent a time in any form. I would say any time during the day would essentially be valid. I'm not adverse to tweaking the time Chronic returns if someone wants that to change, but I think that's a different issue.\n. @fakeleft The problem is that they're not synonymous. \"today\" in regards to time is totally ambiguous. Chronic doesn't return Date objects. If it did, it would no doubt return one for \"today\" because there's no concept of time involved. Chronic.parse(\"today\").to_date == Date.today is what counts. \nI'm more than happy to fix ambiguous times to midday, but it's all relative. If you're parsing \"today\" then you probably don't care about time, and if you do, you need to be more specific.\n. Is there a reason for this? I'm hesitant to merge a patch like this because I won't (and do not expect others) to keep the consistency of using single quotes everywhere. \n. > Basically it is recommended to use \"\" if there a ruby eval and ' when there is no ruby eval.\nI'm not really sure it is. I think it's just entirely personal preference. Anyway, please don't take my questioning as non-appreciation for taking the time to do this. I'm going to merge it, though I will note that I don't expect anyone who's thinking of submitting a patch to Chronic to have to worry about which quotes they use.\nThanks, @yatish27 \n. I like this, but I agree that it could be a confusing thing to add to Chronic. I also agree something like this should always return seconds over minutes. I'm happy to have a parse_duration or parse_span method that does something like this, though. \n. Please squash these changes into a single commit and remove the Gemfile commit as that change is not related to this pull request. \nAlso fwiw the text is downcased so using [Xx] makes little sense, also not sure what the following + is for as that would match xxxxxxxxxmas as well. I think (christ|x)mas is fine to be honest.\n. Awesome, I've been meaning to clean this up for a while. Could you add this logic to grabber, separator, sign and time zone please, happy to merge. Great work, thanks!\n. Great, thanks a lot Ben!\n. Thanks. I'm not sure we're really benefiting from the use of inheritance here though. Maybe definitions should be defined on the instance of the class, and options should be used to instantiate the class. That would remove all of the << self stuff and the rarely used argument to the definitions method\n. That's exactly what I meant, thanks Ben. I don't think there's really any benefit to having definitions as an accessor as I think it'll only be used via subclasses, and it can never not be set. Plus with Ruby's rules for immutability anyone has full control over the definitions Array anyway. \n. Actually I was mistaking options for definitions. The way you've done it in your commits is exactly what I was thinking, the extra snippet makes less sense because you're defining the definitions method twice\n. Sorry Ben I've been super busy. I'll check in on this this evening or tomorrow at the latest.\n. I don't understand either of these messages\u2014\nSent from Mailbox for iPhone\nOn Fri, Jan 24, 2014 at 6:31 PM, alexherbo2 notifications@github.com\nwrote:\n\nYes\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/240#issuecomment-33248278\n. Thanks, maybe we should add 2.1 as well now it's stable. Either way I'm still waiting on Tom to add the hook for travis\n. Thanks, I don't have access to it. @mojombo could you tweak it to http://leejarvis.github.io/chronic/ or switch the project over please :+1: :bomb: :sparkles: \n. I'm not too bothered. The reason it pointed to something custom was because the documentation style has been customized. However I'm not interested in maintaining that so happy to it to be pointed there or to be removed. Again, this is pending input/action from @mojombo \n. > Why would I be getting 12:00:00 UTC instead of 00:00:00?\n\nOut of curiosity, why did you expect 00:00:00?\n. Right, I understand it would be easier for things like that, I was just interested in why you expected that behaviour. Chronic aims to parse human read/writable time strings. This means there's really no decent way to determine the time we should use unless it is specified in the input string (this is basically what the guess option does). Some might say the time should match the time now (that is, tomorrow should present not the first minute of tomorrow's date, but instead tomorrow at 10:35.\nIt's also worth mentioning there are time zone considerations. If we set the time to 00:00:00 GMT it might be 3 hours ahead of a different timezone. If we use the local timezone then everyone gets a different result.\n. > Do you guys accept documentation patches?\nCertainly! Please feel free to add or modify documentation\n. :+1: \n. Thanks @davispuh I'll need a bit more time to review this which I'll hopefully find later this week. Some quick initial thoughts: We use TomDoc rather than YARD. I don't like the extra width argument, when you have to start specifying nil in places then I think there's a problem.\nThanks for this!\n. :+1: \n. :+1: \n. :sparkles: :shipit: :sparkles: \n. Looks good thanks!\n. @davispuh sure that sounds fine. I think this PR is fine to merge to master also, so go ahead\n. I think this looks good so far. There are a few methods in date_object and time_object and some other places that are a bit unwieldy so I'd be keen to clean those up but it looks like you've spent a lot of time on this. Great work!\n. I've be wanting to rewrite Chronic from the ground up, and I've actually been working on it for a couple of years. Here's an old Gist of how it looks. However, this code still isn't ready for any kind of release, even if it improves in Chronic a lot. @davispuh has done great work on the Chronic rewrite which will hopefully cover most concerns anyway. \nPorting something like Chronic to JavaScript is a mammoth task, so I take my hat of to you for even considering it. I think momentjs covers most use-cases, although I don't know of anything completely similar to Chronic in any other languages. It's a unique beast.\n. Are you guys still having these issues? \n```\n\n\nTime.zone = \"Mountain Time (US & Canada)\"\nChronic.time_class = Time.zone\nChronic.parse('2009-11-01 12:00:00') == Time.zone.parse('2009-11-01 12:00:00')\n=> true\n```\n\n\nThis may have been fixed in 0.3.0. Please let me know if you're still having this issue\n. Closed by 2d420c726204e499d0d1238d2a8aa14838a6544d\n. Bugs related to timezone offsets and Daylight savings were fixed and released in 0.3.0. I can't reproduce this, and haven't been able to with a previous checkout. So I'll assume the 0.3.0 changes fixed this. If you can reproduce please reopen this issue with steps. Thanks!\n. In fact, these changes will help. I'll work on merging this patch and adding some tests\n. Although Time.construct does force this behaviour, this isn't what the problem is. It's exactly what the Ruby time class does.\n```\n\n\nTime.local(2011, 2, 29)\n=> 2011-03-01 00:00:00 +0000\n```\n\n\nI've marked this as a bug, Chronic should of course do the right thing and return February. I'll work on a fix for this\n. closed by efba57737376fb2516474bc0b0f6676252ced62b\n. Fixed by @AaronH closed by 3bbfee96e98764dbb69c0c2cd1a438ac7a141e92\n. I think this would be a great feature, but I'm not sure how often it'll be used or if it's beyond the primary scope of Chronic. A chronic-i18n might be a good solution. Nevertheless I've marked this issue as a feature and I'll leave it open for further discussion.\n. A note on this, it looks like it's already been started https://github.com/nofxx/chronic18n I haven't played with it yet, though\n. After more thought on this, I'm going to close it. It's not something I think we should look into building directly into Chronic. It would be pretty simple to build a 18n wrapper much like nofxx has, doing text substitutions before sending text to Chronic.parse. Thanks!\n. I can't reproduce this on either 1.8.7 or 1.9.2 with Chronic 0.3.0. Please reopen with more information if you can reproduce still\n. I've cherry-picked your relevant changes into master. Thank you\n. What version of Chronic were you running against? Can you reproduce this? Your tests are running green\n. There's been a few fixes to DSL related code before and after the 0.3.0 release. I can't reproduce this and your tests run green so I'll assume it's been fixed. Please re-open if you have a repro. Thanks!\n. I can't reproduce this\n```\n\n\nRUBY_VERSION\n=> \"1.9.2\"\nChronic.parse('last week Monday').strftime(\"%w\")\n=> \"1\"\n```\n\n\n```\n\n\nRUBY_VERSION\n=> \"1.8.7\"\nChronic.parse('last week Monday').strftime(\"%w\")\n=> \"1\"\n```\n\n\nPlease re-open if you can reproduce this with more information\n. I can't reproduce this and we have tests in place which check against parsing tomorrow after noon, please reopen if you have a repro\n. I do plan on implementing this, but I don't want to set a milestone just yet. I'm currently in the process of immigration so I don't have a lot of time on my hands. If anyone wants to take a shot at this feature, you're welcome to. A QuarterRepeater should be fairly trivial to implement, my main focus is on bugs until I have more time, though. It is coming!\n. @JeskTop No, that's why it's still marked as open.\n. Notice these outputs:\n```\n1.8.7\n\nTime        Sun Aug 01 12:00:00 +0100 2010\nTime(AR)    Fri, 01 Aug 0010 12:00:00 UTC +00:00\n1.9.2\nTime        0010-08-01 12:00:00 +0100\nTime(AR)    Sun, 01 Aug 0010 12:00:00 UTC +00:00\n```\nAs you can see, on Ruby 1.9.2, all went as expected. This is because 1.8 handles years differently to 1.9. ActiveRecord is obviously doing something to ensure 1.8 works like 1.9 does.\nI'm going to close this as a duplicate to #40\n. There's currently no way of interpreting last as the end of a month. Chronic doesn't contain a month day lookup table except for when constructing Time objects, which is too low level for this. I've labeled this as a feature though, I think it's a great idea.\n. @jeremywadsack Yeah that was my intention for this. Just haven't found time to get around to it yet. \n. This has been fixed in the latest release of Chronic\n. The TypeError has been fixed. This is a planned feature, though. (Supporting the conversion of ordinal strings). At the moment the string third tuesday this december will ignore the third and instead be parsed as tuesday this september. I'll leave this issue open and mark it as a feature\n. I've taken a quick shot at this, and although it's extremely easy to implement, there's the issue of parsing second as an ordinal when Chronic relies on it being a literal second. With this patch We can work with the following output:\n```\n\n\nChronic::Numerizer.numerize 'thirty first month on day one'\n=> \"31st month on day 1\"\nChronic::Numerizer.numerize 'twenty second day month twelve'\n=> \"22nd day month 12\"\n```\n\n\nIf anyone has any thoughts for dealing with seconds, feel free to discuss it here\n. So I guess parsing 'second' can be a special case, and unless it's suffixed with 'day/month/hour/minute/second' then people probably mean a literal second. I've updated the patch to allow for this. Thoughts? @mojombo?\n. I can't reproduce this on the latest version of Chronic. Closing for now, please reopen if you can reproduce it\n. Are you still having these issues? I can't reproduce on 1.8.7 on Linux or OS X. If you're still having this issue please post your full Ruby version and what platform you're testing against\n. closed by 32fc9024e6e8bdc0b9965a234b8f46c84d973d06\n. Please open a specific feature request if you want to support parsing 'current month first day', but do remember that Chronic is for parsing natural strings, current month first day is certainly not that. 1st day of this month works fine.\n. @fare5 No, this feature is not yet supported in Chronic.\n. Summoning @mojombo on this. Ruby 1.9.2 will handle any double digit years as prefixed with 00. Ruby 1.8.7 however works a little differently. See this gist where [0-3]3 is handled as 2000, [4-6]3 is handled as 0000, and [7-9]3 is handled as 1900. I can patch Chronic::Scalar.scan_for_years to ensure one version behaves the same as the other. Thoughts?\nEDIT On a side note, ActiveSupport is using DateTime.civil_from_format to ensure 1.8 works like 1.9 (where 79 would return 0079)\n. @mojombo Yeah, we could add a configuration option for this. Any thoughts on a name for it? Also, there's already :endian_precedence which solves mm/dd/yyyy vs dd/mm/yyyy if that's what you meant. Overwritten like so:\nruby\nChronic.parse('03/04/2011').strftime(\"%d/%m\") #=> \"04/03\"\nChronic.parse('03/04/2011', :endian_precedence => [:little, :middle]).strftime(\"%d/%m\") #=> \"03/04\"\nThough this could be simplified.\n. Yeah we don't need to allow the user to pass in nil so feel free to simplify this. I would possibly set :now to nil in the DEFAULT_OPTIONS hash for clarity, and perhaps use @now = options.fetch(:now, Chronic.time_class.now)\nI'm also not sure the test case helps much. If a platform has microsecond accuracy then this test will pass regardless (it would have passed before this patch). That's of course not taking into consideration that this test will fail if not compared against microseconds.\n. Looks great. I'll merge this later tonight and push out a bugfix 0.4.1 version. Thanks!\n. This was already merged in #35. @precipice also commented to say you had the fix, but I believe your pull request was closed at the time.\n. What version of Chronic are you testing against?\n```\n\n\nChronic::VERSION\n=> \"0.4.3\"\nChronic.parse('3 months ago', :now => Time.local(2011, 5, 30))\n=> 2011-02-28 00:00:00 +0000\n```\n. I'm going to close this, please re-open if you have a working repro against the latest stable version of Chronic. Thanks!\n. Thanks for reporting this, it's fixed on HEAD. I'll push out a bugfix version later this evening\n. This is specific to 32-bit systems and 1.8s inability to deal with it (which is fixed in 1.9).\n\n\nI remember seeing this a long time ago. I haven't worked on a system which doesn't support this for a long time. I believe there probably should be tests for outside of this range for compatible systems, but I'll merge this and look into that a little more later. Thanks\nSee also Year 2038 problem and this question on Stack Overflow.\n. This is actually because of how the Ruby Time class deals with day overflows. An example:\n```\n\n\nTime.local(2011, 2, 31)\n=> 2011-03-03 00:00:00 +0000\nChronic.parse('31 feb 2011') == Time.local(2011, 2, 31, 12)\n=> true\n```\n\n\nThe Time class raises an ArgumentError when a day is past 31 (of course it's not possible to have a day later than 31 in any month), but if it's later than the last day of said month, the month will be incremented and days will be added from the start of this month. Chronic has always relied on this functionality be it a feature or a hinderance. \nThe internals of Chronic don't actually care what 31 is (in certain sense). It's relative information. In this case 31 represents 31 days from the beginning of February, which of course, if you count it, is 03/03/2011 (unless it's a leap year).\nI'll have a think about this and leave this issue open for discussion, because I do agree with you. Libraries shouldn't rely on this functionality but it's how Chronic has always done it, so there's always that one exception to the rule.\n. Summoning @mojombo on this discussion. We can go one of 3 ways:\n- Return nil when an out of month day is supplied\n- Raise when an out of month day is supplied\n- Add a :strict option, disabled by default, which will raise when an out of month day is supplied\n. I'm not sure I follow. Can you describe exactly what you're trying to do, perhaps with some code examples? Thanks.\n. I would recommend altering your string before sending it to Chronic. You can easily achieve what you're hoping for by appending a at x where x is the hour/minute/second you want to default to. Here's a little example with a wrapper around Chronic.parse:\n``` ruby\ndef parse(timestr, hms)\n  timestr << \" at #{hms}\"\n  Chronic.parse timestr\nend\np parse('today', '00:00')       #=> 2011-07-11 00:00:00 +0100\np parse('tomorrow', '13:37:15') #=> 2011-07-12 13:37:15 +0100\n```\nOf course your situation might mean spending a little more time normalizing the string before sending it to Chronic, but it should do what you're looking to do. The idea of having a default_time option sort of defeats the purpose of Chronics internals. Remember though that Chronic.parse returns a Time object. So you can also alter the hour/minute/second once you're done.\n. Hah, I had most of a reply written out with what you've found  before you commented again :)\nI'm not so keen on the first idea, because essentially doing Chronic.parse('tomorrow', :guess => :beginning) is exactly the same as doing Chronic.parse('tomorrow', :guess => false).begin. Is there any reason you want to avoid using that? The idea of using a lambda might be neat, though\n. Hi Chris, thanks for pointing this out. This should have been fixed by 1a5f041a56a3dc5d9e4a9046b3542c986ffd3fc3 -- I'm yet to release Chronic version 0.6, though. When I push out that gem the latest stable version should work as expected. If you want to be sure, please carry out these steps:\n1) git clone git://github.com/mojombo/chronic\n2) cd chronic && rake console\n3) Chronic.parse(\"2011-07-20 10:00:00 +0100\")\nIf you still have issues please let me know\n. I plan on pushing out before the end of the week. If you need it badly I can push for a Tomorrow/Wednesday release at the earliest\n. Thanks, I'll add tests and bump bugfix version in an hour or two\n. I like this idea, although I don't see many use cases myself. I'm not sure on a Hash with boolean values, though. I think perhaps returning an Array of elements in order would make more sense. The other issue is what constitues a day for example. Maybe using the same naming scheme as Chronic does with repeaters, for example:\n\"2nd of November 1986 at 3:30pm\"\n[ :ordinal_day, :month_name, :year, :hour, :minute, :day_portion ]\nOr something along those lines. I'll mark this as a feature nonetheless\n. Any more updates to this? I'm willing to leave it open as a feature if it's something people want, but I can't find a use case enough to work on this\n. Cool. I'm gonna shut this issue as it's not something I can actively work on myself. If you have any questions feel free to drop me an email or open a pull request with any advancements. Thanks!\n. Assuming all current tests pass, could you possibly add some more tests for these features? That way I can just merge, otherwise I'll look at this some time in the next couple of days and add tests myself.\nThanks a lot!\n. Interesting. Could you post your ruby version and current timezone, please. Thanks for adding those tests!\n. Strange, I can't reproduce this failure, and everyone I've asked can't reproduce it. I'll have a closer look at it tomorrow and merge this pull\n. Hah, nice. Yeah I have a repro on Ubuntu 10.10 on a VPS. I'll look more into this tomorrow. Thanks!\n. Thanks darix, I'm going to look into rebuilding the repeaters using the Date class instead so handling zone offsets should be a little easier.\n. This is intended behaviour, though I agree it's not most common response. Chronic has handlers in place for matching a month/year but not a day/month or month/day, meaning anyone relying on this behaviour will have their libraries break, which of course I'd like to avoid, at least in a patchfix update. Check out the handle_sd_sm branch which will handle '8/15' as the 15th day of the 8th month, or with '8/12', :endian_precedence => :little as the 8th day of the 12th month. I'll build some tests and think when's best to merge this, the handling of month/year can be a fallback when the second operand looks like a year\n. Merged bd9ff2d8336577f9e04ef7da25fe7bccfe9d5680 into master\n. I've managed to get 10 minutes to look at this. This problem is actually a little more widespread than first though. First of all, Chronic ignores context in day portions. Now you can probably see the problem with a patch like this. Parsing, for example, 24th of January at 7pm with a past context will return the 23rd of January. Chronic isn't (yet) clever enough to know when it's parsing a time/day portion and nothing else. Chronic loops through Repeaters and re-uses code where it can, meaning it's clever enough to know that a month in the past means 1 month ago, or a year in the past means 1 year ago, but not that a 6pm in the past means yesterday at 6pm (unless it's later than 6pm today).\nI'll mark this as a bug and try to find some time in the coming days to take a closer look at it. Thanks for reporting\n. OK so I think I need more user input into this issue. I mean, ignoring context for day portions kinda makes sense, but not in all situations. The trouble is, Chronic defaults to a future context when none is supplied, rather than :none, for example. But ignores this for day portions without more textual context. Meaning parsing 2pm at 3pm will return one hour previous, returning tomorrows 2pm would simply make no sense. But I also understand that at 11pm, 7am is more likely to mean tomorrow. There's a couple things we can do about this, either default to a non-specific context, and have the user supply a context when dealing with day portions, or leave it how it is, and assume the user will provide more information (for example 7am tomorrow, 10pm yesterday etc). Or alternatively have a cut off time, but I'm against that because it'll get extremely confusing for users.\n. @dlupu Unless I'm missing something, I can't make much sense of your issue. \nChronic.parse('27/7/2011 00:43:57', :context => :past) returns 2011-07-26 00:43:57 +0200\nSurely, with a past content, this is exactly what you're expecting?\n. Sorry I'm confused, looking at your examples you say that the first one returns 2011-07-27 00:43:57 +0200 and the last one returns 2011-07-26 00:43:57 +0200, these are both different. Am I missing something?\n. Oh wait, sorry I read your message wrong. You expect them to be the same? You didn't tell me what Time.now was to go by :+1:\n. Right, which was what? :P\n. No, you're correct. Context should not affect the date. It doesn't matter if we're in 1959 or 2059, 2011 is still the same year, that with any other attributes you give to Chronic, the date returned is supposed to be contextual, context is useless with an absolute date; or should be, at least.\nTrying to find some time over the holidays to hack on Chronic but I'm finding it hard. I will get around to fixing this!\n. Chronic doesn't know what Eastern Daylight Time is, they're merely words, and that's how it's always been. I can't reproduce a positive result with any previous version of Chronic. If you're able to reproduce the passing example I can look into it a little closer. You're sure you're not using ActiveSupport magic for timezones? As stated in the README, for full timezone support, you'll want to use the TimeZone ActiveSupport provides. \nChronic will however parse EDT for Eastern Daylight Time, but there aren't currently any handlers in place to handle your provided string. I'll keep this issue open and look into that\n. @tomekr I don't see how your issue is related to this one. I've fixed your issue in 1be79748d0899b2586a68b4cb009eb9673dde3d2 and pushed 1.6.3\n. I'll have time to look at this later in the week, but initial feedback; you can drop the comment in e0d7267, judging by the regexps you've added it looks a little too taylor made for this specific use case, and might be better implemented as an independent handler, but I'll see when I have time to look a little closer. Would you mind squashing these commits into one or two (impl/tests), it's a little easier to review that way\nThanks for the contribution!\n. It's no problem, I appreciate the effort! I might have time to squash\nthem myself tomorrow and look a little closer at this, time\npermitting.\nThanks again, keep up the Ruby!\nOn 17 Aug 2011, at 23:40, pauldambra\nreply@reply.github.com\nwrote:\n\nHa, well I've managed to add 2 commits while trying to squash (does it show I'm new to Git? :-)) I'll get some advice tomorrow.\nThanks for the feedback... I'll look at the handlers but that's much more Ruby to get my head around!\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/pull/63#issuecomment-1831538\n. I've merged this into a feature branch and rebased the commits. I'm still not entirely sure if I want to merge this into core or not, but I'll leave the branch there for now to think about and close this pull request. Thanks again!\n. Actually this is intended behaviour. Thinking logically, if someone said to me 2pm -- even if it was 7pm, I wouldn't think of 2pm tomorrow, I'd think of today. A similar one is 10am when it's currently 10pm on the same day, I think it's more likely to be talking about 10am today, not tomorrow.\n\nAnyone want to add thoughts to this?\n. Merging this issue with #60 as the same questions lie with both of them, and I think it needs more discussion, thanks!\n. This is a duplicate of #15. It's not as easy as simply exporting regular expressions. Chronic is built on parsing English strings, and I believe supporting I18n out of the box is far beyond the scope of Chronic. Although this repository hasn't had much love for a while, it's probably a good base to start implementing I18n on top of Chronic - https://github.com/nofxx/chronic18n. \nI'm -1 on supporting I18n out of the box, but I'll leave this issue open for a couple of days in case @mojombo or anyone else would like to chime in.\n. Chronic doesn't understand <year> <month> <ordinal> which is why it's displaying the next occurrence of 22nd May, it'll be the same with any other date. I'll mark this as a feature\n. Thanks, this is quite a major bug and it's a shame it hasn't been covered by tests already, as it's not such a simple fix. Chronic currently checks only if todays month index is less than or equal to the index of the month we're looking for. Meaning it doesn't take days into consideration at all. Parsing '1st Jan' with a future context will always return the previous 1st of January even when the current date is the 28th of January. The problem code is here, I'll have a think about this one, but with some of the latest issues it's telling me the way Chronic sends information to repeaters needs to change\n. Closing this as a duplicate of #60 -- hoping to fix this soon but it involves quite an overhaul. Thanks for reporting\n. master is fine, I haven't outlined it in the README so I can manually manage it. Looks good, thanks. Assuming all other tests pass with this I'll merge it this evening and push out the other bug fixes for a 1.6.4. Thanks again\n. It looks like there isn't a handler in place for parsing this string. I'll look into this tomorrow. Thanks for reporting\n. Odd, I can't reproduce this.\n```\n\n\nTime.now\n=> 2011-10-02 23:55:20 +0100\nChronic.parse 'today'\n=> 2011-10-02 23:30:00 +0100\nChronic.parse 'tomorrow'\n=> 2011-10-03 12:00:00 +0100\nChronic.parse 'yesterday'\n=> 2011-10-01 12:00:00 +0100\n```\n\n\nI'm also on Lion, using 1.9.2 with Chronic 0.6.4\n. Can you try this on another machine to rule it out? There's not much I can do to help without a reproduction I'm afraid \n. Looks perfect. No feedback on your code, it looks good. Pull requests like this (small, with readable changes and full tests) will be merged with no hesitance. Thanks for contributing!\n. The first one has never worked, the second one works fine for me. What version of Chronic are you using?\n```\n\n\nChronic::VERSION\n=> \"0.6.4\"\nChronic.parse '29th of November'\n=> 2011-11-29 12:00:00 -0800\n```\n. @zhon the latter shouldn't have a handler anyway. When you say 'on the current branch' do you mean it works on HEAD but not the latest version of Chronic?\n. Weird, that shouldn't be the case as I tested it on both. I'll be pushing a new version later this week anyway so if this is fixed to you on HEAD you'll see these changes on the next stable release. Thanks for reporting\n. zhon, Chronic ignores any word which doesn't interest its tokenizer. It builds a pattern and executes a method which is mapped to said pattern. Meaning what you're looking for is probably perfectly doable. For example:\n\n\n```\n\n\nChronic.parse 'the 29th of november, 2011, some stuff here etc at 10:30am'\n=> 2011-11-29 10:30:00 -0800\n```\n\n\nBut, altering this string by adding a single word that Chronics tokenizer is interested in, could break if there's no associated handler for this pattern:\n```\n\n\nChronic.parse 'Tuesday the 29th of november, 2011, some stuff here etc at 10:30am'\n=> nil\n```\n\n\nIt's all about having a handler available to match specific patterns. If you have a certain pattern you'd like to match, please feel free to open an issue with the debug information returned by running these commands:\n```\n\n\nChronic.debug = true\nChronic.parse(\"my string here\")\ndebug output here\n```\n\n\nExample:\nChronic.parse 'this string contains something chronic is interested in: 10pm'\n[ this(grabber-this) , interested(timezone) , in:(pointer-future) , 10(repeater-time-36000?) , pm(repeater-dayportion-pm) ]\nSo this tells us building a Handler which responds to [:grabber, :timezone, :pointer, :repeater_time, :repeater_day_portion] means we can parse these values and return some quality information.\nHope that helped\n. You've given a bit of an overload of information here. The '5th Tuesday' of any month is always going to be a future month. Sorry I'm working and have little time to browse over bugs at the moment, anything you can do to point directly to the issue you think is a bug specifically would really help me\n. ```\n\n\nputs %w(January February March April May June July August September October November December).map { |m| [m, Chronic.parse(\"5th tuesday in #{m}\")].join(' => ') }.join(\"\\n\")\nJanuary => 2012-01-31 12:00:00 -0800\nFebruary => \nMarch => \nApril => 2012-05-01 12:00:00 -0700\nMay => 2012-05-29 12:00:00 -0700\nJune => \nJuly => 2012-07-31 12:00:00 -0700\nAugust => \nSeptember => \nOctober => 2011-11-01 12:00:00 -0700\nNovember => 2011-11-29 12:00:00 -0800\nDecember => \n```\n\n\nJust saw your update, yes you're right, I wasn't thinking straight. Interesting results. I'll look into this a little more at the end of the week, thanks for reporting :+1:\n. Please test against latest head and let me know if this is all fixed for you, the test cases pass. Thanks for reporting!\n. This appears to be fixed in the latest revision of Chronic. Please re-open if you can reproduce these errors.\n. Thanks a lot for this, love me some tests <3\n. I planned to push later this weekend, but as far as I'm concerned this is a bugfix, and if you need it, I'll push a new gem now\n. :+1: if there's no gem by the weekend, please shout at me (super busy at the moment). Thanks again!\n. :+1: 58dc69bed9470711889222f968706984c0a6d193\n. Interestingly enough, 14:00pm works correctly. Will dig deeper\n. Actually, it looks like this has been fixed since.\n=> 2013-01-28 16:21:55 +0000\n1.9.3 >> Chronic.parse '5pm'\n=> 2013-01-28 17:00:00 +0000\n1.9.3 >> Chronic.parse '17:00'\n=> 2013-01-28 17:00:00 +0000\nI'm going to close this and if any issues come from it please re-open.\n. Chronic isn't designed for parsing date ranges like this. The only range Chronic will hand you back is the range between now and the date you've specified. If you want a date range, simply parse the dates separately.\n. Shoot, I updated my gh-pages and forgot to ask @mojombo to update this. The URL is http://injekt.github.com/chronic \nThe documentation is due to be rewritten in TomDoc though, so the YARD docs will be going down soon to be (hopefully) replaced with some new docs.\nThanks for reporting, I'll close this issue once @mojombo has had chance to change it\n. This looks great, merging and releasing fixes with a version bump. Thanks a lot Joe!\n. This isn't functionality that should be baked into Chronic. Chronic is for naturally parsing times and dates, and to me someone saying '4' in the context of a date or time would usually mean 4 o'clock on the same day. \nYou can abstract this conditional out before hitting Chronic:\nruby\nChronic.parse(mynumber) unless mynumber =~ /\\A\\d\\z/\n. What version of Chronic are you using?\n```\n\n\nChronic::VERSION\n=> \"0.6.7\"\nChronic.parse 'first day of this month'\n=> 2012-02-16 12:00:00 +0000\nChronic.parse '1st day of this month'\n=> 2012-02-16 12:00:00 +0000\nChronic.pre_normalize '1st day of this month'\n=> \"1st day of this month\"\nChronic.pre_normalize 'first day of this month'\n=> \"1st day of this month\"\n``\n. Yeah, it _should_. I don't think there's a handler for this. I'll leave this issue open for now and look into it when I have time. Thanks\n. Precisely. The problem is here: https://github.com/mojombo/chronic/blob/master/lib/chronic/repeaters/repeater_month.rb#L29 Chronic isn't setup to pass tokens to repeaters, so the repeater RepeaterMonth has no idea the ordinal1stexists. This is a widespread issue and isn't as simple as replacing@now.day + 1with1`.\n. I like this idea, but one could argue we need a context for each element. That is, we may want a specific day or month to be fixed whilst the rest of the information is flexible. I'll leave this open as a feature, as it would be something I'd like to implement. I'm working on a small rewrite of Chronic to get around some of the restrictions which has lead to some of the bugs listed on the tracker. It's certainly not an easy feat, though. This is most likely to fit into the road to version 1.\n. There's not really much way to get around this. Chronic isn't built for extracting times, but rather parsing them. That is, Chronic expects something which represents a string that should return a new Time object. Your time should first be extracted from your string before it's sent to Chronic.\n. Yeah, Chronic should of course not raise an error like that but should\nreturn nil. See the commit I referenced above, with that in place\nchronic will return nil for the string you've provided. It'll be\nreleased soon.\n\n\nOn 1 Jun 2012, at 04:33, Mike Ottum\nreply@reply.github.com\nwrote:\n\nYeah, that makes sense. I'm trying to use Chronic to both extract and parse by splitting a sentence up into its component phrases and attempting to parse each phrase (in order of decreasing length) with Chronic. If Chronic returns nil, the algorithm moves onto the next phrase.\nSo, for this issue, I don't expect Chronic to be able to extract the time from the long phrase, but I would like it to return nil instead of throwing an exception. Does that seem reasonable? If so, I can attempt a fix.\nOn Thursday, May 31, 2012 at 9:51 AM, Lee Jarvis wrote:\n\nThere's not really much way to get around this. Chronic isn't built for extracting times, but rather parsing them. That is, Chronic expects something which represents a string that should return a new Time object. Your time should first be extracted from your string before it's sent to Chronic.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/86#issuecomment-6041230\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/86#issuecomment-6052901\n. Closed by @jeremyf's work in 8d2e4d22ae4a14fbabe46b92006b00609fbffa75\n. @jeremyf My main priority is to solve the issues. I can spend any other time prettying it up. I haven't had much time for Chronic lately as real life and work has been catching up but I do plan on spending time on it soon. This is a massive help. Thank you\n. You're correct. 9:26 will work whilst 09:26 will not (for Post meridiem). I'm hoping to find some time over the weekend to fix this. Thank you for your patience!\n. This is looking great. I can't auto pull without tests though. Unfortunately I'm a little bogged down with startup life which is why I haven't had much time to work on Chronic so I won't be able to write tests for this for a while. If you'd like to take a shot at it please feel free. \n\nCould you also remove the rogue .DS_Store that managed to sneak in there? \nThanks for the hard work! :+1: :metal:\n. This is awesome. Merging into develop before a feature release. Thanks for all the hard work!\n. Chronic doesn't yet parse the first day of the month. This will be added soon\n. If this all passes fine on Ruby 1.8.6+ then I'm happy to do so. Could you knock up a patch and submit a pull, @An0Hit0?\n. Yeah, this would require a new pattern. This isn't something I feel is all that necessary. If you'd like to add it please give it a go and send a pull request. Thanks\n. Chronic doesn't yet understand the first day in the month, nor any other of those strings. Parsing the first day of the month will be added asap. Thanks for reporting\n. This is great. Thanks a lot!\n. This looks good. Although it'll only handle a lowercase a, we should probably support both lower and uppercase. Thanks!\n. Thanks for the change, although can I recommend using /^\\s?an? /i instead as I think it looks a littler clearer. I can work on releasing this as part as the gem before the end of next week. Thanks again\n. Merging and modifying myself. Thanks for the code\n. I would probably rather have this as part of the Repeater class in lib/repeater.rb inside the method scan_for_units, I think you'll see it makes more sense in there rather than in the normalize method. Essentially a 'normalized' string shouldn't have to stray too far from the original string. It's the job of the scanners to implement matching rules and assign tags.\nCould you also add some tests for this, please? Once it's there I can merge it straight away.\nThanks for your work.\n. in test/test_parsing.rb you'll see the method test_parse_guess_gr, inside that you'll see the day portions and everything following those. Somewhere in there with the corresponding tests would be great.\n. Merged. Thanks!\n. Yeah the problem is here. Because 'second' can be ambiguous to Chronic, I catch it (or attempt to catch it) early and convert it to 2nd. Otherwise second will be interpreted as a unit of time. It's difficult to interpret what words are likely to come after second where you would expect to replace it with 2nd. Of course the days of the week are included in these, though.\nAre there any other examples you can think of where this may be the case before I just add week days? \n. If you're having a LoadError it means your program is unable to locate chronic in $LOAD_PATH. \nI'm not sure exactly what you'd like the README to state, but if you're parsing a string via a web form then you just need to handle that inside your controller (for example).\nClosing this as it's not a Chronic issue.\n. Chronic::DEFAULT_OPTIONS[:endian_precedence] = [:little, :middle]\nI don't think setting the default endian precedence per zone makes much sense. Chronic should have the same functionality no matter where you use it and doing so could break apps which could be frustrating for users to troubleshoot (This is coming from someone who also changes the default options all the time as everything I do is also UK based).\n. Chronic is for parsing natural language. That is, you would tell Chronic something that would make sense well you tell your buddy. Saying \"Wednesday\" when today is Wednesday makes little sense. Your last example (which actually returns the correct day, is the one which makes sense. You're telling Chronic to head back to yesterday and then use the string \"this wednesday at 22:00\" which again, would make sense in a conversation (even if 'tomorrow' would be more likely)\n. Chronic wasn't really built for this. But let's dig deeper. Take the documentation of the ambiguous_time_range option:\n#        :ambiguous_time_range - If an Integer is given, ambiguous times\n    #                  (like 5:00) will be assumed to be within the range of\n    #                  that time in the AM to that time in the PM. For\n    #                  example, if you set it to `7`, then the parser will\n    #                  look for the time between 7am and 7pm. In the case of\n    #                  5:00, it would assume that means 5:00pm. If `:none`\n    #                  is given, no assumption will be made, and the first\n    #                  matching instance of that time will be used.\nThis tells us using :none returns the first matching instance of that time. We probably don't want that because although the figure we're providing is not ambiguous to us, it is to Chronic. It also says \"If an Integer is given, ambiguous times (like 5:00) will be assumed to be within the range of that time in the AM to that time in the PM\" so lets try that:\n```\n\n\n1.upto(25) { |i| p Chronic.parse(i.to_s, ambiguous_time_range: 12) }\n2012-07-23 13:00:00 +0100\n2012-07-23 14:00:00 +0100\n2012-07-23 15:00:00 +0100\n2012-07-23 16:00:00 +0100\n2012-07-23 17:00:00 +0100\n2012-07-23 18:00:00 +0100\n2012-07-23 19:00:00 +0100\n2012-07-23 20:00:00 +0100\n2012-07-23 21:00:00 +0100\n2012-07-23 22:00:00 +0100\n2012-07-23 23:00:00 +0100\n2012-07-23 12:00:00 +0100\n2012-07-23 13:00:00 +0100\n2012-07-23 14:00:00 +0100\n2012-07-23 15:00:00 +0100\n2012-07-23 16:00:00 +0100\n2012-07-23 17:00:00 +0100\n2012-07-23 18:00:00 +0100\n2012-07-23 19:00:00 +0100\n2012-07-23 20:00:00 +0100\n2012-07-23 21:00:00 +0100\n2012-07-23 22:00:00 +0100\n2012-07-23 23:00:00 +0100\n2012-07-24 00:00:00 +0100\nnil\n```\n\n\nThe problem with this is that you're telling Chronic to be a little more strict and that your time is not ambiguous (when we all know 1 is ambiguous when it comes to time). If all you really need to do is parse a numeric looking string and return an hour, I would simply recommend using Rubys build in Time class.\n. This has nothing to do with the day. You're comparing completely different strings.\n```\n\n\nChronic.parse '14th this month'\n => nil\nChronic.parse '15th of june 2010'\n=> 2010-06-15 12:00:00 +0100\n```\n\n\nThis tells me Chronic just doesn't support parsing x this month no matter which day it is. Remember, Chronic is for parsing human comprehensible time strings. \"15th of June 2010\" is something someone might say, \"fifteenth this month\" is not so much.\n. Yep, I agree. I'll add it to the list of handlers to implement. Thanks\nOn 26 Jul 2012, at 15:21, Taylor Brooks\nreply@reply.github.com\nwrote:\n\nSorry, I left out the word 'of' should've read:\n``` console\nirb(main):001:0> Chronic.parse('15th of this month')\n=> nil\nThat's a human comprehensible or even '15th day of this month'\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/109#issuecomment-7278896\n``\n. I'm loving your enthusiasm, but is there a point to opening this issue?\n. That's great. I think having something similar to Chronic in any other languages is good. I recommend starting something and asking for contribution once you have a stable and basic structure of code in place. I'm going to close this as it's not an issue with this library, but please let me know via [twitter](http://twitter.com/lee_jarvis) or email how you get on.\n. No, Chronic attempts to _guess_ the date you mean (because you didn't provide it. If you want the 1'st of the month you should pass:guess => falsetoChronic.parseand Chronic will return an instance ofChronic::Span`. You can then fetch the begin/end values of this span:\n\n```\n\n\nChronic.parse('july 2012', guess: false)\n=> 2012-07-01 00:00:00 +0100..2012-08-01 00:00:00 +0100\n_.begin\n=> 2012-07-01 00:00:00 +0100\n```\n. Thanks for all this work. I'm not really sure how I feel about adding this kind of functionality to Chronic but I quite like what you've done. I've merged this into the localization branch as I think it needs a little work and more tests but I'm happy to work towards merging this.\n\n\nThanks a ton\n. @luan Now I've refactored master a little I think this might fit. Could you take a shot at rebasing things against master so we can merge and roll this out? Otherwise I'll take a shot at it when I have some spare time. :metal: \n. @luan Sorry I am planning on finding time for this, I'll rebase the changes against master. I need to fix some of the big bugs on head before this featured is merged upstream. Thanks again for the work on this!\n. Sorry I've been super busy lately. I've merged this locally but I'm having failures I'll need to resolve before merging upstream\n. I've merged this into the localization branch and fixed the conflicts. It's not yet running green though, as there are issues with the numerizer parsing. \n. Yeah I must have missed your comment on that other issue. This looks great, thanks for the pull will merge this straight away.\n. Closed by #113\n. Why not just use Rubys built in Time class for this?\n```\n\n\nTime.at(date +%s.to_i)\n=> 2012-08-14 14:54:10 +0100\n```\n. Yeah I'm with Luan on this one. You can accomplish what you want with something easy like\n\n\nruby\ntime = str =~ /\\A[0-9]{10}\\z/ ? Time.at(str.to_i) : Chronic.parse(str)\nThanks for the suggestion.\n. Chronic replaces all periods with colons. This is because 4.15 is a common alias for 4:15 for example. Supporting floats is going to be difficult. I'm not sure it'll be a popular request, either. I'll leave this open but for me it's on the bottom of the issues/features list. Lots of other things have to be done first. Thanks for the suggestion\n. Sorry but I'm gonna go ahead and close this. There's just so much ambiguity when using floats and the existing parsing system Chronic uses. \n. What you're asking for would be somewhat complicated because there's just so many ways to represent even the simplest of timestamps and that's just in the English language.\nI'm going to close this as it's not related to Chronic. But feel free to update it if you find something that does what you're looking for.\n. I think it would need too many configuration options. Most of which strftime cover. You could start with something simple like this, though:\n``` ruby\n!/usr/bin/env ruby\nclass PrettyTime\n  def self.convert(time)\n    out = ''\n    now = Time.now\nout << ordinalize(time.day)\nout << \" \"\nout << monthify(time.month)\nout << \", \"\n\nif time.year < now.year\n  years_ago = now.year - time.year\n  years_str = years_ago > 1 ? \"#{years_ago} years ago\" : \"last year\"\n  out << years_str\nend\n\nout << \" at \"\n\nhour = time.hour\nout << (hour < 12 ? \"#{hour}am\" : \"#{hour - 12}pm\")\n\nend\ndef self.ordinalize(number)\n    if (11..13).include?(number.to_i.abs % 100)\n      \"#{number}th\"\n    else\n      case number.to_i.abs % 10\n        when 1; \"#{number}st\"\n        when 2; \"#{number}nd\"\n        when 3; \"#{number}rd\"\n        else    \"#{number}th\"\n      end\n    end\n  end\ndef self.monthify(month_int)\n    %w(January February March April May June July\n      August September October November December)[month_int - 1]\n  end\nend\np PrettyTime.convert Time.local(2006, 8, 16, 15, 0, 0, 0) #=> \"16th August, 6 years ago at 3pm\"\n. The problem here is that Chronic doesn't support zone based parsing. Chronic recommends using Active Support to set the time zone with `Chronic.time_class = Time.zone` as noted in the README. So yes, this is likely to create a race condition. It's likely that if the `parse` method accepted a time zone or time class it could instead be grouped with the returning time object and avoid a race condition. Chronic should however, not rely on Active Support but I would consider adding a `:time_zone => 'America/Phoenix'` option to `parse` which would (if set), load Active Support safely. \n. Yep same as #121. Trying to find some Chronic time but struggling a little. How about taking a shot at this if you can, @yfeldblum?\n. What version of Chronic are you using? The second example doesn't work for me.\n.\n\n\nChronic.parse('2012-09-27 10:00:00')\n=> Thu Sep 27 10:00:00 +0100 2012\n```\n\n\nYou're using Chronic version 0.3.0. Please upgrade, there are a lot of bugs with version 0.3.0.\n. ```\n\n\n[RUBY_VERSION, Chronic.parse(Time.now.to_s)]\n=> [\"1.9.3\", 2012-09-28 12:10:21 +0100]\n[RUBY_VERSION, Chronic.parse(Time.now.to_s)]\n=> [\"1.8.7\", Fri Sep 28 12:12:44 +0100 2012]\nChronic.parse('2012-09-27 10:00:00 +0000')\n=> Thu Sep 27 11:00:00 +0100 2012\n```\n\n\nChronic version 0.8.0\n. Looks great, thanks!\n. @EddyKang Please open a separate issue for this feature (it's actually slightly different from this one). Cheers!\n. Thanks and I appreciate you taking a shot at this. I still think however that this is the wrong approach. I would rather encapsulate all of the data into a single instance of a parser class or something similar. It would clean up Chronic in general as well as fixing this issue.\nCheers!\n. > you probably already have the code structured more or less the way you want it, and probably wouldn't want to disturb everything\nVery much the opposite. Chronic has massive space for improvement, and if disturbing the code base is what it takes to achieve this, that's exactly what needs to happen.\n\nOr the logic in Chronic.parse could be split out into a Parser class, which would have an attribute :now. Chronic.parse would simply instantiate a Parser and call \"parse\" on it.\n\nThat's exactly the kind of thing I had in mind. Something similar to this:\n``` ruby\nmodule Chronic\n  def self.parse(text, options = {})\n    Parser.new(options).parse(text)\n  end\nclass Parser\n    def initialize(options)\n      @options = options\n    end\ndef parse(text)\n  # parse into tokens and delegate to tag scanners\n  # passing this parser instance around as and when we need it\nend\n\nend\nend\n```\n. Cool. Looking good so far. Can you move the Parser class into it's own file?\nAlso not sure about all the references to self in the Handlers module, I think I like the idea of including them into the Parser class though but I'm still not entirely sure that's a good idea. I realize if we don't do that then it means we need to pass the parser instance to every handler method which I'm also not happy about. I think your solution is probably better right now.\nGreat work so far!\n. I like this, can you open a new pull request and we can discuss it further in there. Cheers!\n. Thanks. There's an issue here, though. The tests do not pass on your branch but they pass on master.\nCould you also rebase this, there are conflicts between your commits.\n. Looks good, thanks. I'm going to merge this into a development branch and keep master for bugfixes, until we have some more tests for issues #121 and #123 and then I'll merge into master.\nThanks!\n. Yeah, they shouldn't be hard at all. I've merged this pull request into the next branch. Any further work towards this should happen in there.\n. That's fine, I'll review this as is. However we shouldn't need to test differences between MRI and JRuby so I think just containing everything in the Parser class will work as expected.\nThanks for your work on this, good stuff!\n. I don't believe the test is necessary especially if it's dependant on Ruby implementations. If all configuration options are incapsulated into an instance of Chronic::Parser I don't believe we should have any issues. You can just revert that commit and I will merge this PR. Cheers\n. This has limitations just like the parse methods on Time and Date, even Ruby's underlying date parsing algorithm returns 20 as the month and 12 as the month day. \nThe only thing we can really do about this is provide an extra configuration option which adds the Handler scalar_year which will return the year instead of the time\n. That's not what a Chronic::Span object is intended to do, and I believe Chronic shouldn't be designed to take on this kind of feature (it may seem simple, but it involves added a massive set of features). Essentially you should get a Chronic::Span object from every possible timestamp. It looks like you want to return 2 separate timestamps, why not something like:\n``` ruby\ndef get_span(string)\n  if match = string.match(/\\Afrom\\s(.+?)\\s(?:to|until)\\s(.+)\\z/)\n    match.captures.map { |c| Chronic.parse(c) }\n  end\nend\np get_span(\"from 1st December 2009 to 2nd of Jan 2011\") #=> [2009-12-01 12:00:00 +0000, 2011-01-02 12:00:00 +0000]\n``\n. Actually I'm thinking of just rolling back to doing explicit requires. I never really liked autoload, anyway.\n. I can't reproduce this even when changing the current time to a daylight saving zone, it seems like it could be more of an issue with Ruby's Time class. Please re-open if you can reproduce an error specific to Chronic\n. Merged, thanks!\n. No there hasn't, I'm struggling to find time for Chronic at the moment. Hoping to start hitting some of these as soon as possible\n. @markerdmann sorry I hadn't noticed your message until today. I can't reproduce the original issue so it'll probably take me a little longer to fix. Usually I would enable debug mode (Chronic.debug = true) then jump into the method that handles this sequence (inHandlers) then debug things from there. It's not always a quick process and there's a few subtle bugs in Chronic that aren't easy to fix. I do still have a rewrite that's currently in progress but again I'm finding it hard to find work on this at the moment, everything is tied up with work\n. No, there's no way to do this. Right now Chronic discards the tokens it doesn't care about [right here](https://github.com/mojombo/chronic/blob/master/lib/chronic/parser.rb#L219). That is, any token that doesn't contain any tags will be thrown into/dev/null`.\nI don't see the benefits of extracting the non tagged items myself. At least not enough to alter the way Chronic works and store them in memory. There will be a ton of caveats when doing this. For example, the word at will be tokenized and tags will be applied to it. So if you had tomorrow I'll be at the station you'll have I'll be the station returned. \nHere's how you could extract those values, though (see the other_words variable):\nruby\n    def tokenize(text, options)\n      text = pre_normalize(text)\n      tokens = text.split(' ').map { |word| Token.new(word) }\n      [Repeater, Grabber, Pointer, Scalar, Ordinal, Separator, TimeZone].each do |tok|\n        tok.scan(tokens, options)\n      end\n      other_words = tokens.reject(&:tagged?).map(&:word) #=> [\"Go\", \"to\", \"the\", \"doctor's\"]\n      tokens.select { |token| token.tagged? }\n    end\n. Thanks!\n. Yes it's the Numerizers fault. I'd like to eventually drop support for the internal Numerizer and use https://github.com/jduff/numerizer instead. Which was originally extracted from Chronic, but I would like to manage it separately. \n. I should also note that 'second' isn't returned as '2nd' not because this is a bug but because 'second' in Chronic is obviously also a time unit\n. Awesome work, thanks a lot\n. Looks good. Great work! Thanks\n. No there's currently no way to do this, but it does need to be added. We can just accept a time_class option which can be set to Time.zone before parsing, and defaults back to Chronic.time_zone. \n. @burlesona Yeah you wouldn't have to alter Time.zone you could just do this:\nChronic.parse('December 21st at 4PM', :time_class => Time.zone) Chronic would simply use this class to calculate times, it would not alter it in any way.\n. It does make sense, but I think passing in a time_zone as a separate string is beyond the scope of Chronic. Why not do something like this in your model/class/etc:\n``` ruby\ndef parse_time(string, zone)\n  orig_timezone = Time.zone\n  Time.zone = zone\n  Chronic.parse(string, :time_class => Time.zone)\nensure\n  Time.zone = orig_timezone\nend\nparse_time 'Jan 2nd', 'Eastern Time (US & Canada)'\n``\n. Maybe this will create race conditions? The problem is, doing it inside Chronic would make no difference..\n. I'm going to close this, if you have any more opinion on the matter or ideas feel free to re-open and discuss.\n. @dnagir Yes I am; see my comment on #182 \n. :metal: Happy new year to you too!\n. What version of Chronic are you using? Every one of those parses fine for me on 0.9.0\n. Hah I didn't noticed that! :metal:\n. I'm not sure I see the benefit of adding this method to the public API. It's essentially absolutely no different from doing this in your own code:time = Chronic.parse('some string') or raise \"...\"adding bang methods for 'things that raise' has been a Rails-esque thing to do and for someone who's not used to that it could be confusing. Thanks for digging in, though!\n. I appreciate this is something that would be extremely useful to your use-case, but there's just not enough need for this to merge into Chronic. I disagree with thethere can't be many people who haven't used rails at some pointcomment but that's unrelated and isn't the main reason I won't merge this. It's really just too easy to add this method in your own code rather than baking it into a public API where it's unlikely to be used very often.\n. @johari I don't understand why this is a feature request. The reasonparse!is not part of the public API is because it adds absolutely no benefit. First of all, bang methods for something that raises an exception in counter to the non-bang method that would returnnilis a Rails-esque _feature_. Secondly I see no reason why users couldn't just add this check to their own code. If you knowparsereturnsnilyou should check for it in a validation. Alternatively you can add your ownparse!` method.\nI'm open to all feature requests but I don't see a great enough benefit for this.\n. > it seems silly that what most people would expect to be the default case isn't supported at all\nWhat makes you think that? Chronic has been around for 7 years and this is the only occurrence of someone requesting this behaviour.\n. @johari Comparing to strptime probably isn't fare. That method expects a valid format. The reason Chronic doesn't raise is because there isn't such thing as a valid format. Chronic will attempt to extract a time object from any string. Chronic may or may not be able to parse your string and return a time object, and I think raising if it's unable to is a bad idea because your string may very well look like a valid time string, but maybe it does not yet support that format.\nI would of course accept pull requests for documentation improvements.\n. The start date is most definitely correct, but the end date should be course be 2013. Odd, it looks like there's a test to cover this here. I'll have to dig deeper\n. Looks like it's dependant on the current month:\n``` ruby\nChronic.parse(\"last winter\", guess: false, now: Time.local(2013, 4))\n=> 2012-12-22 00:00:00 +0000..2013-03-19 00:00:00 +0000\nChronic.parse(\"last winter\", guess: false, now: Time.local(2013, 3))\n=> 2012-12-22 00:00:00 +0000..2012-03-19 00:00:00 +0000\n```\n. Looks like this patch fixes the issue but that feels a little hack-ish and it's avoiding the underlying reason this doesn't work as it should.\n. What are your current time zone settings? Maybe I can reproduce the failures\nOn 22 Jan 2013, at 15:55, Michel Boaventura notifications@github.com\nwrote:\nOn my gentoo machine running on master with both ruby19 and jruby I got two\nfailures:\n1) Failure:\ntest_guess(TestChronic)\nExpected: 2006-11-16 00:00:00 -0200\n  Actual: 2006-11-16 00:30:00 -0200\n2) Failure:\ntest_parse_guess_r(TestParsing)\nExpected: 2006-11-16 00:00:00 -0200\n  Actual: 2006-11-16 00:30:00 -0200\nBut if I run the tests with \"TZ=UTC\", all the tests passes. Am I doing\nsomething wrong?\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/mojombo/chronic/issues/168.\n. date +%Z should do the trick\n. I can't reproduce this in any way whatsoever, can you reproduce on any other machines? I can't really see what the issue would be.\n. Gonna go ahead and close this until we can reproduce it\n. It's not used directly. Your system should handle setting the TZ variable\nwe just override it for testing in multiple time zones. You can check the\nbehaviour like so:\n$ date\nTue 29 Jan 2013 12:08:00 GMT\n$ TZ=est date\nTue 29 Jan 2013 07:08:00 EST\nhttp://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html\nOn 29 Jan 2013, at 01:26, Michel Boaventura notifications@github.com\nwrote:\nI'm trying to find out why this happens on my machines. I've tried it on\nthree gentoo pcs and all of them have this issue. In which part of the code\nthe TZ variable is used?\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/mojombo/chronic/issues/168#issuecomment-12815707.\n. Sure, I'm happy to do that. I've been meaning to hook up travis for some time now anyway.\n@mojombo can you enable the service hook, please?\n. Sorry for the lack of response on this Ben, I wanted to take time to consume it as it's quite a complex set of features. Great to see you've created something from it though!\n. This is fine but I'd rather avoid having to declare the ivars in initializers. Whilst I also prefer everything to run without warnings I think the undeclared ivar warning is nonsense and can compromise readability and simplicity. I'm happy to merge if you could revert that change. \nThanks!\n. Looks good, thanks!\n. @michelboaventura I can't administrate the hooks on Chronic, waiting for @mojombo on this.\n. Nice thanks! :metal: \n. I can't reproduce the original issue\nirb(main):001:0> Chronic.parse(\"2013-09-30T01:00:00\")\n=> 2013-09-30 01:00:00 +0100\nirb(main):002:0> Chronic.parse(\"2013-09-30T01:00:00-05:00\")\n=> 2013-09-30 07:00:00 +0100\nirb(main):003:0> Chronic.parse(Time.now.in_time_zone(\"America/Los_Angeles\").iso8601)\n=> 2013-05-11 12:37:27 +0100\nThis is with Chronic version 0.9.0. Please re-open with a reproduction.\n. @andrijaperovic Yes, this bug has been fixed. If you can reproduce it on the latest version of Chronic please re-open this issue\n. 4237b1ca5f6988064d5029d4c92b6fc1b3304917\n. That's odd, I can't reproduce that test failure locally or on my VPS (with a range of time zones).\n. Yeah, April23 is considered a spelling error, Chronic doesn't (not probably ever will) handle that. Fixing things like that is a prerequisite for using Chronic, if Chronic started trying to fix spelling errors there would be no end.\n. Yeah I was suggesting that as a change, it's not yet possible. I'll mark this as a feature.\n. It's correct that this is not thread-safe. There is currently no workaround until we build something into Chronic (see the other issues). This shouldn't be so hard now that parse creates a new Chronic::Parser instance. We an feed the time_class option into the Parser class and let it default back to Chronic.time_class. Probably once this option is added Chronic.time_class should be removed to avoid questioning thread safety (it'll never be thread-safe).\nTo clarify and reiterate what @dnagir has said; that SO answer is incorrect. I've commented on it.\n. @dnagir Honestly, I don't. I haven't managed to find time for Chronic for quite a while. As frustrating as it is, I do plan to find some time to work on it (though I am working on a replacement, too). Work is very busy. Please feel free to submit a PR for it. @davispuh is currently managing a lot of the code also so one of us can review. Happy to expand collaborators. Still hoping to move the repo or sort something out so I don't have to bother @mojombo every time.\n. :metal: \n. Thanks for taking a shot at this. Things like this mostly fall into the 'normalization' category. Let's break it down:\n1. a.m. am a.m etc should all behave the same (this tells us we need to 'normalize' the strings\n2. Open up lib/parser.rb in the pre_normalize method. \n3. Modify the last line to p text\n4. Try your example, in this case tomorrow at 4a.m. returns next day at 4 am:m:\n5. Uh oh, that's not right!\n6. Use p to go up the substitute chain until we see where the bad change was introduced. Turns out a.m. is pretty quickly turned into a:m: which we should change!\n7. Enable normalize powers! text.gsub!(/([ap]):m:?/, '\\1m')\n8. Write a test.\n9. Run all existing tests.\n10. :metal:\n. You want Time.zone_offset here's an example from UTC+1 (my timezone) to PST:\nirb(main):002:0> Chronic.parse(\"7pm\") - Time.zone_offset(\"PST\")\n=> 2013-07-31 03:00:00 +0100\n. I don't like the use of instance_variable_defined? everywhere. I'd much rather set these ivars to nil than check this every time. I think the tradeoff for no warnings just isn't worth the mess in the code. \nI'm also happy to use minitest ~> 5.0\n. > I decided against setting them to nil because I was lazy reading the whole inheritance chain. Will try to cover this. Totally agree. :)\nI would be too, it's fairly messy. I don't really mind still having the ivar warnings, but if it's something you'd like to cover, go for it!\n\nI'm a bit pondering about the s.add_development_dependency 'minitest', '~> 5.0' right now. The project does not have a Gemfile, that means the ~> 5.0 declaration only affects a gem install chronic --dev, right? I don't want to install the gem when I just want to work on a fork.\n\nMaybe we should add a Gemfile and start using bundler?\n\nSo how should I assure that the version is actually ~> 5.0?\n\nYou would have to use gem 'minitest', '~> 5.0' before requiring minitest/autorun\n. @tbuehlmann Good stuff. Thanks for the work. \n. >  Is there a better way to set the time zone for each user while still accounting for thread safety?\nCurrently there is not.\nSee #182 and #158 \n. :metal:\n. I'm not really sure how this should be fixed to support both features. Will explore later in the week if I have time. Thanks for reporting.\n. There's no reason other than it hasn't been done. I'll consider this change, thanks!\n. I like this. Thanks for the work, it looks much nicer. One thing, though.. could you change the camelCase variable names to use snake_case? Camel case variables in Ruby are rare and I think they're messy (especially as everything else is snake case) I also think this exception should raise an ArgumentError and should have a test.\nApart from that, this looks great.\n. Could you rebase and squash your commits? I'll merge this in this afternoon. Thanks for the work!\nOn Tue, Jul 30, 2013 at 3:38 PM, D\u0101vis notifications@github.com wrote:\n\nhmm, seems there's merge conflict because @current_time from merged PR (ruby-warnings)\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/pull/195#issuecomment-21794878\n. :bomb: thanks!\n. Nice work, thanks! :bomb: \n. I also don't think this is beneficial enough to be a feature. Thanks for the work though, @ismaelga \n. No, I'm happy to leave it for now, we can consider changing it any time before a full 1.0 is released (some day). I'll merge this later. Thanks for the work!\n. This is really great. Thanks a lot for the work! I pinged @mojombo on Twitter about giving you commit bit (or moving the repo to my account, which might make more sense in the long run), hopefully we can get that actioned at some point.\n. Nice, thanks! :metal:\n. @davispuh Thanks, could you update the changelog with a summary of your changes?\n. Looks like this was broken in dbf2e0cffc2c41c3933d9a500912476785583430. @davispuh is there any reason we can't use time_class.local here? That's used everywhere else. \n\nThanks for reporting, Scott.\n. I'm not sure I see the entire benefit to that. Anyway we should revert to using local so Chronic doesn't break for anyone using ActiveSupport::TimeZone. I'll release a 0.10.1 bugfix\n. The is_a? and partners won't work, it has nothing to do with minitest, I'm not sure how they were working before. time_class is not an instance of Time etc. They're all instances of Class so that would return false for them all anyway, it always needed an explicit test against the class name. \nThanks for the patch\n. Sorry about that! Yeah I'm not a huge fan of dropping 1.8 support so easily (and didn't think we had, until now!). That said, 1.8 is EOL and I always intended to drop support for it eventually. I'll alter the readme to provide better feedback about these incompatible changes. I think it means we can finally clean up a lot of other Chronic code (now we've fixed to >=1.9). I'll also alter our gemspec. \nIn conclusion, if we're sticking to dropping 1.8 support in version 0.10 then we won't ever support 1.8 again. If we choose to revert these changes, we can wait until 0.11 or a solid 1.0. I would rather not have Ruby version constraints that would introduce explicit workarounds in the code. \n. I've released 0.10.2 with 1.8.7 support. This support is due to be dropped in 0.11 but not until then.\n@samg Please fix at ['> 0.10.1', '~> 0.10.2', '< 0.11'] this should give you any new bug fixes but continue 1.8.7 support.\n. Fwiw, Chronic isn't really tailored for parsing the output of Time.now.to_s, that's really just a novelty feature I added and it's probably much slower than doing Time.parse (which Chronic does under the hood after it's processed it). So if you know it's a timestamp from Time#to_s you should feed it to Time.parse\n. I don't think this is necessary. I'd like to add the ability to use debug/time_class configuration values per Parser instance. That would solve the problem of hitting race conditions. Then Chronic.debug and Chronic.time_class can be used as 'global configuration', that is, default values which are overridden by a call to .parse:\nruby\nChronic.parse('next tuesday at 3pm', time_class: Time.zone)\nI'm not too worried about the debug flag, though. If someone has enabled debugging they should expect to see it everywhere.\n. Again I don't think this is necessary. If we are going to go the route of making stuff thread stuff like this, then it should be kept simple:\n``` ruby\nclass Chronic\n  def self.time_class\n    Thread.current[:chronic_time_class] || ::Time\n  end\ndef self.time_class=(klass)\n    Thread.current[:chronic_time_class] = klass\n  end\nend\n```\nThere's no need for the prefixed underscores, or the capitalized class name, it's adding unnecessary complexity to what's essentially a simple subject.\nHowever, I do still believe that we should allow setting the time class per Parser instance, and that having this ability means the global configuration does not have to be thread safe. If there's a per parser instance configuration value for time classes, there's absolutely no reason to mutate the global state, and it could be misleading to do so (for example having a Rails initializer with time_class set when someone could change it per thread)\n. This looks good. Could you rename weeks_start to week_start (singular) and squash these commits? I think week_start makes a little more sense, though I'm open to suggestions/objection to that. Thanks for all the work!\n. :sparkles: :shipit: :sparkles: \n. A license is present.\n. We should start using bundler and fix to a specific version of minitest, this would help out development somewhat. I'd also like to start using travis but it's a little difficult to manage when I don't administrate this repository. I've spoken to @mojombo and he's considering the ramifications of moving it. \n. We have this https://github.com/mojombo/chronic/pull/113 which I'd love to have time to merge into the latest version of Chronic, but I think it needs some work\n. Yeah today is not intended to represent a time in any form. I would say any time during the day would essentially be valid. I'm not adverse to tweaking the time Chronic returns if someone wants that to change, but I think that's a different issue.\n. @fakeleft The problem is that they're not synonymous. \"today\" in regards to time is totally ambiguous. Chronic doesn't return Date objects. If it did, it would no doubt return one for \"today\" because there's no concept of time involved. Chronic.parse(\"today\").to_date == Date.today is what counts. \nI'm more than happy to fix ambiguous times to midday, but it's all relative. If you're parsing \"today\" then you probably don't care about time, and if you do, you need to be more specific.\n. Is there a reason for this? I'm hesitant to merge a patch like this because I won't (and do not expect others) to keep the consistency of using single quotes everywhere. \n. > Basically it is recommended to use \"\" if there a ruby eval and ' when there is no ruby eval.\nI'm not really sure it is. I think it's just entirely personal preference. Anyway, please don't take my questioning as non-appreciation for taking the time to do this. I'm going to merge it, though I will note that I don't expect anyone who's thinking of submitting a patch to Chronic to have to worry about which quotes they use.\nThanks, @yatish27 \n. I like this, but I agree that it could be a confusing thing to add to Chronic. I also agree something like this should always return seconds over minutes. I'm happy to have a parse_duration or parse_span method that does something like this, though. \n. Please squash these changes into a single commit and remove the Gemfile commit as that change is not related to this pull request. \nAlso fwiw the text is downcased so using [Xx] makes little sense, also not sure what the following + is for as that would match xxxxxxxxxmas as well. I think (christ|x)mas is fine to be honest.\n. Awesome, I've been meaning to clean this up for a while. Could you add this logic to grabber, separator, sign and time zone please, happy to merge. Great work, thanks!\n. Great, thanks a lot Ben!\n. Thanks. I'm not sure we're really benefiting from the use of inheritance here though. Maybe definitions should be defined on the instance of the class, and options should be used to instantiate the class. That would remove all of the << self stuff and the rarely used argument to the definitions method\n. That's exactly what I meant, thanks Ben. I don't think there's really any benefit to having definitions as an accessor as I think it'll only be used via subclasses, and it can never not be set. Plus with Ruby's rules for immutability anyone has full control over the definitions Array anyway. \n. Actually I was mistaking options for definitions. The way you've done it in your commits is exactly what I was thinking, the extra snippet makes less sense because you're defining the definitions method twice\n. Sorry Ben I've been super busy. I'll check in on this this evening or tomorrow at the latest.\n. I don't understand either of these messages\u2014\nSent from Mailbox for iPhone\nOn Fri, Jan 24, 2014 at 6:31 PM, alexherbo2 notifications@github.com\nwrote:\n\nYes\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/240#issuecomment-33248278\n. Thanks, maybe we should add 2.1 as well now it's stable. Either way I'm still waiting on Tom to add the hook for travis\n. Thanks, I don't have access to it. @mojombo could you tweak it to http://leejarvis.github.io/chronic/ or switch the project over please :+1: :bomb: :sparkles: \n. I'm not too bothered. The reason it pointed to something custom was because the documentation style has been customized. However I'm not interested in maintaining that so happy to it to be pointed there or to be removed. Again, this is pending input/action from @mojombo \n. > Why would I be getting 12:00:00 UTC instead of 00:00:00?\n\nOut of curiosity, why did you expect 00:00:00?\n. Right, I understand it would be easier for things like that, I was just interested in why you expected that behaviour. Chronic aims to parse human read/writable time strings. This means there's really no decent way to determine the time we should use unless it is specified in the input string (this is basically what the guess option does). Some might say the time should match the time now (that is, tomorrow should present not the first minute of tomorrow's date, but instead tomorrow at 10:35.\nIt's also worth mentioning there are time zone considerations. If we set the time to 00:00:00 GMT it might be 3 hours ahead of a different timezone. If we use the local timezone then everyone gets a different result.\n. > Do you guys accept documentation patches?\nCertainly! Please feel free to add or modify documentation\n. :+1: \n. Thanks @davispuh I'll need a bit more time to review this which I'll hopefully find later this week. Some quick initial thoughts: We use TomDoc rather than YARD. I don't like the extra width argument, when you have to start specifying nil in places then I think there's a problem.\nThanks for this!\n. :+1: \n. :+1: \n. :sparkles: :shipit: :sparkles: \n. Looks good thanks!\n. @davispuh sure that sounds fine. I think this PR is fine to merge to master also, so go ahead\n. I think this looks good so far. There are a few methods in date_object and time_object and some other places that are a bit unwieldy so I'd be keen to clean those up but it looks like you've spent a lot of time on this. Great work!\n. I've be wanting to rewrite Chronic from the ground up, and I've actually been working on it for a couple of years. Here's an old Gist of how it looks. However, this code still isn't ready for any kind of release, even if it improves in Chronic a lot. @davispuh has done great work on the Chronic rewrite which will hopefully cover most concerns anyway. \nPorting something like Chronic to JavaScript is a mammoth task, so I take my hat of to you for even considering it. I think momentjs covers most use-cases, although I don't know of anything completely similar to Chronic in any other languages. It's a unique beast.\n. ",
    "shreyankg": "Even I am facing this error.\n. Even I am facing this error.\n. ",
    "graaff": "I'm seeing this also with chronic 0.3.0\n. I'm seeing this also with chronic 0.3.0\n. ",
    "rgarver": "+1\n. yay!\n. See pull #39\n. +1\n. yay!\n. See pull #39\n. ",
    "ddollar": "This would alleviate some issues with the latest version of Gemcutter/Rubygems. The 0.2.3 version on Gemcutter currently http://rubygems.org/gems/chronic declares hoe as a runtime dependency which sets off a chain of dependencies that requires Rubygems 1.3.6 (latest at time of this writing)\n. This would alleviate some issues with the latest version of Gemcutter/Rubygems. The 0.2.3 version on Gemcutter currently http://rubygems.org/gems/chronic declares hoe as a runtime dependency which sets off a chain of dependencies that requires Rubygems 1.3.6 (latest at time of this writing)\n. ",
    "qrush": "+1, getting reports of the same...would much rather have this isolated case fixed :)\n. WOOOO!\nhttp://rubygems.org/gems/chronic\n. +1, getting reports of the same...would much rather have this isolated case fixed :)\n. WOOOO!\nhttp://rubygems.org/gems/chronic\n. ",
    "foca": "+2 :)\n. +2 :)\n. ",
    "ghost": "+1\n. Sure, where should I add the tests for this?\n. Done.\n. is there going to be a fix to this? I am having the same problem. I am using 0.10.2 and Chronic returns nil when passing the following time 13/10/2014 8:00 UTC\n. +1\n. Sure, where should I add the tests for this?\n. Done.\n. is there going to be a fix to this? I am having the same problem. I am using 0.10.2 and Chronic returns nil when passing the following time 13/10/2014 8:00 UTC\n. ",
    "darrinholst": "+1\n. above my head...\n. +1\n. above my head...\n. ",
    "jeremyw": "+1\n0.3.0 fixes this bug: http://gist.github.com/313018\n. +1\n0.3.0 fixes this bug: http://gist.github.com/313018\n. ",
    "JamesCropcho": "+1\n. +1\n. ",
    "jneen": "+1\nthe version currently (0.2.3) up also has a runtime dependency on hoe, which is really bad practice.  i'm opting to build the gem myself rather than have hoe on production machines.\n. +1\nthe version currently (0.2.3) up also has a runtime dependency on hoe, which is really bad practice.  i'm opting to build the gem myself rather than have hoe on production machines.\n. ",
    "AlekSi": "+1\n. +1\n. ",
    "ryanwood": "+10\n. +10\n. ",
    "mattscilipoti": "+1\n. +1\n. ",
    "mojombo": "Done.\n. Version 0.3.0 has been on gemcutter for a while. What exact problem\nare you having?\nTom\nOn Sat, Mar 12, 2011 at 6:54 PM, Bill\nreply@reply.github.com\nwrote:\n\n+1 biting me on Engine Yard tonight\nhttps://github.com/mojombo/chronic/issues/5#comment_865109\n. Yeah, I'd let context rule the day and treat 'second' in a special way.\n. For chronic, assuming 00XX will probably always be incorrect. So the question is, which time direction do you bias? Chronic is supposed to be about doing the right thing based on what people intuitively type. I'm guessing that a good rule of thumb is that any two-digit year that is now + 50 (wrapping around the century) will be the future, and anything now - 50 (wrapping around the century) will be the past. For example, 11-61 means 2011-2061 and 00-10 or 62-99 means 2000-2010 and 1962-1999. This is easy to determine and probably covers most cases. If it doesn't, then users can set the time directionality or the assumed now date.\n. @basicxman That's a fair point. A default of ten years may be more reasonable. Perhaps it's time to think about a default configuration that includes all of these assumptions that Chronic makes and that would let people override those assumptions in a simple way. Another big one is the mm/dd/yyyy vs dd/mm/yyyy format which should also be a config option.\n. Ah yes, good point, there is already a decent mechanism to provide config options. I'd call the two year selector option something like ambiguous_year_future_bias.\n. :thumbsup: but I'm guess that test won't always pass.\n. Updated.\n. Done.\n. Version 0.3.0 has been on gemcutter for a while. What exact problem\nare you having?\n\nTom\nOn Sat, Mar 12, 2011 at 6:54 PM, Bill\nreply@reply.github.com\nwrote:\n\n+1 biting me on Engine Yard tonight\nhttps://github.com/mojombo/chronic/issues/5#comment_865109\n. Yeah, I'd let context rule the day and treat 'second' in a special way.\n. For chronic, assuming 00XX will probably always be incorrect. So the question is, which time direction do you bias? Chronic is supposed to be about doing the right thing based on what people intuitively type. I'm guessing that a good rule of thumb is that any two-digit year that is now + 50 (wrapping around the century) will be the future, and anything now - 50 (wrapping around the century) will be the past. For example, 11-61 means 2011-2061 and 00-10 or 62-99 means 2000-2010 and 1962-1999. This is easy to determine and probably covers most cases. If it doesn't, then users can set the time directionality or the assumed now date.\n. @basicxman That's a fair point. A default of ten years may be more reasonable. Perhaps it's time to think about a default configuration that includes all of these assumptions that Chronic makes and that would let people override those assumptions in a simple way. Another big one is the mm/dd/yyyy vs dd/mm/yyyy format which should also be a config option.\n. Ah yes, good point, there is already a decent mechanism to provide config options. I'd call the two year selector option something like ambiguous_year_future_bias.\n. :thumbsup: but I'm guess that test won't always pass.\n. Updated.\n. \n",
    "jakewendt": "I just tripped over this as well.\n. I just tripped over this as well.\n. ",
    "jfelchner": "Me too.  I'll try to get in a pull request unless someone beats me to it.\nEdit\nAlso a string of \"November 18th 2011\"  becomes \"November 18th, 2010 at 20:11\"\nBut the string \"November 18 2011\" calculates correctly.\n. Just submitted a pull request for support for a format like \"February 14th, 2010\"\n. Me too.  I'll try to get in a pull request unless someone beats me to it.\nEdit\nAlso a string of \"November 18th 2011\"  becomes \"November 18th, 2010 at 20:11\"\nBut the string \"November 18 2011\" calculates correctly.\n. Just submitted a pull request for support for a format like \"February 14th, 2010\"\n. ",
    "adamcrown": "I just ran into this problem myself. \nChronic.parse(\"monday 8:00am\",:now=>Time.parse(\"2010-11-07 8:00pm\"))\nThe article above provides a work-around. It would be nice to have this fixed.\n. I just ran into this problem myself. \nChronic.parse(\"monday 8:00am\",:now=>Time.parse(\"2010-11-07 8:00pm\"))\nThe article above provides a work-around. It would be nice to have this fixed.\n. ",
    "kabuko": "I'm seeing similar:\n```\n\n\nChronic.parse(\"today\", :now => Time.parse(\"2010-05-19 23:00:00 -0700\"))\n=> 2010-05-20 00:00:00 -0700\nChronic.parse(\"yesterday\", :now => Time.parse(\"2010-05-19 23:00:00 -0700\"))\n=> 2010-05-18 12:00:00 -0700\n```\n. I'm seeing similar:\n\n\n```\n\n\nChronic.parse(\"today\", :now => Time.parse(\"2010-05-19 23:00:00 -0700\"))\n=> 2010-05-20 00:00:00 -0700\nChronic.parse(\"yesterday\", :now => Time.parse(\"2010-05-19 23:00:00 -0700\"))\n=> 2010-05-18 12:00:00 -0700\n```\n. \n\n",
    "wapcaplet": "Same here, with chronic gem version 0.2.3:\n```\n\n\nTime.now\n=> Sun Oct 24 23:22:32 -0600 2010 \nChronic.parse('today')\n=> Mon Oct 25 00:00:00 -0600 2010 \nChronic.parse('tomorrow')\n=> Mon Oct 25 12:00:00 -0600 2010 \nChronic.parse('yesterday')\n=> Sat Oct 23 12:00:00 -0600 2010 \n```\n. Same here, with chronic gem version 0.2.3:\n\n\n```\n\n\nTime.now\n=> Sun Oct 24 23:22:32 -0600 2010 \nChronic.parse('today')\n=> Mon Oct 25 00:00:00 -0600 2010 \nChronic.parse('tomorrow')\n=> Mon Oct 25 12:00:00 -0600 2010 \nChronic.parse('yesterday')\n=> Sat Oct 23 12:00:00 -0600 2010 \n```\n. \n\n",
    "mdi": "Also seeing this bug with 0.3.0.\n. Also seeing this bug with 0.3.0.\n. ",
    "ckoehler": "Same problem here. Thanks for reporting!\n. Same problem here. Thanks for reporting!\n. ",
    "alexch": "Also, http://isitruby19.com/chronic reports:\nruby-1.9.2-head > Chronic.parse('3 months ago saturday at 5:00 pm')\nTypeError: can't iterate from Time \nand I'm getting\ncan't iterate from Time\nactivesupport-2.3.8/lib/active_support/core_ext/range/include_range.rb:24:in each'\nactivesupport-2.3.8/lib/active_support/core_ext/range/include_range.rb:24:ininclude?'\nactivesupport-2.3.8/lib/active_support/core_ext/range/include_range.rb:24:in include?'\nactivesupport-2.3.8/lib/active_support/core_ext/range/include_range.rb:24:ininclude_with_range?'\nchronic-0.2.3/lib/chronic/handlers.rb:350:in find_within'\nchronic-0.2.3/lib/chronic/handlers.rb:326:inget_anchor'\nchronic-0.2.3/lib/chronic/handlers.rb:219:in handle_r'\nchronic-0.2.3/lib/chronic/handlers.rb:224:inhandle_r_g_r'\nchronic-0.2.3/lib/chronic/handlers.rb:54:in block in tokens_to_span'\nchronic-0.2.3/lib/chronic/handlers.rb:50:ineach'\nchronic-0.2.3/lib/chronic/handlers.rb:50:in tokens_to_span'\nchronic-0.2.3/lib/chronic/chronic.rb:84:inparse'\n. Also, http://isitruby19.com/chronic reports:\nruby-1.9.2-head > Chronic.parse('3 months ago saturday at 5:00 pm')\nTypeError: can't iterate from Time \nand I'm getting\ncan't iterate from Time\nactivesupport-2.3.8/lib/active_support/core_ext/range/include_range.rb:24:in each'\nactivesupport-2.3.8/lib/active_support/core_ext/range/include_range.rb:24:ininclude?'\nactivesupport-2.3.8/lib/active_support/core_ext/range/include_range.rb:24:in include?'\nactivesupport-2.3.8/lib/active_support/core_ext/range/include_range.rb:24:ininclude_with_range?'\nchronic-0.2.3/lib/chronic/handlers.rb:350:in find_within'\nchronic-0.2.3/lib/chronic/handlers.rb:326:inget_anchor'\nchronic-0.2.3/lib/chronic/handlers.rb:219:in handle_r'\nchronic-0.2.3/lib/chronic/handlers.rb:224:inhandle_r_g_r'\nchronic-0.2.3/lib/chronic/handlers.rb:54:in block in tokens_to_span'\nchronic-0.2.3/lib/chronic/handlers.rb:50:ineach'\nchronic-0.2.3/lib/chronic/handlers.rb:50:in tokens_to_span'\nchronic-0.2.3/lib/chronic/chronic.rb:84:inparse'\n. ",
    "francis": "easy fix for the this:\n@ --- orig/gems/chronic-0.3.0/lib/chronic/handlers.rb  2010-05-03 14:42:38.000000000 -0500\n+++ fixed/gems/chronic-0.3.0/lib/chronic/handlers.rb    2010-07-28 11:18:24.000000000 -0500\n@@ -387,6 +387,10 @@\n       repeaters.sort.reverse\n     end\n\n+    def in_span?(span, t)\n+        t && span && t >= span.begin && t <= span.end\n+    end\n+\n     # Recursively finds repeaters within other repeaters.\n     # Returns a Span representing the innermost time span\n     # or nil if no repeater union could be found\n@@ -397,8 +401,7 @@\n       head, *rest = tags\n       head.start = pointer == :future ? span.begin : span.end\n       h = head.this(:none)\n-            \n-      if span.include?(h.begin) || span.include?(h.end)\n+      if in_span?(span, h.begin) || in_span?(span, h.end)\n         return find_within(rest, h, pointer)\n       else\n         return nil\n\n. Sorry - I meant to post a fix for that too, but came up with something different.  Maybe your approach is better though because I ended up patching active support:\n\n--- orig-activesupport-2.3.8/lib/active_support/core_ext/time/calculations.rb   2010-07-15 07:34:32.000000000 -0500\n+++ activesupport-2.3.8/lib/active_support/core_ext/time/calculations.rb    2010-07-28 11:26:14.000000000 -0500\n@@ -275,7 +275,7 @@\n          if ActiveSupport::Duration === other\n            other.since(self)\n          else\n-            plus_without_duration(other)\n+            plus_without_duration(other.to_f)\n          end\n        end\n\n. I think your way is better.  I found a similar patch in the chronic network graph of branches too.  Also, I found a better patch than my in_span? patch above.  I've merged than into the fork I make of your branch Aaron.\n. AaronH's fork is what we are using in production, and it has been working great with ruby 1.9.2-p0.\n. easy fix for the this:\n@ --- orig/gems/chronic-0.3.0/lib/chronic/handlers.rb  2010-05-03 14:42:38.000000000 -0500\n+++ fixed/gems/chronic-0.3.0/lib/chronic/handlers.rb    2010-07-28 11:18:24.000000000 -0500\n@@ -387,6 +387,10 @@\n       repeaters.sort.reverse\n     end\n\n+    def in_span?(span, t)\n+        t && span && t >= span.begin && t <= span.end\n+    end\n+\n     # Recursively finds repeaters within other repeaters.\n     # Returns a Span representing the innermost time span\n     # or nil if no repeater union could be found\n@@ -397,8 +401,7 @@\n       head, *rest = tags\n       head.start = pointer == :future ? span.begin : span.end\n       h = head.this(:none)\n-            \n-      if span.include?(h.begin) || span.include?(h.end)\n+      if in_span?(span, h.begin) || in_span?(span, h.end)\n         return find_within(rest, h, pointer)\n       else\n         return nil\n\n. Sorry - I meant to post a fix for that too, but came up with something different.  Maybe your approach is better though because I ended up patching active support:\n\n--- orig-activesupport-2.3.8/lib/active_support/core_ext/time/calculations.rb   2010-07-15 07:34:32.000000000 -0500\n+++ activesupport-2.3.8/lib/active_support/core_ext/time/calculations.rb    2010-07-28 11:26:14.000000000 -0500\n@@ -275,7 +275,7 @@\n          if ActiveSupport::Duration === other\n            other.since(self)\n          else\n-            plus_without_duration(other)\n+            plus_without_duration(other.to_f)\n          end\n        end\n\n. I think your way is better.  I found a similar patch in the chronic network graph of branches too.  Also, I found a better patch than my in_span? patch above.  I've merged than into the fork I make of your branch Aaron.\n. AaronH's fork is what we are using in production, and it has been working great with ruby 1.9.2-p0.\n. ",
    "AaronH": "This fixes part of it, but the problem still remains with can't convert Chronic::RepeaterTime::Tick into an exact number\nI was able to get it to work by updating the catch(:done) block in the next(pointer) function in repeater_time.rb replacing the all additions of @type with @type.time.  So, that section looks like: \nif pointer == :future\n          if @type.ambiguous?\n            [midnight + @type.time + offset_fix, midnight + half_day + @type.time + offset_fix, tomorrow_midnight + @type.time].each do |t|\n              (@current_time = t; throw :done) if t >= @now\n            end\n          else\n            [midnight + @type.time + offset_fix, tomorrow_midnight + @type.time].each do |t|\n              (@current_time = t; throw :done) if t >= @now\n            end\n          end\n        else # pointer == :past\n          if @type.ambiguous?\n            [midnight + half_day + @type.time + offset_fix, midnight + @type.time + offset_fix, yesterday_midnight + @type.time + half_day].each do |t|\n              (@current_time = t; throw :done) if t <= @now\n            end\n          else\n            [midnight + @type.time + offset_fix, yesterday_midnight + @type.time].each do |t|\n              (@current_time = t; throw :done) if t <= @now\n            end\n          end\n        end\n. Yeah, I looked at doing it that way but it seemed worse. \nIdeally, the to_f method on the Tick class would be called and that's all you'd have to do but it doesn't seem to work properly so calling the time element specifically seems to work.\n. fpauser, if you look at my fork that fixes it. http://github.com/AaronH/chronic\n. This fixes part of it, but the problem still remains with can't convert Chronic::RepeaterTime::Tick into an exact number\nI was able to get it to work by updating the catch(:done) block in the next(pointer) function in repeater_time.rb replacing the all additions of @type with @type.time.  So, that section looks like: \nif pointer == :future\n          if @type.ambiguous?\n            [midnight + @type.time + offset_fix, midnight + half_day + @type.time + offset_fix, tomorrow_midnight + @type.time].each do |t|\n              (@current_time = t; throw :done) if t >= @now\n            end\n          else\n            [midnight + @type.time + offset_fix, tomorrow_midnight + @type.time].each do |t|\n              (@current_time = t; throw :done) if t >= @now\n            end\n          end\n        else # pointer == :past\n          if @type.ambiguous?\n            [midnight + half_day + @type.time + offset_fix, midnight + @type.time + offset_fix, yesterday_midnight + @type.time + half_day].each do |t|\n              (@current_time = t; throw :done) if t <= @now\n            end\n          else\n            [midnight + @type.time + offset_fix, yesterday_midnight + @type.time].each do |t|\n              (@current_time = t; throw :done) if t <= @now\n            end\n          end\n        end\n. Yeah, I looked at doing it that way but it seemed worse. \nIdeally, the to_f method on the Tick class would be called and that's all you'd have to do but it doesn't seem to work properly so calling the time element specifically seems to work.\n. fpauser, if you look at my fork that fixes it. http://github.com/AaronH/chronic\n. ",
    "fpauser": "Have these problems too running chronic with ruby-1.9.2-p0...\n. The AaronH-Fork is used in whenever too. Runs fine in production.\n+1 for merging the AaronH fork\n. Had problems with Delorean too. The problem is long fixed as it seems - but the fix is not getting pulled-in... this really sucks!\n@Mange: Which progress?\n. Have these problems too running chronic with ruby-1.9.2-p0...\n. The AaronH-Fork is used in whenever too. Runs fine in production.\n+1 for merging the AaronH fork\n. Had problems with Delorean too. The problem is long fixed as it seems - but the fix is not getting pulled-in... this really sucks!\n@Mange: Which progress?\n. ",
    "fguillen": "I have these problems too, I have to use the AaronH fork.\n. I have these problems too, I have to use the AaronH fork.\n. ",
    "thrillcall": "It would be great if AaronH's fork were merged into mainline chronic.  This is causing issues that require ugly workarounds since now for example the Whenever gem is requiring aaronh-chronic as its dependency, and ultrasphinx gem requires just 'chronic' and the currently broken on 1.9.2 chronic seems to win.  Had to create my own fork of aaronh-chronic, rename it in the gemspec to 'chronic' and bring both copies (of the same code!) into bundler.  Please save us from the madness. ;-)\n. It would be great if AaronH's fork were merged into mainline chronic.  This is causing issues that require ugly workarounds since now for example the Whenever gem is requiring aaronh-chronic as its dependency, and ultrasphinx gem requires just 'chronic' and the currently broken on 1.9.2 chronic seems to win.  Had to create my own fork of aaronh-chronic, rename it in the gemspec to 'chronic' and bring both copies (of the same code!) into bundler.  Please save us from the madness. ;-)\n. ",
    "billc": "Has this been integrated to the master? I am receiving the 'iterate Time' error when parsing \"tomorrow at 7pm\". I tried to get the AaronH fork but getting the error\nSource does not contain any versions of 'chronic (>= 0, runtime)'\nSo I am perplexed. Using 1.9.2 Rails 3.0.3\nUpdate:\nI was able to get the AaronH fork working but would always rather work with the master branch. +1 for his fix.\n. Has this been integrated to the master? I am receiving the 'iterate Time' error when parsing \"tomorrow at 7pm\". I tried to get the AaronH fork but getting the error\nSource does not contain any versions of 'chronic (>= 0, runtime)'\nSo I am perplexed. Using 1.9.2 Rails 3.0.3\nUpdate:\nI was able to get the AaronH fork working but would always rather work with the master branch. +1 for his fix.\n. ",
    "samg": "I just noticed this \"Can't iterate Time\" issue to when testing a project of mine (which uses Chronic) for 1.9.2 compatibility. It would be great to get this fixed in a new gem release.\n. Makes sense.  Thanks.\nIn my case I can work around the issue pretty easily in the gemspec (https://github.com/samg/timetrap/commit/f21cda96b8a241651cb08681b44606445736a932).\nIt means that any users running on 1.8.7 won't get the benefit of version 0.10 (e.g. https://github.com/samg/timetrap/issues/74) but that seems pretty reasonable.  For most applications supporting Ruby 1.8 doesn't make much sense anymore, but it's nice to hear that future changes may make Chronic compatible with it again.\nThanks for the great work maintaining this awesome gem.\n. Thanks! Seems to work for me.  The timetrap test suite now executes successfully under 1.8.7 when using the head of chronic master.\nAny idea when this might be released?  I'll try to keep an eye out so I can update my gemspec once it's pushed out to rubygems.\n. I just noticed this \"Can't iterate Time\" issue to when testing a project of mine (which uses Chronic) for 1.9.2 compatibility. It would be great to get this fixed in a new gem release.\n. Makes sense.  Thanks.\nIn my case I can work around the issue pretty easily in the gemspec (https://github.com/samg/timetrap/commit/f21cda96b8a241651cb08681b44606445736a932).\nIt means that any users running on 1.8.7 won't get the benefit of version 0.10 (e.g. https://github.com/samg/timetrap/issues/74) but that seems pretty reasonable.  For most applications supporting Ruby 1.8 doesn't make much sense anymore, but it's nice to hear that future changes may make Chronic compatible with it again.\nThanks for the great work maintaining this awesome gem.\n. Thanks! Seems to work for me.  The timetrap test suite now executes successfully under 1.8.7 when using the head of chronic master.\nAny idea when this might be released?  I'll try to keep an eye out so I can update my gemspec once it's pushed out to rubygems.\n. ",
    "kevinrood": "+1 for merging AaronH's changes into master, or at least creating a Ruby 1.9.2 branch so that can be referenced in bundler directly like so:\ngem \"chronic\", \"0.3.9\", :git => \"https://github.com/mojombo/chronic.git\", :branch => \"ruby192\"\n. @antani, without using git, you can just do this for the time being in bundler:\ngem \"aaronh-chronic\", \"0.3.9\" # for ruby 1.9 compatibility\n. @antani, btw, you were mostly there with git, try this in bundler if you want it straight from git:\ngem \"aaronh-chronic\", \"0.3.9\", :git => 'https://github.com/AaronH/chronic.git' # for ruby 1.9 compatibility\n. +1 for merging AaronH's changes into master, or at least creating a Ruby 1.9.2 branch so that can be referenced in bundler directly like so:\ngem \"chronic\", \"0.3.9\", :git => \"https://github.com/mojombo/chronic.git\", :branch => \"ruby192\"\n. @antani, without using git, you can just do this for the time being in bundler:\ngem \"aaronh-chronic\", \"0.3.9\" # for ruby 1.9 compatibility\n. @antani, btw, you were mostly there with git, try this in bundler if you want it straight from git:\ngem \"aaronh-chronic\", \"0.3.9\", :git => 'https://github.com/AaronH/chronic.git' # for ruby 1.9 compatibility\n. ",
    "antani": "How do I install AaronH's fork ? my following Gemfile entry fails :\ngem 'chronic', '0.3.9', :git => 'git://github.com/AaronH/chronic'\nfails with the following error when I do 'bundle install'\nCould not find gem 'chronic (= 0.3.9, runtime)' in git://github.com/AaronH/chronic (at master).\nSource does not contain any versions of 'chronic (= 0.3.9, runtime)'\n. After upgrading to aarohn-chronic (via bundle install and later bundle update) I am getting follwing error:\nActionController::RoutingError (uninitialized constant CalendarsController::Chronic):\n  app/controllers/calendars_controller.rb:4:in <class:CalendarsController>'\n  app/controllers/calendars_controller.rb:1:in'\nDo I need to change my code with this change ?\n. I just upgraded to the latest version of chronic. \n. How do I install AaronH's fork ? my following Gemfile entry fails :\ngem 'chronic', '0.3.9', :git => 'git://github.com/AaronH/chronic'\nfails with the following error when I do 'bundle install'\nCould not find gem 'chronic (= 0.3.9, runtime)' in git://github.com/AaronH/chronic (at master).\nSource does not contain any versions of 'chronic (= 0.3.9, runtime)'\n. After upgrading to aarohn-chronic (via bundle install and later bundle update) I am getting follwing error:\nActionController::RoutingError (uninitialized constant CalendarsController::Chronic):\n  app/controllers/calendars_controller.rb:4:in <class:CalendarsController>'\n  app/controllers/calendars_controller.rb:1:in'\nDo I need to change my code with this change ?\n. I just upgraded to the latest version of chronic. \n. ",
    "Mange": "Adding myself to this Issue to get emails on any updates. Sorry for spamming you guys in the process. :-(\n. @fpauser: I was commenting; everyone got an email even though I had nothing to contribute. The word was \"process\", not \"progress\". Read my post again. ;-)\n. Adding myself to this Issue to get emails on any updates. Sorry for spamming you guys in the process. :-(\n. @fpauser: I was commenting; everyone got an email even though I had nothing to contribute. The word was \"process\", not \"progress\". Read my post again. ;-)\n. ",
    "hakanensari": "Hello folks. Likewise, just want to track updates.\nBumped into this when using Delorean, which relies on Chronic.\n@mojombo: You guys must be busy. It would be great if you added a contributor or two to maintain popular projects like this.\n. Hello folks. Likewise, just want to track updates.\nBumped into this when using Delorean, which relies on Chronic.\n@mojombo: You guys must be busy. It would be great if you added a contributor or two to maintain popular projects like this.\n. ",
    "pseidemann": "+1\n. +1\n. +1\n. +1\n. +1\n. +1\n. ",
    "bts": "+1. \"Fourty\" is incorrect. I've had to work around this issue in a project using Chronic.\n. +1. \"Fourty\" is incorrect. I've had to work around this issue in a project using Chronic.\n. ",
    "scanferla": "Hi @leejarvis,\nWould you know the best way to use Chronic in other languages nowadays?\nThanks in advance!\n. Hi @davispuh!\nAny updates? :)\nThanks in advance!\n. Great, thanks @davispuh! :)\n. Hi @leejarvis,\nWould you know the best way to use Chronic in other languages nowadays?\nThanks in advance!\n. Hi @davispuh!\nAny updates? :)\nThanks in advance!\n. Great, thanks @davispuh! :)\n. ",
    "luan": "@scanferla  https://github.com/mojombo/chronic/pull/113\n. Yes, I could just start the effort and let people know later, but it's best to know what everyone thinks and maybe know if someone would like to help or opine.\n. I will try to work a little more on this tonight, please le me know more about what do you think could be done better!\n. It shouldn't depend on Rails version to work, if you want it to work you have to put this lines in your Gemfile (for now):\nruby\ngem 'chronic', git: 'git://github.com/mojombo/chronic.git', branch: 'localization'\ngem 'chronic-l10n', '~> 0.0.1.pre.1'\n. Sure thing. Will try to do that today or tomorrow! Thank you.\nOn Friday, January 18, 2013, Lee Jarvis wrote:\n\n@luan https://github.com/luan Now I've refactored master a little I\nthink this might fit. Could you take a shot at rebasing things against\nmaster so we can merge and roll this out? Otherwise I'll take a shot at it\nwhen I have some spare time. [image: :metal:]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mojombo/chronic/pull/113#issuecomment-12412652.\n\n\nLuan Haddad Ricardo dos Santos\n. Ping @injekt\n. As the project description says:\n\nChronic is a pure Ruby natural language date parser.\n\nI don't think unix timestamps would be on that domain.\nMaybe you could write a wrapper yourself around both classes?\n. I was going to tell you to use simple strftime.\nBut what you are asking is a bit different. No chronic can't do that.\n. You still need the code changes I made back in the day to be able to use that side gem though.\n. @scanferla  https://github.com/mojombo/chronic/pull/113\n. Yes, I could just start the effort and let people know later, but it's best to know what everyone thinks and maybe know if someone would like to help or opine.\n. I will try to work a little more on this tonight, please le me know more about what do you think could be done better!\n. It shouldn't depend on Rails version to work, if you want it to work you have to put this lines in your Gemfile (for now):\nruby\ngem 'chronic', git: 'git://github.com/mojombo/chronic.git', branch: 'localization'\ngem 'chronic-l10n', '~> 0.0.1.pre.1'\n. Sure thing. Will try to do that today or tomorrow! Thank you.\nOn Friday, January 18, 2013, Lee Jarvis wrote:\n\n@luan https://github.com/luan Now I've refactored master a little I\nthink this might fit. Could you take a shot at rebasing things against\nmaster so we can merge and roll this out? Otherwise I'll take a shot at it\nwhen I have some spare time. [image: :metal:]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mojombo/chronic/pull/113#issuecomment-12412652.\n\n\nLuan Haddad Ricardo dos Santos\n. Ping @injekt\n. As the project description says:\n\nChronic is a pure Ruby natural language date parser.\n\nI don't think unix timestamps would be on that domain.\nMaybe you could write a wrapper yourself around both classes?\n. I was going to tell you to use simple strftime.\nBut what you are asking is a bit different. No chronic can't do that.\n. You still need the code changes I made back in the day to be able to use that side gem though.\n. ",
    "zenom": "He just updated the code 5 days ago, how is that vaporware, and I believe he did a release within the last couple weeks.\n. He just updated the code 5 days ago, how is that vaporware, and I believe he did a release within the last couple weeks.\n. ",
    "cpanderson": "Yes I see that but for at least one bug that's 8 months old it hasn't been addressed in the latest release and there a quite a few old bugs that haven't been addressed. \nDon't get me wrong, I'm happy that's it's still being developed on!\n. That's not really the point. I'm just wondering if Chronic is being worked on and bugs are being fixed. If not, then maybe I'll fork the project and fix the bugs or look for another solution. If so, great...I'll eagerly await the next release.\n. Yes I see that but for at least one bug that's 8 months old it hasn't been addressed in the latest release and there a quite a few old bugs that haven't been addressed. \nDon't get me wrong, I'm happy that's it's still being developed on!\n. That's not really the point. I'm just wondering if Chronic is being worked on and bugs are being fixed. If not, then maybe I'll fork the project and fix the bugs or look for another solution. If so, great...I'll eagerly await the next release.\n. ",
    "batasrki": "@cpanderson, are you unable to fix these bugs yourself?\n. Or, you could strike the middle and fix some bugs, make a pull request and become a contributor. This way you'd ensure that there IS a next release.\n. @cpanderson, are you unable to fix these bugs yourself?\n. Or, you could strike the middle and fix some bugs, make a pull request and become a contributor. This way you'd ensure that there IS a next release.\n. ",
    "dannyb": "I am running into a very similar problem.  In some cases it works fine, but under some situations it goes off by a day.  I created a gist showing the different scenarios that work and don't work. \nIt does appear to do with the switch of PST/PDT.\nhttps://gist.github.com/672230\n. I am running into a very similar problem.  In some cases it works fine, but under some situations it goes off by a day.  I created a gist showing the different scenarios that work and don't work. \nIt does appear to do with the switch of PST/PDT.\nhttps://gist.github.com/672230\n. ",
    "benpickles": "what a coincidence, i was just making this very change. you might as well namespace MiniDate while you're at it.\n. what a coincidence, i was just making this very change. you might as well namespace MiniDate while you're at it.\n. ",
    "slaxor": "hehe, great minds think alike, ok will do :)\n. very good, thanks\n. hehe, great minds think alike, ok will do :)\n. very good, thanks\n. ",
    "mferrier": "+1\n. +1\n. ",
    "sheuer": "+1\n. +1\n. ",
    "snovotny": "+1\n. +1\n. ",
    "dgm": "+1, this really confused me for a while.\n. I also see this:  \nChronic.parse(\"5/19/2011 01:10 pm\")\n => nil \n. +1, this really confused me for a while.\n. I also see this:  \nChronic.parse(\"5/19/2011 01:10 pm\")\n => nil \n. ",
    "joeellis": "+1\n. +1\n. ",
    "lukemelia": "A little more info on this: it only seems to be a problem when trying to parse times between 11am - 12pm and 11pm - 12am\n. A little more info on this: it only seems to be a problem when trying to parse times between 11am - 12pm and 11pm - 12am\n. ",
    "ahawkins": "This is present on version 0.2.3 and 0.3.0\n. I am not seeing the problem now either. I believe it's a time sensitive issue. When I was doing the testing, it was 11:15PM. After 12AM it worked correctly.\nruby-1.8.7-p302 > require 'rubygems'\n => true \nruby-1.8.7-p302 > require 'chronic'\n => true \nruby-1.8.7-p302 > Chronic.debug = true\n => true \nruby-1.8.7-p302 > Chronic.parse 'today'\n+---------------------------------------------------\n| this(grabber-this) day(repeater-day) \n+---------------------------------------------------\n-anchor\n--(Thu Dec 02 18:00:00 -0800 2010..Fri Dec 03 00:00:00 -0800 2010)\n--(Thu Dec 02 18:00:00 -0800 2010..Fri Dec 03 00:00:00 -0800 2010)\n => Thu Dec 02 21:00:00 -0800 2010 \nruby-1.8.7-p302 > Chronic.parse 'tomorrow'\n+---------------------------------------------------\n| next(grabber-next) day(repeater-day) \n+---------------------------------------------------\n-anchor\n--(Fri Dec 03 00:00:00 -0800 2010..Sat Dec 04 00:00:00 -0800 2010)\n--(Fri Dec 03 00:00:00 -0800 2010..Sat Dec 04 00:00:00 -0800 2010)\n => Fri Dec 03 12:00:00 -0800 2010 \nruby-1.8.7-p302 >\n. This is present on version 0.2.3 and 0.3.0\n. I am not seeing the problem now either. I believe it's a time sensitive issue. When I was doing the testing, it was 11:15PM. After 12AM it worked correctly.\nruby-1.8.7-p302 > require 'rubygems'\n => true \nruby-1.8.7-p302 > require 'chronic'\n => true \nruby-1.8.7-p302 > Chronic.debug = true\n => true \nruby-1.8.7-p302 > Chronic.parse 'today'\n+---------------------------------------------------\n| this(grabber-this) day(repeater-day) \n+---------------------------------------------------\n-anchor\n--(Thu Dec 02 18:00:00 -0800 2010..Fri Dec 03 00:00:00 -0800 2010)\n--(Thu Dec 02 18:00:00 -0800 2010..Fri Dec 03 00:00:00 -0800 2010)\n => Thu Dec 02 21:00:00 -0800 2010 \nruby-1.8.7-p302 > Chronic.parse 'tomorrow'\n+---------------------------------------------------\n| next(grabber-next) day(repeater-day) \n+---------------------------------------------------\n-anchor\n--(Fri Dec 03 00:00:00 -0800 2010..Sat Dec 04 00:00:00 -0800 2010)\n--(Fri Dec 03 00:00:00 -0800 2010..Sat Dec 04 00:00:00 -0800 2010)\n => Fri Dec 03 12:00:00 -0800 2010 \nruby-1.8.7-p302 >\n. ",
    "jwarchol": "I'm not seeing that:\n```\n\n\nChronic.debug = true\n=> true\nChronic.parse('tomorrow')\n+---------------------------------------------------\n| next(grabber-next) day(repeater-day) \n+---------------------------------------------------\n-anchor\n--(Fri Dec 03 00:00:00 -0500 2010..Sat Dec 04 00:00:00 -0500 2010)\n--(Fri Dec 03 00:00:00 -0500 2010..Sat Dec 04 00:00:00 -0500 2010)\n=> Fri Dec 03 12:00:00 -0500 2010\nChronic.parse('today')\n+---------------------------------------------------\n| this(grabber-this) day(repeater-day) \n+---------------------------------------------------\n-anchor\n--(Thu Dec 02 20:00:00 -0500 2010..Fri Dec 03 00:00:00 -0500 2010)\n--(Thu Dec 02 20:00:00 -0500 2010..Fri Dec 03 00:00:00 -0500 2010)\n=> Thu Dec 02 22:00:00 -0500 2010\nChronic::VERSION\n=> \"0.3.0\"\n```\n. Showing the output might be nice too ;-) : \n\n\nTime    Sun Aug 01 12:00:00 -0400 2010\nTime    Fri, 01 Aug 0010 12:00:00 UTC +00:00\n. I'm not seeing that:\n```\n\n\nChronic.debug = true\n=> true\nChronic.parse('tomorrow')\n+---------------------------------------------------\n| next(grabber-next) day(repeater-day) \n+---------------------------------------------------\n-anchor\n--(Fri Dec 03 00:00:00 -0500 2010..Sat Dec 04 00:00:00 -0500 2010)\n--(Fri Dec 03 00:00:00 -0500 2010..Sat Dec 04 00:00:00 -0500 2010)\n=> Fri Dec 03 12:00:00 -0500 2010\nChronic.parse('today')\n+---------------------------------------------------\n| this(grabber-this) day(repeater-day) \n+---------------------------------------------------\n-anchor\n--(Thu Dec 02 20:00:00 -0500 2010..Fri Dec 03 00:00:00 -0500 2010)\n--(Thu Dec 02 20:00:00 -0500 2010..Fri Dec 03 00:00:00 -0500 2010)\n=> Thu Dec 02 22:00:00 -0500 2010\nChronic::VERSION\n=> \"0.3.0\"\n```\n. Showing the output might be nice too ;-) : \n\n\nTime    Sun Aug 01 12:00:00 -0400 2010\nTime    Fri, 01 Aug 0010 12:00:00 UTC +00:00\n. ",
    "Weddingful": "Any chance of getting this change pulled in? I'm definitely running into this use case regularly.\n. Any chance of getting this change pulled in? I'm definitely running into this use case regularly.\n. ",
    "brianstarke": "+1 vote from me :)\n. nvm, found the trick :)\nruby-1.9.2-p0 > Chronic.parse 'current month first day'\n => 2011-01-01 12:00:00 -0500 \n. +1 vote from me :)\n. nvm, found the trick :)\nruby-1.9.2-p0 > Chronic.parse 'current month first day'\n => 2011-01-01 12:00:00 -0500 \n. ",
    "Phill": "+1 here\n. +1 here\n. ",
    "raldred": "I like this, I think it should be a wider feature though with configurable ranges and contexts\nI would like to be able to use last working week / next working week / 2 working weeks ago\nand be returned a range, not just of the 7 days previous like 'last week' does but actual working weeks monday-friday.\nChronic.parse 'last working week', :guess => false  it includes the weekend, maybe this is silently removing the 'working' part of my query\n. Hmm weird... yours indeed seems fine.\nOn Oct 2, 2011 11:56 PM, \"Lee Jarvis\" \nreply@reply.github.com\nwrote:\n\nOdd, I can't reproduce this.\n```\n\n\nTime.now\n=> 2011-10-02 23:55:20 +0100\nChronic.parse 'today'\n=> 2011-10-02 23:30:00 +0100\nChronic.parse 'tomorrow'\n=> 2011-10-03 12:00:00 +0100\nChronic.parse 'yesterday'\n=> 2011-10-01 12:00:00 +0100\n```\n\n\nI'm also on Lion, using 1.9.2 with Chronic 0.6.4\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/70#issuecomment-2267551\n. Can't seem to replicate this, will try again at a similar time this evening & reopen if still an issue.\n. I like this, I think it should be a wider feature though with configurable ranges and contexts\nI would like to be able to use last working week / next working week / 2 working weeks ago\nand be returned a range, not just of the 7 days previous like 'last week' does but actual working weeks monday-friday.\n\nChronic.parse 'last working week', :guess => false  it includes the weekend, maybe this is silently removing the 'working' part of my query\n. Hmm weird... yours indeed seems fine.\nOn Oct 2, 2011 11:56 PM, \"Lee Jarvis\" \nreply@reply.github.com\nwrote:\n\nOdd, I can't reproduce this.\n```\n\n\nTime.now\n=> 2011-10-02 23:55:20 +0100\nChronic.parse 'today'\n=> 2011-10-02 23:30:00 +0100\nChronic.parse 'tomorrow'\n=> 2011-10-03 12:00:00 +0100\nChronic.parse 'yesterday'\n=> 2011-10-01 12:00:00 +0100\n```\n\n\nI'm also on Lion, using 1.9.2 with Chronic 0.6.4\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/70#issuecomment-2267551\n. Can't seem to replicate this, will try again at a similar time this evening & reopen if still an issue.\n. \n",
    "belt": "Check out this project:\nhttps://github.com/asanghi/fiscali\n... it may help define what \"first quarter\" means.\n. Check out this project:\nhttps://github.com/asanghi/fiscali\n... it may help define what \"first quarter\" means.\n. ",
    "JeskTop": "I want to know, this issues was solved?\n. I want to know, this issues was solved?\n. ",
    "mkdynamic": "Review on #273 appreciated.\n. Agree, this implementation feels hairy :) Any ideas on a cleaner way?\n. Review on #273 appreciated.\n. Agree, this implementation feels hairy :) Any ideas on a cleaner way?\n. ",
    "evansagge": "+1\n. +1\n. ",
    "jeremywadsack": "How about last day of a month is first day of the next month minus one day? In other words, use the month day lookup that's built into ruby / the OS.\n. How about last day of a month is first day of the next month minus one day? In other words, use the month day lookup that's built into ruby / the OS.\n. ",
    "rurounijones": "That is what I ended up doing for that particular case instead of usng Chronic.\n. That is what I ended up doing for that particular case instead of usng Chronic.\n. ",
    "semperos": "It would also be great to have \"Last Monday in May\" logic (this is US Memorial Day).\n. Haven't looked into how you're parsing, but the word second at the beginning of the string should always be an ordinal number, not a reference to a unit of time.\nAgain, not familiar with what your parser fully supports, but I could foresee lots of possibilities: second day in january, second week in january, etc.\nI'm not sure what you want to support in the long run. As a consumer of the library, I'd even be happy with you forcing me to use 1st, 2nd, 3rd as opposed to their word-equivalents, as long as the behavior is consistent across the board. It's the element of surprise I'd like to avoid :)\n. Thanks for taking the time to enhance this.\n. It would also be great to have \"Last Monday in May\" logic (this is US Memorial Day).\n. Haven't looked into how you're parsing, but the word second at the beginning of the string should always be an ordinal number, not a reference to a unit of time.\nAgain, not familiar with what your parser fully supports, but I could foresee lots of possibilities: second day in january, second week in january, etc.\nI'm not sure what you want to support in the long run. As a consumer of the library, I'd even be happy with you forcing me to use 1st, 2nd, 3rd as opposed to their word-equivalents, as long as the behavior is consistent across the board. It's the element of surprise I'd like to avoid :)\n. Thanks for taking the time to enhance this.\n. ",
    "tamouse": "+1 for last weekday of month. Currently doing this:\nruby\nd = ((x = Chronic::parse(\"fifth Monday in May\")).nil?) ? (Chronic::parse(\"fourth Monday in May)) : x\n. +1 for last weekday of month. Currently doing this:\nruby\nd = ((x = Chronic::parse(\"fifth Monday in May\")).nil?) ? (Chronic::parse(\"fourth Monday in May)) : x\n. ",
    "jaredbrown": "+1 for last weekday of month\n. +1 for last weekday of month\n. ",
    "timfong888": "+1 last day of the month\n. +1 last day of the month\n. ",
    "kovpack": "+1 last day of the month\n. +1 last day of the month\n. ",
    "shrav": "+1 last day of the month\n. +1 last day of the month\n. ",
    "zedtux": "+1. Here is how I did it based on @jeremywadsack's comment:\nruby\nChronic.parse('1st day next month') - 1.day. +1. Here is how I did it based on @jeremywadsack's comment:\nruby\nChronic.parse('1st day next month') - 1.day. ",
    "cmhobbs": "Outstanding, thanks for the update.  I'll keep using the original syntax for now.\n. Outstanding, thanks for the update.  I'll keep using the original syntax for now.\n. ",
    "geetarista": "I'm having this same issue. Any workaround for this?\n. I'm having this same issue. Any workaround for this?\n. ",
    "somebox": "confirmed, ruby 1.8.7. Pegs cpu at 100%. Pretty scary stuff.\n. confirmed, ruby 1.8.7. Pegs cpu at 100%. Pretty scary stuff.\n. ",
    "twalpole": "For information: This was reproducible with  Chronic.parse(\"summer\", :now=>Time.parse(\"Dec 22, 2010\"))  and would occur with any date in December that was outside of a range it was being compared to (MiniDate#is_between?) if the ranges end date was in December\n. It should assuming the platform has at least microsecond accuracy\n. ok -- I simplified the patch, put :now back into DEFAULT_OPTIONS and override it with current time if its nil.  Can't use options.fetch(...) because that would never allow for override of the :nil .  I also added a sleep 1 into the test to remove the need for microsecond support from the Time class\n. This fixes the hang issue but potentially brings in other problems.  You should probably never have  % 13 in something dealing with months because that allows for a 0..12 range rather than the 0..11 or 1..12 range you probably want.  I've submitted a separate pull request that fixes this issue, as well as another one I found, and adds tests\n. I believe this is caused by commit 58e13008a0c9f6f0619a  in ruby < 1.9,  since the order things are matched against is now dependent on hash order.  Since hash order is not guaranteed in ruby < 1.9, in my case the :anchor  matches are getting checked before the :date matchers and causing the failure\n. Thanks -- that fixed the issue I was having\n. For information: This was reproducible with  Chronic.parse(\"summer\", :now=>Time.parse(\"Dec 22, 2010\"))  and would occur with any date in December that was outside of a range it was being compared to (MiniDate#is_between?) if the ranges end date was in December\n. It should assuming the platform has at least microsecond accuracy\n. ok -- I simplified the patch, put :now back into DEFAULT_OPTIONS and override it with current time if its nil.  Can't use options.fetch(...) because that would never allow for override of the :nil .  I also added a sleep 1 into the test to remove the need for microsecond support from the Time class\n. This fixes the hang issue but potentially brings in other problems.  You should probably never have  % 13 in something dealing with months because that allows for a 0..12 range rather than the 0..11 or 1..12 range you probably want.  I've submitted a separate pull request that fixes this issue, as well as another one I found, and adds tests\n. I believe this is caused by commit 58e13008a0c9f6f0619a  in ruby < 1.9,  since the order things are matched against is now dependent on hash order.  Since hash order is not guaranteed in ruby < 1.9, in my case the :anchor  matches are getting checked before the :date matchers and causing the failure\n. Thanks -- that fixed the issue I was having\n. ",
    "naturalethic": "Were you able to resolve this?  I've just encountered the problem as well.\n. I went with aaronh-chronic, but thanks for this link!\n. Were you able to resolve this?  I've just encountered the problem as well.\n. I went with aaronh-chronic, but thanks for this link!\n. ",
    "scottvrosenthal": "I ended up using this gem: https://github.com/adzap/timeliness\n. This was reopened at the request of @painteddigital, hope you get your issue resolved.\n. I ended up using this gem: https://github.com/adzap/timeliness\n. This was reopened at the request of @painteddigital, hope you get your issue resolved.\n. ",
    "painteddigital": "@ezcoder, could you reopen this issue? It is still unresolved. Chronic does not support Ruby 1.9.2 when I rolled back to 1.8.7, this issue went away. Annoying, but I really like the gem.\n. @ezcoder, could you reopen this issue? It is still unresolved. Chronic does not support Ruby 1.9.2 when I rolled back to 1.8.7, this issue went away. Annoying, but I really like the gem.\n. ",
    "shawnpyle": "Looks like this broke in v8.0.\nirb> Chronic.parse 'current month first day'\n=> nil\nruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-darwin10.8.0]\n. Looks like this broke in v8.0.\nirb> Chronic.parse 'current month first day'\n=> nil\nruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-darwin10.8.0]\n. ",
    "fare5": "@injekt\ndoe's it \" works for you?\nChronic.parse(\"1st day of this month\", :guess => false)\n=> Wed May 22 00:00:00 +0200 2013..Thu May 23 00:00:00 +0200 2013\nruby 1.8.7 (2012-10-12 patchlevel 371) [x86_64-linux]\nchronic (0.9.1)\n. @injekt\ndoe's it \" works for you?\nChronic.parse(\"1st day of this month\", :guess => false)\n=> Wed May 22 00:00:00 +0200 2013..Thu May 23 00:00:00 +0200 2013\nruby 1.8.7 (2012-10-12 patchlevel 371) [x86_64-linux]\nchronic (0.9.1)\n. ",
    "davispuh": "looks like a bug :P\n. that's because of DST, currently no support for it, there's loads of such issues #147, #177, #179, #222, #228, #282 \nthey all will be probably fixed once DST is properly implemented.\n. Seems to be fixed, atleast works for me\nirb> Chronic.parse('0000')\n=> 2013-08-23 00:00:00 +0300\nirb> Chronic.parse('1200')\n=> 2013-08-22 12:00:00 +0300\nirb> Chronic.parse('0000', {:context => :past })\n=> 2013-08-22 00:00:00 +0300\nirb> Chronic.parse('1200', {:context => :past })\n=> 2013-08-22 12:00:00 +0300\n. I was working to improve Chronic support for different date/time formats and get rid of all those regexp hacks. It all went well at start until I had to deal with Timezone parsing. Chronic doesn't really have much logic for Timezone parsing and it defers it to Time.parse so you can't parse any Timezone strings that's not supported by Ruby and Ruby have very poor timezone support. So right now I'm creating new separate gem which will parse Timezones and it will support all locales from CLDR out of box. Then later after might also add CLDR support for Chronic and won't be any need for users to translate anything as it's already done by CLDR guys.\n. yeah, well sorry it's taking quite a lot of time as I've other projects also ongoing and there's never enough time. Anyway I just now pushed TimezoneParser. It's not finished yet and usually I don't like to publish stuff until it's more completed but I had to show :D So basically it's almost done and currently implemented parts are fully working, including tests. Only this is kinda alpha version as I'll change few things and will do various improvements. Also have to write documentation and more tests. Still I would suggest to check it out ;) I'm pretty proud myself lol as it have very good functionality (as example timezone_spec.rb).\nI'm not sure when I'll finish TimezoneParser fully, but it probably will be quite soon as there aren't much left to do. Then after I'll continue to work on some Chronic things, but that will take some not so short while. Basically I would say that you should contribute yourself if you need it. My idea about localization is that there would be different gem which uses CLDR data to parse those strings and Chronic uses it. Same like it will be with TimezoneParser.\n. I've finally finished TimezoneParser yey :) also documented most of methods and pushed gem. It works perfectly and I don't have any plans for new features unless there will be something missing. But there's one bad thing and I'm not sure how to resolve it. It's slow to load timezone data from files to memory. It's only one time cost but for all data files it takes 4-5 seconds and I think that's a lot, it's 6 MiB of text (all languages). Using only abbreviations it still takes 1 second (1 MiB file). I'm using Ruby's marshal which is fastest serialization, but still not enough in this case. Maybe using some custom made binary format would be faster, not sure. Another way would be to create separate files for each locale, but that wouldn't work for abbreviations anyway. Also there can be cases when you've no idea what language you're parsing and then I guess it might be slower to load all files separate. Anyway I would appreciate any reviews, PRs and improvements.\n. Some while ago I started working on quite big rewrite, see #278 and there in that PR this is fixed along with a lot of other things, but it's nowhere close to be ready. It's basically early early alpha :D\nbut there\nruby\nChronic.parse('13/10/2014 8:00 UTC', :guess  => :begin)\n=> 2014-10-13 08:00:00 +0000\nso yeah, some day all Chronic bugs will be fixed ;)\n. I'm still waiting for PRs to be reviewed by @leejarvis some could be merged, but this isn't my lib so I'm waiting ;)\n. it's because gemspec includes whole chronic and thus you get this exception because you don't have numerizer gem, it's fixed in #262 but currently you can just gem install numerizer\n. now and time_class are different options. You specify now to tell Chronic at which time it should treat things like \"Today\", \"Tomorrow\" etc., but with time_class you specify which Time class you want output to be in, eg. Time or Date class\nEDIT: So I think correct behavior would be that when parsing 'Today at 5pm' it would use same Timezone as used for now option for parsing/input, but output would be in Timezone which is for time_class\n. why this haven't been merged? works good :P\nbut it could be improved, seems there have been changes in MiniTest (I've v5.0) and it throws error.\nN:\\Projects\\chronic>rake test\nWarning: you should require 'minitest/autorun' instead.\nWarning: or add 'gem \"minitest\"' before 'require \"minitest/autorun\"'\nFrom:\n  P:/Ruby193/lib/ruby/1.9.1/minitest/autorun.rb:14:in `<top (required)>'\n  N:/Projects/chronic/test/helper.rb:6:in `<top (required)>'\n  N:/Projects/chronic/test/test_chronic.rb:1:in `<top (required)>'\n  N:/Projects/chronic/Rakefile:10:in `block (2 levels) in <top (required)>'\n  N:/Projects/chronic/Rakefile:10:in `each'\n  N:/Projects/chronic/Rakefile:10:in `block in <top (required)>'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:236:in `call'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:236:in `block in execute'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:231:in `each'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:231:in `execute'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:175:in `block in invoke_with_call_chain'\n  P:/Ruby193/lib/ruby/1.9.1/monitor.rb:211:in `mon_synchronize'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:168:in `invoke_with_call_chain'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:161:in `invoke'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:149:in `invoke_task'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:106:in `block (2 levels) in top_level'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:106:in `each'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:106:in `block in top_level'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:115:in `run_with_threads'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:100:in `top_level'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:78:in `block in run'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:165:in `standard_exception_handling'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:75:in `run'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/bin/rake:33:in `<top (required)>'\n  P:/Ruby193/bin/rake:23:in `load'\n  P:/Ruby193/bin/rake:23:in `<main>'\nMiniTest::Unit.autorun is now Minitest.autorun. From P:/Ruby193/lib/ruby/1.9.1/m\ninitest/autorun.rb:18:in `<top (required)>'\nRun options: --seed 19834\nif I add gem \"minitest\" in ./test/helper.rb#6 before require 'minitest/autorun' then there's no more error.\n. yup, there's been regression and there's no test case for it.\nChronic.parse('30-07-2013') # works in 8.0, but not in current master\n. actually it's very easy, just have to be more precise when writing regexp ;) will do PR in 5mins.\n. Done!\nI'm just used to camelCase and for that exception I followed previous code like it was, but improved now ;)\n. hmm, seems there's merge conflict because @current_time from merged PR (ruby-warnings)\n. I just did rebase before reading your reply. I think should be fine without squashing ;)\n. yeah, sorry didn't thought about such format (it's caused by #196), but there wasn't any tests for this anyway, so I would suggest for everyone if you use some format which does work correctly then send PR with test case for that format if there isn't such currently ;) also BTW did you know that before #195 milliseconds weren't parsed :P\nI'll send PR with a fix in a hour :)\n. done, sorry it took so long, got busy with other things...\n. I'm no sure if this is good idea, if you need such functionality you can just write in your own code\nruby\nChronic.parse \"3rd thursday this november\", :now => Chronic.parse(\"1/10/2010\")\nalso this way you can pass more options and such, what if that passed date couldn't be parsed or would return Chronic::Span\nwhile it doesn't really affect typical cases using Time, I don't see why it should be integrated as like I said you can easily specify in own code.\n. yeah actually I had same idea, but currently I've started to change few other things. Basically need to add hours24 option to Parser, if it's true then force interpreting hours as they would be 24 hour clock, if it's false then force 12h clock if it's any other value (eg. nil) then keep current behavior as somewhat smart guess...\n. well, naming that's the hardest part :D\nI don't know what would be best name. Here some more: :force24h, :force_hours24, :clock24h, :force_24h_clock, :time24h, :time_clock24h\nI'll commit changes when option name is chosen.\n. any ideas about that option name?\n. Nice :)\nthere wasn't any conflicts, but I still rebased. So it should merge fine.\nabout next PR, I'm currently thinking how to properly implement timezone parsing. This current implementation doesn't actually parse it at all and just pass it to generic Time.parse, but I've successfully implemented all parsing so Time.parse is not needed at all with only exception being timezones. With my googling I didn't find way to convert timezone abbreviations/names to offsets (in Ruby it's hardcoded /ext/date/date_parse.c#L341 and not exposed outside) so I'm thinking to create separate gem which does that and add dependency on it. Also then it would be possible to offer support for timezone names in different languages.\n. I don't really need commit access. Just when I started reviewing this I noticed how poorly (IMHO) some things are implemented that I wanted to fix it once and for all :D So basically idea is that you would throw in any commonly used date/time format and it would parse it successfully.\n. It appears that TZ database includes even abbreviations. And they can be accessed from TZInfo gem, only thing is that different abbreviations were used at different times so one can represent multiple offsets depending at which time and in which country you're in. I quickly generated all abbreviations to possible offsets gists/TimezoneAbbr_To_Offsets.yaml\n. I've been working to fix lot of things in Chronic, but it's taking more time than I thought it will and I still haven't finished yet. There will be  Chronic::parse, Chronic::parse_time and Chronic::parse_date that would solve this issue with :ambiguous_number_priority, but won't be soon...\n. I've also fixed issue with :guess allowing it to be more flexible as most people wouldn't think that guess means middle of span, but would rather want 00:00. I'll look if I can cherry-pick some my changes without breaking tests and send PR\n. you mean HISTORY.md right? sure :)\nthere will be atleast one more PR with quite big changes, but it will fix lot of things and yeah it would be good to have version before those changes.\n. The goal was to remove all time_class.local (not done yet) and use everywhere Chronic.construct which will support Time, Date, DateTime they all have new. I wasn't aware that ActiveSupport::TimeZone doesn't implement new but I think they should, because all  those mentioned classes does support it. I might send PR to them.\n. hmm, actually seems will have to figure something else, because Time.zone is already initialized and constructor differs very because it's TimeZone not expected Time/Date class\n. reason for new versus local was that each of classes (Time, Date, DateTime) they're a bit different but new is almost same for all.\n. oops, actually I'm talking crap here. This current implementation would support only Time anyway.\nDate can't be used if we need time\nfor DateTime there's no local and for Time.local we can't set offset that's why I used new there.\n``` ruby\nTime.new(year, month=nil, day=nil, hour=nil, min=nil, sec=nil, utc_offset=nil)\nDateTime.new([year=-4712[, month=1[, mday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])\nTime.local(year, month, day, hour, min, sec, usec_with_frac)\nno such DateTime.local\n``\n. seems probably most easiest way would be check fortime_classtype and then use corresponding method as I want to set offset correctly, but only way is withnewand we don't need set offset forActiveSupport::TimeZone` so will make that special case, I can do PR within 30mins.\n. Sorry. Done :)\n. Maybe they weren't working only I thought they were. Sometimes Ruby can be confusing. It's nice that someone does code review, thanks. Also tests are must have. Currently coverage ~96% but after I'll be done with main changes, will need to make 100%\n. It's not yet supported, but this does work\nruby\nChronic.parse('monday of the month at 9am')\n=> 2013-08-05 09:00:00 +0300\n. It's caused by at midnight it assumes next midnight :smile: \nwith 00:00 it does work.\nruby\nChronic.parse('thursday of the month at 00:00')\n=> 2013-09-05 00:00:00 +0300\nChronic.parse('thursday of the month at 12:00')\n=> 2013-09-05 12:00:00 +0300\n. It's caused by 648c61e2e0d8b61a3f5b0d47fb6a80815d4ea28b (#192, #196, #198, #200)\nbecause Regexp's positive lookbehind is used there and it's only available Ruby >= 1.9\nSadly with current implementation I don't see how we could parse such format without making even more worse hacks. So probably I would say easiest way would be just lock to < 0.10 if you need Ruby 1.8 support. Or could create separate branch without that line.\nActually I'm in progress to change lot of parsing related parts and then there won't be such Regexp's. It will be much cleaner way, but it's not yet ready and will take some time. If I'll be lucky then it might be done before end of this month, but can't promise anything.\nI test only on Ruby 1.9.3 and 2.0.0 as I don't really intend to support anything below, but mostly there's very high chance it will still work even on Ruby 1.8. If it won't then depending which features are used it might be very easy to remove them to still be compatible.\n. I'm not maintainer BTW :D I just decided to fix some things as currently this seems top used gem for parsing date/times but for some formats it doesn't really have good support and I'm going to change that :)\n. I would say it's up to you, choose direction ;) Maybe it would be possible to use something* that's still compatible but I don't know. And making more than minor changes isn't worth currently. Actually I knew that lookbehind isn't available in 1.8 but I didn't really thought about it as fixing broken parsing seemed more important and so my bad. Also who still uses 1.8 anyway :smile: \n*for example there's ruby 1.8 gem for regexp which does support lookbehind\nor some other hacks\nor anything you can think of, Ruby 1.8 specific workaround code.\nIt can be used temporarily and removed once I finish these changes I've started as like I said they'll be compatible most likely.\n. Now it should be compatible with Ruby 1.8.7\nYou can try it right from git with Bundler\nIf you find some issues please let us know.\n. That depends on @leejarvis when he'll release.\n. It worked :) But I changed to other way as I realized it could be done even better :P also I just tried on Ruby 1.8.7 and its Time.new doesn't accept any parameters so had to add another fix.\nAll tests pass for 1.9.3 and 2.0.0, but for 1.8.7 everything works except 3 tests fail because two of them use Time.new with parameters (test_chronic.rb#136, test_parsing.rb#39) and one uses date range which isn't supported in 1.8 (test_parsing.rb#355)\nI think it's not worth changing tests and with this PR we still have compatibility with 1.8 :)\n. Actually there I made bug but none of tests caught it. Also I noticed that there's another different bug not related to 1.8 and I fixed that too. Added one test so finally this part should be bugfree.\n. There wasn't any changes (between 0.10.0 vs 0.10.2) which would affect this, most likely it's issue with that specific date/time it was when you tried.\n. irb\nirb(main):009:0> Chronic::VERSION\n=> \"0.10.0\"\nirb(main):010:0> Chronic.parse(Time.now.to_s)\n=> 2013-09-11 14:50:25 +0300\nirb(main):011:0> Chronic.parse(Time.now.to_s)\n=> 2013-09-11 14:50:27 +0300\nirb(main):012:0> Chronic.parse(Time.now.to_s)\n=> 2013-09-11 14:50:28 +0300\nlike I said it's probably something with your specific format.\nfor me Time.now.to_s returns \"2013-09-11 14:52:36 +0300\" but on other machine it's \"Tue Sep 10 21:49:13 -0700 2013\" and that's very different...\n. oh LOL, there indeed was bug with negative timezone, I fixed it in 0.10.2 so yeah...\n. Seems good. :+1: \n. Probably Chronic.debug should also be per-thread.\n. Well I think thread safety is needed. To allow configuration, could create global_time_class which would be class variable thus global then there would be time_class which would return global_time_class if current thread's time_class isn't set. And then of course also possible set it as option to .parse\nit could be like this\n``` ruby\nclass << self\n    def global_time_class\n      @@global_time_class || ::Time\n    end\n    def global_time_class=(time)\n      @@global_time_class = time\n    end\ndef time_class\n  Thread.current[:__Chronic_time_class] || global_time_class\nend\ndef time_class=(time)\n  Thread.current[:__Chronic_time_class] = time\nend\n\nend\n```\nthen global_time_class would be on whole app while still allowing to set per-thread if have such need.\nAs for debug could do same, it's minor change and maybe for some cases it might be useful to debug only single thread.\n. > However, I do still believe that we should allow setting the time class per Parser instance\nI'm not saying we shouldn't, it's a must have.\nThat global class variable would be just extra. But maybe not really needed then, I just like very customizable software so to fit everyone needs :laughing:\n. you probably wanted to reply to #203, not create new issue.\n. :+1: This is good, thanks :)\n. I think this can be merged, @leejarvis ?\n. yup. I added it to .gemspec a while ago with eb912a6 \n. Do you have MiniTest 5?\n. This warning is only for Ruby 1.9, but not for 2.0 I'm not really sure about details why and what. But basically it's just warning and tests does work fine. If would use bundler (ie. bundle exec rake test) then there wouldn't be this warning as it would automatically load gems.\n. yeah, I know, it's because 2 of those tests use Time.new with parameters and Ruby 1.8 doesn't support that. Also for me there's another 3rd test failing because of unsupported date range for 1.8. But these are only test faults and all Ruby 1.8 apps which use this gem will work fine.\n. I'm not really sure if there's much point of it, because Ruby 1.8 is EOL and won't be supported by Chronic v0.11. That's also reason why I didn't bothered with this. Also your implementation is quite overwhelm I would say. The way how Ruby converts string to float can be used to simplify this to RUBY_VERSION.to_f < 1.9 (because \"1.8.7\".to_f will return 1.8)\nOf course this could be added now, but basically I would say that everyone should upgrade and move away from 1.8\nEDIT: Also even better would be just use 1.8 compatible way. That is instead of Time.new use Time.local that will work in both.\n. It's not really a bug, that's how chronic works, end is exclusive limit, meaning that all dates/times right before it are inside interval but not this end limit.\nTo achieve what you want is very simple, just\n``` ruby\n\nChronic.parse( '9/30/2013', guess: false ).end - 1\n=> 2013-09-30 23:59:59 +0930\n```\n\nend in chronic is exclusive, because otherwise it wouldn't work for milliseconds or for even smaller units. Now with current implementation it will work correct.\n``` ruby\n\nfor '10/1/2013' unix timestamp is 1380661200.0\n1380661199.999999 < Chronic.parse( '10/1/2013', guess: false ).end.to_f\n=> true\n```\n. That is bug indeed. I was saying about end limit itself as it contains correct value. But yeah Range should be created as excluding limit when that's the case.\n. It's happening because of DST change on 27th October and Chronic isn't regarding that. It assumes there's always 24h hours in a day, but it wont be the case for 27th October, then clocks will be turned 1 h back and same hour will appear twice thus making it 25h day and so all next weeks calculation will be off by 1h. This bug won't happen after DST is changed or if you look for times before change.\n\nEDIT: Here you can see lib/chronic/repeaters/repeater_weekday.rb#L38\nEDIT2: Actually no, it's this lib/chronic/repeaters/repeater_week.rb#L32 length of week...\n. Why would I close this... It is a bug and definitely needs to be fixed some day.\n. It works fine for me.\n``` ruby\n\nChronic.parse(\"today at midnight\", :now => Time.mktime(2013, 11, 3))\n=> 2013-11-04 00:00:00 +0200\n```\n. When date is parsed and time is not specified for chronic then returned time is pretty much undefined I would say. It's not really clear what it should be, at various places it's used differently.\n\nAnyway I would suggest take only date part:\n``` ruby\n\nChronic.parse('today').to_date.to_s\n=> \"2013-11-01\"\nChronic.parse(Time.now.to_date.to_s).to_date.to_s\n=> \"2013-11-01\"\nChronic.parse('today').to_date == Chronic.parse(Time.now.to_date.to_s).to_date\n=> true\n```\n. All those 3 cases aren't supported by Chronic. Chronic assumes noon means 12:00 thus your case 12:00 noon doesn't make any sense. You should use 12:00 PM\n\nAlso Jan 1, 12 noon works only because Chronic takes 12 as year 2012\n. Well some things in Chronic are implemented kinda random (I would say) and if you use midnight it will take it as next days midnight, eg. Jan 1, midnight will return 2nd Jan 00:00. So best would be to use Jan 1, 12:00 AM or Jan 1, 00:00\nChronic can parse various formats like Jan 1, noon, 1st Jan noon, 1st Jan at noon, 1st Jan midnight, 1st Jan at midnight but results might not be what you expect. There's really no any spec or doc which says what should be values for various cases. Chronic specification are tests that are written and everything else is pretty much undefined. I'm not creator of this gem and IMO there were made some bad design decisions.\nThis is how I see Chronics internals and behavior in some cases...\n\nOkay, maybe it's not that bad, but it still requires some fixing.\n. I don't know. Based on current implementation, no it's not going to work. Chronic sees it as Jan 1, 12:00 12:00\n. Well, I personally prefer this way. Use ' everywhere and \" only where it's necessary. But it's not really big deal. Mostly it's just personal preference and everyone feels there differently. What is important is consistent style. That's needed no matter which style is used.\n. It uses :context => :future by default so it looks in future (ie. next week), it can be set to :past but that would return previous one. Seems Chronic's design haven't thought about this case and there's no :present currently.\nYou can workaround it by adding this week\nruby\nChronic.parse(\"Monday\"+\" this week\", now: Time.now)\nAlso Chronic by default uses Time.now when now is not specified so it's not required.\n. I can't reproduce, it works fine for me. Most likly something with your timezone/environment. Could you provide more details (timezone, ruby, platform)? And try with newest Chronic 0.10.2\n. Seems same as #177 and #179 caused by DST change on that day. Currently Chronic doesn't have any real support for daylight time changes. Also related bugs: #222 #147\n. There haven't been any updates regarding this issue, so it's not fixed.\n. Chronic.parse(\"T\") this is bug, it should return nil not throw exception.\nChronic.parse('2011 May 09 to 2011 June 28') this is just unsupported, but still it shouldn't raise exception. It's unsupported firstly because Chronic parses only discrete times not intervals. Secondly such format 2011 June 28 isn't implemented at all.\n. I'm not sure if Chronic is right gem for this kind of functionality. Chronic has always parsed only discrete times and not durations. Durations are parsed with chronic_duration gem\n. Also I don't think it's good idea to use minutes, it doesn't matter what you've to display to user, but most people would expect to keep seconds internally and to show only minutes would just secs / 60\n. CD also parses natural texts, for example\nChronicDuration.parse('I drank 15 beers in 3 and a half hours')`\n=> 12600.0\nMost of these tests does pass for CD and I think it might be very useful to improve CD even more if you need some specific features (eg. Span for CD). Primarily because Chronic just isn't really meant for it and then when there will be need for more duration features we'll have to reimplement lot of stuff that's already in CD. Anyway it's up to @leejarvis\nAnother thing, I think that pre_normalize part (even in parser.rb) probably should be made in other gem like datetime_normalize or maybe numerizer could implement that functionality as it's quite often required and currently everyone just reimplements it themselves. Also I think that should remove numerizer code from Chronic and just use numerizer gem as CD already uses it.\n. that would be useful functionality and would fit fine for Chronic, but I don't see how that's related to this Minutizer. When you parse such duration, it would return Span and with that can easily get length in seconds. Only currently Chronic doesn't really have any real support for such parsing, but for that feature :+1:  if you implement.\n. It does make sense. And if \"next 3 hours\" returns span then yes it's fine for Chronic. Also Minutizer isn't really needed, because Chronic already have somewhat duration support internally, for example Chronic parses \"after 3 hours\" fine. So what I mean, Chronic shouldn't expose such functionality outside and use durations only internally which it already does (take a look at repeaters). Basically such  span processing should happen same as typical parse - first we split input text in tokens, then we process each token and do rest stuff, etc. So we don't need Minutizer as we already have tokens ready for processing and that's why I'm saying Minutizer isn't good fit here but rather CD. Also Chronic support for durations is very poor as it's not DST aware (here's several issues opened about it) and should be reimplemented completely. For next week it uses week_start + WEEK_SECONDS and your Minutizer doesn't do any better. Besides seems digitize_time is kinda dublicate/same as those day/week/etc repeaters. It would be very useful to create new class ChronicDuration which would implement it all properly rather than your Minutizer.\n. No, no, don't do it in pre_normalize, it's really total hack because people couldn't implement things properly. All pre_normalizeshould actually be removed some day. Correct way to handle it would be when text is split in tokens and then processed as special holiday/season token. This is exactly reason why you can't implement \"next xmas\" with this way, because it's total hack. There's already too many hacks in this lib. And yeah I hate hacks :smile: \n. Implementing it in pre_normalize isn't good idea, because let's say we want to add feature to parse date for \"next Easter\" (or \"Easter 2015\"). Good luck figuring it out with regexp, because you just can't. Easter aren't on fixed date and will be different each year. If we've special token for it, we can calculate it when processing, but not earlier when we haven't parsed anything.\nI'm always going for proper implementations as then can easily extend to support more features, of course it takes more time to develop, but it's worth it. And mostly these quickly hacked up things have to be refactored/reimplemented later again when for example need just add some feature. Especially like now you can easily predict that there probably will be need for other dates too. And just imagine what will happen with pre_normalize if we'll keep adding 20+ other dates and more.\nProper way would be to use holidays gem then we don't have to think about dates at all as it already have them along with names (even for other languages/countries). So basically idea is that we create new token type, use that gem to match holidays and convert them to respective dates. Also probably because not everyone needs such feature so could use do_stuff if defined?(Holidays) so those who need this would just include gem.\n. Looks good :+1: but seems you also included unrelated things: duration.rb, test_parsing_span.rb, test_spanify.rb\n. \"Last Saturday in March\" is just not supported format by Chronic as it doesn't recognize \"Last\" and those other formats aren't really either, it's more of a luck that some work.\nIf you need such feature, you could try debug and implement it.\n. It also crashes on Chronic.parse(\"t\")\n. Was added in #267 and is merged in beta branch\n. it's because for this specific format Chronic expects 3 digits for milliseconds and not less or more, but yeah it should be fixed some day.\n. Nice :+1: , that clearly is a bug, it shouldn't modify state.\n. fixed with #255 as  774a66a\n. similar bug there in test_parse_guess_r starting from #526 line\nruby\n   time = parse_now(\"5\")\n   assert_equal Time.local(2006, 8, 16, 17), time\n5pm, hour is specified, thus it means it's hour precision for span and so dividing it we should get 30 seconds, eg. Time.local(2006, 8, 16, 17, 30)\nseveral next calls also should be with 30s\nand then there's bug with \n``` ruby\n    time = parse_now(\"13:45\")\n    assert_equal Time.local(2006, 8, 17, 13, 45), time\ntime = parse_now(\"1:01pm\")\nassert_equal Time.local(2006, 8, 16, 13, 01), time\n\n```\n1pm is before 14:00, thus because we look in future date it should be 17th not 16th. See how when using 13 instead of 1pm it works correctly.\nIt's funny how these tests test incorrect behavior :smiley: someone needed feature like this? :P\n. there's also other inconsistencies\n``` ruby\n   time = parse_now(\"1 week from now\")\n   assert_equal Time.local(2006, 8, 23, 14, 0, 0), time\ntime = parse_now(\"1 weekend from now\")\n   assert_equal Time.local(2006, 8, 19), time\n```\nsee how in one case we use 14:00 time but for other 0:00.\nThere's really big need for Chronic to have good specification and documentation about indented behavior as currently some cases doesn't really make sense and it's not easy to tell which would be the correct way.\n. another example\nruby\n  time = parse_now(\"3 years ago this friday\")\n  assert_equal Time.local(2003, 8, 18, 12), time\nI would think it means 3 years ago and then friday, which would be 22nd August as 18th is not Friday. Or is it meant to be this friday and then 3 years ago? Would this friday 3 years ago be same and ordering wouldn't matter or test is wrong?\n. it's awful :P incorrect tests...\n``` ruby\n  def test_handle_rdn_rmn_od_sy\n    time = parse_now(\"Thu Aug 10th 2005\")\n    assert_equal Time.local(2005, 8, 10, 12), time\ntime = parse_now(\"Thursday July 31st 2005\")\nassert_equal Time.local(2005, 7, 31, 12), time\n\ntime = parse_now(\"Thursday December 31st 2005\")\nassert_equal Time.local(2005, 12, 31, 12), time\n\ntime = parse_now(\"Thursday December 30th 2005\")\nassert_equal Time.local(2005, 12, 30, 12), time\n\nend\n```\neverything seems to be ok? but actually none of those day names are in those dates, if you take a look at 2005 year calendar you'll see. And there are several such tests with wrong day names.\n. I would also expect it to be starting from 0:00, it's just logical how dates work :D and it was really confusing for me too at first. I think in some next major version we should default to :guess => :begin because that's what most people would expect, not half of span, in some cases it doesn't make any sense to use middle of span.\n. @leejarvis will you take a look?\n. if you always need 1st then you might want to use Chronic.parse(\"monday this month\") and that does work. But yeah this is a bug and will be fixed some day.\n. I know about code :laughing: I've been working on it for a while now to improve and it's not pleasant at all. But once I'll have done it will be very trivial to fix this bug and all other issues. Only that wont be very soon.\n. Ok, I'll change comments to TomDoc syntax (I personally always use YARD)\nAbout width there's not really many choices, it seemed logical to put it before options, but if would put after then yes nils wouldn't bee needed that much. Another way would be to set it independently after initialization. But I don't really see any issue with nils there and also Repeaters will be removed later anyway (they'll be refactored in simpler tags and separate parsing) so it doesn't matter that there's nil now.\n. I updated comments to TomDoc syntax. Did you got time to review? Anything I should change?\n. @leejarvis so what about this? I just rebased, it should merge cleanly.\n. merged in beta branch\n. Looks good :), this is issue I encountered in #246\n. @leejarvis have you looked at this? I think it can be merged.\n. looks good :+1: \n. try something like\n``` ruby\nChronic.parse('this weekend', :now => Date.parse('2014-04-28'), :guess => false)\n=> 2014-05-03 00:00:00 +0300..2014-05-05 00:00:00 +0300\n```\nonly I can't guarantee that it will work for all cases.\n. Chronic being typical and buggy as usual, so currently can't do that...\nthis should work, but doesn't...\nruby\nChronic.parse('this week', :now => DateTime.parse('2014-04-28'), :guess => false)\nso currentl can do something like\n``` ruby\nChronic.parse('next week', :now => DateTime.parse('2014-04-28') - 7, :guess => false)\n=> 2014-04-27 00:00:00 +0300..2014-05-04 00:00:00 +0300\n``\n. This can be merged, but that regexp's will be removed later anyway and implemented with proper tokens.\n. just merged this inbetabranch\n. @leejarvis Looks like you're really busy? What about if I create newbetabranch and merge PRs there and then when you've time you can review them all and merge in master. But in meanwhile I can manage thatbeta` branch.\n. Cool :sunglasses: \n. It is correct. Mountain Time (US & Canada) is MDT thus -06:00\nReason why when parsing with Ruby gives you -0700 is because of your system's configured timezone which isn't MDT.\nFor example Time.strptime(ticks, \"%Q\").to_s for me gives 2014-07-05 03:33:57 +0300\n. yes, you're on MST which is -7:00, but Mountain Time (US & Canada) maps to America/Denver (and not America/Phoenix which is your timezone). America/Denver in this date range is -6:00 and will be -7:00 only in November.\nYou can verify it yourself\nruby\nrequire 'tzinfo'\nrequire 'active_support/time'\nActiveSupport::TimeZone::MAPPING['Mountain Time (US & Canada)']\n=> \"America/Denver\"\nTZInfo::Timezone.get('America/Denver').strftime('%Z')\n=> \"MDT\" # -06:00\nTZInfo::Timezone.get('America/Phoenix').strftime('%Z')\n=> \"MST\" # -07:00\n. merged in beta branch\n. that version file creation kinda don't fit here, I already had that PR made a while ago #262\n. ah, yeah I see, it's because gemspec loads whole Chronic..., but like I said, I've it addressed with #262 including fixing Rakefile#version, which currently is broken (your PR doesn't fix it either). So best would be merge #262 and then rebase this on top of it. No need for version file here.\n. merged this in beta branch\n. hmm, it works fine for me.\nruby\nChronic.parse(\"9-3-1987\")\n=> 1987-09-03 12:00:00 +0300\nwhich Ruby version are you using? also try with Chronic.debug=true to see more detailed output.\n. are you sure you've latest Chronic version 0.10.2? haven't you monkey patched anything?\nI just checked with Ruby 1.9.3, 2.0.0, 2.1.2 and it works fine for all.\nBut those your matched tokens are definitely wrong, especially 3tzminus1987(timezone), but I don't know why...\n. looks ok, merged in beta branch\n. I've encountered a lot of similar issues. Specifically this issue is already fixed in master branch.\n. this is fixed in #278, but it will take some while till it's finished and released.\n. this is same issue as #230 and was actually fixed with #243, but yeah it's not released yet.\n. seems fine. I think this could be merged and I really like all those tests :)\nBut I must say that this will be refactored later a bit differently (not only this, but all repeaters). There's some problems with current implementation. For example just q shouldn't parse as valid quarter and other similar things. Anyway no need to worry about this for now.\n. merged in beta branch. In upcoming refactoring/rewrite, implemented as 764b3c1e08d38f68fe87a4d29fb8f361aa77e5c7 (see #278 )\n. I'm not sure, I don't really like this implementation. But I agree support would be useful.\n. merged in beta branch and reimplemented as d0351763508b312eb327792d38c5d9c5ad9506b9 see how simple ;) and without hacks.\n. merged in beta branch, reimplemented as 4806e1777367429f2ab192ba4b3367129ddae7c3\nbased on this, it should be very simple to implement much more formats.\n. merged in beta branch\n. @leejarvis  have you taken a look on this? What do you think?\n. I'll first finish this so that all tests pass and only then clean it up. Also for some places I'm not sure about best implementation so it would be nice if you can give any tips what could be made better.\n. indeed :+1:\n. No, this is correct behavior as described.\nBy default it uses :endian_precedence => [:middle, :little] which means that day is middle and month is first, but if that's not possible then use other way.\nSo here\nruby\nChronic.parse(\"05/10/2014\")\n => 2014-05-10 12:00:00 +0100\nit's 10th day in 5th month.\nbut here, because it can't be 29th month, so it falls back to other.\nruby\nChronic.parse(\"29/09/2014\")\n => 2014-09-29 12:00:00 +0100\n. Note that I've started quite big changes in #278 and basically this will have to be rewritten once that is finished. For example prenormalize regexp's are completely removed. Also it's somewhat pointless to use Numerizer for other locales as currently it supports only English. So firstly should add locale support to Numerizer.\nAnother thing I'm not sure if it's good idea to put translations directly in Ruby. I think better would be to use CLDR translations and add misspellings (which are not in CLDR) in separate locale files. All translations could be stored in yaml files and loaded at runtime based on used locale. Also there could be different date/time definitions based on locale.\n. No idea, I can't reproduce, it works for me.\nruby\nChronic.parse(\"today 23:30\")\n=> 2014-10-27 23:30:00 +0200\nChronic.parse(\"today 23:45\")\n=> 2014-10-27 23:45:00 +0200\nChronic.parse(\"today 23:59\")\n=> 2014-10-27 23:59:00 +0200\n. Not a coincidence, but bug in Chronic regarding DST. Same issue as #147, #177, #179, #222, #228\nI just tested it with 26th and indeed I get nil, because here also DST changes on 26th (before I tried it on 27th). Anyway I didn't investigated exactly why, but it's not really important as I've started this rewrite #278 and on that branch it works fine (you get correct 23:01). But note that DST rollover still isn't implemented even there (Chronic have never supported that yet), but it's planned to be added later. So currently if you parse something like after 1 hour and in this hour DST changes, result wont be correct.\n. I don't think Chronic have ever supported this format (with year). But it will work when #278 will be done.\nWith that PR\nruby\nChronic.parse('2nd sunday march 2014', :guess => false) # it doesn't work with \"in\", but that will be fixed\n=> 2014-03-09 00:00:00 +0200...2014-03-10 00:00:00 +0200\n. currently Chronic doesn't support such format together with time, but it will be implemented in some next versions.\n. Note that all of pre_normalize regexp's will be removed with #278 (not done yet) because they're just generally a hacks and proper implementation will actually parse that.\n. Well, IMO I think it would be better to write from scratch than port this, just take main idea from that rewrite branch. Tokenization, Taging, Objects, Token Groups, flexible Definitions those are generally good concepts. Only this exact implementation might not be the best, there are few things I don't really like 100% but haven't figured out any better way. As for stability, it currently works for most cases and all tests from test_parsing does pass, but not other tests. There probably won't be much big changes anymore, just generally some fixes there and here as I'm pretty sure there are some edge cases not handled. Also need better test coverage and then will see how good it is. Basically need a test for every date/time format combination to be sure.\nBy the way do you know about Opal? then wouldn't need to manually do anything ;)\n. Chronic will try to extract and parse any date/time like parts of sentence. But currently there isn't a way to get which parts were used and which weren't. Also Chronic can handle only ranges like this week , but not something like between Monday and Wednesday.\nSo basically Chronic can parse any sentences with other text and not only with date, but it won't tell which parts were parsable. Also Chronic is much more complex than simple regexp and I doubt such regexp could be even created.\nAnyway feature about extracting parsed and non-parsed parts from sentence could be added, but if you need that you'll probably have to implement it yourself, it shouldn't be too hard. I would suggest to look at token_group.rb in my rewrite branch. There you can see tokens, which will contain list of all tokens from sentence (sentence is first split in tokens and then each token is tagged with it's type). Chronic is parsing this token list and separating it in Anchor/Arrow/Narrow/Date/Time/Timezone Objects. Each object is a group of sequential tokens. In to_span method from these objects actual date/time is parsed. So to get which part of sentence was parsed you just need to look which tokens was used in objects - HandlerObject#begin, HandlerObject#end will give first and last token index for that object. Then use these indexes to get token itself from token list and from token you can get it's position in sentence with Token#position.\nHere's quick code I just hacked up which will extract parsed text for datetime object. Of course full implementation will be bit more complicated because there will have to handle cases where you've to deal with multiple objects being parsed and not just one.\n``` ruby\ndatetime is instance of DateTimeObject\nfirst_token = @tokens[datetime.begin]\nlast_token = @tokens[datetime.end]\nparsed_text_start = first_token.position\nparsed_text_end  = last_token.position\nparsed_text_end += last_token.word.length\nparsed_text = first_token.text[parsed_text_start...parsed_text_end]\nbefore_parsed_text = first_token.text[0...parsed_text_start]\nafter_parsed_text = first_token.text[parsed_text_end, first_token.text.length]\n```\n``` ruby\nChronic.parse('An important event will happen 2014-12-01T00:00:00!!!')\nparsed_text will be \"2014-12-01T00:00:00\"\nbefore_parsed_text will be \" An important event will happen \"\nafter_parsed_text will be \"!!!\"\n```\n. Yeah, it's looks like same bug and no worries about duplicate issue. Also officially it's not yet fixed, but it does work correctly in my rewrite branch, #278 \nBy the way you can pass time with now, like\nruby\nChronic.parse(\"1st wednesday of this month\", :now => Time.parse('2020-04-01 00:00:00 +0000'))\n. Yeah, it's a known bug. #222 and #147\nAlso it's not really fixed yet (but this case works correctly in my rewrite branch #278)\n. that's really really weird. What debugger are you using? it works fine with IRB for me.\n. indeed looks like a bug\n. these work on 0.10.2 and on master\nruby\nChronic.parse('1000-01-01')\n=> 1000-01-01 12:00:00 +0200\nChronic.parse('0999-01-01')\n=> 0999-01-01 12:00:00 +0200\nChronic.parse('0000-01-01') is expected to be nil, I don't think anyone would encounter such valid date.\nruby\nChronic.parse('999-01-01')\nChronic.parse('100-01-01')\nthese probably won't work in future versions unless there's a good reason to implement them, because typically year is always 4 digits and it doesn't really make sense with 3 digits and what about Chronic.parse('10-01-01')? that might be short year notation so it wouldn't be possible to specify 10year anyway.\n. yeah, it's a bug, will probably be fixed in some next version\n. I'm not sure such format have ever been supported...\n. that's kinda expected, because by default :context => :future, but current version is still bugged... currently you can use some hacks like subtracting day or using  :context => :past for this case...\nin next, yet unreleased version (my rewrite branch) it will be\n``` ruby\nChronic.parse('monday', :context => nil)\n2015-02-09 12:00:00 +0200\nChronic.parse('this monday', :context => nil)  # this is debatable if it should be today...\n2015-02-16 12:00:00 +0200\nChronic.parse('monday at 16:30', :context => nil)\n2015-02-09 16:30:30 +0200\n``\n. it's not really implemented so...context: nilwould return Monday in that week so for Tuesday it would be like last Monday, for your case seems you needcontext: :futurebut just some flag so that current day is returned if it's Monday which is only exception\n. I've been thinking about such feature for next version as I also find this needed and useful, but I haven't decided yet about best implementation.\n. I don't recommend working much on currentmasterbranch because those changes will have to be reworked for next version, I'verewritebranch in progress, see #278 and definitions are changed quite radically there... but if you need this change soon then just go for it.\n. It's a known bug  #230, #272 and it's fixed onmaster` (with  #243) but haven't released yet.\n. It's DST related, currently Chronic almost always breaks on DST change... There are dozens of similar bugs, it will be fixed some day.\n. It must be some conflict/monkey-patching by some other gem as there haven't been any changes to Chronic for a while and it works fine for me. Look into what gems and versions are loaded to find cause.\n. Don't worry about fixing, there's ongoing rewrite of large part of Chronic and I know how big mess current code is. Also actually this is fixed in my rewrite branch\nruby\nChronic.parse(\"2nd Sunday of next May\", :guess => false)\n=> 2016-05-08 00:00:00 +0300...2016-05-09 00:00:00 +0300\nBut that rewrite isn't finished and I'll have time to continue work on it only in autumn. So for now you'll have to somehow workaround it yourself.\n. yeah I think this can be used, what do you @leejarvis think? also might as well merge beta branch in master and release it as there are some fixes and it's been sitting there for ages.\n. I'm not sure what you mean? It looks correct to me.\n``` ruby\nby default, :context => :future and :hours24 => nil\nwhich means it will take best guess\nyou ran it before 17:30 so closest time to 5:30 is 17:30\nChronic.parse(\"5:30\", endian_precedence: :little)\n=> 2015-05-29 17:30:00 +0300\n05:30 forces :hours24 => true so it will definitely be 05:30\nChronic.parse(\"29/05/2015 05:30\", endian_precedence: :little)\n=> 2015-05-29 05:30:00 +0300\nno date specified and closest 05:30 is only tomorrow so\nChronic.parse(\"05:30\", endian_precedence: :little)\n=> 2015-05-30 05:30:00 +0300\n``\n. I already mentionedby default, :context => :future and :hours24 => nilso you just pass:hours24 => true;)\n. Chronic doesn't really support such complex queries and mostly it's luck based whether it will get it correct :D anyway this works fine in myrewritebranch, but it's nowhere near ready for usage.\n. with \"works fine in my rewrite branch\" I mean, it works there as it should producing correct output - feature already implemented there :)\n. kinda not really... basically @leejarvis is current maintainer but haven't seen him respond to anything for a while. I worked on rewrite #278 which would solve most of issues but I haven't had time to complete it yet. It's still on my TODO list, just need to find time when I'll be able to finish it. Also even before that rewrite there are several PRs which could be merged and some are merged inbeta` branch.\n. I've written few comments about it on this reddit thread\nFor my latest code see #347\nThere's still few minor things left to do and biggest part is testing it. Also I had thought out how to implement everything that's left but haven't written that code yet, it's basically just Timezone/DST work. It already should work but there might be some cases which need work (like performance, see my reddit comment)\n. yeah, it's a bug, it's fixed in my rewrite branch but that's not ready yet and will be released as next major version.\n. why month should return end of month? it's actually not supported and that it returns anything at all is just pure luck. \nfor now you can use\nruby\nChronic.parse(\"1 day before next month\", :guess => :begin)\n=> 2016-02-29 00:00:00 +0200\n. I think this format isn't really supported... and see #316, if you want to make PR do it for my rewrite branch, it's still work in progress and not finished but I'll work on it when I'll have time.\nEDIT: actually it seems to be working, but you need to use :context => :past\n. I can't reproduce it and I suspect it's DST related, can you show example of how you parse it and which timezone is used?\n. It's definitely DST related bug.\nFor me with EET timezone it's Chronic.parse('2016-03-27 12am') which gives nil and not your time.\nHandler: handle_sy_sm_sd\nHandler-class: Chronic::RepeaterDayPortion\n--(2016-03-27 00:00:00 +0200..2016-03-27 11:59:59 +0300)\nAnd it makes sense because in this day clock is turned +1h ahead so essentially there's 1 hour missing and thus nil because that hour can't exist, but there's bug that it's not 12am when it's +1h but from 3am becomes 4am and there isn't 3am.\nAnyway it's known that Chronic have loads of DST issues and it's pretty much broken there, but I've a rewrite branch and there never returns nil, tested with your script and for DST change it returns same hour twice, so that 3am returns 4am for me because 3am doesn't exist.\n. because DST change happens only in that day, in other day it moves -1h back thus same hour appears twice and it does exist unlike in this case.\n. you need add :guess => :begin option like Chronic.parse('today at 9:00 am', :guess => :begin)\nit's because current Chronic version gets interval and takes middle of it but it did so very inconsistently and that was fixed there by always using correct interval range.\nfor example current Chronic\n``` ruby\nChronic.parse('today', :guess => false)\n=> 2016-03-15 02:00:00 +0200..2016-03-16 00:00:00 +0200\nChronic.parse('today')\n=> 2016-03-15 13:00:00 +0200 # we're in middle of range\nChronic.parse('today', :guess => :begin)\n=> 2016-03-15 02:00:00 +0200\nChronic.parse('today at 7am', :guess => false)\n=> 2016-03-15 07:00:00 +0200..2016-03-15 07:00:01 +0200 # it's second precision, but minutes weren't specified...\nChronic.parse('today at 7am')\n=> 2016-03-15 07:00:00 +0200 # if \"today\" was middle, why not this?\n```\nwith my rewrite branch it's always consistent\n``` ruby\n Chronic.parse('today', :guess => false)\n=> 2016-03-15 02:00:00 +0200...2016-03-16 00:00:00 +0200\n Chronic.parse('today')\n=> 2016-03-15 13:00:0 +0200 # middle of today's range\nChronic.parse('today', :guess => :begin)\n=> 2016-03-15 02:00:00 +0200\nChronic.parse('today at 7am', :guess => false)\n=> 2016-03-15 07:00:00 +0200...2016-03-15 08:00:00 +0200 # now 1h precision\nChronic.parse('today at 7am')\n=> 2016-03-15 07:30:00 +0200 # also middle of interval\nChronic.parse('today at 7:30am', :guess => false)\n=> 2016-03-15 07:30:00 +0200...2016-03-15 07:31:00 +0200 # 1m precision because minutes specified\n```\nanyway that branch is still work in progress and while there's a lot of work done and basically almost all tests pass and there aren't expected to be big changes anymore there still might be some new bugs. But it does have fixed a lot of current Chronic's issues, especially regarding DST.\nPRs always welcome and on that branch if there's no test for particular date/time format it's considered unsupported so need tests for all formats.\n. It's that way only because it was that way before, I mean with current Chronic.parse('today'), if I change to :begin then it won't match previous behavior but yeah I agree that even before it was really stupid idea to and maybe it's worth changing to default which seems like good idea.\nand yes, I can't really recommend using it yet, I myself wouldn't use it yet :D it needs much more testing and fixing some things. Only I don't know when I'll have time to work on it again, but all code is there up so everything's that there is there and any PRs would be great.\n. btw about that work I did on rewrite branch see #278 \n. FYI, I've started on rewrite a while ago, see my comment on #316\n. It is known issue that Chronic doesn't work correctly when DST is involved, there are loads of such issues. There isn't really much you can do about it as Chronic is just broken in this case.\nAnyway it will be fixed in next Chronic version as I'm working on quite big rewrite which fixes a lot of issues including DST but it's unknown when it will be finished.\n. It works a bit better in my rewrite branch, for more info see #278\nBut that rewrite isn't really finished yet... and there it would be really easy to add support for all these cases.\n. yeah, that is also a bug, and it should be pretty easy to add support for this format once #278 is finished\n. Chronic is actually missing such feature... There's a parameter context but currently it supports only :past and :future\nI've been working on #278 which fixes a lot of issues and it does implement this feature but it's not really ready yet...\nwith my rewrite branch\nruby\ndate = DateTime.parse('2016-10-03')\nChronic.parse(\"monday\", now: date, context: :past)\n=> 2016-09-26 12:00:00 +0300\nChronic.parse(\"monday\", now: date, context: :present)\n=> 2016-10-03 12:00:00 +0300\nChronic.parse(\"monday\", now: date, context: :future)\n=> 2016-10-10 12:00:00 +0300\n. Looks fine to me, but it will be needed to rebase it on rewrite. Also I'm not actually maintainer of this project, but I do have push access.\n. I've been working on #278 (which rewrites quite a bit of logic) for some while but it's still unfinished and lately I haven't had time to continue it but I still plan on finishing it eventually and you should look at it since it doesn't need this at all...\n. Returns nil in my rewrite branch. yup, it is known DST issue #282, #147, #177, #179, #222, #228 and it's actually fixed in my unfinished rewrite branch, but no idea when I'll finish it.\n. It's actually been almost finished for really long time (more than a year) I just haven't been working on it for ages. For more info see #316 \nAnyway I just fixed last tests so now they all pass but it doesn't mean everything is working since there might be cases not covered by tests but they can be fixed once they come up.\n```\nRunning:\n......................................................................................................\nFinished in 11.438857s, 8.9170 runs/s, 67.4893 assertions/s.\n102 runs, 772 assertions, 0 failures, 0 errors, 0 skips\nCoverage report generated for Unit Tests to coverage. 3306 / 3528 LOC (93.71%) covered.\n```\nYou can try and test it already #347\nOnly thing that's left to do is finish timezone support and then could release beta version. When that will happen no idea, but it could be ~soonish.\n. Seems to work in my rewrite branch\n. Such format currently isn't supported but will be in next version (it's already implemented).\n. @macobo Look at #347 and my comments on Reddit\nhaven't really gotten time to still finish it.\n. See #316 \nHaven't had time to be done with this, but should be soonish. \n. you should rebase it on my rewrite branch, see #347 (and #278). Once I'll have that finished it will be merged in master.\n. could if it would be implemented but for now look into other libraries. Looks like same issue as #295\nIt's fixed in my rewrite branch which isn't ready yet.\n. This format isn't implemented, but it already works in my unfinished rewrite branch (#347). There it's very easy to add new date/time formats (lib/chronic/definition.rb). It's fixed in my rewrite branch. It's fixed in my rewrite branch. Fixed with #359. If you already now format, you could use just Date.strptime(str, \"%d/%m/%y\")\nCurrently for Chronic there isn't builtin option, but you can override Definitions\nsee lib/chronic/definition.rb\nNote that in my rewrite branch which will be next major release this format is changed lib/chronic/definition.rb. It is kinda known issue there are a lot of bugs with current Chronic release as you can see from issue count. Most of them, including this one is fixed in my rewrite branch #347 . About it's state you can read https://github.com/mojombo/chronic/issues/344#issuecomment-320060105\nBasically it already should be fine to use, only thing that's not done is timezone name support and there might be issues about which I don't know since it's not really been used but all original Chronic tests does pass.\n. I don't think this is that useful generally for anyone else to be in Chronic. Especially if you parse date in past or in future then how current time is relevant to it. You could just get time and set it yourself on returned result.\nBut what would be useful for Chronic would be to return if there were only Time part, only Date part or Date and Time. There could be different method like Chronic.analyse(time_string) which could give more information about provided time string.\nAnyway this is what I suggest you could do\n``ruby\nnow = Time.now\nparsed = Chronic.parse(time_string, :guess => false).begin\nif parsed.hour == 0 and parsed.min == 0 and parsed.sec == 0\n    # assume user didn't specify time, we'll be wrong in case user specified 00:00:00\n    with_time = Time.new(parsed.year, parsed.month, parsed.day, now.hour, now.min, now.sec)\nelse\n    with_time = parsed\nend\n````\n. I've been working onrewrite` for some time, it will be finished soonish, see #347 \nThere it's super easy to add support for new formats, and I just added this one there, see ec658809213d659e99a36d7aec1b561a143450aa\n. Currently it's not possible, but in my rewrite branch it would be very simple to implement it.\n. I would say currently there isn't really any maintainer since I just happened to work on this but I wouldn't call myself as a real maintainer. I just want to fix some bugs and add support for features I need :D . Anyway I do have git commit access but no access to rubygems so I can't release new gem. But when I'll be done I'll merge my branch in master and contact @leejarvis on Twitter to get new gem out, but before merge release a new version and then one after.\nAbout my rewrite branch progress you can read my comment on #344 . I would say it's pretty much all done and there won't be any big changes. Only thing that's left to do is timezone name parsing. For that currently I've been working on rewriting my TimezoneParser gem to improve performance (switch from Marshal to SQLite) which is used in my rewrite branch. Then once that is done I'll probably go over all GitHub issues and fix them and make a release. But when this will happen it's hard to say as I'm doing this in my free time and not that often.\nAbout that C# port, I had never seen it before but I think it really wasn't good idea to make direct port but way better would have been take this code as inspiration and as an example but create it from scratch  based on these ideas. I don't really know what would be best way to update and port it, like my rewrite changes a lot of things, I would recommend you to take a look at code and see yourself #347 \n. it's a known DST issue #344 but it's fixed in my rewrite branch #347 and works there fine.\n. FYI it's been fixed (a long with a lot of other issues) in my rewrite branch #347 . But there already is such option...\n```ruby\n Chronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-24'))\n=> 2017-10-23 00:00:00 +0300..2017-10-24 00:00:00 +0300\nChronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-23'))\n=> 2017-10-20 00:00:00 +0300..2017-10-21 00:00:00 +0300\nChronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-22'))\n=> 2017-10-20 00:00:00 +0300..2017-10-21 00:00:00 +0300\nChronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-21'))\n=> 2017-10-20 00:00:00 +0300..2017-10-21 00:00:00 +0300\nChronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-20'))\n=> 2017-10-19 00:00:00 +0300..2017-10-20 00:00:00 +0300\n``\n. That's because version you use doesn't havemiddaysupport, it's only implemented inmaster` branch where it does work correctly.\n. Such format isn't supported.. Yeah, that's why it's also a bug but there are a lot of inputs which could crash it, you should catch those exceptions even if Chronic would be 100% safe.\n. looks like a bug :P\n. that's because of DST, currently no support for it, there's loads of such issues #147, #177, #179, #222, #228, #282 \nthey all will be probably fixed once DST is properly implemented.\n. Seems to be fixed, atleast works for me\nirb> Chronic.parse('0000')\n=> 2013-08-23 00:00:00 +0300\nirb> Chronic.parse('1200')\n=> 2013-08-22 12:00:00 +0300\nirb> Chronic.parse('0000', {:context => :past })\n=> 2013-08-22 00:00:00 +0300\nirb> Chronic.parse('1200', {:context => :past })\n=> 2013-08-22 12:00:00 +0300\n. I was working to improve Chronic support for different date/time formats and get rid of all those regexp hacks. It all went well at start until I had to deal with Timezone parsing. Chronic doesn't really have much logic for Timezone parsing and it defers it to Time.parse so you can't parse any Timezone strings that's not supported by Ruby and Ruby have very poor timezone support. So right now I'm creating new separate gem which will parse Timezones and it will support all locales from CLDR out of box. Then later after might also add CLDR support for Chronic and won't be any need for users to translate anything as it's already done by CLDR guys.\n. yeah, well sorry it's taking quite a lot of time as I've other projects also ongoing and there's never enough time. Anyway I just now pushed TimezoneParser. It's not finished yet and usually I don't like to publish stuff until it's more completed but I had to show :D So basically it's almost done and currently implemented parts are fully working, including tests. Only this is kinda alpha version as I'll change few things and will do various improvements. Also have to write documentation and more tests. Still I would suggest to check it out ;) I'm pretty proud myself lol as it have very good functionality (as example timezone_spec.rb).\nI'm not sure when I'll finish TimezoneParser fully, but it probably will be quite soon as there aren't much left to do. Then after I'll continue to work on some Chronic things, but that will take some not so short while. Basically I would say that you should contribute yourself if you need it. My idea about localization is that there would be different gem which uses CLDR data to parse those strings and Chronic uses it. Same like it will be with TimezoneParser.\n. I've finally finished TimezoneParser yey :) also documented most of methods and pushed gem. It works perfectly and I don't have any plans for new features unless there will be something missing. But there's one bad thing and I'm not sure how to resolve it. It's slow to load timezone data from files to memory. It's only one time cost but for all data files it takes 4-5 seconds and I think that's a lot, it's 6 MiB of text (all languages). Using only abbreviations it still takes 1 second (1 MiB file). I'm using Ruby's marshal which is fastest serialization, but still not enough in this case. Maybe using some custom made binary format would be faster, not sure. Another way would be to create separate files for each locale, but that wouldn't work for abbreviations anyway. Also there can be cases when you've no idea what language you're parsing and then I guess it might be slower to load all files separate. Anyway I would appreciate any reviews, PRs and improvements.\n. Some while ago I started working on quite big rewrite, see #278 and there in that PR this is fixed along with a lot of other things, but it's nowhere close to be ready. It's basically early early alpha :D\nbut there\nruby\nChronic.parse('13/10/2014 8:00 UTC', :guess  => :begin)\n=> 2014-10-13 08:00:00 +0000\nso yeah, some day all Chronic bugs will be fixed ;)\n. I'm still waiting for PRs to be reviewed by @leejarvis some could be merged, but this isn't my lib so I'm waiting ;)\n. it's because gemspec includes whole chronic and thus you get this exception because you don't have numerizer gem, it's fixed in #262 but currently you can just gem install numerizer\n. now and time_class are different options. You specify now to tell Chronic at which time it should treat things like \"Today\", \"Tomorrow\" etc., but with time_class you specify which Time class you want output to be in, eg. Time or Date class\nEDIT: So I think correct behavior would be that when parsing 'Today at 5pm' it would use same Timezone as used for now option for parsing/input, but output would be in Timezone which is for time_class\n. why this haven't been merged? works good :P\nbut it could be improved, seems there have been changes in MiniTest (I've v5.0) and it throws error.\nN:\\Projects\\chronic>rake test\nWarning: you should require 'minitest/autorun' instead.\nWarning: or add 'gem \"minitest\"' before 'require \"minitest/autorun\"'\nFrom:\n  P:/Ruby193/lib/ruby/1.9.1/minitest/autorun.rb:14:in `<top (required)>'\n  N:/Projects/chronic/test/helper.rb:6:in `<top (required)>'\n  N:/Projects/chronic/test/test_chronic.rb:1:in `<top (required)>'\n  N:/Projects/chronic/Rakefile:10:in `block (2 levels) in <top (required)>'\n  N:/Projects/chronic/Rakefile:10:in `each'\n  N:/Projects/chronic/Rakefile:10:in `block in <top (required)>'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:236:in `call'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:236:in `block in execute'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:231:in `each'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:231:in `execute'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:175:in `block in invoke_with_call_chain'\n  P:/Ruby193/lib/ruby/1.9.1/monitor.rb:211:in `mon_synchronize'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:168:in `invoke_with_call_chain'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/task.rb:161:in `invoke'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:149:in `invoke_task'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:106:in `block (2 levels) in top_level'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:106:in `each'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:106:in `block in top_level'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:115:in `run_with_threads'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:100:in `top_level'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:78:in `block in run'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:165:in `standard_exception_handling'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/lib/rake/application.rb:75:in `run'\n  P:/Ruby193/lib/ruby/gems/1.9.1/gems/rake-10.1.0/bin/rake:33:in `<top (required)>'\n  P:/Ruby193/bin/rake:23:in `load'\n  P:/Ruby193/bin/rake:23:in `<main>'\nMiniTest::Unit.autorun is now Minitest.autorun. From P:/Ruby193/lib/ruby/1.9.1/m\ninitest/autorun.rb:18:in `<top (required)>'\nRun options: --seed 19834\nif I add gem \"minitest\" in ./test/helper.rb#6 before require 'minitest/autorun' then there's no more error.\n. yup, there's been regression and there's no test case for it.\nChronic.parse('30-07-2013') # works in 8.0, but not in current master\n. actually it's very easy, just have to be more precise when writing regexp ;) will do PR in 5mins.\n. Done!\nI'm just used to camelCase and for that exception I followed previous code like it was, but improved now ;)\n. hmm, seems there's merge conflict because @current_time from merged PR (ruby-warnings)\n. I just did rebase before reading your reply. I think should be fine without squashing ;)\n. yeah, sorry didn't thought about such format (it's caused by #196), but there wasn't any tests for this anyway, so I would suggest for everyone if you use some format which does work correctly then send PR with test case for that format if there isn't such currently ;) also BTW did you know that before #195 milliseconds weren't parsed :P\nI'll send PR with a fix in a hour :)\n. done, sorry it took so long, got busy with other things...\n. I'm no sure if this is good idea, if you need such functionality you can just write in your own code\nruby\nChronic.parse \"3rd thursday this november\", :now => Chronic.parse(\"1/10/2010\")\nalso this way you can pass more options and such, what if that passed date couldn't be parsed or would return Chronic::Span\nwhile it doesn't really affect typical cases using Time, I don't see why it should be integrated as like I said you can easily specify in own code.\n. yeah actually I had same idea, but currently I've started to change few other things. Basically need to add hours24 option to Parser, if it's true then force interpreting hours as they would be 24 hour clock, if it's false then force 12h clock if it's any other value (eg. nil) then keep current behavior as somewhat smart guess...\n. well, naming that's the hardest part :D\nI don't know what would be best name. Here some more: :force24h, :force_hours24, :clock24h, :force_24h_clock, :time24h, :time_clock24h\nI'll commit changes when option name is chosen.\n. any ideas about that option name?\n. Nice :)\nthere wasn't any conflicts, but I still rebased. So it should merge fine.\nabout next PR, I'm currently thinking how to properly implement timezone parsing. This current implementation doesn't actually parse it at all and just pass it to generic Time.parse, but I've successfully implemented all parsing so Time.parse is not needed at all with only exception being timezones. With my googling I didn't find way to convert timezone abbreviations/names to offsets (in Ruby it's hardcoded /ext/date/date_parse.c#L341 and not exposed outside) so I'm thinking to create separate gem which does that and add dependency on it. Also then it would be possible to offer support for timezone names in different languages.\n. I don't really need commit access. Just when I started reviewing this I noticed how poorly (IMHO) some things are implemented that I wanted to fix it once and for all :D So basically idea is that you would throw in any commonly used date/time format and it would parse it successfully.\n. It appears that TZ database includes even abbreviations. And they can be accessed from TZInfo gem, only thing is that different abbreviations were used at different times so one can represent multiple offsets depending at which time and in which country you're in. I quickly generated all abbreviations to possible offsets gists/TimezoneAbbr_To_Offsets.yaml\n. I've been working to fix lot of things in Chronic, but it's taking more time than I thought it will and I still haven't finished yet. There will be  Chronic::parse, Chronic::parse_time and Chronic::parse_date that would solve this issue with :ambiguous_number_priority, but won't be soon...\n. I've also fixed issue with :guess allowing it to be more flexible as most people wouldn't think that guess means middle of span, but would rather want 00:00. I'll look if I can cherry-pick some my changes without breaking tests and send PR\n. you mean HISTORY.md right? sure :)\nthere will be atleast one more PR with quite big changes, but it will fix lot of things and yeah it would be good to have version before those changes.\n. The goal was to remove all time_class.local (not done yet) and use everywhere Chronic.construct which will support Time, Date, DateTime they all have new. I wasn't aware that ActiveSupport::TimeZone doesn't implement new but I think they should, because all  those mentioned classes does support it. I might send PR to them.\n. hmm, actually seems will have to figure something else, because Time.zone is already initialized and constructor differs very because it's TimeZone not expected Time/Date class\n. reason for new versus local was that each of classes (Time, Date, DateTime) they're a bit different but new is almost same for all.\n. oops, actually I'm talking crap here. This current implementation would support only Time anyway.\nDate can't be used if we need time\nfor DateTime there's no local and for Time.local we can't set offset that's why I used new there.\n``` ruby\nTime.new(year, month=nil, day=nil, hour=nil, min=nil, sec=nil, utc_offset=nil)\nDateTime.new([year=-4712[, month=1[, mday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])\nTime.local(year, month, day, hour, min, sec, usec_with_frac)\nno such DateTime.local\n``\n. seems probably most easiest way would be check fortime_classtype and then use corresponding method as I want to set offset correctly, but only way is withnewand we don't need set offset forActiveSupport::TimeZone` so will make that special case, I can do PR within 30mins.\n. Sorry. Done :)\n. Maybe they weren't working only I thought they were. Sometimes Ruby can be confusing. It's nice that someone does code review, thanks. Also tests are must have. Currently coverage ~96% but after I'll be done with main changes, will need to make 100%\n. It's not yet supported, but this does work\nruby\nChronic.parse('monday of the month at 9am')\n=> 2013-08-05 09:00:00 +0300\n. It's caused by at midnight it assumes next midnight :smile: \nwith 00:00 it does work.\nruby\nChronic.parse('thursday of the month at 00:00')\n=> 2013-09-05 00:00:00 +0300\nChronic.parse('thursday of the month at 12:00')\n=> 2013-09-05 12:00:00 +0300\n. It's caused by 648c61e2e0d8b61a3f5b0d47fb6a80815d4ea28b (#192, #196, #198, #200)\nbecause Regexp's positive lookbehind is used there and it's only available Ruby >= 1.9\nSadly with current implementation I don't see how we could parse such format without making even more worse hacks. So probably I would say easiest way would be just lock to < 0.10 if you need Ruby 1.8 support. Or could create separate branch without that line.\nActually I'm in progress to change lot of parsing related parts and then there won't be such Regexp's. It will be much cleaner way, but it's not yet ready and will take some time. If I'll be lucky then it might be done before end of this month, but can't promise anything.\nI test only on Ruby 1.9.3 and 2.0.0 as I don't really intend to support anything below, but mostly there's very high chance it will still work even on Ruby 1.8. If it won't then depending which features are used it might be very easy to remove them to still be compatible.\n. I'm not maintainer BTW :D I just decided to fix some things as currently this seems top used gem for parsing date/times but for some formats it doesn't really have good support and I'm going to change that :)\n. I would say it's up to you, choose direction ;) Maybe it would be possible to use something* that's still compatible but I don't know. And making more than minor changes isn't worth currently. Actually I knew that lookbehind isn't available in 1.8 but I didn't really thought about it as fixing broken parsing seemed more important and so my bad. Also who still uses 1.8 anyway :smile: \n*for example there's ruby 1.8 gem for regexp which does support lookbehind\nor some other hacks\nor anything you can think of, Ruby 1.8 specific workaround code.\nIt can be used temporarily and removed once I finish these changes I've started as like I said they'll be compatible most likely.\n. Now it should be compatible with Ruby 1.8.7\nYou can try it right from git with Bundler\nIf you find some issues please let us know.\n. That depends on @leejarvis when he'll release.\n. It worked :) But I changed to other way as I realized it could be done even better :P also I just tried on Ruby 1.8.7 and its Time.new doesn't accept any parameters so had to add another fix.\nAll tests pass for 1.9.3 and 2.0.0, but for 1.8.7 everything works except 3 tests fail because two of them use Time.new with parameters (test_chronic.rb#136, test_parsing.rb#39) and one uses date range which isn't supported in 1.8 (test_parsing.rb#355)\nI think it's not worth changing tests and with this PR we still have compatibility with 1.8 :)\n. Actually there I made bug but none of tests caught it. Also I noticed that there's another different bug not related to 1.8 and I fixed that too. Added one test so finally this part should be bugfree.\n. There wasn't any changes (between 0.10.0 vs 0.10.2) which would affect this, most likely it's issue with that specific date/time it was when you tried.\n. irb\nirb(main):009:0> Chronic::VERSION\n=> \"0.10.0\"\nirb(main):010:0> Chronic.parse(Time.now.to_s)\n=> 2013-09-11 14:50:25 +0300\nirb(main):011:0> Chronic.parse(Time.now.to_s)\n=> 2013-09-11 14:50:27 +0300\nirb(main):012:0> Chronic.parse(Time.now.to_s)\n=> 2013-09-11 14:50:28 +0300\nlike I said it's probably something with your specific format.\nfor me Time.now.to_s returns \"2013-09-11 14:52:36 +0300\" but on other machine it's \"Tue Sep 10 21:49:13 -0700 2013\" and that's very different...\n. oh LOL, there indeed was bug with negative timezone, I fixed it in 0.10.2 so yeah...\n. Seems good. :+1: \n. Probably Chronic.debug should also be per-thread.\n. Well I think thread safety is needed. To allow configuration, could create global_time_class which would be class variable thus global then there would be time_class which would return global_time_class if current thread's time_class isn't set. And then of course also possible set it as option to .parse\nit could be like this\n``` ruby\nclass << self\n    def global_time_class\n      @@global_time_class || ::Time\n    end\n    def global_time_class=(time)\n      @@global_time_class = time\n    end\ndef time_class\n  Thread.current[:__Chronic_time_class] || global_time_class\nend\ndef time_class=(time)\n  Thread.current[:__Chronic_time_class] = time\nend\n\nend\n```\nthen global_time_class would be on whole app while still allowing to set per-thread if have such need.\nAs for debug could do same, it's minor change and maybe for some cases it might be useful to debug only single thread.\n. > However, I do still believe that we should allow setting the time class per Parser instance\nI'm not saying we shouldn't, it's a must have.\nThat global class variable would be just extra. But maybe not really needed then, I just like very customizable software so to fit everyone needs :laughing:\n. you probably wanted to reply to #203, not create new issue.\n. :+1: This is good, thanks :)\n. I think this can be merged, @leejarvis ?\n. yup. I added it to .gemspec a while ago with eb912a6 \n. Do you have MiniTest 5?\n. This warning is only for Ruby 1.9, but not for 2.0 I'm not really sure about details why and what. But basically it's just warning and tests does work fine. If would use bundler (ie. bundle exec rake test) then there wouldn't be this warning as it would automatically load gems.\n. yeah, I know, it's because 2 of those tests use Time.new with parameters and Ruby 1.8 doesn't support that. Also for me there's another 3rd test failing because of unsupported date range for 1.8. But these are only test faults and all Ruby 1.8 apps which use this gem will work fine.\n. I'm not really sure if there's much point of it, because Ruby 1.8 is EOL and won't be supported by Chronic v0.11. That's also reason why I didn't bothered with this. Also your implementation is quite overwhelm I would say. The way how Ruby converts string to float can be used to simplify this to RUBY_VERSION.to_f < 1.9 (because \"1.8.7\".to_f will return 1.8)\nOf course this could be added now, but basically I would say that everyone should upgrade and move away from 1.8\nEDIT: Also even better would be just use 1.8 compatible way. That is instead of Time.new use Time.local that will work in both.\n. It's not really a bug, that's how chronic works, end is exclusive limit, meaning that all dates/times right before it are inside interval but not this end limit.\nTo achieve what you want is very simple, just\n``` ruby\n\nChronic.parse( '9/30/2013', guess: false ).end - 1\n=> 2013-09-30 23:59:59 +0930\n```\n\nend in chronic is exclusive, because otherwise it wouldn't work for milliseconds or for even smaller units. Now with current implementation it will work correct.\n``` ruby\n\nfor '10/1/2013' unix timestamp is 1380661200.0\n1380661199.999999 < Chronic.parse( '10/1/2013', guess: false ).end.to_f\n=> true\n```\n. That is bug indeed. I was saying about end limit itself as it contains correct value. But yeah Range should be created as excluding limit when that's the case.\n. It's happening because of DST change on 27th October and Chronic isn't regarding that. It assumes there's always 24h hours in a day, but it wont be the case for 27th October, then clocks will be turned 1 h back and same hour will appear twice thus making it 25h day and so all next weeks calculation will be off by 1h. This bug won't happen after DST is changed or if you look for times before change.\n\nEDIT: Here you can see lib/chronic/repeaters/repeater_weekday.rb#L38\nEDIT2: Actually no, it's this lib/chronic/repeaters/repeater_week.rb#L32 length of week...\n. Why would I close this... It is a bug and definitely needs to be fixed some day.\n. It works fine for me.\n``` ruby\n\nChronic.parse(\"today at midnight\", :now => Time.mktime(2013, 11, 3))\n=> 2013-11-04 00:00:00 +0200\n```\n. When date is parsed and time is not specified for chronic then returned time is pretty much undefined I would say. It's not really clear what it should be, at various places it's used differently.\n\nAnyway I would suggest take only date part:\n``` ruby\n\nChronic.parse('today').to_date.to_s\n=> \"2013-11-01\"\nChronic.parse(Time.now.to_date.to_s).to_date.to_s\n=> \"2013-11-01\"\nChronic.parse('today').to_date == Chronic.parse(Time.now.to_date.to_s).to_date\n=> true\n```\n. All those 3 cases aren't supported by Chronic. Chronic assumes noon means 12:00 thus your case 12:00 noon doesn't make any sense. You should use 12:00 PM\n\nAlso Jan 1, 12 noon works only because Chronic takes 12 as year 2012\n. Well some things in Chronic are implemented kinda random (I would say) and if you use midnight it will take it as next days midnight, eg. Jan 1, midnight will return 2nd Jan 00:00. So best would be to use Jan 1, 12:00 AM or Jan 1, 00:00\nChronic can parse various formats like Jan 1, noon, 1st Jan noon, 1st Jan at noon, 1st Jan midnight, 1st Jan at midnight but results might not be what you expect. There's really no any spec or doc which says what should be values for various cases. Chronic specification are tests that are written and everything else is pretty much undefined. I'm not creator of this gem and IMO there were made some bad design decisions.\nThis is how I see Chronics internals and behavior in some cases...\n\nOkay, maybe it's not that bad, but it still requires some fixing.\n. I don't know. Based on current implementation, no it's not going to work. Chronic sees it as Jan 1, 12:00 12:00\n. Well, I personally prefer this way. Use ' everywhere and \" only where it's necessary. But it's not really big deal. Mostly it's just personal preference and everyone feels there differently. What is important is consistent style. That's needed no matter which style is used.\n. It uses :context => :future by default so it looks in future (ie. next week), it can be set to :past but that would return previous one. Seems Chronic's design haven't thought about this case and there's no :present currently.\nYou can workaround it by adding this week\nruby\nChronic.parse(\"Monday\"+\" this week\", now: Time.now)\nAlso Chronic by default uses Time.now when now is not specified so it's not required.\n. I can't reproduce, it works fine for me. Most likly something with your timezone/environment. Could you provide more details (timezone, ruby, platform)? And try with newest Chronic 0.10.2\n. Seems same as #177 and #179 caused by DST change on that day. Currently Chronic doesn't have any real support for daylight time changes. Also related bugs: #222 #147\n. There haven't been any updates regarding this issue, so it's not fixed.\n. Chronic.parse(\"T\") this is bug, it should return nil not throw exception.\nChronic.parse('2011 May 09 to 2011 June 28') this is just unsupported, but still it shouldn't raise exception. It's unsupported firstly because Chronic parses only discrete times not intervals. Secondly such format 2011 June 28 isn't implemented at all.\n. I'm not sure if Chronic is right gem for this kind of functionality. Chronic has always parsed only discrete times and not durations. Durations are parsed with chronic_duration gem\n. Also I don't think it's good idea to use minutes, it doesn't matter what you've to display to user, but most people would expect to keep seconds internally and to show only minutes would just secs / 60\n. CD also parses natural texts, for example\nChronicDuration.parse('I drank 15 beers in 3 and a half hours')`\n=> 12600.0\nMost of these tests does pass for CD and I think it might be very useful to improve CD even more if you need some specific features (eg. Span for CD). Primarily because Chronic just isn't really meant for it and then when there will be need for more duration features we'll have to reimplement lot of stuff that's already in CD. Anyway it's up to @leejarvis\nAnother thing, I think that pre_normalize part (even in parser.rb) probably should be made in other gem like datetime_normalize or maybe numerizer could implement that functionality as it's quite often required and currently everyone just reimplements it themselves. Also I think that should remove numerizer code from Chronic and just use numerizer gem as CD already uses it.\n. that would be useful functionality and would fit fine for Chronic, but I don't see how that's related to this Minutizer. When you parse such duration, it would return Span and with that can easily get length in seconds. Only currently Chronic doesn't really have any real support for such parsing, but for that feature :+1:  if you implement.\n. It does make sense. And if \"next 3 hours\" returns span then yes it's fine for Chronic. Also Minutizer isn't really needed, because Chronic already have somewhat duration support internally, for example Chronic parses \"after 3 hours\" fine. So what I mean, Chronic shouldn't expose such functionality outside and use durations only internally which it already does (take a look at repeaters). Basically such  span processing should happen same as typical parse - first we split input text in tokens, then we process each token and do rest stuff, etc. So we don't need Minutizer as we already have tokens ready for processing and that's why I'm saying Minutizer isn't good fit here but rather CD. Also Chronic support for durations is very poor as it's not DST aware (here's several issues opened about it) and should be reimplemented completely. For next week it uses week_start + WEEK_SECONDS and your Minutizer doesn't do any better. Besides seems digitize_time is kinda dublicate/same as those day/week/etc repeaters. It would be very useful to create new class ChronicDuration which would implement it all properly rather than your Minutizer.\n. No, no, don't do it in pre_normalize, it's really total hack because people couldn't implement things properly. All pre_normalizeshould actually be removed some day. Correct way to handle it would be when text is split in tokens and then processed as special holiday/season token. This is exactly reason why you can't implement \"next xmas\" with this way, because it's total hack. There's already too many hacks in this lib. And yeah I hate hacks :smile: \n. Implementing it in pre_normalize isn't good idea, because let's say we want to add feature to parse date for \"next Easter\" (or \"Easter 2015\"). Good luck figuring it out with regexp, because you just can't. Easter aren't on fixed date and will be different each year. If we've special token for it, we can calculate it when processing, but not earlier when we haven't parsed anything.\nI'm always going for proper implementations as then can easily extend to support more features, of course it takes more time to develop, but it's worth it. And mostly these quickly hacked up things have to be refactored/reimplemented later again when for example need just add some feature. Especially like now you can easily predict that there probably will be need for other dates too. And just imagine what will happen with pre_normalize if we'll keep adding 20+ other dates and more.\nProper way would be to use holidays gem then we don't have to think about dates at all as it already have them along with names (even for other languages/countries). So basically idea is that we create new token type, use that gem to match holidays and convert them to respective dates. Also probably because not everyone needs such feature so could use do_stuff if defined?(Holidays) so those who need this would just include gem.\n. Looks good :+1: but seems you also included unrelated things: duration.rb, test_parsing_span.rb, test_spanify.rb\n. \"Last Saturday in March\" is just not supported format by Chronic as it doesn't recognize \"Last\" and those other formats aren't really either, it's more of a luck that some work.\nIf you need such feature, you could try debug and implement it.\n. It also crashes on Chronic.parse(\"t\")\n. Was added in #267 and is merged in beta branch\n. it's because for this specific format Chronic expects 3 digits for milliseconds and not less or more, but yeah it should be fixed some day.\n. Nice :+1: , that clearly is a bug, it shouldn't modify state.\n. fixed with #255 as  774a66a\n. similar bug there in test_parse_guess_r starting from #526 line\nruby\n   time = parse_now(\"5\")\n   assert_equal Time.local(2006, 8, 16, 17), time\n5pm, hour is specified, thus it means it's hour precision for span and so dividing it we should get 30 seconds, eg. Time.local(2006, 8, 16, 17, 30)\nseveral next calls also should be with 30s\nand then there's bug with \n``` ruby\n    time = parse_now(\"13:45\")\n    assert_equal Time.local(2006, 8, 17, 13, 45), time\ntime = parse_now(\"1:01pm\")\nassert_equal Time.local(2006, 8, 16, 13, 01), time\n\n```\n1pm is before 14:00, thus because we look in future date it should be 17th not 16th. See how when using 13 instead of 1pm it works correctly.\nIt's funny how these tests test incorrect behavior :smiley: someone needed feature like this? :P\n. there's also other inconsistencies\n``` ruby\n   time = parse_now(\"1 week from now\")\n   assert_equal Time.local(2006, 8, 23, 14, 0, 0), time\ntime = parse_now(\"1 weekend from now\")\n   assert_equal Time.local(2006, 8, 19), time\n```\nsee how in one case we use 14:00 time but for other 0:00.\nThere's really big need for Chronic to have good specification and documentation about indented behavior as currently some cases doesn't really make sense and it's not easy to tell which would be the correct way.\n. another example\nruby\n  time = parse_now(\"3 years ago this friday\")\n  assert_equal Time.local(2003, 8, 18, 12), time\nI would think it means 3 years ago and then friday, which would be 22nd August as 18th is not Friday. Or is it meant to be this friday and then 3 years ago? Would this friday 3 years ago be same and ordering wouldn't matter or test is wrong?\n. it's awful :P incorrect tests...\n``` ruby\n  def test_handle_rdn_rmn_od_sy\n    time = parse_now(\"Thu Aug 10th 2005\")\n    assert_equal Time.local(2005, 8, 10, 12), time\ntime = parse_now(\"Thursday July 31st 2005\")\nassert_equal Time.local(2005, 7, 31, 12), time\n\ntime = parse_now(\"Thursday December 31st 2005\")\nassert_equal Time.local(2005, 12, 31, 12), time\n\ntime = parse_now(\"Thursday December 30th 2005\")\nassert_equal Time.local(2005, 12, 30, 12), time\n\nend\n```\neverything seems to be ok? but actually none of those day names are in those dates, if you take a look at 2005 year calendar you'll see. And there are several such tests with wrong day names.\n. I would also expect it to be starting from 0:00, it's just logical how dates work :D and it was really confusing for me too at first. I think in some next major version we should default to :guess => :begin because that's what most people would expect, not half of span, in some cases it doesn't make any sense to use middle of span.\n. @leejarvis will you take a look?\n. if you always need 1st then you might want to use Chronic.parse(\"monday this month\") and that does work. But yeah this is a bug and will be fixed some day.\n. I know about code :laughing: I've been working on it for a while now to improve and it's not pleasant at all. But once I'll have done it will be very trivial to fix this bug and all other issues. Only that wont be very soon.\n. Ok, I'll change comments to TomDoc syntax (I personally always use YARD)\nAbout width there's not really many choices, it seemed logical to put it before options, but if would put after then yes nils wouldn't bee needed that much. Another way would be to set it independently after initialization. But I don't really see any issue with nils there and also Repeaters will be removed later anyway (they'll be refactored in simpler tags and separate parsing) so it doesn't matter that there's nil now.\n. I updated comments to TomDoc syntax. Did you got time to review? Anything I should change?\n. @leejarvis so what about this? I just rebased, it should merge cleanly.\n. merged in beta branch\n. Looks good :), this is issue I encountered in #246\n. @leejarvis have you looked at this? I think it can be merged.\n. looks good :+1: \n. try something like\n``` ruby\nChronic.parse('this weekend', :now => Date.parse('2014-04-28'), :guess => false)\n=> 2014-05-03 00:00:00 +0300..2014-05-05 00:00:00 +0300\n```\nonly I can't guarantee that it will work for all cases.\n. Chronic being typical and buggy as usual, so currently can't do that...\nthis should work, but doesn't...\nruby\nChronic.parse('this week', :now => DateTime.parse('2014-04-28'), :guess => false)\nso currentl can do something like\n``` ruby\nChronic.parse('next week', :now => DateTime.parse('2014-04-28') - 7, :guess => false)\n=> 2014-04-27 00:00:00 +0300..2014-05-04 00:00:00 +0300\n``\n. This can be merged, but that regexp's will be removed later anyway and implemented with proper tokens.\n. just merged this inbetabranch\n. @leejarvis Looks like you're really busy? What about if I create newbetabranch and merge PRs there and then when you've time you can review them all and merge in master. But in meanwhile I can manage thatbeta` branch.\n. Cool :sunglasses: \n. It is correct. Mountain Time (US & Canada) is MDT thus -06:00\nReason why when parsing with Ruby gives you -0700 is because of your system's configured timezone which isn't MDT.\nFor example Time.strptime(ticks, \"%Q\").to_s for me gives 2014-07-05 03:33:57 +0300\n. yes, you're on MST which is -7:00, but Mountain Time (US & Canada) maps to America/Denver (and not America/Phoenix which is your timezone). America/Denver in this date range is -6:00 and will be -7:00 only in November.\nYou can verify it yourself\nruby\nrequire 'tzinfo'\nrequire 'active_support/time'\nActiveSupport::TimeZone::MAPPING['Mountain Time (US & Canada)']\n=> \"America/Denver\"\nTZInfo::Timezone.get('America/Denver').strftime('%Z')\n=> \"MDT\" # -06:00\nTZInfo::Timezone.get('America/Phoenix').strftime('%Z')\n=> \"MST\" # -07:00\n. merged in beta branch\n. that version file creation kinda don't fit here, I already had that PR made a while ago #262\n. ah, yeah I see, it's because gemspec loads whole Chronic..., but like I said, I've it addressed with #262 including fixing Rakefile#version, which currently is broken (your PR doesn't fix it either). So best would be merge #262 and then rebase this on top of it. No need for version file here.\n. merged this in beta branch\n. hmm, it works fine for me.\nruby\nChronic.parse(\"9-3-1987\")\n=> 1987-09-03 12:00:00 +0300\nwhich Ruby version are you using? also try with Chronic.debug=true to see more detailed output.\n. are you sure you've latest Chronic version 0.10.2? haven't you monkey patched anything?\nI just checked with Ruby 1.9.3, 2.0.0, 2.1.2 and it works fine for all.\nBut those your matched tokens are definitely wrong, especially 3tzminus1987(timezone), but I don't know why...\n. looks ok, merged in beta branch\n. I've encountered a lot of similar issues. Specifically this issue is already fixed in master branch.\n. this is fixed in #278, but it will take some while till it's finished and released.\n. this is same issue as #230 and was actually fixed with #243, but yeah it's not released yet.\n. seems fine. I think this could be merged and I really like all those tests :)\nBut I must say that this will be refactored later a bit differently (not only this, but all repeaters). There's some problems with current implementation. For example just q shouldn't parse as valid quarter and other similar things. Anyway no need to worry about this for now.\n. merged in beta branch. In upcoming refactoring/rewrite, implemented as 764b3c1e08d38f68fe87a4d29fb8f361aa77e5c7 (see #278 )\n. I'm not sure, I don't really like this implementation. But I agree support would be useful.\n. merged in beta branch and reimplemented as d0351763508b312eb327792d38c5d9c5ad9506b9 see how simple ;) and without hacks.\n. merged in beta branch, reimplemented as 4806e1777367429f2ab192ba4b3367129ddae7c3\nbased on this, it should be very simple to implement much more formats.\n. merged in beta branch\n. @leejarvis  have you taken a look on this? What do you think?\n. I'll first finish this so that all tests pass and only then clean it up. Also for some places I'm not sure about best implementation so it would be nice if you can give any tips what could be made better.\n. indeed :+1:\n. No, this is correct behavior as described.\nBy default it uses :endian_precedence => [:middle, :little] which means that day is middle and month is first, but if that's not possible then use other way.\nSo here\nruby\nChronic.parse(\"05/10/2014\")\n => 2014-05-10 12:00:00 +0100\nit's 10th day in 5th month.\nbut here, because it can't be 29th month, so it falls back to other.\nruby\nChronic.parse(\"29/09/2014\")\n => 2014-09-29 12:00:00 +0100\n. Note that I've started quite big changes in #278 and basically this will have to be rewritten once that is finished. For example prenormalize regexp's are completely removed. Also it's somewhat pointless to use Numerizer for other locales as currently it supports only English. So firstly should add locale support to Numerizer.\nAnother thing I'm not sure if it's good idea to put translations directly in Ruby. I think better would be to use CLDR translations and add misspellings (which are not in CLDR) in separate locale files. All translations could be stored in yaml files and loaded at runtime based on used locale. Also there could be different date/time definitions based on locale.\n. No idea, I can't reproduce, it works for me.\nruby\nChronic.parse(\"today 23:30\")\n=> 2014-10-27 23:30:00 +0200\nChronic.parse(\"today 23:45\")\n=> 2014-10-27 23:45:00 +0200\nChronic.parse(\"today 23:59\")\n=> 2014-10-27 23:59:00 +0200\n. Not a coincidence, but bug in Chronic regarding DST. Same issue as #147, #177, #179, #222, #228\nI just tested it with 26th and indeed I get nil, because here also DST changes on 26th (before I tried it on 27th). Anyway I didn't investigated exactly why, but it's not really important as I've started this rewrite #278 and on that branch it works fine (you get correct 23:01). But note that DST rollover still isn't implemented even there (Chronic have never supported that yet), but it's planned to be added later. So currently if you parse something like after 1 hour and in this hour DST changes, result wont be correct.\n. I don't think Chronic have ever supported this format (with year). But it will work when #278 will be done.\nWith that PR\nruby\nChronic.parse('2nd sunday march 2014', :guess => false) # it doesn't work with \"in\", but that will be fixed\n=> 2014-03-09 00:00:00 +0200...2014-03-10 00:00:00 +0200\n. currently Chronic doesn't support such format together with time, but it will be implemented in some next versions.\n. Note that all of pre_normalize regexp's will be removed with #278 (not done yet) because they're just generally a hacks and proper implementation will actually parse that.\n. Well, IMO I think it would be better to write from scratch than port this, just take main idea from that rewrite branch. Tokenization, Taging, Objects, Token Groups, flexible Definitions those are generally good concepts. Only this exact implementation might not be the best, there are few things I don't really like 100% but haven't figured out any better way. As for stability, it currently works for most cases and all tests from test_parsing does pass, but not other tests. There probably won't be much big changes anymore, just generally some fixes there and here as I'm pretty sure there are some edge cases not handled. Also need better test coverage and then will see how good it is. Basically need a test for every date/time format combination to be sure.\nBy the way do you know about Opal? then wouldn't need to manually do anything ;)\n. Chronic will try to extract and parse any date/time like parts of sentence. But currently there isn't a way to get which parts were used and which weren't. Also Chronic can handle only ranges like this week , but not something like between Monday and Wednesday.\nSo basically Chronic can parse any sentences with other text and not only with date, but it won't tell which parts were parsable. Also Chronic is much more complex than simple regexp and I doubt such regexp could be even created.\nAnyway feature about extracting parsed and non-parsed parts from sentence could be added, but if you need that you'll probably have to implement it yourself, it shouldn't be too hard. I would suggest to look at token_group.rb in my rewrite branch. There you can see tokens, which will contain list of all tokens from sentence (sentence is first split in tokens and then each token is tagged with it's type). Chronic is parsing this token list and separating it in Anchor/Arrow/Narrow/Date/Time/Timezone Objects. Each object is a group of sequential tokens. In to_span method from these objects actual date/time is parsed. So to get which part of sentence was parsed you just need to look which tokens was used in objects - HandlerObject#begin, HandlerObject#end will give first and last token index for that object. Then use these indexes to get token itself from token list and from token you can get it's position in sentence with Token#position.\nHere's quick code I just hacked up which will extract parsed text for datetime object. Of course full implementation will be bit more complicated because there will have to handle cases where you've to deal with multiple objects being parsed and not just one.\n``` ruby\ndatetime is instance of DateTimeObject\nfirst_token = @tokens[datetime.begin]\nlast_token = @tokens[datetime.end]\nparsed_text_start = first_token.position\nparsed_text_end  = last_token.position\nparsed_text_end += last_token.word.length\nparsed_text = first_token.text[parsed_text_start...parsed_text_end]\nbefore_parsed_text = first_token.text[0...parsed_text_start]\nafter_parsed_text = first_token.text[parsed_text_end, first_token.text.length]\n```\n``` ruby\nChronic.parse('An important event will happen 2014-12-01T00:00:00!!!')\nparsed_text will be \"2014-12-01T00:00:00\"\nbefore_parsed_text will be \" An important event will happen \"\nafter_parsed_text will be \"!!!\"\n```\n. Yeah, it's looks like same bug and no worries about duplicate issue. Also officially it's not yet fixed, but it does work correctly in my rewrite branch, #278 \nBy the way you can pass time with now, like\nruby\nChronic.parse(\"1st wednesday of this month\", :now => Time.parse('2020-04-01 00:00:00 +0000'))\n. Yeah, it's a known bug. #222 and #147\nAlso it's not really fixed yet (but this case works correctly in my rewrite branch #278)\n. that's really really weird. What debugger are you using? it works fine with IRB for me.\n. indeed looks like a bug\n. these work on 0.10.2 and on master\nruby\nChronic.parse('1000-01-01')\n=> 1000-01-01 12:00:00 +0200\nChronic.parse('0999-01-01')\n=> 0999-01-01 12:00:00 +0200\nChronic.parse('0000-01-01') is expected to be nil, I don't think anyone would encounter such valid date.\nruby\nChronic.parse('999-01-01')\nChronic.parse('100-01-01')\nthese probably won't work in future versions unless there's a good reason to implement them, because typically year is always 4 digits and it doesn't really make sense with 3 digits and what about Chronic.parse('10-01-01')? that might be short year notation so it wouldn't be possible to specify 10year anyway.\n. yeah, it's a bug, will probably be fixed in some next version\n. I'm not sure such format have ever been supported...\n. that's kinda expected, because by default :context => :future, but current version is still bugged... currently you can use some hacks like subtracting day or using  :context => :past for this case...\nin next, yet unreleased version (my rewrite branch) it will be\n``` ruby\nChronic.parse('monday', :context => nil)\n2015-02-09 12:00:00 +0200\nChronic.parse('this monday', :context => nil)  # this is debatable if it should be today...\n2015-02-16 12:00:00 +0200\nChronic.parse('monday at 16:30', :context => nil)\n2015-02-09 16:30:30 +0200\n``\n. it's not really implemented so...context: nilwould return Monday in that week so for Tuesday it would be like last Monday, for your case seems you needcontext: :futurebut just some flag so that current day is returned if it's Monday which is only exception\n. I've been thinking about such feature for next version as I also find this needed and useful, but I haven't decided yet about best implementation.\n. I don't recommend working much on currentmasterbranch because those changes will have to be reworked for next version, I'verewritebranch in progress, see #278 and definitions are changed quite radically there... but if you need this change soon then just go for it.\n. It's a known bug  #230, #272 and it's fixed onmaster` (with  #243) but haven't released yet.\n. It's DST related, currently Chronic almost always breaks on DST change... There are dozens of similar bugs, it will be fixed some day.\n. It must be some conflict/monkey-patching by some other gem as there haven't been any changes to Chronic for a while and it works fine for me. Look into what gems and versions are loaded to find cause.\n. Don't worry about fixing, there's ongoing rewrite of large part of Chronic and I know how big mess current code is. Also actually this is fixed in my rewrite branch\nruby\nChronic.parse(\"2nd Sunday of next May\", :guess => false)\n=> 2016-05-08 00:00:00 +0300...2016-05-09 00:00:00 +0300\nBut that rewrite isn't finished and I'll have time to continue work on it only in autumn. So for now you'll have to somehow workaround it yourself.\n. yeah I think this can be used, what do you @leejarvis think? also might as well merge beta branch in master and release it as there are some fixes and it's been sitting there for ages.\n. I'm not sure what you mean? It looks correct to me.\n``` ruby\nby default, :context => :future and :hours24 => nil\nwhich means it will take best guess\nyou ran it before 17:30 so closest time to 5:30 is 17:30\nChronic.parse(\"5:30\", endian_precedence: :little)\n=> 2015-05-29 17:30:00 +0300\n05:30 forces :hours24 => true so it will definitely be 05:30\nChronic.parse(\"29/05/2015 05:30\", endian_precedence: :little)\n=> 2015-05-29 05:30:00 +0300\nno date specified and closest 05:30 is only tomorrow so\nChronic.parse(\"05:30\", endian_precedence: :little)\n=> 2015-05-30 05:30:00 +0300\n``\n. I already mentionedby default, :context => :future and :hours24 => nilso you just pass:hours24 => true;)\n. Chronic doesn't really support such complex queries and mostly it's luck based whether it will get it correct :D anyway this works fine in myrewritebranch, but it's nowhere near ready for usage.\n. with \"works fine in my rewrite branch\" I mean, it works there as it should producing correct output - feature already implemented there :)\n. kinda not really... basically @leejarvis is current maintainer but haven't seen him respond to anything for a while. I worked on rewrite #278 which would solve most of issues but I haven't had time to complete it yet. It's still on my TODO list, just need to find time when I'll be able to finish it. Also even before that rewrite there are several PRs which could be merged and some are merged inbeta` branch.\n. I've written few comments about it on this reddit thread\nFor my latest code see #347\nThere's still few minor things left to do and biggest part is testing it. Also I had thought out how to implement everything that's left but haven't written that code yet, it's basically just Timezone/DST work. It already should work but there might be some cases which need work (like performance, see my reddit comment)\n. yeah, it's a bug, it's fixed in my rewrite branch but that's not ready yet and will be released as next major version.\n. why month should return end of month? it's actually not supported and that it returns anything at all is just pure luck. \nfor now you can use\nruby\nChronic.parse(\"1 day before next month\", :guess => :begin)\n=> 2016-02-29 00:00:00 +0200\n. I think this format isn't really supported... and see #316, if you want to make PR do it for my rewrite branch, it's still work in progress and not finished but I'll work on it when I'll have time.\nEDIT: actually it seems to be working, but you need to use :context => :past\n. I can't reproduce it and I suspect it's DST related, can you show example of how you parse it and which timezone is used?\n. It's definitely DST related bug.\nFor me with EET timezone it's Chronic.parse('2016-03-27 12am') which gives nil and not your time.\nHandler: handle_sy_sm_sd\nHandler-class: Chronic::RepeaterDayPortion\n--(2016-03-27 00:00:00 +0200..2016-03-27 11:59:59 +0300)\nAnd it makes sense because in this day clock is turned +1h ahead so essentially there's 1 hour missing and thus nil because that hour can't exist, but there's bug that it's not 12am when it's +1h but from 3am becomes 4am and there isn't 3am.\nAnyway it's known that Chronic have loads of DST issues and it's pretty much broken there, but I've a rewrite branch and there never returns nil, tested with your script and for DST change it returns same hour twice, so that 3am returns 4am for me because 3am doesn't exist.\n. because DST change happens only in that day, in other day it moves -1h back thus same hour appears twice and it does exist unlike in this case.\n. you need add :guess => :begin option like Chronic.parse('today at 9:00 am', :guess => :begin)\nit's because current Chronic version gets interval and takes middle of it but it did so very inconsistently and that was fixed there by always using correct interval range.\nfor example current Chronic\n``` ruby\nChronic.parse('today', :guess => false)\n=> 2016-03-15 02:00:00 +0200..2016-03-16 00:00:00 +0200\nChronic.parse('today')\n=> 2016-03-15 13:00:00 +0200 # we're in middle of range\nChronic.parse('today', :guess => :begin)\n=> 2016-03-15 02:00:00 +0200\nChronic.parse('today at 7am', :guess => false)\n=> 2016-03-15 07:00:00 +0200..2016-03-15 07:00:01 +0200 # it's second precision, but minutes weren't specified...\nChronic.parse('today at 7am')\n=> 2016-03-15 07:00:00 +0200 # if \"today\" was middle, why not this?\n```\nwith my rewrite branch it's always consistent\n``` ruby\n Chronic.parse('today', :guess => false)\n=> 2016-03-15 02:00:00 +0200...2016-03-16 00:00:00 +0200\n Chronic.parse('today')\n=> 2016-03-15 13:00:0 +0200 # middle of today's range\nChronic.parse('today', :guess => :begin)\n=> 2016-03-15 02:00:00 +0200\nChronic.parse('today at 7am', :guess => false)\n=> 2016-03-15 07:00:00 +0200...2016-03-15 08:00:00 +0200 # now 1h precision\nChronic.parse('today at 7am')\n=> 2016-03-15 07:30:00 +0200 # also middle of interval\nChronic.parse('today at 7:30am', :guess => false)\n=> 2016-03-15 07:30:00 +0200...2016-03-15 07:31:00 +0200 # 1m precision because minutes specified\n```\nanyway that branch is still work in progress and while there's a lot of work done and basically almost all tests pass and there aren't expected to be big changes anymore there still might be some new bugs. But it does have fixed a lot of current Chronic's issues, especially regarding DST.\nPRs always welcome and on that branch if there's no test for particular date/time format it's considered unsupported so need tests for all formats.\n. It's that way only because it was that way before, I mean with current Chronic.parse('today'), if I change to :begin then it won't match previous behavior but yeah I agree that even before it was really stupid idea to and maybe it's worth changing to default which seems like good idea.\nand yes, I can't really recommend using it yet, I myself wouldn't use it yet :D it needs much more testing and fixing some things. Only I don't know when I'll have time to work on it again, but all code is there up so everything's that there is there and any PRs would be great.\n. btw about that work I did on rewrite branch see #278 \n. FYI, I've started on rewrite a while ago, see my comment on #316\n. It is known issue that Chronic doesn't work correctly when DST is involved, there are loads of such issues. There isn't really much you can do about it as Chronic is just broken in this case.\nAnyway it will be fixed in next Chronic version as I'm working on quite big rewrite which fixes a lot of issues including DST but it's unknown when it will be finished.\n. It works a bit better in my rewrite branch, for more info see #278\nBut that rewrite isn't really finished yet... and there it would be really easy to add support for all these cases.\n. yeah, that is also a bug, and it should be pretty easy to add support for this format once #278 is finished\n. Chronic is actually missing such feature... There's a parameter context but currently it supports only :past and :future\nI've been working on #278 which fixes a lot of issues and it does implement this feature but it's not really ready yet...\nwith my rewrite branch\nruby\ndate = DateTime.parse('2016-10-03')\nChronic.parse(\"monday\", now: date, context: :past)\n=> 2016-09-26 12:00:00 +0300\nChronic.parse(\"monday\", now: date, context: :present)\n=> 2016-10-03 12:00:00 +0300\nChronic.parse(\"monday\", now: date, context: :future)\n=> 2016-10-10 12:00:00 +0300\n. Looks fine to me, but it will be needed to rebase it on rewrite. Also I'm not actually maintainer of this project, but I do have push access.\n. I've been working on #278 (which rewrites quite a bit of logic) for some while but it's still unfinished and lately I haven't had time to continue it but I still plan on finishing it eventually and you should look at it since it doesn't need this at all...\n. Returns nil in my rewrite branch. yup, it is known DST issue #282, #147, #177, #179, #222, #228 and it's actually fixed in my unfinished rewrite branch, but no idea when I'll finish it.\n. It's actually been almost finished for really long time (more than a year) I just haven't been working on it for ages. For more info see #316 \nAnyway I just fixed last tests so now they all pass but it doesn't mean everything is working since there might be cases not covered by tests but they can be fixed once they come up.\n```\nRunning:\n......................................................................................................\nFinished in 11.438857s, 8.9170 runs/s, 67.4893 assertions/s.\n102 runs, 772 assertions, 0 failures, 0 errors, 0 skips\nCoverage report generated for Unit Tests to coverage. 3306 / 3528 LOC (93.71%) covered.\n```\nYou can try and test it already #347\nOnly thing that's left to do is finish timezone support and then could release beta version. When that will happen no idea, but it could be ~soonish.\n. Seems to work in my rewrite branch\n. Such format currently isn't supported but will be in next version (it's already implemented).\n. @macobo Look at #347 and my comments on Reddit\nhaven't really gotten time to still finish it.\n. See #316 \nHaven't had time to be done with this, but should be soonish. \n. you should rebase it on my rewrite branch, see #347 (and #278). Once I'll have that finished it will be merged in master.\n. could if it would be implemented but for now look into other libraries. Looks like same issue as #295\nIt's fixed in my rewrite branch which isn't ready yet.\n. This format isn't implemented, but it already works in my unfinished rewrite branch (#347). There it's very easy to add new date/time formats (lib/chronic/definition.rb). It's fixed in my rewrite branch. It's fixed in my rewrite branch. Fixed with #359. If you already now format, you could use just Date.strptime(str, \"%d/%m/%y\")\nCurrently for Chronic there isn't builtin option, but you can override Definitions\nsee lib/chronic/definition.rb\nNote that in my rewrite branch which will be next major release this format is changed lib/chronic/definition.rb. It is kinda known issue there are a lot of bugs with current Chronic release as you can see from issue count. Most of them, including this one is fixed in my rewrite branch #347 . About it's state you can read https://github.com/mojombo/chronic/issues/344#issuecomment-320060105\nBasically it already should be fine to use, only thing that's not done is timezone name support and there might be issues about which I don't know since it's not really been used but all original Chronic tests does pass.\n. I don't think this is that useful generally for anyone else to be in Chronic. Especially if you parse date in past or in future then how current time is relevant to it. You could just get time and set it yourself on returned result.\nBut what would be useful for Chronic would be to return if there were only Time part, only Date part or Date and Time. There could be different method like Chronic.analyse(time_string) which could give more information about provided time string.\nAnyway this is what I suggest you could do\n``ruby\nnow = Time.now\nparsed = Chronic.parse(time_string, :guess => false).begin\nif parsed.hour == 0 and parsed.min == 0 and parsed.sec == 0\n    # assume user didn't specify time, we'll be wrong in case user specified 00:00:00\n    with_time = Time.new(parsed.year, parsed.month, parsed.day, now.hour, now.min, now.sec)\nelse\n    with_time = parsed\nend\n````\n. I've been working onrewrite` for some time, it will be finished soonish, see #347 \nThere it's super easy to add support for new formats, and I just added this one there, see ec658809213d659e99a36d7aec1b561a143450aa\n. Currently it's not possible, but in my rewrite branch it would be very simple to implement it.\n. I would say currently there isn't really any maintainer since I just happened to work on this but I wouldn't call myself as a real maintainer. I just want to fix some bugs and add support for features I need :D . Anyway I do have git commit access but no access to rubygems so I can't release new gem. But when I'll be done I'll merge my branch in master and contact @leejarvis on Twitter to get new gem out, but before merge release a new version and then one after.\nAbout my rewrite branch progress you can read my comment on #344 . I would say it's pretty much all done and there won't be any big changes. Only thing that's left to do is timezone name parsing. For that currently I've been working on rewriting my TimezoneParser gem to improve performance (switch from Marshal to SQLite) which is used in my rewrite branch. Then once that is done I'll probably go over all GitHub issues and fix them and make a release. But when this will happen it's hard to say as I'm doing this in my free time and not that often.\nAbout that C# port, I had never seen it before but I think it really wasn't good idea to make direct port but way better would have been take this code as inspiration and as an example but create it from scratch  based on these ideas. I don't really know what would be best way to update and port it, like my rewrite changes a lot of things, I would recommend you to take a look at code and see yourself #347 \n. it's a known DST issue #344 but it's fixed in my rewrite branch #347 and works there fine.\n. FYI it's been fixed (a long with a lot of other issues) in my rewrite branch #347 . But there already is such option...\n```ruby\n Chronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-24'))\n=> 2017-10-23 00:00:00 +0300..2017-10-24 00:00:00 +0300\nChronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-23'))\n=> 2017-10-20 00:00:00 +0300..2017-10-21 00:00:00 +0300\nChronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-22'))\n=> 2017-10-20 00:00:00 +0300..2017-10-21 00:00:00 +0300\nChronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-21'))\n=> 2017-10-20 00:00:00 +0300..2017-10-21 00:00:00 +0300\nChronic.parse('last weekday', :guess => false, :context => :past, :now => Time.parse('2017-10-20'))\n=> 2017-10-19 00:00:00 +0300..2017-10-20 00:00:00 +0300\n``\n. That's because version you use doesn't havemiddaysupport, it's only implemented inmaster` branch where it does work correctly.\n. Such format isn't supported.. Yeah, that's why it's also a bug but there are a lot of inputs which could crash it, you should catch those exceptions even if Chronic would be 100% safe.\n. ",
    "bsiggelkow": "This is still failing for\n\nChronic.parse \"5/19/2011 01:10 PM\"\n\n. This is still failing for\n\nChronic.parse \"5/19/2011 01:10 PM\"\n\n. ",
    "precipice": "Drat, just noticed that eric/chronic@aa803c79341d5f9756cdbc8b0907456327c56a9f fixes the same bug. Bummer.\n. Drat, just noticed that eric/chronic@aa803c79341d5f9756cdbc8b0907456327c56a9f fixes the same bug. Bummer.\n. ",
    "SixArm": "+1\nrake aborted!\nundefined local variable or method hour_begin' for repeater-hour:Chronic::RepeaterHour\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/repeaters/repeater_hour.rb:39:inthis'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:399:in find_within'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:377:inget_anchor'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:270:in handle_r'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:77:inblock in tokens_to_span'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:73:in each'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:73:intokens_to_span'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/chronic.rb:92:in `parse'\n...\n. Here's a simple way to replicate the error:\n\n\n$ ruby -v\nruby 1.9.2p180 (2011-02-18 revision 30909) [i686-linux]\n$ irb\nirb(main):001:0> require 'chronic'\n=> true\nirb(main):002:0> Chronic.parse('tomorrow')\n=> 2011-04-14 12:00:00 -0700\nirb(main):003:0> Chronic.parse('1 hour')\nNameError: undefined local variable or method `hour_begin' for repeater-hour:Chronic::RepeaterHour\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/repeaters/repeater_hour.rb:39:in `this'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:399:in `find_within'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:377:in `get_anchor'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:270:in `handle_r'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:77:in `block in tokens_to_span'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:73:in `each'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:73:in `tokens_to_span'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/chronic.rb:92:in `parse'\n    from (irb):3\n    from /opt/ruby/192p180/bin/irb:12:in `'\n\n. +1\nrake aborted!\nundefined local variable or method hour_begin' for repeater-hour:Chronic::RepeaterHour\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/repeaters/repeater_hour.rb:39:inthis'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:399:in find_within'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:377:inget_anchor'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:270:in handle_r'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:77:inblock in tokens_to_span'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:73:in each'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:73:intokens_to_span'\n/opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/chronic.rb:92:in `parse'\n...\n. Here's a simple way to replicate the error:\n\n\n$ ruby -v\nruby 1.9.2p180 (2011-02-18 revision 30909) [i686-linux]\n$ irb\nirb(main):001:0> require 'chronic'\n=> true\nirb(main):002:0> Chronic.parse('tomorrow')\n=> 2011-04-14 12:00:00 -0700\nirb(main):003:0> Chronic.parse('1 hour')\nNameError: undefined local variable or method `hour_begin' for repeater-hour:Chronic::RepeaterHour\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/repeaters/repeater_hour.rb:39:in `this'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:399:in `find_within'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:377:in `get_anchor'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:270:in `handle_r'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:77:in `block in tokens_to_span'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:73:in `each'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/handlers.rb:73:in `tokens_to_span'\n    from /opt/ruby/192p180/lib/ruby/gems/1.9.1/gems/chronic-0.3.0/lib/chronic/chronic.rb:92:in `parse'\n    from (irb):3\n    from /opt/ruby/192p180/bin/irb:12:in `'\n\n. ",
    "snoblenet": "Ah, the answer was to stop looking at the Rdoc, and to look at the code instead.\nHad great luck with: \nNumerizer.numerize(\"eight\")\n. Ah, the answer was to stop looking at the Rdoc, and to look at the code instead.\nHad great luck with: \nNumerizer.numerize(\"eight\")\n. ",
    "darkhelmet": "This is affecting me too.\n. This is affecting me too.\n. ",
    "evanwalsh": "+1\n. +1\n. ",
    "basicxman": "50 seems quite large.  I would consider lowering this to 10.  Pleading my case:\nYou have a web application in the current year of 2011, what are the chances an end-user is going to enter a date later than 2021 somewhere?  With 50 I could enter 61 and frankly I would think that to be 1961.\nI think perhaps\n    if entered_year <= now + 10; future; else; past; end\n. 50 seems quite large.  I would consider lowering this to 10.  Pleading my case:\nYou have a web application in the current year of 2011, what are the chances an end-user is going to enter a date later than 2021 somewhere?  With 50 I could enter 61 and frankly I would think that to be 1961.\nI think perhaps\n    if entered_year <= now + 10; future; else; past; end\n. ",
    "nashby": "Sure, your pull request is better.\n. ruby\nirb(main):002:0> Chronic.parse(\"4/5/2011\")\n=> 2011-04-05 12:00:00 +0300\nirb(main):003:0> Chronic.parse(\"4/5/2011\", {:endian_precedence => [:little, :middle]})\n=> 2011-05-04 12:00:00 +0300\nhttps://github.com/mojombo/chronic/blob/master/lib/chronic/chronic.rb#L52\n. ruby\nirb(main):002:0> Chronic::DEFAULT_OPTIONS[:endian_precedence] = [:little, :middle]\nirb(main):003:0> Chronic.parse(\"4/5/2011\")\n=> 2011-05-04 12:00:00 +0300\nif I understood you right.\n. Sure, your pull request is better.\n. ruby\nirb(main):002:0> Chronic.parse(\"4/5/2011\")\n=> 2011-04-05 12:00:00 +0300\nirb(main):003:0> Chronic.parse(\"4/5/2011\", {:endian_precedence => [:little, :middle]})\n=> 2011-05-04 12:00:00 +0300\nhttps://github.com/mojombo/chronic/blob/master/lib/chronic/chronic.rb#L52\n. ruby\nirb(main):002:0> Chronic::DEFAULT_OPTIONS[:endian_precedence] = [:little, :middle]\nirb(main):003:0> Chronic.parse(\"4/5/2011\")\n=> 2011-05-04 12:00:00 +0300\nif I understood you right.\n. ",
    "jfriedlaender": "Thanks for the quick response. This will do the trick (despite my terrible 5/5/2011 example I just noticed i gave).\nIt would still be one step better to be able to set this once for a user like I can do with Chronic.time_class.\n. I clicked comment and close by accident, would like to hear your thoughts on my last comment. Thanks.\n. You understood perfectly, thank you very much!\n. Thanks for the quick response. This will do the trick (despite my terrible 5/5/2011 example I just noticed i gave).\nIt would still be one step better to be able to set this once for a user like I can do with Chronic.time_class.\n. I clicked comment and close by accident, would like to hear your thoughts on my last comment. Thanks.\n. You understood perfectly, thank you very much!\n. ",
    "gamov": "Hello,\nI think it would be worth a comment about this in the README.\n. Hello,\nI think it would be worth a comment about this in the README.\n. ",
    "eric": "Hah. Sorry about that, I somehow missed that. Thanks!\n. Hah. Sorry about that, I somehow missed that. Thanks!\n. ",
    "tuo": "Sorry for the late reply. It really works! Many thanks!\nOn Sat, Jun 11, 2011 at 9:41 PM, injekt \nreply@reply.github.comwrote:\n\nI'm going to close this, please re-open if you have a working repro against\nthe latest stable version of Chronic. Thanks!\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/47#issuecomment-1348291\n. Sorry for the late reply. It really works! Many thanks!\n\nOn Sat, Jun 11, 2011 at 9:41 PM, injekt \nreply@reply.github.comwrote:\n\nI'm going to close this, please re-open if you have a working repro against\nthe latest stable version of Chronic. Thanks!\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/47#issuecomment-1348291\n. \n",
    "jszmajda": "Sure! For reference, this is how it works now:\nirb(main):002:0> Chronic.parse('2011-07-11')\n=> Mon Jul 11 12:00:00 -0400 2011\nirb(main):003:0> Chronic.parse('tomorrow')\n=> Tue Jul 12 12:00:00 -0400 2011\nI'd love to be able to do something like this:\nirb(main):002:0> Chronic.parse('2011-07-11', :default_time => Time.mktime(2000,1,1,10,32,12))\n=> Mon Jul 11 10:32:12 -0400 2011\nor\nirb(main):003:0> Chronic.parse('tomorrow', :default_time => \"13:37:15\")\n=> Tue Jul 12 13:37:15 -0400 2011\n(note the time changes)\nI need to set it up such that Chronic.parse('today') gives today at 00:00:00 instead of today at noon.\nThanks!\n. I did think of that, but the problem is detecting when the user has specified a time component already. I could do the same sort of parsing work Chronic is already doing to detect that, or something simpler, but the only way to really solve the problem (I think) is to have Chronic do it during the parsing.\nMaybe you could point me to where the noon default comes from? I wasn't able to find it in a cursory dig-through.\n. Ah, it's in #guess. We could easily expand the guess option (or add a new one) to adjust where to guess within a given span. That would solve my issue. Here's a couple ideas:\nsymbols with fixed definitions:\nChronic.parse('tomorrow', :guess => :beginning) #=> 2011-07-12 00:00:00 +0100\nChronic.parse('tomorrow', :guess => :middle)    #=> 2011-07-12 12:00:00 +0100\nChronic.parse('tomorrow', :guess => :end)       #=> 2011-07-13 00:00:00 +0100\nor a guessing lambda:\nChronic.parse('tomorrow', :guess => lambda{|span| span.begin })                    #=> 2011-07-12 00:00:00 +0100\nChronic.parse('tomorrow', :guess => lambda{|span| span.begin + (span.width / 3) }) #=> 2011-07-12 08:00:00 +0100\n. I hadn't noticed :guess => false returns a span. I think that would work for me. The only (limited) benefit I can see of passing the lambda at this point is perhaps currying out an application-standardized method, and that it's interesting ;)\nThanks! \n. Sure! For reference, this is how it works now:\nirb(main):002:0> Chronic.parse('2011-07-11')\n=> Mon Jul 11 12:00:00 -0400 2011\nirb(main):003:0> Chronic.parse('tomorrow')\n=> Tue Jul 12 12:00:00 -0400 2011\nI'd love to be able to do something like this:\nirb(main):002:0> Chronic.parse('2011-07-11', :default_time => Time.mktime(2000,1,1,10,32,12))\n=> Mon Jul 11 10:32:12 -0400 2011\nor\nirb(main):003:0> Chronic.parse('tomorrow', :default_time => \"13:37:15\")\n=> Tue Jul 12 13:37:15 -0400 2011\n(note the time changes)\nI need to set it up such that Chronic.parse('today') gives today at 00:00:00 instead of today at noon.\nThanks!\n. I did think of that, but the problem is detecting when the user has specified a time component already. I could do the same sort of parsing work Chronic is already doing to detect that, or something simpler, but the only way to really solve the problem (I think) is to have Chronic do it during the parsing.\nMaybe you could point me to where the noon default comes from? I wasn't able to find it in a cursory dig-through.\n. Ah, it's in #guess. We could easily expand the guess option (or add a new one) to adjust where to guess within a given span. That would solve my issue. Here's a couple ideas:\nsymbols with fixed definitions:\nChronic.parse('tomorrow', :guess => :beginning) #=> 2011-07-12 00:00:00 +0100\nChronic.parse('tomorrow', :guess => :middle)    #=> 2011-07-12 12:00:00 +0100\nChronic.parse('tomorrow', :guess => :end)       #=> 2011-07-13 00:00:00 +0100\nor a guessing lambda:\nChronic.parse('tomorrow', :guess => lambda{|span| span.begin })                    #=> 2011-07-12 00:00:00 +0100\nChronic.parse('tomorrow', :guess => lambda{|span| span.begin + (span.width / 3) }) #=> 2011-07-12 08:00:00 +0100\n. I hadn't noticed :guess => false returns a span. I think that would work for me. The only (limited) benefit I can see of passing the lambda at this point is perhaps currying out an application-standardized method, and that it's interesting ;)\nThanks! \n. ",
    "chrismhilton": "That works an absolute treat - many thanks for the swift reply. Any ideas when v0.6 might be released? I only ask so I know whether to bother changing my code.\n. The end of week will be absolutely great for me. Thanks again,\n. That works an absolute treat - many thanks for the swift reply. Any ideas when v0.6 might be released? I only ask so I know whether to bother changing my code.\n. The end of week will be absolutely great for me. Thanks again,\n. ",
    "noazark": "I am about to take a shot at building it in. I agree that an Array would probably be smarter, so I'll take it in that direction. The whole repeater thing is what I was basing this off of. It makes a lot of sense to keep the repeater names, it would provide more granularity anyways. I'll let you know how it goes.\n. I've taken a stab at it, need to try again.\n. I believe the problem may be coming from chronic.rb:102-130. Chronic replaces all periods with semi-colons. Is this even a common use case? Is there a better way to handle this based on the unit of measure?\n. I am about to take a shot at building it in. I agree that an Array would probably be smarter, so I'll take it in that direction. The whole repeater thing is what I was basing this off of. It makes a lot of sense to keep the repeater names, it would provide more granularity anyways. I'll let you know how it goes.\n. I've taken a stab at it, need to try again.\n. I believe the problem may be coming from chronic.rb:102-130. Chronic replaces all periods with semi-colons. Is this even a common use case? Is there a better way to handle this based on the unit of measure?\n. ",
    "solidsnack": "There seems to be a problem with the tests. A clean clone from master fails in test_parse_guess_gr:\n```\n :; git clone git://github.com/mojombo/chronic.git\nCloning into chronic...\nremote: Counting objects: 2059, done.\nremote: Compressing objects: 100% (955/955), done.\nremote: Total 2059 (delta 1344), reused 1784 (delta 1085)\nReceiving objects: 100% (2059/2059), 277.02 KiB | 338 KiB/s, done.\nResolving deltas: 100% (1344/1344), done.\n :; cd chronic/\n :; rake test                                                                   (in /home/solidsnack/sandbox/chronic/tmp/chronic)\n/usr/bin/ruby1.8 -I\"lib:lib:test\" \"/var/lib/gems/1.8/gems/rake-0.8.7/lib/rake/rake_test_loader.rb\" \"test/test_RepeaterWeekend.rb\" \"test/test_RepeaterHour.rb\" \"test/test_Span.rb\" \"test/test_MiniDate.rb\" \"test/test_parsing.rb\" \"test/test_RepeaterMinute.rb\" \"test/test_RepeaterYear.rb\" \"test/test_Handler.rb\" \"test/test_RepeaterMonth.rb\" \"test/test_RepeaterTime.rb\" \"test/test_RepeaterFortnight.rb\" \"test/test_RepeaterWeek.rb\" \"test/test_RepeaterDayName.rb\" \"test/test_RepeaterWeekday.rb\" \"test/test_Numerizer.rb\" \"test/test_RepeaterSeason.rb\" \"test/test_Token.rb\" \"test/test_DaylightSavings.rb\" \"test/test_RepeaterMonthName.rb\" \"test/test_Chronic.rb\"                                                                        Loaded suite /var/lib/gems/1.8/gems/rake-0.8.7/lib/rake/rake_test_loader        Started\n............................................................F.............................................................                                      Finished in 0.434959 seconds.                                              \n  1) Failure:\ntest_parse_guess_gr(TestParsing) [./test/test_parsing.rb:409]:\n expected but was\n.\n122 tests, 506 assertions, 1 failures, 0 errors\nrake aborted!\nCommand failed with status (1): [/usr/bin/ruby1.8 -I\"lib:lib:test\" \"/var/li...]                                                                                                                                                                 (See full trace by running task with --trace)\n```\nThis test and the one after are the only two that fail; commenting them out leads to success. I will write some some tests for the TZ stuff but I am not sure what to be done about these year tests.\n. :; ruby --version && date +%Z \nruby 1.8.7 (2010-08-16 patchlevel 302) [x86_64-linux]\nUTC\n. Did anyone else try on Linux?\n```\n :; cat /etc/issue && uname -a\nUbuntu 11.04 \\n \\l\nLinux nimbrethil 2.6.38-10-generic #46-Ubuntu SMP Tue Jun 28 15:07:17 UTC 2011 x86_64 x86_64 x86_64 GNU/Linux\n```\n. There seems to be a problem with the tests. A clean clone from master fails in test_parse_guess_gr:\n```\n :; git clone git://github.com/mojombo/chronic.git\nCloning into chronic...\nremote: Counting objects: 2059, done.\nremote: Compressing objects: 100% (955/955), done.\nremote: Total 2059 (delta 1344), reused 1784 (delta 1085)\nReceiving objects: 100% (2059/2059), 277.02 KiB | 338 KiB/s, done.\nResolving deltas: 100% (1344/1344), done.\n :; cd chronic/\n :; rake test                                                                   (in /home/solidsnack/sandbox/chronic/tmp/chronic)\n/usr/bin/ruby1.8 -I\"lib:lib:test\" \"/var/lib/gems/1.8/gems/rake-0.8.7/lib/rake/rake_test_loader.rb\" \"test/test_RepeaterWeekend.rb\" \"test/test_RepeaterHour.rb\" \"test/test_Span.rb\" \"test/test_MiniDate.rb\" \"test/test_parsing.rb\" \"test/test_RepeaterMinute.rb\" \"test/test_RepeaterYear.rb\" \"test/test_Handler.rb\" \"test/test_RepeaterMonth.rb\" \"test/test_RepeaterTime.rb\" \"test/test_RepeaterFortnight.rb\" \"test/test_RepeaterWeek.rb\" \"test/test_RepeaterDayName.rb\" \"test/test_RepeaterWeekday.rb\" \"test/test_Numerizer.rb\" \"test/test_RepeaterSeason.rb\" \"test/test_Token.rb\" \"test/test_DaylightSavings.rb\" \"test/test_RepeaterMonthName.rb\" \"test/test_Chronic.rb\"                                                                        Loaded suite /var/lib/gems/1.8/gems/rake-0.8.7/lib/rake/rake_test_loader        Started\n............................................................F.............................................................                                      Finished in 0.434959 seconds.                                              \n  1) Failure:\ntest_parse_guess_gr(TestParsing) [./test/test_parsing.rb:409]:\n expected but was\n.\n122 tests, 506 assertions, 1 failures, 0 errors\nrake aborted!\nCommand failed with status (1): [/usr/bin/ruby1.8 -I\"lib:lib:test\" \"/var/li...]                                                                                                                                                                 (See full trace by running task with --trace)\n```\nThis test and the one after are the only two that fail; commenting them out leads to success. I will write some some tests for the TZ stuff but I am not sure what to be done about these year tests.\n. :; ruby --version && date +%Z \nruby 1.8.7 (2010-08-16 patchlevel 302) [x86_64-linux]\nUTC\n. Did anyone else try on Linux?\n```\n :; cat /etc/issue && uname -a\nUbuntu 11.04 \\n \\l\nLinux nimbrethil 2.6.38-10-generic #46-Ubuntu SMP Tue Jun 28 15:07:17 UTC 2011 x86_64 x86_64 x86_64 GNU/Linux\n```\n. ",
    "darix": "i can reproduce it on linux with:\nTZ=UTC rake test\nTZ=CEST rake test\nit passes with:\nTZ=CET rake test\n. i can reproduce it on linux with:\nTZ=UTC rake test\nTZ=CEST rake test\nit passes with:\nTZ=CET rake test\n. ",
    "tbarho": "Chronic.parse('05/06 at noon') => nil\nChronic.parse('05-06 at noon') => nil\nIs this the same issue?\n. Chronic.parse('05/06 at noon') => nil\nChronic.parse('05-06 at noon') => nil\nIs this the same issue?\n. ",
    "simon1tan": "Hi, I'd like to seem month-day implemented for cases such as 8-15. Thanks.\n. Hi, I'd like to seem month-day implemented for cases such as 8-15. Thanks.\n. ",
    "grantovich": "The issue @tbarho mentioned seems to still exist. Using the month/day or day/month format while also specifying a time returns nil. Should this be a separate issue?\n. The attached pull request fixes this issue and includes test cases for it.\n. The issue @tbarho mentioned seems to still exist. Using the month/day or day/month format while also specifying a time returns nil. Should this be a separate issue?\n. The attached pull request fixes this issue and includes test cases for it.\n. ",
    "troy": "Thanks @injekt, I appreciate it. That all makes sense.\nFor any other readers, I think that for user-submitted timestamps, the viable solutions today are supporting a few specific formats, or presenting the parsed version back to the user so they can see the parsed time (ideally in realtime). \"Enter what you want\" is not feasible, nor is presenting errors on submission (some of the times do parse, they just aren't what the user expected).\n. When context is not provided, I could see the default going either way. For the default, I think it's more important to document how it behaves than to pick the exact right case - as you said, there isn't one right default for everyone.\nHowever, it should never ignore context when explicitly provided. That was the origin of this issue, and I think a lot more important than getting the default right. If the app developer is willing to spend the effort to decide authoritatively which context is correct for them, it should be honored.\nI'd argue that it should raise an exception when it can't honor the context (rather than, say, returning a future time with context of past). Obviously that's not going to happen right now given that it ignores context for certain inputs, but I think that is the correct behavior when one is given. As a library consumer, I don't ever want a future time returned :)\n. Thanks @injekt, I appreciate it. That all makes sense.\nFor any other readers, I think that for user-submitted timestamps, the viable solutions today are supporting a few specific formats, or presenting the parsed version back to the user so they can see the parsed time (ideally in realtime). \"Enter what you want\" is not feasible, nor is presenting errors on submission (some of the times do parse, they just aren't what the user expected).\n. When context is not provided, I could see the default going either way. For the default, I think it's more important to document how it behaves than to pick the exact right case - as you said, there isn't one right default for everyone.\nHowever, it should never ignore context when explicitly provided. That was the origin of this issue, and I think a lot more important than getting the default right. If the app developer is willing to spend the effort to decide authoritatively which context is correct for them, it should be honored.\nI'd argue that it should raise an exception when it can't honor the context (rather than, say, returning a future time with context of past). Obviously that's not going to happen right now given that it ignores context for certain inputs, but I think that is the correct behavior when one is given. As a library consumer, I don't ever want a future time returned :)\n. ",
    "dlupu": "Hello\nI have a similar issue (or ar least it seems). \nChronic.parse('27/7/2011  00:43:57', :context => :future) returns 2011-07-27 00:43:57 +0200\nChronic.parse('27/7/2011  00:43:57', :context => :past) returns 2011-07-26 00:43:57 +0200 \nI need context => :past in  my application. In your opinion, the result of the second example is a bug  or it's an expected behavior?\n. Sorry about not being clear @injekt.  In fact I'm surprised to see that :context => :past changes the result in this particular case.  \nThe parsed string is not ambiguous at all, so one could expect that both versions return the same result. I don't understand why context information changes the result in this case.  \nsince the string to be parsed is pretty clear \n. I did not specify any reference time so I guess Chronic uses the current time in that case.\n. About 23 hours ago => Mon, 28 Nov 2011 21:07:15 CET +01:00\n. Hello\nI have a similar issue (or ar least it seems). \nChronic.parse('27/7/2011  00:43:57', :context => :future) returns 2011-07-27 00:43:57 +0200\nChronic.parse('27/7/2011  00:43:57', :context => :past) returns 2011-07-26 00:43:57 +0200 \nI need context => :past in  my application. In your opinion, the result of the second example is a bug  or it's an expected behavior?\n. Sorry about not being clear @injekt.  In fact I'm surprised to see that :context => :past changes the result in this particular case.  \nThe parsed string is not ambiguous at all, so one could expect that both versions return the same result. I don't understand why context information changes the result in this case.  \nsince the string to be parsed is pretty clear \n. I did not specify any reference time so I guess Chronic uses the current time in that case.\n. About 23 hours ago => Mon, 28 Nov 2011 21:07:15 CET +01:00\n. ",
    "wulftone": "I think he means this:\nTime.now #=> 2011-12-29 12:03:14 -0800\nChronic.parse('1-12-1950 00:40', :context => :future) #=> 1950-01-12 00:40:00 -0800\nChronic.parse('1-12-1950 00:40', :context => :past) #=> 1950-01-11 00:40:00 -0800\nThe context is clearly irrelevant here, since the date is explicit.  Context should not affect the date, right?\nOr else, context should always affect the date, in which case the :future example should return Jan 13th... but that assumes that :future or :past always implies \"a day ahead or a day behind\" as opposed to a year or a century, or whatever.\n. Just thought I would add that \"yesterday 9am\" also parses correctly, though as stated above, reversing the order to \"9am yesterday\" does not work.  I also added \"last night\" to the list, since \"10pm last night\" is a natural way for us Americans to speak, though \"last night 10pm\" is not (yes, \"last night at 10pm\" is better... but why type \" at\" if you don't have to?)\n1.9.2p290 :002 > Chronic.parse \"9am tomorrow\"\nnil\n1.9.2p290 :003 > Chronic.parse \"tomorrow 9am\"\n2012-03-08 09:00:00 -0800\n1.9.2p290 :004 > Chronic.parse \"9am yesterday\"\nnil\n1.9.2p290 :005 > Chronic.parse \"yesterday 9am\"\n2012-03-06 09:00:00 -0800\n1.9.2p290 :006 >   Chronic.parse \"10pm last night\"\nnil\n1.9.2p290 :007 > Chronic.parse \"last night 10pm\"\n2012-03-06 22:00:00 -0800\n1.9.2p290 :008 >\n. I think he means this:\nTime.now #=> 2011-12-29 12:03:14 -0800\nChronic.parse('1-12-1950 00:40', :context => :future) #=> 1950-01-12 00:40:00 -0800\nChronic.parse('1-12-1950 00:40', :context => :past) #=> 1950-01-11 00:40:00 -0800\nThe context is clearly irrelevant here, since the date is explicit.  Context should not affect the date, right?\nOr else, context should always affect the date, in which case the :future example should return Jan 13th... but that assumes that :future or :past always implies \"a day ahead or a day behind\" as opposed to a year or a century, or whatever.\n. Just thought I would add that \"yesterday 9am\" also parses correctly, though as stated above, reversing the order to \"9am yesterday\" does not work.  I also added \"last night\" to the list, since \"10pm last night\" is a natural way for us Americans to speak, though \"last night 10pm\" is not (yes, \"last night at 10pm\" is better... but why type \" at\" if you don't have to?)\n1.9.2p290 :002 > Chronic.parse \"9am tomorrow\"\nnil\n1.9.2p290 :003 > Chronic.parse \"tomorrow 9am\"\n2012-03-08 09:00:00 -0800\n1.9.2p290 :004 > Chronic.parse \"9am yesterday\"\nnil\n1.9.2p290 :005 > Chronic.parse \"yesterday 9am\"\n2012-03-06 09:00:00 -0800\n1.9.2p290 :006 >   Chronic.parse \"10pm last night\"\nnil\n1.9.2p290 :007 > Chronic.parse \"last night 10pm\"\n2012-03-06 22:00:00 -0800\n1.9.2p290 :008 >\n. ",
    "cpmurphy": "@dlupu , I think my patch for issue #176 addresses your problem.  With current master, I see\nTime.now\n=> 2013-04-15 11:56:35 -0500\nChronic.parse('27/7/2011 00:43:57', :context => :past)\n=> 2011-07-27 00:43:57 -0500\n@wulftone your clarifying examples no longer seem to work -- I just get nil, but\nChronic.parse('1/12/1950 00:40', :context => :past)\nnow returns 1950-01-12 00:40:00 -0600 as I'd expect (for my timezone).\nBTW, @injekt thank you for merging my pull request!\nUnfortunately, I think the original bug described by this issue is still present:\nTime.now\n=> 2013-04-15 12:05:21 -0500\nChronic.parse('6pm', :context => :past)\n=> 2013-04-15 18:00:00 -0500\n. Haven't had a lot of time to look at this yet, but it seems to be something to do with using a 24 hour clock.  There's no error parsing the same time using American am/pm:\nirb -Ilib -rchronic\nirb(main):001:0> Chronic.parse('2013-02-28 17:00', :context => :past)\n=> 2013-02-27 17:00:00 -0600\nirb(main):002:0> Chronic.parse('2013-02-28 05:00pm', :context => :past)\n=> 2013-02-28 17:00:00 -0600\nOne other observation, possibly related.  Current master from github fails one test for me when I run rake:\n```\nrake\nRun options: --seed 62621\nRunning tests:\n...........................................................F................................................................................................\nFinished tests in 0.959279s, 162.6222 tests/s, 748.4791 assertions/s.\n1) Failure:\ntest_handle_sy_sm(TestParsing) [/mnt/src/git/chronic/test/test_parsing.rb:371]:\nExpected: 2013-11-16 00:00:00 -0600\n  Actual: 2013-11-15 23:30:00 -0600\n156 tests, 718 assertions, 1 failures, 0 errors, 0 skips\n```\nThis is a current 1.9.3 ruby:\nruby -v\nruby 1.9.3p385 (2013-02-06 revision 39114) [x86_64-linux]\n. I'm still not sure if the test failure is related to the problem I originally reported, but it is strange...\nSome timezones work, like TZ=UTC, TZ=Japan and TZ=Eire.\nThe four continental US timezones all fail in the same way\n```\nTZ=US/Eastern date; rake\nTue Mar  5 15:25:23 EST 2013\nRun options: --seed 13322\nRunning tests:\n...............................................................................F............................................................................\nFinished tests in 0.915873s, 170.3293 tests/s, 783.9515 assertions/s.\n1) Failure:\ntest_handle_sy_sm(TestParsing) [/mnt/ssd/src/git/chronic/test/test_parsing.rb:371]:\nExpected: 2013-11-16 00:00:00 -0600\n  Actual: 2013-11-15 23:30:00 -0600\n```\nI'm running Ubuntu Precise Pangolin, 12.04.2.If it's not reproducible in other environments maybe it's Ubuntu specific?\nIn any case, the original problem does occur, even in a timezone that passes all the tests:\nTZ=UTC rake console\nirb -Ilib -rchronic\nirb(main):001:0> Chronic.parse('2013-02-28 17:00', :context => :past)\n=> 2013-02-27 17:00:00 +0000\n. I think the spec failure has to do with timezone databases and daylight savings time.  I was able to reproduce it with Red Hat EL 5 and 1.9.3-p0.  On closer investigation, it turns out that the failing spec depends on two values returned by Time.local:\nirb\nirb(main):001:0> Time.local(2013, 11)\n=> 2013-11-01 00:00:00 -0500\nirb(main):002:0> Time.local(2013, 12)\n=> 2013-12-01 00:00:00 -0600\nNotice that there are two different offsets from UTC.  In most of the US, daylight savings time in 2013 doesn't end until November 3rd.  So the average of the start/end times has a half-hour increment because of the different UTC offsets.\n. I've done some more digging into the day subtraction issue.  (Sorry, no patch yet.)  The problem seems to happen when no timezone is specified in the input string.  I'm also able to get it to happen for UTC.  I've put code in a gist and pasted the results below.\nThese should all equal 2013-03-12 17:00:00 UTC.\n2013-03-12 17:00 00:00              : OK\n2013-03-12 17:00 UTC                : OK\n2013-03-12 17:00                    : FAIL, got: 2013-03-11 17:00:00 +0000\nTuesday March 12 17:00 UTC 2013    : OK\nTuesday March 12 17:00             : FAIL, got: 2013-03-11 17:00:00 +0000\n12 March 2013 17:00                 : FAIL, got: 2013-03-11 17:00:00 +0000\nThat output is consistent everywhere I've tried it:\n- RHEL5, ruby 1.8.5\n- RHEL5 ruby 1.9.3p385\n- Ubuntu 12.04.2 ruby 1.9.3p385\n- Ubuntu 12.04.2 ruby 2.0.0-p0\n(Edit: original version had Thursday instead of Tuesday -- that has no material effect on the results.)\n. @dlupu , I think my patch for issue #176 addresses your problem.  With current master, I see\nTime.now\n=> 2013-04-15 11:56:35 -0500\nChronic.parse('27/7/2011 00:43:57', :context => :past)\n=> 2011-07-27 00:43:57 -0500\n@wulftone your clarifying examples no longer seem to work -- I just get nil, but\nChronic.parse('1/12/1950 00:40', :context => :past)\nnow returns 1950-01-12 00:40:00 -0600 as I'd expect (for my timezone).\nBTW, @injekt thank you for merging my pull request!\nUnfortunately, I think the original bug described by this issue is still present:\nTime.now\n=> 2013-04-15 12:05:21 -0500\nChronic.parse('6pm', :context => :past)\n=> 2013-04-15 18:00:00 -0500\n. Haven't had a lot of time to look at this yet, but it seems to be something to do with using a 24 hour clock.  There's no error parsing the same time using American am/pm:\nirb -Ilib -rchronic\nirb(main):001:0> Chronic.parse('2013-02-28 17:00', :context => :past)\n=> 2013-02-27 17:00:00 -0600\nirb(main):002:0> Chronic.parse('2013-02-28 05:00pm', :context => :past)\n=> 2013-02-28 17:00:00 -0600\nOne other observation, possibly related.  Current master from github fails one test for me when I run rake:\n```\nrake\nRun options: --seed 62621\nRunning tests:\n...........................................................F................................................................................................\nFinished tests in 0.959279s, 162.6222 tests/s, 748.4791 assertions/s.\n1) Failure:\ntest_handle_sy_sm(TestParsing) [/mnt/src/git/chronic/test/test_parsing.rb:371]:\nExpected: 2013-11-16 00:00:00 -0600\n  Actual: 2013-11-15 23:30:00 -0600\n156 tests, 718 assertions, 1 failures, 0 errors, 0 skips\n```\nThis is a current 1.9.3 ruby:\nruby -v\nruby 1.9.3p385 (2013-02-06 revision 39114) [x86_64-linux]\n. I'm still not sure if the test failure is related to the problem I originally reported, but it is strange...\nSome timezones work, like TZ=UTC, TZ=Japan and TZ=Eire.\nThe four continental US timezones all fail in the same way\n```\nTZ=US/Eastern date; rake\nTue Mar  5 15:25:23 EST 2013\nRun options: --seed 13322\nRunning tests:\n...............................................................................F............................................................................\nFinished tests in 0.915873s, 170.3293 tests/s, 783.9515 assertions/s.\n1) Failure:\ntest_handle_sy_sm(TestParsing) [/mnt/ssd/src/git/chronic/test/test_parsing.rb:371]:\nExpected: 2013-11-16 00:00:00 -0600\n  Actual: 2013-11-15 23:30:00 -0600\n```\nI'm running Ubuntu Precise Pangolin, 12.04.2.If it's not reproducible in other environments maybe it's Ubuntu specific?\nIn any case, the original problem does occur, even in a timezone that passes all the tests:\nTZ=UTC rake console\nirb -Ilib -rchronic\nirb(main):001:0> Chronic.parse('2013-02-28 17:00', :context => :past)\n=> 2013-02-27 17:00:00 +0000\n. I think the spec failure has to do with timezone databases and daylight savings time.  I was able to reproduce it with Red Hat EL 5 and 1.9.3-p0.  On closer investigation, it turns out that the failing spec depends on two values returned by Time.local:\nirb\nirb(main):001:0> Time.local(2013, 11)\n=> 2013-11-01 00:00:00 -0500\nirb(main):002:0> Time.local(2013, 12)\n=> 2013-12-01 00:00:00 -0600\nNotice that there are two different offsets from UTC.  In most of the US, daylight savings time in 2013 doesn't end until November 3rd.  So the average of the start/end times has a half-hour increment because of the different UTC offsets.\n. I've done some more digging into the day subtraction issue.  (Sorry, no patch yet.)  The problem seems to happen when no timezone is specified in the input string.  I'm also able to get it to happen for UTC.  I've put code in a gist and pasted the results below.\nThese should all equal 2013-03-12 17:00:00 UTC.\n2013-03-12 17:00 00:00              : OK\n2013-03-12 17:00 UTC                : OK\n2013-03-12 17:00                    : FAIL, got: 2013-03-11 17:00:00 +0000\nTuesday March 12 17:00 UTC 2013    : OK\nTuesday March 12 17:00             : FAIL, got: 2013-03-11 17:00:00 +0000\n12 March 2013 17:00                 : FAIL, got: 2013-03-11 17:00:00 +0000\nThat output is consistent everywhere I've tried it:\n- RHEL5, ruby 1.8.5\n- RHEL5 ruby 1.9.3p385\n- Ubuntu 12.04.2 ruby 1.9.3p385\n- Ubuntu 12.04.2 ruby 2.0.0-p0\n(Edit: original version had Thursday instead of Tuesday -- that has no material effect on the results.)\n. ",
    "jbrennan": "It's possible I did something wrong, but for a while it was indeed properly parsing strings with \"Eastern Daylight Time\" (and previously, ones ending in \"ET\", and not \"EDT\").\nI ended up switching away from Chronic, but yeah, the bug may still be relevant (the date string was being produced by a Cocoa app on Lion, saving an NSDate in its \"Long format\" in the Canadian English locale, in case you're interested).\n. It's possible I did something wrong, but for a while it was indeed properly parsing strings with \"Eastern Daylight Time\" (and previously, ones ending in \"ET\", and not \"EDT\").\nI ended up switching away from Chronic, but yeah, the bug may still be relevant (the date string was being produced by a Cocoa app on Lion, saving an NSDate in its \"Long format\" in the Canadian English locale, in case you're interested).\n. ",
    "tomekr": "I've run into this same problem today in the same type of environment:\nRuby 1.8.7 in a Sinatra app. However when I went into irb to give it a go, here was the following results:\n```\n\n\nChronic.parse(Chronic.parse('tomorrow').to_s)\n=> Fri Sep 02 12:00:00 -0500 2011\nChronic.parse(Chronic.parse('in one year').to_s)\n=> Sat Sep 01 18:45:16 -0500 2012\nChronic.parse(Chronic.parse('last week').to_s)\n=> Wed Aug 24 12:00:00 -0500 2011\nChronic.parse(Chronic.parse('yesterday').to_s)\n=> Wed Aug 31 12:00:00 -0500 2011\nChronic.parse(Chronic.parse('today').to_s)\n=> nil\nChronic.parse(Chronic.parse('tomorrow').to_s)\n=> Fri Sep 02 12:00:00 -0500 2011\nChronic.parse(Chronic.parse('in one year').to_s)\n=> Sat Sep 01 18:45:44 -0500 2012\n```\n\n\nthe offending string being:\n```\n\n\nChronic.parse('today').to_s\n=> \"Thu Sep 01 21:00:00 -0500 2011\"\n```\n\n\nAlso, it looks like it works fine for Ruby 1.9.2. Here is the output for the same set of commands on 1.9.2\nruby-1.9.2-p290 :002 > Chronic.parse(Chronic.parse('last week').to_s)\n => 2011-08-24 12:00:00 -0500 \nruby-1.9.2-p290 :003 > Chronic.parse(Chronic.parse('yesterday').to_s)\n => 2011-08-31 12:00:00 -0500 \nruby-1.9.2-p290 :004 > Chronic.parse(Chronic.parse('today').to_s)\n => 2011-09-01 21:00:00 -0500 \nruby-1.9.2-p290 :005 > Chronic.parse(Chronic.parse('tomorrow').to_s)\n => 2011-09-02 12:00:00 -0500 \nruby-1.9.2-p290 :006 > Chronic.parse(Chronic.parse('in one year').to_s)\n => 2012-09-01 18:55:13 -0500 \nruby-1.9.2-p290 :007 > \nruby-1.9.2-p290 :008 >   Chronic.parse('today').to_s\n => \"2011-09-01 21:00:00 -0500\"\n. I've run into this same problem today in the same type of environment:\nRuby 1.8.7 in a Sinatra app. However when I went into irb to give it a go, here was the following results:\n```\n\n\nChronic.parse(Chronic.parse('tomorrow').to_s)\n=> Fri Sep 02 12:00:00 -0500 2011\nChronic.parse(Chronic.parse('in one year').to_s)\n=> Sat Sep 01 18:45:16 -0500 2012\nChronic.parse(Chronic.parse('last week').to_s)\n=> Wed Aug 24 12:00:00 -0500 2011\nChronic.parse(Chronic.parse('yesterday').to_s)\n=> Wed Aug 31 12:00:00 -0500 2011\nChronic.parse(Chronic.parse('today').to_s)\n=> nil\nChronic.parse(Chronic.parse('tomorrow').to_s)\n=> Fri Sep 02 12:00:00 -0500 2011\nChronic.parse(Chronic.parse('in one year').to_s)\n=> Sat Sep 01 18:45:44 -0500 2012\n```\n\n\nthe offending string being:\n```\n\n\nChronic.parse('today').to_s\n=> \"Thu Sep 01 21:00:00 -0500 2011\"\n```\n\n\nAlso, it looks like it works fine for Ruby 1.9.2. Here is the output for the same set of commands on 1.9.2\nruby-1.9.2-p290 :002 > Chronic.parse(Chronic.parse('last week').to_s)\n => 2011-08-24 12:00:00 -0500 \nruby-1.9.2-p290 :003 > Chronic.parse(Chronic.parse('yesterday').to_s)\n => 2011-08-31 12:00:00 -0500 \nruby-1.9.2-p290 :004 > Chronic.parse(Chronic.parse('today').to_s)\n => 2011-09-01 21:00:00 -0500 \nruby-1.9.2-p290 :005 > Chronic.parse(Chronic.parse('tomorrow').to_s)\n => 2011-09-02 12:00:00 -0500 \nruby-1.9.2-p290 :006 > Chronic.parse(Chronic.parse('in one year').to_s)\n => 2012-09-01 18:55:13 -0500 \nruby-1.9.2-p290 :007 > \nruby-1.9.2-p290 :008 >   Chronic.parse('today').to_s\n => \"2011-09-01 21:00:00 -0500\"\n. ",
    "pauldambra": "closing to submit request on a branch other than master\n. Ha, well I've managed to add 2 commits while trying to squash (does it show I'm new to Git? :-)) I'll get some advice tomorrow.\nThanks for the feedback... I'll look at the handlers but that's much more Ruby to get my head around!\n. closing to submit request on a branch other than master\n. Ha, well I've managed to add 2 commits while trying to squash (does it show I'm new to Git? :-)) I'll get some advice tomorrow.\nThanks for the feedback... I'll look at the handlers but that's much more Ruby to get my head around!\n. ",
    "sserdyuk": "I will try to explain why I think it is not a very usable behavior. There two main modes Chronic can be used: to record future events like an appointment calendar (:context => :future) and when a log of past events is recorded like a bug report system (:context => :past). With this in mind, it's handling of \"2pm\" is unusable for both modes because it is unpredictable- may work like you want or may now depending on your local time. While you could force people to look at clock and type \"next\" or \"past\", it is not something I would want to do. My 2 cents.\n. I will try to explain why I think it is not a very usable behavior. There two main modes Chronic can be used: to record future events like an appointment calendar (:context => :future) and when a log of past events is recorded like a bug report system (:context => :past). With this in mind, it's handling of \"2pm\" is unusable for both modes because it is unpredictable- may work like you want or may now depending on your local time. While you could force people to look at clock and type \"next\" or \"past\", it is not something I would want to do. My 2 cents.\n. ",
    "coderberry": "Sounds good. I didn't read it that way but it makes sense. Great job on this gem!!!\n. Sounds good. I didn't read it that way but it makes sense. Great job on this gem!!!\n. ",
    "vlazzle": "cool. yeah all the old tests + 1 new test that i added all pass, at least on my machine.\nlooking forward to the new gem for my rails app.\n. thanks for the quick turnaround! just a bundle update and my project has the change :)\n. cool. yeah all the old tests + 1 new test that i added all pass, at least on my machine.\nlooking forward to the new gem for my rails app.\n. thanks for the quick turnaround! just a bundle update and my project has the change :)\n. ",
    "joefiorini": "Almost perfect :) Chronic.parse(\"Tuesday January 31\") will return nil even thought it's valid. Working on this now, hopefully will send a  pull request soon.\n. Submitted as part of https://github.com/mojombo/chronic/pull/80. It now works with:\nTuesday January 31\nWednesday December 31\nMonday March 8\nHope I didn't miss any edge cases in my tests.\n. Almost perfect :) Chronic.parse(\"Tuesday January 31\") will return nil even thought it's valid. Working on this now, hopefully will send a  pull request soon.\n. Submitted as part of https://github.com/mojombo/chronic/pull/80. It now works with:\nTuesday January 31\nWednesday December 31\nMonday March 8\nHope I didn't miss any edge cases in my tests.\n. ",
    "zhon": "Chronic Version 0.6.4 on Windows Ruby 1.9.2 \ngem says 0.6.4 Chronic::VERSION says 0.3.9\n. On the current branch\nChronic.parse '29th of November'  # works\nChronic.parse '29th day of November' # -> nil\n. Yes it works on HEAD (I just check it out and checked) but not when I did \n```\ngem install chronic\ngem list chronic\n LOCAL GEMS \nchronic (0.6.4)\nirb(main):001:0> require 'chronic'\n=> true\nirb(main):002:0> Chronic::VERSION\n=> \"0.3.9\"\nirb(main):003:0>\n```\n. > @zhon the latter shouldn't have a handler anyway.\nI was hoping Chronic could help me parsing time and date legalizes. For \nexample,\n\"on Tuesday, the 29th day of November, 2011, ...legal jargon about money \nand address of courthouse steps.., at 10:30 a.m.\"\nseems perfectly reasonable to a lawyer.\nI have been banging my head on this one for a while. If Chronic can \nhelp, I would be eternally grateful.\nThank you,\nZhon\n. Still failing on current master.\n. Thx, my fix looked like this: \nruby\ntext.gsub!(/\\b0(\\d+:\\d+\\s*pm?\\b)/, '\\1')\n. The above parses in version 0.9.0 while\nruby\nChronic.parse \"01:00:00 PM\" # -> nil\ndoes not. Closing this issue and opening a new one.\n. The question still remains: Should \nruby\nChronic.parse 'Jan 1, 12:00 noon'\nbe made to parse to a reasonable date?\n. Chronic Version 0.6.4 on Windows Ruby 1.9.2 \ngem says 0.6.4 Chronic::VERSION says 0.3.9\n. On the current branch\nChronic.parse '29th of November'  # works\nChronic.parse '29th day of November' # -> nil\n. Yes it works on HEAD (I just check it out and checked) but not when I did \n```\ngem install chronic\ngem list chronic\n LOCAL GEMS \nchronic (0.6.4)\nirb(main):001:0> require 'chronic'\n=> true\nirb(main):002:0> Chronic::VERSION\n=> \"0.3.9\"\nirb(main):003:0>\n```\n. > @zhon the latter shouldn't have a handler anyway.\nI was hoping Chronic could help me parsing time and date legalizes. For \nexample,\n\"on Tuesday, the 29th day of November, 2011, ...legal jargon about money \nand address of courthouse steps.., at 10:30 a.m.\"\nseems perfectly reasonable to a lawyer.\nI have been banging my head on this one for a while. If Chronic can \nhelp, I would be eternally grateful.\nThank you,\nZhon\n. Still failing on current master.\n. Thx, my fix looked like this: \nruby\ntext.gsub!(/\\b0(\\d+:\\d+\\s*pm?\\b)/, '\\1')\n. The above parses in version 0.9.0 while\nruby\nChronic.parse \"01:00:00 PM\" # -> nil\ndoes not. Closing this issue and opening a new one.\n. The question still remains: Should \nruby\nChronic.parse 'Jan 1, 12:00 noon'\nbe made to parse to a reasonable date?\n. ",
    "sidvorak": "I am also having issues with this.  Same result as zhon on the same versions.  However, I just posted another issue that is slightly different, but I think it has something to do with it. see https://github.com/mojombo/chronic/issues/73  Something is strange about this November....\n. Sorry, here's some more info.  When asking Chronic for the 5th tuesday in September, Chronic correctly returns nil as there is none.  However, when asking for the 5th Tuesday in October it incorrectly returns November 1st.  The same thing happens when parsing the \"5th tuesday in April\", it returns May 1st which is clearly not in April.\nIn my initial post I was just showing that variations on the pronouns in the phrase had no effect.\n. Also, I'm not sure I understand what you mean by 'The '5th Tuesday' of any month is always going to be a future month' as there are cases like November 29,2011 and May 29th, 2011 where there are 5 of a certain day in a month.\n. Ok, great!  Thanks for your work on this!\n. I am also having issues with this.  Same result as zhon on the same versions.  However, I just posted another issue that is slightly different, but I think it has something to do with it. see https://github.com/mojombo/chronic/issues/73  Something is strange about this November....\n. Sorry, here's some more info.  When asking Chronic for the 5th tuesday in September, Chronic correctly returns nil as there is none.  However, when asking for the 5th Tuesday in October it incorrectly returns November 1st.  The same thing happens when parsing the \"5th tuesday in April\", it returns May 1st which is clearly not in April.\nIn my initial post I was just showing that variations on the pronouns in the phrase had no effect.\n. Also, I'm not sure I understand what you mean by 'The '5th Tuesday' of any month is always going to be a future month' as there are cases like November 29,2011 and May 29th, 2011 where there are 5 of a certain day in a month.\n. Ok, great!  Thanks for your work on this!\n. ",
    "amateurhuman": "I was having a similar problem in 0.6.4 and updated to 0.6.6 which fixed the issue. Your problem seems to also be fixed in 0.6.6.\nmain:0> Time.zone = \"Central Time (US & Canada)\" #=> \"Central Time (US & Canada)\"\nmain:0> Chronic.time_class = Time.zone #=> (GMT-06:00) Central Time (US & Canada)\nmain:0> Chronic.parse(\"today 11:00am\") #=> Tue, 06 Dec 2011 11:00:00 CST -06:00\nmain:0> Chronic.parse(\"today 10:59am\") #=> Tue, 06 Dec 2011 10:59:00 CST -06:00\nmain:0> Chronic.parse(\"today 11:59am\") #=> Tue, 06 Dec 2011 11:59:00 CST -06:00\nmain:0> Chronic.parse(\"today 12:00pm\") #=> Tue, 06 Dec 2011 12:00:00 CST -06:00\n. I was having a similar problem in 0.6.4 and updated to 0.6.6 which fixed the issue. Your problem seems to also be fixed in 0.6.6.\nmain:0> Time.zone = \"Central Time (US & Canada)\" #=> \"Central Time (US & Canada)\"\nmain:0> Chronic.time_class = Time.zone #=> (GMT-06:00) Central Time (US & Canada)\nmain:0> Chronic.parse(\"today 11:00am\") #=> Tue, 06 Dec 2011 11:00:00 CST -06:00\nmain:0> Chronic.parse(\"today 10:59am\") #=> Tue, 06 Dec 2011 10:59:00 CST -06:00\nmain:0> Chronic.parse(\"today 11:59am\") #=> Tue, 06 Dec 2011 11:59:00 CST -06:00\nmain:0> Chronic.parse(\"today 12:00pm\") #=> Tue, 06 Dec 2011 12:00:00 CST -06:00\n. ",
    "frankchendev": "I still had similar problem in 0.6.6 too. It could be an issue from daylight saving time transition:\nTime.zone\n,#>,#,#>>, @utc_offset=nil, @tzinfo=#>\nChronic.parse('sunday next week', {:now=>Time.zone.parse('11/01/2011')})\nnil\nChronic.parse('sunday next week', {:now=>Time.zone.parse('10/24/2011')})\nSun Nov 06 11:30:00 -0500 2011\nChronic.parse('sunday next week')\nSun Dec 25 12:00:00 -0500 2011\n(I specified the :now option to make reproducing easier.)\n. I still had similar problem in 0.6.6 too. It could be an issue from daylight saving time transition:\nTime.zone\n,#>,#,#>>, @utc_offset=nil, @tzinfo=#>\nChronic.parse('sunday next week', {:now=>Time.zone.parse('11/01/2011')})\nnil\nChronic.parse('sunday next week', {:now=>Time.zone.parse('10/24/2011')})\nSun Nov 06 11:30:00 -0500 2011\nChronic.parse('sunday next week')\nSun Dec 25 12:00:00 -0500 2011\n(I specified the :now option to make reproducing easier.)\n. ",
    "duelinmarkers": "Presumably the same issue, today we have similar behavior:\n``` ruby\n\n\nChronic.debug = true\n=> true\nChronic.parse \"yesterday at 11:59\", :now => Time.zone.parse('3/13/2012') # tomorrow we'll be ok\n+---------------------------------------------------\n| last(grabber-last) day(repeater-day) at(separator-at) 11:59(repeater-time-43140?) \n+---------------------------------------------------\n-anchor\n--(Mon Mar 12 00:00:00 -0400 2012..Tue Mar 13 00:00:00 -0400 2012)\n--(Mon Mar 12 00:00:00 -0400 2012..Tue Mar 13 00:00:00 -0400 2012)\n--(Mon Mar 12 06:00:00 -0400 2012..Mon Mar 12 18:00:00 -0400 2012)\n--(Mon Mar 12 11:59:00 -0400 2012..Mon Mar 12 11:59:01 -0400 2012)\n=> Mon Mar 12 11:59:00 -0400 2012\nChronic.parse \"yesterday at 11:59\", :now => Time.zone.parse('3/12/2012') # today we get nil\n+---------------------------------------------------\n| last(grabber-last) day(repeater-day) at(separator-at) 11:59(repeater-time-43140?) \n+---------------------------------------------------\n-anchor\n--(Sat Mar 10 23:00:00 -0500 2012..Mon Mar 12 00:00:00 -0400 2012)\n--(Sat Mar 10 23:00:00 -0500 2012..Mon Mar 12 00:00:00 -0400 2012)\n=> nil\n``\n. What I think this comes down to is thatChronic::RepeaterDaytries to provide the next or previous day's date by adding 86,400 seconds, which doesn't work on the 23- or 25-hour days we have at DST changes. In the case above,Chronic::RepeaterDayPortionthen uses just the year, month, and day to construct a new time (inthis), whacking off the 23:00:00 hours and giving you a full day too early. That then leaves a range outside the span we started with, which leads tofind_within` giving up and returning nil.\n. Presumably the same issue, today we have similar behavior:\n\n\n``` ruby\n\n\nChronic.debug = true\n=> true\nChronic.parse \"yesterday at 11:59\", :now => Time.zone.parse('3/13/2012') # tomorrow we'll be ok\n+---------------------------------------------------\n| last(grabber-last) day(repeater-day) at(separator-at) 11:59(repeater-time-43140?) \n+---------------------------------------------------\n-anchor\n--(Mon Mar 12 00:00:00 -0400 2012..Tue Mar 13 00:00:00 -0400 2012)\n--(Mon Mar 12 00:00:00 -0400 2012..Tue Mar 13 00:00:00 -0400 2012)\n--(Mon Mar 12 06:00:00 -0400 2012..Mon Mar 12 18:00:00 -0400 2012)\n--(Mon Mar 12 11:59:00 -0400 2012..Mon Mar 12 11:59:01 -0400 2012)\n=> Mon Mar 12 11:59:00 -0400 2012\nChronic.parse \"yesterday at 11:59\", :now => Time.zone.parse('3/12/2012') # today we get nil\n+---------------------------------------------------\n| last(grabber-last) day(repeater-day) at(separator-at) 11:59(repeater-time-43140?) \n+---------------------------------------------------\n-anchor\n--(Sat Mar 10 23:00:00 -0500 2012..Mon Mar 12 00:00:00 -0400 2012)\n--(Sat Mar 10 23:00:00 -0500 2012..Mon Mar 12 00:00:00 -0400 2012)\n=> nil\n``\n. What I think this comes down to is thatChronic::RepeaterDaytries to provide the next or previous day's date by adding 86,400 seconds, which doesn't work on the 23- or 25-hour days we have at DST changes. In the case above,Chronic::RepeaterDayPortionthen uses just the year, month, and day to construct a new time (inthis), whacking off the 23:00:00 hours and giving you a full day too early. That then leaves a range outside the span we started with, which leads tofind_within` giving up and returning nil.\n. \n\n",
    "jwigal": "This might be related...  I saw an error on Sunday, where Chronic was interpreting 12:30 PM as 12:30 AM on Sunday:\nruby\nree-1.8.7-2010.02 :011 > Chronic.parse(\"12:30 PM\", :now => Time.local(2012, 3, 11, 17, 0, 0, 0))\n => Mon Mar 12 00:30:00 -0400 2012 \nree-1.8.7-2010.02 :012 >\n. Similar problem, slightly different can be found here:\nhttps://github.com/mojombo/chronic/issues/87\n. The original issue may be resolved, but the other relate examples are unfortunately still not resolved. \njeff-wigals-macbook-pro:chronic [master] jeff$ gem list --local | grep chronic\nchronic (0.9.0)\njeff-wigals-macbook-pro:chronic [master] jeff$ irb -Ilib\n1.9.3-p194 :001 > require 'chronic'\n => true \n1.9.3-p194 :002 > Chronic.debug = true\n => true \n1.9.3-p194 :003 > Chronic.parse \"yesterday at 11:59\", :now => Time.parse('2012-03-13')\n-anchor\nHandler: handle_r\nHandler-class: Chronic::RepeaterDay\n--(2012-03-12 00:00:00 -0400..2012-03-13 00:00:00 -0400)\n--(2012-03-12 00:00:00 -0400..2012-03-13 00:00:00 -0400)\n--(2012-03-12 06:00:00 -0400..2012-03-12 18:00:00 -0400)\n--(2012-03-12 11:59:00 -0400..2012-03-12 11:59:01 -0400)\n+---------------------------------------------------\n| [last(grabber-last) , day(repeater-day) , at(separator-at) , 11:59(repeater-time-43140?, timezone) ]\n+---------------------------------------------------\n => 2012-03-12 11:59:00 -0400 \n1.9.3-p194 :004 > Chronic.parse \"yesterday at 11:59\", :now => Time.parse('2012-03-12')\n-anchor\nHandler: handle_r\nHandler-class: Chronic::RepeaterDay\n--(2012-03-10 23:00:00 -0500..2012-03-12 00:00:00 -0400)\n--(2012-03-10 23:00:00 -0500..2012-03-12 00:00:00 -0400)\n+---------------------------------------------------\n| [last(grabber-last) , day(repeater-day) , at(separator-at) , 11:59(repeater-time-43140?, timezone) ]\n+---------------------------------------------------\n => nil\nOops, this shouldn't return nil.\n1.9.3-p194 :005 > Chronic.parse \"12:30 PM\", :now => Time.local(2012, 3, 11, 17, 0, 0, 0)\n-anchor\nHandler: handle_r\nHandler-class: Chronic::RepeaterDayPortion\n--(2012-03-11 13:00:00 -0400..2012-03-12 00:59:59 -0400)\n--(2012-03-11 13:00:00 -0400..2012-03-12 00:59:59 -0400)\n--(2012-03-12 00:30:00 -0400..2012-03-12 00:30:01 -0400)\n+---------------------------------------------------\n| [12:30(repeater-time-1800?, timezone) , pm(repeater-dayportion-pm) ]\n+---------------------------------------------------\n => 2012-03-12 00:30:00 -0400 \n1.9.3-p194 :006 >\nShould return: \n=> 2012-03-12 12:30:00 -0400\nI think @duelinmarkers is correct, the underlying issue is adding 86,400 seconds to advance to the next day, which just doesn't work on the days that have 23 or 25 hours. \n. Similar problem but slightly different can be found here:\nhttps://github.com/mojombo/chronic/issues/74\n. This might be related...  I saw an error on Sunday, where Chronic was interpreting 12:30 PM as 12:30 AM on Sunday:\nruby\nree-1.8.7-2010.02 :011 > Chronic.parse(\"12:30 PM\", :now => Time.local(2012, 3, 11, 17, 0, 0, 0))\n => Mon Mar 12 00:30:00 -0400 2012 \nree-1.8.7-2010.02 :012 >\n. Similar problem, slightly different can be found here:\nhttps://github.com/mojombo/chronic/issues/87\n. The original issue may be resolved, but the other relate examples are unfortunately still not resolved. \njeff-wigals-macbook-pro:chronic [master] jeff$ gem list --local | grep chronic\nchronic (0.9.0)\njeff-wigals-macbook-pro:chronic [master] jeff$ irb -Ilib\n1.9.3-p194 :001 > require 'chronic'\n => true \n1.9.3-p194 :002 > Chronic.debug = true\n => true \n1.9.3-p194 :003 > Chronic.parse \"yesterday at 11:59\", :now => Time.parse('2012-03-13')\n-anchor\nHandler: handle_r\nHandler-class: Chronic::RepeaterDay\n--(2012-03-12 00:00:00 -0400..2012-03-13 00:00:00 -0400)\n--(2012-03-12 00:00:00 -0400..2012-03-13 00:00:00 -0400)\n--(2012-03-12 06:00:00 -0400..2012-03-12 18:00:00 -0400)\n--(2012-03-12 11:59:00 -0400..2012-03-12 11:59:01 -0400)\n+---------------------------------------------------\n| [last(grabber-last) , day(repeater-day) , at(separator-at) , 11:59(repeater-time-43140?, timezone) ]\n+---------------------------------------------------\n => 2012-03-12 11:59:00 -0400 \n1.9.3-p194 :004 > Chronic.parse \"yesterday at 11:59\", :now => Time.parse('2012-03-12')\n-anchor\nHandler: handle_r\nHandler-class: Chronic::RepeaterDay\n--(2012-03-10 23:00:00 -0500..2012-03-12 00:00:00 -0400)\n--(2012-03-10 23:00:00 -0500..2012-03-12 00:00:00 -0400)\n+---------------------------------------------------\n| [last(grabber-last) , day(repeater-day) , at(separator-at) , 11:59(repeater-time-43140?, timezone) ]\n+---------------------------------------------------\n => nil\nOops, this shouldn't return nil.\n1.9.3-p194 :005 > Chronic.parse \"12:30 PM\", :now => Time.local(2012, 3, 11, 17, 0, 0, 0)\n-anchor\nHandler: handle_r\nHandler-class: Chronic::RepeaterDayPortion\n--(2012-03-11 13:00:00 -0400..2012-03-12 00:59:59 -0400)\n--(2012-03-11 13:00:00 -0400..2012-03-12 00:59:59 -0400)\n--(2012-03-12 00:30:00 -0400..2012-03-12 00:30:01 -0400)\n+---------------------------------------------------\n| [12:30(repeater-time-1800?, timezone) , pm(repeater-dayportion-pm) ]\n+---------------------------------------------------\n => 2012-03-12 00:30:00 -0400 \n1.9.3-p194 :006 >\nShould return: \n=> 2012-03-12 12:30:00 -0400\nI think @duelinmarkers is correct, the underlying issue is adding 86,400 seconds to advance to the next day, which just doesn't work on the days that have 23 or 25 hours. \n. Similar problem but slightly different can be found here:\nhttps://github.com/mojombo/chronic/issues/74\n. ",
    "mikeraimondi": "I can confirm that this issue still exists. Chronic.parse('12:00') returns nil on March 8, 2015.\n. I can confirm that this issue still exists. Chronic.parse('12:00') returns nil on March 8, 2015.\n. ",
    "simonmorley": "+1\n. +1\n. ",
    "harold": "Also, fwiw, I think chronic is rad. Integrating it has made the thing I'm working on better, and I'm grateful.\n. When will this show up on rubygems?\n. Nothing is on fire. Whenever is clever.\n. Will do. You're very welcome.\n. @injekt, any chance to push this? Thanks.\n. So cool.\n. Also, fwiw, I think chronic is rad. Integrating it has made the thing I'm working on better, and I'm grateful.\n. When will this show up on rubygems?\n. Nothing is on fire. Whenever is clever.\n. Will do. You're very welcome.\n. @injekt, any chance to push this? Thanks.\n. So cool.\n. ",
    "innonate": "Oops. Was wrong about three summers ago. Didn't read the result correctly.\n. Oops. Was wrong about three summers ago. Didn't read the result correctly.\n. ",
    "kenneth-reitz": ":sparkles: :cake: :sparkles:\n. :sparkles: :cake: :sparkles:\n. ",
    "tarr11": "So here's my dirty hack.   Please let me know if you want it or if this is totally the wrong idea.  :D\nhttps://github.com/tarr11/chronic/commit/a76c6b364970bce1055afc85eb85780b70321351\n. So here's my dirty hack.   Please let me know if you want it or if this is totally the wrong idea.  :D\nhttps://github.com/tarr11/chronic/commit/a76c6b364970bce1055afc85eb85780b70321351\n. ",
    "ndbroadbent": "Ahh, sorry, my irb session was loading version \"0.3.9\". Using bundle exec irb does load \"0.6.7\".\nHowever, in your example, isn't 2012-02-16 the wrong date? Should it be 2012-02-01?\nI would have thought that the following first day of this month string produced the correct result:\n```\n\n\nChronic::VERSION\n=> \"0.3.9\" \nChronic.pre_normalize 'first day of this month'\n=> \"first day of this month\" \nChronic.pre_normalize '1st day of this month'\n=> \"1st day of this month\" \nChronic.parse 'first day of this month'\n=> 2012-02-01 12:00:00 0800 \nChronic.parse '1st day of this month'\n=> 2012-02-16 12:00:00 0800 \n```\n. I think it just adding one to today's date, so tomorrow it would\nproduce 2012-02-17\n\n\n2012/2/15 Piotrek Oko\u0144ski <\nreply@reply.github.com\n\nIt really does return 16th instead of 1st day:\n``` ruby\n1.9.3p0 :002 > Chronic::VERSION\n => \"0.6.7\"\n1.9.3p0 :003 > Chronic.pre_normalize 'first day of this month'\n => \"1st day of this month\"\n1.9.3p0 :004 > Chronic.pre_normalize '1st day of this month'\n => \"1st day of this month\"\n1.9.3p0 :005 > Chronic.parse 'first day of this month'\n => 2012-02-16 12:00:00 +0100\n1.9.3p0 :006 > Chronic.parse '1st day of this month'\n => 2012-02-16 12:00:00 +0100\n```\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/83#issuecomment-3977813\n. Ahh, sorry, my irb session was loading version \"0.3.9\". Using bundle exec irb does load \"0.6.7\".\n\nHowever, in your example, isn't 2012-02-16 the wrong date? Should it be 2012-02-01?\nI would have thought that the following first day of this month string produced the correct result:\n```\n\n\nChronic::VERSION\n=> \"0.3.9\" \nChronic.pre_normalize 'first day of this month'\n=> \"first day of this month\" \nChronic.pre_normalize '1st day of this month'\n=> \"1st day of this month\" \nChronic.parse 'first day of this month'\n=> 2012-02-01 12:00:00 0800 \nChronic.parse '1st day of this month'\n=> 2012-02-16 12:00:00 0800 \n```\n. I think it just adding one to today's date, so tomorrow it would\nproduce 2012-02-17\n\n\n2012/2/15 Piotrek Oko\u0144ski <\nreply@reply.github.com\n\nIt really does return 16th instead of 1st day:\n``` ruby\n1.9.3p0 :002 > Chronic::VERSION\n => \"0.6.7\"\n1.9.3p0 :003 > Chronic.pre_normalize 'first day of this month'\n => \"1st day of this month\"\n1.9.3p0 :004 > Chronic.pre_normalize '1st day of this month'\n => \"1st day of this month\"\n1.9.3p0 :005 > Chronic.parse 'first day of this month'\n => 2012-02-16 12:00:00 +0100\n1.9.3p0 :006 > Chronic.parse '1st day of this month'\n => 2012-02-16 12:00:00 +0100\n```\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/83#issuecomment-3977813\n. \n",
    "pokonski": "You still posted the results for 0.3.9 instead of 0.6.7. 1st and \"first\" work correctly in 0.6.7.\nBUT it really does return 16th instead of 1st day:\n``` ruby\n1.9.3p0 :002 > Chronic::VERSION\n => \"0.6.7\" \n1.9.3p0 :003 > Chronic.pre_normalize 'first day of this month'\n => \"1st day of this month\" \n1.9.3p0 :004 > Chronic.pre_normalize '1st day of this month'\n => \"1st day of this month\" \n1.9.3p0 :005 > Chronic.parse 'first day of this month'\n => 2012-02-16 12:00:00 +0100 \n1.9.3p0 :006 > Chronic.parse '1st day of this month'\n => 2012-02-16 12:00:00 +0100 \n```\n. (\u0ca0_\u0ca0)\n. You still posted the results for 0.3.9 instead of 0.6.7. 1st and \"first\" work correctly in 0.6.7.\nBUT it really does return 16th instead of 1st day:\n``` ruby\n1.9.3p0 :002 > Chronic::VERSION\n => \"0.6.7\" \n1.9.3p0 :003 > Chronic.pre_normalize 'first day of this month'\n => \"1st day of this month\" \n1.9.3p0 :004 > Chronic.pre_normalize '1st day of this month'\n => \"1st day of this month\" \n1.9.3p0 :005 > Chronic.parse 'first day of this month'\n => 2012-02-16 12:00:00 +0100 \n1.9.3p0 :006 > Chronic.parse '1st day of this month'\n => 2012-02-16 12:00:00 +0100 \n```\n. (\u0ca0_\u0ca0)\n. ",
    "ottumm": "I tried to find a smaller reproducible case, but removing almost anything gets rid of the error.\n. Yeah, that makes sense. I'm trying to use Chronic to both extract and parse by splitting a sentence up into its component phrases and attempting to parse each phrase (in order of decreasing length) with Chronic. If Chronic returns nil, the algorithm moves onto the next phrase.\nSo, for this issue, I don't expect Chronic to be able to extract the time from the long phrase, but I would like it to return nil instead of throwing an exception. Does that seem reasonable? If so, I can attempt a fix. \nOn Thursday, May 31, 2012 at 9:51 AM, Lee Jarvis wrote:\n\nThere's not really much way to get around this. Chronic isn't built for extracting times, but rather parsing them. That is, Chronic expects something which represents a string that should return a new Time object. Your time should first be extracted from your string before it's sent to Chronic.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/86#issuecomment-6041230\n. Oh, awesome! I missed the commit above, thanks for fixing!\n. I tried to find a smaller reproducible case, but removing almost anything gets rid of the error.\n. Yeah, that makes sense. I'm trying to use Chronic to both extract and parse by splitting a sentence up into its component phrases and attempting to parse each phrase (in order of decreasing length) with Chronic. If Chronic returns nil, the algorithm moves onto the next phrase.\n\nSo, for this issue, I don't expect Chronic to be able to extract the time from the long phrase, but I would like it to return nil instead of throwing an exception. Does that seem reasonable? If so, I can attempt a fix. \nOn Thursday, May 31, 2012 at 9:51 AM, Lee Jarvis wrote:\n\nThere's not really much way to get around this. Chronic isn't built for extracting times, but rather parsing them. That is, Chronic expects something which represents a string that should return a new Time object. Your time should first be extracted from your string before it's sent to Chronic.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mojombo/chronic/issues/86#issuecomment-6041230\n. Oh, awesome! I missed the commit above, thanks for fixing!\n. \n",
    "mrowe": "And even when it does parse a date successfully, it seems to be a bit confused about the time change:\n```\n\n\nChronic.parse \"5 days from now 03:00\"\n=> Tue Apr 03 02:00:00 +1000 2012\n```\n\n\n(We move out of daylight saving time March 31st in this time zone.)\n. And even when it does parse a date successfully, it seems to be a bit confused about the time change:\n```\n\n\nChronic.parse \"5 days from now 03:00\"\n=> Tue Apr 03 02:00:00 +1000 2012\n```\n\n\n(We move out of daylight saving time March 31st in this time zone.)\n. ",
    "jeremyf": "The following code will verify this test:\n```\n# At present this one succeeds\ntime = parse_now(\"2012-11-4 11:00\")\nassert_equal Time.local(2012,11,4, 11), time\n\n# At present this one fails \ntime = parse_now(\"2012-11-4 11:00AM\")\nassert_equal Time.local(2012,11,4, 11), time\n\n```\nThe problem resides in https://github.com/mojombo/chronic/blob/master/lib/chronic/repeaters/repeater_day_portion.rb\nIf you run TZ=UTC rake the test will pass.  If you run rake the tests will not.  Likewise TZ=EST or TZ=EDT will work.  This is a function of the PORTIONS constant :am.\n. @injekt I would love for the code to be refactored, as it isn't pretty, though the systemic use of 24_60_60 to represent a day would need to be reviewed.\n. @injekt No worries, I'm glad I was able to kick up a specific solution which provides some insights to a general solution. And so long as the specs pass, we have a whole lot more liberties to let this patch live as is. Cheers!\n. The following code will verify this test:\n```\n# At present this one succeeds\ntime = parse_now(\"2012-11-4 11:00\")\nassert_equal Time.local(2012,11,4, 11), time\n\n# At present this one fails \ntime = parse_now(\"2012-11-4 11:00AM\")\nassert_equal Time.local(2012,11,4, 11), time\n\n```\nThe problem resides in https://github.com/mojombo/chronic/blob/master/lib/chronic/repeaters/repeater_day_portion.rb\nIf you run TZ=UTC rake the test will pass.  If you run rake the tests will not.  Likewise TZ=EST or TZ=EDT will work.  This is a function of the PORTIONS constant :am.\n. @injekt I would love for the code to be refactored, as it isn't pretty, though the systemic use of 24_60_60 to represent a day would need to be reviewed.\n. @injekt No worries, I'm glad I was able to kick up a specific solution which provides some insights to a general solution. And so long as the specs pass, we have a whole lot more liberties to let this patch live as is. Cheers!\n. ",
    "kevinmtrowbridge": "Looks like the presence of the 2 digit hour gives it trouble ... perhaps it causes it to believe that the time is in a 24 hour format?  And yet, it seems perfectly valid to me to write 03:15pm ... that's equivalent to 15:15?\n. Looks like the presence of the 2 digit hour gives it trouble ... perhaps it causes it to believe that the time is in a 24 hour format?  And yet, it seems perfectly valid to me to write 03:15pm ... that's equivalent to 15:15?\n. ",
    "dkaufman": "Sorry, forgot to add the test file to git before. It should be there now and .DS_STORE should be removed.\n. Sorry, forgot to add the test file to git before. It should be there now and .DS_STORE should be removed.\n. ",
    "steveburkett": "hi all, i added the both case option.  any idea of when it might become part of the public gem?  for our app, i'll use my forked copy for now.  thanks, i was happy to help! ;)\n. hi all, i added the both case option.  any idea of when it might become part of the public gem?  for our app, i'll use my forked copy for now.  thanks, i was happy to help! ;)\n. ",
    "DaveSanders": "+1 - this is biting us too.  I'm going to have to do some pre-parsing.\n. +1 - this is biting us too.  I'm going to have to do some pre-parsing.\n. ",
    "unikitty37": "Thanks \u2014 I see your point there :)\n. Just a quick note for anyone finding this ticket that it's now Chronic::Parser::DEFAULT_OPTIONS :)\n. Thanks \u2014 I see your point there :)\n. Just a quick note for anyone finding this ticket that it's now Chronic::Parser::DEFAULT_OPTIONS :)\n. ",
    "moskrin": "Thanks tinyclanger!  Just the quick note I was looking for.\n. Thanks tinyclanger!  Just the quick note I was looking for.\n. ",
    "dmagliola": "Ok, sounds good. I thought I understood the rationale, but wanted to check if there was a simple way.\nTo be honest, i'm not using Chronic just for that particular case. I decided on Chronic because it lets people put in things like \"18.20\", or \"8pm\", and I don't need to care because you did an awesome job parsing those :-)\nThe case I'm mentioning is the only one I found that is important to me, that I couldn't figure out how to make Chronic handle. And I have a solution, which is just \"preprocessing\", and if what I got in a straight, plain Integer, I just take it as it is, and if not, I pass it on to Chronic.\nBut, again, wanted to see if there was a more elegant way using the library.\nThank you for your quick response!!\n. Ok, sounds good. I thought I understood the rationale, but wanted to check if there was a simple way.\nTo be honest, i'm not using Chronic just for that particular case. I decided on Chronic because it lets people put in things like \"18.20\", or \"8pm\", and I don't need to care because you did an awesome job parsing those :-)\nThe case I'm mentioning is the only one I found that is important to me, that I couldn't figure out how to make Chronic handle. And I have a solution, which is just \"preprocessing\", and if what I got in a straight, plain Integer, I just take it as it is, and if not, I pass it on to Chronic.\nBut, again, wanted to see if there was a more elegant way using the library.\nThank you for your quick response!!\n. ",
    "taylorbrooks": "Sorry, I left out the word 'of'. It should've read:\nconsole\nirb(main):001:0> Chronic.parse('15th of this month')\n=> nil\nThat's human comprehensible or even '15th day of this month' should work.\n. Sorry, I left out the word 'of'. It should've read:\nconsole\nirb(main):001:0> Chronic.parse('15th of this month')\n=> nil\nThat's human comprehensible or even '15th day of this month' should work.\n. ",
    "andreydjason": "+1 for this idea - good if it work in Rails 3.2 - seems not working yet (or I'm wrong?)\n. Ok man, this sounds good, will make some tests, thanks!\n. +1 for this idea - good if it work in Rails 3.2 - seems not working yet (or I'm wrong?)\n. Ok man, this sounds good, will make some tests, thanks!\n. ",
    "metbril": "+1 for localization. (I am Dutch). If the code is working properly, then I am happy to add a nl-NL localization file.\n. +1 for localization. (I am Dutch). If the code is working properly, then I am happy to add a nl-NL localization file.\n. ",
    "mperice": "@injekt I don't want to nag but any news on this subject?\n. @injekt I don't want to nag but any news on this subject?\n. ",
    "abdirixman": "i do not want to gar but \n. i do not want to gar but \n. ",
    "guyisra": "+1\n. +1\n. ",
    "apuntovanini": "+1 (+2 if I could!) I'd be happy to contribute with the italian locale!\n. +1 (+2 if I could!) I'd be happy to contribute with the italian locale!\n. ",
    "double12gzh": "Good Luck\nOn 2013\u5e7405\u670822\u65e5 04:16, Andrea Vanini wrote:\n\n+1 (+2 if I could!) I'd be happy to contribute with the italian locale!\n\u2014\nReply to this email directly or view it on GitHub \nhttps://github.com/mojombo/chronic/pull/113#issuecomment-18236786.\n\n\nUbuntu\n. Good Luck\nOn 2013\u5e7405\u670822\u65e5 04:16, Andrea Vanini wrote:\n\n+1 (+2 if I could!) I'd be happy to contribute with the italian locale!\n\u2014\nReply to this email directly or view it on GitHub \nhttps://github.com/mojombo/chronic/pull/113#issuecomment-18236786.\n\n\nUbuntu\n. ",
    "dgilperez": "Well, I'd love to contribute with an spanish locale :) \n. +1 for a very interesting feature\n. Well, I'd love to contribute with an spanish locale :) \n. +1 for a very interesting feature\n. ",
    "kylejginavan": "Would be nice to also support ISO dates without seperators like \"19660316\"\n. Would be nice to also support ISO dates without seperators like \"19660316\"\n. ",
    "ticktricktrack": "I do that already, just trying to push a few if's from my code into yours. ;)\n. Convinced, no problem. I'm still incredibly happy about chronic and sometimes wonder how I could do without it. (Better not look at old CSV code)\n. I do that already, just trying to push a few if's from my code into yours. ;)\n. Convinced, no problem. I'm still incredibly happy about chronic and sometimes wonder how I could do without it. (Better not look at old CSV code)\n. ",
    "creativetags": "I also found Stamp but it's just a friendly way to configure strftime.\n. Fair enough, it may well be beyond the goals of Chronic. Maybe somebody sees this and thinks it would be worth starting a project for it. I'd be happy to contribute en-GB localisation for it. I appreciate there are lots of ways to represent time but just something simple, understandable by most and friendly would be nice.\n. Nice! Thanks\n. I also found Stamp but it's just a friendly way to configure strftime.\n. Fair enough, it may well be beyond the goals of Chronic. Maybe somebody sees this and thinks it would be worth starting a project for it. I'd be happy to contribute en-GB localisation for it. I appreciate there are lots of ways to represent time but just something simple, understandable by most and friendly would be nice.\n. Nice! Thanks\n. ",
    "sbowman": "For those that are trying to use Chronic with Rails, here's a workaround for varying time zones.  Basically you keep Chronic in one time zone (UTC), then parse the date/time that comes back from it into the correct time zone.\nruby\n1.9.3p194 :042 > parsed = Chronic.parse(\"tomorrow 3 pm\")\n => Tue, 21 Aug 2012 15:00:00 UTC +00:00 \n1.9.3p194 :043 > ActiveSupport::TimeZone['America/Phoenix'].parse(parsed.strftime(\"%Y-%m-%d %H:%M:%S\"))\n => Tue, 21 Aug 2012 15:00:00 MST -07:00\nNot exactly efficient, but it's safe.\n. Yep, that's what I meant.  And that was my same thought:  pass around a :time_zone option to the handlers. \nI checked out the code with the intention of going down that road, but I haven't had the time to write test cases against it yet.\n. For those that are trying to use Chronic with Rails, here's a workaround for varying time zones.  Basically you keep Chronic in one time zone (UTC), then parse the date/time that comes back from it into the correct time zone.\nruby\n1.9.3p194 :042 > parsed = Chronic.parse(\"tomorrow 3 pm\")\n => Tue, 21 Aug 2012 15:00:00 UTC +00:00 \n1.9.3p194 :043 > ActiveSupport::TimeZone['America/Phoenix'].parse(parsed.strftime(\"%Y-%m-%d %H:%M:%S\"))\n => Tue, 21 Aug 2012 15:00:00 MST -07:00\nNot exactly efficient, but it's safe.\n. Yep, that's what I meant.  And that was my same thought:  pass around a :time_zone option to the handlers. \nI checked out the code with the intention of going down that road, but I haven't had the time to write test cases against it yet.\n. ",
    "linjunpop": "Also\n``` bash\n\n\nChronic.parse('tomorrow 19')\n=> nil\nChronic.parse('tomorrow 18')\n=> Tue Sep 18 18:00:00 +0800 2012\n```\n. Also\n\n\n``` bash\n\n\nChronic.parse('tomorrow 19')\n=> nil\nChronic.parse('tomorrow 18')\n=> Tue Sep 18 18:00:00 +0800 2012\n```\n. \n\n",
    "hahuang65": "No response, and I no longer need this fixed anyways.. No response, and I no longer need this fixed anyways.. ",
    "robinroestenburg": "Note that in the first example Chronic actually adds 1 hour to the time. This results in 13:00 (which is incorrect) to be returned instead of 12:00.\n. Note that in the first example Chronic actually adds 1 hour to the time. This results in 13:00 (which is incorrect) to be returned instead of 12:00.\n. ",
    "fakeleft": "Crap. Sorry, I garbled the Chronic parse results from my irb session.\nruby\nChronic.parse(\"2012-01-01 01:00:00.100\")\nreturns nil.\nI think the point still stands, however - Time.parse works, Chronic.parse doesn't.\nThat's with 0.8.0, btw.\n. I still don't understand how two things that are synonymous produce different results; that, or it's disappointing that Chronic's precision is only good down to the day. I guess complaining without a pull request is not worth much...\n. Crap. Sorry, I garbled the Chronic parse results from my irb session.\nruby\nChronic.parse(\"2012-01-01 01:00:00.100\")\nreturns nil.\nI think the point still stands, however - Time.parse works, Chronic.parse doesn't.\nThat's with 0.8.0, btw.\n. I still don't understand how two things that are synonymous produce different results; that, or it's disappointing that Chronic's precision is only good down to the day. I guess complaining without a pull request is not worth much...\n. ",
    "alexdowad": "I see. Thanks for pointing this out, and sorry for the inconvenience caused. Next time I find a \"bug\" in a gem I'll check for a newer version first...\n. I agree that the approach here is not particularly clean. It was based on the assumption that since this gem seems to be fairly mature, you probably already have the code structured more or less the way you want it, and probably wouldn't want to disturb everything. This was a way to make the gem thread-safe without disturbing the existing code.\nWould you prefer to pass \"now\" as an argument everywhere it is needed?\nOr the logic in Chronic.parse could be split out into a Parser class, which would have an attribute :now. Chronic.parse would simply instantiate a Parser and call \"parse\" on it.\nWhat solution do you prefer?\n. Hi...\nJust had a bit of time this morning, so I whipped up something for you to look at... I'm not issuing a PR right now, because there may be stylistic issues, etc. to resolve first, but here it is:\nhttps://github.com/alexdowad/chronic/commit/199204267c288b6d7f1666ebb0067d467c1614e4\nThere were a number of public methods on Chronic which were essentially helper methods for \"parse\", like \"pre_normalize\" and so on. Those are now methods on Chronic::Parser, and with # :nodoc: on Chronic::Parser, they will not appear in the API docs any more. That is probably a good thing; it means the \"public API\" of your gem will have shrunk. I'm sure clients never use those helper methods directly anyways.\n. OK, here is another cut at it...\nhttps://github.com/alexdowad/chronic/commit/d04f26fe0557c13bf900631173025071351fb454\nAbout the issue regarding Parser/Handler/Handlers, well, this thing is \"your baby\", so however you would like the code to be structured, that is fine. Parser holds all the \"options\" which apply to the current parse. Handler/Handlers need to access that state. Possible solutions include passing the options as arguments into the Handlers, or folding the Handlers into Parser. Passing the Parser itself into the Handlers seems strange to me conceptually, because I think of the Handlers as internal \"components\" of the Parser (like little cogs in a clock), and it seems strange to think of them as acting on the Parser as a whole.\n. OK, issuing a new PR from the rebased branch...\n. Tests for #121 and #123? That shouldn't be hard.\n. They shouldn't be hard, but as it turns out, it is very difficult to get\nthe thread-safety test to fail on MRI! I'm trying to run it on JRuby and\nsee what happens...\n. Arrrghhh! Sorry! I meant to issue a request for you to merge this into next...\n. Do you want me to issue a new PR excluding commit a9555bc? Personally, I don't think it hurts to keep it, because a future version of Ruby may get rid of the GIL, in which case thread safety will become more of an issue.\n. Done. Please note, though, that the problem is not that the test is dependent on Ruby implementations; the \"problem\" (if you can call it that) is that under MRI, Chronic is so close to thread-safe even with mutable, global configuration options, that it's incredibly hard to tell the difference. MRI limits concurrency so severely that once a thread starts running Chronic.parse, it almost always finishes it before another thread has the chance to enter.\n. @nodrog: For now, the easiest thing you can do is to create your own wrapper around Chronic.parse, and use that rather than using Chronic directly. Something like...\ndef parse_date(date)\n  if date =~ /^\\d{4}$/\n    Date.civil(date.to_i, 1, 1)\n  else\n    Chronic.parse(date)\n  end\nend\n. > I believe Chronic shouldn't be designed...\nWell, what Chronic \"should\" or \"shouldn't\" do is up to you to decide. I can just say that Chronic would be a lot more useful to me personally if it included such features, and I believe it would be more useful to other developers as well.\nWhat is Chronic? The readme says it's a \"pure Ruby natural language date parser\". Why would people want a natural language date parser? To parse input which is typed in by a human user (for computer generated output, such as timestamps in a log file, there's no need to resort to a \"natural language\" parser). Where would human users need to type in dates? Probably the most common application is in web sites where users need to enter dates when creating or searching for records. Why pull in a \"date parser\" gem rather than just using something like Date.civil(*str.split('/'))? Because by just wrapping your input in a call to Chronic.parse(), with no additional effort on your part, you can automatically accept all kinds of input, such as \"2 weeks ago\", etc. Entering \"2 weeks ago\" is a lot more convenient for the user than looking at a calendar to find an exact date.\nWhere do users need to enter a time period (rather than a single point in time)? Again, the most common case is probably when searching for a set of records. Chronic.parse('...', :guess => false) is great here, because again, with no effort on your part, you can support all kinds of input, such as \"last week\", \"November 2011\", and so on. \"From ... to ...\" is just a natural extension to that concept.\nIf I can express one more thing here: I think :guess => false for Chronic.parse is a misnomer. The question is not whether Chronic should \"guess\" an exact date or not; the question is whether you are expecting to get back a point in time or a period of time.\nThe code for get_span which you show here is good, but in a way, requiring the client programmer to use such code defeats the purpose of Chronic. The great thing about Chronic is simply that you can support all the date/time period formats you could ever want, with a single call to Chronic.parse.\n. I see. Thanks for pointing this out, and sorry for the inconvenience caused. Next time I find a \"bug\" in a gem I'll check for a newer version first...\n. I agree that the approach here is not particularly clean. It was based on the assumption that since this gem seems to be fairly mature, you probably already have the code structured more or less the way you want it, and probably wouldn't want to disturb everything. This was a way to make the gem thread-safe without disturbing the existing code.\nWould you prefer to pass \"now\" as an argument everywhere it is needed?\nOr the logic in Chronic.parse could be split out into a Parser class, which would have an attribute :now. Chronic.parse would simply instantiate a Parser and call \"parse\" on it.\nWhat solution do you prefer?\n. Hi...\nJust had a bit of time this morning, so I whipped up something for you to look at... I'm not issuing a PR right now, because there may be stylistic issues, etc. to resolve first, but here it is:\nhttps://github.com/alexdowad/chronic/commit/199204267c288b6d7f1666ebb0067d467c1614e4\nThere were a number of public methods on Chronic which were essentially helper methods for \"parse\", like \"pre_normalize\" and so on. Those are now methods on Chronic::Parser, and with # :nodoc: on Chronic::Parser, they will not appear in the API docs any more. That is probably a good thing; it means the \"public API\" of your gem will have shrunk. I'm sure clients never use those helper methods directly anyways.\n. OK, here is another cut at it...\nhttps://github.com/alexdowad/chronic/commit/d04f26fe0557c13bf900631173025071351fb454\nAbout the issue regarding Parser/Handler/Handlers, well, this thing is \"your baby\", so however you would like the code to be structured, that is fine. Parser holds all the \"options\" which apply to the current parse. Handler/Handlers need to access that state. Possible solutions include passing the options as arguments into the Handlers, or folding the Handlers into Parser. Passing the Parser itself into the Handlers seems strange to me conceptually, because I think of the Handlers as internal \"components\" of the Parser (like little cogs in a clock), and it seems strange to think of them as acting on the Parser as a whole.\n. OK, issuing a new PR from the rebased branch...\n. Tests for #121 and #123? That shouldn't be hard.\n. They shouldn't be hard, but as it turns out, it is very difficult to get\nthe thread-safety test to fail on MRI! I'm trying to run it on JRuby and\nsee what happens...\n. Arrrghhh! Sorry! I meant to issue a request for you to merge this into next...\n. Do you want me to issue a new PR excluding commit a9555bc? Personally, I don't think it hurts to keep it, because a future version of Ruby may get rid of the GIL, in which case thread safety will become more of an issue.\n. Done. Please note, though, that the problem is not that the test is dependent on Ruby implementations; the \"problem\" (if you can call it that) is that under MRI, Chronic is so close to thread-safe even with mutable, global configuration options, that it's incredibly hard to tell the difference. MRI limits concurrency so severely that once a thread starts running Chronic.parse, it almost always finishes it before another thread has the chance to enter.\n. @nodrog: For now, the easiest thing you can do is to create your own wrapper around Chronic.parse, and use that rather than using Chronic directly. Something like...\ndef parse_date(date)\n  if date =~ /^\\d{4}$/\n    Date.civil(date.to_i, 1, 1)\n  else\n    Chronic.parse(date)\n  end\nend\n. > I believe Chronic shouldn't be designed...\nWell, what Chronic \"should\" or \"shouldn't\" do is up to you to decide. I can just say that Chronic would be a lot more useful to me personally if it included such features, and I believe it would be more useful to other developers as well.\nWhat is Chronic? The readme says it's a \"pure Ruby natural language date parser\". Why would people want a natural language date parser? To parse input which is typed in by a human user (for computer generated output, such as timestamps in a log file, there's no need to resort to a \"natural language\" parser). Where would human users need to type in dates? Probably the most common application is in web sites where users need to enter dates when creating or searching for records. Why pull in a \"date parser\" gem rather than just using something like Date.civil(*str.split('/'))? Because by just wrapping your input in a call to Chronic.parse(), with no additional effort on your part, you can automatically accept all kinds of input, such as \"2 weeks ago\", etc. Entering \"2 weeks ago\" is a lot more convenient for the user than looking at a calendar to find an exact date.\nWhere do users need to enter a time period (rather than a single point in time)? Again, the most common case is probably when searching for a set of records. Chronic.parse('...', :guess => false) is great here, because again, with no effort on your part, you can support all kinds of input, such as \"last week\", \"November 2011\", and so on. \"From ... to ...\" is just a natural extension to that concept.\nIf I can express one more thing here: I think :guess => false for Chronic.parse is a misnomer. The question is not whether Chronic should \"guess\" an exact date or not; the question is whether you are expecting to get back a point in time or a period of time.\nThe code for get_span which you show here is good, but in a way, requiring the client programmer to use such code defeats the purpose of Chronic. The great thing about Chronic is simply that you can support all the date/time period formats you could ever want, with a single call to Chronic.parse.\n. ",
    "EddyKang": "I'm having the same problem. Adding a time zone returns nil.\n\n\nChronic.parse(\"2013-09-30T01:00:00\")\n=> 2013-09-30 01:00:00 -0700\nChronic.parse(\"2013-09-30T01:00:00-05:00\")\n=> nil\n. @injekt will do thx\n. I'm having the same problem. Adding a time zone returns nil.\nChronic.parse(\"2013-09-30T01:00:00\")\n=> 2013-09-30 01:00:00 -0700\nChronic.parse(\"2013-09-30T01:00:00-05:00\")\n=> nil\n. @injekt will do thx\n. \n\n",
    "nodrog": "+1 for this, i have dates that could be in the format of May 2012 or just 2012\nI am not sure how i can use chronic with these formats, any help much appreciated...\n. thanks alex, yes i ended up doing something similar. Its a shame that chronic cant do this at the moment but i do understand the issue.\nIt would be nice if you could put chronic in a 'date' mode, when all you care about is the date and not the time, as in my case.\nmany thanks for you help\n. +1 for this, i have dates that could be in the format of May 2012 or just 2012\nI am not sure how i can use chronic with these formats, any help much appreciated...\n. thanks alex, yes i ended up doing something similar. Its a shame that chronic cant do this at the moment but i do understand the issue.\nIt would be nice if you could put chronic in a 'date' mode, when all you care about is the date and not the time, as in my case.\nmany thanks for you help\n. ",
    "kswope": "I ran into this same problem on my very first experiment with chronic.\nChronic.parse('2000', :guess => false)\n => 2013-04-05 20:00:00 -0400..2013-04-05 20:00:01 -0400\nI was expecting a range from the first day of the year to the last day.  Who would expect '2000' to be an hour?\nA flagrant violation of principle of least astonishment?  And on the simplest of jobs?\n. I ran into this same problem on my very first experiment with chronic.\nChronic.parse('2000', :guess => false)\n => 2013-04-05 20:00:00 -0400..2013-04-05 20:00:01 -0400\nI was expecting a range from the first day of the year to the last day.  Who would expect '2000' to be an hour?\nA flagrant violation of principle of least astonishment?  And on the simplest of jobs?\n. ",
    "yfeldblum": "I agree. That would be simpler and better.\n. I agree. That would be simpler and better.\n. ",
    "travisbell": "Probably related, this morning, my Chronic calls started straight up failing right at 2AM when DST kicked over.\nChronic.parse('tomorrow at 4:00 pm')\nIs now nil. Argh?\n1.9.2p320 :006 > Chronic.parse('tomorrow at 4:00 pm')\n => nil \n1.9.2p320 :007 >\nI'm currently setting the timezone like so, if that matters:\nTime.zone = \"Pacific Time (US & Canada)\"\nChronic.time_class = Time.zone\nSetting the timezone to 'UTC' seems to fix it. But I am wondering why this worked all the way until yesterday but not today?\n. Probably related, this morning, my Chronic calls started straight up failing right at 2AM when DST kicked over.\nChronic.parse('tomorrow at 4:00 pm')\nIs now nil. Argh?\n1.9.2p320 :006 > Chronic.parse('tomorrow at 4:00 pm')\n => nil \n1.9.2p320 :007 >\nI'm currently setting the timezone like so, if that matters:\nTime.zone = \"Pacific Time (US & Canada)\"\nChronic.time_class = Time.zone\nSetting the timezone to 'UTC' seems to fix it. But I am wondering why this worked all the way until yesterday but not today?\n. ",
    "markerdmann": "I ran into the exact same issue today described by @travisbell above.\n. @injekt I have some time to work on this. I'll fork and send a pull request if I have any luck. Do you have an idea of where in the codebase I might start looking to find the source of the bug?\n. I ran into the exact same issue today described by @travisbell above.\n. @injekt I have some time to work on this. I'll fork and send a pull request if I have any luck. Do you have an idea of where in the codebase I might start looking to find the source of the bug?\n. ",
    "wakiki": "I also encountered the same error as @bricker - has there been any updates on this?\n. I don't know if this is the same issue but I noted the following in issue #179 \n1.9.3p362 :021 > Time.current\n=> Tue, 12 Mar 2013 11:01:30 GMT +00:00 \n1.9.3p362 :017 > Time.zone = \"London\"\n=> \"London\" \n1.9.3p362 :018 > Chronic.time_class = Time.zone\n=> (GMT+00:00) London \n1.9.3p362 :019 > Chronic.parse(\"April 1st at 9am\")\n=> Mon, 01 Apr 2013 09:00:00 BST +01:00 \n1.9.3p362 :020 > Chronic.parse(\"20 days from now at 9am\")\n=> Mon, 01 Apr 2013 10:00:00 BST +01:00\nInterestingly, specifying \"April 1st\" works fine whereas \"20 days from now\" doesn't work.\nChronic 0.9.1\nRails 3.2.6\n. +1 I have the same issue.\n1.9.3p362 :021 > Time.current\n => Tue, 12 Mar 2013 11:01:30 GMT +00:00 \n1.9.3p362 :017 >   Time.zone = \"London\"\n => \"London\" \n1.9.3p362 :018 > Chronic.time_class = Time.zone\n => (GMT+00:00) London \n1.9.3p362 :019 > Chronic.parse(\"April 1st at 9am\")\n => Mon, 01 Apr 2013 09:00:00 BST +01:00 \n1.9.3p362 :020 > Chronic.parse(\"20 days from now at 9am\")\n => Mon, 01 Apr 2013 10:00:00 BST +01:00 \nInterestingly, specifying \"April 1st\" works fine whereas \"20 days from now\" doesn't work.\nChronic 0.9.1\nRails 3.2.6\n. I also encountered the same error as @bricker - has there been any updates on this?\n. I don't know if this is the same issue but I noted the following in issue #179 \n1.9.3p362 :021 > Time.current\n=> Tue, 12 Mar 2013 11:01:30 GMT +00:00 \n1.9.3p362 :017 > Time.zone = \"London\"\n=> \"London\" \n1.9.3p362 :018 > Chronic.time_class = Time.zone\n=> (GMT+00:00) London \n1.9.3p362 :019 > Chronic.parse(\"April 1st at 9am\")\n=> Mon, 01 Apr 2013 09:00:00 BST +01:00 \n1.9.3p362 :020 > Chronic.parse(\"20 days from now at 9am\")\n=> Mon, 01 Apr 2013 10:00:00 BST +01:00\nInterestingly, specifying \"April 1st\" works fine whereas \"20 days from now\" doesn't work.\nChronic 0.9.1\nRails 3.2.6\n. +1 I have the same issue.\n1.9.3p362 :021 > Time.current\n => Tue, 12 Mar 2013 11:01:30 GMT +00:00 \n1.9.3p362 :017 >   Time.zone = \"London\"\n => \"London\" \n1.9.3p362 :018 > Chronic.time_class = Time.zone\n => (GMT+00:00) London \n1.9.3p362 :019 > Chronic.parse(\"April 1st at 9am\")\n => Mon, 01 Apr 2013 09:00:00 BST +01:00 \n1.9.3p362 :020 > Chronic.parse(\"20 days from now at 9am\")\n => Mon, 01 Apr 2013 10:00:00 BST +01:00 \nInterestingly, specifying \"April 1st\" works fine whereas \"20 days from now\" doesn't work.\nChronic 0.9.1\nRails 3.2.6\n. ",
    "kareemk": "Thank you for an awesome gem!\nOn Nov 14, 2012, at 8:13 AM, Lee Jarvis notifications@github.com wrote:\n\nAwesome work, thanks a lot\n\u2014\nReply to this email directly or view it on GitHub.\n. Thank you for an awesome gem!\n\nOn Nov 14, 2012, at 8:13 AM, Lee Jarvis notifications@github.com wrote:\n\nAwesome work, thanks a lot\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "anaMZ": "Here you go :)\n. Here you go :)\n. ",
    "burlesona": "Hey, thanks for the quick reply!\nJust be clear, what I specifically would like to change is to not set Time.zone= when parsing, because in my testing that change affects any other part of the application that uses the Time class.\n. Ok one last comment to make sure my use case makes sense. I use Chronic to parse times for events, events could happen in multiple time zones. So I'd want to not only have Chronic use the system time zone (ie :time_class => Time.zone) but allow the input to specify different time zones. Ie, users are submitting events that need the time parsed, and they might create events in many different time zones.\nYou may well have already meant this and I just don't understand how Chronic works well enough to see it, but that's why I was interested in specifying a specific time zone to use as an option on a single parse.\nSo I might want to do this back to back:\nmeeting_time_1 = Chronic.parse('January 2 at 3pm', :time_zone => 'Eastern Time (US & Canada)')\nmeeting_time_2 = Chronic.parse('January 4 at 3pm', :time_zone => 'Central Time (US & Canada)')\nIn this case the time string is provided by the user in a text field, and the time zone is selected from a dropdown.\nDoes that make sense?\n. Hey, thanks for the quick reply!\nJust be clear, what I specifically would like to change is to not set Time.zone= when parsing, because in my testing that change affects any other part of the application that uses the Time class.\n. Ok one last comment to make sure my use case makes sense. I use Chronic to parse times for events, events could happen in multiple time zones. So I'd want to not only have Chronic use the system time zone (ie :time_class => Time.zone) but allow the input to specify different time zones. Ie, users are submitting events that need the time parsed, and they might create events in many different time zones.\nYou may well have already meant this and I just don't understand how Chronic works well enough to see it, but that's why I was interested in specifying a specific time zone to use as an option on a single parse.\nSo I might want to do this back to back:\nmeeting_time_1 = Chronic.parse('January 2 at 3pm', :time_zone => 'Eastern Time (US & Canada)')\nmeeting_time_2 = Chronic.parse('January 4 at 3pm', :time_zone => 'Central Time (US & Canada)')\nIn this case the time string is provided by the user in a text field, and the time zone is selected from a dropdown.\nDoes that make sense?\n. ",
    "zxiest": "Try something like this:\nChronic.parse(\"next 5:00 pm\", \n:time_class => ActiveSupport::TimeZone.new(\"Pacific Time (US & Canada)\")).utc\n. Maybe this will help someone:\nhttp://stackoverflow.com/a/15786663/226255\nChronic.parse(\"next 5:00 pm\", \n:time_class => ActiveSupport::TimeZone.new(User.first.time_zone)).utc\n. Try something like this:\nChronic.parse(\"next 5:00 pm\", \n:time_class => ActiveSupport::TimeZone.new(\"Pacific Time (US & Canada)\")).utc\n. Maybe this will help someone:\nhttp://stackoverflow.com/a/15786663/226255\nChronic.parse(\"next 5:00 pm\", \n:time_class => ActiveSupport::TimeZone.new(User.first.time_zone)).utc\n. ",
    "markalanevans": "How would one do this without using ActiveSupport? I would like to set the default timezone and i'm using Sinatra.\n. Experiencing the same thing, So are you saying it will go away tomorrow?\n. To me it looks like the problem is happening here:\nhttps://github.com/mojombo/chronic/blob/2e7a3e11643305ba39b08c9b32c6495a0a75226b/lib/chronic/handlers.rb#L559\nI'm using it like:\ntime_at_midnight = Chronic.parse(\"today at midnight\", :now => report.date.to_time )\nWhere report.date  is a DateTime for today   11/3/2013.\n. And your on .10.1\n. All i know is that reporting for us was working until yesterday. We did no updates and then all of a sudden certain reports started failing and its because the Chronic.parse method is returning nil and that seems to be because in some cases\nAnd if this line here:\nhttps://github.com/mojombo/chronic/blob/2e7a3e11643305ba39b08c9b32c6495a0a75226b/lib/chronic/handlers.rb#L569\nreturned h\nthen my reports work, \n. Something definitely happened a few weeks ago, all of a sudden Chronic started returning nil for me as well.\n. so does midnight not work?\n. How would one do this without using ActiveSupport? I would like to set the default timezone and i'm using Sinatra.\n. Experiencing the same thing, So are you saying it will go away tomorrow?\n. To me it looks like the problem is happening here:\nhttps://github.com/mojombo/chronic/blob/2e7a3e11643305ba39b08c9b32c6495a0a75226b/lib/chronic/handlers.rb#L559\nI'm using it like:\ntime_at_midnight = Chronic.parse(\"today at midnight\", :now => report.date.to_time )\nWhere report.date  is a DateTime for today   11/3/2013.\n. And your on .10.1\n. All i know is that reporting for us was working until yesterday. We did no updates and then all of a sudden certain reports started failing and its because the Chronic.parse method is returning nil and that seems to be because in some cases\nAnd if this line here:\nhttps://github.com/mojombo/chronic/blob/2e7a3e11643305ba39b08c9b32c6495a0a75226b/lib/chronic/handlers.rb#L569\nreturned h\nthen my reports work, \n. Something definitely happened a few weeks ago, all of a sudden Chronic started returning nil for me as well.\n. so does midnight not work?\n. ",
    "kbaum": "@burlesona  - ActiveSupport Time.zone = only changes the time zone for the current thread and not the entire application.  If you sent it back to the default after using it, you will not impact other users.\n. @burlesona  - ActiveSupport Time.zone = only changes the time zone for the current thread and not the entire application.  If you sent it back to the default after using it, you will not impact other users.\n. ",
    "dnagir": "@leejarvis you are suggesting to do this Chronic.parse(string, :time_class => Time.zone).\nIt would be fine, except that Chronic does not support time_class as an option yet.\nWith that in mind the only workaround I can see is this https://github.com/mojombo/chronic/issues/182#issuecomment-47058375\n. Is there a usable workaround currently?\nAll I can see to work this around is the following:\n (assuming time_class as an option for parse isn't supported yet)\nruby\ndef parse_with_tz(value)\n  previous = Chronic.time_class\n  begin\n    Chronic.time_class = Time.zone\n    return Chronic.parse(value)\n  ensure\n    Chronic.time_class = previous\n  end\nend\nI was expecting this NOT to be thread-safe.\nHowever, I could not confirm it on MRI and Rubinius:\nhttps://gist.github.com/dnagir/5329defec514596fdc6e\nSo I'm a little puzzled as to whether there's a need in syncronisation (Mutex) or not.\n. UPDATE: I've tested it on JRuby and it does indeed break there. So I can confirm that synchronisation is indeed required for the parse_with_tz. For example:\n``` ruby\nSYNC = Mutex.new\ndef parse_with_tz(value)\n  SYNC.synchronize do\n    previous = Chronic.time_class\n    begin\n      Chronic.time_class = Time.zone\n      return Chronic.parse(value)\n    ensure\n      Chronic.time_class = previous\n    end\n  end\nend\n```\n. UPDATE 2: All implementations will require synchronisation. The fact that MRI and Rubinius didn't in my has no conclusion yet.\nThis is because the Ruby class vars are generally unsafe as proven by this, simplified test - https://gist.github.com/dnagir/80df45c96b49776dd174\n. I don't know how that SO answer can help because time_class option is Not\nsupported at all as far as I can see.\nOn 25 Jun 2014 18:25, \"Abdo\" notifications@github.com wrote:\n\nMaybe this will help someone:\nhttp://stackoverflow.com/a/15786663/226255\nChronic.parse(\"next 5:00 pm\",\n:time_class => ActiveSupport::TimeZone.new(User.first.time_zone)).utc\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mojombo/chronic/issues/182#issuecomment-47073576.\n. @leejarvis roger that.\n\nI'll see if I can send a PR within a few days or so with all that sorted.\nUnless you have it sorted already of course?\n. Do you guys develop Chronic on Ruby 2?\nI'm given error even when I try to bundle it:\n`` sh\n$ bundle\nThere was a LoadError while loading chronic.gemspec: \ncannot load such file -- numerizer from\n  /Users/dnagir/proj/chronic/chronic.gemspec:2:in'\nDoes it try to require a relative path? That's been removed in Ruby 1.9.\n``\n. Well, I just had a closer look at theparser.rb` file.\nThis whole drama can be avoided easily by using now option.\nThis makes me wonder what's the point of the time_class option at all then?\nWhat should happen if both now and time_class options are given?\nThe solution to the whole issue is as simple as: Chronic.parse '9am', now: Time.zone.now\n. In the meanwhile, this PR would make it clear about the time_class support: https://github.com/mojombo/chronic/pull/269\n. Well, I see why now now options doesn't work (which it should) to fix this issue.\nThe time_class is being used all over the place:\n```\nlib/chronic/date.rb\n66:      start_year = Chronic.time_class.now.year - bias\nlib/chronic/handlers.rb\n10:      day_start = Chronic.time_class.local(year, month, day)\n78:        day_start = Chronic.time_class.local(year, month, day)\n126:        end_time = Chronic.time_class.local(next_month_year, next_month_month)\n127:        Span.new(Chronic.time_class.local(year, month), end_time)\n135:      t = Chronic.time_class.parse(options[:text])\n151:        day_start = Chronic.time_class.local(year, month, day)\n168:        day_start = Chronic.time_class.local(year, month, day)\n185:        day_start = Chronic.time_class.local(year, month, day)\n209:        day_start = Chronic.time_class.local(year, month, day)\n240:        day_start = Chronic.time_class.local(year, month, day)\n241:        day_start = Chronic.time_class.local(year + 1, month, day) if options[:context] == :future && day_start < now\n265:        end_time = Chronic.time_class.local(next_month_year, next_month_month)\n266:        Span.new(Chronic.time_class.local(year, month), end_time)\n297:          start_time = Chronic.time_class.local(year, month.index, day)\n301:          day_start = Chronic.time_class.local(year, month.index, day)\n318:        start_time = Chronic.time_class.local(year, month.index, day)\n340:          start_time = Chronic.time_class.local(year, month, day)\n344:          day_start = Chronic.time_class.local(year, month, day)\n363:          start_time = Chronic.time_class.local(year, month.index, day)\n367:          day_start = Chronic.time_class.local(year, month.index, day)\n384:        start_time = Chronic.time_class.local(year, month.index, day)\n399:        time = Chronic.time_class.local(year, month, day, h, m, s)\n400:        end_time = Chronic.time_class.local(year, month, day + 1, h, m, s)\n402:        time = Chronic.time_class.local(year, month, day)\n404:        end_time = Chronic.time_class.local(year, month, day)\n583:      Chronic.time_class.local(*date_parts)\nlib/chronic/parser.rb\n54:      @now = options.delete(:now) || Chronic.time_class.now\nlib/chronic/repeaters/repeater_day.rb\n14:        @current_day_start = Chronic.time_class.local(@now.year, @now.month, @now.day)\nlib/chronic/repeaters/repeater_time.rb\n79:        midnight = Chronic.time_class.local(@now.year, @now.month, @now.day)\nlib/chronic/repeaters/repeater_week.rb\n40:        this_week_start = Chronic.time_class.local(@now.year, @now.month, @now.day, @now.hour) + RepeaterHour::HOUR_SECONDS\n47:        this_week_end = Chronic.time_class.local(@now.year, @now.month, @now.day, @now.hour)\nlib/chronic/time.rb\n31:      offset = Chronic.time_class.now.to_time.utc_offset unless offset # get current system's UTC offset if offset is nil\nlib/chronic.rb\n69:    #   Chronic.time_class = Time.zone\n74:    attr_accessor :time_class\n78:  self.time_class = ::Time\n140:    if Chronic.time_class.name == \"Date\"\n141:      Chronic.time_class.new(year, month, day)\n142:    elsif not Chronic.time_class.respond_to?(:new) or (RUBY_VERSION.to_f < 1.9 and Chronic.time_class.name == \"Time\")\n143:      Chronic.time_class.local(year, month, day, hour, minute, second)\n145:      offset = Time::normalize_offset(offset) if Chronic.time_class.name == \"DateTime\"\n146:      Chronic.time_class.new(year, month, day, hour, minute, second, offset)\nREADME.md\n152:>> Chronic.time_class = Time.zone\ntest/test_chronic.rb\n133:    org = Chronic.time_class\n135:      Chronic.time_class = ::Time\n139:      Chronic.time_class = org\n144:    org = Chronic.time_class\n146:      Chronic.time_class = ::Date\n149:      Chronic.time_class = org\n154:    org = Chronic.time_class\n156:      Chronic.time_class = ::DateTime\n160:      Chronic.time_class = org\n168:    org = Chronic.time_class\n172:      Chronic.time_class = ::Time.zone\n175:      Chronic.time_class = ::Time.zone\n178:      Chronic.time_class = org\n```\nSo whether we add it not it as an option, or whether we use now option or not... is irrelevant because the global Chronic.time_class is still being used everywhere.\nI'm giving up on this :(\n. @leejarvis you are suggesting to do this Chronic.parse(string, :time_class => Time.zone).\nIt would be fine, except that Chronic does not support time_class as an option yet.\nWith that in mind the only workaround I can see is this https://github.com/mojombo/chronic/issues/182#issuecomment-47058375\n. Is there a usable workaround currently?\nAll I can see to work this around is the following:\n (assuming time_class as an option for parse isn't supported yet)\nruby\ndef parse_with_tz(value)\n  previous = Chronic.time_class\n  begin\n    Chronic.time_class = Time.zone\n    return Chronic.parse(value)\n  ensure\n    Chronic.time_class = previous\n  end\nend\nI was expecting this NOT to be thread-safe.\nHowever, I could not confirm it on MRI and Rubinius:\nhttps://gist.github.com/dnagir/5329defec514596fdc6e\nSo I'm a little puzzled as to whether there's a need in syncronisation (Mutex) or not.\n. UPDATE: I've tested it on JRuby and it does indeed break there. So I can confirm that synchronisation is indeed required for the parse_with_tz. For example:\n``` ruby\nSYNC = Mutex.new\ndef parse_with_tz(value)\n  SYNC.synchronize do\n    previous = Chronic.time_class\n    begin\n      Chronic.time_class = Time.zone\n      return Chronic.parse(value)\n    ensure\n      Chronic.time_class = previous\n    end\n  end\nend\n```\n. UPDATE 2: All implementations will require synchronisation. The fact that MRI and Rubinius didn't in my has no conclusion yet.\nThis is because the Ruby class vars are generally unsafe as proven by this, simplified test - https://gist.github.com/dnagir/80df45c96b49776dd174\n. I don't know how that SO answer can help because time_class option is Not\nsupported at all as far as I can see.\nOn 25 Jun 2014 18:25, \"Abdo\" notifications@github.com wrote:\n\nMaybe this will help someone:\nhttp://stackoverflow.com/a/15786663/226255\nChronic.parse(\"next 5:00 pm\",\n:time_class => ActiveSupport::TimeZone.new(User.first.time_zone)).utc\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mojombo/chronic/issues/182#issuecomment-47073576.\n. @leejarvis roger that.\n\nI'll see if I can send a PR within a few days or so with all that sorted.\nUnless you have it sorted already of course?\n. Do you guys develop Chronic on Ruby 2?\nI'm given error even when I try to bundle it:\n`` sh\n$ bundle\nThere was a LoadError while loading chronic.gemspec: \ncannot load such file -- numerizer from\n  /Users/dnagir/proj/chronic/chronic.gemspec:2:in'\nDoes it try to require a relative path? That's been removed in Ruby 1.9.\n``\n. Well, I just had a closer look at theparser.rb` file.\nThis whole drama can be avoided easily by using now option.\nThis makes me wonder what's the point of the time_class option at all then?\nWhat should happen if both now and time_class options are given?\nThe solution to the whole issue is as simple as: Chronic.parse '9am', now: Time.zone.now\n. In the meanwhile, this PR would make it clear about the time_class support: https://github.com/mojombo/chronic/pull/269\n. Well, I see why now now options doesn't work (which it should) to fix this issue.\nThe time_class is being used all over the place:\n```\nlib/chronic/date.rb\n66:      start_year = Chronic.time_class.now.year - bias\nlib/chronic/handlers.rb\n10:      day_start = Chronic.time_class.local(year, month, day)\n78:        day_start = Chronic.time_class.local(year, month, day)\n126:        end_time = Chronic.time_class.local(next_month_year, next_month_month)\n127:        Span.new(Chronic.time_class.local(year, month), end_time)\n135:      t = Chronic.time_class.parse(options[:text])\n151:        day_start = Chronic.time_class.local(year, month, day)\n168:        day_start = Chronic.time_class.local(year, month, day)\n185:        day_start = Chronic.time_class.local(year, month, day)\n209:        day_start = Chronic.time_class.local(year, month, day)\n240:        day_start = Chronic.time_class.local(year, month, day)\n241:        day_start = Chronic.time_class.local(year + 1, month, day) if options[:context] == :future && day_start < now\n265:        end_time = Chronic.time_class.local(next_month_year, next_month_month)\n266:        Span.new(Chronic.time_class.local(year, month), end_time)\n297:          start_time = Chronic.time_class.local(year, month.index, day)\n301:          day_start = Chronic.time_class.local(year, month.index, day)\n318:        start_time = Chronic.time_class.local(year, month.index, day)\n340:          start_time = Chronic.time_class.local(year, month, day)\n344:          day_start = Chronic.time_class.local(year, month, day)\n363:          start_time = Chronic.time_class.local(year, month.index, day)\n367:          day_start = Chronic.time_class.local(year, month.index, day)\n384:        start_time = Chronic.time_class.local(year, month.index, day)\n399:        time = Chronic.time_class.local(year, month, day, h, m, s)\n400:        end_time = Chronic.time_class.local(year, month, day + 1, h, m, s)\n402:        time = Chronic.time_class.local(year, month, day)\n404:        end_time = Chronic.time_class.local(year, month, day)\n583:      Chronic.time_class.local(*date_parts)\nlib/chronic/parser.rb\n54:      @now = options.delete(:now) || Chronic.time_class.now\nlib/chronic/repeaters/repeater_day.rb\n14:        @current_day_start = Chronic.time_class.local(@now.year, @now.month, @now.day)\nlib/chronic/repeaters/repeater_time.rb\n79:        midnight = Chronic.time_class.local(@now.year, @now.month, @now.day)\nlib/chronic/repeaters/repeater_week.rb\n40:        this_week_start = Chronic.time_class.local(@now.year, @now.month, @now.day, @now.hour) + RepeaterHour::HOUR_SECONDS\n47:        this_week_end = Chronic.time_class.local(@now.year, @now.month, @now.day, @now.hour)\nlib/chronic/time.rb\n31:      offset = Chronic.time_class.now.to_time.utc_offset unless offset # get current system's UTC offset if offset is nil\nlib/chronic.rb\n69:    #   Chronic.time_class = Time.zone\n74:    attr_accessor :time_class\n78:  self.time_class = ::Time\n140:    if Chronic.time_class.name == \"Date\"\n141:      Chronic.time_class.new(year, month, day)\n142:    elsif not Chronic.time_class.respond_to?(:new) or (RUBY_VERSION.to_f < 1.9 and Chronic.time_class.name == \"Time\")\n143:      Chronic.time_class.local(year, month, day, hour, minute, second)\n145:      offset = Time::normalize_offset(offset) if Chronic.time_class.name == \"DateTime\"\n146:      Chronic.time_class.new(year, month, day, hour, minute, second, offset)\nREADME.md\n152:>> Chronic.time_class = Time.zone\ntest/test_chronic.rb\n133:    org = Chronic.time_class\n135:      Chronic.time_class = ::Time\n139:      Chronic.time_class = org\n144:    org = Chronic.time_class\n146:      Chronic.time_class = ::Date\n149:      Chronic.time_class = org\n154:    org = Chronic.time_class\n156:      Chronic.time_class = ::DateTime\n160:      Chronic.time_class = org\n168:    org = Chronic.time_class\n172:      Chronic.time_class = ::Time.zone\n175:      Chronic.time_class = ::Time.zone\n178:      Chronic.time_class = org\n```\nSo whether we add it not it as an option, or whether we use now option or not... is irrelevant because the global Chronic.time_class is still being used everywhere.\nI'm giving up on this :(\n. ",
    "aroc": "Awesome!\n. Awesome!\n. ",
    "supairish": "You're right, this was happening in a legacy app using 0.6.7.  Upgrading did fix it. I'll close this issue\n. Hi @davispuh,  Sorry, I'm still confused, since I'm in Phoenix, Arizona.  Phoenix stays Mountain (MST) all year round.\nMy system time is\n~/Projects $ date\nFri Jun  6 16:55:12 MST 2014\nEven having Rails list the US timezones shows this\n~/Projects/xxx $ bundle exec rake time:zones:us\n- UTC -10:00 *\n  Hawaii\n- UTC -09:00 *\n  Alaska\n- UTC -08:00 *\n  Pacific Time (US & Canada)\n- UTC -07:00 *\n  Arizona\n  Mountain Time (US & Canada)\n- UTC -06:00 *\n  Central Time (US & Canada)\n- UTC -05:00 *\n  Eastern Time (US & Canada)\n  Indiana (East)\nhttp://www.timeanddate.com/library/abbreviations/timezones/na/mst.html\n. Yep you're right, thanks for the help clarifying!\n. You're right, this was happening in a legacy app using 0.6.7.  Upgrading did fix it. I'll close this issue\n. Hi @davispuh,  Sorry, I'm still confused, since I'm in Phoenix, Arizona.  Phoenix stays Mountain (MST) all year round.\nMy system time is\n~/Projects $ date\nFri Jun  6 16:55:12 MST 2014\nEven having Rails list the US timezones shows this\n~/Projects/xxx $ bundle exec rake time:zones:us\n- UTC -10:00 *\n  Hawaii\n- UTC -09:00 *\n  Alaska\n- UTC -08:00 *\n  Pacific Time (US & Canada)\n- UTC -07:00 *\n  Arizona\n  Mountain Time (US & Canada)\n- UTC -06:00 *\n  Central Time (US & Canada)\n- UTC -05:00 *\n  Eastern Time (US & Canada)\n  Indiana (East)\nhttp://www.timeanddate.com/library/abbreviations/timezones/na/mst.html\n. Yep you're right, thanks for the help clarifying!\n. ",
    "gareth": "Wow, so fast - thanks, and a neat commit hash too!\n. Wow, so fast - thanks, and a neat commit hash too!\n. ",
    "opsb": "I do realise that it's a simple thing to add to your code but in my experience there's never a case where I would want it to return nil. Seeing as it's a well known convention in the ruby community(there can't be many people who haven't used rails at some point) I don't see that it would be confusing for anyone. For anyone that isn't familiar with the convention the readme could easily make it clear(happy to update the README) e.g.\n```\nChronic.parse('tomorrow')\n  #=> Mon Aug 28 12:00:00 PDT 2006\nChronic.parse('when hell freezes over')\n  #=> nil\nChronic.parse!('when hell freezes over')\n  #=> RuntimeError: Could not parse: when hell freezes over\n```\n. The problem I have with the existing API is that I always assumed that an error would be thrown if chronic wasn't able to parse a date. I can't even think of a scenario where I wouldn't want an error to be thrown. I have added it to my own project but it seems silly that what most people would expect to be the default case isn't supported at all. Of course users can add it to their own code but there's a reason it's popular as a Rails-esque feature, it's really useful!\n. Well, I guess it's personal preference in the end. My preference is towards failing fast as a default, rather than silent fails (I'm not trying to be snarky there). I don't see any reason not to support both preferences, especially as it's such a common idiom.\n. I do realise that it's a simple thing to add to your code but in my experience there's never a case where I would want it to return nil. Seeing as it's a well known convention in the ruby community(there can't be many people who haven't used rails at some point) I don't see that it would be confusing for anyone. For anyone that isn't familiar with the convention the readme could easily make it clear(happy to update the README) e.g.\n```\nChronic.parse('tomorrow')\n  #=> Mon Aug 28 12:00:00 PDT 2006\nChronic.parse('when hell freezes over')\n  #=> nil\nChronic.parse!('when hell freezes over')\n  #=> RuntimeError: Could not parse: when hell freezes over\n```\n. The problem I have with the existing API is that I always assumed that an error would be thrown if chronic wasn't able to parse a date. I can't even think of a scenario where I wouldn't want an error to be thrown. I have added it to my own project but it seems silly that what most people would expect to be the default case isn't supported at all. Of course users can add it to their own code but there's a reason it's popular as a Rails-esque feature, it's really useful!\n. Well, I guess it's personal preference in the end. My preference is towards failing fast as a default, rather than silent fails (I'm not trying to be snarky there). I don't see any reason not to support both preferences, especially as it's such a common idiom.\n. ",
    "johari": "@injekt It would have been nice to merge this PR. As opposed to your opinion, I think it's quite reasonable to have parse! in the public API.\nThis issue particularly bugged me when I was using chronic in a custom setter method in a rails app and it was silently failing.. I tried parse! and it didn't work, so I googled \"chronic parse!\" and ended up here..\nAs I'm reviewing the README right now, I can't see anything about the failing behavior at all. It would have been nice to mention it somewhere (maybe in usage?)\n. @injekt I think silently failing was a bad decision in the first place and I don't know the reasons behind it. strptime also raises exception when arguments are invalid:\nirb\nirb(main):001:0> require \"time\"\n=> true\nirb(main):002:0> Time.strptime(\"04\", \"%m\")\n=> 2013-04-01 00:00:00 +0430\nirb(main):003:0> Time.strptime(\"04\", \"%d\")\n=> 2013-06-04 00:00:00 +0430\nirb(main):004:0> Time.strptime(\"04\", \"invalid\")\nArgumentError: invalid strptime format - `invalid'\n...\nHow do you think the current behavior was the most reasonable one for parse? Don't you think there's room for improvement?\nIn fact, the current behavior of parse resembles those of rails methods (like create) and is probably not in accord with the ruby standard library (like strptime), so it's natural to assume chronic provides a parse! method as well (like create!).\nAnyway, if you still disagree, that's fine. But how about explicitly documenting the current failing behavior in the README so maybe others know beforehand they should raise their own exception or write parse! method if they found it necessary?\nI'd be happy to send a PR for that.\n. @injekt I understand your reasons and respect your decision for the current behavior.\nI'll send a minor documentation PR then..\n. :metal: :metal: :metal: \n. @injekt It would have been nice to merge this PR. As opposed to your opinion, I think it's quite reasonable to have parse! in the public API.\nThis issue particularly bugged me when I was using chronic in a custom setter method in a rails app and it was silently failing.. I tried parse! and it didn't work, so I googled \"chronic parse!\" and ended up here..\nAs I'm reviewing the README right now, I can't see anything about the failing behavior at all. It would have been nice to mention it somewhere (maybe in usage?)\n. @injekt I think silently failing was a bad decision in the first place and I don't know the reasons behind it. strptime also raises exception when arguments are invalid:\nirb\nirb(main):001:0> require \"time\"\n=> true\nirb(main):002:0> Time.strptime(\"04\", \"%m\")\n=> 2013-04-01 00:00:00 +0430\nirb(main):003:0> Time.strptime(\"04\", \"%d\")\n=> 2013-06-04 00:00:00 +0430\nirb(main):004:0> Time.strptime(\"04\", \"invalid\")\nArgumentError: invalid strptime format - `invalid'\n...\nHow do you think the current behavior was the most reasonable one for parse? Don't you think there's room for improvement?\nIn fact, the current behavior of parse resembles those of rails methods (like create) and is probably not in accord with the ruby standard library (like strptime), so it's natural to assume chronic provides a parse! method as well (like create!).\nAnyway, if you still disagree, that's fine. But how about explicitly documenting the current failing behavior in the README so maybe others know beforehand they should raise their own exception or write parse! method if they found it necessary?\nI'd be happy to send a PR for that.\n. @injekt I understand your reasons and respect your decision for the current behavior.\nI'll send a minor documentation PR then..\n. :metal: :metal: :metal: \n. ",
    "duckinator": "@opsb @johari since I've wanted parse! many times, but completely understand (and actually kind of agree with) @leejarvis' reasons for not including it by default, I decided to create a small gem that adds it: https://github.com/duckinator/chronic-bang\nProbably overkill, but oh well.\n(P.S.: Sorry for resurrecting a long-dead thread.)\n. @opsb @johari since I've wanted parse! many times, but completely understand (and actually kind of agree with) @leejarvis' reasons for not including it by default, I decided to create a small gem that adds it: https://github.com/duckinator/chronic-bang\nProbably overkill, but oh well.\n(P.S.: Sorry for resurrecting a long-dead thread.)\n. ",
    "michelboaventura": "My timezone is BRST (http://en.wikipedia.org/wiki/Bras%C3%ADlia_Summer_Time).\nThanks!\n. My mistake. Actually I don't know my Timezone. Running with ZT='BRST' also works. How do I find out my TZ?\n. Ok, I'm a little puzzled now:\nbash\n$ date +%Z\n$ BRST\nBut if I set TZ to 'BRST', 'UTC', 'foo', '' and even set it to nothing works, but if I didn't set it I get the two failures. I think my TZ variable is not setted and chronic doesn't like it.\n. I'm trying to find out why this happens on my machines. I've tried it on three gentoo pcs and all of them have this issue. In which part of the code the TZ variable is used?\n. I've tried this on a Fedora machine, with jruby on my gentoo and it fails.\nThe only way to make it pass is to define some TZ.\nI don't have a mac to test it, so it would be nice if you subscribe chronic\nto travis so we can test it with multiple dependencies.\nIf you feel so I can made a push request with the travis configurations to\nmake it easy.\nRegards,\n. Did you were able to subscribe chronic to travis? I'm anxious to see this working so we can close the issue that is bothering me (https://github.com/mojombo/chronic/issues/168) and I can bump chronic version on Gentoo!\n. My timezone is BRST (http://en.wikipedia.org/wiki/Bras%C3%ADlia_Summer_Time).\nThanks!\n. My mistake. Actually I don't know my Timezone. Running with ZT='BRST' also works. How do I find out my TZ?\n. Ok, I'm a little puzzled now:\nbash\n$ date +%Z\n$ BRST\nBut if I set TZ to 'BRST', 'UTC', 'foo', '' and even set it to nothing works, but if I didn't set it I get the two failures. I think my TZ variable is not setted and chronic doesn't like it.\n. I'm trying to find out why this happens on my machines. I've tried it on three gentoo pcs and all of them have this issue. In which part of the code the TZ variable is used?\n. I've tried this on a Fedora machine, with jruby on my gentoo and it fails.\nThe only way to make it pass is to define some TZ.\nI don't have a mac to test it, so it would be nice if you subscribe chronic\nto travis so we can test it with multiple dependencies.\nIf you feel so I can made a push request with the travis configurations to\nmake it easy.\nRegards,\n. Did you were able to subscribe chronic to travis? I'm anxious to see this working so we can close the issue that is bothering me (https://github.com/mojombo/chronic/issues/168) and I can bump chronic version on Gentoo!\n. ",
    "benwbrum": "Upon more thought, this set of features is growing in ways I really don't think are relevant to most Chronic users.  I'm creating my own gem to handle old dates on documents here: https://github.com/benwbrum/antique_date\n. Upon more thought, this set of features is growing in ways I really don't think are relevant to most Chronic users.  I'm creating my own gem to handle old dates on documents here: https://github.com/benwbrum/antique_date\n. ",
    "kachick": "Thanks for your  comments!\nI have just reverted the commit and rebased to current main line  :)\n. Thanks to merge! :)\n. Thanks for your  comments!\nI have just reverted the commit and rebased to current main line  :)\n. Thanks to merge! :)\n. ",
    "grempe": "I can confirm that this is broken.  The nil example given above is in iso8601 format.\nhttp://www.w3.org/TR/NOTE-datetime\nAnd matches the example of the valid formats given in that document:\nComplete date plus hours, minutes and seconds:\n      YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)\nThe TZD (Time Zone Designator) is defined as being valid with:\nTZD  = time zone designator (Z or +hh:mm or -hh:mm)\nHere is another example from a Rails console:\n```\n\n\nChronic.parse(Time.now.utc.iso8601)\n=> 2013-02-21 00:20:01 UTC\nChronic.parse(Time.now.in_time_zone(\"America/Los_Angeles\").iso8601)\n=> nil\n```\n. I can confirm that this is broken.  The nil example given above is in iso8601 format.\n\n\nhttp://www.w3.org/TR/NOTE-datetime\nAnd matches the example of the valid formats given in that document:\nComplete date plus hours, minutes and seconds:\n      YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)\nThe TZD (Time Zone Designator) is defined as being valid with:\nTZD  = time zone designator (Z or +hh:mm or -hh:mm)\nHere is another example from a Rails console:\n```\n\n\nChronic.parse(Time.now.utc.iso8601)\n=> 2013-02-21 00:20:01 UTC\nChronic.parse(Time.now.in_time_zone(\"America/Los_Angeles\").iso8601)\n=> nil\n```\n. \n\n",
    "andrijaperovic": "I seem to be experiencing the same issue but with an earlier version of Chronic (0.6.4).\n1.9.2p290 :012 > Chronic.parse(Time.now.in_time_zone(\"America/Los_Angeles\").iso8601)\n => nil\nis 0.9.0 the correct fix version for this bug?\n. I seem to be experiencing the same issue but with an earlier version of Chronic (0.6.4).\n1.9.2p290 :012 > Chronic.parse(Time.now.in_time_zone(\"America/Los_Angeles\").iso8601)\n => nil\nis 0.9.0 the correct fix version for this bug?\n. ",
    "TALlama": "The problem seems to be here. Coming into that call to next, we have the following state:\nruby\n    @current_time: nil\n    pointer: :future\n    first: true\n    midnight: 2013-03-10 00:00:00 -0800 (a Time)\n    yesterday_midnight: 2013-03-09 00:00:00 -0800 (a Time)\n    tomorrow_midnight: 2013-03-11 00:00:00 -0700 (a Time)\n    offset_fix: -3600\n    @time: 2013-03-10 00:00:00 -0800\n    @type.class: Chronic::RepeaterTime::Tick\n    @type.time: 0\n    @type.ambiguous?: true\nWe then hit line 80 and cycle through:\n- midnight + @type.time + offset_fix resolves to 2013-03-09 23:00:00 -0800 (a Time), which isn't after @now and is rejected\n- midnight + half_day + @type.time + offset_fix is after @now, and is accepted\nSo we pop the stack and end up at Chronic::Handlers#find_within, where our returned span is (2013-03-10 12:00:00 -0700..2013-03-10 12:00:01 -0700) (one second long), and doesn't cover midnight, so we fall off the end of the method and return nil, which also seems problematic.\nI can't see a simple solution to this problem, but it can be easily replicated by doing a simple Chronic.parse('Mar 10, 2013 12:00am'). Note that Chronic.parse(\"Mar 10, 2013 midnight\") works fine, however, since it hits a different repeater_method.\n. I found that the easiest way to trace the problem was by monkey-patching the code and inserting putses when I needed them; the above drop is a snippet of the output. The full monkey-patch, which can be run on a fresh console to show the step-by-step, is on Gist.\n. The problem seems to be here. Coming into that call to next, we have the following state:\nruby\n    @current_time: nil\n    pointer: :future\n    first: true\n    midnight: 2013-03-10 00:00:00 -0800 (a Time)\n    yesterday_midnight: 2013-03-09 00:00:00 -0800 (a Time)\n    tomorrow_midnight: 2013-03-11 00:00:00 -0700 (a Time)\n    offset_fix: -3600\n    @time: 2013-03-10 00:00:00 -0800\n    @type.class: Chronic::RepeaterTime::Tick\n    @type.time: 0\n    @type.ambiguous?: true\nWe then hit line 80 and cycle through:\n- midnight + @type.time + offset_fix resolves to 2013-03-09 23:00:00 -0800 (a Time), which isn't after @now and is rejected\n- midnight + half_day + @type.time + offset_fix is after @now, and is accepted\nSo we pop the stack and end up at Chronic::Handlers#find_within, where our returned span is (2013-03-10 12:00:00 -0700..2013-03-10 12:00:01 -0700) (one second long), and doesn't cover midnight, so we fall off the end of the method and return nil, which also seems problematic.\nI can't see a simple solution to this problem, but it can be easily replicated by doing a simple Chronic.parse('Mar 10, 2013 12:00am'). Note that Chronic.parse(\"Mar 10, 2013 midnight\") works fine, however, since it hits a different repeater_method.\n. I found that the easiest way to trace the problem was by monkey-patching the code and inserting putses when I needed them; the above drop is a snippet of the output. The full monkey-patch, which can be run on a fresh console to show the step-by-step, is on Gist.\n. ",
    "bostonaholic": "+1\n. +1\n. ",
    "dougc84": "+1 same issue here.  EST Time zone.\n. +1 same issue here.  EST Time zone.\n. ",
    "kueda": "FWIW still not fixed, but for me it only seems to happen on noon the day of the switch:\n2.2.1 :001 > Chronic.parse(\"2016-03-13 12:29:14 PM\")\n => 2016-03-14 00:29:14 -0700 \n2.2.1 :002 > Chronic.parse(\"2016-03-14 12:29:14 PM\")\n => 2016-03-14 12:29:14 -0700 \n2.2.1 :003 > Chronic.parse(\"2016-03-12 12:29:14 PM\")\n => 2016-03-12 12:29:14 -0800 \n2.2.1 :005 > Chronic.parse(\"2016-03-13 1:29:14 PM\")\n => 2016-03-13 13:29:14 -0700 \n2.2.1 :006 > Chronic.parse(\"2016-03-13 11:29:14 PM\")\n => 2016-03-13 23:29:14 -0700\nAnyone found a workaround, or a fork that works, or an alternate library?\n. FWIW still not fixed, but for me it only seems to happen on noon the day of the switch:\n2.2.1 :001 > Chronic.parse(\"2016-03-13 12:29:14 PM\")\n => 2016-03-14 00:29:14 -0700 \n2.2.1 :002 > Chronic.parse(\"2016-03-14 12:29:14 PM\")\n => 2016-03-14 12:29:14 -0700 \n2.2.1 :003 > Chronic.parse(\"2016-03-12 12:29:14 PM\")\n => 2016-03-12 12:29:14 -0800 \n2.2.1 :005 > Chronic.parse(\"2016-03-13 1:29:14 PM\")\n => 2016-03-13 13:29:14 -0700 \n2.2.1 :006 > Chronic.parse(\"2016-03-13 11:29:14 PM\")\n => 2016-03-13 23:29:14 -0700\nAnyone found a workaround, or a fork that works, or an alternate library?\n. ",
    "ghiculescu": "I tried the suggestion at https://github.com/mojombo/chronic/issues/158#issuecomment-11580360 but it didn't seem to make a difference (though it's not clear to me if any changes were actually made or if @injekt was just suggesting possible changes)\n1.9.3p286 :045 > Chronic.parse('9am', time_class: Time.zone)\n => Thu, 04 Apr 2013 09:00:00 EST +10:00\n. I tried the suggestion at https://github.com/mojombo/chronic/issues/158#issuecomment-11580360 but it didn't seem to make a difference (though it's not clear to me if any changes were actually made or if @injekt was just suggesting possible changes)\n1.9.3p286 :045 > Chronic.parse('9am', time_class: Time.zone)\n => Thu, 04 Apr 2013 09:00:00 EST +10:00\n. ",
    "bjfish": "Would there be any issue with doing the following in rails?\nTime.use_zone('Pacific Time (US & Canada)') do\n                 Chronic.time_class = Time.zone\n                 Chronic.parse(\"Sunday\")\n             end\nThank you\n. Would there be any issue with doing the following in rails?\nTime.use_zone('Pacific Time (US & Canada)') do\n                 Chronic.time_class = Time.zone\n                 Chronic.parse(\"Sunday\")\n             end\nThank you\n. ",
    "chewi": "As @kbaum pointed out in the other issue, Time.zone= is thread local. What @bjfish proposed above is still not safe as Chronic.time_class may get called by other threads during that block, however there is one easy workaround. Stick this in an initializer.\nruby\nmodule Chronic\n  def self.time_class\n    ::Time.zone\n  end\nend\nThen you can safely do this.\nruby\nTime.use_zone('Pacific Time (US & Canada)') do\n  Chronic.parse(\"Sunday\")\nend\n. Unfortunately I've completely forgotten why I looked into this. I don't believe we're using that workaround in production at the moment.\n. As @kbaum pointed out in the other issue, Time.zone= is thread local. What @bjfish proposed above is still not safe as Chronic.time_class may get called by other threads during that block, however there is one easy workaround. Stick this in an initializer.\nruby\nmodule Chronic\n  def self.time_class\n    ::Time.zone\n  end\nend\nThen you can safely do this.\nruby\nTime.use_zone('Pacific Time (US & Canada)') do\n  Chronic.parse(\"Sunday\")\nend\n. Unfortunately I've completely forgotten why I looked into this. I don't believe we're using that workaround in production at the moment.\n. ",
    "espen": "That looks like a good workaround @chewi ,have you been using this in production?\n. great @mphalliday, thanks for the feedback. My tests so far looks good. Thanks for sharing @chewi \n. That looks like a good workaround @chewi ,have you been using this in production?\n. great @mphalliday, thanks for the feedback. My tests so far looks good. Thanks for sharing @chewi \n. ",
    "mphalliday": "@espen we've been using @chewi's workaround for a few weeks in production now.  Working well for us.\n. @espen we've been using @chewi's workaround for a few weeks in production now.  Working well for us.\n. ",
    "pachacamac": "Sorry I just found https://github.com/hpoydar/chronic_duration ... so never mind ;)\n. Sorry I just found https://github.com/hpoydar/chronic_duration ... so never mind ;)\n. ",
    "dudo": "You rock.  Cheers!\n. You rock.  Cheers!\n. ",
    "tbuehlmann": "What about simply using s.add_development_dependency 'minitest', '~> 5.0' in chronic.gemspec?\n. I decided against setting them to nil because I was lazy reading the whole inheritance chain. Will try to cover this. Totally agree. :)\nI'm a bit pondering about the s.add_development_dependency 'minitest', '~> 5.0' right now. The project does not have a Gemfile, that means the ~> 5.0 declaration only affects a gem install chronic --dev, right? I don't want to install the gem when I just want to work on a fork. So how should I assure that the version is actually ~> 5.0?\n. Yeah, I will just set them to nil now. It's a no-brainer.\nhttp://guides.rubygems.org/patterns/#declaring-dependencies states to not use the gem method inside of gems. Possible that it's meant for the gem code and not development..\n. I don't know how @mojombo thinks about having a Gemfile in the project, as it's often a matter of taste. Won't pull it in in this pull request. But I see this one finished for now.\n. Was a pleasure, thanks for merging.\n. What about simply using s.add_development_dependency 'minitest', '~> 5.0' in chronic.gemspec?\n. I decided against setting them to nil because I was lazy reading the whole inheritance chain. Will try to cover this. Totally agree. :)\nI'm a bit pondering about the s.add_development_dependency 'minitest', '~> 5.0' right now. The project does not have a Gemfile, that means the ~> 5.0 declaration only affects a gem install chronic --dev, right? I don't want to install the gem when I just want to work on a fork. So how should I assure that the version is actually ~> 5.0?\n. Yeah, I will just set them to nil now. It's a no-brainer.\nhttp://guides.rubygems.org/patterns/#declaring-dependencies states to not use the gem method inside of gems. Possible that it's meant for the gem code and not development..\n. I don't know how @mojombo thinks about having a Gemfile in the project, as it's often a matter of taste. Won't pull it in in this pull request. But I see this one finished for now.\n. Was a pleasure, thanks for merging.\n. ",
    "anazar": "@davispuh thanks for the follow up! :)  I'll keep an eye out for the update \n. chronic (0.10.2)\nRuby 2.0.0\nRails 4.0.0\nIt's a timezone thing.\nWe have our timezone set as follows:\nconfig.time_zone = 'Pacific Time (US & Canada)'\nWhen that is removed it works fine.\n. @davispuh thanks for the follow up! :)  I'll keep an eye out for the update \n. chronic (0.10.2)\nRuby 2.0.0\nRails 4.0.0\nIt's a timezone thing.\nWe have our timezone set as follows:\nconfig.time_zone = 'Pacific Time (US & Canada)'\nWhen that is removed it works fine.\n. ",
    "ismaelga": "yeah, this doesn't add much to the gem. It's just a little thing to make a clean API.\nBut if it happens that no one does\nruby\nChronic.parse \"3rd thursday this november\", :now => Chronic.parse(\"1/10/2010\")\nthis PR turns out to be useless.\nIf there are people using it this way I think it adds value, if not it shouldn't be merged at all.\n. yeah, this doesn't add much to the gem. It's just a little thing to make a clean API.\nBut if it happens that no one does\nruby\nChronic.parse \"3rd thursday this november\", :now => Chronic.parse(\"1/10/2010\")\nthis PR turns out to be useless.\nIf there are people using it this way I think it adds value, if not it shouldn't be merged at all.\n. ",
    "nurettin": "Will this work for you?\nChronic.parse(\"one week hence monday\")\n. Will this work for you?\nChronic.parse(\"one week hence monday\")\n. ",
    "Sephi-Chan": "Thanks! It will do the job for me.\nLet's hope no one wants to find the second monday of the month. :)\nI might try to implement this one when I have time.\n. Thanks! It will do the job for me.\nLet's hope no one wants to find the second monday of the month. :)\nI might try to implement this one when I have time.\n. ",
    "jwoertink": "This still has a little issue as well. Today is Thursday 5/9/2013\nruby\nChronic.parse('thursday of the month at midnight')\n=> 2013-09-06 00:00:00 -0700\nTime.now.midnight\n=> 2013-09-05 00:00:00 -0700\nNotice is puts midnight for tomorrow Friday 6/9/2013\n. This still has a little issue as well. Today is Thursday 5/9/2013\nruby\nChronic.parse('thursday of the month at midnight')\n=> 2013-09-06 00:00:00 -0700\nTime.now.midnight\n=> 2013-09-05 00:00:00 -0700\nNotice is puts midnight for tomorrow Friday 6/9/2013\n. ",
    "TheConstructor": "+1 tried Chronic.parse(\"First Friday of next month at 19:00\")\n. +1 tried Chronic.parse(\"First Friday of next month at 19:00\")\n. ",
    "henry74": "Looks like it's gone in 0.10.2 so okay to close.  Wow, I just got some bad luck getting stuck with the 0.10.0 version. Gave much a bunch of 0's for date values...\n. @davispuh Pull down 0.10.0 and try for yourself.  I had this running for a large batch of jobs which run at different times and every single one resulted in nil.\n@leejarvis I'm using it in a situation where time is coming from another system and could be nil or a time not generated from Time.now.  The Time.now is just a fallback if it's nil.\n. Looks like it's gone in 0.10.2 so okay to close.  Wow, I just got some bad luck getting stuck with the 0.10.0 version. Gave much a bunch of 0's for date values...\n. @davispuh Pull down 0.10.0 and try for yourself.  I had this running for a large batch of jobs which run at different times and every single one resulted in nil.\n@leejarvis I'm using it in a situation where time is coming from another system and could be nil or a time not generated from Time.now.  The Time.now is just a fallback if it's nil.\n. ",
    "adambrod": "++ thread safety \n. ++ thread safety \n. ",
    "gkop": "+1.\nAlso it may be worth looking at how Timecop handles this and whether Timecop is threadsafe. I like the Timecop API since it lets you run arbitrary code within the block. If we were to copy it for Chronic:\nruby\nChronic.time_class(Time.zone) do\n  Chronic.parse('next tuesday at 3pm')\nend\n. +1\n. +1.\nAlso it may be worth looking at how Timecop handles this and whether Timecop is threadsafe. I like the Timecop API since it lets you run arbitrary code within the block. If we were to copy it for Chronic:\nruby\nChronic.time_class(Time.zone) do\n  Chronic.parse('next tuesday at 3pm')\nend\n. +1\n. ",
    "pawurb": "+1 thread safety\n. +1 thread safety\n. ",
    "goodtouch": "Singular version is good for me.\nHere is the modified (& squashed) version!\n. :heart: \n. Singular version is good for me.\nHere is the modified (& squashed) version!\n. :heart: \n. ",
    "bf4": "Great! Glad you beat me to it :)\n. (I probably just missed your update in between when I found the license missing and when I made the issue-- just now)\n. Great! Glad you beat me to it :)\n. (I probably just missed your update in between when I found the license missing and when I made the issue-- just now)\n. ",
    "p8952": "@davispuh my mistake, using MiniTest5 also fixes the issue.\nHowever I now instead get some warnings:\nWarning: you should require 'minitest/autorun' instead.\nWarning: or add 'gem \"minitest\"' before 'require \"minitest/autorun\"'\nAre these anything to worry about?\n. Thanks for the information @davispuh.\n. @davispuh my mistake, using MiniTest5 also fixes the issue.\nHowever I now instead get some warnings:\nWarning: you should require 'minitest/autorun' instead.\nWarning: or add 'gem \"minitest\"' before 'require \"minitest/autorun\"'\nAre these anything to worry about?\n. Thanks for the information @davispuh.\n. ",
    "guilhermesimoes": "@davispuh  I think you're wrong. Chronic has an inclusive end:\n```\ntoday = Chronic.parse(\"today\", :guess => false)\ntoday.exclude_end?\n=> false\n```\nIn my opinion, this is a problem. Here's an example:\n``` ruby\ntoday = Chronic.parse(\"today\", :guess => false)\n=> 2014-01-05 22:00:00 +0000..2014-01-06 00:00:00 +0000\ntomorrow = Chronic.parse(\"tomorrow\", :guess => false)\n=> 2014-01-06 00:00:00 +0000..2014-01-07 00:00:00 +0000\ndef ranges_intersection(r1, r2)\n  new_begin = [r1.begin, r2.begin].max\n  new_end = [r1.end, r2.end].min\n  exclude_end = (new_end == r1.end && r1.exclude_end?) || (new_end == r2.end && r2.exclude_end?)\nRange.new(new_begin, new_end, exclude_end)\nend\nranges_intersection(today, tomorrow)\n=> 2014-01-06 00:00:00 +0000..2014-01-06 00:00:00 +0000\n```\nThis intersection should be empty.\nIf this isn't changed, I think that at least an option should exist to change this behaviour. I'll be monkey patching this in the meantime:\nruby\nmodule Chronic\n  class Span < Range\n    def initialize(_begin, _end, exclude_end = true)\n      super(_begin, _end, exclude_end)\n    end\n  end\nend\n. Since Ruby 2.1.0, the MRI versioning policy changed to follow Semantic Versioning.\nThus, it is better to use '2.1' instead of '2.1.x' in the Travis config since this way rvm will automatically select the latest patch release.\nhttps://www.ruby-lang.org/en/news/2013/12/21/ruby-version-policy-changes-with-2-1-0/\n. @davispuh  I think you're wrong. Chronic has an inclusive end:\n```\ntoday = Chronic.parse(\"today\", :guess => false)\ntoday.exclude_end?\n=> false\n```\nIn my opinion, this is a problem. Here's an example:\n``` ruby\ntoday = Chronic.parse(\"today\", :guess => false)\n=> 2014-01-05 22:00:00 +0000..2014-01-06 00:00:00 +0000\ntomorrow = Chronic.parse(\"tomorrow\", :guess => false)\n=> 2014-01-06 00:00:00 +0000..2014-01-07 00:00:00 +0000\ndef ranges_intersection(r1, r2)\n  new_begin = [r1.begin, r2.begin].max\n  new_end = [r1.end, r2.end].min\n  exclude_end = (new_end == r1.end && r1.exclude_end?) || (new_end == r2.end && r2.exclude_end?)\nRange.new(new_begin, new_end, exclude_end)\nend\nranges_intersection(today, tomorrow)\n=> 2014-01-06 00:00:00 +0000..2014-01-06 00:00:00 +0000\n```\nThis intersection should be empty.\nIf this isn't changed, I think that at least an option should exist to change this behaviour. I'll be monkey patching this in the meantime:\nruby\nmodule Chronic\n  class Span < Range\n    def initialize(_begin, _end, exclude_end = true)\n      super(_begin, _end, exclude_end)\n    end\n  end\nend\n. Since Ruby 2.1.0, the MRI versioning policy changed to follow Semantic Versioning.\nThus, it is better to use '2.1' instead of '2.1.x' in the Travis config since this way rvm will automatically select the latest patch release.\nhttps://www.ruby-lang.org/en/news/2013/12/21/ruby-version-policy-changes-with-2-1-0/\n. ",
    "equivalent": "interesting thing is that when I change my system date to next week (30.10.2013) Chronic.parse('next week sunday') will work .... so it's not working only for today (23.10.2013), but still w.t.h.? :smile: \n. Make sense, cool thx. For me it's not big issue but can you please live this open for now I guess I'm not the only one who was goggling this \nrelated issues : \n- https://github.com/mojombo/chronic/issues/179\n- https://github.com/mojombo/chronic/issues/177\n. interesting thing is that when I change my system date to next week (30.10.2013) Chronic.parse('next week sunday') will work .... so it's not working only for today (23.10.2013), but still w.t.h.? :smile: \n. Make sense, cool thx. For me it's not big issue but can you please live this open for now I guess I'm not the only one who was goggling this \nrelated issues : \n- https://github.com/mojombo/chronic/issues/179\n- https://github.com/mojombo/chronic/issues/177\n. ",
    "nikolaialex": "If you need help, I can try to help out. \nInstead of providing a bunch of regex, wouldn't it be simpler to translate e.g. a German string to the equivalent English one. Then no one needs to worry about chronic internals. You can apply this transformation right at the beginning of the parse method. \nStill user need a way to provide custom transformer. \n```\nclass GermanTranslator\n  def translate(date)\n     date.gsub /heute/, \"today\"\n  end\nend\nChronic.register(:german, GermanTranslator)\nChronic.parse(\"heute\", language: :german) \n```\n. If you need help, I can try to help out. \nInstead of providing a bunch of regex, wouldn't it be simpler to translate e.g. a German string to the equivalent English one. Then no one needs to worry about chronic internals. You can apply this transformation right at the beginning of the parse method. \nStill user need a way to provide custom transformer. \n```\nclass GermanTranslator\n  def translate(date)\n     date.gsub /heute/, \"today\"\n  end\nend\nChronic.register(:german, GermanTranslator)\nChronic.parse(\"heute\", language: :german) \n```\n. ",
    "nofxx": "@nikolaialex that was what I did back in 2010, it worked but that project is no longer online.\nSo the gem is pretty unmaintained...  https://github.com/nofxx/chronic18n\nhttps://github.com/luan/chronic-l10n  Looks intersting.\n@luan But I don't see why we need to change chronic code to use it isn't just translating it?\n. @nikolaialex that was what I did back in 2010, it worked but that project is no longer online.\nSo the gem is pretty unmaintained...  https://github.com/nofxx/chronic18n\nhttps://github.com/luan/chronic-l10n  Looks intersting.\n@luan But I don't see why we need to change chronic code to use it isn't just translating it?\n. ",
    "daniel-rikowski": "I think it would be a useful feature, because in some situations, especially legal contracts, people use \"midnight\" and \"noon\" instead of \"am\" and \"pm\" to remove any ambiguity. \n. I think it would be a useful feature, because in some situations, especially legal contracts, people use \"midnight\" and \"noon\" instead of \"am\" and \"pm\" to remove any ambiguity. \n. ",
    "yatish27": "Basically it is recommended to use \"\" if there a ruby eval and ' when there is no ruby eval. I know it a very insignificant micro optimization.\n. Basically it is recommended to use \"\" if there a ruby eval and ' when there is no ruby eval. I know it a very insignificant micro optimization.\n. ",
    "direction": "Has there been any updates on this? I'm getting the following errors (all to do with DST starting)\n``` ruby\nChronic.parse(\"2014-03-09\")\n=> Sun, 09 Mar 2014 13:00:00 EDT -04:00 # Why is this at one in the afternoon?\nChronic.parse(\"2014-03-09 12:00 AM\")\n=> nil\nChronic.parse(\"2014-03-09 12:59 AM\")\n=> nil\nChronic.parse(\"2014-03-09 1:00 AM\")\n=> Sun, 09 Mar 2014 00:00:00 EST -05:00 # Why is this midnight?\nChronic.parse(\"2014-03-09 2 AM\")\n=> Sun, 09 Mar 2014 01:00:00 EST -05:00 # This has moved back by one hour\nChronic.parse(\"2014-03-09 12:00 PM\")\n=> Mon, 10 Mar 2014 00:00:00 EDT -04:00 # Why is this midnight of the next day?\n```\nIf I try any other times on that day after 2 AM that is not between noon and 1pm, the parsing is correct. \n. Has there been any updates on this? I'm getting the following errors (all to do with DST starting)\n``` ruby\nChronic.parse(\"2014-03-09\")\n=> Sun, 09 Mar 2014 13:00:00 EDT -04:00 # Why is this at one in the afternoon?\nChronic.parse(\"2014-03-09 12:00 AM\")\n=> nil\nChronic.parse(\"2014-03-09 12:59 AM\")\n=> nil\nChronic.parse(\"2014-03-09 1:00 AM\")\n=> Sun, 09 Mar 2014 00:00:00 EST -05:00 # Why is this midnight?\nChronic.parse(\"2014-03-09 2 AM\")\n=> Sun, 09 Mar 2014 01:00:00 EST -05:00 # This has moved back by one hour\nChronic.parse(\"2014-03-09 12:00 PM\")\n=> Mon, 10 Mar 2014 00:00:00 EDT -04:00 # Why is this midnight of the next day?\n```\nIf I try any other times on that day after 2 AM that is not between noon and 1pm, the parsing is correct. \n. ",
    "graysonwright": "I'm getting the same thing:\n``` ruby\nChronic.parse \"3/8/2014 11:59:59 PM\"\n=> 2014-03-08 23:59:59 -0500\nChronic.parse \"3/9/2014 12:00:00 AM\"\n=> nil\nChronic.parse \"3/9/2014 12:59:59 AM\"\n=> nil\nChronic.parse \"3/9/2014 1:00:00 AM\"\n=> 2014-03-09 00:00:00 -0500\nTime.zone.to_s\n=> \"(GMT-05:00) Eastern Time (US & Canada)\"\n```\nRuby version:\nruby 2.1.0dev (2013-11-23 trunk 43807) [x86_64-darwin13.0]\n. I'm getting the same thing:\n``` ruby\nChronic.parse \"3/8/2014 11:59:59 PM\"\n=> 2014-03-08 23:59:59 -0500\nChronic.parse \"3/9/2014 12:00:00 AM\"\n=> nil\nChronic.parse \"3/9/2014 12:59:59 AM\"\n=> nil\nChronic.parse \"3/9/2014 1:00:00 AM\"\n=> 2014-03-09 00:00:00 -0500\nTime.zone.to_s\n=> \"(GMT-05:00) Eastern Time (US & Canada)\"\n```\nRuby version:\nruby 2.1.0dev (2013-11-23 trunk 43807) [x86_64-darwin13.0]\n. ",
    "maricris-sn": "I'm also experiencing something similar:\nChronic.parse(\"3 Nov 2013 10 AM\")\n=> 2013-11-03 10:00:00 -0500\nChronic.parse(\"3 Nov 2013 11 AM\")\n=> nil\nTime.zone.to_s\n\"(GMT-05:00) Eastern Time (US & Canada)\"\nRuby version:\nruby 1.9.3p484 (2013-11-22 revision 43786) [x86_64-linux]\nRails version:\n3.0.19\n. I'm also experiencing something similar:\nChronic.parse(\"3 Nov 2013 10 AM\")\n=> 2013-11-03 10:00:00 -0500\nChronic.parse(\"3 Nov 2013 11 AM\")\n=> nil\nTime.zone.to_s\n\"(GMT-05:00) Eastern Time (US & Canada)\"\nRuby version:\nruby 1.9.3p484 (2013-11-22 revision 43786) [x86_64-linux]\nRails version:\n3.0.19\n. ",
    "gobert": "The same for me for \"2011 May 09 to 2011 June 28\" with 0.10.2\nChronic.parse('2011 May 09 to 2011 June 28')\n=> NoMethodError: undefined method `+' for nil:NilClass\n. The same for me for \"2011 May 09 to 2011 June 28\" with 0.10.2\nChronic.parse('2011 May 09 to 2011 June 28')\n=> NoMethodError: undefined method `+' for nil:NilClass\n. ",
    "TalkativeTree": "I will also write up an explanation of minutize in the README and add it to the pull request if you want to add this.\n. Yeah, I was thinking about changing it to display seconds (would also require a name change). The one difference between this and ChronicDuration is CD is set to parse duration from specific strings like '4m20sec' where Minutizer parsers duration from text more similar to what Chronic would receive. \nSomething a little more Chronic might be to create a Chronic#parse_span method that incorporates what I've written for Minutizer.\n. Regarding Chronic.parse_span, I was thinking it would be for sentences like:\nruby\n'since last tuesday'\n'until next tuesday'\n'last night until this morning'\n'yesterday until tomorrow'\n'yesterday at 5pm until tomorrow at 8am'\n'8am - 12pm'\n'the last 3 days'\n'the next 30 minutes'\n'since August 30th'\nwhich come from test code I've already written for span creation. parsing spans for these kind outside of Chronic would require recreating/copying a lot of what Chronic currently does.\n. For most of the spans of time, like \"yesterday until tomorrow,\" you don't need a duration. But for \"next 3 hours\" or \"past 30 minutes\" I believe you need some kind of duration or representation of that time difference from now. \nMinutizer was built for the end goal of getting spans using Chronic, which is why I sent a pull request for it first. if @leejarvis gives parse_span the go ahead, I can build that feature for Chronic. \n. Will do. I'll create a branch for all of them, instead of just tacking them onto this branch for naming sake.\n. Removed and pushed. Glad you caught that. As you can tell, I'm working on parse_span today hah.\n. btw, i decided to just reset the branch and clean up the commits so it came in as one commit instead of multiple. no need for a commit for deleting files that weren't supposed to be pushed up.\n. Also, I could probably create comments for the parts I've added more in line with current gem commenting format/depth. Let me know if I should add more explanation.\nedit: PSA: I didn't write any tests for Definitions or Dictionary, since I felt like the existing tests still cover the changes I made. \n. Made changes for everything except for the comment on the line using to_sym.\nedit: I think this is more in line with what your comment actually was saying\n``` ruby\n  class Definitions\n    attr_reader :definitions\ndef initialize(options = {})\n  @definitions = definitions(options)\nend\n\ndef definitions(options)\n  raise \"definitions are set in subclasses of #{self.class}\"\nend\n\nend\n```\nI think there are trade offs and benefits of both ways. I like setting options as an instance variable and maybe even making it a attr_accessor over definitions, because it feels more open/closed and flexible to me. \n. I went ahead and cleaned up the commits. Let me know if there are any changes you want me to make in order to merge this.\nTwo changes to note:\n1) I removed the handler_type.to_sym from Dictionary#[]. \n2) I changed Dictionary's attr_accessor to an attr_reader\nedit: \n3) changed test to test definitions directly instead of Parser. In another branch I'm working on, I made a change to Parser#definitions (removed it and placed it in something else) which caused everything to error. Looking at the tests, they are specifically for definitions, so it makes more sense to me to test definitions directly instead of through Parser.new.\n. Just checking in on the status of this request.\n. No worries, busy happens :). fixed the spelling mistake and added in the parentheses, ammended it to the dictionary commit.\n. I will also write up an explanation of minutize in the README and add it to the pull request if you want to add this.\n. Yeah, I was thinking about changing it to display seconds (would also require a name change). The one difference between this and ChronicDuration is CD is set to parse duration from specific strings like '4m20sec' where Minutizer parsers duration from text more similar to what Chronic would receive. \nSomething a little more Chronic might be to create a Chronic#parse_span method that incorporates what I've written for Minutizer.\n. Regarding Chronic.parse_span, I was thinking it would be for sentences like:\nruby\n'since last tuesday'\n'until next tuesday'\n'last night until this morning'\n'yesterday until tomorrow'\n'yesterday at 5pm until tomorrow at 8am'\n'8am - 12pm'\n'the last 3 days'\n'the next 30 minutes'\n'since August 30th'\nwhich come from test code I've already written for span creation. parsing spans for these kind outside of Chronic would require recreating/copying a lot of what Chronic currently does.\n. For most of the spans of time, like \"yesterday until tomorrow,\" you don't need a duration. But for \"next 3 hours\" or \"past 30 minutes\" I believe you need some kind of duration or representation of that time difference from now. \nMinutizer was built for the end goal of getting spans using Chronic, which is why I sent a pull request for it first. if @leejarvis gives parse_span the go ahead, I can build that feature for Chronic. \n. Will do. I'll create a branch for all of them, instead of just tacking them onto this branch for naming sake.\n. Removed and pushed. Glad you caught that. As you can tell, I'm working on parse_span today hah.\n. btw, i decided to just reset the branch and clean up the commits so it came in as one commit instead of multiple. no need for a commit for deleting files that weren't supposed to be pushed up.\n. Also, I could probably create comments for the parts I've added more in line with current gem commenting format/depth. Let me know if I should add more explanation.\nedit: PSA: I didn't write any tests for Definitions or Dictionary, since I felt like the existing tests still cover the changes I made. \n. Made changes for everything except for the comment on the line using to_sym.\nedit: I think this is more in line with what your comment actually was saying\n``` ruby\n  class Definitions\n    attr_reader :definitions\ndef initialize(options = {})\n  @definitions = definitions(options)\nend\n\ndef definitions(options)\n  raise \"definitions are set in subclasses of #{self.class}\"\nend\n\nend\n```\nI think there are trade offs and benefits of both ways. I like setting options as an instance variable and maybe even making it a attr_accessor over definitions, because it feels more open/closed and flexible to me. \n. I went ahead and cleaned up the commits. Let me know if there are any changes you want me to make in order to merge this.\nTwo changes to note:\n1) I removed the handler_type.to_sym from Dictionary#[]. \n2) I changed Dictionary's attr_accessor to an attr_reader\nedit: \n3) changed test to test definitions directly instead of Parser. In another branch I'm working on, I made a change to Parser#definitions (removed it and placed it in something else) which caused everything to error. Looking at the tests, they are specifically for definitions, so it makes more sense to me to test definitions directly instead of through Parser.new.\n. Just checking in on the status of this request.\n. No worries, busy happens :). fixed the spelling mistake and added in the parentheses, ammended it to the dictionary commit.\n. ",
    "mwlang": "I will take a look at the code and see how hard it is to implement...mostly looking to be able to easily figure out a holday's date either in current year or upcoming year.  For example, Father's Day occurring on \"3rd Sunday of June\" (which worked), and Memorial Day, \"Last Monday in May\" (which didn't).  And of course, do it for current year as well as any specified year (as illustrated above).\n. I will take a look at the code and see how hard it is to implement...mostly looking to be able to easily figure out a holday's date either in current year or upcoming year.  For example, Father's Day occurring on \"3rd Sunday of June\" (which worked), and Memorial Day, \"Last Monday in May\" (which didn't).  And of course, do it for current year as well as any specified year (as illustrated above).\n. ",
    "stevecastaneda": "Don't really understand the details of this issue, but the title seems to be what I was looking for.  I'm trying to extract the recognized date/string from a given string and split it into two.  Would this issue address this need?\n. @leejarvis More details here:\nhttp://stackoverflow.com/questions/21336658/extract-recognized-date-string-passed-to-parse-method-in-chronic/21336891?noredirect=1#21336891\nI was basically trying to figure out how to pass a string to Chronic and have it separate and return the recognized date portion of the string vs. just returning nil when you pass in something like:\n\"Meet at Joes Today at 3PM\"\nWould return something like:\nresults = [\"Meet at Joes\", \"12-24-2014 12:00:00\"]\n. Don't really understand the details of this issue, but the title seems to be what I was looking for.  I'm trying to extract the recognized date/string from a given string and split it into two.  Would this issue address this need?\n. @leejarvis More details here:\nhttp://stackoverflow.com/questions/21336658/extract-recognized-date-string-passed-to-parse-method-in-chronic/21336891?noredirect=1#21336891\nI was basically trying to figure out how to pass a string to Chronic and have it separate and return the recognized date portion of the string vs. just returning nil when you pass in something like:\n\"Meet at Joes Today at 3PM\"\nWould return something like:\nresults = [\"Meet at Joes\", \"12-24-2014 12:00:00\"]\n. ",
    "alexherbo2": "@leejarvis\nruby\nnow = Chronic.parse('Friday')\nformat = now.recognized_format #=> %A\ntomorrow = Chronic.parse('tomorrow', :now => now).to_date.strftime(format) #=> Saturday\n. @leejarvis\nruby\nnow = Chronic.parse('Friday')\nformat = now.recognized_format #=> %A\ntomorrow = Chronic.parse('tomorrow', :now => now).to_date.strftime(format) #=> Saturday\n. ",
    "samlehman": "@davispuh I think I was able to work around it by scrubbing the DateTime object that the API returns before it was emitted.\n. @davispuh I think I was able to work around it by scrubbing the DateTime object that the API returns before it was emitted.\n. ",
    "dnrce": "@leejarvis Wouldn't it be even better to link to the official and automatic http://rubydoc.info/gems/chronic/frames? That removes the need to maintain the documentation page.\n. Or just remove the link entirely, because the GitHub page is the project homepage.\n. As mentioned in #218\n. @leejarvis Wouldn't it be even better to link to the official and automatic http://rubydoc.info/gems/chronic/frames? That removes the need to maintain the documentation page.\n. Or just remove the link entirely, because the GitHub page is the project homepage.\n. As mentioned in #218\n. ",
    "donaldpiret": "Figured out how to get around this so will close this issue for now (do Chronic.parse with guess: false, then check to see if it's a range, and take the first value if it is).\nStill think this behaviour is fairly arbitrary and should probably be better documented in case somebody else gets stung by this :)\n. Because this would make it a lot easier to use the results as part of date/time comparisons.\nI could easily say that Time.new(1979, 05, 27, 5,3,2) > Chronic.parse('1979-05-27')\nMy example use case for this is parsing parameters for an API. We've got an endpoint that's supposed to be able to receive a certain parameter either as a date or as a time, in a couple of different formats. It would be easier for us to assume that anything that comes in without a timestamp as part of the parameter should be seen as beginning of day, so that if you're selecting database records based on it, you will include all the ones for the day itself.\n. Oh wow I didn't even realise there was a :guess => :begin option, guess that makes the solution even easier.\nI guess the way in which you format a date usually carries come context information with it as well.\nYou're right that if I type in \"tomorrow\" I might not mean tonight at midnight, but usually if I type in \"2014-03-17\" there's probably going to be a different meaning/use behind it.\nOf course it's probably not realistic to expect a parser to be able to take care of this without it first having a much deeper understanding of purpose, which is naturally where these options come in.\nProbably my bad for not finding them in the first place, but it might be useful to get the various options for guess documented a little bit better? Do you guys accept documentation patches?\n. Just noticed that there's a pretty similar pull request open at #262 that covers the rake file as well. Closing this one\n. Figured out how to get around this so will close this issue for now (do Chronic.parse with guess: false, then check to see if it's a range, and take the first value if it is).\nStill think this behaviour is fairly arbitrary and should probably be better documented in case somebody else gets stung by this :)\n. Because this would make it a lot easier to use the results as part of date/time comparisons.\nI could easily say that Time.new(1979, 05, 27, 5,3,2) > Chronic.parse('1979-05-27')\nMy example use case for this is parsing parameters for an API. We've got an endpoint that's supposed to be able to receive a certain parameter either as a date or as a time, in a couple of different formats. It would be easier for us to assume that anything that comes in without a timestamp as part of the parameter should be seen as beginning of day, so that if you're selecting database records based on it, you will include all the ones for the day itself.\n. Oh wow I didn't even realise there was a :guess => :begin option, guess that makes the solution even easier.\nI guess the way in which you format a date usually carries come context information with it as well.\nYou're right that if I type in \"tomorrow\" I might not mean tonight at midnight, but usually if I type in \"2014-03-17\" there's probably going to be a different meaning/use behind it.\nOf course it's probably not realistic to expect a parser to be able to take care of this without it first having a much deeper understanding of purpose, which is naturally where these options come in.\nProbably my bad for not finding them in the first place, but it might be useful to get the various options for guess documented a little bit better? Do you guys accept documentation patches?\n. Just noticed that there's a pretty similar pull request open at #262 that covers the rake file as well. Closing this one\n. ",
    "benrugg": "Thanks for the response. I was hoping to actually contribute a fix, but the code is a bit over my head. I'm appreciate being able to use it, though!\n. Thanks for the response. I was hoping to actually contribute a fix, but the code is a bit over my head. I'm appreciate being able to use it, though!\n. ",
    "ravinggenius": "I should have been more clear. Given the date Date.parse('2014-04-28'), I'm looking for a range from Date.parse('2014-04-27') to Date.parse('2014-05-03').\n. Thanks. I also got this to work. I had to add .first.to_date to get the actual Date objects to use in my range.\nruby\nsunday = Chronic.parse('last sunday', :now => DateTime.parse('2014-04-28'), :guess => false).first.to_date\nsaturday = Chronic.parse('next saturday', :now => DateTime.parse('2014-04-28'), :guess => false).first.to_date\nweek = sunday..saturday\n. I should have been more clear. Given the date Date.parse('2014-04-28'), I'm looking for a range from Date.parse('2014-04-27') to Date.parse('2014-05-03').\n. Thanks. I also got this to work. I had to add .first.to_date to get the actual Date objects to use in my range.\nruby\nsunday = Chronic.parse('last sunday', :now => DateTime.parse('2014-04-28'), :guess => false).first.to_date\nsaturday = Chronic.parse('next saturday', :now => DateTime.parse('2014-04-28'), :guess => false).first.to_date\nweek = sunday..saturday\n. ",
    "arencinosa": "...I meant, in terms of results: same date for both cases.\n. ...I meant, in terms of results: same date for both cases.\n. ",
    "greysteil": "What's the status of this? Looks like a bunch of other PRs are waiting for it.\n. Also drops 1.8.7 and 1.9.2 from Travis, both of which I believe are end of life. Spec failure is from JRuby - some who knows this gem better should look at that!\n. @leejarvis - updated\n. @davispuh - version file creation is in here because the current setup doesn't allow bundler to do a clean install. If you don't have numerizer installed and try to bundle install you'll get into trouble with require 'chronic' which in turn will require 'numerizer' which will serve you up an error:\n``\nThere was a LoadError while loading chronic.gemspec: \ncannot load such file -- numerizer from\n  /Users/greysteil/projects/chronic/chronic.gemspec:2:in'\nDoes it try to require a relative path? That's been removed in Ruby 1.9.\n```\nTo get Travis working that's going to be an issue, so I created a version file.\n. Specs are passing fine on Ruby 2.1.2 - you can see Travis on my fork at https://travis-ci.org/greysteil/chronic. As I said, someone who knows this gem better should take a look at that JRuby failure!\n. Sounds good to me - happy to rebase this once #262 is merged\n. I've rebased this off master now https://github.com/mojombo/chronic/pull/262 has been merged. That JRuby spec is still failing though...\n. Cheers @guilhermesimoes. Updated.\n. What's the status of this? Looks like a bunch of other PRs are waiting for it.\n. Also drops 1.8.7 and 1.9.2 from Travis, both of which I believe are end of life. Spec failure is from JRuby - some who knows this gem better should look at that!\n. @leejarvis - updated\n. @davispuh - version file creation is in here because the current setup doesn't allow bundler to do a clean install. If you don't have numerizer installed and try to bundle install you'll get into trouble with require 'chronic' which in turn will require 'numerizer' which will serve you up an error:\n``\nThere was a LoadError while loading chronic.gemspec: \ncannot load such file -- numerizer from\n  /Users/greysteil/projects/chronic/chronic.gemspec:2:in'\nDoes it try to require a relative path? That's been removed in Ruby 1.9.\n```\nTo get Travis working that's going to be an issue, so I created a version file.\n. Specs are passing fine on Ruby 2.1.2 - you can see Travis on my fork at https://travis-ci.org/greysteil/chronic. As I said, someone who knows this gem better should take a look at that JRuby failure!\n. Sounds good to me - happy to rebase this once #262 is merged\n. I've rebased this off master now https://github.com/mojombo/chronic/pull/262 has been merged. That JRuby spec is still failing though...\n. Cheers @guilhermesimoes. Updated.\n. ",
    "djiang": "I'm using ruby 1.9.3p484\nHere's the debug output:\nruby\nChronic.debug = true\n=> true\nChronic.parse(\"9-3-1987\")\n-none\n+---------------------------------------------------\n| [9(repeater-time-32400?, scalar, scalar-day-9, scalar-month-9, scalar-year-2009) , -(separator-slashordash-dash) , 3tzminus1987(timezone) ]\n+---------------------------------------------------\n=> nil\n. Ah yes, that was it. I was on 0.9.1.\nThanks @davispuh !\n. I'm using ruby 1.9.3p484\nHere's the debug output:\nruby\nChronic.debug = true\n=> true\nChronic.parse(\"9-3-1987\")\n-none\n+---------------------------------------------------\n| [9(repeater-time-32400?, scalar, scalar-day-9, scalar-month-9, scalar-year-2009) , -(separator-slashordash-dash) , 3tzminus1987(timezone) ]\n+---------------------------------------------------\n=> nil\n. Ah yes, that was it. I was on 0.9.1.\nThanks @davispuh !\n. ",
    "MrAlexLau": "Looks like this is actually fixed with this commit, but I'm pretty sure the gem version needs to be updated (it's been on 0.10.2 for quite a while).\n. Looks like this is actually fixed with this commit, but I'm pretty sure the gem version needs to be updated (it's been on 0.10.2 for quite a while).\n. ",
    "ltrainpr": "When I comment out Chronic.time_class = \"UTC\" in the file config/initializers/chronic.rb it works.\nI'd like the datetime to be saved into the database as UTC time.\n. I figured out that I just needed to add .utc method to the end of the code before saving it to the database.  For example, Chronic.parse('today 9:15pm).utc\n. When I comment out Chronic.time_class = \"UTC\" in the file config/initializers/chronic.rb it works.\nI'd like the datetime to be saved into the database as UTC time.\n. I figured out that I just needed to add .utc method to the end of the code before saving it to the database.  For example, Chronic.parse('today 9:15pm).utc\n. ",
    "jvalente": "I stand corrected. Thank you @davispuh.\n. I stand corrected. Thank you @davispuh.\n. ",
    "m4ce": "That's funny. The machine is running on CET timezone, Europe/Zurich.\nirb(main):018:0> Chronic.parse('today 23:00', :now => Time.local(2014, 10, 26, 16, 00, 00))\n=> Sun Oct 26 23:00:00 +0100 2014\nirb(main):019:0> Chronic.parse('today 23:01', :now => Time.local(2014, 10, 26, 16, 00, 00))\n=> nil\nFunnily enough this happened only yesterday, between 23:01 and 23:59. \nAlso:\nzdump -v /usr/share/zoneinfo/Europe/Zurich | grep 2014\n/usr/share/zoneinfo/Europe/Zurich  Sun Oct 26 00:59:59 2014 UTC = Sun Oct 26 02:59:59 2014 CEST isdst=1\n/usr/share/zoneinfo/Europe/Zurich  Sun Oct 26 01:00:00 2014 UTC = Sun Oct 26 02:00:00 2014 CET isdst=0\nQuite a coincidence that this issue happened on the same day when we move away from DST.\n. That's funny. The machine is running on CET timezone, Europe/Zurich.\nirb(main):018:0> Chronic.parse('today 23:00', :now => Time.local(2014, 10, 26, 16, 00, 00))\n=> Sun Oct 26 23:00:00 +0100 2014\nirb(main):019:0> Chronic.parse('today 23:01', :now => Time.local(2014, 10, 26, 16, 00, 00))\n=> nil\nFunnily enough this happened only yesterday, between 23:01 and 23:59. \nAlso:\nzdump -v /usr/share/zoneinfo/Europe/Zurich | grep 2014\n/usr/share/zoneinfo/Europe/Zurich  Sun Oct 26 00:59:59 2014 UTC = Sun Oct 26 02:59:59 2014 CEST isdst=1\n/usr/share/zoneinfo/Europe/Zurich  Sun Oct 26 01:00:00 2014 UTC = Sun Oct 26 02:00:00 2014 CET isdst=0\nQuite a coincidence that this issue happened on the same day when we move away from DST.\n. ",
    "andywenk": "First of all - thanks for Chronic!\nThis does not work:\nChronic.parse('sunday this week').to_date\nWorkaround:\nChronic.parse('saturday this week').to_date.advance(days: 1)\nRuby 2.1.3\n. First of all - thanks for Chronic!\nThis does not work:\nChronic.parse('sunday this week').to_date\nWorkaround:\nChronic.parse('saturday this week').to_date.advance(days: 1)\nRuby 2.1.3\n. ",
    "McRip": "And a week later\nruby\nChronic.parse('sunday last week')\nreturns nil.\n. And a week later\nruby\nChronic.parse('sunday last week')\nreturns nil.\n. ",
    "dankohn": "OK, thanks.\n. OK, thanks.\n. ",
    "monicao": "Thanks for the heads up. I am working porting this library to javascript. \nHow stable is the rewrite branch? It seems a lot cleaner. Do you think I should just port that branch instead?\n. Yeah, I'm not planning to port his library over blindly, but I will definitely 'borrow' the regexes and overall design. You guys already solved the hard problems.\nI'd be happy to contribute some test for the different date/time combinations. Definitely a lot of edge cases there.\nOpal looks really cool, but I'll write this by hand because the library will probably be a little bit more maintainable if a human writes it. :)\n. Thanks for the heads up. I am working porting this library to javascript. \nHow stable is the rewrite branch? It seems a lot cleaner. Do you think I should just port that branch instead?\n. Yeah, I'm not planning to port his library over blindly, but I will definitely 'borrow' the regexes and overall design. You guys already solved the hard problems.\nI'd be happy to contribute some test for the different date/time combinations. Definitely a lot of edge cases there.\nOpal looks really cool, but I'll write this by hand because the library will probably be a little bit more maintainable if a human writes it. :)\n. ",
    "yb66": "Ok, I did search for similar issues and came up with nothing, but once I post this I see a very similar one on the same page! https://github.com/mojombo/chronic/issues/253\nClose this if it is in fact the same, and apologies for adding to the issue count (you can blame Github's search if you want, I will ;)\niain\n. Thanks for the help, and I'll get the Tickle lib to work properly with your rewrite branch as soon as I've finished with my rewrite! :-)\n. @SirCmpwn I'm currently the maintainer of tickle which depends on Chronic, it may do what you want.\n. Ok, I did search for similar issues and came up with nothing, but once I post this I see a very similar one on the same page! https://github.com/mojombo/chronic/issues/253\nClose this if it is in fact the same, and apologies for adding to the issue count (you can blame Github's search if you want, I will ;)\niain\n. Thanks for the help, and I'll get the Tickle lib to work properly with your rewrite branch as soon as I've finished with my rewrite! :-)\n. @SirCmpwn I'm currently the maintainer of tickle which depends on Chronic, it may do what you want.\n. ",
    "jamesbowles": "@davidchua Can we get some more information on the issue? \nI can't produce the issues with rails console, or pry using rails 4.1.8 and chronic 0.10.2, or \nWhat debugger and version of Ruby are you using?\n. @davidchua Can we get some more information on the issue? \nI can't produce the issues with rails console, or pry using rails 4.1.8 and chronic 0.10.2, or \nWhat debugger and version of Ruby are you using?\n. ",
    "davidchua": "Sorry was away for the weekend.\nI was using\nMRI v2.1.2 (with RVM)\nZeus 0.15.2\nbyebug 3.5.1\nIts really strange because I just tried it again today using the same environment, I can no longer replicate it anymore. I'm not sure what has changed.\nWhen I had the error previously, I had made it a point to test by changing the environments around and was still able to replicate.\nI guess I'll report back again if I do run into it again.\n. Sorry was away for the weekend.\nI was using\nMRI v2.1.2 (with RVM)\nZeus 0.15.2\nbyebug 3.5.1\nIts really strange because I just tried it again today using the same environment, I can no longer replicate it anymore. I'm not sure what has changed.\nWhen I had the error previously, I had made it a point to test by changing the environments around and was still able to replicate.\nI guess I'll report back again if I do run into it again.\n. ",
    "ddevault": "That's pretty slick, @yb66. I'll see if that will do the trick.\nFull disclosure: I'm using nChronic and I was hoping to convince them to port over the feature from upstream so there'd be less work for me :wink: \n. That's pretty slick, @yb66. I'll see if that will do the trick.\nFull disclosure: I'm using nChronic and I was hoping to convince them to port over the feature from upstream so there'd be less work for me :wink: \n. ",
    "xpepermint": "@davispuh Thanks for your answer. context: nil sound good. In my current project I need to execute an action e.g. every Monday. It would be great if context: nil will find the closest Monday - if today is Monday it will return today's Time if today is Tuesday it will return next week's Monday. What do you think?\n. Yes, a flag would do the trick.\n. @davispuh Thanks for your answer. context: nil sound good. In my current project I need to execute an action e.g. every Monday. It would be great if context: nil will find the closest Monday - if today is Monday it will return today's Time if today is Tuesday it will return next week's Monday. What do you think?\n. Yes, a flag would do the trick.\n. ",
    "aripatrick": "Just noting that I would be interested in this flag functionality as well!\n. Just noting that I would be interested in this flag functionality as well!\n. ",
    "JPThorne": "Any news on this? It has been over a year?. Any news on this? It has been over a year?. ",
    "pietdaniel": "At the moment I've constructed this monkey patch\n```\n   def self.get_parser\n     # need to monkey patch out the unneccessary parse definitions\n     definition_grabber = Chronic::Parser.new\n     new_definitions = {}\n     new_definitions[:date] = definition_grabber.definitions[:date]\n     new_definitions[:endian] = definition_grabber.definitions[:endian]\n     new_definitions[:anchor] = {}\n     new_definitions[:arrow] = {}\n     new_definitions[:narrow] = {}\n     new_definitions[:time] = {}\n Chronic::Parser.send(:define_method, \"definitions\") do |*options|\n   new_definitions\n end\n\n Chronic::Parser.new\n\nend\n```\nbut knowing that the feature is needed I will probably submit a PR. The approach I foresee implementing is allowing the definitions method to grab definitions from SpanDictionary based upon flags set within the options variable. Something like\nChronic.parse(\"tomorrow\", :definitions => [:date, :endian])\nwhich would provide results similar to the monkey patch\nEDIT: (did not mean to close this issue)\n. At the moment I've constructed this monkey patch\n```\n   def self.get_parser\n     # need to monkey patch out the unneccessary parse definitions\n     definition_grabber = Chronic::Parser.new\n     new_definitions = {}\n     new_definitions[:date] = definition_grabber.definitions[:date]\n     new_definitions[:endian] = definition_grabber.definitions[:endian]\n     new_definitions[:anchor] = {}\n     new_definitions[:arrow] = {}\n     new_definitions[:narrow] = {}\n     new_definitions[:time] = {}\n Chronic::Parser.send(:define_method, \"definitions\") do |*options|\n   new_definitions\n end\n\n Chronic::Parser.new\n\nend\n```\nbut knowing that the feature is needed I will probably submit a PR. The approach I foresee implementing is allowing the definitions method to grab definitions from SpanDictionary based upon flags set within the options variable. Something like\nChronic.parse(\"tomorrow\", :definitions => [:date, :endian])\nwhich would provide results similar to the monkey patch\nEDIT: (did not mean to close this issue)\n. ",
    "alex-ut": "chronic version 0.10.2\n. chronic version 0.10.2\n. ",
    "DannyBen": "Any chance of this bug being fixed soon?\nwhen adding \"at\" time, the day gets one extra day...\n```\n\n\nChronic.parse \"1 days ago\"\n=> 2016-01-20 13:50:40 +0000\nChronic.parse \"1 days ago at 00:01\"\n=> 2016-01-21 00:01:00 +0000\n```\n\n\nThis was very obvious in one case where I am taking a user input for \"how many days ago\" and \"from now\" and returning dates, like this:\n```\n\n\nChronic.parse \"0 days ago at 00:01\"\n=> 2016-01-22 00:01:00 +0000\nChronic.parse \"0 days from now at 23:59\"\n=> 2016-01-21 23:59:00 +0000\n```\n\n\nI expected the above to be the range of \"today\" of course.\n. Any chance of this bug being fixed soon?\nwhen adding \"at\" time, the day gets one extra day...\n```\n\n\nChronic.parse \"1 days ago\"\n=> 2016-01-20 13:50:40 +0000\nChronic.parse \"1 days ago at 00:01\"\n=> 2016-01-21 00:01:00 +0000\n```\n\n\nThis was very obvious in one case where I am taking a user input for \"how many days ago\" and \"from now\" and returning dates, like this:\n```\n\n\nChronic.parse \"0 days ago at 00:01\"\n=> 2016-01-22 00:01:00 +0000\nChronic.parse \"0 days from now at 23:59\"\n=> 2016-01-21 23:59:00 +0000\n```\n\n\nI expected the above to be the range of \"today\" of course.\n. ",
    "gayle": "Just came across this problem today too, in production.  Took awhile to track down!  Hopefully some day comes soon. :) \n. Just came across this problem today too, in production.  Took awhile to track down!  Hopefully some day comes soon. :) \n. ",
    "angelacode": "You are right!  I was using the tickle gem (any thought if chronic will incorporate similar functionality?  tickle allows recurring events) and it required a really old version of chronic and bundle installed that dependency.\n. You are right!  I was using the tickle gem (any thought if chronic will incorporate similar functionality?  tickle allows recurring events) and it required a really old version of chronic and bundle installed that dependency.\n. ",
    "lemboy": "Oh, sorry, I see - 5 and 05.\nBut what can I do for unambiguous result:\n5:20 parse to 05:20\n05:20 parse to 05:20\n17:20 parse to 17:20 \nand so on with or without any date...\nUse :ambiguous_time_range => :none or, may be :ambiguous_time_range => 24 ?\nAnd thank you for reply and for Chronic!\n. Thanks again! For patience too. :)\n. Oh, sorry, I see - 5 and 05.\nBut what can I do for unambiguous result:\n5:20 parse to 05:20\n05:20 parse to 05:20\n17:20 parse to 17:20 \nand so on with or without any date...\nUse :ambiguous_time_range => :none or, may be :ambiguous_time_range => 24 ?\nAnd thank you for reply and for Chronic!\n. Thanks again! For patience too. :)\n. ",
    "freerobby": "@davispuh Thanks. Yes, I didn't intend this as a feature request (not that I'd be opposed), just as a bug because it should return nil rather than throw an exception. Seems like that piece is taken care of on your dev branch. Feel free to close if you decide this isn't a feature worth building. Thanks!\n. @davispuh Thanks. Yes, I didn't intend this as a feature request (not that I'd be opposed), just as a bug because it should return nil rather than throw an exception. Seems like that piece is taken care of on your dev branch. Feel free to close if you decide this isn't a feature worth building. Thanks!\n. ",
    "nagius": "I found a workaround.\nBy adding few hours to the 'now' time so it's ahead of the timezone's offset, there is no more issue : \nnow = Time.parse(\"2015-08-25 00:00:00 +0000\")\nnow += 12.hours\nChronic.time_class = ActiveSupport::TimeZone.new(\"Pacific Time (US & Canada)\")\nChronic::parse(\"Midnight\", :context => :past, :now => now )\n. I found a workaround.\nBy adding few hours to the 'now' time so it's ahead of the timezone's offset, there is no more issue : \nnow = Time.parse(\"2015-08-25 00:00:00 +0000\")\nnow += 12.hours\nChronic.time_class = ActiveSupport::TimeZone.new(\"Pacific Time (US & Canada)\")\nChronic::parse(\"Midnight\", :context => :past, :now => now )\n. ",
    "mgaskill": "This no longer seems to happen.  Might have been an issue with github at that time, as they were dealing with redirects to the aliased project name.  \"injekt\" was renamed/aliased to \"leejarvis\" at some point.\nIf you want to use the curl command now, you'll have to follow redirects, using the -L flag, like so:\ncurl -L --write-out %{http_code} --silent --output /dev/null http://injekt.github.com/chronic\n\n. This no longer seems to happen.  Might have been an issue with github at that time, as they were dealing with redirects to the aliased project name.  \"injekt\" was renamed/aliased to \"leejarvis\" at some point.\nIf you want to use the curl command now, you'll have to follow redirects, using the -L flag, like so:\ncurl -L --write-out %{http_code} --silent --output /dev/null http://injekt.github.com/chronic\n\n. ",
    "WizardOfOgz": "@kylejginavan anything else? \n. @kylejginavan anything else? \n. ",
    "FabienChaynes": "Hi @leejarvis !\nWould it be possible for you to release a new version of the gem including the last changes?\nThe 0.10.2 is 30 commits behind master and it'll be great to benefit from the last fixes and features.\n. Hi @leejarvis !\nWould it be possible for you to release a new version of the gem including the last changes?\nThe 0.10.2 is 30 commits behind master and it'll be great to benefit from the last fixes and features.\n. ",
    "pmackay": "@davispuh may I ask, what state would you say your rewrite work is currently in? Thanks!. @davispuh may I ask, what state would you say your rewrite work is currently in? Thanks!. ",
    "andrewhavens": "Sounds like a timezone issue. When setting now you didn't specify a time zone, so I think it defaults to UTC. I bet it returned a date relative to your current time zone.\n. @nikkypx No, the problem is that I'm asking Chronic to determine this by using the context: :future option. Chronic does not seem to be respecting this option. I just tried this again today using Chronic 0.10.2.\n. Sounds like a timezone issue. When setting now you didn't specify a time zone, so I think it defaults to UTC. I bet it returned a date relative to your current time zone.\n. @nikkypx No, the problem is that I'm asking Chronic to determine this by using the context: :future option. Chronic does not seem to be respecting this option. I just tried this again today using Chronic 0.10.2.\n. ",
    "nikkypx": "Does \"today at 8:00\" or \"tomorrow at 8:00\" solve your problem?\n. Does \"today at 8:00\" or \"tomorrow at 8:00\" solve your problem?\n. ",
    "kapildewade": "@dbwest pls check this\nhttps://github.com/jduff/numerizer/pull/5\n. @dbwest pls check this\nhttps://github.com/jduff/numerizer/pull/5\n. ",
    "dbwest": "looks like that was not merged...\n. looks like that was not merged...\n. ",
    "pawelkrol": "Thanks a lot for your confirmation. I am looking forward to a new release version containing this fix.\n. Thanks a lot for your confirmation. I am looking forward to a new release version containing this fix.\n. ",
    "SagareGanesh": "@codered This issue is not only for Feb, I also have the same issue for August.\n2.1.0 :021 > Chronic.parse(\"today\")\n=> 2016-08-23 21:00:00 +0530\n2.1.0 :023 > Date.today.end_of_month\n=> Wed, 31 Aug 2016\n2.1.0 :022 > Chronic.parse(\"month\")\n=> 2016-08-28 00:00:00 +0530\nAlso year function gives me an unexpected result.\n2.1.0 :024 > Chronic.parse(\"year\")\n=> 2016-10-28 00:00:00 +0530\n. Hi @keithepley I am using a gem version 0.10.2 version of chronic, and Chronic.parse('yesterday at 9am') works correctly for me. see result.\nChronic.parse('yesterday at 9am')\n=> 2016-08-22 09:00:00 +0530\nPlease provide your chronic gem version, so it ll help to reproduce issue and find out the solution.\nthanks\n. @fearnowrath I think we don't have option like xx hours and xx minutes ago . \nInstead of this you can use xx hours before or xx minutes before.\nIn your case you can use 583 minutes before. (9 hours and 43 minutes = 583 minutes)\n. @codered This issue is not only for Feb, I also have the same issue for August.\n2.1.0 :021 > Chronic.parse(\"today\")\n=> 2016-08-23 21:00:00 +0530\n2.1.0 :023 > Date.today.end_of_month\n=> Wed, 31 Aug 2016\n2.1.0 :022 > Chronic.parse(\"month\")\n=> 2016-08-28 00:00:00 +0530\nAlso year function gives me an unexpected result.\n2.1.0 :024 > Chronic.parse(\"year\")\n=> 2016-10-28 00:00:00 +0530\n. Hi @keithepley I am using a gem version 0.10.2 version of chronic, and Chronic.parse('yesterday at 9am') works correctly for me. see result.\nChronic.parse('yesterday at 9am')\n=> 2016-08-22 09:00:00 +0530\nPlease provide your chronic gem version, so it ll help to reproduce issue and find out the solution.\nthanks\n. @fearnowrath I think we don't have option like xx hours and xx minutes ago . \nInstead of this you can use xx hours before or xx minutes before.\nIn your case you can use 583 minutes before. (9 hours and 43 minutes = 583 minutes)\n. ",
    "frank184": "I've noticed this in a project today.\nWe're Sept 30, 2016 and doing Chronic.parse('this month') returns Oct 1st, 2016.\nI would expect 'this month' to be the month that we're currently in...\n. I've noticed this in a project today.\nWe're Sept 30, 2016 and doing Chronic.parse('this month') returns Oct 1st, 2016.\nI would expect 'this month' to be the month that we're currently in...\n. ",
    "jclusso": "I made this script to show how I tested it. Also we parse like this. I'm not sure how it would be DST related and only affect 1 hour of 1 day per year. Also why would it return nil. DST shouldn't be causing it to return nil. The minute has no difference on it when I manually tested it. \nruby\nChronic.parse('3/13/2016 12:35 AM')\n``` ruby\nyear = 2016\nhours = []\n12.times.each_with_index do |m|\n  m = m + 1\n  Time.days_in_month(m, year).times.each_with_index do |d|\n    d = d + 1\n    24.times.each_with_index do |h|\n      h = h + 1\n      am_or_pm = h > 12 ? 'PM' : 'AM'\n      h = h - 12 if h > 12\n      hours << Chronic.parse(\"#{m}/#{d}/#{year} #{h} #{am_or_pm}\")\n    end\n  end\nend\nhours.select { |h| h.nil? }.count\n```\n. Just wondering, but how come it only affects 3/13/2016 and no other day?\n. I made this script to show how I tested it. Also we parse like this. I'm not sure how it would be DST related and only affect 1 hour of 1 day per year. Also why would it return nil. DST shouldn't be causing it to return nil. The minute has no difference on it when I manually tested it. \nruby\nChronic.parse('3/13/2016 12:35 AM')\n``` ruby\nyear = 2016\nhours = []\n12.times.each_with_index do |m|\n  m = m + 1\n  Time.days_in_month(m, year).times.each_with_index do |d|\n    d = d + 1\n    24.times.each_with_index do |h|\n      h = h + 1\n      am_or_pm = h > 12 ? 'PM' : 'AM'\n      h = h - 12 if h > 12\n      hours << Chronic.parse(\"#{m}/#{d}/#{year} #{h} #{am_or_pm}\")\n    end\n  end\nend\nhours.select { |h| h.nil? }.count\n```\n. Just wondering, but how come it only affects 3/13/2016 and no other day?\n. ",
    "TimHolahan": "@davispuh Thanks for the responses, and for working on chronic.\nYour rewrite branch looks like it solves the problem. I'd like to use it, but it seems to have a more basic issue with time-parsing. In the examples below, all created today (3/14/16), unless I explicitly indicate no minutes and no seconds, your gem adds 30 to the largest unspecified unit:\n2.2.2 :002 > Chronic.parse('yesterday')\n => 2016-03-13 12:30:00 -0400\n2.2.2 :003 > Chronic.parse('yesterday at 1 am')\n => 2016-03-13 01:30:00 -0500\n2.2.2 :004 > Chronic.parse('yesterday at 3 am')\n => 2016-03-13 03:30:00 -0400\n2.2.2 :005 > Chronic.parse('yesterday at 3:00 am')\n => 2016-03-13 03:00:30 -0400\n2.2.2 :006 > Chronic.parse('yesterday at 3:00:00 am')\n => 2016-03-13 03:00:00 -0400\n2.2.2 :007 > Chronic.parse('yesterday at 9 am')\n => 2016-03-13 09:30:00 -0400\n2.2.2 :008 > Chronic.parse('today at 9 am')\n => 2016-03-14 09:30:00 -0400\n2.2.2 :009 > Chronic.parse('today at 9:00 am')\n => 2016-03-14 09:00:30 -0400\n2.2.2 :010 > Chronic.parse('today at 9:00:00 am')\n => 2016-03-14 09:00:00 -0400\n2.2.2 :011 > Chronic.parse('tomorrow at 9 am')\n => 2016-03-15 09:30:00 -0400\nIs this something you're aware of?\n. Hi, @davispuh\nI very much appreciate the detailed response. I had noticed some of the problems you mention about the inconsistent guessing, and it would be nice to have those fixed.\nStill, though consistency is a good thing, it seems \"off\" from a UX point of view to have the default response to Chronic.parse(\"today at 9 am\") return 9:30 am. Nevertheless, it's your project, so it's your call.\nMy guess is that it's probably a better idea to use your branch than the standard gem at this point, but with your cautionary words about the tests and date formats, and a little discomfort on my part about pointing a production build at a Github branch, I guess I'll stay with the standard gem for the moment.\nThanks for your work on this. I'm following your fork, and if you get your branch to a point at which you feel it's production-ready, I'll be eager to use it.\n. @davispuh Thanks for the responses, and for working on chronic.\nYour rewrite branch looks like it solves the problem. I'd like to use it, but it seems to have a more basic issue with time-parsing. In the examples below, all created today (3/14/16), unless I explicitly indicate no minutes and no seconds, your gem adds 30 to the largest unspecified unit:\n2.2.2 :002 > Chronic.parse('yesterday')\n => 2016-03-13 12:30:00 -0400\n2.2.2 :003 > Chronic.parse('yesterday at 1 am')\n => 2016-03-13 01:30:00 -0500\n2.2.2 :004 > Chronic.parse('yesterday at 3 am')\n => 2016-03-13 03:30:00 -0400\n2.2.2 :005 > Chronic.parse('yesterday at 3:00 am')\n => 2016-03-13 03:00:30 -0400\n2.2.2 :006 > Chronic.parse('yesterday at 3:00:00 am')\n => 2016-03-13 03:00:00 -0400\n2.2.2 :007 > Chronic.parse('yesterday at 9 am')\n => 2016-03-13 09:30:00 -0400\n2.2.2 :008 > Chronic.parse('today at 9 am')\n => 2016-03-14 09:30:00 -0400\n2.2.2 :009 > Chronic.parse('today at 9:00 am')\n => 2016-03-14 09:00:30 -0400\n2.2.2 :010 > Chronic.parse('today at 9:00:00 am')\n => 2016-03-14 09:00:00 -0400\n2.2.2 :011 > Chronic.parse('tomorrow at 9 am')\n => 2016-03-15 09:30:00 -0400\nIs this something you're aware of?\n. Hi, @davispuh\nI very much appreciate the detailed response. I had noticed some of the problems you mention about the inconsistent guessing, and it would be nice to have those fixed.\nStill, though consistency is a good thing, it seems \"off\" from a UX point of view to have the default response to Chronic.parse(\"today at 9 am\") return 9:30 am. Nevertheless, it's your project, so it's your call.\nMy guess is that it's probably a better idea to use your branch than the standard gem at this point, but with your cautionary words about the tests and date formats, and a little discomfort on my part about pointing a production build at a Github branch, I guess I'll stay with the standard gem for the moment.\nThanks for your work on this. I'm following your fork, and if you get your branch to a point at which you feel it's production-ready, I'll be eager to use it.\n. ",
    "sponomarev": "The same for CET timezone at Mar, 29\n. The same for CET timezone at Mar, 29\n. ",
    "joevandyk": "Today at 9 am pacific time, a few hours after daylight savings time started:\n[1] pry(main)> Chronic.parse(\"tomorrow at 5am\")\n=> nil\nI'm using 0.10.2. Today at 9 am pacific time, a few hours after daylight savings time started:\n[1] pry(main)> Chronic.parse(\"tomorrow at 5am\")\n=> nil\nI'm using 0.10.2. ",
    "Mnuzz": "Why not fork it?\n. Why not fork it?\n. ",
    "alexagranov-theorchard": "\ud83d\udc4d Someone should really bump up this rewrite branch.  You know what else this rewrite fixes:\nChronic.parse('5pm tomorrow')\nI was just about to log an issue on the main repo that while 'tomorrow 5pm' works (and has tests) the converse '5pm tomorrow' fails.... \ud83d\udc4d Someone should really bump up this rewrite branch.  You know what else this rewrite fixes:\nChronic.parse('5pm tomorrow')\nI was just about to log an issue on the main repo that while 'tomorrow 5pm' works (and has tests) the converse '5pm tomorrow' fails.... ",
    "fearnowrath": "Thanks but why does it throw an error rather than just returning nil? Is it possible to at least make that return nil? Also any plans on adding support for this kind of format in the future?\n. Thanks but why does it throw an error rather than just returning nil? Is it possible to at least make that return nil? Also any plans on adding support for this kind of format in the future?\n. ",
    "jmondo": "I added this test:\nruby\ndef test_one_thing_memory\n  report = MemoryProfiler.report do\n    time = Chronic.parse(\"2012-08-02T13:00:00\")\n    assert_equal Time.local(2012, 8, 2, 13), time\n  end\n  report.pretty_print(to_file: 'memory.log')\nend\n. memory-before.txt\nmemory-after.txt\nhandler.rb 72,736 -> 5,120\nchronic/lib 167,181 -> 94,445\n. For benchmarking I ran the test suite 5 times on master and this branch\n```\nmaster\nFinished in 2.317107s, 71.6411 runs/s, 308.1429 assertions/s.\nFinished in 2.267655s, 73.2034 runs/s, 314.8626 assertions/s.\nFinished in 2.133667s, 77.8003 runs/s, 334.6351 assertions/s.\nFinished in 2.184228s, 75.9994 runs/s, 326.8890 assertions/s.\nFinished in 2.094341s, 79.2612 runs/s, 340.9187 assertions/s.\n(average 2.1993s)\ncamelcase\nFinished in 2.096705s, 79.1719 runs/s, 340.5344 assertions/s.\nFinished in 1.995551s, 83.1850 runs/s, 357.7959 assertions/s.\nFinished in 2.004112s, 82.8297 runs/s, 356.2675 assertions/s.\nFinished in 2.016496s, 82.3210 runs/s, 354.0796 assertions/s.\nFinished in 2.024613s, 81.9910 runs/s, 352.6600 assertions/s.\n(average 2.0274s)\n(-7.81%)\n```\nfaster \ud83d\udc4d \n. let me know if this is too ugly. i have some other nicer looking but slightly less performant solutions. (still an improvement, though)\n. enabled.txt\ndisabled.txt\ntotal bytes down from 545,544 to 96,282. That's only 17.6% of the original memory footprint - down by 82.4%.\n. @davispuh what do you think about this one?\n. I added this test:\nruby\ndef test_one_thing_memory\n  report = MemoryProfiler.report do\n    time = Chronic.parse(\"2012-08-02T13:00:00\")\n    assert_equal Time.local(2012, 8, 2, 13), time\n  end\n  report.pretty_print(to_file: 'memory.log')\nend\n. memory-before.txt\nmemory-after.txt\nhandler.rb 72,736 -> 5,120\nchronic/lib 167,181 -> 94,445\n. For benchmarking I ran the test suite 5 times on master and this branch\n```\nmaster\nFinished in 2.317107s, 71.6411 runs/s, 308.1429 assertions/s.\nFinished in 2.267655s, 73.2034 runs/s, 314.8626 assertions/s.\nFinished in 2.133667s, 77.8003 runs/s, 334.6351 assertions/s.\nFinished in 2.184228s, 75.9994 runs/s, 326.8890 assertions/s.\nFinished in 2.094341s, 79.2612 runs/s, 340.9187 assertions/s.\n(average 2.1993s)\ncamelcase\nFinished in 2.096705s, 79.1719 runs/s, 340.5344 assertions/s.\nFinished in 1.995551s, 83.1850 runs/s, 357.7959 assertions/s.\nFinished in 2.004112s, 82.8297 runs/s, 356.2675 assertions/s.\nFinished in 2.016496s, 82.3210 runs/s, 354.0796 assertions/s.\nFinished in 2.024613s, 81.9910 runs/s, 352.6600 assertions/s.\n(average 2.0274s)\n(-7.81%)\n```\nfaster \ud83d\udc4d \n. let me know if this is too ugly. i have some other nicer looking but slightly less performant solutions. (still an improvement, though)\n. enabled.txt\ndisabled.txt\ntotal bytes down from 545,544 to 96,282. That's only 17.6% of the original memory footprint - down by 82.4%.\n. @davispuh what do you think about this one?\n. ",
    "erunyon": "@davispuh Any update on when the rewrite branch will be released? We're running into the DST issue as well.. @davispuh Any update on when the rewrite branch will be released? We're running into the DST issue as well.. ",
    "macobo": "@davispuh Looking forward to the new release, how's it going along?. @davispuh Looking forward to the new release, how's it going along?. ",
    "bramski": "Open forever.  Along with a lot of other pull requests.  What's the deal?. This much I know. But Chronic shouldn't crash my app.  It's supposed to return nil if it can't parse it.. Open forever.  Along with a lot of other pull requests.  What's the deal?. This much I know. But Chronic shouldn't crash my app.  It's supposed to return nil if it can't parse it.. ",
    "TheKidCoder": "While I see the merit in adding this feature - I would just like to cast my vote against it as any reliance on a cext would limit Chronic's portability. We use Chronic on jruby, for example.. While I see the merit in adding this feature - I would just like to cast my vote against it as any reliance on a cext would limit Chronic's portability. We use Chronic on jruby, for example.. ",
    "JesseBuesking": "@TheKidCoder Ideally this wouldn't replace anything within Chronic but would be offered as an alternative implementation of the Numerizer logic. For example, we could have a gem that simply monkey patches Chronic allowing anyone who is using MRI to simply include the gem to get the benefits.\nI really posted this to raise awareness of OmNomNum and to see what the community thinks is the right approach to using it within Chronic.. @TheKidCoder Ideally this wouldn't replace anything within Chronic but would be offered as an alternative implementation of the Numerizer logic. For example, we could have a gem that simply monkey patches Chronic allowing anyone who is using MRI to simply include the gem to get the benefits.\nI really posted this to raise awareness of OmNomNum and to see what the community thinks is the right approach to using it within Chronic.. ",
    "JacobEvelyn": "Oh awesome, thanks for the info (and all the hard work)! Is your rewrite usable now or are there things that will bite me if I try using that code instead of the master or gem version?. Or, put another way, if I release a gem (so I can use this in my own gem) containing the latest version of your Chronic rewrite branch (as I did yesterday with Chronic master, thinking that might fix the issue), would that be bad and/or would you be unhappy with that?\n(Of course, I'd be much happier if you just released your version as a gem yourself but I don't want to rush you if you don't think it's ready.). Great, thanks! I pushed it to RubyGems and called it chronic-davispuh.. Oh awesome, thanks for the info (and all the hard work)! Is your rewrite usable now or are there things that will bite me if I try using that code instead of the master or gem version?. Or, put another way, if I release a gem (so I can use this in my own gem) containing the latest version of your Chronic rewrite branch (as I did yesterday with Chronic master, thinking that might fix the issue), would that be bad and/or would you be unhappy with that?\n(Of course, I'd be much happier if you just released your version as a gem yourself but I don't want to rush you if you don't think it's ready.). Great, thanks! I pushed it to RubyGems and called it chronic-davispuh.. ",
    "sphanley": "Thanks for the info! Can you help me understand the roadmap for the rewrite? It seems like it's been in the works for a very long time - is there a release planned, or is it still an ongoing effort currently? Are you the primary maintainer of the Chronic project at this point? \nThe reason that I ask is that there's a C# port of Chronic that hasn't been updated in quite some time, and I'm potentially interested in forking and updating it to include the improvements from your rewrite, but I wanted to understand how far along your project is to determine whether it makes sense to undertake that porting work at present.. Sounds good - I'm going to work on familiarizing myself with the code a bit, and see what seems like the best option in terms of advancing a C# version. Thanks for the background!\nI agree that a direct port is probably not the most maintainable course of action - the port only came to my attention because I discovered that it's used (via a NuGet package) in Microsoft's Bot Builder SDK, which is a pretty major project - it's mostly used in their sample projects, but it's used in at least one place in the framework itself. It definitely seems odd to me that they've got a dependency on a seemingly discontinued cross-language port. I'd love to see a more robust C# option that can be maintained going forward!. Thanks for the info! Can you help me understand the roadmap for the rewrite? It seems like it's been in the works for a very long time - is there a release planned, or is it still an ongoing effort currently? Are you the primary maintainer of the Chronic project at this point? \nThe reason that I ask is that there's a C# port of Chronic that hasn't been updated in quite some time, and I'm potentially interested in forking and updating it to include the improvements from your rewrite, but I wanted to understand how far along your project is to determine whether it makes sense to undertake that porting work at present.. Sounds good - I'm going to work on familiarizing myself with the code a bit, and see what seems like the best option in terms of advancing a C# version. Thanks for the background!\nI agree that a direct port is probably not the most maintainable course of action - the port only came to my attention because I discovered that it's used (via a NuGet package) in Microsoft's Bot Builder SDK, which is a pretty major project - it's mostly used in their sample projects, but it's used in at least one place in the framework itself. It definitely seems odd to me that they've got a dependency on a seemingly discontinued cross-language port. I'd love to see a more robust C# option that can be maintained going forward!. "
}