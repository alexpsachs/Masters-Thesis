{
    "tgriesser": "Fixed with addition of forge.\n. @amitava82 - I agree that a wiki would be useful, I'm working on a sample app that I hope to get out there sometime soon. I had actually taken a good look at the landscape of ORM's in node, which is what prompted me to write this -  but in terms of major differentiating factors, the main ones would be:\n- Transaction support\n- Built on top of a query builder (http://knexjs.org), rather than mixing the two together into a single package\n- Eager/Nested eager relation loading (avoiding the N+1 query problem)\n- Relations are defined dynamically as methods on the model, which allows for really expressive and dynamic relations (e.g. with different constraints)\n- No forced validation scheme / typecasting (though hooks and events to easily provide these where necessary)\nIn terms of project structure, that would depend a bit on your app. I have been grouping models/collections into files as they seem to make sense related to the application, though I guess some of that might be addressed by a sample application.\n. Good point, I think I had just pulled the travis-ci connection settings, but I agree that promoting root/empty password might not be the best. Feel free to open a PR or I can take a look at it in a bit.\n. Addressed in #11\n. Thanks @delasteve!\n. Looks like a good compromise for #9, thanks!\n. @dgsan - Thanks, definitely worth pointing out!\n. Hi @amitava82\n1) This would be handled when you create your schema with knex - they are not defined on the models.\njs\nKnex.Schema.createTable(function(t) {\n  t.string('identifier').primary();\n  t.string('title').nullable();\n  t.string('someUnique').unique();\n}).then(function() {\n  console.log('Table Created!');\n});\n2) You'd do it just like you would otherwise in node, by exporting/requiring objects in different files as appropriate. The library has no opinions on the structure of your project.\n3) Right now, you'd need to define and call the schema changes and data inserts you want to make when starting the server. I'm looking into putting something together like rails' migrations, but that's not quite there yet. In my opinion these parts shouldn't be mixed in with the model layer.\n. @rstacruz - agreed! I've been planning on putting one together for it, I think I'm going to split it out as it's own CLI and standalone module outside of the bookshelf lib. Hopefully I'll get to it in the next few weeks, If you have any ideas for it, let me know.\n. I agree with all of those points - it should be based in Knex but be able to be aliased as a bin in both knex and Bookshelf. I'll definitely make sure there's support for programmatic access.\nThis is sort of an idea for what the module's api might look like:\nI'll also look to provide sufficient flexibility for specifying different multiple independent migrations for the same db, easily passing different connections in the same project, etc.\n. All right... took me long enough, but there's now a (very) bare bones implementation of migrations in knex 0.5.0, which is now the required version for the latest 0.6.0... still needs better docs, options, and such, but it's a start - @rstacruz let me know what you think, I'm now bumping getting a nice AR interface to the top of the priority list... see #27\n. Hey @jkeli - thanks for the issue! I believe this should be fixed and I just pushed a 0.1.1, so feel free to take a look at that and see if it's fixed...\n. Hey @willy134 - thanks for pointing out the issue with the incorrect docs on the sqlite db config... should be fixed on the docs.\nThe way to use not just the WHERE but any clause on the model or collection is to use the query method to tap into the query builder chain.\nFor example, on a collection you could do:\njs\nnew Posts()\n   .query('where', {submitDate: '2013-05-26'})\n   .fetch({\n       withRelated: ['author.name','comments.author']\n   })\n   .then(...)\nLet me know if I missed anything with what you're looking to do, or if this could be better documented.\n. Nice catch, thanks Jacob\n. Hi @projectfledge - since the database calls are asynchronous, you'll need to use the then method - which is known as a \"promise\"... resolving with the \"books\" collection (I believe you meant to put Bookshelf.Collection.extend on the Books line. It will look like this:\n``` js\nvar Book = Bookshelf.Model.extend({\n    tableName: 'books'\n});\nvar Books = Bookshelf.Collection.extend({\n    model: Book\n});\napp.get('/books', function(req, res) {\n   new Books().fetch().then(function(theBooks) {\n     res.render('books', {books: theBooks});\n   });\n});\n```\nlet me know if that clears that up - you can read a bit more about promises here.\n. I see you altered the original question - are you sure it's not because you have Bookshelf.Model.extend instead of Bookshelf.Collection.extend on that fifth line?\n. @projectfledge - Also, that passes the raw collection to the view (like you'd have in Backbone) - if you just want the json for the view, you'll need to use collection.toJSON()\n. Ah, thanks for pointing that out - I'll fix it right now.\n. Hi @chymz - looks like it was a bug and wasn't an issue with anything on your end... just fixed the bug and pushed a new release 0.1.6... take a look and see if that takes care of it. Thanks!\n. Thanks for that @chymz - I fixed it slightly differently, but I also made the fulfilled promise value of the attach/detach to be the belongsToMany collection object currently being used. Should be fixed in 0.1.7.\n. I had a longer response for this one but then I accidentally refreshed the browser and lost it... \nBasically the gist was that I didn't think it made as much sense to support here because unlike in Knex where you're building up a bunch of pieces in the query chain and then the then or exec signifies that everything chained before it should be built into a query, in Bookshelf, the save, fetch, load, and destroy all have to run at the time they're called. \nIt would be a little more work internally to support both interfaces - since there are a lot of promises building up internally (vs. Knex where there is one, maybe two at a time in the case of schema building) there'd be a bit more needed to make sure it's taken care of correctly everywhere, and I thought it might be confusing to support both.\nIt was also sort of a preference to keep things consistent with how Backbone.js jqXHR return values provide promises on the frontend, so you can potentially do model.save().then(function() {... on both sides of the wire and have it just work.\nI'm curious if you had specific reasons for preferring the node style callbacks over promises.\n. That makes some sense, I'll take a closer look. So which would be preferable, having an optional callback as the final parameter, or an explicit exec method similar to Knex... I think I'd prefer the latter.\n. So... I'd ideally like to have save, fetch, destroy, and load actually perform the database action when they're called, but adding an exec method sort of implies that you aren't actually executing the command until you call it... which wouldn't be technically correct. \nSo I wanted to see what you thought if there was a small plugin that shimmed in this functionality:\n``` js\nvar Bookshelf = require('bookshelf');\n// Used to optionally add exec support for those who prefer node-style callbacks.\nvar wrapExec = function(target, method) {\n  var targetMethod = target[method];\n  target[method] = function() {\n    var args = arguments;\n    return {\n      then: function(onFulfilled, onRejected) {\n        return targetMethod.apply(this, args).then(onFulfilled, onRejected);\n      },\n      exec: function(callback) {\n        return targetMethod.apply(this, args).then(function(resp) {\n          callback(null, resp);\n        }, function(err) {\n          callback(err, null);\n        }).then(null, function(err) {\n          setTimeout(function() { throw err; }, 0);\n        });\n      }\n    };\n  };\n};\n_.each(['load', 'fetch', 'save', 'destroy'], function(method) {\n  wrapExec(Bookshelf.Model.prototype, method);\n});\n_.each(['load', 'fetch'], function(method) {\n  wrapExec(Bookshelf.Collection.prototype, method);\n});\nmodule.exports = Bookshelf;\n```\nSo in your application you'd just need to require it the first time you used it, and then you'd be good to have an exec call on all appropriate methods:\n``` js\nvar Bookshelf = require('bookshelf');\nrequire('bookshelf-exec');\nnew Bookshelf.Model({id: 1}, {tableName: 'items'}).fetch().exec(function(err, resp) {\n  ...\n});\n```\n. Honestly, it might be easier for you to just use promises and not worry about ICS's defer in this case:\n``` coffee\nrender = (res) -> (obj) -> res.json(object)\napp.get '/user', (req, res, next) ->\n  User.find(parseInt(req.params.id)).then(render(res), next)\n```\n. Hmm so... I think if you do this, it should take care of it:\njs\n_.each(['load', 'fetch', 'save', 'destroy', 'findOrCreate'], function(method) {\n  wrapExec(Bookshelf.Model.prototype, method);\n});\nBasically calling the wrapExec function I provided above on whatever custom methods you add...\n. You can do:\njs\nBookshelf = require('bookshelf');\nrequire('bookshelf/plugins/exec');\nand then Bookshelf will have the wrapExec method attached to it, so you can do \njs\nBookshelf.wrapExec(YourModel.prototype, 'findOrCreate');\n. Yep, that's what it should be... thanks\n. Yep, that's what it should be... thanks\n. Yeah @johanneslumpe - that looks like a good approach!\n. Going to close this for now, will reopen down the line if/when static finder methods are something that make sense to add (probably after the core api is nailed down a bit further).\n. So I think I intended to be able to pass a model as a joinTableName but hadn't quite gotten there yet... If you want to try to work out an implementation/tests for it as a PR, that'd be great...I think the issue may have been with the need for a composite key based on the foreignKey & otherKey but also potentially allowing an idAttribute id... I'm not sure, I'll take out that comment for now so it's not confusing.\nRight now you can do this:\njs\ncollection.belongsToMany(db.Models.Link).attach(link.attributes)\nAnd the object that is set as the attributes will be saved with additional columns, but I realize that doesn't help with wanting a model/methods/timestamps on the join table... I'll think a bit more about this one.\n. Oh... I know what I was going to do here - the equivalent of ActiveRecord's hasMany :through - where you could do\njs\nlinks: function() {\n   return this.hasMany(Links, CollectionsLinks);\n}\nAnd then you'd have a CollectionsLinks model to work with for the joining table... Didn't quite work through the specifics, including how you'd access the join model or how the the fetch/eager loading on that would work... Does that make sense though?\n. So this is probably what you want:\n``` coffee\nclass MyModel extends Bookshelf.Model\n  items: (id) ->\n    @belongsToMany(Item)\nnew MyModel(id: 1).items().query('where', 'id', id).fetch().then (c) ->\n  c.at(0)\n```\nThe reason I didn't want to put finder methods in is because there's a million permutations of them, and once you start adding direct support for them the API can quickly become a bit of a mess.\nBy using query the way described above you can add them wherever you need... and by not doing query() but instead query('method', args*) you stay on the context of the current model/collection you're accessing rather than dropping down into the Knex builder.\nThough I agree some way to fetch/return a single model from a collection could a good addition in this case (hadn't considered relations), I'll take a look into supporting it...\nAnd yeah, a BaseModel is exactly what I'm thinking would be a good way to go... so you can build out the API you'd find most intuitive... it's a little more verbose the first time but it makes the library easier to wrap your head around.\n\nAlso, a get raw json as the result when what I would like is a Collection of Models.\n\nSorry... I'm not sure I follow... you do or do not want that?\n. Yeah, query('where', ... will do it.\n. > Would be nice if you could pass in a hash.\nInteresting, so like query({where: {id: 1}, orWhere: {id: 2})\n. Yeah... that's the idea, unless you call query() with no arguments which returns the underlying Knex builder, which I think I'll keep in there.\nTake a look at the last commit for the object support.\n. So I think that I'm going to revisit the idea of fetching a single object from a collection at some point down the road... for now I'm going to have the object support for the query chain be the solution for this for now.\n. Thanks - should be there now.\n. Thanks for pointing this out @ericclemmons - this should be fixed in the latest release, please let me know if you see any other issues.\n. @kubino yes, in that case you'd probably have something that looks like this (table names might be different)...\n``` js\nvar Post = Bookshelf.Model.extend({\n   tableName: 'posts'\n});\nvar User = Bookshelf.Model.extend({\n   tableName: 'users',\n});\nvar Comment = Bookshelf.Model.extend({\n  tableName: 'comments'\n  user: function() {\n     return this.belongsTo(User);\n  },\n  post: function() {\n     return this.belongsTo(Post);\n  }\n});\nvar Comments = Bookshelf.Collection.extend({\n   model: Comment\n})\nnew Comments().fetch({withRelated: ['user', 'post']}).then(function(postComments) {\n   // postComments should now be a collection where each is loaded with related user & post\n   console.log(JSON.stringify(postComments));\n});\n```\nThat should be the most performant way to do it, as it should only do 3 queries (one for the comments, and one each for the user & posts). Let me know if that's what you're looking for or if it doesn't work at all.\n. Yeah, there isn't a save method on a Collection, only on a Model. You'll need to save each of the models individually.\njs\nWhen.all(Collection.forge([...]).invoke('save')).then(...\n. It looks like sequence takes an array of tasks functions to be called, whereas in the case I showed above, the array is already populated with pending promises... I think for sequence to work, you'd need to do this:\njs\nWhen.sequence(collection.map(function(model) {\n   return _.bind(model.save, model)\n})).then(...\nAny reason you'd need to use When.sequence instead of When.all?\n. Hey @calmdev - So I'm actually writing a separate library for validation... https://github.com/tgriesser/checkit\nI'll advertise/give examples for it a bit more once I polish things up - the docs and test suite are still a little bare, but in my own projects it's been working great so-far... I've been using it alongside Bookshelf and it works well (especially with the use of promises)... Feel free to check it out and see how you like it (and open any tickets/pull requests if things aren't working as you'd expect).\nMy reasoning here is that (in my experience) you'll very often want to validate models differently based on access control, special cases, etc... so I figured it'd be better to separate this out and provide hooks for than to try getting validators all tangled up with the relation logic.\n. I actually may provide a bare bones integration for it once it's done. But here's a very brief example use in a model:\n``` js\ninitialize: function() {\n   this.on('saving', this.validate, this);\n},\nvalidations: {\n  user: {\n      email: ['required', 'validEmail'],\n      password: ['required']\n  },\n  admin: {\n      email: ['required', 'validEmail'],\n  }\n}\nvalidate: function(model, attrs, options) {\n   options.role || (options.role = 'user') {\n     return CheckIt(this.toJSON()).run(this.validations[options.role]);\n   }\n}\n```\nThen saving...\njs\nmodel.save({email: 'test@example.com'}, {role: req.user.acl});\n. Yeah, that looks good - the only thing that might be an issue there is if you get an error that isn't a CheckIt error but is for some reason another error (database or whatever)... then you likely won't have a toJSON method... so what I've been doing so far is a  instanceof check to determine whether to call toJSON on the error object.\nHere's an example with express:\n``` js\nvar errorHandler = function(res) {\n   return function(error) {\n      if (error instanceof CheckIt.Error) {\n        res.json(400, {error: error.toJSON()});\n      } else {\n        res.json(400, {error: error.message});\n      }\n   };\n};\n// Elsewhere ...\n.save().then(function(user) {\n    console.log(user.toJSON());\n}).catch(errorHandler(res));\n``\n. @peteotto can you show the code you're running into that with? You shouldn't get any possibly unhandled errors if all goes well.\n. I've updated my comment above... It's generally an anti-pattern to do.then(onSuccess, onError)because if an error is thrown in theonSuccess` it's not handled.\nYour code example would be better written as:\njs\ncreate = {\n  handler: function(request, reply) {\n    return new Address().save({\n      name: request.payload.name,\n      address_line1: request.payload.address_line1\n    }).then(function(model) {\n      return new Address({\n        'id': model.id\n      }).fetch();\n    }).then(function(model) {\n      return reply(model);\n    }).catch(function(error) {\n      return reply(error);\n    });\n  }\n};\n. Yeah, I think this one is something I'm going to leave off the map for now, but I might look to add a plugin for something like this. But feel free to show me some use cases so I have a better sense for where this might best fit.\n. Yeah... Knex has batch insert support, by passing an array to the insert method. I'll open a ticket over there for looking into an upsert type implementation.\n. This isn't the intended design, though the easiest way to get it currently would be model.query('whereNull, 'reportId').fetch()... but when this is fixed to work the way you'd expect in the latest Knex (0.4.x) and should be ready to go on the next release of Bookshelf in the next day or so.\n. Should be fixed in 0.5.0\n. Currently, the best way would be to do it explicitly:\njs\nnew Post(data).save().then(function(post) {\n   return when.all(post.related('tags').set(tagModels).invoke('save')).yield(post);\n}).then(function(post) {\n  console.log('all tags should be saved on a new post');\n  console.log(JSON.stringify(post))\n});\nI'm creating some helpers to make this process a little nicer, in the active-record branch but for now it's probably best to just do it this way.\n. Yes, the active record branch will eventually do a bit more of the heavy lifting, going to close this one for now...\n. Yeah, you're right... I've been meaning to take a closer look at how the attach / detach methods work and figure out the best api for some of these things.\n. I think I've got this mostly fixed up locally, should have this pushed up with the 0.5.0 release in the next day or so.\n. Should be fixed in 0.5.0.\n. Ah, you're definitely right... I do need to clean this up... I'll look to get this fixed soon (need to take a closer look at joins & relations in general)... in the meantime, if can you try adding: \njs\n{columns: 'books.*'}\ninside the options hash passed to fetch - I think that might take care of it...\n. Sure thing, glad to hear you're liking it!\n. Fixed in 0.5.0\n. Hey @mkMoSs - thanks for the ticket! So I decided to actually take this out, but forgot to document it... \nYou could either do it the way you describe, or you can override the toJSON implementation where this actually takes place now... that might be your best bet.\nThe reason it was removed was because I'd like to eventually provide a more standard interface for the pivot columns in general, allowing specific models to be easily used as targets for some of the more complex \"through\" relations, and so I decided to keep things standard as _pivot_ prefixed for now.\nLet me know if you have any questions (also, there was just a pretty big release, that changed the naming & how the library is initialized a bit, might want to take a look through the 0.5.0 change log).\n. Probably at some point but not right away, the custom toJSON would probably be your best bet.\n. One-to-one aren't necessarily bad, but in general (with the way the library is setup), the primary key should be different than the referencing key, so you'd want an id column as well as a Customer_id column...\nHowever, if this is the way you need to have it setup, you may want to try fetching the settings before saving, and then explicitly setting the method in the save call if you know it needs to be an insert, e.g.:\njs\nnew Settings({ Customer_id: 1, data: 'text'}).save(null, {method: 'insert'}).then(callback);\nHopefully this helps.\n. Ah, okay, thanks for pointing that out - I'll need to take a closer look.\n. @nestradaOBS so can you give me general schema design for those two tables you mentioned trying initially in that last comment - I want to make sure I correctly reproduce it in a test case.\n. Thanks so much for the full test case - I am able to reproduce it and I think I have a fix, I'm going to get to it in the next day or so, just to make sure I have everything covered with it - thanks for the issue!\n. Should be fixed in 0.5.1, let me know if you see any other issues!\n. This is due to the pool that is running, where the default pool setting for postgresql and mysql is to have a minimum of 2 open connections at all times... You can either call process.exit(), or you can drain the pool by calling: Bookshelf.knex.client.pool.destroy(), which should drain and release all clients which would then allow the process to exit as it normally would.\n. Hey, thanks for the ticket. The plugin looks pretty neat, good start... I went ahead and added it to a new wiki page here feel free to add any description or information to that page about it, or if you have any other plugins you make feel free to add them!\n. Hey @DiegoMax - you can read a bit more about how events work here: http://backbonejs.org/#Events as the events are inherited directly from Backbone.js' Events module.\n. Ah, good catch @bogus34 - need to take a look and make sure that gets fixed in checkit... Also, I'm looking to get some proper docs and actually release that sometime soon. I'll keep this ticket open until I do.\n. Thanks for all of the kind words @DiegoMax! Glad to hear you're enjoying the simplicity I've been aiming for in the library!\nI think I'll keep this ticket open for awhile. Anyone reading can feel free to chime in with any success stories, cool things you've built, or things you've discovered in the library here.\n. Hey @brianjmiller... as @DiegoMax sort of mentioned, I would probably just create a custom method on your base Model's prototype for this:\njs\nbookshelf.Model.prototype.cloneAsNew = function() {\n  return new this.constructor(_.omit(this.attributes, 'id'));\n}\nI didn't use the this.toJSON because unless you pass {shallow: true} it includes all of the items in the relations hash.\nNot saying this wouldn't be useful, I think it might be something I'll consider for the active-record branch/features I'm working on, which will give some nice interfaces to the core functionality provided by Bookshelf.\nMy idea is that eventually you'll use require('bookshelf/active-record') to get that interface (which will be a superset of the Bookshelf interface).\n. AngularJS is client side, this is currently only for node.js for interacting with server-side databases... though I do eventually plan on making this and other related things I'm working on for it available on the client side, that's a bit down the road.\n. Great to hear! Actually, next on my todo list is giving it even more of an Active Record feel (static finder methods, etc), but in the meantime everything in the library so-far  should work really well, feel free to open a ticket if you see otherwise!\n. @mchicote yep - keep an eye out, there will be lots of big developments coming soon.\nAs for pagination, you can actually tap into the query chain by calling query with arguments as opposed to with no arguments:\njs\nuser.query({limit: 10, offset: 30}).fetchAll() // result will be a collection of models\njs\nuser.query().limit(10).offset(30).select() // result will be an array of vanilla objects\nSo while there isn't anything \"baked in\" it's actually possible to paginate / modify any queries while maintaining models quite easily.\n. I'm pretty sure you can set {columns: ['a','b','c']} on the options for the fetch method and that should take care of it. Let me know if that doesn't seem to work.\n. Well, first... you don't need to use Q.defer... your promises can be simplified, throwing Errors rather than using deferred.reject, etc:\n``` js\nlogin: function(req) {\n  var self = this;\n// First we need to validate the API Access token (client token)\n  return global.models.Client.forge()\n    .check(req.body.client_token)\n    .then(function(client){\n  // Invalid client token\n  if (client === null) throw new Errors.Api(2006);\n\n  // Valid token\n  // Is this a user or a driver logging in ?\n  var associations = [];\n  var fields = [];\n  var isUser = null;\n  var modelClass = self;\n  if (req.route.path === '/users/login') {\n    isUser = true;\n    fields = [\n      \"email\", \"id\", \"type\"\n    ];\n    associations = [\n      'Profile',\n      {'ActiveBooking': function(qb) {\n        qb.whereIn('status', ['STBookingInTransit'])\n      }},\n      'ActiveBooking.Driver',\n      'ActiveBooking.Driver.Profile',\n      'ActiveBooking.User',\n      'ActiveBooking.Driver.Car'\n    ];\n  } else {\n    isUser = false;\n    modelClass = global.models.Driver.forge();\n    //TODO: Check with roberto if we really need the user object in here ?\n    associations = [\n      'Profile',\n      {'ActiveBooking': function(qb) {\n        qb.whereIn('status', ['STBookingInTransit'])\n\n      }},\n      'ActiveBooking.Driver',\n      'ActiveBooking.User',\n      'ActiveBooking.User.Profile',\n    ]\n  }\n\n  return modelClass.set({\n    'email': req.body.email,\n    'password': STAuth.hash(req.body.password)\n  }).fetch({\n    withRelated: associations,\n    columns: fields\n  }).then(function(user){\n    // Invalid credentials\n    if (user === null) throw new Errors.Api(2001);\n    return user.save({\n      token: uuid.v4(),\n      app_version: req.headers['user-agent'],\n      api_level: client.get('api_level'),\n      platform: client.get('platform')\n    }).then(function(user){\n      if (isUser === true && user.get('type') === 'STUserTypeDriver') {\n        throw new Errors.Api(2007);\n      } else if (isUser === false && user.get('type') === 'STUserTypeUser') {\n        throw new Errors.Api(2007);\n      }\n      user.isUser = isUser;\n      return user;\n    });\n  });\n});\n\n};\n```\nsecond, you should chain a .then(null, function(error) { console.log(error.stack); }) at the last promise there... so in your case:\njs\n       throw new Errors.Api(2007);\n     }\n      user.isUser = isUser;\n      return user;\n    });\n  });\n}).then(null, function(err) {\n   console.log(err.stack);\n});\nand see if there's an error that shows up there. Also, you may want to consider refactoring your code a bit so that the promise handlers are a bit flatter... since that's the idea with promises, you typically shouldn't have to nest as far as you currently are.\n. Yep we're going to make sure this happens and is done right. Keep an eye on #552\n. Yep we're going to make sure this happens and is done right. Keep an eye on #552\n. @kaemu - it's because you need to set the idAttribute on the model definition to user_id if it's the primary key for the table... that's what Bookshelf uses to determine whether the field is \"new\" or not.\n. Hey @salper, thanks for the ticket! I'm going to take a closer look at some of these cases and see what might be going on, and whether any of this is expected behavior or not.\n. Yeah... migrations are something that's been in the pipeline for a little while now, and hasn't quite gotten the attention it deserves:\nhttps://github.com/tgriesser/knex/blob/d98c0b1abc44b8090f426a3d62e0541a394142d8/lib/migrate.js\nI'm hoping to realistically get it wrapped up by sometime mid-november, though if you want to take a stab at implementing something based on what I have so far, that'd be much appreciated. Otherwise, I have plans for implementing an \"active record\" sugar layer, which would be modeled after rails' active-record library and sit atop bookshelf to provide that syntax:\nhttps://github.com/tgriesser/bookshelf/tree/active-record/active-record\nOther than that, there's plans for validations, and better type-casting... hopefully trying to knock out all of this stuff by year end.\nNo \"official\" roadmap yet though.\n. Hey @salper - does the other patch you submitted that I merged in help with this. Looking to get a release out with that fix shortly.\n. Hey @salper - does the other patch you submitted that I merged in help with this. Looking to get a release out with that fix shortly.\n. Cool, it looked alright as far as I could tell. Working on cutting a new release now.\n. Cool, it looked alright as far as I could tell. Working on cutting a new release now.\n. Moving discussion to #93.\n. Not presently, though this is something I'll look into supporting with knex which would give support for it in Bookshelf as well.\n. Does something like the following not work:\njs\nnew models.User({id: 1}).fetch().then(function(user) {\n   var permissions = user.related('Permission_set');\n   // Detach all permissions: permissions.detach();\n   // Detach a permission by id: permissions.detach(10);\n   // Attach a permission permissions.attach({permissionData: value});\n})\n. Also, see the tests for attach/detach here\n. That's named sync, not as in \"synchronous\" but as in \"sync the data with the database\"... there is no option for synchronous inserts, as this defeats the purpose of node. \nYou'll probably want to read up on promises for how to manage async logic... http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/\nBookshelf uses when.js as it's promise implementation, but any A+ compilant lib (such as Q or bluebird) will do:\nhttps://github.com/cujojs/when/blob/master/docs/api.md#api\nAlso, the event handlers can be used in helping with validations, if you return a promise (such as for checking the existence of a user) in any event handlers such as \"saving\" or \"creating\" and the promise fails or throws an error, the whole insert will be rejected and the user will not be inserted into the database.\n``` js\n// In a model:\ninitialize: function() {\n  this.on('creating', function(model) {\n    // If this checkUniqueEmail fails... the whole save will be cancelled\n    return model.checkUniqueEmail();\n  });\n},\ncheckUniqueEmail: function() {\n  return new User({email: this.get('email')}).fetch().then(function(user) {\n     if (user !== null) throw new Error(\"A user account with this email already exists\");\n  });\n}\n```\n. So I had thought about this a decent bit when I refactored it all a little while ago, and the way that I handle it (an example is shown in the tests), is to initialize the database and then inject the database into a function where I create the models. I think the issue with allowing the late binding of the database, is that internally, any eager-loaded relations also need to know about the current database being used... and it becomes a bit messy if you may or may not have a database bound to a model you're using.\n``` js\n// model-init.js\nmodule.exports = function(Bookshelf) {\nvar Account = Bookshelf.Model.extend({\n      tableName: 'account'\n   });\nvar User = Bookshelf.Model.extend({\n      tableName: 'users'\n   });\nreturn {\n     User: User,\n     Account: Account\n   }\n};\n// later\nvar modelInit = require('model-init');\nvar Bookshelf.MySQL = Bookshelf.initialize({...config...});\nvar Models = modelInit(Bookshelf.MySQL);\n```\nAlso, everything should be refactored internally so it's following a data-mapper pattern and it should be possible to extend the base foundation units in dialects/base with a different database, such as MongoDB. The main bookshelf.js would need to be replaced with a dialect-specific one, but I was considering doing this at some point anyway, where you'd need to do require('bookshelf/sql') to get the equivalent of what is being used now, whereas for MongoDB you'd do require('bookshelf/mongodb').\nLet me know if that's something you're looking to do... I'd be interested to try and help out in building that out.\n. > You mind if I ping you via email?\nGo for it.\n. > We're often stuffing a lot of other functions into the models so working with as in your example using model-init would become unwieldy unless you were to start incorporating mixins.\nI do the same... you wouldn't need to have these all in the same file, you'd just need to have each file containing models do a module.exports with a function which accepts the instance you're looking to use as an argument and uses that for creating the models. \nI am going to take another look at it though and see if there'd be a good way to dynamically specify the database as a property on the model and not cause other issues with eager loaded relations, etc.\n. Yeah... Actually, in thinking about it a bit more, it would be pretty cool to come up with a way to do this. It's the API I was going for originally, but it was dependent on caching the initialized databases inside the library with Bookshelf.Instances and Knex.Instances, which wasn't a great way to do it.\nLet's see, so if you had:\njs\nvar User = Bookshelf.Model.extend({\n  tableName: 'users'\n});\na few different api options come to mind:\njs\nnew User({...}, {db: mysql});\nor with a static method, returning an empty instance:\njs\nuser = User.db(mysql).set({...})\nor the way you mentioned, sub-classing the model with the database instance. \nI think it'd be neat to be able to pass it in the options as well as sub-classing the model... not sure if the static method would be worth it.\n. Nice, thanks!\n. @lythesia - might also want to take a look through tests cases for some of these different cases to see how they're handled.\n. Hey @eventEmitter - so I got the basics down for creating models with compound id's... but I'm not certain about how relation loading/pairing should work here. \nEager loading depend on where in queries, which I don't believe will work with multiple keys without a bit of an overhaul on how the queries are composed.\nHow do you anticipate using this feature (what types of relations, etc) - that might help me visualize how to best build this out.\n. Hey @eventEmitter - so I got the basics down for creating models with compound id's... but I'm not certain about how relation loading/pairing should work here. \nEager loading depend on where in queries, which I don't believe will work with multiple keys without a bit of an overhaul on how the queries are composed.\nHow do you anticipate using this feature (what types of relations, etc) - that might help me visualize how to best build this out.\n. Not too sure where this might be happening, but would either of these be related? - https://github.com/brianc/node-postgres/issues/374 or https://github.com/brianc/node-postgres/issues/442\nSounds like maybe running JSON.stringify on the array might fix it?\n. @badave cool, if there's something convenient to make it work that could be set on knex end let me know.\n. I guess I could try to patch this on the knex side of things.\n. Thanks @salper!\n. Thanks @salper!\n. Hey @freshtonic - thanks for pointing this out, it makes sense that the where in would be prefixed here. I'm currently traveling and have limited access to internet but I just looked through the code and it looks like changing this should take care of it:\n``` diff\n+++ b/dialects/sql/relation.js\n@@ -177,13 +177,14 @@ define(function(require, exports) {\n         var targetTable = this.type === 'belongsTo' ? this.parentTableName : this.joinTable();\n         key = targetTable + '.' + (this.type === 'belongsTo' ? this.parentIdAttribute : this.key('foreignKey'));\n       } else {\n-        key = this.isInverse() ? this.targetIdAttribute : this.key('foreignKey');\n+        key = this.targetTableName + '.' +\n+          (this.isInverse() ? this.targetIdAttribute : this.key('foreignKey'));\n       }\n   knex[resp ? 'whereIn' : 'where'](key, resp ? this.eagerKeys(resp) : this.parentFk);\n\n   if (this.isMorph()) {\n\n\nknex.where(this.key('morphKey'), this.key('morphValue'));\nknex.where(this.targetTableName + '.' + this.key('morphKey'), this.key('morphValue'));\n       }\n     },\n```\n\nIf someone wants to submit a PR & fix the 2 associated unit tests I'll go ahead and merge, otherwise I'm going to look at getting this and other tickets fixed after I get back in about a week.\n. Hey @benesch and all thanks for the different tickets/pr's and such, sorry I've been totally MIA on these issues, been traveling overseas for about a week and a half and just returned, still a bit jet lagged... getting caught up on things in the next day or two, so hopefully I'll have some responses for these soon!\n. @benesch - I was gonna merge this in and try to fix the polymorphic relations, did you happen to have a failing test for that (if not I can whip one up really quick)?\n. @benesch - I was gonna merge this in and try to fix the polymorphic relations, did you happen to have a failing test for that (if not I can whip one up really quick)?\n. No worries, thanks for the other stuff so far!\n. No worries, thanks for the other stuff so far!\n. Just merged this in with what should take care of the polymorphic relations. If you have something that seems to still not work, let me know with a test case... otherwise, I'm going to try to get this rolled into a release soon.\n. Just merged this in with what should take care of the polymorphic relations. If you have something that seems to still not work, let me know with a test case... otherwise, I'm going to try to get this rolled into a release soon.\n. Yeah, try changing the .select('v1.upvotes', 'v2.downvotes'); to .column('quips.*', 'v1.upvotes', 'v2.downvotes') and see if it works. \nBasically knex only lets you call select, update or insert once per query, and since you're calling it there (and then again later when the query is compiled by bookshelf) it throws that error. I'll look to make this a bit simpler so you could do it either way in the future.\n. Huh, what is the schema for your registrations table?\n. Huh, what is the schema for your registrations table?\n. @nkcmr can you change res.send(err.stack); to res.send(err.clientError.stack); and see if there's a stack trace that gives any better indication as to where the error is taking place?\n. @nkcmr can you change res.send(err.stack); to res.send(err.clientError.stack); and see if there's a stack trace that gives any better indication as to where the error is taking place?\n. Also, @nkcmr - want to grab the latest knex & bookshelf (0.5 and 0.6 respectively) and see if it fixes any of your issues here?\n. Ah, yeah that should be: \njs\nconnection: {\n    filename: \"./database/main.db\"\n}\nnot database:.\n. > So if that fails, it fails silently. The error handler must now be provided explicitly to the save method like this:\n\nuser.save().then(successFn, failureFn);\n\nActually, you almost never want to use .then(successFn, failureFn), unless you want to have a real reason to, it should almost always be .then(successFn).then(null, failureFn) (in when.js .then(successFn).otherwise(failureFn) and in bluebird and I believe now the Promises ES6 spec .then(successFn).catch(failureFn). I should probably update the docs anywhere I might be doing this.\nSome good reading about promise anit-patterns can be found here.\nAlso, check out what I said on #103 about the fact that I'm going to be switching promise libs... some better error reporting should come along with that as well.\n. All right, it's on to bluebird for promises... check out the latest versions of knex & bookshelf and this section of the FAQ for better info on how to properly debug promises.\n. @bendrucker I'm actually working on trying to structure the library so at its core it's based as a generic data-mapper, and could have an interface that (for example) sits on top of mongoose, or level, couch, etc... you just wouldn't have the same relations available. If anyone is interested in helping to take that on, feel free to shoot me an email and I'd love to discuss!\n. >  Personally I see more need for migrations, schema construction, and validation than another ORM for document databases.\nFor sure, schema construction can be done for the most part with knex, migrations for those in knex are also just about there, and I also hope to wrap up in the next week or two the checkit library for a nice validations solution that can be easily integrated. Better type-handling is also on my short list.\n\nThat's the way juggling does it. There's no question that abstracting away DB specific functionality has some benefit.\n\nSo my ultimate goal with all of this is to structure the library so other libraries mix well with it and everything is nicely layered on top of one another. \nSo the Bookshelf core interface of save, destroy, fetch is the generic base which currently pulls in Knex & a SQL specific adapter (which does all of the nice relation stuff)... and even that can be built on top of, with say a nice active-record static interface which is next on my todo list after the above stuff I mentioned... \nBut I'd like to make it so one could just as easily write adapters written for other databases so say a \"user\" in a postgres row could hasMany mongodb documents and that'd just work. That's a bit further off but I think it'd be a neat goal to keep in mind.\n\nDefinitely has its place but with Amazon RDS supporting Postgres you might see more devs interested in relational DBs.\n\nYeah, absolutely agree... my core focus is on building a solid foundation for relational db's, the other stuff would be nice to have down the road.\n. Hey @benesch - so actually going to be switching knex & bookshelf over to @petkaantonov's bluebird rather soon and cutting a new version release with that.\nThe speed difference is significant to the point where it makes sense to switch, and it actually handles errors quite well without the need for .done.\nI'm also going to ensure there's a shim against common when.js sugar methods (e.g. otherwise, tap, yield) so those are still supported if you're using them off the promises returned by Boookshelf/Knex queries.\nWhen.js is a really great lib, still using it in my own applications (which works just fine, since Promise A+ libs are interoperable)... the performance gap is just too great to ignore for the core of these libraries.\n. Sweet, figured I'd ping you on this ticket so I'd find out something like that :)\n. Sweet, figured I'd ping you on this ticket so I'd find out something like that :)\n. Added a section in the docs about debugging with bluebird in the latest version release. Thanks for the ticket!\n. Oops, tagged the wrong issue here. Will take a look at this in a bit.\n. Oops, tagged the wrong issue here. Will take a look at this in a bit.\n. Currently working on a huge refactor of knex to allow all sorts of stuff like this... will keep you posted when that ships.\n. You'd want either:\n``` js\nstation.seeds().fetch().then(function(seeds) {\n})\n```\nor \n``` js\nstation.related('seeds').fetch().then(function(seeds) {\n})\n``\n. Can you provide the contents of yourseedsmethod? It shows thattargetisundefined... which means thehasMany` is likely targeting the wrong thing.\n. Aha, so you have circular require calls between the two files, read more about it here. The quickest solution would be:\njs\nreturn this.hasMany(require('./seed').Seeds, 'station_id');\nOr using the exports and not referencing the individual model, but rather the module in the top of the file, and then the model on that object inside the method body.\n. See #70 ... in short you can add a columns to the options hash in fetch, or tap into any knex methods with the query method and use columns that way.\n. See #70 ... in short you can add a columns to the options hash in fetch, or tap into any knex methods with the query method and use columns that way.\n. Something like:\njs\nusers.fetch({columns: ['id', 'firstname', 'lastname']}).then(function(c) {\n   // the \"c\" now only has models with 'id', 'firstname', and 'lastname'\n   // ... if that's not the case, let me know bc it's a bug.\n})\n. Something like:\njs\nusers.fetch({columns: ['id', 'firstname', 'lastname']}).then(function(c) {\n   // the \"c\" now only has models with 'id', 'firstname', and 'lastname'\n   // ... if that's not the case, let me know bc it's a bug.\n})\n. Haven't tried it out yet, but did a bit of quick googling and came across this: http://stackoverflow.com/questions/10878731/utf8-console-log-output-using-node-js ... is there any chance this is a formatting issue in the console.log?\n. Haven't tried it out yet, but did a bit of quick googling and came across this: http://stackoverflow.com/questions/10878731/utf8-console-log-output-using-node-js ... is there any chance this is a formatting issue in the console.log?\n. I'm not able to reproduce, just ran a quick test on an empty express app and i'm seeing it both console log'ed and printed to the browser correctly...\n\n\nWhat OS are you encountering this issue with?\n. I'm not able to reproduce, just ran a quick test on an empty express app and i'm seeing it both console log'ed and printed to the browser correctly...\n\n\nWhat OS are you encountering this issue with?\n. Great!\n. Great!\n. Hi @fonini - can you give some of the code that you're having issues with when trying to do these updates? Thanks!\n. Hi @fonini - can you give some of the code that you're having issues with when trying to do these updates? Thanks!\n. It'd just be:\njs\ndefaults: function() {\n   return {\n     // defaults object\n   }\n}\nI guess I didn't think it was something that needed explanation, the code just does _.result(model, 'defaults') meaning if it's a  value, use that, if it's an function, call it and use that.\n. I've been thinking about this one a bit, and I like it, particularly in regards to some changes that'll be coming to make relations a bit more powerful than they are now. \nI think this'll be rolled into the next release via a single: true option on fetch.\n. Thanks @bendrucker!\n. I think the best way is probably:\njs\nmodel.query('whereRaw', 'field', 'SOMEFUNC(1, 2, 3)')\n. Hey @kburkettgeo - It looks like there's two issues in your code here. \nThe first is that IIRC console cannot be called with an undefined context. As a promise resolves in when.js, it's essentially doing resolver.call(undefined, resolvedValue)... in some cases, this works if the context is not necessary, or if the context has already been explicitly bound.\nThe solution for that is either to do\njs\n.then(function(value) {\n  console.log(value)\n})\nor:\njs\n.then(console.log.bind(console))\nThe second issue, is that you're calling geoLogger.getRecentGeoLogEntries(3) immediately, rather than as part of the promise chain... the value from the getRecentGeoLogEntries will likely be called before the other entry is written. To resolve this, you should return a function for the getRecentGeoLogEntries method (shown below).\nAlso, just FYI, the when.defer(); calls are not necessary, you can just return newEntry.save() or the ...limit(n).select() in the getRecentGeoLogEntries function, as they're promises and can be chained with .then, .otherwise, etc rather than needing a when.defer.\nIf your concern was ensure it is explicitly a \"when\" promise, you can just do:\njs\nreturn when(newEntry.save());\nHere's what the code would look like after fixes:\ngeoLogger.js\n``` js\nvar bookshelf = require('bookshelf');\nvar when = require('when');\nbookshelf.geoLogger = bookshelf.initialize({\n  // connection info...\n});\nGeoLogEntry = bookshelf.geoLogger.Model.extend({\n  tableName: 'geo_log_entry'\n});\nGeoLogEntries = bookshelf.geoLogger.Collection.extend({\n  model: GeoLogEntry\n});\nexports.logMessage = function(geoLogLevel, geoLogCategory, source, message) {\n  return new GeoLogEntry({\n      geo_log_level: geoLogLevel,\n      geo_log_category: geoLogCategory,\n      source: source,\n      message: message,\n  }).save();\n};\nexports.logError = function LogException(geoLogCategory, source, error) {\n  return exports.logMessage(geoLogCategory, GeoLogLevel.High, source, error);\n};\nexports.getRecentGeoLogEntries = function(n) {\n  return function() {\n    return new GeoLogEntries()\n      .query()\n      .orderBy('id', 'desc')\n      .limit(n)\n      .select();\n  };\n};\nexports.truncateGeoLog = function() {\n  return new GeoLogEntries().query().del();\n};\n```\ngeoLoggerTests-does-not-work.js\n``` js\nvar geoLogger = require('./../lib/geoLogger.js');\nvar reporters = require('./../lib/reporters.js');\nvar when = require('when');\nvar uuid = require('node-uuid');\nvar testId = 'test-' + uuid.v4();\ngeoLogger.logMessage('Low', 'Api', testId, \"test\")\n.then(function(result) {\n    console.log('source:  ' + result.get('source'));\n    console.log('id:  ' + result.get('id'));\n})\n.then(geoLogger.getRecentGeoLogEntries(3)) // This now returns a function\n.then(function(resp) {\n  console.log(resp);\n})\n.ensure(process.exit);\n```\nAlso, another FYI, if you want to the query method can also take parameters and dynamically tap into the query chain, rather than dropping down to the raw knex builder if invoked with no arguments.\nHope that helps!\n. Cool, this looks good - actually, can you switch the PR to be against the 0.7.x branch, changing the arguments and such should probably be at least a minor release bump rather than patch (since we're still pre 1.0) and there are still a few other things I'd like to get done before that release.\n. That's strange that it'd print out success without inserting the record... I'll try to reproduce and get back to you with what I find. Can you try taking out the process.exit does it seem to do the insert (if it does it seems like it's still a bug, just curious though).\n. @noordmitpf - looking to try and reproduce, can you give me the schema of the \"primary_asset\" table you're looking to insert into? \nI have a feeling that it might be due to the fact that since you're specifying a primary key, it's trying to run an UPDATE rather than an INSERT, which you'd work around by specifying {method: 'insert'} in the options hash:\njs\nPA.forge({primary_asset_id: 8, primary_asset_desc: 'Asset 8'})\n      .save(null, {method: 'insert'})\n      .then(function() {console.log('success'); process.exit(0)})\n      .otherwise(function(){console.log('failed');});\n...but even so, there should still be an error here.\n. @glenselle no errors would be thrown, they'd be handled in the promise onRejected handler:\nTry: \njs\nvar bookshelfSchema = new Account(data).save().then(function(model) {\n   console.log('Everything is saved!');\n   res.json(model);\n}).otherwise(function(err) {\n   console.log(err.stack);\n});\nand see if you get any errors.\n. > You're not going to get an error there because of how knex's update function works. It resolves with the number of affected rows and it doesn't look like Bookshelf ultimately turns that into a rejected promise.\nIt probably should cause a rejected promise in Bookshelf though, if you try to do an update but no rows are affected, don't you think?\nAlso, @noordmitpf I had a full reply typed out last night but then I refreshed the page and lost it... I wish github had an autosave feature or something for draft responses. Anyway, the reason it's not closing is because there's a connection pool setup in knex which defaults to having a minimum of 2 connections and a maximum of 10... you can change this by setting:\njs\nvar BookshelfPG = Bookshelf.initialize({\n  client: 'pg',\n  connection: {\n    host: 'localhost',\n    username: 'username', // changed\n    password: 'password', // changed\n    database: 'dbname', // changed\n    charset: 'utf8',\n    port: 5432\n  },\n  pool: {\n    min: 0,\n    max: 10 // or whatever you want here...\n  }\n});\nI do need to document the info regarding connection pooling better at some point.\nOtherwise, because there is still timers going on keeping the minimum number of connections alive, the process will hang, unless you call process.exit or Bookshelf.knex.client.pool.destroy();.\n. Should be fixed in the latest release, let me know if you see any issues!\n. Yeah, sorry, thanks for the pull request it's taken me a little while to get to this/think it through. \nSo I've never really liked the exec interface, in both knex & bookshelf... it feels like a hack and messes with the underlying promise library api by providing a shimmed then method which isn't consistent with the promise library. For example after applying the exec plugin you can't use tap or catch directly, but only after then is called and returns a \"true\" bluebird promise.\nSo I did this... basically the exec plugin will be gone and in it's place the last argument of any async method will be assumed as a node-style callback:\njs\nusers.fetch({withRelated: ['accounts']}, function(err, resp) {\n   // ... do your callback stuff here\n});\nThat way, it'll be even easier for folks who don't enjoy promises for whatever reason to use the familiar node-style callback pattern and it won't require compromises on the promise consistency with the internals. This'll go out once I get a 0.7 release pushed.\n. > If there is already a nodeify interface on bluebird, why not using it directly if you are always returning a bluebird promise?\nBecause you'd lose the context of the method if it's not wrapped like I'm doing above... also I was thinking that people might like using it the way they're used to in node, where the last argument is the callback.\n\nAn if you need to abstract it, keeping exec as an alias would do the job.\n\nYeah, you're right, basically defining this:\njs\nPromise.prototype.exec = Promise.prototype.nodeify\nso you could use it as it was used before, but without messing things up internally:\njs\nuser.fetch().exec(function(err, resp) {\n  //....\n});\nI'd prefer exec to nodeify naming wise personally... that might be the way to go here.\n. Thanks for that... ideally the syntax should be user.photos.query('count', '*') or user.photos.query().count('*') but it's not working right now because the relation information isn't bound until the select is performed. I'll look into a solution, this is a fairly common case (note that if this is blocking you, you should be able to do it manually with knex, but I'm sure you know that)... I'll look into getting this patched soon.\n. If you don't mind fetching the entire relation, you could just do it on toJSON:\njs\ntoJSON: function() {\n   var json = Model.prototype.toJSON.apply(this, arguments);\n   json.members = _.pluck(json.members, 'id')\n   return json;\n}\nOtherwise you can specify the columns you wish to fetch with the column method in Knex (see #70, #75).\n. Yep, good call @johanneslumpe... this could either be:\njs\nif (method === 'insert' && resp && resp[0] !== 0)\nor\njs\nif (method === 'insert' && resp && this.id == null)\nI'll look to get this fixed shortly.\n. @johanneslumpe - should be fixed in the latest release, let me know if you see any issues!\n. Yep, @johanneslumpe has it correct... the transactions belongTo an Account in both cases, the belongTo is for when the primary key of the target table is referenced in a column of the current table, and a hasOne is essentially the same as a hasMany but with a limit 1.\n. @shortstuffsushi I agree the wording should be changed in the docs.\n. I believe this was fixed in the docs in the last release. Let me know if it still looks like something is off.\n. Can you try changing:\njs\ngroupSessions: function() {\n  return this.hasMany(app.get('Model.GroupSession'), \"session_id\").through(app.get('Model.Participant'), \"id\", \"user_id\");\n}\nto:\njs\ngroupSessions: function() {\n  return this.hasMany(app.get('Model.GroupSession')).through(app.get('Model.Participant'), \"session_id\");\n}\nand see if that produces the correct sql?\n. Can you give me the schema you're working with just so I can understand a bit better the relations between tables?\n. Actually, you might want to try this as:\njs\nthis.belongsToMany(app.get('Model.GroupSession')).through(app.get('Model.Participant'), \"session_id\");\n. Great.\n. Hey @nathggns - not yet but it looks like they'll get added as a plugin in #161\n. Yeah, I'd say plugin would be the way to go... if you want to move it to a visibility.js in plugins and open a PR that'd be great.\n. @Tape are you thinking of taking a shot at this as a plugin or do you want me to go ahead and go for it?\n. All right... this is now a \"visibility\" plugin. Thanks again for the ticket @Tape!\n. Yes, they would update with any model property changes.\n@johanneslumpe re: your question above about the get, you could just override get in the plugin.\njs\nget: function(attr) {\n  // put any virtuals checking/returning stuff here\n  // ...\n  return Backbone.Model.prototype.get.apply(this, arguments);\n},\nAlso, what do you think about changing virtualsInJSON to outputVirtuals.\n. Cool, other one is merged... @johanneslumpe I saw the default is to not include virtuals in the toJSON... do you think it should be the other way around (opt-out) - @nathggns any thoughts on what'd would commonly be the default here?\n. Oops. I had originally not had that else if for the array and the plugin was called below... Nice catch.\n. Cool, you can just add a plugins folder inside of integration and put them in there... maybe calling them at the last line (below the require('./integration/relations')(bookshelf); in integration.js). I need to clean the tests up a bit at some point, so don't worry about doing it in any particular way. I'm going to add a separate docs page for the plugins too. Thanks!\n. Sweet\n. Yeah, fetch({require: true})\n. Huh, that's strange... even unhandled, it shouldn't ever crash the app.\n. No the then is the normal promise A+ compliant then, but you can also use .catch including bluebird's neat extended catch.\n. Yeah I'd update it to do the check in the get/set.\n. Also because if you put an object on the prototype and then accidentally mutate that same object later (on an instance) it'll be the same object on all models and happen everywhere... you generally don't want to put objects/arrays as prototype properties as often as you can (that's why they're typically always defined in the constructor).\n. Haha no problem\n. Actually @nathggns want to jump in #bookshelf on IRC and I can try to debug there?\n. Freenode\n. It'd actually be nice if we could somehow detect in knex if the connection limit is getting hit and if so stop trying to create new connections on that instance... rather than mess up the application.\n. Bug... the columns in the model should be prefixed before going out.\n. Nah, I can reproduce it, it's happening in bookshelf... this is the line you're looking for... so it looks like a quick hack would be to tap into the format method and prefix the keys with the table names, but that's pretty hackish and not really what format is intended for... writing a method in sync somewhere that standardizes the keys to include the tableName seems like the better fix.\n. Actually, I'm not sure that we want the prefix performed when the columns are explicitly specified, because you can choose columns that are potentially from different tables (joins, etc.)... the first call should be the only one needing it (since we know the model the attributes are coming from), so the array stuff can go (sorry). \nUnless you have a different thought for how this might work better that I'm not considering.\n. Hmm, so for the joins I think let's keep the columns where you need to prefix them (if necessary) for now... \nEventually I'd like to grab the schemas for the models out of the database at extension time, so we know what columns are available for each model, the types, etc. Following that, there'll be a way to say model.joins(OtherModel, {colums: [... columns to fetch...])... and then we'll know how the columns should be prefixed there. Still a bit down the road but let's keep the options as simple as possible for now.\n. @zacharynevin does the events model not have a single column primary key?\n. You might be hitting a cyclic dependency issue in your belongsToMany definition. This line should only be hit if you're doing a morphTo relation. Can you paste some code about how your belongsToMany is setup?\n. Yeah, sorry been really busy this past week with moving and stuff, thanks @johanneslumpe, @bendrucker, and @nathggns for helping spearhead all this stuff (discussion, PR's and otherwise). I agree it'd be great to have a system for organizing this stuff as well as a roadmap to keep it all straight. I'll get something together soon and let you know.\n. So here's what I'm thinking. There should be a method in Knex that returns a standardized representation of the schema (column, type, default, etc.)... Bookshelf would then grab that at extension time and keep that info on the Model, using it to typecast things when going to/from the database with the ability to override with a types hash on the model... e.g.\njs\nvar User = Bookshelf.Model.extend({\n   tableName: 'users',\n   types: {\n      permissions: 'json'  // this is actually a \"text\" column but would be stringified/unstringified upon save\n      active: 'bool' // this is actually a tinyint(1) but would be converted explicitly to a boolean\n   },\n   // ....\n});\nIn terms of organization of issues, does anyone have preference on how they're organized... github milestones? wiki public trello board? Open to ideas...\nI'd also like to get a message board up at some point for better support/discussion around these libs, keeping github mostly for feature discussion.\n. > The only thing I might change from your example is using a combo of primitives and config object rather than string references to types.\nHaha, see now that actually always confused me. I would think like... why do I need to refer to the Mongoose object just do to some typecasting; how is Mongoose.Type.Integer clearer than allowing me to use (interchangebly) 'Int', 'int', 'Integer', or 'integer'. Shouldn't typecasting be something that can stand on its own and not be tied into a namespace on the library?\nI agree it'd be nice to also allow primitives to signify types where they exist (String, Boolean, Date, JSON)... maybe this also matters more in Mongo where you have a broader spectrum of object types you're basically always required to define on the model for your BSON.\n\nWhat about allowing custom typecasting functions\n\nDefinitely.\nI have some stuff I've worked on for this locally, I'll look to get it pushed up sometime soon.\n. >  Are we still thinking about having a 'model' function? Or do you still want to do everything within an extended 'extend'\nI'd still like to do the extended extend... On the 0.7.x branch I'm using simple-extend which is basically the Backbone.extend plus this hook which executes an \"extended\" method on the parent object if it exists.\nMainly because I'd like to keep the niceties of CS's class syntax, super in particular, and keep the semantics as close as possible to Backbone's Models & Collections.\nPlus maybe if we implement some good things with the extended hook in these libs and enough people are tired of using my coffee fork or calling @extended at the end of the executable class body, it'll give @jashkenas a compelling enough real-world (in the wild) use case to consider supporting it ;) \n. Cool, makes sense\n. Or new Users().fetch()...\n. Hey @mjhamm75 - thanks for the issue! It looks like @bendrucker closed it, marking it as a duplicate. Ben, can you reference the duplicate ticket id and maybe provide a bit of an explanation when closing?\n. Hey @mjhamm75 - thanks for the issue! It looks like @bendrucker closed it, marking it as a duplicate. Ben, can you reference the duplicate ticket id and maybe provide a bit of an explanation when closing?\n. Nah don't worry about writing something, it's just still something I'd like to think on. I remember there was a reason Jeremy had for wanting it to be model rather than Model in Backbone. Possibly throwing a better error if there's a model attribute missing on a collection.\n. Nah don't worry about writing something, it's just still something I'd like to think on. I remember there was a reason Jeremy had for wanting it to be model rather than Model in Backbone. Possibly throwing a better error if there's a model attribute missing on a collection.\n. There should now be some clearer in there, should go out with a new release a bit later today.\n. I don't think this needs to be rolled into the library as a core feature. A plugin, sure, but IMO it's just duplicating the functionality of require... or a simple service locator... not something that needs to be top level on the Bookshelf object.\nA better solution might be to put something in the FAQ to help people actually understand how cyclic dependencies work in node and how to work around them, rather than papering over it with another layer of naming things (all models need to be required at some point before referencing them for this to work anyway).\nMaybe updating some of the docs examples to just use the require inline in the relation, and then link to the plugin if more explicit conventions are desired.\n. I don't think this needs to be rolled into the library as a core feature. A plugin, sure, but IMO it's just duplicating the functionality of require... or a simple service locator... not something that needs to be top level on the Bookshelf object.\nA better solution might be to put something in the FAQ to help people actually understand how cyclic dependencies work in node and how to work around them, rather than papering over it with another layer of naming things (all models need to be required at some point before referencing them for this to work anyway).\nMaybe updating some of the docs examples to just use the require inline in the relation, and then link to the plugin if more explicit conventions are desired.\n. > It's duplicating a require use case for sure, but it's not true that models would need to be required anyway\nIf there's a js file which registers via Bookshelf.model, but that file is never require'ed in the application, that model wouldn't be accessible for a relation, correct?\n. > It's duplicating a require use case for sure, but it's not true that models would need to be required anyway\nIf there's a js file which registers via Bookshelf.model, but that file is never require'ed in the application, that model wouldn't be accessible for a relation, correct?\n. @bendrucker can you rebase all of this into a single commit?\n. @bendrucker can you rebase all of this into a single commit?\n. What do you think about naming the plugin itself registry? Since that's essentially what it is.\nEdit: I see it's referred to as that in the docs... I meant naming it registry.js.\n. What do you think about naming the plugin itself registry? Since that's essentially what it is.\nEdit: I see it's referred to as that in the docs... I meant naming it registry.js.\n. No, you can use both... just like this:\njs\nactivityGroupCollection\n  .query('where', {performer_id: [..., ...]})\n  .fetch({withRelated: ['performer']})\n@mcmire you might also want to look into the load method... http://bookshelfjs.org/#Model-load\nYou could fetch a few activity groups (which would each still remain in their own collections), consolidate just the models into a single collection, and then call load on that collection to do the relation loading on all models at once.\n. No, you can use both... just like this:\njs\nactivityGroupCollection\n  .query('where', {performer_id: [..., ...]})\n  .fetch({withRelated: ['performer']})\n@mcmire you might also want to look into the load method... http://bookshelfjs.org/#Model-load\nYou could fetch a few activity groups (which would each still remain in their own collections), consolidate just the models into a single collection, and then call load on that collection to do the relation loading on all models at once.\n. Gotcha, good points on the docs, will need to get those updated.\n. Gotcha, good points on the docs, will need to get those updated.\n. Docs will be updated with more info about withRelated and query shortly.\n. I believe that'll work if you set the idAttribute to null for that table. I also think I'm going to try to get the composite idAttribute stuff taken care of soon so you'd be able to specify idAttribute: ['user_id', 'certification_id'].\n. I believe that'll work if you set the idAttribute to null for that table. I also think I'm going to try to get the composite idAttribute stuff taken care of soon so you'd be able to specify idAttribute: ['user_id', 'certification_id'].\n. Well, thinking about it again, I'm not this it would work right now actually... \nBookshelf assumes that every model it's working with has a single column primary key, but you need to be able to set composite key in order for this to work properly. So for now you'll either need to add an auto-incrementing primary key for that table for Bookshelf to work its magic, or handle everything manually with knex.\nOtherwise, you can always pass {method: 'update'} or {method: 'insert'} to the save in order to tell Bookshelf explicitly what to do during the save.\n. Well, thinking about it again, I'm not this it would work right now actually... \nBookshelf assumes that every model it's working with has a single column primary key, but you need to be able to set composite key in order for this to work properly. So for now you'll either need to add an auto-incrementing primary key for that table for Bookshelf to work its magic, or handle everything manually with knex.\nOtherwise, you can always pass {method: 'update'} or {method: 'insert'} to the save in order to tell Bookshelf explicitly what to do during the save.\n. Agreed. I'll get this fixed soon.\n. Agreed. I'll get this fixed soon.\n. Interesting. This could be a bug that it's not using the correct key on load, I'll try to reproduce this in a bit.\n. Interesting. This could be a bug that it's not using the correct key on load, I'll try to reproduce this in a bit.\n. Alright so this is fixed in master. I'll look to get a new patch release cut later today with this and the other features that have been changed recently.\n. Alright so this is fixed in master. I'll look to get a new patch release cut later today with this and the other features that have been changed recently.\n. Cool, thanks it's in there now, I'll get a test in place.\n. Cool, thanks it's in there now, I'll get a test in place.\n. Hmm, I'm not sure... basically the parameters you set on the model when creating a new model object determine the constraints for the query... so if you haven't set any and do a fetch, that seems like the query you'd expect.\nWhat case is it that you're running into where that's happening and you'd expect undefined?\n. Hmm, I'm not sure... basically the parameters you set on the model when creating a new model object determine the constraints for the query... so if you haven't set any and do a fetch, that seems like the query you'd expect.\nWhat case is it that you're running into where that's happening and you'd expect undefined?\n. Good idea, you're right - that would definitely be helpful, I'll look on getting this in there.\n. Good idea, you're right - that would definitely be helpful, I'll look on getting this in there.\n. Merged in @johanneslumpe's fix. I don't think that a null key relation is something that we'd want to support here. Will get this cut in a release sometime soon.\n. I believe you should be able to do:\njs\nknex('user').whereIn('id', [1,2,3]).delete()\nLet me know if that doesn't seem to work.\n. I believe you should be able to do:\njs\nknex('user').whereIn('id', [1,2,3]).delete()\nLet me know if that doesn't seem to work.\n. Sorry, I wasn't looking and thought this was a ticket on knex because of the question being straight sql. I think you'd currently need to use query() to drop down to the query builder to do this with a model currently, because the model constrains to an individual id for ORM purposes:\njs\nmodel.query().whereIn('id', [1, 2, 3]).del().then(...\n. Sorry, I wasn't looking and thought this was a ticket on knex because of the question being straight sql. I think you'd currently need to use query() to drop down to the query builder to do this with a model currently, because the model constrains to an individual id for ORM purposes:\njs\nmodel.query().whereIn('id', [1, 2, 3]).del().then(...\n. The downside with the .invokeThen('destroy') is that it's inefficient to run a query for each delete rather than using a where in (fine for small sets, but not ideal).\n. The downside with the .invokeThen('destroy') is that it's inefficient to run a query for each delete rather than using a where in (fine for small sets, but not ideal).\n. It's certainly possible, it's just a matter of determining how the semantics around that would work...I also didn't want to make it super easy to blow away an entire database table with no arguments collection.destroy(). \nDefinitely something on the radar but I haven't taken time to work through the details yet.\n. It's certainly possible, it's just a matter of determining how the semantics around that would work...I also didn't want to make it super easy to blow away an entire database table with no arguments collection.destroy(). \nDefinitely something on the radar but I haven't taken time to work through the details yet.\n. Thanks @p-baleine - Will get this rolled into a new release shortly\n. Thanks @p-baleine - Will get this rolled into a new release shortly\n. @bavidar just fyi you can also do:\ncoffee\nclass Proxy extends db.Model\nin which case you could also override constructor if you wanted, as long as you called super before whatever logic you're putting in there.\nAlso @bendrucker - that's incorrect actually, idAttribute defaults to \"id\" on the model (pulled in from backbone)... so it was likely the issue with the constructor, but let me know if you don't figure it out and I can look into it a bit more.\n. @bavidar just fyi you can also do:\ncoffee\nclass Proxy extends db.Model\nin which case you could also override constructor if you wanted, as long as you called super before whatever logic you're putting in there.\nAlso @bendrucker - that's incorrect actually, idAttribute defaults to \"id\" on the model (pulled in from backbone)... so it was likely the issue with the constructor, but let me know if you don't figure it out and I can look into it a bit more.\n. I wrote createError for just this purpose and I think it'd be first good to discuss what different error types should be, and why.\n. I wrote createError for just this purpose and I think it'd be first good to discuss what different error types should be, and why.\n. > Most of the time when you're matching against the error you're going to have the model constructor available, but almost never Bookshelf itself.\nWait, really? wouldn't you just do like:\njs\nvar Errors = require('bookshelf').Errors\n. > Most of the time when you're matching against the error you're going to have the model constructor available, but almost never Bookshelf itself.\nWait, really? wouldn't you just do like:\njs\nvar Errors = require('bookshelf').Errors\n. So I think these should also be sub-classed under some sort of generic \"Bookshelf Error\" class. \nMaybe the base Error could be termed \"Exception\", since that's what it essentially boils down to when used with promises (catching on specific exception types, etc.) and it's not Bookshelf.Error which might be confusing.\n``` js\nvar Exception = createError('BookshelfException');\nvar EmptyError = createError(Exception, 'EmptyError');\n// ...\n).catch(Bookshelf.Exception, function() {})\n```\nI'm also thinking there should be a way to create deferred errors, particularly with regards to relations, so that some of the synchronous errors thrown now are just stored on the model and not thrown until a promise happens.\nLike other things, not necessarily looking to rush this in because it's easier to get the semantics right (or at least close) the first time then to have to change things down the line.\n. From some stuff I'm doing in a big relations refactor:\njs\n  init: function(parent) {\n    var hasMany = this;\n    var localKey = this.localKey || _.result(parent, 'idAttribute');\n    var localKeyValue = parent.get(localKey);\n    if (localKeyValue == null) {\n      parent._pendingErrors.push(new Error('The hasMany relation cannot be initiated without a \"localKey\" value.'));\n    }\n    return this.buildQuery(parent);\n  },\nIf I actually throw an error there, it's not within a promise and could crash the app... which might not be until someone calls that method with the bad signature.\nSo I'd push that error onto the model, and then throw once there's a promise initiated on the model.\n. Couldn't merge, but added these in 0.7\n. Yeah, still planning on that\n. Yeah, still planning on that\n. Not yet - played around with building one at one point but there are a lot of pieces around cache invalidation / relations that are tricky - figured it'd be best to leave that in user-land for now... At some point I hope to get something written.\n. Not yet - played around with building one at one point but there are a lot of pieces around cache invalidation / relations that are tricky - figured it'd be best to leave that in user-land for now... At some point I hope to get something written.\n. > but they don't explicitly lend themselves to Bookshelf in any particular way.\nWell, they're useful if you need to do a validation that's async, e.g. checking the database for some condition before saving. That's actually why I wrote it, I couldn't find any other validation libraries that were both fully extensible and handled async operations sanely. \nI'm looking to get some time in the near future to polish up some of the last few pieces around CheckIt and ship it, at that point I'll probably get a more official validation plugin or something for Bookshelf.\nEdit: @bendrucker i see what you were saying, and agree, I was just saying that Checkit provides a more structured way of being able to do async validations.\n. I think the second one should actually be an error, but we can address that later.\n. Hmm, good question. What do you think would be the preferable behavior here? What would be your typical use of an attrs provided in an event here?\n. Yeah it does, good catch! No worries about the test, probably not the best call for me to be testing on an error message anyway.\n. Well, I'm just gonna ship it, if you see anything I missed we can just cut another patch release ;)\n. Yeah, I guess we can put it there for now but I want to rethinking jamming query in the options, it feels sort of like a hack... there should probably be a better interface for these sorts of things.\n. Want to give a test with a potential bad thing?\n. Nice.\n. Hold on the tests are wrong here, the last instanceof check fails if I take the {model: NewModel} out of the NewModel.collection call and I can't seem to figure out why... will reopen one I figure it out.\n. Figured it out.\n. Yeah I'll get it out a little later today hopefully.\n. You could use the knex instance provided by bookshelf to do something like:\n``` js\nvar bookshelf = Bookshelf.initialize({ / db config /});\nbookshelf.knex.schema.createTable('users', function(t) {\n  t.increments('id');\n  t.string('first_name');\n  t.string('last_name');\n  t.string('password');\n  t.timestamps();\n}).then(function() { ... \n   // you now have a users table with a few columns.\n})\n```\nGenerally though, you'd create your database schema separately and be able to assume it's there, and then just have some bookshelf models like:\n``` js\nvar User = bookshelf.Model.extend({\n   tableName: 'users'\n});\nnew User({id: 1}).fetch().then(function(user) {\n  console.log(JSON.stringify(user)); // user with id of 1\n})\nUser.collection().fetch().then(function(users) {\n   console.log(JSON.stringify(users)); // collection of users\n})\n```\n. You could use the knex instance provided by bookshelf to do something like:\n``` js\nvar bookshelf = Bookshelf.initialize({ / db config /});\nbookshelf.knex.schema.createTable('users', function(t) {\n  t.increments('id');\n  t.string('first_name');\n  t.string('last_name');\n  t.string('password');\n  t.timestamps();\n}).then(function() { ... \n   // you now have a users table with a few columns.\n})\n```\nGenerally though, you'd create your database schema separately and be able to assume it's there, and then just have some bookshelf models like:\n``` js\nvar User = bookshelf.Model.extend({\n   tableName: 'users'\n});\nnew User({id: 1}).fetch().then(function(user) {\n  console.log(JSON.stringify(user)); // user with id of 1\n})\nUser.collection().fetch().then(function(users) {\n   console.log(JSON.stringify(users)); // collection of users\n})\n```\n. As of 0.6.4 you can do:\njs\nCustomer.collection().fetch().then(...\nor if you create a collection with the customer model as the target, you can do \njs\nnew Customers().fetch()\nif you need to limit, etc, you can do:\n``` js\nvar customers = Customer.collection();\ncustomers.query('where', 'id', '>', 100).fetch().then(...\n```\n. As of 0.6.4 you can do:\njs\nCustomer.collection().fetch().then(...\nor if you create a collection with the customer model as the target, you can do \njs\nnew Customers().fetch()\nif you need to limit, etc, you can do:\n``` js\nvar customers = Customer.collection();\ncustomers.query('where', 'id', '>', 100).fetch().then(...\n```\n. Yeah, let me see what I can do about that.\n. Yeah, let me see what I can do about that.\n. Can you maybe add a few tests for this, so when the whole relations internals inevitably get refactored this use case doesn't get overlooked.\n. Can you maybe add a few tests for this, so when the whole relations internals inevitably get refactored this use case doesn't get overlooked.\n. Yeah, I may add it at some point though still undecided...\n. Hey @bogus34 definitely appreciate the willingness to contribute, and the various tickets you've opened in the last few months (and bookshelf-fields plugin)... always helpful in getting input, hope it continues. I don't know if \"berated\" was really the right term, feel like Ben was being a bit dramatic there... I think everyone could just take a step back and remember, it's just javascript :)\nI personally wouldn't have closed the ticket, so when I saw it was closed, I just didn't feel like reopening another ticket that has been closed before I would have liked... so I just made a mental note about it.\nI tend to agree with you that the model/relation life-cycles haven't been fully thought out. I've been toying around with a big overhaul of relations which drops the entire \"relations\" and \"eager\" classes entirely and instead splits each relation into its own class. Each of these classes would have a well defined interface for the fetching / loading / pairing of models, so everything is really consistent. This should also be more efficient and give much better visibility into the relation state, provides a consistent way of defining new relation types. This would also be the suitable place to introduce events associated with eager loading. So on that front, and to ditch this ticket which has gotten quite derailed, I've opened #253.\n@bendrucker I'd prefer if tickets in both projects are kept open unless clearly closable (I don't even think I saw the #241 you referenced as to why it's not supported). Again, this isn't a personal inbox, it's my repository... it's pretty much been my focus for about the last year and while I am super appreciative of the willingness to help, the fact is that it's not nearly at the state of being complete. Closing issues is easy, well thought out discussion on how to improve the underlying design is more difficult and what I'd prefer.\nAlso let's do less \"reprimanding\" of people's tone of voice in github tickets... sarcasm, language barriers and the like are not expressed well in tickets, and while it might be poor form to not be friendly regarding oss, it's equally as bad to react poorly... don't feed the trolls, so to speak.\n. Hey @bogus34 definitely appreciate the willingness to contribute, and the various tickets you've opened in the last few months (and bookshelf-fields plugin)... always helpful in getting input, hope it continues. I don't know if \"berated\" was really the right term, feel like Ben was being a bit dramatic there... I think everyone could just take a step back and remember, it's just javascript :)\nI personally wouldn't have closed the ticket, so when I saw it was closed, I just didn't feel like reopening another ticket that has been closed before I would have liked... so I just made a mental note about it.\nI tend to agree with you that the model/relation life-cycles haven't been fully thought out. I've been toying around with a big overhaul of relations which drops the entire \"relations\" and \"eager\" classes entirely and instead splits each relation into its own class. Each of these classes would have a well defined interface for the fetching / loading / pairing of models, so everything is really consistent. This should also be more efficient and give much better visibility into the relation state, provides a consistent way of defining new relation types. This would also be the suitable place to introduce events associated with eager loading. So on that front, and to ditch this ticket which has gotten quite derailed, I've opened #253.\n@bendrucker I'd prefer if tickets in both projects are kept open unless clearly closable (I don't even think I saw the #241 you referenced as to why it's not supported). Again, this isn't a personal inbox, it's my repository... it's pretty much been my focus for about the last year and while I am super appreciative of the willingness to help, the fact is that it's not nearly at the state of being complete. Closing issues is easy, well thought out discussion on how to improve the underlying design is more difficult and what I'd prefer.\nAlso let's do less \"reprimanding\" of people's tone of voice in github tickets... sarcasm, language barriers and the like are not expressed well in tickets, and while it might be poor form to not be friendly regarding oss, it's equally as bad to react poorly... don't feed the trolls, so to speak.\n. Yeah, that's the way to do it... though it'd be helpful to have a teardown method or something top level to make this a bit easier, I'll look into adding this.\n. Yeah, that's the way to do it... though it'd be helpful to have a teardown method or something top level to make this a bit easier, I'll look into adding this.\n. You should just be able to do this.followers().fetch().then(...\n. You should just be able to do this.followers().fetch().then(...\n. @jordwest can you post the actual code (not a simplified example). Also, is this happening with sqlite3 / does putting the transacting in the fetch options fix the issue?\n. @jordwest can you post the actual code (not a simplified example). Also, is this happening with sqlite3 / does putting the transacting in the fetch options fix the issue?\n. >  SQLite blocks on transactions and so while a transaction is active all queries must be run inside it. \nYeah, that's only because I've set the pool max 1 for sqlite3, so really the issue is that once you start a transaction, it's grabbed the only connection allocated to sqlite3 and then if you try to run another query (inside or outside of the connection), it's waiting around for the transaction connection to be freed...\n\nSQLite can't do that. It locks at the file level, not connection.\n\nThat link also references the newer Write Ahead Logging mechanism which I've played around with but wasn't able to get fully working, hopefully in the future that'll be supported so we can bump the pool size a bit.\n. Is that the actual code? Because there's all sorts of javascript syntax errors in it... \n}), {transacting: t}) -> }, {transacting: t})\n},\n   t.rollback({\nto\n}, function() {\n   t.rollback({\n}\n. Is that the actual code? Because there's all sorts of javascript syntax errors in it... \n}), {transacting: t}) -> }, {transacting: t})\n},\n   t.rollback({\nto\n}, function() {\n   t.rollback({\n}\n. Oh, there's a difference there... in the case in the docs, t.rollback isn't being invoked... e.g.\njs\n.then(function(rows) {\nt.commit([model.get('name'), rows.length]);\n}, t.rollback);\nthat works...\njs\n.then(function(rows) {\nt.commit([model.get('name'), rows.length]);\n}, t.rollback());\ndoesn't... but I guess I could make this a bit clearer.\n. Oh, there's a difference there... in the case in the docs, t.rollback isn't being invoked... e.g.\njs\n.then(function(rows) {\nt.commit([model.get('name'), rows.length]);\n}, t.rollback);\nthat works...\njs\n.then(function(rows) {\nt.commit([model.get('name'), rows.length]);\n}, t.rollback());\ndoesn't... but I guess I could make this a bit clearer.\n. Could you make this part of a lifecycle event, for example on fetched or saving?\njs\nvar Link = Model.extend({\n   initialize: function() {\n       this.on('fetched saving', this.checkLink);\n   },\n   checkLink: function(model) {\n     if (_.isEmpty(model.get('link'))) {\n       return SomePromiseCall(model).then(function(someUrl) {\n         model.set('link', someUrl);\n       });\n     }\n   }\n});\n. Yep, the \"fetch\" event happens here when fetching an individual model and here on a collection, well before toJSON (toJSON basically just preps whatever the state of the model is for stringification)... so depending on where you're fetching one or more models you might have to put it in one of these locations. \nAll events are fired with triggerThen which allow you to return a promise before resolving the fetch.\nA caveat is that these events don't occur on eager loads, but you could probably bind the event to whatever the parent model/collection is and run it on the child models.\n. Thanks, awesome to hear! Look forward to it!\n. So you should actually be able to do this with events...\njs\nvar User = Model.extend({\n   initialize: function() {\n      this.on('saving', this.beforeSave);\n   }\n});\nAny of the lifecycle events are actually using trigger-then a promise-aware events implementation such that it waits if a promise is returned in any of the event handlers, and rejects the saving action if an error is thrown or a rejected promise is returned in any handler.\nLet me know if this sounds good for what you're looking for.\n. Good idea, thanks!\n. Good idea, thanks!\n. Nice, you may also be interested in checking out the (non-bookshelf specific) authorization lib I've written here - https://github.com/tgriesser/granted\nStill a few things I might change, like allowing non === true to count as successful, but the base api should remain the way it is now. It's been quite a clean/flexible approach to auth.\n. You actually need to use user.related('roles')... when a relation is eager loaded it gets added to the relations object on the model, meaning it'd be under user.relations['roles'].\nLet me know if that helps you out.\n. Great, thanks! Glad you got it sorted. Also make sure you're returning user.related('roles') at the bottom there (not user.roles(), that would create a fresh collection).\n. @bavidar sorry, so is \"type\" dynamic, like coming from the DB, or just dynamic per model... I'm not seeing how you'd easily add it if it were actually static, but for instance could you do this:\n``` coffee\nclass BaseModel extends Model\n   toJSON: ->\n     json = super\n     if @type then json.object = @type\n     json\nclass Address extends BaseModel\n    type: 'address'\nclass OtherType extends BaseModel\n    type: 'othertype'\n``\n. The one I wrote implementstoJSON` on a base model which the other classes inherit from.\nAnd it's in coffeescript so it's like a million less lines of code :P\n. Oh, missed that. Yep, that should do it :)\n. The second example there should be:\njs\nUsers.forge().query({where: {admin_id: req.locals.admin.id}).fetch({withRelated: ['messages']})\nAs for the first, I'm not sure, is the value of req.locals.admin.attributes.id also 1?\nAlso, take a look at the first question in the faq and see if that answers it http://bookshelfjs.org/#faq\n. What version of bookshelf & knex are you using?\n. Okay, so your code is pretty difficult to follow, you're using bind all over the place, which you really shouldn't need to do, for example here:\njs\nconsole.log(this);\n        return this.fetch({\n          //withRelated: 'driverProfile',\n          require: true\n        })\n        .catch(function(e) {\n          console.log('ERROR RETRIEVING DRIVER PROFILE: ', e);\n          return this;\n        })\nThe \"this\" in that fetch isn't the driver profile, it's the user, so your error log is likely incorrect.\nAlso, triggerThen is not meant to be called with a context:\njs\nreturn user.triggerThen.apply(user, ['roleAdded', role]).then(function() {\n    return user;\n});\nYou should also look into to using node-inspector... you shouldn't really ever be debugging javascript with console.log's\n. Just don't do var foo = new Thing(), instead do\njs\nnew User().save()\n   .then(function(user){\n      return user.thing().save();\n   })\n   .then(function(foo) {...\nYou can also use user.related('thing') if you want the thing added to the user's relations hash.\n. Yeah guess I missed that, though that should be _.omit.apply(_, [Backbone.Model.prototype].concat(modelOmitted)), right?\n. Great, thanks!\n. So this was brought up in #212 and changed in #226...\nI guess (and let me know if you have a different idea on how this should work here) I couldn't imagine any situation where you'd actually be wanting to be basing an association on a null key.\nIf you have a good case I'd consider reverting, since the previous behavior wasn't actually breaking anything, just executing an extraneous query.\n. Oh, so you're saying the nulls should be filtered out of the where in section of the query?\n. I'll get to it in a little later today.\n. Hey @aef- thanks for the ticket... yep, as @bendrucker mentioned, since Bookshelf isn't necessarily looking to keep track of all of your tables/models, this is something you'd need to go about yourself.\nCould make a neat plugin though.\n. Okay, I generally like the idea... you're conditionally creating the uuid in the constructor, and then calling set with the rest of the attrs... makes sense.\nOne issue I see is that it has slightly different semantics as the generateId that Backbone has waiting around in master with jashkenas/backbone/pull/2985, and as I see that change as being part of a potential solution for composite keys, I'm wondering if it makes sense to name this something different.\nThe other thing I'm thinking is whether it might make more sense to implement this as an official plugin rather than on the model directly, though I guess you'd need some way to tap into the set method.\nAlso, what would happen if you created a model with a uuid column and then unset its uuid. Not saying that's a good idea, but I believe the model would still read as being model.isNew() === false\n. Yeah, the callback should be called with the entire transaction body as the target, so using exec:\njs\nBookshelf.transaction(function (transaction) {\n  Customer.forge()\n    .save(customer, {transacting: transaction}).exec(function (error, customer) {\n        if (error) {\n          transaction.rollback(customer);\n        } else {\n          transaction.commit(customer);\n        }\n    });\n}).exec(callback);\nAlthough just to point it out, promises cut this down a few lines...\njs\nBookshelf.transaction(function (transaction) {\n  Customer.forge()\n    .save(customer, {transacting: transaction})\n    .then(transaction.commit)\n    .catch(transaction.rollback);\n}).exec(callback);\n. Okay, I'll take a look.\n. @FabricioFFC just bumped knex to 0.5.10 which now has the \"exec\" method on all promise instances, if you get that you should be good.\n. When the callback is executed the transaction is over, yes.\n. Hmm, this has to do with @johanneslumpe's updatePivot method using the query if one is provided on the options object (which happens internally in the same method that detach, attach, etc. use).\nThe long term solution will be to give the ability to work on pivot tables directly, with something like: \njs\nnewPost.tags().pivot().query(/*some query*/).detach(tagsToDetach, options);\n... but in the meantime doing \njs\ntagOperations.push(newPost.tags().detach(tagsToDetach, _.omit(options, 'query')));\nshould suffice.\n. Oops, thanks.\n. When you're calling Account.collection, you're defining an instance of a collection, not an instance of a model. The initialize should be called when each of the models are created from the result of the collection's fetch call as they're added to the collection - are you not seeing that behavior?\n. > I override parse/format methods and if I declare instance variable in initialize method it becomes unavailable in parse method, so I get error.\nWould you be able to post a bit of code so we have a better sense of what you're looking to accomplish here?\n. Ok, and just to be sure I have the full context, can you show the code where you're extending the Base Model class, calling the Account.collection.fetch()?\n. Oh, I see now, it's because parse is called before initialize.\n. Change your code to this and it should work:\njs\nmodule.exports = function(Db, _) {\n  return Db.Model.extend({\n    constructor: function() {\n      this._transforms = {};\n      this._transformers = {\n        point: { \n          parse: function(val) {\n            if (val) {\n              var values = val.replace('(', '').replace(')', '').split(',');\n              return {\n                lat: parseFloat(values[0]),\n                lon: parseFloat(values[1])\n              };\n            }\n            return val;\n          },\n          format: function(val) {\n            return '(' + val.lat + ',' + val.lon + ')';\n          }\n        }\n      };\n      DB.Model.apply(this, arguments);\n    },\n    // ... rest of code omitted\n  });\n}\n. No, not missing something too obvious...\nSo the vision here was that Bookshelf is ultimately not meant to be an Active Record implementation, but rather an implementation of the Data Mapper pattern. It hasn't quite lived up to that, still needs a bit of work to truly make it data-store agnostic and define a useful way of adding additional adapters. \nThat though, is the main reason there aren't any SQL specific methods directly on the library (less the relations methods, which are sort of necessary for the time being). My hesitation in minting too many methods was that once they're added they're more difficult to deprecate, so I figured I'd give the bare-bones, when in javascript, adding something like find is as simple as:\njs\nModel.find = function(id, options) {\n   if (_.isArray(id)) return this.collection().whereIn('id', id).fetch(options):\n   return new this({id: id}).fetch(options);\n}\nThe other reason is that there's a library which I've been cooking up for awhile and which is finally starting to take a bit of shape, which extends the foundation laid out by Bookshelf and basically acts as a 1-to-1 with all of the familiar Active Record functionality find, findOrCreate, findBy, all of the \"SQL\" clauses to start the chain, scopes, validations, etc, including getter/setters for an easier way of dealing with result sets. \nIt's likely still at least a few weeks out, as soon as I have something ready for preview I'll ping you and @tkellen - I'm hoping to get it launched sooner rather than later, as I recognize it's something a lot of people are after.\nSome of the main difficulties there lie in the relations, and being able to infer details when doing something like:\njs\nUser.where('email', 'foo@bar.com').accounts.active.fetch().then(...\nwhich expands to:\njs\nUser.where('email', 'foo@bar.com').related('accounts').scope('active').fetch(...\nshould ultimately result in:\nsql\n// SELECT * FROM accounts\n// JOIN accounts ON accounts_users.account_id = accounts.id\n// JOIN users ON accounts_users.id = users.id \n// WHERE accounts.status = 'active'\n// AND users.email = foo@bar.com\nSo I agree, there could definitely be a much easier way to do things, and a plugin could be useful in the meantime to cover the more generic cases.\nI just wanted to keep the layers fairly distinct knex -> bookshelf -> active record layer, so you could choose how opinionated you wanted to go at each layer.\nA number of people have asked about it, and I have kept saying it's coming, but I'm really making a push to get it done soon, just a lot of details to try and work out :)\n. Alright, well you don't need to anymore. where has been added to the model as both a static and prototype method, query as a static method, and findAll as a prototype method. With this, you can now do:\n``` js\nUser.where('id', 1).fetch(...\nUser.where('active', true).fetchAll(...\nUser.query({whereRaw: ['some raw query ?', binding], orWhere: ['key', '>', 'value']}).fetchAll(...\n```\nThis means you really shouldn't need to instantiate collections often, if at all, and the where method adds support for the most common case.\nThis should be a nice holdover without adding too much to the API until the library with more of the chaining, opinions, etc. is finished\n. Yeah they should be updated with a few examples, if you see that it's missing some feel free to open a PR with clarifications.\n. You can do either.\n. The issue here is that the relation constraints aren't explicitly added to the query string, but rather determined at the time the model is fetched or persisted. This is a flaw in the current design of the knex builder, and I've been working on re-architecting some things internally to take care of this case. I'll keep this one open to let you know when it works as expected.\n. Can you post an example bit of code illustrating the issue?\n. If the promises aren't returned in the handler then the handler can't know when they've been fulfilled or rejected:\n``` js\non_saving: function(model, attrs, options){\n    var self = this;\n    // change Gender\n    if (this.get('gender') === 'male'))\n        this.set('gender', 'M');\n    else if (this.get('gender') === 'female')\n        this.set('gender', 'F');\n// serialize extra attributes into json field\nvar extras = self.omit(self.permitted_attributes);\nself.attributes = self.pick(self.permitted_attributes);\n\nif (!_.isEmpty(extras))\n  self.attributes.json = JSON.stringify(extras);\nif (self.attributes.document && !HSM.is_encrypted(self.attributes.document)){\n  return HSM.hash(self.attributes.document)\n    .then(function(hashed){\n      self.attributes.document_hash = hashed;\n      return HSM.encrypt(self.attributes.document)\n    }).then(function(cipher){\n      self.attributes.document = cipher;\n    });\n}\n\n}\n```\nAlso, .then with two arguments is an anti-pattern:\nhttps://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-thensuccess-fail-anti-pattern\nBest to use .then(handler).catch(handler):\njs\nuser = Hoek.applyToDefaults(about_me, user);\nBookshelf.transaction(function(t) {\n  new User(user)\n    .save(null, {transacting: t})\n    .then(function(user){\n      user = usr.toJSON();\n      delete user.json\n      credential.user_id = user.id;\n      return new Credential(credential).save(null, {transacting: t})\n          .then(function(cred) {\n              return User.generate_otp(user.id)\n          }).then(function(otp){\n            user.otp = otp;\n            t.commit(user);\n          });\n      });\n    }).catch(t.rollback);\n}).then(function(user){\n  reply(user).code(201).header('Location', '/users/' + user.id);\n}).catch(function(err){\n  if (/^ER_DUP_ENTRY: Duplicate entry/.test(err.message))\n    reply(Hapi.error.conflict(err.clientError.message));\n  else\n    reply(Hapi.error.badRequest(err.message));\n});\n. Yep, see #221, this will be coming soonish, though we'll likely need to come up with a convention around alternate ways of determining error types, since especially in node with potentially different library versions, hard instanceof checks can be misleading.\n. Does changing \njs\nif (self.attributes.password){\nto\njs\nif (this.has('password') && this.get('password')) {\nor moving the delete below the if conditional fix it? First guess is that the this.attributes.password is a falsy value so the field still exists when saving.\n. Patch only uses the attrs specified in the save so you'll need to do \ndelete attrs.password\nin your saving event as well.\nHowever, this all seems to be an anti-pattern, you should probably just be hashing the password elsewhere and then set the token field, never actually setting a password property on your model to then just need to delete it anyway.\njs\nvar Credential = Bookshelf.Model.extend({\n  softDelete: 'deleted_at',\n  tableName: 'credentials',\n  hasTimestamps: ['created_at', 'updated_at'],\n  owner: function(){\n    return this.belongsTo(User)\n  },\n  updatePassword: function(password, options) {\n    var model = this;\n    // assumes you've done Promise.promisifyAll(bcrypt) [1]\n    return bcrypt.hashAsync(password, 10).then(function(token) {\n       return model.save({token: token}, _.extend(options, {patch: true}));\n    });\n  }\n});\n[1]: Info about promisifyAll\n. Correct, and it's an anti-pattern because generally you should only be setting attributes on the model which are database columns. It's not really straightforward that you're setting an attribute, just to go and change it to something else and ultimately needing to delete it before saving. It'd be easier to just not set it in the first place.\nLook at the difference between:\njs\ninitialize: function(){\n  this.on('saving', this.on_saving, this);\n},\non_saving: function(model, attrs, options){\n  var self = this;\n  if (self.attributes.password){\n    self.set('token', bcrypt.hashSync(self.attributes.password, 10));\n    self.set('password', undefined);\n    delete self.attributes.password;\n  }\n}\nand\njs\nsavePassword: function(password, options) {\n  var model = this;\n  return bcrypt.hashAsync(password, 10).then(function(token) {\n     return model.save({token: token}, _.extend({}, options, {patch: true}));\n  });\n}\n. Yep, you should just be able to access it as Model.prototype.tableName, if you'd like to assign it yourself, you can feel free to:\njs\nvar User = Model.extend({\n  tableName: 'users'\n});\nUser._tableName = User.prototype.tableName\n. There's  forShare and forUpdate which do the appropriate locking on postgres & mysql, but they're only made available after you call .transacting.\n\nWhy do you want to do it?\n\nWhy does anyone want to use a relational database... ACID\nA little fast there on the close button :D\n. Two things, the javascript for the Customer.saveRelations is executing before anything else there, unlike the transaction.commit or transaction.rollback which are functions, you're actually calling a function and passing that into the \"then\", so unless that's creating some sort of closure, that's likely incorrect.\nAlso, the transaction has to be passed as a property of an options object, i.e. {transacting: transaction}\nThis should work:\njs\nCustomer.forge()\n        .save(customer, {transacting: transaction})\n        .then(function(customer) {  // This is the model that was just saved, if you want that.\n           return Customer.saveRelationships({transacting: transaction}, customer, relationsAttributes);\n        })\n        .then(transaction.commit)\n        .catch(transaction.rollback);\n. You should probably do this:\n``` js\nbaseBookshelf.transaction(function(transaction) {\n  Customer.forge()\n    .save(customer, {transacting: transaction})\n    .tap(function(customer) {\n       return customer.related('documents')\n          .set(relationsAttributes.documents).invokeThen('save', null, {transacting: t}));\n    .then(transaction.commit)\n    .catch(transaction.rollback);\n}).then(function(customer) {\n   console.log(customer.toJSON());\n}).catch(function(error) {\n});\n```\nTap is shorthand for:\njs\n.then(function(customer) {\n   return customer.someAction().then(function() {\n     return customer;\n   });\n})\ninvokeThen acts like invoke but with a promise, calls the save method on each item in the collection.\nThis assumes you have a \"documents\" relation set on your Customer object. If that isn't the case replace \njs\n return customer.related('documents')\n          .set(relationsAttributes.documents).invoke('save', null, {transacting: t}));\nwith \njs\nreturn Documents.forge(relationsAttributes.documents).invoke('save', null, {transacting: t}));\nwhere documents is a collection that has the model \"Document\".\n\nBut how can I call save N times, to save all the relation data?\n\nYou could also look into the bluebird api for utilities like reduce\n. Hmm, I don't know, I guess it depends on how you're trying to use \"previous\"... presumably you could do this:\njs\nvar previous;\nvar model = new Models.Site({id: 1});\n    return model.fetch().then(function() {\n      previous = this.get('name')\n      return model.save({\n        name: 'updatedknexjs.org'\n      });\n    })\n    .then(function (u) {\n      equal(previous, 'knexjs.org');\n      equal(model.get('name'), 'updatedknexjs.org');\n      model.set('name', 'knexjs.org');\n      return model.save();\n    });\nor this:\njs\nvar previousAttrs;\nvar model = new Models.Site({id: 1});\n    return model.fetch().then(function() {\n      model.set(someValues)\n      previousAttrs = this.previousAttributes();\n      return model.save();\n    })\n    .then(function (u) {\n      // compare previousAttrs here\n      equal(model.get('name'), 'updatedknexjs.org');\n      return model.save();\n    });\nwould either of these work?\n. In the saved event, it puts the previousAttributes on the options object incase you need them for something like this: link\n. Cool.\n. Nope, async only... what's the case where you'd want that?\n. Maybe just wrap whatever functions you need with Promise.method and turn them into then-ables returning promises?\n. > Not understanding why introducing a database or a technology like nodeJS suddenly means everything must be async?\nEverything async is pretty much the definition of node.js\nIt's single threaded, so every time you're doing something that isn't within the javascript program execution (filesystem, database, i/o, child processes), they're meant/required to be offloaded and handled with events/callbacks. Any of the *Sync methods (fs.readDirSync and the like) are legacy and probably shouldn't have been introduced to begin with, but they're not going anywhere at this point.\nBy doing things sync, not only are you blocking the \"event loop\" and losing all the benefits of the time gained by not waiting for I/O, but it's compounded by the fact that you only have a single execution context and javascript isn't as fast as other compiled languages to begin with... so it becomes massively slow. Promises help to abstract this and make async code nicer to deal with and behave much more functionally and closer to sync code, which is why I've adopted them over callbacks for Bookshelf / Knex.\nBut yeah, that's the major differentiator of node, because everything is forced to be async, everything is async and you don't have the issues as you do in other languages where some libraries are async/event driven and others aren't and then it becomes a mess pairing them together.\n\nWhy should it need to be async? If there is a function for each DB table, why shouldn't I structure my code to simply say \"Here are my inputs, give me some output\"?\n\nThe command line might not be the best example, but even in that case, by doing things async you can say here are a bunch of queries to execute, offload them all at once to the databases and resolve when they've all come back and pipe to stdout, vs. saying do a query, wait for the result, do a query wait for the result, etc.\n. Also, if you want the total models in just the collection returned, as in with fetch, you can just checkout the collection.length property\n. Should work locally if you npm link the 0.6 branch\n. Yeah, the docs were wrong on that, sorry about that... Just updated them.\n. Sure thing!\n. Can you post an example? I was fairly sure they were included, but I could be wrong.\n. I'm actually thinking it might just be best to drop this complex set method carried over from Backbone and just have it essentially reset the models in the collection. Are there any cases where you actually want to use set to use this smart update / remove / de-dupe feature that it has now?\n. Cool, so in 0.8 this \"smart update\" behavior will likely be moved to a separate method, update in favor of trimming down set, which you'll be able to access with .fetch({update: true}) \nFor now this should behave as you'd expect / is available in 0.7.3. \nThanks!\n. Because now that knex 0.6 is released, if you install a copy locally and initialize it and then pass it into Bookshelf, it will error (which is what must have happened in @majimboo's case). Or if you install it locally and then install bookshelf, Bookshelf will have it's own separate version of Knex which ends up causing a lot of weird inconsistencies if you have 2 independent database pools / versions of knex you're working with in the same app.\nThe ability to initialize Bookshelf with just a plain object will be deprecated, the new way to do it is to explicitly require knex, initialize there, and then pass that object into bookshelf.\njs\nvar knex = require('knex')(dbConfig);\nvar bookshelf = require('bookshelf')(knex);\nFor version 0.7, the current approach will still work and console.log a warning saying that the syntax is deprecated.\nI wanted to throw the peerDependencies up for now for 0.6 make clear that if you're installing both as peers, you can't have invalid versions. To that end, it did it's job, in 0.7+ there will be an explicit semver check on the knex object.\n. Added as omitPivot in 0.7.6\n. Added as omitPivot in 0.7.6\n. Just a heads up, you may want to change this to:\n``` js\nvar model = ItemModel.forge().query(function(qb) {\n  qb.innerJoin('items_tags', 'items.id', 'items_tags.item_id')\n    .innerJoin('tags', 'items_tags.tag_id', 'tags.id')\n    .groupBy('items.id')\n    .orderBy('items.id', 'asc');\nif (tags && tags.length > 0) {\n    qb.whereIn('tags.name', tags).where(function () {\n      this.where('tags.condition', true);\n      this.orWhere('tags.otherId', otherId);\n    });\n  }\n});\nvar result = yield model.fetchAll();\n```\nAt some point down the line, probably a ways off, model.query() will actually return a unique knex instance rather than returning the internal query chain for the current model.\n. Basically you can think of it as... does the interim table have a primary key, if yes then you can use .through, if no then use .belongsToMany - hasMany.through is basically just sugar for an extra related join. \nI'd actually eventually like to deprecate through if possible actually and replace it a more consistent relation pattern all around.\nIf it's a many-to-many where the joining table has a primary key, you'd use model.belongsToMany(OtherModel).through(PivotModel) - which I think is what you're after in the last question there.\n. > I'm not understanding why a primary key on the join table matters. \nRight, you shouldn't be using .through unless the model has a primary key, as to what the actual columns are, I agree it's a bit ambiguous, the relations are next on my list of things to refactor / document.\n. That looks about right, except you can use both, hidden just takes precedence over something marked visible.\nSee the test cases here\n\nIn the case that I had an actual database field named hidden or visible, how would I escape it?\n\nWouldn't need to, as for now all of the attributes are accessed via .get and stored in this.attributes\n. Cool, thanks!\n. Just fyi, you can alternatively load a plugin via: \njs\nbookshelf.plugin('visibility')\nor multiple plugins at once:\njs\nbookshelf.plugin(['visibility', 'registry', 'virtuals', 'some-external-plugin'])\n. The test case was incorrect checking for the wrong message, should be fixed now - thanks!\n. The test case was incorrect checking for the wrong message, should be fixed now - thanks!\n. I'm not sure I follow the question / use case entirely, but if you're asking how to retrieve the columns for a table, you do that like so:\njs\nknex('data').columnInfo().then(function(columns) {\n  Db.Data = Orm.Model.extend({\n    tableName: 'data'\n  , columns: _.keys(columns)\n  , format: zipXattrs\n  , parse: inflateXattrs\n  });  \n});\nthough you'd just need to manage the fact that the definition of your models is now async.\nOr you could just set the columns attribute on the table definition and refer to it from this.columns\n. Can you provide a quick example of the behavior, just so I can confirm what the behavior should be?\n. What is the use case for needing to read the changed attribute when calling with save.\nI'm curious because I'm planing to change around the semantics around some of the lifecycle pieces and I'm wondering how people are using things like this. I'm also looking at potentially changing the save method signature to just save(options), where all attributes will need to have been set earlier.\n. Yeah I've actually already got Backbone pulled out locally, just pushed that to an 0.8 branch in case anyone wants to take a look, though it's just preliminary - there will be much bigger changes related to simplifying the code for relations and extracting persistence logic into it's own layer, as well as a few minor api changes.\nRelated to the events hash thing, I've got some ideas for something like that but it won't be a part of Bookshelf, it'll live in the beefed up active-recordish layer that will sit on top of bookshelf. I'll keep this one open just so anyone looking around the tickets can get this info.\n. Yeah, I think dates might need to be documented a bit better between knex / bookshelf - they can just be a bit tricky when trying to standardize between different databases when needing to account for the time on the server vs the database (shouldn't be an issue with datetime though), different environments, and the client vs the server. \nSo first, I'm a bit confused - because those values aren't equal... \njs\nnew Date('Sat May 11 2019 00:00:00 GMT-0700 (PDT)').valueOf() !== \n   new Date('Sat May 11 2019 17:00:00 GMT-0700 (PDT)').valueOf()\nWhen you say \"After I save to Bookshelf I get:\" do you mean after you save and then fetch from the database?\nAt what stage are these dates being parsed, and which database are you using.\n. Is the actual column type a timestamp or timestamptz - note the disucussion here https://github.com/tgriesser/knex/issues/184 and the change in knex 0.6 to use timestamptz by default.\n. I think you'd probably either need to use a different type which keeps track of the timezone or explicitly set the date object you want to save in the format method with new Date(yyyy, mm, dd)\nThere were a few issues that looked related in node-postgres https://github.com/brianc/node-postgres/issues/510 and https://github.com/brianc/node-postgres/pull/514\nAs @brianc says at the bottom there \"Timezones & string encodings are hard!\"\n. Great\n. Currently you should just get the schedule from the appt to begin with:\njs\nappt.set('next', next);\nappt.set('scheduleId', scheduleId);\nschedule = appt.related('schedule')\n// do things with schedule\nrather than as a separate object. I am currently in the process of refining a bunch of the relation stuff though, so I'll take a look at this ticket when I get to the attach/detach cases.\n. Then you must not be referencing a valid model in your belongsTo\n. You're not returning the belongsTo\n. This: \njs\nappt.related('schedule').attach(schedule)\nIs essentially saying attach schedule to schedule. Attach is currently only relevant in many-to-many relations (the api may change here), but really you should just be using the schedule object returned by appt.related('schedule') because it's already attached to appt.\n. I guess appt.relations.schedule = schedule or appt.related('schedule').set(schedule.attributes) would do the trick. \nThis'll be laid out a bit more cleanly in the next release.\n. @vladimiry a belongsToMany relation is the only one which supports attach right now.\nYou'll need to do something like:\njs\ncontent = new Content({\n  title: inputStream.filename\n});\ncontent.save().tap(function(content) {\n  return content.related('owner').create(req.user);\n}).then(function(content) {\n  // ...\n})\nBetter support for attach will be made available in the future.\n. Sorry, the above example is likely incorrect, assuming req.user is a model you likely want to define the inverse relation and do something more like:\njs\nreq.user.content().set({\n  title: inputStream.filename\n}).save()\n. Yeah, this is incorrect. I'm going to actually provide support for camel casing the keys directly in the library in the upcoming minor version, but in the meantime I'll see if I can fix this one. Thanks for the test case.\n. First / last would just be a matter of doing a:\njs\n// or whatever the ordering conditionals are...\nModel.query({orderBy: ['updated_at', 'asc']).fetch().then(function(model) { ...\ncorrect? In this case I think they'll be left off of Bookshelf for now, since they can be added pretty easily:\njs\nModel.first = function(options) {\n  return new this().first();\n};\nModel.prototype.first = function(field, options) {\n   return this.query({orderBy: [field || this.idAttribute, 'asc']}).fetch(options);\n};\nTrying to keep the API as minimal as possible for the time being as I'm still sorting out / robustifying the relation stuff internally to fix issues like #83, #366, #262, #141, etc...\nThough I think in the next minor version, allowing any knex parameters specified in the fetch options to be used in building the query.\n. Can you paste the stack trace?\n. I don't believe that throwing primitives is supported behavior with Bluebird. \nSee also, a string is not an error.\n. Either that or this is related to #389 which I need to look into, but yeah definitely always throw error objects rather than strings.\n. Give it a shot with the latest release.\n. You'd likely do that by wrapping the toJSON method,\njs\nvar Pet = bookshelf.Model.extend({\n  toJSON: function() {\n    var json = bookshelf.Model.prototype.toJSON.apply(this, arguments);\n    if (_.isEmpty(json.owner)) json.owner = null;\n    return json;\n  }\n});\n. Yeah I agree something along these lines would be useful, I'll think on it a bit and put it somewhere on the radar as soon as I get a bunch of the relation internals cleaned up.\n. > Is there a reason for this, or was this something that was planned in a future release?\nThis is intentional, as the join requires that you know all of the columns in advance, which bookshelf does not require, you'd need a good way of aliasing all of the columns such that there are no collisions, and then you'd need to iterate over the entire result set to deal with parsing/deduping the columns, which in javascript might actually be slower than dealing with the extra initial query. This is also how ActiveRecord generally deals with eager loading.\nBy making it two separate queries, you also gain the ability to easily constrain the subqueries at different levels, a la:\njs\ndb.User()\n .fetchAll({withRelated: [{\n    'roles': function(qb) {\n       qb.where('status', active);\n    }}, 'roles.info']\n  }).then(function (user) {\n    res.json(user);\n  });\nwhich would provide:\n`` sql\nselect * fromusers`;\nselect * from users_roles where users_roles.user_id in (?, ?) and status = 'active'\nselect * from info where role_id in (?, ?, ?...)\n```\nThere will however be improvements in coming releases, and the ability to do better joins for constraints will be provided (and possibly a simple way of doing something like you mentioned).\n\nIs it possible to do actual bulk updates:\n\nNot with Bookshelf, you'd do it with knex... the .query() method called with no arguments gives you a knex builder instance based on the current tableName...\njs\nUser.query()\n       .where('lastLoginDate', '<', moment().toDate().subtract('d', '60'))\n       .update({enabled: false}).then(...\n. Yeah, this is the same as #380 - I was holding off on merging just because the entire internals are going to change significantly regarding relations and pivot, etc. etc in the next minor version. But I guess I'll go ahead and merge that one to give an option for the time being, probably renaming to something like omitPivot and then just change the behavior later.\n. Yeah, @carldanley just brought this up to me tonight as well, I guess this might be a good FAQ add.\nBut yeah, calling knex.destroy(cb) should do it. Or process.exit which isn't as graceful but gets the job done.\nThe way to think about it is that opening pooled database connections is kind of like opening a new http server with .createServer... it won't exit until you tell it to, so you should just tell it to explicitly when your script is finished.\n. Agreed\n. The next version of Bookshelf I'm working on now will completely overhaul models & relations and add a few layers in between to keep track of related metadata reliably.\n. Thanks again @isaacdurazo!\nYeah 3 megs might be a bit much, if you want to include just the basic logo here, I just created a https://github.com/bookshelf/assets and added you as a collaborator if you want to put the more high-res graphics there. Or if you want to just add the files there I can pull in the smaller logo into the project.\n. Thanks @alliejanoch!\n. Yeah, I'd be fine with this.\n. Thanks, just changed it to just be the same as knex\n. Yeah, this will be something supported in the future but it's going to require a bit of retooling of the internals to do it properly. Definitely on the radar though.\n. Shouldn't you be returning the assertion to have it work correctly w/ mocha's promise handling?\n. Sure, @alliejanoch just curious what the use case is for these events?\n. Sure, @alliejanoch just curious what the use case is for these events?\n. I actually don't see why you'd ever want to sort using a comparator and not just with the order by clause in the query?\n. I actually don't see why you'd ever want to sort using a comparator and not just with the order by clause in the query?\n. >  I also shouldn't have to pass an \"ORDER BY\" clause each time I fetch the country\nIt's just incredibly inefficient to sort the result set in javascript rather than request it in the order you need... particularly when you can just do:\njs\nvar Country = bookshelf.Model.extend({\n    'states': function() {\n        return this.hasMany(States).query('orderBy', 'year_joined');\n    }\n});\n. It should default to ASC, what version of knex are you using with / what was the code caused the issue - I'd like to fix if that isn't the case?\n\nI agree that passing the sort within the query is the preferred approach, when possible.\n\nI think that's the argument against auto-sorting in this case... if you always sort by a comparator, you're automatically invalidating any orderBy clause that may have been conditionally applied to a query. I agree this could be better documented.\n. Oh, I know the default behavior in Backbone is to sort on fetch unless {sort: false} is passed, I'm just saying I don't really think that makes as much sense in this context where results can be sorted efficiently by a query engine rather than js.\nI'll look into that... the query order shouldn't be undefined there.\n. So I've been thinking a lot about Bookshelf features lately and I'm thinking this should probably something we provide out of the box (I'm going to create another discussion ticket with much more in-depth about what I'm thinking the direction of Bookshelf/features will be).\nCurrently you need to specify the columns by tapping into the knex query but that gets pretty hairy when you then need to include the relation columns... there are perfectly good reasons for not wanting every column fetched.\n. So I've been thinking a lot about Bookshelf features lately and I'm thinking this should probably something we provide out of the box (I'm going to create another discussion ticket with much more in-depth about what I'm thinking the direction of Bookshelf/features will be).\nCurrently you need to specify the columns by tapping into the knex query but that gets pretty hairy when you then need to include the relation columns... there are perfectly good reasons for not wanting every column fetched.\n. What's the use case, it seems like dynamically swapping out here would be a bad idea.\n. On the \"options\", transaction should be transacting, also by default now on the latest versions if you return a promise inside a transaction block, it automatically takes care of the commit / rollback for you.\nSee if this works:\njs\nreturn Bookshelf.transaction(function (t) {\n    return DB.Stats\n      .forge({ id: statId })\n      .fetch({ transacting: t })\n      .then(function (stat) {\n        nextTag = stat.get('nextTag');\n        return stat.save({ nextTag: (Number(stat.get('nextTag')) || 100) + 1 }, { transacting: t })\n      });\n}).then(function (m) {\n  console.log(stat.get('nextTag');\n}).catch(function(err) {\n  console.log(err);\n});\n. Thanks @werkt\n. It doesn't really make a difference, does it?\n. It doesn't really make a difference, does it?\n. Thanks @matyo91 \n. Thanks for the link @nareshbhatia - I will definitely take a look. I do have a lot of plans to simplify / robustify a lot of the stuff around the ORM, while maintaining the powerful api. Just haven't had time lately, but it's looking like October should be wide open to work on this stuff and get it closer to a 1.0\n. Thanks for the link @nareshbhatia - I will definitely take a look. I do have a lot of plans to simplify / robustify a lot of the stuff around the ORM, while maintaining the powerful api. Just haven't had time lately, but it's looking like October should be wide open to work on this stuff and get it closer to a 1.0\n. It sounds like you might want a listener on the created event?\n. It sounds like you might want a listener on the created event?\n. Ah, sorry, you want model.on('created', fn)\n. Ah, sorry, you want model.on('created', fn)\n. >  1 for survey and all questions + N for the number of questions from which to get answers. Feels like a lot of DB access.\nNope, Bookshelf should take care of the N + 1 query problem. Should only be 3 calls for the above, Survey, Questions, and Answers\nThere's also a shortcut for what you're doing above.\njs\nSurvey.fetch({withRelated: ['questions.answers'])\n.then(function(survey) {\n   // do something with survey, loaded with questions, \n   // each of which has answers\n})\nor if, for example you want to constrain on the questions or answers\njs\nSurvey.fetch({withRelated: ['questions': function(qb) {\n  qb.where('flagged', true)\n}, 'questions.answers'])\n.then(function(survey) {\n   // Loads all \"flagged\" questions, and their answers, still only 3 queries.\n})\nJust want to point out that for the time being, it's possible to run into the object-relational impedance mismatch problem if you fetch things too deeply... e.g. \"Users have many Surveys, have many Answers, which belong-to Users.\" - If the same user is fetched twice in that case it's a different model for potentially the same user entry in the db, so changing one won't change the other - which isn't ideal.\nI'm planning on addressing this with a session store for models when they're queried so all objects on the same graph will reference the same underlying record in the DB. This will also help with the saving - there is definitely a gap that needs to be filled for consistent nested saving of related models, currently you need to implement that yourself but I'd like to come up with something better this month.\n. >  1 for survey and all questions + N for the number of questions from which to get answers. Feels like a lot of DB access.\nNope, Bookshelf should take care of the N + 1 query problem. Should only be 3 calls for the above, Survey, Questions, and Answers\nThere's also a shortcut for what you're doing above.\njs\nSurvey.fetch({withRelated: ['questions.answers'])\n.then(function(survey) {\n   // do something with survey, loaded with questions, \n   // each of which has answers\n})\nor if, for example you want to constrain on the questions or answers\njs\nSurvey.fetch({withRelated: ['questions': function(qb) {\n  qb.where('flagged', true)\n}, 'questions.answers'])\n.then(function(survey) {\n   // Loads all \"flagged\" questions, and their answers, still only 3 queries.\n})\nJust want to point out that for the time being, it's possible to run into the object-relational impedance mismatch problem if you fetch things too deeply... e.g. \"Users have many Surveys, have many Answers, which belong-to Users.\" - If the same user is fetched twice in that case it's a different model for potentially the same user entry in the db, so changing one won't change the other - which isn't ideal.\nI'm planning on addressing this with a session store for models when they're queried so all objects on the same graph will reference the same underlying record in the DB. This will also help with the saving - there is definitely a gap that needs to be filled for consistent nested saving of related models, currently you need to implement that yourself but I'd like to come up with something better this month.\n. Hmm, can you add {debug: true} in your fetch call and let us know what the fetch is actually calling? \nAlso, if you don't need to reference instance in the final then, it's probably cleaner to do:\njs\nnew Model({id: 1}).fetch().then(function(instance) {\n  return doSomething().then(function() {\n    return instance.fetch();\n  });\n}).then(function(final) {\n  //final == null!\n})\n. Hmm, can you add {debug: true} in your fetch call and let us know what the fetch is actually calling? \nAlso, if you don't need to reference instance in the final then, it's probably cleaner to do:\njs\nnew Model({id: 1}).fetch().then(function(instance) {\n  return doSomething().then(function() {\n    return instance.fetch();\n  });\n}).then(function(final) {\n  //final == null!\n})\n. If you listen on the fetched event, you can throw an error / return a rejected promise, say something like a stale error:\n``` js\nvar createError = require('create-error');\nvar StaleError  = createError('StaleError');\nmodel\n  .on('fetched', function(model) {\n     // if the data is stale, throw a StaleError;\n  })\n  .fetch()\n  .then(function() {\n    // ... success\n  })\n  .catch(StaleError, function() {\n    // Return a promise which hits the api to refresh and re-runs this chain.\n  })\n  .catch(function(err) {\n    // ...\n  })\n```\n@bendrucker if you don't mind keeping this ticket open, I'm in the process working on a new library that will provide a much simpler / robust backing architecture for this library, and I'm starting to collect a bunch of different use cases / tests... the more tickets that are left open the more I can use as data points for considering different cases.\n. If you listen on the fetched event, you can throw an error / return a rejected promise, say something like a stale error:\n``` js\nvar createError = require('create-error');\nvar StaleError  = createError('StaleError');\nmodel\n  .on('fetched', function(model) {\n     // if the data is stale, throw a StaleError;\n  })\n  .fetch()\n  .then(function() {\n    // ... success\n  })\n  .catch(StaleError, function() {\n    // Return a promise which hits the api to refresh and re-runs this chain.\n  })\n  .catch(function(err) {\n    // ...\n  })\n```\n@bendrucker if you don't mind keeping this ticket open, I'm in the process working on a new library that will provide a much simpler / robust backing architecture for this library, and I'm starting to collect a bunch of different use cases / tests... the more tickets that are left open the more I can use as data points for considering different cases.\n. Yeah, it'd probably be better served elsewhere, but it is possible to do it this way as well.\n. Yeah, it'd probably be better served elsewhere, but it is possible to do it this way as well.\n. Yes there are plans for this - except it's not going to be a plugin, it'll probably be be a core thing you can opt-in to.\nBasically, there are a lot of flaws in the current implementation of Bookshelf that aren't easily addressed with the current architecture... mainly relations (they're inconsistent and limited), object identity (nested saving, etc.), being able to properly cache (due to the object identity), and the need for some sort of schema definition. Because each model in a relationship tree is backed by a different attributes object, lots of issues can arise and it becomes tricky/impossible to properly cache / invalidate cache in a single place.\nI'm in the process of working on a solid foundation that will serve as more of a generic data-mapper and follow the unit-of-work pattern similar to SQLAlchemy for more efficient persistence, helping keep object identity consistent among individual models and fix a lot of issues like composite keys, complex relationships, and even generalize different protocols for these things to the point where it'll be possible to extend Bookshelf to multiple databases (and caches).\nI'll get the repository up once I get a little further with it, at which point I'll ping you on this ticket to get your thoughts on putting something together for redis.\n. Yes there are plans for this - except it's not going to be a plugin, it'll probably be be a core thing you can opt-in to.\nBasically, there are a lot of flaws in the current implementation of Bookshelf that aren't easily addressed with the current architecture... mainly relations (they're inconsistent and limited), object identity (nested saving, etc.), being able to properly cache (due to the object identity), and the need for some sort of schema definition. Because each model in a relationship tree is backed by a different attributes object, lots of issues can arise and it becomes tricky/impossible to properly cache / invalidate cache in a single place.\nI'm in the process of working on a solid foundation that will serve as more of a generic data-mapper and follow the unit-of-work pattern similar to SQLAlchemy for more efficient persistence, helping keep object identity consistent among individual models and fix a lot of issues like composite keys, complex relationships, and even generalize different protocols for these things to the point where it'll be possible to extend Bookshelf to multiple databases (and caches).\nI'll get the repository up once I get a little further with it, at which point I'll ping you on this ticket to get your thoughts on putting something together for redis.\n. The current Bookshelf activerecord'y type layer will sit on top of the more datamapper-ish interface, since I know a lot of folks prefer:\njs\nUser.where({id: 1}).fetch().then(...);\nover something more verbose like (I really haven't finalized the api yet, there's a lot still to consider)\njs\nvar session = lib.createSession();\nvar adapter = session.useAdapter(knexAdapter);\nadapter.model('user').queueFetch({\n  where: {id: 1}\n});\nsession.sync().then(function(session) {\n  return session.getIn(['user', 1]);\n}).then(...);\nThis should actually simplify the Bookshelf codebase significantly as it won't need to worry as much about the implementation details of things like relationships or typecasting or database specific features. It'll also pave the way for adding many more convenience methods on Bookshelf's active record layer cleanly, without getting into a bunch of messy SQL specific code in each method (that's why I've been so hesitant to add a bunch of active-record'y methods like findOrCreate, etc., just to not get bogged down in having a huge surface area to the API)\nI'm not sure how the split will work yet between the projects, but they will be separate, but support for the current Bookshelf library as it stands won't go away, it'll just have different internals. \nA more robust DataMapper approach also opens up a ton of awesome possibilities between client-server code re-use, I'm pretty excited about it.\n. The current Bookshelf activerecord'y type layer will sit on top of the more datamapper-ish interface, since I know a lot of folks prefer:\njs\nUser.where({id: 1}).fetch().then(...);\nover something more verbose like (I really haven't finalized the api yet, there's a lot still to consider)\njs\nvar session = lib.createSession();\nvar adapter = session.useAdapter(knexAdapter);\nadapter.model('user').queueFetch({\n  where: {id: 1}\n});\nsession.sync().then(function(session) {\n  return session.getIn(['user', 1]);\n}).then(...);\nThis should actually simplify the Bookshelf codebase significantly as it won't need to worry as much about the implementation details of things like relationships or typecasting or database specific features. It'll also pave the way for adding many more convenience methods on Bookshelf's active record layer cleanly, without getting into a bunch of messy SQL specific code in each method (that's why I've been so hesitant to add a bunch of active-record'y methods like findOrCreate, etc., just to not get bogged down in having a huge surface area to the API)\nI'm not sure how the split will work yet between the projects, but they will be separate, but support for the current Bookshelf library as it stands won't go away, it'll just have different internals. \nA more robust DataMapper approach also opens up a ton of awesome possibilities between client-server code re-use, I'm pretty excited about it.\n. Just looking to understand the use-case here, I was considering dropping the comparator entirely, but figured it'd be easy enough to call sort yourself if needed. I don't see why you'd ever want to use a comparator instead of sorting in the actual query?\n. Just looking to understand the use-case here, I was considering dropping the comparator entirely, but figured it'd be easy enough to call sort yourself if needed. I don't see why you'd ever want to use a comparator instead of sorting in the actual query?\n. Television.prototype.tableName or just model.tableName once you create an instance.\n. That's a bug, but for now it should work if you do \nSecurity.fetchAll({columns: ['symbol', 'name']})\n. So are you just looking to do an immediate fetch after save?\n. Yeah, rethinking how all of this works is on my todo list for the foundation I've been working on (mentioned here). There will definitely be a supported case for this.\nIn the meantime, it's a bit hackish but if you add this to your code, does it seem to accomplish what you're looking for?\njs\nvar save = bookshelf.Model.prototype.save;\nbookshelf.Model.prototype.save = function() {\n   return save.apply(this, arguments).then(function(model) {\n     return model ? model.fetch() : model;\n   })\n};\n. I don't believe it should fetch based on every column if the ID is defined... I'll need to see what's up with that.\n. This would also work:\njs\nvar save = bookshelf.Model.prototype.save;\nbookshelf.Model.prototype.save = function() {\n   return save.apply(this, arguments).then(function(model) {\n     var id = model.id;\n     return model ? model.clear().set('id', id).fetch() : model;\n   })\n};\nBut I agree, this is a bug, I'll patch this to work as expected in the next minor version.\n. I'm half considering whether it'd make sense to normalize the \"returning\" behavior in knex, so that if you specify a returning value it always returns, even if it means a second query in non-pg db's. This would be useful for batch saving collections, which is definitely a missing feature in Bookshelf.\nIn order to do that in mysql you'd need to know if there's a value other than 1 set for auto_increment_offset and auto_increment_increment\n. If you don't need the object as a Bookshelf model it might be easiest to just do:\njs\nbookshelf.knex.select('h.symbol as symbol', 'h.quantity as quantity')\n  .from('holdings as h')\n  .where('h.symbol', 'AAPL')\n  .andWhere('h.fund_id', function() {\n     this.select('id').from('funds').where('symbol', 'TSTF')\n  })\n  .then(...\nOtherwise, you should be able to just do:\njs\nHolding.where({symbol: 'AAPL'}).query(function() {\n   this.where('holdings.fund_id', function() {\n     this.select('id').from('funds').where('symbol', 'TSTF');\n   })\n}).fetch({columns: ['symbol', 'quantity']}).then(...\n. Yeah, this will not work as the library is currently set up - but this is part of what is on the roadmap to be fixed by #552.\n. Yeah sorry I was just gonna add a test\n. Definitely making a bunch of progress on this actually, this is a goal of mine and will have something more concrete around this pretty soon.\n. Excellent bug report @luggage66!\nGetting a patch out for it right away!\n. Working on adding this in knex, will have something for this soon.\n. You'll need to also specify the join conditions:\njs\njoin('table_b', 'table_b.id', 'table_a.table_b_id')\nhttp://knexjs.org/#Builder-innerJoin\n. Not quite, it's something I'm actively working on right now, being able to use model objects as identifiers so you could can create arbitrary joins between different model objects. There's a lot to consider with this, and I'm currently refactoring knex to make this easier to support in Bookshelf.\nI'm hoping to have something for this pretty soon - I'll comment on this ticket once there's something available\n. Reopening for @ecgeiser :)\nAny thoughts on what you'd imagine as a good api here?\n. Yep, have made some progress on some new Bookshelf related things but still debating some of the api internals (dependent on some other refactoring I have in progress in knex).\nWill keep you posted on this.\n. Would setting them directly as properties on the model work? Rather than actually using .set?\n. I think the point was that you could supply your own if you wanted. Which I forget who i was talking with about the other day, possibly @joepie91 who was looking for something similar. \nI guess that seems like a reasonable enough request to have an error class per-constructor\n. It's fine, the next version of bookshelf is going to decorate constructors while maintaining support for ES6 extends, and drop simple-extend for a custom extend, so there's no problem in adding in a little bit of magic via .extended\n. If you drop the \"self\" in favor of \"this\" and not use _.capitalize since we are currently supporting back to 2.x version of lodash, and add a test I'll go ahead and merge.\n. Yeah - what Ben said (Hapi is pretty awesome), also worth noting that ES6 makes it look a bit nicer, take a look at babel if you're interested\njs\nfunction someMiddleware(req, res, next) {\n   req.user.load(['posts']).then(() => next()).catch(next);\n}\n. This should be fixed if you install/use knex 0.8.x - nothing major should have changed, the Bookshelf suite passes with it, give it a shot and let me know if it doesn't seem to fix things.\n. This should be fixed if you install/use knex 0.8.x - nothing major should have changed, the Bookshelf suite passes with it, give it a shot and let me know if it doesn't seem to fix things.\n. Yep - should work with attach\n. Yep - should work with attach\n. You can also do: if (hasOwnProperty.call(attributes, 'some_column_name')\n. So the answer is that no, there's currently not a way to definitively know whether a relation has been fetched and there should be, and while #407 asked the same question there wasn't a real answer there. \nSo yes there are ways to infer whether it may have been fetched as @ricardograca mentioned - but there should be a more well defined object bookkeeping system in place - so I'll put this under the feature request column\n. So the answer is that no, there's currently not a way to definitively know whether a relation has been fetched and there should be, and while #407 asked the same question there wasn't a real answer there. \nSo yes there are ways to infer whether it may have been fetched as @ricardograca mentioned - but there should be a more well defined object bookkeeping system in place - so I'll put this under the feature request column\n. So I'm considering making this the default, but I'm also looking at creating an API which will allow for partial application of things like options for cases like this.\nWill let you know what I come up with.\n. So I'm considering making this the default, but I'm also looking at creating an API which will allow for partial application of things like options for cases like this.\nWill let you know what I come up with.\n. Should be fixed in 0.8.1\n. :+1: \n. :+1: \n. Yep - been meaning to change this. Thanks!\n. Yep - been meaning to change this. Thanks!\n. Thanks!\n. Thanks!\n. Gah yep, sorry, definitely one of many big design flaws I need to address - I'll try to get to this one soon... currently jammed up trying to reroute internals of knex through streams/observables so it's possible to handle the results of queries at the row level which should make a lot of things easier in Bookshelf.\nAs soon as that's done (should be really soon) I'll make this top priority.\n. Gah yep, sorry, definitely one of many big design flaws I need to address - I'll try to get to this one soon... currently jammed up trying to reroute internals of knex through streams/observables so it's possible to handle the results of queries at the row level which should make a lot of things easier in Bookshelf.\nAs soon as that's done (should be really soon) I'll make this top priority.\n. @jclem if you get a chance, can you try with the branch issue-730 I just pushed and see if that has the behavior you'd expect?\nIf so I'll get it tested/merged over the weekend.\n. Sorry for the delay @tbranyen let me take a look.\n. Sorry for the delay @tbranyen let me take a look.\n. So I don't have a problem with merging this, though eventually the plan is to take the underscore specific helpers off the model, in favor of a simpler map-like api which is more iterator based and doesn't have an \"omit\" method. So this would be a temporary change.\nThe real issue is that we want to have hooks to control the serialization of a model when it's serialized toJSON.\nI added an undocumented method for this serialize, which is then called by toJSON to make it easier to override, but this PR points out that we really want to have control over two different aspects of that, serializing the model and serializing the attributes:\nSo how about this:\n``` js\nserializeModel(options) {\n  return _.clone(this.attributes);\n}\nserializeRelations(options) {\n  if (options && options.shallow) return attrs;\n  var relations = this.relations;\n  for (var key in relations) {\n    var relation = relations[key];\n    attrs[key] = relation.toJSON ? relation.toJSON(options) : relation;\n  }\n  if (options && options.omitPivot) return attrs;\n  if (this.pivot) {\n    var pivot = this.pivot.attributes;\n    for (key in pivot) {\n      attrs['pivot' + key] = pivot[key];\n    }\n  }\n}\nserialize(options) {\n   return _.assign(this.serializeModel(options), this.serializeRelations(options))\n}\ntoJSON(options) {\n  return this.serialize(options)\n}\n```\nThat way on your customer model, you'd have:\n``` js\nclass Customer extends bookshelf.Model {\nserializeModel() {\n     return _.omit(this.attributes, 'password')\n   }\n}\n```\nEither that or we should include the visibility plugin by default. I think I'd meant to do that for the 0.8 release but had forgotten.\nThoughts?\n. So I don't have a problem with merging this, though eventually the plan is to take the underscore specific helpers off the model, in favor of a simpler map-like api which is more iterator based and doesn't have an \"omit\" method. So this would be a temporary change.\nThe real issue is that we want to have hooks to control the serialization of a model when it's serialized toJSON.\nI added an undocumented method for this serialize, which is then called by toJSON to make it easier to override, but this PR points out that we really want to have control over two different aspects of that, serializing the model and serializing the attributes:\nSo how about this:\n``` js\nserializeModel(options) {\n  return _.clone(this.attributes);\n}\nserializeRelations(options) {\n  if (options && options.shallow) return attrs;\n  var relations = this.relations;\n  for (var key in relations) {\n    var relation = relations[key];\n    attrs[key] = relation.toJSON ? relation.toJSON(options) : relation;\n  }\n  if (options && options.omitPivot) return attrs;\n  if (this.pivot) {\n    var pivot = this.pivot.attributes;\n    for (key in pivot) {\n      attrs['pivot' + key] = pivot[key];\n    }\n  }\n}\nserialize(options) {\n   return _.assign(this.serializeModel(options), this.serializeRelations(options))\n}\ntoJSON(options) {\n  return this.serialize(options)\n}\n```\nThat way on your customer model, you'd have:\n``` js\nclass Customer extends bookshelf.Model {\nserializeModel() {\n     return _.omit(this.attributes, 'password')\n   }\n}\n```\nEither that or we should include the visibility plugin by default. I think I'd meant to do that for the 0.8 release but had forgotten.\nThoughts?\n. The ability to easily customize the relation output would also help with issues like #765\n. initialize should be back in place in 0.8.1 - sorry about that.\n. Did it throw a different error? Seems your example is updating url, so it should update, no?\n. Actually, with semver anything under 1.x is considered breaking. I meant to remove listenTo from the docs, it was a convention from Backbone that doesn't serve much of a purpose if you don't have long-lived objects like you do on the client.\n. Actually, with semver anything under 1.x is considered breaking. I meant to remove listenTo from the docs, it was a convention from Backbone that doesn't serve much of a purpose if you don't have long-lived objects like you do on the client.\n. Actually it's gone now.\n. Looks good to me\n. Looks good to me\n. It's pretty awesome because it's so simple you can browserify test-file.js > index.js and your tests run in a browser too (where applicable, not as much for Bookshelf). So convenient.\n. It'd be a plain old array... So .at would just be array accessor syntax collection.at(1) -> collection[1]. Remove could be performed with .reduce, .add could be handled with .push or .unshift, etc.\n. Good point @tkellen, I guess that'd be necessary for being able to do a bookshelf.load as well\n. > what about doing away with the collection methods\nI think that was implied in the change unless I missed what you mean here.\n. So my hesitance is that eventually the goal for the long-term api is to drop ~~stateful models~~ edit: stateful model constructors, so there won't really be a notion of a static method, or they won't be as useful as they are currently.\n``` js\nimport {Model} from 'bookshelf'\nclass Account extends Model {\n  //...\n}\n```\nelsewhere: \n``` js\nimport Bookshelf from 'bookshelf'\nvar bookshelf = Bookshelf(config)\nbookshelf('account').where({id: 1})\n  .withRelated(['companies'])\n  .fetchAll().then((user) => {\n     // load meta on admin'ed companies\n     return bookshelf.load(account.companies.filter((c) => c.status === 'admin'), ['meta'])\n  })\n  .then(() => {\n    // ...\n  })\n```\n\nI have a lot of ideas and I don't want to just brain dump until I've pieced them all together.\n\nMight be good to dump them over here: https://github.com/tgriesser/bookshelf/issues/552 or a new ticket \n. > Do you mean the actual models returned from say, forge, or the constructors themselves?\nSorry, edited above. I meant the constructors\n\nbookshelf('contributor').save({name: 'tim'}, {name: 'ricardo'}, {name: 'rhys'});\nbookshelf('contributor').withRelated(['websites', 'projects']).save(tim);\n\nHmm, so I was thinking that bookshelf('contributor') would result in a new instance.\njs\nbookshelf('contributor').assign({name: 'tim'}).save([options])\nThen the bookshelf object, or session / transaction object would have additional methods for persistence:\njs\nbookshelf.persist(<Model|Object|Array<Model|Object>>, [options])\nThe benefits to that approach are more apparent when you're saving with a backing map tracking persisted objects via a session or transaction, e.g. bookshelfTransaction.persisted([...])\nThough maybe it should return a decorated constructor function as you mention. That actually might make more sense, plus it could probably be done fairly cleanly with the ES7 decorator proposal.\nI have a bunch of this stuff in a branch locally, I'll get it out soon so we can discuss pros/cons of various apis.\n. ES6 happened. All the changes are going to be targeted at the /src dir now :)\n. It might be easier to create some of these as gists so we can discuss/update/fork with actual diffs, but a few notes:\n1. https://github.com/tgriesser/bookshelf/issues/803#issuecomment-113018126 This has not accounted for actually making a connection anywhere. The idea behind the example I posted was that the connection to the underlying database is separated from any model definition.\n2. Agreed, forge is going to go away entirely, I'm thinking that bookshelf(modelRef) will return a new model instance and static methods will go away for the most part, unless you want to use them for something custom but they won't be nearly as useful or necessary as they are now\n3. The chaining isn't the difficult part, it's figuring out how to keep an efficient internal registry to be able to follow the unit of work pattern and deal with multiple objects mapping to the same row\n4. Relations should be statically defined, and I'm thinking they should even be defined outside of the bookshelf layer entirely at a separate layer which is consumed/referenced by models - these can be decorated into custom relations via methods, but at the core the entire schema should be statically analyzable\nI just pushed a branch next where I'm also sketching out some ideas for some apis / structure. Feel free to take a look\n. > 1. Do you mean connecting to the database? \nYep, in your example:\njs\nUser.where('id', 1).withRelated('posts.tags').fetch()\nwouldn't work, because the User constructor doesn't have any knowledge of the db connection, that's why in my example you'd adapted from it'd be something like:\njs\nvar db = Bookshelf(knex)\ndb(User).where('id', 1).withRelated(...\nor\njs\ndb('users').where(...\n\nYeah, that's a good idea. When you say 'the entire schema', do you just mean models and relations, or columns/types too?\n\nColumns/types/potentially indexes as well, and while this info might not be required there's a whole lot more you can do / optimize (and less you'd need to type) when you know everything about the data layer looks like upfront, though I don't think this info should be defined on the model... it should be passed into the initialization of the Bookshelf/Knex libs. \nIn fact, you might not need\u2122 to define \"bookshelf models\" unless you need to hook in for validation/serialization/instrumentation purposes, they could be created automatically based on the internal knowledge of the schema.\nI'd also like to ensure there's appropriate helpers in knex to fetch the schema info from the DB so you don't need to write them all out by hand if you'd prefer the DB itself be the source of the schema.\n. > Model has knex in scope, and creates a new knex QueryBuilder whenever a constructor chain is called.\nYeah, this is what I'd like to get away from even further. Model should not be required to have knex in scope at construction time. You should be able to \n``` js\nimport {Model} from 'bookshelf' // not bookshelf(knex)\nclass User extends Model {\n// ...\n}\n```\n\nWell, you may not need to, but generally I like to add methods to my models for use within my app. \n\nYeah, for some, sure. I have an application with ~30ish tables and only about 4 of them need actual \"business logic\" methods defined... the rest of it is boilerplate that disappears when you know the schema.\nAnd yeah, it'd basically mean that any static methods would just be defined directly on prototype\n\nUltimately, I'd probably prefer to tie the schema to the models, rather than read the schema from the DB. Then use a tool to generate knex migrations. That seems pretty far off at this stage though.\n\nYeah that's sort of the idea, that you could potentially do both.\n. > So it's really not a very big change. In fact, I wonder how hard it would be to get a change like this going in master presently...\nIt's a bit bigger than that, because there's a lot more that I'd like to accomplish with this change. Also mutating the model constructor like that sort of defeats the purpose, in mine you wouldn't extend the prototype, you'd instantiate a new Model passing the connection in the constructor.... no more using \"new\"\nAlso if you have multiple connections accessing the same models, you can't mutate them, you'd need to extend and cache\n\nI can certainly see the advantage to that approach. Implicit relations would be very cool, but they would still require names for use. For instance, table A could have two different has-many relations to table B, (ie. table B has two FK columns referencing table A). So this would be ambiguous:\n\nPresumably the relations would come with pre-defined names. Haven't fully determined the syntax.\n. >  It could be used to easily construct the schema on a new machine, which to me is a win, over having a (potential) ton of individual migration files. \nYeah this would be a great step in that direction... if we could get rid of the ton of individual migration files eventually that'd be awesome. I'm not sure what sorts of issues you'd run into with dropping/renaming columns... there always might be a need for some incremental migrations but this could help get rid of a lot of the ugliness there.\nModel files would be relegated to runtime specific things, like if you wanted to define dynamic \"scopes\" or if you wanted model specific accessors / serialization of models, etc... though the latter could probably be done with a static definition file, I'm not sure.\nI think for me personally in like 90% of cases I'd be able to do without the mapping of table to model class if it were all defined in a .schemafile.\n/cc @sdepold @mickhansen @janmeier have you all ever had any thoughts around something like this or would you all ever have a use or desire for something like this in sequelize? It'd be neat if we could make this a project-independent standard, or at least a common core which is extensible for project-specific features.\n. >  It could be used to easily construct the schema on a new machine, which to me is a win, over having a (potential) ton of individual migration files. \nYeah this would be a great step in that direction... if we could get rid of the ton of individual migration files eventually that'd be awesome. I'm not sure what sorts of issues you'd run into with dropping/renaming columns... there always might be a need for some incremental migrations but this could help get rid of a lot of the ugliness there.\nModel files would be relegated to runtime specific things, like if you wanted to define dynamic \"scopes\" or if you wanted model specific accessors / serialization of models, etc... though the latter could probably be done with a static definition file, I'm not sure.\nI think for me personally in like 90% of cases I'd be able to do without the mapping of table to model class if it were all defined in a .schemafile.\n/cc @sdepold @mickhansen @janmeier have you all ever had any thoughts around something like this or would you all ever have a use or desire for something like this in sequelize? It'd be neat if we could make this a project-independent standard, or at least a common core which is extensible for project-specific features.\n. It's related to the babel compilation... I think at some point it got switched so that it's relying on a global copy of core-js\n. I don't think there's much we can do about this until we move to supporting exclusively node 6+, seems the best thing to do for now is ignore it: babel/babel-loader#152\n. > \"streams!!\" -- not sure how this would quite work with the functionality of an ORM but it's lovely to imagine :)\nSo yeah, this is generally eventually the right idea... The main problem is something which first needs to be addressed at the knex level. I'm planning on addressing this relatively soon along with a lot of overall modularizing of knex, but the general issue here is that results are only available as either a \"stream\" or a \"promise\". The streams in knex are still a bit fragile and don't have a great story around error handling. Promises are nice conceptually since you're working with the entire result set, but are terrible for situations where you need to transform the data incrementally as it comes in, as is the case in relationship handling and eager loading, or any part of an ORM more generally.\nI believe the correct solution for this is to make knex queries an Observable. Though they're not yet a standard, I have a good hunch they (or something similar) eventually will be, in a similar way that Promises were not a standard when they were originally used in these libraries.\nThe observable would allow a consumer (Bookshelf) to subscribe to the query and process each row incrementally as they are returned. It's something I've been planning on for awhile, but there's a lot to consider in doing it right.\n. @lourd Can you do me a favor and test w/ changes from https://github.com/tgriesser/bookshelf/pull/1148. In npm set dependency to tgriesser/knex#80fe565 and do a fresh install and verify that tests seem to work on your end. If so I'll merge, and I think that should take care of your issues.\n. > (I also spent a few minutes wondering why npm install was complaining for me, you had a typo in your comment \u2014 tgriesser/bookshelf#80fe565)\nSorry about that\n\nAnecdotally though, the new post-install build script took quite a long time -- longer than installing the rest of the dependencies from a clean install. Would the library be published pre-built?\n\nYep, basically the postinstall checks whether /lib exists (which it would on npm), if it doesn't it installs devDeps and builds. That way you can still install a specific commit hash and have it work without keeping lib checked in on master.\n. Fat arrow fns refer to this in the outer scope. Remove those and it should work\n. \ud83d\udc4d \n. \ud83d\udc4d \n. Sorry, will try to have a look into this one a little later today \ud83d\udc4d \n. Sorry, will try to have a look into this one a little later today \ud83d\udc4d \n. Thanks\n. Thanks\n. Planning on adding this in the future in knex, but for now probably simpler just to use https://github.com/mysqljs/sqlstring\n. Planning on adding this in the future in knex, but for now probably simpler just to use https://github.com/mysqljs/sqlstring\n. @nickbarry that's the version of the npm module, not the version of the actual sqlite3 software. OSX ships with an up-to-date sqlite3 built in, I'd imagine most other machines would by default as well.\n. @nickbarry that's the version of the npm module, not the version of the actual sqlite3 software. OSX ships with an up-to-date sqlite3 built in, I'd imagine most other machines would by default as well.\n. I feel like there should be a simpler way to handle this that doesn't require an additional dependency. \nI'm actually fine with dropping 0.10 and 0.12 from travis but not necessarily specifying an engine version in the package.json until the next minor version bump or until we rely on features that don't exist in old node versions (which shouldn't be for awhile since we use babel to transpile everything).\n. Does it exhibit the correct behavior if you do: \njs\nbaseModel.extend({\n  ...\n  foo: function() {\n    return this.belongsTo('Foo', 'foo_id').query({whereNotNull: 'foo.foo_id'})\n  }\n});\n. @dj-hedgehog hey - sorry about that, must've missed your message (and this thread) until I just saw it on my feed... I've had a lot going on lately and unfortunately I've been been pretty bad about keeping up with open source maintenance :(\nI have an org setup for bookshelf, I could transfer the project there and add you as an admin (meant to do this awhile ago but never did).. Oh my bad sorry I missed this :( \nThought I had given access to the necessary people when I moved it over... Let me know if you still need me to add anyone. Any reason for this change?\n. Just fyi, you can use Promise.resolve([{id: 1...}]) here.\n. babel-runtime shouldn't actually be needed here since it's already in dependencies, right?\n. ",
    "amitava82": "Thanks! I'm digging into docs. Looking forward to the sample app.\n. Can we have change log for each release? Easier to find out what has changed/fixed from previous release.\n. Got! Thanks! Might as well make a note of it in the doc. Newbies (like me :p) won't get confused. Closing\n. Excellent! Yes I was planning of using format and parse for now. Looking forward to it and validation.\n. findAndCountAll works perfect, thanks! I've added a second argument to be passed to  fetch() to load relations.\nincrement works fine as a standalone query, but I'm looking for a way to do it with update statement; as in when I update a row with where clause without fetching the model first.\n. Sorry I was not very clear. What I meant was this:\nUPDATE users\n   SET logins = logins + 1, emailId='x@z.com', phone='1234567'\n   WHERE id = 12\n. Works, thanks!\n. ",
    "jkrems": "Thanks & sorry for not submitting the PR myself.\n. ",
    "rstacruz": "I'd really love to see Bookshelf get migrations support!\n. Coolbeans! Let me throw a few suggestions. First, I think it's better implemented in Knex than Bookshelf. It should be possible to run migrations in just Knex: there's no reason to require models in a migration transactions.\nSecond, I think it needs to be designed for programmatic access. Consider:\n``` js\nvar db = Knex.Initialize({ ... });\nvar migrator = new Knex.Migrator({\n  path: './migrations',\n  database: db,\n  logger: console.log\n});\nmigrator.currentVersion().then(...   / \"20130523\" /\n// Perform a migration\nmigrator.migrate().then(...\nmigrator.migrate({ to: \"20130605\" })\n// Create a migration file\nmigrator.generate().then(...\nmigrator.generate(\"add_created_at_to_user\")\n```\nThis way, your bin only needs to be a thin wrapper around it.\nI'm making a project right now that has bindings for Sequelize -- http://ricostacruz.com/expo/ . It tries to access Sequelize's migrator class programmatically (which it's not designed for).\n. Perhaps there should be aliases for some of knex's query methods, I usually do:\njs\nUser\n  .query((q) => q.orderBy('updated_at'))\n  .query((q) => q.limit(4))\n  .fetch()\nSeems like it'd make more sense as:\njs\nUser\n  .orderBy('updated_at')\n  .limit(4)\n  .fetch()\n. ",
    "pward123": "I'm doing this with https://npmjs.org/package/migrate using migration files like the following:\n``` coffeescript\nfor key, value of require(\"../lib/MyApp/common\")\n  eval(\"var #{key} = value;\")\nMyApp = require(\"../lib/MyApp\")\nbookshelf = MyApp.bookshelf()\nnodefn = require(\"when/node/function\")\nexports.up = (next) ->\n  nodefn.liftCallback(next)(\n    bookshelf.spread((db) ->\n      db.Knex.Schema.createTable(\"Users\", (table) ->\n        table.increments(\"id\").primary()\n        table.string(\"email\").unique()\n        table.string \"passwordHash\"\n      )\n    ).then(() ->\n      console.log '  -> Users table created'\n    ).catch((err) ->\n      console.log \"  -> Unable to create Users table \" + err\n    )\n  )\nexports.down = (next) ->\n  nodefn.liftCallback(next)(\n    bookshelf.spread((db) ->\n      db.Knex.Schema.dropTable(\"Users\")\n    ).then(() ->\n      console.log '  -> Users table dropped'\n    ).catch((err) ->\n      console.log \"  -> Unable to drop users table \" + err\n    )\n  )\n```\nIt uses a json file to track migrations applied which can be ugly if you're switching configurations. I'd rather have it use a db table entry\n. I'm doing this with https://npmjs.org/package/migrate using migration files like the following:\n``` coffeescript\nfor key, value of require(\"../lib/MyApp/common\")\n  eval(\"var #{key} = value;\")\nMyApp = require(\"../lib/MyApp\")\nbookshelf = MyApp.bookshelf()\nnodefn = require(\"when/node/function\")\nexports.up = (next) ->\n  nodefn.liftCallback(next)(\n    bookshelf.spread((db) ->\n      db.Knex.Schema.createTable(\"Users\", (table) ->\n        table.increments(\"id\").primary()\n        table.string(\"email\").unique()\n        table.string \"passwordHash\"\n      )\n    ).then(() ->\n      console.log '  -> Users table created'\n    ).catch((err) ->\n      console.log \"  -> Unable to create Users table \" + err\n    )\n  )\nexports.down = (next) ->\n  nodefn.liftCallback(next)(\n    bookshelf.spread((db) ->\n      db.Knex.Schema.dropTable(\"Users\")\n    ).then(() ->\n      console.log '  -> Users table dropped'\n    ).catch((err) ->\n      console.log \"  -> Unable to drop users table \" + err\n    )\n  )\n```\nIt uses a json file to track migrations applied which can be ugly if you're switching configurations. I'd rather have it use a db table entry\n. Thanks =) The example in the docs for collection.forge probably should be changed then.\nFYI, any reason why When.all works, but When's sequence wouldn't? I keep getting Object has no method 'apply'.\n. Thanks =) The example in the docs for collection.forge probably should be changed then.\nFYI, any reason why When.all works, but When's sequence wouldn't? I keep getting Object has no method 'apply'.\n. Oh, I don't need the sequence for that specific call. I was making that part of a seed module where I would be removing the existing records and repopulating\n. Oh, I don't need the sequence for that specific call. I was making that part of a seed module where I would be removing the existing records and repopulating\n. Same here with mocha.\nI'm not even doing a fetch. Literally, what I posted is the entire code in the only test I have (I'm just trying out buster).\n. Same here with mocha.\nI'm not even doing a fetch. Literally, what I posted is the entire code in the only test I have (I'm just trying out buster).\n. I was responding to your comment that Mocha works fine.\nLooks like that resolves the problem with buster.  Thanks!\nOn Jan 12, 2014, at 10:56 AM, Johannes Lumpe notifications@github.com wrote:\n\nSame what? Is it working for you both with mocha, or not?\n@pward123 Did you try adding my suggested code to the tearDown method of your testCase?\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks. Just seemed strange that I'd have to do the following since I can use a fetch directly off the query call, but not count. Is there a better way?\n\n``` javascript\nme._Model\n    .forge()\n    .query(criteria)\n    .query()\n    .count('id as count')\n    .then(function(result) {\n        return result[0].count;\n    })\nEdit: changed ._knex to .query()\n```\n. ",
    "esatterwhite": "One thing that would be insanely helpful would be helpers to deal with relationships to auto create the JOIN tables needed to deal with relations. Relations are really the primary benefit over knex, and doing a little model introspection to auto generate a migration would be fantastic. I basically have to hand write all of this anyway - with knex or with knex and manual tweaking.\nAnd after 2 or 3 times of trial and error, it is usually faster and easier to just open a DB Shell and write the SQL...\nI always liked the way the south project for Django did this.\nMake a change to a model, auto generate a migration. done.\n. So do all the hard work in SQL and then just lay bookshelf on the database you wrote manually? What benefit does bookshelf bring to the table at that point?\n. @rhys-vdw the issue is about migrations within bookshelf, not the merit of active record. The Model that bookshelf does provide makes it easier to do introspection into the database and what the data was / should look like. It should be able to make better decisions to help generate migrations. That would be awesome.\nAs it stands, the migration tool generates an empty file and is no more helpful than me writing a SQL file to make the changes to the database. \nSo, if I want to do anything interesting / complex or  with large datasets or most anything outside of `Model.where().fetch()' ( as you have pointed out ) , I can't really use bookshelf, I have to use knex or write the SQL anyway.\n. Ok, I'm a little confused by this thread. There isn't a way to assign a foreign key with out saving out new records?\nLike Model A has a FK to Model B if both objects already exist?, I just want to do\ninstance_a.related('modelb').set( instance_b )\nThat isn't possible? I have to manually assign IDs ?\n. Oh, So you had to do Object Relation mapping...\n@syzer Doesn't attach only work with collections / hasMany / many-to-many\nI don't think this works if related returns a model\n. what? That doesn't mean anything to me. A Blog w/ comments is still a has many.\nIf you were going the other way and trying to retrieve the blog associated to a comment, that would be a has one. and the related would return a Model instance. and that would all fall apart\n. I don't mind ORMs if they map my relational objects. What you are describing is writing custom code to do that.\n. Before this project can be made great again, we must first define what was great about in the first place. And if those things are even important anymore. I think this thread does a pretty good job illustrating what is not great - largely that relations are largely broken and widely misunderstood. And to be fair, that is what and ORM is supported to do. As soon as the problem extends beyond a single join, the recommended solution is to drop down to knex and basically write the query by hand. Again the job of an ORM.\nIt should also be noted that there is a project built on knex that is doing what bookshelf has been trying to do for a number of years https://github.com/Vincit/objection.js. I would disagree with that. Outside of the JSON schema validation, objection does what bookshelf suggests it can do. . Can someone elaborate one the thumbs down? Objection docs suggest (minus things that  json schema)\n\nAn easy declarative way of defining models and relationships between them\nSimple and fun way to fetch, insert, update and delete objects using the full power of SQL\nPowerful mechanisms for eager loading and inserting object graphs\nCompletely Promise based API\nEasy to use transactions\n\nTransactions are actually handled by knex in both cases. so that is a wash.\nBoth use promises, but that isn't really relevant to what an ORM does.\nBookshelf gives a way to define models and relation ships between them. Both do that just as easily.\nWhat bookshelf does not do very well is \n Simple and fun way to fetch, insert, update and delete objects using the full power of SQL\n Powerful mechanisms for eager loading and inserting object graphs\nWhich are basically the reasons behind using ORMs.\nOnce you've defined these relations with bookshelf models, doing anything outside of simple selects is rather difficult and in many cases just isn't possible with out writing one ore more queries by hand or with knex - which, does require you to know table names and column names. And in the case of joins and many to many relations, will also require you to inject aliases for tables and columns. \nI'm not trying to take a cheap shot at bookshelf here, I have production code that runs on it, and open source projects that allow it as a backed orm option. I have a vested interest in this project. But for it to succeed, we need to be honest about what it's problems are.. I would like to second @maxnordlund thoughts. python has some surprisingly good ORM / data mapper tools. \nthese are honestly a joy to work with\n django orm\n peewee\n* sqlalchemy\nThese query apis make virtually anything possible.\nThe thing that has always been frustrating with ORMs in node is that writing SQL and mapping relations is usually a requirement rather than a low level feature. And if that is the requirement, I don't really want to or get much benefit  in using that ORM. . When I encounter ORMs that look and feel like SQL or make me write a lot of sql to fill in the gap, I really rather just write the query in sql and drop the ORM all together.  \nIt's much easier and performant to just a pass a parmaterized string and send it to the driver. It'll be much faster than any amount of abstraction. It's easy to debug because you can actually see the query.  The more I use things like knex, the less useful I find it.\njs\nconst SQL = 'SELECT some sql  FROM table WHERE complexity > $1'\npostgres.query({\n  text: SQL\n, values: [ 10 ]\n}, cb)\ncall it a day. \nso I'm on the other side of the fence.  If I'm going to use an ORM-y abstraction, I'd prefer abstractions the fit in with the language I'm coding in.  Otherwise I'd rather just write the SQL.. ",
    "rhys-vdw": "\nOne thing that would be insanely helpful would be helpers to deal with relationships to auto create the JOIN tables needed to deal with relations.\n\nThis is not really appropriate for Bookshelf IMO. It's designed in such a way that it can be retrofitted to an existing database.\n. > What benefit does bookshelf bring to the table at that point?\n@esatterwhite an object oriented representation of your database and convenience functions for manipulating the data therein. I personally would not call designing a database schema and writing migrations \"the hard work\" of using with a database. As you pointed out, there are ORMs that are tightly coupled to the schema like you're suggesting (I believe the Django ORM generates migrations/schema from the models, for instance). Bookshelf takes a lot from ActiveRecord, a very popular ORM despite the fact it does none of the \"hard work\" you reference.\n. @esatterwhite if you want some help with migrations you can use Knex's migration system. It's not perfect of course, but you can always use knex.raw if you want to do some dialect-specific (or otherwise unsupported) operation.\n. The code example is incorrect. You want to set require: false. The returned value should then be null. If there is a still a problem please open a new issue as this relates to an older version of Bookshelf. If it does work please paste the revised code here for future reference. Thanks.\n. The code example is incorrect. You want to set require: false. The returned value should then be null. If there is a still a problem please open a new issue as this relates to an older version of Bookshelf. If it does work please paste the revised code here for future reference. Thanks.\n. Hi @ErisDS. Thanks for pointing this out. I'll try to update the docs soon.\n. I think it's the fact that the foreign key is being excluded by columns. More detailed explanation here.\n. @dksakkos You just need to make sure that the column used by the relation is included in your columns argument. This is a known issue.\n. Yes. @qawemlilo was incorrect here.\n@dksakkos You can add debug: true to check the SQL output of any of your queries. This might help you (or us) determine the problem.\nAlso in future please open a new issue.\n. @dksakkos All good dude. So the reason load('name') didn't work is not because load is not recognized, but because you load a relation, not an attribute.\nThis code, as far as I can tell, should work. Note that I'm not using Collection here, simply because we'll be removing collections soon.\njs\nCity\n  .query('where', 'population', '>', 1000000)\n  .fetchAll({\n    withRelated: ['country'],\n    columns: ['name', 'country_id'],\n    debug: true\n  }).then(function(cities) {\n    console.log(JSON.stringify(cities));\n  }).catch(function(error) {\n    console.error(error);\n  });\nCan you please try that code, then confirm that the results are the same running the logged queries in your favourite SQL client?\n. I think this works:\njs\nconsole.log(cities.pluck('name'));\n. @dksakkos Actually that wont do what you want. But it's just a basic JS question. Simply call toJSON on the collection and then remove the stuff you don't want with lodash or something.\n. @dksakkos No probs. Good luck.\n. Hi @devpatel. Please open a new issue for this feature.\n. @light24bulbs:\nYour suggestions:\njs\nsite.related('model').add(modelInstance).then(doSomething)\njs\nsite.related('model').add([instance1, instance2])\nIs \"model\" a singular or plural relation? We already have an Collection#add method, which is synchronous and only mutates the collection object (not that database).\nAre these supposed to do insert or updates? If the former, than create handles the first case. It only accepts one argument, as @tgriesser notes above.\n\nAny progress on this?\n\nNobody is working on this, but I think that create should accept multiple arguments. I've opened issue #1116 to discuss this change to create, ultimately I would expect you to provide the PR for this if it is indeed the change you're looking for.\nIf this is not the behaviour you're after please open a new issue describing the specific behaviour you want. There seems to be no specific call to action in this thread.\n. @syzer @kichooo Did my instructions not work? Not provide the functionality you want? What exactly are you asking for?\n. @syzer And .attach() doesn't work in this case?\n. Hi @asonnenschein, thanks for the report. I'd like there to be new issue for this as the one you're responding to is closed. Would you mind doing the honours?\nI have a suspicion of what the problem may be here. After the related models are returned, bookshelf groups them by their relevant join keys and then reassociated to each 'parent' model in the collection. When overriding the columns, the required foreign keys are omitted, and therefore the associations cannot be rebuilt. A workaround should be as simple as adding the relevant keys to your calls to columns.\nCould you try the following to confirm that this is the problem?\njs\nif (req.params.submission === 'all' && req.params.file === 'all') {\n  new db.SubmissionsFiles()\n    .fetchAll({\n      withRelated: [{\n        submission: function (qb) {\n          // Change here...\n          qb.column('submissions_id', 'name', 'title', 'likes', 'dislikes', 'votes');\n        },\n        submissionThumbnail: function (qb) {\n          // ...and here...\n          qb.column('submissions_thumbnails_id', 'directory', 'name');\n        }\n      }],\n      // ...and another one here for the other side of the relation.\n      columns: ['submissions_files_id', 'directory', 'original_name', 'name', 'caption']\n    })\n    .then(function (file) {\n      console.log(file.toJSON());\n      return res.status(200).send(file);\n    })\n    .catch(function (error) {\n      return res.status(404).send(\"Could not get file!\");\n    })\n  ;\nIf this works I'd still appreciate a new issue to be opened. I think we can probably build in a workaround to have the keys in the join but omit them from the returned model.\n. > Is this evidence of BookshelfJS still not supporting composite keys, or is this some sort of unrelated bug?\nComposite keys are unsupported. Adding comprehensive support would be difficult (eg. certain relation types). It would be easier to add partial support (eg. allowing the operation you're going for there by not trying to return id). If you'd like to open a new issue per supported feature we can discuss on a case by case basis and try to get some better behaviour for you.\nHowever what you're describing is (in Bookshelf terms) a many to many relationship with a pivot table (in this case you can describe this without creating a specific model for posts.\n``` js\nvar Event, Timeline;\nvar postColumns = ['create_date', 'poster'];\nEvent = bookshelf.Model.extend({\n  tableName: 'events',\n  events() {\n    return this.belongsToMany(Timeline, 'posts').withPivot(postColumns);\n  }\n});\nTimeline = bookshelf.Model.extend({\n  tableName: 'timelines',\n  events() {\n    return this.belongsToMany(Event, 'posts').withPivot(postColumns);\n  }\n});\nTimeline.forge({ id: 5 }).related('events').create({ / event fields / });\n```\n. @vellotis Yeah, I think that's a good idea. I've done something similar in another project:\njs\ngetAliasedTable() {\n  const { table, name } = this.state;\n  return table === name ? table : `${table} as ${name}`\n}\n. > Don't know what the stack trace is, as the error gets logged out from the promise catch handler.\nHm, I think you should still have the line from which the error is fired. Try this: console.log('error', error.stack).\n\n{ [Error: Cannot find module 'pg-native'] code: 'MODULE_NOT_FOUND' }\n\nThat is weird. Knex doesn't support pg-native yet. If this error is caused by Knex please submit an issue report there.\n\n[TypeError: Converting circular structure to JSON]\n\nLess weird. You're assigning the result of knex.raw() as an attribute. knex.raw returns an instance of the Raw class. It's a complex object. Bookshelf/knex will try to serialize objects with JSON.stringify before inserting/updating. For this to work the object would have to be passed directly to QueryBuilder#update. When this object is serialized you should get JSON representation of the class, but in this case it appears it's failing because of a circular reference.\nThe attributes are not arguments to update - they're values set on an object that represents the values in the row. If you want to call a function in SQL, try something like this:\njs\nPhysical\n  .query('update', {\n    geo: knex.raw('ST_SetSRID( ST_Point(66,55) , 4326)')\n  })\n  .save().then(function(physical){\n    res.status(201).send(physical.toJSON());\n    next();\n  })\n. This ought to do it:\n``` js\ninitialize: function(){\n   this.on('saving', this._saveGeo);\n}\n_saveGeo: function(model, attributes, options){\n   var geo = attributes.geo || model.get('geo');\n   if (geo) {\n     model.unset('geo');\n     delete attributes.geo;\n var x = geo[0],\n     y = geo[1];\n\n options.query.insert({\n   geo: knex.raw('ST_SetSRID( ST_Point(' + x + ', ' + y + ') , 4326)')\n });\n\n}\n});\n```\n\nIs there a good way to log out all SQL queries as they are run against the db, to allow for easy inspection?\n\nYes, pass debug: true to knex to log all queries. Or pass options.true to fetch, save etc for logging specific queries.\n. This is an awkward use case for events. I've never liked the duplication of attributes and model.get(). Also it means that you're unsetting the value on the model, so it will be gone afterwards. I would probably override save() with custom functionality that detects this particular field instead and doesn't save it.\n. @jameslaneconkling Also you might want to look at this: https://github.com/jfgodoy/knex-postgis\n. Ah, right. My advice was incorrect. It stemmed from a misunderstanding on Knex:\njs\nknex('table').insert({a: 5}).insert({b: 6}).toString();\n// insert into \"table\" (\"b\") values (6)\nIt would appear that, unlike .where and .select, subsequent calls to insert override the previous call. Sorry for misleading you.\nThe more I look at the Sync's implementation the more I feel that this should work:\njs\nvar newPhysical = new Physical({ geo: knex.raw('ST_SetSRID( ST_Point(66,55) , 4326)') })\n  .save().then(function(physical){\n    res.status(201).send(physical.toJSON());\n    next();\n  }).catch(function(err){\n    console.log('Error creating new Physical: ', err);\n    res.status(500).send(err);\n    next();\n  });\nWhat query is generated by this original code?\n. Also what error did it produce?\n. Could you provide version of Bookshelf and Knex, and the stack trace for each of those errors?\n. @jameslaneconkling Also, can you please do so in a new issue.\n. Hi @mackwic, I'm going to try to tackle this soon. I'm not sure how involved it will be yet, but I'll post updates here.\n. I've just added Collection#count, Model#count and Model.count to master. I'd prefer that the response from query() was constrained, as suggested above, but I think this is a step in the right direction.\n. @chrisfrancis27: Did you try the count() function?\njs\nYourModel.forge({ id: 5 }).comments().count().then(commentCount =>\n  console.log(`There are ${commentCount} comments.`)\n);\n. > Actually I just saw issue #715 which is exactly related to what I mentioned. Sorry for the duplicated report.\nActually that is a subtly different issue, that the query returned from Collection#query() is filtered. Collection#count should filter by relation since #781 (included in 0.8.2). This should be a new issue.\n. @acepukas Oh my, how embarassing! That's my code btw. Thanks for looking into this. I'm pretty busy presently with other tasks so I won't be able to fix this immediately. Would you be willing to open a PR? Happy to provide support and guidance if necessary. It looks like you've got your head around the problem.\n\nThe options.isCount is not the most elegant workaround to the fact that testing for hasMany relationship wasn't enough to isolate the constraint to just collection.count() calls. Maybe someone knows a better way.\n\nAgreed, but you're on the right track. There is already a problem where constrain will emit a fetching event for a count on through table in a call to count(). I think the solution here would be to remove the constrain function and move the relevant logic directly into Sync#count and Sync#select.\n. @acepukas Great. master is the correct branch, yeah.\n\nit's only applicable to Sync#select calls?\n\nThis.\n. > I'm getting an error: TypeError: Cannot read property 'parentFk' of undefined\n@cmcewen This occurs when you try to use a Collection or Model in place of a relation instance. At the time of writing, relations are instances of either of the mentioned types with a relatedData property. Please open a new issue for your problem if this doesn't help. This is a feature request thread.\n. @JBustin, @bendrucker is no longer actively involved with Bookshelf. If you'd like help with a specific problem please open a new issue with more specific information. You can reference this issue from there if necessary.\n. @recursivefunk This is a discussion to be had over at https://github.com/tgriesser/knex/issues\n. @amanmohla not to my knowledge.\n. @amanmohla Why not check out @johanneslumpe's PR #244? If it works we might be able to work towards getting it in the next release.\n. @cspotcode, @bendrucker is no longer working on Bookshelf. The comment he's referring to is here, btw.\nI have no experience with vagrant, but this would make testing easier and quicker to set up on a new computer, right?\ntbh it seems a bit strange to have an npm module with a single config file in it. We could do the load trick with the already existing knex devDependency - however it seems to Vagrantfile is no longer in knex?\n. @apolishch That's great. We should maintain a list of plugins on the website.\n. Good approach, @jtwebman. Currently planning a refactor/update of how Bookshelf relations work using a similar strategy (among other changes).\n. Good approach, @jtwebman. Currently planning a refactor/update of how Bookshelf relations work using a similar strategy (among other changes).\n. I'm just working on a new spec currently - a significant API change. It's not finished, but you can see my WIP here. The better documented ideas are in README.md, but there are more features (and draft implementations) in notes.md. I'm in the process of refining the ideas in notes and moving them to README. Feedback would be great.\n. I'm just working on a new spec currently - a significant API change. It's not finished, but you can see my WIP here. The better documented ideas are in README.md, but there are more features (and draft implementations) in notes.md. I'm in the process of refining the ideas in notes and moving them to README. Feedback would be great.\n. @kimmobrunfeldt Please keep avoid adding off topic questions into existing issues. Use options.transacting as shown in docs.\n. @kimmobrunfeldt My apologies - it is on topic. Just looking over the other comments here. Tim mentions above that:\n\nThere's forShare and forUpdate which do the appropriate locking on postgres & mysql, but they're only made available after you call .transacting.\n\nSo you might want to double check that Bookshelf is generating the query correctly (you can do this by passing debug: true as an option to save()). If not, then the PR you linked (#516) might need to be merged for this to work. Can you respond in #516 with to verify that it works? Cheers.\n. @aef- There's a lot going on here, could you open a new issue showing exact use case with expected and actual ouput.\n. @aef- There's a lot going on here, could you open a new issue showing exact use case with expected and actual ouput.\n. This is really a knex issue. You'd do better finding/creating an issue\nthere.\nOn Thu, 17 Sep 2015 1:08 pm JT Turner notifications@github.com wrote:\n\nThis hack doesn't work if you set it that way the schema then sets it on\nthe create table and breaks.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/332#issuecomment-140955636\n.\n. @peteut This is still broken in the current version.\n. It may do, I can check if you like. Is there a reason why it hasn't been merged yet?\n. It may do, I can check if you like. Is there a reason why it hasn't been merged yet?\n. @peteut Finally got the test environment set up. PR: #771.\n. I had a look at it last night. It's fixable but will require a bit of a\nchange. #771 fixed a different problem that was discussed in this issue.\n\nOn Thu, 3 Sep 2015 8:14 am Ben Ockmore notifications@github.com wrote:\n\nJust wondering what the status of this is? #771\nhttps://github.com/tgriesser/bookshelf/pull/771 doesn't seem to have\nfixed it - not sure if it was meant to. Thanks!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/397#issuecomment-137260879\n.\n. Let's leave this one open, I kind of like it.\n. Let's leave this one open, I kind of like it.\n. @marco-fiset Nobody is working on this feature presently. I'd suggest building out a plugin if you need it.\n. @AntJanus updated_at will not be modified in the code you've shown.\n. @AntJanus updated_at will not be modified in the code you've shown.\n. @dennismonsewicz From the docs:\n\n``` js\nvar bookshelf = require('bookshelf')(knex);\nvar User = bookshelf.Model.extend({\n  tableName: 'users'\n});\n```\nPls avoid reviving dead issues.\n. Hey @tgriesser, do you know why this never ended up getting merged? It seems like a good idea. I'm happy to reapply these changes to the new file structure if you believe the behaviour should be default.\n\nultimately we're going to want to do a select for newly inserted and non-fetched objects where we need to anyway\n\nI can also add a call to Model#refresh after insertion for databases other than Postgres. I'd be hesitant to make that default though due to number of extra queries that would silently cause non-pg users.\n. No, I implemented it ages ago. Not sure why I didn't close the PR.\nOn Tue, Jul 26, 2016, 8:19 AM ricka notifications@github.com wrote:\n\n@rhys-vdw https://github.com/rhys-vdw Did this lose steam? I'd\npersonally love to see this in place, and I think everyone agrees it is\nuniversally a great idea.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/pull/425#issuecomment-235103791,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAyLWeRAeP2mgbfWnNE2w4sMZ8p8aLAmks5qZTZmgaJpZM4CO2N8\n.\n. @ricka Sorry I didn't look at the full thread. What I added was refresh(). If you don't care about performance you can do this:\n\njs\ninitialize: function () {\n  this.on('updated craeted', (model, resp, options) => {\n    return this.refresh();\n  });\n}\nOtherwise I did at one stage try to get support for this added. It's pretty hard dealing with the different dialects. I'm sure it's possible, but I had some trouble (to do with Bookshelf architecture). The main reason you're not able to override returning is that it's specified explicitly within fetch somewhere. So you'll probably need to fork.\nIf you can get it working I'm open to merging it into master, but it would need to be tested thoroughly of course. You might be able to monkey patch it in for your own purposes though.\n. Well, just for more examples, here's mine. Note that if you give it a relation, it will fail.\nAlso, there's this PR that I wrote, adding Collection#count. I can't merge it yet because it was forked before the recent repo file structure change. Also I'm not sure if it goes far enough in fixing things - it doesn't constrain the query returned by Collection#query().\n. Hi @jucrouzet. Could you explain explicitly the use case for this option? Is it so that for update can be added to all eager loaded relation queries?\nThings that need to happen for this feature to be merged:\n- Better explanation of exact use case for my benefit (haven't used these commands before)\n- New PR against src/sync.js, rather than lib/sync.js since we now build with Babel.\n- Documentation update of index.html in the bookshelf.transaction section.\n. What's wrong with this:\njs\nbookshelf.transaction(function(trx) {\n  return RenewalModel.forge({\n    type: type,\n    status: 'new'\n  })\n  .query('limit', 1)\n  .query('forUpdate') // => Specify here the FOR UPDATE\n  .fetch({transacting: trx})\n  .then(function(instance) {\n    if (instance) {\n      return instance.save({status: 'pending'}, {patch: true, transacting: trx});\n    }\n  });\n});\n. np ;)\n. Cool. Easy fix then. Just for anyone else encountering the same problem, this is my updated parse and format (adapted from the example in the API documentation):\nJavaScript\n  format: function(attrs) {\n    return _.transform(attrs, function(memo, val, key) {\n      memo[_.snakeCase(key)] = val;\n    });\n  },\n  parse: function(attrs) {\n    return _.transform(attrs, function(memo, val, key) {\n      if (_.startsWith(key, '_pivot_')) {\n        memo[key] = val;\n      } else {\n        memo[_.camelCase(key)] = val;\n      }\n    });\n  }\n. SELECT 'cllrf' LIKE 'l%'; returns false. Doesn't that mean this is the correct response?\n. If you pass { debug: true } to your Knex.js config you can see what SQL is being output with the command, and if it's as you expected.\n. If you pass { debug: true } to your Knex.js config you can see what SQL is being output with the command, and if it's as you expected.\n. @claym For what it's worth, this is my solution to the where problem. Just add this method to your base model. It only accepts objects (rather than the (key, value) syntax).\nJavaScript\n  filter: function(filter) {\n    if (!_.isEmpty(filter)) {\n      var filter = this.format(filter);\n      this.query(function(qb) {\n        return qb.where(filter);\n      });\n    }\n    return this;\n  }\n. Will take a PR for this one.\n. Hey guys, my initial reaction here is that this is more complex than it need be. Unless I'm missing something.\nAs far as I can tell there is no conceptual difference between a belongsTo with a null FK and a morphTo with a null *_type/*_id. Why not just have the same behaviour as a null belongsTo - which is to return null (rather than a NullBelongsToAssociation for instance). \nThe error message \"The target polymorphic model was not found\" makes sense if there is a string value, but it is not one of the listed columns. That is actually \"exceptional\" behaviour - eg. the database and models are inconsistent.\nAlso I'll just point out that this PR targets the lib/ build directory, rather than the new src/ ES6 dir. (PR predates this repo structure change.)\n. > which is to return null\nOr actually I think it returns an empty model, but that's a different issue.\n. A belongsTo relation always returns a Model.\nSo, the current behaviour of belongsTo is this:\n``` js\nEngine = bookshelf.Model({\n  tableName: 'engine',\n  car() { return this.belongsTo('Car'); }\n});\nconst engine = Engine.forge();\nconst unfetchedEngine = engine.related('car');\n// unfetched engine is an empty model\nunfetchedEngine.isNew() // always new, because it hasn't been fetched.\nunfetchedEngine.fetch(engine => {\n  // engine is either null, or the same instance as\n  // unfetchedEngine with retrieved row data.\n});\n```\nSo this is how it should be:\n``` js\nvar relatedModel = someModel.aMorphToRelation()\n// related model is empty always - without having been fetched there\n// is no way to know if it exists or not.\nrelatedModel.fetch(function(fetchedRelatedModel) {\n  if (fetchedRelatedModel != null) {\n    // ...\n  } else {\n    // relation isn't present\n  }\n})\n```\nDoes that make sense?\n. Cool I'm with you now, cheers.\nIn the context of #753, this makes sense. However it will have one difference to other relations...\n``` js\n// This will create a new model.\nPerson.related('father').set({ name: 'Peter' }).save();\n// set is not defined.\nPerson.related('polymorphicRelation').set(data).save();\n```\nThat's something to consider, but right now I think that's probably a better bug to have than the one you're solving.\n\nWould you like me to make that change as well as update to the new ES6 src/ and add some tests?\n\nUltimately yes, but maybe give me a day to think about this and think about other implications. Thanks for the follow up.\n. > This would more closely resemble the behavior of belongsTo, but it's quite an assumption to make that the developer is looking for an instance of the first model type.\nTotally. Yeah, there is no easy fix here. I'd prefer to refactor the relations API at a higher level than to add more complexity and tape to fix that particular edge case.\nThe real problem is that queries are built into models. A relation conceptually a query - not an \"empty model\". That's why we have these weird empty models. There is no great fix for this until this is addressed - but it's such a fundamental design choice that it would require lots of breaking changes.\n. Hi, this not a problem with belongsToMany as such, but a problem with how parsing/formatting is performed. Since parse/format take an object as input, it is not possible to convert a string on its own (in this case the idAttribute).\nDuplicate discussion here: #397.\nThanks for the report. I'm going to close this as a duplicate, any further discussion should take place in the original issue.\n. Hey guys, I'm still interested in this feature. @tgriesser, did you remove the 'PR please' tag because this will be addressed by changes you're currently working on?\n. Hi, still looking for a solution for this?\nThis should do the job:\njs\nitem.save(item.changed, {patch: true});\n. Adding 'docs' tag because this example could be added to the docs under Model#changed.\n. I've been wondering about the same thing. Just to be clear, the problem is this: When saving additional models in a custom save call, you need to create a transaction if one is not provided - otherwise you risk doing a partial save.\nIn practise my attempts at a 'correct' solution have been a bit of a mess so I've just ensured that I always pass a transaction to models with multiple inserts on save, and just suggest that this is done via comments (ie. quite bad solution).\nI've considered something like this (sorry for the coffee):\n``` CoffeeScript\n  bookshelf.model 'User', BaseModel.extend {\n    constructor: ->\n      BaseModel.apply @, arguments\n      @on 'saving', @_onSaving\n      @on 'saved', @_onSaved\n_onSaving: (model, attrs, options) ->\n  if not options.transacting\n    options.shouldCommitTransaction = true\n    return bookshelf.transaction (trx) -> options.transacting = trx\n\n_onSaved: (model, resp, options) ->\n  someThingIMustHaveWhenSaved.forge(user_id: @id).save(null, options)\n  .then ->\n    if options.shouldCommitTransaction\n      options.transacting.commit()\n  .catch ->\n    if options.shouldCommitTransaction\n      options.transacting.rollback()\n\n```\nThe only problem here is that I'm not sure what happens if the thing barfs during the save function.There is no handler for a failed save (AFAIK), so I suspect the transaction would be open.\nYou could do something like this I guess:\nCoffeeScript\n  save: (attrs, options) ->\n    proto.save(attrs, options)\n    .catch ->\n      if options.shouldCommitTransaction\n        options.transaction.rollback()\nAnyway, I felt like I wasn't well enough aquainted with the system to fully understand how this could backfire, but it could be generalized into a mixin or base class somehow. A few of my models with saved handlers do inserts, and I wouldn't want to have to repeat this much logic everywhere.\nWhat do you think?\nPS Just to be clear, I'm pretty sure the above code has problems in it, but this is the general idea I've been toying with.\n. The problem of events in the case of generalizing the solution is that you don't have good control over which order events are executed.\nSo, the ideal (IMO) is that you'd have the above _onSaving and _onSaved handlers in the base class (call it BaseModel). They would handle the transaction creation and commit/rollback.\nThe additional insertion should go in the child model (User in this case). However, I always put that stuff in the saved event handler. So, ultimately there are  two handlers to this event (one from the base class, one from the child with the additional insertion), but the order is wrong! The transaction will be completed before the second model is inserted.\nSo, I've got ideas about how this could be mitigated, but it's clearly not a simple problem - which is why I haven't actually employed this strategy yet.\n. Yeah, actually, you know what. I can't spend too much time discussing this because I'm at work, but you could always override save like this:\nJavaScript\nproto = bookshelf.Model.prototype;\nbookshelf.Model = bookshelf.Model.extend({\n  save: function (attrs, options) {\n    if (this.requireSaveTransaction && !options.transacting) {\n      return bookshelf.transaction(function(trx) {\n        options.transacting = trx;\n        return proto.save.apply(this, arguments);\n      });\n    } else {\n      return proto.save.apply(this, arguments);\n    }\n  }\n});\n\nDoes save even 'wait' for events to be handled?\n\nYes, it does. Some event handlers can return promises, if they are rejected the calling method will be. This means you could do something like this (using the above plugin):\nJavaScript\nMyDeepSavingModel = bookshelf.Model.extend({\n  things: function() { this.hasMany('Thing'); },\n  initialize: function() {\n    bookshelf.Model.apply(this, arguments);\n    this.on('saved', this.saveThing);\n  },\n  requireSaveTransaction: true,\n  saveThing: function (model, attrs, options) {\n    return this.things().create(attrs.thing, options);\n  }\n});\nAnd all that looks like from the outside is a normal .save() call. Internally it will create a transaction if required.\nI think this is the cleanest solution...\nPS. This has an error:\nJavaScript\n    // this could be save or saveDeep\n    return fn.apply(self, [ params, opts ])\n      .then(function () {\n        if (opts.mustCommit) {\n          return opts.transacting.commit();\n        }\n      })\n      .catch(function () {\n        // Must check here or else we'll be rolling back transactions twice when this has a transaction passed in.\n        return opts.transacting.rollback();\n      });\nEDIT: updated code and fixed some errors\n. My pleasure. Thanks for prompting me to think about this problem. I just updated my code in my previous response, I think the concept is sound. Good luck.\n. Hm, okay. So I've had a crack at creating a plugin. Here's the complete code:\n``` JavaScript\nmodule.exports = function (bookshelf) {\n  var proto = bookshelf.Model.prototype;\nvar Model = bookshelf.Model.extend({\n    trasactSave: false,\n    save: function (attrs, options) {\n      var self = this;\n      if (!options) options = {};\n      if (this.transactSave && !options.transacting) {\n        return bookshelf.transaction(function (trx) {\n          options.transacting = trx;\n          return proto.save.call(self, attrs, options);\n        });\n      } else {\n        return proto.save.call(self, attrs, options);\n      }\n    }\n  });\nbookshelf.Model = Model;\n};\n```\nSo you can save additional models within the transaction in the saved event handler. Just pass the options.transacting object through to any calls to save.\nEdit: Fixed code error.\n. I actually made a plugin for this: bookshelf-transact-save . I didn't post a reply because I haven't tested it properly, but I thought I might leave it here in case someone is looking for this feature.\nEDIT: Doesn't do deep saving, just handles the automatic transaction generation.\n. There is no built in API for this currently, but you can pass it to raw.\njavascript\nbookshelf.transaction(function(trx) {\n  trx.raw('set constraints deferred')\n  .then(function() {\n    // ...\n  });\n});\n. Relevant issue is being tracked for knex: tgriesser/knex#581\n. Were I to guess I'd say the core of the problem is here:\n\nIf you're adding models to the collection that are already in the collection, they'll be ignored, unless you pass {merge: true}, in which case their attributes will be merged into the corresponding models, firing any appropriate \"change\" events.\n\nInternally this is probably using a Collection and identifying the models by their ID attribute, hence why it's dropping all the duplicate results with id: 2. This is not actually incorrect behaviour - as you're just asking for a list of Routes that the station has, which you're getting.\nI think the solution would be to create a model for stations_routes (called, say, TrainTimes) and adding that as a hasMany relationship. Then you can do:\ntrainTimes: function () { return this.hasMany(TrainTimes); } and station.fetch({withRelated: 'trainTimes.route'});.\nMake sense?\nPersonally I find the pivot stuff not as useful as creating explicit models most of the time anyway.\n. Were I to guess I'd say the core of the problem is here:\n\nIf you're adding models to the collection that are already in the collection, they'll be ignored, unless you pass {merge: true}, in which case their attributes will be merged into the corresponding models, firing any appropriate \"change\" events.\n\nInternally this is probably using a Collection and identifying the models by their ID attribute, hence why it's dropping all the duplicate results with id: 2. This is not actually incorrect behaviour - as you're just asking for a list of Routes that the station has, which you're getting.\nI think the solution would be to create a model for stations_routes (called, say, TrainTimes) and adding that as a hasMany relationship. Then you can do:\ntrainTimes: function () { return this.hasMany(TrainTimes); } and station.fetch({withRelated: 'trainTimes.route'});.\nMake sense?\nPersonally I find the pivot stuff not as useful as creating explicit models most of the time anyway.\n. Yeah, something related to this that I'd be interested is a lazy load function. I'm imagining something like model.load('relation', {lazy: true}) or model.lazyLoad('relation').\nThis would load a relation only if it had not yet been fetched.\nThis is useful when I have a function that can take a model and make some decision based on its relations. I may be using the same function in various contexts, without knowing if the required relations have been fetched yet. At the moment I tend to just load the relation every time (potentially causing redundant loads).\nI want this for my rest api. I have many places in my express routes that check models for various permissions, based on the resource they're accessing. So, for example:\njs\nvar Object = bookshelf.Model.extend({ tableName: 'objects' });\nvar User = bookshelf.Model.extend({\n  tableName: 'users',\n  objects: function() { return this.objects().fetchAll(); }\n  ownsObject: function(objectId) {\n    return this.lazyLoad('objects').then(() => this.related('objects').findWhere({id: objectId}));\n  }\n});\nownsObject might be called in various middleware and route handlers. Now ownsObject can be called repeatedly in different contexts and I know that it won't do any unnecessary loads. (Of course this would have to be used with caution.)\n. @ricardograca Absolutely. This is what I meant when I said \"this would have to be used with caution\". This is actually true even without a 'lazy load'. Even while the response of a query is being turned into models by fetch, another process could be modifying the database simultaneously.\nYou wouldn't want to use lazyLoad much in an application with persistent models, for instance.\nFor instance, in a REST server, each request generates a User model, which is then repeatedly asked if it has certain permissions (eg. User.isAllowedToModify(otherModel)). Each of these calls results in a query. In very deeply nested routes this could happen five times or so. If someone changes the user permissions during this time, it's not a big deal really, it's kind of like they made the request 200ms earlier. In the case of a web server dealing with a single request, lazyLoad could be quite handy.\n. load as it works currently can be used to refresh a relation. I think the user should have to be explicit when calling a function that may be a no-op. Also there are back-compatibility issues if we just changed load itself; It would silently change behaviour and could cause hard to find bugs.\n. @ricardograca you can currently do refresh({withRelated: [/* ... */]}), which solves that nicely.\n. Seems related to this issue: https://github.com/tgriesser/bookshelf/issues/640\n. Seems related to this issue: https://github.com/tgriesser/bookshelf/issues/640\n. Closing as duplicate of #126.\n. Hm, actually this is different to #126, as it requests that query() returns a constrained query builder object (as opposed to just adding count to a Collection).\n. @helios1138 Not that I'm aware of. Nor would it be trivial to fix.\n. @helios1138 What were you trying to achieve, exactly?\n. @helios1138 That is not what this particular issue is about, it's subtley different. It's about the following:\njs\nconst query = Model.related(relationName).query();\nCurrently that query object will not be constrainted properly.\nHowever, if you use the query callback, it should theoretically work fine:\njs\nconst countPromise = Model.related(relationName).query(...whatever).count()\nAlthough problems have been reported. I just merged #1115 which should fix some instances. Please try out master now and see if it solves your problem.\n. @helios1138 Done.\n. @helios1138 oops, or maybe not... hold up\n. @helios1138 Okay, it's released. For some reason https://www.npmjs.com/package/bookshelf is still listing the latest as 0.9.1...\n. I think this is the better way:\nJavaScript\nvar Session = bookshelf.Model.extend({\n    tableName: 'session',\n    users: function() {\n      return this.hasMany(User);\n    },\n    posts: function () {\n      return this.hasMany(Post).through(User);\n    }\n});\nvar User = bookshelf.Model.extend({\n    tableName: 'user',\n    posts: function() {\n      return this.hasMany(Post);\n    }\n});\nvar Post = bookshelf.Model.extend({\n    tableName: 'post',\n});\n``` JavaScript\nSession.forge({ id: myID })\n.fetch({ withRelated: 'posts' })\n.then(function (session) {\n  var sessionPosts = session.related('posts');\n});\n// OR\nSession.forge({ id: myID }).posts().fetch()\n.then(function (posts) {\n  // We have posts here without loading a Session model at all, just using its ID.\n});\n```\n. I think this is the better way:\nJavaScript\nvar Session = bookshelf.Model.extend({\n    tableName: 'session',\n    users: function() {\n      return this.hasMany(User);\n    },\n    posts: function () {\n      return this.hasMany(Post).through(User);\n    }\n});\nvar User = bookshelf.Model.extend({\n    tableName: 'user',\n    posts: function() {\n      return this.hasMany(Post);\n    }\n});\nvar Post = bookshelf.Model.extend({\n    tableName: 'post',\n});\n``` JavaScript\nSession.forge({ id: myID })\n.fetch({ withRelated: 'posts' })\n.then(function (session) {\n  var sessionPosts = session.related('posts');\n});\n// OR\nSession.forge({ id: myID }).posts().fetch()\n.then(function (posts) {\n  // We have posts here without loading a Session model at all, just using its ID.\n});\n``\n. AFAIKwithRelateddoesn't do anything on a call tosave. But you'll already have the \"othermodel\" model cached from the call tofetchin your particular code example.\n. AFAIKwithRelateddoesn't do anything on a call tosave. But you'll already have the \"othermodel\" model cached from the call tofetch` in your particular code example.\n. Unfortunately bookshelf does currently not support composite keys.\n\nIs there a way to save/update the user with a composite key by just doing 'save' or do I need to include the 'where' clause as well?\n\nYou'll have to use a where clause for now.\nI'm going to close this as a duplicate as this issue is being tracked in #93.\n. Currently bookshelf does not support this. I generally do something like this:\njs\nmodel.set(_.omit(req.body, _.isObject)).save();\n\nWhy relations are not removed automatically just before save? Is any reason for it? Or only reason is that nobody implement it yet? ;-)\n\nDue to the way models are structured there isn't a way for model code to easily get a list of relation keys. Another option would be to just ignore any key that holds an array or JSON object, but both of these are valid types for certain databases. In most cases you can probably get away with this approach.\n\nIf they cannot be removed where is it best place for removing relations, in function format? or is any better place?\n\nThe best place, in my opinion, would be in the set function. Override set in a base model/plugin and have it check if values are objects or arrays. Something like this (untested):\n``` js\nfunction isArrayOrPlainObject(value) {\n  return .isPlainObject(value) || .isArray(value);\n}\nMyBaseModel = bookshelf.Model.extend = {\n  set: function(key, val, options) {\n    if (key == null) return this;\n// Handle both `\"key\", value` and `{key: value}` -style arguments.\nif (typeof key === 'object') {\n  attrs = key;\n  options = val;\n} else {\n  (attrs = {})[key] = val;\n}\n\n// This will be terrible if you're using array or JSON type columns.\nreturn bookshelf.Model.prototype.set.call(this, _.omit(attrs, isArrayOrPlainObject), options);\n\n}\n}\n``\n. Closing as a duplicate.\n. Happy to discuss this change. I'd prefer that it were keyed aswithRelated`\nNot hard to implement this one yourself.\njs\nvar proto = bookshelf.Model.prototype;\nvar WithRelatedModel = bookshelf.Model.extend({\n  fetch: function(options) {\n    options = options == null ? {} : _.clone(options);\n    if (this.withRelated && options.withRelated != null) {\n      options.withRelated = this.withRelated;\n    }\n    proto.fetch.call(this, options);\n  }\n});\nI think this would be best as a plugin for now, but we can still add it to the main repo. Rather not add more functionality around relations in case they are reimagined.\n. Happy to discuss this change. I'd prefer that it were keyed as withRelated\nNot hard to implement this one yourself.\njs\nvar proto = bookshelf.Model.prototype;\nvar WithRelatedModel = bookshelf.Model.extend({\n  fetch: function(options) {\n    options = options == null ? {} : _.clone(options);\n    if (this.withRelated && options.withRelated != null) {\n      options.withRelated = this.withRelated;\n    }\n    proto.fetch.call(this, options);\n  }\n});\nI think this would be best as a plugin for now, but we can still add it to the main repo. Rather not add more functionality around relations in case they are reimagined.\n. The fetching event provides options.query, which is equivalent to the qb object given to the Model.query callback.\nCorrect code:\nJavaScript\n  initialize: function () {\n    this.on('fetching', function (model, attrs, options) {\n      options.query\n      .leftJoin(/*...*/)\n      .groupBy(/*...*/)\n      .count(/*...*/);\n    });\n  }\n. You could always make a PR against the docs.\n. If you add a role relation to the Tenant model, can you do this?\njs\nUser.where({email:req.query.email})\n  .fetch({withRelated:['tenants.role', {\n    'tenants':function(qb){\n      qb.where({subdomain:req.query.subdomain});\n    }\n  }]})\nDisclaimer: This might not work, I'm not that familiar with the workings of query callbacks in the withRelated option.\n. If you add a role relation to the Tenant model, can you do this?\njs\nUser.where({email:req.query.email})\n  .fetch({withRelated:['tenants.role', {\n    'tenants':function(qb){\n      qb.where({subdomain:req.query.subdomain});\n    }\n  }]})\nDisclaimer: This might not work, I'm not that familiar with the workings of query callbacks in the withRelated option.\n. > with 'fetch' function not 'query' or 'raw'\nThe Bookshelf API offers a way to achieve this using a combination of fetch and query. \n``` JavaScript\nUser = bookshelf.Model.extend({\n  tableName: 'user'\n});\nUser.forge().query(function (qb) {\n  qb.where('name', 'John').orWhere('login', 'SomeValue');\n}).fetch()\n```\nJavaScript\n{\n  method: 'select',\n  options: {},\n  bindings: [ 'John', 'SomeValue', 1 ],\n  sql: 'select \"user\".* from \"user\" where \"name\" = ? or \"login\" = ? limit ?'\n}\n. Seems inappropriate to me, but it should be trivial to write a plugin that replaces fetch supporting that option. Just take the assigned attributes and expand them out into the the above code I provided, then delete the attributes and execute the original fetch function.\n. @tbranyen FYI this example use can be addressed by the visibility plugin.\n. Hi @tbranyen. Firstly, thanks for the PR!\nI guess the original intention of the underscore methods were to match the Backbone.js API, which has no concept of relations. So currently they're more related to get than toJSON.\nSince Bookshelf does have relations, this seems reasonable. But what happens when you call invert on an model with relations?\nThis would be a breaking change, so I'm not willing to merge this before a bit more discussion (hopefully @tgriesser will weigh in). In the meantime it's not a great deal more work to simply call _.omit(customer.toJSON(), 'password') or to use the visibility plugin designed for this specific purpose.\n. The problem with invert is this:\n``` js\n_.invert({\n  id: 5,\n  name: 'John',\n  relatives: [\n    {id: 2, name: 'Mary'},\n    {id: 6, name: 'Peter'}]\n});\n// outputs:\n{5: \"id\", John: \"name\", \"[object Object],[object Object]\": \"relatives\"}\n```\nBy 'breaking changes' I meant breaking other people's apps, not breaking Bookshelf itself. If code relies on these being shallow, then it will break.\nHowever, generally speaking I think I'm coming around to this idea. I'm also of the opinion that invert is not a particularly useful method, so maybe it can be dropped and this change incorporated. @ricardograca, do you have an opinion on this?\n. The problem with invert is this:\n``` js\n_.invert({\n  id: 5,\n  name: 'John',\n  relatives: [\n    {id: 2, name: 'Mary'},\n    {id: 6, name: 'Peter'}]\n});\n// outputs:\n{5: \"id\", John: \"name\", \"[object Object],[object Object]\": \"relatives\"}\n```\nBy 'breaking changes' I meant breaking other people's apps, not breaking Bookshelf itself. If code relies on these being shallow, then it will break.\nHowever, generally speaking I think I'm coming around to this idea. I'm also of the opinion that invert is not a particularly useful method, so maybe it can be dropped and this change incorporated. @ricardograca, do you have an opinion on this?\n. > A safer approach would be to create a special case for the omit() method and use .toJSON() only in that case. What do you guys think?\nWell, this particular use case of _.omit is already handled by the visibility plugin. Consistency is very important, so I would be hesitant to make a special case here.\n\nI can't think of any case where invert would be useful :\\ Why was it included in the first place?\n\ninvert and friends were taken from Backbone. I've personally never used any of them. I actually can't think of any good use cases for Bookshelf, at least none none so frequent to justify them being in the API. I'd be interested to hear of some other uses.\nTo be honest I think these functions could provide unexpected behaviour either way, which is not a good sign. Maybe they should just be canned altogether in the name of simplicity? Or stripped from core and moved to a plugin? I think the latter might be the safest, as it provides support for those who depend on them. It could even have a config setting to change whether it's deep or shallow.\nSorry @tbranyen, I'm sure this isn't the response you were hoping for. It's still open for discussion though.\n. > A safer approach would be to create a special case for the omit() method and use .toJSON() only in that case. What do you guys think?\nWell, this particular use case of _.omit is already handled by the visibility plugin. Consistency is very important, so I would be hesitant to make a special case here.\n\nI can't think of any case where invert would be useful :\\ Why was it included in the first place?\n\ninvert and friends were taken from Backbone. I've personally never used any of them. I actually can't think of any good use cases for Bookshelf, at least none none so frequent to justify them being in the API. I'd be interested to hear of some other uses.\nTo be honest I think these functions could provide unexpected behaviour either way, which is not a good sign. Maybe they should just be canned altogether in the name of simplicity? Or stripped from core and moved to a plugin? I think the latter might be the safest, as it provides support for those who depend on them. It could even have a config setting to change whether it's deep or shallow.\nSorry @tbranyen, I'm sure this isn't the response you were hoping for. It's still open for discussion though.\n. @tbranyen, how would you feel about having these features in a plugin, taking a config option for deep/shallow?\n. @tbranyen, how would you feel about having these features in a plugin, taking a config option for deep/shallow?\n. Mm. I have to agree with @ricardograca here. However, I'd additionally add that I think that these lodash extensions should be removed from core. I only suggest moving them to a plugin because it will be a quick fix for people already using them.\nThey don't seem so useful to be worth saving the characters.\njs\n_.omit(model.toJSON(), blacklist);\n// vs\nmodel.omit(blacklist);\nIn my opinion there's no need for a shorthand to functions that already sit on a one character identifier. Also, using _ and toJSON makes the function of the code more explicit and understandable (albeit less terse).\nWith regards to the serialization changes, they seem appropriate. I'd still use the visibility plugin for hiding fields though.\n. Just did some cursory investigation. Origin of problem:\njs\n// Listen to added models' events, and index models for lookup by\n// `id` and by `cid`.\nmodel.on('all', this._onModelEvent, this);\nBaseCollection lines 97-99\nIt's possible to prevent warning by increasing max listeners emitter.setMaxListeners(n). It seems that this just changes the number at which a warning is produced, and doesn't actually affect functioning. Default max listeners is 10.\nThis code adds a single listener to a model's all event when it is added to the collection. There is no complimentary call to removeListener in Collection#remove().\nSo, I realize weeks have past, but do either of you (@rkmax or @b3njamin) recall if might have been doing something like adding the same model to collection(s) more than 10 times? This would trigger the warning (which is actually a memory leak then). If you don't think this was happening, then this will require further investigation. Another possibility is that client code is using the all event and causing the leak.\nEither way removeListener should be added to Collection#remove. I'll accept a PR for this.\n. Any chance either of you could supply a code example or test case that reproduces the error?\n. The problem is here.\njs\nmodel.changed = setProps(Object.create(null), this.changed);\nshould be\njs\nmodel.changed = Object.create(null);\nsetProps(model.changed, this.changed);\nOr alternatively setProps could be modified to return the first argument.\n. Actually setProps has a big bug in it too:\njs\nfunction setProps(obj, hash) {\n  var i = -1, keys = Object.keys(hash);\n  while (++i < hash.length) {\n    var key = hash[i]  // <-- here\n    obj[key] = hash[key];\n  }\n}\nProbably the correct fix would be to remove setProps and use model.changed = _.clone(this.changed);, unless there is some compelling reason not to. Are you willing to make a PR for this @adomasven? I've never had a use for .clone(), but I have the test environment set up if you'd prefer me to do it.\n. The variables keys is never used. I updated the comment.\nOkay, I'll have a look at in the next couple of days.\n. Hey @adomasven, that's what I came up with. It was a bit more involved than I'd expected.\nSince you're using clone, maybe you could point your package.json dependency at the PR to check if it works for you? I just added one fairly basic test case, there might be more complex use cases that fail.\n. @blah238 Thanks for the confirmation.\n. Hey, this appears to have been dropped with the Backbone dependency in 0.8. I'm not sure what the intention was here, but there's a discrepancy between the API and the documentation. I'm not sure which needs to be corrected though.\nIs listenTo particularly useful?\n. Hey, this appears to have been dropped with the Backbone dependency in 0.8. I'm not sure what the intention was here, but there's a discrepancy between the API and the documentation. I'm not sure which needs to be corrected though.\nIs listenTo particularly useful?\n. I agree this is problematic. The main issue is I have is Model.fetchAll(withRelated: 'hasOneRelation').toJSON() adds empty objects for these relations (instead of null).\nPerhaps an option like: toJSON({ omitNew: true }) might solve that problem?\nIn terms of using the relation in logic, it's pretty easy to work around. You can called isNew() on the related model: It will return true if it's empty. Also, Model.hasOneRelation().fetch() will still resolve to undefined, as you'd expect.\nSimply setting the model reference to undefined would break use cases like this: Model.related('hasOneRelation').set(attrs).save(), as you'd be calling set on undefined...\n. Null please. Undefined properties are excluded in JSON.stringify output.\nOn Tue, Jun 14, 2016, 6:30 AM Matteo Ferrando notifications@github.com\nwrote:\n\nI'm doing the pull request to this, should the serializer return undefined\nor null in relations that return true for isNew?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/753#issuecomment-225698882,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/AAyLWZ2QqOKqL4JEBOMfoX1E_ZXUWNonks5qLb30gaJpZM4EiKfm\n.\n. Closing this as we now have Model#refresh in master.\n. > ...fails due to the errors it uses being static properties on the model...\n\n@luggage66 Actually ES6 extends does do static inheritance - the inheriting class will take the static properties of the parent.\n``` js\nclass Test {\n  static test() { return \"hello\";}\n}\nclass Child extends Test {}\nconsole.log(Child.test());\n// \"hello\"\n```\nThe problem is that Bookshelf's extend method has an additional functionality that decorates the class with specific instantiations of these errors. Because ES6 offers no static constructor, I don't know that we can recreate this exact API using the new class syntax. However this is certainly something I'm keeping in mind moving forward.\nThe rationale behind having this sublcassed errors is for catching by type in Bluebird. eg.\njs\nUser.forge({id: 1}).fetch({require: true}).then(function (user) {\n  return user.account().fetch({require: true});\n}).catch(User.NotFoundError, function (error) {\n  console.log(\"User not found!\");\n}).catch(Account.NotFoundError, function (error) {\n  console.log(\"Account not found!\");\n}).catch(function (error) { console.log(\"Unknown error occurred: \" + error); });\nI have two possible solutions for this. I prefer the second.\n1. Lazily create error classes\nInstead of having Model.NotFoundError, use Model.error('NotFound') to return the error instance. Since there is no static constructor, we'll have to define the error the first time this is called. So something like this:\njs\nclass Model {\n  // ...\n  static error(errorName) {\n    errorClass = `${errorName}Error`;\n    if (this[errorClass] == null) {\n      this[errorClass] = class extends super.error(errorName);\n    }\n  }\n}\nSo that allows the above use of catch by type, like this:\njs\nUser.forge({id: 1}).fetch({require: true})\n.then((user) => user.account().fetch({require: true}))\n.catch(User.error('NotFound'), (error) =>\n  console.log(\"User not found!\")\n);\n2. Give model type to errors\nProvide a model type like so:\n``` js\nclass NotFoundError extends Error {\n  constructor: (message, Model) {\n    this.Model = Model;\n    super(message);\n  }\nstatic forModel(Model) {\n    return (error) => error instanceof this && error.model = Model;\n  }\n}\n```\nThat class just lives at bookshelf.NotFoundError and is always fired with the model constructor as an argument. Then catch like so, taking advantage of Bluebird's catch allowing a callback.\n``` js\nimport {NotFoundError} from 'bookshelf';\nUser.forge({id: 1}).fetch({require: true})\n.then((user) => user.account().fetch({require: true}))\n.catch(NotFoundError.forModel(User), (error) =>\n  console.log(\"User not found!\");\n);\n```\nThis is not a high priority change yet. There are other features that will be affected by moving to ES6 classes. However, I'd like to get everything right, so feedback is encouraged. :+1:\n. @luggage66 extends already does static inheritance. If you want to get this happening, please consider providing a PR implementing my second proposal from the post above.\nAFAIK Decorators are ES7 and the standard has not yet been finalized, and this can be achieved without them anyway.\nJust a note on back compatibility here. Errors can be removed from the Model classes entirely, alleviating this problem. However, they were placed on the classes so that they could be used in combination with Bluebird's Promise#catch, which also accepts a predicate as an argument. so we can do something like this:\n``` js\n// import new errors module\nimport { NotFoundError } from './errors';\n// model definition\nclass Model {\n  static NotFoundError(error) {\n    deprecate('NotFoundError');\n    // Use the predicate on our error class.\n    return NotFoundError.forModel(this)(error);\n  }\nfetch() {\n    // ...\n    throw new NotFoundError(this.constructor);\n    // ...\n  }\n}\n```\nAre you up for helping out with this change?\nedit: Fixed the deprecated NotFoundError example.\n. > It at least copies collection, forge, fetchAll, etc.\nES6 extend does this already...\n. I've never used TypeScript, but if you use ES extend, it would copy the static error classes from Model  onto your new subclass. Bookshelf's Model.extend has an additional functionality that does extra work by the magical extended function. Errors get subclassed via Model.extended.\nSo presumably, using ES inheritance you get this:\n``` js\nclass Account extends bookshelf.Model {  / ... / }\nclass User extends bookshelf.Model {  / ... / }\nassert.equal(Account.NotFoundError, User.NotFoundError);\n// The purpose of subclassing being for Bluebird's catch by type.\nPromise.all(\n  Account.where({ id: 1 }).fetch({ require: true }),\n  User.where({ id: 1 }).fetch({ require: true })\n).catch(Account.NotFoundError, error => / could be either account or user / );\n```\nThe solution is to stop subclassing errors and provide some other method for catching them. We could add a static for() method and an instance of the issuing class to each error.\n``` js\nclass NotFoundError extends Error {\n  constructor(Model) {\n    this.name = 'NotFoundError';\n    this.Model = Model;\n  }\n  static is(maybeError) {\n    return maybeError instanceof Error && maybeError.name === this.name;\n  }\nstatic for(Model) {\n    return error => this.is(error) && this.Model === Model;\n  }\n} \n// ...\nconst { NotFoundError } = bookshelf.Model;\nPromise.all(\n  Account.where({ id: 1 }).fetch({ require: true }),\n  User.where({ id: 1 }).fetch({ require: true }))\n.catch(NotFoundError.for(Account), error => console.error('account not found!'))\n.catch(NotFoundError.for(User), error => console.error('user not found!'));\n``\n. @bogas04 We still need an error implementation and then we can add ES6 examples to the docs. I've added the \"PR please\" label as I am not actively working on Bookshelf presently. I will review any submissions though.\n. Hi @pschuegr, I'm going to close this one. Please raise it as a knex issue. Cheers!\n. You can see [here](https://github.com/tgriesser/bookshelf/blob/master/lib/model.js#L105-L113) that thefetched` event is fired after the eager relations are loaded.\nTry Model.forge({id: 1}).fetch({withRelated: 'relationas', debug: true}) to see if the relation query is being called correctly.\n. I think:\n``` js\nvar model = Model.forge();\nmodel.related('things').on('fetching:collection', handler);\nmodel.load('things'); // should call handler\nvar model.related('item').on('fetching', handler);\nmodel.load('item'); // should call handler\n``\n. Yes, after the response has been received.\n. Yeah, I think you're right. There is currently no event on [eager loading](https://github.com/tgriesser/bookshelf/blob/863ad8d3175e084558c13aa86beabeabae2b06b8/lib/eager.js#L23-L38).\n. Thanks guys. I'll close this as a duplicate of #253. Further discussion should happen there.\n. The best way to achieve this would be to override your [Model#serialize`](https://github.com/tgriesser/bookshelf/blob/0.8.1/lib/base/model.js#L84-L100) function.\nSomething like this:\njs\nMyModel = bookshelf.Model.extend({\n  serialize: function(options) {\n    var attrs = _.clone(this.attributes);\n    if (options && options.shallow) return attrs;\n    var relations = this.relations;\n    for (var key in relations) {\n      var relation = relations[key];\n      attrs[key] = relation.toJSON ? relation.toJSON(options) : relation;\n    }\n    if (options && options.omitPivot) return attrs;\n    if (this.pivot) {\n      var pivot = this.parse(this.pivot.attributes); // <-- Added parse here\n      for (key in pivot) {\n        attrs['_pivot_' + key] = pivot[key];\n      }\n    }\n    return attrs;  \n  }\n});\nThis should give you the behaviour you want for now.\nThe real problem is here though. If no \"through\" model is provided, it defaults to the original bookshelf.Model. So even if you replace bookshelf.Model with your own base with custom parse/format, the pivot model does not use it.\n. Hey @rockingskier.\n\nI feel like I am either missing some crucial information or the point of this. :(\n\nOkay, so does this work?\njs\n  // Recipe\n  ingredients: function () {\n    return this\n      .belongsToMany('Ingredient')\n      .through(['RecipeIngredient'])\n      .withPivot(['measurement', 'sort_order']);\n  }\nI tend to do this, just because I don't like flattening the data:\njs\nRecipe.fetchAll({withRelated: 'recipeIngredient.ingredients'}).then(function (results) {\n  var json = result.toJSON();\n  // json is:\n  [{\n    id: ...\n    recipeIngredient: {\n      sortOrder: ...\n      measureMent: ...\n      recipedId: ...\n      ingredient: {\n        id: ...\n        name: ...\n        ...\n      }\n   }, { ...\n}]\nAlthough in this particular case I think the flattened data is probably appropriate.\n. Okay, it sounds like you've found a problem then. Thanks for the very detailed feedback. It would be preferable to get these test cases into the Bookshelf test framework and work from there.\nIf you're interested in tackling this there are instructions for setting up the test framework here. I'm happy to review your PR's and merge when ready. If you're unable to provide the PR, I (or someone else) should get around to it eventually, but you'll have less control over the delivery time.\nI expect that this fix I suggested should keep you going in the meantime either way.\n. No problem. I think the whole parse/format thing needs a bit of a rethink anyway. Hopefully this can be addressed with other outstanding issues in one fell swoop.\n. Hey @rockingskier I had a look into this last night using your example project (thanks for that). I discovered that it's not as simple a fix as I'd hoped for. I will keep looking into it, but it was hard to make a change that didn't touch a large portion of the relations codebase. This might have to be addressed with more than duct tape.\nI'll leave the issue open for when relations are revisited. Of course you're still welcome to try a PR if you're game.\n. Assume you're the guy I was talking to on IRC?\nJust for posterity here is my solution. It's as many queries as there are models in the updates collection, so it's not particularly efficient, but it does use idiomatic Bookshelf code.\nJavaScript\nbookshelf.transaction(function (trx) {\n  // get all references as a collection.\n  return MyModel.forge().query(/* whatever query */).fetchAll({transacting: trx})\n  .then(function(collection) {\n    // add updates with merge (this adds new instances where the ID is not already in the collection).\n    collection.add(updates, {merge: true});\n    // `save` will update or insert as required.\n    return collection.invokeThen('save', null, {transacting: trx});\n  });\n});\n. I'm guessing the cause of the problem is here:\nJavaScript\n  // Sets the constraints necessary during a `model.save` call.\n  saveConstraints: function(model, relatedData) {\n    var data = {};\n    if (relatedData && relatedData.type && relatedData.type !== 'belongsToMany' && relatedData.type !== 'belongsTo') {\n      data[relatedData.key('foreignKey')] = relatedData.parentFk || model.get(relatedData.key('foreignKey'));\n      if (relatedData.isMorph()) data[relatedData.key('morphKey')] = relatedData.key('morphValue');\n    }\n    return model.set(data);\n  },\nShould be something like: if (relatedData && !relatedData.throughTarget && relatedData.type && relatedData.type !== 'belongsToMany' && relatedData.type !== 'belongsTo')\n. I guess either the link should be removed or Model#cid should be documented. It's currently still being assigned to models.\n. Agreed. I guess something similar to Backbone's description should be added.\n. Hi @kimmobrunfeldt. I wonder if maybe initialize is the wrong place to be generating a validation schema? Without seeing the Rating class definition, I can't be sure, but I would suggest the folowing:\nI assume the validation schema is the same between all instances of Rating. Therefore create validation schema once on the prototype:\n``` js\nRating = bookshelf.Model.extend {\n  // instead of:\n  initialize: function() {\n    this.validationSchema = createRatingValidationSchema()\n  },\n// do this (extend adds properties directly to the prototype):\n  validationSchema: createRatingValidationSchema();\n}\n```\nValidating on creation can cause problems down the track (for instance if you wish to start with an empty instance and set attributes one at a time). Also, it causes unnecessary validations (as you're discovering). I personally validate my models in the saving event callback. This is called before any update or insert operations are executed.\njs\n  initialize: function() {\n    this.on('saving', function() { this.validate(); });\n  }\n. > For single request, the model's initialize function is called ~10 times.\nI had assumed that this was because it was returning a collection with 10 models in it. In which case it needs to initialize each of them individually. Is initialize being called more than once per model?\n. Well, if you want to optimize you could do this:\n``` js\nvar query = Rating.query()\n  .where('category', opts.category)\n  .limit(opts.limit)\n  .offset(opts.offset);\nquery.then(//...\n```\nCalling Model.query will only return a query builder if you give it no arguments. The way you did it in your example is actually returning a Rating instance and modifying the underlying query builder which is used in fetchAll.\nIf you do as I have above, it will just execute raw knex query, which will be more optimal as it will bypass model creation. Just keep in mind that it wont parse your output keys.\n. @adomasven Well, I've written tests and am pretty confident that it works. There might be some edge cases, but I don't think so. It was completely broken before, so it has to be at least be an improvement! It probably needs a few more tests.\nAlso, it now supports cloning relations and a few other things that didn't work before. Tell me how it goes!\n. Thank you!\n. Thanks!\n. Can you post the declaration of Target#dataset and Dataset#hasMany, and also the bindings for the above generated query?\n. (Sorry, edited your post for code formatting)\n. Try this:\njs\n  target: function() {\n    return this.hasMany(Target);\n  },\n  schema: function() {\n    return this.hasMany(Schema);\n  }\nThe relation requires a Model, not a Collection. You don't need to define your own collections like that.\n. Sorry I can't resolve this right now. I'll get back to you if we need more info. If you could provide the binding for the generated query that would be good. You should be able to get them by passing debug: true to the options on fetch.\n. > I will work on getting a test case running with it tomorrow.\nGreat. If you could submit the failing test as a PR we can work from there. I'm still getting my head around the code base but I've got a fair idea of where to start looking.\n. Ah, looks like this is related: #550\n. I'm going to close this as a duplicate of #550. We can discuss the issue there. \n. Are you still interested in a fix for this one @ezra-quemuel? I've created a PR. Perhaps you could try checking it out into your project to see if it fixes the problem?\nI've changed the behaviour of fetch to always fetch by idAttribute if available. Also, I've made it always silently ignore JSON attributes when fetching. I think this works as you (and I) would expect, and passes all tests. Nonetheless, I'm not sure that I'm going to be able to pull it into master without a bit more consideration simply because it involves an API change.\n. Uh, actually the tests are failing on Travis CI. Maybe it's using a different version of node-pg or knex. It passed locally though.\n. The latter is correct. bookshelf.transaction is just a passthrough to knex.transaction.\n. I think Collection#where should be consistent with Model#where by having it modify the query.\nAlso to update docs to reference lodash instead of underscore. Also to deprecate findWhere.\nWhat do you think?\n. > Why does it need to be deprecated?\nOn second thought I'm not sure why I suggested that... :confused:. It would make sense to remain as an alias for the old where method. I guess we'll need agreement from @tgriesser for this as it would be a breaking change.\n. Hm, build's failing because node-postgres returns strings. I'm not sure if I should parse the response within count or leave that up to the library consumer.\n. Rather than modifying the qb knex instance, maybe it'd be cleaner to pass bookshelf.knex as a second argument:\njs\nModel.query(function (qb, knex) {\n  var sub = knex(...);\n  qb.join(sub);\n});\n. Cheers.\n. Thanks for the report. That looks like a bug to me. It would be great if you could add some test coverage for this as well.\n. @JbIPS So that's failing for \"Model hasTimestamps does not set created_at when {method: \"update\"} is passed\" currently.\n. :+1: \n. Thanks man. I ended up finding some problems in other parts of the code while I was reviewing your changes and ended up pulling your changes to my fork and fixing a few other things. Your commits are now in master though.\n. Not that I'm aware of. That would be up to @tgriesser. I'm pointing my project at git currently. Perhaps target a specific commit to ensure you don't get any surprises...\n. This is such a great idea. The less barrier for entry, the more quality PRs we should expect to receive.\nI recently went through this process myself and had to do a bit of head scratching.\nMy only criticism is that it doesn't reference the \"How do I run the test suite?\" guide for setting an environment variable pointing to a config file. You can actually specify user, password, database name etc for each DBMS.\n. Yeah, I tried to go down that route and got stuck on the no password thing. It's referenced in the docs.\n. Actually the only problem I had was accessing MySQL through phpMyAdmin, which disallows passwordless users. There was meant to be a flag to activate it, but it didn't seem to work. I ended up just using command line, phpMyAdmin was unnecessary.\nFor PostgreSQL I just used the Bookshelf config file, as I had no 'root' user, just my OSX username/password.\nSorry, not very helpful.\nOne thing that might be useful is a link to 'how to install' guides for each. I imagine the typical user has just one or the other installed.\n. The default template is at ./test/integration/helpers/config.js.\nThe config file I use looks like this:\n``` js\nmodule.exports = {\nmysql: {\n    database: 'bookshelf_test',\n    user: 'root',\n    encoding: 'utf8'\n  },\npostgres: {\n    user: [username],\n    database: \"bookshelf_test\",\n    password: [password]\n    host: \"localhost\",\n    port: 5432,\n    charset: \"utf8\",\n    ssl: false\n  },\nsqlite3: {\n    filename: ':memory:'\n  }\n};\n```\nI don't use my usual application database because it would damage my data!\nI put this file at ~/.bookshelf_config.js and add this line to my .zshrc (or .bashrc if you use bash):\nexport BOOKSHELF_TEST='/Users/[system username]/.bookshelf_config.js'\n. Amazing.\n. You're missing a return here.\njs\nfunction (project_id) {\n   if (req.body.project_tasks) {\n     return Datasource.Task.query(\"whereIn\", \"task_id\", req.body.project_tasks).fetchAll({ transacting: t })\n. No probs.\n. Database compatibility is achieved via knex. Knex supports Oracle, but currently bookshelf has no test coverage for Oracle.\nI'm not sure of plans in this area. @tgriesser might wish to expand on this answer.\n. Yeah, or at least it was discussed 5 months ago. If you want to follow this up further try over at knex. I'm going to close this one. Cheers.\n. Take another look at the registry plugin documentation. Your main mistake is not using a string to identify models in your relations. This means you're not using the registry plugin!\nActually I use the same pattern for my models. I use registry, but I pass an instance of bookshelf into each model file. So it's more like this:\nbookshelf-instance.js:\n``` js\nvar knex = / ... /\nvar bookshelf = require('bookshelf')(knex);\nvar fileNames = getModelFileNamesArray();\nfileNames.each(function (fileName) {\n  // No need to do any assignment here, because each model registers itself.\n  require(fileName)(bookshelf);\n});\nmodule.exports = bookshelf;\n```\nsome-model.js:\n``` js\nmodule.exports = function(bookshelf) {\n// This file is responsible for adding its model(s) to the registry.\n  bookshelf.model('SomeModel', bookshelf.Model.extend({\n    tableName: 'some_models';\n    owner: function() {\n      // Use string to identify other model, preventing circular dependencies.\n      return this.belongsTo('Owner');\n    }\n  });\n});\n```\nThen in your other source files, when you need models:\n``` js\nvar bookshelf   = require('./bookshelf-instance');\nvar Client      = bookshelf.model('Client');\nvar User        = bookshelf.model('User');\nvar ProjectTask = bookshelf.model('ProjectTask');\n/ Code that uses models... /\n``\n. Note to self: Updates tests in accordance with [knex's behaviour](https://github.com/tgriesser/knex/blob/5e65678b32fa639843902d39603ab2050d84f10f/lib/dialects/postgres/schema/columncompiler.js#L40-L43). Test output should be checked against string/json based on Postgres version.\n. Note to self: Updates tests in accordance with [knex's behaviour](https://github.com/tgriesser/knex/blob/5e65678b32fa639843902d39603ab2050d84f10f/lib/dialects/postgres/schema/columncompiler.js#L40-L43). Test output should be checked against string/json based on Postgres version.\n.JSON.stringifycallsObject#toJSON()internally, so you're all good. [More info on MDN](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON_behavior).\n.JSON.stringifycallsObject#toJSON()` internally, so you're all good. More info on MDN.\n. Relevant discussion here: #246.\n. Relevant discussion here: #246.\n. Hi @light24bulbs. You'll be happy to know that I actually wrote this change yesterday.\nI can't see any problem with changing the behaviour of fetch for this. As was pointed out in a couple of other issues, having fetch match on columns other than idAttribute has unexpected behaviour such as using non-indexed columns and sometimes attempting to fetch with JSON attributes (which have no equality operator).\nI just haven't merged the changes in because of the problems with the new JSON tests in Travis CI.\nSemantically I like the idea of refresh,reload or renew, but since fetch currently updates the model on which it's called, it makes sense to just change its behaviour.\nUltimately I think it would be nice to have a distinction between fetch and refresh. refresh would update the model itself, and fetch gets a nice model. I think it's too soon for such a dramatic API break though.\n. Hi @light24bulbs. You'll be happy to know that I actually wrote this change yesterday.\nI can't see any problem with changing the behaviour of fetch for this. As was pointed out in a couple of other issues, having fetch match on columns other than idAttribute has unexpected behaviour such as using non-indexed columns and sometimes attempting to fetch with JSON attributes (which have no equality operator).\nI just haven't merged the changes in because of the problems with the new JSON tests in Travis CI.\nSemantically I like the idea of refresh,reload or renew, but since fetch currently updates the model on which it's called, it makes sense to just change its behaviour.\nUltimately I think it would be nice to have a distinction between fetch and refresh. refresh would update the model itself, and fetch gets a nice model. I think it's too soon for such a dramatic API break though.\n. Oh, sorry, I probably wasn't clear enough. It checks for the presence of idAttribute and fetches by that. If not it uses its current behaviour.\n. Oh, sorry, I probably wasn't clear enough. It checks for the presence of idAttribute and fetches by that. If not it uses its current behaviour.\n. Okay, good to hear feedback on this. I wasn't sure whether to go ahead with it. Personally I was surprised by the behaviour of fetch (as were others #550, #778). It is inconsistent with the behaviour of save which assumes that an object exists if it has an idAttribute.\nBut you've raised a valid point. Perhaps refresh would be more appropriate. Ultimately I think this API would be cleaner:\n``` js\n// deprecated\nModel.forge({id: 4}).fetch()\n// preferred\nModel.where({id: 4, other: 'value'}).fetch();\nModel.forge({id: 4}).refresh();\n``\n. Okay, good to hear feedback on this. I wasn't sure whether to go ahead with it. Personally I was surprised by the behaviour offetch(as were others #550, #778). It is inconsistent with the behaviour ofsave` which assumes that an object exists if it has an idAttribute.\nBut you've raised a valid point. Perhaps refresh would be more appropriate. Ultimately I think this API would be cleaner:\n``` js\n// deprecated\nModel.forge({id: 4}).fetch()\n// preferred\nModel.where({id: 4, other: 'value'}).fetch();\nModel.forge({id: 4}).refresh();\n``\n. Well, at the moment I think just addingrefreshis enough. I agree that the current behaviour offetchon a Model instance doesn't make sense. You'd expect it to update the model, but it doesn't, in fact it will fail if the row has changed.\n. @light24bulbs Hey mate, this is now in master. I took your advice and leftfetchas it is.refreshwill default tofetch's behaviour if noidAttribute` is present. If you're keen you can point your project dependency the current head commit to get the change. Thanks for the feedback.\n. Hm, don't forget to read the docs!\nSomething like this perhaps?\n``` js\ngetPopular: function(limit, offset) {\n  return this.query(function(query) {\n    var postIds = knex('posts')\n      .select('id')\n      .sum('votes as points')\n      .join('votes', 'post.id', 'votes.track_id')\n      .groupBy('post.id');\nquery.join(postIds.as('y'), 'y.id', 'posts.id')\n  .orderByRaw('(y.points - 1)/POW(((UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(x.timestamp))/3600)+2, 1.5) DESC');\n  .limit(limit)\n  .offset(offset)\n\n}\n```\n. Hm, don't forget to read the docs!\nSomething like this perhaps?\n``` js\ngetPopular: function(limit, offset) {\n  return this.query(function(query) {\n    var postIds = knex('posts')\n      .select('id')\n      .sum('votes as points')\n      .join('votes', 'post.id', 'votes.track_id')\n      .groupBy('post.id');\nquery.join(postIds.as('y'), 'y.id', 'posts.id')\n  .orderByRaw('(y.points - 1)/POW(((UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(x.timestamp))/3600)+2, 1.5) DESC');\n  .limit(limit)\n  .offset(offset)\n\n}\n``\n. Okay, here's how I debug these things - threre's probably a better way, but this is fairly simple. Just go to http://knexjs.org and paste your JS into the console followed by atoString().bookshelf.knexis the same asknex` in the console there. So paste this:\n``` js\n  var trackIds = knex('tracks')\n    .select('tracks.id')\n    .sum('votes as points')\n    .join('votes', 'tracks.id', 'votes.track_id')\n    .groupBy('tracks.id');\nknex('tracks').join(trackIds.as('y'), 'y.id', 'tracks.id')\n    .orderByRaw('(y.points - 1)/POW(((UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(x.timestamp))/3600)+2, 1.5) DESC')\n    .limit(limit)\n    .offset(offset).toString();\n```\nThat will output the compiled query and you can play from there.\nSo yeah, this query: knex.select('id') has no table name, so is never going to be useful. The error error: function sum(votes) does not exist suggests that votes is not a column type that can be summed. Is it an integer or float? Or is it a varchar or something else that doesn't make sense to add?\n. Oh, and John passed on your message. My pleasure. :wink: \n. @tgriesser With regards to tests, I'm currently having a problem with this PR. Is there a good way to check if the database knex is connected to has JSON column support so I can switch between text and json output? I tried a variant of this but the version property is not present on bookshelf.knex.client.\nI've no problem with mocha, but I'm happy to gradually move tests to tape if you believe it's a superior framework.\n. Hey @tgriesser, I ended up resolving aforementioned problem :relieved:. If you'd like to move to tape I think it'd be best if you set up the framework since you have a concept of how it should work. If you can get it all set up I'm happy to start using it exclusively.\n. Yeah, this is great. I've actually been thinking a lot about potential improvements to relations and collections. I definitely think that collections can be completely discarded in preference of bare arrays (no decoration at all).\n\nWould be nice if the bare array still had a model property--I use that a lot in endpoints when passing around collections.\n\nRather than having bookshelf.load, how about having MyModel.load and MyModel.save. They could take a completely bare array of either models, or plain objects. The static methods could have an awareness of the correct table, and the existing relations for the model.\nSomething like this:\n``` js\n// this below is the constructor of an extended Model.\nfunction save(models, options) {\n// Accepts single model or array.\n  if (!_.isArray(models)) models = [models]\n// Separate new and existing models.\n  var grouped = _(models)\n    .map(function(model) {\n      return model instanceof this ? model.attributes : model;\n    });\n    .groupBy(models, function(model) {\n      return this.isNew(model) ? 'update' : 'insert';\n    })\n    .value();\n// Bulk insert - currently not supported by bookshelf.\n  insertPromise = this.query().insert(grouped.insert);\n// Update each model.\n  updatePromises = .map(grouped.update, function(model) {\n    return this.where(.pick(model, this.idAttribute)).query().update(model);\n  }\n// Resolve all and return.\n  return Promise.all([updatePromises, insertPromise].flatten())\n    .then(function (results) {\n      return _.pluck(results, 'rows');\n    })\n    .map(function (row) {\n      return this.forge(row);\n    });\n}\n// Example use:\nContributor.save([{name: 'tim'}, {name: 'ricardo'}, {name: 'rhys'}]);\n```\nThis offers a generic way of saving either raw data or arrays of models returned from fetch. No decorated arrays required! Also bulk insert, which is currently lacking.\nAnother thing to do would be to make sure the constructor (Contributor) is fully aware of all relation types (currently not possible, but I have some ideas here). Then we can also do a recursive save:\n`` js\n// Can use raw object or aContributor` model.\ntim = {\n  name: 'tim',\n  projects: [{name: 'bookshelf'}, {name: 'knex'}],\n  websites: [{url: 'bookshelfjs.org'}, {url: 'knexjs.org'}]\n};\n// Save just contributor and projects relation.\nContributor.save(tim, {withRelated: 'projects'});\n// Or save all (equivalent)\nContributor.save(tim, {withRelated: ['projects', 'websites']});\nContributor.save(tim, {withRelated: true});\n// withRelated: true here meaning to interpret all known relation keys as relations, rather\n// than attributes. Alternatively they could be specified by name.\n// Or (for a single model) just use the original method (with new withRelated option):\nContributor.forge(tim, {withRelated: true}).save({withRelated: true});\n```\nWhat do you guys think?\n. Oh, yeah, and Model.load would be much the same, if that wasn't clear.\n. > Potentially simplifying the knex internal query constructed\nAlso I don't think asPartial will be necessary for this. I have a lot of ideas and I don't want to just brain dump until I've pieced them all together. If you guys like this direction I can spend a bit of time putting the ideas together in one place.\n. Right, that makes a lot of sense. This actually seems a lot cleaner than making constructor models with lots of static data attached.\nIf I understand correctly though, these ideas are actually compatible, simply replace all instances of Contributor with bookshelf('contributor'). \nIs that case, it would be something like this:\njs\nbookshelf('contributor').save({name: 'tim'}, {name: 'ricardo'}, {name: 'rhys'});\nbookshelf('contributor').withRelated(['websites', 'projects']).save(tim);\n\nthe goal for the long-term api is to drop stateful models\n\nDo you mean the actual models returned from say, forge, or the constructors themselves?\n. Right! I'll write my proposal up later, there's actually more subtlety to\nthe idea that I haven't detailed.\nOn Wed, 17 Jun 2015 3:59 am Tim Griesser notifications@github.com wrote:\n\nDo you mean the actual models returned from say, forge, or the\nconstructors themselves?\nSorry, edited above. I meant the constructors\nbookshelf('contributor').save({name: 'tim'}, {name: 'ricardo'}, {name: 'rhys'});\nbookshelf('contributor').withRelated(['websites', 'projects']).save(tim);\nHmm, so I was thinking that bookshelf('contributor') would result in a\nnew instance.\nbookshelf('contributor').assign({name: 'tim'}).save([options])\nThen the bookshelf object, or session / transaction object would have\nadditional methods for persistence:\nbookshelf.persist(>, [options])\nThe benefits to that approach are more apparent when you're saving with a\nbacking map tracking persisted objects via a session or transaction, e.g.\nbookshelfTransaction.persisted([...])\nThough maybe it should return a decorated constructor function as you\nmention. That actually might make more sense, plus it could probably be\ndone fairly cleanly with the ES7 decorator proposal.\nI have a bunch of this stuff in a branch locally, I'll get it out soon so\nwe can discuss pros/cons of various apis.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/799#issuecomment-112515057\n.\n. > Though maybe it should return a decorated constructor function as you mention. That actually might make more sense, plus it could probably be done fairly cleanly with the ES7 decorator proposal.\n\nI think just using static methods is enough, and I just read that they are inherited! If this is correct, it would be really useful and could lead to some clean patterns.\nI've been reading up about these new features, but I'm not 100% over them yet. I assume that we want to target latest ECMA spec for this stuff and then transpile back to something compatible with node?\n. @ricardograca Oh, sorry. I'm currently working on Model and ModelBase.\n. Changelog in JSON, courtesy of @tgriesser.\n. Model and ModelBase documentation is complete.\n. Starting work on Collection and CollectionBase.\n. Collection and CollectionBase are complete.\n. Note: Must update attach docs https://github.com/tgriesser/bookshelf/issues/29#issuecomment-116712479\n. First draft of design completed.\n\n. Thanks.\nAh, I decided to group some of the less salient info into the \"Misc\" section.\nSo it would be something like:\n\nFires \"fetching\", \"fetched\". Throws ModelNotFoundError. See also Model#fetch.\n\nI was thinking that some methods have a lot of info that doesn't justify the vertical space usage. A lot of the method descriptions are already pretty wordy and cover the more complex details of these features. If this turns out to be more confusing than helpful it can be changed pretty easily.\n. Add versions as suggested here #888.\n. @ricardograca Yeah, I've squashed the commits and manually rebased them into a new branch. They just need some test coverage and they'll be good to go.\n. So, firstly, for some context, here is the readme example as I'd have it. Whenever you see a Model used explicity, it could just as easily be bookshelf('Model') in the style of the model registry. I've basically tried to make the interface look as much like Tim's example yesterday as possible.\n``` js\nimport {Model, relation, table} from 'bookshelf';\n@table('users')\nUser extends Model {\n  @relation\n  static messages() { return this.hasMany(Posts); }\n});\n@table('messages')\nPosts extends Model {\n  @relation\n  static tags() { return this.belongsToMany(Tag); }\n}\n@table('tags')\nTag extends Model {}\nUser.where('id', 1).withRelated('posts.tags').fetch()\n  .then(user => console.log(user.related('posts').toJSON())\n  .catch(error => console.error(error));\n```\nThe @table decorator exists to add the table name directly to the model constructor (ie. Tag.tableName === 'tags').\n. Now the main thing I wanted to achieve with this design is to divorce the concept of chains from the actual model state. Because I want all 'command builder' chains to come off the constructor, they absolutely must not store state. A mutable constructor function seems bad. (I'm calling them 'command builders' to distinguish them from knex's 'query builder'.)\nSo, I came up with this concept of a ChainFactory class. I don't know how different it is from how lodash, knex do chaining, tbh, but this is unique in that it copies the static interface of the Model it starts on.\nI'll start from the bottom:\n``` js\n// -- ChainFactory\n// ChainFactory generates command chains that inherit from its static interface.\n// Any call to chain will either create a new chain, or continue an existing\n// one.\n//\n// The rule here is that every chainable method calls chain internally\n// to get an instance of \"itself\". This ensure that it will make sense when\n// bound to the ChainFactory constructor, and also when it's intantiated. When\n// instantiated chainInstance.chain is overridden to return itself.\n//\n// This obligation to call .chain() is hidden from consumers of Bookshelf, as\n// they can make their own chaining functions by calling .query() or .where()\n// as they can now.\nclass ChainFactory {\n  static chain() {\n// Create new object with this constructor as its prototype. This will give\n// the `chain` the static properties Class.*\nlet chain = Object.create(this);\n\n// Remove any static functions we don't want to chain. eg. `forge`.\n// We just override their name on the current object, shadowing the super\n// version.\n//\n// __notChainable is assigned by the `@doNotChain` decorator.\nfor (property in this) {\n  if (property.__notChainable) {\n    chain[property] = null;\n  }\n}\n\n// Now override the `prototype.chain` (ie. `ChainFactory.chain`), with a\n// function that returns itself. This way any chained calls\n// will not produce new instances.\nchain.chain = function () { return this; };\n\n// Allow state to be assigned here by inheriting classes.\nif (this.initializeChain) this.initializeChain(chain);\n\n// Return the new chain instance.\nreturn chain;\n\n}\n}\n// -- @doNotChain static method decoration\n// Tacks on a little flag to methods that we don't want to reveal in chains.\n//\n//     class MyThingo extends ChainFactory {\n//       @doNotChain\n//       someStaticFunction() {\n//         // ...\n//       }\n//     }\n//\nfunction doNotChain() {\n  return function decorator(staticFunction, name, descriptor) {\n    staticFunction.__notChainable = true;\n  }\n}\n```\nSo, just say you have Model extends ChainFactory, the object returned from Model.chain() is a new instance whose prototype is Model itself (not Model.prototype, which is what you'd get from new Model()). This means that it inherits the static interface. Because there are static methods that don't make sense in a chain, you can decorate them with @doNotChain to tell the chain factory to hide them.\nThis doesn't make a lot of sense in isolation so I'll move on to Model now.\n. So, he is the (fairly large) Model class that I've concocted.\n``` js\n// -- Model, based on existing model, but different.\n@staticAlias('q', 'query');\nclass Model extends ChainFactory {\n// Build a new model instance. Model.forge() is preferred.\n  //\n  //     Model.forge({id: 5});\n  //     // same as\n  //     new Model({id: 5});\n  //\n  // This is also overridden, however, to initiate a transacted save.\n  //\n  //     Model.transacting(trx).where(...\n  // \n  // is the same as:\n  //\n  //     Model(trx).where(...\n  //\n  constructor(attributes) {\n// No need to call `super` here, we're just inheriting static properties (amazing!).\n\n// Check if this is not being called as a constructor. Gives us the\n// transaction shorthand above.\n//\n// Much terser than `{transacting: trx}`, but still fairly clear in the\n// context of a transaction callback.\nif (arguments.callee !== this.constructor) {\n  // If there are no arguments we return a command chain bound to a\n  // transaction.\n  let transaction = attributes;\n  return this.transacting(transaction);\n}\n\n// Set initial attribute state.\nthis.attributes = new Map();\nthis.set(attributes);\n\n// Call overridden initializer.\nif (this.initialize) this.initialize();\n\n}\nget id() {\n    if (Array.isArray(idAttribute)) {\n      return idAttributes.map(attr => this.attributes[attr]);\n    }\n    return this.attributes[idAttribute];\n  }\nisNew() {\n    return _.isEmpty(this.id);\n  }\n// Classic attribute mutator.\n  set(attributeName, value) {\n    _.isString(attributeName) {\n      this.attributes.set(attributeName, value);\n    } else {\n      let attributes = attributeName;\n      Object.keys(attributes).forEach((key) =>\n        this.attributes.set(key, attributes[key])\n      );\n    }\n  }\n// Classic attribute accessor.\n  get(key) {\n    return this.attributes.get(key);\n  }\n// A few passthroughs here, for convenience.\n  load(related, {transacting}) {\n    return this.constructor(transacting).withRelated(related).load(this);\n  }\n  save({withRelated, transacting}) {\n    if (this.isNew()) {\n      this.create.apply(this, arguments);\n    } else {\n      this.patch.apply(this, arguments);\n    }\n  }\n  patch({withRelated, transacting}) {\n    return this.constructor(transacting).withRelated(related).patch(this);\n  }\n  create({withRelated, transacting}) {\n    return this.constructor(transacting).withRelated(related).create(this);\n  }\n// refresh replaces fetch. fetch only exists to terminate chains. You\n  // can only refresh models. (I kind of prefer renew here because it sounds\n  // like re-borrowing a book from a library. Thematic heh.)\n  refresh({transacting}) {\n    let attributes = this.isNew()\n      :  this.attributes\n      ?  _.pick(this.attributes, this.idAttribute);\nreturn this.constructor(transacting).where(attributes).fetch()\n\n}\n// -- Static non-chained members --\n// Model.load(engine, 'carriages')\n  // // or...\n  // Model.load(users, 'accounts', 'messages')\n  //\n  // Doesn't support nested loading.\n  @doNotChain;\n  static load(target, ...related) {\n// Accept array input.\nif (_.isArray(related[0])) related = related[0];\n\n// Bulk load each relation type.\nreturn Promise.all(related.map(relation => {\n  let rel = this.relation(relation);\n  return rel.attach(target);\n});\n\n}\n@doNotChain;\n  static forge(attributes) {\n    return new this(attributes);\n  }\n// -- Chain members --\n// Intialize the chain instance.\n  @doNotChain;\n  static initializeChain(chain) {\n// `this` here is the constructor, as it's a static function.  Note,\n// `tableName` is attached statically to the class constructor.\nchain._ModelConstructor = this;\nchain._queryBuilder = knex(this.tableName); \nchain._withRelated = new Set();\nchain._returnSingle = true;\nchain._columns = undefined;\nchain._where = new Map();\n\n}\n// Set this chain to return all rows when fetch is called.\n  static all() {\n    let chain = this.chain();\n    chain._returnSingle = false;\n    return chain;\n  }\n// Set this chain to return a single row when fetch is called.\n  static one() {\n    let chain = this.chain();\n    chain._returnSingle = true;\n    return chain;\n  }\n// Add relations to be retrieved with the query.\n  // Could just be called with.\n  //\n  //   House.where({id: 5}).with([rooms, occupants]).fetch();\n  //\n  static withRelated(relations) {\n    let chain = this.chain()\n    relations = Array.isArray(relations) ? relations : [relations];\n    relations.forEach(relation =>\n      chain._withRelated.add(relation);\n    );\n    return chain;\n  }\n// How about using the following instead of the object syntax?\n  //\n  //     Model.q('where', 'id', '<', 10).q('where', 'id', >, 2).all().fetch().then(//...\n  //\n  static query(method, ...args) {\n    let chain = this.chain();\n    let query = chain._queryBuilder;\n// Handle 'whereIn', 'id', [0,2,3] type syntax.\nif (_.isString(method) {\n  query[method].apply(query, args)\n  return chain;\n\n// Handle callback syntax.\n} else if (_.isFunction(method)) {\n  method.call(query, query, knex);\n  return chain;\n\n// Handle terminating chain when no arguments are passed.\n} else if (_.isUndefined(method)) {\n  return query;\n\n// Tell user if they made a mistake.\n} else {\n  throw new Error('unexpected argument');\n}\n\n}\nstatic limit(limit) {\n    this.query('limit', limit);\n  }\nstatic offset(offset) {\n    this.query('offset', offset);\n  }\n// Set the current transaction.\n  // Actually would like to use this shortcut as well:\n  //\n  //     Model(transaction).where('id', 5)...\n  //\n  // This allows Model(null) too, so you can write functions that are\n  // transaction agnostic.\n  //\n  static transacting(transaction) {\n    if (transaction) {\n      return this.query('transacting', transaction);\n    }\n    return this.chain();\n  }\n// Just the hash argument here.\n  static where(attributes) {\n// Do all the prefixing and formatting here so that the consumer doesn't\n// have to. Also helps with DRY in Relations.\n//\nlet formatted = this.prefixKeys(_.mapKeys(attributes, this._formatKey));\nreturn this.query('where', formatted);\n\n}\n// fetch. Now you can't call it on instances (see renew. It terminates a\n  // command chain and builds a query based on the state it accrued during its\n  // lifespan.\n  //\n  static fetch() {\nlet single  = this._returnSingle,\n    columns = this._columns,\n    related = this._withRelated,\n    Model   = this._ModelConstructor;\n\n// Now construct query. We just discarded the last reference to the chain\n// by not providing `query` with arguments.\nlet qb = this.chain().query();\n\nif (single) qb.limit(1);\n\n// NOTE: `_this._columns` is `undefined` by default, so becomes '*'.\nreturn qb.select(columns) \n  .get('rows')\n  .map(record => Model.forge(_.mapKeys(record, this.parseKey))\n  .then((models) => _ModelConstructor.load(models, related))\n\n}\nstatic relation(relationName) {\n// Ensure we have a relations object.\nlet relations = this._relations || this._relations = {};\n\n// Do we already have a cached version of this relation?\nif (relations[relationName]) {\n\n  // Yes, return it.\n  return relations[relationName];\n} else if (this[relationName].__isRelation) {\n\n  // No, but we can make one.\n  return relations[relationName] = this[relationName]();\n\n  // Friendly errors.\n} else if (this[relationName]) {\n  throw new Error(`\n    There is a static function called ${relationName}, but it has not\n    been marked as a relation with the `@relation` attribute.\n  `);\n}\nthrow new Error(`Invalid relation name: ${relationName}`);\n\n}\n// -- Helpers.\nstatic parseKey(key) {\n    return key;\n  }\nstatic formatKey(key) {\n    return key;\n  }\nstatic prefixKeys(attributes) {\n    return _.mapKeys(attributes, (value, key) => ${this.tableName}.key)\n  }\n}\n```\n. Okay, so now for some explanation...\nSo, the important thing to note is that Babel's extend performs not only the normal inheritance you'd expect...\n``` js\nclass Child extends Parent { //...\n// is equivalent to:\nChild.prototype = Parent.prototype;\nChild.proto = Parent;\n```\nThis means that every time you extend, you get to take your entire static interface with you. This is the first language I've been able to do this in, so pretty cool.\nChain has all the static functions of Model (besides the ones decorated with @doNotChain), but their this value is pointing at the chain instance instead of the static model. To make this work, both Model and chain need to conform to the same interface - they both have a method called chain(), but it behaves differently for each.\n`` js\n// creating a new chain: internallywherecallsModel.chain` which is the chain factory method.\n// These are two separate instances:\nlet chain1 = Model.where();\nlet chain2 = Model.where();\n// However, because we inherit the static interface, they are easily modified by custom class definitions.\n@table('songs');\nclass Song extends Model {\n  static favourites() {\n    return this.query('listen_count', '>', 100); // calls chain internally.\n  }\n}\n@table('musicians');\nclass Music extends Model {\n  @relation\n  static songs() { return this.hasMany(Song); }\n}\n// Just works. (theoretically, ha)\nMusic.related('songs')\n  .favourites()\n  .whereIn('id', [0,1,2,3,4,5])\n  .query('artist_name', 'ilike', 'devo')\n  .query().count()\n  .then(result => console.log('you learned: ', result));\n``\n. So, something I noticed is true in the current code base, is thatRelationis essentially immutable after construction. This means that I was safely able to [copy it by reference](https://github.com/tgriesser/bookshelf/blob/master/src/base/model.js#L162) when I was restoringModel#clone` the other week. Of course nothing's really immutable in JS, but the API is currently designed so that you never interact directly with the Relation object.\nSo why bother instantiating these per object? You only need one per class. The basic idea is that the supplied relation definitions, eg\njs\n@relation\nstatic function acquaintances { return this.hasMany(Acquaintance).through(Friend); }\n...are considered to be factories for Relation models. (Much as they are now, but this time attached to the constructor instead of the instance, and only executed once).\nThe additional advantage of having these @relation attributes is that we can straight away know exactly which relations exist on a model, without any initialisation.\nSo, this makes these types of things much simpler:\n``` js\nlet person = {\n  name: 'Joe',\n  friends: [\n    {name: 'Tom'}, {name: 'Dick'}, {name: 'Harry'}\n  ]\n}\nPerson.withRelated('friends').save(person)\n.then(joe => console.log('joe is friends with ', _.pluck(joe.toJSON().friends, 'name').join(', '));\n```\nThis is how I do the same thing now:\njs\nvar person = // as above\nvar friends = person.friends;\nPerson.forge(_.omit(person, _.isObject)).save().tap(function(person) {\n  // Note constructing lots of Model instances here, would no longer be necessary.\n  return person.related('friends').add(friends).invokeThen('save');\n}).then(function (joe) {\n  console.log('joe is friends with ', _.pluck(joe.toJSON().friends, 'name').join(', ');\n});\nNow Person already knows what relations a Person  can have. This also makes the options withRelated: true possible, which would just store all relations. You could have a model with 12 different relations and your code would not get any larger (unlike the last example which would almost double in size). But anyway, I'm going to put the final touches on my Relation classes and post them here.\n. But first I'll mention transactions.\nThis is my proposed API:\n``` js\nbookshelf.transaction(transacting => {\n// withRelated() without arguments defaults to saving all known relations.\n  return Model(transacting).withRelated().save(data).then(model => { //...\n// Or we can do the equivalent from a model instance (the old way) like so:\n  return Model.forge(data).save({withRelated: true, transacting}).then(model => { //...\n});\n```\nBasically (shown in the massive Model definition above), the constructor is able to check if it's being called with new or not, and decide to return a chain with the query set to a transaction. This is purely for brevity.\n. Okay, stuff to think about certainly. I'll have a look through your branch.\n1.  I must admit I'm not entirely clear on your meaning here. Do you mean connecting to the database? Or connecting models by a conceptual relationship? (btw, that was just the readme example with changed syntax)\n2. Right, my main concern is not forge, but that model data and queries are all jammed into the one object abstraction, and they aren't necessarily related. Commands like where, select etc. I think that it's overloading the instance abstraction - hence why I went to the static interface. \n3. I'll read up about it. The intention would be to automatically update multiple models for the same item on insert/update?\n4. Yeah, that's a good idea. When you say 'the entire schema', do you just mean models and relations, or columns/types too?\n. > ...the User constructor doesn't have any knowledge of the db connection\nNeither the constructor, not the models have a reference to knex attached. Model has knex in scope, and creates a new knex QueryBuilder whenever a constructor chain is called. (see Model#initializeChain above for specifics.) This is to simplify design around query state (since there is none attached to instances). And also why I suggested that asPartial might not be necessary, as the query only lives for the lifespan of the chain.\n``` js\n{Model} = Bookshelf(knex);\n@table('users')\nUser extends Model { ... }\n// User has no knowledge of connection/knex\nUser.where('id', 1).withRelated('posts.tags').fetch().then(user => //...\n    |<-----        knex instance lifespan      ----->|\n// user also doesn't have any knowledge of db or knex. It just knows it can\n// call super.save(this) to save itself.\n```\n\nIn fact, you might not need\u2122 to define \"bookshelf models\"\n\nWell, you may not need to, but generally I like to add methods to my models for use within my app. My models tend to have a lot of business logic or helper methods to them. eg. User.resetPassword() User.allowedAccessTo(resource). There would still need to be some way to define functions like this.\nThe kinds model extensions I use (as a consumer of Bookshelf 0.8) can be grouped into three categories: instance methods (set, get), static methods (forge), and chainable methods (query, any relation method, where).\nWhat I would like to see is a clean, accessible way of defining and codifying those concepts and separating their APIs and state. But also allowing new models to be extended easily for use in application logic. The class syntax or Model.extend both seem like well understood conventions for defining objects, and I think the constructor chain thing is a nice way of encapsulating query state.\nWhat I really don't want is model instances to have any knowledge of a connection, or a knex instance. Just to be simple data containers with get, set, attributes, and a few convenience methods:\njs\n  patch({withRelated, transacting}) {\n    return this.constructor(transacting).withRelated(related).patch(this);\n  }\n  create({withRelated, transacting}) {\n    return this.constructor(transacting).withRelated(related).create(this);\n  }\n// ...\nSorry if I'm banging on about this, I just want to make sure that you understand what I'm getting at. I feel as though I haven't fully grasped your vision presently.\n\nColumns/types/potentially indexes as well\n\nThat's good to hear. I was under the impression that you didn't want that level of coupling between schema and ORM.\nUltimately, I'd probably prefer to tie the schema to the models, rather than read the schema from the DB. Then use a tool to generate knex migrations. That seems pretty far off at this stage though.\n. > Model should not be required to have knex in scope at construction time.\nRight. The one advantage I can really see to this is the ability to break models into different modules without having to pass a bookshelf instance to them. Is that the idea? In my current project I've separated my models and bookshelf initialization into a separate module, but this means doing this:\n``` coffee\n'server' module\norm = require('models')(config)\nMyModel = orm.model('MyModel')\n'models' module\nmodule.exports = (config) ->\n  knex = require('knex')(config.knex)\n  bookshelf = require('bookshelf')(knex)\ngetFiles('./models').forEach (file) ->\n    require(file)(bookshelf, config)\n./models/*\nmodule.exports (bookshelf) ->\n  bookshelf.model 'ModelName', bookshelf.Model.extend {\n    # ...\n  }\n```\nIt's kind annoying. It would be a lot cleaner if I could do this (which you appear to be suggesting):\n``` coffee\n'my-models' module\nmodule.exports {\n  User = require('./models/user')\n  Account = require('./models/account')\n  #...\n}\n./models/*\nbookshelf = require('bookshelf')\nmodule.exports = bookshelf.Model.extend {\n  # ...\n}\n'server' module\nknex = knex(config)\nbookshelf = bookshelf(knex)\nbookshelf.registerModels(require('my-models'))\n```\nThat said, all bookshelf() needs to do is this:\n``` js\nbookshelf = function(modelName) {\n  Model = this.modelCache[modelName];\n// In my approach like this. In yours you'd extend the prototype.\n  Model.createQueryBuilder = function() {\n    return new knex(Model.tableName);\n  }\n}\nbookshelf.registerModels = function(models) {\n  let cache = bookshelf.modelCache;\n  _.extend(cache, models);\n}\n```\nSo it's really not a very big change. In fact, I wonder how hard it would be to get a change like this going in master presently...\n\nthe rest of it is boilerplate that disappears when you know the schema.\n\nI can certainly see the advantage to that approach. Implicit relations would be very cool, but they would still require names for use. For instance, table A could have two different has-many relations to table B, (ie. table B has two FK columns referencing table A). So this would be ambiguous:\njs\n// Just assuming that you'd use table names instead of\n// model names when they're implicitly defined.\nbookshelf('table_a').related('table_b').fetchAll()\nOr perhaps that's fine to have as a kind of default setting, and you can upgrade to class definitions when you feel a concept is sufficiently complex, the above case being an example of that?\n. > Also if you have multiple connections accessing the same models, you can't mutate them, you'd need to extend and cache.\nRight. I'm with you now.\nI'll read through the next branch and keep iterating on this concept.\n\nPresumably the relations would come with pre-defined names.\n\nThoughts on syntax:\nYou could generate names based on column names, using similar assumptions that Bookshelf uses currently. So, say there is a table called people, with two FKs to people called friend_id, and another called family_member_id, you could generate a model called Person, and relations called friends and familyMembers. (You'd need a good pluralization library for the people to Person conversion, but it would be cool.)\nSo, Person could be a 'default model', with no extra functionality. The model could be instantiated lazily (ie. first time you request Person model, it looks through the schema for a table called people).\nIf you've already called bookshelf.registerModel('Person', MyPersonModel) then it will extend the model with whatever extra functionality you like, on top of the default relations. If you don't follow the convention of relation_name_id you would be required to add your own relations here (or potentially use a more.  So, you get all the benefits of automatic relations, with flexibility to extend at the cost of more verbose code.\n``` js\n// entry point to program.\nknex = require('knex')(/ config /)\nbookshelf = require('bookshelf')(knex);\n// No definition required, bookshelf intuits (and caches) relation friends when it\n// first initializes Person internally, via schema analysis.\nbookshelf('Person').friends().where('name', 'ilike', 'Joe%').fetchAll()\n// Now just say your 'friends' relation doesn't follow the required convention, you could do either of these:\n{Model, HasMany} = bookshelf;\n// cbf defining a model:\nbookshelf('Person').addRelation(HasMany, 'friends', 'people', 'friendFK');\nbookshelf('Person').friends().where('name', 'ilike', 'Joe%').fetchAll()\n// or with a model (not necessarily using decorators and stuff, I'm not even sure\n// if they're a good idea, but you get the point)\n@tableName 'people'\nPerson extends Model {\n  sayHello() {\n    console.log(Hello, ${@get('name')}!);\n  }\n// not sure if this attribute or static is necessary now, but via some method.\n  @relation\n  static friends() { return new HasMany(this, 'people', 'friendFK') };\n}\n// Register that model.\nbookshelf.registerModel('Person', Person);\n// Use original syntax. Only this time you get your decorated model.\nbookshelf('Person').friends().where('name', 'ilike', 'Joe%').fetchAll()\n// Can still access familyMembers because it did follow bookshelf conventions.\nbookshelf('Person').familyMembers()...\n```\nI realized while writing this that only one side of the relationship has a foreign key though, so it's not going to be able to generate names via the column name for everything (in fact the above example a self-referential edge case, it would usually only work for belongsTo and belongsToMany relationships, I can rewrite it later). Most of the time the FK is just the name of the table, singularized with _id attached. You could default the relation names on the other side with the relation's model name.\n. Also, I'm sure you're aware of this, but having the models unaware of connections unify the transaction and normal syntax, which is really cool.\njs\nbookshelf('Model')...\nbookshelf.transaction((transaction) {\n  transaction('Model')...\n});\nBut also another reason for not storing the queryBuilder in the model instance itself, as it might be tempting to take the model instance and use it outside of the transaction cb (which would not work). Perhaps the result of fetch should just be a simple object state (set, get, changed, etc.) without any save, load function at all, so you have to do this:\njs\nbookshelf.transaction((t) {\n  return t('MyModel').where(...).fetch()\n    .then(m => t('MyModel').load(m, 'relationName')\n    .then(m => // ...\n}.then(modelObject => {\n  // reusing model instance from trx, but it doesn't matter because all the connection info\n  // is coming from `bookshelf.\n  return bookshelf(`MyModel`).save(modelObject);\n})\nHm... Certainly not as readable as model.save()...\n. @kevinob11 @jordansexton Bookshelf is not currently under active development.\n. Hi @dxuehu. Thanks for that. I'm in the process of rewriting all the docs in JSDoc comments and hope to have the new documentation up and running in the next few weeks. I actually just went through Collection and saw these problems. I'm going to merge your changes into master and also copy them into the new documentation branch as well.\n. FYI, the \"change\" event is also no longer fired under any circumstances, and wont be restored (#802). Also, a refactor is in the works to remove the Collection type entirely and replace it with bare arrays.\nNonetheless I want to keep the API and documentation as tight as possible until these major changes come through, so please report any problems you discover. Much appreciated. :+1: \n. Discussion here: #633. I'm not familiar with the cause for the change but it sounds like endpoints is dependant on it. But the PR that @tkellen mentions appears to have been closed and the branch deleted without merging (may still have been included in the code base through other means). I'm just looking through the bookshelf code to get my head around this one...\n. Okay, this is why:\nbefore:\njs\nknex('table').distinct().select('table.*').toString();\n// select distinct \"table\".* from \"table\"\nafter:\njs\nknex('table').distinct().select([]).toString();\n// select distinct * from \"table\"\n. I think this should work - change here:\n``` js\n// before\ncolumnsInQuery = _.some(knex._statements, {grouping:'columns'})\n// after\ncolumnsInQuery = .some(knex._statements, (statement) =>\n  statement.grouping === 'columns' && !.isEmpty(statement.value)\n)\n// or perhaps...\ncolumnsInQuery = _(knex._statements).where({grouping: 'columns'}).some('value.length');\n```\nI'll try to throw this fix together soon unless you feel like submitting a PR.\n. Thanks for the report, @epeli. :+1:\n. @tkellen Can you comment on this \"upcoming rewrite\" mentioned here? Is there an issue relating to it?\n. @epeli, okay, that's fixed in master now.\n. You're welcome, @epeli.\n. Hi @babsonmatt, this is not supported by Bookshelf, but something like this might work as a workaround.\njs\nAtom = bookshelf.Model.extend({\n  tableName: 'atoms',\n  edges: function() {\n    return this.hasMany(AtomEdges, 'src').query('orWhere', 'dest', this.id);\n  }\n});\nI think this might fail in the case of Atom.fetchAll({withRelated: 'edges'}), but I'm not sure.\nAs this is an unusual type of relation, I think to support a case like this we'd need to allow for custom relationship definitions. This is not currently on the roadmap, but could be useful.\n. Hi @babsonmatt you're quite right. Just playing around with knex, it seems this is designed to be able to chain where and orWhere in a literal way.\njs\nknex('table').orWhere('a', 1).orWhere('b', 2).where('c', 3).orWhere('d', 4);\n// select * from \"table\" where \"a\" = 1 or \"b\" = 2 and \"c\" = 3 or \"d\" = 4\n// Note that first `orWhere` is treated as `where`.\nThe where in my suggestion is appended before the relation constraints are applied internally. So, the initial or is ignored. Currently there is no good way to address this while still retaining relation niceties such as withRelated, load etc.\nThis is going to have to be something to consider moving forward, but for now I suggest you just accept this as an unusal and unsupported use case and do something like this:\njs\nAtom = bookshelf.Model.extend({\n  tableName: 'atoms',\n  edges: function() {\n    return AtomEdge.collection().query('where', 'src', this.id).query('orWhere', 'dest', this.id);\n  }\n});\nIt wont work with withRelated, but at you'll get a function that you can use with fetch. eg. Atom.forge({id: 5}).edges().fetch().\nI'll leave this open for future reference.\n. Hi @thaume. The documentation in this regard is quite lacking. I'll quickly summarize the need-to-know information about plugins here for you.\nYou can view existing plugins (including registry) here. Or one I wrote here.\nCreating a plugin\nA typical plugin module looks like this:\n``` js\nmodule.exports = function (bookshelf, options) {\n// Alias original model for convenience.\n  // (This might be the model created by the previously registered plugin)\n  var proto = bookshelf.Model.prototype;\n// Create a new Model to replace bookshelf.Model.\n  var Model = Bookshelf.Model.extend({\n    constructor: function (attributes, options) {\n      proto.constructor.apply(this, arguments);\n  // ... Custom constructor behaviour.\n}\n\n// ... Other custom content.\n\n}\n// Replacement.\n  bookshelf.Model = Model;\n};\n```\nYou can also modify bookshelf.Collection similarly. This is the base Collection type returned by Relations.\nRegistering a plugin.\nPlugin registry code is here for reference.\nRegister a plugin via the following method: bookshelf.plugin(plugin, options).\noptions (Object)\nOptions is an optional argument that will be passed to the plugin initialization code.  It is passed as the second argument to the plugin function (see above). None of the three default plugins accept options, but it may have a place in your plugin.\nplugin (string|string[]|function)\nIf you provide a string it will try to find a module. It will first check for a match within the node_modules/bookshelf/plugins directory.\njs\nbookshelf.plugin('registry');\nIf nothing is found it will pass the string raw to require(), so you can either require an npm dependency by name or one of your own modules by relative path.\njs\nbookshelf.plugin('./bookshelf-plugins/my-favourite-plugin');\nbookshelf.plugin('plugin-from-npm');\nYou can also provide an array of strings, which is the same as calling bookshelf.plugin one with each string. In this case the same options object will be reused.\njs\nbookshelf.plugin(['registry', './my-plugins/special-parse-format']);\nHope that answers your question. I'm just going to leave this open as a TODO for adding this to the docs.\n. No probs. I was going to link you to the docs like a smart arse, then checked and saw there was nothing there... :laughing:\nWill have to address this as part of #800.\nI use a bunch of (my own) plugins with bookshelf, I find the base model can get a bit monolithic otherwise.\nHave fun.\n. @tgriesser Hey Tim, mind if I merge this into master? It's a bit of a hassle having to keep updating the feature branch as master evolves.\n. You can do your validation in the \"saving\" event fired by a Model.\njs\n// Like this, or via Checkit\nUser = bookshelf.Model.extend({\n  tableName: 'users',\n  initialize: function() {\n    this.on('saving', this._assertEmailUnique);\n  },\n  _assertEmailUnique: function(model, attributes, options) {\n    if (this.hasChanged('email')) {\n      return this\n        .query('where', 'email', this.get('email'))\n        .fetch(_.pick(options, 'transacting'))\n        .then(function (existing) {\n          if (!existing) throw new Error('duplicate email');\n        });\n    }\n  }\n});\nThis still allows for a race condition yes, but you can stop the database from getting into an inconsistent state by having a unique constraint. So in the rare case that two people sign up with a new email address at the exact same time, you'll return a 500, otherwise you can give a nice named error. For me that is satisfactory.\nI believe you can get better safety on this by using the correct transaction isolation level in the save, and having the same transaction used in the saving callback.\n. I was deliberately vague because I am not very knowledgable on transaction isolation levels. I believe that if, in Postgres, you set the transaction isolation level to 'serializable' that it will ensure that all transactions touching the same areas (ie. users table) they are guaranteed to run as if they were executed one after the other (in serial). But I'd recommend doing your own research there. This isn't really a Bookshelf specific issue.\n. @andre1s, yes, a unique constraint is required. The problem is that @nicholaswyoung wants to be able to explicitly check for presence before insertion, as the errors returned from the database can be difficult to parse. The question is how to ensure that the select check for an existing user remains correct until the insert is fired - as there is a race condition here. My understanding is that if you execute both the check and the insertion in a serializable transaction, they are guaranteed to be operating on the same data - regardless of other simultaneous queries on the user table. Is that incorrect?\n. Thanks for clarification, @andre1s. I guess the best approach would be to parse the error thrown by the database then.\n. It's not really possible to do a single query to retrieve all instances and relations without requiring a large amount of processing. For instance, imagine the following:\n``` js\nHouse.fetchAll({withRelated: ['rooms', 'residents']}).then(...\n// select * from houses;\n//  house (id: 1, id: 2, id: 3)\n// select * from rooms where house_id in (1,2,3)\n// select * from residents where house_id in (1,2,3)\n```\nNow if you did this in a single query, you'd have to do multiple joins. This means that you'd have this many result rows:\nrow count = number of houses * number of rooms * number of residents\nYou'd have each model duplicated many times. The more relations you have the more duplications there would be. So if you had a three houses, each with 100 rooms and 100 residents, you'd get a result of 3 * 100 * 100 - that's 30000 rows. Doing it this way returns 3 houses, 300 rooms and 300 residents -> 603 rows. Not only would this consume more RAM, but it would require more JS processing - which you really want to minimize in node.\nIt's possible to make this more efficient using PostgreSQL's json_object_agg, but it is not cross compatible.\nDoes that make sense or am I misunderstanding you?\n. Hi @nicholaswyoung, did my response answer your question? You're welcome to propose optimizations here. Otherwise I'd like to close this issue if you feel it's resolved.\n. Hi @rkmax. This is actually the designed behaviour of save(attrs, {patch: true}).\nTo get the effect you want you need to do this:\njs\nModel.forge({id: .1}).fetch({require: true})\n  .then(function(model) {\n    // Add `model.changed` as an argument.\n    return model.setProp(/* ... */).save(model.changed, {patch: true});\n  });\n  .then(/* ... */);\nA similar confusion was noted in #698. My proposed fix was to update the docs to show the above as an example. But perhaps the API could be more expressive here.\nI would like to deprecate the patch option to save and replace it with model.patch. The attrs argument could be made optional, defaulting to model.changed.\n``` js\n// the following all generate \"update models set thing = 'something'\"\n// current:\nmodel.set({thing: 'something'}).save(model.changed, {patch: true});\n// proposed, defaults to model.changed:\nmodel.set({thing: 'something'}).patch();\n// still support current behaviour:\nmodel.set({other: 'ignore'}).patch({thing: 'something'});\n```\nDoes this feel more intuitive?\n. Right. And defaulting to model.changed seems sensible?\n. > I understand that the idea behind the .patch method is persist only the properties you are passing are arguments\nWell, that is the current behaviour of .save(attrs, {patch: true}), but both you and @FredKSchott (#698) assumed that the model would patch all changed attributes.\nI actually think this is a reasonable expectation; I can't think of why one would want to set attributes on a model but not store them in an update query.\n\nI think it's not necessary because in that case .patch will mimic .save\n\nsave() will save all set attributes on a model, not just those that have changed.\nAlso, if patch(attrs) was to replace save(attrs, {patch: true}) then there would be no longer be any use for the attrs argument to save.\n. Thinking about this more... Perhaps save should really be only updating changed attributes. Apparently this is how ActiveRecord works.\n. @ricardograca Cool, I think I agree. Although I wonder if it makes sense to move towards deprecating the attrs argument to save. It only seems useful in the context of patch, in all other situations set() does the job sufficiently, and can be chained.\njs\nmodel.set(attrs).save();\nmodel.patch(attrs);\nIn the meantime we can still support save(attrs, {patch: true}) with a deprecation warning.\n. Consider these points when revisiting this.\n. Consider this when making changes.\n. Hi @fereidani. Yep, thanks for spotting this. Hope you don't mind if I suggest a bit of a change here:\n``` js\n      if (_.isFunction(target[relationName])) {\n        relation = targetrelationName;\n      }\n  if (!relation) throw new Error(relationName + ' is not defined on the model.');\n\n```\nOtherwise looks great.\n. > ...if we're sure all the arguments are functions it's better performance strategy to use (elem !== undefined).\nWe're not sure that all the arguments will be functions, that is the point of the check. This is not performance critical code, it's just run once per call to relation. Furthermore, I did a benchmark test and I'm not sure that your assertion is correct:\n\nLooks to me like the most appropriate check is _.isFunction() before trying to invoke it. It's easy to read, similar performance, and will catch more violated preconditions.\n. Also you need to modify files in the src/ folder. lib/ contains ES6 compiled output.\n. @abalmos, that seems kind of unnecessary, can't you just call the correct method?\nIn the future I expect that relations will not be defined as instance methods, so this shouldn't be an issue. Nothing set in stone yet.\n. @abalmos Right. I always whitelist my 'expand' params so I haven't had that problem. But you're right, it makes sense. In the future the object will simply have a list of known relations, rather than having to discover them as it does now. Currently I'm in the process of rewriting the docs (which is taking ages) but I hope to start work on relations afterwards.\n. Hi @rocketmannot. I'm currently in the process of updating bookshelf documentation. The particular example of load syntax is already on my TODO list.\nI'm going to close this as a duplicate. If you find any specific problems, could you be so kind as to list them in #800, and I'll try to address them as I go. Meanwhile there is more detailed JSDoc annotations in the master branch here, including as many options as I could work out for each method.\n. Hi @mAAdhaTTah. Could you provide more detail about the situation in which you want an event? Is it as simple as wanting an event triggered every time you call Collection#fetch or Model#fetch? (ie. any time that a query goes out that will return some set of models.)\n. I think I understand, sorry if I've missed the mark here.\nIt seems to me that what you're describing here is a simple relationship. A relationship is essentially what you say - when saving you default some properties. eg.\n``` js\nlet user = User.forge({id: 1});\n// Automatically sets user_id to 1\nuser.related('resources').create({ name: 'new-resource' }).then(//...\n// Automatically constrains select query to user_id = 1.\nuser.related('resources').fetch().then(//...\n```\nMy approach to this is to just use relations from User everywhere. Simply retrieve the appropriate User model from your socket connection.\nSo, I do something like this in express. I'm just going to use this generic 'Resource' model.\n``` js\nresourcesRouter = express.router();\nresourcesRouter.use(function(req, res, next) {\n  // req.user is attached by PassportJS\n  req.models.resources = req.user.related('resources');\n  next();\n});\nresourcesRouter.route('/')\n.get(function(req, res, next) {\n  // Constrained by user_id because resources is a relation.\n  req.models.resources\n  .fetchAll()\n  .then(res.json);\n})\n.post(function(req, res, next) {\n  req.models.resources\n  .create(req.body)\n  .then(req.json);\n});\nresourcesRouter.route('/:resourceId')\n.all(function(req, res, next) {\n  // Also constrained by user_id because resources is a relation.\n  req.models.resources\n  .query('where', 'id', req.params.resourceId)\n  .fetch()\n  .then((resource) => req.models.resource = resource)\n  .then(() => next());\n})\n.get(function(req, res, next) {\n  res.json(req.models.resource)\n})\n.patch(function(req, res, next) {\n  req.models.resource.set(req.body).save().then(res.json);\n});\n```\n. Hi @kisayista. I think you may have found a bug.\n\nDoes it have something to do with the SQL IN operator as above? ...  When I carry out the Postgres query with the IN operator in a separate psql shell, the sector is returned just fine\n\nI think you answered your own question there. The query looks correct. If the correct queries are firing, the models should be returned.\nAny chance you could provide a test case that consistently reproduces this? I'll have a shot at fixing it if so.\n. Hi @fereidani. Actually this is a problem that I'm aware of. But I think there is no issue yet, so thank you. I can provide you with a workaround for now.\nThe issue here is that bookshelf uses the foreign key (by default, father_id) from your menu model to find the correct father relation. Since your menu model has the attribute set to undefined, it will create the above query you're seeing.\nI'm not entirely sure how to resolve this. Obviously the query shouldn't be fired if there is no foreign key assigned. There is the possibility of doing an extra join based on the ID of the model if the foreign key does not exist yet.\nFor now I'd suggest simply including the FK in your query and then _.omit it it from the JSON response.\n. @fereidani Thanks. Good feedback here.\n\n1.throw an error for developers to understand they should include foreign key in select list.\n\nThis is an attractive quick fix.\nIt's a tad complex because columns can be specified by either query('columns|select') or by fetch({columns: ...}). Might be sufficient to check after this _.groupBy statement if group[\"undefined\"] exists and then raise an exception.\nI wonder if it might introduce a breaking error into production code somehow though? Perhaps a warning would be sufficient?\n\n2.write a fallback function for when foreign key or keys are not fetched from table like this :\n\nThe interesting thing about this (or something like this), would be that you could do Model.forge({id: 5}).related(/* whatever you want */) and then fetch relations regardless of what keys they rely on.\nYou  don't even have to do a second query. You could just do an additional join in the query. However that would introduce a lot of complexity into the code base for an edge case.\n\n3.force select foreign key(s) ( not really my choice )\n\nNot easy, nor sufficient. For example:\n```\nThing = bookshelf.Model.extend({ whatever: function () { return this.belongsTo('Whatever'); });\n// Does not fix this case:\nThing.forge({id: 2}).related('whatever').fetch();\n```\nI think I'm happy for the first one to go through. Ultimately I'm looking at splitting up the relations into separate classes for each relation type. Until that happens I'd like to prevent the already fairly complex relation code from getting any more hairy. Open to further discussion here though.\n. Hey @rkmax.\nWhich version of bookshelf are you using? I changed the behaviour of timestamps between 0.8.1 and the current HEAD, so if try pointing your project at head to see if the problem goes away.\nFailing that, could you confirm that the problem is originating from Bookshelf and not your table definition? (ie. you're not accidentally updating with a trigger function or something).\nAnd is this happening whenever you call save() on an object, or just in specific circumstances?\n. Btw, the reason I asked about the trigger was because of this issue: https://github.com/tgriesser/bookshelf/issues/759\nIt's not necessarily related though.\n. Cool. Can you try using bookshelf at HEAD to see if the problem persists?\n. Any luck, @rkmax? I'm keen to resolve this one.\n. Any luck, @rkmax? I'm keen to resolve this one.\n. Would you be able to provide a a simplified version of the code that causes this? There's not much to work with here.\n. Would you be able to provide a a simplified version of the code that causes this? There's not much to work with here.\n. Hi guys. Can't do it presently. It's a problem!\nThe best solution for now is to add an array of relation names to the model as in the endpoints example above. This is going to be resolved by a relations refactor soon. I'll use this thread to air ideas for a new API. I've got a plan in mind, but I'm trying to stay focused on the docs presently. Hopefully we can get some good ideas going.\nedit: pressed comment too soon.\n. I think I might build a plugin that overrides Model.extend, adding an extra method that identifies all relations and adds them to an array using the method here https://github.com/tgriesser/bookshelf/pull/815#issuecomment-118842318.\nThis extra method (Model#relationNames() perhaps) would be a temporary fix until we've settled on a nicer API for relations.\nFeel free to make suggestions.\n. Interesting, the same thing could be achieved with ES7 decorators, incidentally.\nHowever, I was thinking something more along the lines of this:\njs\nModel.extend({\n}, {\n  // Add a static definition to the constructor.\n  relations: {\n    author: function () {\n      return this.hasMany(...)\n    }\n  }\n});\nThe thing about this.hasMany, this.belongsTo etc. is that it returns what is, for all intents and purposes, an immutable object. So there's no reason to run these more than once per class relation (let alone every time you want to access a relation).\nSo you could overload model.related('relationName') to check the constructor for a cached version of the Relation and instantiate a new Collection or Model assigning it to its relatedData property. (I can go into more detail here later if necessary, just about to go to sleep.) This would mean less redundant processing/instantiation when accessing relations.\nSo getting a list of relations would be easy after that:\njs\nrelationNames() { return Object.keys(this.constructor.relations); }\n. Interesting, the same thing could be achieved with ES7 decorators, incidentally.\nHowever, I was thinking something more along the lines of this:\njs\nModel.extend({\n}, {\n  // Add a static definition to the constructor.\n  relations: {\n    author: function () {\n      return this.hasMany(...)\n    }\n  }\n});\nThe thing about this.hasMany, this.belongsTo etc. is that it returns what is, for all intents and purposes, an immutable object. So there's no reason to run these more than once per class relation (let alone every time you want to access a relation).\nSo you could overload model.related('relationName') to check the constructor for a cached version of the Relation and instantiate a new Collection or Model assigning it to its relatedData property. (I can go into more detail here later if necessary, just about to go to sleep.) This would mean less redundant processing/instantiation when accessing relations.\nSo getting a list of relations would be easy after that:\njs\nrelationNames() { return Object.keys(this.constructor.relations); }\n. You may.\n. No probs. I understand the docs leave a bit to be desired at the moment.\n. Hi @hulbert. Thanks for the suggestion. If I understand correctly, you're suggesting changing the behaviour of Model.extend to make static fields (provided in the second argument) constant.\nUltimately I think we want to be moving towards using ES6 classes for model definitions (or at least the option thereof). This means that extend should, if anything, emulate the behaviour of extends.\nFurthermore, I appreciate the reasoning behind this, but I'm unconvinced that it's necessary. Mutability is an expected and well understood part of JS development. Personally I think that this change would fix a class of errors so rare that it doesn't justify the change.\n. >  Bookshelf/Backbone-style is creating its own inheritance style which seems to mimic more traditional OO languages like Java.\nI think it's actually very similar to the now core ES6 class/inheritance OO style. Java/C#/C++ do not do \"static inheritance\" (ie. Child.func === Parent.func). ES does.\n\nIn Java, a class property can only be defined as static so it's strange to have a mutable class property, even in a language like JS...\n\nYou seem to be conflating the concepts of \"static\" and \"constant\". You're correct in that a \"class member\" in JS is not like a \"static\" class member in Java. But this is just one of many differences between the two systems.\n\n...what the use cases are for modifying a class property...\n\nOther similar questions: What are the use cases for redefining a class name? What are the use cases for redefining an instance method? What are the use cases for allowing a string to be passed to a function that requires an object? Why are prototypes mutable?\nI can think of two use cases for mutable members: monkey-patching and mocking for tests. Considering we're promoting an inheritance models, I'd accept that they're only useful for stubbing in testing.\n\nFunnily enough, Backbone internally calls them \"static properties\" despite being mutable\n\nYou're again conflating \"constant\" and \"static\". Valid (but inadvisable) Java:\n``` Java\npublic class Test {\n   public static int value = 5;\n}\nTest.value = 6;\n```\n\nMy biggest concern is in node, if one of these class property is modified in one module then it will be changed everywhere in the node runtime.\n\nI hear you and understand your argument. I think it's something to keep in mind, as we do use defineProperty in places, but for now I'm going to have to respectfully reject this change request. From experience I find that trying to emulate the \"correctness\" of a statically typed program in JS is going down a rabbit hole that leads to needless complexity and doesn't actually address many real world problems.\nI'd advise you to just define your own enum/constant types values (eg Account.CHARACTER_LIMIT) by the method you're describing. Could I ask if you actually did accidentally reassign something as you describe, or if you just think the API could be more \"correct\"?\nThe type of problems I really want to see addressed are ones of surprising behaviour. User.staticMethod = 5 is code that, while it does a stupid thing, does what you expect. Why allow it? Because a JavaScript developer expects it to work. Is this a bad thing? Shrug. Out of scope for this discussion IMO.\n. > I do think there is a place for constant class properties in Javascript but doesn't sound like ES6 adds them anyways\nYeah, I looked that up while we were having this discussion. No constant members in the class definitions. Hopefully it will be coming in a future spec.\n\n...would it be advisable to do something like this...\n\nCurrently there are no issues with that approach. AFAIK the only time that this strategy falls down is when _.extend is used, reading from your object with constant properties. It will turn them all into normal object properties.\njs\nvar X = _.extend({}, Account);\nX.CHARACTER_LIMIT = 'hello';\n. Simplest approach:\n``` js\n// base-model.js\nvar BaseModel = bookshelf.model('BaseModel', bookshelf.Model.extend({\n    // convert snake_case to camelCase\n    parse: function(attrs) {\n        return _.reduce(attrs, function(memo, val, key) {\n            memo[s.camelize(key)] = val;\n            return memo;\n        }, {});\n    },\n// convert camelCase to snake_case\nformat: function(attrs) {\n    return _.reduce(attrs, function(memo, val, key) {\n        memo[s.underscored(key)] = val;\n        return memo;\n    }, {});\n}\n\n}));\n// user.js\nrequire('base-model');\nvar User = bookshelf.model('User', bookshelf.model('BaseModel').extend({\n    tableName: 'users',\n}));\n```\nAlternatively you can write it as a plugin for reuse between projects, replacing bookshelf.Model. Details here.\n. Make sure the file that defines BaseModel is required by the User file.\n. I've updated my example.\n. You don't need Promise.method because \"saving\" catches errors asynchronously already. It is redundant, but not wrong. It should not be causing an issue.\n\ni have to an extra delete\n\nAre you saying that the attribute is not unset?\n. How about this:\n``` js\nvar Resource = bookshelf.model('Resource', bookshelf.model('BaseModel').extend({\n    tableName: 'resources'\n    org: function () {\n        return this.belongsTo('Org');\n    }\n}));\nvar Org = bookshelf.model('Org', bookshelf.model('BaseModel').extend({\n    tableName: 'orgs',\n    resource: function() {\n        return this.hasOne('Resource');\n    }\n}));\nvar resource = new Resource({\n    uid: uid,\n    type: 'org'\n});\nreturn resource.save()\n    .then(function(resource) {\n        resource.related('org').set(\n            uid: uid,\n            name: orgData.name,\n        }).save();\n    });\n```\nI think that should work if you prefer. However I think the way you expected to do it is interesting. I think I'll open a feature request.\n. As far as I can tell you can't have both ways. You wish to \"attach\" an Org to a Resource, but you wish to not have the resource have any awareness of Org. They are related in your database, why not allow this to be  represented in your ORM layer?\n. Consider implications for set.\n. To be clear, you're suggesting that...\njs\nModel.forge({id: 5}).isNew() === true\n...is incorrect behaviour, and should instead be false until saved/fetched?\n. Hi @ardsouza. Sorry I forgot to get back to you. If you haven't worked this out yet I'd appreciate it if you pointed your bookshelf dependency at the head commit on master to see if the timestamp problem still exists. If it does, please open a new issue - this one is about isNew and idAttribute.\n. @olalonde Nothing formal yet. Just an idea of where we want to go and what we primarily want ot address. The creation of a roadmap will be preceded by a community discussion, and the plans will all be open for comment.\n. I don't think this will be addressed until some work has been done on refactoring the basics of relations. Since realistically that is a while away, I can suggest a slightly cleaner workaround for you @austingray.\nNone of the code below has been tested\n``` js\n// -- Helper functions for recursive relationships --\n// Create a string to be passed to withRelated to request nested models.\nfunction recursiveRelation(relation, maxDepth) {\n  return _.repeat(relation, maxDepth).join('.');\n};\n// Turn a recursive relationship into a Collection instance.\nfunction flattenRecursiveRelation(parent, relation, options) {\n  var root, next, models = [];\n// Set default options.\n  options = _.extend({includeSelf: false}, options);\n// Is the parent model part of the recursion?\n  root = options.includeSelf ? parent : parent.relations[relation];\n// No models?\n  if (root == null) {\n    return bookshelf.Collection.forge(models);\n  }\n// Step through models.\n  next = root;\n  while (next != null) {\n    models.push(next);\n    // NOTE: Must use relations[] instead of related(). The latter would create empty\n    //       objects where none are found.\n    next = next.relations[relation];\n  }\n// Wrap models in a Collection.\n  return root.constructor.collection(models);\n};\n// -- Example --\nModel.fetch({withRelated: recursiveRelation('child', 10)}).then(function(model) {\n  // If \"model\" is part of the recursion (ie. is the same type as \"child\"):\n  var children = flatternRecursiveRelation(model, 'child', {includeSelf: true});\n// Alternatively, if \"model\" is a different type:\n  var children = flattenRecursiveRelation(model, 'child');\nreturn children.invokeThen('save', {new_field: 'new value'});\n});\n```\nIf you don't find this satisfactory, I know that this behaviour is supported in at least one other ORM - moron.js. See here for details. I don't know much about it except that it's pretty early in development and supports recursive relations.\nOtherwise I'll accept a PR for recursion support (properly - not my workaround above), but as I mentioned, I believe this will be easier after some structural changes.\n. > I'm not manually creating any transaction, I'm just doing a Model.save() so I assume bookshelf starts one?\nNope. Not unless you to tell it to.\n\nIs it safe to commit the transaction in my event handler or will bookshelf automatically attempt to commit the transaction later after all event handlers were called?\n\nAs I tried to explain above, this doesn't make sense. A transaction could contain code to save 100 models, you can't automatically commit the transaction after each one.\n\nCouldn't there be an event that is called after the transaction that .save() used is committed/rollbacked?\n\nThere is no event, as transactions occur outside of the purview of models and their events. But you can just add your handler to the end of the transaction block.\njs\nbookshelf.transaction((transacting) => {\n  return Model.forge(data).save(null, {transacting})\n    .then(/* ... */)\n    .then(/* ... */);\n}).then(doThing);\n. You're right. It is feasible. The fact that other ORM's have such a feature is argument enough for its usefulness.\nCurrently the transaction object is the same object that is returned by knex.transaction. See code here. It's good to have this purity. I suspect better approach may be to apply this change to knex.js directly.\nOtherwise it may be possible to override and extend bookshelf.transaction to return an augmented transaction object. For this option, it should be possible to do so via a bookshelf plugin. I'd prefer to avoid extending the object in bookshelf core if possible.\nSo I'm happy to take a PR on knex.js, or for a plugin in the bookshelf repo. Maybe start an issue on knex.js first though to run it by the other collaborators.\nCheers!\n. Cheers.\n. Hm. The \"destroying\" event is not sufficient because there is a chance destroy will fail, right?\n. Are previousAttributes accessible in the \"destroyed\" callback? That would makes sense if they were, I think. It seems correct to fire the \"destroyed\" event after all side effects of destroy have completed.\n. No probs.\n. Try:\njs\n.query(function(qb) {\n  qb.join('category', 'category.id', 'products.category_id')\n  .where('products.category_id', '=', req.params.id)\n  .orderBy('products.product_name', 'asc');\n})\n.fetchAll({debug: true})\nAlso, instead of logging from the callback, call fetchAll({debug: true}) for debug trace.\n. Hi @dksakkos.\nIn your examples you're doing something a bit strange - naming a relationship after the \"pivot table\", rather than the models it returns. Do you want to return Joiners or Users from joiner()? Here's an attempt at answering:\nFor a many-to-many you just put belongsToMany on each side of the relationship. I've actually not used belongsToMany with through before, but the second argument is meant to be the table, not the foreign key.\nShould be something like this I believe:\njs\nvar Bet = Bookshelf.Model.extend({\n    tableName: 'bet',\n    idAttribute: 'bet_id',\n    creator: function() {\n      return this.belongsTo(User, 'bet_creator');\n    },\n    joinedUsers: function() {\n      return this.belongsToMany(User, 'joiner', 'user_id');\n    }\n});\n. > I can only fetch this through the join table, that is why I use the through command.\nbelongsToMany also uses a pivot table. If you don't need data from the joiner table you shouldn't require a Joiner model at all.\n\nHowever, the problem that remains is how can I only fetch the user_id and the username, and discard the useless columns.\n\nTry this:\njs\nBet\n  .query({where: {match: requestObject.matchid}})\n  .fetchAll({\n    withRelated: [\n      {user: function(qb) { qb.columns('user_id', 'username'); }},\n      'joiner'\n    ],\n    debug:true\n  })\n  .then(function(collection) {\n    return res.json(collection.toJSON());\n  });\n. > I believe it's because collections don't have fetchAll, but fetch().\nSorry, updated code. Just copy pasted and didn't realize there was a collection hidden in there.\n\nI get no output.\n\nThere should be a debug trace from the query.\n. Add a .catch, it might be throwing before the debug trace.\n. Um. Well, that doesn't seem likely/possible. But evidently it's happening.\nfetch() should return a Promise, and then() should return that same promise reference for chaining.\n. Could you please add this example to the JSDoc doclet in src/model.js so we keep parity with upcoming generated docs? Thanks.\n. > ...it erased all my changes.\nYour changes to what?\n. @stridentbean, I think that you are mistaken. Calling npm run jsdoc will update /lib/model.js, but leaves /src/model.js unchanged. I just checked out your branch and confirmed that this is the case locally. Could you try that again and commit the changes to /lib/model.js too?\n. Thanks, @stridentbean.\n. Hi @blah238. You can access the old previousAttributes via options.previousAttributes. See here.\n. Reopening as a reminder to add this to the documentation for saved, created and updated.\n. Hi @skysteve. Thanks for the report. model.fetchAll is just an alias for new Collection([], {model: Model}).fetch(), so if one fails it's no surprise if the other does. I believe this is a long standing bug with polymorphic relations and fetchAll - I've encountered it before: #640.\nI've used morphTo successfully before without the hack you've used in the last code example. Could you show me the issue you got it from, or explain why it works? I'm not sure what you're trying to achieve here. Could you show your schema too - just the polymorphic table and accounts table?\nnotes:\nJust reading through the relations code... The first argument to morphTo doesn't do anything if you supply column names. It appears to only be used to generate the default values for columns. Should change it to an \"overload\" where the first argument can either be a string or an array of column names. Also the documentation stinks. There is no explanation of what morphName is under morphTo.\n. Hi @offmadisonave. There are two ways to achieve this.\nGet AccountUser object explicitly by nested eager loading.\n``` js\nvar User = bookshelf.Model.extend({\n  tableName: 'users',\n  accountUsers: function() {\n    return this.hasMany(AccountUser);\n  }\n});\nUser.fetch({withRelated: ['accountUsers.account']}).then( // ...\n// user.toJSON -> { id, name, accountUsers: [{ role, account: { ... } }] }\n```\nOr get \"through\" model attributes via withPivot.\n``` js\nvar User = bookshelf.Model.extend({\n  tableName: 'users',\n  accounts: function() {\n    return this.belongsToMany(Account).through(AccountUser).withPivot('role');\n  }\n});\nUser.fetch({withRelated: ['accounts']}).then( // ...\n// user.toJSON -> { id, name, accounts: [{ ..., _pivot_role }]\n``\n. Comment edited (I pressed submit by accident).\n. Thanks @fereidani. :smiley:\n. Thanks @fereidani. :smiley:\n. Hi @LukeL99. The reason thatreturning \"id\"is being used is because bookshelf tries to update theidAttributeof the model after inserting. Bookshelf assumes that all tables have a primary key, and uses this to determine whether a model is \"new\" or not. ie. a model with a non-nullidAttribute` is \"new\".\nThe default idAttribute for any model is \"id\". You can see here how it is used as the second argument to Knex#insert. The returned value then updates the model's attribute here.\nI'm assuming your table has no primary key, or has a composite primary key. Neither of these are supported currently.\nIf you have no primary key, you could try setting the idAttribute of your table to null/undefined. This will remove the returning \"id\" clause. However Bookshelf will still try to assign the returned value to an attribute. In this case you might get { null: undefined } or something silly.\nI'm happy to take a PR that changes this line to not update Model#id if idAttribute is null or undefined. Just beware that isNew will always return false on instances of this model, so it's not going to be a fully supported use case.\n. Hi @LukeL99. The reason that returning \"id\" is being used is because bookshelf tries to update the idAttribute of the model after inserting. Bookshelf assumes that all tables have a primary key, and uses this to determine whether a model is \"new\" or not. ie. a model with a non-null idAttribute is \"new\".\nThe default idAttribute for any model is \"id\". You can see here how it is used as the second argument to Knex#insert. The returned value then updates the model's attribute here.\nI'm assuming your table has no primary key, or has a composite primary key. Neither of these are supported currently.\nIf you have no primary key, you could try setting the idAttribute of your table to null/undefined. This will remove the returning \"id\" clause. However Bookshelf will still try to assign the returned value to an attribute. In this case you might get { null: undefined } or something silly.\nI'm happy to take a PR that changes this line to not update Model#id if idAttribute is null or undefined. Just beware that isNew will always return false on instances of this model, so it's not going to be a fully supported use case.\n. @mrbeskin \n\nAm I correct in my understanding that there is currently not built-in support for using a non-id natural key as the primary key?\n\nI don't fully understand the question. AFAIK any column with a type that supports equality comparison can be used as a primary key in Bookshelf. Ideally this would actually be a primary key in your schema.\n@LukeL99\n\nIs id required on pivot tables as well?\n\nNo. Only if you create a model class and want it behave as expected. (So only for pivot models specified explicitly in .through relations.)\nThe idAttribute is only used for relations (ie. linking foreign keys) and checking if the model is \"new\" - which is used only in save and can be manually overridden by calling save(null, {method: \"update\"}) or save(null, {method: \"insert\"}). So you can live with it anywhere, you just might have to handle some edge cases manually (relation joins etc).\n\nIs this documented anywhere that I just missed?\n\nNot sure. The docs for idAttribute incorrectly suggest that composite keys are supported. They are not - at least not in the case of relations.\n\nMay I suggest a section on database considerations to use this framework in the documentation?\n\nYou are more than welcome to provide one. Perhaps in the \"Bookshelf Models\" section (which is mirrored in the JSDoc doclets in src/model.js).\n. @mrbeskin \n\nAm I correct in my understanding that there is currently not built-in support for using a non-id natural key as the primary key?\n\nI don't fully understand the question. AFAIK any column with a type that supports equality comparison can be used as a primary key in Bookshelf. Ideally this would actually be a primary key in your schema.\n@LukeL99\n\nIs id required on pivot tables as well?\n\nNo. Only if you create a model class and want it behave as expected. (So only for pivot models specified explicitly in .through relations.)\nThe idAttribute is only used for relations (ie. linking foreign keys) and checking if the model is \"new\" - which is used only in save and can be manually overridden by calling save(null, {method: \"update\"}) or save(null, {method: \"insert\"}). So you can live with it anywhere, you just might have to handle some edge cases manually (relation joins etc).\n\nIs this documented anywhere that I just missed?\n\nNot sure. The docs for idAttribute incorrectly suggest that composite keys are supported. They are not - at least not in the case of relations.\n\nMay I suggest a section on database considerations to use this framework in the documentation?\n\nYou are more than welcome to provide one. Perhaps in the \"Bookshelf Models\" section (which is mirrored in the JSDoc doclets in src/model.js).\n. @nathanmarks You could make a PR that does something like this:\njs\nqueryBuilder.update(data).returning(isArray(idAttribute) ? idAttribute : ...idAttribute)\n. @nathanmarks Actually what happens when you change your idAttribute to the composite key array?\n. @nathanmarks Well, it looks as thought partial support was included a long time ago, and I've tried to maintain it in changes I've made. However that is one of the few features that will work. You can't do relations etc. Officially there can be no claim to support composite keys.\n. @nathanmarks It was noted in the idAttribute documentation previously. Perhaps it should be restored with a warning.\n. @nathanmarks I don't believe so, which is why I removed the documentation. However I would be happy to support the case of selecting and updating by ID were tests added and it was documented.\n. Yep. Two methods, pick your favourite:\n``` js\n// Load a store instance with related items.\nStore.forge({id: 5}).fetch({withRelated: 'items'}).then(function (store) {\n  console.log('Here is the store', store.toJSON());\n  console.log('Here are the items', store.related('items').toJSON());\n});\n// Create a store instance and load its related items (without loading the store instance).\nStore.forge({id: 5}).related('items').fetch().then(function (items) {\n  console.log('Here are all the items at store with ID 5', items.toJSON());\n});\n```\n. Yep. Two methods, pick your favourite:\n``` js\n// Load a store instance with related items.\nStore.forge({id: 5}).fetch({withRelated: 'items'}).then(function (store) {\n  console.log('Here is the store', store.toJSON());\n  console.log('Here are the items', store.related('items').toJSON());\n});\n// Create a store instance and load its related items (without loading the store instance).\nStore.forge({id: 5}).related('items').fetch().then(function (items) {\n  console.log('Here are all the items at store with ID 5', items.toJSON());\n});\n```\n. > For some reason, that also adds _pivot_store_id, and _pivot_item_id. Even if I specify columns in the fetch to be ['name', 'description']\nThese are not attributes in your model, but are generated by toJSON. You can disable this behaviour by calling toJSON({omitPivot: true}).\n\nAlso, is there another way to ask for help other than filling your repo with issues?\n\nYes, you may use any of the options here. Although reporting here is the most likely way to get a response. It also allows us to note problems with documentation - such as omitPivot not being documented under toJSON.\n. > For some reason, that also adds _pivot_store_id, and _pivot_item_id. Even if I specify columns in the fetch to be ['name', 'description']\nThese are not attributes in your model, but are generated by toJSON. You can disable this behaviour by calling toJSON({omitPivot: true}).\n\nAlso, is there another way to ask for help other than filling your repo with issues?\n\nYes, you may use any of the options here. Although reporting here is the most likely way to get a response. It also allows us to note problems with documentation - such as omitPivot not being documented under toJSON.\n. I believe the latest versions of Knex have JSONB support. Bookshelf is intended to work cleanly with anything output by knex, and no problems have been reported. It should be fine - if there any any issues please report them here.\n. I believe the latest versions of Knex have JSONB support. Bookshelf is intended to work cleanly with anything output by knex, and no problems have been reported. It should be fine - if there any any issues please report them here.\n. See tgriesser/knex#387.\nedit: Sorry, referencing wrong issue\n. See tgriesser/knex#387.\nedit: Sorry, referencing wrong issue\n. \"Initialize\" is misspelled in your class declaration.\nOn Sun, 2 Aug 2015 5:07 pm jamesdixon notifications@github.com wrote:\n\nHi,\nI'm following the example of using validation in a model that's shown in\nthe documentation http://bookshelfjs.org/#Model. Unfortunately, it\nappears that my initialize() method is never called.\nHere's the model:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  hasTimestamps: true,\ninitialze: function () {\n    this.on('saving', this.validateSave);\n  },\nvalidateSave: function () {\n    return validations.validate(this.attributes, function(err, value) {\n      if(err) {\n        throw err;\n      }\n    });\n  }\n});\nAnd I'm calling it like so:\nUser.forge(newUser)\n  .save()\n  .then(function() {\n    reply();\n  }).catch(function(err) {\n    console.log(err);\n    reply(Boom.badRequest(err.name));\n  });\nWhen placing a debugger; statement in initialize(), it appears that it is\nnever called. However, I tried another method and overrode the constructor\nand it worked perfectly; all validations checked successfully.\nAny suggestions?\nThanks!\nJames\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/858.\n. \"Initialize\" is misspelled in your class declaration.\n\nOn Sun, 2 Aug 2015 5:07 pm jamesdixon notifications@github.com wrote:\n\nHi,\nI'm following the example of using validation in a model that's shown in\nthe documentation http://bookshelfjs.org/#Model. Unfortunately, it\nappears that my initialize() method is never called.\nHere's the model:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  hasTimestamps: true,\ninitialze: function () {\n    this.on('saving', this.validateSave);\n  },\nvalidateSave: function () {\n    return validations.validate(this.attributes, function(err, value) {\n      if(err) {\n        throw err;\n      }\n    });\n  }\n});\nAnd I'm calling it like so:\nUser.forge(newUser)\n  .save()\n  .then(function() {\n    reply();\n  }).catch(function(err) {\n    console.log(err);\n    reply(Boom.badRequest(err.name));\n  });\nWhen placing a debugger; statement in initialize(), it appears that it is\nnever called. However, I tried another method and overrode the constructor\nand it worked perfectly; all validations checked successfully.\nAny suggestions?\nThanks!\nJames\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/858.\n. Just looking at your code, you do have a problem though. It appears your validations.validate function performs async behaviour (hence the callback). The \"saving\" event allows for async, but you must return a promise from your function. The way you have it now the error will not be thrown during the call to save().\n\nI'd recommend using Bluebird's \"promisification\" tooling to create a compatible version of validate.\n``` js\nvar Promise = require('bluebird');\nvar validations = Promise.promisifyAll(require('validations'));\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  hasTimestamps: true,\ninitialze: function () {\n    this.on('saving', this.validateSave);\n  },\nvalidateSave: function() {\n    return validations.validateAsync(this.attributes);\n  }\n});\n``\n. Just looking at your code, you do have a problem though. It appears yourvalidations.validatefunction performs async behaviour (hence the callback). The\"saving\"event allows for async, but you must return a promise from your function. The way you have it now the error will not be thrown during the call tosave()`.\nI'd recommend using Bluebird's \"promisification\" tooling to create a compatible version of validate.\n``` js\nvar Promise = require('bluebird');\nvar validations = Promise.promisifyAll(require('validations'));\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  hasTimestamps: true,\ninitialze: function () {\n    this.on('saving', this.validateSave);\n  },\nvalidateSave: function() {\n    return validations.validateAsync(this.attributes);\n  }\n});\n```\n. @ricardograca Do you think we should wait for the new documentation (maybe a week maximum), or just release a new version now?\n. @ricardograca Do you think we should wait for the new documentation (maybe a week maximum), or just release a new version now?\n. @nathanboktae Hey I just released the new version. Enjoy.\n. Thanks for the report, @jadengore.\nAssuming your observation is correct, either the behaviour is wrong or the documentation is wrong. One of these will have to be corrected.\nThis will need to be revisited.\n. Any thoughts on preferred behaviour here (null or undefined) are welcome.\n. null vs undefined is a controversial issue. Personally I've never actually checked if the resolved model is either, since I typically use if (result != null). I think this is a common pattern because undefined and null mean essentially the same thing.\nUsually I would agree with @ricardograca and say to just default to the documentation, as that is what people have been expecting up until now. However in this case I think there might be a valid argument towards having all these return null rather than undefined:\nJSON.stringify() will ignore properties that are undefined. Since most of the time Bookshelf is used for web servers that do a lot of this business it may make sense to use null. If relations returned undefined this would happen:\n``` js\n// Person exists without a home:\nPerson.where({id: 1}).fetch({withRelated: 'home'}).then(JSON.stringify);\n// We get:\n'{ \"id\": 1 }'\n// We expect:\n'{ \"id\": 1, home: null }'\n// Person does not exist:\nPerson.where({id: 1}).fetch().then(JSON.stringify);\n// We get:\nundefined\n// We expect:\n'null'\n```\nAlso you might want to do something like this:\njs\nPromise.props({\n  home: House.where({id: 1}).fetch(),\n  person: Person.where({house_id: 1}).fetch()\n}}.then(res.json);\nFeel free to continue the discussion, but if there are no objections I'd like to see the following:\n- Change all functions to return null by convention when referring to non-existent models.\n- Tests where appropriate to avoid regressions.\n- Update documentation for fetch, fetchOne and anything else that is inconsistent.\n. Thanks for the quick response everyone. Seems we all agree then.\nJust thought I'd note here that what I said about relations returning undefined is incorrect. Actually, as noted in #753, they return empty unsaved instances. This detail requires a larger change and is out of scope for this issue.\nWe can still fix documentation and behaviour and add tests for the simpler case of Model#fetch. It's not a large change if anybody feels like submitting a PR.\n. > Should this be a new issue?\nYes please, simply because this is closed.\n. > Should this be a new issue?\nYes please, simply because this is closed.\n. Kind of. Actually this is a bit silly. You'd hope to be able to do this:\njs\nvar thingVar = undefined;\nModel.where('thing', thingVar).fetch().then( // ...\nBut this builds the query select * from table where thing = NULL, instead of select * from table. I think this might be an error in Knex's behaviour. Certainly it feels wrong to me.\nThis will work consistently though:\njs\nModel.query(function(qb) {\n  if (thingVar != null) qb.where('thing', thingVar);\n})\n. Kind of. Actually this is a bit silly. You'd hope to be able to do this:\njs\nvar thingVar = undefined;\nModel.where('thing', thingVar).fetch().then( // ...\nBut this builds the query select * from table where thing = NULL, instead of select * from table. I think this might be an error in Knex's behaviour. Certainly it feels wrong to me.\nThis will work consistently though:\njs\nModel.query(function(qb) {\n  if (thingVar != null) qb.where('thing', thingVar);\n})\n. js\nModel.query(function(qb) {\n  if (thingVar != null) qb.where('thing', thingVar);\n  if (otherVar != null) qb.where('other', otherVar);\n})\n. You're welcome.\n. Hi @sandro-csimas. It can help to pass {debug: true} to your call to fetch. That way you get the generated queries logged out for your review.\njs\nreturn UserActivity\n  .where({place_id: place.id})\n  .save({\n      place_id: null,\n      parameters: JSON.stringify({place_name: this.place.get('name')})\n    }, {\n      method: 'update',\n      patch: true,\n      transacting: transaction,\n      debug: true // <-- Here\n  });\nIf the correct query is being generated, then the problem may just be that there is no user_activity with place_id = 2.\n\nHow to prevent this behavior? I try \"require\": false but is not working.\n\nIf you're adding require: false to save() and it's still firing the exception, you have found an error.\nAlso, note that since you're not returning either of these promises, your main promise chain will resolve regardless of these expressions failing/succeeding:\njs\n        cache.removePlacePosition(this.place).catch(function(err) {\n          logger.error('Error removing place %d from cache.', this.place.id, err);\n        });\n        activities.placeRemoved(this.place).catch(function(err) {\n          logger.error('Error creating an user activity of \"place %d removed\".', this.place.id, err);\n        });\n. > ...i need to update all UserActivity rows...\nActually the code you've used will only save a single instance (save does not save in bulk). I'd actually recommend doing this:\njs\nUserActivity.where({place_id: place.id}).query()\n  .transacting(transaction)\n  .update({ place_id: null, /* ... */ })\nActually ends up being much terser. If you want to check the output you can chain .debug()after .query().\n. @sandro-csimas, unfortunately @tgriesser is not active on bookshelf issues as he's busy with other tasks. So you're going to have to endure my less knowledgable advice.\nThe two code examples you've given are correct, however. save does not add LIMIT 1, only Model#fetch. This was a misunderstand on my part, sorry for misleading you.\nYou can see here that the only conditions under which NoRowsUpdatedError is fired is when:\n- method === 'update', whether by isNew() returning true, or by it being specified explicitly, as you have.\n- require !== true ie. you haven't explicitly requested that the error is not thrown.f\n- resp === 0 ie. the number of modified columns is equal to zero.\nAll three of this conditions must be true for the exception to be fired. Since the first two are true, is there a  chance that the third is too?\n. Could you show me the code where you're passing require: false? There is a test case for this.\n. Hi @dksakkos. This is a known problem. See #819 for more info.\nAssociating the related object Comment with its parent User requires each User instance to have its id set. The workaround is easy: Just make sure you include 'id' in your columns array.\n. It's not clear what you're asking here. I'm guessing that you mean you're setting an attribute on a model to an array, then calling Model#save() to insert it into a JSON column?\nCould you please provide a code example and the generated query (by passing {debug: true} as an argument to save).\n. Okay... So is that working?\nOn Sat, 8 Aug 2015 5:49 pm spwizard notifications@github.com wrote:\n\nThe issue seems to be with this\n\"{\"{\\\"DishId\\\":\\\"R00265\\\",\\\"Name\\\":\\\"Miso\nSoup\\\",\\\"Description\\\":\\\"Seaweed, tofu, spring onion, soy bean broth\n(unlimited\nrefills).\\\",\\\"PriceInGBP\\\":220,\\\"Quantity\\\":2}\",\"{\\\"DishId\\\":\\\"R00500\\\",\\\"Name\\\":\\\"Spicy\nSeafood Udon\\\",\\\"Description\\\":\\\"Shrimps, salmon, squid, vegetables, udon\nnoodles, spicy broth.\\\",\\\"PriceInGBP\\\":430,\\\"Quantity\\\":2}\"}\"\nvar createOrder = function(req, res, done) {\nnew Order(req.body).save().then(function(order) {\nres.json(order);\n});\n};\nThanks\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/864#issuecomment-128927491\n.\n. Hey @spwizard, I just added code delimiters to your comment above for readability.\n\nYou have to understand that unless you say more than \"I am having trouble with [task]\" it's going to be difficult for anyone to give you specific advice on how to help. In what way is it not working? Is there an error report? Is the table not being updated? etc. Tell me what you know so I can help.\n. Hey, can't help you much right now on Saturday night, but you might find the solution you need here: tgriesser/bookshelf#94 brianc/node-postgres#442.\n. Great. You might prefer to do something like this:\njs\nOrder = bookshelf.BaseModel.extend({\n  tableName: 'orders',\n  initialize: function() {\n    this.on('saving', function(model, attrs, options) {\n      var products = this.get('products');\n      if (_.isArray(products)) {\n        this.set('products', JSON.stringify(products));\n      }\n    }\n  },\n  // ...\n});\n. Hi @cuteboi. Sorry for the slow response. The documentation is totally misleading here. Since before I've been involved with Bookshelf it does not fully support composite primary keys. AFAIK it is supported by isNew and that's about it. I'm not sure if there was ever full support.\nHowever! This is definitely something I'd like to see happening. Adding save() support for models with composite keys is not difficult. Problem starts here.\nI'm marking this as a bug. Two possible PR's here:\n1. Update documentation to mention that composite primary keys are not properly supported. (Although leave the example showing an array).\n2. Add support for composite primary keys for Model#save(). This might require a few helper functions.\n. > I'm thinking something along these lines (fetching last week's comments)\nThat's a good approach. It would be like this:\njs\ndb.User.forge({username: username})\n  .fetch({\n    withRelated: [\n      {\n        'comment': function(qb) {\n          qb.where({status: 'EDITED'}).where('created_at', '>=', moment().subtract(1, 'week'))\n        }\n      },\n      'address'\n    ],\n  }).then( // ...\nOr if you want to reuse that logic, you can do the following:\n``` js\nvar User = bookshelf.Model.extend({\n  tableName: 'users',\n  comments: function() {\n    return this.hasMany(/ ... /);\n  },\n  lastWeeksComments: function() {\n    return this.comments()\n      .where({status: 'EDITED'})\n      .where('created_at', '>=', moment().subtract(1, 'week')); \n  },\n  // ...\n});\ndb.User.forge({username: username})\n  .fetch({withRelated: ['lastWeeksComments' 'address'])\n  .then( // ...\n```\nI'd guess that the former is more appropriate in this case.\n. btw, passing a moment object there. I'm pretty sure knex accepts moment - it definitely accepts Date instances and ISO 8601 string.\n. Not currently, there is a PR for this feature but it is incomplete/abandoned.\n. That's worrying. Just reviewing CollectionBase. I can't see how those two would get out of sync. Are the extra models duplicates? What is the result of toJSON?\n. Which version of Bookshelf?\n. Okay, it appears you've found a bug. Presumably in Collection, since the array and length are getting out of Sync.\n. Hey @chrisfrancis27, as far as I know nobody has looked into this. If you want to get your hands dirty you can have a look. It looks like a problem in Collection. PR welcome.\n. It's possible to actually handle these migrations via Knex's (sparingly documented) migration module. That way you don't need to check if tables exist - it will keep track of which tables have been created. It's not the best for retrofitting to an existing database, but this is a new project it would be best to start there.\nYou could start debugging this yourself by logging all output by passing {debug: true} to the Knex config.\nI think the problem is that when you call readdirSync here the result will return:\n- All model files (*.js)\n- index.js\n- Any subdirectories (migrations).\nYou've filtered out index.js, but when it called require('./models/migrations') it executes the migration code again. The simplest solution here would be to just include models and have that call migrations internally.\n``` js\nvar bluebird = require('bluebird');\nmodule.exports = function(bookshelf) {\n    require('./migrations').then(function() {\n      return bluebird.all([\n        require('./item')(bookshelf),\n        require('./plan')(bookshelf),\n        require('./store')(bookshelf),\n        require('./subscription')(bookshelf),\n        require('./transaction')(bookshelf),\n        require('./user')(bookshelf)\n    ])\n  }\n}\n``\n. As far as I can tell the code snippet you've provided is correct. If you don't throw fromcatch` the chain should resolve as if there was no error.\n. We can reopen this if you'd like to provide more info.\n. Can you provide a stack trace:\njs\n            // Error\n            .catch(function(err) {\n                console.error(err, err.stack);\n                res.json({failure: true});\n            });\n. None of those files exist in Bookshelf any more, nor have they for several versions. Try updating to latest.\n. Oh, right. Sorry, I didn't look at your code properly:\njs\n    addressWithCountry: function() {\n        return this.address().fetch({withRelated:[\n            {country: function(qb) { qb.column('name'); }}\n        ]})\n    }\nthis.address() returns a Collection, but Collection#fetch returns a promise. So they are different things. Bookshelf calls fetch on any relations specified by withRelated.\nYou can't call function that returns a promise in that way. I am currently planning a new API that would allow this, however:\njs\n    addressWithCountry: function() {\n        // Planned API.\n        return this.address().withRelated('country', (qb) => qb.column('name'));\n    }\nIn the meantime you must do this:\njs\n.fetch({\n    withRelated: {country: function (qb) { qb.column('name') }}\n})\nYou could make a helper if you like:\n``` js\nfunction related(relation, columns) {\n  var result = {};\n  result[relation] = function (qb) { qb.column(columns) };\n  return result;\n}\n// ...\n.fetch({withRelated: related('country', ['name'])});\n``\n. Bear in mind that you'll have to also select theidcolumn or else Bookshelf will now know whichCountryto attach to whichUser`.\n. Ah, it's nested:\njs\n.fetch({\n  withRelated: {'address.country': function (qb) { qb.column('country_id', 'name') }\n})\n. > It wouldn't work unless I add a 'country' function in my schema, and as you said bookshelf doesn't accept this.\nI didn't say this.\n\nUsing the helper also shouldn't work, because as you said bookshelf doesn't know the user_id. Besides, if the helper runs async, will it return on time?\n\nHelper method was just to help build arguments to withRelated. There is nothing async about it.\n. > But is seems like a workaround. For example, if we had a table 'continent', with continent_id and name as attributes, how could we access the name of the continent that the country is in?\nYou've already opened an issue on this and I told you it is a known issue. Yes, you'll have to include the keys required to reassociate the models. Just don't call column when getting relations and everything will be alright. Or do this:\njs\n.fetch({\n  withRelated: [\n    {'address.country': function (qb) { qb.column('country_id', 'continent_id', 'name')},\n    'address.country.continent'\n  ]\n})\nAS:\njs\n.fetch({columns: ['column as my_special_column']});\n.fetch({withRelated: {'other': (qb) => qb.column('column as my_special_column')}});\n. Can you get stack traces for those exceptions?\njs\nconsole.error('Error:', error.stack);\n. Right. The native problem seems related to this this.\nI suspect it's because toJSON is trying to serialize your Raw object, I assume Raw#client has a reference to pg which has the .native getter in it.\nAs for the other problems I'll have to return to this later.\n. Right. The native problem seems related to this this.\nI suspect it's because toJSON is trying to serialize your Raw object, I assume Raw#client has a reference to pg which has the .native getter in it.\nAs for the other problems I'll have to return to this later.\n. Your first post was in the right place. This question pertain to Knex. I don't know the answer, but I think I've seen this discussed before on their issues page. How Bookshelf approaches this issue will be based on the Knex API.\n. Hi @hulbert. I absolutely agree that this is misleading. I'm planning a new API that will disentangle model instances and queries.\nIt will look something like this:\n`` js\nbookshelf('SomeItem').forge({relatedId: relatedId}).query( // ...\n// Error:queryis undefined becauseModelinstances have noquery` method\nbookshelf('SomeItem').where(relatedId, relatedId}).fetch().then(\ntransaction('SomeItem').where(relatedId, relatedId}).fetch().then(\n// -> Promise\n// Chain a query straight off the SomeItem chain factory.\nbookshelf('SomeItem').forge({id: 5}).fetch()\n// Error: fetch is undefined.\n// You can't \"fetch\" a model you already have...\nbookshelf('SomeItem').forge({id: 5}).refresh()\n// -> Promise\n// You can refresh it though...\nbookshelf('SomeItem'}.forge({name: 'Rhys'}).refresh()\n// Error: Unidentifiable - cannot refresh a model without its ID column defined.\n```\nI've been thinking about this change for a couple of months (or really since I started using Bookshelf). But I want to be confident with the API before I publish my proposal for feedback.\nI think this will make these kind of issues a lot clearer. What do you think?\n. > how would do the initial fetching of SomeItem whose id is 5?\n``` js\nbookshelf('Something').forge({id: 5}).refresh();\n// Broken down:\n// Create new chainable model builder.\nvar builderChain = bookshelf('Something');\n// Create a new model.\nvar model = builderChain.forge({id: 5});\n// Now refresh the model in place (and also return a promise)\nvar modelPromise = model.refresh();\n// Or, you can go this way:\nbookshelf('Something').where({id: 5}).fetch();\n// Broken down:\n// Create new chainable model builder.\nvar builderChain = bookshelf('Something');\n// Mutate query within chain, adding a where constraint.\nbuilderChain.where({id: 5});\n// Now execute select query, returning a promise that resolves to the model.\nvar modelPromise = builderChain.fetch();\n```\n\nAnd would one still be able to do this to get many instances of a model, and have a concept of an assignable model class (rather than having to continually call bookshelf('SomeItem')?\n\nThis is the exact problem I've been thinking about. The problem is that the \"builder chain\" is instantiated within bookshelf or transaction, and that is where its connection is defined. This way we separate the concept of table/model from the idea of a specific bookshelf connnection. But, I agree that it would be desirable to initialize like this:\n``` js\nUsers = bookshelf('Users')\n// Each of the following is instantiated knowing about the connection info of the bookshelf instance.\nUser.all.fetch().then(users => / ... /);\nUser.one().where({id: 5}).fetch().then(user => / ... /);\n```\nI haven't got a good solution for this yet, but I do agree that supporting the above is necessary. Do you think the following should be supported too?\njs\nAdmin = bookshelf('User').where('isAdmin', true);\nAdmin.where({name: 'John'}).all().fetch();\nAdmin.query('orderBy', 'created_at').all().fetch();\nThe way I'd been thinking about this so far was that each call to bookshelf('User') would create a mutable chain (much like calling knex(tableName)). In Knex you cannot do this:\n``` js\n// Doesn't work because 'admins' is mutated in place.\nvar admins = knex('users').where('isAdmin', true);\nadmins.where('name', 'John').select('').then(// ...\nadmins.orderBy('created_at').select('').then(// ...\n// Must do this instead:\nvar admins = knex('users').where('isAdmin', true);\nadmins.clone().where('name', 'John').select('').then(// ...\nadmins.clone().orderBy('created_at').select('').then(// ..\n```\nBut I don't think that forcing people to clone() is appropriate for Bookshelf. The other option is implicitly cloning the entire chain instance each time a method is called. This seems like it would be needlessly expensive though.\nThoughts?\n. Closing for inactivity. fetchAll ignores model attributes by design, and plans for future API have moved on beyond this point. If interested, plans currently reside at: https://github.com/rhys-vdw/bookshelf-api-proposal.\n. Hi @jamesdixon, this is not core but I've written some code for myself that does this. Hopefully it will give you an idea of how it should work.\nI've just compiled this from CoffeeScript and cleaned up and simplified the output, but it isn't tested. Hopefully you'll get the idea.\n``` js\n// processors.coffee\n// Helper methods for common data transformations.\nvar isAbsoluteUrl = require('is-absolute-url');\nvar _ = require('lodash-node');\nmodule.exports = {\n  trim: function(string) {\n    if (!.isEmpty(string)) {\n      return string.trim();\n    }\n  },\n  absoluteUrl: function(urlString) {\n    var trimmed;\n    if (.isEmpty(urlString)) {\n      return urlString;\n    }\n    trimmed = urlString.trim();\n    if (isAbsoluteUrl(trimmed)) {\n      return trimmed;\n    } else {\n      return \"http://\" + trimmed;\n    }\n  },\n  lowerCase: function(string) {\n    if (!_.isEmpty(string)) {\n      return string.toLowerCase();\n    }\n  }\n};\n```\n``` js\n// processor-plugin.js\n// A plugin that adds processor support for Model.\nvar processors = require('./processors');\nmodule.exports = function(bookshelf) {\n  var proto = bookshelf.Model.prototype;\nbookshelf.Model = bookshelf.Model.extend({\n    set: function(key, value, options) {\n      var processedKey, self = this;\n  if (key == null) return this;\n\n  if (this.processors != null) {\n    if (_.isObject(key)) {\n      processedKey = _.transform(key, function(result, value, key) {\n          result[key] = self.processAttribute(value, key);\n        };\n      });\n      return proto.set.call(this, processedKey, value, options);\n    }\n    value = this.processAttribute(value, key);\n  }\n  return proto.set.call(this, key, value, options);\n},\n\nprocessAttribute: function(value, key) {\n  var processes;\n  if (this.processors != null && this.processors[key] != null) {\n    processes = this.processors[key]\n  }\n  if (_.isEmpty(processes)) {\n    return value;\n  }\n  if (!_.isArray(processes)) {\n    processes = [processes];\n  }\n  _.each(processes, function(process) {\n    var func;\n    if (_.isString(process)) {\n      func = processors[process];\n      if (func == null) {\n        throw new Error(\"Unknown processor `\" + process + \"`\");\n      }\n    } else {\n      func = process;\n    }\n    value = func(value);\n  });\n  return value;\n}\n\n});\n};\n```\n``` js\n// bookshelf.js\n// init knex etc...\nvar bookshelf = Bookshelf(knex);\nbookshelf.plugin('./processer-plugin');\nmodule.exports = bookshelf;\n```\n``` js\n// user.js\n// Example use.\nvar bookshelf = require('./bookshelf')\nmodule.exports = bookshelf.Model.extend({\n  tableName: 'users'\n  processors: {\n    email: ['lowercase', 'trim'],\n    homepage: 'absoluteUrl',\n    name: 'trim',\n    age: function(age) { return Math.max(0, age); }\n  }\n});\n```\nI'd actually like to see this tested and added as a core plugin, since it seems useful. Let's leave this issue open in case someone wants to do it.\n. Note that the above code only changes \"setters\", but so long as all your data is entering the DB through Bookshelf you should be fine.\n. @jamesdixon If there are any bugs tell me and I'll update the comment for future reference.\n. Hey @futbalguy. Thanks for the PR. I'm not sure this is going to behave how you expect.\nThe text beneath the second @example will be considered to be part of the example. (\"Note that both columnNames and morphValue...\")\nBefore there were long \"descriptions\" with interspersed code blocks. It would be possible to reword everything using \"examples\" - but in the theme I'm working on all the examples will be moved above the description.\nRemoval of vertical whitespace in code is good.\nI'm not sure about chaining without indentation though. I do this personally in my own code, but I think it's generally considered unusual:\njs\n// this thing:\nModel\n.where(thing)\n.fetch()\n.then(() =>\n. @futbalguy Sorry for being slow getting back to you. Thanks for the example, every bit helps.\n\nIn that case, would you mind explaining how the code examples are formatted correctly? When I run JSDoc, they do not format correctly, but they look correct at Bookshelfjs.org.\n\nCurrently the docs from bookshelfjs.org are not generated from JSDoc. The documentation you see there is my efforts so far in changing that. The theme is still a work in progress, but when I generate anything that is indented by four spaces is automatically turned into a code block by the markdown plugin.\nI hope to have the new website up soon, at which point your PR will be on the website.\n. @futbalguy Sorry for being slow getting back to you. Thanks for the example, every bit helps.\n\nIn that case, would you mind explaining how the code examples are formatted correctly? When I run JSDoc, they do not format correctly, but they look correct at Bookshelfjs.org.\n\nCurrently the docs from bookshelfjs.org are not generated from JSDoc. The documentation you see there is my efforts so far in changing that. The theme is still a work in progress, but when I generate anything that is indented by four spaces is automatically turned into a code block by the markdown plugin.\nI hope to have the new website up soon, at which point your PR will be on the website.\n. Have you looked at #873? And acquainted yourself with knex-postgis? I don't really know what PostGIS is, but I get the idea\nI'd look at doing something like this:\n``` js\nclass GeoJson {\n  constructor(attrs) {\n    this.attributes =  attrs instanceof GeoJson\n      ? .clone(attrs.attributes)\n      : .clone(attrs);\n  }\n  toJSON() {\n    // Called when serializing your instance.\n    return this.attributes;\n  }\n  toQuery() {\n    return knex.raw('', this.attributes);\n  }\n}\n// Override your parse/format like so.\nbookshelf.Model = bookshelf.Model.extend({\n  parse() {\n    return super.parse(_.mapValues((value, column) => {\n      Type = this.types && this.types[column];\n       return Type ? new Type(value) : value;\n    }));\n  }\nformat() {\n    return super.format(_.mapValues((value, attribute) =>\n      value.toQuery ? value.toQuery() : value;\n    ));\n  }\n});\nbookshelf.model('Geofences', bookshelf.Model.extend({\n  tableName: 'geofences',\n  types: { geojon: GeoJson }\n});\n```\nNow you can define types with toQuery that will automatically generate their desired output before being inserted into the database. toJson will be called before serializing, so you can present the data for the user.\nIf you still want to do something like this:\njs\n    // INIT\n    initialize: function(){\n        // CONVERT  to object\n        if(this.attributes.areaAsGeoJson){\n            this.attributes.geojson = JSON.parse('{\"type\": \"Feature\",\"geometry\":'+this.attributes.areaAsGeoJson+'}');\n            this.attributes.areaAsGeoJson = undefined;\n        }\n    },\nLook at the virtuals plugin. It's designed for this kind of thing.\njs\n  virtuals: {\n    areaAsGeoJson: function(value) {\n      this.set('geojson', {type: 'Feature', geometry: JSON.parse(value)});\n    }\n  }\nMight take some playing around, but this is the basic approach I'd take.\n. Have you looked at #873? And acquainted yourself with knex-postgis? I don't really know what PostGIS is, but I get the idea\nI'd look at doing something like this:\n``` js\nclass GeoJson {\n  constructor(attrs) {\n    this.attributes =  attrs instanceof GeoJson\n      ? .clone(attrs.attributes)\n      : .clone(attrs);\n  }\n  toJSON() {\n    // Called when serializing your instance.\n    return this.attributes;\n  }\n  toQuery() {\n    return knex.raw('', this.attributes);\n  }\n}\n// Override your parse/format like so.\nbookshelf.Model = bookshelf.Model.extend({\n  parse() {\n    return super.parse(_.mapValues((value, column) => {\n      Type = this.types && this.types[column];\n       return Type ? new Type(value) : value;\n    }));\n  }\nformat() {\n    return super.format(_.mapValues((value, attribute) =>\n      value.toQuery ? value.toQuery() : value;\n    ));\n  }\n});\nbookshelf.model('Geofences', bookshelf.Model.extend({\n  tableName: 'geofences',\n  types: { geojon: GeoJson }\n});\n```\nNow you can define types with toQuery that will automatically generate their desired output before being inserted into the database. toJson will be called before serializing, so you can present the data for the user.\nIf you still want to do something like this:\njs\n    // INIT\n    initialize: function(){\n        // CONVERT  to object\n        if(this.attributes.areaAsGeoJson){\n            this.attributes.geojson = JSON.parse('{\"type\": \"Feature\",\"geometry\":'+this.attributes.areaAsGeoJson+'}');\n            this.attributes.areaAsGeoJson = undefined;\n        }\n    },\nLook at the virtuals plugin. It's designed for this kind of thing.\njs\n  virtuals: {\n    areaAsGeoJson: function(value) {\n      this.set('geojson', {type: 'Feature', geometry: JSON.parse(value)});\n    }\n  }\nMight take some playing around, but this is the basic approach I'd take.\n. Calling hasMany (in this case via Country#citizens()) will return an empty Collection. Calling related('citizens') will return a collection loaded on the model previously.\nSo this...\njs\ncountry.related('citizens').invokeThen('destroy');\n...will only work if you've previously loaded your citizens Collection with either load() or fetch({withRelated: 'citizens'}).\nYou can consider related as doing something like this:\njs\nrelated(relationName) {\n  var relation = this.relations[relationName];\n  if (!relation) {\n    relation = this.relations[relationName] = this[relationName]();\n  }\n  return relation;\n}\n. Calling hasMany (in this case via Country#citizens()) will return an empty Collection. Calling related('citizens') will return a collection loaded on the model previously.\nSo this...\njs\ncountry.related('citizens').invokeThen('destroy');\n...will only work if you've previously loaded your citizens Collection with either load() or fetch({withRelated: 'citizens'}).\nYou can consider related as doing something like this:\njs\nrelated(relationName) {\n  var relation = this.relations[relationName];\n  if (!relation) {\n    relation = this.relations[relationName] = this[relationName]();\n  }\n  return relation;\n}\n. I acknowledge that this is a confusing aspect of the API, but I'm closing this issue because it's a known problem.\n. I acknowledge that this is a confusing aspect of the API, but I'm closing this issue because it's a known problem.\n. Hi @ezra-quemuel, thanks for the report. Happy to accept a PR, or you can wait for me to get around to fixing this.\n. Hi @ezra-quemuel, thanks for the report. Happy to accept a PR, or you can wait for me to get around to fixing this.\n. So what's really happening here is that you're calling two different count() functions. The new method Collection#count, and QueryBuilder#count from Knex.js.\nModel#query() or Collection#query() return a QueryBuilder when called without arguments. So you're just calling QueryBuilder.count() in your second example there.\nWhat were you trying to achieve by calling .query() without arguments in the chain?\n. So what's really happening here is that you're calling two different count() functions. The new method Collection#count, and QueryBuilder#count from Knex.js.\nModel#query() or Collection#query() return a QueryBuilder when called without arguments. So you're just calling QueryBuilder.count() in your second example there.\nWhat were you trying to achieve by calling .query() without arguments in the chain?\n. > Perhaps whereIn could get the same treatment as Model.where() in Bookshelf?\nI'm open to that.\nFor now do this:\njs\nModel.query('whereIn', 'value', values).count()\n. > Perhaps whereIn could get the same treatment as Model.where() in Bookshelf?\nI'm open to that.\nFor now do this:\njs\nModel.query('whereIn', 'value', values).count()\n. Also, I wonder if maybe deprecating .query() with no arguments in favor of .queryBuilder() would be helpful to clarify this.\n. Also, I wonder if maybe deprecating .query() with no arguments in favor of .queryBuilder() would be helpful to clarify this.\n. Calling query without arguments returns the underlying Knex QueryBuilder. I\nthink it's explained in the docs.\nOn Sat, 29 Aug 2015 at 11:58 am blah238 notifications@github.com wrote:\n\nThat works great. What's the difference exactly?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/882#issuecomment-135927305\n.\n. Calling query without arguments returns the underlying Knex QueryBuilder. I\nthink it's explained in the docs.\nOn Sat, 29 Aug 2015 at 11:58 am blah238 notifications@github.com wrote:\nThat works great. What's the difference exactly?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/882#issuecomment-135927305\n.\n. Leaving this open to consider the option of renaming query() (no arguments) to queryBuilder() to eliminate this point of confusion. Having a consistent contract for query() seems preferable.\n. Hi @sgentile. count returns a promise. You must call where before count. You can call count or fetch - not both. Look at the tests again.\n\nIn future please create a new issue rather than commenting on closed issues. I think part of the problem is that there is no example in the docs, so it would be good to have a new issue for this if you wouldn't mind.\n. Hi @sgentile. count returns a promise. You must call where before count. You can call count or fetch - not both. Look at the tests again.\nIn future please create a new issue rather than commenting on closed issues. I think part of the problem is that there is no example in the docs, so it would be good to have a new issue for this if you wouldn't mind.\n. Hey, this code is needlessly overcomplicated by different promise structures. I simplified it a bit. But your problem was that you hadn't passed {transacting: transaction} to your call to UserActivity#save(), so it did not have access to your new circle.id that was isolated in your transaction.\njs\nexports.updateCircle = function(circle, user) {\n  return Bookshelf.transaction(function(transaction) {\n    return getMemberPermission(circle, user)\n    .then(function(permission) {\n      if (neitherOwneraNorAdmin(permission)) {\n        throw messages.apiError('circle.update.noPermission', 'User has no permission to update the circle.');\n      }\n      return circle.save(null, {scenario: 'edition', transacting: transaction});\n    }).tap(function(circle) {\n      return UserActivity.forge({\n        circle_id: circle.id,\n        user_id: user.id,\n        type: 'circle_updated',\n        particular: 0,\n        occurrence_date: new Date()\n      }).save({transacting: transaction});  // <-- This was missing.\n    });\n  }).catch(ValidationError, function(err) {\n    throw messages.validationError('circle.update.', err);\n  }).catch(function(err) {\n    console.log(err.stack)\n    throw messages.apiError('circle.update.error', 'Error updating circle.', err);\n  });\n};\n. Hey, this code is needlessly overcomplicated by different promise structures. I simplified it a bit. But your problem was that you hadn't passed {transacting: transaction} to your call to UserActivity#save(), so it did not have access to your new circle.id that was isolated in your transaction.\njs\nexports.updateCircle = function(circle, user) {\n  return Bookshelf.transaction(function(transaction) {\n    return getMemberPermission(circle, user)\n    .then(function(permission) {\n      if (neitherOwneraNorAdmin(permission)) {\n        throw messages.apiError('circle.update.noPermission', 'User has no permission to update the circle.');\n      }\n      return circle.save(null, {scenario: 'edition', transacting: transaction});\n    }).tap(function(circle) {\n      return UserActivity.forge({\n        circle_id: circle.id,\n        user_id: user.id,\n        type: 'circle_updated',\n        particular: 0,\n        occurrence_date: new Date()\n      }).save({transacting: transaction});  // <-- This was missing.\n    });\n  }).catch(ValidationError, function(err) {\n    throw messages.validationError('circle.update.', err);\n  }).catch(function(err) {\n    console.log(err.stack)\n    throw messages.apiError('circle.update.error', 'Error updating circle.', err);\n  });\n};\n. @sandro-csimas It's very hard to help you with this code that \"doesn't make sense\" (by your own admission) without you telling us what the error is.\n. @sandro-csimas, ah, sorry. I didn't know what 'locked' means. So the transaction promise never resolves (ie. neither catch, nor then handlers are called)?\n. I think I changed this, @vschoettke. That use case was undocumented and had no test case so I didn't realize I was breaking anything.\nI believe I changed this in the course of fixing Model#timestamp which is synchronous and documented as setting attributes on the model based on the result of isNew().\nI assume that you are doing a .fetch() first to check if the model exists before selecting insert or update?\n. I think I changed this, @vschoettke. That use case was undocumented and had no test case so I didn't realize I was breaking anything.\nI believe I changed this in the course of fixing Model#timestamp which is synchronous and documented as setting attributes on the model based on the result of isNew().\nI assume that you are doing a .fetch() first to check if the model exists before selecting insert or update?\n. Sorry @vschoettke I'm still not 100% clear\nAre you saying that you're fetching a new UUID from some shared ID table, or that you're checking for the presence of a record with a duplicate UUID first?\nEither way, I'm considering something like this:\n``` js\nbookshelf.Model = class Model {\n  // ...\n  save() {\n    return this.isNew() ? this.insert() : this.update();\n  }\ninsert() {\n    // this replaces save(attrs, {method: 'insert'})\n  }\nupdate() {\n    // this replaces save(attrs, {method: 'update'})\n  }\n```\nSo if you mean to fetch a new UUID you could override thusly:\njs\nclass UUIDModel extends bookshelf.Model {\n  insert() {\n    return UUID.getNextUUID().then(uuid => {\n      this.set('uuid', uuid)\n      return super.insert()\n    })\n  } \n}\nOr if you meant to check the existance of a pre-existing model you could do this:\njs\nclass UUIDModel extends bookshelf.Model {\n  isNew() {\n    return this.fetch().then(model => return model == null);\n  }\n  save() {\n    return this.isNew().then(isNew => isNew ? this.insert() : this.update());\n  } \n}\nSo it's a change for you. but it means that the contract of isNew remains synchronous in Bookshelf core, which makes sense to me. Happy to discuss this further and get a new version out.\nAlso worth noting here is that I'm not even sure if Model#timestamp()'s contract is overly useful. I just noticed that it did something different to the documentation. One could make an argument for making timestamp() private.\n. Okay, so that would be this method in my proposed changes:\njs\nUUIDModel =  bookshelf.Model.extend({\n  save() {\n    return this.fetch().then(existing =>\n      existing == null ? this.insert() : this.update()\n    );\n  } \n});\nYour other option would be to change the options object in a \"saving\" event handler (you can do this in 0.8.2 as far as I know).\nSomething like this:\njs\ninitialize: function() {\n  this.on('saving', (model, attrs, options) {\n    return this.constructor.where('id', this.id).fetch().then(function (existing) {\n      options.method = existing == null ? 'insert' : 'update';\n    });\n  }\n}\nAlternatively we could add tests and documentation for supporting promises returned by isNew. However this means that timestamp() will not be able to keep its current contract:\n\nSets the timestamp attributes on the model, if hasTimestamps is set to true or an array. The default implementation is to check if the model isNew...\n\nSo that would mean removing Model#timestamp() as a public function, or adding logic that means it will sometimes return a promise. Personally I think overridden functions should maintain their original contract - they should not modify their return type. So modifying save directly or hooking into an event feels like a cleaner approach.\n. And also the version of Bookshelf you're using pls, @LordSputnik.\n. So my memory isn't that great apparently. This one's a duplicate. #397, #665 and #642 are all related.\n. > When a user deletes a node in the organisation, all children nodes have to be deleted and employees have to be dissociated with the deleted nodes i.e. remove entries from the junction table.\nThe best way to do this is to set up ON DELETE CASCADE or ON DELETE SET NULL per foreign key in your table definitions. This is not something that you'd do in Bookshelf. You can do it in the Knex schema builder if you're using it.\n\njs\n   if (!organisation) {\n        reply(\"ORGANISATION NODE ... CAN NOT BE FOUND\");\n    }\n\ntry: fetch({require: true}).\n\nI suppose relations are eagerly loaded...\n\nNot unless you explicitly request them using withRelated:\njs\nModel.where('something', 5)\n  .fetch({withRelated: ['friends', 'family']})\n  .then(function (model) { ...\n\nmodel.employees().detach().then(function() {\n\nHere employees() returns an empty collection that represents the employees relation. I'd advise you to call model.related('employees') instead.\nCollection#detach, as documented, requires an array of models (or model IDs) to detach from the relationship. I believe it will then delete matching rows in the many-to-many join table.\nThe above code says \"detach no employees from this model\", as it has no IDs specified.\n. Quite welcome.\n. You'd like a minimum version for each feature? I think this will be possible with the new JSDoc generated website I'm launching this evening. Using the @since tag. Model#refresh and Model#count were both added in 0.8.2, so I guess they could be added there.\nFYI there is a change log. If you're worried about different instances of your project using different versions you should be using npm install bookshelf --save-exact. IMO this should be the default behaviour of npm.\n. Agreed 100%. This is a bug in Knex, please open an issue there referencing this. I'll accept a PR at Knex to fix this.\nI feel as though there was a related discussion at knex but I can't find it now. tgriesser/knex#332 is relevant here.\n. Closed as duplicate. #435\nPro tip: If you had searched instead of posting you would have had your answer 10 hours earlier.\n. > knex does not have property called VERSION\nKnex#VERSION\n\nThe bookshelf documentation is wrong.\n\nBookshelf() knex parameter description - \"Knex instance\".\nBookshelf \"Installation\" guide with example.\nAlways willing to take PRs that improve documentation. A statement as general as \"[it] is wrong\" doesn't give us anything to work with.\n. Hi @rauls. A lot of address here. For future reference it's easier to manage when these are broken into separate issues.\n\nmodel.query().whereIn( 'id', [1,2,3,4] ).then\n\nAs you suggested this exact syntax wouldn't be possible as .query() returns a Knex instance. That doesn't mean it's not possible. It could be done like this:\njs\nmodel.whereIn([0, 1, 2]).fetch()\nmodel.whereIn(attribute, [0, 1, 2]).fetch()\n\nmodel.query().where( { id: [ 1,2,3,4 ] ).then\n\nSame deal with where. You can add methods to Model, but not to QueryBuilder.\nI'm not so sure about this one. That is just what whereIn is for. Why the needless overloading? Also, I'm not sure this is a thing, but if a database did support array type comparisons, it would be unclear whether you're wanting WHERE id = (1, 2, 3, 4) or WHERE id IN (1, 2, 3, 4).\nI currently have a proposal for a full API overhaul, and this feature you've suggested is in there.\nFrom the proposal:\njs\nUsers.one(5).fetch().then(user =>\nUsers.all([20, 3, 5]).fetch(users =>\nUsers.whereIn('field', [1, 2, 3]).fetch(users =>\n\nAlso as a minor request in the documentation - could we have a matrix table that defines which combinations of model.query/where/fetch/fetchAll/select is possible or not.\n\nThis is actually explained in the docs. A relation that returns a Collection will expose fetch, one that returns a Model will expose fetchAll. It's not good, and it's confusing to learn and use. However the aforementioned proposal corrects this. You're welcome to add PRs clarifying the current API (docs are written inline in code via JSDoc).\n\nAs getting undefined where() calls could be either smartly mapped or even throw an console error describing why it doesn't exist in that object?\n\nOr better yet I could just fix the problem: #780\nI think I'll do this today.\n\nThanks for updating the docs anyway, much nicer looking. But could you add the version number to the top of the page, and left menu and page title too ?\n\nYou're welcome. I agree this is a good idea, I noticed after I launched that I'd missed it. I've created an issue: bookshelf/bookshelf-jsdoc-theme#1. I will accept a PR, otherwise I'll get around to it next time I'm working on the theme.\n\nAny chance of adding docs to ZEAL?\n\nPrior to your asking I had not heard of Zeal. I'm not sure what's involved but it sounds like it could be convenient for its users. Is it something you'd be willing to organize?\n. Basically I think you want to be using polymorphic relations rather than inheritance. Inheriting a new model over a table doesn't make a great deal on sense in this instance.\nI'd probably do something like this:\n``` js\n// plugin-instance.js\nbookshelf.model('PluginInstance', bookshelf.Model.extend({\n    tableName: 'plugin_instances',\n    idAttribute: 'id',\n    hasTimestamps: ['tcreated', 'tmodified'],\n    pluginDataModels: []\nproject: function() {\n    return this.belongsTo('Project');\n},\nplugin: function() {\n    return this.belongsTo('Plugin');\n},\ncards: function () {\n    return this.belongsToMany('Card');\n},\npluginData: function () {\n    return this.morphTo.apply(this, ['plugin_type'].concat(this.pluginDataModels));\n}\n\n}, {\n    registerPlugin: function (Plugin) {\n        // Add the name of the plugin data model to the pluginDataModels array. That way\n        // we can call related('pluginData') on any plugin instance and get its\n        // correct data model.\n        this.prototype.pluginDataModels.push(Plugin.prototype.DataModel);\n    }\n});\n```\n``` js\n// index.js\nfunction registerPlugin(Plugin) {\n  // do whatever needs to be done\n  bookshelf.model('PluginInstance').registerPluginDataModel(Plugin);\n}\nmodule.exports.registerPlugin = registerPlugin;\n```\n``` js\n// plugins/pinboard.js\nPinboardData = bookshelf.Model.extend({\n    plugin: function () { return this.morphOne('Pinboard', 'plugin_type');\n});\nPinboard = bookshelf.model('PluginInstance').extend({\n    pluginName: 'pinboard',\n    pluginType: 'board',\n    baseUrl: '/pinboards',\n    pluginDataModel: 'PinboardData'\n});\nbookshelf.register('PinboardData', PinboardData);\nbookshelf.register('Pinboard', Pinboard);\nmodule.exports = Pinboard.\n```\n``` js\n// library consumer code\nlib = require('my-library')\npinboard = require('my-library/plugins/pinboard');\nlib.registerPlugin(pinboard);\n```\n. Hi @ReconShot. I was aware of this, but changing primary key value is rare enough that it hasn't come up before.\n~~You can work around it like this for now:~~\n@rluba reports this doesn't work apparently. :(\njs\nModel.where({custom_id: 1}).save({\n  custom_id: 2,\n  name: 'blabla',\n  email: 'email@email.com'\n}, {patch: true})\n.then(...)\nI think the logic on paper should be something like this:\njs\nvar idAttribute = this.idAttribute;\nvar id = this.previousAttributes[idAttribute] || this.attributes[idAttribute];\nif (id != null) {\n  return insert(attributes);\n} else {\n  return update(id, attributes);\n}\nAlthough in practise the code that manages this operation is nothing like this! So it's not going to be so simple a change.\nThe real question is what is more correct:\n``` js\nModel.where('id', 5).fetch().then(model => {\n  model.set('id', 6);\nmodel.id === 5; // id represents the persisted id column in the database.\n  model.id === 6; // id represents the current id column in the model.\n});\n```\nCurrently we have the latter. Personally I think the former is more correct.\n. Seems you've found a solution, @apla. Would you be able to provide a PR?\n. Thanks @rluba, I updated my comment.\n. Thanks @skevy. :+1:\n. It'll do. Thanks @tkambler.\n. Hi. This is a knex issue, since you're accessing Knex#transaction directly. Have you tried updating to a more recent version of knex (or bookshelf for that matter)?\nRelated: tgriesser/knex#405.\n. No probs.\n. > produces a select with an undefined id\nA select? Or an update?\npatch: true should always update btw, so method: 'update' is redundant.\n. > doing that query without method: 'update' does n insert\nModelBase#saveMethod must be aware of options.patch. \n. > a select - the first query, however, does an update\nVery strange. I can't work out how a select could be generated here. I'll have to look into it.\n. Well, this question was left open for a while. @lichtner, respond if you're still stuck and I'll reopen and try to help.\n. Thanks @bsiddiqui.\n. Use promise.all instead of promise.try. Use map instead of foreach. Pass\nthe mapped promises into promise.all. Return the promise resulting from\npromise.all.\nOn Sun, 27 Sep 2015 9:57 am jamesdixon notifications@github.com wrote:\n\nThanks @blah238 https://github.com/blah238. Here's the complete method:\ncreate: (businessId, services, transaction) => {\n    // get model references\n    const ServiceGroup = Bookshelf.model('ServiceGroup');\n```\n// set options\nlet options = {};\n// if the update should be part of a transaction, add it to the options\nif (!_.isEmpty(transaction)) {\n  options.transacting = transaction;\n}\nreturn Promise.try(() => {\n// iterate through the list of services\n  _.forEach(services, (service) => {\n    /*         *  If object does NOT have an id, that means it is new and has not been         *  created so in that case it should be created and a new group should         *  then also be created.         /\nif (_.isUndefined(service.id)) {\n\n  // associate the service with the business id\n  service.businessId = businessId;\n\n  ServiceGroup\n    .forge()\n    .save(null, options)\n    .then((serviceGroup) => {\n\n```\n// associate new service with new service group\n              service.serviceGroupId = serviceGroup.get('id');\n```\n          // create the new service\n      return Service.forge(service).save(null);\n    });\n\n} else {\n\n  /**           * If object has an id, that means it has already been created.           * In that case create a new instance of the service or surcharge           * and remove the old one from being active. In this case a new group           * should not be created. The new instance should associate with the same           * group as the last object.           */\n\n  // mark previous instance as Inactive\n  service.active = false;\n\n  // update the previous instance\n  Service\n    .update(service.id, service.businessId, service, transaction)\n    .then((updatedService) => {\n\n      // activate and remove the id of the service\n      delete service.id;\n      service.active = true;\n\n      // create the new instance\n      return Service.forge(service).save(null);\n    });\n}\n\n}); // forEach\n}); // end promise.try\n```\n},\nGiven your explanation of when the tx resolves, it sounds like it has\nsomething to do with the way I've setup the promise. As you can see, I'm\nlooping through a list of services and didn't attempt to return them as I\nwas thinking it would break out of the loop before it had finished. Hence,\nI attempted to use Promise.try() to start the chain. However, maybe it's\na combination of those things that's just wrong.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/928#issuecomment-143506099\n.\n. Thanks @jadengore.\n. Hi @Distopico. The virtuals plugin adds properties to the Model instance. So, the code above is trying to add Model#id, first as a getter, then as both a getter and setter.\n\nModel#id is already exists, and is used internally by Bookshelf code. Your first code snippet (adding a getter) is completely redundant because if you set Model#idAttribute to \"user_id\" you'll get the exact same behaviour. However, by not supplying a setter, you're preventing Bookshelf from setting it!\nIn the second case, calling set('user_id') executes that same line, causing an infinite recursion: set 'id', set 'user_id', set 'id', set 'user-id' etc.\nLooking at your code, it looks to me that you're trying to achieve this:\njs\nvar User = bookshelf.Model.extend({ table: 'users', idAttribute: 'user_id' });\nvar user = new User();\nuser.id = 'TEST';\nassert(user.get('user_id') === 'TEST', 'user_id was set by `id` setter');\nThis is a good idea, but is not something that should be achieved via the virtuals plugin. What this needs is a change in src/base/model that defines a getter/setter pair for Model#id, which uses Model#idAttribute to determine the correct attribute to retrieve/update.\nIf you're willing I'll accept a PR that adds this functionality.\nPS. Are you sure this worked in 0.8.1? I can't see how it would have been possible. There were some changes made to virtuals, however.\n. Leaving this open for changes mentioned in my previous post.\n. Leaving this open for changes mentioned in my previous post.\n. That would be amazing. Separate would be better I guess but whatever you\nfind easier.\nOn Tue, 13 Oct 2015 at 10:29 am Basil Siddiqui notifications@github.com\nwrote:\n\n@rhys-vdw https://github.com/rhys-vdw happy to fix this and some of the\ndocs PRs - would you prefer a single PR or a separate PR for each issue?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/931#issuecomment-147548415\n.\n. That would be amazing. Separate would be better I guess but whatever you\nfind easier.\nOn Tue, 13 Oct 2015 at 10:29 am Basil Siddiqui notifications@github.com\nwrote:\n@rhys-vdw https://github.com/rhys-vdw happy to fix this and some of the\ndocs PRs - would you prefer a single PR or a separate PR for each issue?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/931#issuecomment-147548415\n.\n. Hi @jamesdixon, sorry for the slow reply. This should have been addressed by #772.\n\n``` js\nbookshelf.Collection = bookshelf.Collection.extend({\n  fromLastWeek() {\n    return this.where('created_at', '>', moment().subtract(1, 'week'));\n  }\n});\n// ...\nuser.related('posts').fromLastWeek().fetch().then(posts => // ...\n``\n. Also, bear in mind that [Collection#serialize](https://github.com/tgriesser/bookshelf/blob/c040ee4dee26fe5b95daedd2873f1b5d9bdae647/src/base/collection.js#L99-L103) callsModel#serialize- so unless you want to change the array structure you probably don't need to do that.\n. Thanks @dsauerbrun. I added a little more (including thewithRelated@paramtag).\n. Hi @MartinCa. Looks like this bug was caused by bad scoping ofvar`.\nBest to use the new ES6 variable types (let and const), and declare variables as close to use as possible. This is not best practise with var; moving var relation into the for loop gives misleading scope (since it will be defined it the function scope - var does not respect for blocks).\nCan you please remove the var relation declaration and change this to:\n``` js\n      if (!_.isFunction(target[relationName])){\n        throw new Error(relationName + ' is not defined on the model.');\n      }\n  const relation = target[relationName]();\n\n```\n. Nice, thanks @MartinCa.\n. Nice, thanks @MartinCa.\n. @vellotis Hey, good catch - there is a bug here! But your fix is wrong. I think it should be something like this:\n`` js\n      // Handle\"key\", value` style arguments.\n      if (setVirtual.call(this, value, key)) {\n        return this;\n      }\n  if (isPatching) {\n    this.patchAttributes[key] = value;\n  }\n\n  return proto.set.apply(this, arguments);\n\n```\nCould you open a new PR with the correct change and a test or two to show that it works?\n. @vellotis Hey, good catch - there is a bug here! But your fix is wrong. I think it should be something like this:\n`` js\n      // Handle\"key\", value` style arguments.\n      if (setVirtual.call(this, value, key)) {\n        return this;\n      }\n  if (isPatching) {\n    this.patchAttributes[key] = value;\n  }\n\n  return proto.set.apply(this, arguments);\n\n```\nCould you open a new PR with the correct change and a test or two to show that it works?\n. @vellotis Understandable, it's a bit confusing.\nThe existing tests don't cover the set(key, value) argument style, so that's the main one.\nThanks. :+1:\n. @vellotis Understandable, it's a bit confusing.\nThe existing tests don't cover the set(key, value) argument style, so that's the main one.\nThanks. :+1:\n. @vellotis Really nice work. Thanks for the PR.\n. @vellotis Really nice work. Thanks for the PR.\n. Looks like you can just do:\njs\nUser.forge({ id: 5 }).fetch({ withRelated: ['group', 'friends'], require: true })\n  .then(handleUser)\n  .catch(bookshelf.NotFoundError, handleError);\nAnd that should also require at least one group and friend model in the relations. Could you confirm whether this is the case?\nThe desired behaviour should be documented/tested if it works.\n. Looks like you can just do:\njs\nUser.forge({ id: 5 }).fetch({ withRelated: ['group', 'friends'], require: true })\n  .then(handleUser)\n  .catch(bookshelf.NotFoundError, handleError);\nAnd that should also require at least one group and friend model in the relations. Could you confirm whether this is the case?\nThe desired behaviour should be documented/tested if it works.\n. Personally I don't think that behaviour would be intuitive or correct, so I'm glad it's not the case. If you're interested in expanding the behaviour here we can turn this into a discussion thread.\n. Personally I don't think that behaviour would be intuitive or correct, so I'm glad it's not the case. If you're interested in expanding the behaviour here we can turn this into a discussion thread.\n. Maybe require: ['relation', 'otherRelation.itsChild'] or something?\n. Maybe require: ['relation', 'otherRelation.itsChild'] or something?\n. Or we expand the DSL to do this:\njs\nUser.where('id', 1).fetch({ withRelated: ['account!', 'friends', 'posts!.responses'] });\n// Will fail if user has no 'account' or 'posts'.\n. Or we expand the DSL to do this:\njs\nUser.where('id', 1).fetch({ withRelated: ['account!', 'friends', 'posts!.responses'] });\n// Will fail if user has no 'account' or 'posts'.\n. Hm. Problem with the other way is that we don't currently support passing a key/value object as the value of a withRelated call.\nIf we did I'd expect it to be something like this:\njs\nUser.fetchAll({ withRelated: {\n  friends: { where: { gender: 'f' }, orderBy: 'age' }\n}).then(maleFriends =>\nThat is just because Model#query() accepts a similar object and the two should be equivalent.\nHowever, I'm not very fond of the object syntax for knex, since there are methods that it does not support properly (.orderBy(column, direction) for example). So perhaps it would be better that way.\nI'd want to be able to document it clearly like \"this is the options object to be passed to fetch on the relation\". Currently fetch doesn't take a query option, but it could be made to do so...\nIf we take this approach then we can support options.columns while we're at it.\n. Hm. Problem with the other way is that we don't currently support passing a key/value object as the value of a withRelated call.\nIf we did I'd expect it to be something like this:\njs\nUser.fetchAll({ withRelated: {\n  friends: { where: { gender: 'f' }, orderBy: 'age' }\n}).then(maleFriends =>\nThat is just because Model#query() accepts a similar object and the two should be equivalent.\nHowever, I'm not very fond of the object syntax for knex, since there are methods that it does not support properly (.orderBy(column, direction) for example). So perhaps it would be better that way.\nI'd want to be able to document it clearly like \"this is the options object to be passed to fetch on the relation\". Currently fetch doesn't take a query option, but it could be made to do so...\nIf we take this approach then we can support options.columns while we're at it.\n. From the docs:\n\n[Model#query] Will return this model or, if called with no arguments, the underlying query builder.\n\nSo the only events you'll get from calling methods on the QueryBuilder are Knex events. It's not part of Bookshelf.\nIf you want to use Bookshelf events you must use the Bookshelf API:\n``` js\nvar User = bookshelf.model('User');\n// Triggers \"saving\", \"updating\", \"saved\" and \"updated\".\n// (your second code example - much terser btw.)\nreturn User.where('name', 'Foo').save({ name: 'Bar' }, { patch: true }).then(function (users) {\n  ...\n});\n// Or something fancier using query: triggers \"fetching\", \"fetched\".\nUser.query('whereRaw', 'age % 2 = 0').fetch().then(function (usersWithEvenAge) {\n  ...\n});\n```\nRead #882 for more explanation. Possibly solved by #892.\n. From the docs:\n\n[Model#query] Will return this model or, if called with no arguments, the underlying query builder.\n\nSo the only events you'll get from calling methods on the QueryBuilder are Knex events. It's not part of Bookshelf.\nIf you want to use Bookshelf events you must use the Bookshelf API:\n``` js\nvar User = bookshelf.model('User');\n// Triggers \"saving\", \"updating\", \"saved\" and \"updated\".\n// (your second code example - much terser btw.)\nreturn User.where('name', 'Foo').save({ name: 'Bar' }, { patch: true }).then(function (users) {\n  ...\n});\n// Or something fancier using query: triggers \"fetching\", \"fetched\".\nUser.query('whereRaw', 'age % 2 = 0').fetch().then(function (usersWithEvenAge) {\n  ...\n});\n```\nRead #882 for more explanation. Possibly solved by #892.\n. There is a discussion of where here. Note that I created this issue before I was a collaborator. Actually I'm happy to update Model#where and Collection#where to use format eventually (soon even?). It's incredibly simple to roll your own though.\n. There is a discussion of where here. Note that I created this issue before I was a collaborator. Actually I'm happy to update Model#where and Collection#where to use format eventually (soon even?). It's incredibly simple to roll your own though.\n. @jamesdixon: #780\nI'd fix that at the same time. Probably for 0.9 or 0.10.\n. @jamesdixon: #780\nI'd fix that at the same time. Probably for 0.9 or 0.10.\n. @jamesdixon Hm. I'd sooner provide an option called attributes rather than columns. Since columns implies the literal column names.\nAnyway, you can't simply apply format() to ['column_a', 'column_b'], since it expects an object. The whole thing needs to be refactored.\nI think the best approach would be to deprecate parse and format and replace them with methods columnToAttribute, attributeToColumn.\n. @jamesdixon Hm. I'd sooner provide an option called attributes rather than columns. Since columns implies the literal column names.\nAnyway, you can't simply apply format() to ['column_a', 'column_b'], since it expects an object. The whole thing needs to be refactored.\nI think the best approach would be to deprecate parse and format and replace them with methods columnToAttribute, attributeToColumn.\n. My understanding of the auto incrementing integer type is that it keeps a record of its last insertion. If you insert rows with explicit IDs, you can get this problem.\nOn an empty table, if you were to do the following:\njs\nPromise.each([\n  User.forge({ name: 'John' }).save(), // created user ID 1\n  User.forge({ name: 'Jane' }).save(), // created user ID 2\n  User.forge({ id: 3, name: 'Bob' }).save(null, { method: 'insert' }), // created user ID 3 explicitly\n  User.forge({ name: 'Sam' }).save() // Attempting to create user with ID 3\n]).then( // ...\nWhen the above code goes to create Sam, it will fail with the error you've given. This is because the auto incrementing key last generated the ID 2, and inserting with an explicit ID has thrown things out of whack. This is the only thing I can think of.\nBtw, rather than adding console.log, you can pass { debug: true } as an option to save, fetch etc. do get a debug trace of all queries.\n. My understanding of the auto incrementing integer type is that it keeps a record of its last insertion. If you insert rows with explicit IDs, you can get this problem.\nOn an empty table, if you were to do the following:\njs\nPromise.each([\n  User.forge({ name: 'John' }).save(), // created user ID 1\n  User.forge({ name: 'Jane' }).save(), // created user ID 2\n  User.forge({ id: 3, name: 'Bob' }).save(null, { method: 'insert' }), // created user ID 3 explicitly\n  User.forge({ name: 'Sam' }).save() // Attempting to create user with ID 3\n]).then( // ...\nWhen the above code goes to create Sam, it will fail with the error you've given. This is because the auto incrementing key last generated the ID 2, and inserting with an explicit ID has thrown things out of whack. This is the only thing I can think of.\nBtw, rather than adding console.log, you can pass { debug: true } as an option to save, fetch etc. do get a debug trace of all queries.\n. This is how Bookshelf works. Model instances are mutable, and have their internal Knex query reset after a query is executed.\nModel.where is actually shorthand for Model.forge({}).where.\nSo you could do this:\njs\nvar completedTodos = models.Todo.where('completed', null);\nvar totalCount = yield completedTodos.clone().count();\nthis.body = {\n    data: (yield completedTodos.fetchAll()).toJSON(), // omits \"where completed is null\"\n    totalCount: totalCount,\n};\n. This is how Bookshelf works. Model instances are mutable, and have their internal Knex query reset after a query is executed.\nModel.where is actually shorthand for Model.forge({}).where.\nSo you could do this:\njs\nvar completedTodos = models.Todo.where('completed', null);\nvar totalCount = yield completedTodos.clone().count();\nthis.body = {\n    data: (yield completedTodos.fetchAll()).toJSON(), // omits \"where completed is null\"\n    totalCount: totalCount,\n};\n. Agreed, I will happily accept a PR.\n. Agreed, I will happily accept a PR.\n. @xiechao06\nJust looked at the source and clone is definitely broken! Thanks for telling me.\nTry this:\njs\nfunction completedTodos() {\n  return models.Todo.where('completed', null);\n}\nvar totalCount = yield completedTodos().count();\nthis.body = {\n    data: (yield completedTodos().fetchAll()).toJSON(),\n    totalCount: totalCount,\n};\n. Hi @bsiddiqui,\n\nWhen I do a fetch and save it responds with an array...\n\nCould you show me the fetch and save code? That doesn't sound right.\n\nwhen I do a .where(...).save(...) it returns a single id\n\nAcutally this is returning the number of changed columns. See Knex#update. Using save in this way is currently undocumented, unfortunately.\nDatabases other than PostgreSQL do not support returning more than one value from an INSERT/UPDATE statement. Which DBMS are you using? If you are using PostgreSQL it might be possible to do something like this:\njs\nModel.where('name', 'Rhys').query('returning', '*').save(attrs).then(rows =>\nShow me what you're trying to do and we'll see if any doc/code changes are required.\n. Hi @bsiddiqui,\n\nWhen I do a fetch and save it responds with an array...\n\nCould you show me the fetch and save code? That doesn't sound right.\n\nwhen I do a .where(...).save(...) it returns a single id\n\nAcutally this is returning the number of changed columns. See Knex#update. Using save in this way is currently undocumented, unfortunately.\nDatabases other than PostgreSQL do not support returning more than one value from an INSERT/UPDATE statement. Which DBMS are you using? If you are using PostgreSQL it might be possible to do something like this:\njs\nModel.where('name', 'Rhys').query('returning', '*').save(attrs).then(rows =>\nShow me what you're trying to do and we'll see if any doc/code changes are required.\n. Love your work, @jadengore!\n. Love your work, @jadengore!\n. Thanks, @bsiddiqui.\n. Thanks, @bsiddiqui.\n. Hi @bweber. Happy to help here, but I need more information. Are you trying to remove the models from the collection in memory, or to actually modify the persisted models? Could you provide an example of some Bookshelf code and how you would like it to behave with this plugin?\n. I wasn't aware of this. Which DMBS are you using?\n. Could you add debug: true to the fetch command and add the logged query and the code to this thread pls?\n. It appears to be caused by ambiguity between \"foo\" being a string literal or a column identifier. Using PostgreSQL, Knex will forward an exception when trying to SELECT an invalid column.\nPlaying:\nsql\nsqlite> create table t(id integer primary key, name text);\nsqlite> insert into t (name) values ('Rhys');\nsqlite> select * from t;\n1|Rhys\nsqlite> select *, hello from t ;\nError: no such column: hello\nsqlite> select *, \"hello\" from t;\n1|Rhys|hello\nsqlite> select \"name\", \"hello\" from t;\nRhys|hello\nsqlite> select `name`, `hello` from t;\nError: no such column: hello\nI'm pretty sure this is caused by Knex using incorrect delimeters for sqlite3.\n. Thanks @cobbspur, I've reported this issue upstream.\n. @jamesdixon The 'name' of a resource is a concept from JSON API, so you'll have to decide how you want to supply it. The obvious answer is to provide it at definition time:\n``` js\nvar superSerialize = bookshelf.Model.prototype.serialize;\nJsonApiModel = bookshelf.Model.extend({\n  serialize: function() {\n    return {\n      type: this.type,\n      id: this.id,\n      attributes: superSerialize.apply(this)\n      // or whatever...\n    };\n  }\n});\nUser = JsonApiModel.extend({\n  tableName: 'users',\n  type: 'user'\n});\n```\nIf you want to provide a type without specifying it on the model you have to work out what you want to use... You could use the table name (this.tableName) or constructor name (this.constructor.name)... I think I'd just require it explicitly though as above.\n. @ricardograca Current a release will add two commits to master:\n- Release \n- Remove compiled source and generated documentation after  release.\nI thought about the release branch... If we had a release branch I think it would end up being the same as master after each release (thereby not really adding much). Any ideas on how to simplify this?\n. @ricardograca Right, yes. That's not a bad idea... That way we'd keep compiled source out of master permanently. Shouldn't be too much effort to change the target branch in the release script.\n. @ricardograca I'm about to merge this, I just thought I'd let you know why I didn't end up implementing your suggestion. First is that I already spent more time than I expected working on the release script (with non-existant bash script skills). Secondly I worried that there might be weirdness/complexity merging master into the release branch when they have different .gitignore files etc.\nNo problem with the concept, perhaps we can look at it again before release.\n. @ricardograca Perhaps the ultimate here would be to have a branch that contains only the built files and package.json. Remove README, /src etc - everything that is not required by npm.\nAlso I do wonder if we could get away with dropping bower support. There is a general community movement towards using npm for front end. I wonder if people are even using Bookshelf in browser...\n. @jadengore, @ricardograca.\nNo more /lib.\n. > You can use Bookshelf in the browser?\nYep. There's an instance running at http://bookshelf.js. Actually I'm glad you mentioned this because I just checked and knex.js is missing.\nKnex works fine in browser. You can use it as a query builder, or you can run websql in the browser. Bookshelf works similarly. (Although Bookshelf doesn't really win at query generation.)\n\nwhy do we need to keep the generated code in the repo in the first place? What's wrong with just generating what's needed when publishing/developing?\n\nBower links to the specific commit, so we actually have to have it there for Bower.\nAlso incidentally, just noticed the Bookshelf releases view, which has a list of releases associated with commits. Not sure how these are created. Perhaps GitHub looks at the commit message for the word \"Release\".\nThe other reason is that if someone has a complain about a specific version we have the exact data that is in the npm ready to be checked out.\n. @bsiddiqui Yes, that is a great idea.\nGithub doesn't allow PRs against the wiki, but if you just paste the documentation into this issue thread I'll update the wiki after merging the PR.\n. You could just make it that users in particular are fetched differently (also means fewer queries):\nuser.js\n``` js\nfunction selectRoleAndState() {\n  this.query()\n    .leftJoin('user_roles', 'users.id', 'user_roles.user_id')\n    .leftJoin('user_state', 'users.id', 'user_states.user_id')\n    .select(\n      'users.email', 'users.created_at', 'users.updated_at',\n      'user_states.user_state', 'user_roles.user_role'\n    );\n}\nvar User = Bookshelf.model.extend({\n  tableName: 'users',\n  initialize() {\n    this.on('fetching', selectRoleAndState);\n  }\n}\n```\nOtherwise you'll have to override your serialize function.\n. No probs. FYI you can also drop unwanted attributes with the visibility plugin. Helps with some situations like this.\n. Hm, that's an old discussion. I personally wouldn't advise that approach.\nIf you soft deletion why not do something like this:\n``` js\nfunction skipDeleted(model, columns, options) {\n  return this.query('whereNotNull', 'deleted_at');\n}\nSoftDeleteModel = bookshelf.Model.extend({\n  initialize() {\n    this.on('fetching', skipDeleted);\n  },\ndestroy(options) {\n    var now = new Date();\n    return this.save({ deleted_at: now }, _.extend({ patch: true }, options)); \n  }\n});\n```\nThat should cover all the use cases...\n. @bsiddiqui Right sorry, try this handler:\njs\nfunction skipDeleted(model, columns, options) {\n  // There is also a `query` in options.\n  return options.query.whereNotNull('deleted_at');\n}\n. @bsiddiqui Hm, that's odd. I can't look into it now, but if you find anything out please post here.\n. Ah, interesting. The query option must be being passed to the relations. You've really uncovered a bunch of bugs here.\nThe bug is here - should omit 'query' also I guess.\n. Actually thinking about this more - that shouldn't be the problem. I'm not sure why you're getting this issue. If you add this line:\njs\nconsole.log('skipDeleted', new Error().stack);\nto your skipDeleted callback it might yield some more information about why it's being called at the wrong time.\n. > Looks like it's only when using through\nHm. Is the event handler meant to be applied to the through relation? Is it possible that the callback is somehow being bound to the wrong object? What happens if you do this instead:\njs\nskipDeleted(model, attributes, options) {\n  // use `model` instead of `this`.\n  return options.query.whereNull(_.result(model, 'tableName') + '.' + 'deleted_at');\n}\n. > Yeah that makes sense - this.query doesn't work because this references the model prototype?\nNo, I'm not sure exactly what's going on there. The QueryBuilder is replaced at certain times during a model's life time. It may be that this.query() is returning a different instance to the one in options which is going to be used for the query.\n\nDoes my explanation of the issue in my last comment make sense?\n\nYes, but I'm not sure what is going wrong. The relations code is quite hairy (as you've probably noticed). I'd need to sit down and create a test case, reproduce the error, and try to debug it. I actually don't mind doing this, but I'm not in a good position time wise to look into it right now.\n. I should note that both of these behaviours seem like bugs to me.\n. What is the error?\n. And the code that throws it?\n. Are you sure? Because there is no way to call model.save when model is undefined. Check the stack trace of the error.\n. > It is abstraction code. I can not share real project.\nWell then you'll have to debug your own project. It sounds like you're doing something like this:\njs\ndoSomething().then(model.save) // passing function as unbound callback.\n. Hey @apla, thanks for that. Tests and all!\n. Yeah, I'm just finalizing a new release script. I'll do a release soon.\n. > I could not figure out where do the models get pushed in the collection and why they are not getting pushed. The models never get pushed inside the handled object\nTry to see out what's happening here - that's where the models get grouped by their key values before being assigned to relations here. In the past I've added logs to this section of code to see what's happening when the models are being associated.\nIt would be good to get some better error reporting here.\n. @amanmohla This is a known problem due to how parse and format work. I've an idea of how to fix it, but it would take a lot of work and I'm not expecting to address it personally in the immediate future.\nUnfortunately in the meantime you may have to avoid using parse/format (unless you're able/willing to rename your database columns).\n. Either of these will work:\njs\nAccount.forge({name: accountName}).fetch().then(account =>\n  account.related('users').query('where', 'email', email).fetch({ require: true })\n).then(user =>\n  console.log('Found a user', user))\n).catch(User.NotFoundError, error =>\n  console.error(`Unable to find user with email ${email} in account ${accountName}`)\n);\njs\nAccount.where({ name: accountName }).fetch({withRelated: {\n  users: query => query.where('email', email)\n}}).then(account => account.related('users')).then(_.first).then(user =>\n  console.log('Found a user', user)\n);\n. Oh, sorry... It should be account.related('user').query('where', 'email', email)\n. > the records with the duplicate IDs now all have identical properties rather than being distinct (except for the ID).\nThis shouldn't be happening, obviously. Would you be able to provide an example that causes this?\n\nI have a somewhat unique situation...\n\nIt sounds like you're just adding appointments to a one-to-many relationship, which should be straight forward.\n\nBecause of the virtual nature of the dynamically generated records for recurring instances and the fact that there is a relation that depends on appointment.id, I need to keep the id the same for those records in order to retrieve the relation information I need.\n\nI don't get it, sorry. I'm having trouble with \"virtual nature\" and \"keep the id the same\". :-S\n. Cheers.\n. Cheers.\n. Closed by #968.\n. @jadengore You need to target the src/ directory, not lib/. lib/ is compiled from src/. btw, I'm going to try to remove lib/ from version control this weekend.\n. Yep, great. Cheers.\n. Thanks @cspotcode - please be careful to target src/ folder (not lib/).\n. > Backbone also allows binding the this context, which Bookshelf doesn't\n\nsupport. Bookshelf's events are somewhere between node events and Backbone\nevents.\n\nBookshelf events are implicitly bound to the Model/Collection instance that emits the error.\nThis event interface was created Backbone was removed as a dependency. It's there to provide back compatibility, but IMO should be a thin wrapper around Node's EventEmitter. Adding context would create more complexity in the wrapper. If people really want to use a different this they can use Function.bind.\nHowever we definitely want the multiple event name support for .off() if it is supported by .on(), @cspotcode. :+1: Should probably document this as well...\n. @cspotcode Yep, was just adding some context. I've opened a new issue re docs: #976.\n. Thanks @cspotcode!\n. That's weird. Best place to start is adding debug: true to your queries to see the output.\njs\nMyModel.where({id: 1}).fetch({ debug: true }).then(function(m) {\n  m.set('foo', 'foobar');\n  return m.save(null, { debug: true });\n}).then(function(m) {\n  console.log(m.get('foo')); //foobar\n});\n. Also make sure you're .catching any errors.\n. Ah, cool. Thanks for following up.\n. That's funny. It seems we don't actually have bower support. I don't know where I got that idea from. I wonder what this is for...\n. Oh, right. It's just for docs. Well in that case we should continue to build it out for the page, because it's good to be able to play with it in console. I'll keep it only in the gh-pages branch.\n. That's weird. Which version of bookshelf are you using?\n. Hey @madarche. Thanks, @freesteph just pointed out to me in the Gitter. I released Bookshelf a few days before Knex and didn't even think about it.\nThe reason knex is a devDependency is because it's only used in testing. Users supply their own instance of knex. I think the better choice would be listing it in the peerDependencies, which should show a warning if the version is incorrect.\nI'll try to update fix this in the next couple of days.\n. Good to hear. Thanks.\n. I did this in #950 because babel-cli now has this preferGlobal flag, but I can see that it probably wasn't the best choice now... :cold_sweat:\nActually I'm going to drop the postinstall script entirely and move compilation to prepublish.\nI did some research last night about the right way to do this, so I've got a much clearer idea of how this should be done now. I'll clean it all up and cut 0.9.1 asap.\n. Great, thanks @cspotcode.\n. @konobi You're right, it's not well documented. It could be added as a tutorial.\n. Thanks @tkrotoff! :+1: \n. Thanks for that @tkrotoff. :+1:\n. Hey @tkrotoff I agree, but was I in the middle of an eslint upgrade and code clean up as part of #993. I removed trailing spaces too.\nI appreciate the recent PRs. :)\n. Hey @sjonnet19, I'm going to address this by requiring knex in peerDependencies and removing the version check entirely. See #979.\n. Thanks for the PR nonetheless.\n. This looks like a knex issue (qb is a knex QueryBuilder instance). Please post the issue in the Knex issue tracker.\n. Shall I merge now, @tkrotoff?\n. Copy+paste error I guess. Cheers @cspotcode.\n. Looks great. :+1:\n. Current via the release script only. We'll just release soon I think.\n. This is so great. :heart:\n. There are many mistakes in the documentation. It was all written by myself retroactively and in one big sweep. Clarification is welcome.\n@ricardograca's solution is best:\n\nthe fix would be to swap out lines 143 and 144\n\nJust ensure that an array is always passed to Collection#format/Collection#parse.\n. Great, thanks for that.\n. I'm not sure if this will work, but you could try this:\njs\nvar City = bookshelf.Model.extend({\n    tableName: 'city',\n    idAttribute: 'department', //this is a composite pk (department, province)\n    addresses: function(){\n        var province = this.get('province');\n        return this.hasMany(Address,'city_department').where('city_province', province);\n    }\n}\nI suspect that will fail in some (hopefully not all) cases...\n. I'm not sure if this will work, but you could try this:\njs\nvar City = bookshelf.Model.extend({\n    tableName: 'city',\n    idAttribute: 'department', //this is a composite pk (department, province)\n    addresses: function(){\n        var province = this.get('province');\n        return this.hasMany(Address,'city_department').where('city_province', province);\n    }\n}\nI suspect that will fail in some (hopefully not all) cases...\n. @cspotcode I deliberately held off on documenting this feature. I was thinking that it should be deprecated. I have a few of issues with it:\n- Object iteration is not (by the spec) in definition order. In practise this is not a problem because every interpreter does it properly anyway, but it seems like a bad fit for a QueryBuilder chain which can be order dependant.\n- You can't repeat a key. It's totally normal for knex queries to use where/orWhere multiple times in one query.\n- It's not a significantly more readable shorthand when you have fat arrow functions available.\n- Not all knex methods support a single argument - so some methods cannot be called by a key/value structure.\nThanks for the PR, but I'm going to hold off on merging this until this has been discussed. Thoughts anyone?\n. > This is a great example of a problem so many Javascript APIs have. They try to be super-expressive and flexible by supporting a million different function signatures. However, in the end, they become more ambiguous and error-prone.\nMy thoughts exactly. I would similarly prefer to drop set(attribute, value) in preference for .set({attribute: value}). Again, virtually no sugar, but causes very confusing documentation.\nLet's leave this undocumented. I'm closing this and opening a ticket to deprecate this functionality.\n. > Object iteration order actually is in the ES6 spec, for some reason.\nAlso thanks for that. Good to know.\n. Cheers.\n. > How should I handle deprecating functionality?\n\nDeprecating existing functionality is a normal part of software development and is often required to make forward progress. When you deprecate part of your public API, you should do two things: (1) update your documentation to let users know about the change, (2) issue a new minor release with the deprecation in place. Before you completely remove the functionality in a new major release there should be at least one minor release that contains the deprecation so that users can smoothly transition to the new API.\nhttp://semver.org/\n\nHowever, because we're not yet at version 1 I believe we can treat patch as minor and minor as major. eg. we just need to deprecate in at least one patch release before we release next minor without the feature.\n. > How should I handle deprecating functionality?\n\nDeprecating existing functionality is a normal part of software development and is often required to make forward progress. When you deprecate part of your public API, you should do two things: (1) update your documentation to let users know about the change, (2) issue a new minor release with the deprecation in place. Before you completely remove the functionality in a new major release there should be at least one minor release that contains the deprecation so that users can smoothly transition to the new API.\nhttp://semver.org/\n\nHowever, because we're not yet at version 1 I believe we can treat patch as minor and minor as major. eg. we just need to deprecate in at least one patch release before we release next minor without the feature.\n. > Only show sets.id in the output \nIt should be getting all columns by default. Pass debug: true to options to check the query output.\nIf you wish to change the columns returned, the following undocumented syntax will work:\njs\nworkoutrequest.fetch({\n  withRelated: [\n    { sets: function(query) { query.column('id', 'other', 'column'); } },\n    'sets.exercise'\n]})\n. > Only show sets.id in the output \nIt should be getting all columns by default. Pass debug: true to options to check the query output.\nIf you wish to change the columns returned, the following undocumented syntax will work:\njs\nworkoutrequest.fetch({\n  withRelated: [\n    { sets: function(query) { query.column('id', 'other', 'column'); } },\n    'sets.exercise'\n]})\n. Definitely sounds like a good plan.\n\nThis would also make it possible to use the format bookshelf('table') and not needing to worry about new and forge and constructors vs instances, etc...\n\nSounds like this would be a complete API break. Perhaps this would be more suited as a new project.\n. Definitely sounds like a good plan.\n\nThis would also make it possible to use the format bookshelf('table') and not needing to worry about new and forge and constructors vs instances, etc...\n\nSounds like this would be a complete API break. Perhaps this would be more suited as a new project.\n. See #1018.\nThere is a workaround in the interim.\n. See #1018.\nThere is a workaround in the interim.\n. > Bluebird's reduce implementation, however, only passes the array's length as the fourth argument.\nI think that's because any promises have potential to not have not yet been reduced. From Bluebird Promise.reduce docs:\n\nIf the reducer function returns a promise, then the result of the promise is awaited, before continuing with next iteration. If any promise in the array is rejected or a promise returned by the reducer function is rejected, the result is rejected as well.\n\nA PR would be great, thanks.\n. > Bluebird's reduce implementation, however, only passes the array's length as the fourth argument.\nI think that's because any promises have potential to not have not yet been reduced. From Bluebird Promise.reduce docs:\n\nIf the reducer function returns a promise, then the result of the promise is awaited, before continuing with next iteration. If any promise in the array is rejected or a promise returned by the reducer function is rejected, the result is rejected as well.\n\nA PR would be great, thanks.\n. > Adding an example to the API would be cool :P\nEvidently there is confusion between Knex's QueryBuilder#count and Model#count. I don't think there is any mention of count taking two arguments in the docs, so I'm not sure where that idea came from. However some more examples couldn't hurt.\nThis is how it's intended to be used:\njs\nModel.where({ field: value }).count().then(count =>\n. The instance method has an example.\n. And so does Collection#count.\n. Agreed, but #1013 should solve that issue.\n. Hey guys, firstly I'd like to apologise for the horrid wording on the .through() docs - as I'm reading it even I am confused. Let's leave this issue open to clean up the docs there.\nSo, just to clarify the use of language here:\njs\nThis = Model.extend({\n  targets: function () { this.hasMany(Target).through(Interim, throughForeignKey, otherKey); }\n});\nNow, the throughForeignKey is the column that is used to join Interim to This.\n\nOur tables look exactly like this, essentially:\n\n@agarzola, I'm going to show you the Model definitions one would use with the diagram you've provided.\nBookshelf doesn't support models without a primary key, so actor_film_mapping wouldn't typically attract a Model. You can just use belongsToMany.\n``` js\nbookshelf.model('Actor', Model.extend({\n  tableName: 'actor',\n  idAttribute: 'actor_id',\n  films: function() { return this.belongsToMany('Film', 'actor_film_mapping'); }\n});\nbookshelf.model('Film', Model.extend({\n  tableName: 'film',\n  idAttribute: 'film_id',\n  actors: function() { return this.belongsToMany('Actor', 'actor_film_mapping'); }\n});\n```\nHowever, if you do want to create a join model using through, you should be able to do the following:\n``` js\nbookshelf.model('Casting', Model.extend({\n  idAttribute: ['actor_id', 'film_id'], // Composite keys not actually supported, but you need something I guess...\n  tableName: 'actor_film_mapping',\n  actor: function() { return this.hasOne('Actor'); }\n  film: function() { return this.hasOne('Film'); }\n});\nbookshelf.model('Actor', Model.extend({\n  tableName: 'actor',\n  idAttribute: 'actor_id',\n  casting: function() { return this.hasMany('Casting'); }\n  films: function() { return this.belongsToMany('Film').through('Casting'); }\n});\nbookshelf.model('Film', Model.extend({\n  tableName: 'film',\n  idAttribute: 'film_id',\n  casting: function() { return this.hasMany('Casting'); }\n  films: function() { return this.belongsToMany('Actor').through('Casting'); }\n});\n```\n. > Our users and orgs tables have the typical id identifier, and only in the admins table do we refer to them by user_id and org_id. Is this an antipattern, or is there a way to express that in the models?\nCome on mate, you had a chance to supply your schema and you provided someone else's - why make this harder for everyone?\nNo it's not an anti-pattern - it's the supported use case. Just omit the idAttribute member in all cases as it defaults to id.\n. All good.\n\nIncluding user and org methods on the Admin model doesn\u2019t seem to have any effect on the outcome.\n\nYep, they just add those relations to the Org model if you wish to use it directly.\njs\nAdmin.forge({ id: 5 }).fetch()\n  .then(admin => admin.pivot.related('mailingAddress').fetch());\n\nI don\u2019t quite understand why the difference in the methods (.belongsToMany() vs .hasOne()) in this relationship since neither table make reference to the admins table nor each other.\n\nSo the behaviour here is a bit odd, and I haven't tried every combination - but as far as I know:\nSelf#belongsTo(Other).through(Pivot) and Self#belongsToMany(Other).through(Pivot) each represent a relationship where the Self model has a reference to the Pivot. So in this case we'd expect Self to have an pivot_id. belongsTo will return a single model, whereas belongsToMany should return a Collection.\nhasOne or hasMany are the opposite of this. They declare having a reference to another model. So Self#hasMany(Other).through(Pivot) suggests that there are many pivot rows with a self_id that references selves.id.\n. Might be a bug. Could you share the exact relation definition and unexpected query from the failing relation?\n. @ricardograca - you've been using too much ActiveRecord: Collection#first is a passthrough to Lodash's _.first.\nIf you want to require a single expect you should use .belongsTo().through() as I mentioned earlier.\n\nI don't think you need .through with .belongsToMany...\n\nAdding .through to .belongsToMany changes is the class of the pivot model. Useful for parse/format or other customization.\n. You can checkout any tagged release commit and open /index.html to view the documentation as it was. In the commit link you posted you just need to navigate up to root and open index.html.\nFYI nothing significant changed between 0.8.1 and 0.8.2, so http//bookshelfjs.org should be sufficient for 0.8.1. Generally speaking the biggest change between those versions were documentation improvements.\n. @ihinsdale Yes, but if you look at the changelog you'll see that it almost all applies to 0.8.2.\n. #397.\n. Originally reported over a year ago. Should probably fix this at some stage...\n. Nice spot. Will you provide a PR?\n. Cheers. :)\n. @miguelcobain See #831. Something like this, perhaps:\njs\n// CURRENTLY NOT SUPPORTED\nPerson.forge({\n  name: 'miguel',\n  friends: [{ name: 'rhys' }],\n  skills: [{ skill: 'JavaScript' }, { skill: 'css' }]\n}).save({ withRelated: ['friends', 'skills'] }).then(person =>\nCould take withRelated: true to accept all. There's a few things that need to happen before then though.\n. Sure, the docs could be as simple as @see Model#through.\n. Neat. Beware that ES extension is still not completely the same as using extend. See #756\n. Hey, that's clever.\n. > I propose that Bookshelf's package.json should specify the necessary devDependencies instead of expecting them to exist\nYeah, they're already there. The problem is that the postinstall script that I wrote doesn't install everything.\nI've been advised that the set up is to not do anything in postinstall and move the build logic into the prepublish script. This would require users to manually npm install if they would like to depend on a specific commit.\n. > What's the logic of the Posts model using the messages table?\nA bit strange, but I don't mind it. I often choose a name that makes more sense to your application logic - it may not be the name in the schema.\n\nAnd the model name should be singular, not plural.\n\nDefinitely.\n\nFinally, I think the example shouldn't show the .where method, but use User.forge({id: 1}) instead, so that people don't think that using the .where method is the correct way of querying the database all the time. @rhys-vdw thoughts?\n\nI disagree with this. I think .where(...).fetch(...) and .forge(...).refresh() make sense, but .forge().fetch() is a bad combination. My more specific thoughts here - we can discuss it in that thread if you like. Generally speaking I think that .forge should be avoided in query building chains and reserved for synchronous creation of unpersisted models.\n. @ricardograca You were meant to just look into my profile pic's eyes and read my mind.\ncorrect link.\n. This is related to how Node.js resolves circular dependencies.\nIf you want a property value, you'll have to break the cycle somehow:\njs\n// prop.js\nexports = 'my value';\njs\n// foo.js\nexports = bookshelf.Model.extend({\n  tableName: 'foos'\n}, {\n  prop: require('prop')\n});\njs\n// bar.js\nexports = bookshelf.Model.extend({\n  tableName: 'bars'\n}, {\n  prop: require('prop')\n});\nIf you use a getter instead of a method you could use the registry plugin to achieve this:\njs\nvar Foo = bookshelf.Model.extend({\n  tableName: 'foo',\n  bar: function() {\n    return this.belongsTo('Bar');\n  }\n}, {\n  getSomeProperty: function() {\n    return bookshelf.model('Bar').anotherProperty;\n  }\n});\nmodule.exports = bookshelf.model('Foo', Foo);\n. It's possible that there is a bug here. Can you call count as count('*', { debug: true }) and share the generated SQL?\n. > it failed with a huge error\nYou should specify a column...\njs\nexports.seed = function(knex, Promise) {\n  return Promise.join(\n    knex('polls').insert(COLUMN_NAME_HERE, JSON.stringify(polls))\n  );\n};\n\nRight, didn't know about the ability to specify a jsonb type. That's the problem with functions that accept boolean values as arguments, it's always obscure what the argument is doing.\n\nFixed in master: tgriesser/knex#1044\nThis entire thread pertains to Knex. I'm going to close this as off topic. If there are unresolved questions here please ask in the knex issues.\n. This is a knex question. Please search for or open an issue in the Knex issue tracker.\n. js\n// Attach listener to `Collection` instance.\nUser.collection().on('fetched', callback).fetch().then( // ...\njs\n// Listen for collection fetched event.\nUser.on('fetched:collection', callback).fetchAll().then( // ...\n. js\n// Attach listener to `Collection` instance.\nUser.collection().on('fetched', callback).fetch().then( // ...\njs\n// Listen for collection fetched event.\nUser.on('fetched:collection', callback).fetchAll().then( // ...\n. @kripod Yeah, this is a great idea. I'd like simple test cases for this just to be sure. Also this should be documented as the default way to achieve this, leaving manual parse/format overrides as more \"advanced\" approaches.\n@ricardograca I don't think that the idea of key conversion for records will go away, we'll just have to update/remove the plugin as the feature evolves.\n. Thanks.\n. Thanks.\n. > is there a way to return 10 replies per post?\nOnly by querying once per post. There is actually no (simple) way to do this in SQL as far as I know.\n. > is there a way to return 10 replies per post?\nOnly by querying once per post. There is actually no (simple) way to do this in SQL as far as I know.\n. That's so cool. Let's leave this issue open. To add this feature generally we'd have to be support it knex, and all dialects though.\n. That's so cool. Let's leave this issue open. To add this feature generally we'd have to be support it knex, and all dialects though.\n. Doesn't the Visibility plugin cover this?\n. Doesn't the Visibility plugin cover this?\n. Use the Visibility plugin.\n. Use the Visibility plugin.\n. @Chris-Satchell Yes please.\n. @Chris-Satchell Yes please.\n. > Is there any way to have Bookshelf only submit an insert for the columns that are part of a table\u2019s schema and ignore everything else?\nOnly manually:\n``` js\nimport { pick, isObject, contains } from 'lodash';\nconst { Model } = bookshelf;\nconst parentSet = Model.prototype.set;\nconst WhitelistModel = Model.extend({\n  allowedAttributes: [],\n  set(attribute, value, options) {\n    // Untested\n    if (isObject(attribute)) {\n      return parentSet.call(this, pick(attribute, this.allowedAttributes), options);\n    }\n    if (contains(this.allowedAttributes, attribute)) {\n      return parentSet.call(this, attribute, value, options);\n    }\n    return this;\n  }\n});\nconst Order = WhitelistModel.extend({\n  table: 'orders',\n  allowedAttributes: [/ 'orders' table columns /]\n});\n```\n. > Is there any way to have Bookshelf only submit an insert for the columns that are part of a table\u2019s schema and ignore everything else?\nOnly manually:\n``` js\nimport { pick, isObject, contains } from 'lodash';\nconst { Model } = bookshelf;\nconst parentSet = Model.prototype.set;\nconst WhitelistModel = Model.extend({\n  allowedAttributes: [],\n  set(attribute, value, options) {\n    // Untested\n    if (isObject(attribute)) {\n      return parentSet.call(this, pick(attribute, this.allowedAttributes), options);\n    }\n    if (contains(this.allowedAttributes, attribute)) {\n      return parentSet.call(this, attribute, value, options);\n    }\n    return this;\n  }\n});\nconst Order = WhitelistModel.extend({\n  table: 'orders',\n  allowedAttributes: [/ 'orders' table columns /]\n});\n``\n. Personally I prefer yourcreateOrdermethod though.\n. Personally I prefer yourcreateOrdermethod though.\n. If you're happy to have these other values set in the attributes, but not\npersisted to the database, thenModel#format` is probably a more idiomatic\nplace to do so.\nOn Wed, Jan 27, 2016, 2:26 AM Alfonso notifications@github.com wrote:\n\nClosed #1101 https://github.com/tgriesser/bookshelf/issues/1101.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1101#event-526638143.\n. If you're happy to have these other values set in the attributes, but not\npersisted to the database, then Model#format is probably a more idiomatic\nplace to do so.\n\nOn Wed, Jan 27, 2016, 2:26 AM Alfonso notifications@github.com wrote:\n\nClosed #1101 https://github.com/tgriesser/bookshelf/issues/1101.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1101#event-526638143.\n. I'm not a proponent of using set attributes in a fetch, and would prefer to deprecate this feature, so I'm going to give you what is in my opinion a more sane way to go about achieving the same:\n\njs\ninitialize() {\n  this.on('fetching', (model, columns, options) => {\n    if (!model.get('x')) {\n      options.query.where({y: true});\n    }\n  });\n}\nNo need to set anything on the model since the response will contain the y column.\n. I'm not a proponent of using set attributes in a fetch, and would prefer to deprecate this feature, so I'm going to give you what is in my opinion a more sane way to go about achieving the same:\njs\ninitialize() {\n  this.on('fetching', (model, columns, options) => {\n    if (!model.get('x')) {\n      options.query.where({y: true});\n    }\n  });\n}\nNo need to set anything on the model since the response will contain the y column.\n. Would you be willing to open a PR to fix this? JSDoc comment in\nsrc/sync.js (I think).\nOn Tue, Jan 26, 2016, 10:01 AM Ben Ockmore notifications@github.com wrote:\n\nThanks very much. I didn't see anything about this in the documentation\nfor the fetching event - there, it says that the options parameter will\ncontain the options passed to fetch, which doesn't include the query.\nPerhaps the docs could be updated to indicate what properties are added to\nthe options parameter? (unless I've missed that information somewhere?)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1103#issuecomment-174716829\n.\n. Would you be willing to open a PR to fix this? JSDoc comment in\nsrc/sync.js (I think).\n\nOn Tue, Jan 26, 2016, 10:01 AM Ben Ockmore notifications@github.com wrote:\n\nThanks very much. I didn't see anything about this in the documentation\nfor the fetching event - there, it says that the options parameter will\ncontain the options passed to fetch, which doesn't include the query.\nPerhaps the docs could be updated to indicate what properties are added to\nthe options parameter? (unless I've missed that information somewhere?)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1103#issuecomment-174716829\n.\n. Hey @npatmaja.\nSo, I would to know is the operation (detaching through an interim table) is supported or do I have to delete the records manually?\n\nI'm not sure. I recommend turning debugging on (you should be able to pass debug: true to the options argument of each method you've called). That should help illustrate what's actually going on.\n\nIt will be very nice if this feature is available.\n\nLet's confirm what's actually going on here first. I just had a look at the detach code, and it's pretty straight forward. Perhaps not too hard to modify.\n. Hey @npatmaja.\n\nSo, I would to know is the operation (detaching through an interim table) is supported or do I have to delete the records manually?\n\nI'm not sure. I recommend turning debugging on (you should be able to pass debug: true to the options argument of each method you've called). That should help illustrate what's actually going on.\n\nIt will be very nice if this feature is available.\n\nLet's confirm what's actually going on here first. I just had a look at the detach code, and it's pretty straight forward. Perhaps not too hard to modify.\n. Please share the generated queries output by debug: true here.\n. Please share the generated queries output by debug: true here.\n. There is no support for passing arguments directly to relation functions. However you might be able to achieve the same outcome with the following:\njs\nSavedPosts.fetch({ withRelated: {\n  someRelatedModel: qb => qb.where(some_id: 5)\n}).then(posts =>\n. There is no support for passing arguments directly to relation functions. However you might be able to achieve the same outcome with the following:\njs\nSavedPosts.fetch({ withRelated: {\n  someRelatedModel: qb => qb.where(some_id: 5)\n}).then(posts =>\n. This is a user error:\njs\n    locale() {\n      return this.belongsTo('Locale', 'id');\n    }\nShould be:\njs\n    locale() {\n      return this.belongsTo('Locale', 'localeId');\n    }\nYou're supplying the wrong columns for the join. Hence it's joining locales.id to packs.id. By coincidence these have the same value of 1 in the first model of your example. Make sure to test with debug: true option to get debug output.\n. This is a user error:\njs\n    locale() {\n      return this.belongsTo('Locale', 'id');\n    }\nShould be:\njs\n    locale() {\n      return this.belongsTo('Locale', 'localeId');\n    }\nYou're supplying the wrong columns for the join. Hence it's joining locales.id to packs.id. By coincidence these have the same value of 1 in the first model of your example. Make sure to test with debug: true option to get debug output.\n. @gergelyke Thanks. I think this has been killing our CI recently!\n. @dannymidnight If you'd still like this merged I need a better understanding of the use case. Sorry for the late response.\n. Hey, I added a comment over at bookshelf/bookshelf-jsdoc-theme#3. Sorry for the late response.\n. Hey mate, thanks for this. Merging now. :+1:\n. No probs. Open up a PR bumping to knex support and we'll see if the tests pass in Travis.\n. Sounds good. Cheers!\n. @helios1138 is correct. Currently relations do not know how to perform joins. You'll have to manually add a join in the query callback.\nSomething like this:\njs\nModel\n  .query('join', 'others', 'models.id', 'others.model_id')\n  .where('others.is_active', true)\n  .fetch()\n. The reason here is that the relation query uses the foreign key (other_id for instance) attribute of Some for its where clause. In the case above it isn't there, so it needs to be fetched first.\nYou could theoretically add logic to Relation to do a join instead if the attribute is not present. Instead constraining where by the idAttribute. However, you'd have to write this logic for every relation type.\nIt's a great idea, but also a large undertaking.\n. Okay, sorry, my bad. words is not the right function to be using here! Should be an easy fix if anybody is interested in supplying a PR.\n. There is also a \"where\" function in bookshelf.\nOn Fri, Feb 19, 2016, 6:49 AM Antony Agrios notifications@github.com\nwrote:\n\nHi to everybody.\nI don't know if this has discussed before, but i want to know if this is\npossible.\nI write an angularjs app, and i want to pass some filters as js object on\npost, and make a layer to tranform these filters to a bookshelf query.\nIn sequelize i was before, this was easy because it has a mongodb like\nquery system , and just passing an object its easy to build a query.\nHow can i do something like that on bookshelf?\nFor example. where in sequelize is something like this:\nwhere:{\nsomething: value\n}\nand its easy to build.\nI dont know if im clear enough, if you want to know more please tell me.\nThanks a lot.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1134.\n. Oh, sorry. I was responding via email and the message only included this example (maybe you edited your original?):\n\njs\nwhere:{\n  something: value\n}\nLook at the knex.js docs for info on this, but you can do:\njs\n{\n  where: {\n    somenumber: { $gt: 42 }\n    $or: [\n     { someOthernumber: { $in: [1,2 ] },\n     { name: { $like: 'jan%' }\n   ]\n  }\n}\njs\nModel.query(function(query) {\n  query\n    .where('somenumber', '>' 42)\n    .orWhereIn('someOtherNumber', [1, 2])\n    .or('name', 'like', 'jan%')\n}).fetch().then(models =>\n. > this will fetch the first model in the database which is the user with id: 1.\n\nI think this should throw an error or something as the query hasn't been specified.\n\nI agree with this. This is not a documentation error. refresh should throw a NotFoundError if no record is found, and should accept require: false to override this behaviour. Sorry for the late response here. I'm going to close #1149 and leave this issue open as a bug.\n. You want to use this code:\njs\nmyModel.related('actions').count().then(actionCount => /* ... */ );\n. Your actionCount definition above does not return a relation, therefore it does not have a relatedData property. You need to use the object returned by hasMany, belongsTo etc.\nClarified answer @cmcewen. Please respond here if this solves your problem and I'll close this issue.\n. @cmcewen So what you really want is for the count value to be an \"attribute\" of the model, rather than a relation, right?\nYou might like to try the following approach (or some variant thereof):\njs\nconst Idea = bookshelf.Model.extend({\n  table: 'ideas',\n  initialize() {\n    this.on('fetching fetching:collection', (model, columns, options) => {\n      options.query.select(knex.raw(\n        `(select count(*) from actions where actions.idea_id = ideas.id) as action_count`\n      ));\n    });\n  }\n});\nSee how that goes.\n. > That's still the N+1 queries problem though, correct?\nNo. One query. Look at the generated query with debug: true.\n\nMaybe .fetchAll({ includeRegistrationCount: true }) and use if (options.includeRegistrationsCount) in the event handler?\n\nThat's the idiomatic way to do it, yeah.\n. This behaviour is wrong and should not be documented. See this comment.\n. Sounds good. Have you had a look at how one might go about implementing it?\n. Thanks for the report. I'll accept a PR to correct this.\n. Can anybody confirm that this is fixed as of 0.9.4?\n. This code is very confusing. What exactly are you trying to achieve?\nThere are some bad code smells here, for instance use of setTimeout and promises. Look at Promise.delay. Make sure you're returning promises from your then callbacks. In general it looks here that you have a misunderstanding of how promises work.\nAlso try to avoid sharing state on this. That might be tripping you up. You're assigning this.site etc. Is it possible that you're changing its value between calling the method and stopping?\nAlso why are you delaying the fetching of data? You're deliberately making the database operations slower and less efficient by breaking them up.\n. Could you share a minimal example? Sounds like a bug.\nOn Fri, Mar 11, 2016, 12:07 PM Stefan Kleeschulte notifications@github.com\nwrote:\n\nAccoring to the docs http://bookshelfjs.org/#Model-event-creating, the model.on(\"creating\",\ncb) callback should receive attrs as second argument with \"attributes\nthat will be inserted\". But attrs only contains the timestamp fields (I\nuse hasTimestamps), nothing else. The model (first argument to the\ncallback) contains all attributes (at model.attributes) - even those\nwhich have no corresponding column.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1156.\n. Thanks for the report. A PR would be appreciated.\n. @dpiccone This is related to #1195 #1194.\n. @dpiccone This is related to #1195 #1194.\n. Sorry guys, I expect this was a bug, as detailed in #1194. Just merged the PR. I'll try to push an update soon.\n. Sorry guys, I expect this was a bug, as detailed in #1194. Just merged the PR. I'll try to push an update soon.\n. js\nModel.fetchAll({ debug: true }).then( ...\n\nconsole\n$ node my-app.js DEBUG=knex:query,knex:tx\nSee Knex FAQ section 'How do I debug?'.\n. tap and other promise extensions are not part of the Bookshelf API. You will see these used only in examples after calling a Bookshelf method that returns a promise. Bookshelf currently uses Bluebird for its underlying promise structure. See Bluebird docs for information about Promise#tap.\n. tap allows you to attach a success handler that does not modify the resolved promise value.\njs\nUser.fetchAll()\n  .tap(users => console.log(`loaded ${users.length} users...`)\n  .then(users => doSomethingWithUsers(users));\n. Ha ha ha ha. No problem. Good luck. :+1: \n. The feature you're referring to is usually called 'pagination'. It generally boils down to manipulating the result set with offset and limit. There is a discussion in #435 with a bunch of examples.\n. Sadly not, sorry. You're after something like ActiveRecord's ActiveModel#find_each right?\n. Try \"create\" instead of \"attach\". \"attach\" is for many-to-many relations.\nOn Wed, Mar 23, 2016, 5:24 AM Muhammad Raihan Muhaimin \nnotifications@github.com wrote:\n\nI am trying to save a one to many relation\nMy models are\nFoo\nfoo = bookshelf.Model.extend({\n        tableName: 'foo',\n        bar: function () {\n            return this.hasMany('bar', 'barId');\n        }\nBar\nbar = bookshelf.Model.extend({\n        tableName: 'bar',\n        foo: function () {\n            return this.belongsTo('foo', 'barId');\n        }\nWhat I am trying to do\nvar Foo = { id: 7 }\nnew Bar({ blah: blah.val  })\n                .foo()\n                .attach(foo);\nThe error I am getting\n(intermediate value).foo().attach is not a function\nAny help will be appreciated.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1170\n. Hi @andrerpena, thanks for the issue.\nCan you please explain the difference between the Model.* and model.* and what represents 1 Contact and what represents the Contacts repository?\n\nThe two concepts are conflated in Bookshelf.\n\nThen, to my surprise, the where method was on the model, not on the Model...\n\nActually where is aliased on the constructor too.\njs\n// the following:\nModel.where(condition).fetch()\n// is equivalent to:\nModel.forge().where(condition).fetch()\nBasically any model instance can be used to chain new queries. Allowing you to create such nonsense statements as:\njs\n// user model with name 'John' is created and discarded.\nnew User({ name: 'John' }).where({ name: 'Jane' }).fetchAll().then(janes =>\nI agree that this is a confusing design choice, but that's how it's been since before I started using the project. When using Bookshelf I just stick to using the static aliases for where fetch etc. to keep these concepts separate.\nI've brought this issue up before in discussions for \"bookshelf next\", but I don't believe @tgriesser feels that this is a significant problem. Either way I imagine a change here would break dependant projects in such a way that it would not be viable. It would also require re-architecting a lot of Bookshelf. Currently there are no collaborators working on large scale changes here, so it would be up to somebody from the community to take the project and do the work. I'd be happy to help guide the project, but I would not guarantee any major personal involvement.\n. You'll have to use Knex's whereIn.\njs\nProduct.query(query => query.whereIn('id', [1, 2])).fetch().then(collection => {\n});\n. @monquixote That's correct. Since this question doesn't really explain what's going wrong I'm going to close it.\n. These results are as expected. You have specified a relation on orders.id and customers.id. Looking at the schema of the data returned I'd expect to see something like this:\njs\nvar Customer = Bookshelf.Model.extend({\n  tableName: 'customers',\n  orders: function() {\n    return this.belongsTo('Order', 'customerId');\n  }\n});\njs\nvar Order = Bookshelf.Model.extend({\n  tableName: 'orders',\n  customer: function() {\n    return this.hasOne('Customer', 'customerId');\n  }\n});\nNote that Bookshelf will never auto generate camel-cased keys, so the fact that you weren't supplying 'customerId' at any time is a red herring.\nSee one-to-one explanation.\n. Looks like the default regex pattern for Lodash's words is camel case and underscore sensitive. This is a bug in Events.\n. Closing as duplicate of #1131.\n. There's nothing wrong with the code example in the docs. This seems like a knex schema/migration issue. Please open an issue there.\n. Since this would have limited usage I don't think we'd want to support it in this repository. You'd be better off writing your own plugin based on the virtuals plugin (which is easy enough to do). In that case you'd be able to include whichever version of Lodash you like. (Although it would be nice to update Lodash here.)\n. Responding here instead.\nI think the preferred and more consistent solution is the first:\njs\n// Collection Instance\n{\n  models: [...],\n  pagination: {\n    total: 1623, // total found\n    page: 7, // current page\n    limit: 15, // requested page size\n    offset: 90, // current offset\n    rowCount: 15 // returned row count\n  }\n}\nDo you think we need rowCount? It is already provided by collection.length?\nAlso please add pages or pageCount for the total number of pages.\nAlso, maybe I'm bike-shedding, but I feel like pageSize would be clearer than limit - describing in terms of 'pages' rather than individual rows. Thoughts?\n. Agreed. I would prefer to go with page and pageSize, as they are usually the values used when rendering pagination front end. We'd need to keep total though as that is not something that can be calculated from page and pageSize (if there is a half page).\n. @anyong I think the first of the two is best, which you have appeared to have gone ahead and implemented. This is looking really great. Do you think it's done?\n. (sorry I realize now I misread your post, I'll get back to you soon)\n. Hey @anyong, sorry for the neglect. This is looking great and I'm going to merge it in. Just going to play around to see how to get the plugin docs to play nicely with the website.\n. Hm, I don't have time to get the JSDoc to render nicely, so I'm just going to merge and release for now.\n. @anyong Cool, I've merged this manually so I could rebase and fix indentation.\n. @anyong I just released too. 0.9.5\n. extend is a method on Model and Collection. Not on Bookshelf or\nbookshelf. If you think there is a problem with the docs you could at\nleast link the problematic section...\nOn Sun, Apr 3, 2016, 8:01 AM Rishabh Singhal notifications@github.com\nwrote:\n\nHi,\nI was reading docs and it gave me wrong impression that method \"extend\" is\na instance method. This happened because \"bookshelf\" which is a instance\nwas used. For the sake of clarity, I believe that we should use \"Bookshelf\"\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1187\n. @davebaol Done.\n. Woohoo.\n. Thanks @quackware \n. Duplicate of #1044. This should have been fixed in release 0.9.4 with moving from 'babel-polyfill' to 'babel-runtime' (see PR #1148). Can you confirm which version of Bookshelf you're using please?\n. Yeah, it seems that core-js is still a dependency of babel-runtime. I'd like to resolve this, obviously, but the project wont work without it. I don't have time to look into it further for now, unfortunately.\n. FYI core-js is a shim to modernise JS, so I guess it's augmenting some globals. Without babel-runtime some functionality will fail.\n. @thomasdelobel Good catch. Could you provide a PR?\n. @thomasdelobel that code could probably be rewritten pretty trivially without using drop or rest and using normal named arguments instead.\n. eg:\n\njs\nmorphTo(morphName, ...candidates) {\n  candidates = _.flatten(candidates);\n // ...\n}\n. Oops, I misread the code. You're right.\n. Oops, I misread the code. You're right.\n. Thanks @thomasdelobel, great catch.\n. Thanks @thomasdelobel, great catch.\n. What is the bug?\n. What is the bug?\n. What queries are generated? Are they as expected? Please run your program like so:\nbash\n$ node ./my-script.js DEBUG=knex:query,knex:tx\n. What queries are generated? Are they as expected? Please run your program like so:\nbash\n$ node ./my-script.js DEBUG=knex:query,knex:tx\n. Try checking the models returned from Promise.all, what do they look like?\n. Try checking the models returned from Promise.all, what do they look like?\n. And is that what's in your database?\n. And is that what's in your database?\n. Well I guess it's a bug. Thanks for the report. If you find more information please report here.\n. Well I guess it's a bug. Thanks for the report. If you find more information please report here.\n. Why use buffers? Why not just insert normal strings?\n. Why use buffers? Why not just insert normal strings?\n. Right. Well that behaviour would be part of Knex, not Bookshelf specifically.\n\nusing _.groupBy on uuid as a key\n\nSounds like it could be the issue. I'd accept a PR to support this if it's tested thoroughly, but otherwise you might be able to work around it like so:\n``` js\n  var SubSite = bookshelf.Model.extend({\n    idAttribute: 'uuid',\n    tableName: 'binary_uuid_test',\ninitialize: function() {\n  this.on('saving', this._generateId);\n},\n\nformat: function(attributes) {\n  attributes.uuid = buildBuffer(attributes.uuid);\n  return attributes;\n},\n\nparse: function(attributes) {\n  attributes.uuid = attribute.uuid.toString('hex');\n  return attributes;\n},\n\n_generateId: function (model, attrs, options) {\n  if (model.isNew()) {\n    model.set(model.idAttribute, buildBuffer(uuids.pop()));\n  }\n}\n\n});\n```\nThis way the uuid will always be a string in the model, but converted appropriately before being sent to the database.\n. Right. Well that behaviour would be part of Knex, not Bookshelf specifically.\n\nusing _.groupBy on uuid as a key\n\nSounds like it could be the issue. I'd accept a PR to support this if it's tested thoroughly, but otherwise you might be able to work around it like so:\n``` js\n  var SubSite = bookshelf.Model.extend({\n    idAttribute: 'uuid',\n    tableName: 'binary_uuid_test',\ninitialize: function() {\n  this.on('saving', this._generateId);\n},\n\nformat: function(attributes) {\n  attributes.uuid = buildBuffer(attributes.uuid);\n  return attributes;\n},\n\nparse: function(attributes) {\n  attributes.uuid = attribute.uuid.toString('hex');\n  return attributes;\n},\n\n_generateId: function (model, attrs, options) {\n  if (model.isNew()) {\n    model.set(model.idAttribute, buildBuffer(uuids.pop()));\n  }\n}\n\n});\n```\nThis way the uuid will always be a string in the model, but converted appropriately before being sent to the database.\n. > format is called after object is initialized from DB -> Model Object and parse is called when object is saved to DB. right?\nOther way around.\nparse: columns -> attributes\nformat: attributes -> columns\n. > format is called after object is initialized from DB -> Model Object and parse is called when object is saved to DB. right?\nOther way around.\nparse: columns -> attributes\nformat: attributes -> columns\n. > I'd like to have it fetch the items for a certain time range, and keep extending the time range if there aren't at least a certain number of items returned.\nIsn't the same as saying created_at > [starting_date], limit [count]? You shouldn't need to do two fetches.\n\nTo that end, I've overridden the board's fetch method so it looks something like this...\n\nIt looks like it should work. Did turn on query tracing to see the generated queries? How are you invoking fetch? Is the filter callback being invoked?\n. > I'd like to have it fetch the items for a certain time range, and keep extending the time range if there aren't at least a certain number of items returned.\nIsn't the same as saying created_at > [starting_date], limit [count]? You shouldn't need to do two fetches.\n\nTo that end, I've overridden the board's fetch method so it looks something like this...\n\nIt looks like it should work. Did turn on query tracing to see the generated queries? How are you invoking fetch? Is the filter callback being invoked?\n. Ah, just merged #1208 which is the same fix. Thanks @shesek!\n. Hey guys, the problem here is that bookshelf uses the retrieved key column on the related models to associate them with their parent models.\nIn @zombler's case, this means you need to add a select('story_id') in the query callback to ensure it's included.\n. Bookshelf should warn or error when relations are missing the required columns. I believe this is a duplicate but the other instances can be tracked down later.\n. @c990802 Wow, that's weird.\n\nDo you have any clues what's happening here?\n\nSounds like a race condition.\n\nTested on 0.8.2 & 0.9.4\n\nFailed on both, I take it?\nCan you try turning on query logging (pass debug: true to options) and also log when the timeout runs to see if they're going out of order?\n. @c990802 Wow, that's weird.\n\nDo you have any clues what's happening here?\n\nSounds like a race condition.\n\nTested on 0.8.2 & 0.9.4\n\nFailed on both, I take it?\nCan you try turning on query logging (pass debug: true to options) and also log when the timeout runs to see if they're going out of order?\n. Thanks @vellotis!\n. Thanks @alanhoff!\n. This might suffice.\n``` js\n// To assign.\nmodel.related('relatedModel').set(otherModel.attributes);\n// To persist.\nmodel.related('relatedModel').save(otherModel.attributes).then(model => // ...\n```\n. @mgmcdermott Problems with parse/format are known. I'm happy to mark this is a bug and will accept a PR making changes.\nIt's not an easy fix though, I've tried tackling it before.\n. > But I have to say it is bad idea to carry transaction over many HTTP requests.\n@vellotis The example shows a single request.\n\nTransaction is working only in callback function. How i can do it?\n\n@Claud The example you've shown looks correct. Just make sure to have an error handler which calls rollback().\n. Thanks @teebot.\n. Then you should update bookshelf.\nOn Sun, May 15, 2016, 8:45 PM Ren\u0101rs Vilnis notifications@github.com\nwrote:\n\nJust noticed the same issue.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1218#issuecomment-219278069\n. Yeah, they're bad. Perhaps one of you guys would like to make some updates to polymorphic.md?\n. @vellotis Sorry I didn't get to this earlier. I actually had written a plugin that does this, but it's just in a comment!\n\nhttps://github.com/tgriesser/bookshelf/issues/877#issuecomment-132409019\n. I'm not sure if it's a good idea to combine these two separate concepts.\n. Hm. This is such a weird pattern. But your fix is consistent with the current design. Thanks for the helpful comment.\n. @nixgadget just make sure there's a unique constraint on the UUID, as you have. If the database throws you can handle it, but it's so unlikely that I wouldn't bother writing a handler for it.\nIf you really need to do it, you can build a loop in addIdIfNeeded that keeps generating IDs until it finds one that doesn't already exist.\n. @niallobrien yes.\n. @justincy This looks fine, the tests pass. Upgrading lodash to version 4.0 is a separate issue.\nAm I missing something?\n. @justincy how did it break your code? Lodash is not exposed by bookshelf, and npm can handle different versions of the same library.\n. One of the tests timed out, just re-running it.\n. Thanks @tkrotoff.\n. Thanks @tkrotoff. Docs are still a bit messy because I migrated the entire thing from HTML to JSDoc, and there were a lot of things missing. I imagine there are still plenty more errors around, but I really appreciate this proof read. \ud83d\udc4d \n. @kevinob11 Nice catch. I just realized that this event is not documented!\nWould you be interested in adding documentation here? You just need to add a JSdoc comment, like this one.\n. Yep. Use Model#query.\n```js\nvar question = bookshelf.model('Question')\nquestion.query(function (queryBuilder) {\n  // mutate query builder in place\n}\nvar queryBuilder = question.query()\n// get reference to underlying QueryBuilder instance\n```. > I know it's a terrible thing to do, but I think we should close questions either immediately or after 3 days at most if there's no answer\n@ricardograca I disagree with this. I've always seen questions as \"documentation bugs\". Bookshelf documentation is incomplete. The way I used to approach things was to answer the question if I could, and then open or request a PR adding the answer in the docs. If I couldn't answer it I'd leave a note saying I don't know - if the answer comes up then it can be added to docs and closed. These questions are key insights into possible omissions in Bookshelf's feature set or documentation.. Oh, but - I don't have time to contribute so feel free to disregard my opinion.. Ha, yeah. I'm just programming by permutation here and left a line in. The test work locally but fail on the server due to a different version of PG. I think I've got it this time. ;-)\n. Promise.each is performed in serial. This will slow queries down significantly. Promise.map is probably what you want here.\n. This adapter layer is for back compat right?\nI think we should just do a breaking change and update all of these to use the newest names.\nSee here they all just ref the lodash docs (which will now be incorrect). I'd prefer we just updated the names in this methods array, and updated the docs here.\n. Yeah, tbh I think we should drop the lodash methods entirely. But that's probably even more annoying.\nWould you be able to note any changed methods in the changelog please?\nedit: to be clear I mean users would find dropping lodash methods more annoying than updating them each time Lodash changes its API.\n. Nah. I'm just going to bump minor version. There's nobody actively working on Bookshelf. I'm just facilitating PR's these days.\n. That's okay, minor and patch are treated differently in semver when the major version is 0. A minor version can contain a breaking change.\n. Up to you, I'm happy to just accept the minimal change set.\n. ",
    "willy134": "So this does work with collections.  With models the fetch command is always limited to the first() function.\nCollections work for me.\nThanks\n. ",
    "projectfledge": "Thank you! The issue was the Bookshelf.Model.Extend whereas it should have been Collection.\nI was looking at the collections section of the documentation and saw the accounts example under forge http://bookshelfjs.org/#Collection-forge var Accounts = Bookshelf.Model.extend({\nCheers\n. ",
    "chymz": "Thank you for this patch ! Works nicely !\n. ",
    "teckays": "More than 2 years and it still does't work!!!!. More than 2 years and it still does't work!!!!. any updates on this????\n. any updates on this????\n. From the code:\n// Thrown when the collection is empty and {require: true} is passed in model.fetchAll or\n  // collection.fetch\n  EmptyError: (0, _createError2.default)('EmptyError'),\nthis error is thrown on both model.fetchAll and collection.fetch but the error is only made available inside a collection instance.\n. The only solution I've found for now is to:\n```\nconst Model = bookshelf.Model.extend({\n ... \n}, {\n    findAll: function() {\n        return this\n             .where({clause})\n             .fetchAll({require: true})\n             .then((entries) => entries.toJSON())\n             .catch(this.EmptyError, (err) => Promise.reject())\n    },\nEmptyError: bookshelf.Collection.EmptyError // Add this line\n\n})\n```\nin order to have the Collection.EmptyError instance inside Model instance. Not sure if this is the way to go though!\n. ",
    "johanneslumpe": "@teckays instead of being hostile, how about pulling yourself together and creating a fix for it?. @teckays instead of being hostile, how about pulling yourself together and creating a fix for it?. I quickly want to chime in on this. I'm also using UUIDs, but it seems that it is not necessary to overwrite the isNew() function to achieve the desired behavior. By hooking into the saving event on the model we can generate an id after the insert/update method has been determined, like so:\n```\ninitialize: function(params) {\n    this.on('saving', this._generateId);\n},\n_generateId: function (model, attrs, options) {\n    if (model.isNew()) {\n      model.set(model.idAttribute, uuid.v4());\n    }\n}\n```\nThis way there is no override involved and to me this does not feel messy or hackish. @tgriesser would you agree?\n. @tgriesser Why are we even using datetime and not timestamp ? Wouldn't the whole issue just vaporize, if we used a timestamp type for those fields? (which then could just receive the value from either new Date().getTime() or Date.now())\nReading the date back would of course use the timezone of the server, but would yield the correct time, in contrast to saving a string into a datetime field, which has been converted to UTC earlier. Like this:\nvar d = new Date(1389166613497) // just passing in the timestamp for a consistent example\nvar dTS = d.getTime() // => 1389166613497\nvar dString = d.toJSON() // => \"2014-01-08T07:36:53.497Z\"\nIf we were able to save dString into the database everything would be fine, since recreating a date from it would yield the correct result, like this:\n// the date will be correctly converted to the local timezone\nvar dateLater = new Date(dString);\nBut since we only have a string representation like 2014-01-08 07:36:53, recreating the date from the database will result in this:\n// will specify the date in the local timezone, even though it's UTC\nvar dateFromDB = new Date(\"2014-01-08 07:36:53\");\ndateFromDB.toJSON() // => \"2014-01-08T05:36:53.000Z\" - oops\nApart from hitting a bug in 2038 - is there anything that makes this not feasible?\n. @tgriesser Why are we even using datetime and not timestamp ? Wouldn't the whole issue just vaporize, if we used a timestamp type for those fields? (which then could just receive the value from either new Date().getTime() or Date.now())\nReading the date back would of course use the timezone of the server, but would yield the correct time, in contrast to saving a string into a datetime field, which has been converted to UTC earlier. Like this:\nvar d = new Date(1389166613497) // just passing in the timestamp for a consistent example\nvar dTS = d.getTime() // => 1389166613497\nvar dString = d.toJSON() // => \"2014-01-08T07:36:53.497Z\"\nIf we were able to save dString into the database everything would be fine, since recreating a date from it would yield the correct result, like this:\n// the date will be correctly converted to the local timezone\nvar dateLater = new Date(dString);\nBut since we only have a string representation like 2014-01-08 07:36:53, recreating the date from the database will result in this:\n// will specify the date in the local timezone, even though it's UTC\nvar dateFromDB = new Date(\"2014-01-08 07:36:53\");\ndateFromDB.toJSON() // => \"2014-01-08T05:36:53.000Z\" - oops\nApart from hitting a bug in 2038 - is there anything that makes this not feasible?\n. gotta bump this one again @tgriesser ;) Any opinion about this? Or any progress which hasn't surfaced yet?\n. gotta bump this one again @tgriesser ;) Any opinion about this? Or any progress which hasn't surfaced yet?\n. @tgriesser Seems to be fine now, thanks! Had to adjust my test, since now Bookshelf will always return 0 as the new id, if no id has been set and no auto-increment took place. I was expecting the id to be undefined in my case, since 0 indicated no increment took place, meaning no new id is present. But it's fine like this, too!\n. @tgriesser Seems to be fine now, thanks! Had to adjust my test, since now Bookshelf will always return 0 as the new id, if no id has been set and no auto-increment took place. I was expecting the id to be undefined in my case, since 0 indicated no increment took place, meaning no new id is present. But it's fine like this, too!\n. To me it looks like you got it backwards. It is correct that hasOne expects the key to be on the destination table. If you specify a hasOne relation, then the destination table of the specified relation should have a key column, which references the id of the model \"owning\" the hasOne relation, i.e. the model, which the hasOne relation belongsTo.\nA model, which belongsTo another model, will use the foreign key column in its own table to look up the related model in the related model's table.\nLogically a transaction does not have accounts. It belongsTo accounts - and that is what you actually modelled in your table. The transaction contains foreign keys for two accounts. So it belongsTo those accounts.\nSwapping out hasOne with belongsToshould not give you the same result, but actually the proper result. If you then fetch the toAccount relation, it should execute a query like the following:\nSELECT * FROM accounts WHERE id = transactions.to_account_id\nwhich then should yield you the proper toAccount for the transaction.\n. To me it looks like you got it backwards. It is correct that hasOne expects the key to be on the destination table. If you specify a hasOne relation, then the destination table of the specified relation should have a key column, which references the id of the model \"owning\" the hasOne relation, i.e. the model, which the hasOne relation belongsTo.\nA model, which belongsTo another model, will use the foreign key column in its own table to look up the related model in the related model's table.\nLogically a transaction does not have accounts. It belongsTo accounts - and that is what you actually modelled in your table. The transaction contains foreign keys for two accounts. So it belongsTo those accounts.\nSwapping out hasOne with belongsToshould not give you the same result, but actually the proper result. If you then fetch the toAccount relation, it should execute a query like the following:\nSELECT * FROM accounts WHERE id = transactions.to_account_id\nwhich then should yield you the proper toAccount for the transaction.\n. You can insert data into the joining table, by passing a custom object as first argument to the attach method of your relation. You will have to add your foreign key to it as well.\nBut since you only have two fields in your joining table and no additional info, you can just pass the model you wish to attach to your relation as first argument.\nSomething like this:\n``\n/* I assume a variableroleModel` exists and contains a valid RoleModel */\nPartyModel.forge(attributes).save().then(function (party) {\n    party.roles().attach(roleModel).then(function (relation) {\n      console.log('role attached');\n    });\n});\n```\nThe above code would save a new PartyModel and then attach an existing RoleModel to it, by inserting an entry into your joining table. Have you set up a relation inside your models (like the roles function in my example)?\nAs for updating a joining table, which contains additional information: @tgriesser do we need a through-model for that?\n. You can insert data into the joining table, by passing a custom object as first argument to the attach method of your relation. You will have to add your foreign key to it as well.\nBut since you only have two fields in your joining table and no additional info, you can just pass the model you wish to attach to your relation as first argument.\nSomething like this:\n``\n/* I assume a variableroleModel` exists and contains a valid RoleModel */\nPartyModel.forge(attributes).save().then(function (party) {\n    party.roles().attach(roleModel).then(function (relation) {\n      console.log('role attached');\n    });\n});\n```\nThe above code would save a new PartyModel and then attach an existing RoleModel to it, by inserting an entry into your joining table. Have you set up a relation inside your models (like the roles function in my example)?\nAs for updating a joining table, which contains additional information: @tgriesser do we need a through-model for that?\n. Why are you using the RoleCollection in your belongsToMany relation?\nThe first argument is - as far as I know - supposed to be a model, so your relation would more likely be like this:\nrole: function () {\n    return this.belongsToMany(RoleModel, 'party_role', 'party_id', 'role_id');\n}\nAnd the same for your RoleModel just using your PartyModel as target and switching the ids.\nAlso, are the models you are trying to attach already present in the database? Or are you just creating them using Model.forge() and then try to attach them directly?\n// man replying via email doesn't really work well with code snippets\n. @adriano-di-giovanni sorry for the misleading information, didn't know that we can use collections aswell. Is the insert working now?\n. @adriano-di-giovanni it's in there :)\nAn alias to Knex.transaction, the transaction object must be passed along in the options of any relevant Bookshelf.Sync calls, to ensure all queries are on the same connection. \n. Ok that sounds good! Right now I think having some kind of updatemethod might be nicer, instead of having to create another model for that. Basically the update method could do the same thing my knex example does, but just wrap it in a shorthand method. Maybe something like:\nmyModel.someRelation().update({\n    someColumn: 'some value',\n    anotherColumn: 1\n}, 456).then...\nThe first argument could be the updates to make, the 2nd one the foreign key for the related model. The \"origin\" key could be fetched from myModel.id. As for timestamps, maybe we can have a method or a property on the relation, aswell for that? Like the timestamps on the model?\n. @tgriesser what about an \"updatePivot\" method to directly target the pivot table and to make one's intention more clear? (Since the update method on a relation could also mean that one wants to update a row in the target table in case of a hasOne or hasMany relation)\n. @tgriesser Check out https://github.com/johanneslumpe/bookshelf/commit/6ac23ece3e6993eeb87cf4b68e5e17fea35cd7c0\nif you have time and tell me if that is along the line of what you'd do for updating a record in a pivot table. This seems to work and updates the rows properly for a belongsToMany relation. If you think it's fine then I'll add  tests and send a pull request!\n. Interesting, initially I wanted to create a pivotmethod, similar to the one available in Eloquent. This one would have simply returned a new Knex instance for the join table.\nI think updatePivot might sound better, but I can also go with updateJoin. I will change the signature of the method and then add some tests this week and PR.\nIn regard to only updating a single row: I actually use this to update all rows in the pivot table, matching a whereIn condition. Maybe we could allow users to pass in an object containing conditions, for a more fine-grained control over the query. But for that to be complete the update method would have to check for keys for all where* methods. At first the most basic ones like whereIn, whereNotIn, where might be enough?\nAnother thing: I noticed that the promise always resolves with the relation object. I suppose you bound it to the relation? I'm not sure, but can it be rebound? For the update method returning the number of updated rows might be nicer, or even better the relation and the number of updated rows.\n. @tgriesser see #153 & #154\nIf the PRs are fine with you, I can also write up docs for the method.\nUpdate\nScratch #153 & #154 - use #156 \n. @tgriesser Any estimate on when a new Bookshelf version will hit npm? (so that there is no need to manually pull from git)\n. You could do it like this:\nSomeModel.forge({id: 2}).fetch({\n    withRelated:['someRelation']\n}).then(function (item) {\n  return item.related('someRelation').invokeThen('destroy').then(function () {\n    return item.destroy().then(function () {\n      console.log('destroyed!');\n    });\n  });\n});\nYou should wrap that in a transaction though. This will issue a DELETE query for each item in the collection. For performance it might be better to use a knex query, which bulk deletes all relations from the related table and to then reset the collection on the model.\nUpdate:\nUsing knex it could look like this:\n```\nSomeModel.forge({id: 123})\n.fetch()\n.then(function (item) {\n  var relation = item.someRelation();\n  var tableName = relation.relatedData.targetTableName;\n  var foreignKey = relation.relatedData.key('foreignKey');\nreturn Bookshelf.DB.knex(tableName)\n  .where(foreignKey, item.id)\n  .del()\n  .then(function (numRows) {\n    console.log(numRows + ' rows have been deleted');\n  }).catch(function (err) {\n    console.log(err);\n  });\n});\n```\nThe above example is for a hasMany or hasOne relation, but you get the idea :)\nUsing the first method you should get the appropriate destroying and destroyed events for each model, the second method would be kind of a \"silent\" delete.\n. Yeah that's what i meant. On your Bookshelf instance a reference to knex is stored. So you could use it to perform this kind of bulk-delete. You would still be using a model, as in my example, so you could retrieve tablenames and keynames easily.\nI think it would be nice to have a del method on a relation though, which would perform this kind of bulk delete. Maybe I'll have time to wrap something up. \n. @adriano-di-giovanni I just checked something and you can get the same result by doing the following:\n```\nvar relation = item.someRelation();\nvar tableName = relation.relatedData.targetTableName;\nvar foreignKey = relation.relatedData.key('foreignKey');\nreturn relation.sync().query.where(foreignKey, item.id).del().then(function (numRows) {\n  console.log(numRows + ' rows have been deleted');\n}).catch(function (err) {\n  console.log(err);\n});\n```\nThat way you do not have to reference the knex object on your DB instance directly, but can just work with the relation! The above code is meant to be wrapped inside a then function after a fetch of a single model.\n. @tgriesser It would be able to automatically decide whether to delete child-objects (those who cannot exist without a parent, like children of a hasOne or hasMany relationship) or to just delete the entry from the relation table, based on the type of the relation, right?\n. The easiest way would be, to just update your relation names to be snake cased, since their names are directly taken from their function names. Everytime you call the related method on your model, it will try to call a method with the same name as the relation your specified. So if you call related('someRelation') it will try to call the method someRelation on your model and then save the result into a relations object on the model, using the key you passed to the related method. So it actually uses the passed in key, but that maps one to one to a function on your model. \nWhen you then serialize the model, the default  toJSON function will iterate over the keys in the relations object and use those keys as keys for the resulting JSON object.\nSo if you want to keep camelCased function names but have snake_cased keys for your JSON output you could either overwrite the related method on the model, to store the results with a snake_cased key, or you could overwrite the toJSON method to convert the keys there.\nAnother option could be to create a map for those relation names on your model and then check that map while serializing the model. That way you could even give arbitrary names to your relations in your JSON and it might be faster to look up the names in a map, instead of converting them always on the fly. But here you would also have to overwrite toJSON to include the key-check.\n. Looks fine to me and if it works for you then it's fine :)\n. @tgriesser does that mean that Bookshelf will lose some love? Or will it receive the same amount of attention like your active record addon? Would be sad to see the project stagnating.\n. Your can do the following:\n```\nvar Bookshelf  = require('bookshelf');\nBookshelf.DB = Bookshelf.initialize({\n  client: 'mysql',\n  connection: {\n    host     : '127.0.0.1',\n    user     : 'root',\n    password : 'yourpass',\n    database : 'yourdb',\n    charset  : 'utf8'\n  }\n});\nBookshelf.DB.knex.client.getConnection().then(function (connection) {\n  console.log('Yay, we have a connection!');\n}).catch(function (err) {\n  console.log('Ooops, something went wrong!');\n});\n```\ngetConnection() will return a promise, which will be fulfilled when a connection is made, or rejected in case of an error, providing your either with the connection or the error object.\n. I think everybody working with an ORM like Bookshelf is automatically creating something like this. I use a mechanism very similar to Ghost's - basically I just have a different field name for the allowed attributes.\nIt might save a few minutes of preparation for your base model but then we need a switch to be able to disable the feature is somebody doesn't want to use it. And if one does not need it it will always incur the overhead of checking the option if the feature is enabled or not.\nI feel that because it is just a small sugar coating, it might be better left to each project to handle the specific (even though often very similar) implementation, if needed.\n. I agree with @bendrucker on this. Even for the most basic validation of permitted/allowed attributes you can have different ways. For example just removing all non-allowed keys or throwing an error and thus triggering a hard abort of the action. And if Bookshelf implements solution A, then there will be people who want solution B to be the default.\n. Have you tried to attach your speaker models to the talk model after saving it?\nTalk.forge({}).save().then(function (talk) {\n  talk.speakers().attach(users).then(function () {\n    console.log('saved');\n  });\n});\n. You can overwrite the model's 'toJSON' method to exclude the pivot fields. There you can also loop through the talks array and reduce it to a list of ids!\n. Not sure if you will attach additional data to your edges table and because of that want to use a join model, but changing the relations from hasMany through to belongsToMany and specifying the edges table as pivot table does the trick:\nparents: function () {\n  return this.belongsToMany(Vertex, 'edges', 'targetId', 'sourceId');\n},\nchildren: function () {\n  return this.belongsToMany(Vertex, 'edges', 'sourceId', 'targetId');\n},\n. Sorry - not at home and not much time. You are not saving the 'Edge' model but you are only attaching it to another collection. The model isn't being saved at all - thus no 'saving' event ;) You might want to check for events of the collection. Maybe that helps?\n. @Tape is a changing schema your only concern about  direct-from-db serialization? If so, that should be easily be counterable using a custom toJSON method, no?\nBut I have to agree with the fact that it's just very comfortable to just specify attributes which shouldn't be sent to the user (I also do that).\n@bendrucker where would you create the properties, that should be ignored? From what I see those should be defined on the attributes hash of the model. I was playing around with this for fun. It works, but it leads to problems when one wants to save the model to the database, because - well - the properties are not enumerable anymore. This would probably require to make them enumerable before calling save or update, and resetting them afterwards. Or do you have a better way for this? (Just for the sake of discussion/theory)\n. This adds the requested feature of #159. Virtuals properties are read-only for now.\n@tgriesser I wanted to add the functionality to get a virtual value using get('virtualProp') but unfortunately that killed some of your tests, since you test for the use of the original Backbone get method. So right now virtuals will be included in the result of toJSON, if specified, but can only be accessed using model.virtualProp which might make it hard to use because you have to remember which properties are virtual and which aren't and then use the appropriate syntax to get the value. So I would propose to add an intermediate get method, which will first check for any virtual getter and if it doesn't find anything, then calls the original Backbone get method.\nWhat do you think?\n. This also doesn't support nested virtuals - is there any need for it?\n. @tgriesser Yeah I can add it as a plugin. Not sure where tests + docs would go though? outputVirtuals sounds nicer!\n. @tgriesser Yeah I can add it as a plugin. Not sure where tests + docs would go though? outputVirtuals sounds nicer!\n. @nathggns when the plugin is merged you would be able to create virtuals like this:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  outputVirtuals: true,\n  virtuals: {\n    fullName: function() {\n      return this.get('firstName') + ' ' + this.get('lastName');\n    }\n  },\n});\nAnd you could access them like this:\nmodel.fullName;\nmodel.get('fullName');\n. @nathggns when the plugin is merged you would be able to create virtuals like this:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  outputVirtuals: true,\n  virtuals: {\n    fullName: function() {\n      return this.get('firstName') + ' ' + this.get('lastName');\n    }\n  },\n});\nAnd you could access them like this:\nmodel.fullName;\nmodel.get('fullName');\n. bump, anyone? ;)\n. That's the point - the hasOnewith through does unfortunately not work. Any help here is greatly appreciated. On a side node, since you mentioned joins: joining multiple tables as a condition for fetching a single model (restricting the result through an existing relation), the id column of the model being fetched is not being prefixed with the table name in th select or where part of the query and will then result in column id is ambiguous - ever had that issue?\n. Oh let me try that!\n. Yep, that works! Thanks for the idea. Now the other issue then is the prefixing of the ids, but I will open another issue for that.\n. @tgriesser can you mark this one as a bug? Even though using belongsToMany with fetchOne works in some situations, it specifically doesn't work when eager-loading relations. Apart from that, there is the bug with trying to add something to a collection, when there is none ;)\n. @tgriesser can you mark this one as a bug? Even though using belongsToMany with fetchOne works in some situations, it specifically doesn't work when eager-loading relations. Apart from that, there is the bug with trying to add something to a collection, when there is none ;)\n. Tests are missing for now, because I'm unsure how to add them. If I can get some help on that I will migrate the tests from the other PR into this one.\n. Tests are missing for now, because I'm unsure how to add them. If I can get some help on that I will migrate the tests from the other PR into this one.\n. You need to add an error handler using .catch.\n. You need to add an error handler using .catch.\n. Fixes #168 \n. Fixes #168 \n. I aggree with @tgriesser. This is most likely the easiest way to fix that issue.\n@nathggns If you call toJSON first and then omit the values you're good.\n. Ok @tgriesser you're fixing it? Else I'd add a custom omit method. (and most likely other methods as well)\n. Got it fixed, including the other underscore methods\n. Man, sorry for the mess...\n. Man, sorry for the mess...\n. Fixes #170 \n. Feel free to submit yours.\n. Looks good to me. You should grab the tests I added and add them to your PR. Then I think your version should be merged, not mine. Already too late here - I should stop for today ;)\n. @tgriesser can you merge in the tests from my pr? Just so they're in.\n. Ah forget it, didn't see that @nathggns already added them - all good!\n. @nathggns perfect!\n. Actually from what I see in the source, the config is set to have a maximum of 10 connections in the pool. But you should be able to actually pass a pool config when initializing Bookshelf. Something along those lines:\nBookshelf.DB = Bookshelf.initialize({\n  client: 'mysql',\n  connection: {\n    host     : '127.0.0.1',\n    user     : 'root',\n    password : '',\n    database : 'somedb',\n    charset  : 'utf8'\n  },\n  pool : {\n    min: 2,\n    max: 5\n  }\n});\nThis is untested, but from looking at the source this should work, as Bookshelf passes  the config down to Knex and it again passes the config down to the client, omitting the client property. The client then passes an object to the pool constructor which has been extended with the client's pool defaults and config.pool.\n. @nathggns Has this been solved?\n. @nathggns Has this been solved?\n. Ah ok. Yeah that's not happening for the where part of the query at all. Is bookshelf or knex doing the prefixing? I assume knex? Maybe I still have an old version - if you cannot reproduce it.\n. Ah ok. Yeah that's not happening for the where part of the query at all. Is bookshelf or knex doing the prefixing? I assume knex? Maybe I still have an old version - if you cannot reproduce it.\n. Don't merge this yet - fix is incomplete.\n. Don't merge this yet - fix is incomplete.\n. Ok, should be good to go now.\n. Ok, should be good to go now.\n. Ha actually you're right! I added it in because in my use case I was specifying columns from the same table, without prefixing them manually. But your point make excellent sense. I assume this was just the lazyness in my head telling me \"I don't always want to prefix columns from the same table in order to avoid invalid SQL.\"\nWhat do you think about something like localColumns or something along those lines, to specify columns local to the table of the \"origin\" model for the query. So we could do something like:\n.fetch({localColumns: ['id','name','something'], columns: ['table1.id','table2.name','table3.something']})\nSeeing it written out like that now also seems to improve the readibility of the query, since columns from the origin model are grouped together. And we don't have to worry about collisions there. Of course this is just sugar. What do you say?\n. Ha actually you're right! I added it in because in my use case I was specifying columns from the same table, without prefixing them manually. But your point make excellent sense. I assume this was just the lazyness in my head telling me \"I don't always want to prefix columns from the same table in order to avoid invalid SQL.\"\nWhat do you think about something like localColumns or something along those lines, to specify columns local to the table of the \"origin\" model for the query. So we could do something like:\n.fetch({localColumns: ['id','name','something'], columns: ['table1.id','table2.name','table3.something']})\nSeeing it written out like that now also seems to improve the readibility of the query, since columns from the origin model are grouped together. And we don't have to worry about collisions there. Of course this is just sugar. What do you say?\n. Ok, then when I get home I'll remove the array code and just keep the prefixing in the first method! That sounds like a neat idea, to be able to get the columns from the db during extension. Did you think a bit more about it already or is it just an idea for now?\n. Ok, then when I get home I'll remove the array code and just keep the prefixing in the first method! That sounds like a neat idea, to be able to get the columns from the db during extension. Did you think a bit more about it already or is it just an idea for now?\n. Btw I'll be on irc in about an hour or so, if you feel like discussing about this.\n. Btw I'll be on irc in about an hour or so, if you feel like discussing about this.\n. bump, can this be merged?\n. bump, can this be merged?\n. What exactly isn't working for you, Tao? What kind of error do you get? I just tested what you are trying to do, and it works without any issues.\nI just tested the following code:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  info: function() {\n    return this.hasMany(Info, 'user_id').query('where', 'name', '=', this.get('name'));\n  }\n});\nAnd accessing the name attribute works just fine and returns the correct rows. If the model's id is 3 and the name is \"Tao\", the resulting query will be:\nselect `data`.* from `data` where `name` = 'Tao' and `data`.`user_id` in (3)\n. What exactly isn't working for you, Tao? What kind of error do you get? I just tested what you are trying to do, and it works without any issues.\nI just tested the following code:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  info: function() {\n    return this.hasMany(Info, 'user_id').query('where', 'name', '=', this.get('name'));\n  }\n});\nAnd accessing the name attribute works just fine and returns the correct rows. If the model's id is 3 and the name is \"Tao\", the resulting query will be:\nselect `data`.* from `data` where `name` = 'Tao' and `data`.`user_id` in (3)\n. Ok, can you log the model you get after the 2nd query? It looks like you're not getting a routeID back at all. How do you actually perform the query?\n\nOn Jan 8, 2014, at 12:39 AM, Tao Yang notifications@github.com wrote:\nhi Johannes,\nthanks for the quick reply!\nhere is the debug output from the real scenario\n{ sql: 'select boat_has_route.* from boat_has_route where dwh_nid = ? limit 1',\n  bindings: [ 67271 ],\n  __cid: '__cid1' }\n{ sql: 'select boat.* from boat where boat.boatID in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\n{ sql: 'select boat_has_route_for_bs.* from boat_has_route_for_bs where boat_has_route_for_bs.boatID in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid1' }\n{ sql: 'select seasonal_price.* from seasonal_price where routeID is null and seasonal_price.boatID in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\nI'm querying one entry from table 'boat_has_route' which has a belongsTo relationship to boat table on boatID. Boat has a hasMany relationship to table boat_has_route_for_bs. boat_has_route_for_bs has a hasMany relationship to seasonal_price. routeID is existing in boat_has_route_for_bs, and I define the relationship between boat_has_route_for_bs and seasonal_price as follow:\nseasonalPrices: function() {\n    return this.hasMany(SeasonalPrices, 'boatID').query('where', 'routeID', '=', this.get('routeID'));\n  }\nbut from the debug info, this.get('routeID') returns undefined.\nTao\n\u2014\nReply to this email directly or view it on GitHub.\n. Ok, can you log the model you get after the 2nd query? It looks like you're not getting a routeID back at all. How do you actually perform the query?\nOn Jan 8, 2014, at 12:39 AM, Tao Yang notifications@github.com wrote:\nhi Johannes,\nthanks for the quick reply!\nhere is the debug output from the real scenario\n{ sql: 'select boat_has_route.* from boat_has_route where dwh_nid = ? limit 1',\n  bindings: [ 67271 ],\n  __cid: '__cid1' }\n{ sql: 'select boat.* from boat where boat.boatID in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\n{ sql: 'select boat_has_route_for_bs.* from boat_has_route_for_bs where boat_has_route_for_bs.boatID in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid1' }\n{ sql: 'select seasonal_price.* from seasonal_price where routeID is null and seasonal_price.boatID in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\nI'm querying one entry from table 'boat_has_route' which has a belongsTo relationship to boat table on boatID. Boat has a hasMany relationship to table boat_has_route_for_bs. boat_has_route_for_bs has a hasMany relationship to seasonal_price. routeID is existing in boat_has_route_for_bs, and I define the relationship between boat_has_route_for_bs and seasonal_price as follow:\nseasonalPrices: function() {\n    return this.hasMany(SeasonalPrices, 'boatID').query('where', 'routeID', '=', this.get('routeID'));\n  }\nbut from the debug info, this.get('routeID') returns undefined.\nTao\n\u2014\nReply to this email directly or view it on GitHub.\n. Can you post your models, so I can use them for a test? If you have post the SQL for the three tables as well.\nOn Jan 8, 2014, at 1:45 AM, Tao Yang notifications@github.com wrote:\nhere is the row I've got from 3rd query\n// irrelevant columns removed\n[ { boatID: 1,\n    routeID: 2,\n    seasonalPrices: [] } ]\nand I'm querying like\nvar boatHasRoute = new BoatHasRoute();\n// bshbhr is the relation name of boat_has_route_for_bs\nboatHasRoute.fetch({withRelated: ['boat', 'boat.bshbhr', 'boat.bshbhr.seasonalPrices']}).then(...);\nThanks,\nTao\n\u2014\nReply to this email directly or view it on GitHub.\n. Can you post your models, so I can use them for a test? If you have post the SQL for the three tables as well.\nOn Jan 8, 2014, at 1:45 AM, Tao Yang notifications@github.com wrote:\nhere is the row I've got from 3rd query\n// irrelevant columns removed\n[ { boatID: 1,\n    routeID: 2,\n    seasonalPrices: [] } ]\nand I'm querying like\nvar boatHasRoute = new BoatHasRoute();\n// bshbhr is the relation name of boat_has_route_for_bs\nboatHasRoute.fetch({withRelated: ['boat', 'boat.bshbhr', 'boat.bshbhr.seasonalPrices']}).then(...);\nThanks,\nTao\n\u2014\nReply to this email directly or view it on GitHub.\n. The issue here is that you are eager loading the relations and that at the time of fetching the attributes are not set on the model. There is no value for routeID yet. You can easily test this, by replacing this.get('routeID'); to a fixed value. Then the query will execute successfully. My example above works fine because I already loaded the model and thus its attributes are available.\n\nI'm not sure if it's feasible for you, but you could fetch incrementally like this:\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nreturn boatHasRoute\n.fetch({withRelated: ['boat', 'boat.bshbhr']})\n.then(function (res) {\n  var firstRel = res.related('boat')\n  .related('bshbhr')\n  .first();\n  return firstRel\n  .seasonalPrices()\n  .query('where', 'routeID', '=', firstRel.get('routeID')).fetch().then(function (res) {\n    console.log(res.first().get('price'));\n  });\n});\nOf course this depends upon whether you want to only fetch the first result (as I did) or more.\n. The issue here is that you are eager loading the relations and that at the time of fetching the attributes are not set on the model. There is no value for routeID yet. You can easily test this, by replacing this.get('routeID'); to a fixed value. Then the query will execute successfully. My example above works fine because I already loaded the model and thus its attributes are available.\nI'm not sure if it's feasible for you, but you could fetch incrementally like this:\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nreturn boatHasRoute\n.fetch({withRelated: ['boat', 'boat.bshbhr']})\n.then(function (res) {\n  var firstRel = res.related('boat')\n  .related('bshbhr')\n  .first();\n  return firstRel\n  .seasonalPrices()\n  .query('where', 'routeID', '=', firstRel.get('routeID')).fetch().then(function (res) {\n    console.log(res.first().get('price'));\n  });\n});\nOf course this depends upon whether you want to only fetch the first result (as I did) or more.\n. @our1944 sorry for the late reply! You shouldn't have to manually attach them back to the original object. Following up on my example, here is a block of code to prove it:\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nreturn boatHasRoute.fetch({require: true, withRelated: ['boat', 'boat.bshbhr']})\n.then(function (res) {\n  return res.related('boat')\n  .related('bshbhr')\n  .first()\n  .load('seasonalPrices').then(function (first) {\n    console.log(first.related('seasonalPrices').first().get('price'));\n    console.log(res.related('boat').related('bshbhr').first().related('seasonalPrices').first().get('price'));\n  });\n});\nBoth calls to console.log will log the same value. I modified my original example a bit to account for this.get('routeID') inside seasonalPrices()  on BookingSystemsHasBoatHasRoute. It works fine like  this, without having to use query to use add a where condition\n. @our1944 sorry for the late reply! You shouldn't have to manually attach them back to the original object. Following up on my example, here is a block of code to prove it:\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nreturn boatHasRoute.fetch({require: true, withRelated: ['boat', 'boat.bshbhr']})\n.then(function (res) {\n  return res.related('boat')\n  .related('bshbhr')\n  .first()\n  .load('seasonalPrices').then(function (first) {\n    console.log(first.related('seasonalPrices').first().get('price'));\n    console.log(res.related('boat').related('bshbhr').first().related('seasonalPrices').first().get('price'));\n  });\n});\nBoth calls to console.log will log the same value. I modified my original example a bit to account for this.get('routeID') inside seasonalPrices()  on BookingSystemsHasBoatHasRoute. It works fine like  this, without having to use query to use add a where condition\n. @bendrucker The variable name was just for the sake of the example ;)\n. @bendrucker The variable name was just for the sake of the example ;)\n. Ok, seems resolved. Closing this.\n. Ok, seems resolved. Closing this.\n. @visigoth I assume you can get away with that by changing the posts relation from a Tag from\nposts: function () {\n  return this.belongsToMany(Posts);\n}\nto\nposts: function () {\n  return this.belongsToMany(require('./post').Posts);\n}\nBecause posts is then evaluated at run time, the cyclic dependency shouldn't be an issue anymore.\n. @visigoth I assume you can get away with that by changing the posts relation from a Tag from\nposts: function () {\n  return this.belongsToMany(Posts);\n}\nto\nposts: function () {\n  return this.belongsToMany(require('./post').Posts);\n}\nBecause posts is then evaluated at run time, the cyclic dependency shouldn't be an issue anymore.\n. @nathggns that is correct.\n. @nathggns that is correct.\n. I think that would be a nice idea. Calling require or calling Bookshelf.store wouldn't make a difference performance-wise (somebody correct me, if I'm wrong), It might also help to get rid of stuff like require(../../../../../models/mymodel) *\n* hyperbole\n. @bendrucker you meant at extension time, right? If so, then this could be integrated into the custom extend method which is required anyway to fetch column information from the database. But it already feels wrong to pass in a model name like\n...extend({\n  identifier: 'something',\n  ...\n});\nGot a better idea?\n. @bendrucker I recently talked with @tgriesser about the extend issue with coffeescript and he has a PR pending for this issue. But not sure if and when that is going to find its way into the language\n. Actually why don't we make this a plugin for now? Then it's just additional and the core won't be affected. And at some point the plugin could be merged if its code base is mature and clean enough. (And works with coffee).\n. @nathggns The issue is exactly what @bendrucker mentioned. That's actually what I meant. That you cannot have a custom extend method with coffeescript and there are no hooks for extend.\n@bendrucker ok I see your point. I have to say I always use the extend method though. Just curious, do you use the inheritance pattern you mentioned? \n. @bendrucker You mentioned the use of a method like Bookshelf.model(modelObj). Can you elaborate on the way you would want it to work?\nFrom my point of view it could be a convenience method like extend which will actually call extend under the hood and then attach things to the model after extending it normally. This would mean that model() would just be a wrapper around things like extend, fetchColumnsForModel and register (fictional method just as an example) etc. like this:\n```\nBookshelf.model = function (protoProps, staticProps, parentCtor, identifier) {\n  var modelCtor = parentCtor.extend(protoProps, staticProps);\n// side effects of this function would be attaching\n  // a promise for the column info to the prototype\n  this.fetchColumnsForModel(modelCtor);\n// add the model to the registry\n  this.register(modelCtor, identifier);\nreturn modelCtor;\n};\n```\nThis would then not destroy the inheritance pattern you mentioned, because you would still be able to something like this:\n```\nfunction Model() {};\nModel.prototype = new Bookshelf.Model();\nBookshelf.fetchColumnsForModel(Model);\nBookshelf.register(Model, 'mymodel');\n```\nIs that along the lines of what you were thinking about? (Despite you despising the idea of having a registry)\n@tgriesser What do you think about this? It could mitigate the issue with the extend hook, because the convenience method could wrap all of it.\n. @bendrucker @tgriesser I fully agree on this one. Would be nice to have a central list, maybe even with status info per entry.\n. @bendrucker @tgriesser I fully agree on this one. Would be nice to have a central list, maybe even with status info per entry.\n. Sounds good so far. @bendrucker good idea with the primitives. What about allowing custom typecasting functions? For example to convert a date to a UTC timestamp. Now that I think about it, that should probably be a filter or something else...\nAre we still thinking about having a 'model' function? Or do you still want to do everything within an extended 'extend' method @tgriesser ?\nSent from my iPhone\n\nOn Jan 15, 2014, at 5:31 PM, Ben Drucker notifications@github.com wrote:\nYes on knex handling DB calls to collect columns/types and Bookshelf having custom typecasting. The only thing I might change from your example is using a combo of primitives and config object rather than string references to types. So the example becomes:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  types: {\n    permissions: Bookshelf.types.JSON,\n    active: Boolean\n  }\n});\nThat's borrowed from Mongoose, btw, which I tend to cite pretty often since it's a pretty user-friendly lib. The advantage of primitives is that you don't have to memorize a series of custom abbreviations\u2014you only have to consult the docs for JSON.\n\u2014\nReply to this email directly or view it on GitHub.\n. Sounds good so far. @bendrucker good idea with the primitives. What about allowing custom typecasting functions? For example to convert a date to a UTC timestamp. Now that I think about it, that should probably be a filter or something else...\n\nAre we still thinking about having a 'model' function? Or do you still want to do everything within an extended 'extend' method @tgriesser ?\nSent from my iPhone\n\nOn Jan 15, 2014, at 5:31 PM, Ben Drucker notifications@github.com wrote:\nYes on knex handling DB calls to collect columns/types and Bookshelf having custom typecasting. The only thing I might change from your example is using a combo of primitives and config object rather than string references to types. So the example becomes:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  types: {\n    permissions: Bookshelf.types.JSON,\n    active: Boolean\n  }\n});\nThat's borrowed from Mongoose, btw, which I tend to cite pretty often since it's a pretty user-friendly lib. The advantage of primitives is that you don't have to memorize a series of custom abbreviations\u2014you only have to consult the docs for JSON.\n\u2014\nReply to this email directly or view it on GitHub.\n. @rhys-vdw @amanmohla There is still my old PR https://github.com/tgriesser/bookshelf/pull/244\nIt might not be exactly what you want and maybe it won't even work with the current version but maybe it is a start?\n. Interestingly I don't have this problem using mocha.\n\n@pward123 you might be able to reach down into the pool instance like this:\nBookshelf.knex.client.pool.destroy(function () {\n  console.log('pool destroyed');\n}\nto destroy the pool and all its connections.\n. Interestingly I don't have this problem using mocha.\n@pward123 you might be able to reach down into the pool instance like this:\nBookshelf.knex.client.pool.destroy(function () {\n  console.log('pool destroyed');\n}\nto destroy the pool and all its connections.\n. Same what? Is it working for you both with mocha, or not?\n@pward123 Did you try adding my suggested code to the tearDown method of your testCase?\n. Ok cool, then this can be closed I assume :)\n. @tgriesser What do you think, we should add a plugins section to the docs, right?\n. Ah ok, cool then :) Your version actually looks nicer!\n. Ah ok, cool then :) Your version actually looks nicer!\n. If you want to convert your column names you should be able to do this with custom format and parse methods on your model. What is called OWNER in the other table? The foreign key column? If so, you can simply specify a hasOne relationship and then specify the custom foreign key as 2nd argument.\n. You're referencing the foreign key incorrectly. You are passing an array as foreign key, but you want to pass in a string. So what you want is this:\nvar Record = Bookshelf.Model.extend({\n    tableName: 'RECORD',\n    idAttribute: 'RECORDID',\n    user: function() {\n        return this.belongsTo(User, 'OWNER');\n    }\n});\n. You can catch these errors just like any other using the catch method. Then you can inspect the caught Error object and check if it contains a clientError property. This property will then give you further information about your database error. After that you can decide how to proceed, depending on the error code you got.\n. You can catch these errors just like any other using the catch method. Then you can inspect the caught Error object and check if it contains a clientError property. This property will then give you further information about your database error. After that you can decide how to proceed, depending on the error code you got.\n. Like this:\nnew Device({\"device_chash: chash})\n.save()\n.then(function (model) {\n    // play with your model here\n})\n.catch(function (err) {\n    // do error handling here\n});\n. Like this:\nnew Device({\"device_chash: chash})\n.save()\n.then(function (model) {\n    // play with your model here\n})\n.catch(function (err) {\n    // do error handling here\n});\n. You're welcome!\n. You're welcome!\n. You actually don't need to use a hasMany().through() relation here. A normal belongsToManywill just do fine. But to get to your issue: did you try to specify specific keys in your through method? The method is defined as .through(JoinModel, [throughFk], [otherKey]). So you can pass in custom keys as 2nd and 3rd argument. This should help :)\n. You actually don't need to use a hasMany().through() relation here. A normal belongsToManywill just do fine. But to get to your issue: did you try to specify specific keys in your through method? The method is defined as .through(JoinModel, [throughFk], [otherKey]). So you can pass in custom keys as 2nd and 3rd argument. This should help :)\n. Ok cool! This is is resolved then, yes?\n. It might be useful to allow collections to be registered too since they can be used for relations as well. Just to keep things consistent and not force users to use two different was of referencing, e.g. .register() for models but still require() for collections.\nSent from my iPhone\n\nOn Jan 19, 2014, at 12:48 AM, Ben Drucker notifications@github.com wrote:\nNot really that hard. Read the explanation I've included in the docs. (https://github.com/valet-io/bookshelf/blob/feature/model-registry/index.html#L614)\nThe confusion comes from the fact that Node creates copies of the modules which in most cases are just empty objects to avoid infinite recursion. Models are needed within methods, not to construct related models. Once hasOne or any other relation function is called the module is loaded. The issue people run into is when they do this:\n// model.js\nvar RelatedModel = require('./related-model');\nvar Model = Bookshelf.Model.extend({\n  related: function() {\n    this.hasOne(RelatedModel);\n   }\n});\nmodule.exports = Model;\n// related-model.js\nvar Model = require('./model');\nvar RelatedModel = Bookshelf.Model.extend({\n  related: function() {\n    this.belongsTo(Model);\n   }\n});\nmodule.exports = RelatedModel;\nThere's a reason why requiring the modules directly works:\nrelated: function() {\n   this.hasOne(require('./related-model');\n}\nBy the time that require is called, RelatedModel loaded. What trips people up is that they expect var Model = require('./Model'); to just work and eventually become Model. What node actually does is creates a copy, not a reference, of module.exports as it exists when the cyclic dependency is encountered\u2014i.e. {}.\n\u2014\nReply to this email directly or view it on GitHub.\n. Ok now that I thought about it (sorry for not replying earlier, battling a flu/sinusitis here) the whole idea for this was to have a unified repository of models/collections to being able to deal with circular dependencies and to reduce typing. But what this does right now, is only changing the syntax required to include a model. It does save some headaches in regard to path resolution and nesting, by removing the requirement to use require('../../../model'), but I think having a string resolution in there somewhere should be a goal. I assume (without further checking) that it's only a handful of places where a check has to be implemented whether a string or an object was passed in.\n\nAlso I'd like to propose that we add a method for fetching a model from the registry and not directly access the \"cache\". It would be nice to use the method, without a name parameter, but that doesn't work since you're also using that call for registering. I can live without this, but it might be more comfortable for users.\n. I was referring to Bookshelf.models. Just bad wording on my part there. Since it's effectively the internal store for register, should users be accessing it directly? (Even if it's no harm, maybe having an accessor to retrieve a model might be nicer?\n. That was my point when I said that we cannot use .register('mymodel') with the way it's currently implemented. Because you expect the first argument to be a model. And yeah, then the function should be renamed. Could be model, but could also be registry.\nFor me using Bookshelf.models is not a huge issue, it just feels a tad off. Could also just be me!\n. @bendrucker Very nice! Great work, I like it! I feel that this is really going to come in handy.\n. You can do something like this:\nActivityGroupCollection\n.fetch({withRelated: ['performer', {\n  'performer': function (qb) {\n    // qb is a reference to the query builder, so you can use all its methods here\n    qb.where(...);\n  }\n}])\n.then(...)\n. So you want to constrain your results for ActivityGroup, and then fetch all RoundtableUsers for each of those, correct? You could hook into the fetching event of your collection and modify the query there, like this:\njavascript\n    var groups = ActivityGroupCollection.forge();\n    groups.on('fetching', function (collection, columns, options) {\n      options.query.whereIn('performer_id', [1,2,3]);\n    });\n    groups.fetch({withRelated:['performer']})\n    .then(function (groups) {\n      console.log(groups);\n    });\nThat will result in two queries:\nSQL\n    select `activity_group`.* from `activity_group` where `performer_id` in (1,2,3)\n    select `roundtable_user`.* from `roundtable_user` where `roundtable_user`.`id` in (?)\nIs that what you want?\n. @bendrucker good catch - I should've mentioned the query method.\n. The query should not bind user_id, but photo.id, which would be 1 in this case. And that is correct, since you want all users for a given photo. photo.load('user') is suposed to fetch all users which belong to the photo model. Since you defined a through relationship, the query seems correct. It fetches all users by joining from photos to users, via photo_groups. What kind of query were you expecting here?\n. I just ran your code with a minor change (I didn't use load, but fetched the relation directly):\n``` javascript\n    User = Bookshelf.DB.Model.extend({tableName: 'users'});\n    PhotoGroup = Bookshelf.DB.Model.extend({tableName: 'photo_groups'});\n    Photo = Bookshelf.DB.Model.extend({\n        tableName: 'photos',\n        user: function(){ return this.belongsTo(User).through(PhotoGroup); }\n    });\nPhoto.forge({id: 1}).user().fetch();\n\n```\nThe produced query is the same as yours, but the binding is correct:\nsql\nselect `users`.*, `photo_groups`.`id` as `_pivot_id`, `photo_groups`.`user_id` as `_pivot_user_id` from `users` inner join `photo_groups` on `photo_groups`.`user_id` = `users`.`id` inner join `photos` on `photo_groups`.`id` = `photos`.`photo_group_id` where `photos`.`id` = ? limit 1\nbindings: [ 1 ]\nIf I fetch first and then run load('user') it indeed tries to bind user_id. This seems like a bug. You can mitigate the problem, by passing 'id' as 2nd argument to belongsTo.\n. @tgriesser it seems this can be fixed by patching either the key or eagerKeys methods of the relation. I made a quick test using the following, and it still passes all the tests, but now the binding is correct:\neagerKeys: function(resp) {\n  var key = this.isInverse() ? this.key('foreignKey') : this.parentIdAttribute;\n  key = this.isThrough() && key === singularMemo(this.targetTableName) + '_' + this.targetIdAttribute ? this.parentIdAttribute : key;\n  return _.uniq(_.pluck(resp, key));\n},\n. Missing a test I know, but it's 1:30 AM...\n. I didn't really check it yet, but this might just be an issue with the joining key - at least that's what it looks like to me atm when running your example. The relation is actually joined on posts.id = genre.id which of course should be posts.genre_id = genre.id.\n. Yeah I see - must have been a weird copy/paste error on my side.\n. @bavidar Another way to do this (If you do not need your ids prior to saving the model) is to hook into the \"saving\" event and then use a function like this:\njavascript\nfunction something(model, attrs, options) {\n  if (model.isNew()) {\n    model.set(model.idAttribute, this.createId(\"prefix_\"));\n  }\n}\nThat way the function will be called after Bookshelf decided whether to update/insert. And then you're good for setting the id manually.\n. Yeah the EmptyResponse error is the main error right now, I think. Depending on whether we want to add basic validation to Bookshelf, then we might have a few more to add to the list.\n. Why did you move the errors to base/model.js? We also need those custom errors for collections :)\n. I have Bookshelf around in almost every controller, because of my need for transactions. If we are going to have someCollection.NotFoundError and someModel.NotFoundError couldn' that be a bit confusing to people instead of having just a single place for them?\n. @bendrucker I definitely like the idea of NotFound and Empty - gives the whole thing more semantical meaning :+1: \n. @grzegorzgolec out of curiosity: are you looking for something that caches single queries? Or do you want to cache the serialized JSON (which could contain data from multiple queries)?\n. @tgriesser @bendrucker I took the liberty to get some code written for extracting the table schema for a model. What do you guys think about this? No tests yet, I will add them later. I just want to get the discussion about this going, since this might be a neat feature.\nOne thing right now is that when tables are creating on the fly, this will fail in mysql, since a 'FLUSH TABLES' statements needs to be issed in order for the information schema to be updated. Could be fixed by checking the client and then conditionally adding that.\nAlso even though the comment inside the plugin file mentions typecasting, that's not implemented yet. It might even be better to have that separately or at least to give the user the option to override the castings the plugin chose.\nAnyway, looking forward to hearing/reading your thoughts.\n. @bendrucker Could be used for automatically cleaning invalid attributes (it does that right now) Typecasting could be implemented using a basic map for available types and their js-counterparts.\n. @bendrucker Isn't he just seeing the toJSON result of a Date object? It might make more sense to have this formatting step inside the model's toJSON method, since you'd probably want to keep the date object around instead of a string\n. That's exactly what I was referring to! And +1 for moment.js!\n. Hey Peter,\nyour second approach is correct. In a hasOne relationship the id of the owning model must be present in the record of the owned model.\nSo when a User hasOne DriverProfile then inside the table for the Driverprofile you need to have a column for the user id, which by default will be the singlar version of the User table + _id. When you're calling addDriverProfile, does the User model have an id? \nHere is a working example for you:\n``` javascript\nvar Genre = Bookshelf.DB.Model.extend({\n  tableName: 'genres',\nposts: function () {\n    return this.hasMany(Post);\n  }\n});\nvar Post = Bookshelf.DB.Model.extend({\n  tableName: 'posts'\n});\nGenre.prototype.addPost = function(title) {\n  return Post.forge({\n    title: title,\n    genre_id : this.id\n  }).save()\n  .bind(this)\n  .then(function (post) {\n    return this.fetch({\n      withRelated: 'posts'\n    });\n  });\n};\nGenre.forge({name: 'my genre'})\n.save()\n.then(function (genre) {\n  return genre.addPost('new post');\n})\n.then(function (genre) {\n  console.log(genre.related('posts').first().get('title'));\n});\n```\nWhen executed with the debug: true flag, this will log the following to the console:\njavascript\n{ sql: 'insert into `genres` (`name`) values (?)',\n  bindings: [ 'my genre' ],\n  __cid: '__cid2' }\n{ sql: 'insert into `posts` (`genre_id`, `title`) values (?, ?)',\n  bindings: [ 7, 'new post' ],\n  __cid: '__cid3' }\n{ sql: 'select `genres`.* from `genres` where `genres`.`name` = ? and `genres`.`id` = ? limit 1',\n  bindings: [ 'my genre', 7 ],\n  __cid: '__cid4' }\n{ sql: 'select `posts`.* from `posts` where `posts`.`genre_id` in (?)',\n  bindings: [ 7 ],\n  __cid: '__cid2' }\nnew post\nSince the addPost method mirrors your addDriverProfile method I suspect that the error lies with your model not having an id at the time of creating a DriverProfile, the table names being different from what Bookshelf expects as default (you might want to try to set them explicitly) or your database schema missing a column or having a column name spelled differently.\nCould you please try to add a .catch() handler to the promise inside your addDriverProfile method to see if there is an issue there? \n. Hey Peter,\nyour second approach is correct. In a hasOne relationship the id of the owning model must be present in the record of the owned model.\nSo when a User hasOne DriverProfile then inside the table for the Driverprofile you need to have a column for the user id, which by default will be the singlar version of the User table + _id. When you're calling addDriverProfile, does the User model have an id? \nHere is a working example for you:\n``` javascript\nvar Genre = Bookshelf.DB.Model.extend({\n  tableName: 'genres',\nposts: function () {\n    return this.hasMany(Post);\n  }\n});\nvar Post = Bookshelf.DB.Model.extend({\n  tableName: 'posts'\n});\nGenre.prototype.addPost = function(title) {\n  return Post.forge({\n    title: title,\n    genre_id : this.id\n  }).save()\n  .bind(this)\n  .then(function (post) {\n    return this.fetch({\n      withRelated: 'posts'\n    });\n  });\n};\nGenre.forge({name: 'my genre'})\n.save()\n.then(function (genre) {\n  return genre.addPost('new post');\n})\n.then(function (genre) {\n  console.log(genre.related('posts').first().get('title'));\n});\n```\nWhen executed with the debug: true flag, this will log the following to the console:\njavascript\n{ sql: 'insert into `genres` (`name`) values (?)',\n  bindings: [ 'my genre' ],\n  __cid: '__cid2' }\n{ sql: 'insert into `posts` (`genre_id`, `title`) values (?, ?)',\n  bindings: [ 7, 'new post' ],\n  __cid: '__cid3' }\n{ sql: 'select `genres`.* from `genres` where `genres`.`name` = ? and `genres`.`id` = ? limit 1',\n  bindings: [ 'my genre', 7 ],\n  __cid: '__cid4' }\n{ sql: 'select `posts`.* from `posts` where `posts`.`genre_id` in (?)',\n  bindings: [ 7 ],\n  __cid: '__cid2' }\nnew post\nSince the addPost method mirrors your addDriverProfile method I suspect that the error lies with your model not having an id at the time of creating a DriverProfile, the table names being different from what Bookshelf expects as default (you might want to try to set them explicitly) or your database schema missing a column or having a column name spelled differently.\nCould you please try to add a .catch() handler to the promise inside your addDriverProfile method to see if there is an issue there? \n. @cultofmetatron sorry for the late reply! Glad you figured it out :)\n. @bavidar What exactly do you mean by \"That worked but it would not let me pull a property from the model so that each model had a different \"objectName\".\nIf you want always the same object name, as defined by type, then this would work:\n``` javascript\nAddress = Bookshelf.Model.extend({\n  tableName: 'addresses',\n  hasTimestamps: ['date_created', 'date_modified'],\n  prefix:'adr',\n  type: 'address',\ntoJSON: function () {\n    var attributes = Bookshelf.Model.prototype.toJSON.call(this);\n    attributes['type'] = this.type;\n    console.log(attributes);\n  }\n});\nconsole.log(Address.forge({some: 'thing'}).toJSON());\nconsole.log(Address.forge({another: 'thing'}).toJSON());\n// the above logs the following:\n// { some: 'thing', type: 'address' }\n//{ another: 'thing', type: 'address' }\n```\nIf you actually want the type to be a combined value which inclues some attribute from the model, then you can just change the above toJSON method to this:\njavascript\n  toJSON: function () {\n    var attributes = Bookshelf.DB.Model.prototype.toJSON.call(this);\n    attributes['type'] = this.type + '_' + this.get('specialColumn');\n    console.log(attributes);\n  }\n// used in the above example this will log:\n// { some: 'thing', specialColumn: '123', type: 'address_123' }\n// { another: 'thing', specialColumn: '456', type: 'address_456' }\nIs this what you are looking for?\n. @bavidar What exactly do you mean by \"That worked but it would not let me pull a property from the model so that each model had a different \"objectName\".\nIf you want always the same object name, as defined by type, then this would work:\n``` javascript\nAddress = Bookshelf.Model.extend({\n  tableName: 'addresses',\n  hasTimestamps: ['date_created', 'date_modified'],\n  prefix:'adr',\n  type: 'address',\ntoJSON: function () {\n    var attributes = Bookshelf.Model.prototype.toJSON.call(this);\n    attributes['type'] = this.type;\n    console.log(attributes);\n  }\n});\nconsole.log(Address.forge({some: 'thing'}).toJSON());\nconsole.log(Address.forge({another: 'thing'}).toJSON());\n// the above logs the following:\n// { some: 'thing', type: 'address' }\n//{ another: 'thing', type: 'address' }\n```\nIf you actually want the type to be a combined value which inclues some attribute from the model, then you can just change the above toJSON method to this:\njavascript\n  toJSON: function () {\n    var attributes = Bookshelf.DB.Model.prototype.toJSON.call(this);\n    attributes['type'] = this.type + '_' + this.get('specialColumn');\n    console.log(attributes);\n  }\n// used in the above example this will log:\n// { some: 'thing', specialColumn: '123', type: 'address_123' }\n// { another: 'thing', specialColumn: '456', type: 'address_456' }\nIs this what you are looking for?\n. @bavidar I'm no coffeescript guy, could you rewrite your example in javascript? ;) Could you not just create a base model, modify its toJSON method and then extend this with all your other models?\n. @bavidar I'm no coffeescript guy, could you rewrite your example in javascript? ;) Could you not just create a base model, modify its toJSON method and then extend this with all your other models?\n. @bavidar Ok so I checked your coffeescript and actually that really isn't anything else than my code in javascript, since it directly becomes this:\njavascript\ndb.Model.prototype.toJSON = function() {\n  this.attributes[\"object\"] = \"address\";\n  return this.attributes;\n};\nApart from the fact that you might want to call the super toJSON method, I do not see any issue, why you couldn't access type. I do the same thing in my toJSON example above and that works well. And as I stated above, having a base model and extending it should get rid of the need to always override toJSON. If I still misunderstood your issue, I'd be happy to hear an explanation so that we can figure this out :)\nUpdate\nDo these examples help?\n``` coffeescript\nclass Model\n toJSON: () ->\n   asd:123\nclass Base extends Model\n  toJSON: () ->\n    attrs = super\n    attrs[\"object\"] = @type \n    attrs\nclass Base2 extends Model\n  toJSON: () ->\n    attrs = super\n    attrs[\"object\"] = @constructor.type\n    attrs\nclass Sub1 extends Base\n  type: 123\nclass Sub2 extends Base2\n  @type: 456\ns = new Sub1()\nconsole.log(s.toJSON())\ns2 = new Sub1()\ns2.type = 'abc'\nconsole.log(s2.toJSON())\ns3 = new Sub2()\nconsole.log(s3.toJSON())\n```\n. @bavidar Ok so I checked your coffeescript and actually that really isn't anything else than my code in javascript, since it directly becomes this:\njavascript\ndb.Model.prototype.toJSON = function() {\n  this.attributes[\"object\"] = \"address\";\n  return this.attributes;\n};\nApart from the fact that you might want to call the super toJSON method, I do not see any issue, why you couldn't access type. I do the same thing in my toJSON example above and that works well. And as I stated above, having a base model and extending it should get rid of the need to always override toJSON. If I still misunderstood your issue, I'd be happy to hear an explanation so that we can figure this out :)\nUpdate\nDo these examples help?\n``` coffeescript\nclass Model\n toJSON: () ->\n   asd:123\nclass Base extends Model\n  toJSON: () ->\n    attrs = super\n    attrs[\"object\"] = @type \n    attrs\nclass Base2 extends Model\n  toJSON: () ->\n    attrs = super\n    attrs[\"object\"] = @constructor.type\n    attrs\nclass Sub1 extends Base\n  type: 123\nclass Sub2 extends Base2\n  @type: 456\ns = new Sub1()\nconsole.log(s.toJSON())\ns2 = new Sub1()\ns2.type = 'abc'\nconsole.log(s2.toJSON())\ns3 = new Sub2()\nconsole.log(s3.toJSON())\n``\n. I'm a bit lost - how's that different from my suggestion, which @bavidar denied as not being what he wants? :)\n. I'm a bit lost - how's that different from my suggestion, which @bavidar denied as not being what he wants? :)\n. @tgriesser Look at my comment from 7 hours ago :P It actually has a coffeescript example! With a base model! ;)\n. @tgriesser Look at my comment from 7 hours ago :P It actually has a coffeescript example! With a base model! ;)\n. Did you try to run the select query using the exact bindings manually against the DB using a tool like Navicat? If so, does that yield a result? \n. @cabhishek I'm not 100% sure but since you are using athroughrelationship I think you have to use anidcolumn on your joining table. If all you want is to be able to fetch some data from the pivot table then you can also go withbelongsToMany` like this:\njavascript\nraces: function () {\n  return this.belongsToMany(Race, 'athlete_races_2', 'athlete_id', 'race_id').withPivot(['some', 'pivot', 'fields']);\n}\n. @cabhishek I'm not 100% sure but since you are using a through relationship I think you have to use an id column on your joining table. If all you want is to be able to fetch some data from the pivot table then you can also go with belongsToMany like this:\njavascript\nraces: function () {\n  return this.belongsToMany(Race, 'athlete_races_2', 'athlete_id', 'race_id').withPivot(['some', 'pivot', 'fields']);\n}\n. @cabhishek The other way would be to then add an id column to your pivot table, because you need it to fetch your pivot-model. As long as compound keys aren't implemented this is the only way to achieve this afaik.\n. @cabhishek The other way would be to then add an id column to your pivot table, because you need it to fetch your pivot-model. As long as compound keys aren't implemented this is the only way to achieve this afaik.\n. @majimboo Did you initialize Bookshelf? If not, you need to call initialize first. The returned instance will then have a knex property available for you to use.\n. @majimboo Did you initialize Bookshelf? If not, you need to call initialize first. The returned instance will then have a knex property available for you to use.\n. Then you need to use that instance:\njavascript\nBookshelf.PG.knex(...)\n. Then you need to use that instance:\njavascript\nBookshelf.PG.knex(...)\n. As far as I know, this was something that @tgriesser maybe wanted to implement. See #56 \n. As far as I know, this was something that @tgriesser maybe wanted to implement. See #56 \n. Yeah @bendrucker maybe I get the time to write something for this. It might benefit some people.\n. Yeah @bendrucker maybe I get the time to write something for this. It might benefit some people.\n. @tgriesser get on IRC so we can talk about this :)\n. @tgriesser this should work? Build is failing?\n. You are not using a proper charset.It must be one of these: https://github.com/felixge/node-mysql/blob/master/lib/protocol/constants/charsets.js\nThis recent commit https://github.com/felixge/node-mysql/commit/ad9bd8fddedc438f71d08deae5378dca040c054d introduced the behavior, that node-msql will now throw an error, if an invalid charset is specified. In case that you want to use UTF8, use 'UTF8_GENERAL_CI', to which the connection should also default, if no charset is specified.\n. I think this falls into the same category as your other question :) There is no auto-detection the the related model's id and thus you will have to explicitly set your foreign key to it. As @bendrucker mentioned in #343 a plugin could be created for this. But you'd probably then not do related('capital').set, but rather usa.set('capital', washington). Which of course would only work for belongsTo relationships and would require a bit more work/architectural thinging for hasOne, hasMany and belongsToMany.\n. If you specify that a SocialLogin model belongsTo a User model, then it is expected that by default the table for your social logins contains a user_id column (by default the singular version of the target model's tableName + _id - target being the model to which the other one belongs, in this case User).\nBy adding id as 2nd parameter you specifically state that a different field should be used as joining field/foreign key. The way the relationships work hasn't been changed so this should not be a new error for you.\n. For invokeThen you are not passing the correct transaction object. 't' isn't defined, you should be passing 'transaction'. Does that solve your timing issue?\nSent from my iPhone\n\nOn May 15, 2014, at 12:18 AM, Fabr\u00edcio Ferrari de Campos notifications@github.com wrote:\nI'm using the code below to update the customer data and the relations data:\nbaseBookshelf.transaction(function(transaction) {\n  Customer.forge()\n    .save(customer, {transacting: transaction})\n    .tap(function(customer) {\n       return customer.related('documents')\n          .set(relationsAttributes.documents).invokeThen('save', null, {transacting: t}));\n    .then(transaction.commit)\n    .catch(transaction.rollback);\n}).then(function(customer) {\n   getRelationsData(customer, callback);\n}).catch(function(error) {\n});\nIn the getRelationsData I query the documents data based on the foreign key that isn't the primary key from Customer, because of this I cannot use withRelated from bookshelf.\nBut when the select is done, it doesnt retun the documents data inserted. I guess the select is done before the transaction is completed, but turning on the debug mode, the insert occurs before the select, but the debug doesnt print the transaction itself.\nI put a setTimeout to test and the selected returned the data saved, so the problem must be with the transaction that wasn't completed.\nIs there some workaround to resolve this?\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah it seems better to actually throw an error to prevent unexpected behavior if somebody overwrites some model by accident! :+1: \n. @simg But you will lose the ability to have real foreign keys on your relationship, thus you are sacrificing data integrity for performance. As far as I can see, real foreign keys for arrays are also not on the roadmap for postgres 9.4.\n. When Knex 0.6.0 lands this should be much easier! It will allow things like:\n\njavascript\nknex.whereIn('id', knex.raw('(select * from table where id = ?)', [binding])).orWhere('id', 22)\nor\njavascript\nvar q1 = knex.select('*').from('table').where('id', binding);\nknex.whereIn('id', q1).orWhere('id', 22);\n. This is very similar to the  visibility plugin, just with a different purpose. Maybe we can roll out a generic solution which covers hiding, guarding and automatic cleaning of wrong properties (In combination with schema detection)?\n. This is very similar to the  visibility plugin, just with a different purpose. Maybe we can roll out a generic solution which covers hiding, guarding and automatic cleaning of wrong properties (In combination with schema detection)?\n. I think we talked about this (same reason, the columnInfo data) and \nthere is no event for model extension, as it wouldn't be compatible with \ncoffeescript. I remember something like this. @tgriesser had a pull \nrequest open for coffeescript to support something like that if I \nrecall that correctly.\nAnyway, for a solution: How about overriding the extend method to look \nfor a \"postExtend\" method after extending the base and if it finds one \nit will be executed in the scope of the model?\n. I think we talked about this (same reason, the columnInfo data) and \nthere is no event for model extension, as it wouldn't be compatible with \ncoffeescript. I remember something like this. @tgriesser had a pull \nrequest open for coffeescript to support something like that if I \nrecall that correctly.\nAnyway, for a solution: How about overriding the extend method to look \nfor a \"postExtend\" method after extending the base and if it finds one \nit will be executed in the scope of the model?\n. It doesn't exit because Knex keeps the connection open. You will have to destroy/close it manually through the Knex connection pool. Don't have a code sample right now but I will add one when I'm at work. Or you can search trough the issues, because this has come up before :)\nSent from my iPhone\n\nOn Jul 1, 2014, at 7:17 AM, npow notifications@github.com wrote:\nHi,\nI'm trying to use bookshelf.js to populate my database via a nodejs script (executed in a cronjob). However I noticed that the process doesn't exit even after the records are successfully written to the database. Is there something I'm supposed to do to make it exit?\nI've tried the following simple code and it doesn't exit either:\nvar knex = require('knex')({\n  client: 'postgresql',\n  connection: {\n    host     : '127.0.0.1',\n    user     : 'npow',\n    password : '',\n    database : 'miserly',\n    charset  : 'utf8'\n  }\n});\nvar bookshelf = require('bookshelf')(knex);\nconsole.log('here');\n\u2014\nReply to this email directly or view it on GitHub.\n. It doesn't exit because Knex keeps the connection open. You will have to destroy/close it manually through the Knex connection pool. Don't have a code sample right now but I will add one when I'm at work. Or you can search trough the issues, because this has come up before :)\n\nSent from my iPhone\n\nOn Jul 1, 2014, at 7:17 AM, npow notifications@github.com wrote:\nHi,\nI'm trying to use bookshelf.js to populate my database via a nodejs script (executed in a cronjob). However I noticed that the process doesn't exit even after the records are successfully written to the database. Is there something I'm supposed to do to make it exit?\nI've tried the following simple code and it doesn't exit either:\nvar knex = require('knex')({\n  client: 'postgresql',\n  connection: {\n    host     : '127.0.0.1',\n    user     : 'npow',\n    password : '',\n    database : 'miserly',\n    charset  : 'utf8'\n  }\n});\nvar bookshelf = require('bookshelf')(knex);\nconsole.log('here');\n\u2014\nReply to this email directly or view it on GitHub.\n. How about something along these lines:\n\n``` javascript\nvar num = 5;\nvar saves = [];\nfor (var i = 0; i < num; ++i) {\n    saves.push(Store.forge({ ... }).save());\n}\nPromise.all(saves)\n.then(function () {\n    return knex.destroy();\n})\n.then(function () {\n    console.log('all done');\n});\n```\n. How about something along these lines:\n``` javascript\nvar num = 5;\nvar saves = [];\nfor (var i = 0; i < num; ++i) {\n    saves.push(Store.forge({ ... }).save());\n}\nPromise.all(saves)\n.then(function () {\n    return knex.destroy();\n})\n.then(function () {\n    console.log('all done');\n});\n``\n. You're welcome :)\n. This should help with issues like #405 \n. This should help with issues like #405 \n. I think there is no direct way of knowing whether a relation has been loaded or not. As you already pointed out,related()` always returns an object. That's because it either returns the already fetched relation or it just creates a new object and returns that.\nFor a hasOne or morphOne relation you could use the isNew() method to determine whether you just got a new model returned or one which already has an id set. For hasMany, morphMany and belongsToMany what instantly comes to mind is to check whether the length of the collection is larger than 0, but that of course does not necessarily mean that a relation has not been fetched yet.\nIf you wanted to implement something like a fetched flag, you'd have to start with the related() method, setting the flag on the newly created instance. And then of course if fetch() is called on the relation. I'm not sure how big the percentage of projects is, which keep models around in memory and then need to check whether something has been fetched or not. If enough people were interested in this, it could validate to implement a flag like I mentioned above in the core.\n@tgriesser what do you think about this?\n. I think there is no direct way of knowing whether a relation has been loaded or not. As you already pointed out, related() always returns an object. That's because it either returns the already fetched relation or it just creates a new object and returns that.\nFor a hasOne or morphOne relation you could use the isNew() method to determine whether you just got a new model returned or one which already has an id set. For hasMany, morphMany and belongsToMany what instantly comes to mind is to check whether the length of the collection is larger than 0, but that of course does not necessarily mean that a relation has not been fetched yet.\nIf you wanted to implement something like a fetched flag, you'd have to start with the related() method, setting the flag on the newly created instance. And then of course if fetch() is called on the relation. I'm not sure how big the percentage of projects is, which keep models around in memory and then need to check whether something has been fetched or not. If enough people were interested in this, it could validate to implement a flag like I mentioned above in the core.\n@tgriesser what do you think about this?\n. Oh man, why didn't I think of that... geesh.\n. Actually the documentation is quite solid: http://bookshelfjs.org/#Model-idAttribute :)\nSince you did not set the idAttribute Bookshelf will assume that you are using a column named id for your primary key. But that column does not exist in your table. If you want to use identity_card as primary key, then set your idAttribute to that value.\nApart from that: Bookshelf will try to update a record if your model already contains a value for the property referred to by idAttribute. So you don't have to set the id if you want to save the model and using an auto-increment key. If you do not use an auto-incrementing key, then you can pass {method:'insert'} as 2nd parameter to save: save(null, {method: 'insert'}) which will force Bookshelf to actually insert the row instead of updating it.\n. Oh no worries :)\n. hasMany does definitely work!\nSent from my iPhone\n\nOn Aug 24, 2014, at 3:47 PM, Ben Drucker notifications@github.com wrote:\nYeah you definitely can't use belongsToMany for same-table relations. hasMany might work.\n\u2014\nReply to this email directly or view it on GitHub.\n. hasMany does definitely work!\n\nSent from my iPhone\n\nOn Aug 24, 2014, at 3:47 PM, Ben Drucker notifications@github.com wrote:\nYeah you definitely can't use belongsToMany for same-table relations. hasMany might work.\n\u2014\nReply to this email directly or view it on GitHub.\n. You could attach the listener in the model's initialize method. So when you create a new model and save it, the listener will have been attached and will be subsequently triggered.\nOn Oct 2, 2014, at 10:15 PM, Scott Persinger notifications@github.com wrote:\nHow can I setup a listener that will be called whenever a new instance of my Bookshelf-extended User model is saved?\nI understand I can attached to 'saved' on a single instance, or on a collection of models, but how can I setup a listener if the model doesn't exist yet?\n\u2014\nReply to this email directly or view it on GitHub.\n. You could attach the listener in the model's initialize method. So when you create a new model and save it, the listener will have been attached and will be subsequently triggered.\nOn Oct 2, 2014, at 10:15 PM, Scott Persinger notifications@github.com wrote:\nHow can I setup a listener that will be called whenever a new instance of my Bookshelf-extended User model is saved?\nI understand I can attached to 'saved' on a single instance, or on a collection of models, but how can I setup a listener if the model doesn't exist yet?\n\u2014\nReply to this email directly or view it on GitHub.\n. @tgriesser for the object-relational impedance mismatch couldn't we use a simple cache on the constructor to take care of this? (maybe) Something like this: https://gist.github.com/johanneslumpe/f163d62924dd9d29dff9\n\nThat was something I had done for backbone-associations, but it should be possible to adapt it I guess. You already mentioned you want to use some kind of session store, just wanted to throw this out there in case it helps. Since this works with reference counting for removing objects from the cache when they're not used anymore it might be useful to actually use weakmaps to get rid of that step.\nWill the session store be limited to a single request? Or how do want to define a session?\n. @tgriesser for the object-relational impedance mismatch couldn't we use a simple cache on the constructor to take care of this? (maybe) Something like this: https://gist.github.com/johanneslumpe/f163d62924dd9d29dff9\nThat was something I had done for backbone-associations, but it should be possible to adapt it I guess. You already mentioned you want to use some kind of session store, just wanted to throw this out there in case it helps. Since this works with reference counting for removing objects from the cache when they're not used anymore it might be useful to actually use weakmaps to get rid of that step.\nWill the session store be limited to a single request? Or how do want to define a session?\n. The issue is on line 220 of the model code:\njavascript\nreturn sync[options.method](method === 'update' && options.patch ? attrs : this.attributes);\nIn the case of using \"update\" with patch: true, it will set the attributes on the model normally, as always, but then it will pass the raw object, which you pass to he save method, to the selected syncing method. So it will actually set the virtuals on the model just fine, but it will never try to save the distinct first and last columns, but always just the name column. The easiest way to work around this - for now - would be to just not use the virtual property with update/patch. We might have to add a save method to the virtuals plugin to handle this case.\n. +1 for making this configurable. The current way is a nice shortcut for not having but build select queries manually, but I do see a benefit in making it optional/configurable.\n. Wow, that is a really nice write-up. I'm on board with that. Especially the part about getting rid of events in favor of life cycle methods seems like a good idea. And using POJOS as base will help a lot to cut down the source size I'd imagine.\nAlso being able to just log all queries for a single request is something I'm looking forward to. Especially if there will be an easy way to log additional parameters like route, parama etc. I'd be up for doing some ui work for that. We can talk about that on irc if you'd like @tgriesser\nWhat I'm curious about is the timeframe of this though. And what is the plan for the \"old\" version of bookshelf then? Will it just be discontinued or still receive big fixes?\nAnyway, kind of stoked to see a turn into this direction!\n. Well currently there are \"destroying\" and \"destroyed\" events triggered on the model before and after the deletion. Would you be able to hook into them? You\nmight be able to use them to set a custom flag on your model marking it as destroyed, if you keep it around.\n. Going to close this one now. If you still have questions, post back here :)\n. How about this:\n``` javascript\nvar ConversationUser = bookshelf.Model.extend({\n  tableName: 'conversation_users'\n});\nvar Conversation = bookshelf.Model.extend({\n    tableName: 'Conversations',\n    whitelist: function(){\n        return this.hasMany(ConversationUser, 'ConversationId')\n        .query({where: {type: 'whitelist'}});\n    },\n    blacklist: function(){\n        return this.hasMany(ConversationUser, 'ConversationId')\n        .query({where: {type: 'blacklist'}});\n    },\n    moderators: function(){\n        return this.hasMany(ConversationUser, 'ConversationId')\n        .query({where: {type: 'moderator'}});\n    }\n});\n```\nIf you now had a Conversation with an id of 5, the produced query for a whitelist would be the following:\nSQL\nselect \"conversation_users\".* from \"conversation_users\"\nwhere \"type\" = \"whitelist\"\nand \"conversation_users\".\"ConversationId\" = 5\nDoes this help?\n. You still have a circular dependency. Field requires DocumentEditionValue and vice versa. One of the two will be undefined. Try removing those require statements and see if that helps. The whole point of the registry is that you do not have to require the other models. By using the registry, but not removing the require statements themselves, you gain nothing ;)\n. It is not Bookshelf's responsibility to load your model files for you. You will have to make sure that you require you model files. You could use something like require-directory to load all the files inside your models directory. After that all your models should be available in the registry - if you register them with the registry that is.\nYou should most likely do this in some kind of bootstrap file when starting up your server. Of course you have to require your models in your controllers. My comment above was referring to a model requiring another model file.\n. @dpiccone It might be useful to have a separate transform pipeline/function for this outside of bookshelf, which accepts an object and just returns a very specific set of fields.\n. @dpiccone It might be useful to have a separate transform pipeline/function for this outside of bookshelf, which accepts an object and just returns a very specific set of fields.\n. ",
    "melardev": "Hi, this feature still has a bug, detach only works if there is something to delete, if there is no rows to delete then it triggers an exception. I have tested with detach() and detach([]), they both trigger an exception with the following stacktrace:\nCustomError: EmptyResponse\n    at Child.<anonymous> (D:\\MyBookshelfProject\\node_modules\\bookshelf\\lib\\model.js:715:21)\n    at PassThroughHandlerContext.finallyHandler (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\finally.js:57:23)\n    at PassThroughHandlerContext.tryCatcher (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\util.js:16:23)\n    at Promise._settlePromiseFromHandler (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\promise.js:512:31)\n    at Promise._settlePromise (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\promise.js:569:18)\n    at Promise._settlePromise0 (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\promise.js:614:10)\n    at Promise._settlePromises (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\promise.js:694:18)\n    at _drainQueueStep (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\async.js:138:12)\n    at _drainQueue (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\async.js:131:9)\n    at Async._drainQueues (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\async.js:147:5)\n    at Immediate.Async.drainQueues [as _onImmediate] (D:\\MyBookshelfProject\\node_modules\\bluebird\\js\\release\\async.js:17:14)\n    at runCallback (timers.js:705:18)\n    at tryOnImmediate (timers.js:676:5)\n    at processImmediate (timers.js:658:5). ",
    "vjpr": "\nI'm curious if you had specific reasons for preferring the node style callbacks over promises.\n\nAll my code is currently written with Iced Coffee Script. I find it easier to read and refactor code when theres less nesting. Just personal preference.\nE.g. findOrCreate\nfindOrCreate: (title, url, done) ->\n      await @find(where: {url}).done defer done, link\n      return done(null, link) if link?\n      link = @build({title}).setUrl(url)\n      await link.save().done defer()\n      done null, link\nPromises are great and its definitely advantageous for standard JS - and I might start using them more even with Iced Coffee.\nI'd say I'm a minority using Iced Coffee, but I would argue there would be a lot of code using regular Node.js callbacks, and providing support for it would make it easier for people to transition to this lib.\nAt the moment I need to refactor all my code from Node.js callbacks to use Bookshelf. Would be tons easier if callbacks were supported. I think many people would be in same boat.\n. Yep the latter works well, would save me tons of effort not having to rewrite all my code.\n. That looks great. I'll try it out now.\nWhen you say plugin, is this going to be bundled with the lib or would I have to add it separately?\n. Small fix for incorrect context being used in apply.\ntarget[method] = function() {\n    var that = this;\n    var args = arguments;\n    return {\n      then: function(onFulfilled, onRejected) {\n        return targetMethod.apply(that, args).then(onFulfilled, onRejected);\n      },\nand exec is the same.\n. Using this findOrCreate example it looks like promises are incompatible with Iced Coffee Script.\n@findOrCreate: (where, attrs, options, done) ->\n    model = new @(where)\n    model.fetch(_.extend options, require: true).then null, (e) ->\n      return model.set(attrs).save() if e.message is \"EmptyResponse\"\n      throw e\nSay I do use a promise and then want to use await defer:\n```\nuser = User.findOrCreate(id: 1, name: 'Bob') // user is a promise\nawait user.exec defer e, user // doesn't work\nawait user.then defer r, defer e // won't move on because Iced needs both defers to be satisfied\nawait user.always defer r // Promise#always is deprecated though\nreturn next(r) if _.isError r\n```\nI think what is needed is a .exec method on the when promise library. Shame the Promise.prototype is private.\nAt the moment I am using always and a wrapper:\n```\nonError - function to be called when promise rejected.\nonSuccess - function to be called when promise is fulfilled.\nesc = (onError, onSuccess) ->\n  return (result) ->\n    if _.isError result\n      onError? result\n    else\n      onSuccess? result\n```\nto write:\napp.get '/user', (req, res, done) ->\n  User.find(parseInt(id)).always esc done\nNot sure if you had any idea of an alternative method I could investigate?\n. This is a contrived example.\nI have tons of code with much more complicated logic. I'd have to rewrite all my code to use promises which is unappealing. Plus the framework I am working (auth logic, controllers helpers etc) is all errback based.\nSequelize offers the .done chaining function for perfect errback support on every method, but it looks like it has a much different mechanism for resolving promises.\nWhat would need to be done to implement exec in Bookshelf? - I would be happy to have a crack at it if you provided some pointers :)\n. Ok I'll give it a whirl. Cheers!\n. Thanks. FYI, just found out that in the upcoming version 2.2.0 of when.js they are introducting when.bindCallback() allowing attachment of node-style callback: https://github.com/cujojs/when/blob/dev/node/function.js#L196\n```\nfunction bindCallback(promise, callback) {\n        return when(promise, callback && success, callback);\n    function success(value) {\n        return callback(null, value);\n    }\n}\n\n``\n. @tgriesser I'm getting an error with the newbookshelf/plugins/exec`:\nModels.User.forge(user).save().exec (e, r) ->\n        return done e if e\n        console.log u\n        done()\n```\n      1) #findById\n{ sql: 'insert into \"users\" (\"created_at\", \"email\", \"id\", \"name\", \"password\", \"updated_at\") values ($1, $2, $3, $4, $5, $6) returning \"id\"',\n  bindings: \n   [ Thu Jun 20 2013 15:39:42 GMT+1000 (EST),\n     'test1@test.com',\n     'ce09ba2a-a554-47ba-91bd-0f4d91d1db1a',\n     'Vaughan',\n     'test',\n     Thu Jun 20 2013 15:39:42 GMT+1000 (EST),\n     Thu Jun 20 2013 15:39:42 GMT+1000 (EST),\n     'test1@test.com',\n     'ce09ba2a-a554-47ba-91bd-0f4d91d1db1a',\n     'Vaughan',\n     'test',\n     Thu Jun 20 2013 15:39:42 GMT+1000 (EST) ],\n  __cid: '__cid1' }\n\u2716 1 of 1 test failed:\n1) Models UserService #findById:\n     Error: The query type has already been set to insert\n      at Common.setType (xxx/node_modules/knex/knex.js:96:15)\n      at .extend.insert (xxx/node_modules/knex/knex.js:794:19)\n      at .extend.insert (xxx/node_modules/bookshelf/bookshelf.js:914:10)\n      at .extend.save.when.all.then.then.model.attributes.(anonymous function).model.(anonymous function) (xxx/node_modules/bookshelf/bookshelf.js:399:45)\n      at Object.i [as then] (xxx/node_modules/when/when.js:355:15)\n      at handlers (xxx/node_modules/when/when.js:253:12)\n      at len (xxx/node_modules/when/when.js:417:5)\n      at drainQueue (xxx/node_modules/when/when.js:735:4)\n      at process.startup.processNextTick.process._tickCallback (node.js:244:9)\n```\nresult is set to arguments which in the case of save() is empty.\nThis is causing the method to run twice because of this line:  result || (result = targetMethod.apply(ctx, args));\nNot sure what the purpose of this check is?\n. @tgriesser I'm getting an error with the new bookshelf/plugins/exec:\nModels.User.forge(user).save().exec (e, r) ->\n        return done e if e\n        console.log u\n        done()\n```\n      1) #findById\n{ sql: 'insert into \"users\" (\"created_at\", \"email\", \"id\", \"name\", \"password\", \"updated_at\") values ($1, $2, $3, $4, $5, $6) returning \"id\"',\n  bindings: \n   [ Thu Jun 20 2013 15:39:42 GMT+1000 (EST),\n     'test1@test.com',\n     'ce09ba2a-a554-47ba-91bd-0f4d91d1db1a',\n     'Vaughan',\n     'test',\n     Thu Jun 20 2013 15:39:42 GMT+1000 (EST),\n     Thu Jun 20 2013 15:39:42 GMT+1000 (EST),\n     'test1@test.com',\n     'ce09ba2a-a554-47ba-91bd-0f4d91d1db1a',\n     'Vaughan',\n     'test',\n     Thu Jun 20 2013 15:39:42 GMT+1000 (EST) ],\n  __cid: '__cid1' }\n\u2716 1 of 1 test failed:\n1) Models UserService #findById:\n     Error: The query type has already been set to insert\n      at Common.setType (xxx/node_modules/knex/knex.js:96:15)\n      at .extend.insert (xxx/node_modules/knex/knex.js:794:19)\n      at .extend.insert (xxx/node_modules/bookshelf/bookshelf.js:914:10)\n      at .extend.save.when.all.then.then.model.attributes.(anonymous function).model.(anonymous function) (xxx/node_modules/bookshelf/bookshelf.js:399:45)\n      at Object.i [as then] (xxx/node_modules/when/when.js:355:15)\n      at handlers (xxx/node_modules/when/when.js:253:12)\n      at len (xxx/node_modules/when/when.js:417:5)\n      at drainQueue (xxx/node_modules/when/when.js:735:4)\n      at process.startup.processNextTick.process._tickCallback (node.js:244:9)\n```\nresult is set to arguments which in the case of save() is empty.\nThis is causing the method to run twice because of this line:  result || (result = targetMethod.apply(ctx, args));\nNot sure what the purpose of this check is?\n. Perhaps from line 17 should read:\nreturn result.then(function(resp) {\n          callback(null, resp);\n        }, function(err) {\n          callback(err, null);\n        }).then(null, function(err) {\n          setTimeout(function() { throw err; }, 0);\n        });\n. Perhaps from line 17 should read:\nreturn result.then(function(resp) {\n          callback(null, resp);\n        }, function(err) {\n          callback(err, null);\n        }).then(null, function(err) {\n          setTimeout(function() { throw err; }, 0);\n        });\n. But what happens if the select query fails? Then I'd have to check its not some sort of database error.\n. Its a pretty common workflow to get and check if a model exists. This is a lot of code for such a common operation.\nI think its best to provide another option to allow the success handler to return a null value.\n. Yep that's fine.\nOn Thu, Jun 20, 2013 at 12:29 PM, Tim Griesser notifications@github.comwrote:\n\nIt returns undefined now... that should work, right?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/21#issuecomment-19727532\n.\n. @tgriesser On further thought I think null is much more preferable.\n- Its more standard amongst Node.js libraries. Mongo, Mongoose, Sequelize, Persistence, etc, etc.\n- It makes more sense - null says to me that a null value has been returned. undefined doesn't indicate that a response was returned - and I would think there is an error somewhere in the code.\n- Also, I ran into a problem using the Passport.js library which has a deserializeUser method which uses the following logic which relies on a null value, as opposed to undefined.\n\n// an error or deserialized user was obtained, done\n    if (err || user) { return done(err, user); }\n    // a valid user existed when establishing the session, but that user has\n    // since been removed\n    if (user === null || user === false) { return done(null, false); }\n. @tgriesser On further thought I think null is much more preferable.\n- Its more standard amongst Node.js libraries. Mongo, Mongoose, Sequelize, Persistence, etc, etc.\n- It makes more sense - null says to me that a null value has been returned. undefined doesn't indicate that a response was returned - and I would think there is an error somewhere in the code.\n- Also, I ran into a problem using the Passport.js library which has a deserializeUser method which uses the following logic which relies on a null value, as opposed to undefined.\n// an error or deserialized user was obtained, done\n    if (err || user) { return done(err, user); }\n    // a valid user existed when establishing the session, but that user has\n    // since been removed\n    if (user === null || user === false) { return done(null, false); }\n. At the moment I'm using this hack:\n```\n  initialize: =>\n    @on 'fetched', @onFetched\nonFetched: (model, resp, options) =>\n    unless _.isEmpty resp\n      @fetched = true\nisNew: =>\n    not @fetched\n```\nI'm sure I will encounter lots of issues.\n. ```\n@forge\n      name: profile.displayName\n      fb: JSON.stringify profile\n      fbId: profile.id\n.save() ...\n@forge({fbId: profile.id}).fetch() // runs where fbId = $1 instead of where fb_id = $1\n```\nDelete would be the same if using something other than id.\n. Probably quite a rare case but sounds good. \nJust clarifying from my last post, the main issue is select queries not running format when using fetch.\n@forge({fbId: profile.id}).fetch() // runswhere fbId = $1instead ofwhere fb_id = $1``\nThis complicates things like findOrCreate.\n. > First makes sense, since that's based off the model attr's... \n...just realised what you meant - I didn't read that as the method Sync#first.\nMakes sense now.\n. Maybe you should be able to declaratively set the where clause on the table. \n```\nclass UserCollection extends Bookshelf.Collection\n  tableName: 'users'\n  where: {id: 1}\nusers = new UserCollection\nusers.fetch().then (models) -> ...\n```\nThe where is then like the url in Backbone.\nAt the moment fetch gets the entire table which is not what you want most of the time.\nOr perhaps just adding a where method onto the collection directly?\n. Ok. I can just extend Bookshelf.Collection if need be.\n. Great to see this reopened :) I'll take a look.\n. At the moment I'm just creating a join table model like so:\nclass Collection\n  addLink: (link) =>\n      cl = db.Models.CollectionLink.forge\n        collectionId: @id\n        linkId: link.id\n        order: 0\n      cl.save()\n. At the moment I'm just creating a join table model like so:\nclass Collection\n  addLink: (link) =>\n      cl = db.Models.CollectionLink.forge\n        collectionId: @id\n        linkId: link.id\n        order: 0\n      cl.save()\n. Yep that makes sense.\n. Yep that makes sense.\n. > Sorry... I'm not sure I follow... you do or do not want that?\nquery().where() produces the json from the db. When I wanted a Model or a Collection of Models.\nBut you have covered this above:\n\nyou stay on the context of the current model/collection you're accessing rather than dropping down into the Knex builder.\n. > Sorry... I'm not sure I follow... you do or do not want that?\n\nquery().where() produces the json from the db. When I wanted a Model or a Collection of Models.\nBut you have covered this above:\n\nyou stay on the context of the current model/collection you're accessing rather than dropping down into the Knex builder.\n. > And yeah, a BaseModel is exactly what I'm thinking would be a good way to go... so you can build out the API you'd find most intuitive... it's a little more verbose the first time but it makes the library easier to wrap your head around.\n\nI agree. The thing that drew me to Bookshelf was the fact that it was layered really nicely. In Sequelize and most ORMs if you find something you can't do you have to drop straight down to SQL, and extensibility is difficult.\n. > And yeah, a BaseModel is exactly what I'm thinking would be a good way to go... so you can build out the API you'd find most intuitive... it's a little more verbose the first time but it makes the library easier to wrap your head around.\nI agree. The thing that drew me to Bookshelf was the fact that it was layered really nicely. In Sequelize and most ORMs if you find something you can't do you have to drop straight down to SQL, and extensibility is difficult.\n. > Yeah, query('where', ... will do it.\nWould be nice if you could pass in a hash.\n. > Yeah, query('where', ... will do it.\nWould be nice if you could pass in a hash.\n. Yep. That would be great. \nAlso, if a query is called on a collection I think it should always return the models as a collection of models.\nIf the user wants to run a raw query they should use Bookshelf.Knex.\n. Yep. That would be great. \nAlso, if a query is called on a collection I think it should always return the models as a collection of models.\nIf the user wants to run a raw query they should use Bookshelf.Knex.\n. I've only had one use case so far and I expected it to be @changed.\nI just looked at Backbone and couldn't find a similar event:\nhttp://backbonejs.org/#Events-catalog\nBackbone.save fires change -> request -> sync.\nI'll try and find some more cases.\nOn Fri, Feb 7, 2014 at 3:36 AM, Tim Griesser notifications@github.comwrote:\n\nHmm, good question. What do you think would be the preferable behavior\nhere? What would be your typical use of an attrs provided in an event\nhere?\n\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/227#issuecomment-34342068\n.\n. Not being called for me.\n\nLooking at the code the promise is rejected here preventing fetched being called later on.\n. Thanks!\nOn Mon, Feb 10, 2014 at 12:39 PM, Ben Drucker notifications@github.comwrote:\n\nYeah nevermind you're right. All of the past-tense events depend on the\noperation completing successfully. For now you should monkey-patch the\nsave, destroy, and fetch methods:\n['save','destroy','fetch'].forEach(function (method) {\n  Model.prototype[method] = function () {\n    return Model.prototype[method].apply(this, arguments).finally(function () {\n      this.trigger('post' + method);\n    });});\nI'd like to change around the event nomenclature at some point to make\nthings more flexible but this should give you what you want for now.\n\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/229#issuecomment-34594982\n.\n. I've monkey-patched below adding @options.query = query:\n\n``` coffee\n  {Sync} = require 'bookshelf/dialects/sql/sync'\n# Issues a delete command on the query.\n  Sync::del = Promise.method ->\n    query = @query\n    syncing = @syncing\n    @options.query = query\n    query.where syncing.idAttribute, syncing.id  if syncing.id?\n    throw new Error(\"A model cannot be destroyed without a \\\"where\\\" clause or an idAttribute.\")  if query.wheres.length is 0\n    @query.del()\n```\n. ",
    "orgertot": "@tgriesser i tried to use your code for the findOrCreate()-Function. At first I was wondering why this is not a normal function in bookshelf but anyway.\nDo the .fetch() return values changed? Because the .fetch() is not returning the EmptyResponse\nissue can be found here\nEdit: First comment ever on github.\nEdit: Found the issue:\nfindOrCreate: function(options) {\n              var cloned = this.clone();\n              return this.fetch(_.extend(options, {require: true})).then(function(result) {\n                 if (result === null) return cloned.save();\n                 return result;\n              });\n        }\n. @tgriesser i tried to use your code for the findOrCreate()-Function. At first I was wondering why this is not a normal function in bookshelf but anyway.\nDo the .fetch() return values changed? Because the .fetch() is not returning the EmptyResponse\nissue can be found here\nEdit: First comment ever on github.\nEdit: Found the issue:\nfindOrCreate: function(options) {\n              var cloned = this.clone();\n              return this.fetch(_.extend(options, {require: true})).then(function(result) {\n                 if (result === null) return cloned.save();\n                 return result;\n              });\n        }\n. This is still important. Any updates?. This is still important. Any updates?. I've got a similar problem.\nOn my get request the returned dateformate is \"yyyy-MM-ddTHH:mm:ss.SSSZ\".\nBut when i try to insert it in this format I become an SQL-error: \"Incorrect date time value\"\n. Huh... A won registry plugin? Thats to much for me..\nBut without the registery plugin Im not able to do circular relationship? Like A to B but not B to A\n. Do you mean this: http://bookshelfjs.org/#Collection-instance-attach\n. > If you need to constrain the query performed by fetch, you can call the query method before calling fetch.\nYou can also use the where method. Sooo what you want to do is to read the invoices from your database and then, with a REST-GET-method, attach the information of the user to the invoice?\nI would define a new function for the model and invoke that after the fetch. What do you mean exactly? \nYou want to fetch for example switch with the matching Ap record? Just do it like you did it before just the other way around.\njavascript\nSwitch.forge({\nfoo: bar\n}}).fetch({withRealted:['ap']}).then(...);\nYou have to add the ap function to your model tho.\nEdit: Ohhhh like a switch has more then one ap?\nyou could do it anyway. just add this to your switch model\njavascript\n...\naps: function() { return this.hasMany(Switch); }),\n...\nAnd add to your query\njavascript\nwithRelated: [\n        {wlc:function(qb){qb.column('id','name','ip');}},\n        'switch',\n        'switch.aps'\n        ]})\n. ",
    "studds": "I took a slightly different approach. Because the id is created client side, it will never be null. So I overrode the default isNew to check 'serverCreatedAt' instead and added timestamps to all my tables.\nOriginally I thought about hacking in some sort of 'upsert', but that seemed messy and inefficient (with postgres... other databases this might be a good option). Checking the serverCreatedAt column is a better match to the original design, but is still exposed to race conditions, though, so I'll need to add in some sort of intelligent retry - perhaps it's enough to revert to 'update' if 'insert' fails?\njavascript\n    // A model is new if it has never been saved to the server, and lacks an 'serverCreatedAt' date\n    Bookshelf.Model.prototype.hasTimestamps = ['serverCreatedAt', 'serverUpdatedAt'];\n    Bookshelf.Model.prototype.isNew = function () {\n        console.log('serverCreatedAt', this.get('serverCreatedAt'));\n        return !this.get('serverCreatedAt');\n    };\n. ",
    "tukkajukka": "I'm using generated UUIDs and because of existing conventions in Backbone and Bookshelf, the column name for the UUID is 'id'. I noticed that when setting the 'id' field manually in a model's initialize() method, the underlying updated only the 'updated_at' field.\nI fixed this using the following override for isNew() and provided a boolean flagging whether the model is still new:\n```\nidSetButNew: false,\ninitialize: function(params) {\n    if(this.isNew()) {\n        this.set('id', uuid.v4());\n        this.idSetButNew = true;\n    }\n    // more initialization stuff\n},\nisNew: function() {\n    return !this.get('id') || this.idSetButNew;\n}\n```\nI think it could be useful if Bookshelf provided some practices for using custom ID generators to avoid this kind of overrides.\n. @johanneslumpe: I think that's a good workaround. Way better than what I had.\n. @johanneslumpe: I think that's a good workaround. Way better than what I had.\n. That try-catch analogy sounds good and explains the proper usage very well. Good to know you are working on this kind of stuff, too.\n. That try-catch analogy sounds good and explains the proper usage very well. Good to know you are working on this kind of stuff, too.\n. ",
    "sidazhang": "@johanneslumpe the issue with your approach seems to be that the point of client-side generated id is so that you know the id before the insert event. Now, we won't know it. Which renders it the same as a server SERIAL.\n. @johanneslumpe the issue with your approach seems to be that the point of client-side generated id is so that you know the id before the insert event. Now, we won't know it. Which renders it the same as a server SERIAL.\n. @jordwest @tgriesser +1 on the PR, a main advantage of client-side ID generation is that you know the id prior to insert. Is this PR going to be merged?\n. @jordwest @tgriesser +1 on the PR, a main advantage of client-side ID generation is that you know the id prior to insert. Is this PR going to be merged?\n. +1 I am also having some issues with this (when the idAttribute needs to be parsed / formatted); I just gave up and stuck with pascal_case\n. What is a good pattern to use knex with bookshelf.js?\nFor example: \n``` js\nvar rows = books.map(function(book) {\n   return book.attributes\n}) \nknex.insert(rows).into('books')\n```\nSomething like this?\n. Wait. So knex.insert actually takes bookshelf object? \nThat's awesome!\nHere is a thought that I wanted to run past you:\nI have a fairly custom database schema pattern such as client-side ID on every table, composite primary keys. This often does not play very nice with bookshelf.js.\nI would really like to use bookshelf.js models and collections but I don't necessarily need things like book.save() I am more than happy to do knex.insert(book).into('books')\nWould you think this is a good pattern?\n. Do you mean I have to do this:\njs\nknex.insert(book.toJSON()).into('books')\n. All I needed was mostly some sort of models module that formats and parses data from/to database(underscore) and nodejs(camelcase) and that's probably about it.\n. ",
    "mistakia": "That looks great.\np.s. Ive setup a simple temp solution using simple class property wrappers\nlike these for now -\nhttps://github.com/TryGhost/Ghost/blob/master/core/server/models/base.js\nOn Monday, November 25, 2013, Tim Griesser wrote:\n\nI've got some cool ideas for how this could be done with the bluebird\npromise lib's error specific catch, and by creating a deferred chain for\nthe model calls, until a then coerces it to a promise:\nErr = require 'bookshelf/errors'Model.find(1).destroy().then ->\n   console.log('model destroyed');.catch Err.ModelNotFound, (err) ->\n   console.log('model not found' + err.stack);   .catch Err.ModelNotDestroyed, (err) ->\n   console.log('model could not be destroyed' + err.stack);\nwhich would expand to:\nErr = require 'bookshelf/errors'Model.find(1).then ->\n   return model.destroy().then ->\n   console.log('model destroyed');.catch Err.ModelNotFound, (err) ->\n   console.log('model not found' + err.stack);   .catch Err.ModelNotDestroyed, (err) ->\n   console.log('model could not be destroyed' + err.stack);\nIn that instance it only saves a line, but I feel like this idea could\nmake for a really cool looking chaining api here.\n/cc @rstacruz https://github.com/rstacruz\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/27#issuecomment-29226238\n.\n\n\nKia Rahimian\n@vacaywave https://twitter.com/vacaywave\nfb.com/VacayWave https://www.facebook.com/VacayWave\n. Hey, just wondering if there's an update on how to attach relations with a join model/table with additional attributes (timestamps, etc)?\n. I have bookshelf/knex powering a nodejs API that angularjs taps into and\nit's a lot of fun. Relations are a breeze.\nOn Monday, November 25, 2013, Tim Griesser wrote:\n\nGreat to hear! Actually, next on my todo list is giving it even more of an\nActive Record feel (static finder methods, etc), but in the meantime\neverything in the library so-far should work really well, feel free to open\na ticket if you see otherwise!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/69#issuecomment-29234222\n.\n\n\nKia Rahimian\n@vacaywave https://twitter.com/vacaywave\nfb.com/VacayWave https://www.facebook.com/VacayWave\n. Sure - I recently undertook a rewrite of a project I'm working on with the\nprimary goal of improving the manageability of the code base.\nI decided to migrate from sequelize to bookshelf/knex and couldn't be\nhappier. My controllers are much slimmer because of better relation\nhandling/eager-loading and support for polymorphic associations and\n'through' - not supported in sequelize. But I think the best part of the\ntransition has been having access to the underlying query builder knex. So\nfar the grass has truly been greener and the only problems I've had are\nwith node-mysql - for some reason I'm not getting any packet responses from\nmysql and therefore it's not emitting a callback for 'LOAD DATA' queries.\nAlso, if your still residing in callback hell, like me, both knex &\nbookshelf expose the method exec().\nAlthough I've never considered mongo for anything more than dumping logs in\nand I've only been using bookshelf/knex for a week, I can confidently say\nthat the bookshelf/knex combo is at the top when it comes to relational\ndatabase libraries in nodejs.\np.s. both sources are small and easy to read in case you ever need to dig\nin.\np.s.s these class property CRUD wrappers are a nice touch i.e.\nfindAll/browse, findOne/read, edit/update, add/create, destroy/delete -\nhttps://github.com/TryGhost/Ghost/blob/master/core/server/models/base.js\np.s.s.s if your set on using a doc store with angular, take a look at\ncouchdb with pouchdb (http://pouchdb.com/) - ive always been interested in\ntesting it out\nOn Tuesday, November 26, 2013, Dimitrios Arethas wrote:\n\n@vacay https://github.com/vacay care to share your experience?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/69#issuecomment-29268402\n.\n. +1\n. \n",
    "ErisDS": "I ended up here with the same question after searching :wink:, I then found the following hints, which I thought it would be helpful to post here:\n- Example on stackoverflow showing this is working now: http://stackoverflow.com/a/22153459/1808480\n- Docs on with/update Pivot http://bookshelfjs.org/#Model-withPivot\n- Related discussion #134\n. Just an idea, but it would be cool to provide an example using node-validator\n. I thought this might be the case, we're trying to do it inside the Post model on a saving event, where we have the json data but don't necessarily have a post.\nI guess for now we'd have to move it back to the api layer.\nThe active-record branch - will this provide more tools for managing relationships? At the moment we have to do the lifting of figuring out which tags to create, which to attach, and which to detach etc.\n. This seems super similar to #1371,\nI have usecases for both this issue and for being able to do:\nUser.fetchAll({ withRelated: {\n  friends: { columns: 'id' }\n}).then(maleFriends =>\n. We just upgraded Ghost to use lodash 4 and saw the same issue.  To resolve it, we have to delete node_modules and re-run npm install. Then the issue goes away (this is on npm 2). \nSo essentially, npm can only make the right thing happen on a fresh install, re-running npm install on an existing set of dependences, or even npm update doesn't result in the right thing happening. \nFor sure this is a bug in npm, but unfortunately, npm is very buggy and getting them to fix things (and everyone to be on a bug-free version) is going to take quite some time \ud83d\ude09 \nSeeing as knex is now running on lodash 4, would it not make sense to work towards upgrading bookshelf as well? v4 seems to be quite a nice upgrade, with some great new tools. \nIs there a reason for bookshelf being on the older version other than the fact the upgrade requires fiddly work to swap function names etc? Would this be something you'd be looking for a contrib for?\n. It's not a problem with bookshelf, but expecting npm to fix things just doesn't work IMO \ud83d\ude09 \nThe upgrade itself is still needed - can I raise a separate issue to get that done? \nAlso, I highly recommend turning on greenkeeper for both knex and bookshelf, although it creates a bit of repository noise, it makes keeping dependencies up-to-date much much easier because it takes the manual element out of it.\n. Can this be reopened? (I can't do it) Only one part is done \ud83d\ude09 \n. Hey @rhys-vdw, is there something we can do - some manual testing etc, that would be helpful?\nI realise this is being pushy, because it is in no way bookshelf's fault. The web of node, npm & lodash interdependencies resulting from bookshelf being on lodash v3 whilst Ghost is on v4 are causing us some pretty horrible problems, including making it hard to install or upgrade Ghost. \nWe have ~a week before we'd like to do our next release, which would include the lodash upgrade and it would be really, really helpful if we could get this merged in time.\nUnfortunately the issues seem to be deep enough that we'd need to either rollback the upgrade or ship Ghost with a fork of bookshelf. Neither of these options is great, but I completely understand if you're too busy to push forward with this. It would help us to know if that is the case.\n. @acburdine do you perchance have a Ghost branch lying around with this upgrade on? If not and you have chance to whip one up that would be awesome, else I'll look at it a bit later.\n@rhys-vdw said it would be useful to see the upgrade run against our build \ud83d\ude04 \n. This issue is closed, however I'm also interested in this behaviour.\nIt seems very similar to #937 - I think there is room to expand the ability of bookshelf to pass options to the relation queries?\n. @tgriesser Is this an oversight? Would a PR be welcome? We're on a mission to get this implemented for Ghost 1.0: https://github.com/TryGhost/Ghost/issues/7495\n. I'm thinking more along the lines that there should be a single way to declare our own function for creating an id, rather than using auto-increment ids. \nThere is a setting which lets us tell bookshelf which column to expect will be the id: http://bookshelfjs.org/#Model-instance-idAttribute\nHowever, we still want to use the id column, we just don't want to use an auto-increment id.\nPerhaps there is a way to do this using parse and format?\n. >  My suggestion would be to have a way to provide joining table model to belongsToMany relation.\nI don't think that is the right approach? That requires a lot of extra code and management of how relationships interact on our side, which is likely to result in things being missed, regressions & bugs. Handling the relationship models is IMO, what bookshelf is for.\nWhat we want to do, fundamentally, is not use auto-increment ids, and instead provide our own way to create an ID. I think that this logic should be handed to bookshelf for it to handle? \nCan we please agree on a spec before any work is done, so that we know the PR will get accepted?\n. > Can we please agree on a spec before any work is done, so that we know the PR will get accepted?\n@tgriesser @vellotis any thoughts? This is majorly blocking us. I don't want to commit to us implementing something that isn't going to get merged.\n. > Can we please agree on a spec before any work is done, so that we know the PR will get accepted?\n@tgriesser @vellotis any thoughts? This is majorly blocking us. I don't want to commit to us implementing something that isn't going to get merged.\n. Please can we get a review here? \n. Just gonna point out here, that a couple of us recently got commit rights, but we don't have the ability to publish a release cc @tgriesser \ud83d\ude09 . Just gonna point out here, that a couple of us recently got commit rights, but we don't have the ability to publish a release cc @tgriesser \ud83d\ude09 . Fairly sure this issue body should say _previousAttributes.\nThe reference to _updatedAttributes in #326 is as a result of some work we did in Ghost many years ago to get around a problem with _previousAttributes not working properly.\nI'm just doing some work on Ghost (3.5 years later :grin:) and I'm still having the same problem. We use our own internal _updatedAttributes instead of _previousAttributes because it works as we would expect / as we need.\nOur implementation is very straightforward, in our base model (all of our models extend from this) we have\nonSaving: function onSaving(newObj) {\n     // Store the previous attributes so we can tell what was updated later\n     this._updatedAttributes = newObj.previousAttributes();\n},\nupdatedAttributes: function updatedAttributes() {\n    return this._updatedAttributes || {};\n},\nIn the subsequent models we throw events from onUpdated, onCreated with the affected Model.\nIn the event handlers, model._attributes & model._previousAttributes will both be the same, containing the saved attributes and model._updatedAttributes will contain the attributes from prior to the save. \nThe documentation says:\n\nReturn a copy of the model's previous attributes from the model's last fetch, save, or destroy. \n\nTherefore, I believe this is a bug and that _previousAttributes should contain the data from prior to the save? Or am I misunderstanding the description and it's from the last save, and not PRIOR to the last save?\nSummary:\nEither the behaviour of previousAttributes not containing the previousAttributes is a bug in which case I'd like to help to fix it. \nOr this is a documentation issue & previousAttributes works as expected, in which case I can also help to clarify the docs and I'd like to propose the addition of updatedAttributes to be part of bookshelf core.. Is the \"More information required\" label intended to mean I need to provide more info? GitHub doesn't generate notifications for labels and I only saw this because I went to link it to an issue in our own repo.\nIf it's for me - can you let me know what I should provide that would be useful? \n. I'm not 100% sure if it is a bug, or if it is actually expected but a bit weird behaviour & not quite properly explained behaviour. Having worked through it a bit more, I think what's going on is this:\n```\n// grab an existing model \nvar myModel = MyModel.forge({name: 'Hannah'}).fetch();\n// outputs Hannah\nmyModel.get('name') \n// Update the model with my full name, but don't save\nmyModel.set('name', 'Hannah Wolfe'); \n// This is now Hannah Wolfe\nvar currentName = myModel.attributes.name;\n// This contains just Hannah\nvar previousName = myModel._previousAttributes.name;\n// Test if the model is out of date\nmyModel.hasChanged(); // will be true, which is correct\nmyModel.hasChanged('name'); // will be true, which is correct\n```\nAll of the above is the world of a model that has been updated without being saved, e.g. using .set(). Not sure how much that method is used as opposed to calling .save() with the new properties. We do both, but mostly the latter.\nIn all of the above, previousAttributes & hasChanged are as we would expect. \nNow to where it gets confusing...\n```\n// Actually save!!!\nmyModel.save();\n// ... then ...\n// This is still Hannah Wolfe\nvar currentName = myModel.attributes.name;\n// This is now Hannah Wolfe because we have saved\nvar previousName = myModel._previousAttributes.name;\n// Test if the model is out of date\nmyModel.hasChanged(); // will be false, which is correct\nmyModel.hasChanged('name'); // will be false, which is correct\n// This implementation, which we have in Ghost, would produce Hannah\nvar updatedName = myModel._updatedAttributes.name;\n```\nSo, although the behaviour seems weird, I think _previousAttributes was only ever intended to be a way of looking at the current model and whether any changes are unsaved.\nMeanwhile, what confuses, is when you need to know what the previous state was just after the save. _previousAttributes sounds like it would tell you the right thing... but it doesn't... I think it's just badly named.\nPretty sure previousAttributes& hasChanged are interrelated and changing either of those is a fairly breaking and undesirable change \ud83d\ude02 .\nHence why I'm thinking that actually, this is a proposal for a new feature, where by on save, the previousAttributes are saved as updatedAttributes so they can still be accessed and wasUpdated() becomes a thing...\nThe use case is something like this:\n```\n// in our post model\nfunction onUpdated(model) {\n    if (model.get('status') === 'published') {\n       // A post that is published was updated... fire an event\n        eventService.emit('post.published.edited', model);\n   }\n}\n// Elsewhere\neventService.on('post.published.edited', function eventHandler(model) {\n   // Do code here that figures out what changed, to determine if we need to update things like RSS feeds\n});\n```\nI'm totally OK with being told this usecase isn't common enough amongst bookshelf users to warrant storing yet another set of attributes on every model, and that our custom implementation is what we should do (maybe we should pluginify it).\nBuuuut in this case, I still think the docs need to be clarified, which I can do if wanted \ud83d\ude01 \nTL;DR \n- previousAttributes relates to saved vs unsaved data,\n- _previousAttributes should probably be called \"_currentAttributes\" because it contains what's currently stored, where attributes may contain unsaved data. \n- we probably can't and shouldn't change the existing implementation\n- Maybe we could add a new feature for updatedAttributes / wasUpdated, but can also introduce this as a plugin I think\n- I can definitely improve the docs so that I don't get confused by this again \ud83d\ude02 \n. ",
    "kubino": "Hi Tim, perfect exactly what I needed and working like a charm. Sorry you could write just rtfm, but I did, and overlook that. Thx again!\n. ",
    "denisahac": "// product category\nvar ProductCategory = DB.Model.extend({\n    tableName: 'tblProductCategories',\n    idAttribute: 'categoryId',\n    // list of products\n    products: function() {\n        return this.hasMany(Product, 'categoryId');\n    }\n});\n// collection of product categories\nvar ProductCategories = DB.Collection.extend({\n    model: ProductCategory\n});\n// product\nvar Product = DB.Model.extend({\n    tableName: 'tblProducts',\n    idAttribute: 'productId',\n    // product category reference\n    productCategory: function() {\n        return this.belongsTo(ProductCategory, 'categoryId');\n    }\n};\nNow how would I query the productCategories including the products associated with each category.\nProductCategories.forge().related().......\nrelated method does work\n. ",
    "bendrucker": "Take a look at the docs for model#fetch, specifically the withRelated option\n. @peteotto The create handler can be cut down a whole lot:\njs\ncreate = {\n  handler: function(request, reply) {\n    return new Address().save({\n      name: request.payload.name,\n      address_line1: request.payload.address_line1\n    })\n    .call('fetch')\n    .then(reply)\n    .catch(reply);\n  }\n};\n. @peteotto The create handler can be cut down a whole lot:\njs\ncreate = {\n  handler: function(request, reply) {\n    return new Address().save({\n      name: request.payload.name,\n      address_line1: request.payload.address_line1\n    })\n    .call('fetch')\n    .then(reply)\n    .catch(reply);\n  }\n};\n. Not at all @thetutlage. Please open a new issue though if you're having trouble.\n. Not at all @thetutlage. Please open a new issue though if you're having trouble.\n. Yes, lowercase\n. Yes, lowercase\n. collection.at(0).get('product_id')\n. No. Bookshelf is currently based on Backbone and the only public interface is via get. \nhttps://github.com/tgriesser/bookshelf/issues/552#issuecomment-70015790\n. Can you copy/paste and/or link to \"this\" part of the docs that you think is unclear/incorrect?\nA related model will always be at least an empty object, but since relations are lazy it will be undefined until you call related or use withRelated in a fetch.\nThe easiest way to test for the presence of related data just depends on your business logic. You can always use _.isEmpty but in pretty much all cases you could just use if (owner.id).\n. Search for function(qb) and there's an example of using that syntax to get a hold of the query builder (i.e. Knex).\n. I hear you. For now we're going to refrain from adding new examples where there are already several. The one page doc format is particularly strained with things like relations and readability is an issue. \nI'll keep a tally here which I'd love for you to contribute to as you get started:\nhttps://github.com/tgriesser/bookshelf/wiki/Examples-Todo\n. Yes\n. Assuming exampleRelation is a collection, you want invokeThen. invoke returns an array of promises and so calling then would throw. invokeThen is wrapping the returned array in a Promise.all which then actually resolves the promise array using then. \nIf exampleRelation is a single model \u2014\u00a0e.g. Model.relation: function() { return this.hasOne(ExampleRelation); } \u2014 then it would just be a standard save. \n. The mixing of DBs is really cool. Never would have thought of that but I can totally see use cases. \n. +1 on this. It's something that I do pre-destroy fairly often\u2014checking to see whether some dependent model has records for the parent before permitting a destroy. It would definitely be better off as a stored procedure in the DB but  it's a lot easier to do it at the application level.\n. I went in and looked at what it would take to implement the original request. As @harry-zhang mentioned, using belongsTo is the right solution for his use case. hasMany is tougher. @kaemu, you might be able to use belongsToMany in your case. This isn't an issue that has a quick fix unfortunately. \n. Hook into the fetching event and set the related option there\n. @adriano-di-giovanni  Yes, the events section for collections should be changed. It would be a big help if you could submit a PR. \n. See #146 \n. I'd offer the same comment here as I did on #161 (https://github.com/tgriesser/bookshelf/pull/161#issuecomment-31584647)\nI don't think edge behaviors like this belong as a core feature when you can easily implement them using Object.defineProperty.\n. @nathggns Just want to clarify my comment in light of your current implementation. Doing something like that at the routing/controller level is definitely not a practice, which I think you understand. But it's also very easy to add this kind of behavior using ES5 objects. Happy to go into this a little more if you or anyone else are interested. Backbone's getter/setter structure, event listeners, etc. are meaningful when you're developing for the browser and you can only use ES3. ES5 finalized a lot of very useful object manipulation features and ES6 will bring even more.\n. Take a look at how the virtuals plugin is implemented: https://github.com/johanneslumpe/bookshelf/commit/7e1232f81f41fdd76149edc32ba64e0b15515074#diff-b3db804e6d07fad88cd8b6d9a6d6be85R43\nOwn properties are enumerable by default so you're going to have a hard time implementing the visible side of this concept properly. The hidden side, on the other hand, is easy. Just define the property as enumerable: false. \nThe implementation here will work, but it could potentially become a problem to maintain. Object.keys would include the hidden properties, for example. Not the end of the world, but using Object.defineProperty is definitely the right way to do this. \n. javascript\nObject.defineProperty(Model.prototype, 'property', {enumerable: false});\nvar model = new Model();\nmodel.property = 'foo';\nNow model.property returns 'foo' but Object.keys(model) will return an empty array.\nThe exact way you configure your objects would depend on the use case. If anyone who wants this feature can offer a real world use case I can give you some more guidance. \n. Still not entirely clear on a scenario where you wouldn't use columns to restrict the query, but do whatever works. No doubt that if you're doing this regularly using a plugin or implementing this on a base model class is a good idea.\n. @Tape Gotcha. If you're genuinely ignoring those IDs, you might just consider letting them exist in the response. But if for some reason you do need to clean up the serialized object, it's definitely a perfect case for a plugin. As you noted, needing something like this is a sign of minor code smell. But I can also see it being useful if you find yourself needing to regularly hide attributes on the model level. \n@johanneslumpe Yeah you're right, that's going to be a problem. In this case it sounds like monkey patching toJSON is the most direct way to deal with this. Bookshelf is probably going to be a good candidate for a big rewrite well down the road to replace the backbone model logic with native JS objects. A lot of the backbone model functionality could be replaced with getters/setters+ non-enumerable properties (ES5), and Object.observe (ES6/harmony). It can't be shimmed so the browser is always going to be an issue. But in Node it's an increasingly bad idea to decorate objects with custom behavior that duplicates native functionality.\n. I think this might be nice as a plugin, but I'm not entirely sure it belongs as a core feature in the library (with the need to write docs, maintain it, etc.). It's really easy to define \"virtuals\" using ES5's Object.defineProperty which can be enumerable (appear in .toJSON()) or non-enumerable (accessible when called but not in Object.keys.\n. FYI, never use both args of then. If your success handler throws an exception, it won't be caught. Bluebird's .catch(rejectionHandler) is just doing .then(null, rejectionHandler).\n. I'd strongly advise against using generic variables like res\u2014it's going to get confusing quickly. \nThis should work though, although I very rarely use eager loading. Cleaning up a little:\njavascript\nreturn new BoatHasRoute({dwh_nid: 1})\n  .fetch({require: true, withRelated: ['boat', 'boat.bshbhr']})\n  .then(function (boatHasRoute) {\n    return boatHasRoute.related('boat')\n      .related('bshbhr')\n      .invokeThen('load', 'seasonalPrices')\n      .return(boatHasRoute.toJSON())\n  })\n  .then(function(bhrJSON) {\n    // Do whatever you need with your JSON here\n  });\n. I'd strongly advise against using generic variables like res\u2014it's going to get confusing quickly. \nThis should work though, although I very rarely use eager loading. Cleaning up a little:\njavascript\nreturn new BoatHasRoute({dwh_nid: 1})\n  .fetch({require: true, withRelated: ['boat', 'boat.bshbhr']})\n  .then(function (boatHasRoute) {\n    return boatHasRoute.related('boat')\n      .related('bshbhr')\n      .invokeThen('load', 'seasonalPrices')\n      .return(boatHasRoute.toJSON())\n  })\n  .then(function(bhrJSON) {\n    // Do whatever you need with your JSON here\n  });\n. You got it! And yeah, didn't mean for that to sound like such a strong admonition. Clarifying the var names also made it easier to show of the wonderful sugary goodness of Bluebird (.return).\n. You got it! And yeah, didn't mean for that to sound like such a strong admonition. Clarifying the var names also made it easier to show of the wonderful sugary goodness of Bluebird (.return).\n. I have to assume you defined id as 181 elsewhere, otherwise this would fail to produce valid SQL. You don't need to  fetch the model before destroying it unless you need to check attributes on the model first. Instead, do: \njavascript\nnew Events({id: yourDefinedEventId}).destroy();\nAlso, you can toss the otherwise statement. Catching a rejection and then blindly re-throwing an error within the handler isn't doing anything. The sync equivalent would be: \njavascript\ntry {\n  throw new Error();\ncatch (error) {\n  throw error;\n}\n. I have to assume you defined id as 181 elsewhere, otherwise this would fail to produce valid SQL. You don't need to  fetch the model before destroying it unless you need to check attributes on the model first. Instead, do: \njavascript\nnew Events({id: yourDefinedEventId}).destroy();\nAlso, you can toss the otherwise statement. Catching a rejection and then blindly re-throwing an error within the handler isn't doing anything. The sync equivalent would be: \njavascript\ntry {\n  throw new Error();\ncatch (error) {\n  throw error;\n}\n. Got it. In that case it would be helpful to see real code to try to diagnose what's going on.\n. Got it. In that case it would be helpful to see real code to try to diagnose what's going on.\n. Haha no prob. My first guess here is that req.params.id is the issue. Bookshelf cares about the difference between '1' and 1 (the latter is correct). @tgriesser has mentioned typecasting as a feature on the short list a couple of times. (Happy to help w/ that once you spec out the implementation Tim)\nAlso, there's a more promise-y way to do your control flow. I know promises can be a hurdle initially, but once you become comfortable with them, it's the only way you'll want to code. Bluebird is a fantastic library\u2014the best w/out question. If you return a promise in a promise handler, the next handler in the chain will resolve that promise. It's a tad harder when you need if statements, but it still works well. Your example above becomes: \njavascript\nreq.user.model.events().query({ where: { id: parseInt(req.params.id) }}).fetchOne({ require: true }).then(function(model) {\n  // if event is in the past, destroy it\n  if (model.start < +new Date()) {\n    return model.destroy();\n  } else {\n    return Promise.reject('start after now');\n  }\n})\n.then(function() {\n  res.send(200);\n})\n.catch(function() {\n  res.send(500);\n});\nOther than the type issue, your example isn't wrong. But chaining promises rather than nesting them is always a good idea. Otherwise there's a good chance you start swallowing errors or creating closures without realizing. \n. Haha no prob. My first guess here is that req.params.id is the issue. Bookshelf cares about the difference between '1' and 1 (the latter is correct). @tgriesser has mentioned typecasting as a feature on the short list a couple of times. (Happy to help w/ that once you spec out the implementation Tim)\nAlso, there's a more promise-y way to do your control flow. I know promises can be a hurdle initially, but once you become comfortable with them, it's the only way you'll want to code. Bluebird is a fantastic library\u2014the best w/out question. If you return a promise in a promise handler, the next handler in the chain will resolve that promise. It's a tad harder when you need if statements, but it still works well. Your example above becomes: \njavascript\nreq.user.model.events().query({ where: { id: parseInt(req.params.id) }}).fetchOne({ require: true }).then(function(model) {\n  // if event is in the past, destroy it\n  if (model.start < +new Date()) {\n    return model.destroy();\n  } else {\n    return Promise.reject('start after now');\n  }\n})\n.then(function() {\n  res.send(200);\n})\n.catch(function() {\n  res.send(500);\n});\nOther than the type issue, your example isn't wrong. But chaining promises rather than nesting them is always a good idea. Otherwise there's a good chance you start swallowing errors or creating closures without realizing. \n. You got it! If you're all set, can you close the issue?\n. You got it! If you're all set, can you close the issue?\n. Migrations are a knex feature. Mind opening an issue over there and closing this one? \nhttps://github.com/tgriesser/knex\n. Migrations are a knex feature. Mind opening an issue over there and closing this one? \nhttps://github.com/tgriesser/knex\n. Circular dependencies are an issue for an module system, not just Node. But yes, it is a Node / CommonJS problem. You might not see it with other DB libs because they have chosen to use a central model registry in the background without the dev having to think about it. For example, in Mongoose: \njavascript\nmongoose.model('Model', schema);\nMongoose instantiates the model, registers it on the module, and then resolves string dependencies for you, so you can do: \njavascript\nrelation: { type: mongoose.Types.ObjectId, ref: 'Model' }\nWhen that actually goes to use the relation, it looks up the model from the registry. \nWhen you require relations immediately in a Bookshelf model and then refer to them as variables in your relation definitions, those models will be empty objects if you have circular relations. When you use require directly in your relations, Node won't look for the related model until you actually call the relation. At that time the model is available. \nYou don't need to worry about performance issues here. Node caches modules so requiring something more than once it's identical to storing it as a reference and then accessing the reference. \n. Circular dependencies are an issue for an module system, not just Node. But yes, it is a Node / CommonJS problem. You might not see it with other DB libs because they have chosen to use a central model registry in the background without the dev having to think about it. For example, in Mongoose: \njavascript\nmongoose.model('Model', schema);\nMongoose instantiates the model, registers it on the module, and then resolves string dependencies for you, so you can do: \njavascript\nrelation: { type: mongoose.Types.ObjectId, ref: 'Model' }\nWhen that actually goes to use the relation, it looks up the model from the registry. \nWhen you require relations immediately in a Bookshelf model and then refer to them as variables in your relation definitions, those models will be empty objects if you have circular relations. When you use require directly in your relations, Node won't look for the related model until you actually call the relation. At that time the model is available. \nYou don't need to worry about performance issues here. Node caches modules so requiring something more than once it's identical to storing it as a reference and then accessing the reference. \n. store is a bad abstraction. If this is going to be a feature, all models should get stored at instantiation. And building a central model repo doesn't fit with the existing style of extending a base object. See Mongoose's implementation: \nhttps://github.com/LearnBoost/mongoose/blob/3.8.x/lib/index.js#L279\nThis is definitely something that should be done right. \n. The extend method could add the model to a models object on the Bookshelf instance. That's a bad idea too thought because it relies on you using Model.extend and would break Coffeescript's extend and regular prototype assignment without the convenience method. There's no easy hack that belongs in the lib. Obviously you could implement it yourself. \n. There's an issue with CS? Link? I meant that using a custom extend method was a problem because Coffeescript uses Subclass extends Class. CS or no CS, custom extend behavior is not a good idea IMO. You should be able to subclass with:\njavascript\nfunction Model() {};\nModel.prototype = new Bookshelf.Model();\nConvenience methods (like Model.extend) are fine, but breaking normal inheritance patterns is not. If there's going to be an abstraction on top of prototypes, it should be opaque and obvious. It might need to be a breaking change. Bookshelf.model(modelObj) would be ideal. \n. Found it: https://github.com/jashkenas/coffee-script/pull/3289\nInteresting. I write a decent amount of Coffeescript. The syntax is awesome. But if the suggestion is to use extended hooks for CS and .extend for JS, I have mixed feelings. Rails does this nicely because Ruby has native extend hooks.\nIt's the only way to do an ActiveRecord clone in JS and so I'm with @tgriesser on using it for that. But for a library where the primary purpose is not emulating a Ruby library I don't think that messing with Javascript prototypes is a developer-friendly way of doing things. \n. @johanneslumpe I don't use that right now. I'm using Bookshelf in JS and CS projects and use the convenience methods in both. An extend helper that assigns properties of an object to the prototype and then assigns the second arg to the constructor is OK in my book. That's just reducing boilerplate. Anything past there is going beyond the bounds of the prototype model. \n. I guess register is probably the most reasonable solution given existing functionality. \nThe better implementations I've seen (e.g. Mongoose) choose explicitly to construct from a schema, set of validations/hooks, etc. The constructor that takes a schema and creates 'Model' is just a regular function (mongoose.model('Model', schema);) You can export that if you'd like, but relations are expected to be defined using string names ('Model'). \nThe major advantage is that it significantly reduces confusion and documentation, since providing multiple different supported ways to create and link models is one more thing for new users to learn \u2014 and get wrong. All of us have the benefit of plenty of experience using Bookshelf. For a new user though, is it obvious which one of the following works?\n``` javascript\nBookshelf.register(Model, 'model');\n// #1\notherModel.relation = function() { return this.hasMany('Model'); };\n// #2\notherModel.relation = function() { return this.hasMany(Model); };\n// #3\notherModel.relation = function() { return this.hasMany(model); };\n```\nI would hope it's obvious that 3 is not right, but still. My preference for abstractions is that they be black boxes (or not exist). No one is going to read the source code and figure it out \u2014\u00a0they're going to waste an hour banging their head and then file an issue. \nI don't despise the idea of having a registry \u2014\u00a0I think given that database models are almost certainly going to have circular relations, it should absolutely exist. My issue is with making it optional. If users are expected to be using the registry (which they should), it should be non-obvious how to go about instantiating a model from scratch.\nAdmittedly though the more I've thought this through, the more I realize that there just needs to be an aggressive statement in the docs about closing every model file with a register and have register return the model:\njavascript\nmodule.exports = Bookshelf.register(MyModel);\n. Actually the best way to do it might be to use a lowercase model method, but have a little extra logic: \n- if (protoProps instanceof Bookshelf.Model): register it and return it\n- else construct the object with the logic you used\nI'd actually be cool with doing it this way. Still sticks to convention well (lowercase method, capital case class). I'd still like to put together some milestones before taking on a big change for a future release, but I'll happily volunteer to draft this functionality + tests.\n. I'm making it a priority to implement this. It's non-trivial to monkey patch this in and circular dependencies has been a cause of a lot of issues. Requiring models directly in relation functions adds a ton of unnecessary characters to model code. I'm opening a new issue devoted to this (#199) and closing this one.\n. @tgriesser Are you keeping a list of feature requests anywhere? Happy to help corral things into milestones and checklists. Keeping tons of uncategorized open issues as reminders is going to get hard to manage. It would also make it easier for people to identify where they should contribute PRs and where asking for a bigger feature is the right choice. \n. @tgriesser Are you keeping a list of feature requests anywhere? Happy to help corral things into milestones and checklists. Keeping tons of uncategorized open issues as reminders is going to get hard to manage. It would also make it easier for people to identify where they should contribute PRs and where asking for a bigger feature is the right choice. \n. Cool \u2014\u00a0I'm a contributor on knex but not here. Happy to try to take a preliminary stab at organizing some issues if you'd like. \n. Cool \u2014\u00a0I'm a contributor on knex but not here. Happy to try to take a preliminary stab at organizing some issues if you'd like. \n. Yes on knex handling DB calls to collect columns/types and Bookshelf having custom typecasting. The only thing I might change from your example is using a combo of primitives and config object rather than string references to types. So the example becomes:\njavascript\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  types: {\n    permissions: Bookshelf.types.JSON,\n    active: Boolean\n  }\n});\nThat's borrowed from Mongoose, btw, which I tend to cite pretty often since it's a pretty user-friendly lib. The advantage of primitives is that you don't have to memorize a series of custom abbreviations\u2014you only have to consult the docs for JSON.\n. Yes on knex handling DB calls to collect columns/types and Bookshelf having custom typecasting. The only thing I might change from your example is using a combo of primitives and config object rather than string references to types. So the example becomes:\njavascript\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  types: {\n    permissions: Bookshelf.types.JSON,\n    active: Boolean\n  }\n});\nThat's borrowed from Mongoose, btw, which I tend to cite pretty often since it's a pretty user-friendly lib. The advantage of primitives is that you don't have to memorize a series of custom abbreviations\u2014you only have to consult the docs for JSON.\n. As for issues, definitely the more that stays in GH the better. I use Asana and Trello for dev work a lot, but it doesn't translate especially well to OSS projects. Wiki is nice for changelogs, features, tutorials, etc. \nIRC is good for on demand support, but a message board ends up becoming a hassle. I'm already on GH so I'll drop in and address issues once or twice a day on projects I follow. A separate website would mean having to get email notifications for something new which I would be much less likely to do. \n. I guess if you're case insensitive then string types are fine combined with primitives. It would be helpful when it comes to testing though. If Bookshelf.types.Integer is a constructor for the integer type, it's easy to do an instanceof whereas that's going to be a pain with strings. Now you could do a little logic to make strings work:\njavascript\n_.each(model.types, function(type, fieldName) {\n  if (typeof type === 'function') {\n    typedVal = new type(untypedVal);\n  if (typeof type === 'string') {\n    typedVal = new Bookshelf.types[type](untypedVal);\n  } else {\n    throw new Error('bad type');\n});\n. Same, with mocha as well. Mocha is pretty aggressive about tearing down everything, even with open sockets. I did a little Googling and wasn't able to find any discussions of how Buster handles this. Are you definitely running your async tests properly? Make sure to always return your Bookshelf ops (e.g. return model.fetch()) so that the runner treats them as async.\n. Could have sworn I put a ref, but maybe I forgot. In any case, it's an exact double post of #195. I answered there. \nDon't worry, I wouldn't instant-close a ticket just because a similar question had been answered before :)\n. @tgriesser Thoughts on whether to alias? If you're for it I'll write it up this afternoon. Didn't mean to close this. \n. Fixes:\nNew Syntax\n- [x] Pending tests\n- [x] Passing tests\n- [ ] Documentation\nCollections\n- [x] Pending tests\n- [x] Passing tests\n- [ ] Documentation\nString Resolution\n- [x] Pending Tests\n- [x] Attempt passing tests\n- [x] Rule on whether to include\n. New set of commits supporting Bookshelf.model(name, [Model]) and Bookshelf.collection(name, [Collection]). Hoping to have some time tomorrow to look at string resolution. \n. I'll repurpose the explanation and move it out to a plugin. It's duplicating a require use case for sure, but it's not true that models would need to be required anyway. It does assume that you're requiring Bookshelf in your model files, which I suspect a lot of people are. Requiring a module inline by path every time is a pain, especially when you reference it several times. \nIn an ideal world everyone thoroughly understands circular dependencies.  But the reality is that the distinction between references and copies in JS is going to be lost on most people and they're just going to replicate the convention they see in the docs. Inline requires at least work though, even if it's ugly. \nBefore I pull this as a plugin I'm going to change things around a little bit. I'm going to have it just register module IDs rather than reference the model object itself. That way Node's module caching system gets used as expected rather than effectively caching all models immediately.\n. No, it would be. But it's basically just opting to attach the models to a shared object (Bookshelf, which is being required) rather than using Node's module system in the traditional sense. It's still 100% backward compatible since Bookshelf.model just returns the model and module.exports will still have the right value. A simple example just for clarity: \n``` javascript\n// file: a.js\nmodule.exports = {};\n// file b.js\nvar a = require('./a');\na.foo = 'bar';\n// file c.js\nrequire('./a').foo; // => 'bar'\n```\nRather than directly require each other, b and c talk to each other through a. This is pure sugar and easy to implement even without a formal plugin. It lets you stick to the popular style of declaring dependencies at the top.\nIf Model1 refers to Model3, this will break:\n``` javascript\nvar Model1 = require('./model1');\nvar Model2 = require('./model2');\nvar Model3 = Bookshelf.Model.extend({\n  model1: function() {this.hasOne(Model1);}\n});\n```\nBut this won't:\n``` javascript\nvar models = Bookshelf.models;\nvar Model3 = Bookshelf.Model.extend({\n  model1: function() {this.hasOne(models('Model1'));}\n});\n```\nIf I were to go even further and either build in string reference support directly or monkey patch methods in a plugin (which I won't do because it would be incredibly brittle), the syntax gets even nicer:\n``` javascript\nvar Model3 = Bookshelf.Model.extend({\n  model1: function() {this.hasOne('Model1');}\n});\n```\nI'm leaning heavily towards the string references side. It's not a breaking change\u2014it's just a matter of trying to resolve the model name into a require through the registry. Assuming I switch this over to storing module IDs rather than entire modules, it would look like:\njavascript\nif (typeof Target === 'string') {\n  Target = require(Bookshelf.model(Target));\n}\n. Reopening because I've refactored as a plugin and monkey patched all the relation methods (including morphTo which we'd forgotten and has a different signature). Updating the docs now.\n. @johanneslumpe Let me know if it fulfills all your hopes & dreams :)\n. Yessir. Commits squashed. \n. @tgriesser Good call. Done. \n. Per @tgriesser's comment I guess this should be a separate module. Can you open a new request without the file (but with the switch of config from js to json)?\n. withRelated adds queries to get your related objects. Given orders with customer_id, withRelated: ['customer'] would take care of fetching the customer with the specified ID and attaching it as a relation to the order. \nI'm not entirely clear on what you're trying to do here if you say you don't want the WHERE IN. The problem with your original snippet is that you're calling where after fetch. You might want to take a look at the query method for the right way to modify the original query: \nhttp://bookshelfjs.org/#Collection-query\nAlso, the debug flag could be helpful: \nhttp://bookshelfjs.org/#faq\n. @danschumann Really nice to hear that! I'm working on some big updates to the docs. Hit a pretty busy time with my company but I'm eager to share the plans. I think a key part of a \"userland by default\" policy (i.e. don't do every feature) is quality documentation / \"recipes\" for new users. Appreciate the participation!\n. Is it useful? Almost certainly not. But Bookshelf is also only trying to constrain a query with a limit of 1 for you. An object with attributes that match multiple DB rows also can't be strictly mapped to a single row. There's some responsibility on the user to ensure that objects actually map to the row they expect. \nI can actually think of a valid counterexample in this case. What if I modify the query like this?\njavascript\nModel\n  .forge()\n  .query(function (qb) {\n    qb.orderBy('id', knex.raw('RANDOM()'));\n  })\n  .fetch()\n  .then(function (model) {\n    // random model\n  });\nThat's a perfectly valid use case. Now if you want to resolve undefined when the original models has no attributes you need to inspect the query before it's sent and make sure it has constraints. \nRather than manually check for attributes.length === 0, you could certainly check inside fetching. If anything though you should be rejecting fetch if you want to enforce the presence of attributes, not returning undefined.\n. As the plugin ecosystem mature we can figure out a better place to put this stuff\n. @harry-zhang Doc refreshes are in the works for both bookshelf and knex. Love that you guys are using Bookshelf at Lob! I thought I'd have time last week to get this started but ended up running out of time. We have a separate repo now for the websites and written docs. They're going to eventually come out of this repo as the index.html file and become a series of structured markdown docs that get built using a static site generator to power the actual website. \nYou can follow that work if you're interested: https://github.com/bookshelf/bookshelfjs.org\n. Assuming your models are related you can do this within Bookshelf rather than writing SQL through knex:\njavascript\nvar Country = Bookshelf.Model.extend({\n  citizens: function() {\n    return this.hasMany(People);\n  }\n});\nThen perform your destroy on the collection (http://bookshelfjs.org/#Collection-invokeThen)\njavascript\ncountry.citizens().invokeThen('destroy');\n. True. Depends on how much needs to go on. If models register destroying events for validation, an invokeThen is your only option. A happy medium might be to use a Collection and create a delete method that constructs the query and invokes the models destroyed methods when the query resolves.\nMight also be helpful: https://github.com/tgriesser/bookshelf/issues/135?source=cc\n. Bookshelf determines whether a particular operation is an update or an insert based on whether it has an ID. (http://bookshelfjs.org/#Model-isNew) If you think about it, that makes sense\u2014in most cases you won't have an ID until you insert to the DB and the auto-incremented ID is returned. You can always override this behavior by expressly specifying a method in the save options, either insert or update.\njavascript\nnew Proxy.save(data, {method: 'insert'});\nIt would help to see your createId method in order to diagnose why it's not working. Keep in mind though that on expect an event handler, so unless createId returns a function, your code won't work. \nUnfortunately using a pre-defined ID means you have to manually specify any time you want to do an insert. There's no way for Bookshelf to decide whether a model has been persisted or not if it can't rely on the ID. \n. Really cool to see that you guys are using Bookshelf over at Lob btw. Would love to hear more about how you're using it. \n. That's awesome! \nYou're better of using initialize rather than constructor. initialize is called when an instance is constructed, but constructor is going to override that behavior. (https://github.com/tgriesser/bookshelf/blob/master/dialects/base/model.js#L32) If you do actually want to override the constructor, make sure to call db.Model.apply(@, arguments) inside your custom constructor function. (http://bookshelfjs.org/#Model-constructor)\nIn your example above you don't have idAttribute defined so your event handler won't do anything. Resolving the function calls into values, you'd be doing:\ncoffee\n@on 'saving', (model) ->\n  model.set undefined, 'prefix_' if true\nidAttribute should be defined on the Proxy prototype. If you'd like I'm happy to jump on a hangout and take a look directly. I'll be using you guys soon as a customer\u2014happy to pay it forward. \n. @tgriesser Yup, realized that when we were looking at it. We were able to figure it out. \n. An overhaul of the docs is something on the shortlist of priorities. Good idea though\u2014I'll definitely keep this in mind. I'm not sure whether blog is necessarily the best example. It's a common one for sure (e.g. Rails docs), but I happen to think it translates poorly to real world business logic. Nevertheless, the metaphor should always stay the same. Personally I'm partial to the book metaphor\u2014it fits with the project name!\n. Thanks!\n. Agreed. One I can immediately think of is EmptyResponse. That's the error message right now, but ideally it would be the type and the message would be more descriptive. That might actually be the only one for now. That's a common case where you're going to want to match in your API request handlers and provide a relevant response. Everything else is going to be the result of a user error or something that becomes a 500. \n. Just noticed @johanneslumpe raised the same exact example in #136. Closing that since we already have a few comments here. \n. I'll copy them over to collections as well. In an actual implementation it's not all that useful to have errors on the root object. Most of the time when you're matching against the error you're going to have the model constructor available, but almost never Bookshelf itself.\nA generic framework example: \n``` javascript\nvar Model = require('./model);\nfunction get (request, reply) {\n  new Model({id: request.params.id}).fetch()\n    .then(function (model) {\n      reply(model);\n    })\n    .catch(Model.NotFoundError, function(err) {\n      reply(404);\n    });\n}\n```\n. I'll copy them over to collections as well. In an actual implementation it's not all that useful to have errors on the root object. Most of the time when you're matching against the error you're going to have the model constructor available, but almost never Bookshelf itself.\nA generic framework example: \n``` javascript\nvar Model = require('./model);\nfunction get (request, reply) {\n  new Model({id: request.params.id}).fetch()\n    .then(function (model) {\n      reply(model);\n    })\n    .catch(Model.NotFoundError, function(err) {\n      reply(404);\n    });\n}\n``\n. Available in the sense of already in place, not that it's ever impossible to require bookshelf. And if you're doing transactions, you already do have it for sure. To me errors belong on the constructors that create them.\n. Yes, even then. I'm thinking of changing things around a little more though and using distinctModelNotFoundErrorandCollectionEmptyErrorobjects with similar behaviors. ForModelNotFound`, the default message could be: \njavascript\ninflection.transform(this.prototype.tableName, ['singularize', 'capitalize']) + ' not found.'\nAnd for collections: \njavascript\ninflection.transform(this.prototype.model.prototype.tableName, ['capitalize']) + ' not found.'\n. @johanneslumpe What do you think of this? I broke things out into two separate constructors: NotFoundError for models and EmptyError for collections. They're both attach to the base so they'd be available both as MyModel.NotFoundError and Bookshelf.Model.NotFoundError. \n. @johanneslumpe What do you think of this? I broke things out into two separate constructors: NotFoundError for models and EmptyError for collections. They're both attach to the base so they'd be available both as MyModel.NotFoundError and Bookshelf.Model.NotFoundError. \n. @johanneslumpe Managed to completely fuck up the tree but I think it's fully repaired. Any other errors you can think of before this gets docs? I'm pretty sure these are the only two that wouldn't be due to dev error (bad model refs, etc) that you'd want to match on.\n. The exception piece makes sense. Can you give an example of what you mean w/ the deferred errors?\n. That's a tough one. It definitely shouldn't crash the app if it's being called in withRelated or load. But I'd expect the following to throw synchronously:\n``` js\nvar BadModel = Bookshelf.Model.extend({idAttribute: null});\nvar Model = Bookshelf.Model.extend({rel: function () { return this.hasMany(BadModel); });\nModel.rel();\n```\nIn my mind the right way to do it is to make sure relation.init happens in a promise for things like fetch since it returns a promise. \nIn any case, I'll do the subclassing thing sometime tonight.\n. I'm guessing this might land with active-record\nhttps://github.com/tgriesser/bookshelf/tree/active-record\n. I'm guessing this might land with active-record\nhttps://github.com/tgriesser/bookshelf/tree/active-record\n. You got it. If you're interested in turning your implementation into a plugin, I can certainly look at a PR. Even for internal structure the plugin system is a good way to keep things clear/organized.\n. You got it. If you're interested in turning your implementation into a plugin, I can certainly look at a PR. Even for internal structure the plugin system is a good way to keep things clear/organized.\n. Yeah that's a tough one. The only way to make that work will be consolidating into one listener or at least pushing all the behavior that requires sequential order into a single listener. So:\njavascript\nthis.on('saving', function (model, attributes, options) {\n    // manipulate model\n   return asyncValidate();\nIt shouldn't be too messy\u2014just put all the model mutation logic in appropriate functions elsewhere and call them in the listener. It'll be easier to test that way anyway. \n. That's an interesting idea. I still much prefer the approach of \"no order is guaranteed.\" That's not going to change for the event listeners themselves (i.e. they'll be wrapped in Promise.all through trigger-then. It makes some sense to have an order of operations on different events though. And a lifecycle doc, a la Hapi's. You want to use creating and updating to mutate the model and saving to do async things. But what if someone wants to do things the other way around?\nThat's the thing about changes like this. It reduces your boilerplate, but it might increase someone else's. In this case I don't think there's a good reason to assume your use case is the most popular, so I'd have to say no. @tgriesser?\n. Yeah I understand what you're looking for. Are you writing the post slug differently in creating and updating?\n. Just FYI, promises are a nicety for error handling and control flow with checkit, but they don't explicitly lend themselves to Bookshelf in any particular way. I'm starting to use joi more because it plugs in nicely with hapi. Throwing inside a promise has the same practical effect of returning a rejection. The only difference between using checkit and a validation lib that throws would be:\n``` javascript\n// promises\nreturn checkit.run(object).then(function () {\n  // validated, do other things\n});\n// sync\n// validate is a fn that runs the rules\nreturn Promise.try(validate, object, this).then(function () {\n  // validated, do other things\n});\n```\nDon't get me wrong, I love promises as much as anyone. But in this case switching from validate.js to checkit isn't not going to change the solution. @sebgie wants to run a series of sync operations. Looking back at my original answer the asyncValidate line isn't even relevant. It's just a series of synchronous setters and then synchronous validators. \nIt's safe to assume all the handlers on creating/updating will run before the saving ones if all handlers on both are synchronous. Wrapping them in a promise is going to force them to wait until the next tick but they're still going to run in order once fired.\nThe final word for now is that the only way to enforce order on events is to keep things in a single listener. If we revisit the lifecycle events and break up pre-save into more steps in the future, that could change. \n. No problem. If you take a crack at it and want me to take a look at it, just let me know. \n. Yup, agreed that the promise structure is just helpful in general. When I mentioned adding more events, I had built-in/plugin-based validations in mind, i.e. preValidate and postValidate. \n. You can try a custom query to make things idempotent, but this will probably require you to not only use knex, but also to write different raw queries for different DBs. Postgres added writable CTEs in v9 so it's possible to do an upsert there. MySQL will require a totally different query. That's the only way you're going to fulfill all your requirements\u2014creating a new user with an email and password hash that matches an existing one has to be a noop on the DB level. \n. I think this was more a case of wanting to do things the right way than practical need. The issue is that Ghost has a normal multi-user database schema but for now only chooses to support a single user. A unique key constraint on email takes care of the more obvious issue of double registration if you manged to hit the user endpoint twice. Seems like the Ghost team found a workable temporary solution: \nhttps://github.com/TryGhost/Ghost/pull/2128\n. I think this was more a case of wanting to do things the right way than practical need. The issue is that Ghost has a normal multi-user database schema but for now only chooses to support a single user. A unique key constraint on email takes care of the more obvious issue of double registration if you manged to hit the user endpoint twice. Seems like the Ghost team found a workable temporary solution: \nhttps://github.com/TryGhost/Ghost/pull/2128\n. The attrs parameter is admittedly not very useful as is. But what would be most helpful for us in thinking about how to repurpose it would be to hear your actual use case.\n. I'll go in and fix this later if need be, but please take a look at the Travis build and fix the integration tests on the error message. \n. This is probably a good case to add to #221. Testing on error messages is definitely brittle, but this might be a case for a custom, catchable error. It's not the worst thing to test on error messages, but I'll typically only do it with a regex (e.g. /method: 'insert'/ rather than the full message. \n. fetched should always be called unless you pass the {required: true} flag to fetch. Are you seeing something different?\n. Yeah nevermind you're right. All of the past-tense events depend on the operation completing successfully. For now you should monkey-patch the save, destroy, and fetch methods:\njavascript\n['save','destroy','fetch'].forEach(function (method) {\n  Model.prototype[method] = function () {\n    return Model.prototype[method].apply(this, arguments).finally(function () {\n      this.trigger('post' + method);\n    });\n});\nI'd like to change around the event nomenclature at some point to make things more flexible but this should give you what you want for now. \n. Good catch. This should be a pretty quick fix. It's easier to patch Sync.prototype.del but this actually belongs here: https://github.com/tgriesser/bookshelf/blob/master/dialects/base/model.js#L160\nLiterally a one or two line fix + tests. I'll take care of this later today unless you want to submit a PR. \n. Agreed. It'll at least have parity w/ the other methods for now. \n. Well that was fast!\n. Currently there's no automatic table generation. Knex, the SQL query builder that powers Bookshelf, has a migration utility and can construct your tables. It's really just a difference in philosophy between Bookshelf/Knex and the many other JS libraries out there that have some sort of ORM or SQL component. Bookshelf models don't know anything about your database schema. \nIf you wanted to you could certainly store a schema object on your Model's prototype to describe the fields, but implementing that would be left to you rather than handled automatically by the library. \nThe nice thing is that you could write it yourself in an hour, versus trying to write a one size fits all solution that would be brittle and complicated. \n. Yeah, best bet is definitely to just assume your schema is ready. Creating your schema should be part of your build/deploy process rather than something you do when your application starts. The migration utility has a CLI that can help you create and run migration templates\u2014you just fill in the actual operations.\n. Yeah, best bet is definitely to just assume your schema is ready. Creating your schema should be part of your build/deploy process rather than something you do when your application starts. The migration utility has a CLI that can help you create and run migration templates\u2014you just fill in the actual operations.\n. Agreed! If you're stuck on anything, don't hesitate to ask. Not having everything built in as a feature can make things a little more intimidating early on. In the end, good event hooks and concise/clear source code is the real key to productivity with a library. Happy to help you work through common operations (validation, typing, migrations, etc.) if you get stuck.\n. Agreed! If you're stuck on anything, don't hesitate to ask. Not having everything built in as a feature can make things a little more intimidating early on. In the end, good event hooks and concise/clear source code is the real key to productivity with a library. Happy to help you work through common operations (validation, typing, migrations, etc.) if you get stuck.\n. No events will be fired on the model per #241. The collection should have its fetched event triggered though. I'll look into it. \n. No events will be fired on the model per #241. The collection should have its fetched event triggered though. I'll look into it. \n. I was wrong that fetched should be fired. No events are fired on eager loads. \n. Alexander,\nIt's frustrating to be berated and disrespected for software we write and support for free. Please don't do it again. \nUnless Alice is on Github, please don't speak in hypotheticals either. It's not helpful to us, nor to you. \nThere are numerous closed tickets about the challenges of firing events on collection members and relations by default. I'd suggest reading them if you're looking to better understand this issue. We are certainly not looking to spite you. There are good reasons for the decision to not have 100% event coverage everywhere you might expect them. I'm working on better documenting and explaining why. \nIf you'd like to share specific use cases and your full code, we can certainly help you find the best way to implement things. \n. There's also often times a language (and partly cultural) barrier. I guess it's a testament to your english @bogus34 that the comment came off as standoffish rather than just overly direct as non-native speakers tend to sound. That said, you'll find that sarcasm comes off poorly in writing, especially with a group of online strangers. \nThe issue was closed because, like the other very similar one you filed (#241), our current position is that it's not supported. \nThere's a similar issue at work here w/ prioritizing maximum usability over first-glance expectations (again, docs would help). If you're using a fetched event to append some extra data, then universal events is precisely what you want. Go ahead and fire them manually. But what happens if you're using it to do some validation or authorization? How do you handle that on the root model? By adding automatic behavior, it actually makes things harder for people to use. I probably want to handle an error on a dependent model separately, but event listeners called within the default fetch behavior don't provide any way for me to do that. All of a sudden the promise chain incorporates all exceptions from related models and distinguishing the source becomes very difficult. This particular case gets better with #221, but there are many others. \nfetch has to have unique considerations that save and destroy don't. Collections don't support the latter two, except by invokeThen, which makes it more apparent that you should be implementing your own solution. fetch is called on models and collections and triggers side effects. Any time you're firing side effects internally it becomes very difficult to override that behavior without monkey patching the public API. That's why the answer right now is that you're responsible for firing the side effects yourself. \nIf you'd like to post specific examples of what you're struggling to implement, please feel free to open a new issue. Otherwise I'm going to bow out of the discussion here. \n. Right now collection.fetch only fires a fetched event for the collection itself. The models are never actually being called with fetch so I'm not sure it's entirely appropriate to fire events. \n@fritx your method is going to create collection.length unnecessary DB calls so I'd highly recommend against using it. \n@bogus34 If you can share what you're actually doing in your fetched handler(s) I can try to help you find a way to make things work. \n. Right now collection.fetch only fires a fetched event for the collection itself. The models are never actually being called with fetch so I'm not sure it's entirely appropriate to fire events. \n@fritx your method is going to create collection.length unnecessary DB calls so I'd highly recommend against using it. \n@bogus34 If you can share what you're actually doing in your fetched handler(s) I can try to help you find a way to make things work. \n. A collection is a convenient way to populate and manage a group of models, but not doing operations on each model is pretty consistently implemented. You have invokeThen available for calling model methods no save method on a collection. Right now there's no magic for collections\u2014reads can be done automatically, but things like saves and destroys should use custom queries. The problem here is that collections can potentially have many models and automatically firing lots of event listeners could have fairly serious performance implications. In the case of a cache, you should cache the whole collection or bulk insert all its members. Going and doing that individually is going to take a long time. \n@fritx While that will work, I recommend against it. It's not a good idea to have Model.prototype.fetch sometimes fetch the model and other times just run some side-effects. It's brittle and will potentially create headaches for you with future API changes in Bookshelf. \nAnd yes, if you add custom collection behavior you'd need to use that collection explicitly in relations where the model is on the right side of an n-to-many relationship rather than allowing a collection to be implicitly created from the model. \nIt would be really helpful to see actual code here. Firing fetched events on every model in a collection is easy and I'll look into it at some point. But I'd generally consider it an anti-pattern. Happy to help figure out the right way to do whatever you need. \n. A collection is a convenient way to populate and manage a group of models, but not doing operations on each model is pretty consistently implemented. You have invokeThen available for calling model methods no save method on a collection. Right now there's no magic for collections\u2014reads can be done automatically, but things like saves and destroys should use custom queries. The problem here is that collections can potentially have many models and automatically firing lots of event listeners could have fairly serious performance implications. In the case of a cache, you should cache the whole collection or bulk insert all its members. Going and doing that individually is going to take a long time. \n@fritx While that will work, I recommend against it. It's not a good idea to have Model.prototype.fetch sometimes fetch the model and other times just run some side-effects. It's brittle and will potentially create headaches for you with future API changes in Bookshelf. \nAnd yes, if you add custom collection behavior you'd need to use that collection explicitly in relations where the model is on the right side of an n-to-many relationship rather than allowing a collection to be implicitly created from the model. \nIt would be really helpful to see actual code here. Firing fetched events on every model in a collection is easy and I'll look into it at some point. But I'd generally consider it an anti-pattern. Happy to help figure out the right way to do whatever you need. \n. Roughly correct. There's performance issue, but also the general principle that it's way easier for you to add custom behavior than to strip out something we enforce. If a collection.fetch triggers load cycle events on all models, it's pretty hard to prevent that if you don't need it. There'd have to be an options flag and that's a nightmare to document and generally bad practice. \nWhereas if you want to add in this behavior, it's easy. Here's how you and @fritx should be doing it:\njs\ncollection.fetch()\n  .then(function (collection) {\n    return collection.models;\n  })\n  .map(function (model) {\n    return model.triggerThen('fetched');\n  })\n  .return(collection);\nSee the Bluebird API docs for more on functional programming w/ promises. You should make sure your fetched handlers only contain basic sync operations otherwise you'll slow down your application significantly. I'm starting to map out an FAQ/recipes sections for the revamped docs w/ common problems. I'll include this there. \n. Roughly correct. There's performance issue, but also the general principle that it's way easier for you to add custom behavior than to strip out something we enforce. If a collection.fetch triggers load cycle events on all models, it's pretty hard to prevent that if you don't need it. There'd have to be an options flag and that's a nightmare to document and generally bad practice. \nWhereas if you want to add in this behavior, it's easy. Here's how you and @fritx should be doing it:\njs\ncollection.fetch()\n  .then(function (collection) {\n    return collection.models;\n  })\n  .map(function (model) {\n    return model.triggerThen('fetched');\n  })\n  .return(collection);\nSee the Bluebird API docs for more on functional programming w/ promises. You should make sure your fetched handlers only contain basic sync operations otherwise you'll slow down your application significantly. I'm starting to map out an FAQ/recipes sections for the revamped docs w/ common problems. I'll include this there. \n. You got it! I highly recommend taking a 15 min read through with the Bluebird API. It's a really amazing library and functional transformations (maps, filters, reducers, etc.) of promises can be extremely powerful. \n. You got it! I highly recommend taking a 15 min read through with the Bluebird API. It's a really amazing library and functional transformations (maps, filters, reducers, etc.) of promises can be extremely powerful. \n. See https://github.com/tgriesser/knex/issues/251#issuecomment-41174836 for the proposed implementation. It's a todo for 0.6. \n. Can you provide a little more context as to what you're trying to do? fetch.call(this, options); is identical to fetch(options);.\n. Can you provide a little more context as to what you're trying to do? fetch.call(this, options); is identical to fetch(options);.\n. > this in fetch of a model/collection seems to be the instance itself, isn't it?\nCorrect. Are you having trouble with the file you posted? There's some unnecessary lines, including the event handlers resolving this. \n. > this in fetch of a model/collection seems to be the instance itself, isn't it?\nCorrect. Are you having trouble with the file you posted? There's some unnecessary lines, including the event handlers resolving this. \n. If you remove the handlers you'd need to also remove the listener registrations themselves otherwise you're going to trigger an error. You could also just leave the handlers as empty functions. Event listeners can modify the model, the operation's options, or throw/return a rejected promise to cancel the operation. Resolving a value won't do anything.\u00a0\u2014\nBen Drucker\nOn Sun, Feb 16, 2014 at 1:03 AM, fritx notifications@github.com wrote:\n\nGet it, thanks\nBut am I going to remove all those fetching/creating-like handlers, or remove the return statements inside only?\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/issues/243#issuecomment-35178274\n. If you remove the handlers you'd need to also remove the listener registrations themselves otherwise you're going to trigger an error. You could also just leave the handlers as empty functions. Event listeners can modify the model, the operation's options, or throw/return a rejected promise to cancel the operation. Resolving a value won't do anything.\u00a0\u2014\nBen Drucker\n\nOn Sun, Feb 16, 2014 at 1:03 AM, fritx notifications@github.com wrote:\n\nGet it, thanks\nBut am I going to remove all those fetching/creating-like handlers, or remove the return statements inside only?\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/issues/243#issuecomment-35178274\n. In any event handler returning a value won't do anything. Similarly, resolving a value has no effect. The only difference between Bookshelf event listeners and generic Backbone (or Node) event listeners is that they're wrapped in a promise. If the promise is rejected (either by throwing in the handler or returning a rejected promise), the event is halted. Regardless, the actual value never matters. Your fetch patch method looks fine\u2014nothing wrong there.\n. In any event handler returning a value won't do anything. Similarly, resolving a value has no effect. The only difference between Bookshelf event listeners and generic Backbone (or Node) event listeners is that they're wrapped in a promise. If the promise is rejected (either by throwing in the handler or returning a rejected promise), the event is halted. Regardless, the actual value never matters. Your fetch patch method looks fine\u2014nothing wrong there.\n. Hmm. Personally this is not something I'd use since I'd prefer to write quality tests than have the schema magically discovered. Typecasting might be a little tough since MySQL and Postgres data types aren't exactly the same. If not for typecasting, what would this be used for?\n. Hmm. Personally this is not something I'd use since I'd prefer to write quality tests than have the schema magically discovered. Typecasting might be a little tough since MySQL and Postgres data types aren't exactly the same. If not for typecasting, what would this be used for?\n. Makes sense. Typecasting is not that hard, just a lot of tests. Definitely would lean towards two separate plugins. Typecasting should probably eventually be core since people using IDs from request params and having things break because of strings is pretty common.\n\nOn Sun, Feb 16, 2014 at 4:10 PM, Johannes Lumpe notifications@github.com\nwrote:\n\n@bendrucker Could be used for automatically cleaning invalid attributes (it does that right now) Typecasting could be implemented using a basic map for available types and their js-counterparts.\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/pull/244#issuecomment-35212621\n. Makes sense. Typecasting is not that hard, just a lot of tests. Definitely would lean towards two separate plugins. Typecasting should probably eventually be core since people using IDs from request params and having things break because of strings is pretty common.\n\nOn Sun, Feb 16, 2014 at 4:10 PM, Johannes Lumpe notifications@github.com\nwrote:\n\n@bendrucker Could be used for automatically cleaning invalid attributes (it does that right now) Typecasting could be implemented using a basic map for available types and their js-counterparts.\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/pull/244#issuecomment-35212621\n. You can use model.parse to update your timestamp attribute with any formatting you'd like. Assuming you don't have identical column names for your timestamps in all tables, you'd do this:\n\njs\nModel = Bookshelf.Model.extend({\n  parse: function (attrs) {\n    attrs.timestampAttr = dateFormatterFn(attrs.timestampAttr);\n  }\n});\nEDIT: Ignore this, see below\n. You can use model.parse to update your timestamp attribute with any formatting you'd like. Assuming you don't have identical column names for your timestamps in all tables, you'd do this:\njs\nModel = Bookshelf.Model.extend({\n  parse: function (attrs) {\n    attrs.timestampAttr = dateFormatterFn(attrs.timestampAttr);\n  }\n});\nEDIT: Ignore this, see below\n. Yes, JSON does not have a Date type. My understanding was that he was seeing ISO-8601 dates from MySQL and wanted to parse them to a different format in his models. Guess I left out that a format would also be required to get things back. \nBut looking into the node-mysql docs though I'm noticing that it does coerce dates into actual date objects and back. So ignore the parse suggestion. Override toJSON like this:\njs\nModel = Bookshelf.Model.extend({\n  toJSON: function () {\n    var attrs = Bookshelf.Model.prototype.toJSON.apply(this, arguments);\n    attrs.myTimestampAttr = moment(this.get('myTimestampAttr')).format('YYYY-MM-DD HH:mm:ss');\n    return attrs;\n  }\n});\nI'm using moment.js to do formatting in this example, but you could do it without it if you really wanted to.\n. Yes, JSON does not have a Date type. My understanding was that he was seeing ISO-8601 dates from MySQL and wanted to parse them to a different format in his models. Guess I left out that a format would also be required to get things back. \nBut looking into the node-mysql docs though I'm noticing that it does coerce dates into actual date objects and back. So ignore the parse suggestion. Override toJSON like this:\njs\nModel = Bookshelf.Model.extend({\n  toJSON: function () {\n    var attrs = Bookshelf.Model.prototype.toJSON.apply(this, arguments);\n    attrs.myTimestampAttr = moment(this.get('myTimestampAttr')).format('YYYY-MM-DD HH:mm:ss');\n    return attrs;\n  }\n});\nI'm using moment.js to do formatting in this example, but you could do it without it if you really wanted to.\n. It's normally a toss up as to whether you use a library for something small or just write it yourself. Don't make that mistake with dates. Moment will save you tons of frustration. \n. It's normally a toss up as to whether you use a library for something small or just write it yourself. Don't make that mistake with dates. Moment will save you tons of frustration. \n. If that's your exact snippet it's not working because of your handlers. You can't do this:\njs\nconsole.log.call(null, 'log this');\nThat's effectively what's happening in your example. Instead do: \njs\nsessions.fetch().bind(console).then(console.log).catch(console.log);\nIn the original case your transaction should be rejected because the console.log call should throw with a TypeError. There might still be an issue to fix here but let's at least get the easy part fixed. \n. If that's your exact snippet it's not working because of your handlers. You can't do this:\njs\nconsole.log.call(null, 'log this');\nThat's effectively what's happening in your example. Instead do: \njs\nsessions.fetch().bind(console).then(console.log).catch(console.log);\nIn the original case your transaction should be rejected because the console.log call should throw with a TypeError. There might still be an issue to fix here but let's at least get the easy part fixed. \n. Can you debug and post the queries? \nhttp://bookshelfjs.org/#faq\n. Can you debug and post the queries? \nhttp://bookshelfjs.org/#faq\n. I did a little research and it turns out there's nothing that can be done about this (also it doesn't have to do with Bookshelf). I wrote up a more direct test with knex. SQLite blocks on transactions and so while a transaction is active all queries must be run inside it. With MySQL or Postgres a non-transacting query will use another connection\u2014SQLite can't do that. It locks at the file level, not connection.\n. Doubly confirmed. Updated the gist with an example that passes\u2014the commit is fired after a 100ms delay and then the non-transacting query resolves. So I guess the answer is that if you need transactions and have any sort of serious query volume, use Postgres because SQLite is going to cause major issues. \n. Closed b/c #247 is inherent to SQLite and not a Knex problem\n. Per your first question, take a look at the syntax from #75. \nFor compiling the cars into a single array, you want a reducer. \n. You should refactor this with promises to preserve the default behavior. Also, using relations could cause unexpected behaviors since it will fire fetched on all models as opposed to just those that were eagerly loaded. Try this instead:\njs\nthis.on('fetched', Promise.method(function (model, attributes, options) {\n  if (!(options && options.withRelated)) return;\n  return Promise.map(options.withRelated, function (relation) {\n    return model.related(relation);\n  })\n  .then(function (related) {\n    return (related.models || [related]);\n  })\n  .map(function (model) {\n    return model.triggerThen('fetched', model, model.attributes);\n  });\n});\n. I'm most of the way done on writing an authorization lib which is why I thought to do this. An options interface eliminates the need to do this nastiness: \nhttps://github.com/valet-io/bookshelf-authorization/blob/57eb1b803486565bac914d1fa831286f90aadf8d/lib/bookshelf-authorization.js#L12\n. I'm most of the way done on writing an authorization lib which is why I thought to do this. An options interface eliminates the need to do this nastiness: \nhttps://github.com/valet-io/bookshelf-authorization/blob/57eb1b803486565bac914d1fa831286f90aadf8d/lib/bookshelf-authorization.js#L12\n. :+1: \n. :+1: \n. You might find mocha-as-promised helpful btw. \nIt basically patches the mocha runner and if it returns a thenable it appends a .done(done, done).\n. @bavidar and I talked about this yesterday\u2014@tgriesser's snippet is my recommendation. Type is a static for each Model prototype. The difference between using @attributes and super is that super is calling the default toJSON and then modifying its output whereas referencing @attributes is essentially reimplementing it. \n. @bavidar and I talked about this yesterday\u2014@tgriesser's snippet is my recommendation. Type is a static for each Model prototype. The difference between using @attributes and super is that super is calling the default toJSON and then modifying its output whereas referencing @attributes is essentially reimplementing it. \n. If we're having a concision battle, if @type then json.object = @type can become json.object = @type since JSON will toss the undefined value.\ncoffee\nclass BaseModel extends Model\n   toJSON: ->\n     json = super\n     json.object = @type\n     json\nBen, eking out the win by 14 characters :confetti_ball:\n. If we're having a concision battle, if @type then json.object = @type can become json.object = @type since JSON will toss the undefined value.\ncoffee\nclass BaseModel extends Model\n   toJSON: ->\n     json = super\n     json.object = @type\n     json\nBen, eking out the win by 14 characters :confetti_ball:\n. @connrs If you're running a custom implementation right now it would be really helpful to see that code. \n. Agreed \u2014\u00a0would also need a similar change to collections. I'm mainly curious to see whether anyone's attempted \"cascading\" soft deletes with related models.\n. @olso Not sure if Tim has done anything with it. If you need it now you should patch as illustrated above.\n. Some knex changes in the pipeline will make the easier. But for now I'm pretty sure your best bet is just to do a regular query and not use the relation. \n. If that's the exact content of your totalGroups function you need to return the promise.\n. For your first question, try something like:\njs\ntotalGroups: function() {\n  return Group.collection().query('where', 'parent', '=', 0).count('*');\n }\nGroup should be a collection.\nFor your second, you can't use a relation where the foreign key is not uniform. So that would look like: \njs\ncontacts: function () {\n  return Contact.collection().query(function (qb) {\n    qb.where('uid_by', '=', this.id).orWhere('uid_by', '=', this.id);\n  }.bind(this));\n. Agreed. I got an email notification asking about pagination\u2014guess you deleted it. For now you'd use limit and offset in knex. I have a working pagination method in use\u2014I'll open source it as a plugin once the dust settles on knex 0.6. \n. Can you post the full code for your first question? Same for your second. There's nothing wrong with either snippet. It's whatever's calling them that's causing the issue.\n. Versions are not the issue here. \nRight now Bookshelf only supports using actual relations with load/withRelated. You're gonna need to run those queries separately individually as function calls. How you do that really depends on the structure of your application and models. \nI'm also noticing that my example a few posts back had a typo and used uid_by twice rather than uid_by OR uid_to. The problem is that you're using a schema that has two potential foreign keys. There's really no way at present for Bookshelf as an ORM to handle that kind of situation. \nFor your virtuals, two things. First, it's breaking because your function call is returning a promise and not the actual object. The second issue is that your requesting async data in your virtual which you can't do. Virtuals are being called by toJSON and toJSON is synchronous. Avatar should be a relation that's handled on fetch or with load. You could then use a virtual to copy some data to a different place on the object, e.g. return contact.related('avatar').get('url');\n. @babsonmatt Supporting using arbitrary queries in for relations would be fairly difficult to implement so that's unlikely to happen in the near future. You could pretty easily build your own implementation to handle relational queries you write yourself. You'd have to handle all the eager loading/pairing behaviors but it's very doable.  It's worth mentioning that setting a distributions property won't work if you intend to do anything with the model other than serialize (e.g. save, run validations, etc.).\n. I'd say this falls on the \"optionitis\" end of the spectrum. It would be really easy for an end user to implement this themselves by hooking into the fetching event, right?\n. Closing this since it's not clear what's actually going on here. Fe\n. Per #124 and #44, right now the timezone is the server's local time. This is often non-ideal and the ability to use UTC times makes way more sense. Those issues have been cold for a while but when there's an update it'll be in there. \n. Per #124 and #44, right now the timezone is the server's local time. This is often non-ideal and the ability to use UTC times makes way more sense. Those issues have been cold for a while but when there's an update it'll be in there. \n. Right now there isn't, in large part because the registry plugin is just that\u2014a (optional) plugin. There would be no way to add a truncateAll method because by default Bookshelf does not keep track of your models. \nIn the mean time, you could just create a small helper to do it. Also you'll want to use mocha-as-promised to avoid the need to always call .done(done) at the end of a promie chain. You'll see from my example that there is a cleaner way to do this, at least control flow-wise. \njs\nvar truncateAll = function () {\n  return Promise.map(Bookshelf._models, function (model) {\n    return model.prototype.tableName;\n  })\n  .then(Bookshelf.knex)\n   .call('truncate');\n};\nToss that in a test helpers file or something. Then in your tests:\njs\nbeforeEach(truncateAll);\nAlso check out the Bluebird API reference for explanations of the sugar methods I'm using to clean things up.\n. Right now there isn't, in large part because the registry plugin is just that\u2014a (optional) plugin. There would be no way to add a truncateAll method because by default Bookshelf does not keep track of your models. \nIn the mean time, you could just create a small helper to do it. Also you'll want to use mocha-as-promised to avoid the need to always call .done(done) at the end of a promie chain. You'll see from my example that there is a cleaner way to do this, at least control flow-wise. \njs\nvar truncateAll = function () {\n  return Promise.map(Bookshelf._models, function (model) {\n    return model.prototype.tableName;\n  })\n  .then(Bookshelf.knex)\n   .call('truncate');\n};\nToss that in a test helpers file or something. Then in your tests:\njs\nbeforeEach(truncateAll);\nAlso check out the Bluebird API reference for explanations of the sugar methods I'm using to clean things up.\n. Polymorphic associations do exactly what you're trying to replicate here\n. Check out model.load and model.related: \nhttp://bookshelfjs.org/#Model-load\nhttp://bookshelfjs.org/#Model-related\n. Sorry, misunderstood the question. You could specify the relations on the  model itself, and regexing fn.toString would also work. Another option would be to put a relation property on the methods themselves:\njs\nvar relation = function (fn) {\n  fn.relation = true;\n  return fn;\n};\nThen you'd just wrap all your relation methods in relation and then filter prototype properties where the value is a function with property relation === true. \n. Definitely open an issue over at knex for the schema builder. For storing literals as hstore it might be fairly trivial right now with proper format/parse functions. Have you tried using it? What happens?\n. I don't use hstore so I can't really speak to what pg does to parse it or format. I can say though that you'll most if not all of the schema flexibility benefits of hstore with a json column. I use them regularly and it works quite without any special handling from Bookshelf.\n. Using events to handle this kind of data is problematic when it comes to dealing with relations. \nAlso worth a read: https://github.com/brianc/node-postgres/issues/140\n. The nice thing about JSON is that it's pretty easy to keep portable. You can query it with Postgres but in other DB you can just stringify it and parse it on the way out in user land. That's pretty important given knex/Bookshelf's status as mostly DB agnostic.\n. No\n. A few things here. First, there's no need to specify that you want to update in your saves. save will automatically determine whether to call knex.insert or knex.update based on model.isNew. model.isNew, in turn, is determined by whether or not the model has an id defined. Yours do, so specifying the save options is redundant. \nmodel.format modifies the model attributes before they're sent off to the DB driver but does not actually affect the model itself. So you're never actually setting the password attribute to null (it should be undefined btw). Subsequent fetch calls are probably including the password on the query which doesn't match, although I'd like to see the debug queries to try to diagnose why that's not printing to the console. \nThis is an easy fix\u2014this logic belongs in a saving event handler, not format. That'll eliminate the need to synchronously encrypt the password. Basically you just want to check whether password is defined on saving. If so, hash the password, set the proper hash and salt attributes, and set the password attribute to undefined. \n. That's correct. Limit parse and format to things like change property casing (snake <=> camel) or typing. \n. That's correct. Limit parse and format to things like change property casing (snake <=> camel) or typing. \n. thanks!\n. thanks!\n. @gitSauced Have you read the wiki entry for the registry plugin? There's a pretty good explanation of both the problem (unrelated to Bookshelf itself) and how the plugin solves it. If you're still having trouble you can open a new issue. \n. Right now events are only fired on the direct target model when fetched, not from collections and not on eager loads. You can track this in #253.\n. Right now events are only fired on the direct target model when fetched, not from collections and not on eager loads. You can track this in #253.\n. It does not. You'd be responsible for implementing something like this through model events. \n. It does not. You'd be responsible for implementing something like this through model events. \n. It's one of many old open issues that are low priority so you're probably better off just writing it yourself. It's probably a good plugin case regardless.\n. It's one of many old open issues that are low priority so you're probably better off just writing it yourself. It's probably a good plugin case regardless.\n. Good catch. My thought is to just pull that out as it's unnecessary info. \n. Good catch. My thought is to just pull that out as it's unnecessary info. \n. You'd need to use knex.raw. \n. You'd need to use knex.raw. \n. It would be helpful to know exactly what response you're hoping for rather than PHP functions. Not sure what you're looking to do. \n. It would be helpful to know exactly what response you're hoping for rather than PHP functions. Not sure what you're looking to do. \n. I know nothing about vertx so I really can't speak to how it works and whether a Node library needs any changes to work within it. If it can run Javascript and supports Node sockets then it should work fine. Although I should point out that it's unlikely to be worth the time to worry about all of this, \n. That's a feature in MS SQL but no other RDBMSes as far as I'm aware. It's also usually a very bad idea with significant perf costs. Why do you want to do it?\n. Completely misread the original. Ignore my comment. \n. Just to avoid a steeply net negative contribution here:\n- Multiple queries can call SELECT FOR SHARE, but FOR UPDATE locks are exclusive\n- You can't block other writes \u2014\u00a0a lock just makes them wait until it's released\n- You should be particularly careful about locking, especially with multiple rows. It will kill your DB response times if used too much\n- You may not need to use either \u2014 the database is smart enough to handle things like incrementing a counter via a single query in a regular old transaction\n. invokeThen is a shortcut for:\njs\ncollection.invokeThen = function (method) {\n  var args = _.rest(arguments);\n  return Promise.map(collection.models, function (model) {\n    return model[method](args);\n  });\n};\nYou're just calling the given method on each model by passing it to collection.invokeThen. \nYou need to be careful about making sure to return promises inside promise handlers and not creating permanently pending promises. \nCan you post your current code?\n. I know all this sounds tempting, but you should drop the idea now. Synchronous is never the right idea. I read this twice and I honestly still don't understand what you are actually trying to do.\n. > Not understanding why introducing a database or a technology like nodeJS suddenly means everything must be async?\nBecause under the hood you're hitting sockets. There are no synchronous APIs for sockets in Node. There is no possible way, for example, to make a synchronous HTTP request. \n. You got it. Ruby is usually the counterexample to Node I use to discuss, as Tim mentions above, ecosystems where async is enforced by best practice rather than by necessity. It's almost essential to dive in with EventMachine to build an application that survives under any sort of load. But since it's not required by the language, you end up with weird bugs and performance issues as well as difficulty integrating 3rd party libraries. Callbacks/promises/generators/coroutines/events are all just different flavors of the same evented architecture that Node provides. \nIt's admittedly not as easily as saying that lines 1, 2, 3 run in order of top to bottom. But because async is \"native,\" the async interfaces you'll find in Node packages are dramatically more refined than anything you'd see in other popular languages. \n. For now you'll need to drop into knex. You could certainly add this as method on your collection base.\njs\ncollection.query().count('*').then(handleCount);\n. If you're already calling fetch then by all means use that. Definitely don't do that if you don't need the models themselves.\n. Just use the third argument (morphValue): \nhttp://bookshelfjs.org/#Model-morphOne\n. No need to include the files or export it publicly from Bookshelf \u2014\u00a0you can still traverse named CommonJS packages like so:\njs\nvar ModelBase = require('bookshelf/dialects/sql/model');\n. It's up to you to save the related model. You could add a post-save hook for your user model to check whether the setting model had changed and call save on it if so.\n. Sure, like this:\njs\nmodule.exports = Bookshelf.Model.extend({\n  tableName: 'users',\n  initialize: function () {\n    this.on('saved', function (model) {\n      if (model.related('setting').hasChanged()) {\n        return model.related('setting').save();\n      }\n    });\n  }\n});\nYou could extend this pattern as far as you wanted, including passing a withRelated option to save with the same syntax you would with fetch and then parsing it in an event handler:\n``` js\nvar Promise = require('bluebird');\nmodule.exports = Bookshelf.Model.extend({\n  tableName: 'users',\n  initialize: function () {\n    this.on('saved', function (model, attributes, options) {\n      if (options.withRelated) {\n        if (!Array.isArray(options.withRelated)) options.withRelated = [options.withRelated];\n        return Promise.map(options.withRelated, function (name) {\n          if (model.related(name).hasChanged()) {\n            return model.related(name).save();\n          }\n        });\n      }\n    });\n  }\n});\n``\n. I'm assuming @babsonmatt's original example is not the exact use case. I can help more if you share exactly what you're doing, including where you're calling Bookshelf models (oftentimes that'll be within a route handler in an HTTP framework. \n. :thumbsup: \n. This terminology get pretty muddy. When it comes to collections of data in ORMs lazy loading often refers to \"dumb queries\" where you iterate through a collection and fetch the relation individually for each model. In that senseloadis still a form of eager loading. If you can figure out a way to succinctly and meaningfully explain how Bookshelf is intelligently optimization related model queries please open a new request against master.\n. Yes, knex provides [schema methods](http://knexjs.org/#Schema) and a [migration API + CLI](http://knexjs.org/#Migrate). \n. Can you share exactly what the schema is you're working with? Hard to say what to do without more info. In general the rule of thumb with an ORM is to try to work within its boundaries wherever possible. \n. Yeah this is going to pretty much be impossible to do with relations, since you're not relating to the primary key. You should build custom queries to this using knex. Iteratively callingdestroy` on a list of models will be slow.\n. This is documented in knex but I made a note in the Bookshelf docs explaining that. Btw, the documentation site is just the index.html file at the project root. No compilation. \n. Hi @coolaj86 and many thanks for the contribution\nI went through your page and fixed some anti-patterns in there. I'm going to close this but feel free to chime in on this issue if you don't understand why particular things I changed are the best way to do things. \nAlso, it would be great if you could replace the SQL file with knex migrations or even just raw schema builder calls.\n. The problem is that the syntax you're describing above can't be supported with the current model structure. Since relations are lazily evaluated (i.e. when you specify them with withRelated or load), Bookshelf doesn't know how your models are related until you tell it initialize the relational method. There is no way to know that blog corresponds to a relation as opposed to a property. We could assume that blog is a related object because typeof Post.prototype.blog === 'function', but this has the potential to break existing code. It's certainly not a good idea to have columns with the same name as relations, but right now that possibly exists. \nA good way forward with this would be a plugin. The model constructor has an options argument. You could set ModelBase.prototype.contructor to parse options.withRelated. You'd:\n1) Strip the properties specified there from attributes\n2) Set the attributes and instantiate a model by applying the original constructor\n3) Call model[relationName]() for each options.withRelated to get at the relatedData\n4) Set the right foreign keys on the parent model\n5) Call model.related for each options.related\nDefinitely no small task, but happy to help if you're willing to take it on. \n. Composite keys aren't supported right now (see #93). This seems like something where you should be using a join table, but regardless you can always run a custom query.\n. Nope, the docs are correct. belongsTo is used where the foreign key is a column in the model. For example, for Post with id and author_id and Author with id, Post belongsTo Author. \n. Guess it's just a matter of how you choose to read it. It makes sense to me that one-to-one translates to \"one post belongsTo one author\u2014\u00a0and its inverse: \"one author has many posts.\" I'm not super familiar with nomenclatures other libraries/languages use to describe this and my limited impression was that it was the same. If you can think of a way to concisely make this clearer, by all means send a PR. \n. Hang on \u2014\u00a0you're saying that savingusertries to write auser_idvalue tousers? Can you [debug](http://knexjs.org/#Builder-debug) that query and confirm?\n. Renaming this to more accurately reflect what's clearly a bug. @babsonmatt, can you do me a favor and double check whether the related user has anidproperty? Looks from the SQL output like it does but it would be helpful to have confirmation. That would just mean there's an _extra_user_idproperty that doesn't belong and not anything missing. \n. Thanks!\n. What iscallback`?\n. Hey Ron,\nFor the foreseeable future that will remain an exercise for user in format. While it's definitely a trivial addition to add a useUnderscore property, the general opinion of the project (as well as my personal one) is that easy changes that can be made with a few lines of user code don't need to be baked in. \nHaving columnName on a model property wouldn't really work, since tableName is part of the model prototype. There's no obvious place to put it. Bookshelf does not know about your database or table schema. You're always welcome to provide a custom mapping of attributes to column names and then parse it in format. You could do something like that in a BaseModel class and then have all other models extend from that. That way the feature works exactly as you want and takes only a few lines of code to implement. \n. Looks like the exact same issue as #349. Closing this and will track it down there. Not sure how this popped up as it's a rather serious bug. Although for what it's worth, the above should be rewritten. Nested promises are almost never correct.\njs\nnew User({id:1}).fetch({withRelated: ['team']})\n  .then(function(user){\n      return user.related('team').set({name: 'Developers'}).save();\n  })\n  .then(console.log);\n});\n. Will work on it today, hopefully should be a quick fix. I'd consider\n  this a critical bug.\u00a0 --- Ben Drucker Valet.io\n  973-985-6070 On May 16, 2014 at 10:06 AM Martin Angelov\n    notifications@github.com wrote:\nThanks! Weirdly I didn't see the original issue. Hope this gets\nresolved. \u2014 Reply to this email\n    directly or \n      view it on GitHub.\n. I think this is a docs issue and that options.query is a knex query. Try options.query.where'('type', '=', 'book') and see if that works.\n. @ricardograca's answer is spot on \u2014\u00a0that's the most correct way to do this\n. Polymorphic relations need a type and id. So your photo table would have imageable_type and imageable_id. If those values were site and 0, respectively, photo.imageable() would return a Site with id = 0. Since you're not passing an imageable_type, Bookshelf doesn't know what model you want.\n. Bookshelf just delegates the connection to knex so that's odd...\nCan you confirm that the defaults work? The intent is really that you configure those databases to be password-less as specified in the config rather than changing the config to fit the DB.\n. Please post your config that you're handing to Bookshelf.initialize so we can see how you're setting up\n. Feel free to send a PR with a note about the property specified idAttribute being parsed/formatted like any other property before id is assigned. \n. That's exactly what hasChanged does :)\n. Where would this help you avoid a query in the real world? hasChanged becomes true any time an attribute is set that's not a noop. A brand new model is seen as having changed. Doesn't matter that its values might be already persisted. \n. Hmm. Read through all that and I think I at least understand the gist of what you're doing. \nI'd actually contend the opposite on built in versus userland in this case. Detecting changes is tricky because you need to fetch the entire model first in order to really know for sure whether a set is creating values that will result in a change to the database. That's a decision you may be able to make based on a whole host of complicated factors specific to the business logic of your app. Getting it to work in a way that is sensible for everyone would be tough. \nOftentimes it's not a bad idea to just try to keep operations idempotent and ignore the possibility of unnecessary writes. But unless it's a huge issue, it's often better to just accept the additional response time and address the issue comprehensively in the future with some sort of caching strategy. \nRe: consulting, I'm happy to spend some time digging in. Email's on my profile. \nAlso, be careful with your conditional in your example. You may be releasing zalgo.\n. Looks good, thanks!\n. Yup, 100% on all counts. Anything falsy will be ignored in attributes. Just remember with major versions to check new options in case something baked in collides with one of your custom options. \n. Yeah \u2014 falsy comment is related to attributes (see the lines I linked above).\nFor options you can do anything you want. It's entirely up to you how you choose to inspect the options object and take action on it. Keep in mind that lifecycle events are fired with trigger-then so you can return a promise from an event handler in order to do something async. \nAssuming you're using bcrypt or something similar, this question has been asked a handful of times in case you're curious to see your options. I gave a mostly well-written example here, although it adheres to some bad conventions from the OP in that issue: https://github.com/tgriesser/bookshelf/issues/192#issuecomment-32554243\nChiefly I would avoid using password as the column name for your hashed password. Either that or call the plain text pass something else, like raw_password. \n. Nope \u2014\u00a0in true JS fashion you have all the parts and are asked to assemble them yourselves. I'd recommend: \n- Bookshelf (obviously)\n- knox (for s3)\n- gm (ImageMagick)\n. Should almost certainly work if you do it the other way around (Bookshelf first, Knex second).\nThat said this is a bug. @tgriesser \u2014\u00a0noticed that this change snuck in on bd6d4c82ef9296858b1620136a7f7d3e49c2223d. I disagree with the move \u2014\u00a0I don't see knex as a peerDependency to Bookshelf, at least the way config works now. Why the change?\n. Almost asked whether the intent was to deprecate object onfig. Makes perfect sense then.\n. Re Tim's comment in #404 \u2014\u00a0I'd argue for making this the default in 0.9 an option as it is here for 0.8. \n. Re Tim's comment in #404 \u2014\u00a0I'd argue for making this the default in 0.9 an option as it is here for 0.8. \n. No but you can track it at https://github.com/tgriesser/knex/issues/54. It would be appreciated if you could share your exact use case there. This is something I'm pretty sure I've never needed even once and I believe Tim mentioned the same somewhere. That's not to say it's invalid \u2014\u00a0would just be helpful to have a hint of why people want it and how they'd use it (versus a bunch of :thumbsup: in the thread). \n. Can you be a little more detailed about your schema? Normally Bookshelf figures out whether a model is new based on an id.\n. Don't agree with this one. Picking an arbitrary name is more confusing and I've never seen any project choose to do documentation like that. Constructor names and other objects often conflict with more abstract software concept names. Doing things like wrapping in , capitalizing where appropriate, and careful sentence structure help deal with it. If you find specific instances where things could be clear then by all means send a PR. \nClosing since I'm pretty confident others will agree, otherwise feel free to reopen.\n. Unless I'm missing something significant, why aren't you just doing the initial fetchAll on a tags model or collection {withRelated: 'items'}?\n. Got it. Kinda depends on what you're optimizing for. Custom query would make sense here since you want to join from name to tag ID to item ID. \n. Yeah the combo of the where-in and distinct could be a pain. Still, do it though collection.query so you don't have to manually cast the data.\n. See #44 for UTC timestamps. Non-issue for API design though, because JSON.stringify(new Date()) returns a UTC string.\n. Weird, looks like the following would handle this:\nhttps://github.com/tgriesser/bookshelf/blob/master/lib/model.js#L190\n. How would that be different than the current behavior? All an event-emitter pattern does is populate an _events object for you.\n. I think it would be a mistake to deviate from the emitter pattern because there may come a time where pulling out the Backbone dependency is good for Bookshelf. There would already be some gain with using native events for integration with domains.\n. Yeah it definitely makes a difference. The various relation methods just create a model/collection with appropriate relatedData (foreign keys, query, etc.)\napppointment.schedule() returns the related model, whereas appointment.related('schedule') calls appointment.schedule and stores its return on appointment.relations. If appointment.schedule returns undefined then you wouldn't get a related model.\n. You should be doing promisification with bcrypt so that you're not blending node-style callbacks and promises. \nSyntax here is fine though. Are you sure you're using the latest version?\n. Bookshelf doesn't interact in any way with your data. You can always add custom behavior to your model prototypes with parse and format. Postgres has an extremely useful JSON datatype with query support. It's one of the reasons I use PG exclusively over MySQL. node-postgres will take care of stringification and parsing automatically in most cases. \nIn MySQL, you'd be responsible for using parse and format to use JSON's parse and stringify methods on the appropriate attributes. \nRe: pivot attributes, go ahead and open another issue on that for discussion. I think enough people would prefer they not be included by default in JSON to merit a breaking change to the default in a future release. \n. Bookshelf doesn't interact in any way with your data. You can always add custom behavior to your model prototypes with parse and format. Postgres has an extremely useful JSON datatype with query support. It's one of the reasons I use PG exclusively over MySQL. node-postgres will take care of stringification and parsing automatically in most cases. \nIn MySQL, you'd be responsible for using parse and format to use JSON's parse and stringify methods on the appropriate attributes. \nRe: pivot attributes, go ahead and open another issue on that for discussion. I think enough people would prefer they not be included by default in JSON to merit a breaking change to the default in a future release. \n. With top notch hosted options like Heroku Postgres for managed and and Amazon RDS for more IaaS-style deployments it's also really easy to use. JSON and hstore are great as well. Querying inside JSON/hstore data isn't the fastest but it works fine and it's super convenient. You get the best open source SQL db plus one of the biggest advantages of NoSQL. Tables most of the time, but schemaless where you want that flexibility. \nFor now, format and parse are called when sending attributes to or reading them from database driver. So you're doing things the right way.\n. With top notch hosted options like Heroku Postgres for managed and and Amazon RDS for more IaaS-style deployments it's also really easy to use. JSON and hstore are great as well. Querying inside JSON/hstore data isn't the fastest but it works fine and it's super convenient. You get the best open source SQL db plus one of the biggest advantages of NoSQL. Tables most of the time, but schemaless where you want that flexibility. \nFor now, format and parse are called when sending attributes to or reading them from database driver. So you're doing things the right way.\n. @matanster It is mentioned there http://knexjs.org/#Installation-pooling\n. Missed the second half of your comment. I think the note about how to destroy the pool is sufficient. I think it's reasonable to expect that users understand that open sockets cause processes to stay open. Plenty of people won't even need to think about this if they're using a CLI to run tests that automatically exits the process (like Mocha's CLI). The only case where the average person might need to destroy the pool is for tests. \n. Depending on the case you could just check model.relations\n. parse runs on read, format on write. Can you please post code if you're seeing unexpected behavior?\n. No worries!\n. You're looking for morphTo. \nYou'll probably find it easiest to express a database schema first and then determine the right set of association methods to construct the right queries rather than the other way around. You want a table 'members' with columns 'member_id', 'group_id' and 'member_type' (which can be 'group' or 'person'). The morph* methods will take care of constructing appropriate queries for that type of table. \nFeel free to reopen if this isn't what you were trying to create. \n. Sure. I'll give an example with Sinon but it should translate reasonably closely for other tools. If you're using Sinon you should check out sinon-as-promised (by me :smile:) for some extra sugar. \njs\nsinon.stub(Book.prototype, 'fetch').resolves({id: 0, name: 'Moby Dick'});\nnew Book().fetch().then(function (book) {\n  expect(book.get('name')).to.equal('Moby Dick');\n});\nI usually try to avoid stubbing prototypes where possible since you have to be super careful to clean up after yourself. Another module under test almost certainly makes use of that method and if you forget to restore your sub you'll probably break tests. Sinon's sandboxing helps, but I like to avoid the problem entirely via something like this (using Mocha):\n``` js\nvar Book = Model.extend({\n  requireFetch: function (options) {\n    return this.fetch(_.extend(options, {\n      require: true\n    }));\n  }\n});\ndescribe('#requireFetch', function () {\nvar book;\n  beforeEach(function () {\n    book = new Book();\n    sinon.stub(book, 'fetch').resolves(book);\n  });\nit('gets a book', function () {\n    var options = {};\n    return book.requireFetch(options).then(function (book) {\n      expect(book).to.equal(book);\n      expect(book.fetch).to.have.been.calledWith(options);\n    });\n  });\n});\n```\nThat way you avoid the need to restore stubbed methods since you're always starting on a fresh instance. Not always possible, but it's a nice pattern.\nMileage may vary obviously depending on your toolset but it's all standard JS testing techniques. No particular trick.\n. So technically knex just passes connection params directly to the underlying database driver. Maria uses db where node-postgres and node-mysql both use database. Honestly I think node-mariasql should alias the property. If for some reason they object a knex workaround would make sense.\n. I think it makes more sense to propose a PR with node-mariasql. They more than likely didn't think to maintain parity with the other popular Node SQL libs. The knex documentation is pretty clear that the connection options are passed directly to the driver. Usually that's not an issue since MySQL and PG share the usual options and users can elect to pass through custom stuff. \n. Thanks but this isn't correct. on is expecting a function to be passed in. Calling the function returns a promise. \n. I don't understand what we need to do here. \n\nA simple update to the above logic should make updates and deletes work with composite keys.\n\nA PR would be great. Otherwise, a more readable and code-oriented explanation of what's breaking and the code you've used to fix it at present would be helpful.\n. Interesting idea. Assuming everything's configured properly there should be negligible difference between the two methods. And with https://github.com/tgriesser/knex/pull/372 it should be pretty easy.\n. You can't create relations with arbitrary queries \u2014\u00a0a good chunk of an ORM is the code that takes explanatory terms like \"one to many\" and turns them into code. Of course you can always implement that logic yourself if you need truly arbitrary queries on a case by case basis. What you might find helpful is the ability to modify the query builder for a related model/collection, like so:\njs\nModel.extend({\n  tableName: 'sites',\n  administrators: function () {\n    return this.hasMany(require('./user')).query(function (qb) {\n      qb.where('admin', true);\n    });\n  }\n});\n. :thumbsup: from me\n. Are you on Windows?\n. Hmm because there's definitely not a general issue. Not sure what would be up there. If you do a fresh clone & npm install does it persist?\n. +1 for the default. Now that I think about it there's no breaking change for other DBs but a nice gain for Postgres. Yet another reason to use it. \n. I've never seen this either, but it couldn't hurt to change array comparison tests to check against length and deep member equality.\n. If you want multiple join tables without their data your best bet is just to write the query using the knex API.\n. If you want multiple join tables without their data your best bet is just to write the query using the knex API.\n. So there's technically two requests here \u2014\u00a0through references an actual model. The more join tables you have the more I'm inclined to assume that join tables will not have any actual data but references. Requiring models there would just add noise, unless of course there's other data you'd want. Care to weigh in on your use cases @ongmingyang and @rarkins? \n. So there's technically two requests here \u2014\u00a0through references an actual model. The more join tables you have the more I'm inclined to assume that join tables will not have any actual data but references. Requiring models there would just add noise, unless of course there's other data you'd want. Care to weigh in on your use cases @ongmingyang and @rarkins? \n. Mind posting a full request body with the actual business logic (as opposed to an abstract \"model\")?\n. Would be great to just do the svgs. That whole directory is npmignore-d but 8k of SVG would be a lot easier on people cloning/pulling than 3MB. \n. @ryanking8215 That's going to be fairly inefficient to go grab and load potentially thousands of records just to get the count. I'd started to write a pagination plugin before Bookshelf 0.7 and Knex 0.6. I'll revisit that when I have a chance.\n. Can you share the queries being run by passing debug: true when initializing Bookshelf?\n. Can you share the queries being run by passing debug: true when initializing Bookshelf?\n. Can you please address the failing test as well as provide a test for the new behavior?\n. Can you please address the failing test as well as provide a test for the new behavior?\n. Looks great. If you don't mind, a line (one sentence tops) in the docs would be great.\n. Looks great. If you don't mind, a line (one sentence tops) in the docs would be great.\n. Nah it's okay. Thanks!\n. Nah it's okay. Thanks!\n. Thanks. Can you squash as well?\n. Thanks. Can you squash as well?\n. :thumbsup: \n. :thumbsup: \n. Awesome! \n. Awesome! \n. At the moment this isn't possible because Bookshelf needs to know more about a relation than just the queries required to build it. However, it looks like you'd be able to do what you need by changing the query. An example of this is provided in the relation type docs: \njs\nStory.where({id: 2}).fetch({\n  withRelated: ['comments.tags', 'comments.author', {\n    'author': function(qb) {\n      qb.where('status', 'active')\n    }\n  }]\n})\n.then();\nYou could call query methods to restrict the columns returned and apply where statements in there.\n. At the moment this isn't possible because Bookshelf needs to know more about a relation than just the queries required to build it. However, it looks like you'd be able to do what you need by changing the query. An example of this is provided in the relation type docs: \njs\nStory.where({id: 2}).fetch({\n  withRelated: ['comments.tags', 'comments.author', {\n    'author': function(qb) {\n      qb.where('status', 'active')\n    }\n  }]\n})\n.then();\nYou could call query methods to restrict the columns returned and apply where statements in there.\n. Glad you were able to get what you wanted in a relatively few LOC. After seeing your example I get what you're after better now. The only challenge is an array of numbers vs. objects. A big goal of the Bookshelf and Knex APIs is giving users the tools to concisely build custom behavior.\n. Glad you were able to get what you wanted in a relatively few LOC. After seeing your example I get what you're after better now. The only challenge is an array of numbers vs. objects. A big goal of the Bookshelf and Knex APIs is giving users the tools to concisely build custom behavior.\n. Are you on the latest version? Sounds related to #430.\n. Are you on the latest version? Sounds related to #430.\n. http://knexjs.org/#Builder-whereRaw\n. Right now the answer is to just use knex. There are some tricky issues when it comes to handling this in batches, including raising lifecycle events on the models (performance vs. consistency) and what to do when some models in the collection are new and others aren't. If you think you can tackle an implementation that would work consistently we'd happily take a PR. \n. If you wanted to patch Bookshelf.Collection to handle the general case:\njs\nBookshelf.Collection.prototype.insert = function () {\nreturn Promise\n  .bind(this)\n  .then(function (models) {\n    return knex.insert(this.toJSON({shallow: true})).into(this.tableName()).returning(this.idAttribute());\n  })\n  .map(function (id, index) {\n    this.at(index).set(this.idAttribute(), id);\n  })\n  .return(this);\n};\nUntested but the general pattern is sound\n. Well not exactly, but that's the beauty of implicit, recursive toJSON calls from JSON.stringify:\n\nIf an object being stringified has a property named toJSON whose value is a function, then the toJSON method customizes JSON stringification behavior: instead of the object being serialized, the value returned by the toJSON method when called will be serialized. (MDN)\n\nSo a lot of times you can just return a model object (in a web server framework for example) because toJSON will be implicitly called. Now that I think about it though, this isn't happening for database inserts. So you will have to explicitly call toJSON. Updating the above example to reflect.\nThe example makes a bunch of assumptions though, including that you're not doing formatting/parsing of attribute names. Mileage may vary.\n. If you're finding the ORM defaults to be more of a burden than a help, why use the models at all? You can also always patch the existing methods.\n. Yeah I specifically don't use camelized attributes because I find it to be a huge cognitive + development burden to go DB (snake) => server model (camel) => JSON (snake) => client model (camel). If you're doing client side IDs you really just need to set {method: 'insert'} in your POST handlers.\n. Can you please post some test examples?\n. Yeah that was my assumption. If you don't return the promise the test will automatically pass. Other promise libs will just swallow the errors without notice. Bluebird waits one event loop tick and by default logs to stderr, although you can tell it to throw the unhandled rejection. \n. This can just become a noop right?\n. Cool. Will patch when I have a chance. Event semantics can be a little tricky with stuff like this but it should be a relatively easy fix. \n. > My guess is that somewhere in the toJSON function typeof checks dates as objects instead of as dates and doesn't check if they have their own toJSON already.\nhttps://github.com/tgriesser/bookshelf/blob/master/lib/base/model.js#L86-L102\nNot the case. Also I use dates all the time and don't see this. Any idea what else might be causing it?\n. Don't think it should matter whether you use timestamp or timestamptz. You can just check the date object though and peek at its toJSON.\n. I use the exact same setup without issue. And it looks fine when you stringify it. \n. :) no worries\n. Side note: Mocha supports promises. You should be returning your promises and not manually calling done. \n. Mind adding 'attached' and 'detatched' as well for parity?\n. Leaving this for @tgriesser to merge just in case there's any reason this was omitted\n. Good catch!\n. To run tests you just need to have Postgres and MySQL running with a database 'bookself_test' available. SQLite is in memory so there's no setup required.\n. Can you see whether this is just MySQL? Just put SQLite in the array on https://github.com/tgriesser/bookshelf/blob/master/test/integration.js#L32\n. In that case just go ahead and push and let Travis handle it at least for this PR\n. In that case just go ahead and push and let Travis handle it at least for this PR\n. Just remove MySQL from that array if you can't get a working server running and don't commit that change. Mocha isn't really doing anything that you need to care about. It's just calling a bunch of callbacks and trapping exceptions. \n. Just remove MySQL from that array if you can't get a working server running and don't commit that change. Mocha isn't really doing anything that you need to care about. It's just calling a bunch of callbacks and trapping exceptions. \n. I'm more inclined to address Dash first since that parses a structured format as opposed to scraping HTML. I get that scraping makes it easier to add support without the project's buy in. But the reverse is also true: a project that wants to actively support DevDocs needs to jump through a ton of hoops to maintain compatibility. They do have a requests board. For now adding Bookshelf and Knex there and discussing on the board makes the most sense. \nI've committed in the past to working on the website + docs. Now that the APIs are settling a little bit I'll follow through on that this fall. As that progresses, I'd be happy to work with you or anyone else who wants to integrate with DevDocs. \n. No reason why they couldn't use an identical format. As mentioned above I can offer guidance on docs but if at some point the markup changed I assume that breaks DD.\n. The docs are just a huge index.html file right now. I'd like to change this so there's a little more structure and it's not such a chore to hunt down and update things. Linked to their instruction above but here's an example of a scraper: \nhttps://github.com/exlee/d3-dash-gen\nAt a quick glance it's XML + SQLite + HTML/JS. Haven't actually done a docset myself though. \n. Collections use the tableName from the model prototype. In theory methods that instantiate a collection from a model could explicitly overwrite it as you've indicated. Using different tables for a single model constructor seems like it's violating the concept of an ORM. Can you offer a little more detail on what you're trying to do?\n. Right \u2014 can't say I've ever seen anyone do this but you can override the tableName for an individual model. But since fetchAll instantiates a collection, you'll lose that. \nWhat I'm wondering is why you'd want to do this. I think copying the tableName for fetchAll from an instance would be inconsistent with the API even if it solves this particular case. Happy to try to better understand your actual problem here though and see if there's a better way to approach it.\n. I'm still not clear on what that means. It sounds like you don't actually want models. In that case you can just use knex, the cross-database SQL query builder that powers Bookshelf. \n. What you've included though doesn't use any features of Bookshelf. You could just as easily do:\njs\napp.get('/:tableName', function (req, res, next) {\n  knex(req.param('tableName'))\n    .select('*')\n    .then(function (rows) {\n      res.send(rows);\n    });\n});\n. Assuming you can't properly sort using an orderby, you can do something more complex using events and extension.\njs\nbookshelf.Collection = bookshelf.Collection.extend({\n  initialize: function () {\n    this.on('fetched', collection.sort, collection);\n  },\n  sort: function () {\n    this.models.sort(this.sorter);\n  },\n  sorter: function ($1, $2) {\n    if ($1.get('prop') < $2.get('prop')) return -1;\n    if ($1.get('prop' > $2.get('prop'))) return 1;\n    return 0;\n  }\n});\n. So ignore my original rec. I'm not a Backbone guy and had never seen/touched that feature. Your solution looks good.\n. Seems like that is the behavior in Backbone. Mind opening a PR with a failing test?\n. Enjoy! Certainly not urgent since I can't say I've heard anyone ask about this. \n. This looks like a Postgres error. Mind posting the queries that get generated?\n. tableSchema sounds like it would make sense. Can you copy and paste the queries from above and show me what they should look like? Can't say I've used custom schemas in PG so any info you can offer on how this should be implemented would be a huge help.\n. Hard to tell because of the omissions in the example but I think this is fixed by #437, to be released soon\noptions override behaviors but are never required. So new Model({id: 1}).isNew() is false. If you call model.save it should trigger an update query but if you go purely on a provided option it would overwrite the timestamp.\n. Agreed on being more user friendly. Looping through the arguments is unnecessary. load already handles a single string and an array of strings. So there just needs to be one more case where arguments.length >= 2 and typeof arguments[1] === 'string'. \n. Agreed on being more user friendly. Looping through the arguments is unnecessary. load already handles a single string and an array of strings. So there just needs to be one more case where arguments.length >= 2 and typeof arguments[1] === 'string'. \n. You could handle it in format\n. You could handle it in format\n. @ryanking8215 Visibility patches toJSON so that would not work.\n. @ryanking8215 Visibility patches toJSON so that would not work.\n. @coolaj86 If you do a little more looking into why it's getting parsed into an empty object I'd love to hear findings. Have a feeling that this is a node-postgres thing.\n. @coolaj86 If you do a little more looking into why it's getting parsed into an empty object I'd love to hear findings. Have a feeling that this is a node-postgres thing.\n. No question \u2014 my impression in this case was that it was a more pressing issue of \"this odd type is breaking.\" Not fetching the column at all would be ideal but in the short term just deleting it in format (or I guess ideally parse so it's never included in an update anyway) is a reasonable solution. \n. No question \u2014 my impression in this case was that it was a more pressing issue of \"this odd type is breaking.\" Not fetching the column at all would be ideal but in the short term just deleting it in format (or I guess ideally parse so it's never included in an update anyway) is a reasonable solution. \n. Yeah you definitely can't use belongsToMany for same-table relations. hasMany might work. \n. Yeah you definitely can't use belongsToMany for same-table relations. hasMany might work. \n. Not sure what you're suggesting. belongsToMany implies a join table. It shouldn't support this type of relation if that's what you're thinking.\n. Not sure what you're suggesting. belongsToMany implies a join table. It shouldn't support this type of relation if that's what you're thinking.\n. No worries. I think it's just generally challenging to keep straight. The relation terms imply an (n|one) to (n|one) relation but that's sometimes ambiguous. I think belongsTo and hasMany are pretty clear in their basic cases, but belongsToMany, through, don't lend themselves as well to clear n/one descriptions. \nI think the best way to address this would be recipes focusing on how translate SQL parlance into Bookshelf methods. I think it's a more achievable goal to keep the ORM API reasonably sized when you expect a reasonable understanding of SQL and provide easy access to the builder (knex). Making things simpler for people who don't know what a foreign key is will always be a moving target. Whereas \"here's an example of a comments table with nested replies and its associated model definition\" is quite reasonable. \nTagging this for docs \u2014 will be looking at a ground up rewrite of the content this fall.\n. No worries. I think it's just generally challenging to keep straight. The relation terms imply an (n|one) to (n|one) relation but that's sometimes ambiguous. I think belongsTo and hasMany are pretty clear in their basic cases, but belongsToMany, through, don't lend themselves as well to clear n/one descriptions. \nI think the best way to address this would be recipes focusing on how translate SQL parlance into Bookshelf methods. I think it's a more achievable goal to keep the ORM API reasonably sized when you expect a reasonable understanding of SQL and provide easy access to the builder (knex). Making things simpler for people who don't know what a foreign key is will always be a moving target. Whereas \"here's an example of a comments table with nested replies and its associated model definition\" is quite reasonable. \nTagging this for docs \u2014 will be looking at a ground up rewrite of the content this fall.\n. withRelated: ['pages', 'pages.words']. Cheers!\n. withRelated: ['pages', 'pages.words']. Cheers!\n. There are examples of this as well as other relationship in the docs:\nhttp://bookshelfjs.org/#Model-relation-types\n. There are examples of this as well as other relationship in the docs:\nhttp://bookshelfjs.org/#Model-relation-types\n. The way you're doing it you can just call query before calling fetch. query can be called without argument to return the builder or with a callback which will be called with the builder. You want the latter. You can also access the query using the withRelated option on fetch by passing in an object. Here's a relevant example from the docs:\njs\nStory.where({id: 2}).fetch({\n  withRelated: ['comments.tags', 'comments.author', {\n    'author': function(qb) {\n      qb.where('status', 'active')\n    }\n  }]\n}).then(...\n. It does!\n. Cheers!\n. The first field is actually attached to the collection prototype. You just can't override format and parse because collections don't have those methods. Their models do. Curious what you're trying to do that this would have come up.\n. The above example isn't really possible. Query calls are passed to knex which doesn't handle things like variable casing. You're going to have to use snake case if your DB is snake cased in your queries. You can certainly set Foo.prototype.parse and Foo.prototype.format in order to have the actual data that's fetched come back in whatever case you'd like.\n. Not sure we need new method names \u2014\u00a0save and destroy on collections would be fine to the extent that those queries can be built reliably for normal use cases. \n. Correct, as documented. Most of the time you'll just want to update the query by passing an object or a callback. If for some reason you wanted the builder and then intended to manually run the query, that behavior allows it without the need for an additional API method. \n. No, that's right. That's a perfect example of a time when you want the query to be returnable (count) versus just modifying the query on the model itself (fetch). The empty argument behavior is instead of a more verbose API, e.g. setQuery which takes an object or callback and getQuery that takes no arguments.\n. Your first alternate example is incorrect but the second comment is correct. Will update the docs.\n. Can you please provide a fully reproducible example, including the necessary schema? Here's a good example of something we can easily run to try to diagnose your situation:\nhttps://github.com/tgriesser/knex/issues/463#issuecomment-54284425\nAlso, using invokeThen across collections of more than a couple of models is generally bad practice since performance will be very poor.\n. Curious why this came up. Also, the browser files are built automatically so you can amend that out. \n. This type of relation should use belongsToMany. through is only really relevant when you want to actually have a joining model. In this case having a join model is just extra code noise since the join table is just pairs of IDs. \n. You're going to have the set the columns manually with the schema you've chosen. The docs for belongsToMany explain how to do that. Or you can change your schema to conform with its expectation. \n. Yup. If you're going to use through, you'll need a join model. Relational methods are primarily for reading data. You'll want attach for your join table. \n. Aside from the typo, attach is what you'd use to insert into the join table. It's not for reading. \n. belongsTo is the appropriate relation when a relates to b through a key (default b_id) on a. attach takes 1 or more IDs or 1 or more models, so your example is not correct. \nBookshelf doesn't do magic write queries where it will insert a new row in one place and update a join table as well. That's your responsibility. \nWould definitely be worth a thorough read through the relations section of the docs, at least for an understanding of what the various methods can accept as arguments and what they return. I know that matching SQL concepts with ORM concepts isn't always easy but it seems like you're just getting tripped up on the actual API usage here.\n. Not really possible. Those are supposed to resolve synchronously for toJSON among other synchronous methods. \n. Have to say no to that one. toJSON is a special method in that it's called on all object nodes by JSON.stringify. I only see this introducing a lot of code smell (of course anyone is welcome to offer examples to the contrary). Best best is to get the data during an existing async operation like fetch via the 'fetching' event and then use virtuals to transform it.\n. Lemme know what you're actually trying to do and I'm happy to offer how I'd solve it\n. Hard to understand what's actually going on when you call CourseConverter on the attributes. \nHere it would either be appropriate to explicitly load the fees when needed or attach appropriate logic to the fetching event for the model and collection. Keep in mind that events aren't fired recursively (collection.fetch doesn't trigger 'fetching' or 'fetched' on the models it receives). Typically it's really rough on performance to run 100+ queries when fetching 100 models and you'd be well served trying to optimize it into at most a few. \nThere are quite a few things that could be done above to improve. Here's some fixes:\njs\n new Course({ progcode: request.params.code, termcode: termcode })\n    .fetch({ withRelated: [ 'degreeType', 'degreeLocation', 'departments' ], require: true })\n    .tap(function (course) {\n        course.fees().then(course.set.bind(course, 'fees'));\n    })\n    .then(function(course) {\n        response.json(CourseConverter(course.toJSON()));\n        next();\n    })\n    .catch(Course.NotFoundError, function () {\n        next(new restify.NotFoundError());\n    });\n. If you debug the queries you'll see why this is happening. Bookshelf expects the database to supply the ID. Based on the info above, your ID is not a serial and doesn't autoincrement. Inserting data violates the constraint. \n. Having a really hard time understanding what you're trying to accomplish here. Can you please let it out more clearly with a usage example? \n. Still lost. triggerThen traverses the registered events and calls them like trigger would. The only difference is that the calls are wrapped in promises so throws become rejections and returned promises/rejections are propagated. Is this behavior not working expected with listeners that are only firing once? Still confused what the expectation is and how it's not being met.\n. Got it. Makes sense. In that case if you can hard reset and start from scratch please do the following:\n1. Commit a failing test for expected behavior\n2. Get it to pass\nAlso, please use lodash which is already a dep. No underscore. \n. Yes, lodash is better in basically every way. But we're going to go the direction steering people towards functional array methods instead of lodash stuff anyway. \n. Yes, lodash is better in basically every way. But we're going to go the direction steering people towards functional array methods instead of lodash stuff anyway. \n. model.id itself is read-only. If you set the property specified by model.idAttribute, model.id is updated. \nhttps://github.com/tgriesser/bookshelf/blob/master/lib/base/model.js#L63\n. It shouldn't but if you're seeing that a reproduction or failing test case would be appreciated.\n. It shouldn't but if you're seeing that a reproduction or failing test case would be appreciated.\n. Just verified that this works as expected:\nhttps://gist.github.com/bendrucker/a11f829b4e41fb29421a\n\n. No worries. It's worth reading a little bit about proper flow control with promises to make the best use of Bookshelf and Knex. A huge advantage is that fulfillment values are propagated so that my example will handle all errors in the one catch callback where yours only handles errors from the call to model.save. Used properly, promises are an incredibly powerful pattern. But if you introduce unnecessary nesting you can easily lose errors like this. Bluebird is actually super helpful in this regard \u2014\u00a0it's telling you that you're not propagating an error correctly. Most promise libraries would happily swallow that error and never tell you that your code is probably broken.\n. Multiple queries are expected since a join requires you to know all the columns in advance in order to alias overlaps (almost always 'id', 'created_at', 'updated_at', sometimes others) and then map the properties to the right objects.\nAs for the foreign key issue, you'll need to properly specify the key as the second argument to hasMany. fund.holdings is what's being called in order to generate the related data query there. Your sample above has the right config for holding.fetch({withRelated: 'fund'}) but not the inverse. Bookshelf relations need to be defined on the model where you intend to fetch \u2014\u00a0that means both a belongsTo on the model that contains the foreign key and hasMany/hasOne on the model(s) referenced by it.\n. Multiple queries are expected since a join requires you to know all the columns in advance in order to alias overlaps (almost always 'id', 'created_at', 'updated_at', sometimes others) and then map the properties to the right objects.\nAs for the foreign key issue, you'll need to properly specify the key as the second argument to hasMany. fund.holdings is what's being called in order to generate the related data query there. Your sample above has the right config for holding.fetch({withRelated: 'fund'}) but not the inverse. Bookshelf relations need to be defined on the model where you intend to fetch \u2014\u00a0that means both a belongsTo on the model that contains the foreign key and hasMany/hasOne on the model(s) referenced by it.\n. Exactly. If you write the query using knex manually, you could use a join and save the extra query.\njs\nknex\n  .from('funds f')\n  .select('f.id as fundId', 'f.ticker as fundTicker', 'h.id as holdingId')\n  .innerJoin('holdings h', 'f.id', 'h.fundId')\n  .map(function (row) {\n    // map each database row to the object you're expecting\n  });\nEven if you know the column names, this kind of thing gets increasingly complex as you start to think about nested relations. Future versions of Bookshelf will likely move towards easier construction of complex queries using knex and then properly casting to models rather than trying to do the (near) impossible and get all the crazy multilevel join scenarios to work.\n. Exactly. If you write the query using knex manually, you could use a join and save the extra query.\njs\nknex\n  .from('funds f')\n  .select('f.id as fundId', 'f.ticker as fundTicker', 'h.id as holdingId')\n  .innerJoin('holdings h', 'f.id', 'h.fundId')\n  .map(function (row) {\n    // map each database row to the object you're expecting\n  });\nEven if you know the column names, this kind of thing gets increasingly complex as you start to think about nested relations. Future versions of Bookshelf will likely move towards easier construction of complex queries using knex and then properly casting to models rather than trying to do the (near) impossible and get all the crazy multilevel join scenarios to work.\n. Haven't looked at that in particular but it's always helpful to see other effective implementations. A powerful API is always >> an ultra-simple drop-in solution. Mostly because the latter is a myth :smile: \n. Haven't looked at that in particular but it's always helpful to see other effective implementations. A powerful API is always >> an ultra-simple drop-in solution. Mostly because the latter is a myth :smile: \n. This can be done with the query builder and I'm inclined to say an extra option isn't needed:\njs\nnew Book({'ISBN-13': '9780440180296'}).fetch({\n  withRelated: [\n    {\n      genre: function (qb) {\n        qb.column('id');\n    },\n    'editions'\n  ]\n});\n. This can be done with the query builder and I'm inclined to say an extra option isn't needed:\njs\nnew Book({'ISBN-13': '9780440180296'}).fetch({\n  withRelated: [\n    {\n      genre: function (qb) {\n        qb.column('id');\n    },\n    'editions'\n  ]\n});\n. They are, but just on the prototype and not the constructor. \njs\nsubmissionCount: function(){\n  console.log(bookshelf.knex(SomeModel.prototype.tableName).where({'id': this.id}).count('*').toString());\n}\n. They are, but just on the prototype and not the constructor. \njs\nsubmissionCount: function(){\n  console.log(bookshelf.knex(SomeModel.prototype.tableName).where({'id': this.id}).count('*').toString());\n}\n. reset is just going to empty the collection. It's a holdover from Backbone that probably isn't of any use for a stateless application. \nHere's code directly from an application of mine that wraps the integration tests, starting with a seed database state before every test. This is definitely something you'll do with knex and not Bookshelf. \nhttps://gist.github.com/cf298bf515d8b6fdcd05\n. reset is just going to empty the collection. It's a holdover from Backbone that probably isn't of any use for a stateless application. \nHere's code directly from an application of mine that wraps the integration tests, starting with a seed database state before every test. This is definitely something you'll do with knex and not Bookshelf. \nhttps://gist.github.com/cf298bf515d8b6fdcd05\n. Take a look at the docs for examples. Polymorphic relations just add a *_type column that specifies what other table the relation targets.\n. Take a look at the docs for examples. Polymorphic relations just add a *_type column that specifies what other table the relation targets.\n. Bookshelf does not handle related updates or nested objects for saving. If you're inserting multiple objects your best bet is dropping to knex to handle the batch inserts and any transaction logic. The nice thing is that you can use the ORM or the query builder together.\n. Bookshelf does not handle related updates or nested objects for saving. If you're inserting multiple objects your best bet is dropping to knex to handle the batch inserts and any transaction logic. The nice thing is that you can use the ORM or the query builder together.\n. That's odd. Could you please provide some more code? new Model().fetch() clearly works. I'm assuming you're referring to calling fetch a second time, but more detail for reproducing would be helpful.\n. That's odd. Could you please provide some more code? new Model().fetch() clearly works. I'm assuming you're referring to calling fetch a second time, but more detail for reproducing would be helpful.\n. This is a case where you really want to write code to do this efficiently. Ideally you fetch all the posts and then run a second query with a count(id) where post_id=post subquery for each post ID. Then you can map those counts onto the post models.\n. This is a case where you really want to write code to do this efficiently. Ideally you fetch all the posts and then run a second query with a count(id) where post_id=post subquery for each post ID. Then you can map those counts onto the post models.\n. collection.mapThen is helpful\u2014it's a wrapper around Promise.prototype.map from Bluebird and so you can return a promise. You probably don't want that in this case though. The models are just inside collection.models so you can call whatever map/reduce functions you need here on that.\n. collection.mapThen is helpful\u2014it's a wrapper around Promise.prototype.map from Bluebird and so you can return a promise. You probably don't want that in this case though. The models are just inside collection.models so you can call whatever map/reduce functions you need here on that.\n. Cool. Labels are good for that too!\n. Cool. Labels are good for that too!\n. Can you please offer more information about what you're expecting, what you're seeing, and what we can do to reproduce what you're seeing?\n. Not sure if it made a release. Try master.\n. Not sure if it made a release. Try master.\n. Jack,\nCan you please share the exact schema and naming of the tables in question (or really just the primary and foreign keys)? A description of exactly what sort of object you intend to return, whether that's just the array of questions or some combo of a nested object with multiple model types would be helpful.\nI'm happy to help but the way you've formatted your database info and pseudocode. Using proper markdown really goes a long way in making it easier for us to help you.\n. The way you're using exec will swallow all errors and does not guarantee any execution order. Give the Bluebird API a read through and try to use only the promise interface. Here's an example of some basic working code:\nhttps://gist.github.com/bendrucker/c63ebaff3c9ed5c8f56c\nAnd another:\nhttps://github.com/tgriesser/knex/#examples\n. You need to use idAttribute since you're using a nonstandard primary key. In the future:\n1. Post code that doesn't have unrelated bugs. I know you did some manual investigation but when you post broken code it takes a few minutes to fix before I can actually dig into the real problem. \n2. Use the debug initialization flag for Bookshelf to get all your queries printed to stdout. The vast majority of problems people see with Bookshelf are the result of the wrong query being generated. \n``` js\n'use strict';\nvar assert = require('assert');\nvar knex = require('knex')({\n  client: 'sqlite3',\n  connection: {\n    filename: ':memory:'\n  }\n});\nvar bookshelf = require('bookshelf')(knex);\nvar Post = bookshelf.Model.extend({\n  tableName: 'Post',\n  idAttribute: 'ID',\n  User: function () {\n    return this.belongsTo(User, 'UserID');\n  }\n});\nvar User = bookshelf.Model.extend({\n  tableName: 'User',\n  idAttribute: 'ID',\n  Posts: function () {\n    return this.hasMany(Post, 'UserID');\n  }\n});\nknex.schema.createTable('User', function (table) {\n  table.increments('ID');\n  table.string('Name');\n})\n.createTable('Post', function (table) {\n  table.increments('ID');\n  table.string('Title');\n  table.string('Body');\n  table.integer('UserID').references('User.ID');\n})\n.then(function () {\n  return knex('User').insert([\n    {name: 'User 1'},\n    {name: 'User 2'}\n  ]);\n})\n.then(function () {\n  return knex('Post').insert([\n    {Title: 'Title 1', Body: 'Body 1', UserID: 1},\n    {Title: 'Title 2', Body: 'Body 2', UserID: 1},\n    {Title: 'Title 3', Body: 'Body 3', UserID: 2}\n  ]);\n})\n.then(function () {\n  return User.where({ID: 1}).fetch({withRelated: ['Posts']});\n})\n.then(function (user) {\n  assert.equal(user.related('Posts').models.length, 2);\n  return Post.where({ID: 3}).fetch({withRelated: ['User']});\n})\n.then(function (post) {\n  assert.equal(post.related('User').get('Name'), 'User 2');\n})\n.finally(function () {\n  return knex.destroy();\n});\n``\n. The docs cover these issues. Specifically you should look into [model.get](http://bookshelfjs.org/#Model-get) and [collection.at](http://bookshelfjs.org/#Collection-at). I know it's tempting to dive right in but you should really consider spending an hour or two with the docs.\n.withRelated` can take strings or objects where the object key is the string you would have used and the value is a function that will be called with the query builder for constructing that relation.\njs\nThread\n  .query('orderBy', 'updated_time', 'desc')\n  .query('where',  'user_id', req.param('id'))\n  .query('limit', parseInt(req.param('limit')))\n  .fetchAll({\n    withRelated: {\n      messages: function (qb) {\n        qb.orderBy('column', 'desc');\n      }\n    }\n  })\n  .then(renderThreads, next);\nThere's an example of this in the relations docs just above hasOne. \n. For anyone stumbling onto this here's the documented example:\njs\nStory.where({id: 2}).fetch({\n  withRelated: ['comments.tags', 'comments.author', {\n    'author': function(qb) {\n      qb.where('status', 'active')\n    }\n  }]\n}).then(...\nAnd another similar issue: \nhttps://github.com/tgriesser/bookshelf/pull/489#issuecomment-56114033\n. You need to process your results since you want to go from an array of models to an array of strings. Not sure how you propose using visibility to do that but I'd highly recommend against it. You should also never explicitly call toJSON because its implicitly called by JSON.stringify and your code will break if collection is ever something different with no toJSON method. \nUse column on the query to only get a single column. Or even easier just use the documented columns option for the various fetch methods.\nWhere you map those objects to strings is really up to you and how your application logic is structured. \n. Got it. Whether the slightly reduced payload coming from the DB is worth your dev time is a question of the particular situation. In this case it definitely is. If you added an internal column that you didn't want in public responses it would often make sense just to hide it in code instead of trying to get every query for that model (including relations) to call column.\nAs for toJSON, it's not incorrect so much as it is an unnecessary statement. It will be implicitly called if you just call res.json(collection). If you changed up your model layer one day and collection was just a plain array then your code triggers a TypeError. It's a very minor point but it'll save you some keystrokes and maybe a future headache. \n. That's correct\n. No worries! That's the beauty of clear issues with a ton of background and readable stack traces, dumps, etc. Easy for a fresh set of eyes to catch!\n. Just replace User with User.model since that's where you're defining it. Or skip stuffing the model in User.model and just make it User. \n. Neither\nhttps://github.com/tgriesser/knex/issues/387\n. Yup I'd take a PR on knex that adds a note to count with a link to 387. \n. I'd vote against this just because it encourages new users to lump code into a single handler where they should be trying to break up calls. \n. Tim's mentioned removing Backbone entirely and I'm inclined to think that makes the 1.0. There are many benefits to using EventEmitter over Backbone events for a Node lib and so I'm inclined to oppose any API changes that try to make things more familiar for Backbone people (at a cost of complexity).\n. idAttribute is the column in which the primary key appears, defaulting to 'id'. Are your primary keys actually {{table}}_id? Just need to confirm before further investigation. Can't say I've ever seen that before nor do I think it's a good idea.\n. Reading through your calls there's clearly something wrong but it's really difficult to make sense of it with the way you're naming your keys. Please post an schema for both tables, or really just a list of keys. \n. Cool, so the issue is as expected. belongsTo specifies a relation where the foreign key is on the model. hasOne is the reverse where the foreign key is present on another type of model.\n- Games belongsTo Sponsors\n- Sponsors hasOne Games \n. https://github.com/tgriesser/bookshelf/wiki/Plugin:-Model-Registry\n. > After thinking about it more, maybe it's always better in a case like this to first fetch the row, then perform a save. It's another round-trip to the database, but that's not the end of the world.\nIn user land that's up to you but save should be able to handle update errors without an extra call.\n. In that case we can just make require: true the default and let you explicitly pass in a value to override.\n. Not possibly currently, see #462\n. Yup, if you can rework the DB I'd go for that. FYI, here's the best way to do uuids as PKs (which I do):\nhttp://blog.clearbit.co/postgres-offsets\nYou want an internal column for performant offsets for pagination but otherwise it's unnecessary.\n. You'd need to use a raw queries via model.query or collection.query for that, although definitely use bindings for the values.\n. Not sure if you were proposing pseudo SQL at the top. It's a bad idea to do batch inserts one by one for perf reasons. I also doubt there's a good way to just ignore unique constraint errors for a portion of a query since that goes against SQL concepts. You'd need to map over the collection's models with mapThen, manually returning model.save().catch(isUniqueErr, handle) where you'd be responsible for providing a predicate filter isUniqueErr and handler handle that matches and handles the errors.\n. Actually your best bet is to build up the query the normal way, stringify it with toString and then just splice in the the ignore to be honest. Then pass that to knex.raw.\n. Unfortunately I don't believe so. Pretty sure that's determined by isSingle for the relation. Plural relation means you get a collection.\n. Well you can do that know by grabbing the transaction object inside the closure and assigning it to something in a higher scope. You lose the ability to auto-commit the transaction but it'll work fine.\n. No, see #380\n. No, see #380\n. js\nvar extend = require('xtend');\nvar BaseModel = Bookshelf.Model.extend({\n  toJSON: function (options) {\n    return Bookshelf.Model.prototype.toJSON.call(this, extend(options || {}, {\n      omitPivot: true\n    });\n  }\n})\nThen extend BaseModel instead of Bookshelf.Model. Basically that code is overriding toJSON, setting omitPivot on the options, then calling through to the original implementation. \n. js\nvar extend = require('xtend');\nvar BaseModel = Bookshelf.Model.extend({\n  toJSON: function (options) {\n    return Bookshelf.Model.prototype.toJSON.call(this, extend(options || {}, {\n      omitPivot: true\n    });\n  }\n})\nThen extend BaseModel instead of Bookshelf.Model. Basically that code is overriding toJSON, setting omitPivot on the options, then calling through to the original implementation. \n. Correct, if you force the query builder to exclude it the ORM internals can't link up the records.\n. Correct, if you force the query builder to exclude it the ORM internals can't link up the records.\n. In most cases, yes. The only time Bookshelf is joining for you is with belongsToMany relations and other cases of relations with a joining table. In order to use joins everywhere Bookshelf would need to know about your schema and what columns are available on a table. That's under consideration for the future, but for now we're limited by it.\n. In most cases, yes. The only time Bookshelf is joining for you is with belongsToMany relations and other cases of relations with a joining table. In order to use joins everywhere Bookshelf would need to know about your schema and what columns are available on a table. That's under consideration for the future, but for now we're limited by it.\n. Most likely going to start pulling all plugins out to their own repos, including the default ones that ship with Bookshelf right now. Conferring w/ Tim on that. If we do end up moving that direction now, I'll change the section of the docs and take a PR for the link to this. Stay tuned.\n. Most likely going to start pulling all plugins out to their own repos, including the default ones that ship with Bookshelf right now. Conferring w/ Tim on that. If we do end up moving that direction now, I'll change the section of the docs and take a PR for the link to this. Stay tuned.\n. First off I'd like to hear why you're using three databases with the same model but need them to interact.\nSecond, I don't understand what you're trying to do in your last example block. Can you clarify how you're getting Character?\n. First off I'd like to hear why you're using three databases with the same model but need them to interact.\nSecond, I don't understand what you're trying to do in your last example block. Can you clarify how you're getting Character?\n. Yeah I'm not clear on what \"over-engineered\" means. If you want specific columns for the SQL query and not filtering on the model level that's what you're gonna have to do. You're basically preventing the ORM from performing its default behaviors and so you need to write a bunch more code.\n. Yeah I'm not clear on what \"over-engineered\" means. If you want specific columns for the SQL query and not filtering on the model level that's what you're gonna have to do. You're basically preventing the ORM from performing its default behaviors and so you need to write a bunch more code.\n. If you can use examples to explain what's unclear that would help. Now that I look again your original code looks fine and I'm not sure what your concern is.\n. @c990802 is correct. There are cases where you have to add some parentheses to ensure that new is called on the right value, e.g. new (bookshelf.model('myModel'))(attributes) otherwise new targets the wrong part of the expression. In that example if you don't use the extra pair of parentheses new instantiates bookshelf.model instead of the constructor returned by bookshelf.model.\n. @c990802 is correct. There are cases where you have to add some parentheses to ensure that new is called on the right value, e.g. new (bookshelf.model('myModel'))(attributes) otherwise new targets the wrong part of the expression. In that example if you don't use the extra pair of parentheses new instantiates bookshelf.model instead of the constructor returned by bookshelf.model.\n. Methods on the model instance typically related to specific properties of a model instance (e.g. fetch). Sometimes you have helpers to do things like fetchAll that are present on both the ctor and prototype.\n. Stick to the latter. We're looking to pull the collections API ASAP. It's too heavy and as you've noticed the shift towards exposing Active Record style methods on models has already started.\n. Appreciate the feedback. Still mapping out a better layout for the documentation. It's tough to handle a sizable API, multiple clients and their quirks, and then general Node knowledge like this particular issue. \nThe real answer here is just to opt everyone into the registry and make it part of the core.\n. Because Bookshelf doesn't know your whole schema upfront, you need to fetch the notifications and use withRelated: 'node' and then just return reduce the output to get the node objects. If you want to do this efficiently, drop down to knex via the query method and use a join.\n. Is this behavior something you want consistently across the app? If so you can do it by overriding the toJSON method.\n. No need to use Promise.reduce as you're not doing anything async. Collections have a reduce method mixed in from underscore. \n. js\nexports.create = function(req, res) {\n  Ad.forge(req.body).save().then(function(ad){\n    return ad.load(['section', 'category']);\n  })\n  .then(function (ad) {\n    res.json(ad.toJSON());\n  });\n};\nYou could also add the load behavior to an .on('saving') event if you wanted this all the time.\n. You can call query inside the category and section methods. Might be enough to get what you need.\n. You can call query inside the category and section methods. Might be enough to get what you need.\n. A builder isn't passed in. Just do .query(fn) on this.belongsTo('Related') to change the query builder. fn will be called with a query builder. There's an example in the docs, but just with the .query(whereObject) version:\nhttp://bookshelfjs.org/#Model-belongsToMany\n. A builder isn't passed in. Just do .query(fn) on this.belongsTo('Related') to change the query builder. fn will be called with a query builder. There's an example in the docs, but just with the .query(whereObject) version:\nhttp://bookshelfjs.org/#Model-belongsToMany\n. :blush: \n. :blush: \n. The Backbone dep is going away anyway\n. The current plan is to create a proper base model layer and not use Backbone. The only reason to use Backbone was the hope of code reuse between the browser and server. \nNot sure what you're talking about with version conflicts. NPM isn't flat, you shouldn't have issues.\n. The current plan is to create a proper base model layer and not use Backbone. The only reason to use Backbone was the hope of code reuse between the browser and server. \nNot sure what you're talking about with version conflicts. NPM isn't flat, you shouldn't have issues.\n. Pass debug: true as an option to knex when you initialize it. There are a couple issues over at knex about how to improve the logging mechanisms. I'm going to close this so we keep discussion somewhat focused around fixing Knex first and then thinking about how Bookshelf should expose that interface.\n. Pass debug: true as an option to knex when you initialize it. There are a couple issues over at knex about how to improve the logging mechanisms. I'm going to close this so we keep discussion somewhat focused around fixing Knex first and then thinking about how Bookshelf should expose that interface.\n. Except when using knex.raw, parameters are always passed as bindings. That's the easy way out of worrying about injection.\n. Except when using knex.raw, parameters are always passed as bindings. That's the easy way out of worrying about injection.\n. The only way around this is for virtuals to patch extend and merge the object. That'll break with ES6 or CoffeeScript extends. I'm always uneasy about coupling behavior tightly to extend. \n. The only way around this is for virtuals to patch extend and merge the object. That'll break with ES6 or CoffeeScript extends. I'm always uneasy about coupling behavior tightly to extend. \n. Right \u2014\u00a0extend versus extends. Right now extend just a generic subclassing function, with the same output as the extends keyword in Coffee or ES6. Doing merge behavior like this would require breaking that convention. The issue here is not where the function comes from, but whether it's a good idea to start embedding specific inheritance behaviors in Model.extend that will break when using a generic extends keyword. And I say it's a bad idea.\n. Right \u2014\u00a0extend versus extends. Right now extend just a generic subclassing function, with the same output as the extends keyword in Coffee or ES6. Doing merge behavior like this would require breaking that convention. The issue here is not where the function comes from, but whether it's a good idea to start embedding specific inheritance behaviors in Model.extend that will break when using a generic extends keyword. And I say it's a bad idea.\n. Well the interface is totally open now. Registry and computed properties will probably become core features and the concept of built-in plugins will go away to clarify that people are expected to bring their own.\n. Well the interface is totally open now. Registry and computed properties will probably become core features and the concept of built-in plugins will go away to clarify that people are expected to bring their own.\n. You need to drop down to knex in order to be using raw values for column names. \n. You need to drop down to knex in order to be using raw values for column names. \n. Correct. There is no exposed reference from the model to bookshelf. You need to require the bookshelf instance itself.\n. Correct. There is no exposed reference from the model to bookshelf. You need to require the bookshelf instance itself.\n. You should just be able to do User.where({ roleId: 5 }).query('count', '').then(handleCount). I believe that'll resolve an array to handleCount where the first value is the count. Haven't tried this, but the general idea is that you're going to want to use Knex but build up the query using Bookshelf's helpers.\n. You should just be able to do User.where({ roleId: 5 }).query('count', '').then(handleCount). I believe that'll resolve an array to handleCount where the first value is the count. Haven't tried this, but the general idea is that you're going to want to use Knex but build up the query using Bookshelf's helpers.\n. Call query() (no args) and then you'll get the query builder itself. That's just a knex query object which'll have a count method.\n. Call query() (no args) and then you'll get the query builder itself. That's just a knex query object which'll have a count method.\n. See https://github.com/tgriesser/knex/issues/394 for native enum vs constraint discussion\n. See https://github.com/tgriesser/knex/issues/394 for native enum vs constraint discussion\n. Yes, you need to pass a columns option to fetchAll. Otherwise it's going to try to add all of them.\n. Yes, you need to pass a columns option to fetchAll. Otherwise it's going to try to add all of them.\n. You can't. What're you trying to do?\n. You can't. What're you trying to do?\n. You need to use relations to handle that. If you want to share an example of code you've got written now that you're not happy with I'd love to help. It's too hard to be clear about general ideas like this.\n. You need to use relations to handle that. If you want to share an example of code you've got written now that you're not happy with I'd love to help. It's too hard to be clear about general ideas like this.\n. You could implement something like that yourself but Bookshelf isn't going to automatically fetch the corresponding User row every time you get a subtype. You also can't do what you're looking for with prototypal inheritance. You can make the public interface look the way you want with the \"virtuals\" plugin.\n. You could implement something like that yourself but Bookshelf isn't going to automatically fetch the corresponding User row every time you get a subtype. You also can't do what you're looking for with prototypal inheritance. You can make the public interface look the way you want with the \"virtuals\" plugin.\n. No. Take a look at the model implementation. There's an attributes object backing get and set. You could override get to check a related model that you've already loaded.\n. No. Take a look at the model implementation. There's an attributes object backing get and set. You could override get to check a related model that you've already loaded.\n. Yup that's it. You can totally get the interface you want, you just need to make sure the related user is always loaded. Then you can virtuals for specific user attributes in the child models that will call child.related('user').get(...) to obtain value. There's no way to do this for arbitrary user attributes (i.e. without defining the properties explicitly) because there'd be no way to serialize that. \n. Yup that's it. You can totally get the interface you want, you just need to make sure the related user is always loaded. Then you can virtuals for specific user attributes in the child models that will call child.related('user').get(...) to obtain value. There's no way to do this for arbitrary user attributes (i.e. without defining the properties explicitly) because there'd be no way to serialize that. \n. > Sort of concerned with so many .then blocks.\nDon't be. This is actually how promises should look. Sometimes you have to nest things, but ideally you're going for as little as possible and relying on the propagation of values down the chain instead.\n\nMy other concern is that this doesn't look atomic. Should I need to wrap the whole thing into a transaction to make sure it's rolled back if any of the db operations fail or will it be taken care of by the Bookshelf? \n\nThat does matter and you will need to handle that yourself. \n``` js\nvar adObj = { title: 'Ad title', description: 'Some ad description', ...}\nvar labelIds = [1, 2] // this array returned from a service\nbookshelf.transaction(function (t) {\n  return Ad\n    .forge(adObj)\n    .save(null, {\n      transacting: t\n    })\n    .tap(function (ad) {\n      // updated pivot table ads_labels\n      return ad\n        .labels()\n        .attach(labelIds, {\n          transacting: t\n        });\n    });\n})\n.then(function (ad) {\n  return ad.load(['section', 'category', 'labels']);\n})\n.then(function (ad) {\n  res.json(ad.toJSON());\n})\n.otherwise(function (err) {\n  console.error(colors.red(err));\n  res.sendStatus(500);\n});\n```\nNote that by returning a promise inside the transaction callback you're letting knex auto-commit it for you (which you want). It'll wait until that promise is resolved and commit it or rejected and roll it back. You don't need to do the read inside the transaction and should always minimize what's happening inside a transaction where possible.\n. \n. You're looking for attach\n. Gonna need code\n. Ok and can you spell out what you're trying to accomplish in terms of rows in the database?\n. > it is wrong in some way\nNot necessarily. I'm just trying to understand what changes you're expecting to the DB (presumably a new row) so I can be sure I'm recommending the right method.\n. Sorry if this comes off a little harsh but I can't help you if you don't answer my question. I have your schema which is the first step. Now I need to know what row you're expecting Bookshelf to create for you in the database, specifically what table and the contents of the row.\n. Yes, your most recent example looks right. Is that working for you?\n. If you could create a repository that reproduces your setup that would be awesome. Looking for something I can clone and run so I look at the stuff in scope in _processPivot where that exception is coming from. \n. Please put something in there that I can run\n. Cool, close enough. SQLite is nice because it can be done in memory and eliminates any need to be dealing with schemas outside of the node process. Will take a look tomorrow.\n. Cool, glad it worked\n. You can't do model: 'Directory' when instantiating a collection. You need to pass the model object in. That shouldn't create circular dep issues because you only need the model to create the collection and never vice versa.\n. Bookshelf doesn't do joins for most queries because it doesn't know about your database schema. Without that information, it can't properly handle column name collisions. Bookshelf needs to see the chapter first so it can fetch the book by id in a separate query. For something like this you'd invert the way you're doing it. \njs\nnew Chapter({\n  title: 'Title'\n})\n.fetch({\n  withRelated: 'book'\n});\n. You can also use the query method on Bookshelf to easily add the constraints, but you have to keep in mind that you'll get all the columns back.\n. Chapters don't look like they have a book_id column so the relations aren't correct\n. Your DB schema definitely matches the relation methods then. What I'm wondering is how you're managing to get output without a book_id column.\n. Right, your database is correct. The hasMany doesn't matter here. Relations are not automatically bidirectional. You have to define both sides. The side that matters here is that a chapter belongsTo a book, meaning that a chapter has a key book_id that corresponds to the id of a row in books. \nWe're on the same page there. Here's where an issue becomes evident. You say the output is:\njson\n{\n\"title\": \"Title\",\n\"id\": 3,\n\"user_id\": 1,\n\"created_at\": null,\n\"updated_at\": null,\n\"books\": {}\n}\nWhat happened to the book_id column?\n. Alright, time to get a test reproducing this. Will knock that out later.\n. Seems like a bug in your code: \nhttps://github.com/bendrucker/bookshelf-616\nLook through this and see if you can see any fundamental differences from your code\n. Yeah pg isn't gonna make a different. If it's the Hapi plugin's fault I'll happily yell at Peter and Leore for you :)\n. Sure. The args to withRelated just point to the methods on the model which will return a related instance. In your example you had everything set up correctly. I only changed it to book from books because it's a belongsTo relation and it doesn't make sense to use a plural since there can only be one book to a chapter. \n. > Does it matter if my table names are something like xyz_books and xyz_chapters\n:cry: :cry: :cry:\nYes. That's how the relations work if you don't manually specify a key.\n\nBy default, the foreignKey is assumed to be the singular form of the Target model's tableName, followed by _id.\n. With you 100% there. The require option is gonna get tricky with Postgres returning support but that only applies to updates and isn't handled properly right now anyway.\n\nThis'll be an easy PR if you're up for tackling it, otherwise I'll put it on my list.\n. Yeah sqlite3 has issues with 0.11+ / io right now. Not sure what's up with that error. Doesn't appear to be coming from Bookshelf.\n. What you're proposing is exactly what fetch does. \n. This is already available. Just do something like:\njs\nPost.fetchAll({\n  withRelated: related\n});\n. Ah, I get what you're asking. It's on you run a few reducers to extract these. The way Bookshelf is designed isn't especially well suited to the way Ember wants you to do this. Nor is really any ORM that I know of. It does shave some bytes off the response but it's makes it much more onerous for clients to consume.\n. First off, sorry that the docs aren't clearer about this. It's a bit of a pain to do a json column outside of Postgres 9.3+ where you have actual json support. \n\nHow can I add a getter that silently converts the string coming back into a json object when the underlying database does not support the json field type?\n\nWith Model.prototype.parse\n\nI believe that what I want is to write an .on('saving', ...) that does this conversion. Is this the best approach? How do I actually modify the data attribute when saving (with example code)?\n\nUse Model.prototype.format here. \n\nMay I suggest adding a jsonAttributes model property that identifies json fields and does the conversion automatically?\n\nYou can totally implement this yourself now on a base model so you can use the same behavior on multiple model classes. We're going to hold off on adding this as a feature for now since Bookshelf tries to stay fairly light. That's not to say this'll never land, but we do want to evaluate how it should be included and whether it might be best as a plugin instead of a core feature.\n. No plans to add new lifecycle events. If you need granular control over call order you do that from a single event handler that calls other functions. Otherwise order is indeterminate. \n. Bookshelf doesn't do joins for a lot of queries where you might want it to. In order to safely join tables, you need to know all the columns so you can alias every column and avoid collisions. \nYou can use columns: 'account_id and then transform the result to remove the foreign key column.\n. > Also, when you mean knowing all the columns are you referring performing the query via the standard Bookshelf fetch/fetchAll or via the query builder\nNo, more an abstract comment. I think we're going to take Bookshelf in the direction of forcing users to state more about their schema upfront in order to get the speed and customizability benefits of using joins instead of internally figuring out which queries to run.\n. > How would you do the transformation to remove the foreign key column?\nJust set toJSON to delete the foreign key attribute and created the nested object if needed (for cases where you're not getting the related object as well).\n. See #623\nA plugin would be great (external). We're not merging PRs any more for plugins sitting in the plugins/ folder. Everything there will either become a core feature or be moved to an external package.\n. I don't think we're going to go this route. The discussions that we've had have centered around making bookshelf a function and allowing a model name to be passed in. Within a transaction queries would automatically be bound similar to the way this namespacing concept works, but without any of the complexity and required docs.\n. Looks good to me. Can you please rebase this 2x (from master, then squash) so I can do a final run through?\n. There's no way to do this with Bookshelf right now but we're interested in moving Bookshelf to a streaming-compatible API and internals. For now you need to just use the query builder directly by running model.query(). With no arguments query returns the builder.\n. You need to put the where first if it's on the track and not the album.\n. You need to put the where first if it's on the track and not the album.\n. this.hasMany('track').through('album').where('is_publish',1) is not the same as this.hasMany('track').where('is_publish',1).through('album'). The former expectsis_publishon album, the latter ontrack. \n.this.hasMany('track').through('album').where('is_publish',1)is not the same as this.hasMany('track').where('is_publish',1).through('album'). The former expectsis_publishon album, the latter ontrack. \n. Yes. You're going to have to override toJSON and do this manually for now. This is kind of crappy and yet another reason we'd like to move away from letting format and parse be black boxes. If we could know what the pivot prefix was going to be this would be an easy fix.\n. Yes. You're going to have to override toJSON and do this manually for now. This is kind of crappy and yet another reason we'd like to move away from letting format and parse be black boxes. If we could know what the pivot prefix was going to be this would be an easy fix.\n. You can use knex.raw to call stored procedures. Knex is available as bookshelf.knex on your initialized bookshelf instances. \n. You can use knex.raw to call stored procedures. Knex is available as bookshelf.knex on your initialized bookshelf instances. \n. It's printed with console.log. \n. It's printed with console.log. \n. Please fence your code in the future so we can read it\nStill not clear on what you're asking. What model are you trying to limit? Bib? What output are you expecting?\n. Please fence your code in the future so we can read it\nStill not clear on what you're asking. What model are you trying to limit? Bib? What output are you expecting?\n. Hey @aitorllj93, \nWe tend to be pretty open about things on the issue tracker, but something as generic as a database schema is something better suited for Stack Overflow.\n. Hey @aitorllj93, \nWe tend to be pretty open about things on the issue tracker, but something as generic as a database schema is something better suited for Stack Overflow.\n. > Would it be easier if the client supplied a function that parsed/formatted actual keys (rather than entire structures)?\n100% correct \u2014\u00a0this is what I was getting at in https://github.com/tgriesser/bookshelf/issues/635#issuecomment-75988111. \n. > Would it be easier if the client supplied a function that parsed/formatted actual keys (rather than entire structures)?\n100% correct \u2014\u00a0this is what I was getting at in https://github.com/tgriesser/bookshelf/issues/635#issuecomment-75988111. \n. If you strip the bib_record_id column then Bookshelf can't assemble the relation query. If you want to omit that column you need to do so during serialization, not as a fetch option.\n. toJSON is fine. The point is that you have to be careful about overriding the columns for a query and make sure any required foreign keys are included. Otherwise you break all your relations.\n. Thank you!\n. Please format your code using the correct GitHub Flavored Markdown syntax in the future so we can read it. \nSeems like this is a MySQL specific issue and so I can't really speak to what exactly might be causing it in your specific case. If you truly believe this is a universal issue, you'd have to create a repo that can reproduce the issue that we could git clone, npm install, and then npm test to cause the failure. \nIn this case you should be changing the logic here entirely so I don't think it matters all that much. Instead of writing 10 queries, and running them roughly in parallel, you should be building up 1 update + where in query using an array of the matched object ids. \n. Can you please be clearer about exactly what you're trying to do, i.e. what your data should look like in the DB, model, and JSON output and how you're trying to configure that behavior now?\n. No, you'd need to override toJSON in order to transform a value for serialization only.\n. This is tricky. where is documented right now as a proxy to .query('where', ...). The moment you start getting into direct query manipulation and start mixing in models concerns like key transformations, things get confusing. \nThis is part of the reason I've never done camel/snake case transformations and just leave things in the snake case that the DB and HTTP APIs speak. \nI know you're interested in better behavior here. Let me start an email thread and see if we can get moving on a roadmap similar to Knex as well as some design docs that propose better APIs for thorny issues like this.\n. You can call the query method.\njs\nUser\n  .where({active: true})\n  .query('orderBy', 'created_at', 'desc')\n  .fetchAll()\n  .then(function (users) {\n    // ...\n  });\n. Bookshelf doesn't have any opinion on where you serialize your models. This is a case where a more full-feature framework like Hapi really shines. With no structure in express doing formatting in a consistent way is something you have to determine from scratch, whereas a config-oriented framework like Hapi provides that consistent interface for you.\n. You're looking for withPivot. There's no relation helper for pulling in the roles the way you're describing. You'd have to assemble the queries/data yourself. \n. Without seeing models here so we know how you've defined your relations it's impossible to say what you're doing wrong.\n. For one you need to manually specify the table name on one side. Read up on how Bookshelf assembles those queries:\nhttp://bookshelfjs.org/#Model-belongsToMany\n. If you've got more detail or more questions happy to continue the discussion here\n. Referring to rkmax here. You're welcome to open a new issue with a full reproduction of your schema, models, the call you're trying to make, and the final response you'd like to send to the client.\n. That looks right. Are you sure the column names are correct? And can you share the queries that are run?\n. Are you ever calling getAdminAccounts(access).fetchAll()?\n. Yes\n. Currently there's support for where in. If that's not what you're looking for please share the SQL you'd like to generate. \nhttp://knexjs.org/#Builder-whereIn\n. Please format your code using the correct GitHub Flavored Markdown syntax in the future so we can read it. \nI need a full example here, i.e. something that defines contacts so I can run it directly and generate a query string. \n. Your example is correct. Noted on wanting helpers to do this more easily. We'll definitely consider it.\n. Not clear what the question is here but I'll assume that you're asking how to populate merchant.transactions to fetch unique rows. Bookshelf doesn't handle this for you. You can use Knex to do a join or do withRelated: ['vouchers.transaction'] and then de-dupe and transform the data as needed.\n. Yeah unfortunately there's not a better way. This falls into the largest category of Bookshelf requests \u2014\u00a0features that require schema knowledge to implement. Right now most relations are assembled using multiple queries and then stitched together in JS. We're planning on querying the DB for table info and using that to enable more joins and custom queries since we'll always be able to anticipate the columns coming back.\n. Use Submission.prototype.toJSON to only include the attributes you need when serializing. \n. You should use knex (i.e. model.query) to do a join in order to perform the listing filtering by neighborhood id. The way you're handling it in the gist is not using a valid column name, even if there were joins involved. And Bookshelf mostly doesn't use joins where you might expect because it's not possible to properly join and denormalize data without knowing the schema. That's the most significant upcoming change that needs to happen.\n. You have to handle that yourself that manually by doing something like this:\njs\nPromise.join(\n  new User({id: 1}).fetch(),\n  Role.fetchAll(),\n  function (user, roles) {\n    return user.set('roles', roles);\n  }\n)\n.then(function (user) {\n  // handle user\n});\nEssentially you're just attaching arbitrary data and not relations because the list of roles isn't derived from your user in any sense.\n. Definitely just discussion right now, no progress yet. If anything we're looking to slim down the model layer though and take out the Backbone stuff and remove collections entirely.\n. I don't agree that this needs documentation. It should be evident from the fact that you're calling this.belongsTo in the function body that you can't call your method belongsTo. \n. The only way to support this would be to add special behavior to extend and forbid the use of the extends keyword in ES6 et al. There's definitely benefits to doing that (supporting this would be one). But I favor keeping subclassing generic. @tgriesser what do you think?\n. 1. Yes, it's possible for sure. But the extended feature isn't used or documented right now. I'm saying that it's more important to target a new feature of the language than offer this feature among others that depend on extension-time code.\n2. It would be easy to use this.constructor.NotFoundError instead of a direct reference. \n. Nice! We'd probably change the API a little bit but there's definitely interest in getting something like this in Bookshelf. Bookshelf is due for a lot of plumbing work to rip the generic model functionality away from the query stuff. Once that starts we can talk a little more concretely about query presets like this.\n. Thanks @muddydixon! I really like this as a way of addressing #674. I'm really not keen on doing any sort of dynamic magic with extend since it takes away the option to use the extends keyword in languages that support it. This is a nice middle ground.\nIf you add this consistently across all the custom errors I'll get it merged right away.\n. Seems like we're not on the same page here. \nIf you add NoRowsDeletedError and NoRowsUpdatedError to the Model and add the same behavior for Collection.EmptyError, this is ready to merge. But it has to be consistent.\n. Yup, figured it was just a language barrier. Thanks again!\n. Collections are on the chopping block for future Bookshelf versions. It's an abstraction that makes sense in stateful applications with Bookshelf but really just gets in the way on the server.\nIt should be non-breaking to change this in the mean time:\nhttps://github.com/tgriesser/bookshelf/blob/383d211f12b8235f86848c8e99ced7b03b7c4543/lib/relation.js#L243-L247\nThat needs to use Target.collection and Model.collection could then be overridden. \nAll that said, I think your workaround example is better than using collections explicitly.\n. self.set('latitude', ...) should resolve it\n. :smile: :+1: \nAlso, use bind instead of closing over the parent context\n. Ah. Promise.resolve(otherLibPromise).bind(context).then(handler) in that case.\n. Currently Bookshelf has no support for batch inserts. I'd recommend dropping to Knex to insert all the records at once.\n. You can't do arbitrary queries right now with relations. You have to get that data separately and assemble your response. Relations assume that the return value should be as the appropriate model/collection.\n. Might be because you include the foreign key so the relation can be associated. \n. As long as you have the required relational columns you can add whatever you'd like.\n. No problem! The oddities here generally come back to the recurring issue of joins vs. multiple queries for relations. You can only use joins if you explicitly alias all your columns during queries since you're almost guaranteed to have conflicts (e.g. every table has an id column). In order to alias all your columns you need to list out every column in the select, (no *). And in order to do that, Bookshelf would need a way for you to tell it about every column or go looking for that info itself. We're planning to support both paths, with the latter preferred and the former available as a fallback.\n. Technically this is more of a promises question than a Bookshelf one. And unfortunately there's no great answer here. I'm not sure if there's a way to do this in Express but I wrote a promise plugin for Hapi which was eventually adapted into the core. That way you call next(promise) instead of promise.then(next, next).\n. Seems like you're not passing in a Knex instance:\njs\nvar knex = require('knex')(config)\nvar bookshelf = require('bookshelf')(knex)\nIf you are doing that correctly, post code and we can reopen.\n. Code please!\n. Everything looks okay to me. Next step would be publishing a full-on cloneable repo that uses in-memory SQLite so we can test the same thing. \nThat would mean:\njs\nrequire('knex')({\n  client: 'sqlite3',\n  connection: {\n    filename: ':memory:'\n  }\n})\n. Does address require listing?\n. Post full code for both models please\n. You've got the registry loaded but then you're not using it for your morph* relations. Give the registry docs a thorough re-read and you'll see that you have a circular relation between your two models and are getting empty objects when you require at the top as expected.\n. I'd focus on understanding circular references first. Because once you get that you'll get why the reference you pass into your relation methods is just an empty object, thus the error.\n. It will \u2014\u00a0initialize is called from the Model constructor\n. This is already in master as 8b142b48623ebc17afca3415a226956e22305511\n. Duplicate of #586. This is by design. \n. Model code?\n. https://github.com/bendrucker/bookshelf-issue-706\nOne place worth looking right off the bat is user._events to see if you're managing to double register the listeners\n. This sort of issue often traces back to a shared object\u2014something that's on the prototype that should be assigned in the constructor instead. Hard to say what's up here. I'd just start writing unit tests and commenting out inheritance patterns. Uncomment things until you find the culprit.\n. When you do save(attrs, {patch}), only attrs, i.e. the explicitly passed data, is updated.\n. Sort of, although the details aren't exactly correct.\nattrs do get set on the model:\nhttps://github.com/tgriesser/bookshelf/blob/702919b5386b20416c2de25cfd5492fd200ae988/lib/model.js#L193\nhttps://github.com/tgriesser/bookshelf/blob/702919b5386b20416c2de25cfd5492fd200ae988/lib/model.js#L205\nBut then when you use options.patch:\nhttps://github.com/tgriesser/bookshelf/blob/702919b5386b20416c2de25cfd5492fd200ae988/lib/model.js#L220\nYou shouldn't actually need options.patch here anyway\n. Sort of, although the details aren't exactly correct.\nattrs do get set on the model:\nhttps://github.com/tgriesser/bookshelf/blob/702919b5386b20416c2de25cfd5492fd200ae988/lib/model.js#L193\nhttps://github.com/tgriesser/bookshelf/blob/702919b5386b20416c2de25cfd5492fd200ae988/lib/model.js#L205\nBut then when you use options.patch:\nhttps://github.com/tgriesser/bookshelf/blob/702919b5386b20416c2de25cfd5492fd200ae988/lib/model.js#L220\nYou shouldn't actually need options.patch here anyway\n. isNew just uses the primary key you tell Bookshelf about (idAttribute) which defaults to 'id'. If you don't tell Bookshelf what your primary key is it never knows that something isn't new and is therefore an update.\n. isNew just uses the primary key you tell Bookshelf about (idAttribute) which defaults to 'id'. If you don't tell Bookshelf what your primary key is it never knows that something isn't new and is therefore an update.\n. I think there are some open tickets about that. Pretty sure there are still serious issues around compound keys.\n. I think there are some open tickets about that. Pretty sure there are still serious issues around compound keys.\n. Bookshelf expects tableName to be on the prototype and it's possible idAttribute is the same. There is no way to add prototype properties with the class syntax, including under the current ES7 class properties. Bookshelf models don't really play nicely with class. You have to manually add everything to the prototype after the class is defined.\n. Initialize is called by the constructor. If you want to have the parent events retained, call Parent.prototype.initialize on this from the initialize method of the child.\n. Yes. Nothing funky going on, just prototypal inheritance. \n. Don't bind your functions. It's slow. saving is the umbrella event. creating OR updating depends on what's actually going on. Calling model.save always means the model is saving. Creating vs. updating just means an insert query or an update. They're mutually exclusive.\n. Ah, so the title versus your original post got me confused. Use get/set. Don't treat attributes as mutable.\n. This is a limitation. The only way for an ORM to use joins for all relation queries is to know your entire schema, most importantly every column name for every table you query. Bookshelf doesn't, so it resorts to optimizing things into a small number of selects.\n. ",
    "dksakkos": "@qawemlilo\nApparently the columns that I am requesting can only be from the city table; when I try to include country.name it throws the following error:\njavascript\nclientError: \n   { [Error: ER_BAD_FIELD_ERROR: Unknown column 'country.name' in 'field list']\n     code: 'ER_BAD_FIELD_ERROR',\n     errno: 1054,\n     sqlState: '42S22',\n     index: 0 } }\n. @rhys-vdw Debug mode is already on true.\nI'm sorry, I just thought it was a similar problem. In the future I will open a new one.\n. Okay, my fault. I had incorrectly specified the foreign key in the city model. It now correctly prints\njavascript\n[{\"name\":\"Paris\",\"country\":{\"country_id\":147,\"name\":\"France\"}}]\nHow can I know restrict the output to paris, france only?\n. @rhys-vdw Ahh okay, yes I understand how it works. Thank you all very much for your help, we can consider this issue solved.\n. Update: I can now fetch correctly the joiners.\nI changed this bit:\njavascript\njoiner: function() {\n        return this.hasMany(User, 'user_id').through(Joiner, 'user_id', 'bet_id');\n    }\nto\njavascript\njoiner: function() {\n        return this.belongsToMany(User, 'user_id').through(Joiner, 'bet_id', 'user_id');\n    }\nBut how can I fetch only the user_id and the username for the users and joiners?\n. Hi @rhys-vdw, I appreciate the reply.\nActually I want to return the Users, so I can fetch the usernames. I can only fetch this through the join table, that is why I use the through command (http://bookshelfjs.org/#Model-through).\nI tried your solution but it doesn't seem to work. Right now I'm happy with the fix I implemented, since it works. \nHowever, the problem that remains is how can I only fetch the user_id and the username, and discard the useless columns.\n. I get an error on fetchAll(): undefined is not a function.\nI believe it's because collections don't have fetchAll, but fetch().\nIf I use the latter, along with the following relation in my model\njavascript\nvar Bet = Bookshelf.Model.extend({\n    tableName: 'bet',\n    idAttribute: 'bet_id',\n    joiner: function() {\n        return this.hasMany(Joiner, 'bet_id');\n    }\n});\nand run your code, I get no output.\n. There is no output at all, and I really don't know why. As you said, there should at least be an error printed out.\nAlso, for some reason fetchAll() doesn't work with the Bet model either. I have to use the Bets collection and fetch() method in order to avoid the \"undefined is not a function\" TypeError.\nBut even so, no output whatsoever.\n. For some reason it fails to recognize catch as a function. If I use otherwise instead, I get a  \njavascript\n[TypeError: undefined is not a function]\non this line:\njavascript\n {user: function(qb) { qb.columns('user_id', 'username'); }}\n. Sure thing.\njavascript\nleagueModel.Bets().forge()\n  .query({where: {match: requestObject.matchid}})\n  .fetch({\n    withRelated: [\n      {user: function(qb) { qb.columns('user_id', 'username'); }},\n      'joiner'\n    ],\n    debug:true\n  })\n  .then(function(collection) {\n   console.log(JSON.stringify(collection.toJSON()));\n  })\n  .catch(function(err) {\n      console.error(err);\n  });\nThis one fires a \njavascript\nTypeError: undefined is not a function\non the first line of code.\nIf I change it to this\njavascript\nnew leagueModel.Bets()\nit fires the same error on the line where the catch function is.\n. Fair enough. But I still end up with an error on the catch function.\n. OK. Once again, this is the code I'm using\njavascript\nmodel.Bets.forge()\n  .query({where: {match: requestObject.matchid}})\n  .fetch({\n    withRelated: [\n    {user: function(qb) { qb.columns('user_id', 'username'); }},\n      'joiner'\n    ],\n    debug:true\n  })\n  .then(function(collection) {\n   console.log(JSON.stringify(collection.toJSON()));\n  })\n  .otherwise(function(err) {\n      console.error(err);\n  });\n}\nand this is my schema\n``` javascript\nvar Bet = Bookshelf.Model.extend({\n    tableName: 'bet',\n    idAttribute: 'bet_id',\n    user: function() {\n    return this.belongsTo(User, 'bet_creator');\n    },\n    joiner: function() {\n        return this.belongsToMany(User, 'user_id').through(Joiner, 'bet_id', 'user_id');\n}\n});\nvar Joiner = Bookshelf.Model.extend({\n    tableName: 'joiner',\n    idAttribute: 'joiner_id',\n    bet: function() {\n        return this.belongsTo(Bet, 'bet_id');\n    },\n    user: function() {\n        return this.belongsTo(User, 'user_id');\n    }\n});\n```\nThere should be an error somewhere.\nThe error I get is a [TypeError: object is not a function].\n. Aaaaah found it. Line\njavascript\n{user: function(qb) { qb.columns('user_id', 'username'); }}\nchanged to\njavascript\n{user: function(qb) { qb.column('user_id', 'username'); }},\nIt's column, not columns!\n2 days of work for one character. I love my job.\nThank you both for your help!\n. Aah the workaround you suggested works perfectly fine. Thank you so much and apologies if it had been posted before, I did some searching but couldn't find it.\n. It works great, as always.\nGreat work @rhys-vdw, I appreciate your help very much.\n. Sure thing. It prints out\n[TypeError: Cannot read property 'type' of undefined] \n'TypeError: Cannot read property \\'type\\' of undefined\\n    at exports.EagerRelation.EagerBase.extend.eagerFetch (c:\\Users...\\node_modules\\bookshelf\\dialects\\sql\\eager.js:26:22)\\n    at EagerBase.fetch (c:\\Users...\\node_modules\\bookshelf\\dialects\\base\\eager.js:70:35)\\n    at c:\\Users...\\node_modules\\bookshelf\\dialects\\sql\\model.js:234:60\\n    at NearFulfilledProxy.when (c:\\Users...\\node_modules\\bookshelf\\node_modules\\when\\when.js:465:43)\\n    at Object._message (c:\\Users...\\node_modules\\bookshelf\\node_modules\\when\\when.js:389:25)\\n    at deliver (c:\\Users...\\node_modules\\bookshelf\\node_modules\\when\\when.js:299:7)\\n    at c:\\Users...\\node_modules\\bookshelf\\node_modules\\when\\when.js:296:63\\n    at Immediate.drainQueue as _onImmediate\\n    at processImmediate as _immediateCallback'\n. Oops, you're right.\nI now have the latest version. The error I get now is this:\n[TypeError: Cannot read property 'parentFk' of undefined] \n'TypeError: Cannot read property \\'parentFk\\' of undefined\\n    at EagerRelation. (c:\\Users...\\node_modules\\bookshelf\\lib\\eager.js:27:20)\\n    at EagerRelation.tryCatcher (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\util.js:26:23)\\n    at EagerRelation.eagerFetch (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\method.js:15:34)\\n    at EagerRelation. (c:\\Users...\\node_modules\\bookshelf\\lib\\base\\eager.js:65:33)\\n    at EagerRelation.tryCatcher (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\util.js:26:23)\\n    at EagerRelation.fetch (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\method.js:15:34)\\n    at ModelBase.extend._handleEager (c:\\Users...\\node_modules\\bookshelf\\lib\\model.js:302:54)\\n    at null. (c:\\Users...\\node_modules\\bookshelf\\lib\\model.js:107:23)\\n    at Object.tapHandler (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\finally.js:63:44)\\n    at Object.tryCatcher (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\util.js:26:23)\\n    at Promise._settlePromiseFromHandler (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\promise.js:503:31)\\n    at Promise._settlePromiseAt (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\promise.js:577:18)\\n    at Promise._settlePromises (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\promise.js:693:14)\\n    at Async._drainQueue (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\async.js:123:16)\\n    at Async._drainQueues (c:\\Users...\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\async.js:133:10)\\n    at Immediate.Async.drainQueues as _onImmediate\\n    at processImmediate as _immediateCallback'\nHope this helps!\n. You mean I should use this code\njavascript\n.fetch({\n    withRelated: {country: function (qb) { qb.column('name') }}\n})\nin my query?\nIt wouldn't work unless I add a 'country' function in my schema, and as you said bookshelf doesn't accept this.\nUsing the helper also shouldn't work, because as you said bookshelf doesn't know the user_id. Besides, if the helper runs async, will it return on time?\n. The last bit of code you posted works. But is seems like a workaround. For example, if we had a table 'continent', with continent_id and name as attributes, how could we access the name of the continent that the country is in?\nWould this work? \njavascript\n.fetch({\n  withRelated: {'address.country.continent': function (qb) { qb.column('country_id', 'continent_id', 'name') }\n})\n. Also, on another note, how is it possible for the returned column to be named as we want? I am talking about the 'AS' alias.\n. My question was if I can use 'address.country.continent' but you already sorted it out, thank you.\nFor anyone else viewing this thread:\nAs long as there is a function defined in the schema model, it is possible to fetch it like the way @rhys-vdw described.\nIt is also possible to fetch specific relations like this\njavascript\n'address.country.continent': function (qb) {\n    qb.column('continent_id', 'name');\n},\n'address.country.climate': function (qb) {\n    qb.column('climate_id', 'name');\n},\n...\netc.\nMy question regarding the AS alias is related to the following scenario.\nIf I want to perform two queries on the 'user' table, for example\n``` sql\nSELECT username FROM user WHERE user.status == 'user' AS 'users';\nSELECT username FROM user WHERE user.status == 'admin' AS 'admins';\n```\nHow can it be done?\nI tried\njavascript\n'user': function(qb) {\n    qb.where({status: 'user'}).column('username as users');\n},\n'user': function (qb) {\n    qb.where({status: 'admin'}).column('username as admins');\n},\nbut apparently I am not allowed to use two functions with the same name, nor I can change the names, because they are used to specify the database table.\n. Alright, I solved it by adding different functions in my db schema, like this:\njavascript\ngetUsers: function() {\n    return this.user().query({where: {status: 'user'});\n},\ngetAdmins: function() {\n    return this.user().query({where: {status: 'admin'});\n}\n. ",
    "calmdev": "Ok, well that makes sense to me - I agree with the reasoning. I wanted to ask that way I don't do anything that goes against the progression of this project as I want to continue using it - very promising. I am going to check out the work that you have started with the checkit library.\nThanks for the example. \nI was going to ask about it, but then it suddenly appeared as I was typing this reply. I will try it out!\n. Ok, well that makes sense to me - I agree with the reasoning. I wanted to ask that way I don't do anything that goes against the progression of this project as I want to continue using it - very promising. I am going to check out the work that you have started with the checkit library.\nThanks for the example. \nI was going to ask about it, but then it suddenly appeared as I was typing this reply. I will try it out!\n. I believe this is exactly what I needed. Can you verify if the implementation is ok? I want to share it incase others are interested in this. Your example above demonstrates use for more complex cases, I think - which is pretty cool.\nModel:\njs\nvar User = Bookshelf.Model.extend({\n    tableName: 'users',\n    initialize: function() {\n        this.on('saving', this.validate, this);\n    },\n    validations: {\n        email: ['required', 'validEmail'],\n        username: ['required', 'alphaNumeric'],\n        age: ['isNumeric']\n    },\n    validate: function(model, attrs, options) {\n        return CheckIt(this.toJSON()).run(this.validations);\n    }\n});\nUsage:\njs\nUser.forge({\n    email: 'invalid@testcom',\n    username: 'joe-invalid'\n}).save().then(function(user) {\n    console.log(user.toJSON());\n}, function(errors) {\n    console.log(errors.toJSON());\n    // { email: 'The email must contain a valid email address', username: 'The username must only contain alpha-numeric characters' }\n});\n. Excellent. Thanks for the tip.\n. ",
    "pon": "We've tried implementing this pattern using Bookshelf and CheckIt. Everything behaves as expected, except we are seeing a \"Possibly unhandled TypeError: Invalid validation\" error logged. We are handling the error in the forge promise, but it is still being logged. I'm curious if this is expected behavior or something that other people have run in to.\n. We've tried implementing this pattern using Bookshelf and CheckIt. Everything behaves as expected, except we are seeing a \"Possibly unhandled TypeError: Invalid validation\" error logged. We are handling the error in the forge promise, but it is still being logged. I'm curious if this is expected behavior or something that other people have run in to.\n. https://gist.github.com/peteotto/9415651\n. https://gist.github.com/peteotto/9415651\n. Thanks Tim - I'll give that a try!\n. Thanks Tim - I'll give that a try!\n. ",
    "thetutlage": "It is mandatory to use checkit , i want to use https://www.npmjs.org/package/indicative , but for some reason it does not work\n. It is mandatory to use checkit , i want to use https://www.npmjs.org/package/indicative , but for some reason it does not work\n. Any updates ?\n. Not working , i have tried using all the hooks , saving ,saved , updating , updated and previousAttributes are blank in every case\n. Not working , i have tried using all the hooks , saving ,saved , updating , updated and previousAttributes are blank in every case\n. Yes \nUserModel\njavascript\nbookshelf.model(\"Users\",{\n   initialize: function(){\n        this.on(\"creating\", this._beforeCreate, this);\n        this.on(\"created\", this._afterCreate, this);\n        this.on(\"updating\", this._beforeUpdate, this);\n        this.on(\"updated\", this._afterUpdate, this);\n   },\n   _beforeUpdate: function(model,attrs,options){\n       console.log('model>>>>>',model);\n       console.log('options>>>>>',options);\n   },\n   _afterUpdate: function(model,response,options){\n       console.log('after:model>>>>>',model);\n       console.log('after:options>>>>>',options);\n   }\n});\nNow i will paste the console output from my unit tests\nAfter update\n\n\nBefore update\n\n\nOld email in my database was user@example.com which i updated with new@example.com\nUpdate Query\nvar data_object = {email_address:'new@example.com',email_verified:false};\n      return self.model.forge({id:user_id})\n      .save(data_object,{patch: true});\nHere self.model is something inside collection\n. Yes \nUserModel\njavascript\nbookshelf.model(\"Users\",{\n   initialize: function(){\n        this.on(\"creating\", this._beforeCreate, this);\n        this.on(\"created\", this._afterCreate, this);\n        this.on(\"updating\", this._beforeUpdate, this);\n        this.on(\"updated\", this._afterUpdate, this);\n   },\n   _beforeUpdate: function(model,attrs,options){\n       console.log('model>>>>>',model);\n       console.log('options>>>>>',options);\n   },\n   _afterUpdate: function(model,response,options){\n       console.log('after:model>>>>>',model);\n       console.log('after:options>>>>>',options);\n   }\n});\nNow i will paste the console output from my unit tests\nAfter update\n\n\nBefore update\n\n\nOld email in my database was user@example.com which i updated with new@example.com\nUpdate Query\nvar data_object = {email_address:'new@example.com',email_verified:false};\n      return self.model.forge({id:user_id})\n      .save(data_object,{patch: true});\nHere self.model is something inside collection\n. ",
    "SkylerRogers": "@tgriesser - how safe/reliable is it to handle this issue via the knex config (assuming you desire everything to be stored in UTC)?\nFor example something like this:\nmodule.exports = {\n  development: {\n    client: 'mysql',\n    connection: {\n      host: 'localhost',\n      user: 'root',\n      password: '',\n      database: 'my_database',\n      timezone: 'UTC'\n    }\n  }\n}. @tgriesser - how safe/reliable is it to handle this issue via the knex config (assuming you desire everything to be stored in UTC)?\n\nFor example something like this:\nmodule.exports = {\n  development: {\n    client: 'mysql',\n    connection: {\n      host: 'localhost',\n      user: 'root',\n      password: '',\n      database: 'my_database',\n      timezone: 'UTC'\n    }\n  }\n}.\n",
    "dj-hedgehog": "The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. @sessa The project is under new leadership. Will you provide some tests? Otherwise I will close the PR.. @sessa The project is under new leadership. Will you provide some tests? Otherwise I will close the PR.. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. Re-opened. Please use thumbs up (:+1:) emoji on the original question so have an easier time prioritising and planning the next steps.. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. Re-opened. Please use thumbs up (:+1:) emoji on the original question so have an easier time prioritising and planning the next steps.. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. @ricardograca @Playrom and I talked about Gitter. I was not aware that there is a Gitter channel already. Nonetheless our time is very limited and I don't see myself being able to support Gitter or likewise IRC on top of the work we already have to do for Bookshelf.js. So until we get new or old regular contributors and the project back in shape I would refrain from anything but SO and GitHub itself. What is your opinion on that @Playrom ?\nFor our discourse and internal talk @Playrom and I use Telegram right now. I would love to have you on there too. Please contact me via @Hedge on Telegram.. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. @ricardograca Feel free to reopen such issues yourself.\nI didn't look at any issues individually.. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. Re-opened. Please use thumbs up (:+1:) emoji on the original question so have an easier time prioritising and planning the next steps.. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. @mezod You are right :)\nRe-opened. Please use thumbs up (:+1:) emoji on the original question so have an easier time prioritising and planning the next steps.. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. I reopened this issue and matched the original issue to our new template. Please fill in the required information in it!. I reopened this issue and matched the original issue to our new template. Please fill in the required information in it!. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. Re-opened. Please use thumbs up (:+1:) emoji on the original question so have an easier time prioritising and planning the next steps.. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. Yeah the problem was that the plugin required version 0.9.5 of Bookshelf. Case closed :)\n. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. Good job @chamini2. Can you also add documentation for the feature?. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. The project leadership of Bookshelf recently changed. In an effort to advance the project we close all issues older than one year.\nIf you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nWe also started an open discussion about the future of Bookshelf.js here https://github.com/bookshelf/bookshelf/issues/1600. Feel free to drop by and give us your opinion.\nLet's make Bookshelf great again. @vellotis: I'm sorry. My Bookshel-models are created dynamically by the Strapi-framework. I wrote simplified versions illustrating my problem just for this issue.\nWhy is it expected behaviour that withRelated loads entries related to a related model instead of those related to this very model?\nWhat do I need to specify to retrieve those bids related to this auction?\nI went through the documentation without finding anything pointing me into the right direction.\n. One auction may have multiple bids.\nI want to load those bids associated to a specific Invoice with Auction.forge(id: 1).fetch({withRelated: ['bids']}).\nHowever what I get with Auction.forge(id: 1).fetch({withRelated: ['bids']}) are those bids associated to a certain user (=bidder) and I'm wondering why that is the case.\nDoes that clarify the situation?\n. I'm so ashamed right now. After debugging through a lot of Strapi's code I figured that I overlooked referencing the wrong item from invoice.bids. That was the whole problem. I'm really sorry for wasting your time on this one.\n. @coryallegory We are working on it but our time is also limited. We will make some announcements / start an open discussion soon.\n@jordansexton Thank you for your contribution. Thank you for your contribution \ud83d\udc4d. LGTM!\nHow about you @Playrom ?. Is there a reason to use the lint-staged approach over pretty-quick as described here https://prettier.io/docs/en/precommit.html ? . it is not, sadly. I also dislike this :(. Your guess it right. Yes, it wraps per default at 80 columns however you can set it via printWidth to a more reasonable amount. I suggest 120 columns. This should fix most of your aforementioned problems. How many columns do you suggest @ricardograca . @chentsulin Can you please set printWidth: 120 and run prettier on the codebase again?. ",
    "demisx": "@tgriesser Is Bookshelf.knex the current way to get a hold of the knex instance from the bookshelf instance? Bookshelf.Knex shown in the example above returns undefined.\n. @tgriesser Is Bookshelf.knex the current way to get a hold of the knex instance from the bookshelf instance? Bookshelf.Knex shown in the example above returns undefined.\n. A year later, do you guys still feel strong Bookshelf.js is a better ORM than Sequelize? I am in the process of choosing one and would prefer something that's more like ActiveRecord like. Thank you in advance for sharing your experience and Happy New 2015 Year! \n. @mchicote Thank you very much for your feedback. I didn't know about the pagination issue with the Bookshelf. \n. @tgriesser :+1: So great to hear it.\n. We are using Bookshelf 0.8 on multiple projects and it's great. The support from @bendrucker has been amazing while going through initial hoops. Highly recommend this library.\n. We are using Bookshelf 0.8 on multiple projects and it's great. The support from @bendrucker has been amazing while going through initial hoops. Highly recommend this library.\n. +1 This should be documented. Very helpful.\n. @bendrucker Yeah, I've read this page a couple of times, but I couldn't find a section that talks about limiting columns that are returned withRelated. Please feel free to point out the exact section where this has been documented. Somehow, I am not seeing it and search for qb.column returns nothing.\n. @bendrucker Yeah, I've read this page a couple of times, but I couldn't find a section that talks about limiting columns that are returned withRelated. Please feel free to point out the exact section where this has been documented. Somehow, I am not seeing it and search for qb.column returns nothing.\n. @bendrucker I see. For a newbie like me, showing the example with columns would be really helpful. That's when you get a chance to update the docs. Thank you.\n. @bendrucker I see. For a newbie like me, showing the example with columns would be really helpful. That's when you get a chance to update the docs. Thank you.\n. @bendrucker I'd love to! My understanding I can just edit and save that Wiki page?\n. @bendrucker I'd love to! My understanding I can just edit and save that Wiki page?\n. +1 For joins\n. +1 For joins\n. Do we still need to do new Model().fetch() as the docs show or can we do Model.fetch() too?\n. @bendrucker Would be great if Underscore mentions on http://bookshelfjs.org/ were replaced with lodash ones.  I was under impression that Bookshelf still uses Underscore. I could capture this under Wiki, but looks like there is no page for this. Maybe I should enter it as a separate issue?\n. @bendrucker Would be great if Underscore mentions on http://bookshelfjs.org/ were replaced with lodash ones.  I was under impression that Bookshelf still uses Underscore. I could capture this under Wiki, but looks like there is no page for this. Maybe I should enter it as a separate issue?\n. I believe lodash has better performance, than underscore. Plus up-to-date docs add overall value to the project in general. So, to me, it does make a difference. Your call.\n. I believe lodash has better performance, than underscore. Plus up-to-date docs add overall value to the project in general. So, to me, it does make a difference. Your call.\n. @tgriesser Thank you so much for blazing support, as usual! \n. @ricardograca Thank you for detail explanation. That makes sense. I wonder if setting up a trigger at Postgres db level will have much advantage or side-effects. My understanding I would need to remove hasTimestamps: true from each model.\n. @ricardograca Thanks!\n. @ricardograca What about the updated_at field? Will i need to create some sort of DB trigger via knex.raw to have this field updated only on UPDATE and INSERT or is there a more elegant way doing that in knex? Sorry, just starting out with it.\n. @ricardograca Like your approach, since these fields should be managed in my app automatically.\nFor those who end up here from Google, here is what the modified migration looks like:\njs\nexports.up = function(knex, Promise) {\n  return knex.schema\n    .createTable('sections', function(table) {\n      table.timestamp('created_at').notNullable().defaultTo(knex.raw('now()'));\n      table.timestamp('updated_at');\n      table.increments('id').primary();\n      table.string('code').unique();\n      ... ... ...\n    });\n};\n. Is this the plugin I need to use? https://github.com/tgriesser/bookshelf/wiki/Plugin:-Visibility\n. Is this the plugin I need to use? https://github.com/tgriesser/bookshelf/wiki/Plugin:-Visibility\n. Thank you. For others, here is what was done to get rid of the _pivot* attributes:\njs\n... ... ...\n.then(function(classified) {\n    res.json(classified.toJSON({ omitPivot: true }));\n  });\n@bendrucker  Is there a way to set this globally inside of a model definition, for example, instead of specifying it in every .then block?\n. Thank you. For others, here is what was done to get rid of the _pivot* attributes:\njs\n... ... ...\n.then(function(classified) {\n    res.json(classified.toJSON({ omitPivot: true }));\n  });\n@bendrucker  Is there a way to set this globally inside of a model definition, for example, instead of specifying it in every .then block?\n. :+1: Worked like a charm.\n. :+1: Worked like a charm.\n. I got this working with the following model definition:\njs\nvar Category = base.Model.extend({\n  tableName: 'categories',\n  subCategories: function() {\n    return this.hasMany('Category', 'parent_id')\n  }\n});\nHowever, I have a weird situation when subCategories results return empty array with 2 columns specified, but results are there when I add a third column (see below).\n``` js\nCategory\n    .where({ id: params.catId })\n    .fetch({\n      withRelated: [\n        {\n          subCategories: function(qb) {\n            // this works and subCategories array is filled with results:\n            qb.column('categories.id', 'categories.code', 'categories.parent_id');\n        // however, this call below returns empty subCategories array:\n        // qb.column('categories.id', 'categories.code');\n      }\n    }\n  ],\n  require:true,\n})\n.then(function(model) {\n  res.json(model);\n});\n\n```\nWhat can possibly cause this behavior?\n. I got this working with the following model definition:\njs\nvar Category = base.Model.extend({\n  tableName: 'categories',\n  subCategories: function() {\n    return this.hasMany('Category', 'parent_id')\n  }\n});\nHowever, I have a weird situation when subCategories results return empty array with 2 columns specified, but results are there when I add a third column (see below).\n``` js\nCategory\n    .where({ id: params.catId })\n    .fetch({\n      withRelated: [\n        {\n          subCategories: function(qb) {\n            // this works and subCategories array is filled with results:\n            qb.column('categories.id', 'categories.code', 'categories.parent_id');\n        // however, this call below returns empty subCategories array:\n        // qb.column('categories.id', 'categories.code');\n      }\n    }\n  ],\n  require:true,\n})\n.then(function(model) {\n  res.json(model);\n});\n\n```\nWhat can possibly cause this behavior?\n. I think I got it, but not sure if I can explain it right. Looks like I must include categories.parent_id column for the orm to find the related row, since this column is specified as the foreign_key. I just need to find a proper way to filter it out somewhere, so it's not included into JSON sent to the client.\n. I think I got it, but not sure if I can explain it right. Looks like I must include categories.parent_id column for the orm to find the related row, since this column is specified as the foreign_key. I just need to find a proper way to filter it out somewhere, so it's not included into JSON sent to the client.\n. :+1: Thank you so much. Just wanted to make sure I didn't re-invent the wheel.\n. :+1: Thank you so much. Just wanted to make sure I didn't re-invent the wheel.\n. @c990802 Not sure what you mean.I am using bookshelt already and I do use relations where they are needed.\n@bendrucker I was under impression that I needed to use .query() call only for those cases when a query can't be handled at bookshelf level and I need to fallback to knex. I guess I do need to use it if I want the sql query generate the where clause, right?\n. This was clarified in #595. Thank you.\n. Sorry, I guess I should've worded this differently. I've read documentation a few times and I do realize that .forge() is a convenience method for new(). What I am not clear about is when  there is a good use case to new a model or when not. In docs, I see some methods get called on the model instance and some are called on the Model class.\n. This is what I was suspecting, but was initially confused by all these various ways to access data in the docs. Thank you for clarifying it.\n. :+1: I love this shift. Thank you!\n. @bendrucker Thank you Ben. This worked. The only thing I am missing now is some section and category relations data that comes from joins (i18 and locales tables). I can probably add joins here too, but I see how this approach would be a duplication of code anywhere I need to fetch an Ad model. Wondering, if there is a way to attach join queries to each relation when I define the Ad model in the first place, so ad.load(['section', 'category']) line will automatically perform all the joins I need for a given resource:\njs\n// in ad-model.js\nvar Ad = base.Model.extend({\n  tableName: 'ads',\n  section: function() {\n    return this.belongsTo('Section'); // <- attach section related joins here\n  },\n  category: function() {\n    return this.belongsTo('Category'); // <- attach category related joins here\n  }\n});\n. Sorry, Ben. Not following. I've tried this for the heck of it (see below), but qb is undefined. I am looking for a way to associate these queries in one place, so each time I reference relation section, they are run. Is it doable? Thank you.\nsql\nvar Ad = base.Model.extend({\n  tableName: 'ads',\n  section: function(qb) {\n    qb.innerJoin('sections_i18n', 'sections.id', 'sections_i18n.section_id');\n    qb.innerJoin('locales', 'locales.id', 'sections_i18n.locale_id');\n    qb.where({ 'locales.code': 'en-US' });\n    qb.column('sections.id',  'sections_i18n.name');\n    return this.belongsTo('Section');\n  },\n  ... ... ...\n});\n. Sorry, Ben. Not following. I've tried this for the heck of it (see below), but qb is undefined. I am looking for a way to associate these queries in one place, so each time I reference relation section, they are run. Is it doable? Thank you.\nsql\nvar Ad = base.Model.extend({\n  tableName: 'ads',\n  section: function(qb) {\n    qb.innerJoin('sections_i18n', 'sections.id', 'sections_i18n.section_id');\n    qb.innerJoin('locales', 'locales.id', 'sections_i18n.locale_id');\n    qb.where({ 'locales.code': 'en-US' });\n    qb.column('sections.id',  'sections_i18n.name');\n    return this.belongsTo('Section');\n  },\n  ... ... ...\n});\n. @bendrucker You are one awesome guy. Thank you!\n. @bendrucker You are one awesome guy. Thank you!\n. Guys, anyone please? This is a showstopper right now. Thank you.\n. Guys, anyone please? This is a showstopper right now. Thank you.\n. @ricardograca Do you mean I need to write it out as strings and pass it to the \u2019querymethod?\n. @ricardograca Do you mean I need to write it out as strings and pass it to the \u2019query method?\n. Thank you. My understanding I need to get a reference to knex from a bookshelf instance. But how do I access the bookshelf instance from a Model to begin with? Let's say something like this:\nUser.Bookshelf.knex\n. Thank you. My understanding I need to get a reference to knex from a bookshelf instance. But how do I access the bookshelf instance from a Model to begin with? Let's say something like this:\nUser.Bookshelf.knex\n. I've tried this query:\njs\nUser.where({ roleId: 5 })\n  .query('count', '')\n  .then(function (count) {\n    console.log('\\n count:', count);\n  });\nBut got an error saying Object [object Object] has no method 'then'. \n. I've tried this query:\njs\nUser.where({ roleId: 5 })\n  .query('count', '')\n  .then(function (count) {\n    console.log('\\n count:', count);\n  });\nBut got an error saying Object [object Object] has no method 'then'. \n. Yeap! This worked:\njs\nUser.where({ roleId: 5 })\n  .query()\n  .count()\n  .then(function (count) {\n    console.log('\\n count:', count);\n  });\n. Yeap! This worked:\njs\nUser.where({ roleId: 5 })\n  .query()\n  .count()\n  .then(function (count) {\n    console.log('\\n count:', count);\n  });\n. A+ answer as usual! Thank you Ben. With this level of support, using Bookshelf/Knex has been a real joy.\n. Oh yeah, orderByRaw, of course. Thank you!\n. Thank you @ricardograca for your prompt answer. Please see my responses below. Let me know if you need any additional info.\n\nIt would help if you would post how you're trying to insert the data, and the generated SQL (pass {debug: true} as option to the save method). \n\nI've shown the knex().insert function I am using in the description. I am not sure where to pass { debug: true } as it doesn't appear to support it. Please advise.\n\nAlso, your migration isn't creating a JSONB data column, but a plain JSON one.\n\nPassing true param actually creates a jsonb field. See here. This is what I see in Postgres:\n``` sh\n\\d polls\n                                Table \"public.polls\"\n\nColumn   |           Type           |                     Modifiers                    \n------------+--------------------------+----------------------------------------------------\n id         | integer                  | not null default nextval('polls_id_seq'::regclass)\n question   | jsonb                    | not null\n answers    | jsonb                    | not null\n created_at | timestamp with time zone | not null default now()\n updated_at | timestamp with time zone | \nIndexes:\n    \"polls_pkey\" PRIMARY KEY, btree (id)\n``\n. Totally agree. I wish I could simply specifyjsonbinstead of passing thetrue` flag. Thank you for pointing out that sentence in the docs. Indeed, I missed it. This must be a recent addition as I don't recall seeing it before. I'll be more attentive next time.\nNow, since I am seeding via knex('polls').insert(polls) and answers array is a nested field within polls array element, where do you think I should  add the  JSON.stringify() call to? \n. Yeah, I've already tried to stringify the entire polls object via\njs\nexports.seed = function(knex, Promise) {\n  return Promise.join(\n    knex('polls').insert(JSON.stringify(polls))\n  );\n};\n, but it failed with a huge error:\n\n[10:45:32] Error: Command failed: /bin/sh -c knex --knexfile config/db/knexfile.js seed:run\nerror: insert into \"polls\" (\"0\", \"1\", \"10\", \"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\", \"107\", \"108\", \"109\", \"11\", \"110\", \"111\", \"112\", \"113\", \"114\", \"115\", \"116\", \"117\", \"118\", \"119\", \"12\", \"120\", \"121\", \"122\", \"123\", \"124\", \"125\", \"126\", \"127\", \"128\", \"129\", \"13\", \"130\", \"131\", \"132\", \"133\", \"134\", \"135\", \"136\", \"137\", \"138\", \"139\", \"14\", \"140\", \"141\", \"142\", \"143\", \"144\", \"145\", \"146\", \"147\", \"148\", \"149\", \"15\", \"150\", \"151\", \"152\", \"153\", \"154\", \"155\", \"156\", \"157\", \"158\", \"159\", \"16\", \"160\", \"161\", \"162\", \"163\", \"164\", \"165\", \"166\", \"167\", \"168\", \"169\", \"17\", \"170\", \"171\", \"172\", \"173\", \"174\", \"175\", \"176\", \"177\", \"178\", \"179\", \"18\", \"180\", \"181\", \"182\", \"183\", \"184\", \"185\", \"186\", \"187\", \"188\", \"189\", \"19\", \"190\", \"191\", \"192\", \"193\", \"194\", \"195\", \"196\", \"197\", \"198\", \"199\", \"2\", \"20\", \"200\", \"201\", \"202\", \"203\", \"204\", \"205\", \"206\", \"207\", \"208\", \"209\", \"21\", \"210\", \"211\", \"212\", \"213\", \"214\", \"215\", \"216\", \"217\", \"218\", \"219\", \"22\", \"220\", \"221\", \"222\", \"223\", \"224\", \"225\", \"226\", \"227\", \"228\", \"229\", \"23\", \"230\", \"231\", \"232\", \"233\", \"234\", \"235\", \"236\", \"237\", \"238\", \"239\", \"24\", \"240\", \"241\", \"242\", \"243\", \"244\", \"245\", \"246\", \"247\", \"248\", \"249\", \"25\", \"250\", \"251\", \"252\", \"253\", \"254\", \"255\", \"256\", \"257\", \"258\", \"259\", \"26\", \"260\", \"261\", \"262\", \"263\", \"264\", \"265\", \"266\", \"267\", \"268\", \"269\", \"27\", \"270\", \"271\", \"272\", \"273\", \"274\", \"275\", \"276\", \"277\", \"278\", \"279\", \"28\", \"280\", \"281\", \"282\", \"283\", \"284\", \"285\", \"286\", \"287\", \"288\", \"289\", \"29\", \"290\", \"291\", \"292\", \"293\", \"294\", \"295\", \"296\", \"297\", \"298\", \"299\", \"3\", \"30\", \"300\", \"301\", \"302\", \"303\", \"304\", \"305\", \"306\", \"307\", \"308\", \"309\", \"31\", \"310\", \"311\", \"312\", \"313\", \"314\", \"315\", \"316\", \"317\", \"318\", \"319\", \"32\", \"320\", \"321\", \"322\", \"323\", \"324\", \"325\", \"326\", \"327\", \"328\", \"329\", \"33\", \"330\", \"331\", \"332\", \"333\", \"334\", \"335\", \"336\", \"337\", \"338\", \"339\", \"34\", \"340\", \"341\", \"342\", \"343\", \"344\", \"345\", \"346\", \"347\", \"348\", \"349\", \"35\", \"350\", \"351\", \"352\", \"353\", \"354\", \"355\", \"356\", \"357\", \"358\", \"359\", \"36\", \"360\", \"361\", \"362\", \"363\", \"364\", \"365\", \"366\", \"367\", \"368\", \"369\", \"37\", \"370\", \"371\", \"372\", \"373\", \"374\", \"375\", \"376\", \"377\", \"378\", \"379\", \"38\", \"380\", \"381\", \"382\", \"383\", \"384\", \"385\", \"386\", \"387\", \"388\", \"389\", \"39\", \"390\", \"391\", \"392\", \"393\", \"394\", \"395\", \"396\", \"397\", \"398\", \"399\", \"4\", \"40\", \"400\", \"401\", \"402\", \"403\", \"404\", \"405\", \"406\", \"407\", \"408\", \"409\", \"41\", \"410\", \"411\", \"412\", \"413\", \"414\", \"415\", \"416\", \"417\", \"418\", \"419\", \"42\", \"420\", \"421\", \"422\", \"423\", \"424\", \"425\", \"426\", \"427\", \"428\", \"429\", \"43\", \"430\", \"431\", \"432\", \"433\", \"434\", \"435\", \"436\", \"437\", \"438\", \"439\", \"44\", \"440\", \"441\", \"442\", \"443\", \"444\", \"445\", \"446\", \"447\", \"448\", \"449\", \"45\", \"450\", \"451\", \"452\", \"453\", \"454\", \"455\", \"456\", \"457\", \"458\", \"459\", \"46\", \"460\", \"461\", \"462\", \"463\", \"464\", \"465\", \"466\", \"467\", \"468\", \"469\", \"47\", \"470\", \"471\", \"472\", \"473\", \"474\", \"475\", \"476\", \"477\", \"478\", \"479\", \"48\", \"480\", \"481\", \"482\", \"483\", \"484\", \"485\", \"486\", \"487\", \"488\", \"489\", \"49\", \"490\", \"491\", \"492\", \"493\", \"494\", \"495\", \"496\", \"497\", \"498\", \"499\", \"5\", \"50\", \"500\", \"501\", \"502\", \"503\", \"504\", \"505\", \"506\", \"507\", \"508\", \"509\", \"51\", \"510\", \"511\", \"512\", \"513\", \"514\", \"515\", \"516\", \"517\", \"518\", \"519\", \"52\", \"520\", \"521\", \"522\", \"523\", \"524\", \"525\", \"526\", \"527\", \"528\", \"529\", \"53\", \"530\", \"531\", \"532\", \"533\", \"534\", \"535\", \"536\", \"537\", \"538\", \"539\", \"54\", \"540\", \"541\", \"542\", \"543\", \"544\", \"545\", \"546\", \"547\", \"548\", \"549\", \"55\", \"550\", \"551\", \"552\", \"553\", \"554\", \"555\", \"556\", \"557\", \"558\", \"559\", \"56\", \"560\", \"561\", \"562\", \"563\", \"564\", \"565\", \"566\", \"567\", \"568\", \"569\", \"57\", \"570\", \"571\", \"572\", \"573\", \"574\", \"575\", \"576\", \"577\", \"578\", \"579\", \"58\", \"580\", \"581\", \"582\", \"583\", \"584\", \"585\", \"586\", \"587\", \"588\", \"589\", \"59\", \"590\", \"591\", \"592\", \"593\", \"594\", \"595\", \"596\", \"597\", \"598\", \"599\", \"6\", \"60\", \"600\", \"601\", \"602\", \"603\", \"604\", \"605\", \"606\", \"607\", \"608\", \"609\", \"61\", \"610\", \"611\", \"612\", \"613\", \"614\", \"615\", \"616\", \"617\", \"618\", \"619\", \"62\", \"620\", \"621\", \"622\", \"623\", \"624\", \"625\", \"626\", \"627\", \"628\", \"629\", \"63\", \"630\", \"631\", \"632\", \"633\", \"634\", \"635\", \"636\", \"637\", \"638\", \"639\", \"64\", \"640\", \"641\", \"642\", \"643\", \"644\", \"645\", \"646\", \"647\", \"648\", \"649\", \"65\", \"650\", \"651\", \"652\", \"653\", \"654\", \"655\", \"656\", \"657\", \"658\", \"659\", \"66\", \"660\", \"661\", \"662\", \"663\", \"664\", \"665\", \"666\", \"667\", \"668\", \"669\", \"67\", \"670\", \"671\", \"672\", \"673\", \"674\", \"675\", \"676\", \"677\", \"678\", \"679\", \"68\", \"680\", \"681\", \"682\", \"683\", \"684\", \"685\", \"686\", \"687\", \"688\", \"689\", \"69\", \"690\", \"691\", \"692\", \"693\", \"694\", \"695\", \"696\", \"697\", \"698\", \"699\", \"7\", \"70\", \"700\", \"701\", \"702\", \"703\", \"704\", \"705\", \"706\", \"707\", \"708\", \"709\", \"71\", \"710\", \"711\", \"712\", \"713\", \"714\", \"715\", \"716\", \"717\", \"718\", \"719\", \"72\", \"720\", \"721\", \"722\", \"723\", \"724\", \"725\", \"726\", \"727\", \"728\", \"729\", \"73\", \"730\", \"731\", \"732\", \"733\", \"734\", \"735\", \"736\", \"737\", \"738\", \"739\", \"74\", \"740\", \"741\", \"742\", \"743\", \"744\", \"745\", \"746\", \"747\", \"748\", \"749\", \"75\", \"750\", \"751\", \"752\", \"753\", \"754\", \"755\", \"756\", \"757\", \"758\", \"759\", \"76\", \"760\", \"761\", \"762\", \"763\", \"764\", \"765\", \"766\", \"767\", \"77\", \"78\", \"79\", \"8\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"9\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\") values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60, $61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75, $76, $77, $78, $79, $80, $81, $82, $83, $84, $85, $86, $87, $88, $89, $90, $91, $92, $93, $94, $95, $96, $97, $98, $99, $100, $101, $102, $103, $104, $105, $106, $107, $108, $109, $110, $111, $112, $113, $114, $115, $116, $117, $118, $119, $120, $121, $122, $123, $124, $125, $126, $127, $128, $129, $130, $131, $132, $133, $134, $135, $136, $137, $138, $139, $140, $141, $142, $143, $144, $145, $146, $147, $148, $149, $150, $151, $152, $153, $154, $155, $156, $157, $158, $159, $160, $161, $162, $163, $164, $165, $166, $167, $168, $169, $170, $171, $172, $173, $174, $175, $176, $177, $178, $179, $180, $181, $182, $183, $184, $185, $186, $187, $188, $189, $190, $191, $192, $193, $194, $195, $196, $197, $198, $199, $200, $201, $202, $203, $204, $205, $206, $207, $208, $209, $210, $211, $212, $213, $214, $215, $216, $217, $218, $219, $220, $221, $222, $223, $224, $225, $226, $227, $228, $229, $230, $231, $232, $233, $234, $235, $236, $237, $238, $239, $240, $241, $242, $243, $244, $245, $246, $247, $248, $249, $250, $251, $252, $253, $254, $255, $256, $257, $258, $259, $260, $261, $262, $263, $264, $265, $266, $267, $268, $269, $270, $271, $272, $273, $274, $275, $276, $277, $278, $279, $280, $281, $282, $283, $284, $285, $286, $287, $288, $289, $290, $291, $292, $293, $294, $295, $296, $297, $298, $299, $300, $301, $302, $303, $304, $305, $306, $307, $308, $309, $310, $311, $312, $313, $314, $315, $316, $317, $318, $319, $320, $321, $322, $323, $324, $325, $326, $327, $328, $329, $330, $331, $332, $333, $334, $335, $336, $337, $338, $339, $340, $341, $342, $343, $344, $345, $346, $347, $348, $349, $350, $351, $352, $353, $354, $355, $356, $357, $358, $359, $360, $361, $362, $363, $364, $365, $366, $367, $368, $369, $370, $371, $372, $373, $374, $375, $376, $377, $378, $379, $380, $381, $382, $383, $384, $385, $386, $387, $388, $389, $390, $391, $392, $393, $394, $395, $396, $397, $398, $399, $400, $401, $402, $403, $404, $405, $406, $407, $408, $409, $410, $411, $412, $413, $414, $415, $416, $417, $418, $419, $420, $421, $422, $423, $424, $425, $426, $427, $428, $429, $430, $431, $432, $433, $434, $435, $436, $437, $438, $439, $440, $441, $442, $443, $444, $445, $446, $447, $448, $449, $450, $451, $452, $453, $454, $455, $456, $457, $458, $459, $460, $461, $462, $463, $464, $465, $466, $467, $468, $469, $470, $471, $472, $473, $474, $475, $476, $477, $478, $479, $480, $481, $482, $483, $484, $485, $486, $487, $488, $489, $490, $491, $492, $493, $494, $495, $496, $497, $498, $499, $500\n    at ChildProcess.exithandler (child_process.js:213:12)\n    at emitTwo (events.js:87:13)-    at ChildProcess.emit (events.js:172:7)\n    at maybeClose (internal/child_process.js:818:16)\n    at Socket. (internal/child_process.js:319:11)\n    at emitOne (events.js:77:13)\n    at Socket.emit (events.js:169:7)\n    at Pipe._onclose (net.js:469:12)\n. ",
    "dmalan": "Hi Tim,\nThanks so much for the follow-up.  I just tried out .query, as in the below, though I did have to add {method: 'update'} to force an UPDATE instead of an INSERT (presumably because the entity's idAttribute (id) is undefined in this context, and so .save otherwise defaulted to INSERT):\njavascript\nmodels.Entity\n.forge()\n.query({where: ['uuid', '=', req.params.uuid]})\n.save(attributes, {method: 'update'})\n.then(function(model) {\n    // success\n}, function(err) {\n    // error\n});\nBut by forcing the UPDATE query, I fear I forced a SQL query that isn't quite right.  In particular, the automatically generated query included id = NULL as well as created_at = '2013-08-21 22:17:51':\n--> ComQueryPacket\n{ command: 3,\n  sql: 'update `collection` set `created_at` = \\'2013-08-21 22:17:51\\', `name` = \\'foo\\', `updated_at` = \\'2013-08-21 22:17:51\\' where `uuid` = \\'110ec58a-a0f2-4ac4-8393-c866d813b8d1\\' and `id` = NULL' }\nAs a workaround, we could first .fetch the id of the entity via its uuid, but we'd definitely prefer to avoid the additional SELECT if there's a cleaner way perhaps?\nIf related, I also tried passing .query a function (after upgrading to 0.2.5), but the call to qb.where actually seemed to hang on me, whereby after never prints:\njavascript\nmodels.Entity\n.forge()\n.query(function(qb) {\n    console.log('before');\n    qb.where('uuid', '=', '110ec58a-a0f2-4ac4-8393-c866d813b8d1');\n    console.log('after');\n})\n.save(attributes, {method: 'update'})\n.then(function(model) {\n    // success\n}, function(err) {\n    // error\n});\nMuch obliged!\n. Thanks very much, both changes seem to be working nicely now!\n. Thanks so much for the thoughts, Tim.  Just a few follow-ups, if you don't mind!\nUnrelated to soft deletes, we noticed that code like\njavascript\nmodels.Entity\n.forge()\n.query(function(qb) {\n    qb.where('uuid', '=', '110ec58a-a0f2-4ac4-8393-c866d813b8d1');\n})\n.then(function() {\n    console.log('success');\n}, function(err) {\n    console.log('failure');\n});\noutputs failure, which seems to be the result of del at line 998 in bookshelf.js, which doesn't seem to like it if wheres is undefined (as happens when syncing.id is null):\njavascript\nreturn this.query.where(wheres).del();\nIf we change line 980 from\njavascript\nvar wheres, syncing = this.syncing.resetQuery();\nto\njavascript\nvar wheres = {}, syncing = this.syncing.resetQuery();\nwe do get success and\n--> ComQueryPacket\n{ command: 3,\n  sql: 'delete from `dropboxes` where `uuid` = \\'110ec58a-a0f2-4ac4-8393-c866d813b8d1\\'' }\nas expected.\nMeanwhile, if we do override sync to implement soft deletes with\njavascript\nsync: function(options) {\n    var sync = Bookshelf.Model.prototype.sync.apply(this, arguments);\n    if (!options.hardDelete)  {\n        sync.del = function(options) {\n            return sync.update.call(sync, {deleted_at: new Date()});\n        };\n    }\n    return sync;\n},\nwe actually get a query of\n--> ComQueryPacket\n{ command: 3,\n  sql: 'update `dropboxes` set  where `uuid` = \\'110ec58a-a0f2-4ac4-8393-c866d813b8d1\\'' }\nwhich isn't syntactically valid (because of the missing key/value pair after set).  Should we be passing in deleted_at in some other way perhaps?\nMany thanks!\n. Thanks, Tim, working nicely now!\nFor selects, meanwhile, we're currently using\njavascript\nthis.on('fetching', function(model, columns, options) {\n    model.query({whereNull: 'deleted_at'});\n});\nwhich works well.  I was curious to ask, though, what you had in mind for soft delete-aware selects using sync?  Whereas\njavascript\nsync.del = function(options) {\n    return sync.update.call(sync, {deleted_at: new Date()});\n};\nworks well for overriding del, doing the same for select, as with\njavascript\nsync.select = function(options) {\n    return sync.select.call(sync, {deleted_at: null});\n};\nresults, we realized, in infinite recursion.  Just curious if you had a somewhat different approach in mind for injecting the deleted_at clause into sync.select?\n. ",
    "D0rmouse": "Whoops, I'm sorry... Too eager with the complaints. Seems I've caused my own problem.\n. ",
    "servel333": "For other readers, I was able to get around this in a sort-of convoluted way but that works.\nNo timestamps in a save:\n``` javascript\nvar saveWithoutTimestamps = function(Model, modelAttributes, saveAttributes, saveOptions) {\n  var model = new Model(modelAttributes);\n  model.hasTimestamps = false;\n  return model.save(saveAttributes, saveOptions);\n};\nvar Model = ...;\nsaveWithoutTimestamps(Model, { attr: \"value\" })\n  // No createdAt or updatedAt is set\n  .then( ... )\n  .catch( ... );\n```\nOptional timestamps in save\n``` javascript\nvar saveModel = function(Model, modelAttributes, saveAttributes, saveOptions) {\n  var model = new Model();\n  var timestamps = model.timestamp(saveOptions);\n  model.hasTimestamps = false;\n  saveAttributes = _.defaults({}, saveAttributes, timestamps);\n  model.set(modelAttributes);\n  return model.save(saveAttributes, saveOptions);\n};\nvar Model = ...;\nsaveModel(Model, { attr: \"value\" }, { createdAt: new Date() })\n  // createdAt is set to the date passed in\n  // updatedAt is set to the default value normally set by the model.\n  .then( ... )\n  .catch( ... );\n```\n. Possibly. I wasn't aware you could pass options into a model like that.\n. Possibly. I wasn't aware you could pass options into a model like that.\n. Just to add to this discussion and give a use-case, we are implementing an API. In our production environment we have three databases.\nOne is a main database where we draw users, accounts, etc.\nThen, there is a live database that has order information in a payment system.\nFinally, there is a sandbox database that is identical to live except data.\nsandbox is for our customers to use to build and test against our API while live is for them to run their production code against. We need both live and sandbox loaded at the same time since any request coming in could be made against either database, and we need identical models for both, therefore we were planning on using the same model.\n. Just to add to this discussion and give a use-case, we are implementing an API. In our production environment we have three databases.\nOne is a main database where we draw users, accounts, etc.\nThen, there is a live database that has order information in a payment system.\nFinally, there is a sandbox database that is identical to live except data.\nsandbox is for our customers to use to build and test against our API while live is for them to run their production code against. We need both live and sandbox loaded at the same time since any request coming in could be made against either database, and we need identical models for both, therefore we were planning on using the same model.\n. Thanks for the swift and wonderful response. parse and format are precisely what I was looking for.\n. ",
    "ricardograca": "I also don't know how long that has been supported, but it's there: http://bookshelfjs.org/#Model :)\n. For reference the terminology used in Bookshelf follows the same convention of ActiveRecord or CakePHP, which seems to be the standard in most ORM libraries these days.\n. Well, you can always create a \"Make-Bookshelf-Like-Backbone-Again\" plugin with this kind of stuff, since the needed functionality is all in place :)\n. Reopening this since it seems to also be a problem in PR #1800.\nThis Stack Overflow question could be of interest.. https://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/\n. Was this already implemented? I see a returning: undefined property in my queries, but I can't figure out how to make the save method return anything.\n. I tried changing the returning value in the saving event of my model like this:\njavascript\nvar MyModel = bookshelf.Model.extend({\n  /* ... */\n  initialize: function() {\n    this.on('saving', function(model, attrs, options) {\n       options.query.returning('*')\n    })\n  }\n})\nThe query seems to be correct, yet nothing is returned apart from the attributes already set during the model creation (in this case only id):\nsql: 'update \"my_models\" set \"id\" = $1 where \"id\" = $2 returning *'\nIs there anything extra that needs to be done to make returning actually return something, or is it not implemented at all?\n. @tkambler Yes.\n. @blah238 Cool! Do you want to add it to the list of community plugins?. This isn't working. Tried a few simple use cases:\njs\nAuthor.forge({id: 1, ownPosts: [{blog_id: 1, name: 'testing'}]}).save()\nAuthor.forge({id: 1}).save({ownPosts: [{blog_id: 1, name: 'testing'}]})\nAuthor.forge().save({ownPosts: [{blog_id: 1, name: 'testing'}]})\nAlso tried with a belongsTo relation instead of the hasMany from the example above and the result was the same:\n\nError: Undefined binding(s) detected\n\nThe relation seems to be set correctly on the model, but then saving the model fails every time. Some of the code and ideas here can probably be reused on another working implementation.. @michaelbearne Are you still interested in getting this merged? I'm trying to adapt the PR to the current code base and seems like I succeeded but it's causing problems with a test for eager loading belongsToMany through.\nThis also seems to conflict heavily with the changes in #1397.. @michaelbearne Are you still interested in getting this merged? I'm trying to adapt the PR to the current code base and seems like I succeeded but it's causing problems with a test for eager loading belongsToMany through.\nThis also seems to conflict heavily with the changes in #1397.. Closing this due to lack of response. If anyone wants to submit a new PR based on the current code base, and with the corresponding tests, this feature can still make it in.. I also ran into this same issue a while back. What happens is that the feature to auto-update the timestamp columns is a part of Bookshelf, when you use its models to access and modify data.\nSeeds, on the other hand, are a feature of Knex which has no knowledge of model definitions. It accesses the databases directly (well, through the respective node driver). Notice how you're not using any models in the seed definition, but using the table name directly.\nCurrently you must update those columns explicitly in your seed files. Or use a default value in your database.\n. You're better off just setting the default value to NOW() on your table definitions. If you also use knex for migrations you can do that with something like:\nknex.schema.createTable('stuff', function(t) {\n    // ...\n    t.timestamp('created_at').notNullable().defaultTo(knex.raw('now()'))\n}\nor using plain old SQL:\nCREATE TABLE stuff (..., created_at DATETIME WITH TIMEZONE NOT NULL DEFAULT NOW());\n. If you are only going to use Bookshelf to update the database, then it will set the value for you already (provided you use the timestamps: true model option). In this case you only need the initial value, so use the same logic as for the created_at column. Or set its value in JavaScript as bendrucker mentioned.\n. Exactly the same as created_at.\n. You're using an old version of MySQL apparently: http://stackoverflow.com/questions/4489548/why-there-can-be-only-one-timestamp-column-with-current-timestamp-in-default-cla\n. @AndrewKiri table.timestamps() is not provided by Bookshelf, but Knex. According to the source, .timestamps() doesn't return anything, so your example will not work. Where did you get that example from?. @oscar-g Doubtful, since the plan is the opposite: move plugins to their own repository/npm module. There are plans to promote the registry plugin to a built-in feature, since it is really useful, used by a lot of people and an integral part of the next-gen API we're working on, but plugins that aren't as widely used won't receive the same treatment.\n. @oscar-g Doubtful, since the plan is the opposite: move plugins to their own repository/npm module. There are plans to promote the registry plugin to a built-in feature, since it is really useful, used by a lot of people and an integral part of the next-gen API we're working on, but plugins that aren't as widely used won't receive the same treatment.\n. @jadengore I'm not sure. Personally I don't have anything against it. I was just mentioning the previous plan. @rhys-vdw or @tgriesser are more qualified for these decisions.\n. As I see it it's just a matter of style or personal preference.\n. As I see it it's just a matter of style or personal preference.\n. hasOne() <- The other model contains the foreign key\nbelongsTo() <- The current model contains the foreign key\nIt seems to me that, judging by your first example, a node hasOne notification, and that a notification belongsTo a node. You don't have to use both relations BTW. Just the ones that you actually need.\n. @wrouesnel I think you can do something like this:\njavascript\nmodels.Node = Bookshelf.Model.extend({\n  /* ... */\n  unansweredNotifications: function() {\n    return this.hasMany('Notification', 'nodeid').query('where', 'unanswered', null);\n  }\n})\nDid you try that? You might have to do a raw where due to the null, but I'm not sure about that.\n. How are you defining the Field model? Also I'm pretty sure that even models that don't need to be registered in the registry but do need to access other models that are, must also be declared with the registry syntax of db.model('Stuff', { /*...*/ }).\n. Closing as duplicate of #583.\n. You mean the Model's extend? Isn't it derived from Backbone's extend anyway?\n. You mean the Model's extend? Isn't it derived from Backbone's extend anyway?\n. Sure, I agree. The regular way of extending means that properties defined in the child take precedence over those defined in the parent. What I hadn't realized was that the built-in extend was working like the ES6 one, since I'm not using that stuff yet.\nI guess anyone affected by this issue (only me?) would have to do the merging explicitly since it's a custom behavior. That can probably be done in a plugin.\nBTW, I'm pretty sure there will be a lot of plugins for Bookshelf once you guys finish the rewrite.\n. Sure, I agree. The regular way of extending means that properties defined in the child take precedence over those defined in the parent. What I hadn't realized was that the built-in extend was working like the ES6 one, since I'm not using that stuff yet.\nI guess anyone affected by this issue (only me?) would have to do the merging explicitly since it's a custom behavior. That can probably be done in a plugin.\nBTW, I'm pretty sure there will be a lot of plugins for Bookshelf once you guys finish the rewrite.\n. This?\n. This?\n. On your category's initializemethod  you're calling the parent's initialize immediately, without waiting for the checkParentId promise to resolve, so your code is behaving as it should. I'm not sure if it's a good idea to have two concurrent saving event handlers like that.\n. On your category's initializemethod  you're calling the parent's initialize immediately, without waiting for the checkParentId promise to resolve, so your code is behaving as it should. I'm not sure if it's a good idea to have two concurrent saving event handlers like that.\n. Why are you using Promise.all with a single Promise? The purpose of that method is making sure an array of several Promises/values are all resolved, but your array only has a single promise so it's pointless.\n. Why are you using Promise.all with a single Promise? The purpose of that method is making sure an array of several Promises/values are all resolved, but your array only has a single promise so it's pointless.\n. Something like:\nAd.query(scope).orderByRaw('details->>\\'price\\'')\nOr if you're ok with mixing quoting styles (or you already use \" for all your strings):\nAd.query(scope).orderByRaw(\"details->>'price'\")\nWhen you call .query() you get access the underlying knex query builder, so you can use all the methods specified in the knex docs: http://knexjs.org/#Builder-orderByRaw\n. In regards to #1600 this is still an issue. I just tested and the linked test case still fails.\nVersions:\n\nbluebird@3.5.0\nbookshelf@0.10.4\nknex@0.13.0\nsqlite3@3.1.8\n. @Playrom It looks like @kirrg001 used the workaround I mentioned above. This bug isn't easy to fix unfortunately.. This is probably the same problem reported in issue #629.\n. This is probably the same problem reported in issue #629.\n. @stoxx Can you check if it's the same issue mentioned above? I know the other one isn't about morphTo but there is a similar behavior of parentFk being undefined when calling .fetchAll({ withRelated: ['relation'] }) which seems to be the issue here.. And what was supposed to happen? Also, can you provide code that demonstrates the issue?. Can you try this little variation and see if it helps?\n\n``` javascript\nexports.bib = function(req, res) {\n  Bib.forge()\n  .query({limit: 3})\n  .fetchAll({columns: ['id', 'record_num']})\n  .tap(function(bib) {\n    return bib.each(function(bibThingy) {\n       bibThingy.load(['biblocation'])\n    }\n  }).then(function(bib) {\n    res.json(bib.toJSON());\n  })\n};\n```\nIf there are any errors above try replacing the .tap with .then. If the toJSON() fails ignore it for now and just look at the returned bib model objects and check if they are as you expect them to.\n. I see. I was trying to rule out something potentially related with issue #629. I would say your issue is not related with that.\nLooking more closely I'd say your code is working as intended. Are you sure those Bib models that are being returned do indeed have biblocations associated with them?\n. What database adapter are you using?\n. Yeah, using an alias is not supported in WHERE clauses in PostgreSQL. AFAIK the behavior you are after is non-standard and only supported on MySQL.\n. Closing this for lack of activity. If you have any new data in regards to this issue you can leave a comment and we may reopen it.\n. Check this out: http://bookshelfjs.org/#Model-withPivot\n. The thing is that .where is a shortcut to .query('where', ...), which itself is a shortcut to the underlying knex instance's query builder. Knex is lower level than Bookshelf and doesn't know anything about it, which means that knex doesn't know anything about Bookshelf models, and since the .parse() method is a Bookshelf method that only affects Bookshelf models, it doesn't come into play when calling .where().\nRight now the only \"solution\" is that you have to remember that by calling .where() you're accessing lower-level methods, so model logic doesn't apply. If you're using .parse() to transform the names of database columns you'll have to use the original untransformed names when using .where(), just like you have to when using .query().\n. Update statements? As in calling .save() on a model that has an id?\n. Please post the complete code that triggers that incorrect SQL query.\n. Yeah, that's issue #642. Unfortunately I can't help you in this case since I never encountered that problem, but other users might be able to offer some assistance.\n. Still a valid issue.. Probably a stupid question, but where did this NullMorphToAssociation idea came from?\n. @kirrg001 Can you take a quick look at this? The part that worries me about this implementation is that it's not possible to implement an interface that closely resembles the behavior of belongsTo without foreign key. The proposed solution just implements the fetch method which means that if the user tries to use any other method on the fake relation model it will just lead to a different error.\nSeems like it's just trading one error for potentially another.. @kirrg001 Can you take a quick look at this? The part that worries me about this implementation is that it's not possible to implement an interface that closely resembles the behavior of belongsTo without foreign key. The proposed solution just implements the fetch method which means that if the user tries to use any other method on the fake relation model it will just lead to a different error.\nSeems like it's just trading one error for potentially another.. > Why would article.modifiedBy() return null?\nPresumably because it's the only relation type where a target model isn't defined before actually fetching the record, so we can't instantiate a new blank model. However, I think the current behavior of throwing an error makes sense, but I also agree with Rhys when he says that:\n\nThe error message \"The target polymorphic model was not found\" makes sense if there is a string value, but it is not one of the listed columns.\n\nSo, what I propose here is to keep everything as is and just have two different error messages:\n\nIf there is no _type and/or _id the message would say something like \"The target polymorphic model could not be determined because it's missing the type and/or id columns\".\nIf there is a _type but it's not one of the expected types the message would be \"The target polymorphic model foo is not one of the defined target types\".. > Why would article.modifiedBy() return null?\n\nPresumably because it's the only relation type where a target model isn't defined before actually fetching the record, so we can't instantiate a new blank model. However, I think the current behavior of throwing an error makes sense, but I also agree with Rhys when he says that:\n\nThe error message \"The target polymorphic model was not found\" makes sense if there is a string value, but it is not one of the listed columns.\n\nSo, what I propose here is to keep everything as is and just have two different error messages:\n\nIf there is no _type and/or _id the message would say something like \"The target polymorphic model could not be determined because it's missing the type and/or id columns\".\nIf there is a _type but it's not one of the expected types the message would be \"The target polymorphic model foo is not one of the defined target types\".. Try issue #552.\n. Reopening this to get the discussion going again.. I'm not entirely sure why format is involved in reading operations, but this will be investigated in due time. I agree with you on how these methods should work, but the issue of having the idAttribute always present in a model irregardless of what parse and format might do to a model is still a good point that this issue raises.\n\nAs for the usefulness of these methods, maybe in time they will become unnecessary.. It's being discussed. Take a look at issues #90 and #552. There are probably other issues where this is mentioned, but I can't find them now.\n. You are probably looking for this instead: http://bookshelfjs.org/#Model-format\n. There's no way this would work without defining the 'Tenant' model somewhere (i.e.: App.model('Tenant', ???)). Wherever you are doing that you forgot to do the same with the Landlord model.\n. Are you requiring the Landlord and Tenant models somewhere in your code before trying to access them in other models (in this case the User model)?\n. Then I'm not sure how the related('tenant') is even working in the first place :confused: The bottom line is that you must require those models somewhere before they can be used.\n. It happens :) You know, I read your updates and looked at the title many\ntimes and still didn't notice the LanDORD. I'm sure Ben also didn't catch\nit :D\nEm 15/04/2015 19:38, \"Rob Wilkerson\" notifications@github.com escreveu:\n\nAw, s**t. I'll do everyone a favor and just punch myself in the head. It\nwas a freaking typo. A typo that is, I guess, reasonably understandable in\nsome ways, but a typo nonetheless and I couldn't feel like a bigger idiot\nright now.\nNot only is it in my code, but I copied and pasted the error message\ndirectly from my console and the same typo is right in the subject of this\nissue. I missed this all over the place. My apologies, guys.\nhttps://gist.github.com/robwilkerson/62e4201705cd688ac80f#file-user-js-L31\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/691#issuecomment-93525902.\n. You would have to access the knex query builder. See issues #662, #590, #383, #98 and #61 for further info.\n. Closing this for lack of activity. If you need any further clarification about this issue we can reopen it.\n. When you define a initialize() method (or any other method or property) on a child object it will override the parent's initialize() method, so it will never be called. If you also want the parent's initialize() to be executed when a child is created you have to explicitly call it from the child's initialize() method.\n\nSomething like:\nvar Descendant = Parent.extend({\n  initialize: function() {\n    Parent.prototype.initialize.call(this)\n    // ...\n  }\n})\nI don't know if Bookshelf allows attaching multiple events of the same type to a model though.\nCheckout issue #605 for a similar problem.\n. It depends. If you are overriding the base Bookshelf Model in those plugins then it's anyone's guess as to which plugin will \"win\". The only certainty is that your application won't work as you want it to.\nIf your plugins just create new built-in model types that you then extend on your application, then there shouldn't be any problems if you do it properly.\n. You can override Bookshelf.Model all you want. What you can't do is override built-in methods with something else and not call the parent method (in case the parent method does something useful).\nIn that example you gave, if you extend the Model object into another Model, and on this second model you override initialize() with something else without calling the parent's initialize() method you will indeed lose the \"scopes\" functionality in any instances created from that second Model.\nThe only reason that plugin doesn't call the parent's initialize() method is because by default it doesn't do anything.\n. As for your second question, you call the parent's method like above. However, unless you control everything it's possible there will be contradictory event handlers.\n. If the first plugin defines a custom initialize(), and the second one does the same thing, then only the second one would stick around when you extend your own models. I think. You better try it yourself because this is something I never did myself.\n. According to the docs that only works if you pass a hash of properties to the save() method itself.\n. Have you tried simply passing the columns option to fetchAll?\nSomething like:\nFileContent.fetchAll({columns: ['id', 'name']})\nThis should work when fetching individual models, but I don't know if it's also supported on fetchAll.\n. In your model's initialize method what happens if you don't run that\n__super__.initialize() method?\nEm 22/04/2015 23:04, \"Rob Wilkerson\" notifications@github.com escreveu:\n\nWow. It looks like something is going on. If I log model._events at the\ntop of my User.encryptPassword() handler, I get the dump below. What\ncould I be doing to cause something like this?\n{ creating:\n    [ { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] } ],\n   saving:\n    [ { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] } ],\n   all:\n    [ { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] } ] }\n { creating:\n    [ { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] } ],\n   saving:\n    [ { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] },\n      { callback: [Function], context: undefined, ctx: [Object] } ],\n   all:\n    [ { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] },\n      { callback: [Function], context: [Object], ctx: [Object] } ] }\nBut, as weird as that looks to me, it still doesn't top the fact that my\nAddress event handler is also being called.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/706#issuecomment-95352415.\n. Yeah, there is clearly something in common with all models that is causing that strange behavior, but I also can't see it.\n\nDoes this only happen when testing or in other scenarios as well?\n. Then how did it still produced problems when I suggested that you commented\nout that line?\nEm 30/04/2015 14:34, \"Rob Wilkerson\" notifications@github.com escreveu:\n\nFor anyone doing a search later...\nFinally tracked this and got it fixed, I think. Seems that the primary\nissue was the way I was calling the parent object's initialize() method.\nWhen I started playing with Bookshelf, I was figuring things out by\ninspecting what I had. In doing so, I had the following code in my custom\nmodel (e.g. User):\ninitialize: function() {\n    this.constructor.super.initialize();  // <--- Problem\n    this.on('saving', this.encryptPassword);\n},\nThis seemed to work and it made for pretty readable code. The key to the\nfix was this change:\ninitialize: function() {\n    App.prototype.initialize.call(this);  // App is my base model\n    this.on('saving', this.encryptPassword);\n},\nIt makes sense now, but the original way \"worked\" and read better to me so\nit seemed correct enough until the fallout started appearing. The call to\nthe prototype method is how it's shown in the docs, but no reason was given\nso it didn't really hit me that this was at the heart of the issue.\nAnyway, I seem to be back on track. Thanks again for all of the help.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/706#issuecomment-97790815.\n. Then how did it still produced problems when I suggested that you commented\nout that line?\nEm 30/04/2015 14:34, \"Rob Wilkerson\" notifications@github.com escreveu:\nFor anyone doing a search later...\nFinally tracked this and got it fixed, I think. Seems that the primary\nissue was the way I was calling the parent object's initialize() method.\nWhen I started playing with Bookshelf, I was figuring things out by\ninspecting what I had. In doing so, I had the following code in my custom\nmodel (e.g. User):\ninitialize: function() {\n    this.constructor.super.initialize();  // <--- Problem\n    this.on('saving', this.encryptPassword);\n},\nThis seemed to work and it made for pretty readable code. The key to the\nfix was this change:\ninitialize: function() {\n    App.prototype.initialize.call(this);  // App is my base model\n    this.on('saving', this.encryptPassword);\n},\nIt makes sense now, but the original way \"worked\" and read better to me so\nit seemed correct enough until the fallout started appearing. The call to\nthe prototype method is how it's shown in the docs, but no reason was given\nso it didn't really hit me that this was at the heart of the issue.\nAnyway, I seem to be back on track. Thanks again for all of the help.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/706#issuecomment-97790815.\n. As a workaround I think you can use load individually on each returned user instead of trying to eager load all of them at once. Something like:\n\njavascript\n// ...\n.then(function () {\n  return User.fetchAll()\n}).then(function (users) {\n  return users.each(function (user) {\n    return user.load(['roles'])\n  })\n}).then(function(users) {\n  users.each(function (user) {\n    console.log(user.id, user.related('roles').length);\n  });\n}).then( // ...\n. There's a note on the docs explaining it in the Relation Types section.\nYou can also check the model.relations object for the presence of the relation you're looking for. Example:\njavascript\nif (myModel.relations.foobars) {\n  // do stuff\n}\nAlso check issue #407 which asks the exact same question as this one.\n. There's a note on the docs explaining it in the Relation Types section.\nYou can also check the model.relations object for the presence of the relation you're looking for. Example:\njavascript\nif (myModel.relations.foobars) {\n  // do stuff\n}\nAlso check issue #407 which asks the exact same question as this one.\n. @rhys-vdw The only problem with your example is that if some other process or request changes something in the collection while the first process/request hasn't finished consuming it, that may lead to conflicts. Not sure what the right thing to do would be in that case.\n. Other than that is there any reason why this can't be the default for how .load() works? Is there any case where you'd want to load a relation from the database multiple times in the same request?\n. Yes, this would have to be done with other breaking changes. I'm just trying to figure out how this relationship refreshing can be kept coherent with the model refresh feature.\n. I may be misunderstanding your data model, but it seems like you have an error in your relations. I would think that a Product hasMany Description(s) rather than belonging to a single description. The latter doesn't make much sense semantically, further compounded by your choice of relation attribute name: \"descriptions\".\nWith that out of the way, it's not very clear what you're asking. Are you trying to get a list of products that match a certain description? If that is the case then check out issue #141.\n. I may be misunderstanding your data model, but it seems like you have an error in your relations. I would think that a Product hasMany Description(s) rather than belonging to a single description. The latter doesn't make much sense semantically, further compounded by your choice of relation attribute name: \"descriptions\".\nWith that out of the way, it's not very clear what you're asking. Are you trying to get a list of products that match a certain description? If that is the case then check out issue #141.\n. http://bookshelfjs.org/#Model-related\nhttp://bookshelfjs.org/#Model-relation-types\n. http://bookshelfjs.org/#Model-related\nhttp://bookshelfjs.org/#Model-relation-types\n. That's because models.related('users') is a collection, so it doesn't have a related method. However each model that is in that collection does have that method.\nAlthough I didn't test it I think you can get all your posts using one of the underscore methods:\njavascript\nvar posts = models.related('users').reduce(function(list, user) {\n  return list.concat(user.related('posts'))\n}, [])\nMaybe there's a better way, so let me know if you find it.\n. That's because models.related('users') is a collection, so it doesn't have a related method. However each model that is in that collection does have that method.\nAlthough I didn't test it I think you can get all your posts using one of the underscore methods:\njavascript\nvar posts = models.related('users').reduce(function(list, user) {\n  return list.concat(user.related('posts'))\n}, [])\nMaybe there's a better way, so let me know if you find it.\n. I'm planning to follow through with Tim's decision and making this the default, but for all types of fetch calls.. Composite keys is being tracked in issue #93.\n. Composite keys is being tracked in issue #93.\n. Can you provide a more complete example? I don't understand where the rest of the where conditions are coming from.\nAnd the query that you were expecting would also help.\n. Can you provide a more complete example? I don't understand where the rest of the where conditions are coming from.\nAnd the query that you were expecting would also help.\n. So, you fetched the token once and then are trying to fetch it again (your first example) in the same request? What's your primary key?\nBTW, calling .query and adding something to the query builder like you are doing does precisely that: adds something to the already existing query. If you want to override the complete WHERE clause I'm almost certain you'll have to:\na) create a new model with only the attributes you're after: new Token({id: 3}).fetch().then(/* ... */)\nb) use Knex directly: knex('tokens').where('id', 3).then(/* ... */)\nYour first example also doesn't make much sense, because you're trying to limit the query on something that is already part of the query to begin with. That's why you're getting the same condition twice in the resulting query.\nIf you want to limit the returned columns use the columns: ['blah'] option in fetch().\nA more thorough explanation of what you're trying to achieve would help, otherwise all we can do is give generic answers.\n. So, you fetched the token once and then are trying to fetch it again (your first example) in the same request? What's your primary key?\nBTW, calling .query and adding something to the query builder like you are doing does precisely that: adds something to the already existing query. If you want to override the complete WHERE clause I'm almost certain you'll have to:\na) create a new model with only the attributes you're after: new Token({id: 3}).fetch().then(/* ... */)\nb) use Knex directly: knex('tokens').where('id', 3).then(/* ... */)\nYour first example also doesn't make much sense, because you're trying to limit the query on something that is already part of the query to begin with. That's why you're getting the same condition twice in the resulting query.\nIf you want to limit the returned columns use the columns: ['blah'] option in fetch().\nA more thorough explanation of what you're trying to achieve would help, otherwise all we can do is give generic answers.\n. I could swear someone opened an issue already about being able to reload data for a model that had already been fetched, but I can't find it now. You may be able to find it with a more thorough search through the existing issues.\nAbout the main issue I still don't understand why you think this is different from what's documented. I totally agree that Bookshelf's documentation doesn't always answer every question, but in this case it says this about the query method:\n\nit will call the specified method on the query builder, applying any additional arguments from the model.query call ... returning the current model. \n\nSo, it will add to the existing query and return the current model, after which the fetch() method is called in your example, and it says that the fetch is called\n\nusing any attributes currently set on the model to form a select query\n\nso, it is the exact behavior you're seeing. Whether it's what you wanted or not is a different matter, but to me the docs are clear on this. If you think that something is missing from the docs it would greatly help if you explained what it is and what caused you doubts in regards to the existing docs.\n. I could swear someone opened an issue already about being able to reload data for a model that had already been fetched, but I can't find it now. You may be able to find it with a more thorough search through the existing issues.\nAbout the main issue I still don't understand why you think this is different from what's documented. I totally agree that Bookshelf's documentation doesn't always answer every question, but in this case it says this about the query method:\n\nit will call the specified method on the query builder, applying any additional arguments from the model.query call ... returning the current model. \n\nSo, it will add to the existing query and return the current model, after which the fetch() method is called in your example, and it says that the fetch is called\n\nusing any attributes currently set on the model to form a select query\n\nso, it is the exact behavior you're seeing. Whether it's what you wanted or not is a different matter, but to me the docs are clear on this. If you think that something is missing from the docs it would greatly help if you explained what it is and what caused you doubts in regards to the existing docs.\n. Closing this for lack of activity. If you need any further clarification about this issue we can reopen it.\n. From the docs:\n\nIf you only wish to update with the params passed to the save, you may pass a {patch: true} flag to the database\n\nSince you're passing null params to the save() method, there is nothing to update, so that SQL is not totally unexpected.\nMaybe Bookshelf should throw an error in that case, but I don't know what's the policy in terms of error handling in the library.\n. I'm also a little worried about breaking something, but we can just merge it and then revert it if we get flooded with angry bug reports. I think the main problem is going to be additional values when using keys(), values() and pairs(). What if people are somehow counting the number of values in those cases and using that in some way? Or expecting those arrays to only contain actual model attributes and not relations?\nA safer approach would be to create a special case for the omit() method and use .toJSON() only in that case. What do you guys think?\nPS: I can't think of any case where invert would be useful :\\ Why was it included in the first place?\n. I'm also a little worried about breaking something, but we can just merge it and then revert it if we get flooded with angry bug reports. I think the main problem is going to be additional values when using keys(), values() and pairs(). What if people are somehow counting the number of values in those cases and using that in some way? Or expecting those arrays to only contain actual model attributes and not relations?\nA safer approach would be to create a special case for the omit() method and use .toJSON() only in that case. What do you guys think?\nPS: I can't think of any case where invert would be useful :\\ Why was it included in the first place?\n. I would include both the visibility and the registry plugins by default. The registry in particular should be the preferred way of declaring and accessing models, since it's usually required unless your application only has 1 or 2 models, or you put them all in the same file or you really like to write require.\n. I would include both the visibility and the registry plugins by default. The registry in particular should be the preferred way of declaring and accessing models, since it's usually required unless your application only has 1 or 2 models, or you put them all in the same file or you really like to write require.\n. Closing due to lack of response. If anyone is still interested in this we can discuss it further.. Well, first {name: 'test'} is not a valid option for the query method. Anyway, this should do what you want:\njavascript\nModel.query().where('stuff_id', 34).count()\n// or\nModel.query({\n  where: {'stuff_id', 34}\n}).query().count()\nNote that in the first case calling query() without parameters returns the query builder which is subsequently used to access other query building methods, where as in the second example the first call to query() is passing some options, so it will not return a query builder, but a model instance instead. This is why it is necessary to call query() a second time without parameters.\n. What you have seems almost right. The problem is that you're calling .save() on a Promise object which isn't right.\nReplace the .save() line and the .tap() call with:\n``` javascript\n.then(function(existingAddress) {\n  if (existingAddress) {\n    console.log(existingAddress);\n    throw new Error('EXISTS');\n  }\n// Not sure what you're trying to save here, since you don't see to be\n  // passing any new data to the Tenant or the existingAddress model\n  return existingAddress.save() // Tenant.save({some: 'data'}) ??\n})\n```\nI'm not sure if this is really what you want. If not then you need to explain in more detail what you're trying to accomplish.\n. What does currentAddress() do then?\n. Got it. This should do what you want:\n``` javascript\nTenant.forge(req.user).related('currentAddress').fetch().then(function(currentAddress) {\n  if (currentAddress) {\n    console.log(currentAddress);\n    throw new Error('EXISTS');\n  }\nreturn currentAddress.save({ / your new address data /})\n}).then(function(address) {\n  res.setHeader('Location', '/tenant/addresses/' + address.id);\n  return res.status(201).send();\n}).catch(function(err) {\n  return err === 'EXISTS'\n    ? res.status(409).send('A current address already exists')\n    : res.status(500).send();\n});\n``\n. Yeah, I was almost certain you were close. I think you can also replace that.related('currentAddress')with what you had (.currentAddress()`) but I never use it like that so I wasn't entirely sure if it would work correctly.\n. Oops! :sweat: Ok, not much difference anyway. Just create a new Address instance and save it:\nreturn new Address({ /* your new address data */}).save()\nHow you get a reference to the Address model is up to you.\n. \"No\" and \"it depends\" respectively to your questions ;)\nThe long answer is that Bookshelf does not know anything about your database schema unless you tell it. That is, there are some assumptions in some cases but not how you were expecting. In that case the assumption is that the foreign key will have the same name as the referenced table in singular form with a _id added at the end, so what you are seeing is currently correct. Migrations are a feature provided by the Knex query builder, not by Bookshelf, so your models have no knowledge of the underlying database. This will probably be changed a bit in the future though.\nAs for the second question you don't need to name it like that if you don't want to. Just specify what the foreign key name is as the second parameter to the relation method. More info in the docs.\n. https://help.github.com/articles/markdown-basics/\n. I could be reading your question in the wrong way, but I think you are misunderstanding how Bookshelf works.\nFirst, you have your \"class\" and \"instance\" variable names backwards. Usually \"classes\" in Javascript are distinguished by being capitalized, and instances by using the same name as the \"class\" but with all lower case characters. You have the exact opposite.\nSecond you don't need to use generic for loops for iterating through your collections, unless you really want to. If you don't insist on doing that there are built-in methods for dealing with collections. You can check them out in this section of the docs.\nFinally, to access properties of related objects just do:\n``` javascript\nEquipment.where('id', 0).fetch({withRelated: ['hardwiredinputs']}).then(function(equipment) {\n  equipment.related('hardwiredinputs').forEach(function(input) {\n    var inputId = input.get('id')\ninput.keys().forEach(function(attributeName) {\n  console.log(attributeName + ' is ' + input.get(attributeName))\n})\n\n})\n})\n```\nNot sure if this is what you're after.\n. You can assign related object properties to variables just fine, I don't understand what kind of difficulty you're having. I did just that in the previous example.\nIf the relation is one of the type: belongsTo or hasOne then obviously you don't need to use a loop to iterate through all the elements (rows) of your relation (since there's only one of them), and can simply do:\njavascript\nEquipment.where('id', 0).fetch({withRelated: ['hardwiredinput']}).then(function(equipment) {\n  var inputName = equipment.related('hardwiredinput').get('name')\n})\nif it's a relation that can have multiple related objects then you also don't necessarily need to use a loop to access all of them. Just use the at() method for example:\njavascript\nEquipment.where('id', 0).fetch({withRelated: ['hardwiredinputs']}).then(function(equipment) {\n  var input1Name = equipment.related('hardwiredinputs').at(0).get('name')\n})\nalthough I still don't understand why you're making such a the big deal out of assigning something to a variable.\n\ncan I also .set() the values in the columns the same way?\n\nYes: http://bookshelfjs.org/#Model-set\n. So you just want to look for a related object based on the value of one of its properties? Simple as using either the where() or the findWhere() methods that are described in the Additional Backbone Methods section.\nWas that all? :D\n. Oh, so you actually want to get a model based on a value of a property of one of its related objects right? That's more complicated. That's it right?\n. So, you actually want to fetch a hardwiredinput based on its name and then get the related equipment? Your requirements seem to change with every reply :D\n. So you want to iterate through all equipments and through all of their hardwiredinputs? Your first example seems to suggest that you are only interested in one.\nAnyway, you're better off reading the docs very carefully and maybe these issues: #202, #655, #597, #255, or searching for any other issues that mention relations, because I still don't know what you're after.\n. You shouldn't be accessing those properties most of the time. Just use .related(), .get() and .set() like I already explained several times.\nStick to what's in the docs instead of trying to dig into internal model properties and you'll have a much better time.\n. > The problem is that the save doesn't update the DB. \nSo, the equipment doesn't get saved?\n\ncan I save the equipment and all its related hardwiredinputs this way?\n\nNot currently. save() only saves the selected model's data: #83 and #552.\n. I can't close issues. I'm just a user like you :) You'll have to close it yourself.\n. Biggest problem was probably naming version 0.8.0 as such instead of 1.0.0 due to the breaking change nature of it. We should follow semver more closely in the future to avoid these issues and frustration.\nAnyway, in this particular case I don't think .listenTo() has any particular advantage over .on(), so the above could probably be written as:\njavascript\nthis.on('add', this.emitRooms);\nPS: And listenTo removed from the docs unless someone has anything against it. Otherwise we would have to re-introduce it.\n. Biggest problem was probably naming version 0.8.0 as such instead of 1.0.0 due to the breaking change nature of it. We should follow semver more closely in the future to avoid these issues and frustration.\nAnyway, in this particular case I don't think .listenTo() has any particular advantage over .on(), so the above could probably be written as:\njavascript\nthis.on('add', this.emitRooms);\nPS: And listenTo removed from the docs unless someone has anything against it. Otherwise we would have to re-introduce it.\n. Good point @tgriesser. So we'll still be in a state of turmoil for some time I guess :)\n. Good point @tgriesser. So we'll still be in a state of turmoil for some time I guess :)\n. Check issues #425, #497.\n. How about:\n``` javascript\nfunction getTransactions(account_id) {\n  var options = account_id ? {where: {account_id: account_id}} : {}\nreturn Transaction\n    .query(options)\n    .fetchAll()\n    .then(function(transactions) {\n      / ... /\n    });\n}\n``\n. @rapzo I don't think so.. What's wrong with uncommenting those lines, removing the?and placing those comparisons inside console.log statements?\n. Again, what does the console.log tell you? Also, I think you shouldn't be modifying theattributesobject directly, but use the.set()and.get()` instead.\n. See issue #240 \n. I don't think there's anything like what you want currently.\nThe \"big changes\" may take longer to be released than expected, and it will always be a gradual thing, so it's pretty safe to say that you can build your project with confidence that things won't completely break tomorrow. If you're still interested in this after all this time :)\n. It was probably referring to this. Since the backbone dependency is going away in a future version I'm not sure if it's worth adding the missing info. Then again, it could still be a while before that happens.\n. Actually I would say that it's either documented or Bookshelf is changed so that it isn't required any more. I'm not sure if it can be remove right now as it seems to be used to keep track of newly created models that aren't saved to the database yet.\n. So the idea is to remove Collection#where?\n. That looks good to me, except for the deprecation of Collection#findWhere. Why does it need to be deprecated?\n. @muhaimincs What did you try? Usually you don't need knex to do a simple SELECT.. You have to be more specific and provide examples if you want any kind of help.. Yeah, that was never implemented, and given the current direction Bookshelf is heading it probably never will.\nYou can still achieve the same thing with:\njs\nvar knex = require('knex');\nModel.query(function (qb) {\n  var sub = knex(...);\n  qb.join(sub);\n});. Good point. Since I went to the trouble of setting up password-less users I never thought of that. Can you point me to a place that references that method so that I don't write anything wrong?\n. BTW, what problems did you have with trying to setup a password-less user? Was it with MySQL or PostgreSQL? I'd like to get that part as complete as possible and to cover as much problematic scenarios as possible.\n. All good points :) I'll update the document with that in mind.\n. @rhys-vdw That config file specified by an env variable you mentioned above is it the same config file you would use for the rest of your application? If yes wouldn't that make the test suite use your application database instead of bookshelf_test?\n. @rhys-vdw Updated the doc with even more detailed instructions. This should be a good start for everyone.\n. What happens if you don't convert them back to normal Date objects in model's format function? Are you having any problems with that?\n. I'm almost certain that is handled by Knex (or even the underlying database adapters) and not Bookshelf. Take a look here and here.\n. So, there's a bug after all? What exactly is the problem?\n. So, there's a bug after all? What exactly is the problem?\n. Closing this for lack of activity. If you need any further clarification about this issue we can reopen it.\n. Check out issue #324 and see if it helps answer your question. If not, you could try it and report any issues that potentially show up. I'd like to give you a better answer but this is the best I can do without ever having tried bookshelf on a multi-process app.\n. Check out issue #324 and see if it helps answer your question. If not, you could try it and report any issues that potentially show up. I'd like to give you a better answer but this is the best I can do without ever having tried bookshelf on a multi-process app.\n. Closing this for lack of activity. If you need any further clarification about this issue we can reopen it.\n. Yeah sometimes I also use the ability to fetch by a given attribute but never when combined with an id attribute as well. @light24bulbs Why would you want to fetch with non-id attributes and the id attribute at the same time? It doesn't make sense to me since the id attribute is already specifying a single row, so you can't be more specific than that, and considering that the result would be the same in both cases. Is it some kind of security concern? That is, you want the possibility of returning nothing if the id and the otherAttribute don't match a row that exists?\nThat said, the Model.where({ ... }).fetch() form does look like the preferred way to fetch by random attributes.\nIf we were to change this behaviour it should be preceded by deprecation messages first to give users time to migrate to the preferred way of fetching. Seems like the only change would be to replace forge with where right?\n. Yeah sometimes I also use the ability to fetch by a given attribute but never when combined with an id attribute as well. @light24bulbs Why would you want to fetch with non-id attributes and the id attribute at the same time? It doesn't make sense to me since the id attribute is already specifying a single row, so you can't be more specific than that, and considering that the result would be the same in both cases. Is it some kind of security concern? That is, you want the possibility of returning nothing if the id and the otherAttribute don't match a row that exists?\nThat said, the Model.where({ ... }).fetch() form does look like the preferred way to fetch by random attributes.\nIf we were to change this behaviour it should be preceded by deprecation messages first to give users time to migrate to the preferred way of fetching. Seems like the only change would be to replace forge with where right?\n. Have you tried it? Are there any errors? The output is not what you expect?\n. Have you tried it? Are there any errors? The output is not what you expect?\n. I never used tape, only mocha, but I have no problems learning something new :) Other than that :+1: for making tests able to run in isolation.\n. I never used tape, only mocha, but I have no problems learning something new :) Other than that :+1: for making tests able to run in isolation.\n. Would the new not-collection still have some of the collection methods for manipulating and accessing its elements like add, remove, at, etc? Or would it be just a plain old array?\n. Since it's just an array and this is a major breaking change anyway what about doing away with the collection methods? Maybe provide an external plugin to add back that functionality for people that aren't ready for that big of a change. The idea here is to simplify the core.\n. Ah right, I was the one that missed what you meant when exemplifying the alternatives :)\n. Reopening to get the discussion going again.. @rhys-vdw What exactly are you working on from those items above?\n. Nice! What will be in the Misc section of methods? Wouldn't a Events section be more helpful?\n. What happened?\n. Is there a way to load a bookshelf plugin other than during application\nstart? How are you loading your plugins right now?\nEm 24/06/2015 3:14 da tarde, \"Tom Coquereau\" notifications@github.com\nescreveu:\n\nHello guys,\nI have been looking for an example of an external plugin (like the\nregistry plugin for instance) that could be loaded into bookshelf on\napplication start. Does anyone have a clue where I could find a one ?\nWould anyone have some tips about the best ways of implementing a\nserializer that could be re-used across application (I believe a plugin\nwould be the best fit).\nThanks !\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/809.\n. Closing this for lack of activity. If you need any further clarification about this issue we can reopen it.\n. @rhys-vdw Totally agree with that. I never understood the point of saving every single attribute if they haven't changed. It's not even a breaking change AFAICT.\n. @abalmos That's actually the objective Bookshelf is currently aiming for: separating the model and the persistence layers to bring it more in line with the data-mapper pattern, so this proposed change makes sense.\n. Check out issues #407 and #711 and see if those answer your question.\n. So what do you want to know exactly? I don't think I follow your question.\n. I see. Can you explain what the use case for that is?\n. Got it. @rhys-vdw is going to work on relations, so he should be able to provide some more feedback on this.\n. If you could get rid of that \"Merge pull request...\" commit I would gladly merge this. \n. Many thanks :)\n. What happens if you don't delete the attribute in this case?\n. What happens if you don't delete the attribute in this case?\n. What's the SQL output? And does the property actually exist in the table?\n. What's the SQL output? And does the property actually exist in the table?\n. I didn't know you can use promises mixed in with events like that. What happens if you remove the Promise.method?\n\nAlso, what is the value of tags that is being passed to that query?\n. I didn't know you can use promises mixed in with events like that. What happens if you remove the Promise.method?\nAlso, what is the value of tags that is being passed to that query?\n. What values are you setting on the Org model instance before saving?\n. What values are you setting on the Org model instance before saving?\n. Right, as I expected. Unfortunately Bookshelf currently doesn't support saving related data as easily as that. .save() will only try to save the model's own attributes so, you'll have to use something like this:\n``` javascript\n// ...\nreturn resource.save().then(function(resource) {\n  var org = new Org({\n    uid: uid,\n    name: orgData.name,\n    resourceId: resource.id // or \"resource_id:\" if you're not converting to/from camel case \n  });\nreturn org.save();\n});\n``\n. Right, as I expected. Unfortunately Bookshelf currently doesn't support saving related data as easily as that..save()` will only try to save the model's own attributes so, you'll have to use something like this:\n``` javascript\n// ...\nreturn resource.save().then(function(resource) {\n  var org = new Org({\n    uid: uid,\n    name: orgData.name,\n    resourceId: resource.id // or \"resource_id:\" if you're not converting to/from camel case \n  });\nreturn org.save();\n});\n``\n. I know. Sorry about that. @rhys-vdw FYI.\n. I know. Sorry about that. @rhys-vdw FYI.\n. This requires #821 first. As soon as we can know which attributes are relations I think it would be relatively straightforward to change the behaviour of.set()` to implement this.\n. Well, Bookshelf doesn't do joins currently. You will get the data you want, but through individual queries, so in your example there will be 3 separate queries. If you really really want to use joins so that you end up with a single query, you'll have to use Knex.\nI think security is coming out empty because you have an error in your model definition. Since you are using a non-default primary key name you have to specify it with the idAttribute property, not id like you have. Same thing with the Country model.\n. Are you getting any errors? I think there is a limit on the number of arguments you can pass to that IN (...) statement, and that could be the cause.\n. So, as you currently have things set up, the securities table should have a foreign key named symbol which points to the primary key of holdings. Can you verify if this is true?\n. Then your Holding model is wrong. The security relation should be belongsTo. In a belongsTo the foreign key is in the current model, which seems to be what you have in your tables, since symbol on the holdings table is the foreign key for the securities table, right?\n. You can't currently. Not with Bookshelf alone. It is possible if you modify the query though. Check issues #202, #355, #597, #655 and #834 for more information.\nBTW, you can just use withRelated: ['fund', 'security.country'] since that will return both security and country.\n. Can you explain what the intended result is?\nAnd also, where did you get that first code example? AFAIK models don't have a .select() method since that's a knex method, so how is that even working? The usual way of limiting the columns returned by a fetch() call is by passing in a columns property in the options object.\n. So, you need to filter the results of Table_b based on an attribute of the related Table_a right? That's currently not possible with Bookshelf alone. You'll have to use a custom query like you already did.\nCheck issues #202, #355, #597, #655 for possibly related questions.\n. It's not possible for .catch to not be recognized as a function. Can you provide the whole sample code where that is happening?\n. The problem with that is that you're calling the model constructor leagueModel.Bets() and then calling .forge() on the result of that. That doesn't work. You either use the model constructor to create a new instance like:\nnew leagueModel.Bets().query().fetch(/* ... */)\nor you use forge to build a new instance:\nleagueModel.Bets.forge().query().fetch(/* ... */)\nBoth at the same time doesn't do anything good as you found out.\n. The updated event is fired after the model is updated (or saved to the database if you prefer), so that will reset any changes, which means that it will no longer be considered changed. When the updating event fires, the model is about to be updated, but hasn't yet, so it can still have changed attributes.\n. Since version 0.14.0 the previous attributes (prior to a updated event) are now available in model.previousAttributes(). This was introduced in PR #1848. As a result the options.previousAttributes property was removed.. That is very vague. Can you explain in greater detail what you're doing,\nwhat the result is and what you would expect the result to be?\n. Yes it should be possible to do what you want. In the creating event if you throw an error the save will never happen. Check out the documentation for the save method for further details.\n. Yes it should be possible to do what you want. In the creating event if you throw an error the save will never happen. Check out the documentation for the save method for further details.\n. A new release is not very far away. I can't give an exact estimate but it will happen sooner rather than later.\nIn the mean time you can point your package.json to the repo directly to get the latest code:\n{\n  //...\n  bookshelf: github:tgriesser/bookshelf,\n  //...\n}\n. A new release is not very far away. I can't give an exact estimate but it will happen sooner rather than later.\nIn the mean time you can point your package.json to the repo directly to get the latest code:\n{\n  //...\n  bookshelf: github:tgriesser/bookshelf,\n  //...\n}\n. It seems all detected regressions were already fixed, so I would say it's time to do a new release. Although there are some issues with the current docs, delaying the release probably won't make much difference anyway.\n. I would prefer if the behaviour was kept constant, so in this case it should return undefined. I don't see the advantage of returning something different.\n. Right, but that means changing the behaviour of the Model class as it has been for a very long time. I also agree that null is more representative though, but that change is not backwards compatible, so we should probably precede it with deprecation warnings first.\n. No idea. So, on versions prior to 0.8.1 when you called .fetch({withRelated: 'foo'}) if no rows were found, you would get undefined?\n. You have my vote :+1: \n. Can you post the rest of the code? You're writing that statement in a very convoluted way, so we need to make sure it is really necessary.\n. Closing this for lack of activity. If you need any further clarification about this issue we can reopen it.\n. Closing this for lack of activity. If you need any further clarification about this issue we can reopen it.\n. Closing this for lack of activity. If you feel like you didn't get your issue answered properly let us know and we'll reopen it.\n. I'm almost certain it's standardized just for Bookshelf. Do you need info on how to create a plugin?\n. So you want implicit transaction support? That is, whenever you have a Bookshelf Promise chain, it will always happen inside a transaction?\n. How are you defining your relationships? Can you proved the exact code that is causing that incorrect query?\n. How are you defining your relationships? Can you proved the exact code that is causing that incorrect query?\n. :+1: Breaking change though.... so Bookshelf 0.9.0?\n. @apla That seems like the expected result to me. Why do you think that's the wrong result for that code you posted? What were you expecting to get instead?\n. Wait, you're using parse and format to alias a column name to a different attribute name? I see what the problem is now. You were expecting to get id: 7 instead of organization_id: 7 after save right?\n. Right, @apla that's issue #583.\n. Thanks for spotting that and submitting a patch, however that file is now auto-generated from the inline JSDoc comments in the code itself. If you could re-submit the pull-request by changing this file instead I'll merge it ASAP.\n. Sorry if I wasn't clear enough before, but you must either create a new pull-request that only changes the file in the src directory, or force push the correct commit into this PR (while omitting the previous incorrect commit).\n. After a lot of consideration I'm not going to merge this. The functionality would be awesome to have, but I agree with Rhys that mentioned on #885:\n\nPersonally I think overridden functions should maintain their original contract - they should not modify their return type.\n\nAlso, since this PR was opened there have been a few changes to saveMethod() that made it more complex.\nFurthermore there is now usage of a synchronous isNew() on Model#serialize() and the Model#toJSON() method of the Virtuals plugin, thus making it considerably harder to handle a possible promise returning isNew() without increasing the complexity of the code base exponentially for something that can be solved with:\n\n...modifying save directly or hooking into an event feels like a cleaner approach.\n\nWhich, given the use case for this feature as stated on the above linked issue, would be:\njs\ninitialize: function() {\n  this.on('saving', (model, attrs, options) {\n    return this.constructor.where('id', this.id).fetch().then(function (existing) {\n      options.method = existing == null ? 'insert' : 'update';\n    });\n  }\n}. @rhys-vdw So, only the documentation is incorrect now right?\n. I think you would be better off with a polymorphic relationship than with several hasOne that aren't the best choice according to what you're trying to achieve. With a polymorphic relationship you only have to store the type of reference in an attribute and the referenced element in another. So instead of having book, journal and conference attributes (which is also a very rigid schema, making future expansion of reference types harder), you would have referenceableType and referenceableId columns in your parent model. I think this should make it easier to achieve what you are after.\nTake a look at the doc entry for the morphOne relation.\n. Closing this for lack of activity. If you feel like you didn't get your issue answered properly let us know and we'll reopen it.\n. Thanks. You'll see the changes on the website when we do a new release.\n. Thanks. You'll see the changes on the website when we do a new release.\n. Thanks for this, but you should only change the original JSDoc comments on files under src. Everything under docs and lib is automatically generated from those comments when we do a new release, so those files shouldn't be edited. Especially build/bookshelf.js should not be edited manually, since it is also generated.\n. Closing this for lack of activity. If you feel like you didn't get your issue answered properly let us know and we'll reopen it.\n. You should be able to change your model's toJSON method to do that instead of relying on virtuals which were not meant for that kind of usage. Or better yet, just name your database column id if you can.\n. javascript\nvar Stuff = bookshelf.Model.extend({\n  toJSON: function() {    \n    this.id = this.user_id\n    delete this.user_id\n    return this\n  },\n  // ...\n})\nObviously you won't be able to access user_id afterwards, but if you need that just copy the whole object inside the toJSON method before doing any changes.\n. @rhys-vdw Is it just this:\njs\nObject.defineProperty(ModelBase, 'id', {\n  get: function() {\n    return this.get(this.idAttribute);\n  },\n  set: function(value) {\n    return this.set(this.idAttribute, value);\n  }\n})\nI did that change locally and all tests pass, but I'm not sure any of them is testing what this is supposed to do/fix. What's the purpose of this change? It's not entirely clear to me from your description above.\n. Because it's module.exports not module.export.\n. @rhys-vdw That seems a bit too ruby-like, and not something that would be very obvious to JS developers. The meaning of the ! Is a bit obscure. The other options mentioned seem ok to me.\n. @rhys-vdw That seems a bit too ruby-like, and not something that would be very obvious to JS developers. The meaning of the ! Is a bit obscure. The other options mentioned seem ok to me.\n. Closing this due to lack of activity. If you have further info to add we can reopen this issue to continue the discussion.\n. @1mike12 So, why do you think your workaround isn't the actual preferred way of doing it? Also, isn't this an issue with the plugin and not Bookshelf?\n. What code did you use to get that query?\n. What about having a \"release\" branch that contains builds?\n. With a branch dedicated to just carrying the release code you wouldn't do a release on master. That's what the release branch is for. The master branch is for on-going work. When you are ready to make a release the workflow would be:\n- merge master into release\n- build all the necessary files\n- commit and push the built files to release\n- profit\nIt's important that release is never merged into master, only the other way around. You can even have different .gitignore files on both branches.\n. Sure, no problem. I use that system on a project, with files that only exist on the release branch, and it works fine. I could take a look at that release script if you tell me what issues you were having with it.\n. You can use Bookshelf in the browser? O_o How?\nStupid question, but why do we need to keep the generated code in the repo in the first place? What's wrong with just generating what's needed when publishing/developing?\n. Got it. The link to that bookshelf site doesn't work.\nI also wonder if there is a single person using Bookshelf in the browser.\nReleases can be automatically created from git tags or manually created on GitHub's website (which will also create git tags).\nOk, so what problems were you having with the release script?\n. Reopened due to renewed interest in fixing it.. That's a feature of the node-postgres module due to the known precision problems of Javascript when dealing with bigints: https://github.com/brianc/node-postgres/pull/353.\nIn any case, that would be something to discuss in knex, not Bookshelf. See also this issue for further info: https://github.com/tgriesser/knex/issues/387.\n. What's your database schema?\n. @rhys-vdw Is there an earlier bug report about this issue of format not applying to the primary key in some cases? I can't find it anywhere.\n. > The SQL that is generated keeps referencing user.customer_id, but that doesn't exist in the relation.\nThat gets generated when you do what?\n. Closing this due to lack of activity. If you have anything else to add we can reopen this.\n. Try putting something inside the argument to the first .where().. What's the code you used to get that result? What result are you actually getting and what did you expect?\n. What's the code you used to get that result? What result are you actually getting and what did you expect?\n. Why aren't you defining parse and format on extend instead? I'm almost certain that is the problem here.\n. You seem to be causing some chaos with that approach and it's not exactly what it says on the issue you linked to.\nIf you want to have a base model from which all others inherit from, take a closer look at what the example is actually doing. It's nothing like what you have here. Also, you need the registry plugin, so make sure it's being loaded before doing anything else.\nTip: right click on the date link on a comment to get a link to the actual comment.\n. I don't know since I'm not seeing you're entire code, and I'm not that knowledgeable in how Bookshelf works internally, but you're approach doesn't seem right.\nMy guess is that constructor() isn't called when a model is instantiated as part of a collection, but if there's a parse method on the model's prototype, then that gets called (that's why no one has complained about this issue before). Since you're only adding the parse and format methods on the constructor method, instead of defining them right away on the extend call, your methods never get added to the model instance.\n. That wasn't the problem. The problem was setting format and parse on constructor(). Did you also take care of that?\n. No problem. Now we know that constructor() isn't called when a model is instantiated as part of a collection. At least that's what it seems.\n. Why are you defining knex as global? And what do your model files look like?\n. Is the second block of code in that example supposed to represent a controller? It would help if you identified which files those blocks are.\n. That's not helpful at all, but I'll try to tell you what seems to be wrong anyway.\nFirst, you're creating a Bookshelf instance in your model Bookshelf = require('bookshelf')(knex); and then creating another Bookshelf instance in what I think is your controller var Bookshelf = require('bookshelf')(global.knex);. The Readme file is very clear about this:\n\nThis initialization should likely only ever happen once in your application. As it creates a connection pool for the current database, you should use the bookshelf instance returned throughout your library.\n\nAnd instead you're creating multiple instances.\nJudging from you only example model above I assume your other model looks the same, which means it's creating yet another bookshelf instance, causing even more problems.\nRead the README file and the online documentation carefully and you should be able to fix your code.\n. Why do you have both an image_id in the users table and a user_id in the images table?\n. Ok, great.\nI'm not sure, since I'm not very familiar with through but I suspect that you're using .through incorrectly since the Image model can't be used as an intermediate step between users and friends. I think it's usually used when you have this type of relation:\nUser > Profile > Image\nWhere Profile links the other two models together, so you could use through to get a User from an Image, or the other way around. In your case you have something like this:\nImage > User <> Friend\nSo, it's not possible to use through like you have in your example, because Image doesn't link Users and Friends.\nWhen you fetch a user with all related users specifying friends.avatar you're actually getting back all the users that are friends with the specified user, and since you included .avatar also their related avatars (since the call to user.friends() will return a collection of User models).\nOn a side note it usually doesn't make sense that a user belongs to an image. It's more logical that an image belongs to a user, unless your Image model is the primary concern of your application, or you really mean that a certain user is contained in an image.\n. If any of you guys does open a PR might as well handle #967 as well :)\n. According to the backbone docs you should be able to do model.off(null, someHandlerForBoth) to remove the someHandlerForBoth callback from all events. It's not exactly the same thing though. Not sure if Bookshelf implemented it that way, but since it's based on backbone I think it only contains functionality that exists there, so that explains the lack of model.off('updating creating').\nSo, this is more an enhancement than a bug.\n. This is a great fit for #1608 and should be very easy.\n@Playrom is there a new gitter channel? I'm not aware of the bookshelf IRC channel. Have you used it?. We'll go with @mrhwick solution for now. If anyone is interested in maintaining other communication channels feel free to mention it here and possibly reopen this issue.. Neither bookshelf.js nor knex.js are being included in the website anymore.. Maybe start by including a deprecation warning in the next version?\n. Apparently it's only used on Bookshelf's own website. That was added initially in version 0.7 in b22ba35fc8f1f79a938e9a1a60afa3a9d4805aef. I think the purpose was to run examples live on the browser, but that's no longer a thing, so I'd say it can safely be removed.\n. #979\n. #979 \n. When you say \"empty fooBar\" is it null or undefined?\nI agree that the default should be require: true, which is similar to the solution in the issue you linked to. However, that would be a breaking change, so I'm not sure if it's something we can do right away. @rhys-vdw what do you think?\n. Weird. I would expect null like what you'd get with a .fetch().\n. That isn't possible right now. Using the object notation in a withRelated call is only useful for altering the query that is performed on the relation. There's an example in the docs.\n. @tkrotoff It's right there, but I'll reproduce it here for clarity:\njs\nnew Book({'ISBN-13': '9780440180296'}).fetch({\n  withRelated: [\n    'genre', 'editions',\n    { chapters: function(query) { query.orderBy('chapter_number'); }}\n  ]\n}).then(function(book) {\n// ...\n})\n. Not that kind of object notation, but passing an actual javascript object, like the original comment wanted to do. If you have unrelated questions please open a new issue instead.\n. I agree with this proposal. Having an empty model as return value isn't very useful, especially since you already have access to it anyway.\nAdditionally I think that it would be a good new feature to return the model as it was before the delete as the second argument of the destroyed event. It can be used to access its values after it's removed to form some kind of message to the user. This is mentioned in #840.. This seems like the correct fix to me, however there are also some bad ModelBase#... links in src/base/model.js, which should also be fixed.\nUpdate: And another one here: https://github.com/tgriesser/bookshelf/blob/ab30fd12a773a88a81ae31018975a60c0946c550/src/base/collection.js#L85. It's possible there are more.\n. Great job!\n. Not sure if it was ever supported.\nI don't think it makes much sense to support it though, because a collection is more like an array than an object. It should be removed from the docs.\n. #979.\n. Many thanks :)\n. What about that stuff about gh-pages? How is that done?\n. I don't think it's possible to return specific attributes that were not part of the original data to save. You can either save a model that already has a createdAt attribute (from a previous fetch for example), or use refresh to update the model from the database. Something like:\njs\nmyModel.save().then(function(model) {\n  return model.refresh({columns: ['createdAt']})\n}).then(function(model) {\n  // model now has \"createdAt\"\n})\n. Thanks, but that part is already fixed in #1001 :)\n. Where and how are you consuming the result of that code?\nAnd on a side note you totally misunderstood the point of promises. When you write promise code like that you're not gaining anything over callback style code. In fact, the point of promises is to make code look more like synchronous code while being asynchronous.\nSo, instead of the callback-like-but-actually-promises style you used, this would be better:\njs\nmodel.Group.forge({id:7040}).fetch().then(function (group) {\n    return group.disciplines().fetch()\n}).then(function (discs) {\n    return discs.map(v => { \n        // return v.refresh();\n        return v.save({ name: '111' });\n    });\n});\n. Right, I know what the problem is now, after looking more carefully at your Models. You can't have a model property/method called listeners since that is used internally by Bookshelf to keep track of event listeners on a model.\nI'll add a new issue to address that shortcoming.\n. Right, I know what the problem is now, after looking more carefully at your Models. You can't have a model property/method called listeners since that is used internally by Bookshelf to keep track of event listeners on a model.\nI'll add a new issue to address that shortcoming.\n. Check the above linked issue for progress on this, but in the mean time you'll just have to choose another name for your listeners relation.\n. Check the above linked issue for progress on this, but in the mean time you'll just have to choose another name for your listeners relation.\n. So you want to show only stores from a certain province? Or is it something else? It's not very clear what you're after.\nIf you use:\njs\nreturn new Store()\n    .fetchAll({\n        withRelated: ['addresses.city']\n    }).then(function(stores) {\n        // ...\n    })\nYou should get all the stores with all addresses with all the related cities. No need to specify both ['addresses', 'addresses.city'], since the first is already implicitly fetched when fetching the second. Isn't this returning related cities?\n. I don't understand what you mean when you say you need city_province. If that attribute is part of the City model it should be retrieved even if it's used on a composite key.\n. The result of what?\nYou mentioned queries, models and results, but don't actually post the code that is generating the results. That makes it harder to help you.\nAlso, I'm totally lost on what your DB schema looks like because you keep mentioning column names and attributes that don't match up. You talk about city_department, but apparently there's no such thing. It's actually just department. However your first JSON result in your first comment actually has city_department :confused: . You also mix the terms \"province\" and \"district\", which further adds to the confusion.\nSo, a little clarification on what your DB looks like would help.\n. Closing this due to lack of activity. If you have any further info to add we can reopen this issue.\n. How would this be addressed? A warning for a few versions first?\n. Are you using hasTimeStamps to set custom timestamp attribute names?\n. That part doesn't make any sense. I doubt that Bookshelf randomly decided to remove 7 days from your dates. This is likely something else in your code, most likely the moment.js code.\nWhen you have custom timestamp attributes, those are always automatically set to the current date (which is what you're getting), but unless I'm missing something, you're not using that functionality.\nAre you sure that the date strings are correct before being parsed by moment? If you remove your custom parse method do the dates get saved correctly? If you don't use moment to parse dates, do the dates get saved correctly?\n. I have no idea, but Bookshelf is not \"moment-aware\", so most likely it's the moment code that you're using that is causing problems. No idea how or why since I only used moment very briefly.\nIf you could figure out the exact place where the date is being reset to the current date that would help, otherwise my guess is as good as yours.\n. I'm glad you managed to sort it out :)\n. I'm glad you managed to sort it out :)\n. @dj-hedgehog This is still an issue but I made the mistake of not writing down what the documentation should say instead. It should still be fixed eventually though.. It seems that either the documentation is completely wrong on this, or Bookshelf is not behaving as it should since attrs seems to be only the id of the model after it was saved to the database. This is probably the return value from the database engine, which means that it will possibly contain something else besides the id when working with PostgreSQL but not on other dialects. I'm still investigating this.. Composite keys are not supported at all on Bookshelf currently. Actually I think there's at least one operation that accepts composite keys, but I'm almost certain relations isn't it.\n. Composite keys are not supported at all on Bookshelf currently. Actually I think there's at least one operation that accepts composite keys, but I'm almost certain relations isn't it.\n. Closing this due to lack of activity. If you have any further information to add we can reopen this issue.\n. I think this is still a valid concern and would benefit the project.. I like the idea of a schema file. It could be used to easily construct the schema on a new machine, which to me is a win, over having a (potential) ton of individual migration files. I don't know if you thought about this possibility already.\nIs there anything that couldn't be done with this approach and that would really require having a model file? I want to know where's the line that separates the functionality of models vs the .schemafile.\n. I like the idea of a schema file. It could be used to easily construct the schema on a new machine, which to me is a win, over having a (potential) ton of individual migration files. I don't know if you thought about this possibility already.\nIs there anything that couldn't be done with this approach and that would really require having a model file? I want to know where's the line that separates the functionality of models vs the .schemafile.\n. You're overriding the base .set() method in your SetItem model, so when you call forge(), which calls .set() internally, it's using your overridden method instead of the correct method.\nYou have to name your set relation something else.\nA solution to this relatively common problem is being tracked in #1018.\n. You're overriding the base .set() method in your SetItem model, so when you call forge(), which calls .set() internally, it's using your overridden method instead of the correct method.\nYou have to name your set relation something else.\nA solution to this relatively common problem is being tracked in #1018.\n. Maybe it would be best to rework the Collection#count example to not include .query() otherwise people may get confused about how to use it, like in this case.\n. > why would it try to find admin_id inside the users table to begin with?\nBecause that's how .through works. According to the docs:\n\nBy default, the foreignKey is assumed to be the singular form of the Target model's tableName, followed by _id\n\nWhich is precisely users.admin_id. I'm not that familiar with .through myself, but my guess is that you're using it incorrectly as you already suspect. Without a database schema it's hard to know for sure what you're doing wrong, but take a better look at the docs for .through and you may figure it out on your own. I suspect you also don't need to specify any additional arguments since you seem to be using the default table and key names.\n. > Actually, that is precisely the opposite. The Target model is User.\nNo it isn't. It's Admin. I think the confusion may be due to the text being lifted unchanged from another similar method (.belongsToMany()). In this case it should read:\n\n...the singular form of the Interim model's tableName...\n\nAnd note that you need a \"Foreign key in this model\", where \"this model\" is the model from which the .through method is being called. In your case that's User, hence users.admin_id.\n. > A junction table is more like this: User > Admin < Farm, where the admins table is expected to include the references to the other two tables via user_id and farm_id\nThat's why you should use .belongsToMany instead, like was suggested already :) You will have to override the table name though.\nAlso, if you're new to RDBMS, you should check out Rails' Associations guide which explains in great detail how these associations work and what the conventions are. Bookshelf uses a very similar naming system, with the difference being that belongsToMany is called has_and_belongs_to_many over there.\n. Hmm... I don't think you need .through with .belongsToMany in your case. That's the whole point. So, this should work with your database schema:\njs\nthis.belongsToMany('Farm', 'admins')\nIf you are sure that a user will only be administering one farm, you can return just the first record, so:\njs\nthis.belongsToMany('Farm', 'admins').first()\n. How are you calling that? You probably have to limit the results like this instead:\njs\nuser.related('farm').first()\nNo idea if it will work or not. Sorry, but I'm not that familiar with the process of limiting related data queries. You'll probably find more answers by searching through the issues.\n. These associations were developed a long time ago before any of us (me and Rhys) joined the project, so it's possible that .through was never meant to mimic how the equivalent in ActiveRecord works. I only linked to that documentation because it's very thorough, has many examples, and is the base for many other ORMs, so it's a great introduction to the subject, but you should always refer to Bookshelf's docs for actual usage. Sorry if I made it look like everything in Bookshelf was supposed to work like in ActiveRecord.\nI think that you're right when you say that .through only works one way, and I think the example currently reflects that, although it doesn't explain all possibilities in great detail. I never needed to use it myself, so I also don't know much about it.\nWe probably also need a Guides section in the website to help users on common tasks and to explain some concepts in more detail.\n. Is this key attribute supposed to be a part of the model you partially showed above (please post the complete model next time) or the Kvnode model? What's the key used for? Is it a primary key?\nWhat do you mean by \"the query fails\"?\n. Yes, you're right. That's a known issue, but I can't seem to find it right now. I'll link to it when I find it so you can keep track of the progress on this.\n. What version of Bookshelf are you using?\n. It's very weird that you're creating models on-the-fly with each association. I never seen anyone do that before, although it's probably safe. You should probably use your existing User model on your WorkOrder model's associations instead of creating new ones though.\nAlso, in your example the tech and creator are exactly the same thing, but in reality they have different foreing keys, so that should be:\njs\n// ...\ntech: function () {\n  return this.belongsTo(User, 'tech_id');\n},\ncreator: function () {\n  return this.belongsTo(User, 'creator_id');\n},\n// ...\nI assume these two are where you're having problems right? Are you sure the data that you think is missing is really in the database?\nUpdate: Wait, I think you have to override the default foreign keys in your case for each of those User model accesses. I've corrected my example above to clarify.\n. Yes, use the registry plugin :)\nOh, and just one more thing. You should do some reading on the DRY principle ;)\n. That's outside the scope of this issue, but join us on Gitter and we'll talk there.\n. tgriesser/bookshelf\n. Great! I'm glad everything is working as you expected now :)\n. Can you explain why those queries are incorrect and what you expected them to be? Also, can you check if .hasOne().through() is producing the query that you're after or not?\nSorry, I meant .hasOne, not hasMany, so I've updated my question.\n. Right, that seems to be correct. I thought that getting the \"grandparent\"\nwas the part that wasn't working. I think the problem with all these\nrelated issues is a misunderstanding of how it works combined with\nincomplete and ambiguous documentation.\nWhat about hasOne().through()? Doesn't it achieve what you want?\nEm 18/11/2015 19:36, \"Chris Broome\" notifications@github.com escreveu:\n\nI'm in the process of fixing this issue in my fork. Looking through the\ntests, I see that the use case for belongsTo().through() is to get a\nmodel's grandparent.\nBlog has many Post.\nPost has many Comment.\nComment belongs to Blog through Post.\nI think this is the source of my confusion because this is not the use\ncase that I was describing above. Therefore I think no changes should be\nmade to the belongsTo.through relationship type.\nThe relationship I'm describing is having an optional foreign key live on\na join table (rather than as a nullable foreign key in the table itself).\nHere's an example schema for such a relationship where a user has either\nzero or one shopping carts. In other words, a shopping cart belongs to a\nuser.\nCREATE TABLE user (\n  id integer NOT NULL PRIMARY KEY,\n  name varchar(255) NOT NULL\n);\nCREATE TABLE cart (\n  id integer NOT NULL PRIMARY KEY\n);\nCREATE TABLE user_cart (\n  id integer NOT NULL PRIMARY KEY,\n  user_id integer NOT NULL,\n  cart_id integer NOT NULL\n);ALTER TABLE user_cart ADD CONSTRAINT user_cart_user_id_fk FOREIGN KEY (user_id) REFERENCES user (id) ON DELETE CASCADE ON UPDATE CASCADE;ALTER TABLE user_cart ADD CONSTRAINT user_cart_cart_id_fk FOREIGN KEY (cart_id) REFERENCES cart (id) ON DELETE CASCADE ON UPDATE CASCADE;ALTER TABLE user_cart ADD CONSTRAINT user_cart_user_id_unique UNIQUE (user_id);\nNote that the UNIQUE constraint confines this to be a zero or one type of\nrelationship.\nMaybe the solution is to support explicit hasZeroOrOne and\nhasZeroOrOne.through relationships as described in #753\nhttps://github.com/tgriesser/bookshelf/issues/753. Also, I actually\nlike the name hasOptional better.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1031#issuecomment-157835618\n.\n. You can't add custom error messages in Bookshelf. That issue was about having distinct NotFoundError messages per model, so you could catch which model was producing the error like:\n\njs\nnew Foo({id: 1})\n  .fetch({require: true})\n  .then(function() {})\n  .catch(Foo.NotFoundError, function(error) {\n    // do something with the error\n  })\n. You can check the error to see which model emitted the error:\njs\nnew Foo({id: 1})\n  .fetch({require: true})\n  .then(function() {})\n  .catch(function(error) {\n    var FooNotFound = error instanceof Foo.NotFoundError\n    var BarNotFound = error instanceof Bar.NotFoundError\n  })\n. Using any of the methods mentioned in Bluebird's documentation doesn't do that already?\n. Agree with @rhys-vdw. This isn't the solution to this problem. Tests will probably be overhauled anyway since there isn't any clean up to the data between each of them, which could have been a cause of this problem.. I'm pretty sure the build is not failing due to this change. @rhys-vdw Can you check if something changed with a recent ESLint version that could explain this build failure?\n. Probably just a meaningless hiccup then. \n. What do you mean by \"loading\" a user? Is it on a relation of another model or by itself?\n. Why not just:\njs\nvar Student = Bookshelf.Model.extend({\n  tablename: 'users'\n})\nvar Employee = Bookshelf.Model.extend({\n  tablename: 'users'\n})\nand then:\njs\nvar SomeModel = Bookshelf.Model.extend({\n  tablename: 'some_models',\n  employees: function() {\n    return this.hasMany(Employee)\n  }\n})\n. Or if you really have shared behavior, you can create a User model first:\njs\nvar User = Bookshelf.Model.extend({\n  tablename: 'users'\n})\nand then just extend it to get your custom behavior:\n``` js\nvar Employee = User.extend({\n  someRelation: function() {\n    return this.belongsTo(Something)\n  }\n})\n// same thing for Student\n```\n. I seriously don't understand what you're trying to achieve. I understand your description, but I don't see why you would want to \"instantiate\" a model after fetching another model.\nAre you trying to attach different relations to the model according to the user type?\n. Got it. It's always easier working with concrete examples instead of abstract concepts :)\nI never tried this, but I think you can use the fetched event to mutate what type of object is being returned. Something like:\n``` js\n// You would still need to have different Employee and Student models defined beforehand\nvar User = bookshelf.Model.extend({\n  initialize: function() {\n    this.on('fetched', function(model) {\n      if (model.get('type') === 'employee') model = new Employee(model.attributes)\n      // same thing for student type\n    })\n  }\n})\n```\nAgain, no idea if this will work, because it attempts to change the model that is being fetched in \"mid-flight\" and I don't think anyone thought about doing that when designing Bookshelf.\nYour safest approach would be to just tweak your functionFoo method to react to different type attributes. You can even have different methods in your User model that get called from functionFoo according to the type, making it a little bit more modular, although it isn't as OOP as you're looking for.\nMaybe there are better alternatives, but I can't think of any right now.\n. Closing this due to lack of activity. If you have any more questions regarding this issue we can reopen it.\n. Reopening this, since it seems there is some interest in the feature. It will probably have to be worked on by someone that needs it though.. @rhys-vdw I'm getting this locally.\n. Maybe it only happens on linux, although that makes no sense since there are no native modules in ESLint right?\nIt's not the wrong version, but rather the newest one. I have 1.9.0 though (and 4.1.5 of babel-eslint).\nHave you tried cloning the repo fresh? Maybe you have something in your local copy that makes this not fail.\n. 0.10.40\n. Isn't it just the eslint package that is doing the linting before the compilation step? What's the relation between eslint and babel-eslint?\nI should note that everything works fine if I skip the linting step and build Bookshelf as is, so it's really just an incorrect warning.\n. Node 0.10, is supported by Bookshelf right, so I don't think it's \"incorrect\".\nI think I found the relevant issues:\nhttps://github.com/estools/escope/issues/88\nhttps://github.com/eslint/eslint/issues/4481\n. That's not my example, but I think you're right.\n. @kripod If you can address the comment by the reviewer and provide some tests we can merge this.. Merging this as is and then I'll add more documentation to it and change the method used as proposed by @chamini2. The difference in performance is negligible between the two, but it uses less code, and is not less readable, so there's that.. Duplicate of #974.. Depends on what you mean by \"with Bookshelf\". You can get that output by overriding the serialize method of any model, but that will be permanent, so you are probably better off just formatting the output using lodash or a simple Array.map.\n. Using models it's not possible since models will always serialize into an object. So, I think my first answer isn't correct. You should override toJSON(), which on second thought, is what allows you to control how a model will be transformed into a string.\nAFAIK there are no drawbacks to that approach except for the obvious of only having one type of output when you want to stringify your models, or convert them to pure javascript objects.\n. Using models it's not possible since models will always serialize into an object. So, I think my first answer isn't correct. You should override toJSON(), which on second thought, is what allows you to control how a model will be transformed into a string.\nAFAIK there are no drawbacks to that approach except for the obvious of only having one type of output when you want to stringify your models, or convert them to pure javascript objects.\n. And it's failing when you do what?\n. Why are you using .through on that relation?\nIn fact, I'm almost certain your relations are all a bit too complicated unnecessarily. You don't seem to be attaching any extra info to the join table, so it would be best to use just belongsToMany (without through).\nSo, can you try something like this instead?\n``` js\nTutorials = bookshelf.Model.extend({\n  tableName: 'tutorials',\n  idAttribute: 'tutorials_id',\n  user: function () {\n    return this.belongsTo(Users, 'users_id');\n  },\n  tags: function () {\n    return this.belongsToMany(Tags, 'tutorials_tags', 'tags_id');\n  }\n});\nTags = bookshelf.Model.extend({\n  tableName: 'tags',\n  idAttribute: 'tags_id',\n  tutorials: function () {\n    return this.belongsToMany(Tutorials, 'tutorials_tags', 'tutorials_id');\n  }\n});\n```\nThe parameters to belongsToMany may be wrong. I never use them since I always use the defaults, so I'm not very familiar with them. You'll have to check the documentation to fit your use case.\n. Not possible currently. It's not a very requested feature, so unless you want to contribute it, I don't think anyone else will work on it.\n. Not possible currently. It's not a very requested feature, so unless you want to contribute it, I don't think anyone else will work on it.\n. Not sure. Both override toJSON so that could cause problems since this question is specifically about converting models to JSON.\n. Not sure. Both override toJSON so that could cause problems since this question is specifically about converting models to JSON.\n. The visibility plugin only omits fields when serializing the model. If you want those attributes to be hidden only sometimes but not all the time when serializing the mode, then you have to use other methods.\n. The visibility plugin only omits fields when serializing the model. If you want those attributes to be hidden only sometimes but not all the time when serializing the mode, then you have to use other methods.\n. What exactly is the problem here?\n. What exactly is the problem here?\n. And you're absolutely certain that there are indeed stats for that entity_id? And why do you need to convert the id to CHAR(25)? Your debug output shows a CONVERT but the SQL log shows a CAST instead. That doesn't seem right.\nI'm almost certain this is an issue with wither knex or the MySQL adapter, not Bookshelf.\n. And you're absolutely certain that there are indeed stats for that entity_id? And why do you need to convert the id to CHAR(25)? Your debug output shows a CONVERT but the SQL log shows a CAST instead. That doesn't seem right.\nI'm almost certain this is an issue with wither knex or the MySQL adapter, not Bookshelf.\n. This is not a bookshelf issue. Can you open a similar issue over on knex's repository?\n. This is not a bookshelf issue. Can you open a similar issue over on knex's repository?\n. I think the example is supposed to work without having to specify an unsigned column just for one of the database adapters, that's why this is an issue with knex and not bookshelf. Or am I missing something?\n. I think the example is supposed to work without having to specify an unsigned column just for one of the database adapters, that's why this is an issue with knex and not bookshelf. Or am I missing something?\n. Yeah, but the solution is just a workaround. I still think the migration should just work across all supported dialects, but no one has suggested that in any of those issues.\nI'm not against adding a note to the docs saying that is a known issue, and a link to the issue over at knex, but it should be noted that it is a workaround for MySQL only.\n. Yeah, but the solution is just a workaround. I still think the migration should just work across all supported dialects, but no one has suggested that in any of those issues.\nI'm not against adding a note to the docs saying that is a known issue, and a link to the issue over at knex, but it should be noted that it is a workaround for MySQL only.\n. That seems like a bug, but can you provide the code that leads to that result?\n. That seems like a bug, but can you provide the code that leads to that result?\n. How about #1105?\nWait, never mind. It's not the same thing. I misunderstood the question.\nI think the format method was supposed to be called in that case. What if you use the longer version:\njs\nProfile.collection().query(function(qb) {\n  qb.where('user_id', '=', 123)\n}).fetch()\n  .then(function(collection) {...\nOr just using fetchAll:\njs\nProfile.where({user_id: 123}).fetchAll()\nDoesn't that work as intended?\n. I thought you were not getting the results you wanted in the output. What you describe is a known limitation and there is no way around having to use the actual column names when using any of the knex methods. That won't change, however there may be helper methods in the future to avoid having to resort to knex in the first place.\n. @dannymidnight Using your example, what's wrong with just using:\n```js\nthis.Model = Bookshelf.Model.extend({\n  tableName: 'records'\n});\nthis.ModelObj = Bookshelf.model.bind(Bookshelf).call(null, 'Model', this.Model);\n```\ninstead of having to patch the library itself to achieve the same thing? This looks like a corner case where you are changing the context on purpose, right?. Closing this due to lack of response. If you have anything more to add we can reopen this for further discussion.. I'm going to merge this because even with the default JSDoc theme the quotes break things. This change will require a new version of our own jsdoc theme.. Reopening this since creating related models still sucks.. Reopening this since it's still an issue and something that should be addressed.. Is it on purpose that database is a global?\nPS: And bookshelf as well.\n. Can you fix any such errors then? That way we avoid having to ask about those things.\n. Closing due to lack of activity. If you have anything else to add we can reopen this issue.\n. No better way possible. That's the correct way to use an association that has a foreign key different from the expected default:\n\nBy default, the foreignKey is assumed to be the singular form of the Target model's tableName, followed by _id\n\nSo, if you use something else, like in your example, you have to specify it as the second argument to belongsTo.\n. Your relations are wrong according to what I understand. Your database schema is also not ideal apparently.\nYou're trying to access the User model using the article foreign key in the article table (second argument to belongTo), which is probably wrong and not what you meant.\nIf you're just starting I suggest you follow the recommendations in terms of naming and stick to plural table names and foreign keys composed with the singular form of the table name followed by _id, so:\n```\nvar User, Article;\nUser = bookshelf.Model.extend({\n  tableName: 'users',\n  article: function() {\n    return this.hasOne(Article);\n  }\n});\nArticle = bookshelf.Model.extend({\n  tableName: 'articles',\n  author: function() {\n    return this.belongsTo(User);\n  }\n});\n```\nThe articles table must have a column named user_id and that's it.\nUpdate: I misread part of your question before answering. Updated.\n. No problem. Glad everything is sorted.\nI know the documentation is a bit lacking, but time doesn't allow us to work on everything we wanted unfortunately.\n. The documentation is inline with the code files in /src/. It's just JSDoc comments that get converted to HTML when publishing.\nYou can generate the docs locally on your machine by cloning this repo and using the built-in task for that with:\nnpm run jsdoc\n. @Aurelsicoko Notice how in your case your table names are not plural, which is the default that Bookshelf expects, which means you have to specify the foreign key names to use.\n. Without seeing your database schema and updated model definitions it's impossible to know what you're doing wrong.\n. Try this:\njs\nArticle = bookshelf.Model.extend({\n  tableName: 'article',\n  author: function() {\n    return this.belongsTo(User, 'author');\n  }\n});\nYou should read the documentation a few more times since you seem to have missed that detail that is clearly explained in the docs for the second argument of belongsTo:\n\nForeignKey in this model. By default, the foreignKey is assumed to be the singular form of the Target model's tableName, followed by id / {{idAttribute}}.\n\nSince you're using author as the foreign key instead of the expected default (user_id) tou have to specify it in both models.\n. This isn't even valid javascript:\n[{\n  'feed.userRelated',\n  'feed.activityTypes',\n  'feed': function(limitNow) {\n    limitNow.offset(start).limit(10);\n  }\n}]\n. I think you'll have to use .query() or .where() for that, because if you omit the arguments to save() it will set any attributes that are defined on the model, but the WHERE part will always be the id only.\nYou should take a look in the source code for the save method. It is pretty well documented and should help you a lot more than I can.\n. That's not a very requested feature so I don't think it will get a high priority unless someone wants to provide a PR that implements it.\n. Yes, there's #552, but I don't think there's any talk about that particular feature. Composite primary keys are very requested, but you're actually the first person to request Buffer type primary keys.\nI'm not sure it would be easy to implement, particularly when it comes to associations, so given the limited resources and the fact that no one makes any money for this work, it's very unlikely that it will get implemented by someone that won't be using that feature.\nIf it's just a case of a few comparisons failing you may be able to dig into the source code and implement it yourself. The code is relatively clean, commented and easy to follow nowadays.\n. There are a lot of issues already regarding this, so if you search the issues list you'll find more information.\n. Related issues with probably useful information: #202, #597, #655, #833 and #834.\n. I think you're asking something that has been answered many times before. Can you check issues #202, #597, #655, #833 and #834, #1129? There are probably others, but these were the ones I could easily find. \n. Can you explain what doesn't work? What results you get and what you expect? Steps to reproduce? Preferably a small code sample that reproduces the problem.\n. You're just missing orWhere then :) Not sure why it isn't documented, but on knex's website there are lots of examples using it.\n. Are you updating all the rows with the same value?\n. The only way to avoid hitting an OOM error would be to divide the work in smaller chunks.\nYou could also try avoiding Bookshelf for that particular task and use Knex directly. Having to instantiate all those models at once is sure to take its toll on performance. If you search in the issues list maybe you'll find something that can help you.\n. That seems like it's the intended (although maybe surprising at first) behavior according to this (and the first() method is here).\nIf there are no constraints it will probably just do a SELECT * FROM Models ORDER BY id ASC LIMIT 1;. It's possible that someone is using this to quickly fetch the first model from a table, so I don't think we can change it that easily without potentially causing some pain.\nHowever this could be documented.\n. Well, I'm following semver here that states that:\n\nMajor version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable.\n\nand\n\nMajor version X (X.y.z | X > 0) MUST be incremented if any backwards incompatible changes are introduced to the public API.\n\nHere X is 0 so this doesn't apply.\nI don't think this should be reverted, because it would just be postponing the problem, and version 0.x is precisely to test things and to potentially break stuff. My idea is to try to get to a point where a major 1.0.0 version will be stable for as long as possible, so some breakage will occur before that.\nDo you have any real world examples of this breaking any code or is it more a theoretical problem?. > Bookshelf is not in the state of initial development. (...) We are using bookshelf for > 3-4 years.\nThat's debatable. There have been some breaking changes over the years, and we never released a 1.0.0. Time is not what determines if something is stable or in development.\nYour example makes sense, but is it a real example or a hypothetical one? Because unless someone comes up and actually complaints about this change breaking actual programs and doing the necessary changes to their code base not being a viable option because it would be too daunting of a task and they really need some change that was introduced with 0.13.0 then I don't see a reason to revert this.\nIf someone is worried about this change breaking something they can always stay on version 0.12.1. If the problem is not being able to update code then why would you even update a dependency?\nHowever I also don't want to purposely cause anyone harm, so if you can provide a valid reason that is not based on theoretical problems then we can always backport the other non-breaking changes to the 0.12.x branch.. Ok, those are valid examples. The thing is that the order of events will change eventually, so what difference does it make if it's now or 3 months from now? You will have to adapt your code base anyway right? That said I don't mind postponing this change until the next release, if that is a good compromise for you, but it has to be released at some point.\nAlso, there are other breaking changes in this release, including your PR about running async events in sync. It probably doesn't affect as many people but it doesn't change the fact that it is a breaking change, so should it also be removed? Breaking changes will occur and I would rather not pile them up all for the future 1.0.0 release.\nAs for the current version names I agree that Bookshelf should have released version 1.0.0 long ago, but that hasn't happened yet, so I'm trying to work towards it. In the mean time there will be some breakage.\nHowever I don't think your problem is the version number, since if we were already at a major version this would be the next major version and everything else would be the same and you would still be complaining about the order of events.\nIn the future would it help if I do some pre-releases before the final versions? Would that give you enough time to prepare for any potential changes?. BTW, I will be unable to do a new release in the next couple of hours, but if you make the necessary changes you can merge them and I'll do a release as soon as I get the chance.\nAlso, this will be a 0.13.1 release, which breaks semver, but I don't think anyone has built an application yet depending on the order of events of version 0.13.0.. Good points, but I'm working for free and practically alone on this, so there's just so much I can do to support older branches and backport important fixes. However I created a 0.12 branch a while back precisely to be able to do this if needed. If someone else complains about one of the breaking changes I'll look into making a point release in the 0.12 branch.\nI'm glad you got it sorted. I'll keep you posted on important breaking changes in the future.\n\nI would suggest to keep this as is and release a 1.x asap\n\nI'm working on it! :sweat_smile: . Duplicate of #472.\n. Looks good to me, although I remember talking about removing /lib before but we couldn't do it at the time due to some reason I forgot. Something related with the release process and needing to link to actual files in /lib?\n. I'm totally for not depending on babel, but that would mean dropping support for Node.js 0.10 and 0.12 which are still very used versions, so I doubt it will happen any time soon.\nAs for Bluebird, it's the same situation, but even less likely for Bookshelf to drop it as a dependency, since it performs better than native V8 Promises, although I get your point about developer choice.\nThat said, let's see what others have to say about it.\n. No, #90, #552, #592 and #669.\n. I see a couple of things potentially wrong there. First and most obvious is the for loop inside the promise chain. That's usually a big no unless you're only iterating through data that is already available. In your case you're calling an asynchronous function (fetch) inside a synchronous loop, so that's bound to cause problems.\nIf you want to load multiple things inside a promise you should use Promise.all.\nThen your SiteObj thing also seems a little too much convoluted. You usually don't want to call methods that load data in models through another object. You can add your own instance and class methods to the Site model during extend, which is probably what you're after.\nAlso, it looks like you're trying to load related data, but you can already do that using\nnew MyModel.fetch({withRelated: 'something'}).then(function(result) { ...\nIf you need to change the related data query to constrain it or something there are also some questions that deal with that already if you look in the issue tracker.\n. I personally have code that uses Bookshelf with multiple different types of queries firing concurrently for long periods of time (over 1 minute) and never had any issues like that, so if you're worried about this issue happening in a busy system, then you shouldn't be, as long as your code is correct, and judging by your examples, it probably isn't.\nMy best advice is to fix the issues that we already mentioned first, read the Bluebird docs a few more times and if you still have problems try to create a minimum code sample using an in memory SQLite database that is able to reproduce the problem.\n. That's the intended behavior according to the docs. Every time you call .save() it will update the timestamps if the model has them, like your model does. You're just updating the model so I'm not sure how you got the idea that the timestamps should not have been updated.\nIf you want soft deletes check #53 and #261.\n. Oh, that's different. You didn't clearly explain what the problem actually was, so I assumed it was the part about both created_at and updated_at being updated, since you used all capitals to emphasize that part.\nI think your problem is how you're defining the timestamp functionality. You're passing an array of column names, however those columns don't actually exist in the database. When you pass an array to .hasTimestamps you have to use actual column names as they exist in the database, because that functionality doesn't use parse/format. Since you're using the default column names anyway, you should be able to get everything working perfectly by just using .hasTimestamps = true.\nFor reference here's the relevant documentation.\n. Well, it would help if you could provide a minimum code sample that reproduces the problem using an in-memory SQLite database, because looking at the provided code I see no obvious problems. However I think you have more going on that's not in the provided code, judging by the non-standard name property on your model, right?\n. I just remembered something. It probably won't make a difference but could you try calling save like this:\njs\nLike.forge(item).save({method 'insert'})\n. Ha :D No problem.\n. Take a look at #227 and #1015. This is either a documentation issue or a functionality issue.\n. The response comes a bit late, but I think you could use the .through() method to specify the joining model and add the hasTimestamps option to that model. This is hinted at in the documentation, although not specifically about adding timestamps.\nExample using the linked examples as base:\n```js\nvar AuthorBook = bookshelf.Model.extend({\n  tableName: 'authors_books',\n  hasTimestamps: true\n});\n// In the Author Model\n// ...\n  books: function() {\n    return this.belongsToMany(Book).through(AuthorBook);\n  }\n// ...\n``. So, the only ones from that list missing on the Readme arebookshelf-bcryptandbookshelf-history`. For reference community plugins were added to the Readme in 5835928a0f a few months after this issue was opened.\n@bsiddiqui Are you still interested in adding those two plugins to the list? . Thanks, but the mentioned issue will be fixed by the next release, at which point the documentation will also get updated, so this won't be necessary.. This seems to be fixed by now. Probably with #1469.. @tmcdonnell87 Yes there is, it's because the PR lacks tests to check for this change.. There are no tests in PR #1260. If you're not willing to add at least one test to check for the correct behavior of that change I might be able to add one.\nI'm planning on doing a release soon, but that won't include changes, only small bug fixes. The release after that will include changes, like the one being proposed in #1260.. Fixed in #1260.. I just checked the included test case with Bookshelf 0.12.1 (without the other changes proposed here obviously) and it passes correctly, so marking this PR as invalid.. For the record, this was fixed in #1469.. Not easy to fix since the result can be a bigint. We can't convert to a number in this case, so this should be a documentation fix only perhaps?\nI would still prefer that Bookshelf returned a number, since that's the expectation.. @vellotis Are you interested in adding tests to this PR?. Closing this since it doesn't include tests and there were many changes to Bookshelf and Knex since this PR was written and the conflicts are hard to fix properly. Also, I tried as much as possible to adapt the code into the current codebase but the original issue this was supposed to fix wasn't fixed.\nHowever I now have a new test case that can be used to check for the last remaining issue mentioned in one of the comments of #96.. Fixed with #1563.. I just tested these changes with the latest version of Bookshelf and they all pass, so maybe it was your problem? In any case do you still think it's necessary to merge this?. Closing this due to lack of response. If you have any more information to add we can reopen this PR to discuss it again.. So, this was meant to test if a specific Model property (changedAttributes) was not present when instantiating new Models.\nThis comes from a time when Bookshelf was based on Backbone and Backbone models do have that property. However there was code in place to exclude it (along with others, see here and here) from Bookshelf models during initialization. Since this project moved away from Backbone a few years ago this test doesn't make sense anymore.\nHowever, I think you're trying to test something else here. @vellotis can you explain what that is?\n  . Seems to be fixed now.. Closing this due to lack of activity. If you have anything more to add we can reopen it.. Well the docs briefly mention what defaults does, but I agree that it could be expanded upon.\n\nIf the model isNew, any defaults will be set and an insert query will be performed.. Fixed with #1797.. This will be a bit tough to implement in the registry plugin, but I'll leave it open as a feature request in case someone wants to work on it.. Closing this due to lack of response.. Closing this due to lack of response.. PR #1326 has been merged. Did it solve your issue?. Closing this due to lack of response and because this PR has become a mess. If you wish to get these changes merged you should open a new PR that doesn't include the lib files and upstream merge commits.. Closing this since there are several proposed solutions and the user never responded back.. Closing due to lack of response and since this is probably fixed already.. Closing this due to lack of response.. Closing this due to lack of response.. Closing this due to lack of response and because the original question doesn't have enough information to get a proper answer.. Closing this due to lack of response and because the original question doesn't have enough information to get a proper answer.. This conflicts with #799, but since collections could still be re-implemented as a plugin it may be important to revisit this issue.. No idea, but if you haven't been able to figure it out in all this time it probably isn't. I'll mark it as a feature request.. @GabrielNicolasAvellaneda Actually the .toJSON() method is something natively supported by JSON.stringify(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior\n\nIt's not supposed to produce a string. That's the job of JSON.stringify().. This isn't really fixable until something like #1018 is implemented, because Bookshelf doesn't know what your schema looks like, so it doesn't know which attributes represent valid database columns and which ones do not.. This isn't really fixable until something like #1018 is implemented, because Bookshelf doesn't know what your schema looks like, so it doesn't know which attributes represent valid database columns and which ones do not.. Can you explain why this is necessary and what kind of side effects it may have?. Closing this due to lack of response. I'm not against merging this, but I need more information if anyone is still interested in getting this merged. If anyone has anything more to add we can reopen this PR and discuss it again.. This is a bug. Both in the creating and updating events attrs currently only contains attributes that were passed as arguments to the save() method. This means that any attributes that were changed with .set() or .forge() won't be in the attrs argument.. Not sure what you're asking but since you're using a query builder method that part is documented over on knex's website here. If you have any more questions regarding its usage it's best to ask in the knex repository directly or on Stack Overflow.. It looks like the code that handles this event has been like that since about version 0.8.2. Also, from looking at the code I see no reason why this wouldn't work, but I haven't looked too deeply or investigated much.\nCan any of you provide a reproducible test case for this issue?. This seems to be fixed with the latest version. Either that or there is some information missing from this issue.\nCheck PR #1853 for a test case that is similar to the mentioned steps to reproduce.. Closing this due to lack of response. If you have anything more to add we can reopen this to discuss it further.. Fixed some time between the issue creation date and today.. Fixed some time between the issue creation date and today.. I'm not sure this is a lodash issue at all. What version of Bookshelf are you using?. If you could get a reproducible test case that would help a lot. Here's an example: https://gist.github.com/ricardograca/da68dc091fcbe15c395558c166fd7200. It could be an issue with plugins. If you have any other plugin besides pagination you could try turning them off one by one until the problem is gone.. What is the fetch code that you're using?. And parse code?. It was a design decision. Not sure if it still makes sense, but the linked issue above can be used for further discussion.. Is this still an issue with the latest version? Can you provide a reproducible test case?. Is this still an issue with the latest version? Can you provide a reproducible test case?. Yeah, I know what you mean. That exact behavior was also very strange to me when I started using Bookshelf. The thing is that just because two collections have the exact same type of model doesn't mean they are the same object/class.\nWhen you instantiate a collection by calling .related() on a model it will create a new anonymous collection constructor with the model set to the parent Model. Bookshelf has no knowledge of your OtherThings collection, so the two could never be the same thing.\nThe surprising thing here is that in both cases they refer to the same data on the database. That's one of the reasons why Tim and others (me included) wanted to get rid of collections altogether. See #799.. > Oh god yes, I'd love the removal of collections - but it'd break our entire app.\nYeah, it would be a major breaking change for sure, but it should be possible to ease the transition with a plugin that emulates the old behavior.\n\nTheoretically, since bookshelf does know which model to set as parent - wouldn't it be possible to just instantiate using Model.prototype.collection everywhere and thus allowing user space to overload?\n\nAFAIK this is the method that gets called when fetching one-to-many type relations, so it is already instantiating collections using the method you mentioned. I think it should be possible to implement the changes that you want by modifying that method to use a specific Collection class if it's referenced in the Model somehow, which is probably what you're doing, right?. Could be. If you want to do the changes necessary for this I'm open to a PR, although you have to keep in mind that collections will probably be removed at some point in the future. Could be a very distant future though.. Interesting. With #1806 the registry plugin will be promoted to core, so this feature will be built-in. It would be a good idea to add these instruction on how to create a custom reusable collection to a guide explaining the whole process.. It seems like Knex implemented nested transactions with save points according to this comment by elhigu, so this should now be possible. Refer to #353 for more info.. It seems like Knex implemented nested transactions with save points according to this comment by elhigu, so this should now be possible. Refer to #353 for more info.. Closing this due to lack of response. If this is still valid we can reopen this issue.. Sounds good to me. What do you think @mrhwick ?. For those still interested in this also see #799.. @JC3 Are you interested in addressing the issues that were raised so this can be merged?. Closing this due to lack of activity. If you have anything more to add we can reopen it.. No idea what this is about.. There's no lib/next/example/init-models.js in the distribution version of Bookshelf. There's also no fluent_record in Bookshelf. No idea what this is about, but probably not Bookshelf related.. There's no lib/next/example/init-models.js in the distribution version of Bookshelf. There's also no fluent_record in Bookshelf. No idea what this is about, but probably not Bookshelf related.. Closing this as duplicate of #1664.. Bookshelf is indeed compatible with Node 4.3. You should be able to find the problem with the suggestions others have offered.. So, the reason that you can't just use model.id in the groupedKey part is because of issue #1388. However, due to some other recent changes it is now possible to use model.parse to get the correct key. I'll get a fix for this soon.\nAs a note to self, there should be a camelCase to snake_case functionality built-in that doesn't depend on parse and format, because we're mainly dealing with that type of transformation on these types of bug reports, but it's quite possible that all this dependency on these two methods throughout the code base is introducing bugs if used with other types of transformations.. I've been working on this for some time and it's almost ready. Here's a sneak peek:\n\n. I think it should, since it doesn't lock the file in any way.. I think it should, since it doesn't lock the file in any way.. Sorry @ErisDS, I thought you needed more information from @NomadicBits. After reading the issues more carefully it seems to be a bug. So, you propose to fix the current implementation of model._previousAttributes to behave like your own model._updatedAttributes?. Ok, I get it now. Seems like the correct behavior from _previousAttributes, so no bug here.\nHowever I think having _updatedAttributes on the core would be great. I use that kind of information a lot in other non-node.js projects. Proper documentation is also very much welcome :+1: . @ErisDS @NomadicBits I've looked at a few ORMs, notably Sequelize, ActiveRecord and Eloquent, and they all seem to behave like what we already have in Bookshelf in regards to previousAttributes.\nHowever, the ActiveModel::Dirty class (documentation here) used by ActiveRecord models does have a few methods to track changes before the last save, like the previous_changes() method, but that only records changes done before the save, not what all the attributes were like.\nSo, my current solution to fixing this issue is to clarify the current documentation, and to add some additional method(s) to get the attributes before the last save. Your updatedAttributes solution seems adequate, but I don't like the name. The result of that method isn't a list of updated attributes, but rather the opposite of that, i.e. the attributes how they were before the update. Any suggestions? Thoughts? I'm open to breaking changes.\n. @ErisDS @NomadicBits I've looked at a few ORMs, notably Sequelize, ActiveRecord and Eloquent, and they all seem to behave like what we already have in Bookshelf in regards to previousAttributes.\nHowever, the ActiveModel::Dirty class (documentation here) used by ActiveRecord models does have a few methods to track changes before the last save, like the previous_changes() method, but that only records changes done before the save, not what all the attributes were like.\nSo, my current solution to fixing this issue is to clarify the current documentation, and to add some additional method(s) to get the attributes before the last save. Your updatedAttributes solution seems adequate, but I don't like the name. The result of that method isn't a list of updated attributes, but rather the opposite of that, i.e. the attributes how they were before the update. Any suggestions? Thoughts? I'm open to breaking changes.\n. Thinking about this some more I think it's best to just change previousAttributes() and previous() to return the expected values. This will be a breaking change, but currently it's a bit useless having these methods return the same values that are already set on the model after a save(), so I doubt it will cause problems for anyone.\nSo, with the proposed changes both methods would always track changes done to the model, and would not get reset when saving.. Thinking about this some more I think it's best to just change previousAttributes() and previous() to return the expected values. This will be a breaking change, but currently it's a bit useless having these methods return the same values that are already set on the model after a save(), so I doubt it will cause problems for anyone.\nSo, with the proposed changes both methods would always track changes done to the model, and would not get reset when saving.. No, the docs are correct. Maybe an image with some example tables would help to visualize where the foreign keys are.\nhasOne is like hasMany but with a single target instead of multiple, so it is also the opposite of belongsTo. What this means is that the target model will have a key like this_model_id and this is what you use the foreignKey parameter for.\nThe last parameter (foreignKeyTarget) is only needed if the foreign key in the target model references a key in this model other than the default id (or the value of idAttribute).. No idea what this insertId is, but I'm pretty sure it was never in the docs, and that it's coming from Knex, so this isn't an issue with Bookshelf. Also, the original question seems to have been answered.\nThe Upsert feature is already open in #55, so I'm closing this.. No idea what this insertId is, but I'm pretty sure it was never in the docs, and that it's coming from Knex, so this isn't an issue with Bookshelf. Also, the original question seems to have been answered.\nThe Upsert feature is already open in #55, so I'm closing this.. Bookshelf has no knowledge of your database schema, except for the table name and a few foreign keys in some cases. This means that it's not possible to know beforehand which columns have a default value. However, there's a request for a refresh/returning feature so that you can get the inserted values right after saving the new model.\nIn the mean time you can use the defaults functionality from Bookshelf, but that is independent from your database schema. It's all done on the application side.\nClosing this as duplicate of #1665.. Fixed with #1830.. Fixed with #1529.. That seems correct @coryallegory. Thanks anyway @websoftwares.. That seems correct @coryallegory. Thanks anyway @websoftwares.. I don't understand what you mean, but the previous() and previousAttributes() methods were recently changed to behave like most developers expect them to: #1848.. Closing this due to lack of response.. Closing this due to lack of response.. Closing this due to lack of response.. I don't understand what you're trying to get at. Is that an example on how to solve #1535?. I have no idea what this is about. Is that error only thrown when adding an event listener for fetched / fetching events? Or when the event triggers?. This has some good ideas but I'm not a fan of the _parseWrapper thing, mainly because it's a somewhat obscure method and it may not be obvious that it must be called internally instead of parse() when developing new features or bug fixes. It's also used in a few places where it's not really necessary.\nThere's also the somewhat popular opinion that parse() and format() are confusing and should be removed, which may eventually happen, so I'd prefer a solution that doesn't depend on these methods, and especially that doesn't make them more confusing than what they already are.\nI'm working on a solution to this issue that doesn't involve parse() and it should be ready very soon, so this is something that is definitely going to be fixed in the next version.\nThank you for your contribution anyway.. > I don't see how dropping down to knex.raw() is an acceptable solution...\nBecause it's the only way right now. I agree it sucks, but no one has implemented what you want yet.\n\nWhy can't bookshelf let me do something as simple as...\n\nBecause if it was that simple to implement someone would have done it already, so clearly it's not simple. This has been an issue for a long time and many already reported it, but no one actually did the required work. This will require a very extensive refactor of Bookshelf, which will happen at some point, but for now knex.raw will have to do. The issue here is that these relations are not fetched using JOIN, but using two separate queries. See issue #141 for more info.\nFor the record, this is a duplicate of #141.. Closing this due to lack of response. If you have anything more to add we can reopen it.. @pbassut Can you open a new issue explaining the problem?. Closing this due to lack of activity. If you have anything more to add we can reopen it.. Closing this due to lack of response. If you have anything more to add we can reopen this for further discussion.. Closing this due to lack of activity. If you have anything more to add we can reopen it.. Closing this due to lack of activity. If you have anything more to add we can reopen it.. Closing this due to lack of activity. If you have anything more to add we can reopen it.. @mstaniewski Probably:\n```js\nreviewsAverage: function(){\n    return this.reviews().query(qb => {\n      qb.select('place_id')\n      qb.avg('service_rate as service_rate_avg')\n      qb.avg('price_rate as price_rate_avg')\n      qb.groupBy('place_id')\n    }).first()\n  }. @mstaniewski Probably:\n``js\nreviewsAverage: function(){\n    return this.reviews().query(qb => {\n      qb.select('place_id')\n      qb.avg('service_rate as service_rate_avg')\n      qb.avg('price_rate as price_rate_avg')\n      qb.groupBy('place_id')\n    }).first()\n  }. Closing due to lack of response.. Closing due to lack of response.. @Playrom This is a documentation change. Why would it need tests?. I don't understand what the problem is. You're trying to get some columns of thequestions` table but they're not showing up on your model?\nUpdate: Nevermind, I got it now after reading the question a few more times. So, these related questions are like static questions that are the same for all applicants or do they depend on the applicant?. I don't understand what the problem is. You're trying to get some columns of the questions table but they're not showing up on your model?\nUpdate: Nevermind, I got it now after reading the question a few more times. So, these related questions are like static questions that are the same for all applicants or do they depend on the applicant?. Closing this due to lack of response.. Fixed with #1779.. You can't.. You can't.. I just have one (probably unpopular) suggestion and that is to drop babel. Since node versions 0.10 and 0.12 are no longer supported is it really still necessary?. > ...so Babel is not totally unnecessary yet...\n... if you want to write code using ES6/7 features. If you don't then it is.\nThis change only affects Bookshelf.\nAgreed on closing old issues. I'm afraid they will come back to bite us eventually and nobody will remember that there was an issue about it by then.. I know it's a terrible thing to do, but I think we should close questions either immediately or after 3 days at most if there's no answer. This isn't stack overflow, and I think these take a lot of our time.. @jkantr I think the best thing to do is to go over the issues that are not labeled and figure out what they are and apply a label.\nIf you are sure it's a bug report, then finding out if it's still an issue would help a lot. This won't be easy because most of the time there's no code example on how to reproduce the bug.\n@joepie91 That's a good point. However sometimes the questions are about advanced usages of Bookshelf that may even require dropping down to knex. Is this something we want in the docs? Maybe we do, in an \"Advanced Topics\" section or something like that.\n. Your analysis seems correct. You can do what you feel is the best in terms of \"stale\" issues, but I'm almost certain all of them are still valid.\nMy contributions are mostly in terms of labeling and triaging incoming issues and answering the most basic questions.\nI've delved into the code base in the past, and it was a bit messy, very difficult to follow along, not enough or incorrect documentation, so I've mostly given up on that. I also haven't used Bookshelf in a while, so I'm not in the best position to fix issues or develop enhancements.\nGood luck, you're going to need it :wink: . I just wanted to update this with my personal opinion on how things should move forward, and provide an update to this.\nShort term\nFirst, I'm in the process of merging or closing all open PRs. It doesn't make sense to let them gather dust like that. However, some of them contain breaking changes so caution is needed.\nI just released a new version of Bookshelf that contains most of the PRs that were safe to merge: mainly documentation and small bug fixes. The rest will be taken care of soon and most should be handled by the next release. This will be a somewhat breaking release because we'll finally add the engines key to require Node 4 or newer. People still using older versions will have to continue using version 0.12.x of Bookshelf. I just created a new 0.12 branch for dealing with any possible updates to this version, but it will generally be unsupported once the new one is out.\nSome PRs can't be merged in their current form, even if they contain valuable changes, because they target an older version of Bookshelf that didn't use babel and/or their authors don't want to update them to address some concerns that were raised in the mean time. These will have to be recreated again.\nAfter all PRs are dealt with, or when only unmergeable PRs are left, the time will come to get rid of babel. See #1606 for the reasoning and discussion around that change.\nLong term\nThat was the short term plan. The longer term plan is to finally take Bookshelf in the direction outlined in #552, along with some of the ideas expressed in #1661. That is, to convert it from the sort of active record type ORM that it is now to a data mapper ORM.\nIn the middle of all this, the test suite should also be overhauled because it has a few issues right now. The biggest, in my opinion, is that it doesn't have any kind of isolation between individual tests. Many depend on each other, the working mock dataset isn't reset between each individual test and they must all be run in a specific order. That makes any refactoring or addition of new tests harder than it needs to be, as well as making the tests' validity questionable.\nGeneral Guidelines\nWe should also decide on a few guidelines to help steer development and decision making. These are the ones that I can think of:\n\nData Mapper: always thrive to achieve separation between the models and the underlying database.\nDon't depend on the query builder so much: this is implied in the first one, but to explain a little better, any functionality that can only be achieved by using the query builder and that comes up a lot should probably be converted to a built-in process. Ideally there shouldn't be the need to access the query builder at all.\nDon't require a database: also implied in the first one, but is a concern that has come up a few times before. What this means is that all database specific code and any abstractions required to make something work in all supported database engines will be handled by Knex.\nThe simpler the better: if there are two solutions to a problem, go with the one that is clearly the simpler and less invasive, even if it isn't as complete as the other one.\nPrefer more methods that do smaller individual things than less with too many configuration options each.\nHave only one way to do things.\nDon't shock people too much: that is, don't try to change too much at the same time. Small gradual changes are the way to go.\n\nThe second last one is especially concerning to me, because e.g. there are a lot of ways of fetching a model from the database currently, and all these options come at a cost of user confusion, inconsistent behavior, results and documentation.\n  . > I'm really looking forward to see where this is going, as its not everyday an established ORM takes time to do such an major overhaul.\nWell, the plan is to do it as gradually as possible, instead of trying to change everything from one version to the next. Some already tried that before and failed. It's just too big of an undertaking to do in one go.\nThanks for the suggestions on good ORMs to check out.. > ...if it can be done by the query builder, why reimplement it?\nWell, in that case it seems like you just want to use a query builder. So, it's a matter of preference really. Do you want to build the queries yourself or have some higher level abstraction?\nI bet some would argue why you'd need a query builder at all when you can just use the specific database adapter.\nIf we depend too much on having to know how the database works and how to generate correct SQL then there's no point in Bookshelf at all. It's job is to precisely abstract the database layer, so if it's not doing that it has problems. If that's the case, then you're right and you're better off just using a query builder.. > ...interface layer between the backend and frontend.\nDo you mean to provide a plugin or do whatever changes are necessary in core to allow Bookshelf to be used on the client-side?. @ansem78 If you have any specific issues with the documentation it would help if you opened issues explaining those problems.\nAgreed about dropping collections. That is one of the medium term goals: #799.\nAbout relations not being present when converting to JSON I'm certain that already happens. If you do:\njs\nnew Customer({id: 1}).fetch({withRelated: 'settings'}).then(function(model) {\n  console.log(model.toJSON())\n})\nyou'll get the expected customer with a sub-object with the related settings. Maybe you have the visibility plugin active and that is conflicting with your expectations?. > This is contradictory. The first statement is correct, but the second implicitly says that also a reading operation calls format, that is obviously false.\nWell, it's not implicit. It actually says that format will influence fetch() operations, which it does. Take a look at #668. Why do you say it's false? Can you provide a reproducible code sample where removing id attributes in the format method doesn't influence fetch() or eager loading of relations?. Please continue that discussion in #668. I've reopened it. Sorry I linked the wrong issue in my previous comment. I've edited it to the correct issue.. Closing this since the discussion already received a lot of useful contributions and 0.14.0 was just released together with a new documentation website redesign.\nIf you want a new feature or you have a bug to report use the issue tracker for filing specific issues.. It seems like a good idea to me.\nPS: You got the username wrong ;). I think that would be ok, but why not just return the new bookshelf instance from the database.js file directly and avoid all the repetition in the models?. @dantman I don't think Bookshelf aims to support react-native, unless I'm missing something. Anyway, we would still have to support Node versions that probably also don't have all those shiny new features for some time, so I'm sure react-native will catch up.\nBTW, I just noticed there's no engines key in package.json.. > I see no reason not to support react-native.\nHow about extra burden on bookshelf developers who may not even be familiar with it? Unless any of the current developers wants to support it, I don't think it will be a high priority in the considerations list for this proposal. Do you want to help out on that front?. :+1: . :+1: . @skwee357 It looks like @Playrom hasn't been active lately. If he doesn't respond in a few days let me know and we'll discuss how to fix this issue and get a new release out.. I propose that the old issues related with documentation that were all closed just now be re-checked to see which ones are still valid. I'm pretty sure all of them still are, and should be fixed.. Oh, I just wanted to say that if they are still open it's because most of the time it's not easy to figure out what to write and what the issue with the docs is in the first place, so this will take a lot of work to sort through, but I'm willing to help from time to time.. Docs have been updated. For the record, this happens automatically every time a new release is published.. Me? Are you sure? :D My specialty is documentation, but I'll try.. Me? Are you sure? :D My specialty is documentation, but I'll try.. There's a small problem with your description. You say that you run a fetchAll right after the save method, but your code says you are running them in parallel.\nIf you really want to execute things sequentially this is how it should look like:\njs\nconsole.time('save')\nconsole.time('fetchAll')\nModel.forge({id: 1}).save(attributes).then(function (newModel) {\n  console.timeEnd('save');\n}).then(function() {\n  return Model.fetchAll();\n}).then(function (allModels) {\n  console.timeEnd('fetchAll');\n});. There's a small problem with your description. You say that you run a fetchAll right after the save method, but your code says you are running them in parallel.\nIf you really want to execute things sequentially this is how it should look like:\njs\nconsole.time('save')\nconsole.time('fetchAll')\nModel.forge({id: 1}).save(attributes).then(function (newModel) {\n  console.timeEnd('save');\n}).then(function() {\n  return Model.fetchAll();\n}).then(function (allModels) {\n  console.timeEnd('fetchAll');\n});. @bloxmobnico If in your example you use the equivalent Knex queries directly is there any extra delay?. Well, if knex queries work as expected then it sure looks like some kind of bug in Bookshelf indeed.. @Playrom it's free for open-source projects.. @Playrom it's free for open-source projects.. Fixed with PR #1616. All production dependencies are up to date now. Only some dev dependencies can't be updated immediately until we add the engines key to package.json to support only Node version 4 and newer.. I think you're looking for the opposite operation, which is parse.. @tmcdonnell87 Can you verify this is still a bug with the latest version of Bookshelf (0.13.3)?. @tmcdonnell87 Can you verify this is still a bug with the latest version of Bookshelf (0.13.3)?. See #1602 and #1607. . See #1602 and #1607. . Possibly related to #1611.\nAlso, the timers are probably correct, but it's the queries that aren't being executed like you expected them to.. Actually you may have uncovered the reason for the bug I linked to. It seems that queries are being handled in a FILO fashion instead of being more FIFO (or even random) like they were supposed to.. Not that I know of since this is a new development. I don't think anyone is working on it, so if you'd like to see this fixed faster you can try to debug it further.. Closing due to lack of response. If you have anything more to add we can reopen this issue.. @mrhwick might have a different opinion, but I think this PR needs to have at least one test added for this before it's merged.. @jordansexton Can you add tests to verify the correct behavior of this bug fix?. @mrhwick I think the test are failing due to the node_modules cache maybe? Is there a way to force update the cache?. Related issue: https://github.com/babel/babel-eslint/issues/479. > Also, I don't know if there is harm in always using transacting: t, if t is null for usual actions.\nI'm almost certain that's OK since the check is usually something like if (options.transacting).. If you are ok with always converting id you can use the parse method.. I don't think it's exposed. There's one Promise instance exposed on the knex query builder after you instantiate a new Bookshelf object, if that's of any help:\njs\nvar bookshelf = new Bookshelf(knex)\nbookshelf.knex.Promise. Closing this due to lack of response. If you have anything more to add we can reopen this for further discussion.. Possibly duplicate of #1542.. Would be helpful if you filled out the issue template so we can get some context about this proposal.. @ollija Can you add some tests to check for this? I'm asking because there was already a much earlier issue exactly like this one that was deemed fixed (#49), but it must have regressed at some point. I would like to prevent that from happening again in the future.. I just added a test for this in #1735.. Bookshelf doesn't do UNION operations, so you always have to use Knex (like in your example) if you want that.\nHowever I fail to see where the error is in:\n\nThe logged error: ...\n\nIt's outputting exactly what you told it to.. >  think this problem is related in someway to this line:\nHowever that line would simply set columns to departments.* and ignore your defined ones, but that shouldn't even be possible because you are specifying columns so that part of the code shouldn't be doing anything.\nI think it could be because in your qb.columns('id', 'name'); call you are missing foreign keys required to retrieve the related records, so bookshelf just adds departments.* to ensure they are there, but I'm not sure about this. Can you try adding the missing key to .columns and see if that helps?. So, the part of the code you linked to isn't related with this issue since you're using the query builder's .columns() method, not the columns: ['...'] option of the fetch() method.\nIs that authenticatable relation going through the departments table?. So, the part of the code you linked to isn't related with this issue since you're using the query builder's .columns() method, not the columns: ['...'] option of the fetch() method.\nIs that authenticatable relation going through the departments table?. Closing this due to lack of response.. Duplicate of #1015. If you happen to know what it should say instead that would be great!. Seems like you're proposing something related with Knex, not Bookshelf. Anytime you use the query builder directly, you're using Knex.. Oh I see. I misinterpreted your question. It's actually an old feature request that has been brought up multiple times: #141, #559, #714 and possibly more but I didn't look further.\n\nI've got your point but actually the relations are defined on the Bookshelf level, right?\n\nYes, but every time you use the query builder interface (q.something() in your example) you're using Knex, and Knex has no knowledge of Bookshelf models. Yes, I also agree this is confusing.\n\nMaybe my solution it's not the one, but there would have to be a way to retrieve all users which have a country named \"X\" without using the INNER JOINs, because this defeats the purpose of modeling relations under each Model.\n\nActually, that would be the preferred way to do it, but Bookshelf doesn't do JOINs currently. That's why you have to use the query builder interface. When you're using JOINs you're actually dropping down to Knex like I mentioned above.. You can try this plugin: https://www.npmjs.com/package/bookshelf-json-columns. Possibly fixed in #1625. Can you try that PR and see if it fixes your problem?. Can you see if this comment is of any help in your case?. Good work. Thanks!. I'm going to assume you actually closed the .fetch().then() call and you just forgot to include the }) in the code above.\nFirst, are you using some kind of camelCase to snake_case conversion on that model? Because there was a bug that prevented the id from being updated in some cases when using that kind of parse() and format() methods.\nAlso, your {patch: true} option isn't doing anything since it's outside the options object (second argument to .save(). It should be {method: \"update\", patch: true}.\nFinally, there's a test in place to guarantee that the primary key of a model can be updated and it is currently passing, so this issue is probably fixed in the master branch and the fix will be available in the next release.. Closing this due to lack of response. If you have anything more to add we can reopen this for further discussion.. I'm pretty sure that this works like you expect it to. Are you experiencing anything different?. I'm pretty sure that this works like you expect it to. Are you experiencing anything different?. Closing this due to lack of response.. This is on hold until #1696 is merged in, since mocha 4.x requires node 4 or newer.\nHowever, the following must be observed when dealing with this upgraded dependency:\n\nmochajs/mocha#2879\nwhy is node running?\n  . I've seen tests fail due to some build error because OracleDB wasn't present.. So, both the first and the second parameters are \"model firing the event\"? There must be some difference. Since you're delving into this do you know what the difference is? This could finally fix #1015.. Ok, thanks for the info. Can you update your PR to include that information? I ask because having the first two arguments being \"model firing the event\" isn't correct.. What do you really want to do? If you want to filter some models based on a relation that isn't possible right now.. I don't really understand what you mean, but you should probably be able to do what you want with knex which is accessible via the query builder interface of Bookshelf: http://bookshelfjs.org/#Model-instance-query . I don't understand where your three-way relationships are. Can you clarify?. Ok, I think I understand now. You want to eager load the associated UserRight Periods together with the User's Rights.\n\nThe problem here is that the relation you have now is between User and Right, but none of these models have any knowledge of the Period model. That relation only exists in the UserRight model, so your tree looks something like:\nUser -> UserRight -> Right\n            |\n            v\n         Period\nCurrently Bookshelf can't eager load that kind of relation as far as I know. However you should be able to work around it by creating a new relationship between User and UserRight:\njs\nconst User = bookshelf.Model.extend({\n  // ...\n  userRights: function() {\n    return this.hasMany(UserRight)\n  }\n}\nThen you can eager load both right and period:\njs\nUser.fetchAll({\n  withRelated: ['userRights.period', 'userRights.right']\n})\nI know it's not exactly the same thing in terms of data structure, but it should get you the data you want.\n. Closing due to lack of response.. Good point about not needing an actual database server for testing. However, in order to fix issue #1665 won't it require database adapter specific code? Or does knex already support that? . Well, I think to decide how to fix these types of issues would require having a set of rules for development going forward. In this case one of the rules could be that all database interaction is always performed by Knex like you suggested, so Bookshelf doesn't know anything about database engines. If Knex doesn't support something that is needed for Bookshelf, then it's implemented there first. This is just an example of a possible rule, but it's something in line with the objectives that Tim had.\nI think having these rules would help to define a clearer vision for the future.. @mrhwick So, if Bookshelf abstracts the database interface details shouldn't the query builder interface be removed? Currently that's a source for a lot of confusion since you have to use actual database column names when accessing the query builder, whereas Bookshelf aliased column names are used everywhere else. It's also not clear when you're using Bookshelf model methods and Knex methods in case if you're a new user.\nThe only problem with that is that Bookshelf would become very limited in what it can do if users are suddenly unable to access Knex methods. Maybe this just means that Bookshelf should implement the functionality that is missing instead of forcing users to use the query builder.. Not sure. Are you saying that any attributes that are not set to a value by the user will be set to null? But that value isn't from the database?. This feature is only going to avoid two trips to the database with PostgreSQL (and MSSQL?) anyway. The thing is that Bookshelf doesn't know you schema, so that isn't going to work. I think there's a plugin with schema support, so it may work with that plugin.. > ...can we support it and fallback to calling refresh?\nI think that's the idea here.. Of course :) Good luck. Just remember that all the tests must pass and the PR must include tests for this feature.. Of course :) Good luck. Just remember that all the tests must pass and the PR must include tests for this feature.. Everything looks good to me. Thanks!. With your proposal what would happen if I retrieve a model from the database, manually change the updated_at timestamp and then save the model without setting the forceTimestamps option? And what would happen if I do the same thing but without manually changing updated_at, so basically just retrieving the model, changing some other attribute and save it back?. > ... the timestamps will be regenerated, for context, the updated_at, and override what came from what the service is connected to.\nI don't understand what you mean by \"regenerated\". It's also not very clear what you mean by \"what the service is connected to\". What service?\nI'm also not too sure what is the current timestamp behavior but I'm almost certain the old behavior (prior to version 0.10.4) was correct and what most people expected. Not sure why it was changed.\nSo, with your change it will be required to set forceTimestamps in order for a user to manually change any of the created_at or updated_at columns right? However updated_at will still be updated automatically each time a model is saved?. Closing this due to lack of response. If you have anything more to add we can reopen this for further discussion.. Also, can you verify this only happens with Bookshelf? Because you're using the query builder, which means you're using Knex directly, which can indicate a bug in Knex and not Bookshelf.. @the-gardener if you can answer the questions in the comments before yours we can move this forward.. Sure, I get that, but the code sample above isn't enough for someone without your specific setup to work on this. If you can get a standalone code sample that fully reproduces the bad behavior it would help in debugging this problem.. Example gist: https://gist.github.com/ricardograca/9343668dbb8444f7e297. Closing this due to lack of response. If anyone has anything more to add we can reopen it.. Closed due to inactivity. If you have anything more to add we can reopen this issue.. Format.. Related PR: #1040. It just needs an example of a camel case to snake case conversion and possibly some conflict fixes.. It's here.\nYou're welcome to contribute PRs that help unclutter the code base. For further info check out #1600 and #1612. \n. I never used Docker. Will the SQLite and OracleDB tests run as well using Docker? Not sure how important the OracleDB tests are though.. @rapzo That's another discussion that also took place in #1661. I don't see a problem with not having OracleDB tests with the Docker solution, since all specific database engine tests should eventually be removed anyway.\nBTW, is it possible to configure Travis to use the new solution you propose here?. @rapzo Feel free to ignore my ignorant comments about Docker :wink: . > ... withRelated is left join ...\nWell, technically this is not always true. In this case it isn't, because no JOIN clauses are used to construct the relation, but two separate SELECT.\nI'm going to add this as a feature request for now, but this won't be a priority.\nIn the mean time if you want to return null instead you can override the serialize method of the User model and check for the value of order and act accordingly. A bit wasteful, but it should work. Either that or use a raw Knex query.. > ... withRelated is left join ...\nWell, technically this is not always true. In this case it isn't, because no JOIN clauses are used to construct the relation, but two separate SELECT.\nI'm going to add this as a feature request for now, but this won't be a priority.\nIn the mean time if you want to return null instead you can override the serialize method of the User model and check for the value of order and act accordingly. A bit wasteful, but it should work. Either that or use a raw Knex query.. According to the docs, the patch option when set to true:\n\nOnly save attributes supplied in arguments to save.\n\nSo it's working as intended. If you leave out the patch option it will probably do what you expect.. So, your use case for this is that you use set() to set some values but don't save the model, and then later on when saving you add some more attributes to be changed? I don't see the advantage of using patch: true in that case. Is it just a performance issue?. So, your use case for this is that you use set() to set some values but don't save the model, and then later on when saving you add some more attributes to be changed? I don't see the advantage of using patch: true in that case. Is it just a performance issue?. Closing this since the wanted effect can easily be achieved by a small change to the original code:\n```js\nconst model = await Model.forge({ id: 5 }).fetch();\nmodel.set('attr_a', 'some value');\nmodel.set('attr_b', 'some value');\nawait model.save();\n// or\nconst model = await Model.forge({ id: 5 }).fetch();\nawait model.save({attr_a: 'some value', attr_b: 'some value'}, {patch: true});\n```. Closing this since the wanted effect can easily be achieved by a small change to the original code:\n```js\nconst model = await Model.forge({ id: 5 }).fetch();\nmodel.set('attr_a', 'some value');\nmodel.set('attr_b', 'some value');\nawait model.save();\n// or\nconst model = await Model.forge({ id: 5 }).fetch();\nawait model.save({attr_a: 'some value', attr_b: 'some value'}, {patch: true});\n``. Right, so what do you propose @marianacapelo? Reword the documentation to make it clearer? Or maybe just remove the{patch: true}option since it's value is debatable?. @marianacapelo Can you provide a code example of your use case?. @marianacapelo You don't actually need thepatch: true` option in that case. If you leave it out you get the results that you need. The only use case for that option is performance.\nSo, on one hand I think it makes sense to change the patch functionality to use only changed attributes, and it's an easy change to make. On the other hand that would break backwards compatibility and it's possible someone has the opposite use case, that is, is expecting only the attributes passed to save() to be present in the query, but somehow I doubt it.\nI'll reopen this and add it to the version 1.0 project for consideration.. So, there's currently no one that has publish privileges on npm? I'm almost certain at least one version was published by @dj-hedgehog recently. . Fixed in version 0.11.0, although you should be installing 0.11.1 due to a missing file in the previous version.. This seems like an even better fix for #1460 than #1470. Thanks!. I'm not that sure about increasing our dependency on .format() and .parse(), but I'm not contributing much code to the project anyway, so maybe someone more active can comment on this issue.. @osher Sorry, I'll take a look later today. Currently busy with something else.. Marking this as wontfix for now since version 7.x of pg requires at least Node 4.5 and we're aiming to support all 4.x versions.. @ai Yes please. I'd appreciate someone checking out why the tests are failing and figuring it if it's because of the new version of Knex :confused: . Probably just a circular dependency issue, but can't tell for sure since you're not showing how you're trying to access the Course model. See here for further info: #598, #691, #792.. Just to clarify, it's not exactly a circular dependency issue. The problem was that the Instructor model wasn't available (loaded) when it was being required in the Course model.\nThe registry plugin doesn't require your models for you.. There's already a PR dealing with this issue. Can you check #1639 and see if it solves your issue?. Thanks, looks good to me.. There were talks of removing or changing format and parse since their behavior is considered too confusing. I'm not going to do any of those changes, and I'm not even sure that is still the plan, but it was talked about at some point, FYI.\nHowever I think the problem here is also made more complicated by the fact that .where() is just a convenience wrapper around .query() which is using Knex directly, which in turn has no knowledge of parse and format. The real problem is the need to access the query builder directly which marks a deficiency in terms of functionality of Bookshelf.\nThe bottom line is that it's probably not a good idea to start mixing in parse and format methods all throughout the code. Then again, it would solve a lot of confusion until the time comes that someone evaluates what to do with these methods.\nLet's see what others have to say about this.. Sorry, just realized this is a duplicate of #650. You can continue the discussion on that issue.\nOther related issues: #668, #1076, #1212.. You raise good points. These methods come from the origins of Bookshelf when it was meant to be compatible with Backbone, so they are leftovers from that time. At one point it was decided that the Backbone dependency was holding back the project so all the documentation was reworded to remove any references to it, but unfortunately there weren't that many changes to the code to accompany that change. The idea was to remove the concept of collections altogether, since they didn't seem to offer any meaningful advantage while creating a few issues, but that never happened.\nMaybe it's time to revise that plan once again, but in the mean time I think push is just a convenience method around add and set also uses add but adds a few more capabilities around it. I'm going to open a new issue to start the discussion of deprecating push since it seems to be totally unnecessary.\n\nvivified as instances of the model\n\nAgreed about that one as well.. On second thought it seems that it would probably not be a good idea deprecating push right now since it adds a model to the end of the collection. It's just a convenience method, but I can see why it's useful. A better plan would be to do the changes proposed in #799. Check that out if you're interested.\nSo, basically:\n\n\nset adds models to the collection in a smart way. It's used by add and push (through add) internally. It's the method that actually does any changes to the collection, unlike add or push which are just convenience methods.\n\n\nadd adds models to the collection only. No smart removal or updating of models, unlike set.\n\n\npush is the same as add but makes sure the specified model(s) are added to the end of the collection.. Why are you saying that Model.extend() is being deprecated?. I'm pretty sure .extend() isn't deprecated.\n\n\nPS: It's @ricardograca. Related PR: #1683.. Possibly related issues: #407, #711, #821 and #1018.. @Cl1608Ho Do you have anything useful to add or comment about this issue?. There's probably an endless loop or a cyclic dependency somewhere in your code.. Can you provide a complete code sample that reproduces the problem? Something that I can just download and run. Here's an example of what I mean: https://gist.github.com/ricardograca/9343668dbb8444f7e297. Closing this issue due to lack of response. If you have anything more to add we can reopen it.. The saving event is indeed only fired after the query has been built, from what I can tell. Not sure if it can be fired before that.\nOn second thought, your example probably should just create a new row in the database. If you remove the saving event handler, does it do that?. Doesn't seem to be supported by Knex, so until that is done it probably won't be supported by Booshelf in a database agnostic way. If you're using a single database then you can use raw queries for that in the mean time.\nRelevant Knex issue: #203.. Right, the problem here is that fetchOne() is a collection method, not a model method, and you're trying to use it on a model (the return value of model.where()). You can achieve what you want with:\njs\nsessions().collection().where('key', sess_key).fetchOne({withRelated: ['users']}).then(function(row) {\n  callback(false, row.related('users'));\n}).catch(function(err) {\n  callback(err);\n});. Closing this due to lack of activity. If you have anything more to add we can reopen this again.. @DJAndries Can you fill out the description according to the provided template? At least the Introduction and Motivation parts, because I had to go to your Readme file to understand what this plugin does. Apart from that everything looks good to me.. Currently not possible right now using only Bookshelf. Possibly one of the biggest omissions in my opinion. Related issues: #202, #597, #655, #833, #834 and #1129.\nYou can work around it with custom queries by accessing the knex query builder though. Check the related issues for possible solutions.. > However this can cause an issue when trying to save a model that did not change, hence causing the updated_at to be updated to the current time. Since the model did not change, I believe we should not change the updated_at field as well.\nI'm not entirely sure about this one. It may be desirable to \"touch\" a record for some reason, only to update its updated_at value. If the user is using canEditUpdatedAtKey and updatedAtKey it probably means they want to update it manually right?\nAs for the created_at issues, I agree that 1 must be fixed, but in 2 how is the new row being inserted at all if the primary key doesn't exist on the database and the model is \"not new\"?. Good points about updated_at and abusing a functionality to do something else. I agree with you.\nIf you can fix the failing tests to account for this behavior, without introducing any new bugs hopefully, and provide tests to cover all possibilities I think we can merge this. I've noticed quite a few issues related with timestamps lately, so something is definitely wrong.. So, I've finally started looking into this and there are some problems I'd like to get fixed in regards to timestamps.\nFirst, the DEFAULT_TIMESTAMP_KEYS constant is defined in both src/base/model.js and src/model.js. Obviously this isn't good and has to be fixed. There should only be one source for this value. I'm not saying you have to fix it, but just pointing it out.\nThen, the whole canEditUpdatedAtKey, canEditCreatedAtKey thing has got to go. It just seems like it's duplicating already existing functionality. It was already possible to specify a date to override the default value, by using the date: '2018-01-02'option to save. It just seems over-complicating things. In regards to your use case of an already existing ID on a new model, you will have to pass the method: 'insert' option to save anyway, so that should be the indicator that it's a new model and the createdAt attribute must be given a value in this case. If that wasn't happening, then it's a bug.\nFinally, the hasTimestamps option is used when you want to use automatic timestamps. If you don't want to use that feature and instead manually set them just temporarily disable it:\n```js\nvar Thing = bookshelf.Model.extend({\n  hasTimestamps: true\n});\nvar something = Thing.forge({created_at: '2017-12-12'}, {hasTimestamps: false}).save()\n// or\nvar something = new Thing()\nsomething.hasTimestamps = false\nsomething.set('created_at', '2017-12-12')\nsomething.save()\n```\nAlternatively, the timestamping feature could be made smarter by looking at attributes that have changed. If a model has a created_at or updated_at that has changed (see hasChanged()) then that column will not be automatically updated and the user supplied values will be used. I'm almost certain this is how Rails does it.\nI'm open to feedback.. > I'm not sure that passing {method: 'insert'} to create a model with predefined ID is very user intuitive. \nI thought it was the only way because without that option it will try to do an UPDATE query but fail because there is no existing row that matches the predefined id. How are you doing it then?. No, what I don't understand is how you are inserting new rows with predefined ids without passing method: 'insert' to save.\nAlso, are you saying that created_at should only be set in the .timestamp() method if it hasn't been explicitly set by the user?. How do you determine \"it was not previously set\"? It can already be set in the database for all we know, but not in the model and generating a new timestamp for created_at will lead to an incorrect date after saving. I don't think this should happen.\nIf a user does set a new created_at timestamp manually then I think that will show up in the .hasChanged() method and in that case use the provided value instead of trying to generate a new one.. I see what you mean now, but that can't be. We're talking about the automatic timestamp feature, so it should work for its intended purpose, and that means only set created_at if method === 'insert'. You can't expect the timestamp attributes to always be set on the model, even though they may be set on the database. In this case always generating new created_at values would be bad.\nThe thing is if you have hasTimestamps set to true then you want automatic timestamp handling. If you need to insert pre-existing data with pre-determined timestamps then you don't want the automatic timestamp feature, in which case just turn it off and insert all you want. If you are creating a new record with a pre-determined id then you are passing the method: 'insert' option to save, so you will get automatic timestamps if you have them turned on.\nAFAICT that's how Rails works. However, it additionally checks to see if the user hasn't set any of the timestamp attributes manually before automatic determining them. If there are manually set timestamp attributes, then just use the user supplied values. However, I'm not sure that Bookshelf currently can handle this because it may not always determine hasChanged correctly for all use cases. This is the part that needs to be investigated.\nI think that better than a document it would help to get the entire test suite that checks for the expected behavior.. In Rails if you have automatic timestamp handling it will only set created_at to the current time if it's an insert and the user hasn't explicitly set it to something. The tricky part in Bookshelf is the \"user hasn't set it explicitly\". I'm not sure this can be determined accurately right now. These are the cases where a user may set that value:\njs\nmodel.set('created_at', '2018-01-01')\nmodel = Model.forge({created_at: '2018-01-01'})\nmodel = new Model({created_at: '2018-01-01'})\nmodel.save({created_at: '2018-01-01'})\nI think we have to assume that in all the above cases the user wants to override the automatic value of created_at. There's the hasChanged() method but I'm not sure if it will return the correct value in all cases.. That's it :). Postponing this for the next release due to a request from the Ghost team to get a release out ASAP.. Since you're using the query builder (Knex) you should ask in that project's issue tracker instead.. I'm pretty sure the test didn't fail because of this change.. I'll just update Travis config file to test on Node 8.x instead.. Ok, so builds are failing on Node.js 8 because this line gets called with an undefined cmd argument (the error is specifically in child_process.spawn() that gets called by child_process.exec() at some point), which produces an error in that version of Node. Apparently everything worked fine on previous versions, possibly because child_process.spawn() would just ignore a missing file argument or something along those lines.. @vellotis Can you tell me what the purpose of the scripts/build.js file is? AFAICT it doesn't seem to be doing anything. That part about Building compiled files always gets passed undefined whenever it is called.. Ok, I think I figured it out. It seems the original purpose was to build Bookshelf on the user's machine after npm install or to prepare it for publishing, not sure. It was supposed to enable installing Bookshelf from github at one point. Whatever it was now all it does is install dev dependencies and nothing more since the npm run build command is run afterwards.\nAs it is Bookshelf cannot currently be installed via github since the src directory is included in .npmignore. I'm feeling more and more inclined to just go ahead with #1606. That would solve a lot of issues in one go.. Great, so now babel is complaining about Unknown plugin \"syntax-object-rest-spread\" specified in... on the Node 8 build on Travis. It works perfectly fine locally, so I'm going to go ahead and merge this as is and then proceed to blow babel to smithereens.. As part of #1714 I'll be removing babel-eslint and relying on standard eslint to do the linting.. This just needs tests. I can add tests myself if you don't have the time for that.. It's @ricardograca... the other Ricardo must be feeling very sorry he ever contributed to Bookshelf ;)\nBack on topic, I'm not sure what's going on. If you can write a small gist that I can just download and run that reproduces the issue it would certainly help. Here's an example to get you started.. I'll leave this open until you or someone else can find the actual problem here. In the mean time there's not much I can do without a reproducible test case.. I think you're looking in the right place. Maybe also take a look at the eagerPair method in src/relation.js which is responsible for pairing relations to models.. Tests are failing on Node 8 due to babel for some reason. Even replacing babel-preset-es2015 with babel-preset-env doesn't solve the problem. It just produces a different error. The update to use Ubuntu 16.04 on Travis seems to cause no issues, so I'll leave that in.. You are defining both relations in the exact same way, but they are not the exact same. Try removing the foreignKey and otherKey arguments to your belongsToMany() calls since they are wrong in the User model and you seem to be using the default names so Bookshelf should pick up the correct keys for you:\n```js\n// ...\nusers() {\n  return this.belongsToMany('User', 'users_groups');\n}\n// and\ngroups() {\n  return this.belongsToMany('Group', 'users_groups');\n}\n``. It's @ricardograca.... the other Ricardo must be getting tired of getting bombarded with mentions meant for me :rofl: . Yeah, Bookshelf doesn't touch the case of arguments.. Didn't know about that module. Could be a good option, but I need to understand how it would work. Are you saying that we would add that module topackage.json` and then have a git pre-commit hook to execute it?. Ok, could be a good idea. I'll take a look at those options.. > Devs usually use it in their IDE to format on save.\nThat won't work because almost no one would have that installed and even if it was added to the Contributing document, people would still send PRs without reading it and installing the necessary package on their IDE.\nIs there a way to make this work without having to install an additional dependency? If not, then I guess option 2 you mentioned above would also be a good compromise.. Fixed with #1883.. This is on hold until #1696 is merged in, since pg 7.x requires node 4.5 or newer.. Well, you could use invokeThen() but that is basically the same thing as what you're using now.\nAnother option is to use knex directly:\njs\nbookshelf.knex('vendors').truncate()\nI agree a better interface is definitely something that is needed.. No idea why Travis is failing on Node 4 right now on the pr build. Seems to be related with installing Oracle, although the error is about dpkg not being able to obtain a lock. Will have to be investigated if it persists.. The tests are inconsistent because testing for Oracle is a PITA and is constantly causing problems. Ripping it out right now.. The tests are failing because of Oracle again.. Oracle again.... That doesn't seem right. Can you provide a code example that reproduces the issue?. js\nvar shelf = bookshelf(knex) // :(\nvar shelf = bookshelf(db) // :D. Sure, that sounds like a good idea :+1: . What version of Bookshelf are you using?. Ok, thanks. Apparently #1639 didn't fix all use cases. Can you provide a code sample that reproduces the problem?. What's the purpose of:\njs\nlocations: function(qb) {},\nmerchantAccounts: function() {}\n? If you aren't adding anything to the queries why not just use the simpler option:\njs\n.fetch({ withRelated: ['locations', 'merchantAccounts']});\nAnyway I'll try to create a test case with the provided code.. So, I just noticed that all examples I've ever seen and used of withRelated() it uses an array. If you replace the object with the array as mentioned in my previous comment does it still produce incorrect results? Or if you are unable to change that right now, can you verify that relations are returned correctly if the primary key is not 0?. Yeah, this was fixed for foreign keys in #1639, but I thought there could be an issue if the parent primary key was also 0, which that PR didn't account for, but apparently it's not an issue. So, the problem here was using an object instead of an array for withRelated() :) I'm glad you got it working.\nClosing this as duplicate of #1685.. Many thanks!. Small problem. We already have a document explaining how to setup the dev environment, and I would prefer to not have duplicate instructions to avoid confusion, like what happened in your case.\nSo, I think it would be better to have that section of the FAQ point to .github/CONTRIBUTING.md instead.. Is this so that you can get which columns are available on the actual database?. Right. I think that's against how Bookshelf is expected to work. Models aren't supposed to know how the actual database is setup, and this information must be provided by the user. This is by design and going forward I only see this separation between database and models getting stronger, so I think you're better off trying to implement what you need in a plugin.\nHowever, if you can come up with a way to do it that doesn't break any current functionality or expectations then I'll accept a PR, because this may be useful in other situations. Maybe take a look at #900 for inspiration.\nWith that said, if all you want are validations then check out #39 and tgriesser/checkit.\n. The test suite failed due to a timeout in the \"should support large arrays\" Collection base test on Node 4. Running that particular job again everything passed. Maybe the timeout for that test should be increased.. And what does attributes look like? And how are you using your plugin?. And the missing column name is really XXX? Can you post the actual query that is getting generated?. Oh I see what the problem is now. You already have some attributes set on your model (this.attributes), and then you pass some more attributes to save(). The attributes that you pass to save() don't make the previously set model attributes disappear. They are also used when saving.\nPS: You can see the queries by passing the debug: true option to knex:\njs\nvar knex = require('knex')({\n  client: 'sqlite3',\n  connection: {filename: ':memory:'},\n  debug: true\n}). Well, you could clear all attributes before save:\njs\nreturn bookshelf.Model.prototype.save.call(this.clear(), attributes, options). Closing this due to lack of response. If you have anything more to add we can reopen this for further discussion.. Could be related to #1554, and not specifically about using .query() with fetchAll().. Fixed in #1846.. Fixed in #1846.. > Maybe there is a good reason to not run it in parallel, but then we should document it.\nI assume you meant \"to run it in parallel\" here.\nI don't think there's any good reason for the events to be run in parallel. I've looked at the entire history of this part of the code, including the triggerThen repo and the current code is just a simplification of a previous for loop followed by Promise.all. It was like that from the beginning but I can't find any evidence that it was done with the purpose of achieving parallel execution of event listeners (in case there are more than one), so your proposed changes are probably ok.. I'd say probably not, but it won't be much later after that. There are still 3 issues left in the project for the next version, although I'm already looking into the table alias one.\nYou can go ahead and merge all of your approved PRs though.. Ok, if I'm unable to finished reviewing, merging and/or refactoring the last remaining PRs by Saturday I'll just move them to the next version and start preparing version 0.13.0 from what's already done which is already substantial.. Probably fixed in #1716.. Sure, merging just the test sounds good to me.. > So i think the fix which was merged happens too late?\nCould be. I never delved too deep into the relations code. Are you going to investigate? It's quite possible that your fix is better than the already merged one, in which case it should be replaced. The current test suite has a test in place for #629.. The backtrace only shows files related to Express. Why do you think this is a Bookshelf issue?. Can you provide a reproducible test case? Or at the very least post the code you're using that is producing this warning?. No problem :smile: . The should support large arrays test was taking too long in one of the build jobs. The timeout for that particular test should be increased to prevent these kinds of false positives.. I think something is missing from that zip file. When running yarn:\n\nERROR: There are no scenarios; must have at least one.. I'm getting 180.00ms, 298.53ms and 433.04ms, for MySQL, Knex, Bookshelf respectively. I remember some time ago there was a discussion about performance as well and the culprit seemed to be the creation of each Model in a fetchAll() call. Not sure if it ever was addressed, but probably not.. The extra long execution time of Bookshelf is expected in this case since it doesn't use JOIN. This should definitely be improved, but it's currently not a priority for me.. > But all of the targets (MySQL, Knex, Bookshelf) from this test are using the exact same queries.\n\nI thought Bookshelf didn't use joins when eager loading relations, but maybe it does for belongsToMany relations? With other relation types it does multiple SELECT queries though.\n\nWhy is it expected that Bookshelf is ~600ms slower? Can you please explain further?\n\nBeats me. I thought that it was doing multiple SELECT queries with all relation types, but if that's not the case who knows what makes it slow? I don't think anyone ever profiled it extensively, apart from that one user that also complained about bad performance with fetchAll().. I'm sure that PR will help a little, but probably not enough to close the gap to standalone Knex. We should re-test this after the next release is out.. I should really do something about the timeout of \"supports large arrays\".... Thanks for the warning, but this was already fixed with #1748. The documentation will be updated to include this fix on the next public release which shouldn't take too long now.. Yes, from the documentation about Model.extend:\n\nsubclasses created with extend can be further extended and subclassed as far as you like.\n\nSo, you can do something like:\njs\nconst CommonModel = bookshelf.Model.extend({\n  something: () => {\n    // ...\n  }\n})\nconst T1 = CommonModel.extend({\n  tableName: 'T1'\n})\nconst T2 = CommonModel.extend({\n  tableName: 'T2'\n}). I don't think so. You would have to write a custom raw query and run it by accessing the knex instance that bookshelf is using:\njs\nbookshelf.knex.raw('INSERT IGNORE ...')\nYou would have to parse the results from this query yourself since it is outside of Bookshelf models.. Closing this due to lack of response.. Closing this due to lack of response.. This will be fixed in a patch to the 0.13 version instead.. Fixed with #1796.. Version 5.0.0 was apparently a mistake and was removed from npm: https://github.com/sinonjs/sinon/issues/1747.. Related with #1791. I'll get this fixed ASAP.. Ok, just some clarification. Do you have hasTimestamps: true in your Model?. And you're getting this because you're using the columns option in a fetch?\nPS: It's ricardograca, not ricardogama.. Ok, cool. And again, it's ricardograca not ricardogama ;). Fixed with #1797.. Can you verify that without the hasTimestamps option the results are as expected?. I can't reproduce this with a model that has hasTimestamps set to true. Can you provide a standalone test case the reproduces this issue? Something like this is ideal.. Wait, never mind. This is also a duplicate of #1791 as strange as it may seem. Since I had already fixed it in my local dev environment the results were coming back correct. The fix will be up shortly.. @kirrg001 Care to take a look? There are a couple of changes here.. The only problem is that this PR introduces a potentially breaking change, so it can't be a patch release. However, it should be possible to branch off from the 0.13.2 release commit and create a new 0.13.3 build from that without the breaking change.\nBasically the only difference is that this line should be changed to:\njs\nif (isNewModel && !setUpdatedAt || !setUpdatedAt) {\n  // ...\n}\nI can do the release if you take care of the rest. The associated test should also be removed BTW.. Ok then, but I'll direct any angry developers to you :stuck_out_tongue_winking_eye: . Then you won't know that the new release is out :smile: . Care to elaborate on what \"breaks everything\" means? We have a test in place for that setting and it is passing so.... Care to elaborate on what \"breaks everything\" means? We have a test in place for that setting and it is passing so.... Ok, thanks for the explanation. Will take a look at it.. Ok, thanks for the explanation. Will take a look at it.. @mborst It was deprecated for the reasons you stated. That feature leaves some ambiguity as to which columns will be updated, so what's the purpose of \"stupidly\" setting an unknown timestamp column? How are you using this in practice?. @mborst It was deprecated for the reasons you stated. That feature leaves some ambiguity as to which columns will be updated, so what's the purpose of \"stupidly\" setting an unknown timestamp column? How are you using this in practice?. Ok, it's still not exactly clear to me why you would want to constantly override the date that gets set as now for the automatic timestamp feature, because it's not that automatic anymore in that case, but given that this feature seems to be useful to at least one person I'll remove the deprecation warning on the next release.. The only benefit of doing .get('attribute') is it being shorter than model.attributes.attribute by 3 characters :wink: This is a leftover from when Bookshelf was based on Backbone.\nAs for your feature request it sounds good to me.. That's weird. Looking at the failed test it seems like the two expected objects in the response array have their order swapped, even though they are correct individually. I've never seen this particular error before. Can you check if there could be some kind of race condition here? It's important that any async tests always return promises or call done() when done.\nAlso, what Node version are you using?. Looking at the test more closely it's a bit weak since there shouldn't be any requirement (or guarantee) that the columns are retrieved in any particular order. I'll ignore that failed test, but I still need to review this more carefully to make sure no new bugs or breaking changes are introduced and I don't have time for that right now.. @jwhitmarsh Can you share your actual code solution to the issue you describe?. I don't understand what the problem is, and your code sample is insufficient to figure it out, but it sounds like this is probably a Knex issue, since it's what provides the transaction interface.. I don't understand what the problem is, and your code sample is insufficient to figure it out, but it sounds like this is probably a Knex issue, since it's what provides the transaction interface.. Closing this due to lack of response. If you have anything more to add we can reopen this issue.. Closing this due to lack of response. If you have anything more to add we can reopen this issue.. Use .orderByRaw() from Knex.\nAnd please format your code sample properly, otherwise it's much harder to read.. Use .orderByRaw() from Knex.\nAnd please format your code sample properly, otherwise it's much harder to read.. Closing this since the exact same question was already asked on Stack Overflow.. Closing this since the exact same question was already asked on Stack Overflow.. That's because when you specify columns: ['something'] you're limiting the columns that are fetched, and in that case you're not including the foreign key (supervisor_id) required to be able to recreate the association between records.\nIf you don't want that key on the output it's best to use the visibility plugin to hide it from serialization.\nI know this behavior is not very obvious, since you're not the first to stumble upon this, but the thing is that the query builder (knex.js) works on a lower level than Bookshelf, so if you use it to modify any queries you have to be careful not to omit important columns.\nThis could be better documented though, because there is no warning that bad things may happen when you use the columns option, although in that case you're using the query builder version of it, so it's outside the scope of Bookshelf.. That's because when you specify columns: ['something'] you're limiting the columns that are fetched, and in that case you're not including the foreign key (supervisor_id) required to be able to recreate the association between records.\nIf you don't want that key on the output it's best to use the visibility plugin to hide it from serialization.\nI know this behavior is not very obvious, since you're not the first to stumble upon this, but the thing is that the query builder (knex.js) works on a lower level than Bookshelf, so if you use it to modify any queries you have to be careful not to omit important columns.\nThis could be better documented though, because there is no warning that bad things may happen when you use the columns option, although in that case you're using the query builder version of it, so it's outside the scope of Bookshelf.. Bookshelf currently doesn't support it. That seems a bit outside the scope of a ORM anyway. What are you trying to achieve?. Bookshelf currently doesn't support it. That seems a bit outside the scope of a ORM anyway. What are you trying to achieve?. It's the first time I've heard of partition tables so this won't be a top priority. If you want to submit a PR that implements the necessary support I can review it then, but I'm not even sure if Knex supports this.. It's the first time I've heard of partition tables so this won't be a top priority. If you want to submit a PR that implements the necessary support I can review it then, but I'm not even sure if Knex supports this.. Looks like you're probably using format to the model's attributes to snake case before saving. The attribute in question is being converted to med_pla_17 which obviously is not the same as MED_PLA17, so the problem is in your format method.. Looks like you're probably using format to the model's attributes to snake case before saving. The attribute in question is being converted to med_pla_17 which obviously is not the same as MED_PLA17, so the problem is in your format method.. That can't be the whole thing. You're missing the format method. Maybe it's in the bookshelfGestao.Model base model?\nI don't know what kind of format method you're using but just make sure that field is transformed correctly in that method.. That can't be the whole thing. You're missing the format method. Maybe it's in the bookshelfGestao.Model base model?\nI don't know what kind of format method you're using but just make sure that field is transformed correctly in that method.. Closing this due to lack of response.. This isn't related to mocha. The failures are due to a recently merged PR, but the tests will be fixed soon.. This isn't related to mocha. The failures are due to a recently merged PR, but the tests will be fixed soon.. Never heard of it, but the database support in Bookshelf comes from Knex, so you may want to go to their issue tracker and ask there instead.. Never heard of it, but the database support in Bookshelf comes from Knex, so you may want to go to their issue tracker and ask there instead.. Maybe this Stack Overflow question would help.. Maybe this Stack Overflow question would help.. Closing this due to lack of response.. This isn't related to chalk. The failures are due to a recently merged PR, but the tests will be fixed soon.. This isn't related to chalk. The failures are due to a recently merged PR, but the tests will be fixed soon.. Duplicate of #1525.. Duplicate of #1525.. @leebickmtu Are you willing to add tests to this PR so that it can be merged?. The fetching:collection event is triggered before anything is actually fetched from the database. It's generally used to change something about the query before it runs. You're probably looking for the fetched:collection event.\nI can understand your confusion since the docs for fetching:collection incorrectly state that the first argument to the event handler is \"the collection that has been fetched\", but it isn't. It's an empty collection because no models have been fetched yet.. The tests failing is not related with the new mocha version. That problem was already fixed.. Have you tried the code that is in this change or are you referring only to the published version 0.13.3?. This PR you're commenting on fixes that then.. Yeah, I agree it sucks. I also struggled with it a while back. It's supposed to be the initialize settings of knex, so here:\n```js\nvar knex = require('knex')({\n  client: 'mysql',\n  connection: {\n    // ...\n  },\n  debug: true\n});\nvar bookshelf = require('bookshelf')(knex);\n```\nYou can also pass that exact same option to every operation that accesses the database (fetch, save, etc.) and only that particular operation will be logged.\n. I'm actually thinking of revamping the debug feature to be a little more custom. What kind of features are you missing with the current debug mode?. I'm not so sure about not mutating models, because you may want to change the model in some way in the event handlers before it's passed to the end action. Otherwise the usefulness of events is decreased in my opinion.\nAlso, the idea for future development is to ensure that when you have a model it's always the same instance that gets used in the same session so that you can reference it even if it gets loaded by some collection elsewhere. Having stale models that don't reflect the state of the actual data is not a good idea.\nHowever, I agree that once a relation is loaded on a model, as in your example, it should stay loaded even if calling load() again without including that particular relation. This won't be easy to achieve though.. @LuisBonsembiante Can you provide feedback on the review?. @fl0w Since @LuisBonsembiante isn't responding, do you want to take a stab at it?. @LuisBonsembiante Yes, this PR needs tests. See the comments above.. All of your questions should be answered in the Contributing document.. Is this with PostgreSQL?. Can you confirm that if you fetch() the model that was just saved immediately after the save(), instead of using the model returned from the save() call, you get numbers as expected?. If the results differ between save() and fetch() then this is a bug. However, you can workaround it until it's fixed by using the Processor plugin.. ~~Blocked by https://github.com/domenic/sinon-chai/issues/120.~~. ~~Blocked by https://github.com/domenic/sinon-chai/issues/120.~~. Many thanks.. I'm not sure what to say here, since this is so open-ended and you can't usually generalize a set of rules for all Node.js based ORMs.\nThe only things that I think are good practices are things that are good practices for all ORMs irregardless of platform, like making sure that operations that are supposed to be atomic are run inside a transaction. That's not even specific to ORM usage.\nMaybe you should take a look at the FAQ first.. Closing this due to lack of response.. What version of Bookshelf are you using?. No, Portugal and it's ricardogra\u00e7a ;)\nCan you try with the latest version (0.13.3) and see if the problem persists? I think what you're reporting was already fixed. Also, there's a built-in case-converter plugin now:\njs\nbookshelf.plugin('case-converter'). @rhys-vdw, @johanneslumpe, @anyong, @vellotis, @bendrucker You are the top 5 contributors besides me and Tim. Are any of you interested in, or have any objections against, appearing in the contributors section of package.json?. No idea what this is about. What version of Bookshelf are you using? Where in your code is the error happening?\nThat said, this is probably unrelated to Bookshelf. I found this if it's of any help.\nIf the problem persists can you provide a reproducible example in the form of a gist or similar?. The problem is that webpack doesn't like dynamic requires, and that is required for the .plugin() functionality of Bookshelf. This is the line that triggers the error.\nI've read through the discussion related to this issue over on webpack's repository and to me it seems that using webpack for Node.js projects isn't as helpful as it is for websites and does cause problems in these cases because it's perfectly fine to have dynamic require() calls in a Node.js project, but webpack needs to be able to load all requires at compile time (or something like that) for websites.\nI'm not inclined to implement a fix that would make the .plugin() code more convoluted than it needs to be just to fix a very corner case of using webpack, especially when there seems to be some suggestions already \"that there should be some way of indicating to webpack that a specific require() expression should be ignored\" and there could be \"some way of saying 'allow dynamic require expressions in these files' in the webpack config\".. Are you getting the error on updatedObjekt.managedBy().detach();?. Check out #928.. Check out #928.. Do you have acquisition_date as one of the values of the Asset.hasTimestamps array?. Do you have acquisition_date as one of the values of the Asset.hasTimestamps array?. Ok, so this is working as intended, although it's not optimal behavior. Since you were updating acquisition_date with a different value that would mark that attribute as changed as you found out. Your fix is the correct one, since the value has to be exactly the same for an attribute to not be marked as changed, but there is a simpler way of achieving what you want by using the Processor Plugin:\njs\nvar Asset = bookshelf.Model.extend({\n  tableName: 'assets',\n  processors: {\n    acquisition_date: function(value) {\n      return new Date(value);\n    }\n  }\n}). Ok, so this is working as intended, although it's not optimal behavior. Since you were updating acquisition_date with a different value that would mark that attribute as changed as you found out. Your fix is the correct one, since the value has to be exactly the same for an attribute to not be marked as changed, but there is a simpler way of achieving what you want by using the Processor Plugin:\njs\nvar Asset = bookshelf.Model.extend({\n  tableName: 'assets',\n  processors: {\n    acquisition_date: function(value) {\n      return new Date(value);\n    }\n  }\n}). Probably related to the server's timezone that is different from the client's.. Probably related to the server's timezone that is different from the client's.. @ErisDS @kirrg001 Care to check this out? This makes your custom _updatedAttributes implementation redundant, but it also changes the behavior of previousAttributes() so you may want to test these changes beforehand.. @ErisDS @kirrg001 Care to check this out? This makes your custom _updatedAttributes implementation redundant, but it also changes the behavior of previousAttributes() so you may want to test these changes beforehand.. Good question. Probably not. Definitive answer in a few minutes.. @kirrg001 Doesn't seem to be needed. On top of that options.previousAttributes is not documented anywhere, so I doubt many people are using it. For anyone using it it's just a matter of changing options.previousAttributes to model.previousAttributes() in the event listeners.\nI'll wait for further reviews before changing this, so I can do it all in one go.. That doesn't seem right. I also just found one other somewhat related test that would pass in such a situation when it should fail.\nThere's also no test for that particular scenario you described. I'll have to fix that.. @kirrg001 All reported issues fixed, and I added some tests to check for them.. That hasn't changed AFAIK. Looking at the relevant code, the options are being provided to triggerThen as the third argument, so it must be something before that. I'll investigate, but it's probably not related to these changes.. I used git bisect and the issue was introduced in 2ebd1afc4009aefc9ca9423423f6943c0fc783ff which was the commit that converted the source code to vanilla JavaScript compatible with Node4, so it has nothing to do with these changes. I'll investigate and fix that in another PR.\nMy guess is that it's something in the .once() method.. Found the problem... it's something really simple.. Check out #1857.. Hmm, it's been a while since I've worked on this but I'm almost certain that I did it like that because it's how it was already behaving and I didn't want to break backwards compatibility, otherwise I agree that having the previousAttributes be {} for a new model instance would make more sense.\nI'll take a look at it and see if that was indeed the case or if there was any other reason.\nThere's also no test for hasChanged() without fetch which sucks... :(\nThank you for your comments.. Hey @kirrg001 sorry for the long delay. I've looked at the changes and you are correct about previousAttributes() returning attributes. It should return {} when forging a new model indeed.\nHowever, after a fetch, save or even eager loading it will return the current attributes. This is the correct behavior according to the docs and it's how it was already done before.\nI've added more tests to check for the correct behavior and fixed the tests related with previousAttributes() on new forged models.. Hey @kirrg001 sorry for the long delay. I've looked at the changes and you are correct about previousAttributes() returning attributes. It should return {} when forging a new model indeed.\nHowever, after a fetch, save or even eager loading it will return the current attributes. This is the correct behavior according to the docs and it's how it was already done before.\nI've added more tests to check for the correct behavior and fixed the tests related with previousAttributes() on new forged models.. @kirrg001 Care to take a look?. @kirrg001 Done.. It was different before but only because previously previousAttributes would be populated to match the current attributes with each database operation, therefore what you were getting after .save() were the  current attributes (after save), but if you had actually changed any attributes you wouldn't be able to see the actual previous attributes. That's why the use case you describe appeared to work.\nHowever I think you're correct and it does seem like if the status attribute appears in attributes then the previousAttributes should also contain the previous value, even though it's the same. changed will continue to be an empty object and that's how you would determine if a certain attribute changed anyway.. @kirrg001 Are you sure you're testing with the latest changes and the correct branch? This test ensures that calling previousAttributes() will return the current attributes if no changes were done to the model after fetch.\nI haven't checked the case with the updated event yet though.. I just checked the use case you mentioned and it's working as expected. How are you getting that behavior of empty previousAttributes() after save() if the attributes haven't changed?. I've added a few more tests to ensure the behavior you mention is observed: https://github.com/bookshelf/bookshelf/pull/1848/commits/3cdfa6e797400b23145c74829b58cf75fb77b56d. As you can see the test case is passing, and it seems to do exactly what you're saying. Maybe you have some plugin interfering with this, or some other event listener, or something else.\nI'm writing a simple stand-alone test case that you can use to try to reproduce the behavior, but at this point I think Bookshelf itself is working fine. Oh yeah, I remember you had a custom property in Ghost models for storing the proper previous attributes, before this change. Could it be related to that?. Here is the gist: https://gist.github.com/ricardograca/da68dc091fcbe15c395558c166fd7200. Nice work! I'll fix it this weekend hopefully. Apart from that are there any other issues?. @kirrg001 Fixed. Nice catch there :1st_place_medal: . This isn't supported at the moment as far as I know. It seems to be supported by Knex though: https://github.com/tgriesser/knex/issues/569, https://github.com/tgriesser/knex/issues/2276 and it's already possible to add new results to the array: https://github.com/bookshelf/bookshelf/issues/1586.\nYou also seem to be attempting to do something similar to #363 or am I misinterpreting your intention?. Use the whereIn() method of Knex.. If eans is already an array that would explain the incorrect results since you're wrapping an array inside an array, which seems to be the case.. By the results you're getting it's clearly an array already, so you have to remove the [] around eans in your query() call.\nEither that, or it's a string without the [] but with a , separating the items, which would be even weirder.. The problem is most likely with your input data, and I can't help you anymore. If you think this is a bug with Bookshelf please provide a standalone test case that reproduces the issue.. These lodash methods are in the process of being deprecated (as methods attached to collections and model) so this won't be fixed. You can just use the lodash method directly:\n```js\nvar rejected = _.reject(collection.models, {active: false})\n// instead of\nvar rejected = collection.reject({active: false})\n```\nSee #736 for further info, although that is about models. There is also the intention of removing the concept of collections as they are now, and for that check out the discussion on #803.. If you want any help you'll have to provide the code you are using, the results you're getting and what results you were expecting.. First of all, you need to eager load the relation when you fetch Client, and then you can't just assign the return value of a fetch to a variable since it returns a Promise:\njs\nClient\n  .where({client_id: 1})\n  .fetch({withRelated: ['sentConnectionRequest']})\n  .then(function(client) {\n    const sentConnectionRequest = client.related('sentConnectionRequest').where({to_client_id: 2});\n  });. Then use .query():\n``js\nClient\n  .where({client_id: 1})\n  .fetch()\n  .then(function(client) {\n    return client.related('sentConnectionRequest').query('where', 'to_client_id', 2).fetch();\n  }).then(function(connectionRequests) {\n    // ...\n  });. Probably. I'm not so sure about all thoseawait, but I don't useawait, so can't help much in that front. Also, the last.fetch()` seems unnecessary.\nFinally, you should properly format your code blocks to activate syntax highlighting so they become more readable.. To answer your question: yes. Just look at the ongoing Projects or search for Pull-Requests with the docs label.. Fixed in #1863.. The bookshelf-scopes package is not maintained by the Bookshelf team. Please open a new issue over on the proper repository: https://github.com/jtwebman/bookshelf-scopes. If you still think this is an issue with Bookshelf alone you'll have to provide a reproducible test case and explain why you think the issue belongs here.. .where() uses the knex.js query builder, so you'll have to open a new issue on that repository instead if you think this is something else than user error. In any case a reproducible test case would help. As it is there is not enough information on the issue report.. I follow the Bookshelf tag, so it's best not to spam me with duplicate questions. Just chose one or the other.. Closing this because the exact same question was also asked on Stack Overflow. In the future don't duplicate questions on different websites. Just chose one or the other.. This version is not compatible with Node.js 4, so this PR is postponed until we also drop support for that particular version of Node.js.. Superseded by #1868. . For some reason sqlite3 is not being installed on the Node.js 4 job.. The build succeeds now, after restarting the job.. Looks like it was just a temporary issue with sqlite on Node.js 4. Restarting the job seems to have fixed it.. >  I'm also using \"bookshelf-uuid\" to auto-generate ids for my models, is it possible the null problem is due to that?\nVery likely, considering that .attach() works perfectly fine otherwise.\nCan you also provide the data that you're passing to .attach() and the exact errors you're getting? Without that there's not much to work on.. That would help, thanks! Could be a problem with the different camelCase to snake_case names. You have to use the column names as they are in the database in your .belongsToMany().. This version of Knex requires Node.js >= 6, so we'll only update after we also drop support for Node.js 4, possibly in Bookshelf version 1.0.. Could be an option. It has been taking a bit longer than expected to release 0.14, but I'd really like for that version to maintain Node.js 4 support since it's what's available by default on Ubuntu 16.04 which is still maintained. Let's see how the release cycle goes and take it from there.. Could be an option. It has been taking a bit longer than expected to release 0.14, but I'd really like for that version to maintain Node.js 4 support since it's what's available by default on Ubuntu 16.04 which is still maintained. Let's see how the release cycle goes and take it from there.. As stated before, support for Node 4 will be dropped in Bookshelf 1.0, which is the release after the next one.. Well, it will go faster if other people help out with the open issues for that version :wink: . Closing due to lack of response.. Closing due to lack of response.. No idea what you're talking about.. No idea what you're talking about.. Thanks for the detailed description but I don't use TypeScript so someone else will have to provide a PR for this.. Thanks for the detailed description but I don't use TypeScript so someone else will have to provide a PR for this.. After some more investigation this seems like something that should be requested on DefinitelyTyped's repository instead.. After some more investigation this seems like something that should be requested on DefinitelyTyped's repository instead.. I'm going to merge this as is and then change the description of the test in another PR.. Renamed in fc667332707ea978ff5e8db879fdb81479c15d54.. Hey @jorgebucaran thanks for the contribution. It looks good to me. I was actually thinking of removing chalk altogether since it's only used to output a single color in a single place, so not sure how useful it is, but I'll accept this for now, especially because it has no dependencies.. Hey @jorgebucaran thanks for the contribution. It looks good to me. I was actually thinking of removing chalk altogether since it's only used to output a single color in a single place, so not sure how useful it is, but I'll accept this for now, especially because it has no dependencies.. Yes, Knex 0.15+ support is planned for the 1.0 release of Bookshelf. That will happen after the next version (0.14) is released. See here for more info.. Yes, Knex 0.15+ support is planned for the 1.0 release of Bookshelf. That will happen after the next version (0.14) is released. See here for more info.. Closing due to lack of response.. Closing due to lack of response.. Can you try with:\njs\nqb.columns(['name']). Closing due to lack of response.. Did you take a look at the knex repository for any possibly related issues?. Did you take a look at the knex repository for any possibly related issues?. Closing due to lack of response.. Closing due to lack of response.. Nice work. I'll check it out ASAP and report back.. Nice work. I'll check it out ASAP and report back.. @chentsulin Can you address the last remaining comment above? I can do that after merging this, but I'd like to avoid several multi-thousand lines PRs if possible.. Many thanks!. Your Transport model is incorrect. According to your database structure it should be:\njs\nconst Transport = bookshelf.Model.extend({\n  tableName: 'transports',\n  partner: function() {\n    return this.hasMany(Partner, 'transportId') // or `hasOne` if you prefer\n  }\n});\nThe docs explain where the foreign keys are located for the various relation types: http://bookshelfjs.org/#Model-instance-belongsTo.. Your Transport model is incorrect. According to your database structure it should be:\njs\nconst Transport = bookshelf.Model.extend({\n  tableName: 'transports',\n  partner: function() {\n    return this.hasMany(Partner, 'transportId') // or `hasOne` if you prefer\n  }\n});\nThe docs explain where the foreign keys are located for the various relation types: http://bookshelfjs.org/#Model-instance-belongsTo.. Closing this due to lack of response.. You're committing each individual save, so of course only the last one will be rolled back.. No idea. It's one of the tradeoffs of using an ORM. If you use the database adapter directly it's even faster than knex. If you use a native C library faster still.\nPossibly related: #1774, #1061, and others if you search.. There is still a chance that this migration will fail with clients other than SQLite or when using a connection pool with more than 1 connection, but it's still an improvement, so many thanks.. There's no need to specify your own serialize method in this case. Any relations that are present will already be part of the output: http://bookshelfjs.org/#Model-instance-serialize\nThen, your model relations don't match what say they do. You mention that \"An Account can have an owner\" but then use belongsTo. This is weird. In fact, normally if you'd like to have something belong to and have many of something else you would use belongsToMany instead. If you want a simple parent->child like relation just use belongsTo on one model and hasMany|One on the other model.. Closing this due to lack of response.. You can push more commits to the eerenyuan:patch-1 branch to update this PR.. Many thanks!. As you can see from the failing test case the reason for that code being that way is to enable user defined timestamps, so this PR is not going to be accepted unless you have something else to add.. About your question number 2, that is how every other ORM I checked seems to work, so that's why it is that way. It seems to be an expectation at this point that both timestamp columns will be set when creating a new model.. @eerenyuan What do you mean by an old version? The most recent version on npm is 0.13.3. A new version is almost ready and will be released soon.. Closing this due to lack of response. If you update the PR with the requested changes this can be reopened.. > ... but in your docs the order isn't specified.\nIt kind of is: http://bookshelfjs.org/#Model-instance-save\n\nFires\n   \"saving\"\n   \"creating\"\n   \"updating\"\n   \"created\"\n   \"updated\"\n   \"saved\"\n\nThe idea here is that saving and saved wrap the other more specific events.\nAlso check out related: #1142.\n. There has been some talk about this before, and it would be a nice side-effect if Bookshelf was converted to conform to the Data Mapper pattern, which is something that is actually a long term goal for this project. I'll leave this open as a reminder of that.. Duplicate of #1872.. Are you calling .plugin() on your bookshelf instance? http://bookshelfjs.org/#Bookshelf-instance-plugin . Do you have any other active plugins that modify parse? Are you overriding parse in your models?. Can you provide a reproducible test case for this issue? Here's an example to get you started.. Sorry, I haven't had time to look into this, but I suspect it's related with the automatic timestamps feature as you already figured out.. Thanks for the heads-up. Will update soon.. Checkout #1872 and #1879, but yes, that's the gist of it. The last version with Node 4 support (0.14.0) was supposed to be released a few months ago, when Node 4 was still being maintained but that hasn't happened yet.\nI'd like to get that release out soon, but there are still a few open issues. The one that required more work is almost done (new documentation) so I think this could be achieved really soon and then we'll get to work on version 1.0.\nI'll keep this issue open as a reminder.. If you intend to use Bookshelf on Node.js 6 or newer, probably yes.. @kibertoad You got the username wrong :wink:\nI think Bookshelf is now compatible with Knex 0.15+ with the recent 0.14.2 release. It's not reflected in the package's peerDependencies yet, because I would like to test it some more to be sure.. I'm a little hesitant to merge this because it requires Node.js 8.6. We should probably make a distinction between supported Node.js versions for running Bookshelf and for developing it.. Many thanks!. Thanks for the report. This is actually a bug in the case-converter plugin since it doesn't call the parent model's parse method.. Yep, looks like you're calling the same parse method that you're in. You need to save a reference to the original before overriding it:\n```js\nconst datetimePlugin = bookshelf => {\n  const parentParse = bookshelf.Model.prototype.parse;\nbookshelf.Model = bookshelf.Model.extend({\n    parse: attrs => {\n      const data = _.mapValues(attrs, (val, key) => {\n        if (key === 'updated_at' || key === 'created_at') {\n          return moment(val).valueOf();\n        }\n        return val;\n      });\n      return parentParse.call(this, data);\n    },\n  });\n};\n``. Sort of. Some of the built-in plugins still need work to make all of them work nice with other plugins. I'll keep this open as a reminder for that.. This looks good, but I'm a bit hesitant to merge it because this newer version of husky drops support for Node.js 4, and the 0.14.0 version of Bookshelf is still aiming to maintain support for that version. However this is only adevDependencyso it may not be such a big deal in terms of compatibility.. Yeah, I agree, let's go with bleeding edge fordevDependencies.. This is being worked on in another PR.. Closing this since it's a duplicate of a Stack Overflow post: https://stackoverflow.com/questions/53151351/bookshelf-js-how-do-i-fetch-many-to-many. Closing this since it already has an answer and there were no further comments.. There's nowhithDeletedoption infetchPage()` within the bookshelf-pagination Bookshelf plugin, so this is most likely an issue with the bookshelf-paranoia plugin. Closing this until evidence is provided otherwise. You should open an issue over on that plugins's issue tracker.\nIf you are certain that it is an issue with Bookshelf then please provide a reproducible test case that doesn't depend on bookshelf-paranoia.. Got it. Thanks for the clarification.. Nice work! I'll review this properly soon.. I will most likely make it to the next version (0.14.0) which will be released soon.. > I think my problem is that I am using strapi-hook-knex and strapi-hook-bookshelf and I cannot find a way to retrieve the knex function from the contenxt\nYou'll have to ask on the strapi project for that. It's the first time I ever heard of that package.\n\nMan a bit of more documentation further than the simple case scenarios for the open source projects wouldn't harm eh ? :(\n\nCare to contribute the required documentation that's missing so that the next person doesn't feel like that?. Closing this since it seems to have been answered already.. Is this still an issue with the latest version?. What database is this? Can you provide a reproducible test case for this problem?. Great! Thanks, I'll check it out ASAP.. I don't even understand how/why Buffers can be used as keys, so the fact that it more or less works at all is new to me.\nYou can do whatever you need to make your use case work as long as that doesn't break any of the existing functionality and tests are included. If the extra fixes you mention are not immediately being required to you it's OK if you don't fix them.. Fixed in #1820. Will be released when 0.14.0 comes out.. This is most likely an issue with the bookshelf-paranoia plugin, which is outside the control of this project. Closing this until evidence is provided otherwise. You should open an issue over on that plugins's issue tracker.\nIf you are certain that it is an issue with Bookshelf then please provide a reproducible test case that doesn't depend on bookshelf-paranoia, or explain what exactly in Bookshelf is causing the behavior you're seeing.. Yeh, naming the foreign key id was not a good idea. Bookshelf is assuming that all tables have a primary key named id, so if you use that name for a foreign key you're going to get strange behavior unless you specifically tell Bookshelf that a table does not have a primary key.\nFrom: https://bookshelfjs.org/api.html#Model-instance-idAttribute\n\nIf the table you're working with does not have a Primary-Key in the form of a single column you'll have to override it with a getter that returns null. Closing this as solved.. Does it help if you add a .fetch() before .load()?\n\nPerson.collection(people).fetch().load('pet').then( /*...*/ ). I haven't had the time to look at this yet. But I'll give you a better reply soon.. It would help if you could provide a reproducible test case. Something like this: https://gist.github.com/ricardograca/da68dc091fcbe15c395558c166fd7200. Either you have some other part of the application interfering with it, or the gist isn't exactly the same, for example using `new User().fetchAll()` instead of `Users.fetch()` where `Users` is a collection. Also, are you using the latest version on your application?. 0.14 was just released this past Sunday :wink:\n\nAlso, you're using a lot of plugins. Any one of them could be causing this issue, so you should try to narrow it down until you can find the culprit.. I think this was fixed a while ago but not released yet. Can you check with the latest master?\nAlso, check out https://github.com/bookshelf/bookshelf/pull/1846. It is not expected behavior. This will be fixed soon.. Thanks. The current version of Bookshelf is not fully compatible with Knex 0.15.0+ yet, but that will be added in the next version.. This will be released in a patch update to Bookshelf soon.. Released in 0.14.2.. Fix released in 0.14.2.. I'm not seeing the behavior you mention if the foreign key is set to null. In this case the relation will simply not be set, but there are no errors from the database. This was tested on SQLite, MySQL and PostgreSQL.\nIf this is an issue specific to MariaDB, you'll have to provide a reproducible test case for further investigation and possible fix. Here's an example to get you started.. As you can see here, we've been using pg 7.4.1+ since January (Bookshelf 0.13.0) and it has been working fine. What do you mean by \"not working\"?\nIf you can provide a minimal reproducible test code sample this can be reopened, otherwise it's possibly some problem with your code.. Can you fill in the description? What is this about?. Closing due to lack of response.. Closing due to lack of response.. > Is this desired/expected behaviour so that all objects match?\nIt isn't. It's supposed to be null if it doesn't exist irregardless of other models. Thanks for the report. Will look into this as time permits.. I don't think this can be fixed without going back to the previous poorly performing eager loading code. It would help if you can provide a reproducible test case. Here's an example to get you started: https://gist.github.com/ricardograca/da68dc091fcbe15c395558c166fd7200. Possibly of interest: https://stackoverflow.com/questions/23509740/distinct-on-postgresql-json-data-column. I would still like to get this fixed for regular JSON columns, but that will probably require a rewrite of the queries.. See #1941.. From what I can tell it means it's \"changed\" in regards to what is in the database.. Because, following the logic I mentioned, it means there are no changes in the model compared to what's in the database after it's updated.. Right, but that's what the previous attributes are for, and it's still useful to know if something is in a different state from what's in the database, not to mention that hasChanged is used internally to figure out if a model is dirty or not.\nYou can also easily save the model.changed object in the saving event if you need to access this later: const hadChanged = _.clone(this.changed).\nAs for the destroying event, the model still hasn't been destroyed, so if it didn't had any changes, it will continue to not have any changes. On the destroyed event I agree it could have all attributes as changed if that's not the case currently.. You mention that calling User.query().toString() produces an incorrect query, but I think that is expected since you're not doing anything with the query builder, and on top of that you're not even using that in any of the other code examples you posted.\nIf you can provide a reproducible test case it would help (like this example), otherwise there's not much to work on, since calling model.fetchAll() is guaranteed to be working.\nProbably you have some plugin or event listener creating problems.. In the code you posted you have tablename set as users, but in the database creation queries you have Users. PostgreSQL is case sensitive, so obviously your query will not work because the table users doesn't exist.. Also, I'd appreciate if you don't open duplicate issues after an issue was closed as obvious PEBCAK.. Duplicate of #1944.. Sure, as long as all the existing tests pass it should be fine.. Possibly in the next version (1.0.0), if not earlier.. Looks to me you're already doing it for lists where the user is the owner. If you use listsPick instead of lists in your withRelated array you should get lists where the user is the picker.. You should be able to use the .serialize() method for that.\nPossibly something like:\n```js\nserialize() {\n  let relations = _.mapValues(this.relations, relation => {\n    return relation.toJSON ? relation.toJSON() : relation)\n  }\nreturn Object.assign({}, this.attributes, {relationships: relations})\n}\n```\nNote that this is a very simple example. If you need more options check the source for the serialize method and adapt accordingly.. Please don't cross post question on multiple repositories. Closing as this was already answered on knex's repository.. Where is this checkJson() coming from? It seems to be causing problems in Travis.\n. Missing period at the end of the sentence. Also, the English used is a bit weird. I would change the following:\n\n...templates when creating your entry, this will help clarify the scope of your proposal or the subject of your issue. . Missing period at the end of this sentence.. I have no idea what this means. This paragraph isn't very clear to me. What is a \"common pattern hard to express\"? By \"similar effect\" do you mean how to reproduce the bug? Or is it something related with new features?. The usage of \"motivate\" here doesn't make much sense.  You probably mean \"explain\" instead.\n\nAlso missing a period at the end of this sentence.. Could also be a bug fix, not necessarily a feature, so how about:\n\nA short description of the changes this PR introduces.. I'm pretty sure you don't mean \"completition\" here, but rather \"resolution\" or some other synonym.\n\nAlso missing a period at the end of this sentence.. \"they\" should be \"the\". Also, I think \"reproduce it\" is the usual term instead of \"similar effect\", so I think this sentence should read \"...show how developers can reproduce it...\". Missing period at end of sentence again. You seem to do this a lot, so you should double check these before committing.. Also missing a period, and the running part is a bit strange. I think it should be more like \"...the actual errors while running the affected code.\". Replace updated with update.\nI think you should further clarify that passing in custom values for timestamps will use those values instead. Something like:\n\n... of the timestamps columns values, and use the values you specify instead.\n\nIt's better to be too obvious than not obvious enough.. Is there any possibility of groupedKey ever being undefined?. I'm not too sure about removing this test. The thing is that created_at mustn't change when updating a model, but your PR is producing a change right?. Here it's the same thing as above. We don't want created_at to change with an update.. I see. Very good explanation, thanks! I understand why you need to change how created_at is handled when updating. This could actually solve the issue of not being able to update the created_at column without having to resort to even more option flags, however this is a major change.\nI'm currently preparing a small bug fix and documentation updates release without any major changes, but this timestamp issue will be handled on the next release after that for sure. If you don't mind I'd like to think a little bit more about this issue before merging, to avoid potentially introducing even more problems related with this functionality. Specifically, the changes in PR #900 seem to have the potential to cause conflicts.. Yeah, I noticed that discrepancy. I'll take a look at the failing test after the next release as well.\n  . I'll convert to that method after merging this, since the original author isn't interested in doing it.. This started throwing a warning when running tests:\nKnex:warning - knex.__knex__ is deprecated, you can get the module versionby running require('knex/package').version\n\nCan you look into it?. So, this is already explained above and I'd prefer if it wasn't repeated again with slightly different wording and examples. This could lead to some confusion. You can add a note to check the above sections or something.. This is also explained above.. This is good advice, but the installation part is already explained above. Maybe that part above could be improved, but duplicating it here doesn't seem right.. Do you mind returning the call to save() here instead of calling ok() at the end? This ensures better consistency with the rest of the test suite and if the test fails the error will get caught correctly instead of being handled by the generic global onPossiblyUnhandledRejection() handler.. You call the events \"async\", but they seem more sync now since the next listener is only called after the first one resolves, so can you explain the async nature of this test?. Can you change this a little bit to make it clearer what the purpose of date is? Something like:\n\nSpecify what date is used as the value of now when creating or updating timestamp attributes. This overrides the current date with the specified value.. I'm not sure this description fits with what is actually being tested here. It should be the opposite since previousAttributes will now detect changes to nested objects.. I'd prefer if this was set to \"none\". Also, can you set semi: false?. Wow. I really hate how the function arguments are split into individual lines like this. Makes no sense for such a small number of arguments. Is it possible to avoid this?. Also definitely dislike the ternary conditional operator split into multiple lines. Is this avoidable? Although in this case these previous 3 lines could be improved.\n\nI see that not all ternary operators are reformatted like that, so do you know what's the trigger for splitting them into multiple lines?. This is weird. Splitting a single line fat arrow function into multiple lines makes its intention a bit ambiguous: e.g. was it supposed to be returning something or was it supposed to return undefined? Did the author made a mistake?. This is definitely super weird :confused: Why is the options.patch in a single line by itself? Is there like a 80 column max line length limit or something?. We should burn this evil nested ternary operator, but that has nothing to do with this PR. This is more of a note for my future self.. I also dislike all these unnecessary (), although I have to admit it makes the code more readable. Is this configurable? If not we can go with it.. I'm guessing we can't keep this { in the previous line, right?. :+1: 120 sounds good to me as well. 80 is definitely too narrow.. Ok, not a big deal then.. Ok, part of the compromise part I guess. Not a big deal. Thanks for your comments.. You have an extra ). You should at least enable the linter in your IDE before submitting a PR, or run npm run lint as that would catch this small mistake.. We can go with this approach for now. If anyone has any reasons to use pretty-quick we can discuss this further.. This particular Case Converter plugin is part of core, so it can't be removed from this list: https://github.com/bookshelf/bookshelf/blob/master/lib/plugins/case-converter.js. It's just missing a dedicated wiki page.. Can you either add the proper issue number or just remove that reference?. Can you remove this debug option? It's polluting the test output.. I'm a bit worried this will make it less obvious what packages need to be installed, since the previous:\n\n...mysql, pg, or sqlite3...\n\nreferred to actual package names on npm. So, maybe your changes could also include a link to each package.. Yes, that's fine, but it's @ricardograca (probably the second result in the auto-complete list).. ",
    "adamscybot": "Most of the time, reading and then letting bookshelf decide to UPDATE or INSERT is fine. However, we have a case where we are pulling in an external data source and dumping it into our db. We then query this external source every day or so. This source either updates existing records or ads new ones (its basically a TV electronic program guide which is a good use case).\nAs this is 1000's of rows, it would be useful to halve the number of queries for efficiency reasons. This could be even better with batch insert support.\n. ",
    "danpaul": "I'm really happy with Knex and don't want to complain but since you're asking for use cases for an upsert, I'll post what brought me here. I actually seem to find the need for upsert pretty routinely. The particular problem I'm dealing with now is a log of posts read by users. There is a user id column and a post id column and I can't guarantee that a request to add an entry, hasn't already been made, so, it would be nice to be able add a new row with user id and post id if that row doesn't already exist (or, in my case upsert the identical row).\n. ",
    "danielzurawski": "The reason to use upsert is to avoid deadlocks in a busy system\n. ",
    "jordansexton": "@Playrom Can we reopen this? ON DUPLICATE KEY / ON CONFLICT statements are super important, and the workaround in Bookshelf is super hacky. Here's mine (using flow), as an example:\n```javascript\n/ @flow /\n'use strict';\nimport type Collection from 'bookshelf/lib/collection';\nimport type Model from 'bookshelf/lib/model';\nimport type QueryBuilder from 'knex/lib/query/builder';\nimport type Result from 'pg/lib/result';\nconst Sync = require('bookshelf/lib/sync');\nconst insert = Sync.prototype.insert;\nSync.prototype.insert = async function (...rest: any[]): void {\n    let conflict: ?string | string[] = this.options.conflict;\n    if (conflict == null) {\n        return await insert.apply(this, rest);\n    }\n    else {\n        const syncing: Model      = this.syncing;\n        const query: QueryBuilder = this.query.insert(syncing.format(Object.assign(Object.create(null), syncing.attributes)));\n    conflict = arrayWrap(conflict);\n\n    const placeholders: '??'[] = Array(conflict.length).fill('??');\n    const idColumn: string     = syncing.idColumn;\n    const raw: Raw             = query.client.raw(dedent`\n        ON CONFLICT (${ placeholders.join(', ') })\n        DO NOTHING\n        RETURNING ??\n    `, conflict.concat(idColumn));\n\n    const result: Result = await query.client.raw(`${ query.toQuery() } ${ raw.toQuery() }`);\n\n    return result.rows.map(function (row: Object): any {\n        return row[idColumn];\n    });\n}\n\n};\n```\nUsage:\njavascript\nconst job: Job = await Job.create(\n    { myUniqueColumn: 'someUniqueValue' },\n    { conflict: 'my_unique_column' }\n);. This is a very old issue, but if anyone finds this, you can use Knex's columnInfo to do this.. Most ORMs support multiple RDBMSs. They rarely have the most advanced or specific features of any system. For example, Knex has JSON support, but it only extends to declaring the column type and getting data in and out. If you want to do JSON queries, you need to drop to knex.raw to do it.\nAside from it only working on Postgres, I think the main reason for not having something like this in Bookshelf is that performance isn't exactly the primary concern of an ORM. The abstraction of tables and joins is well understood by people who work with SQL and relational databases. Unless you're storing really simple objects in arrays, and even then, the performance bottleneck of your application is not likely to come down to using joins. Moreover, 2x or even 5x performance on a couple of operations isn't even close to worth it for the added complexity in both library code and userland code.\nAdd this to a lack of foreign key constraints, which are always a feature people want out of their ORM, even if it doesn't actually protect data integrity all that much, and it makes it hard to justify the complexity of supporting array-based relationships for one RDB. I mean, I use Postgres too, but if your problem is slow joins, it's safer, more portable, and likely better all around to just denormalize as needed and rely on a caching layer for expensive operations. There are usually other easier optimizations to make than using unique data structures in your table.\n. Yep! I just wanted to fly the feature past someone first.\n. Yep! I just wanted to fly the feature past someone first.\n. Awesome. Okay, I fixed the test failure, added a test for the new behavior, and rebased the commits.\nAnything else/different I should do?\n. Awesome. Okay, I fixed the test failure, added a test for the new behavior, and rebased the commits.\nAnything else/different I should do?\n. Done, and I can squash if desired.\n. Done, and I can squash if desired.\n. +1\nThough, are Underscore-style collections even here to stay in Bookshelf?\n. I found a workaround per https://github.com/jtwebman/bookshelf-scopes/issues/1#issuecomment-286905196\nCalling extended on your model class will cause it to be assigned the desired Error classes and other plugin behavior.. Last public commit to next was June 17 (282abe55ea5070933b95858cd9415bd33887b558). I would also like to know if Bookshelf is under active development.\n. @fcarreiro Bookshelf and Knex are stable, flexible, full featured, well tested, and used in production by many individuals and organizations. In addition, there are many plugins still being developed for it. By all means, consider Bookshelf (or any other ORMs you might evaluate) as you would any other library: on its merits.\nYou're essentially asking the library maintainers to project their expected effort in the future, and thus bear responsibility for your decision to use (or not use) Bookshelf now. As a counterpoint, if Bookshelf currently seems unmaintained/is missing features/doesn't use ES6/7, and that presents a problem for your use of it right away, what would really cause that perception to change?\nUse Bookshelf, or \"consider moving to another ORM\" if you think that's best, but it seems to me that evaluating the historical and current development on the project per the commit history, Pulse, and Graphs on Github is a much better idea than deciding based on a reply to a comment on a 2 year old issue.\nPer @rhys-vdw's comment above, Bookshelf isn't under active development. To me, that's not a huge problem, because of all the existing great things about it, but you can read the above thread and look at the commit history to assess the state of the project.. @awebdeveloper I realize this is over a year later, but you're getting\nMaximum call stack size exceeded\nbecause of the this.set(\"id\", value) you have in the virtual id setter. This is causing it to call itself recursively.. A few concerns.\n- As far as naming/locating the config goes, random dotfiles, especially if they are assumed to live in the project root, clutter and obscure the operation of the application. Especially if the file is a critical runtime dependency of the application, not like an .eslintrc file that is used at development or build time. It shouldn't be hidden on any platform. \n- How would the schema file work for different environments? Is it JSON only or can you execute JS in it? If it's JSON only, it's a pain to do things like loops. If you're familiar with webpack, it expects a JSON config, but you pass it into the compiler yourself, and thus can construct it however you see fit for the environment/build target. Overall, I think it would be preferable to pass the config into Bookshelf as desired rather than have it read it from somewhere. This is how Redis clients, AWS clients, and other data store clients tend to work in Node environments.\n- I'm immediately suspicious of the idea of a schema file that would be portable to other ORMs or query builders (or even other data store adapters for the same ORM, next bullet point). As they all have and support different databases, data types, SQL dialects, and other features, this seems like the (usually impossible) write once run anywhere holy grail.\n- How is data store independence proposed to be achieved? What if you switch data stores and VARCHAR(255) isn't supported? Does your schema break? What if your column names transform differently between data store (like_this in most RDBMS, but LikeThis in, say DynamoDB)? This is something better handled by transformation in the model layer.\n- The database schema, if contained in a file, is usually a generated file (as in ActiveRecord) that merely reflects the state of current migrations. I would rather write migrations, a tried and true and robust way of changing a database over time that provides the full power of the host language & platform, than mess with a JSON schema directly. Is this what you had in mind?\n. Thanks for the merge! Yeah, good to note. I use a getter in a base model, similar to https://github.com/tgriesser/bookshelf/issues/756#issuecomment-110113718, to do some of this automagically (a la ActiveRecord), e.g.\njavascript\nget tableName () {\n    var tableName = this._tableName;\n    if (tableName == null) {\n        tableName = pluralize.plural(underscored(this.constructor.name));\n        this._tableName = tableName;\n    }\n    return tableName;\n}\n. Related: #981\n. Ah, so they are. Hmm. That seems pretty atypical for npm packages, even ones installed from Github. I think I remember seeing advice like that (maybe from Domenic?), and it seemed like an idealized notion of how npm packages should be installed that is not actually a reflection of real world use or expectations.\nIt seems reasonable to expect that installing from a github commit or tag will work just like installing from npm proper. This is also a problem for remote installs that rely on specfic github commits in the package.json (very common).\nUntil this is moved to prepublish, would npm install instead of npm install babel-cli work in the postinstall script to install all of the devDependencies?\n. Agreed, and somewhat related: #1223\nMaybe you have thoughts on that?\n. What are these \"requests\"? Are they web requests? What data are you referring to? What does any of this have to do with an ORM?\nThere is not nearly enough detail to tell what you're looking for a solution to, but on face it sounds like it's out of scope for any ORM anyway. While I appreciate that you're frustrated and in a hurry, nothing in this issue appears to be an issue with Bookshelf, and there's a lot that seems specific to your use case. If you need to manipulate data asynchronously before handing it to your model, you can do that. It sort of sounds like you need some custom business logic around handling your data, but this isn't obviously the domain of an ORM.\n. I'm familiar with that issue and commented on it some time ago. As the OP of that issue mentioned initially, no ORM supports that feature. If you want that feature, you may have to implement it. The clear desire for the feature you assert does not clearly exist to me. Rather, it's a somewhat esoteric feature of one RDMBS, that is unsupported by any of the ORMs @simg evaluated. If you look at https://github.com/tgriesser/knex/issues/1471, you can see that @rkoberg shows how do it in SQL. That's about as close as you're going to get without a lot of work being done on this feature, work that no one has an obvious interest in actually doing.\nBack to this issue, you used the term \"mandatory request\" which is a term that has no obvious contextual meaning. That's why I asked for context of what you're trying to do. I have no idea what that is at this point. There are plenty of reasons to be disappointed with any library, and plenty of things that Bookshelf can't do, but this is neither here nor there. No one can help you if you aren't specific about what the issue you're running into is, and a determination of the relevance to Bookshelf matters because that's what this is about. If it's the aforementioned one (Postgres arrays), the answer is simple: few people are using them, they have not been implemented in Bookshelf or any notable ORM I know of, and they aren't likely to be added in a timeframe that is useful to you if you're in a hurry.\n. I'm not going to get into the issue of whether a small number of people constitutes a clear desire or not. What is true is that no one has indicated they are implementing that feature or has any plans to. For that feature, you are presumably on your own, and will need to write SQL and your own logic for populating models if that's an issue.\nAs for what's actually possible right now based on the bullets above, there are fetching and fetched events you can subscribe to on a given Model, and return Promises from to asynchronously modify the query and/or modify the results. Depending on what you're doing with the data or what it is, you may still need to make raw queries that result in parsing and forging or populating your own model instances.\n. No problem. Hope it works out for you!\n. Bookshelf (and Knex) are not aware of your columns until they are fetched from the database, and even then, they don't care what you name them. So, here's a big caveat: aliasing them like this is a bad idea, as you will need to use the column names with where statements, joins, etc. Any time you need to access Knex or SQL, the aliases will not be used when you do.\nUltimately, this means having two different names for the same thing in your application code, which will certainly create bugs that are hard to diagnose because you'll get unfriendly SQL errors. I strongly recommend using the actual column names throughout your code to avoid the maintenance this presents, or using the virtuals plugin to alias them in the application code if you really must.\nHowever, that said: you can accomplish what you want by implementing the parse and format methods of the model you want to perform the conversion on. Something like this (using lodash for simplicity):\npost.js\n```javascript\nvar invert    = require('lodash/invert');\nvar parser    = require('./parser');\nvar formatter = require('./formatter');\n// your mapping above\nvar attributesToColumns = {\n    'custom_name_in_model': 'column_name_in_table',\n    'user':                 'user_name',\n    'password':             'password_hash',\n    'date':                 'created_at',\n    'update':               'updated_at'\n};\n// flip the keys and values\nvar columnsToAttributes = invert(attributesToColumns);\nvar Post = bookshelf.Model.extend({\n    tableName: 'posts',\n    parse:     parser(columnsToAttributes),\n    format:    formatter(attributesToColumns)\n});\n```\nparser.js\n```javascript\nvar reduce = require('lodash/reduce');\n// reusable higher order function\nvar parser = function (columnsToAttributes) {\n    return function (columns) {\n        return reduce(columns, function (attributes, value, column) {\n            attributes[columnsToAttributes[column]] = value;\n            return attributes;\n        }, {});\n    };\n};\n```\nformatter.js\n```javascript\nvar reduce = require('lodash/reduce');\n// reusable higher order function\nvar formatter = function (attributesToColumns) {\n    return function (attributes) {\n        return reduce(attributes, function (columns, value, attribute) {\n            columns[attributesToColumns[attribute]] = value;\n            return columns;\n        }, {});\n    }\n};\n```. The easy way to do this is to use the visibility plugin. You will still get the data from the database, but it will be excluded from the JSON output of the model.. Since transactions are used for concurrency control, and Bookshelf doesn't do anything with transactions but pass them to Knex, this is a Knex question rather than a Bookshelf question. It's also highly database-specific: different databases handle concurrency control differently.\nFor example, in Postgres, you would need to use a\nsql\nSELECT ... FOR UPDATE (NOWAIT | SKIP LOCKED)\nquery, inside a transaction that you've\nsql\nSET TRANSACTION ISOLATION LEVEL REPEATABLE READ\nor SERIALIZABLE on. If you need to do this in Bookshelf, you'll need to use Knex and raw queries.. I just encountered this as well. I believe the issue is caused by this line which calls fetchAll() without passing the options object containing a transacting property, or without calling qb.transacting(transaction) after cloning the query in this method.. This won't work. The virtuals plugin does not await the getters it calls, so any async methods you define will just return a Promise, not their eventual values.. I think passing all options might be a problem, as this includes passing things like require. I'd argue that the require must apply to the fetchAll of the rows you want, not the count. I don't know if this matters in practice, or why the count is using a fetchAll rather than a fetch anyway. It would also be passing withRelated, which will fail in the worst case or be wasteful in the best case. Maybe just blacklisting some options to exclude could work, though it presents some forward compatibility issues.. ",
    "mrpoptart": "I've handled this in a BaseModel class, which I extend for all of my models. This was partially stolen from work in https://github.com/bsiddiqui/bookshelf-modelbase, which I couldn't get to work.\n```js\nconst bookshelf = require('../config/bookshelf');\nconst BaseModel = bookshelf.Model.extend({},\n  {\n    /*\n     * Select a model based on a query\n     * @param {Object} selectData\n     * @param {Function} [callback]\n     * @return {Promise}\n     /\n    findOne: function (selectData, callback) {\n      return this.forge(selectData).fetch(callback);\n    },\n/**\n * @param {Object} selectData\n * @param {Object} updateData\n * @returns {Promise}\n */\nupsert: async function (selectData, updateData) {\n  const existingModel = await this.findOne(selectData);\n  if (existingModel) {\n    return await existingModel.set(updateData).save();\n  } else {\n    return await new this(updateData).save();\n  }\n}\n\n},\n);\nmodule.exports = BaseModel;\n```\n```js\nconst BaseModel = require('./BaseModel');\nconst Account = BaseModel.extend({\n  tableName: 'accounts',\n  hasTimestamps: true,\n});\nmodule.exports = Account;\n```\nUsage:\njs\ntransactions.forEach(async (transaction) => {\n  await Transaction.upsert(\n    {\n      transaction_id: transaction.transaction_id,\n    },\n    {\n      user_id: user_id,\n      account_id: transaction.account_id,\n      account_owner: transaction.account_owner,\n    }\n  }\n}\n. ",
    "JuliaRakitina": "Still no official solution ?. ",
    "singhpratik17": "\"Upsert\" - anything yet?. ",
    "fl0w": "I think it's saner to do INSERT .. ON CONFLICT DO NOTHING RETURNING * (PostgreSQL), but Knex doesn't support it so I wrap my query in a raw that when needed.. This is an honest opinion by someone who uses bookshelf currently, but not a contributor.\nBookshelf does have some fundamental flaws which I battle with on a daily basis. There's only so much monkey patching I'm comfortable with doing. Not that bookshelf isn't functional, because it really is, just not for our use. I never equate commit history to how viable a project is.\nCollections are a continuous headache. An example is the lack of proper events fired which has been addressed but ignored/rejected previously. While existent in Model, a relation becomes a Collection and events (other than Collection.fetched) doesn't fire, and can't even be invoked manually without monkey patching.\nThe lack of support for composite primary keys (used heavily for our SaaS) is a huge bummer for me. I'm forced to drop down to knex extensively for simple relational SELECTs.\nBookshelf will work fine for most applications, but as with all/most ORM's there's a threshold. I've been personally trying to find time to introduce/switch to objection.js (github) which is very active but also quite young. The repo owners are mature, active, thoughtful and senior developers and it shows. The ORM is quite different compared to both Sequelize and bookshelf.js. I recommend a read through the docs (which are excellent IMO) before giving it a go. The API is still in flux, but the devs are very considerate of semver-versioning with proper multi-version deprecations before removals/updated API.\nMy two cents which might or might not answer your question.\nEdit Edited what browser auto-corrected \n. I am shamelessly going to bump this, hoping for clarification at best.. Oh god yes, I'd love the removal of collections - but it'd break our entire app.\nI've been trying to hack bookshelf to not create an anonymous collection by monkey patching and adding/relying on Model.prototype.collection to instance the correct type. I seem to have misplaced that branch though.\nTheoretically, since bookshelf does know which model to set as parent - wouldn't it be possible to just instantiate using Model.prototype.collection everywhere and thus allowing user space to overload?\ne.g.\n```js\nclass MyModelCollection extends bookshelf.Collection {\n  // ... all the hacks\n}\n// Trying to mimic Collection.prototype.model overload design\nclass MyModel {\n  get collection () {\n    return MyModelCollection\n  }\n}\n```. > which is probably what you're doing, right?\nCorrect, but either I was ninja-refactoring to hard and got lost or I'm pretty sure there's instantiation done directly via bookshelf.Model.collection somewhere, specifically upon relation fetching. Give me a few and I'll try to find it, or I'll correct myself by surrendering my suggestion.. I am considering if it was the registry that offended me, here on line 51:\nhttps://github.com/bookshelf/bookshelf/blob/0766746c2e116d498d55ca4ee7fdde96c0c6cf6e/src/plugins/registry.js#L50-L52. It's been a while since I looked at bookshelf's source, so I'm a bit off about its inners. I'll take a look and submit if I can produce anything of quality.. If anyone else stumbles upon this, here's the correct way to register a custom collection when using the registry plugin:\n```js\nclass MyModels extends bookshelf.Collection {\n  get model () {\n    return MyModel\n  }\n}\nclass MyModel extends bookshelf.Model {\n  static collection (...args) {\n    return new MyModels(...args)\n  }\n}\nbookshelf.collection('MyModels', MyModels) // This is what I previously forgot\nbookshelf.model('User', User)\n```\nAfter this bootstrap everything runs as expected currently (except that Collection.fetched event isn't fired on a relation call as I would have expected - but Collection.fetching does).. As far as I can tell, when doing allot of bookshelf hacking to get namedModifiers working (e.g. predefined fn's for .query() methods to be use on fetch and down the related chain) fetching:collection isn't necessary and actually inconsistent. It's better to just define a custom collection for said model and register fetching handler.\nEdit Actually sorry, I read this one wrong. Keeping to announce my stupidity.. Not sure about performance, but isn't it saner to just wrap original query as a subquery if there's statements like groupBy, distinct etc. and count it?. @ricardograca I'll try, keep this open though and I'll reference this if I produce anything of value.. My god, I completely missed #1817, still think my solution is cleaner. Apologies :). Added a simple test, if it's not enough pointers are appreciated and I'll add tests accordantly.. The package bookshelf-camelcase looks a bit too optimistic IMO. It only overloads bookshelf parse/format options, and I think that the update will yield knex identifiers which bookshelf have no idea how to convert case (in this case). That package is flawed (I think), and the correct way is to setup knex correctly using wrapIdentifiers.. Sort of related, but not the root of your issue (unless you hav pool min: 1 max: 1).\nYou should have all db requests within the transaction using trx, as knex is locking the connection in use for that transaction and at edge-ish where your entire pool is used and all are waiting for a fetch before continuing.. Sort of related, but not the root of your issue (unless you hav pool min: 1 max: 1).\nYou should have all db requests within the transaction using trx, as knex is locking the connection in use for that transaction and at edge-ish where your entire pool is used and all are waiting for a fetch before continuing.. You should at least add await knex('tasks').transacting(trx).where({spotId: spot.id}).update('isDeleted', true);. You should at least add await knex('tasks').transacting(trx).where({spotId: spot.id}).update('isDeleted', true);. I would avoid escaping myself, just make sure each value actually is an array of strings and use whereIn.. FYI using node 10 I've added Symbol.asyncIterator to my base class which enables for-await-of-loops. Super clean way to implement \"walkable cursors\".. js\nconst users = User.forge().query(qb => qb.whereNotIn('id', [2, 3, 4])).fetch(). Isn't it better to continue following knex with semver minors considering 1.0 seems far off based on what's in the version 1.0 project. Knex is also brewing with activity and would be sad to fall behind because bookshelf keeps backwards compatibility with node v4 which is EOL anyway?. Isn't it better to continue following knex with semver minors considering 1.0 seems far off based on what's in the version 1.0 project. Knex is also brewing with activity and would be sad to fall behind because bookshelf keeps backwards compatibility with node v4 which is EOL anyway?. Just do a Collection sortBy.\nThe other way is to do a an aggregated join or a sub query selecting a count and Then sort by it.. Check the generated query and replicate it using knex. Depends on what database your using but I would use a window function (in postgresql).. Check the generated query and replicate it using knex. Depends on what database your using but I would use a window function (in postgresql).. I'm not entirely sure, but theoretically based on my understanding of the inner workings of bookshelf you'd have to overload knex prop per model instance and manage the knex connections manually.. I'm not entirely sure, but theoretically based on my understanding of the inner workings of bookshelf you'd have to overload knex prop per model instance and manage the knex connections manually.. I've been on a internet-less vacation, so sorry for no responding sooner.\nI would use the official bookshelf register and simply overload the getter to also optionally accept a knex object which is switched on each use. So I'd make sure I always required model objects through.\nSo something like:\n```js\nbookshelf.extendedRegister = (bookshelf, options = {}) => {\n  const originalRegister = bookshelf.register\n// Of the top of my head, not tested but only to showcase my thought\n  bookshelf.register = (key, knexOrClass) => {\n    if (!knexOrClass) {\n      return originalRegister(key)\n    } else if (knexOrClass instanceof bookshelf.Model) {\n      // default behaviour\n      return originalRegister(key, knexOrClass)\n    } else {\n      // I haven't considered collections here but you get the idea\n      const model = originalRegister(key)\n      model.knex = knexOrClass\n      return model\n    }\n  }\n}\n// Koa mw\napp.use(async (ctx, next) => {\n  ctx.state.models.User = bookshelf.register('User', someFnToFetchCorrectDBConnection())\n  await next()\n})\n```\nThen just have a fn to manage connections according to schema (or session?), instead of defining it on the model.. I've been on a internet-less vacation, so sorry for no responding sooner.\nI would use the official bookshelf register and simply overload the getter to also optionally accept a knex object which is switched on each use. So I'd make sure I always required model objects through.\nSo something like:\n```js\nbookshelf.extendedRegister = (bookshelf, options = {}) => {\n  const originalRegister = bookshelf.register\n// Of the top of my head, not tested but only to showcase my thought\n  bookshelf.register = (key, knexOrClass) => {\n    if (!knexOrClass) {\n      return originalRegister(key)\n    } else if (knexOrClass instanceof bookshelf.Model) {\n      // default behaviour\n      return originalRegister(key, knexOrClass)\n    } else {\n      // I haven't considered collections here but you get the idea\n      const model = originalRegister(key)\n      model.knex = knexOrClass\n      return model\n    }\n  }\n}\n// Koa mw\napp.use(async (ctx, next) => {\n  ctx.state.models.User = bookshelf.register('User', someFnToFetchCorrectDBConnection())\n  await next()\n})\n```\nThen just have a fn to manage connections according to schema (or session?), instead of defining it on the model.. You are probably trying to access the library Bookshelf and not the instance.\njs\nconst bookshelf = new Bookshelf(knex)\nbookshelf.knex.raw() // -> works fine. You are probably trying to access the library Bookshelf and not the instance.\njs\nconst bookshelf = new Bookshelf(knex)\nbookshelf.knex.raw() // -> works fine. Don't commit each individual save. Pseudo e.g.\njs\nbookshelf.transaction(async trx => {\n  for (const table of tables)\n    await new Table(table).save({ transacting: trx })\n  await trx.commit()\n}). I don't understand your problem to be honest.\nIf you want the entire transaction to commit when everything's done, you need to commit once at the end, if you expect a fail somewhere I recommend you either handle it using\n * ON CONFLICT (which isn't directly supported by knex) to avoid breaking the transaction\n * or make use of savepoints (which is supported by knex), sort of like a transaction within a transaction.\nPS This is of course assuming your using PostgreSQL, cannot comment on usage for other RDBs. Yes, using ES6 classes works out of the box. Try it.\n```js\nclass Thread extends Model {\n  get tableName () {\n    return 'test'\n  }\nposts () {\n    return this.hasMany(Post)\n  }\n}. You'll want to use bookshelf ability to opt in raw queryBuilder using QueryBuilder#select and QueryBuilder#groupBy (or QueryBuilder#groupByRaw).\nHere's an example (not tested):\n```js\nclass MyModel extends bookshelf.Model {\n  get tableName () {\n    return 'invoice'\n  }\n}\nconst myModels = await MyModel.forge()\n  .query(qb => {\n    qb.select(knex.raw('EXTRACT(MONTH FROM ??)', 'lastPaymentDate'))\n    qb.select(knex.raw('count(??)', 'lastPaymentDate'))\n    qb.groupBy(knex.raw('EXTRACT(MONTH FROM ??)'), 'lastPaymentDate'))\n  })\n  .fetch()\n. Is `blog_post_i18n.id` a primary key?\nDid you try `.fetchAll` (or `BlogPost.collection().fetch()`)?. are you sure you have multiple rows with `blog_post_i18n.id = 28`? Nothing looks weird to me.. Ah, I get it. You need to change the default foreign key for bookshelf to understand what to match when mapping eager results.. I always mix these up (and I'm on a phone), but try something close tojs\ni18n() {\n  return this.hasMany(BlogPosti18n, 'id', 'id')\n}\n``. I think you misspelledtableName` (notice the uppercase N).\nBonus, in package.json scripts you don't need to reference e.g. nodemon by its path \"dev\": \"./node_modules/.bin/nodemon ...\", you can simply do \"dev\": \"nodemon ...\". npms resolves this for you \ud83d\udc4d . Keep in mind that the only reason to why I could identify the problem by simply glancing at the error message is because I've done this many times myself (or simply forgot to define it all together). Don't sweat it, happens to all of us.. ",
    "mtsr": "Note the slight difference for belongsToMany relations:\nnew Post(data).save().then(function(post) {\n  // fetch the existing tags\n  return new Tags().query(/* some query */).fetch()\n  .then(function(tagModels) {\n     // 'attach' them to the post\n     return when.all(post.related('tags').attach(tagModels)).yield(post);\n  }\n}).then(function(post) {\n  console.log('all tags should be saved on a new post');\n  console.log(JSON.stringify(post))\n});\nNote that you might need to create new tags as well.\n. While not directly supported you can add them easily by doing:\nmodel.query({ limit: 10, offset: 0 }).fetch()\n. ",
    "cstotzer": "Cool! Thanks a lot!\n. Yes, that took care of it. I can live with that work around for the time being since I'm just prototyping. Thanks a lot!\n. ",
    "rarkins": "@tgriesser do you have any plans to implement something similar to the functionality which was removed, i.e. remapping of the pivot names? \n. I'm looking into hstore in Postgresql as a way to minimise the frequency of schema changes, but lack of support in Bookshelf.js seems to be the deal-breaker. Unless.. it can be supported somewhat elegantly but is undocumented?\n. I just tested, and if I give Bookshelf its own connection parameters (not reusing Knex) then the error no longer happens, even with PGUSER absent from ENV.\n```\nKnex.knex = Knex.initialize({\n  client: 'pg',\n  connection: {\n    host     : conf.get(\"pg.host\"),\n    port     : conf.get(\"pg.port\"),\n    user     : conf.get(\"pg.user\"),\n    password : conf.get(\"pg.password\"),\n    database : conf.get(\"pg.database\"),\n    charset  : 'utf8'\n  },\n  debug: true\n});\n// bookshelf\nBookshelf.PG = Bookshelf.initialize({\n  client: 'pg',\n  connection: {\n    host     : conf.get(\"pg.host\"),\n    port     : conf.get(\"pg.port\"),\n    user     : conf.get(\"pg.user\"),\n    password : conf.get(\"pg.password\"),\n    database : conf.get(\"pg.database\"),\n    charset  : 'utf8'\n  },\n  debug: true\n});\n```\nNote: debug parameters were only just added to help troubleshoot the issue. They weren't previously present.\n. I realised I wasn't approaching this the right way Bookshelf-wise, so will answer my own question and close this.\nRather than use a hasMany relation, I should be using a belongsToMany relation plus withPivot.\nMy Hotel model now looks like this, and works:\nvar Hotel = exports.Hotel = Bookshelf.Model.extend({\n  tableName: 'hotel',\n  nearbyAttractions: function() {\n    return this.belongsToMany(Attraction).withPivot('distance_meters').query('orderBy', 'distance_meters', 'asc').query('limit', 5);\n  }\n});\nI can then access the distance_meters by using attraction._pivot_distance_meters.\n. Is there any solution to this? I tried something like:\nreturn this.belongsTo('Table1').through('Table2').through('Table3');\n..but it fails.\n. Is there any solution to this? I tried something like:\nreturn this.belongsTo('Table1').through('Table2').through('Table3');\n..but it fails.\n. Seems to me like something ideally on the future feature list, not the \"yet another reason to use knex again\" list. \n. Seems to me like something ideally on the future feature list, not the \"yet another reason to use knex again\" list. \n. In my case my mapping is similar to a mapping of city belongs to state belongs to country. And so if I want to know what country an address is in I need to map from object to country via city_id and state_id. This seems to be the normalized form of the data but results in really inefficient queries so I've denormalized it again. Am I doing it wrong or is Bookshelf still evolving in this area? Many cases where one query using joins would work actually result in multiple queries when I let bookshelf handle it. \n. In my case my mapping is similar to a mapping of city belongs to state belongs to country. And so if I want to know what country an address is in I need to map from object to country via city_id and state_id. This seems to be the normalized form of the data but results in really inefficient queries so I've denormalized it again. Am I doing it wrong or is Bookshelf still evolving in this area? Many cases where one query using joins would work actually result in multiple queries when I let bookshelf handle it. \n. ",
    "nestradaOBS": "My first design of the Customer and Settings tables did have a surrogate key column id, however eagerly fetching the results was impossible due to this block of code : \neagerPair: function(relationName, related, models) {\n      ...\n      var grouped = _.groupBy(related, function(model) {\n        return this.isSingle() ? model.id : (model.pivot ?\n          model.pivot.get(this.key('foreignKey')) : model.get(this.key('foreignKey')));\n      }, this);\n      for (var i = 0, l = models.length; i < l; i++) {\n        var model = models[i];\n        var groupedKey = this.isInverse() ? model.get(this.key('foreignKey')) : model.id;\n        model.relations[relationName] = this.relatedInstance(grouped[groupedKey]);\n      }\n    }\nSo upon entering this block, my Settings model looked like { id:1, Customer_id:2, ...}, however since isSingle() returns true, the grouping property was model.id and not model.Customer_id. Later when attempting to add the relation, groupedKey being the Customer_id=2, the grouped[groupedKey] returns undefined.\n. Well I reduced my schema in the following way : \n```\n-- bookshelf_test catalog\nUSE bookshelf_test;\nDROP TABLE IF EXISTS Settings;\nDROP TABLE IF EXISTS Customer;\n-- Customer\nCREATE TABLE Customer (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  name varchar(128) NOT NULL,\n  PRIMARY KEY (id)\n) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;\n-- Settings\nCREATE TABLE Settings (\n  id int(10) unsigned NOT NULL AUTO_INCREMENT,\n  Customer_id int(10) unsigned NOT NULL,\n  data varchar(64),\n  PRIMARY KEY (id),\n  CONSTRAINT settings_customer_fk FOREIGN KEY (Customer_id) REFERENCES Customer (id) ON DELETE CASCADE\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\n-- test data\nLOCK TABLES Customer WRITE;\nINSERT INTO Customer VALUES (1,'Customer1');\nINSERT INTO Customer VALUES (2,'Customer2');\nINSERT INTO Customer VALUES (3,'Customer3');\nINSERT INTO Customer VALUES (4,'Customer4');\nUNLOCK TABLES;\nLOCK TABLES Settings WRITE;\nINSERT INTO Settings (id, Customer_id, data) VALUES (1, 1, 'Europe/Paris');\nINSERT INTO Settings (id, Customer_id, data) VALUES (2, 4, 'UTC');\nUNLOCK TABLES;\n```\nMy original models are : \n// Define the model\nvar Settings = Bookshelf.Model.extend({ tableName: 'Settings' });\nvar Customer = Bookshelf.Model.extend(\n  { tableName: 'Customer',\n    settings : function () {\n      return this.hasOne(Settings); }\n  }\n);\nAnd a simple example test (I didn't try this out so bear with me, I had to remove a lot but you get the gist of it) : \n```\ndescribe('#getCustomerWithSettings()', function () {\n    it('should return Customer(id=1) with settings', function (done) {\n      var expected = {\n        id      : 1,\n        name    : 'Customer1'\n        settings: {\n          id:              : 1\n          Customer_id      : 1,\n          data             : 'Europe/Paris'\n        }\n      };\n  new Customer({ id: 1 })\n    .fetch({ withRelated: 'settings' })\n    .then(function (model) {\n      var cust = model.toJSON();\n      assert.deepEqual(cust, expected);\n      done();\n    });\n});\n\nit('should return Customer(id=4) with settings', function (done) {\n  var expected = {\n    id      : 4,\n    name    : 'Customer4',\n    settings: {\n      id:            : 2,\n      Customer_id    : 4,\n      data           : 'UTC'\n    }\n  };\n  new Customer({ id: 4 })\n    .fetch({ withRelated: 'settings' })\n    .then(function (model) {\n      var cust = model.toJSON();\n      assert.deepEqual(cust, expected);\n      done();\n    });\n});\n\n});\n});\n```\nThanks for any help, this was my original model, and it was the second test that failed (first one passed because id === Customer_id)\n. Thanks for your quick reply! When indeed by adding require('when/monitor/console') I am indeed getting a stack trace however I'm just curious as to why my error is getting is a failing promise since the execution point has left the bookshelf promise and returned an immutable value (promise spec?). Here is an example of my test:\n```\ndescribe('#getCustomerWithRooms()', function () {\nit.only('should return a customer with rooms', function (done) {\n\n  var expected = {\n    id    : 1,\n    name  : 'test',\n    email : 'test@example.com',\n    active: 1,\n    rooms : [\n      { id: 1, name: 'Paris', phoneNumber: '5101', email: paris@telepresence.orange.com' },\n      { id: 2, name: 'Tokyo', phoneNumber: '5118', email: 'tokyo@telepresence.orange.com' }\n    ]\n  };\n\n  new Customer({ id: id })\n    .fetch({ withRelated: 'rooms' })\n    .then(function (model) {\n\n    var cust = model.toJSON();\n\n    // Remove the _pivot attributes\n    cust.rooms = _.map(cust.rooms, function (report) {\n      return _.omit(report, '_pivot_Customer_id', '_pivot_Room_id');\n    });\n\n    // dump(cust);\n    assert.deepEqual(cust, expected);\n    done();\n\n  });\n});\n\n});\n```\nAnd here is my output:\n```\n1..1\n[promises] Unhandled rejections: 1\n[ { reason: \n     { message: 'expected { Object (id, name, ...) } to deeply equal { Object (id, name, ...) }',\n       showDiff: true,\n       actual: [Object],\n       expected: [Object] },\n    message: 'AssertionError: expected { Object (id, name, ...) } to deeply equal { Object (id, name, ...) }',\n    stack: \n     [ '--- Unhandled rejection escaped at ---',\n       '    at Object.PromiseStatus (D:\\test\\node_modules\\when\\monitor\\aggregator.js:24:11)',\n       '  ...[filtered frames]...',\n       '    at Object.PromiseStatus.observed (D:\\test\\node_modules\\when\\monitor\\aggregator.js:44:12)',\n       '  ...[filtered frames]...',\n       '    at Object.module.exports.getCustomerWithRooms (D:\\test\\server\\model\\customer.js:165:8)',\n       '    at Context. (D:\\test\\test\\model\\customer.test.js:257:16)',\n       '    at Test.Runnable.run (D:\\test\\node_modules\\mocha\\lib\\runnable.js:194:15)',\n       '    at Runner.runTest (D:\\test\\node_modules\\mocha\\lib\\runner.js:355:10)',\n       '    at D:\\test\\node_modules\\mocha\\lib\\runner.js:401:12',\n       '    at next (D:\\test\\node_modules\\mocha\\lib\\runner.js:281:14)',\n       '    at D:\\test\\node_modules\\mocha\\lib\\runner.js:290:7',\n       '    at next (D:\\test\\node_modules\\mocha\\lib\\runner.js:234:23)',\n       '    at Object._onImmediate (D:\\test\\node_modules\\mocha\\lib\\runner.js:258:5)',\n       '    at processImmediate [as _immediateCallback] (timers.js:330:15)',\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       [Object],\n       '--- Caused by reason ---',\n       'AssertionError: expected { Object (id, name, ...) } to deeply equal { Object (id, name, ...) }' ] } ]\nnot ok 1 customers getCustomerWithRooms() should return a customer with rooms\n  Error: timeout of 10000ms exceeded\n      at null. (D:\\test\\node_modules\\mocha\\lib\\runnable.js:165:14)\n      at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\ntests 1\npass 0\nfail 1\n```\nThanks for any ideas or directions I should investigate :)\n. ",
    "jayceekay": "I might be missing something, but why do we register events on the model instances rather than the Models themselves?\nEDIT: disregard this, I found a good example in this issue: https://github.com/tgriesser/bookshelf/issues/39\nSorry about that.\n. Hey, this worked.  Thanks for the help!\n. ",
    "bogus34": "Btw, if I pass {async: false} to CheckIt then simple validation (function(){ return false; }) doesnt apply.\n. Alright, I've found an answer.\nCheckIt().run modifies its argument inplace, leading to a sort of race conditions when multiple objects are saved in parallel.\n So the right validate function is something like this:\njavascript\n validate: function(model, attrs, options) {\n        return CheckIt(this.toJSON()).run(deepClone(this.validations));\n    }\n. Maybe I have to be more precise.\n``` javascript\nUser = db.Model.extend({\n  tableName: 'users',\n  photos: function(){ return this.hasMany(Photo); }\n});\nnew User({id: 1}).fetch().then(function(user){\n  user.photos().fetch(); // [1]\n  user.photos().query(); // [2]\n  users.photos().query().count(''); // [3]\n  users.photos().query('count', ''); // [4]\n  users.photos().query('count', '*').fetch(); // [5]\n});\n```\n[1] works fine, query is 'select \"photos\".* from \"photos\" where \"photos\".\"user_id\" = ?'\n[2] 'select * from \"photos\"', relation information is lost\n[3] 'select count(*) from \"photos\"', relation information is lost\n[4] executes no query at all\n[5] results with an error: The query type has already been set to select\nAll this except [1] looks highly counterintuitive for me. How can I get 'select count(*) from photos where photos.user_id = ?' ?\nThank you!\n. Maybe I have to be more precise.\n``` javascript\nUser = db.Model.extend({\n  tableName: 'users',\n  photos: function(){ return this.hasMany(Photo); }\n});\nnew User({id: 1}).fetch().then(function(user){\n  user.photos().fetch(); // [1]\n  user.photos().query(); // [2]\n  users.photos().query().count(''); // [3]\n  users.photos().query('count', ''); // [4]\n  users.photos().query('count', '*').fetch(); // [5]\n});\n```\n[1] works fine, query is 'select \"photos\".* from \"photos\" where \"photos\".\"user_id\" = ?'\n[2] 'select * from \"photos\"', relation information is lost\n[3] 'select count(*) from \"photos\"', relation information is lost\n[4] executes no query at all\n[5] results with an error: The query type has already been set to select\nAll this except [1] looks highly counterintuitive for me. How can I get 'select count(*) from photos where photos.user_id = ?' ?\nThank you!\n. So query is correct and I am fine with it but it incorrectry tries to use undefined photo.user_id field instead of photo.id\n. So query is correct and I am fine with it but it incorrectry tries to use undefined photo.user_id field instead of photo.id\n. Hell why?\nLook. \nSuppose, Alice wrote a very usefull library with some model and collection. And suppose, this collection has some custom logic bound to fetched event. Say it loads some additional data. And now she recognise that this fetched event is completely useless becouse it may be triggered and may be not. Poor Alice. All she can do is wrote to a documentation and to her blog \"if you load my great collection as a relation, then please trigger my custom logic manually\".\n. Oh, Im sory. Please excuse me if I was too rough.\nActually I just want to help Bookshelf to be excelent for everyone. So I spend my time trying to understand the code, writing a bunch of helpers, posting an issues after all. For free.\nI'll stop bothering you.\n. One more time: @bendrucker, please excuse me if my tone looks too harsh in english. This is only because my english is far from good. My sarcasm was no intended to insult you. It was just a reaction to closing an issue w/o any explanation. Of course you may handle any issues the way you prefer.\n. I'm convinced that we have to threat fetching a collection just as an another way to fetch a model. After all when I fetch a collection I got a model that was retrieved from database.\nI'm just inspecting and planing so I haven't REAL example. But @fritx have.\nAnd I can easily invent one.\nMaybe I want to implement a sort of id-based cache. So when model is fetched I put it to cache so I can take it back in future.\nOr maybe I want to write something to log when my special model is fetched.\nSimplest idea to implemment this is to hook into fetched event. But next in some point I'll use Collection to get a bunch of models and everething goes wrong. Btw, collection may be used implicitly if I load my model in context of relation.\n. I'm convinced that we have to threat fetching a collection just as an another way to fetch a model. After all when I fetch a collection I got a model that was retrieved from database.\nI'm just inspecting and planing so I haven't REAL example. But @fritx have.\nAnd I can easily invent one.\nMaybe I want to implement a sort of id-based cache. So when model is fetched I put it to cache so I can take it back in future.\nOr maybe I want to write something to log when my special model is fetched.\nSimplest idea to implemment this is to hook into fetched event. But next in some point I'll use Collection to get a bunch of models and everething goes wrong. Btw, collection may be used implicitly if I load my model in context of relation.\n. To summarize.\nMy main point is that Model is actually fetched from database even if it is loaded by Collection. So it looks logical if it will fire apropriate events.\nYour opposit point is that firing many events may lead to a performance problems.\nAm I correct? \nAnyway, it's worth to be explicitly documented.\nThank you!\n. To summarize.\nMy main point is that Model is actually fetched from database even if it is loaded by Collection. So it looks logical if it will fire apropriate events.\nYour opposit point is that firing many events may lead to a performance problems.\nAm I correct? \nAnyway, it's worth to be explicitly documented.\nThank you!\n. > There's performance issue, but also the general principle that it's way easier for you to add custom behavior than to strip out something we enforce.\nYes, that makes sense. Thank you!\n. > There's performance issue, but also the general principle that it's way easier for you to add custom behavior than to strip out something we enforce.\nYes, that makes sense. Thank you!\n. ",
    "shanehyde": "I have to agree, I had tried most of the others and this one fits the bill very well.  fast, works well.\nCould use a bit more examples of updating/inserting data with the various associations, but easy enough to read the source/test cases to figure most of it out.\n. I would be nice if there was another interface to setting a BelongsTo rather than using a create.  The reason is, that if a model has 2 BelongsTo associations that are NOT NULL, there is no way to create a child model using the associations.  \nIn the example above, if the models were \n```\nvar Project = bookshelfInstance.Model.extend({\n    tableName: 'projects',\n    tasks: function () {\n        return this.hasMany(Task)\n    }\n})\nvar User = bookshelfInstance.Model.extend({\n    tableName: 'users',\n    tasks: function () {\n        return this.hasMany(Task)\n    }\n})\nvar Task = bookshelfInstance.Model.extend({\n    tableName: 'tasks',\n    project: function () {\n        return this.belongsTo(Project)\n    },\n    assignee: function () {\n        return this.belongsTo(User)\n    }\n})\n```\nWe should be able to do something like...\nvar task = new Task({...});\ntask.assignee().set(user);\ntask.project().set(project);\ntask.save()\nFor the project I am working on, I had no choice but use the manual field setting as @tgriesser showed.\n. I have tested this a little more and I missed one thing.  If I use related('buildings').create(...) then the insert is not correctly associated with the Station, which is a definite bug.  Looks like this.relatedData is not being populated correctly when withRelated is being used.\nUsing related('buildings').create(...)\n``\n{ sql: 'insert intobuilding(createdAt,name,updatedAt`) values (?, ?, ?)',\n  bindings: \n   [ Tue Oct 01 2013 14:34:00 GMT+1000 (EST),\n     'Big test',\n     Tue Oct 01 2013 14:34:00 GMT+1000 (EST) ],\n  __cid: '__cid2' }\n```\nUsing buildings().create(...)\n{ sql: 'insert into `building` (`createdAt`, `name`, `station_id`, `updatedAt`) values (?, ?, ?, ?)',\n  bindings: \n   [ Tue Oct 01 2013 14:37:03 GMT+1000 (EST),\n     'Big test',\n     1,\n     Tue Oct 01 2013 14:37:03 GMT+1000 (EST) ],\n  __cid: '__cid4' }\n. ",
    "DiegoMax": "How about something like model.forge(oldModel.toJSON()), that should give u a cloned instance without ID.\n. sorry, forgot to remove the id prop, this should work: model.forge(_.omit(oldModel.toJSON(), 'id'))\n. and of course, you could also implement the method on your model, something like:\njavascript\nclone: function() {\n    return yourBaseModelInstance.forge(_.omit(this.toJSON(), 'id'));\n}\nI have not tested this code, but it should give you the idea.\n. I can't get my head over the \"javascript way\" of things yet hehe, a \"clone\" method as a \"class\" method is completely amazing for a C/Objective-C person like me, but now that i see it, as usual, it makes sense.\n. Well, i think that either i have faced a limitation, or i am doing something very wrong.\nI will show u my login() method inside of my User model:\n``` javascript\nlogin: function(req) {\n        var deferred = Q.defer();\n        var self = this;\n        // First we need to validate the API Access token (client token)\n        global.models.Client.forge().check(req.body.client_token)\n            .then(function(client){\n                if (client === null) {\n                    // Invalid client token\n                    var e = new Errors.Api(2006);\n                    return deferred.reject(e);\n                } else {\n                    // Valid token\n                    // Is this a user or a driver logging in ?\n                    var associations = [];\n                    var fields = [];\n                    var isUser = null;\n                    var modelClass = self;\n                    if (req.route.path === '/users/login') {\n                        isUser = true;\n                        fields = [\n                            \"email\", \"id\", \"type\"\n                        ];\n                        associations = [\n                            'Profile',\n                            {'ActiveBooking': function(qb) {\n                                qb.whereIn('status', ['STBookingInTransit'])\n                            }},\n                            'ActiveBooking.Driver',\n                            'ActiveBooking.Driver.Profile',\n                            'ActiveBooking.User',\n                            'ActiveBooking.Driver.Car'\n                        ];\n                    } else {\n                        isUser = false;\n                        modelClass = global.models.Driver.forge();\n                        //TODO: Check with roberto if we really need the user object in here ?\n                        associations = [\n                            'Profile',\n                            {'ActiveBooking': function(qb) {\n                                qb.whereIn('status', ['STBookingInTransit'])\n                        }},\n                        'ActiveBooking.Driver',\n                        'ActiveBooking.User',\n                        'ActiveBooking.User.Profile',\n                    ]\n                }\n                modelClass.set({\n                    'email': req.body.email,\n                    'password': STAuth.hash(req.body.password)\n                })\n                    .fetch({\n                        withRelated: associations,\n                        columns: fields\n                    })\n                    .then(function(user){\n                        if (user === null) {\n                            // Invalid credentials\n                            var e = new Errors.Api(2001);\n                            return deferred.reject(e);\n                        } else {\n                            user.save({\n                                token: uuid.v4(),\n                                app_version: req.headers['user-agent'],\n                                api_level: client.get('api_level'),\n                                platform: client.get('platform')\n                            }).then(function(user){\n                                    if (isUser === true && user.get('type') === 'STUserTypeDriver') {\n                                        var e = new Errors.Api(2007);\n                                        return deferred.reject(e);\n                                    } else if (isUser === false && user.get('type') === 'STUserTypeUser') {\n                                        var e = new Errors.Api(2007);\n                                        return deferred.reject(e);\n                                    }\n                                    user.isUser = isUser;\n                                    deferred.resolve(user);\n                                })\n                        }\n\n                    })\n            }\n        })\n    return deferred.promise;\n}\n\n```\nIf i set the \"columns\" property on the user model (as on the above code), the promise is not even fulfilled (then never called), and by doing some debug i can see the underlying queries being generated like this:\n{ sql: 'select \"email\", \"id\", \"type\" from \"users\" where \"email\" = ? and \"password\" = ? limit 1',\n  bindings: \n   [ 'diego@massanti.com',\n     'e3881addf9d7d750fed9e4bd7620796eaa1374ec' ],\n  __cid: '__cid4' }\n{ sql: 'select \"email\", \"id\", \"type\" from \"profiles\" where \"user_id\" in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\n{ sql: 'select \"email\", \"id\", \"type\" from \"bookings\" where \"status\" in (?) and \"user_id\" in (?)',\n  bindings: [ 'STBookingInTransit', 1 ],\n  __cid: '__cid3' }\nAs you can see, the query builder is using the columns property for the base model AND for every one of the related tables.\nIs this a bug, a limitation or am i doing something really wrong ??\nAlso, if this is a limitation, is there any workaround for this other than manually building all the queries ?\nThanks in advance\n// Diego\n. Thanks for the tip about the promises, i was SURE that i was doing that kind of wrong, even if it worked because of the fact that i was nesting 2 levels of promises, again, im still kind of new to this platform and im getting used to it.\nThanks a lot for the tip and for your time!\n. Confirmed, it works :D thanks!\n. Yah it makes complete sense and honestly i didn't even know that there was a plugin system when i wrote this ticket...\nBut considering that i ended up creating a \"base\" model and then extending all my models from there, it is really simple to implement this feature now.\nYou will have to deal with my (maybe) nonsense questions for some time while i get to know this library. :)\nThanks.\n// Diego\n. @tgriesser et all:\n I would like to have your opinion about some caching that i have implemented on this API im working on.\nIt is certainly working amazingly good so far, but i just want to be sure that the way i did this is the way it is supposed to be done\n``` javascript\nfetch: function (options) {\n    var methodArgs = arguments;\n    var self = this;\n    var newPromise = When.defer();\n    if (.keys(self.attributes).length == 1 && .has(self.attributes, 'token')) {\n      // One of the most hammered SQL queries is the one that validates the user token\n      // It is hammered ever 10 seconds by every running application on the system\n      // For this reason, this specific query (select from users where token) result\n      // is cached globally for 120 seconds and only destroyed if the user logs-in again.\n  // If the query is by token, lets try the cache first\n  global.Cache.get(self.cachePrefix + self.attributes.token, function (err, value) {\n    if (!err && !_.isEmpty(value)) {\n      //console.log(\"userByToken cache hit!\");\n      return newPromise.resolve(value[self.cachePrefix + self.attributes.token]);\n    } else {\n      global.models.Base.prototype.fetch.apply(self, methodArgs)\n        .then(function (user) {\n          if (user === null) return newPromise.resolve(user); // if no user is found, we dont cache anything.\n          global.Cache.set(self.cachePrefix + self.attributes.token, user, function (err, success) {\n            if (!err && success) {\n              //console.log(\"Caching user...\");\n              newPromise.resolve(user);\n            } else {\n              newPromise.reject(err);\n            }\n          })\n        })\n    }\n  })\n} else {\n  // if this is not a query by token, lest just query the DB\n  global.models.Base.prototype.fetch.apply(self, methodArgs)\n    .then(function (user) {\n      newPromise.resolve(user);\n    })\n}\nreturn newPromise.promise;\n\n}\n```\nBasically, my questions would be:\n- Is there a better way to check that the query is select * from users where token = ? other than the nasty\n  if (_.keys(self.attributes).length == 1 && _.has(self.attributes, 'token'))\n- Is fetch() the best place to do this ?\nThanks for your time.\n// Diego\n. Thanks, and sorry to reopen this, but since you just mentioned that there is an effort to focus more on community, i would like to suggest that a forum or something where users and developers can interact (outside of this issue tracker) would be great. I personally feel that im spamming the issue tracker every time i want to ask something that might not be a specific issue, like on this case, but i don't really know of any other place where to reach the devs or collaborators. If i can help you with anything in order to make that happen, from hosting to man hours in order to set it up and what not, please let me know. I would happily contribute to this project with anything i can. Thanks for the quick reply! I will send the PR in a few days after i write some tests and clean the code.\n. Well, this is the way i see it:\n- Syntax Highlighting: available in pretty much every forum software, even as part of the core or as a plugin.\n- Notifications, also available in many flavors.\n- Same for Markdown (standard, not GHFM).\nDiscourse (http://discourse.org) is the one i prefer, nevertheless, the options are endless.\nAs for the integration with GitHub issues, it should be trivial to write a simple plugin that allows people to place links to issues by typing something like #, have a routine to check if the issue exists and replace with the proper  element and the issue name.\nOn top of that, Discourse supports OAuth via GitHub, which should also be a lock for spammers as you could set it up so that a github account is the only way to login.\nJust ranting here, but i think the whole project would benefit a lot with a message board for many reasons.\n// Diego\n. @tgriesser you mean that you are writing your own message board using Bookshelf itself ? Thats a great idea if thats what you meant!!\n. ",
    "darethas": "Just as a general inquiry --  Is the use of this ORM possible with AngularJS?\n. Oh great. I am looking to drop this in, instead of Mongoose. I ran into headaches with Mongoose (albeit probably mainly due to my lack of knowledge) with populations and trying to do relationships. This has more of an active-recordish feel to it, and just plain looks easier.\n. @vacay care to share your experience?\n. ",
    "marcoschicote": "Hi @demisx, I quite new to bookshelf and I only used it for one small example. My requirements are to be able to save a record, fetch a lot of records and save some of them back with a few minor modifications (one by one). I tried bookshelf and asked a couple of questions in Github. I had a really nice experience and the project maintainers answered gently and fast. \nHowever, I will be moving away from bookshelf for now as there's no support for pagination. One can bypass this and query using knex but the resulting collection will not be a collection of models. For me, for now, that's a deal breaker. But I will definitely keep track of this project as it sounds quite interesting. \n. @tgriesser this is what I mean, really fast at answering questions or complaints.\nThe thing is that if I do that and add\n.then(function(collection){ collection.at(0).product_id })\nit returns undefined. Am I missing something else? If I inspect the collection and go models[0].attributes.product_id I get the correct value, that's why I thought the model was not being built.\n. Thanks @bendrucker. Is there a way I can access the attributes using the dot notation? I thought about virtuals but if the attribute and the virtual are named the same, I get a loop.\n. Thanks for all the help @bendrucker \n. +1\n. ",
    "SusanthCom": "@DiegoMax are you still using BookShelf ? How is your experience so far ?\nAm yet to make a selection between BookShelfJS / SequelizeJS. Landed this page from a google search. Nice to see many Participants here. \n@tgriesser your tips / comments / suggestions gives confidence on this ORM.\nNice to see this Open even after 2 years :+1: \n\n\nIs there any User List list for BookShelfJS similar to this Users List of Backbone\nIs there a list that highlights,  Why BookShelfJS similar to this Why Backbone\n\nThe popular Ghost :smiley:  is depending on \"bookshelf\": \"0.7.9\" :+1: \n\nSpecial thanks to @tgriesser  and all team members for making such a beautiful Software.\n:heart:  Keep Rocking :heart:\nUpdate :\nfor Dependent Repositories and other detailed info, scroll down to bottom of this link.\n. @demisx  Thanks for fast response  :+1:  This looks like the right choice :smile: \n. ",
    "daslicht": "Is there somewhere a comparison between  BookShelfJS / SequelizeJS. ?\n. Can you do queries like this (psudocode)\nvar friend =  find( 'friend', 'name = john');  // find friend john\nand later in the code or even in the  template get related objects like this:\noutput:   friend.name ?\nor even : \n```\nvar friends =  findAll( 'friend''); \niterate over friends object, maybe even in template:\nfor each friends as friend{\n        output:  friend.name;\n}\n```\n. ",
    "CodisRedding": "How about now, what does the comparison look like these days?\n. ",
    "duffytilleman": "Can we get some documentation on the homepage about attaching related models?  I'd be happy to contribute it, but I've been using bookshelf for about six months now and it's still not clear to me what the 'normal' way to attach models for each relation type is.\n. +1 for this.  My workaround is to add an event handler in the Model prototype's initializer:\nBookshelf.Model.prototype.initialize = function() {\n  this.on('fetched', function(model) {\n    model._fetched = true;\n  });\n};\nThe issue with this, in addition to being hacky, is that I'd love this to apply when the model is fetched via a collection, or a relation.\n. ",
    "davis": "@tgriesser Isn't that the most important part about relational mapping?\n. @tgriesser Isn't that the most important part about relational mapping?\n. ",
    "marshals": "What's the status on this?  I'm trying to do the same thing using attach and it doesn't appear that the attach method is there. Thanks.\n. @tgriesser Sorry, I just realized that my relationship isn't a \"belongsToMany\" and that's what attach requires.  It's a \"hasMany\" instead.  Is \"create\" the proper way to create these?  Something like the following?  Thanks for your help.\n```\nvar site = Site.forge({id: 1});\nvar admin1 = Admin.forge({username: 'user1', password: 'test'});\nvar admin2 = Admin.forge({username: 'user2', password: 'test'});\nPromise.all([site.save()])\n  .then(function() {\n    return Promise.all([\n      site.admins().create([admin1, admin2])\n    ]);\n  })\n```\n. ",
    "light24bulbs": "Hmm. Wouldn't it be better if there was something built into bookshelf that could do that?  For example:\njavascript\nsite.related('model').add(modelInstance).then(doSomething)\nor \njavascript\nsite.related('model').add([instance1, instance2])\n. Hmm. Wouldn't it be better if there was something built into bookshelf that could do that?  For example:\njavascript\nsite.related('model').add(modelInstance).then(doSomething)\nor \njavascript\nsite.related('model').add([instance1, instance2])\n. Any progress on this?  Attaching relations still seems clunky and create doesn't seem to apply for two existing models.  Is my suggestion above possible?  This is particularly true for situations where you have a join table that may not even have its own model, forcing me to use a knex operation, like:\ncoffeescript\n                        db.knex\n                        .returning('id')\n                        .insert({user_id: user.get('id'), business_id: req.body.business_id})\n                        .into('businesses_users')\n                        .then (relation_id) ->\nOr maybe there is an idiomatic way to do this and I am just not aware of it.\n. Yes, that is how I understand it. \nIn my opinion there should absolutely be a function \"set\" that can attach any model to any other model, for any type of relation.  Even if they both already are saved models. \n. Wow, thats cool!  Is that mentioned in the relevant section of the docs?  It's an extremely common use case.\n. Wow, thats cool!  Is that mentioned in the relevant section of the docs?  It's an extremely common use case.\n. I have a database model\ncoffeescript\n{\nname: 'db value'\n}\nAnd I would like it to jsonify to \ncoffeescript\n{\nname: 'virtual value'\n}\nBy doing something like this in the model:\ncoffeescript\nvirtuals: {\n    name: () -> \n         \"virtual name\"\nBut I'm aware this could create some problems by overriding the default getter on the model.  I'm curious if there is an idiomatic way to override a property other than wrapping the toJSON function.\n. Hi, @rhys-vdw \nUpdating fetch to use only the ID seems far more breaking to me.  For instance, my code frequently does \nModel.forge(anAttribute: 'aValue').fetch() \nas a way to query by parameters.  I think fetch works well and that it's behavior isn't so unexpected.  I would rather have a separate method refresh or reload to handle this.  I don't consider it to be API breaking to introduce a new method.  I think it is more breaking to change the behavior of an existing method.\n. Hi, @rhys-vdw \nUpdating fetch to use only the ID seems far more breaking to me.  For instance, my code frequently does \nModel.forge(anAttribute: 'aValue').fetch() \nas a way to query by parameters.  I think fetch works well and that it's behavior isn't so unexpected.  I would rather have a separate method refresh or reload to handle this.  I don't consider it to be API breaking to introduce a new method.  I think it is more breaking to change the behavior of an existing method.\n. Oh. \nHmm, well, In my opinion, that is a more unexpected behavior than it was before, because before it was constant.  You've taken two logically separate functions and combined them into one method which magically switches between them.\nAnd believe it or not, it actually does break some of my code and possibly other's code as well.  Some of my code does:\nModel.forge(id: 21, anAttribute: 'aValue').fetch()\nThough this could obviously be rewritten, I would still argue for introducing a new method refresh as it is more clear and gives the user a choice of which functionality they want. Could you explain how a new method would be API breaking where changing an existing method is not?  \nIf you're tied to this functionality, maybe checking isNew when deciding to use the id or not would work well.\nBut hey, I love the lib otherwise.  You guys are doing something right :)\nThank you for all the hard work which makes my life easier!\n@tgriesser \n@ricardograca \n. Oh. \nHmm, well, In my opinion, that is a more unexpected behavior than it was before, because before it was constant.  You've taken two logically separate functions and combined them into one method which magically switches between them.\nAnd believe it or not, it actually does break some of my code and possibly other's code as well.  Some of my code does:\nModel.forge(id: 21, anAttribute: 'aValue').fetch()\nThough this could obviously be rewritten, I would still argue for introducing a new method refresh as it is more clear and gives the user a choice of which functionality they want. Could you explain how a new method would be API breaking where changing an existing method is not?  \nIf you're tied to this functionality, maybe checking isNew when deciding to use the id or not would work well.\nBut hey, I love the lib otherwise.  You guys are doing something right :)\nThank you for all the hard work which makes my life easier!\n@tgriesser \n@ricardograca \n. Awesome!  Just what I needed.  Thank you!\n. Awesome!  Just what I needed.  Thank you!\n. ",
    "dvp0": "Can there be a way to destroy model with all related .hasOne and .hasMany models ? I know it is silly but could be helpful ! \nIf a USER has \none PROFILE, (hasOne)\none AUTHORIZATION (hasOne)\ntwo ADDRESSES (hasMany)\none COMPANY (belongsTo)\n@tgriesser  What is your recommended way to delete USER with its PROFILE, AUTH, and ADDRESSES  ?\n. @tgriesser This functionality seems very vital for large data objects. Would be really helpful if we can get this built in bookshelf !\n. @tgriesser This functionality seems very vital for large data objects. Would be really helpful if we can get this built in bookshelf !\n. @absolux Thank you so much for the response. I tried what you said, the query knex executes (from the logs), works fine when I manually run on database. But when ran through Bookshelf/knex, it throws this error.\n``` javascript\nDebug: handler, error\n    {\"msec\":406.71834897994995,\"error\":\"Internal error: Cannot read property 'parentFk' of undefined\",\"data\":{\"isBoom\":true,\"isServer\":true,\"data\":null,\"output\":{\"statusCode\":500,\"payload\":{\"statusCode\":500,\"error\":\"Internal Server Error\",\"message\":\"An internal server error occurred\"},\"headers\":{}},\"isDeveloperError\":true}}\nDebug: internal, implementation, error\n    TypeError: Cannot read property 'parentFk' of undefined\n    at EagerRelation.eagerFetch (/Users/dev/d_projects/rx/rx-api/node_modules/bookshelf/lib/eager.js:84:22)\n    at EagerRelation. (/Users/dev/d_projects/rx/rx-api/node_modules/bookshelf/lib/base/eager.js:74:33)\n    at EagerRelation.tryCatcher (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/util.js:26:23)\n    at EagerRelation.fetch (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/method.js:15:34)\n    at _handleEager (/Users/dev/d_projects/rx/rx-api/node_modules/bookshelf/lib/model.js:1351:56)\n    at null. (/Users/dev/d_projects/rx/rx-api/node_modules/bookshelf/lib/model.js:685:21)\n    at Object.tapHandler (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/finally.js:63:31)\n    at bound (domain.js:287:14)\n    at Object.runBound (domain.js:300:12)\n    at Object.tryCatcher (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/util.js:26:23)\n    at Promise._settlePromiseFromHandler (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/promise.js:507:31)\n    at Promise._settlePromiseAt (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/promise.js:581:18)\n    at Promise._settlePromises (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/promise.js:697:14)\n    at Async._drainQueue (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/async.js:123:16)\n    at Async._drainQueues (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/async.js:133:10)\n    at Immediate.Async.drainQueues (/Users/dev/d_projects/rx/rx-api/node_modules/bluebird/js/main/async.js:15:14)\n    at Immediate.wrapped [as _onImmediate] (/Users/dev/d_projects/rx/rx-api/node_modules/newrelic/lib/transaction/tracer/index.js:161:28)\n    at processImmediate [as _immediateCallback] (timers.js:383:17)\n<<< RESPONDING < /users/my < 2016-08-15T10:00:14-04:00 (took 2091) < 1471269612410:Dev-Patels-MacBook-Pro.local:87451:irw3x243:10001\n|\n  knex:client acquired connection from pool: __knexUid5 +145ms\n{ method: 'select',\n  options: {},\n  timeout: false,\n  cancelOnTimeout: false,\n  bindings: [ '28' ],\n  __knexQueryUid: '7e392da5-867a-43aa-9104-d37812c6235e',\n  sql: 'select \"permissions\". from \"permissions\" inner join \"privileges\" on \"permissions\".\"id\" = \"privileges\".\"permission_id\" inner join \"roles_users\" on \"privileges\".\"role_id\" = \"roles_users\".\"role_id\" where \"roles_users\".\"user_id\" = ?' }\n  knex:query select \"permissions\". from \"permissions\" inner join \"privileges\" on \"permissions\".\"id\" = \"privileges\".\"permission_id\" inner join \"roles_users\" on \"privileges\".\"role_id\" = \"roles_users\".\"role_id\" where \"roles_users\".\"user_id\" = ? +3ms\n  knex:client releasing connection to pool: __knexUid5 +317ms\n```\n. Aaah, I can live with that. You are the man @absolux, thanks \ud83d\udc4d\ud83c\udffc\n. ",
    "syzer": "+1\n. We have Person, PersonTasks, Task, tables. (many to many)\nsite.related('model').add(modelInstance).then(doSomething) add this extra model but you cannot save them.\nif you call create(instead add) then you get to store relation with related model, but it calls insert Always.\nSo you need to catch if if this relation was stored earlier.\nLost 5 hours on that :(\n. ",
    "kichooo": "+1\n. ",
    "juanimarchese": "Hi guys! Doing site.related('model').create doesn't work anymore. How can I associate a one to one relationship?\n. Hi guys! Doing site.related('model').create doesn't work anymore. How can I associate a one to one relationship?\n. ",
    "pschuegr": "So this part of the docs is misleading then, I guess, because owner is always going to be at least equal to {}.  Correct?  Is there an easier way to tell if owner actually exists than checking owner.attributes?\nvar owner = book.related('owner');\n  if (owner) {\n    console.log(owner.toJSON());\n  }\n. It's under http://bookshelfjs.org/#Model-relation-types.  I can edit this and do a PR if you're in agreement.  Switch to using owner.id?\n. +1.  I'm missing the ability to use hasOne/through.  Is there a workaround which lets you still retrieve\nmodel.fetch({withRelated: ['hasOneThroughRelation']})\n?\n. Fantastic response, thank you!\n. Ok thanks - I came to this question because I was trying to figure out how to connect two models which both have a belongsTo relation with a third model and I was trying to figure out whether it was possible to use hasMany/through, but I wasn't having any luck.  I ended up just loading them eagerly with the dot syntax ({withRelated: ['thirdModel', 'thirdModel.secondModels']}).  It's not ideal, but it works great.\nThanks!\n. Sure.  If I remember correctly, this is basically the crux of it:\n```\nnew Model({id: 1}).fetch()\n.then(function(instance) {\n  doSomething()\n  .then(function() {\n    return instance.fetch();\n  })\n  .then(function(final) {\n    //final == null!\n  })\n})\n```\nI guess it makes sense that if doSomething changed anything on the instance (or in the database), the select would fail because it would be using all the fields as selection criteria.  So, this actually might not be a bug, but the difference in behaviour  between mySQL and sqlite3 indicates something off somewhere.\nI was essentially trying to use the fetch as a refresh call - that was the original motivation for this.\n. Sure.  If I remember correctly, this is basically the crux of it:\n```\nnew Model({id: 1}).fetch()\n.then(function(instance) {\n  doSomething()\n  .then(function() {\n    return instance.fetch();\n  })\n  .then(function(final) {\n    //final == null!\n  })\n})\n```\nI guess it makes sense that if doSomething changed anything on the instance (or in the database), the select would fail because it would be using all the fields as selection criteria.  So, this actually might not be a bug, but the difference in behaviour  between mySQL and sqlite3 indicates something off somewhere.\nI was essentially trying to use the fetch as a refresh call - that was the original motivation for this.\n. ",
    "asonnenschein": "Howdy!  I can't seem to get the above code sample to work.  Returning entire records through my withRelated list works fine, but when I try to specify the actual columns to return, I don't get any error messages or anything - it just returns an empty JSON object.\nHere's a code sample:\njs\n      if (req.params.submission === 'all' && req.params.file === 'all') {\n        new db.SubmissionsFiles()\n          .fetchAll({\n            withRelated: [{\n              submission: function (qb) {\n                qb.column('name', 'title', 'likes', 'dislikes', 'votes');\n              },\n              submissionThumbnail: function (qb) {\n                qb.column('directory', 'name');\n              }\n            }],\n            columns: ['directory', 'original_name', 'name', 'caption']\n          })\n          .then(function (file) {\n            console.log(file.toJSON());\n            return res.status(200).send(file);\n          })\n          .catch(function (error) {\n            return res.status(404).send(\"Could not get file!\");\n          })\n        ;\nWhich returns objects like this:\njs\n [ { directory: 'uploads/697aa9b0ad5b880a064f9f196b00a8c3.gif',\n    original_name: 'VORmrSS.gif',\n    name: '697aa9b0ad5b880a064f9f196b00a8c3.gif',\n    caption: 'This is a caption.',\n    submissionThumbnail: {},\n    submission: {} },\n  { directory: 'uploads/39e086ed32de8d56fd0aaca6cc3b25a8.jpg',\n    original_name: 'VcglMZK.jpg',\n    name: '39e086ed32de8d56fd0aaca6cc3b25a8.jpg',\n    caption: 'This is a caption.',\n    submissionThumbnail: {},\n    submission: {} },\n  { directory: 'uploads/c9ed5f2b91da79c3746d8d7b0785570f.jpg',\n    original_name: 'Vwzl3al.jpg',\n    name: 'c9ed5f2b91da79c3746d8d7b0785570f.jpg',\n    caption: 'This is a caption.',\n    submissionThumbnail: {},\n    submission: {} } ]\nIf it helps at all, here are my models that are being called in my fetchAll() function:\n``` js\nSubmissions = bookshelf.Model.extend({\n  tableName: 'submissions',\n  idAttribute: 'submissions_id',\n  user: function () {\n    return this.belongsTo(Users, 'users_id');\n  },\n  submissionFile: function () {\n    return this.hasMany(SubmissionsFiles, 'submissions_files_id');\n  },\n  submissionThumbnail: function () {\n    return this.hasMany(SubmissionsThumbnails, 'submissions_thumbnails_id');\n  },\n});\nSubmissionsFiles = bookshelf.Model.extend({\n  tableName: 'submissions_files',\n  idAttribute: 'submissions_files_id',\n  user: function () {\n    return this.belongsTo(Users, 'users_id');\n  },\n  submission: function () {\n    return this.belongsTo(Submissions, 'submissions_id');\n  },\n  submissionThumbnail: function () {\n    return this.hasOne(SubmissionsThumbnails, 'submissions_thumbnails_id');\n  },\n});\nSubmissionsThumbnails = bookshelf.Model.extend({\n  tableName: 'submissions_thumbnails',\n  idAttribute: 'submissions_thumbnails_id',\n  user: function () {\n    return this.belongsTo(Users, 'users_id');\n  },\n  submission: function () {\n    return this.belongsTo(Submissions, 'submissions_id');\n  },\n  submissionFile: function () {\n    return this.belongsTo(SubmissionsFiles, 'submissions_files_id');\n  },\n});\n```\nAny ideas on what I'm doing wrong here?  I'm using bookshelf.js version 0.8.1 and knex version 0.8.6.\n. @ricardograca Sure thing.  The SQL generated for my first withRelated function is: \n'select \"name\", \"title\", \"likes\", \"dislikes\", \"votes\" from \"submissions\"'\nAnd the SQL generated for the second function is:\n'select \"directory\", \"name\" from \"submissions_thumbnails\"'\nI'm 100% positive that these columns exist and that there is data in them.  When I specify only the table name in the withRelated list, it works properly.  Also, pasting the above queries into a psql prompt (I'm running PostgreSQL) works properly.\n. @ricardograca Whoops, forgot about that part!  I'm invoking this function:\njavascript\n      new db.Tutorials()\n        .fetchAll({withRelated: 'tags'})\n        .then(function (tutorials) {\n          return res.render('tutorials.html', {\n            tutorials: tutorials.toJSON()\n          });\n        })\n        .catch(function (error) {\n          return res.status(500);\n        })\n      ;\n. Looking at my database logs (I'm using PostgreSQL, btw), it looks like the query isn't being constructed correctly: \nERROR:  column tutorials_tags.tag_tags_id does not exist at character 252\nIt should be looking for 'tutorials_tags.tags_id'.\n. I'm using .through() because I want the records in my tutorials and tags tables to be unique.  A Tutorial might be associated with multiple tags, and a tag might be associated with multiple tutorials.  The tutorials_tags table is used for mapping that relationship.\nYour suggestion produces the same error I'm getting when I use .through():\nERROR:  column tutorials_tags.tag_tags_id does not exist at character 164\n. I'm using .through() because I want the records in my tutorials and tags tables to be unique.  A Tutorial might be associated with multiple tags, and a tag might be associated with multiple tutorials.  The tutorials_tags table is used for mapping that relationship.\nYour suggestion produces the same error I'm getting when I use .through():\nERROR:  column tutorials_tags.tag_tags_id does not exist at character 164\n. OK, so this .hasMany() call almost does it:\njavascript\nTutorials = bookshelf.Model.extend({\n  tableName: 'tutorials',\n  idAttribute: 'tutorials_id',\n  user: function () {\n    return this.belongsTo(Users, 'users_id');\n  },\n  tags: function () {\n    return this.hasMany(Tags, 'tutorials_id').through(TutorialsTags, 'tags_id');\n  }\n});\nWhich produces this query:\n{ method: 'select',\n  options: {},\n  bindings: [],\n  sql: 'select \"tutorials\".* from \"tutorials\"' }\n{ method: 'select',\n  options: {},\n  bindings: [ 8, 9 ],\n  sql: 'select \"tags\".*, \"tutorials_tags\".\"tutorials_tags_id\" as \"_pivot_tutorials_tags_id\", \"tutorials_tags\".\"tutorials_id\" as \"_pivot_tutorials_id\" from \"tags\" inner join \"tutorials_tags\" on \"tutorials_tags\".\"tutorials_tags_id\" = \"tags\".\"tags_id\" where \"tutorials_tags\".\"tutorials_id\" in (?, ?)' }\nExcept the inner join should be done on tutorials_tags.tags_id instead of tutorials_tags.tutorials_tags_id.\n. OK, so this .hasMany() call almost does it:\njavascript\nTutorials = bookshelf.Model.extend({\n  tableName: 'tutorials',\n  idAttribute: 'tutorials_id',\n  user: function () {\n    return this.belongsTo(Users, 'users_id');\n  },\n  tags: function () {\n    return this.hasMany(Tags, 'tutorials_id').through(TutorialsTags, 'tags_id');\n  }\n});\nWhich produces this query:\n{ method: 'select',\n  options: {},\n  bindings: [],\n  sql: 'select \"tutorials\".* from \"tutorials\"' }\n{ method: 'select',\n  options: {},\n  bindings: [ 8, 9 ],\n  sql: 'select \"tags\".*, \"tutorials_tags\".\"tutorials_tags_id\" as \"_pivot_tutorials_tags_id\", \"tutorials_tags\".\"tutorials_id\" as \"_pivot_tutorials_id\" from \"tags\" inner join \"tutorials_tags\" on \"tutorials_tags\".\"tutorials_tags_id\" = \"tags\".\"tags_id\" where \"tutorials_tags\".\"tutorials_id\" in (?, ?)' }\nExcept the inner join should be done on tutorials_tags.tags_id instead of tutorials_tags.tutorials_tags_id.\n. OK, figured it out.  Looks like I should've been using a .belongsToMany() method in addition to a .through() method where I specify both the [throughForeignKey] and [otherKey] inputs:\njavascript\nTutorials = bookshelf.Model.extend({\n  tableName: 'tutorials',\n  idAttribute: 'tutorials_id',\n  user: function () {\n    return this.belongsTo(Users, 'users_id');\n  },\n  tags: function () {\n    return this.belongsToMany(Tags, 'tutorials_id').through(TutorialsTags, ['tutorials_id'], ['tags_id']);\n  }\n});\n. OK, figured it out.  Looks like I should've been using a .belongsToMany() method in addition to a .through() method where I specify both the [throughForeignKey] and [otherKey] inputs:\njavascript\nTutorials = bookshelf.Model.extend({\n  tableName: 'tutorials',\n  idAttribute: 'tutorials_id',\n  user: function () {\n    return this.belongsTo(Users, 'users_id');\n  },\n  tags: function () {\n    return this.belongsToMany(Tags, 'tutorials_id').through(TutorialsTags, ['tutorials_id'], ['tags_id']);\n  }\n});\n. ",
    "amanmohla": "Is this fixed? I am still facing the same issue with v0.9.1\n. Just checking if this is implemented now?\n. javascript\ngetTableColumns: function () {\n        var tableName = this.getTableName(),\n            schemaName = this.getSchemaName();\n        return thBookshelf.knex\n            .raw('SELECT column_name FROM information_schema.columns WHERE table_schema = \\'' + schemaName + '\\' AND table_name = \\'' +\n                tableName + '\\'')\n            .then(function (result) {\n                var columns = _.map(result.rows, function (row) {\n                    return row['column_name'];\n                });\n                return promise.resolve(columns);\n            });\n    }\nAt the moment I am using something like this to fetch columns, but was wondering if there is something already implemented.\n. ",
    "johngroves": "It is possible to accomplish this using .pick() from underscore:\nModel.related('relatedModel').pick(['columns','you','would','like']);\n. ",
    "howardmann": "Hi there I am also facing the same issue when trying to specify withRelated columns for a hasMany relationship. The solution provided works for a belongsTo relationship but hasMany returns an empty array.. Hi there I am also facing the same issue when trying to specify withRelated columns for a hasMany relationship. The solution provided works for a belongsTo relationship but hasMany returns an empty array.. ",
    "roackb2": "Hi there, I'm also facing the exact same issue as @howardmann have, I can't use the select clause on an hasMany relationships, any updates here?. Hi there, I'm also facing the exact same issue as @howardmann have, I can't use the select clause on an hasMany relationships, any updates here?. ",
    "Matrixbirds": "@gsdnano  i changed qb.column to qb.columns and that works.\nbookshelf version 0.10.4\njavascript\n.fetch({\n   withRelated: [\n     {'devices': qb => qb.columns('id', 'device_name')}\n   ],\n   columns: ['device_id'] \n}) \nthat works under this schema definination\n```\ndevice:\nid primary key\nrelations:\ndevice_id: // for device primary key\nrelations = bookshelf.Model.extend({\n    device () {\n        return this.belongsTo(device, 'device_id', 'id')\n    }\n})\n```\n. I got same error in my case i used virtuals name override my database column name.\njust rename ur virtuals name. @ricardograca i want to perform validation before insert by using invoke constructor#query method, but it throw error when insert fields contained undefined value. ",
    "mxgrn": "Oh, that was it, my bad! And thanks for the prompt response!\n. ",
    "felipefac": "Just found out that there is using knex.\nBookshelf.knex.raw(query).then(callback);\n. I was trying to pass a db function as a parameter like:\nmodel.query(\"where\", \"DATE(field)\", \"=\", \"2013-01-01\").fetch....\nThe problem is the DATE(field) was going quoted to the database and i could not find a way to remove them.\nThen i tried\nmodel.query(\"where\", Bookshelf.knex.raw(\"DATE(field)\"I, \"=\", \"2013-01-01\").then .....\nBut the select ignored the last two parameters after the raw function was called and \nwas returning only this:\n'Select * from table where Date(field)'\nAfter some time i decided to use a raw SQL. I should have reported a issue yesterday.\nIs it a issue right?\nBTW great work on bookshelf congratulations.\n. I tried the method you described. The thing is the query returned was incomplete.\nFor the command that you gave it returns:\n'Select  * from table where Date(field)'  and nothing else.\n. ",
    "samsaga2": "I was writing a better example and you're right. The bindings: [ undefined ] means my keys are wrong.\nBut my real problem it's that Bookshelf doesn't support composited keys. Something like:\n``` javascript\nvar Table1 = db.Model.extend({\n  tableName: 'table1',\n  idAttribute: ['key1', 'key2']\n});\nvar Table2 = db.Model.extend({\n  tableName: 'table2',\n  test: function() {\n    return this.belongsTo(Table1, ['key1_id', 'key2_id']);\n  }\n});\n```\nThanks for your help.\n. ",
    "FabricioFFC": "@tgriesser \nIn my case I have a object called Customer, that has many hasMany associations. These associations are stored in my model as arrays. Follows an example below:\n\nname: 'Customer X',\nemail: 'customerx@gmail.com',\nbankAccounts: [{\n  agency: '0110',\n  accountNumber: '01111'\n  ...\n}]\n\nWhat is the best way to save my main object (Customer) and it's relations? I dig into the docs and the Ghost code, but I didn't found any simple way to save the object with all data associated.\n. @tgriesser ok. Thank you!\n. In my case the foreign key isn't my primary key, and Bookshelf tries to bind my primary key value instead of to bind my foreign key value.\n```\nCustomer = Bookshelf.Model.extend({\n  tableName: 'customers',\n  assets: function () {\n    return this.hasMany(Assets, [\"customersDocumentNumber\"]);\n  }\n  ...\nAsset = Bookshelf.Model.extend({\n  tableName: 'assets',\n  customers: function () {\n    return this.belongsTo(Customer, \"documentNumber\");\n  }\n});\n```\nThe correct behavior should query the assets table with the customer documentNumber, instead of the customer id.\n{ sql: 'select \"customers\".* from \"customers\" where \"customers\".\"id\" = ? limit 1',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\n{ sql: 'select \"assets\".* from \"assets\" where \"assets\".\"customersDocumentNumber\" in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid1' }\n. In my case the foreign key isn't my primary key, and Bookshelf tries to bind my primary key value instead of to bind my foreign key value.\n```\nCustomer = Bookshelf.Model.extend({\n  tableName: 'customers',\n  assets: function () {\n    return this.hasMany(Assets, [\"customersDocumentNumber\"]);\n  }\n  ...\nAsset = Bookshelf.Model.extend({\n  tableName: 'assets',\n  customers: function () {\n    return this.belongsTo(Customer, \"documentNumber\");\n  }\n});\n```\nThe correct behavior should query the assets table with the customer documentNumber, instead of the customer id.\n{ sql: 'select \"customers\".* from \"customers\" where \"customers\".\"id\" = ? limit 1',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\n{ sql: 'select \"assets\".* from \"assets\" where \"assets\".\"customersDocumentNumber\" in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid1' }\n. Thank you very much! :)\n. Thank you very much! :)\n. @tgriesser using exec returns  \n. @tgriesser using exec returns  \n. @tgriesser now it worked great! thank you again!\n. @tgriesser now it worked great! thank you again!\n. @tgriesser one more thing... when my callback is executed the transaction is over, right? I'm asking, because when my callback contains a save (to save another customer), I receive the constraint error about the primary key (autoincrement), because Postgres is trying to insert a new customer with the same id from the previous.\n. @tgriesser one more thing... when my callback is executed the transaction is over, right? I'm asking, because when my callback contains a save (to save another customer), I receive the constraint error about the primary key (autoincrement), because Postgres is trying to insert a new customer with the same id from the previous.\n. @tgriesser the custom keys feature is already available? I read the changelog and didn't find it. \n. ",
    "willrstern": "Eric Clemmons came up with https://github.com/ericclemmons/bookshelf-manager as a way of saving a deeply-nested model with relations.\n. ",
    "shinzui": "Is this feature in development? It's hard to tell by looking at #552\n. Is there a plan to fix this?\n. Is this scheduled for a future release? \n. ",
    "adnanoner": "Is this possible?\n. @helios1138 do you have an example of how you handle selects in your model? Got the parsing to work but not the selecting and formatting.\n. @helios1138 do you have an example of how you handle selects in your model? Got the parsing to work but not the selecting and formatting.\n. Any update @castarco ?  Also, how do you select an uuid (since they are stored as bytes)?\nFor those interested I'm using parse with the node-uuid package (and am using a mysql function to convert the uuid in the database as per https://www.percona.com/blog/2014/12/19/store-uuid-optimized-way/ ):\n```\n  parse: function (attrs) {\n    attrs.uuid = uuid.unparse(attrs.uuid);\n    return attrs;\n  },\n```\n. Any update @castarco ?  Also, how do you select an uuid (since they are stored as bytes)?\nFor those interested I'm using parse with the node-uuid package (and am using a mysql function to convert the uuid in the database as per https://www.percona.com/blog/2014/12/19/store-uuid-optimized-way/ ):\n```\n  parse: function (attrs) {\n    attrs.uuid = uuid.unparse(attrs.uuid);\n    return attrs;\n  },\n```\n. @ryanvanderpol thanks so much, you are absolutely right \ud83d\udc4d \n. @ryanvanderpol thanks so much, you are absolutely right \ud83d\udc4d \n. ",
    "vellotis": "It may be possible with bookshelf-manager.\n. @awebdeveloper Your joining table name is group_users not `group_user.\njs\nmembers: function () {\n        return this.belongsToMany(UserProfile, 'group_user', 'group_id','user_id');\n}\n. @rhys-vdw I would say that @tgriesser's improvement fixes the problem for most of the cases. But not these cases when alias actually needed. Eg. self referencing relations. My suggestion is to add a new model property called tableAlias which would be used in all cases instead of tableName when it is present.\n. As @tgriesser is not active on this project this feature request has been suspended.\n@DeadEye0112 But as a workaround I suggest you to use @mike1o1 's attempted way and filter the result collection...\njs\nProperty.forge({name: 'propName'}.fetch( {\n     withRelated: [\n         {\n              'street': function(qb) {\n                   qb.where('name', 'streetName');\n               }\n         }                  \n     ]\n}).then(function (allStreetProps) {\n  var streetProperties = allStreerProps.filter(function (prop) {\n      return !prop.street().isNew();\n    });\n  // following procedures\n})\n. @rhys-vdw I think this is resolved by my PR #1206\n. Resolved by #1206\n. @JBustin I may consider merging it. But it doesn't have an tests.\nAre you willing to contribute?\n. The returning statement can be used only for Oracle, PostgreSQL and MSSQL. http://knexjs.org/#Builder-returning\n. js\nMyModel.forge({foo:'bar'}).fetch()\nInitializes model with provided values. If model doesn't have value for id then provided keys/values are used for SQL WHERE query on knex.\njs\nMyModel.where({foo:'bar'}).fetch()\nInitializes empty model and keys/values provided for where are used for SQL WHERE query on knex.\n. js\nMyModel.forge({foo:'bar'}).fetch()\nInitializes model with provided values. If model doesn't have value for id then provided keys/values are used for SQL WHERE query on knex.\njs\nMyModel.where({foo:'bar'}).fetch()\nInitializes empty model and keys/values provided for where are used for SQL WHERE query on knex.\n. You could look bookshelf-manager plugin. But I don't know if it will help you.\n. Something similar to following one could be used for this case...\neager-load-plugin.js\n``` js\nmodule.exports = function eagerLoadPlugin(bookshelf) {\n  var ModelCtor = bookshelf.Model;\n  bookshelf.Model = ModelCtor.extend({\n    initialize: function() {\n      // Call super. This way we can use Parent Model initializers as well\n      ModelCtor.prototype.initialize.apply(this, arguments);\n  this.on('fetching fetching:collection', withEager);\n}\n\n}, {\n    collection: function() {\n      return ModelCtor.collection.apply(this, arguments).on('fetching', withEager);\n    }\n  });\n};\nfunction withEager(modelOrCollection, columns, options) {\n  options = options || {}\nvar eagerLoad = (this instanceof ModelCtor)\n    ? this.eagerLoad // from Model\n    : this.model.prototype.eagerLoad; // from Collection\n// Add eager load relations. This logic here should be something more complex.\n  options.withRelated = (eagerLoad  || []).concat(options.withRelated || [])\n}\n```\nmy-model.js\n``` js\nvar bookshelf = ... ;\nvar MyModel = bookshelf.Model.extend({\n  tableName: 'my_models',\n  eagerLoad: ['oneRelation', 'secondRelation'],\noneRelation: function() {\n    return ... ;\n  },\n  secondRelation: function() {\n    return ... ;\n  },\n});\nmodule.extends = MyModel;\n```\nThe idea is to populate withRelated option with correct values before fetching event. One caveat is that the fetching event gets also called when already performing an eager fetching. So it can get to infinite loop.\nMy implementation is simple but it doesn't allow to perform complex merging/overriding. I hope this example helps.\n. @hagabaka Sry. I forgot the collection part. I updated my solution. But it still has a caveat for infinite loop.\n. @arnold-almeida\nMaintained by me and @rhys-vdw.\n. Actually you are correct and I came to the same realisation on my way home yesterday. I will fix it and create some tests. And then create a new PR.\n. Actually you are correct and I came to the same realisation on my way home yesterday. I will fix it and create some tests. And then create a new PR.\n. Done. I created one test (actually more of a copy/paste) and improved one test as well. Because the actual change in DB wasn't reflected in the tests. My problem was that the model got correct attribute values, but they didn' end up in DB.\n. Done. I created one test (actually more of a copy/paste) and improved one test as well. Because the actual change in DB wasn't reflected in the tests. My problem was that the model got correct attribute values, but they didn' end up in DB.\n. @rhys-vdw  Great to be helpful for this awesome project. Thanks for fast response.\n. @rhys-vdw  Great to be helpful for this awesome project. Thanks for fast response.\n. I share the same problem.\nI am using bookshelf-soft-delete package. So I am dealing with records that are soft deleted. So I have three tables.\n| people | homes | houses |\n| --- | --- | --- |\n| id | id | id |\n| deleted_at | person_id | deleted_at |\n|  | house_id |  |\n|  | deleted_at |  |\nAnd the example models\n``` js\nvar Person, House, Home;\nPerson = Model.extend({\n  tableName: 'people',\n  house: function() { return / THE ACTUAL PLACE FOR RELATION DECLARATION / }\n});\nHome = Model.extend({\n  tableName: 'homes',\n  house:\n});\nHouse = Model.extend({\n  tableName: 'houses'\n});\nPerson.forge({id: 1}).house().fetch()\n.then(function(model) {\n  / Handle single model /\n});\n```\nI would like to have query that is for fetching single record. Something like this\nsql\n    SELECT `houses`.* FROM `houses`\nINNER JOIN `homes` ON `homes`.`house_id` = `houses`.id\n     WHERE `homes`.`person_id` = ?\n       AND `homes`.`deleted_at` IS NULL\n       AND `houses`.`deleted_at` IS NULL\n     LIMIT 1\nNow some relation declarations and their generated SQL:\nthis.belongsTo(House);\nsql\nselect `houses`.* from `houses`\n where (`houses`.`deleted_at` is null)\n   and `houses`.`id` = ? limit ?\nthis.belongsTo(House).through(Homes, 'id');\nsql\n    select `houses`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`house_id` as `_pivot_house_id`\n      from `houses`\ninner join `homes`\n        on `homes`.`house_id` = `houses`.`id`\ninner join `people`\n        on `homes`.`id` = `people`.`id`\n        -- `homes`.`id` should be `homes`.`person_id`\n        -- `people`.`id` key is the foreign key declared by \"through\"\n     where (`houses`.`deleted_at` is null)\n       and `people`.`id` = ? limit ?\nthis.hasOne(House);\nsql\nselect `houses`.*\n  from `houses`\n where (`houses`.`deleted_at` is null)\n   and `houses`.`person_id` = ? limit ?\nthis.hasOne(House).through(Home, 'xxx')\nsql\n    select `houses`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`person_id` as `_pivot_person_id`\n      from `houses`\ninner join `homes`\n        on `homes`.`id` = `houses`.`id`\n        -- Should join `homes`.`house_id` instead of `homes`.`id`\n        -- `houses`.`id` key is the foreign key declared by \"through\"\n     where (`houses`.`deleted_at` is null)\n       and `homes`.`person_id` = ? limit ?\nthis.belongsToMany(House).through(Home, 'house_id', 'person_id');\nsql\n    select `houses`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`person_id` as `_pivot_person_id`,\n           `homes`.`house_id` as `_pivot_house_id`\n      from `houses`\ninner join `homes`\n        on `homes`.`house_id` = `houses`.`id`\n     where (`houses`.`deleted_at` is null)\n       and `homes`.`person_id` = ?\nthis.belongsToMany(House).through(Home, 'house_id', 'person_id').query(function(q){q.limit(1);});\nsql\n    select `houses`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`person_id` as `_pivot_person_id`,\n           `homes`.`house_id` as `_pivot_house_id`\n      from `houses`\ninner join `homes`\n        on `homes`.`house_id` = `houses`.`id`\n     where (`houses`.`deleted_at` is null)\n       and `homes`.`person_id` = ? limit ?\nThe last one is the closest I could get. But fetch() for this relation is still returning collection, not single model.\nSo @ricardograca. As you see I tried also hasOne through variant.\nIs there a nice way for solving this? As stated in #1025 comment, through() method initally served other purpose. And as @chrisbroome stated in the end of this comment I would suggest the same fix for it.\n. I share the same problem.\nI am using bookshelf-soft-delete package. So I am dealing with records that are soft deleted. So I have three tables.\n| people | homes | houses |\n| --- | --- | --- |\n| id | id | id |\n| deleted_at | person_id | deleted_at |\n|  | house_id |  |\n|  | deleted_at |  |\nAnd the example models\n``` js\nvar Person, House, Home;\nPerson = Model.extend({\n  tableName: 'people',\n  house: function() { return / THE ACTUAL PLACE FOR RELATION DECLARATION / }\n});\nHome = Model.extend({\n  tableName: 'homes',\n  house:\n});\nHouse = Model.extend({\n  tableName: 'houses'\n});\nPerson.forge({id: 1}).house().fetch()\n.then(function(model) {\n  / Handle single model /\n});\n```\nI would like to have query that is for fetching single record. Something like this\nsql\n    SELECT `houses`.* FROM `houses`\nINNER JOIN `homes` ON `homes`.`house_id` = `houses`.id\n     WHERE `homes`.`person_id` = ?\n       AND `homes`.`deleted_at` IS NULL\n       AND `houses`.`deleted_at` IS NULL\n     LIMIT 1\nNow some relation declarations and their generated SQL:\nthis.belongsTo(House);\nsql\nselect `houses`.* from `houses`\n where (`houses`.`deleted_at` is null)\n   and `houses`.`id` = ? limit ?\nthis.belongsTo(House).through(Homes, 'id');\nsql\n    select `houses`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`house_id` as `_pivot_house_id`\n      from `houses`\ninner join `homes`\n        on `homes`.`house_id` = `houses`.`id`\ninner join `people`\n        on `homes`.`id` = `people`.`id`\n        -- `homes`.`id` should be `homes`.`person_id`\n        -- `people`.`id` key is the foreign key declared by \"through\"\n     where (`houses`.`deleted_at` is null)\n       and `people`.`id` = ? limit ?\nthis.hasOne(House);\nsql\nselect `houses`.*\n  from `houses`\n where (`houses`.`deleted_at` is null)\n   and `houses`.`person_id` = ? limit ?\nthis.hasOne(House).through(Home, 'xxx')\nsql\n    select `houses`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`person_id` as `_pivot_person_id`\n      from `houses`\ninner join `homes`\n        on `homes`.`id` = `houses`.`id`\n        -- Should join `homes`.`house_id` instead of `homes`.`id`\n        -- `houses`.`id` key is the foreign key declared by \"through\"\n     where (`houses`.`deleted_at` is null)\n       and `homes`.`person_id` = ? limit ?\nthis.belongsToMany(House).through(Home, 'house_id', 'person_id');\nsql\n    select `houses`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`person_id` as `_pivot_person_id`,\n           `homes`.`house_id` as `_pivot_house_id`\n      from `houses`\ninner join `homes`\n        on `homes`.`house_id` = `houses`.`id`\n     where (`houses`.`deleted_at` is null)\n       and `homes`.`person_id` = ?\nthis.belongsToMany(House).through(Home, 'house_id', 'person_id').query(function(q){q.limit(1);});\nsql\n    select `houses`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`person_id` as `_pivot_person_id`,\n           `homes`.`house_id` as `_pivot_house_id`\n      from `houses`\ninner join `homes`\n        on `homes`.`house_id` = `houses`.`id`\n     where (`houses`.`deleted_at` is null)\n       and `homes`.`person_id` = ? limit ?\nThe last one is the closest I could get. But fetch() for this relation is still returning collection, not single model.\nSo @ricardograca. As you see I tried also hasOne through variant.\nIs there a nice way for solving this? As stated in #1025 comment, through() method initally served other purpose. And as @chrisbroome stated in the end of this comment I would suggest the same fix for it.\n. Dirty solution by monkey patching Bookshelf.\njs\nPerson = Model.extend({\n  tableName: 'people',\n  house: function() {\n    return this._relation('belongsTo', House, {\n      foreignKey: 'house_id',\n      joinClauses: function(knex) {\n        knex.join('homes', 'homes' + '.' + this.key('foreignKey'), '=', 'houses' + '.' + this.targetIdAttribute);\n        knex.join('people', 'people' + '.' + this.throughIdAttribute, '=', 'homes' + '.' + this.key('throughForeignKey'));\n      },\n      joinColumns: function(knex) {\n        var columns;\n        columns = [];\n        columns.push(this.throughIdAttribute);\n        columns.push(this.key('foreignKey'));\n        Array.prototype.push.apply(columns, this.pivotColumns);\n        knex.columns(_.map(columns, function(col) {\n          return 'homes' + '.' + col + ' as _pivot_' + col;\n        }));\n      },\n      whereClauses: function(knex, response) {\n        var key;\n        key = 'people' + '.' + this.targetIdAttribute;\n        knex.where(key, this.parentFk);\n      }\n    }).init(this).through(Home, 'person_id');\n  }\n});\nThis could be optimized.\nThis generates following SQL:\nsql\n    select `brands`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`house_id` as `_pivot_house_id`\n      from `houses`\ninner join `homes` on `homes`.`house_id` = `houses`.`id`\ninner join `people` on `people`.`id` = `homes`.`person_id`\n     where (`houses`.`deleted_at` is null)\n       and `people`.`id` = ? limit ?\n. Dirty solution by monkey patching Bookshelf.\njs\nPerson = Model.extend({\n  tableName: 'people',\n  house: function() {\n    return this._relation('belongsTo', House, {\n      foreignKey: 'house_id',\n      joinClauses: function(knex) {\n        knex.join('homes', 'homes' + '.' + this.key('foreignKey'), '=', 'houses' + '.' + this.targetIdAttribute);\n        knex.join('people', 'people' + '.' + this.throughIdAttribute, '=', 'homes' + '.' + this.key('throughForeignKey'));\n      },\n      joinColumns: function(knex) {\n        var columns;\n        columns = [];\n        columns.push(this.throughIdAttribute);\n        columns.push(this.key('foreignKey'));\n        Array.prototype.push.apply(columns, this.pivotColumns);\n        knex.columns(_.map(columns, function(col) {\n          return 'homes' + '.' + col + ' as _pivot_' + col;\n        }));\n      },\n      whereClauses: function(knex, response) {\n        var key;\n        key = 'people' + '.' + this.targetIdAttribute;\n        knex.where(key, this.parentFk);\n      }\n    }).init(this).through(Home, 'person_id');\n  }\n});\nThis could be optimized.\nThis generates following SQL:\nsql\n    select `brands`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`house_id` as `_pivot_house_id`\n      from `houses`\ninner join `homes` on `homes`.`house_id` = `houses`.`id`\ninner join `people` on `people`.`id` = `homes`.`person_id`\n     where (`houses`.`deleted_at` is null)\n       and `people`.`id` = ? limit ?\n. There is a slight problem with this solution. Nested eager loading doesn't work.\n. Managed to get it working following hacky way:\njs\nPerson = Model.extend({\n  tableName: 'people',\n  house: function() {\n    return this._relation('belongsTo', House, {\n      foreignKey: 'person_id',\n      joinClauses: function(knex) {\n        knex.join('homes', 'homes' + '.' + this.otherKey, '=', 'houses' + '.' + this.targetIdAttribute);\n      },\n      joinColumns: function(knex) {\n        var columns;\n        columns = [];\n        columns.push(this.throughIdAttribute);\n        columns.push(this.key('foreignKey'));\n        Array.prototype.push.apply(columns, this.pivotColumns);\n        knex.columns(_.map(columns, function(col) {\n          return 'homes' + '.' + col + ' as _pivot_' + col;\n        }));\n      },\n      whereClauses: function(knex, response) {\n        var key;\n        key = 'people' + '.' + this.key('foreignKey');\n        knex.where(key, this.parentId);\n      }\n    }).init(this).through(Home, 'person_id', 'house_id');\n  }\n});\nsql\n    select `brands`.*,\n           `homes`.`id` as `_pivot_id`,\n           `homes`.`person_id` as `_pivot_person_id`\n      from `houses`\ninner join `homes` on `homes`.`house_id` = `houses`.`id`\n     where (`houses`.`deleted_at` is null)\n       and `homes`.`person_id` = ? limit ?\n. Resolved by #1403\n. @ricardograca Just to philosophically continue the converisation. What will be the future as this project is not actively developed but just maintained?\n. @gergelyke Great optimization. Suggested change is performing the exact thing under hood as current. Can't figure out why it was implemented that way as it is currently.\n@rhys-vdw Sorry that I'm trying to tidy up PRs and issues.\n. Hi @RichardSimko \nIf you look the source of Model::related then you understand it better.\n. Hi @RichardSimko \nIf you look the source of Model::related then you understand it better.\n. @dannymidnight Why whould you call related without model instance? Are you referencing the related method in some array? Could you please provide an actual use case as JS? Sadly actual use case can't be seen in added tests.\n. @jamesdixon Is this issue obsolete?\n. @davestevens I have to say that I agree withe the suggested change as save gets called before create or update. Actually all the other ORMs that are somehow mimic ActiveRecord behave that way.\n@rhys-vdw I know this may be a vital change for someone. But the documentation denotes this behaviour.\n. Actually if you look the implementation then this should work as well.\njs\nmodel.fetch({\n    withRelated: [\n        {'relation1':  () => { /*do nothing or something*/ }},\n        {'relation1.subrelation': (query) => { query.sortBy('id'); }}\n    ]\n});\n. Resolved by PR #1195\n. @jamesdixon #1195 is in v0.10.\nI'm reopening it. Could you provide valid and invalid queries for that issue?\n. I think the last mentioned problem can be solved with parse & format. And as you do not know automatically which fields need to be parsed when fetching from and formatted when saving/updating to database, it is required to declare them in Model.\nFor example: I'm using MySQL 5.7 which supports JSON type. But mysql2 doesn't support it straight forward, It means it handles it as a string. So I have to parse/stringify the field every time I perform read/write operation.\nFor this I have made a Bookshelf plugin for myself:\n``` js\n'use strict';\nvar Promise = require('bluebird'),\n    _ =         require('lodash');\nfunction parseJsonColumns(attrs) {\n  if (attrs && this.jsonColumns) {\n    this.jsonColumns.forEach(function(key) {\n      if (_.isString(attrs[key])) {\n        attrs[key] = JSON.parse(attrs[key]);\n      }\n    });\n  }\n  return attrs;\n};\nfunction formatJsonColumns(attrs) {\n  if (attrs && this.jsonColumns) {\n    this.jsonColumns.forEach(function(key) {\n      if (_.isPlainObject(attrs[key])) {\n        attrs[key] = JSON.stringify(attrs[key]);\n      }\n    });\n  }\n  return attrs;\n};\nmodule.exports = function(Bookshelf) {\n  if (!Bookshelf) {\n    throw new Error('Must pass an initialized bookshelf instance');\n  }\n  var ModelCtor = Bookshelf.Model;\nBookshelf.Model = ModelCtor.extend({\n    parse: function(attrs) {\n      parseJsonColumns.apply(this, arguments);\n      return ModelCtor.prototype.parse.apply(this, arguments);\n    },\n    format: function(attrs) {\n      formatJsonColumns.apply(this, arguments);\n      return ModelCtor.prototype.parse.format(this, arguments);\n    }\n  });\n};\n```\nThen you shall declare jsonColumns on the model:\njs\nconst Events = bookshelf.Model.extend({\n    tableName: 'events',\n    jsonColumns: ['someColumnName', 'otherColumnName']\n})\nSo quick plugin refactoring for PostGIS:\n``` js\n'use strict';\nconst Promise = require('bluebird'),\n      _ =           require('lodash');\nmodule.exports = function(Bookshelf) {\n  if (!Bookshelf) {\n    throw new Error('Must pass an initialized bookshelf instance');\n  }\n  const ModelCtor = Bookshelf.Model,\n        st = Bookshelf.knex.postgis;\nfunction parseGISColumns(attrs) {\n    if (attrs && this.GISColumns) {\n      this.GISColumns.forEach(function(key) {\n        if (_.isString(attrs[key])) {\n          attrs[key] = JSON.parse(attrs[key])\n        }\n      })\n    }\n    return attrs\n  }\nfunction formatGISColumns(attrs) {\n    if (attrs && this.GISColumns) {\n      this.GISColumns.forEach(function(key) {\n        if (_.isPlainObject(attrs[key])) {\n          attrs[key] = st.geomFromGeoJSON(attrs[key])\n        }\n      });\n    }\n    return attrs\n  }\nBookshelf.Model = ModelCtor.extend({\n    initialize () {\n      this.on('fetching', function (model, columns, options) {\n        const gisColumns = .intersection(this.GISColumns, columns)\n        if (!.isEmpty(gisColumns)) {\n          gisColumns.forEach(function (column) {\n                        const index = columns.indexOf(column)\n            columns.splice(index, 1, st.asGeoJSON(column))\n          })\n        } else if (_.includes(columns, ${this.tableName}.*)) {\n          columns.push.apply(columns, _this.GISColumns(st.asGeoJSON))\n        }\n      })\n      return ModelCtor.prototype.parse.apply(this, arguments)\n    }\n    // Actually this may not be needed as returned value should already be in JSON format\n    parse (attrs) {\n      parseGISColumns.apply(this, arguments)\n      return ModelCtor.prototype.parse.apply(this, arguments)\n    }\n    format (attrs) {\n      formatGISColumns.apply(this, arguments)\n      return ModelCtor.prototype.parse.format(this, arguments)\n    }\n  })\n};\n```\nAnd use it jus by defining GISColumns:\njs\nconst Events = bookshelf.Model.extend({\n    tableName: 'events',\n    gisColumns: ['location']\n})\n. Resolved by PR #1195.\n. > @jamesdixon \n\nAlso, is there a difference between related('pets') and pets()? When called on parentAppointment, they both return the same result.\n\nYou have a correct question. This is the place where your problem situates.\nif you look your pets() function then it returns just a \"description\" of the relation. If you look related(name) method declaration then you see that actually it initiates the relation.\njs\n/*406*/ ModelBase.prototype.related = function(name) {\n/*407*/   return this.relations[name] || ( // Return initiated relation if possible\n            this[name]  // look for presence of relation description\n            ? this.relations[name] = this[name]() // relation description found, initiate and assign it\n            : void 0 // relation description not found\n          );\n/*408*/ };\nYou should always use related(name) to access your relations.\nNow about the problem\nAt the end of belongsToMany specification:\n\nCollections returned by a belongsToMany relation are decorated with several pivot helper methods. See attach, detach, updatePivot and withPivot for more information.\n\nSo attach method is valid only for belongsToMany relation. The following I found from the source code seems to confirm that.\njs\n/*49*/ if (this.type === 'belongsToMany') {\n/*50*/   _.extend(target, pivotHelpers);\n/*51*/ }\nSo you are correct. The clone is missing attach, detach, updatePivot and withPivot (+ helpers _processPivot, _processPlainPivot and _processModelPivot) properties (but only for belongsToMany relation collection). Personally I don't feel that the belongsToMany condition has to be checked here. We could just add the missing property names to collectionProps array as they are missing for all other collections any way.\njs\n/*69*/ const collectionProps = ['attach', 'detach', 'updatePivot', 'withPivot', '_processPivot', '_processPlainPivot', '_processModelPivot'];\n. @jamesdixon Made a suggestion for this bug as a PR #1222.\n. @Znarkus Actually this brings up other questions for me. Look at this part of save() method:\njs\n/*977*/ return this.triggerThen((method === 'insert' ? 'creating saving' : 'updating saving'), this, attrs, options)\n/*978*/ .bind(this)\n/*979*/ .then(function() {\n/*980*/   return sync[options.method](method === 'update' && options.patch ? attrs : this.attributes);\n/*981*/ })\nWhy is \"patch\" passing attrs not dirty attributes held by \"changed\" property? So to solve your problem and my question wouldn't this be appropriate?\njs\nreturn this.triggerThen.apply(this, [\n  (method === 'insert' ? 'creating saving' : 'updating saving'),\n  this,\n  (method === 'insert' ? this.attributes : this.changed),\n  options\n])\n.bind(this)\n.then(function() {\n  return sync[options.method](method === 'update' && options.patch ? this.changed : this.attributes);\n})\nI know that this would need a change in documentation. But could anyone explain the initial intentions for not using \"changed\" property?\n. @Znarkus Actually this brings up other questions for me. Look at this part of save() method:\njs\n/*977*/ return this.triggerThen((method === 'insert' ? 'creating saving' : 'updating saving'), this, attrs, options)\n/*978*/ .bind(this)\n/*979*/ .then(function() {\n/*980*/   return sync[options.method](method === 'update' && options.patch ? attrs : this.attributes);\n/*981*/ })\nWhy is \"patch\" passing attrs not dirty attributes held by \"changed\" property? So to solve your problem and my question wouldn't this be appropriate?\njs\nreturn this.triggerThen.apply(this, [\n  (method === 'insert' ? 'creating saving' : 'updating saving'),\n  this,\n  (method === 'insert' ? this.attributes : this.changed),\n  options\n])\n.bind(this)\n.then(function() {\n  return sync[options.method](method === 'update' && options.patch ? this.changed : this.attributes);\n})\nI know that this would need a change in documentation. But could anyone explain the initial intentions for not using \"changed\" property?\n. > Ok after some time I got my answer from #814. This really should be exampled in documentation. But I will copy the pracktise here too.\n\njs\nmodel.set({thing: 'something'}).save(model.changed, {patch: true});\n\nSorry @Znarkus. As I was too concerned with my own issue I didn't help to solve your ploblem.\nWhy do you want to validate only the ones that get updated? For me it doesn't make sense why the other attributes should not get validated. I am assuming that you are using the validation practise that is described in Model.extend with Checkit.\n. @c990802  It seems to me that the syntax is not valid. Could you update it? It is not clear what are your code intentions.\n. @c990802  It seems to me that the syntax is not valid. Could you update it? It is not clear what are your code intentions.\n. @jamesdixon Yep. It is exactly the case I was trying to start supporting with this PR.\n. @jamesdixon Sorry. I misread your issue\nYou are using 'fetching' event. But I am trying to fix 'fetched' event. As I did some investigation on where an what get's triggered for withRelated I found out that 'fetched' event gets triggered on \"Relation\" instance, not result Model instance. It makes sense also. \"fetched\" event can't be triggered on collection of models as we do not know how many of them are being fetched from DB. It could be triggered on single relation like hasOne and belongsTo. There only one model gets fetched if any.\n. Maybe you could use Virtuals plugin and nested withRelated.\njs\nvar Relation = bookshelf.Model.extend({\n    tableName: 'relations',\n    virtuals: {\n      role: function() { return this.related('user').get('name') },\n      name: function() { return this.related('resource').get('name') }\n    },\n    user: function(){\n        return this.belongsTo('User', 'userId');\n    },\n    resource: function(){\n        return this.belongsTo('Resource', 'resourceId');\n    },\nand then\njs\nUser.forge({userId: user}).fetch({\n    columns: ['userId', 'name'], \n        withRelated: ['relates.user', 'relates.resource']\nNow you should have to use toJSON({shallow: true}) to leave relations data out from the output.\n. Sry, toJSON({shallow: true}) doesn't work as relates is also a relation. You should use something like json-schema-filter to whitelist correct keys.\n. Hi @Genchou \nI assume you are familiar with Rails Activerecord. Bookshelf tries to fill the similar kind of gap in Node.js world, but is not so advanced as Activerecord is. This means that it doesn't distinguish User object and User object ID as Activerecord does. And doesn't eagerly save relations. You are too much expecting the same kind of behaviour as Activerecord is capable of.\nYou have to consider that you must use plain IDs. So your last discovery is correct. You have to use user_id instead of User model object. You cannot eagerly save associated models. Everything that you would like to get saved must be saved \"manually\" (by keeping in mind Activerecord) and in correct order.\n``` js\nvar picture = new Picture({\n    // other attributes\n    user_id: loggedUser.id\n});\n// or\npicture.set({ user_id: loggedUser.id });\n// or\npicture.set('user_id', loggedUser.id);\n```\nI hope this helps.\n. @jamesdixon I think you are using the fetched event wrong. Could you specify a bit how does you relation declaration look like in the Appointment model?\n. I assume that Staff has a relation belongsTo('User'). What if you use `withRelated: 'staff.user'?\nThen you should be able to access user by doing:\njs\nAppointment.findOne({id:id}, {withRelated: 'staff.user'}))\n.then(function (appointment) {\n  var staff = appointment.related('staff');\n  var user = staff.related('user');\n  ... \n})\n. @Claud Bookshelf.transaction Returns a Promise. If it gets solved the transaction gets automatically committed.\n:exclamation: But I have to say it is bad idea to carry transaction over many HTTP requests. By design it not a good idea to keep transaction open for a long time. In this time window some other user may want to modify the same record. Or something else may happen to the transaction context owner so it will not get rejected or committed. You should really reconsider if it is really required for your business logic.\n:bulb: But if you still think that it is a good idea Bookshelf.transaction actually internally looks like this. So actually it depends on Knex. So take a look at the end of Knex Transactions paragraph.\n. Seems that @rhys-vdw is correct. I didn't know this kind of feature for matching signature request paths in express.js.\n. @miketerpak The trigger does not fire for eagerly loaded (with withRelated option) associations. Look @ PR #1206. I fixed this and have been waiting for this PR to get merged. Sadly no response.\n. Aren't virtuals for (pre)processing attributes before getting/setting? Seems to me pretty much so. Why wouldn't it be a good idea to not to have this functionality? Currently if I would call set recursively it would make an infinite loop. Then it would set/get an actual attribute.\n. Hi @jamesdixon \nIf you look the signature of belongsToMany then the solution for your problem would be:\njs\n// Appointment\nconst Appointment = BaseModel.extend({\n    tableName: 'appointment',\n    services: function() {\n        this.belongsToMany('Service').through('AppointmentService');\n    },\n    pets: function() {\n        this.belongsToMany(\n          'Pet',\n          AppointmentService.prototype.tableName, // joining table name\n          'appointment_id', // foreignKey\n          'pet_id' // otherKey\n        ).withPivot(['service_id']);\n    }\n});\nBy myself I would prefer to use AppointmentService.prototype.tableName instead of just a string value for joining table.\n:heavy_plus_sign: Please close you previous issues if they have been solved. (#1214)\n. i have come to a realization that throughbehaves differently for every relation type. If it was up to me I would have changed relations API to be similar to Rails one. As its really nice, clean and understandable in every aspect. But sadly relations is one of the weakest backbones of Bookshelf. But still its usable.\n. What would be the problem? In DB the view is just a computed table. For most of the databases view is only for selecting. So it behaves just like any other table.\n``` js\nvar SomeView = Model.extend({\n  tableName: 'some_view_name'\n});\nSomeView.forge().fetchAll() // executes \"select some_view_name.* from some_view_name\"\n.then(function(view_collection) {\n  // dump as json\n  var json = view_collection.toJSON();\n  ... etc ...\n});\nSomeView.forge().fetch() // executes \"select some_view_name.* from some_view_name limit ?\" where limit is 1\n.then(function(view) {\n  // dump as json\n  var some_view_field = view.get('some_view_field');\n  ... etc ...\n});\n```\n. I had a discussion with @rhys-vdw and he noted:\n\nNobody is actively working on bookshelf. [May 11 11:26]\n\nSo sadly for Bookshelf there won't be any.\n. Sry @jamesdixon that I haven't had time to view your problem. Actually belongsToMany relations get attached not by 'person_id' values but by its pivotal values. If you look your debug query\nsql\nselect \"pet\".*,\n       \"appointment_pet\".\"parent_id\" as \"_pivot_parent_id\",  # <= this one matters\n       \"appointment_pet\".\"pet_id\"    as \"_pivot_pet_id\" \nfrom   \"pet\" \n       inner join \"appointment_pet\" \n               on \"appointment_pet\".\"pet_id\" = \"pet\".\"id\" \nwhere  \"appointment_pet\".\"parent_id\" in ( ?, ?, ?, ?, \n                                          ?, ?, ?, ?, \n                                          ?, ?, ?, ?, \n                                          ?, ?, ?, ? )\nso you should change your query something like\njs\npets: (qb) => {\n  qb.select(['appointment_id as _pivot_parent_id', 'pet.*']);\n}\nI hope it works. I haven't checked it in action.\n. Hmm... I recognized that your qb.select actually didn't change the query at all. So my suggestion doesn't work as qb.select doesn't modify eagerly loaded relation query..\n. @robwilkerson  I assume guid is your primary key? belongsTo relation can be fetched only if you provide the foreign_key to the model (eg. department_id). If you do not know the value of the foreign key then you shall fetch Course from the db before you can fetch its related Department.\nSo your second vairant is correct for you. You may want to use {withRelated: 'department'} for fetch operation. This way your associated Department gets eagerly loaded and you could access it by using model.related(name).\njs\nCourse.forge({ guid: '4f847841-09f5-4ee8-8d31-b26a3de3cb35' })\n    .fetch({withRelated: 'department'})\n    .then(function(course) {\n        var department = course.related('department');\n        return res.send(department);\n    })\nI assume materials is hasMany relation which doesn't use foreign key but primary key to find its related Material\u00b4s.\n. @robwilkerson Seems that you are somehow accidentially declaring a loop in your Model. Could you expose your models?\n. @robwilkerson format is reserved property http://bookshelfjs.org/docs/src_base_model.js.html#line367. Seems to be also a documentation problem that it is not defined there.\nGiven documentation problem is also addressed in #1040.\n. @jamesdixon You cannot check if something is changed after you have already saved it.\nSee this example:\n``` js\n// assume data is different from what's in the database\nconst data = { staffId: 10 };\nreturn Appointment\n.findOne(query, options)\n.tap((appointment) => {\n    appointment.set(data);\n    console.log(appointment.hasChanged('staffId')); // true\n    return appointment\n    .save(null, options)\n    .then(() => {\n        console.log(appointment.hasChanged('staffId')); // false\n    });\n});\n```\n. @skywickenden I think the problem is in knex instead. Look tgriesser/knex#1276.\n. I think this (line 214) is the root of the problem.\njs\n/*213*/  bookshelf.Collection.prototype.fetchPage = function (...args) {\n/*214*/    return fetchPage.apply(this.model.forge(), ...args);\n/*215*/  };\nThis initiates the model again and querybuilder state gets \"lost in action\". I will look for the proper solution and make a PR.\n. #1261 seems to be handling the same problem. It does work for...\njs\nSomeModel.collection().query(function(qb){\n  qb.where(knex.raw('`tableName`.`columnName`'), conditionValue);\n}).fetchPage(...)\n.then(function(results) {\n   ...handle results...\n});\nBut not for queries made through relation. For example...\njs\nSomeModel.forge({id: 1}).relation().query(function(qb){\n  qb.where(knex.raw('`tableName`.`columnName`'), conditionValue);\n}).fetchPage(...)\n.then(function(results) {\n   ...handle results...\n});\n. Suggested fix in PR #1258\n. The solution is acceptable. But the tests are still missing for it. I'm not saying that MSSQL tests are needed. But definitely the general tests need to reflect this improvement.\n@sandorfr are you willing to finish PR #1260? MSSQL specific tests Would not be in scope of this issue. A separate issue would be created for it.\n. Hi @renarsvilnis . Great that you got it solved. And sorry I couldn't help you earlier. But just to clarify.\nrefresh method refreshes the current model. It would be necessary to perform refresh if there is any business logic in database too when inserting a record.\nload performs just relations loading.\nBut jou could get almost the same behaviour with refresh with withRelated option.\njs\nreturn yield option.refresh({withRelated: 'options'});\nAs I describe this also reloads fresh given model from the DB.\n. I really liked the way NPM v2 handled packages. But it wasn't Windows friendly as it has MAX_PATH restriction.\nNPM v3 to the \"rescue\". Now it doesn't have deep nested dependencies. It tries as much it is possible to install them in the root node_modules directory. But it may mess up the dependencies some times. I usually in these situations have deleted the node_modules directory and run npm install.\nNPM 3 vs NPM 2\nStill I'm not sure this is the solution.\n. @chamini2 As you are not using database provided primary key Bookshelf thinks that this record is already present in database. So you should force to use insert method on save.\njs\nBank.forge({name: 'Bank Name'}).save({method: 'insert'});\n. @chamini2 Am I missing something? Doesn't my provided\njs\nBank.forge({name: 'Bank Name'}).save({method: 'insert'});\nway work where you force to use insert method instead of update?\n. @chamini2 Actually I agree. As when I started off with Bookshelf I expected the exact your described behaviour. But this is the part of the framework that everybody use the way it currently behaves. eg.\njs\ncar = new Car({id: 1});\ncar.set(attributes);\ncar.save(this.changed, {patch: true}); // Update only for fields that are present\n// But actually `insert` gets invoked as`id` would be missing and therefore `isNew()` returns true.\nSo this can't be considered as an easy fix. Or what do you think @rhys-vdw ?\n. @chamini2 I think something similar to your suggested solution may be considerable for version 0.10. Also adding isPersisted would come under consideration.\nCurrently this is a bug of eager loading. fetching:collection and fetched:collection events are not passed to eagerly loaded collection instance. You could fix your eager loaded records case by overriding Model#collection method:\njs\nconst ModelBase = Bookshelf.Model;\nconst Model = ModelBase.extend({\n  // prototype methods\n}, {\n  // static methods\n  collection() {\n    return ModelBase.collection.apply(this, arguments).on('fetched', function(collection) {\n       collection.forEach(model => { model._new = false; });\n    });\n  }\n})\nAs Model#collection is a static method you shouldn't override it in your isNewOverwrite method.\n. @rmharrison You could use\n``` js\nvar Bookshelf = require('bookshelf')(knex); // Bookshelf instance\n// use it somewhere after declaring models\nfetchAll({columns: [Bookshelf.knex.raw(\"jsoncol->'value'\")]})\n```\nThis should work, as internally knex.select(columns) is called. (knex.select)\n. Strangely tests fail if not only Pagination Plugin tests are run. Here with only Pagination Plugin tests it works.\nWhat could be the difference when running all tests not only Pagination Plugin ones?\n. Seems that virtuals plugin somehow ruins up bookshelf.Model... Investigating further.\n. It wasn't a problem with virtuals but the base class of the Model I was using for verifying the instance of this.\n@rhys-vdw I think this PR is ready to be merged.\nI needed to improve CollectionBase.clone as well implement RelationBase.clone. Actually there was an issue currently that Relation object didn't get cloned on collection cloning but got copied. So original and cloned collecion would have a reference to the same Relation object.\n. @kirrg001 I could rebase if you are ok to review it. I didn't accept my own PRs (not my practise) while I was more active on bookshelf project.. Good. I will rebase it on the weekend.\nhttps://mailtrack.io/ Sent with Mailtrack\nhttps://mailtrack.io/install?source=signature&lang=en&referral=kaarel.raspel@gmail.com&idSignature=22\n2017-04-21 12:59 GMT+03:00 Katharina Irrgang notifications@github.com:\n\n@vellotis https://github.com/vellotis I will review it \ud83d\udc4d\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/pull/1272#issuecomment-296149365,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AASzavVPH81EkOJypu95vfPYnSztjAmCks5ryH4TgaJpZM4IsozQ\n.\n. Sadly, this is the downside of open source. People around the world putting\ntheir own free time to the projects. And some times they value their free\ntime with real physical people more than the time in open source community\nwith virtual people.\n\nBut, really. I am going to rebase the PR in upcoming weekend.\nMy apologies!\n2017-04-28 17:02 GMT+03:00 Patrick Mettraux notifications@github.com:\n\nAny news on this ? The issue is still here\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/pull/1272#issuecomment-298006094,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AASzav0otfYKuX30cIsiLe4anpfz4C0fks5r0fFvgaJpZM4IsozQ\n.\n. @ezmiller I guess it is a mixup of your otherKey and foreignKey identifiers.\nmodel.belongsToMany(Target, [table], [foreignKey], [otherKey])\nI may be wrong, but try this way\n\njs\nconst User = bookshelf.Model.extend({\n  tableName: 'users',\n  initialize: function() {\n    this.on('creating', this.encryptPassword);\n  },\n  hasTimestamps: true,\n  posts: function() {\n    return this.hasMany(Posts, 'author');\n  },\n  comments: function() {\n    return this.hasMany(Comments);\n  },\n  following: function() {\n    return this.belongsToMany(UserFollow, 'users_users', 'user_id', 'follower_id');\n  },\n  followers: function() {\n    return this.belongsToMany(UserFollow, 'users_users', 'follower_id', 'user_id');\n  },\n});\n. Initally a reply to deleted comment by @ahmedcanuck \n\nHow about a polymorphic relationship? That's what we did and it worked out really well for us.\n\n@ahmedcanuck I prefer to think that for the current case polymorphic relationship is redundant. @ezmiller's solution is elegant enough.\n. Closing as resolved by #1288\n. Hi @brenolf \nBookshelf uses Knex underneath to communicate with the DB. So you could use knex for this.\njs\nModel.where('updatable', true)\n.query() // Get Knex instance related to model\n.update('field', false) // http://knexjs.org/#Builder-update\n. You could override your Model and Collection to have require always true. Implemented as a plugin\n``` js\n// require_always_plugin.js\nmodule.exports = function(bookshelf) {\n  var modelProto = bookshelf.Model.prototype;\n  var collectionProto = bookshelf.Collection.prototype;\nvar optionsRequireAlways = function(options) {\n    options = options || {};\n    if (options.require === undefined) {\n      options.require = true;\n    }\n    return options;\n  };\nvar Model = bookshelf.Model.extend({\n    fetch: function(options) {\n      options = optionsRequireAlways(options);\n      return modelProto.fetch.call(this, options);\n    },\n    fetchAll: function(options) {\n      options = optionsRequireAlways(options);\n      return modelProto.fetchAll.call(this, options);\n    }\n  });\nvar Collection = bookshelf.Collection.extend({\n    fetch: function(options) {\n      options = optionsRequireAlways(options);\n      return collectionProto.fetch.call(this, options);\n    },\n    fetchOne: function(options) {\n      options = optionsRequireAlways(options);\n      return collectionProto.fetchOne.call(this, options);\n    }\n  });\nbookshelf.Model = Model;\n  bookshelf.Collection = Collection;\n};\n```\nAnd then use it as a plugin where you initialize Bookshelf before defining Models.\njs\nbookshelf.plugin(require('./require_always_plugin.js'));\nFor collection it throws EmptyError and for model NotFoundError.\nMore info of Bookshelf plugin usage.\n. @vitornogueira You could try to use instead.\njs\nsheets: qb => qb.select('id', 'title'),\n. @vitornogueira It doesn't seem to say very much. Could you debug eager loading SQL query to see how its executed?\njs\n// select\nSchedule\n  .where({ route_id: request.params.id })\n  .query(function(qb) {\n    qb.debug(true);\n  })\n  .fetchAll({\n    required: true,\n    withRelated: [{\n      sheets: qb => qb.debug(true).select('id', 'title'),\n    }],\n    columns: ['id', 'title', 'description', 'type', 'url', 'updated_at'],\n  })\n  .then(schedules => {\n    reply(schedules)\n  })\n. @vitornogueira Does it work if you don't apply query modifyer? I think the query it is missing pivotal return values that are required for eager loaded models. Could you perform the query just {withRelated: ['sheets'}}?\n. Seems to me that it is a bug with Collection.fetchAll and withRelated if they are used together.\n. Ok already reported @ # 629. Closing as a duplicate.\n. Still not a bug. Had different issues with it.\nBut keeping it closed for cleanup purposes.\n. @Claud How are you calling save?\n. The attributes in attrs argument present the values that get passed to the sql. The model gets these attributes (password, password_repeat and old_password) unsetted. But in attrs they still have the old state. So you should do something following.\njs\nthis.on('saving', (model, attrs, options) => {\n    ['password', 'password_repeat', 'old_password'].forEach(function(attrName) {\n      model.unset(attrName);\n      delete attrs[attrName];\n    });\n});\n. https://github.com/tgriesser/bookshelf/blob/118248583fdbcabc8bee280bb4370a44787d1d70/src/model.js#L971-L974\njs\n//                                         The event gets emitted HERE       and      HERE\n//                                                                v v v               v v v\n/*971*/  return this.triggerThen((method === 'insert' ? 'creating saving' : 'updating saving'), this, attrs, options)\n/*972*/  .bind(this)\n/*973*/  .then(function() {\n//                                                        Attributes get used HERE\n//                                                                            v v v\n/*974*/    return sync[options.method](method === 'update' && options.patch ? attrs : this.attributes);\nAs you see these attributes don't get changed anywhere between the event and usage.\n. came to the realization that the relation shall be absent from the JSON if its new.\n. Good work! The final result is pretty decent. :+1: \n. Sry @chamini2. Actually I looked into your problem but found that cannot be achieved currently with standard ways. It may be achieved by manipulating relation object. I have done it by myself few times. Check out this example.\n. Great you got it working. It is currently the only way to declare your required relation.\n@chamini2 Is it resolved for you now? Could you please close the issue then. I just got the official collaborator of the repository and trying to tidy up the issues section.\n. The eager loading is the tricky part in this. I played around with my foreignKey otherKey parameters until I got it working.\nI will try to help you. But you have to do the debugging.\nIn your case you want that records returned from DB would be eagerly paired by _pivot_provider_id. It happens in eagerPair method.\nIf you look there then you see that\n- L294 populates pivot property on related models because isJoined return true.\n- L297-L304 is grouping related models by foreignKey because m.pivot is present, isInverse returns false as it is not neither belongsTo or morphTo relation.\n- L308-L322 makes the pairing by parent model's id L311.\nIt seems to me that it cannot be done without overriding also eagerPair method. So to start you off:\n`` js\n  activities: function() {\n    return this._relation('hasMany', Activity, {\n      foreignKey: 'provider_id',\n      joinClauses: function(knex) {\n        knex.join('providers', 'providers.id', 'activities.provider_id');\n        knex.join('users', 'providers.id', 'users.provider_id');\n      },\n      joinColumns: function(knex) {\n        knex.columns(['providers.id as _pivot_id', 'users.id as _pivot_provider_id']);\n      },\n      whereClauses: function(knex) {\n        knex.where('users.id', this.parentId);\n      },\n      eagerPair: function(relationName, related, parentModels) {\n        // If this is athroughorbelongsToManyrelation, we need to cleanup & setup theinterim` model.\n        related = this.parsePivot(related); // isJoined() would be true any way\n    // Group all of the related models for easier association with their parent models.\n    var grouped = groupBy(related, function(m) {\n       return m.pivot.get(this.key('foreignKey')); // as (`m.pivot` === true) and ( (this.isInverse() && this.isThrough()) === false)\n    });\n\n    // Loop over the `parentModels` and attach the grouped sub-models,\n    // keeping the `relatedData` on the new related instance.\n    each(parentModels, function(model) {\n      var groupedKey = model.get(this.key('foreignKey')); // this.key('foreignKey') should equal 'provider_id'\n      var relation = model.relations[relationName] = this.relatedInstance(grouped[groupedKey]);\n      relation.relatedData = this;\n      // if (this.isJoined()) _.extend(relation, pivotHelpers);  <= THIS CANNOT BE DONE AS `pivotHelpers` is internal of \"realtion.js\"\n    });\n\n    // Now that related models have been successfully paired, update each with\n    // its parsed attributes\n    related.map(model => {\n      model.attributes = model.parse(model.attributes)\n    });\n\n    return related;\n  }\n}).init(this).through('Provider');\n\n}\n```\nI have to say it is really hacky. But it could work.\n. Hey @chamini2. This is an issue of bookshelf (and also knex has it) that it can't be installed from repository. The only quick and simple way for you would be to use your own branch and update your package.json to add postisntall script npm run build.\nI have discussion with @rhys-vdw on a topic how to solve mentioned problem. Actually there is a solution in place. But for unknown reasons it keeps ruining up the postinstall script in package.json. So we need to find another one.\n@rhys-vdw currently responsible of releases. He promised to make a release soon. Sadly I do not know when he can find time for that.\n. @chamini2 As there is not standard way for doing this, overriding hocus-pocus again must be done.\njs\nuser: function() {\n  return this._relation('belongsTo', bookshelf.model('User'), {\n    foreignKey: 'activity_id',\n    joinClauses: function(knex) {\n      knex.join('user_activities', 'users.user_id', '=', 'users.id');\n    },\n    joinColumns: function(knex) {\n      knex.columns(['user_activities.' + this.key('foreignKey') + ' as _pivot_' + col]);\n    },\n    whereClauses: function(knex) {\n      const key = 'user_activities' + '.' + this.key('foreignKey');\n      knex.where(key, this.parentId);\n    },\n    eagerPair: function(relationName, related, parentModels) {\n      related = this.parsePivot(related);\n      const grouped = _.groupBy(related, (m) => m.pivot.get(this.key('foreignKey')) );\n      _.each(parentModels, (model) => {\n        const groupedKey = model.id;\n        const relation = model.relations[relationName] = this.relatedInstance(grouped[groupedKey]);\n        relation.relatedData = this;\n      });\n      related.each((model) => {\n        model.attributes = model.parse(model.attributes)\n      });\n      return related;\n    }\n  });\n}\nI hope through is not necessary.\n. isThrough is false. Thats why joinClause doesn't get called,\n``` js\n user : function() {\n    return this._relation('belongsTo', bookshelf.model('User'), {\n      foreignKey  : 'activity_id',\n  // ####   HERE   ####\n  throughTarget: bookshelf.Model,\n  // ################\n\n  joinClauses : function(knex) {\n    knex.join('user_activities', 'user_activities.user_id', '=', 'users.id');\n  },\n  joinColumns : function(knex) {\n    let key = this.key('foreignKey');\n    knex.columns(['user_activities.' + key + ' as _pivot_' + key]);\n  },\n  whereClauses : function(knex) {\n    const key = 'user_activities' + '.' + this.key('foreignKey');\n    knex.where(key, this.parentId);\n  },\n  eagerPair : function(relationName, related, parentModels) {\n    related = this.parsePivot(related);\n    const grouped = _.groupBy(related, (m) => m.pivot.get(this.key('foreignKey')) );\n    _.each(parentModels, (model) => {\n      const groupedKey = model.id;\n      const relation = model.relations[relationName] = this.relatedInstance(grouped[groupedKey]);\n      relation.relatedData = this;\n    });\n    related.each(model => model.attributes = model.parse(model.attributes));\n    return related;\n  }\n}).init(this);\n\n},\n```\nSetting throughTarget should fix it.\n. I have thought about using columnInfo for that as well. There isn't a common way currently. You could solve it with a plugin. There are parse and format methods that you could override (and call super internally).\nLook #1101 for some example.\n. Hi @ijc-90.\nCould you please provide a stacktrace of the error or just a line number and file name where this error gets thrown?\n. How does your app/models/base_model.js look like?\n. Your problem lies here instead\njs\nreturn Promise.map(options.withRelated, function (relation) {\n    return model.related(relation);\n})\n .map(function (model) {\n     return model.triggerThen('fetched', model, model.attributes);\n});\nAs your withRelated has a value ['type.gateway'] following code model.related(relation) tries to resolve model.related('type.gateway'). This is not supported. You have to resolve eagerly loaded relations separately model.related('type').relation('gateway').\n. @ijc-90 Did you get it working?\n. Glad I could help.\nClosing as resolved.\n. @spamguy I assume you are trying to use bookshelf.transaction. As you can read it is an alias to knex.transaction method. At the end of referenced section there is a note:\n\nNotice that if a promise is not returned within the handler, it is up to you to ensure trx.commit, or trx.rollback are called, otherwise the transaction connection will hang.\n\nThe actual implementation of this note can be found in knex transaction.js#L42-L45.\nSo preferred usage would be:\njs\nbookshelf.transaction(function(trx) {\n  trx.commit();\n  trx.rollback();\n})\nBy looking the implementation this is not supported by knex.\nSimilar to your requested behaviour can be achieved by doing.\njs\nnew Promise(resolver, rejecter) {\n  bookshelf.transaction(resolver).catch(rejecter);\n}).asCallback(... callback ...);\n:grey_exclamation: So if you feel that is still an issue please create an issue entry for knex.\n. Closing as not an issue of bookshelf but knex.\n. @chamini2 I think it is a good catch to solve it in a more abstract way.\nBut I have to strongly mention that using _relation with options that override Relation methods is not a standard way to solve non-supported relations. It is a feature that I accidentially found when I faced the same kind of problems.\nAll use cases seem to be covered by tests. Good to merge.\nThanks @chamini2\n. @rhys-vdw made the v0.10.0 release already. Sadly only lodash upgrade is included. But the other updates are still in the pipe.\n. The announcement should have been more cheerful :smile: \n:tada: v0.10.0 released :tada:\n. Hi @miketerpak \nI assume that your described behavior is related to related method?\n\nThe related method returns a specified relation loaded on the relations hash on the model, or calls the associated relation method and adds it to the relations hash if one exists and has not yet been loaded.\nSo that is the expected behavior.\n\nBut if you are referring to toJSON that serializes the results then it is a reported bug #753.\n. How to replicate this?\n. Hi @lukywong. Could you try without the fat arrow?\njs\nIndent.query(function(qb) { indentQuery(query, qb); }).fetchAll()\n. Hi @Titozzz \nI would suggest you to use the standard way that Bookshelf provides. All collections are populated with a list of lodash methods. The full list of lodash methods are also documented.\nSo you could easily do:\njs\ncollection.map(function(model) {\n  // perform mapping operation\n})\n. I would suggest bookshelf-paranoia instead of bookshelf-soft-delete as it works for eagerly loaded relations too.\nbookshelf-modelbase is one neat plugin.\n. Hi @zigzag-way \nYou can use this internal API. But still the correct way would be to use related method. Then if you don't have the relation present an empty Collection/Model gets created.\n. @chamini2 All the events magic lies in model.js#L971-L1034. And if you take look in events.js#L98-L105 then you can see that these are just promise chains. Promise chains currently can only be breaked by throwing an exception.\nYou could work out a workaround by implementing your own error and then catching it.\njs\nPromise.resolve()\n.then(function() {\n  return Promise.resolve('x')\n  .tap(function(x) {\n    throw new CustomError();\n  });\n}).then(function(y) {\n  // never reaches here\n}).catch(CustomError, function(){\n  // all ok. just pass\n}).then(\n. . . .\n. @chamini2 Take it as GOTO behaviour. As you know Promise is a tool to handle callback hell. If you use Node style then you pass Error to callback as long some callback handles it. So Promise is a callback chain. If you throw an Error then it is a \"GOTO statement\". If catch it, it is the \"destination\" of GOTO in the chain of callbacks.\n. @ryanvanderpol \nBookshelf doesn't support it by native. But I already adviced once today in #612 on fellow to use bookshelf-manager plugin that may help you. \n. @ryanvanderpol\nThis is how it currently is meaned to be used. But the dreams are big to have it one day as built in a solid feature. Sadly not any time soon.\n. It must be kept in mind that babel is required for building. But it is not needed in production. So it shall be installed if lib is missing and is not yet installed.\n. npm install --only=dev does too much. As installing sqlite3 on windows is not the easiest thing to resolve. It should install only babel.\n. It should be installed programmatically by using npm package or something similar. And by cherry picking only the needed ones from dev dependencies.\nhttp://stackoverflow.com/a/20686728/878435\n. Hi @teckays\nWhy can't you just use bookshelf.Collection.EmptyError?\njs\nconst Model = bookshelf.Model.extend({\n ...   \n}, {\n    findAll: function() {\n        return this\n             .where({clause})\n             .fetchAll({require: true})\n             .then((entries) => entries.toJSON())\n             .catch(bookshelf.Collection.EmptyError, (err) => Promise.reject(<customError>))\n    }\n})\n. Hi @andrezzoid\nYou could use Collection#updatePivot for this case. The examples of usage can be found from tests.\n. @andrezzoid If this doesn't suit you then you have to do it manually by using separate Model for joined table.\n. Hi @raj-optisol \nI think the example you found has a bug.\n``` js\nUser = bookshelf.Model.extend({\n  tableName: 'users',\n  initialize: function() {\n    this.on('saving', this.assertEmailUnique);\n  },\n  _assertEmailUnique: function(model, attributes, options) {\n    if (this.hasChanged('email')) {\n      return this\n        .query('where', 'email', this.get('email'))\n        .fetch(.pick(options, 'transacting'))\n        .then(function (existing) {\n      // Currently it throw an error if 'email' is existing\n      // existing = new bookshelf.Model()\n      // console.log(!existing) // true\n      if (!existing) throw new Error('duplicate email');\n\n    });\n}\n\n}\n});\n```\nSo it should be...\njs\nif (existing) throw new Error('duplicate email');\n. @raj-optisol There is now way at the moment how to distinguish errors thrown by knex. https://github.com/tgriesser/knex/issues/522\n. Hi @hagabaka \nMay I ask which DB engine (+ version) are you using? And Is the schema still changeable? Maybe I can suggest you a better solution.\nAs I understand currently you are using/referring to Class Table Inheritance (aka Table Per Type Inheritance):? So every propery (lets call them so) lives in a separate table\nIf not, then I will figure out something for you.\n. Ok. Now I get it.\nWhen you are doing A.fetchAll({withRelated:'subtype'}) then only 2 requests are performed\n1. Fetch all records. Return a collection. Collection can only  be of one type. As your A isa base model it doesn't have a type value.\n2. Fetch all eager subtype table records. Associate them by A.id. So this query doesn't know about type field as it fetches all records from the subtype table and then associates them with base by id only.\nSo to get it work you would have to do n+1 query by yourself as you referred you are doing. The simplest option would be by combining Collection.invokeThen and Model.load.\njs\nA.fetchAll().then(function(a_collection) {\n  return a_collection.invokeThen('load', 'subtype');\n}).then( ... )\n:exclamation: But I might say that it is not a good practise because of n+1 queries. With your current DB scheme it is inevitable. You should make your subtype relations type aware and use polymorphic anti-pattern.\n. Hi @Titozzz \nAs you are trying to use orderBy with custom column you should look at lines helpers.js#L121-L123 as well.\njs\n/*121*/ return obj.query(qb => {\n/*122*/   qb.orderBy(_sort, _order);\n/*123*/ });\nSo you should use knex#orderBy to define your query order.\n. Hi @raj-optisol \nYou can use .query().toSQL() or  .query().toString(). But achieving exact result as in Rails is a bit more complicated as queries may be not complete. The cause is that many statements get applied just before performing the query in Bookshelf. For example Bookshelf relations behave so. Also many plugins use events to apply query statements. If you want to debug the queries then I would suggest you to use Knex#debug instead. For example\njs\nmodel.query(function(qb) {\n  qb.debug(true);\n}).fetch()\nIt prints the debug info in the console.\n. It is not so simple. NodeJS is all about events. Query can be modified by Model fetching event. That means we do not have the full query before it is really being fetched, sent to knex and handled by the DB.\nThis means refactoring the current codebase to support this feature. As this is Open Source project it lives it's life along with the needs of its developers who are willing contribute.\nAs I like to say:\n- Open Source is the best thing that could have happened. (because it is free and you could implement fixes yourself)\n- Open Source is the worst thing to be happening. (because it is free and nobody else is going to solve your specific problem for you)\n. If you do not have query modifications by events you could use just model.query().toString()\n. @cjnqt Is this for testing purposes?\n. Why don't you use Bookshelf::transaction?\n. Closed because of incativity and possibly not an issue.\n. You should create a new issue for this question. But...\nIt would be the best if these two databases have their own way to perform replication. It shouldn't be a responsibility of business logic.\nBut if you still wan't it to be a business logic then as a transaction it is not possible. You could listen knex query-response event and put your own replication in place.. You should create a new issue for this question. But...\nIt would be the best if these two databases have their own way to perform replication. It shouldn't be a responsibility of business logic.\nBut if you still wan't it to be a business logic then as a transaction it is not possible. You could listen knex query-response event and put your own replication in place.. returning statement is not so universal for all db engines.\nhttps://github.com/tgriesser/bookshelf/issues/507#issuecomment-231316905\n. @arden You could return a promise that resolves with attrs.\n``` js\n    toJSON: function toJSON(options) {\n        options = options || {};\n    var attrs = tujiaoBookshelf.Model.prototype.toJSON.call(this, options);\n    let image = this.get('image');\n    if (!_.isEmpty(image)) {\n        attrs.image = config[config.env].image.tuyaImageUrl + image;\n    }\n\n    return Promise.try(function() {\n      // call other async methods\n    }).return(attrs);\n},\n\n```\nAnd then by knowing toJSON returns a Promise using it as a promise.\njs\nmodel.toJSON()\n.then(function(attrs) {\n  // do your stuff\n})\n``\n. Hi @chamini2 \nDoesn't this suggested API make morphTo too complex? Maybe a completely separate relation type morphToMany should be added?\n. Actually I agree with you. @chamini2  Willing to contribute with a PR for this API improvement?\n. @chamini2 How can you use then on a model? Maybe you meant...\njs\nphoto.related('imageable')\n  .fetch()\n  // In this case it is a Site\n  .then((img) => img.fetch())\n  .then((img) => {\n    // img is null here\n  })\nSo the issue gets preproduced if the fetch gets called second time?\n. Seems to be a bug. It needs to be investigated why it occurs.\n. Huh. Sry @chamini2 . I have somehow missed this PR. I did rerun the tests. There seem to be issues with the PR.\n. Seems that there is an issue with eager loads morphTo (photos -> imageable) test.\nSomewhy imageable doesn't get wetched.\n. @chamini2 \nThis seems to be a knex issue. https://github.com/tgriesser/knex/issues/1537\n. I'm using a json field. I had problems. I solved them by implementing a plugin that overrides parse and format methods.\n``` js\nvar _ = require('lodash');\nvar Promise = require('bluebird');\nmodule.exports = function(Bookshelf) {\n  if (!Bookshelf) {\n    throw new Error('Must pass an initialized bookshelf instance');\n  }\n  var modelCtor = Bookshelf.Model;\nvar parseJsonColumns = function(attrs) {\n    if (.isArray(this.jsonColumns)) {\n      this.jsonColumns.forEach(function(key) {\n        if (.isString(attrs[key])) {\n          attrs[key] = JSON.parse(attrs[key]);\n        }\n      });\n    }\n    return attrs;\n  };\n  var formatJsonColumns = function(attrs) {\n    if (.isArray(this.jsonColumns)) {\n      this.jsonColumns.forEach(function(key) {\n        if (.isPlainObject(attrs[key])) {\n          attrs[key] = JSON.stringify(attrs[key]);\n        }\n      });\n    }\n    return attrs;\n  };\nBookshelf.Model = modelCtor.extend({\n    parse: function(attrs) {\n      parseJsonColumns.apply(this, arguments);\n      return modelCtor.parse.apply(this, arguments);\n    },\n    format: function(attrs) {\n      formatJsonColumns.apply(this, arguments);\n      return modelCtor.format.apply(this, arguments);\n    }\n  });\n};\n``\n. @eltonk You could use virtuals plugin. But virtuals plugin by nature is synchronous. If any async procedures are involved I would suggest to use [events`](http://bookshelfjs.org/#Model-subsection-events). Events are promise friendly.\n. Bookshelf is using Knex as a DSL. countDistinct is a part of Knex API.\nBookshelf pagination has multiple problems that I have solved to myself as a proprietary plugin (copy/paste). You could make solve your problem similarly.\n. But I see it as a bug of pagination.js.\n. I might be a bug.\n@Znarkus The way you are trying to use `attach  should be possible by looking the source. But it doesn't have any tests. So I think this feature implementation may have not been completed.\nBut I am not fully confident about that. Which options are passed to attach in opts variable?\n. @Znarkus Did you investigate it further?\n. @Znarkus What about using collection and knex querybuilder?\n`` js\nFile.collection().query(function (qb) {\n  // Perform SQL joining\n  qb.join(FileResource.prototype.tableName, FileResource.prototype.tableName + '.file_id', File.prototype.tableName + '.id')\n    // Apply conditions\n    .where(FileResource.prototype.tableName + '.fileable_type', resourceType)\n    .andWhere(FileResource.prototype.tableName + '.fileable_id', resourceId)\n// Declare that you would like to return onlyfiles` table fields\n}).fetch({columns: [File.prototype.tableName + '.*']})\n// or by using fetchAll\nFile.query(function (qb) {\n  // Perform SQL joining\n  qb.join(FileResource.prototype.tableName, FileResource.prototype.tableName + '.file_id', File.prototype.tableName + '.id')\n    // Apply conditions\n    .where(FileResource.prototype.tableName + '.fileable_type', resourceType)\n    .andWhere(FileResource.prototype.tableName + '.fileable_id', resourceId)\n// Declare that you would like to return only files table fields\n}).fetchAll({columns: [File.prototype.tableName + '.*']})\n``\n. @chamini2 [fetchAll`](http://bookshelfjs.org/index.html#Model-instance-fetchAll) is a alias of...\n``` js\nthis.forge().fetchAll(options)\n// to be exact\nfetchAll(options) {\n  return this.forge().fetchAll(options);\n}\n```\nGood point to have it in docs.\n. @nabilfreeman Could you specify?\n. @chamini2 I have faced this issue before by myself. The thing is that when you call Model.collection() then the events doesn't get copied to the new collection instance. Look this. The solution would be to override Model::collection method...\njs\nModel.extend({\n  ...\n}, {\n  collection: function() {\n    return Model.collection.apply(Model, arguments).on('fetching', function (collection, columns, opts) {\n      // do your stuff\n    });\n  }\n})\n. Hi @yansenarmandau \nSorry for the delay. The use of transaction should be correct. How do you perform the 10 times invoking of the procedure?\n. Hi @castarco \nSome tests would be welcomed to confirm the necessity of this change.\n. @castarco, for the delay\nI guess that this would be enough. Are you still willing to finish the PR?\n. @castarco I rerunned the test. It passed.\n. Thanks @castarco \n. Regards @venables \n. Hi @orgertot \nI think in this case you would have to implement your own registry plugin. Or not to use registry plugin at all by referencing the Models directly.\n. Sadly Collection::attach works only for belongsToMany relation.\nSorry @alexey2baranov. There is no other way than inserting/saving the relation(s) by yourself and then adding them to the collection. Or if you do not want to add them to collection you may just use Model::load on User to fetch them after saving them.\nAlso deletion shall be performed the same way.\n. For example to not perform Model::load...\njs\naddresses = user.related('addresses')\naddresses.add([\n  { user_id: user.id, type: 'e-mail', value: 'some.email@address.com' },\n  { user_id: user.id, type: 'home', value: 'some house address' }\n]).invokeThen('save')\n.then(function (addresses) {\n  // other procedures\n})\n. Hi @kahwooi \nYou could use Colection::invokeThen...\njs\nSales.collection(data).invokeThen('save').then(function(sales){\n  // use saved sales\n});\n. Hi @alexey2baranov \nBy calling fetch you are declaring to get User and eager load all the addresses with it. Eager loading can be done only by knowing the id of the User. As you know only the e-mail of the user at that point of time the User must be fetched from the db by providing e-mail. Then the id can be used as a foreign key on the addresses relation and can be eager fetched.\nIf you know the id of the user you could do...\njs\nUser.forge({id: 1}).load(['addresses']) // returns User model without performing fetch from\n                                        // `users` table but only from `addresses` table\n// or\nUser.forge({id: 1}).addresses().fetch() // returns collection of Address models related with\n                                        // the User\n. Sry @alexey2baranov . I have missed something in your example.\nYou could optimize it by doing...\njs\nUser.forge({email: 'joe@example.com', name: \"joe\"})\n    .save()\n    .tap(user => {\n        return Address.forge({value:\"surgut\", user_id:user.get(\"id\")})\n            .save()\n    })\n    .then(user => {\n        return user.load({withRelated: ['addresses']})\n    })\n    .then(function(user) {\n        console.log('Got user:', user.get('name'));\n        console.log('Got addresses:', user.related('addresses'));\n    });\nLook Promise::tap for more info. And investigate using promises. Makes your life easier in the future. :wink: \n. @alexey2baranov Take a look at the tests. \n. sql\nselect distinct ON (type) \"type\",\n                          \"description\",\n                          \"options\",\n                          \"user_id\"\nfrom   \"user_settings\"\nwhere  ( \"user_settings\".\"user_id\" = '385'\n          or \"user_id\" is null )\n       and \"type\" in ( 'notify-user-payment-payment-declined',\n                       'notify-user-news-story' )\norder  by \"type\" asc,\n          \"user_id\" ASC NULLS LAST\nsql\nselect distinct ON (type) \"type\",\n                          \"description\",\n                          \"options\",\n                          \"user_id\"\nfrom   \"user_settings\"\nwhere  ( \"user_settings\".\"user_id\" = ? -- binding: '385'\n          or \"user_id\" is null )\n       and \"type\" in ( ?, -- binding: ''notify-user-payment-payment-declined''\n                       ? ) -- binding: 'notify-user-news-story'\norder by \"type\" asc,\n         \"user_id\" ASC NULLS LAST\nI don't see any other differences than bindings are used.\n. Hi @dj-hedgehog \nThis is valid and expected behavior for eager loading. But your example models setup seems to not reflect your actual models. The field bidder in query select \"bid\".* from \"bid\" where \"bid\".\"bidder\" in (?) gets computed from tablename and should be bid_id. So assume that your Auction bids declaration seems something like this.\njs\nvar Auction = bookshelf.Model.extend({\n  tableName: 'auction',\n  highestBid: function() {\n    return this.hasOne(Bid);\n  }\n  bids: function() {\n    return this.hasMany(Bid, 'bidder'); // <--\n  }\n});\nI am sorry but instead of me assuming things, you should read the spec and look the tests for examples.\n. @dj-hedgehog By looking Auction relation bids it is a hasMany relation. So it should return all related bids. Maybe you can specify your question or example?\n. Good, clarifies.\nAuction.forge(id: 1).fetch({withRelated: ['bids']}) should perform 2 queries. Something like\n- select \"auction\".* from \"auction\" where \"auction\".\"id\" = ? limit ?\n- select \"bids\".* from \"bids\" where \"bids\".\"auction_id\" IN (?)\nSo could you copy/paste the declaration of bids relation of Auction model? The example Auction model that you provided should generate second query like I described.\n. Good that you found out! :smile:\n. Hi @olalonde \ntoJSON method doesn't know how to handle cyclic references. This is one reason why the inverse relation is not attached to User model in given case.\nBut as you already have the AuthProvider instance, it is not required to \"resolve\" it again.\njs\n   AuthProvider\n      .forge({ id })\n      .fetch({\n        withRelated: ['user'],\n      })\n      .then((authProvider) => {\n        if (!authProvider) {\n          throw new Error(`unknown user ${id}`)\n        }\n        const user = authProvider.related('user')\n        console.log(user)\n        // How to do this? console.log(user.related('authProvider'))\n        console.log(authProvider)\n      })\n. @lyfeyaj I think you should use morphTo instead. Actually I think that PR #1326 will meet your needs.\n. It is an issue with the documentation. fetchPage is added by pagination plugin.\n. I have been using plugin that creates a static method field.\njs\nmodule.exports = function (bookshelf, options) {\n  bookshelf.Model = bookshelf.Model.extend({}, {\n    field: function (fieldName) {\n      return this.prototype.tableName + '.' + fieldName;\n    }\n  });\n};\nThen it can be used like Model.field('someFieldName'). Eg.\njs\nAuthor.forge().books().query(function (qb) {\n  qb.where(Book.field('id'), 2); // WHERE books.id = 2\n}).fetchOne()\n// . . .\n. Hi @vanesyan \nAny comment on this? Or explanation?\n. @tgriesser ping\nI think it would be best to wait until the maintanance is dropped. It is not very far away for v0.10 (2016-10-01). But is a bit further away for v0.12 (2016-12-31).\n\u2757 I would strongly recommend to roll back deps that have dropped support for Node (< 4).\n\nfrom https://github.com/nodejs/LTS\n. I agree with @vanesyan \nSo the following plan would be:\n1.  Fix v0.xx support for v0.10.x of Bookshelf.\n2. Drop support from >= v0.11\n. @tgriesser ping\n. @tgriesser\nThe other way would be to rollback the eslint dependency to ^2.13.0 and release a new patch version 0.10.2 for Bookshelf to fix it for Node v0.10 and v0.12. And as you said release a new minor v0.11.0 of Bookshelf with latest eslint.\n. Any way. This needs a resolution. I would handle it myself in described way (not current PR) but I don't have permissions on npm.\n. I will be your stacktrace:\n... -> model.js#L613\nmodel.js#L616 -> model.js#L619\nmodel.js#L624 -> sync.js#L34\nsync.js#L44 <= all objects are omitted from attributes and will not end up in query\n. If you use some query parameters straight from parsed object it woud suggest you to verify the types. Actually they can be strings or object with keys having string values.\n. I really consider it as a feature of bookshelf not a bug. As fields may be JSON fields they cannot be used in as a query condition. So you must take into account that query gets parsed into an object.\nI'm gonne close this issue as a \"not a Bookshelf issue\".\nIf you have a better reason why this is still an issue of bookshelf, then let me know and I may open it again.\nThank you for your collaboration.\n. No offence. You have bounced to this feature. I must say that you have tested your code good.\nI understand your concern. But the purpose of an ORM is to make DB manipulation easier. It is not a solution to all of your sorrows. Actually your application should have another layer between your ORM and server (aka express js). If you know Rails then it has Strong Parameters that will whitelist the parameters.\nAs JS is not a strongly typed language it is up to you to make sure that every argument gets passed correct.  It may happen with every module. NEVER just pass the parameters to ORM from router without checking its validity. Let's say you have boolean is_admin field. You should blacklist this somehow from getting passed to ORM straight from HTTP request. NodeJS alternative to Rails like Strong Parameters I would suggest you to use strong-params.\n. Actually yeah, it is redundant. I misunderstood the babel-runtime dependency and moved it under devDependencies. I understood my mistake and moved it back. But the value vas left in buildDependencies.\nWill fix it.\n. js\nBook.forge({name: 'test'}).save()\n.then(function(book) {\n  book.related('pages').attach({name: 'book'})\n  .then(function(pages) {\n    // use `book` or `pages`\n  })\n})\nInvestigate the documentation.\n. You are not referring the object but the id of the object.\njs\nPage.forge({content: 'test', book_id: 27}).save()\n.then(function(page) {\n   // use `page`\n})\n. I think this duplicates PR #1397\n. As this only targets belongsTo I would prefer to keep going with #1397 as it targets all relations,\n@chamini2 Could you collaborate on #1397?\n. Not bad @ricardogama . Could you write a test for it?\n. Regards @ricardogama \n. Hi @chiangf \nCould you be more detail?\n. @chiangf I see. I think that the NULL foreign key cannot be skipped. At least I do not have an idea how to skip it.\n. Eager loading is being executed any way - is it NULL or not. That's just the behavior of eager loading. I agree, that it could be improved.\n. Hi @pruhstal\nFew notices.\nBut use stackoverflow. Github is for issues related with the library provided by the repository.\n``` js\n    module.exports.model = bookshelf.Model.extend({\n      tableName: 'books',\n  user: function() {\n    return this.belongsTo(User, 'user_id'); // hasOne --> belongsTo\n  },\n\n  reviews: function() {\n    return this.hasMany(BookReview);\n  }\n});\n\nmodule.exports.model = bookshelf.Model.extend({\n  tableName: 'users',\n\n  reviews: function() {\n    return this.hasMany(BookReview, 'user_id');  // belongsTomany --> hasMany\n  }\n});\n\n```\n. Closing as not an issue\n. @MarkHerhold Sorry. I once already was in the middle of merging it but something got in the way. Thanks again.\n. Hi @MarkHerhold \nNodeJS 0.10 and 0.12 support will get dropped for bookshelf next minor (v0.11) version.\nAlready discussed issue. Closing.\nhttps://github.com/tgriesser/bookshelf/pull/1398#issuecomment-250213228\n. Hi @scalhoun \nI'm sorry I couldn't respond faster. You using it the correct way now.\nCan this be closed now? Thanks\n. Hi @gabmontes \nThe thing is that when you do unset then actually a key is deleted from entity.attributes. \nThis means that Bookshelf doesn't know anything about this field and performs an UPDATE query without this field setter. So actually you should do entity.set('prop', null). In this case entity.attributes['prop'] = null gets performed and UPDATE query has field setter for that.\nSo actually I can't really understand why there is such a method like unset. I have never used it. I understand what you intended to use it for.\nClosing as not an issue but feature\n. I agree. PR welcomed.\n. @gabmontes Good. Thanks for contributing.\n. Seems reasonable... Thanks\n. Hi @tmorehouse \nI using using JSON field the same way and I have made Bookshelf plugin to target this issue:\n``` js\nmodule.exports = function (Bookshelf) {\n  if (!Bookshelf) {\n    throw new Error('Must pass an initialized bookshelf instance')\n  }\nfunction ignoreOnFormat (attrs) {\n    if (this.ignoreColumnsOnSave) {\n      this.ignoreColumnsOnSave.forEach(function (column) {\n        delete attrs[column]\n      })\n    }\n  }\nvar ModelCtor = Bookshelf.Model\nBookshelf.Model = ModelCtor.extend({\n    format: function (attrs) {\n      ignoreOnFormat.apply(this, arguments)\n      return ModelCtor.prototype.format.apply(this, arguments)\n    }\n  })\n}\n```\nAn use it like:\njs\nBookshelf.Model.extend({\n  tableName: 'someTableName',\n  ignoreColumnsOnSave: ['foobar']\n})\n. Hi @tmorehouse \nI using using JSON field the same way and I have made Bookshelf plugin to target this issue:\n``` js\nmodule.exports = function (Bookshelf) {\n  if (!Bookshelf) {\n    throw new Error('Must pass an initialized bookshelf instance')\n  }\nfunction ignoreOnFormat (attrs) {\n    if (this.ignoreColumnsOnSave) {\n      this.ignoreColumnsOnSave.forEach(function (column) {\n        delete attrs[column]\n      })\n    }\n  }\nvar ModelCtor = Bookshelf.Model\nBookshelf.Model = ModelCtor.extend({\n    format: function (attrs) {\n      ignoreOnFormat.apply(this, arguments)\n      return ModelCtor.prototype.format.apply(this, arguments)\n    }\n  })\n}\n```\nAn use it like:\njs\nBookshelf.Model.extend({\n  tableName: 'someTableName',\n  ignoreColumnsOnSave: ['foobar']\n})\n. @Natanael1234 \nCollection::where actually internally calls lodash::find or lodash::filter. If you want to apply conditions you have to use Collection::query.\n. @darkghoul79 This is a previously known problem actually #1031.\nI have solved it previously a bit hacky way - https://github.com/tgriesser/bookshelf/issues/1031#issuecomment-218313647. Maybe it is helpful for you.. @pmettraux Great work!\nI forgot that not everybody has a long weekend. 1st of May is a holiday in wide range of European countries. I just wanted to start rebasing.\nSadly as this is still my implementation. I am not willing to merge it. @kirrg001 please review and merge  the PR.. js\n/*264*/ return relation;\nSeems that the tests are not doing enough.\n. As well array filtering shall be done in base/collection.js instead of here.\nCollectionBase#serialize docs shall be updated as well.\n. Currently omitNew doesn't work for collections.\njs\nvar collection = new SomeCollection([{id: 1}, {noid: null}, {id: 3}, {noid: null}]);\ncollection.toJSON({omitNew: true}); // => [{id: 1}, null, {id: 3}, null]\nThis case is not covered by your implementation nor tests.\n. I would use ES6 array destructing...\njs\nconst [Target] = _.find(candidates, ([,tableName]) => tableName === morphValue)\n. I don't really like that the API of morphTo gets slightly changed. But I don't have any better idea to solve it.\n. Ok. I'm good with it.\n. As it is not a registry plugin I would check for strings instead of using isNil. This way the API would be intact.\njs\nif (_.isArray(arguments[1]) && arguments[1].every(_.isString)) {\n  columnNames = arguments[1];\n. I think lodash::filter is redundant here.\njs\ninvokeMap(this.models, 'toJSON', options).filter(negate(isNull))\n. :+1: \n. I still think that we cannot change the core Model API.\njs\n// This should be possible when \"registry\" plugin is not used\nthis.morphTo('imageable', null, Site, Author)\nIt is used by many Bookshelf users. Actually I think it is used also with \"registry\" plugin. So the best would be that it is not changed for that too. But as there is no way to determine for 2nd argument if the array is the declaration for column names or for Model name and morphValue.\nSo I would suggest to refactor following logic.\njs\nif (_.isArray(arguments[1])) {\n  columnNames = arguments[1];\n} else {\n  columnNames = null;\n}\nif (_.isArray(arguments[1]) || _.isNil(arguments[1])) {\n  candidates = _.drop(arguments, 2);\n } else {\n  candidates = _.drop(arguments, 1);\n}\nand implement it to look the first array argument to be string as I did indicate previously.\njs\nif (_.isArray(arguments[1]) && arguments[1].every(_.isString)) {\n  columnNames = arguments[1];\n  candidates = _.drop(arguments, 2);\n} else {\n  columnNames = null;\n  candidates = _.drop(arguments, 1);\n}\n. This could be optimized to\njs\nif (isArray(arguments[1]) || isNil(arguments[1])) {\n  columnNames = arguments[1]; // may be `null`\n  candidates = drop(arguments, 2);\n} else {\n  columnNames = null;\n  candidates = drop(arguments, 1);\n}\n. In original API the second parameter as columnNames is optional. Previously the given parameter was the only type of array. Now as you are using arrays to declare morphValue to you can not make columnNames optional.\n. No offence. I had more trouble to read it this way.\n. consider this one without registry plugin:\njs\nmorphTo('imageable', [Site, 'cover_photo'], [Author, 'profile_pic'])\n// columnNames: [Site, 'cover_photo']\n// morphValues: [Author, 'profile_pic']\nActually, yes, it doesn't reflect to old API. I am sorry. But it would make new API more fail proof.\n. This is not very self describing.\njs\nthis.foreignKeyTarget ? parent.attributes[this.foreignKeyTarget] : parent.id\nTo follow Bookshelfs pattern it would be great to have a method for condition checking.\njs\nthis.isTargetedForeignKey() ? parent.attributes[this.foreignKeyTarget] : parent.id\n// - - - - -\nisTargetedForeignKey() {\n  return (this.foreignKeyTarget != null);\n}\n. This also is not self describing why it is done. Again isTargetedForeignKey() would be recommended way to determine which key to use.\n. Self describing?\n. Use var instead of const. This is a requirement before Node 0.10 and 0.12 are dropped. I don't see a reason at the moment why should it be done. Only Node 6+ has ES6 near-full support. But people still use Node 4. Meteor just migrated it's core from 0.10 to 4.\n. By just unit testing if SQL is correctly built is not enough. Mostly in these cases eager loading may not work. And I am guessing that it is so at the moment. You should add migration to '/test/integration/helpers/migration.js' and write tests that target eager loading.\n. It goes for all relation types: hasOne, belongsTo, \u00b4hasMany\u00b4 & belongsToMany.\n. You should keep in mind that .through(...) can be used with each relation type.\nI know. The downside of solution implementation - loads and loads of tests.\n. _.clone(...) is a bit \"heavy load\" operation. Actually we would only need one key. Use _.pick(...) instead for specific key.\n. Same here....\n. Hmm... Yeah. You are correct. Then we'd still have to stick to using _.clone.\n. I think you meant:\njs\nconst parsedAttribute = _.head(_.keys(m.parse(_.invert({ attribute }))));\nreturn m.get(parsedAttribute);\n. That was my intention\n. I would wollow the current code practice as on line 452:\njs\n/*Not*/ return this.foreignKeyTarget !== undefined;\n/*But*/ return (this.foreignKeyTarget != null); // which is weaker comparison and is true for non-null/non-undefined values\n. Same here...\n. Redundant?\n. Same here...\n. Sry. I noticed it but forgot to mention: JSDoc update is missing\n. Great!\n. ",
    "kaemu": "Thank you, it works really better like that indeed!\n. but\n\nreturn this.hasMany(Log, 'machine_serialnum', 'serialnum');\n\nand\n\nreturn this.hasMany(Log, ['machine_serialnum', 'serialnum']);\n\ndon't work.\n{ sql: 'select Log.* from Log where machine_serialnum in (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',\n  bindings: [ 1, 9, 2, 5, 3, 11, 12, 14, 4, 18, 6, 7, 17, 8, 13, 16 ],\nbindings are machine PK, not Machine serialnum\n. ",
    "salper": "Also, as we are seriously thinking about moving from Sequelize to Bookshelf, is there any roadmap concerning future releases (for example, the migrate feature) ?\n. @tgriesser That was the patch associated with it. I just didn't have the time to dig further, and I was not sure if I was doing things right. I was using my fork instead on production. You merged it, so it's good for me.\n. @tgriesser That was the patch associated with it. I just didn't have the time to dig further, and I was not sure if I was doing things right. I was using my fork instead on production. You merged it, so it's good for me.\n. @tgriesser  Any news about this ?\n. @tgriesser  Any news about this ?\n. If there is already a nodeify interface on bluebird, why not using it directly if you are always returning a bluebird promise ? An if you need to abstract it, keeping exec as an alias would do the job.\n. If there is already a nodeify interface on bluebird, why not using it directly if you are always returning a bluebird promise ? An if you need to abstract it, keeping exec as an alias would do the job.\n. Well, that's what I meant. The other thing is that keeping exec or another alias will ease the pain when moving to another promise library (compatwise). I'll test it on my company fork tomorrow. \n. Well, that's what I meant. The other thing is that keeping exec or another alias will ease the pain when moving to another promise library (compatwise). I'll test it on my company fork tomorrow. \n. I couldn't wait, all our tests are running well. I also tried this on knex :\njavascript\nexec: function(callback) {\n  return this.then().nodeify(callback);\n},\nand everything worked fine.\n. I couldn't wait, all our tests are running well. I also tried this on knex :\njavascript\nexec: function(callback) {\n  return this.then().nodeify(callback);\n},\nand everything worked fine.\n. Probably a circular reference using require().\n. If exec plugin is applied, the exec shim is returned by the save, which provides no bind methode. Also, I used _.bind because I don't know if Bookshelf can be used client side. If that's not the case, I can replace it by f function {}.bind instead.\n. ",
    "benesch": "+1 for migrations. Currently trying to decide if it's better to continue with Sequelize with its lack of polymorphic relationships, or to switch to Bookshelf and give up on migrations. \nGood to hear it's in the works. I have a feeling the foundations of this project are much stronger.\nLet me know if I can help with migrations\u2014it's something I'd like to see pushed through ASAP. \n. Agh, yes! I just ran into this myself. I've put together a full demonstration of the bug.\nCurrently looking into a solution. Looks like the cleanest fix would be to not parse the model until after eager matching.\n. Okay, benesch/fix-#97 should fix it.\n@tgriesser\u2014thoughts? It might be cleaner to avoid creating any models until eager pairing's completed, but that would require a fairly substantial refactoring of the pairing code.\n. TODO: still broken on polymorphic relations :/\n. @tgriesser \u2014 no worries! Thanks for being so responsive in general.\n. @tgriesser \u2014 no worries! Thanks for being so responsive in general.\n. Shoot, sorry\u2014I don't have a test case for you.\nOn Sun, Nov 24, 2013 at 12:23 PM, Tim Griesser\n\n\nwrote:\n@benesch https://github.com/benesch - I was gonna merge this in and try\nto fix the polymorphic relations, did you happen to have a failing test for\nthat (if not I can whip one up really quick)?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/97#issuecomment-29160392\n.\n. Shoot, sorry\u2014I don't have a test case for you.\n\nOn Sun, Nov 24, 2013 at 12:23 PM, Tim Griesser\n\n\nwrote:\n@benesch https://github.com/benesch - I was gonna merge this in and try\nto fix the polymorphic relations, did you happen to have a failing test for\nthat (if not I can whip one up really quick)?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/97#issuecomment-29160392\n.\n. I'm with you on this. The problem is Bookshelf's internal promises module, when.js. Other promise implementations provide a done method, which signals the end of a promise chain. If you call .done() on a promise chain, any unhandled errors will be logged to the console:\n\njavascript\nuser.save().then(successFn)\n  .done();\nwhen has only just implemented done support, and Bookshelf is on an older release of when.\nIn the meantime, enable when/monitor/console. Any unhandled rejections will be logged to the console\u2014you don't even need to remember to call done!\nWhile it's possible that enabling debug mode in Bookshelf could load the monitor console, I think that's a decision better left to the user. I think the solution is better documentation. I'll open another issue.\n. https://github.com/tgriesser/knex/commit/ea0b7ffeba98347dfe2634647cf6b509ef984900\n. ",
    "ghost": "very nice!\n. +10 for custom custom column types,\nToday I work with several tables containing components postgis and it becomes impossible to use bookshelf\n. +10 for custom custom column types,\nToday I work with several tables containing components postgis and it becomes impossible to use bookshelf\n. Is possible with bookshelf and knex.raw but not with only bookshelf:\njavascript\ninitialize: function() {\n                this.on('fetching fetching:collection', function(model, columns, options){\n                    if(columns){\n                        columns.push(knex.raw(\"ST_AsGeoJSON(other.position) as position\"));\n                    } else {\n                        options.query.select(knex.raw(\"ST_AsGeoJSON(other.position) as position\"));\n                    }\n                });\n               this.on('fetched', function(model, response, options){\n                    // parse geo position to Object\n                    model = geo.simpleParse({\n                        data: model\n                    });\n                });\n}\nBookshelf has a Knex.js instance -> Bookshelf.knex\nhttp://bookshelfjs.org/#Utility\n. You can insert spatial data using the EWKT format as a simple string literal and it is inserted and handled without error (See http://postgis.net/docs/manual-1.3/ch04.html#id435014).\nvar newPhysical = Physical\n  .query('insert', {\n    geo: 'SRID=4326; POINT (' + x + ' ' + y)'\n  })\n  .save()\n  .then(...)\nThis is stored in postgres as a hashed geometry object that is converted back to the appropriate lat/lon using ST_AsText using SELECT ST_ASText(geo) as geo from [tablename]\n. Can you give a code example of the following: \"add a columns to the options hash in fetch,\"\nThanks!\n. Can you give a code example of the following: \"add a columns to the options hash in fetch,\"\nThanks!\n. Config file not having non-mysql dialects. Adding other dialects resolves the issue.\n. Without process.exit, the program just hangs which is why I was experimenting with it.\nI'd greatly appreciate any tiny but full pg example to confirm and complete my understanding (or lack) of this mini-stack (PromisesA+, bookshelf js, backbone and pg)\n-MN\n\nOn 04-Dec-2013, at 10:30 pm, Tim Griesser notifications@github.com wrote:\nThat's strange that it'd print out success without inserting the record... I'll try to reproduce and get back to you with what I find. Can you try taking out the process.exit does it seem to do the insert (if it does it seems like it's still a bug, just curious though).\n\u2014\nReply to this email directly or view it on GitHub.\n. After adding {method: 'insert'}, the insertion now happens but the process never ends.\nAny clue?\n\nAlso, how do I trap such 'reject' errors?\nHere's the output as requested:\n{ attributes: { primary_asset_id: 8, primary_asset_desc: 'Asset 8' },\n  _previousAttributes: { primary_asset_id: 8, primary_asset_desc: 'Asset 8' },\n  changed: {},\n  relations: {},\n  cid: 'c1',\n  id: 8,\n  _knex: null,\n  primary_asset_id: 8 }\nAnd the model is currently (also tried earlier with SERIAL instead of INTEGER:\nCREATE TABLE primary_asset\n(\n  primary_asset_id INTEGER NOT NULL UNIQUE,\n  primary_asset_desc VARCHAR(80) NOT NULL,\n  PRIMARY KEY(primary_asset_id)\n);\n. IMHO, an new object-save should be treated as an insert when the primary-key is supplied assuming that it is not a sequence/serial without having to explicitly specify it as an insert. \nUnless the BookshelfJS-ORM says by design  that all primary-keys (non-composite key) are always ids to be managed by db as sequece/serial and application has no control over its value.\nOn 06 Dec 2013, at 05:03, Ben Drucker notifications@github.com wrote:\n\n@tgriesser My only reason for doubting the wisdom of doing that is because different RDBMSs seem to have different ideas about what to return when it comes to updates. I'd consider 0 matched rows error-worthy, but not 0 changed rows. From a quick look at the integration test it seems like that would pass whether you had no Site with id: 200 or if you already had one with that id and name: 'This doesnt exist'. Is that right?\n\u2014\nReply to this email directly or view it on GitHub.\n. Ok, but if I execute this, it doesn't work:\n\nvar User = require('./user');\nvar Users = Bookshelf.MySQL.Collection.extend({\n    model: User\n});\nUsers.fetch().then(function (collection) {\n    console.dir(collection);\n});\nThis is the error I get: TypeError: Object function (){ return parent.apply(this, arguments); } has no method 'fetch'\n. Ok, but if I execute this, it doesn't work:\nvar User = require('./user');\nvar Users = Bookshelf.MySQL.Collection.extend({\n    model: User\n});\nUsers.fetch().then(function (collection) {\n    console.dir(collection);\n});\nThis is the error I get: TypeError: Object function (){ return parent.apply(this, arguments); } has no method 'fetch'\n. Ok, thanks for all the comments, really appreciate it.  I had a look at the collection and object files in the test packages and redesigned a couple things. \nSomething that I've been wondering about for a while now is how I can configure custom column names for attributes.  For instance, my User has 4 columns, FIRSTNAME, LASTNAME, PASSWORD and EMAIL).  But in my object I would like to use the camelcase attributes.\nAnd what if it's completely different.  I have a table with a OneToOne relationship with User, based on the UserID.  But the column in the other table is called OWNER.\n. Ok, thanks for all the comments, really appreciate it.  I had a look at the collection and object files in the test packages and redesigned a couple things. \nSomething that I've been wondering about for a while now is how I can configure custom column names for attributes.  For instance, my User has 4 columns, FIRSTNAME, LASTNAME, PASSWORD and EMAIL).  But in my object I would like to use the camelcase attributes.\nAnd what if it's completely different.  I have a table with a OneToOne relationship with User, based on the UserID.  But the column in the other table is called OWNER.\n. Ok, bit by bit I'm untangling it :).\nThe parse-method was what I was looking for, so I took care of the differences between var-names and column names.  Now, to get back to the relation-question, consider this:\nDatabase:\nUSER (USERID, FIRSTNAME, LASTNAME, EMAIL, PASSWORD);\nRECORD(RECORDID, NAME, OWNER);\nAs you can see, the record has exactly 1 owner.  The field corresponds to the field USERID in USER (but has a different name).\nSo after reading the documentation (and having a look at the objects.js in helpers). I came up with this:\n```\nvar Record = Bookshelf.Model.extend({\n    tableName: 'RECORD',\n    idAttribute: 'RECORDID',\n    user: function() {\n        return this.belongsTo(User, ['OWNER']);\n    }\n});\nvar User = Bookshelf.Model.extend({\n    tableName: 'USER',\n    idAttribute: 'USERID'\n});\n```\nHowever, when I fetch all the Records, I have no Users attached to them.  These are the collection definitions:\n```\nvar Users = Bookshelf.Collection.extend({\n    model: User\n});\nvar Records = Bookshelf.Collection.extend({\n    model: Record\n});\n```\nAnd this is how I retrieve the records:\nvar records = new Records().fetch({withRelated: ['user']}).then(function (records) {\n    records.forEach(function (record) {\n        console.log(record.toJSON());\n    } );\n});\nAnyone has an idea?\n. Already corrected it, but I still don't get to see my user :-/.  Copy/paste from the manual:\nvar records = new Records().fetch({withRelated: ['user']}).then(function (records) {\n    records.forEach(function (record) {\n        console.log(JSON.stringify(record.related('user')));\n    });\n});\nedit>\nThe data exists btw :).\nedit2>\nThese are the SQL statements that are being executed (and to mee they seem correct):\n{ sql: 'select `USER`.* from `USER`',\n  bindings: [],\n  __cid: '__cid1' }\n{ sql: 'select `RECORD`.* from `RECORD`',\n  bindings: [],\n  __cid: '__cid2' }\n{ sql: 'select `USER`.* from `USER` where `USER`.`USERID` in (?)',\n  bindings: [ 6 ],\n  __cid: '__cid3' }\nI assume that the bindings-attribute is the value which it's looking for on the USER-table, so that is correct.  However, the output us {} unfortunately.\n. Yeah, error in copy/pasting, my apologies. I updated my post to reflect the actual situation.\n. That worked. Is there a way to get around this?  I see that #97 has been opened 2 months ago :).\n. This is the complete model:\n```\nmodule.exports = function (Bookshelf) {\nvar User = Bookshelf.Model.extend({\n    tableName: 'USER',\n    idAttribute: 'USERID',\n    parse: function(attrs) {\n        return {\n            email: attrs.EMAIL,\n            password: attrs.PASSWORD,\n            firstname: attrs.FIRSTNAME,\n            lastname: attrs.LASTNAME\n        }\n    }\n});\n\nvar Record = Bookshelf.Model.extend({\n    tableName: 'RECORD',\n    idAttribute: 'RECORDID',\n    user: function() {\n        return this.belongsTo(User, 'OWNER');\n    }\n});\n\nvar Users = Bookshelf.Collection.extend({\n    model: User\n});\n\nvar Records = Bookshelf.Collection.extend({\n    model: Record\n});\n\nreturn {\n    Models: {\n        User: User,\n        Record: Record\n    },\n    Collections: {\n        Users: Users,\n        Records: Records\n    }\n}\n\n};\n```\nAnd this is how I tried to retrieve the records:\nvar records = new Records().fetch({withRelated: ['user']}).then(function (records) {\n    records.forEach(function (record) {\n        console.log(JSON.stringify(record.related('user')));\n    });\n});\nI did the exact same thing without the parse-method, and then it worked (so I just left the tableName and idAttribute in place).  \nAdditional question, right now I have my complete model in 1 file.  I'm using NodeJS, so I was wondering how I could easily split everything out in separate files and use it in my application.\n. Ok, now for some reason it started to work.  The only difference is that I added a parse-method to the Record-model.   So both objects now have a parse-method and all of a sudden it started to work.\nI have another question, but I'll open a new thread for that.  Thanks everyone for all the help :).\n. Ok, thanks for the help.  I just looked at the guide and it seemed the only fit location to do this :).\nWhat do you mean exactly with: \n\"You may want to consider refactoring this a little bit though. I'd recommend storing the hash as a different property. Password should only be defined for users that haven't been saved to the DB and hash will be defined once they are saved.\"\nThat's what I was doing, no?  Checking if it's a new user (with the isNew()-call) and only then calculate the hash. \nI'm planning to do a series of blog articles on this one btw (I'm creating a NodeJS web application with Bookshelf), so hopefully that will be one of the first real tutorials on Bookshelfjs :).\n. My solution is something like this\n``` javascript\ninitialize: function() {\n                this.on('fetching', function(model, columns, options){\n                    // Set default relation\n                    if(!options.withRelated){\n                        options.withRelated = [];\n                    }\n                    options.withRelated.push(\"other\");\n                });\n            this.on('fetched', function(model, response, options){\n                // parse geo position to Object\n                model = geo.simpleParse({\n                    data: model\n                });\n            });\n\n}\n```\nand the other model with postGIS\njavascript\ninitialize: function() {\n                this.on('fetching fetching:collection', function(model, columns, options){\n                    if(columns){\n                        columns.push(knex.raw(\"ST_AsGeoJSON(other.position) as position\"));\n                    } else {\n                        options.query.select(knex.raw(\"ST_AsGeoJSON(other.position) as position\"));\n                    }\n                });\n}\n. ok thanks, but in the future I think is good idea implement a option in 'fetch' like 'withOr' \nnew User({name: \"jhon\", username: \"jhon\"}).fetch({withOr: true})..\n. Ok thanks ;)\n. Yes works fine in 0.8.1,\njavascript\nvirtuals: {\n                id: function() {\n                        return this.get(\"user_id\");\n                    }\n                }\n}\nI not use virtuals for \"set\",  I only use \"virtual\" for facility return JSON\nI need to return, model.toJSON()\n{\nuser: {\n      id: 2,\n      name: \"test\"\n   }\n}\nand not\n{\nuser: {\n      user_id: 2, // redundant\n      name: \"test\"\n   }\n}\nand he was making do with virtuals in 0.8.1\n. how change toJSON by model?\n. Ok thanks, is more code but works, I hope works together with visibility plugin, but I think the virtual plugin can also work for that purpose without having to be adapted toJSON\n. @jamesdixon I did abandon this temporarily, but I'll take a second look when I find some time. Thanks for the link\n. @jamesdixon I'm still having a hard time getting this to actually modify the query after hitting the fetching callback. My code looks like this:\ninitialize: function() {\n    this.on('fetching', function(model, columns, options) {\n      options.query = options.query.column(columns, st.asGeoJSON('location')).from(this.tableName);\n      console.log (options.query.toString());\n    });\n  }\nAnd I get a nice SQL statement printed in the terminal, but the query seems to execute if the function was not even there. Are you returning anything from that callback? Perhaps it's something elsewhere in my code causing me problems\n. Some progress... I think it is something elsewhere in my code causing me problems\n. I'll give that a shot. It looks like I was having issues because before my\nfetchAll() call on the model, I had a query function that was also\nmodifying the SQL query. Playing around with that now and making progress.\nThanks for the help!\nOn Fri, Apr 22, 2016 at 1:46 PM, James Dixon notifications@github.com\nwrote:\n\nnot having that was causing issues with other plugins, etc that override\ninitialize()\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1172#issuecomment-213583282\n\n\nTaylor Denouden\ntaylor.denouden@hakai.org\n. I actually just got this working in an even simpler way. Now doing:\n``\n  initialize: function() {\n    this.on('fetching', function(model, columns, options) {\n      if(columns[0] ===${this.tableName}.*` || columns.indexOf('location') >= 0) {\n        columns.push(st.asGeoJSON('location'));\n      }\n    });\nreturn bookshelf.Model.prototype.initialize.apply(this, arguments);\n\n}\n```\nIt just checks to see if the location should be returned as defined by what's in the columns parameter. If location should be returned, it just pushes st.asGeoJSON('location') to columns. Knex takes care of modifying the query after that.\nApplying the initialize arguments should only be necessary if you're using some other library that also modifies the initialize function; as you stated before.\n. @rogerschlachter I wasn't able to do the reverse, but didn't look into too much. I found that postgres could properly insert coordinates in EWKT format without having to do st.geomFromEWKT() first. So, in the end I just made sure I was only inserting EWKT formatted  geometry. There's probably room for improvement with this approach.\n. I'm also having the same issue, where I'm trying to run the following code in my model, in order to add another property to the response.  The property relies on the fetched event which doesn't fire when using the fetchAll method, but does run with fetch method.\njs\n  initialize() {\n    this.on('fetched', (model) => {\n      const isComplete = model.related('questionnaires').every(item => item.get('completed_at') !== null);\n      model.set('is_complete', isComplete);\n    });\n  }. ",
    "tristanz": "Has this been added to knex yet?\n. Is whereRaw documented somewhere?\n. ",
    "gajus": "I have asked a related question on Stack Overflow before I came across this thread.\nhttp://stackoverflow.com/questions/39022745/how-to-separate-model-declaration-from-database-connection\n. > Stick to the latter. We're looking to pull the collections API ASAP. It's too heavy and as you've noticed the shift towards exposing Active Record style methods on models has already started.\nThat was over a year ago. Whats the situation now?\n. > Stick to the latter. We're looking to pull the collections API ASAP. It's too heavy and as you've noticed the shift towards exposing Active Record style methods on models has already started.\nThat was over a year ago. Whats the situation now?\n. For the record, there is an existing plugin that provides this functionality.\nhttps://github.com/jpstone/bookshelf-camelcase\n. Whats the decision on this?\n. Whats the decision on this?\n. I am having the same issue.\n``` js\nimport Bookshelf from './../Bookshelf';\nimport Promise from 'bluebird';\nimport bcrypt from 'bcrypt';\nconst hash = Promise.promisify(bcrypt.hash);\nconst hashPassword = async (model): string => {\n  if (!model.attributes.password) {\n    return;\n  }\nconst passwordHash = await hash(model.attributes.password, 10);\nmodel.set('password', passwordHash);\nconsole.log('YA', model.attributes.password);\nreturn passwordHash;\n};\nexport default Bookshelf.Model.extend({\n  tableName: 'user',\n  initialize: function () {\n    this.on('creating', this.hashPassword, this);\n    this.on('updating', this.hashPassword, this);\n  },\n  hashPassword\n});\n```\nand here is the debug output:\n13:06:16 server-0 request undefined\n13:06:16 server-0 { method: 'select',\n13:06:16 server-0   options: {},\n13:06:16 server-0   timeout: false,\n13:06:16 server-0   cancelOnTimeout: false,\n13:06:16 server-0   bindings: [ '1', 1 ],\n13:06:16 server-0   __knexQueryUid: '68e91756-28d6-44bd-b6d9-491d4a7d8c27',\n13:06:16 server-0   sql: 'select `user`.* from `user` where `user`.`id` = ? limit ?' }\n13:06:16 server-0 YA $2a$10$oh64wkScuaodgnE2p/H2a.4ejkkSiQ8pfeyK6nLGvC/gPEFsvel/y\n13:06:16 server-0 { method: 'update',\n13:06:16 server-0   options: {},\n13:06:16 server-0   timeout: false,\n13:06:16 server-0   cancelOnTimeout: false,\n13:06:16 server-0   bindings: [ 'gajus@gajus', 'test', '1', 'gajus', 'test', '1' ],\n13:06:16 server-0   __knexQueryUid: 'c875b8b5-e227-420c-9229-c3b1ea779a94',\n13:06:16 server-0   sql: 'update `user` set `email` = ?, `first_name` = ?, `id` = ?, `last_name` = ?, `password` = ? where `id` = ?' }\n. It works as expected using the creating event, though updating event does not register the new value.\n. I can confirm that model.set does update the model.\n``` js\nmodel.set('password', passwordHash);\nconsole.log('model', model);\n```\nmodel ModelBase {\n  attributes:\n   { id: '1',\n     email: 'gajus@gajus',\n     password: '$2a$10$367zfEwkaOO//bUeqkuMqew7HuTo3QJbD/Ig4vxbBFPLUNwYZIqp.',\n     firstName: 'test',\n     lastName: 'gajus',\n     createdAt: 2016-08-18T13:05:02.000Z,\n     updatedAt: 2016-08-25T12:04:49.000Z },\n  _previousAttributes:\n   { id: 1,\n     email: 'gajus@gajus',\n     password: 'test',\n     firstName: 'test',\n     lastName: 'gajus',\n     createdAt: 2016-08-18T13:05:02.000Z,\n     updatedAt: 2016-08-25T12:04:49.000Z },\n  changed:\n   { id: '1',\n     password: '$2a$10$367zfEwkaOO//bUeqkuMqew7HuTo3QJbD/Ig4vxbBFPLUNwYZIqp.' },\n  relations: {},\n  cid: 'c3',\n  id: '1',\n  _events:\n   { creating: [Function: hashPassword],\n     updating: [Function: hashPassword] },\n  _eventsCount: 2,\n  _knex: null }\n. Something else is off.\n``` js\nimport Bookshelf from './../Bookshelf';\nconst hashPassword = async (model): string => {\n  model.set('password', 'OOOO');\n};\nexport default Bookshelf.Model.extend({\n  tableName: 'user',\n  initialize: function () {\n    this.on('creating', this.hashPassword, this);\n    this.on('updating', this.hashPassword, this);\n  },\n  hashPassword\n});\n```\n{ method: 'select',\n  options: {},\n  timeout: false,\n  cancelOnTimeout: false,\n  bindings: [ '1', 1 ],\n  __knexQueryUid: '519bd5fd-a903-4df8-8605-4b12b44b961a',\n  sql: 'select `user`.* from `user` where `user`.`id` = ? limit ?' }\n{ method: 'update',\n  options: {},\n  timeout: false,\n  cancelOnTimeout: false,\n  bindings: [ 'gajus@gajus', 'test', '1', 'gajus', 'test', '1' ],\n  __knexQueryUid: '030e9f19-fa33-4282-a718-8e5457818b7a',\n  sql: 'update `user` set `email` = ?, `first_name` = ?, `id` = ?, `last_name` = ?, `password` = ? where `id` = ?' }\n. It looks like that model cannot be updated when using {patch: true}:\njs\nUserModel\n    .forge({\n      id: user.id\n    })\n    .fetch({\n      require: true\n    })\n    .call('save', user, {\n      patch: true\n    })\nWhen I set {patch: false}, it works as expected.\nA bug?\n. @Whoaa512 have you figured out how to promisify the current bundle?\n. @therobinkim Have you considered adding more contributors to the repository? All these open PRs discourage further contribution from new people considering to use the library.\n. @therobinkim Sorry.\n@tgriesser Have you considered adding more contributors to the repository? All these open PRs discourage further contribution from new people considering to use the library.\n. > Can I ask what you're trying to do that requires promisification?\nI had a wrong assumption that promisifyAll will behave like Promise.try when it detects an existing promise implementation.\nHowever, then intention was to wrap the existing promise prototype in a custom (in this case an up to date Bluebird) promise implementation.\n. js\nPostModel\n  .query('where', 'id', 'in', [1])\n  .fetchAll({\n    withRelated: [\n      'badges'\n    ]\n  })\n  .call('toJSON')\nDoes the job.\nRelated: http://stackoverflow.com/questions/39040725/how-to-fetch-data-for-a-collection-of-models-using-withrelated.\n. js\nPostModel\n  .query('where', 'id', 'in', [1])\n  .fetchAll({\n    withRelated: [\n      'badges'\n    ]\n  })\n  .call('toJSON')\nDoes the job.\nRelated: http://stackoverflow.com/questions/39040725/how-to-fetch-data-for-a-collection-of-models-using-withrelated.\n. > To override the default column names, assign an array to hasTimestamps. The first element will be the created column name and the second will be the updated column name.\nYou are right. Should read more attentively.\n. > To override the default column names, assign an array to hasTimestamps. The first element will be the created column name and the second will be the updated column name.\nYou are right. Should read more attentively.\n. ",
    "chrismcleod": "Another good reason for this, and maybe I just dont know how to do it, is for exporting typescript classes.  I attempt to do this:\ntypescript\nexport const Models = function(bookshelf) {\n  return {\n    User: bookshelf.Model.extend({})\n  }\n}\nHowever, Models is an object and not a type so I cant use Models.User in type definitions.  Such as:\n```typescript\n// view.ts\nexport class View {\n}\n// server.ts\nimport {View} from \"./view\";\nimport {User} from \"./models\";\nconsole.log(User); // the User model is displayed\nconst v = new View(); // throws typescript compile error Cannot find name 'User'\n```. ",
    "lythesia": "Sorry for silly questions, i've done it with through() and withPivot().\n. ",
    "eventEmitter": "hi, whats the progress on this issue? it would be really nice to have this feature. \n. hi, whats the progress on this issue? it would be really nice to have this feature. \n. For me it's https://www.npmjs.com/package/related\n. ",
    "huliseerow": "Hey @tgriesser I'm answering on behalf of @eventEmitter. We use it mostly for internationalization. Meaning we have a table for example Country for this table we hava a CountryLocale Table with the country_id, language_id and the name of the Country in the corresponding language. So the PrimaryKey of CountryLocale is composed of the two keys id_language and id_country. \n. ",
    "nathasm": "Is this a dead issue? Or are there still plans for composite key support?\n. Is this a dead issue? Or are there still plans for composite key support?\n. ",
    "TheBeege": "Hey @tgriesser - I'm dead in the water without this. I'll throw a use case at you in the event it helps.\nWe have timelines, posts, events, and users. A user can place an event on a timeline by creating a post. Timelines and events belong to many of each other through posts. Posts also belong to a user. Our post table looks like this:\nCREATE TABLE posts\n(\n  timeline_id integer NOT NULL,\n  event_id integer NOT NULL,\n  create_date timestamp without time zone,\n  poster integer,\n  CONSTRAINT posts_pkey PRIMARY KEY (timeline_id, event_id)\n)\nWeird, part is, I found mention of composite keys at http://minocys.azurewebsites.net/designing-postgresql-tables-with-composite-keys/. When using this in practice, I hit Unhandled rejection error: column \"id\" does not exist. The debug output looks like this:\n{\n    method: 'insert',\n    options: {},\n    bindings: ['2015-09-01 00:00:00', 31, 474, 146],\n    sql: 'insert into \"posts\" (\"create_date\", \"event_id\", \"poster\", \"timeline_id\") values (?, ?, ?, ?) returning \"id\"',\n    returning: 'id'\n}\nIt's trying to spit out an ID, even though I've specified idAttributes on my Post model as ['timeline_id', 'event_id'].\nIs this evidence of BookshelfJS still not supporting composite keys, or is this some sort of unrelated bug?\nEDIT: If you need help with this at all, I'm heavily invested in BookshelfJS due to this project. If I can get some context, I'll do the best I can.\n. Sorry for the long silence. I just started a new job.\nThis is exactly the explanation I was looking for. Thank you @ricardograca !\nI'm happy to close this in favor of #799. I may submit a PR for documentation to add your explanation, but I need to figure out my new life schedule with this job first :/ Thanks again!. ",
    "rluba": "@rhys-vdw But how would you set create_date and poster in this example when using .create(\u2026)?\nRelated: How would you insert a new Event-Timeline relation for an existing Event and existing Timeline and set  create_date and poster as part of the INSERT? Using attach and then updatePivot requires two roundtrips to the database and is impossible if eg. poster is a required field.\n. Answered my own question in #648.\n. @gfarrell I agree. Using two queries is problematic in the general case and even impossible if one of the pivot fields is required (ie. NOT NULL).\n. While reading the source code, I discovered that you can pass a non-model object to .attach() to define any fields in the pivot table during insertion.\nThis feature doesn\u2019t seem to be documented, but it works:\nJavaScript\nmodelA.modelBs().attach({b: b_id, role: role, created_at: new Date(), updated_at: new Date()}).\n. @rhys-vdw Just FYI: The suggested workaround using {patch: true} doesn\u2019t work \u2013 the query is still built as\nSQL\nUPDATE tablename SET id = newid WHERE id = newid\n(tested with bookshelf 0.9.5).\nI had do drop down to knex and build the query myself to work around this issue \u2014 no big deal in my case.\n. ",
    "jcowgar": "Another ORM I have explored recently does composite relation keys as an array. Translating to Bookshelf(ish) talk:\nreturn this.belongsTo(Client, ['timeline_id', 'event_id']);\n. ",
    "dnascimento": "Any update on this? \n. Is not there a better way to manage parent/heritage relationships?\nFor instance, the child Model can be saved with attributes of parent table and bookshelf stores both?\n. @kichingxx just use where clause like:\nnew model().where({key: keyVal}).save(obj)\nHowever, compose keys should be a bookshelf feature... \n. @kichingxx just use where clause like:\nnew model().where({key: keyVal}).save(obj)\nHowever, compose keys should be a bookshelf feature... \n. ",
    "castarco": "Maybe this PR should be closed.... its too old to be fixed to match the current code base.\n. Hi @vellotis , ok, thank you. I'll try to add these tests.\n. Hi again @vellotis . I'm facing some trouble to find the best way to test this.\nI think I have to test something like:\n1. Create a simple model with an id property holding a \"complex object\" (nothing like a scalar: integers, strings...). The \"complex\" object should be simple enough to not obscure the test. I'm thinking on something like an object with two integer properties.\n2. Add the format and parse methods to this model. Using a simple bijective transformation.\n3. Create an entity and store it in the DB.\n4. Try to update it with the patch option and verify that no NoRowsUpdatedError has been thrown.\n5. Re-read from DB the object and verify that the correct ID has been retrieved?\nThank you for your time.\n. This pull request has passed, the \"crashed\" test has not crashed, but resulted in timeout (and I haven't changed anything in the code, the new added test for Node v6 has passed, the old test for Node v0.10 is the problematic one).\n. ",
    "mrhwick": "Closing until re-implementation. Collected all related issues under #1664. Closing due to staleness.. Closing until re-implementation. All issues related to refresh and returning collected under #1665. This is stale and not well-described. Closing for now. We can refer to this if it becomes relevant again.. This is stale. We can refer to this if it becomes relevant again.. This is stale. We can refer to this if we later want to have collections automatically sort themselves on initialization.. @brunocascio No update. If you want to write and submit a PR for this, I would be happy to review and see how it fits into the future releases of bookshelf.. In lieu of anyone being able to commit to real-time communication channels, we should lean into using:\n\nGithub issues/projects/pull requests for development work\nGithub issues / StackOverflow tag monitoring for support work\n\nKeep it simple. We don't need to unnecessarily complicate our communication channels when we are all already on Github and StackOverflow right now.. We're also curious about the active maintenance status of this library. @tgriesser, any thoughts?. In the case that my organization decides to switch to another ORM (an unlikely possibility at the moment), suggestions for alternative ORM libraries are welcome.\nIn the more likely case that we continue to use bookshelf.js for our current implementation, we are interested in helping the library mature. Of particular interest at this time is solving concerns expressed in issues such as #813, as they are threats to the usefulness of this library at scale. We are currently working through ways to reduce the impact of these limitations, but the best solution would be to mature this library to make use of SQL constructs such as table joins, which are supported by the underlying querybuilder, knex.\nIf there is interest in an effort to support a new fork of this project, please keep this thread informed.. I firmly believe we need to reduce the number of communication channels we use to manage this project. I've settled on only using the github repo for communication because it is the most publicly linked to the project.. Jumping in a bit late on the discussion here.\nI accepted the invitation to join the maintainers team for bookshelf. I currently have production projects making extensive use of bookshelf.js and knex.js, and a vested interest in seeing this project succeed.\nAs far as I can tell, we have a handful of different problems on our hands right now:\n\nNo clear project ownership / plan\nWe have a new set of maintainers. This is a very good first step.\nNeed to solidify the set of core contributors who can coordinate on management activities. \nWe have a mixture of collaborators/owners on the repo and bookshelf.js organization. \nSome of the repo collaborators are not in the github organization.\nToo complex, makes it hard to know who is involved and who is not.\n\n\nWe do not have a coordinated effort to decide what comes next. I want to change this.\n\n\nConfusion over communication channels\nHistorically, there have been a variety of communication channels.\nNeed to be realistic and not create idealistic expectations of our participation.\nKeep it simple, and don't overcommit our time as contributors.\n\n\nLack of system knowledge\nDo any of the maintainers know how the system is structured at a high level?\nCan't resolve bugs without familiarity of how the system actually functions.\nCan't make feature additions/improvements if no one knows where to start development.\n\n\nThere are a shit-ton of leftover issues and PRs backlogged on the github repo\nNeed to identify what is important and what is not\nNo way to know whether issues / PRs are still relevant\nNo consensus on what to do with stale items (>1 year old)\n\n\nDocumentation is out of sync with the actual library\nMissing core features expected of state-of-the-art ORMs in 2017\nI'll just give one example: composite primary keys\nI'm certain there are plenty of others that have been identified in the mess of leftover issues.\n\n\nRelease management / package publishing seems to be undiscussed completely at this point\nCode quality issues\nIntermittent test failures on travis builds\nRefactoring is badly needed in some major system features, such as relation management\n\n\n\nI'm sure this list is not exhaustive. There's a lot of stuff to catch up on.\nI propose that we tackle the maintainer/support story first and foremost. We've got a mixture of repo collaborators and github organization members. We have open questions about communication mechanisms (see #973). If I were a user or potential user of this library, the lack of a cohesive support and maintenance story for this library would worry me greatly. We can do better.\nI edited our first Github project on this repo to align it with establishing a baseline of expectations on maintenance and support. Once we have that in place, we can decide what is next priority.. I'm concerned about the fact that we have a seemingly insurmountable wall\nof issues that would scare away prospective contributors. We need to start\nforward momentum somewhere, and the pile of leftovers makes it tough to\nknow where to start. I would rather have a few key issues that explain the\nunderlying problems we need to solve and reference the hundreds of other\nspecific instances and examples.\nIf these old issues are still affecting our users, the history will be\nthere for our reference.. @rapzo If/When you find yourself able to help manage this library, I will happily add you to the maintainers group. If you have any contributions of note on your fork that you think would be good candidates for inclusion in the library properly, feel free to point them out.. Fewer communications channels makes it easier to collaborate by pushing communication into the same space. I'm currently waiting to hear back from @tgriesser about what is necessary to make a new release of this library. That's the last piece that the maintainer team doesn't have access to at the moment. \nMy priority after that is to streamline the contribution process by simplifying the setup / test processes. I want to work on making it easy to adapt the codebase before we start envisioning grand futures for the project.. @chamini2 I agree. There are also a lot of issues with bookshelf being a very leaky abstraction. The internals of knex are exposed all over the place instead of being wrapped in nice abstractions. I'm still piecing it together, but it looks like this is because the project didn't meet all of the needs of its users, and opted to just expose the database connector beneath it instead of implementing those features as a part of the abstraction. So now anyone who is using bookshelf is actually using some kind of hybrid monster of bookshelf and knex.. Also, pinging @tgriesser again about how we can actually package and publish new versions of bookshelf. Work to make this library better is irrelevant if we can't release.. I hadn't considered mailing npm support about this. It looks like that did the trick. I'll see what needs to be done to publish a next version so we can start improving for a new major version.. @TJKoury Open a new issue for this. I'm pretty sure that doesn't exist currently, so any implementations would be useful as a contribution. I do know that schema validation is available as a plugin.. I would love to see bookshelf move in the direction of mimicking the patterns of the Django ORM. It is an excellent example of separating the data model from the storage solution. When working with that ORM, I almost never need to think about the database underneath the modeling layer.\nI think we can progressively approach that goal. my next milestone is to get bookshelf's testing story to a breakthrough moment where it is concerning itself with only the layer of abstraction which it provides. All the edge cases of the various database dialects and features... leave that work to knex, the database connector.. @tgriesser Any help on putting out a new release?\nIt would also be immensely helpful for us to document the process for making new releases. I put a card on this repo's github projects: https://github.com/bookshelf/bookshelf/projects/1#card-5247809. A regression test would be useful. I'll take a look at #1623 and see if I can derive a reproduction case from there to write a regression test for this change.. We can reach the caching management from here.\n\nI went ahead and deleted all caches to see if that helps.\n. In your use case, is the object forged with an ID provided for this relationship?\nI'm still gaining context around the internals of bookshelf as I come onboard to collaborate, but I want to be sure we know what behavior you are expecting clearly before I investigate further.. My intuition is that a patch upgrade to a library as stable as bluebird should not be breaking any functionality in bookshelf. Based on this intuition, I re-ran the build that previously triggered this issue to be created when it broke. The build completed successfully with no test failures this time.\nThis indicates to me that there might be some nondeterministic behavior happening in the test that previously failed. I'm going to close this issue, but this is something to be aware of if we see broken builds from test failures like this one.. I put everyone into the maintainers team that is currently in the organization. Let me know if you don't want to actively maintain this project, and I'll take you back out.\nHere's the list ATM, since Github does not allow us to display teams publicly:\n@tgriesser \n@brianc \n@blah238 \n@bendrucker \n@rhys-vdw \n@mrhwick\n@tkellen \n@isaacdurazo \n@ricardograca \n@jadengore \n@Playrom \n@johanneslumpe \n@dj-hedgehog \n  . @rapzo \nI'll add you to the maintainers list. You should get an invite shortly.. I just realized this as I'm looking at the current testing strategy. It actually makes little sense to execute bookshelf against a real database in our integration tests. We probably shouldn't be directing contributors to even run a real database for testing bookshelf.\nUnit tests for bookshelf should not require any code external to the unit under test.\nIntegration tests for bookshelf should be testing the integration of various bookshelf code, not integration between bookshelf and known external dependencies such as knex.js. We definitely shouldn't be testing the interactions between knex.js and databases during the bookshelf test runs. Hopefully knex.js has its own tests that provide guarantees about how knex.js interacts with different SQL dialects.\nA better strategy would probably be to create a knex.js test prop (or use an already-built solution like https://www.npmjs.com/package/mock-knex). Then we can safely scope our unit and integration tests to the level of this library alone.. You bring up a good point. I think a situation like that is going to require that we adapt the API between knex.js and bookshelf to ensure that bookshelf (and any other code dependent on knex) be given the information necessary to make decisions like this.\nTaking #1665 as an example, I would expect knex to act as the database abstraction well enough to hide the existence of the \"returning\" functionality from bookshelf. Bookshelf would call down to knex with the save/update command including an option that indicates bookshelf expects an implicit refresh on the updated/inserted record to be returned back out (or maybe that is the default option?). If bookshelf does not receive the expected return (for whatever reason; maybe it can't be done with a particular database or knex failed to do it correctly for some reason) we could fail back to making an additional query to perform the refresh. I'm sure there are alternative designs for this interaction as well.. Bookshelf is built with knex plugged in as the module used for database connection and execution, which improves quality in bookshelf. This provides an opportunity for lowered coupling and increased cohesion in the sense that bookshelf no longer needs to concern itself with the manner in which database connection and execution occurs, as long as knex is well-tested and can be trusted to function as documented.\nSubsequently, we can tighten up the focus (cohesion) of bookshelf as a library to spread only down to the API where knex will take over. It doesn't need to concern itself with testing that knex reacts as expected with the correct inputs. I think this is a strong argument for removing the test scaffolding related to actually running a variety of databases and measuring the database effects of bookshelf code.. Bookshelf can expose the knex query builder without implementing or verifying any of that functionality itself. \nThat means that the knex library can be tested independently to provide verification and bookshelf does not need to concern itself with guaranteeing that knex's functionality is correct. Knex should provide those guarantees, and bookshelf is not made any less reliable by proxying those guarantees out to its users.. This would be a useful fix if we were able to publish new package versions. So far, I can't seem to get ahold of anyone who was managing that for this library in the past to tell us how to do so.. \n\n. So that's the list of people who might be able to help us out:\n@tgriesser \n@rhys-vdw \n@ErisDS \n@kirrg001 . You should have an invite to the organization and maintainer team again. I thought I had added everyone, but I must have missed some people who weren't on the bookshelf organization but the repo itself. It would be helpful if you could also add one of the more recently active maintainers, or all of the maintainers team to the npm package administration as well.. Thanks for pinging me. I'll get this done.. Links in case this needs migration work:\nhttps://github.com/brianc/node-postgres/blob/master/CHANGELOG.md\nhttps://node-postgres.com/guides/upgrading\n. Thank you for mentioning this. Still getting everything worked out in transitioning ownership and the publishing process.. Let me know if you still have trouble with 0.11.1. My downstream project appears to be installing version 0.11.1 fine.. ",
    "matthew-dean": "So, does that mean that a data type of json is not supported?\n. Oops, I meant to say an array of JSON. JSON may be working, but I haven't been able to get JSON arrays to insert.\n. Ah, ok, thanks.\n. ",
    "ricardogama": "@badave @matthew-dean You can use the bookshelf-json-columns plugin, it makes that job easier.\n. Have you seen #1397?\n. @lumberj I think it does, at least in the first example:\njs\nMachine = db.Model.extend({\n    tableName: 'Machine',\n    idAttribute : 'machine_id',\n    logs: function() {\n        return this.hasMany(log, 'machine_serialnum', 'serialnum');\n    }\n});\n. @lumberj I think it does, at least in the first example:\njs\nMachine = db.Model.extend({\n    tableName: 'Machine',\n    idAttribute : 'machine_id',\n    logs: function() {\n        return this.hasMany(log, 'machine_serialnum', 'serialnum');\n    }\n});\n. We just released the bookshelf-cascade-delete plugin which implements the solution proposed by @tkellen, hope it can help you guys!\n. We just released the bookshelf-cascade-delete plugin which implements the solution proposed by @tkellen, hope it can help you guys!\n. @coolaj86 Take a look at the bookshelf-json-columns plugin.\n. @spwizard Take a look at the bookshelf-json-columns plugin.\n. @rhys-vdw Please review.\n. @vellotis Thanks, just updated the PR with your suggestions.\n. @rhys-vdw ping\n. @vitorbaptista Maybe #1397 solved this issue already? Try the master branch.\n. @vitorbaptista Maybe #1397 solved this issue already? Try the master branch.\n. @tgriesser @rhys-vdw @vellotis @ricardograca Any thoughts on this?\n. @tgriesser @rhys-vdw @vellotis @ricardograca Any thoughts on this?\n. Thanks @vellotis for the review, I'll let you know when it's all done.\n. @vellotis Added full test coverage for all 4 relations, simple and eager loaded with through versions as well. Tests are not passing on 0.10 and 0.12 by the reasons we already know (this should be fixed asap), above 4.0 all looks sharp.\n@chamini2 Feel free to review and try it out to see if it fixes your use case.\n. @vellotis Fixed your comments, please review.\n. @vellotis My pleasure, thanks for the review!\n. @tgriesser When a release can be expected with this feature? \n. @tgriesser When a release can be expected with this feature? \n. @vellotis I guess the reason is to avoid any Travis build to fail, since the current eslint version is not compatible with those versions. I guess this is the most practical solution but I suggest you to take a look at #1399.\n. @chamini2 @vellotis I'm currently working on #1397, covering all relations, eager and through, but It's taking me longer than expected. I'll keep you posted.\n. @vellotis Sure, just added. Please take a look.\n. @vellotis can you review?\n. @vellotis ping\n. @vellotis @rhys-vdw @tgriesser It seems many people would like to have the feature introduced in #1397, when a release can be expected? \nIt would also be nice to have this fix merged, making the feature complete and closing all related and  unsolved issues.\n. @vellotis @rhys-vdw @tgriesser ping\n. @vellotis @rhys-vdw @tgriesser ping\n. @vellotis @rhys-vdw @tgriesser ping\n. @TinOo512 That's great news, I'll take a look as soon as I can!. @TinOo512 That's great news, I'll take a look as soon as I can!. @Playrom just rebased this branch and everything seems ok.\nSince #1397 the foreignKeyTarget argument was added to the relation methods, allowing to specify what column a foreign key refers to, where previously was assumed to be the id or the calculated join column. \nIn that implementation, the attribute() method was added so that all those conditionals wouldn't be scattered across the code. However, the parentAttribute for the belongsTo relation is being miscalculated as explained on this PR original description and as revealed on the changes of the test suite.\nI hope this is enough for you to understand the motivation for this fix, it would help fixing other bugs on third party plugins like seegno/bookshelf-cascade-delete#25.\nCheers!. @Playrom Thanks, keep up the good work!. Have you seen #1397? Although it was not released yet.\n. @MarkHerhold That's it!\n. I think you can always use the transacting method:\njs\nbookshelf.transaction(trx => {\n  model1.query().increment('field', 1).transacting(trx)\n}).then(() => {\n  model2.query().increment('field', 2).transacting(trx)\n});\n. @richardsimko Have you tried the following?\njs\ngroupedKey = model.get(this.attribute('parentIdAttribute'));. Currently I lack the time to investigate this further, sadly I don't use Bookshelf anymore due its minimum maintainability, and I got stuck just like you are now.\nI feel bad that my contribution led you to this issue, so I'l make an effort on this weekend or maybe next week and I'll try to fix this.. I recommend Objection.js, it's also based on knex and well documented and maintained.. I would take a look at Objection.js. I would take a look at Objection.js. It is, and basically drops support for Node@4/Npm@2, that's why Travis builds are important and should not be ignored \ud83d\ude1e . It is, and basically drops support for Node@4/Npm@2, that's why Travis builds are important and should not be ignored \ud83d\ude1e . You're right, this seems a known issue that happens with npm@2 (npm/npm#8850), and in this case happens when you also have lodash as dependency on your project. \nNonetheless sadly it breaks projects on node@4 that have lodash and the latest bookshelf version as dependencies.. You're right, this seems a known issue that happens with npm@2 (npm/npm#8850), and in this case happens when you also have lodash as dependency on your project. \nNonetheless sadly it breaks projects on node@4 that have lodash and the latest bookshelf version as dependencies.. Sorry it has a bug, let me fix and I'll let you know when's ready to review.. My bad guys, done!. Thanks! Any idea of how far are you from making a new release?. I only used const because eslint was warning to do so, I even considered refactoring all the file. Why not use the babel-register compiler for mocha and have all code wrote in es6? If not, it would be great the fix the eslint configuration file to not warn about using let and const.\n. Yes, the id on the Interim model has absolutely no effect on the query, so I guess there's no use for this pivot.\n. Just added.\n. Removed this conditional since this script does not make sense if this array is empty or non existent. AFAIK the buildDependencies property on package.json is only used by this script, therefore if it's to be removed in the future, so does this script.. Replaced the use of _.filter and _.map with this for .. of cycle, which seems acceptable since Bookshelf is now only supported by node@4 and above, right?. ",
    "freshtonic": "@badave I'm not soliciting schema design tips or data modeling tips. I pointed out that it's contrived as an example.  It's provided merely to illustrate a bug in Bookshelf.\nIn summary: the select ... from $TABLE where $COLUMN in (...) query can and will break when there is a join table added to that query where the join table has a column with the same name. That's all there is to it.\nThe bug fix should be straightforward: alias all table names and reference all columns via an alias to disambiguate.\n. ",
    "sburrows-redant": "I believe I'm having a problem related to this issue.\nNotificationRecipient has a relation of:\nbelongsTo(Notification, 'notification_id');\nEverything works great when using a NotificationRecipient.fetch() {withRelated}. \nBut if I parse both models with a CamelCasing method it works correctly for the NotificationRecipient but the related object (notifications) becomes empty.\nIf I parse only Notifications it parsed that model correctly (when I remove the parse method off NotificationRecipient).\nI'm using this:\ncollection.query(function(qb) {\n      qb.where({user_id: userId, delivered: false});\n}).fetch({withRelated: ['notification']}).then(function (r) {\n      callback(r); \n      //callback has r.toJSON()\n});\nand the parse method is \nreturn _.reduce(attributes, function (memo, value, key) {\n            memo[inflection.camelize(key, true)] = value;\n            return memo;\n}, {});\nIs there anything else I need to do?\nThanks!\n. ",
    "nkcmr": "\nIt is in sqlite3\n. \nIt is in sqlite3\n. How do you initialize an sqlite database? This is my current guess:\njavascript\nvar db = Bookshelf.initialize({\n    client: \"sqlite\",\n    connection: {\n        database: \"./database/main.db\"\n    }\n});\nI feel like this is a problem with initialization.\n. ",
    "harrywang": "Thanks. Any future plan to support NoSQL databases?\n. Thanks!\n. ",
    "rizidoro": "Yeah , +1 for mixing DBs =D\n. Yeah , +1 for mixing DBs =D\n. Its not.... I tried browser too \n. Its not.... I tried browser too \n. @tgriesser  thanks for reply... I tried with  SQLite and the error doesn't happen... looks like is a problem with my Mysql connection...  thanks for help =D. I'm using OSX Maverick with a brew mysql...\n. @tgriesser  thanks for reply... I tried with  SQLite and the error doesn't happen... looks like is a problem with my Mysql connection...  thanks for help =D. I'm using OSX Maverick with a brew mysql...\n. I tried with a fresh new mysql install, and works...  =D\n. I tried with a fresh new mysql install, and works...  =D\n. ",
    "Karnith": "hi, is there any update on this?\n. ",
    "vineey": "+1 Would really love to see this future, really really need this!\n. ",
    "do-io": "It has been a while, and I see this is still open. Am curious if there has been any further thought towards the DB mixing thoughts. . @richenlin I will definitely look this over.... ",
    "richenlin": "I made a similar attempt based on knex.js, welcome you to provide valuable advice, thanks\nrepo: https://github.com/thinkkoa/thinkorm. ",
    "juan-g": "Since the new MEAN stack (MongoDB, Express.js, AngularJS, and Node.js) is now widely considered the main alternative to the traditional LAMP stack (Linux, Apache, MySQL, and PHP), in my opinion it would be very useful for many if MongoDB, the most popular NoSQL database, were supported by Bookshelf.js, an excellent Node.js ORM.. Since the new MEAN stack (MongoDB, Express.js, AngularJS, and Node.js) is now widely considered the main alternative to the traditional LAMP stack (Linux, Apache, MySQL, and PHP), in my opinion it would be very useful for many if MongoDB, the most popular NoSQL database, were supported by Bookshelf.js, an excellent Node.js ORM.. ",
    "petkaantonov": "@tgriesser btw, yield is available by now in bluebird as return/thenReturn\n. ",
    "hal-gh": "Is there any more information about using bookshelf (or Knex) with PostGIS? This ticket seems to imply that it's not possible.\n. ",
    "davidfurlong": "Hey guys. I think I found a neat (and much cleaner) way to use Bookshelf with postgis. \nI wrote a quick writeup here\nhttps://gist.github.com/davidfurlong/0a347dd71bf5fb91477a77fbd72a2954\n. Hey guys. I think I found a neat (and much cleaner) way to use Bookshelf with postgis. \nI wrote a quick writeup here\nhttps://gist.github.com/davidfurlong/0a347dd71bf5fb91477a77fbd72a2954\n. Any updates on this?\n. I think theres room for improvement on the event docs in these ways:\n\n\nI think we need to clarify that 'ing'-ending event models are changed but not committed to the database yet - its currently unclear whether the models in memory have actually been changed at this point (as in does getting an attribute get the old or the new value). I know its the new one.\n\n\nThe parameter 'attrs' is probably not the best name for it (suggestions?) \n\n\n'Attributes that will be inserted.' leaves ambiguous which attributes we can expect to be in this object\n\n\n'Model firing the event.' re: attrs description is unclear (suggestions?). Perhaps something like 'Key-value, plain object of Model's attributes (// ADD which attributes //). The result of calling Model.toJSON()'\n\n\nI would be inclined to make attrs an array of attribute keys rather than an object (but practically, because of backwards compatibility this is probably not a good idea right now). I've found the same behaviour. Trying to await the transaction completion by passing it to the 'created' handler, but its unclear how to await a transaction completed. Made a plugin for this. It adds the committed event which is like saved, but is delayed to fire after the transaction completes.\n\n\nhttps://github.com/DeedMob/bookshelf-committed-plugin. \ud83d\udcaa\ud83d\udcaa\ud83d\udcaa appreciate the effort & will try to find time to contribute. This week I created a plugin which could also just be a PR: \nhttps://github.com/DeedMob/bookshelf-committed-plugin\nIt addresses some issues me and others were having with saved/updated/created events firing before the transaction has been completed. > I really would like to be able to use ES6 classes, which I believe is already the plan but worth mentioning again\nI think that's already the case: class User extends Bookshelf.Model {\n\nawaitable (which is really just thenable)\n\nI think this is also the case as it's just Promises (depending on node version obviously).\n\n(We use both above in production). @ansem78 Yep response.json() will call the toJSON method of the model. \nI think you are expecting this code below to add the relation to the user:\njs\nconst u = await User.where({ id: 1 }).fetch();\nawait u.load(['role']) // needs to be assigned to u in order to have reference to the loaded relation\nThere isn't one set of loaded data => There can be two Models representing the same database row which have some different attributes and different loaded relations. Which can be quite confusing.. - I agree that collections are confusing and I would see them removed.\n- I also think the docs could do with a lot of work (I would be willing to help)\n- I think transaction handling with a transaction object with const trx = await Bookshelf.transaction(); and trx.commit() is better than the current paradigm (or at least offer this as an option) ~ although this seems to currently be possible with just slightly messier syntax: const trx = new Promise(); const t; Bookshelf.transaction(y => t = y; trx); // use t, trx.resolve() to commit.\n. Notably when I try\nmodel.fetch({ withRelated: ['role.event']})\nThe promise resolves with null. I have also tried to rename 'event' to 'ev' - perhaps its a special keyword in Bookshelf to no avail. If the model was created inside a transaction, the created event can fire before the transaction has completed. Pass through the transacting in the 3rd argument and await the promise to fix this. Even awaiting the transactions doesnt reliably work.. Perhaps its only in the created event handler that this doesnt work.. > Even awaiting the transactions doesnt reliably work.\nseems you can't await a transaction. Makes sense. ~~Solution: \nuse the saved event instead and check options.method (3rd argument) to check whether insert or update~~ EDIT: saved has the same issue. Solved by\nhttps://github.com/DeedMob/bookshelf-committed-plugin. for some reason it started randomly working now.. > So, both the first and the second parameters are \"model firing the event\"? There must be some difference. Since you're delving into this do you know what the difference is? This could finally fix #1015.\nThe first is the bookshelf Model the second is the Model attributes, after having toJSON()ed. All three events have the exact same arguments. \n\nSomewhat unrelated:\nI've been trying to extend Bookshelf with a plugin to fire a 'committed' event after a save in a transaction has committed. I managed to write a version which unfortunately triggers this event when every save in the transaction completes, not the transaction itself. I have since found a better way though\n```\nimport _ from 'lodash';\nimport Promise from 'bluebird';\n// Committed Plugin\n// Emits the 'committed' event on update or insert when the save transaction completes for all models\nmodule.exports = function(Bookshelf) {\n  const proto = Bookshelf.Model.prototype;\n  const Model = Bookshelf.Model.extend({\n    save: function(key, value, options) {\n      let attrs;\n      // Handle both \"key\", value and {key: value} -style arguments.\n      if (key == null || typeof key === 'object') {\n        attrs = key || {};\n        options = .clone(value) || {};\n      } else {\n        (attrs = {})[key] = value;\n        options = options ? .clone(options) : {};\n      }\n      options.method = this.saveMethod(options);\n      const save = proto.save.call(this, attrs, options);\n  if (options.transacting) {\n    options.transacting.client.on(\n      'query-response',\n      (response, obj, builder) => {\n        console.log(response, obj, builder);\n        this.triggerThen('committed', this, attrs, options);\n        options.transacting.emit('query-response', response, obj, builder);\n      }\n    );\n  } else {\n    save.tap(model => this.triggerThen('committed', this, attrs, options));\n  }\n\n  return save;\n},\n\n});\nBookshelf.Model = Model;\n};\n```. EDIT: I have a feeling this part of the FAQ sheds light onto the issue\n\nMy relations don't seem to be loading, what's up?\n...\nThis is only an issue if you're eager loading data with load without first fetching the original model.\n Model({id: '1'}).fetch({withRelated: [relations...]}) should work just fine.\n\nThe jobApplicationModel is declared from a saved event listener.\n\nThis also happens with fetch though.\nEvent {\n  attributes: {},\n  _previousAttributes: {},\n  changed: {},\n  relations: {},\n  cid: 'c255',\n  _events: { committed: [Function], destroying: [Function] },\n  _eventsCount: 2,\n  relatedData:\n   RelationBase {\n     targetTableName: 'events',\n     targetIdAttribute: 'id',\n     type: 'belongsTo',\n     target: { [Function: Event] dependents: [Array] },\n     foreignKey: 'event_id',\n     foreignKeyTarget: undefined,\n     parentId: 9,\n     parentTableName: 'event_roles',\n     parentIdAttribute: 'event_id',\n     parentAttributes:\n      { id: 9,\n        event_id: 13,\n        title: 'fff',\n        about: null,\n        capacity: null,\n        date_starting: 2017-11-27T18:00:16.000Z,\n        date_ending: 2017-11-27T20:00:16.000Z,\n        deleted_at: null,\n        created_at: 2018-01-01T21:51:34.504Z,\n        updated_at: 2018-01-01T21:51:34.504Z,\n        hours: 2 },\n     parentFk: 13 } } EventApplication {\n  attributes:\n   { event_role_id: 9,\n     user_id: 3,\n     updated_at: 2018-01-01T21:51:40.813Z,\n     created_at: 2018-01-01T21:51:40.813Z,\n     id: 8,\n     status: 'pending',\n     notes: null,\n     seen_by_organization_since_last_status_change: false,\n     seen_by_applicant_since_last_status_change: true,\n     status_changed_at: null,\n     did_attend: null,\n     deleted_at: null },\n  _previousAttributes:\n   { event_role_id: 9,\n     user_id: 3,\n     updated_at: 2018-01-01T21:51:40.813Z,\n     created_at: 2018-01-01T21:51:40.813Z,\n     id: 8,\n     status: 'pending',\n     notes: null,\n     seen_by_organization_since_last_status_change: false,\n     seen_by_applicant_since_last_status_change: true,\n     status_changed_at: null,\n     did_attend: null,\n     deleted_at: null },\n  changed: {},\n  relations:\n   { role:\n      EventRole {\n        attributes: [Object],\n        _previousAttributes: [Object],\n        changed: {},\n        relations: [Object],\n        cid: 'c250',\n        id: 9,\n        _events: [Object],\n        _eventsCount: 2,\n        relatedData: [Object] },\n     user:\n      User {\n        attributes: [Object],\n        _previousAttributes: [Object],\n        changed: {},\n        relations: {},\n        cid: 'c253',\n        id: 3,\n        _events: [Object],\n        _eventsCount: 1,\n        virtuals: [Object],\n        relatedData: [Object] } },\n  cid: 'c232',\n  _events: { committed: [Function] },\n  _eventsCount: 1,\n  _knex: null,\n  id: 8 }. possibly related (and full circle lol) https://github.com/bookshelf/bookshelf/issues/1650. I know you're probably really busy , but any chance you've looked at this?\nIt may be something I'm doing wrong, but it's really throwing me for a loop, and it occurs sporatically in different places, suggesting it's not some weird quirk. I appreciate it!. Oops my bad. I'll try that!\nCouldn't reproduce. Will keep trying to reproduce\nhttps://gist.github.com/davidfurlong/a52a743299e8131c966180ef76df497d. I'm still experiencing this issue. I've tried many small changes - I've looked at the source at length. I can't reproduce this issue. The only thing I can reasonably conclude now is that either I have some really strange setup bug with my bookshelf plugins, there are some sort of side effects happening with mutating models somewhere that overwrite loaded relations or that the nested loading of relations has a bug.\nIt's pretty clear from the below code execution that my load (I have also tried refresh) to eager load relations doesn't actually fetch the related models reliable, sometimes giving an empty Model or Collection when related Models do exist in the database\nMy most recent struggle:\n```js\nconst application = await model.load([\n        'job.organization.memberships.user',\n]);\nconsole.log(application.related('job').related('organization').related('memberships'));\n// Output logs: 0 models\nconsole.log(await application.related('job').related('organization').related('memberships').fetch());\n// Output logs: 22 models\nconst membershipsLoaded = await Membership.where({ organization_id: oId }).fetchAll();\n// Output logs: 22 models\nconst oId = application.related('job').related('organization').get('id');\n// Output logs: 13\n```\njs\n// Organization.js\n...\n memberships() {\n    return this.hasMany('Membership', 'organization_id');\n  }\n...\njs\n// Membership.js\n...\n organization() {\n    return this.belongsTo('Organization', 'organization_id');\n  }\n.... > I'll leave this open until you or someone else can find the actual problem here. In the mean time there's not much I can do without a reproducible test case.\nYeah I get that. It seems replacing load/refresh with fetch & withRelated worked. Very strange. Currently looking through the source code of bookshelf. Any pointers on where to look? Looking at eager.js. I've figured it out. Here's what was happening:\nI had an on event handler on JobApplication that then called await model.refresh({ withRelated: ['job.organization', 'user'] });. I also called\nconst application = await model.load([\n        'job.organization.memberships.user',\n      ]); further down in the original code. Since these reference the same Model, and models are mutated,  the on handler code was overwriting the related data, \"unloading\" the data I had loaded elsewhere.\nShort term solution: clone(). Long term solution: Bookshelf shouldn't mutate models / make the docs clearer.\nBookshelf events are really tricky and bug prone in my experience (See also https://github.com/bookshelf/bookshelf/issues/1650) -- word of warning to my future self ;). Ah okay I thought this was in addition to knexs debug mode (which isn't that useful in my case). > I'm actually thinking of revamping the debug feature to be a little more custom. What kind of features are you missing with the current debug mode?\nI don't know. But debugging my latest issue (https://github.com/bookshelf/bookshelf/issues/1823) would have been easier if I could have seen a log of mutations or functions performed on models. Knex doesn't show Bookshelf models ids, and logging yourself presumes you know what you're looking for.. > I'm not so sure about not mutating models, because you may want to change the model in some way in the event handlers before it's passed to the end action.\nFor some event handlers this makes sense, for many it doesn't (any ending in -ed it doesn't, for ex. saved or updated), as there is no action after it\n\nHaving stale models that don't reflect the state of the actual data is not a good idea\n\nI disagree - you usually don't want to maintain a reference to stale models, and you should update your references (m = m.load('...')). This is a classic argument around mutating vs non mutating. Models are also defacto possibly stale, as there may have been changes to the data from a different instance of this Model / through raw SQL etc.\n\nHowever, I agree that once a relation is loaded on a model, as in your example, it should stay loaded even if calling load() again without including that particular relation. This won't be easy to achieve though.\n\nUnloading itself would be fine, as an error would be thrown. The current behaviour is much worse: it actually sets an empty Model/Collection. So in the case of iterating over a collection it silently fails. Which made it so hard to spot.. ",
    "vxcamiloxv": "@davidfurlong  Good Solution!!\n. @davidfurlong  Good Solution!!\n. In 0.8.x works fine but in 0.12.1 I was getting Maximum call stack size exceeded . To reproduce this error you need some table like city with a foreign key to country\n\nCity table\n```\n\n\nid | name    | country_id\n1  | Bogot\u00e1  | 2\n- Country table\n\nid | name       | locale\n1  | Mexico     |  es_MX\n2  | Colombia   |  es_CO\n``\nand the above code always whencityis fetched (new City({'id': 1})) adds as relationcountry` for getting something like:\n{\n  city: {\n   id: 1,\n   name: \"Bogot\u00e1\",\n   country: {\n     id: 2,\n     name: \"Colombia\",\n     locale: \"es_CO\"\n  }\n } \n}. ",
    "jacobwgillespie": "I'm sorry, I have a typo in the above code - I'm using station.seeds().fetch().  station.seeds() is returning that object, hence why .fetch() is undefined.\n. Though simplified, here's the contents of my models:\nHere's seed.js:\n``` javascript\nvar Seed,\n    Seeds,\n    playlistBookshelf = require('./base'),\n    Station = require('./station').Station;\nSeed = playlistBookshelf.Model.extend({\ntableName: 'seeds',\nstation: function() {\n    return this.belongsTo(Station, 'station_id');\n  }\n});\nSeeds = playlistBookshelf.Collection.extend({\n  model: Seed\n});\nmodule.exports = {\n  Seed: Seed,\n  Seeds: Seeds\n};\n```\nAnd station.js:\n``` javascript\nvar Station,\n    Stations,\n    playlistBookshelf = require('./base'),\n    Seeds = require('./seed').Seeds;\nStation = playlistBookshelf.Model.extend({\ntableName: 'stations',\nseeds: function() {\n    return this.hasMany(Seeds, 'station_id');\n  }\n});\nStations = playlistBookshelf.Collection.extend({\n  model: Station\n});\nmodule.exports = {\n  Station: Station,\n  Stations: Stations\n};\n```\n. Ahh, thank you!  I knew there was something I was missing someplace.  :+1: \n. ",
    "Rauno56": "Yep, I know. Just had to look it up. Thank's anyways.\n. ",
    "adriano-di-giovanni": "Thanks @bendrucker ;)\nPolymorphic relations seem to be the way to go.\nI published a gist of the\n- database schema (database.sql);\n- model classes (PartyModel.js, PersonModel.js, OrganizationModel.js);\n- collection class (PartyCollection.js);\n- application (index.js).\nIt works. I think it is correct. Maybe it can help someone else.\nThanks again,\nAdriano\n. Thanks, @johanneslumpe \nand yes, I set up a relation inside my models.\nIn PartyModel I set up\n```\n    roleCollection: function () {\n      var\n        RoleCollection = Collections.getByName('RoleCollection');\n  return this.belongsToMany(RoleCollection, 'party_role', 'party_id', 'role_id');\n},\n\n```\nIn RoleModel I set up\n```\n    partyCollection: function () {\n      var\n        PartyCollection = Collections.getByName('PartyCollection');\n  return this.belongsToMany(PartyCollection, 'party_role', 'role_id', 'party_id');\n}\n\n```\nI then set up a transaction\n```\n          .then(function () {\n            var\n              partyModel = results.partyModel,\n              roleModel = results.roleModel;\n        return partyModel\n          .roleCollection()\n          .attach(roleModel);\n      })\n\n```\nbut I can't make your code work: transaction is rolled back because\nColumn \\'party_id\\' cannot be null\nLooking at the sql, I can read\ninsert into `party_role` (`party_id`, `role_id`) values (NULL, NULL)\nI'm trying to understand why :)\n. So, @tgriesser \nis it correct to use a Collection as the target of a belongsToMany relation defined in a Model?\n. @johanneslumpe, @tgriesser maybe I've got it.\nIt seems to be that if you create a new instance of a model and then save it, the id attribute is not updated.\nLooking at the Bookshelf source code in ./dialects/sql/model.js lines 189 through 192 you can read\n// After a successful database save, the id is updated if the model was created\n      if (method === 'insert' && resp) {\n        this.attributes[this.idAttribute] = this[this.idAttribute] = resp[0];\n      }\nIf PartyModel has idAttribute: 'party_id', the above snippet updates\n- this.attributes.party_id;\n- this.party_id\nbut it doesn't update this.id.\nIs it correct, @tgriesser?\n. Thanks, @tgriesser \nNow I only have to fix a \nLock wait timeout exceeded; try restarting transaction \non\nreturn partyModel\n              .roleCollection()\n              .attach(roleModel);\n          })\n          .then(t.commit, t.rollback);\n. @tgriesser, it now works like a charm.\nI added the options hash with the transacting attribute. Maybe worth adding an example in the documentation.\nThanks for your help, @tgriesser and @johanneslumpe \nThanks for Bookshelf, @tgriesser \n``` javascript\n.then(function () {\n  var\n    partyModel = results.partyModel,\n    roleModel = results.roleModel,\n    options = {\n      transacting: t\n    };\nreturn partyModel\n    .roleCollection()\n    .attach(roleModel, options);\n})\n.then(t.commit, t.rollback);\n``\n. @johanneslumpe it's now clear :) It was not before usingattach. Thanks @johanneslumpe,\ndo you mean aknex` query without using any Bookshelf model or collection?\n. Thanks again, @johanneslumpe \n. @bendrucker, that was my first attempt\n``` javascript\nemailAddresses: function () {\n  var\n    collection = this.contactMechanismCollection().query('where', 'contact_mechanism_type',\n      '=', 'email_address');\ncollection.on('fetching', function (collection, columns, options) {\n    options = options || {};\n    options.withRelated = options.withRelated || [];\nif ( ! _.contains(options.withRelated, 'specialization')) {\n  options.withRelated.push('specialization');\n}\n\n});\nreturn collection;\n}\n```\nbut looking at the select function in ./dialects/sql/sync.js of Bookshelf\n``` javascript\nselect: Promise.method(function() {\n  var columns, sync = this,\n    options = this.options, relatedData = this.syncing.relatedData;\n// Inject all appropriate select costraints dealing with the relation\n  // into the knex query builder for the current instance.\n  if (relatedData) {\n    relatedData.selectConstraints(this.query, options);\n  } else {\n    columns = options.columns;\n    if (!.isArray(columns)) columns = columns ? [columns] : [.result(this.syncing, 'tableName') + '.*'];\n  }\n// Set the query builder on the options, in-case we need to\n  // access in the fetching event handlers.\n  options.query = this.query;\n// Trigger a fetching event on the model, and then select the appropriate columns.\n  return Promise.bind(this).then(function() {\n    return this.syncing.triggerThen('fetching', this.syncing, columns, options);\n  }).then(function() {\n    return this.query.select(columns);\n  });\n}),\n```\nthe fetching event is triggered after selecting constraints on the knex query.\nAm I mistaken?\n. @tgriesser, I suggest to change documentation about built-in events for collections: the arguments for the fetching event handler seem to be (collection, columns, options) instead of (model, columns, options). Do you agree?\n. Here's my solution: I ended up overriding the sync function for ContactMechanismCollection.\n``` javascript\nvar\n  ContactMechanismCollection = Bookshelf.Collection.extend({\n    ...\nsync: function (options) {\n  options = options || {};\n  options.withRelated = options.withRelated || [];\n  if ( ! _.contains(options.withRelated, 'specialization')) {\n    options.withRelated.push('specialization');\n  }\n\n  return Bookshelf.Collection.prototype.sync.call(this, options);\n\n});\n```\n@tgriesser, I suggest to change the documentation for sync: according to your code, signature is sync: function (options) instead of sync: function (collection, options).\n. @bendrucker, I'm going to :)\n. @bendrucker, how do I edit docs?\n. @bendrucker, done.\n. It's not about my case, @tgriesser :)\nI can test attributes.length and return undefined if it's value is zero.\nMy question is as follows: is it useful to have the first entry of a table returned?\nBookshelf maps objects to database entries. An object with no attributes can't be mapped to a database entry: the latter has them.\nDo you agree?\nInviato da iPhone\n\nIl giorno 23/gen/2014, alle ore 17:13, Tim Griesser notifications@github.com ha scritto:\nHmm, I'm not sure... basically the parameters you set on the model when creating a new model object determine the constraints for the query... so if you haven't set any and do a fetch, that seems like the query you'd expect.\nWhat case is it that you're running into where that's happening and you'd expect undefined?\n\u2014\nReply to this email directly or view it on GitHub.\n. It's not about my case, @tgriesser :)\nI can test attributes.length and return undefined if it's value is zero.\n\nMy question is as follows: is it useful to have the first entry of a table returned?\nBookshelf maps objects to database entries. An object with no attributes can't be mapped to a database entry: the latter has them.\nDo you agree?\nInviato da iPhone\n\nIl giorno 23/gen/2014, alle ore 17:13, Tim Griesser notifications@github.com ha scritto:\nHmm, I'm not sure... basically the parameters you set on the model when creating a new model object determine the constraints for the query... so if you haven't set any and do a fetch, that seems like the query you'd expect.\nWhat case is it that you're running into where that's happening and you'd expect undefined?\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks @bendrucker ;)\n. Thanks @bendrucker ;)\n. \n",
    "aidenbell": "Ill make a commit for this and send a pull request later.\n. ",
    "glenselle": "I think I'm experiencing the same problem. I'm also trying to get Bookshelf models to work and it just hangs. No errors are thrown and the db connection works fine. I know that because I'm using Knex elsewhere through Bookshelf.knex and my queries work flawlessly. Here's my code:\n```\nAccountController.create = function() {\n  var res = this.response\n    , req = this.request\n    , data;\ndata = {\n    name: req.body.name,\n    owner: req.body.owner,\n    type: req.body.type,\n    number: req.body.number,\n    routing: req.body.routing\n  };\nvar bookshelfSchema = new Account(data).save().then(function(model) {\n    console.log('Everything is saved!');\n    res.json(model);\n  });\n}\n```\n. @tgriesser Thanks a lot. I had a schema issue and that was causing the problem. But I wouldn't have figured that out if I didn't have the error.\n. ",
    "troygoode": "In case it helps, this is the best way to get a UTC formatted string representation of the current date in node.js:\njavascript\nnew Date().toISOString()\n. ",
    "dimitrisuls": "@tgriesser Thanks for the swift responses!\nThough Membership will contain more columns such as joinDate, .. So we need a model for it in Bookshelf.\nI've been thinking this through I guess it's better to just add an ID-column and put unique contraint over player_id and lobby_id? Even though that's not really best practice.\nSince it doesn't seem possible to have a model in Bookshelf with a multi-column primary key?\nAnd thanks for this awesome ORM :)! By far the best ORM out there for Node.js, and we tried a lot..\n. Thanks for the help @tgriesser.\nWe went with an ID on the memberships-table anyway. Since a composite PK wouldn't work on our client-side ORM.\nThis can be closed.\n. Thanks a lot for the swift and elaborate explanation!\nThis is what I used to have on each of my models:\nmodel.js:\njs\nformat: function (attrs) {\n    return toCamelCase(attrs);\n},\nparse: function (attrs) {\n    return toUnderscore(attrs);\n},\ntoUnderscore.js:\njs\nfunction (attrs) {\n    return _.reduce(attrs, function (memo, value, key) {\n        memo[_s.underscored(key)] = value;\n        return memo;\n    }, {});\n}\ntoCamelCase.js:\njs\nfunction (attrs) {\n    return _.reduce(attrs, function (memo, value, key) {\n        memo[_s.camelize(key)] = value;\n        return memo;\n    }, {});\n}\nNow I removed the parse-function and replaced it with this:\n``` js\ntoJSON: function () {\n    var model = db.Model.prototype.toJSON.apply(this, arguments);\nreturn toUnderscore(model);\n\n},\n```\nNo more need for the parse-method I suppose since this overridden toJSON-method will underscore everything.\nAnd the format-method can stay the same, since relations shouldn't be saved like that.\nWhat do you think? :)\n. Oke thanks ^^!\n. ",
    "zacharynevin": "Yeah this would be a great feature. I can do it in knex, but having a more concise way of doing it would be ideal.\n. That produces the following SQL (and an error, because there is no column \"session_id\" for group_sessions):\nSELECT \"group_sessions\".* FROM \"group_sessions\" INNER JOIN \"participants\" on \"participants\".\"id\" = \"group_sessions\".\"session_id\" WHERE \"participants\".\"user_id\" = ?\nThe problem seems to be that the pivot columns are wrong. The pivot columns that I am getting are \"participants\".\"id\" as \"pivot_id\" (which is incorrect, I want to join where \"participants\".\"session_id\" = \"group_sessions\".\"id\") and \"participants\".\"user_id\" as \"pivot_user_id\" (which is correct). Is there any way to specify this?\n. That produces the following SQL (and an error, because there is no column \"session_id\" for group_sessions):\nSELECT \"group_sessions\".* FROM \"group_sessions\" INNER JOIN \"participants\" on \"participants\".\"id\" = \"group_sessions\".\"session_id\" WHERE \"participants\".\"user_id\" = ?\nThe problem seems to be that the pivot columns are wrong. The pivot columns that I am getting are \"participants\".\"id\" as \"pivot_id\" (which is incorrect, I want to join where \"participants\".\"session_id\" = \"group_sessions\".\"id\") and \"participants\".\"user_id\" as \"pivot_user_id\" (which is correct). Is there any way to specify this?\n. Thank so much! The belongsToMany association worked, with a minor adjustment:\nthis.belongsToMany(app.get('Model.GroupSession')).through(app.get('Model.Participant'), \"user_id\", \"session_id\");\n. Thank so much! The belongsToMany association worked, with a minor adjustment:\nthis.belongsToMany(app.get('Model.GroupSession')).through(app.get('Model.Participant'), \"user_id\", \"session_id\");\n. Okay, I will try that. I was fetching the model before destroying it because I was checking some attributes first.\n\nOn Jan 8, 2014, at 7:36 AM, Ben Drucker notifications@github.com wrote:\nI have to assume you defined id as 181 elsewhere, otherwise this would fail to produce valid SQL. You don't need to fetch the model before destroying it unless you need to check attributes on the model first. Instead, do:\nnew Events({id: yourDefinedEventId}).destroy();\nAlso, you can toss the otherwise statement. Catching a rejection and then blindly re-throwing an error within the handler isn't doing anything. The sync equivalent would be:\ntry {\n  throw new Error();\ncatch (error) {\n  throw error;\n}\n\u2014\nReply to this email directly or view it on GitHub.\n. Okay, I will try that. I was fetching the model before destroying it because I was checking some attributes first.\nOn Jan 8, 2014, at 7:36 AM, Ben Drucker notifications@github.com wrote:\nI have to assume you defined id as 181 elsewhere, otherwise this would fail to produce valid SQL. You don't need to fetch the model before destroying it unless you need to check attributes on the model first. Instead, do:\nnew Events({id: yourDefinedEventId}).destroy();\nAlso, you can toss the otherwise statement. Catching a rejection and then blindly re-throwing an error within the handler isn't doing anything. The sync equivalent would be:\ntry {\n  throw new Error();\ncatch (error) {\n  throw error;\n}\n\u2014\nReply to this email directly or view it on GitHub.\n. It definitely does. I have no problem selecting events by id. \n\nWhen I get home (on the bus now) I'll send over more code.\n\nOn Jan 8, 2014, at 11:16 AM, Tim Griesser notifications@github.com wrote:\n@zacharynevin does the events model not have a single column primary key?\n\u2014\nReply to this email directly or view it on GitHub.\n. It definitely does. I have no problem selecting events by id. \n\nWhen I get home (on the bus now) I'll send over more code.\n\nOn Jan 8, 2014, at 11:16 AM, Tim Griesser notifications@github.com wrote:\n@zacharynevin does the events model not have a single column primary key?\n\u2014\nReply to this email directly or view it on GitHub.\n. Ok, as promised, here is the code I used. Sorry for the late response, I fell asleep while playing Cookie Clicker:\n\nreq.user.model.events().query({ where: { id: req.params.id }}).fetchOne({ require: true }).then(function(model) {\n  // if event is in the past, destroy it\n  if (model.start < +new Date()) {\n    model.destroy().then(function(model) {\n      res.send(200);\n    })\n  }\n})\n. Ok, as promised, here is the code I used. Sorry for the late response, I fell asleep while playing Cookie Clicker:\nreq.user.model.events().query({ where: { id: req.params.id }}).fetchOne({ require: true }).then(function(model) {\n  // if event is in the past, destroy it\n  if (model.start < +new Date()) {\n    model.destroy().then(function(model) {\n      res.send(200);\n    })\n  }\n})\n. It worked! I'll keep that typecasting issue in mind. Thank you so much.\nSent from my iPhone\n\nOn Jan 9, 2014, at 3:44 AM, Ben Drucker notifications@github.com wrote:\nHaha no prob. My first guess here is that req.params.id is the issue. Bookshelf cares about the difference between '1' and 1 (the latter is correct). @tgriesser has mentioned typecasting as a feature on the short list a couple of times. (Happy to help w/ that once you spec out the implementation Tim)\nAlso, there's a more promise-y way to do your control flow. I know promises can be a hurdle initially, but once you become comfortable with them, it's the only way you'll want to code. Bluebird is a fantastic library\u2014the best w/out question. If you return a promise in a promise handler, the next handler in the chain will resolve that promise. It's a tad harder when you need if statements, but it still works well. Your example above becomes:\nreq.user.model.events().query({ where: { id: parseInt(req.params.id) }}).fetchOne({ require: true }).then(function(model) {\n  // if event is in the past, destroy it\n  if (model.start < +new Date()) {\n    return model.destroy();\n  } else {\n    return Promise.reject('start after now')\n  }\n})\n.then(function() {\n    res.send(200);\n})\n.catch(function(e) {\n    res.send(500);\n});\nOther than the type issue, your example isn't wrong. But chaining promises rather than nesting them is always a good idea. Otherwise there's a good chance you start swallowing errors or creating closures without realizing.\n\u2014\nReply to this email directly or view it on GitHub.\n. It worked! I'll keep that typecasting issue in mind. Thank you so much.\n\nSent from my iPhone\n\nOn Jan 9, 2014, at 3:44 AM, Ben Drucker notifications@github.com wrote:\nHaha no prob. My first guess here is that req.params.id is the issue. Bookshelf cares about the difference between '1' and 1 (the latter is correct). @tgriesser has mentioned typecasting as a feature on the short list a couple of times. (Happy to help w/ that once you spec out the implementation Tim)\nAlso, there's a more promise-y way to do your control flow. I know promises can be a hurdle initially, but once you become comfortable with them, it's the only way you'll want to code. Bluebird is a fantastic library\u2014the best w/out question. If you return a promise in a promise handler, the next handler in the chain will resolve that promise. It's a tad harder when you need if statements, but it still works well. Your example above becomes:\nreq.user.model.events().query({ where: { id: parseInt(req.params.id) }}).fetchOne({ require: true }).then(function(model) {\n  // if event is in the past, destroy it\n  if (model.start < +new Date()) {\n    return model.destroy();\n  } else {\n    return Promise.reject('start after now')\n  }\n})\n.then(function() {\n    res.send(200);\n})\n.catch(function(e) {\n    res.send(500);\n});\nOther than the type issue, your example isn't wrong. But chaining promises rather than nesting them is always a good idea. Otherwise there's a good chance you start swallowing errors or creating closures without realizing.\n\u2014\nReply to this email directly or view it on GitHub.\n. Let's say that I want to have the ability to save or update, for example, thebbilling address of a user. Instead of having two api methods for create and update, I have one that does both with an upsert.\n. Oh, I never knew that.\n. \n",
    "nathggns": "I'll definitely need this in the near future. \n. I'll definitely need this in the near future. \n. How do you do it in Knex, I'm getting this error.\nThe query type has already been set to select\n. This is how I do counting at the moment. Should be implemented at the library level. \n``` js\n/*\n * object can be a collection or a model\n /\nfunction count(object) {\n    var sync = object.sync();\nreturn Q().then(function() {\n\n    var relatedData = sync.syncing.relatedData;\n\n    if (relatedData) {\n        if (relatedData.isJoined()) {\n            relatedData.joinClauses(sync.query);\n        }\n\n        relatedData.whereClauses(sync.query);\n    } else {\n        sync.query.where(_.extend(Object.create(null), sync.syncing.attributes));\n    }\n\n    var result = sync.query.count('*');\n\n    return result;\n}).then(function(result) {\n    if (!result) {\n        throw new Error('EmptyResponse');\n    }\n\n    return Number(_.values(result[0])[0]);\n});\n\n}\n```\n. Sounds great. \n. I'd love this, I implemented it manually at my web server's response level (if you sent a model at a response, it would check for hidden/visible properties). Would be nice to have this supported in Bookshelf. \n. I'd love this, I implemented it manually at my web server's response level (if you sent a model at a response, it would check for hidden/visible properties). Would be nice to have this supported in Bookshelf. \n. How would you do this with Object.defineProperty? I'd definitely prefer it be as easy as adding a property to the array. \n. A code example would be more of a help here. Just to make sure we're on the\nsame page.\nOn 5 January 2014 01:36, Ben Drucker notifications@github.com wrote:\n\nTake a look at how the virtuals plugin is implemented: johanneslumpe@\n7e1232f#diff-b3db804e6d07fad88cd8b6d9a6d6be85R43https://github.com/johanneslumpe/bookshelf/commit/7e1232f81f41fdd76149edc32ba64e0b15515074#diff-b3db804e6d07fad88cd8b6d9a6d6be85R43\nOwn properties are enumerable by default so you're going to have a hard\ntime implementing the visible side of this concept properly. The hidden\nside, on the other hand, is easy. Just define the property as enumerable:\nfalse.\nThe implementation here will work, but it could potentially become a\nproblem to maintain. Object.keys would include the hidden properties, for\nexample. Not the end of the world, but using Object.defineProperty is\ndefinitely the right way to do this.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/pull/160#issuecomment-31593880\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. I'm using it to hide passwords and emails anywhere in my application that outputs them to the browser. (It's an API). \n. I'd still say having an array to do it would be the best way to do it, even if it uses defineProperty under the hood. \n. Seems setting enumerable to false doesn't actually hide a property from serialisation by Express, at least. \n. I haven't had a proper look at the code but I was wondering, do the virtuals update if you modify one of their dependent properties? \n. I haven't had a proper look at the code but I was wondering, do the virtuals update if you modify one of their dependent properties? \n. What's the syntax for defining a virtual? \n. What's the syntax for defining a virtual? \n. Nice! Great work! Already love Bookshelf, it's just getting better!\nOn 4 January 2014 19:53, Johannes Lumpe notifications@github.com wrote:\n\n@nathggns https://github.com/nathggns when the plugin is merged you\nwould be able to create virtuals like this:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  outputVirtuals: true,\n  virtuals: {\n    fullName: function() {\n      return this.get('firstName') + ' ' + this.get('lastName');\n    }\n  },\n});\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/pull/161#issuecomment-31586996\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. Nice! Great work! Already love Bookshelf, it's just getting better!\nOn 4 January 2014 19:53, Johannes Lumpe notifications@github.com wrote:\n\n@nathggns https://github.com/nathggns when the plugin is merged you\nwould be able to create virtuals like this:\nvar User = Bookshelf.Model.extend({\n  tableName: 'users',\n  outputVirtuals: true,\n  virtuals: {\n    fullName: function() {\n      return this.get('firstName') + ' ' + this.get('lastName');\n    }\n  },\n});\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/pull/161#issuecomment-31586996\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. I'd say the default should be to include them. \n. I'd say the default should be to include them. \n. Strange, I could never get that to work. Instead it would throw an error and the app would crash. \n. Strange, I could never get that to work. Instead it would throw an error and the app would crash. \n. Ah. Does then not support a second argument? That's pretty standard for\npromise implementations.\nOn 4 January 2014 20:43, Johannes Lumpe notifications@github.com wrote:\n\nYou need to add an error handler using .catch.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/166#issuecomment-31588122\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. Ah. Does then not support a second argument? That's pretty standard for\npromise implementations.\nOn 4 January 2014 20:43, Johannes Lumpe notifications@github.com wrote:\n\nYou need to add an error handler using .catch.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/166#issuecomment-31588122\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. I'll look into it more.\nOn 4 January 2014 20:52, Tim Griesser notifications@github.com wrote:\n\nNo the then is the normal promise A+ compliant then, but you can also use\n.catchhttps://github.com/petkaantonov/bluebird/blob/master/API.md#catchfunction-handler---promiseincluding bluebird's neat extended\ncatchhttps://github.com/petkaantonov/bluebird/blob/master/API.md#catchfunction-errorclassfunction-predicate-function-handler---promise\n.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/166#issuecomment-31588319\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. I'll look into it more.\nOn 4 January 2014 20:52, Tim Griesser notifications@github.com wrote:\n\nNo the then is the normal promise A+ compliant then, but you can also use\n.catchhttps://github.com/petkaantonov/bluebird/blob/master/API.md#catchfunction-handler---promiseincluding bluebird's neat extended\ncatchhttps://github.com/petkaantonov/bluebird/blob/master/API.md#catchfunction-errorclassfunction-predicate-function-handler---promise\n.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/166#issuecomment-31588319\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. Yes I've realised this just now. It seems to work fine now. Thanks for the help. \n. Cool. Sounds good.\nOn 4 January 2014 21:19, Tim Griesser notifications@github.com wrote:\n\nYeah I'd update it to do the check in the get/set.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/pull/168#issuecomment-31588903\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. Cool. Sounds good.\nOn 4 January 2014 21:19, Tim Griesser notifications@github.com wrote:\n\nYeah I'd update it to do the check in the get/set.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/pull/168#issuecomment-31588903\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. @johanneslumpe \n. @johanneslumpe \n. The issue is if the underscore methods it uses work on the attributes property, which doesn't include virtual properties. \n. Looks at fixing this now. \n. That's not a good fix though. The methods should work themselves.\nOn 4 January 2014 21:43, Johannes Lumpe notifications@github.com wrote:\n\nI aggree with @tgriesser https://github.com/tgriesser. This is most\nlikely the easiest way to fix that issue.\n@nathggns https://github.com/nathggns If you call toJSON first and then\nomit the values you're good.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/170#issuecomment-31589419\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. Oh I was fixing it too. Pretty close to it too. \n. I was just about to send my pull request. Fixes it with less code duplication. \n. This is my version. Similar approach to this but also reduces the duplication of the getter/setter logic. https://github.com/tgriesser/bookshelf/pull/173\n. They are in there. I cherry-picked your commit into my branch @johanneslumpe \n. Appears to be being caused by using defineProperty in the constructor to remove properties from serialisation, like https://github.com/tgriesser/bookshelf/pull/160#issuecomment-31594043 shows. \n. (I'm not hiding id, just to be clear. This was being thrown when getting a model by id). \n. Actually, it's just me not calling the super method when extending constructor. \n. I can see that it should work but my app shouldn't crash until there is more than 20 concurrent database connections, which that max should make impossible. Yet, we see crashes under load testing. \nSent from my iPhone\n\nOn 6 Jan 2014, at 21:21, Johannes Lumpe notifications@github.com wrote:\nActually from what I see in the source, the config is set to have a maximum of 10 connections in the pool. But you should be able to actually pass a pool config when initializing Bookshelf. Something along those lines:\nBookshelf.DB = Bookshelf.initialize({\n  client: 'mysql',\n  connection: {\n    host     : '127.0.0.1',\n    user     : 'root',\n    password : '',\n    database : 'somedb',\n    charset  : 'utf8'\n  },\n  pool : {\n    min: 2,\n    max: 5\n  }\n});\nThis is untested, but from looking at the source this should work, as Bookshelf passes the config down to Knex and it again passes the config down to the client, omitting the client property. The client then passes an object to the pool constructor which has been extended with the client's pool defaults and config.pool.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes, too many concurrent database connections. I've been digging into it, but I'm just getting more and more confused. The pool never has more than 10 connections, but the limit in the db is set to 20. There shouldn't be any errors. \n. Maybe the app is retaining connections even when they're supposed to have ended. \n. Nah, limiting it to 1 cluster was the first thing I did to try and debug this.\n\nI've set my local PG connection limit to 20 to try and debug this.\nI've noticed that getRawConnection inside the knex client is getting called far more than 10 times too, and destroyRawConnection is never called. \n. This has little to do with heroku and more to do connection limits. I've managed to reproduce it locally with a low connection limit.\nI'm just sending a high amount of concurrent web requests using siege. \n. Nope, just the once.\nOn 6 January 2014 23:06, Tim Griesser notifications@github.com wrote:\n\nAre you calling Bookshelf.initialize (or Knex.initialize) more than once?\nThat's the only think I can think of for why it would be called more than\n10 times.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/175#issuecomment-31697273\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. What server?\nOn 6 January 2014 23:07, Tim Griesser notifications@github.com wrote:\n\nActually @nathggns https://github.com/nathggns want to jump in\nbookshelf on IRC and I can try to debug there?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/175#issuecomment-31697383\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. What server?\nOn 6 January 2014 23:07, Tim Griesser notifications@github.com wrote:\n\nActually @nathggns https://github.com/nathggns want to jump in\nbookshelf on IRC and I can try to debug there?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/175#issuecomment-31697383\n.\n\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. No. Still trying to work this out. \nSent from my iPhone\n\nOn 15 Jan 2014, at 21:35, Johannes Lumpe notifications@github.com wrote:\n@nathggns Has this been solved?\n\u2014\nReply to this email directly or view it on GitHub.\n. No. Still trying to work this out. \n\nSent from my iPhone\n\nOn 15 Jan 2014, at 21:35, Johannes Lumpe notifications@github.com wrote:\n@nathggns Has this been solved?\n\u2014\nReply to this email directly or view it on GitHub.\n. I don't know enough about this issue to say for sure but isn't this (cyclic dependencies) a node problem not a bookshelf problem? \n\nSent from my iPhone\n\nOn 11 Jan 2014, at 17:38, Shaheen Gandhi notifications@github.com wrote:\ncool; that worked. seems like a common problem; what's the real solution?\n\u2014\nReply to this email directly or view it on GitHub.\n. I don't know enough about this issue to say for sure but isn't this (cyclic dependencies) a node problem not a bookshelf problem? \n\nSent from my iPhone\n\nOn 11 Jan 2014, at 17:38, Shaheen Gandhi notifications@github.com wrote:\ncool; that worked. seems like a common problem; what's the real solution?\n\u2014\nReply to this email directly or view it on GitHub.\n. Should we look into being able to store models in a central repository. Something like this.\n\nBookself.store('name', model);\nAnd then if you pass a string to the relationship functions it will fetch it from the store? \nSent from my iPhone\n\nOn 12 Jan 2014, at 16:29, Ben Drucker notifications@github.com wrote:\nCircular dependencies are an issue for an module system, not just Node. But yes, it is a Node / CommonJS problem. You might not see it with other DB libs because they have chosen to use a central model registry in the background without the dev having to think about it. For example, in Mongoose: \nmongoose.model('Model', schema);\nMongoose instantiates the model, registers it on the module, and then resolves string dependencies for you, so you can do:\nrelation: { type: mongoose.Types.ObjectId, ref: 'Model' }\nWhen that actually goes to use the relation, it looks up the model from the registry.\nWhen you require relations immediately in a Bookshelf model and then refer to them as variables in your relation definitions, those models will be empty objects if you have circular relations. When you use require directly in your relations, Node won't look for the related model until you actually call the relation. At that time the model is available.\nYou don't need to worry about performance issues here. Node caches modules so requiring something more than once it's identical to storing it as a reference and then accessing the reference.\n\u2014\nReply to this email directly or view it on GitHub.\n. Should we create a helper for extending models that automatically stores them then?  \n\nSent from my iPhone\n\nOn 12 Jan 2014, at 21:09, Ben Drucker notifications@github.com wrote:\nstore is a bad abstraction. If this is going to be a feature, all models should get stored at instantiation. And building a central model repo doesn't fit with the existing style of extending a base object. See Mongoose's implementation:\nhttps://github.com/LearnBoost/mongoose/blob/3.8.x/lib/index.js#L279\nThis is definitely something that should be done right.\n\u2014\nReply to this email directly or view it on GitHub.\n. I don't know that much about Coffeescript. What's the issue there?\n\nOn 12 January 2014 22:02, Johannes Lumpe notifications@github.com wrote:\n\nActually why don't we make this a plugin for now? Then it's just\nadditional and the core won't be affected. And at some point the plugin\ncould be merged if its code base is mature and clean enough. (And works\nwith coffee).\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/181#issuecomment-32135578\n.\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. Really like the way this is going. If we change the docs to make the\nexpectant way to register a relationship and to get the model is the\nregistered name, something like\nvar postWithId1 = Bookshelf.get('Post').forge({ id: 1 });\nthen I don't think it'll be too confusing.\nOn 13 January 2014 13:15, Ben Drucker notifications@github.com wrote:\n\nActually the best way to do it might be to use a lowercase model method,\nbut have a little extra logic:\n- if (protoProps instanceof Bookshelf.Model): register it and return it\n- else construct the object with the logic you used\nI'd actually be cool with doing it this way. Still sticks to convention\nwell (lowercase method, capital case class). I'd still like to put together\nsome milestones before taking on a big change for a future release, but\nI'll happily volunteer to draft this functionality + tests.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/181#issuecomment-32168064\n.\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. The ongoing connection is what is stopping the process from ending, but I'm\nnot sure if there's an easy way to stop a connection in Bookshelf.\nOn 12 January 2014 09:18, pward123 notifications@github.com wrote:\n\nI've noticed that anytime I initialize a bookshelf instance in my tests,\nbuster-test fails to terminate.\nIf I leave the Bookshelf.initialize in the following test, the buster-test\napplication just hangs after reporting results. Commenting out the\ninitialize (or just putting in bad connection info) causes buster-test to\nterminate normally.\nvar Bookshelf = require('bookshelf'),\n    buster = require(\"buster\"),\n    assert = buster.assert;\nvar bookshelf = Bookshelf.initialize({\n    client: \"mysql\",\n    debug: false,\n    connection: {\n        host:     \"localhost\",\n        database: \"blah\",\n        user:     \"blah\",\n        password: \"blah\",\n        timezone: \"+00:00\"\n    }\n});\nbuster.testCase(\"A test case\", {\n    \"test it\": function () {\n        assert(true);\n    }\n});\nAny ideas on what might be causing this?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/183\n.\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. The ongoing connection is what is stopping the process from ending, but I'm\nnot sure if there's an easy way to stop a connection in Bookshelf.\nOn 12 January 2014 09:18, pward123 notifications@github.com wrote:\n\nI've noticed that anytime I initialize a bookshelf instance in my tests,\nbuster-test fails to terminate.\nIf I leave the Bookshelf.initialize in the following test, the buster-test\napplication just hangs after reporting results. Commenting out the\ninitialize (or just putting in bad connection info) causes buster-test to\nterminate normally.\nvar Bookshelf = require('bookshelf'),\n    buster = require(\"buster\"),\n    assert = buster.assert;\nvar bookshelf = Bookshelf.initialize({\n    client: \"mysql\",\n    debug: false,\n    connection: {\n        host:     \"localhost\",\n        database: \"blah\",\n        user:     \"blah\",\n        password: \"blah\",\n        timezone: \"+00:00\"\n    }\n});\nbuster.testCase(\"A test case\", {\n    \"test it\": function () {\n        assert(true);\n    }\n});\nAny ideas on what might be causing this?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/183\n.\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. We might want to add something about this to the docs and add a helper\nmethod say the author doesn't have to touch the underlying libraries.\nOn 12 January 2014 17:12, pward123 notifications@github.com wrote:\n\nClosed #183 https://github.com/tgriesser/bookshelf/issues/183.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/183\n.\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. Looks good to me. Maybe you should add defaults for hidden and visible so\nif you view the plugin source code it's more obvious what you have to add\nto use it?\nOn 13 January 2014 15:46, Johannes Lumpe notifications@github.com wrote:\n\n@tgriesser https://github.com/tgriesser What do you think, we should\nadd a plugins section to the docs, right?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/pull/186#issuecomment-32180746\n.\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. I'd still have hidden and visible as null properties on the base model. \nSent from my iPhone\n\nOn 13 Jan 2014, at 18:24, Tim Griesser notifications@github.com wrote:\nI'd actually had this one locally but didn't get a chance to push it yet... mine looked more along the lines of:\nvar _      = require('lodash');\n  var proto  = Bookshelf.Model.prototype;\n  var toJSON = proto.toJSON;\nvar Model = Bookshelf.Model.extend({\n```\nconstructor: function() {\n  proto.constructor.apply(this, arguments);\n  var options = arguments[1] || {};\n  if (options.visible) {\n    this.visible = .clone(options.visible);\n  }\n  if (options.hidden) {\n    this.hidden = .clone(options.hidden);\n  }\n},\ntoJSON: function() {\n  var json = toJSON.apply(this, arguments);\n  if (this.visible) {\n    json = .pick.apply(, [json].concat(this.visible));\n  }\n  if (this.hidden) {\n    json = .omit.apply(, [json].concat(this.hidden));\n  }\n  return json;\n}\n```\n});\nBookshelf.Model = Model;\nThat way you could set the visible/hidden in the options, and you could have both visible and hidden set and, if you wanted to say hide specific items on a sub-classed model which already defines the visible items.\n\u2014\nReply to this email directly or view it on GitHub.\n. Models always represent one row. If you want to fetch multiple rows, use a collection.\n\nSent from my iPhone\n\nOn 16 Jan 2014, at 10:09, Bjorn121 notifications@github.com wrote:\nOk, this will probably be the first question of many :). I have a user object which corresponds to a USER table. This is the object:\nvar Bookshelf = require('bookshelf').MySQL;\nvar User = Bookshelf.Model.extend({\ntableName: 'USER',\nidAttribute: 'USERID'\n});\nmodule.exports = User;\nThis is how I query the database:\nvar user = new User();\nuser.fetch().then(function (model) {\nconsole.dir(model);\n});\nI really don't know why (I've checked the code), but for some reason Bookshelf ALWAYS adds the LIMIT 1 to the query. I've checked the docs, google and even the tests that ship with the package, but I couldn't find a single example nor reason.\nSo is it possible to shed some light on this?\n\u2014\nReply to this email directly or view it on GitHub.\n. Models always represent one row. If you want to fetch multiple rows, use a collection.\n\nSent from my iPhone\n\nOn 16 Jan 2014, at 10:09, Bjorn121 notifications@github.com wrote:\nOk, this will probably be the first question of many :). I have a user object which corresponds to a USER table. This is the object:\nvar Bookshelf = require('bookshelf').MySQL;\nvar User = Bookshelf.Model.extend({\ntableName: 'USER',\nidAttribute: 'USERID'\n});\nmodule.exports = User;\nThis is how I query the database:\nvar user = new User();\nuser.fetch().then(function (model) {\nconsole.dir(model);\n});\nI really don't know why (I've checked the code), but for some reason Bookshelf ALWAYS adds the LIMIT 1 to the query. I've checked the docs, google and even the tests that ship with the package, but I couldn't find a single example nor reason.\nSo is it possible to shed some light on this?\n\u2014\nReply to this email directly or view it on GitHub.\n. Users.forge().fetch()\n\nSent from my iPhone\n\nOn 16 Jan 2014, at 12:07, Bjorn121 notifications@github.com wrote:\nOk, but if I execute this, it doesn't work:\nvar User = require('./user');\nvar Users = Bookshelf.MySQL.Collection.extend({\nmodel: User\n});\nUsers.fetch().then(function (collection) {\nconsole.dir(collection);\n});\nThis is the error I get: TypeError: Object function (){ return parent.apply(this, arguments); } has no method 'fetch'\n\u2014\nReply to this email directly or view it on GitHub.\n. Users.forge().fetch()\n\nSent from my iPhone\n\nOn 16 Jan 2014, at 12:07, Bjorn121 notifications@github.com wrote:\nOk, but if I execute this, it doesn't work:\nvar User = require('./user');\nvar Users = Bookshelf.MySQL.Collection.extend({\nmodel: User\n});\nUsers.fetch().then(function (collection) {\nconsole.dir(collection);\n});\nThis is the error I get: TypeError: Object function (){ return parent.apply(this, arguments); } has no method 'fetch'\n\u2014\nReply to this email directly or view it on GitHub.\n. There's a parse and format method you can override that might help. That's all the help I can offer for that one I'm afraid. \n\nSent from my iPhone\n\nOn 16 Jan 2014, at 13:39, Bjorn121 notifications@github.com wrote:\nOk, thanks for all the comments, really appreciate it. I had a look at the collection and object files in the test packages and redesigned a couple things.\nSomething that I've been wondering about for a while now is how I can configure custom column names for attributes. For instance, my User has 4 columns, FIRSTNAME, LASTNAME, PASSWORD and EMAIL). But in my object I would like to use the camelcase attributes.\nAnd what if it's completely different.  I have a table with a OneToOne relationship with User, based on the UserID. But the column in the other table is called OWNER.\n\u2014\nReply to this email directly or view it on GitHub.\n. I don't think having multiple properties that do the same thing is a good idea. It's a well documented part of the API. I don't think it should be changed. \n\nSent from my iPhone\n\nOn 17 Jan 2014, at 21:00, Ben Drucker notifications@github.com wrote:\nClosed #197.\n\u2014\nReply to this email directly or view it on GitHub.\n. How do you intend to work around cyclic dependencies?\n\nOn 18 January 2014 21:29, Ben Drucker notifications@github.com wrote:\n\nRealizing it makes no sense to allow string references to models. It's too\nmuch magic and it would require a lot of tests in order to not introduce\nbugs. The current implementation assumes every Target is a model. String\nreferences force a significant refactor since all of a sudden every place\nthat uses a Target can't assume it's a model.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/199#issuecomment-32693695\n.\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. Yes my first reaction was the same but thinking about it, it could work.\nSent from my iPhone\n\nOn 18 Jan 2014, at 17:08, Ben Drucker notifications@github.com wrote:\nMy first instinct was to say that this isn't possible right now. But I'm actually not sure that's true. It would be great if you could try and report back. I'd ask Tim but he's in the process of moving/going on vacation.\n\u2014\nReply to this email directly or view it on GitHub.\n. Is it not possible to add a delete method to collection that runs in one query? \n\nSent from my iPhone\n\nOn 27 Jan 2014, at 13:34, Tim Griesser notifications@github.com wrote:\nClosed #213.\n\u2014\nReply to this email directly or view it on GitHub.\n. Is it not possible to add a delete method to collection that runs in one query? \n\nSent from my iPhone\n\nOn 27 Jan 2014, at 13:34, Tim Griesser notifications@github.com wrote:\nClosed #213.\n\u2014\nReply to this email directly or view it on GitHub.\n. Make it so the standard destroy only works when there are constraints set,\nand then a force flag or something that will delete without constraints.\nMake the exception thrown if there are no constraints so that it is clear\nwhy it is being thrown.\n\nOn 27 January 2014 18:24, Tim Griesser notifications@github.com wrote:\n\nIt's certainly possible, it's just a matter of determining how the\nsemantics around that would work...I also didn't want to make it super easy\nto blow away an entire database table with no arguments\ncollection.destroy().\nDefinitely something on the radar but I haven't taken time to work through\nthe details yet.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/213#issuecomment-33404312\n.\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. Make it so the standard destroy only works when there are constraints set,\nand then a force flag or something that will delete without constraints.\nMake the exception thrown if there are no constraints so that it is clear\nwhy it is being thrown.\nOn 27 January 2014 18:24, Tim Griesser notifications@github.com wrote:\n\nIt's certainly possible, it's just a matter of determining how the\nsemantics around that would work...I also didn't want to make it super easy\nto blow away an entire database table with no arguments\ncollection.destroy().\nDefinitely something on the radar but I haven't taken time to work through\nthe details yet.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/213#issuecomment-33404312\n.\n\n\nThanks,\nNathaniel Higgins\nhttp://nath.is\n@nathggns http://twitter.com/nathggns\n. ",
    "mackwic": ":up: ?\n. ",
    "chrisfrancis27": "Is there a recommended standard way of achieving this yet? I've tried this on my Dataset model:\njavascript\ncommentCount: function() {\n  return this.hasMany('Comment').query({\n    count: 'id as comment_count'\n  });\n},\ncomments: function() {\n  // One-to-many\n  return this.hasMany('Comment');\n}\nBasically I want a comments array attribute to be populated when retrieving a single model, but a commentCount for each model when retrieving a collection. This seems to generate the right sort of query:\nsql\nselect count(\"id\") as \"comment_count\" from \"comments\" where \"comments\".\"dataset_id\" in (?, ?, ?)\nBut the response is returning \"commentCount\": [] (an empty array, not a number as I'd expect). Any ideas where I'm going wrong?\nCheers\n. Hey @rhys-vdw, thanks for the quick response! :) I was trying to define the counts as attributes in the model definition itself, so in my controller I could use something declarative like:\n``` javascript\n// GET /datasets/\nDataset.fetchAll({\n  withRelated: ['assetCount', 'commentCount']\n}).then(\n  collection => reply({ datasets: collection })\n);\n// GET /datasets/:id\nnew Dataset(request.params.id).fetch({\n  withRelated: ['assets', 'comments']\n}).then(\n  model => reply({ dataset: model })\n);\n```\nNote the withRelated option is different between the collection and singular queries. However, I've now changed it to use the .count() function as you mention above, and to remove the withRelated: [...] subquery entirely, so my controller now looks like this:\njavascript\n// GET /datasets/\nDataset.fetchAll().then(datasets => {\n  Promise.all(datasets.map(d => {\n    return Promise.all([\n      d.comments()\n        .query('where', 'dataset_id', '=', d.id)\n        .count()\n        .then(c => d.set('commentCount', c)),\n      d.assets()\n        .query('where', 'dataset_id', '=', d.id)\n        .count()\n        .then(c => d.set('assetCount', c))\n    ]);\n  })).then(() => {\n    return reply({ datasets });\n  });\n});\nI'll look into optimising it further to reduce the number of DB calls (currently 2 select count(*) calls per model) but for now this works well enough.\n. Any fix for this? I've just encountered exactly the same bug in 0.9.1. I have a model which has a parents collection using belongsToMany and through:\njavascript\nparents: function() {\n  // Many-to-many\n  return this.belongsToMany('Thing')\n    .through('Relationship', 'object_id', 'subject_id')\n    .query({\n      where: { type: 'upstream' }\n    })\n  ;\n}\nAfter fetching the collection, the length property seems correct, but enumerating over the models returns many duplicates:\njavascript\nthing.parents()\n  .fetch()\n  .then(prevModels => {\n    console.log(prevModels.length); // 2\n    console.log(prevModels.map(m => m.id)); // [ 24, 24, 26, 24, 26, 24, 26, 24, 24, 26, 24, 26, 24, 26, 24, 26 ]\n  })\n;\nI've verified that the entire model is the same as in @rbdr's example, not just the id attribute.\n. ",
    "andrewscwei": "I am currently on version 0.8.2 and it seems like when I perform count() on a hasMany collection of a model, it loses the relation filter. Is that intended behavior? \nFor example, let's say I have a simple model like so:\njavascript\nlet User = bookshelf.Model.extend({\n  tableName: 'users',\n  comments: function() {\n    return this.hasMany('Comments');\n  }\n}\nand I do:\njavascript\nUser.forge({ id: 1 }).comments().count();\n...this generates the following SQL command:\nsql\nselect count(*) as `count` from `comments`\n...and gives me a count of all the comments in the table rather than just comments where user_id is 1.\nIn order to get the comment count of that particular user I have to explicitly specify it like so:\njavascript\nUser.forge({ id: 1 }).comments().query('where', 'user_id', '=', 1).count();\nwhich then generates:\nsql\nselect count(*) as `count` from `comments` where `user_id` = ?\nThis feels a bit odd to me and I would assume that the first example should give me the number of comments specific to the user. Is this how it is supposed to be or am I missing something? Please advise, thanks!\n. Actually I just saw issue #715 which is exactly related to what I mentioned. Sorry for the duplicated report.\n. ",
    "acepukas": "@rhys-vdw I haven't run the tests but I have a strong feeling that the test you referenced is giving a false positive if it's passing. The code responsible for constraining relations on collection.count() queries will only be applied to \"through\" relationships on models/collections. It appears it's been that way since version 0.8.2. I'm currently working with version 0.9.1.\nThe \"constrain\" function in the Sync class is the culprit, this line specifically. It checks for a \"through\" relationship on the Relation object but there is no branch for dealing with \"hasMany\" relationships.\nI've patched it with an \"else if\" like so:\njavascript\nif (relatedData.isThrough()) {\n  // ...\n} else if(relatedData.type === 'hasMany') {\n  var fk = relatedData.parentTableName + '_' + relatedData.parentIdAttribute;\n  knex.where(fk, '=', relatedData.parentFk);\n}\nIt's pretty naive code. I don't know the Bookshelf code base well enough to know if I'm missing some edge case here but it's working.\njavascript\nthis.posts().count(); // properly filtering by relations with \"hasMany\" constraint added\nI'm guessing this would conflict with the hasMany(Model, 'foreign_key') scenario. Anyway, just thought I'd point it out.\n. Alright @rhys-vdw, in the interest of thoroughness I went ahead and forked bookshelf and got the test suite up and running. My suspicions were confirmed regarding the hasMany count test reporting a false positive. In fact all of the collection integration tests were faulty.\nThis test helper here is the culprit.\nReplacing that function with\n``` javascript\nvar formatNumber = { // formatNumber does not need to be placed in checkCount.\n  mysql:      .identity,\n  sqlite3:    .identity,\n  postgresql: function(count) { return count.toString(); }\n}[dialect];\nvar checkCount = function(actual, expected) {\n  expect(actual).to.equal(formatNumber(expected));\n}\n```\nthen allows the hasMany count test to fail.\nI noticed that a similar checkCount function is in test/integration/model.js so there may be false positives lurking in those tests too.\nNow that that test fails, placing this snippet here:\njavascript\n} else if(relatedData.type === 'hasMany' && options.isCount) {\n  const fk = relatedData.key('foreignKey');\n  knex.where(fk, '=', relatedData.parentFk)\n}\nand adding this line before here:\njavascript\noptions.isCount = true;\nwill pass the test.\nThe options.isCount is not the most elegant workaround to the fact that testing for hasMany relationship wasn't enough to isolate the constraint to just collection.count() calls. Maybe someone knows a better way.\n. ",
    "stiff": "@acepukas Great job, I was feeling the same, and can confirm that in actual use count() didn't work as advertised but it was not critical enough for me for such a deep investigation.\n. @acepukas Great job, I was feeling the same, and can confirm that in actual use count() didn't work as advertised but it was not critical enough for me for such a deep investigation.\n. ",
    "cmcewen": "I'm trying to use count as an attribute on a model, very similar to this https://github.com/tgriesser/bookshelf/issues/126#issuecomment-149580534\nI'm getting an error: TypeError: Cannot read property 'parentFk' of undefined, which I've traced back to this line https://github.com/tgriesser/bookshelf/blob/master/src/eager.js#L24.\nIs that an incorrect way to use this function, or is this something worth debugging and fixing?\nI might end up needing to just write a separate group by query myself in order to make this performant (the use case is something similar to fetching a bunch of Posts in a feed which all have various numbers of Likesthat should be attached to them), but happy to contribute if it will help out.\n. Comment moved\n. @rhys-vdw I guess my problem is solved in the sense that I know it's not possible so you can go ahead and close it out, but I do think it would be a useful feature to define relation counts that way.\nI'm fetching a collection of many models that all have these relationships, so using the solution you suggested seems pretty inefficient - for 20 models in a collection, that means iterating through each of them and running 20 SQL queries.\nMy current solution is to fetch the collection, run a count (*) group by query on the related table using the ids of the models in the collection, and  then iterate through and assign the results to each item in the collection.\n. Yes, that's the correct outcome. That's still the N+1 queries problem though, correct?\n. ",
    "gregucsd": "Any update on this? I cannot find a pattern that works with use of through().\n. Yes.  But I'm new to the use of the pool parameter and want to make sure this doesn't impact Bookshelf in any way.\n. That makes sense.  Thanks.\n. Just ran into this myself with redefinition of endsWith from babel-polyfill.  Still trying to track down the other package that defines it...\n. ",
    "frogcjn": "TypeScript\n    User.collection().query(function (qb) {\n      qb.join('courses', 'users.id', 'courses.user_id');\n      qb.groupBy('users.id');\n      qb.select(\"users.*\");\n      qb.count('* as course_count');\n      qb.orderBy(\"course_count\", \"desc\");\n    }). ```TypeScript\n    User.collection().query(function (qb) {\n      qb.join('courses', 'users.id', 'courses.user_id');\n      qb.groupBy('users.id');\n      qb.select(\"users.\");\n      qb.count(' as course_count');\n      qb.orderBy(\"course_count\", \"desc\");\n    })\n```\n   . ",
    "muhaimincs": "@frogcjn how do you manage to get collection(). please check similar issue here https://github.com/bookshelf/bookshelf/issues/445. @rhys-vdw I can't access knex to use select(). What is the right way to access knex? knex turn out to be undefined. I was just testing it to see what value appear in knex. js\nModel.query(function (qb, knex) {\n  var sub = knex(...); //undefined\n  qb.join(sub);\n});\nIs there any options need to be specific on the model part?. ",
    "harry-zhang": "+1 on being able to override primaryKey.  Right now we have two tables\n``` CoffeeScript\nJob = db.Model.extend(\n  tableName: \"jobs\"\n  to: ->\n    @hasOne Address, \"id\"\n  from: ->\n    @hasOne Address, \"id\"\n)\nAddress = db.Model.extend(\n  tableName: \"addresses\"\n)\nnew Job(\"id\": id).fetch(withRelated: [\"to\", \"from\"]).then (model) ->\n    reply(model)\n```\nSo logically what I want is my entire job object returned, along with the nested breakout of what the address should be.  However, there doesn't seem to be an easy way to do this in Bookshelf without writing your own query.  The debug string from Bookshelf \n{ sql: 'select `jobs`.* from `jobs` where `id` = ? limit 1',\n  bindings: [ '00a0f5a2f1e40e7b5fa3' ],\n  __cid: '__cid1' }\n{ sql: 'select `addresses`.* from `addresses` where `addresses`.`id` in (?)',\n  bindings: [ '00a0f5a2f1e40e7b5fa3' ],\n  __cid: '__cid2' }\n{ sql: 'select `addresses`.* from `addresses` where `addresses`.`id` in (?)',\n  bindings: [ '00a0f5a2f1e40e7b5fa3' ],\n  __cid: '__cid1' }\nIt looks like it's forcing the bindings in the to and from queries I want to use the job_id that was initially passed.  There doesn't seem to be anywhere in the docs that lets me override the primary key being used.  The only option is to specify the foreign key that it is searching on in addresses (which I have already overridden to use \"id\" instead of Bookshelf's default \"address_id\").\nEDIT: Nevermind...realized I can do a belongTo and set the foreign key to to & from for it.\n. +1 on being able to override primaryKey.  Right now we have two tables\n``` CoffeeScript\nJob = db.Model.extend(\n  tableName: \"jobs\"\n  to: ->\n    @hasOne Address, \"id\"\n  from: ->\n    @hasOne Address, \"id\"\n)\nAddress = db.Model.extend(\n  tableName: \"addresses\"\n)\nnew Job(\"id\": id).fetch(withRelated: [\"to\", \"from\"]).then (model) ->\n    reply(model)\n```\nSo logically what I want is my entire job object returned, along with the nested breakout of what the address should be.  However, there doesn't seem to be an easy way to do this in Bookshelf without writing your own query.  The debug string from Bookshelf \n{ sql: 'select `jobs`.* from `jobs` where `id` = ? limit 1',\n  bindings: [ '00a0f5a2f1e40e7b5fa3' ],\n  __cid: '__cid1' }\n{ sql: 'select `addresses`.* from `addresses` where `addresses`.`id` in (?)',\n  bindings: [ '00a0f5a2f1e40e7b5fa3' ],\n  __cid: '__cid2' }\n{ sql: 'select `addresses`.* from `addresses` where `addresses`.`id` in (?)',\n  bindings: [ '00a0f5a2f1e40e7b5fa3' ],\n  __cid: '__cid1' }\nIt looks like it's forcing the bindings in the to and from queries I want to use the job_id that was initially passed.  There doesn't seem to be anywhere in the docs that lets me override the primary key being used.  The only option is to specify the foreign key that it is searching on in addresses (which I have already overridden to use \"id\" instead of Bookshelf's default \"address_id\").\nEDIT: Nevermind...realized I can do a belongTo and set the foreign key to to & from for it.\n. +1 this would be very helpful\n. +1 this would be very helpful\n. ",
    "joepie91": "Not sure if this is strictly the same issue, but I have the following usecase/situation. A proposed solution is included at the bottom.\nI'm building an application that makes heavy use of revisioned objects. The table structure of revisionable objects (and associations) resembles roughly the following structure (irrelevant columns removed for clarity):\n``` sql\nCREATE TABLE nodes\n(\n  id text NOT NULL,\n  perma_id text,\n  deleted boolean,\n  name text,\n  CONSTRAINT nodes_pkey PRIMARY KEY (id)\n)\nCREATE TABLE node_tags\n(\n  id text NOT NULL,\n  perma_id text,\n  deleted boolean,\n  name text,\n  CONSTRAINT node_tags_pkey PRIMARY KEY (id)\n)\nCREATE TABLE node_tag_associations\n(\n  id text NOT NULL,\n  node_id text,\n  tag_id text,\n  CONSTRAINT node_tag_associations_pkey PRIMARY KEY (id)\n)\n```\nThe node_tag_associations table acts as a pivot table for a belongsToMany relationship, and may contain additional metadata for the relationship. My issue (and proposed solution) also apply to other relationship types, though.\nRevisioning is done according to the following rules:\n1. The latest revision will have deleted = false. If an object is deleted in its entirety, all revisions have deleted = true, including the last one.\n2. id indicates the unique ID for that row/revision.\n3. perma_id indicates the 'object ID' - that is, the ID of the object the revision is meant to represent. The perma_id is shared across all revisions of an object, and thus not unique across the table - which makes it unfit for use as an idAttribute.\n4. All IDs are UUIDs.\nNow here's the catch: foreign keys refer to the perma_id of an object, not to the id of a particular revision. It should always just select the latest revision for that object (which is fairly easy to accomplish through a .query on the relationship, as far as I can tell). However, the id is the primary key that uniquely identifies a row, and is thus what should be used for eg. DELETE and UPDATE operations.\nThe current assumption that bookshelf makes is that the foreign key and primary key refer to the same column - in more complex usecases such as the above, this simply isn't the case.\nMy proposed solution: have a separate idAttribute and (optional) relationIdAttribute option on model definition. When resolving a foreign key in either direction, use the relationIdAttribute if it is defined, otherwise fall back to the idAttribute. This should solve nearly every foreign-key-ID-related issue, not just my use case, with a minimal change.\nThis solution will preserve backwards compatibility. It also seems fairly simple to implement from a quick browse through the bookshelf code, but I don't feel that I'm familiar enough with the internals yet to submit a patch myself (as this  would touch critical code).\n. I've worked around this in my wrapper by simply checking _.isEmpty(this.changed) (where this is the model). Should be fairly simple to implement in core - I'd say that silent failure could be a valid option here when no changes have been made.\n. My testing attempts fail for unclear reasons:\n```\nsven@linux-rfa7:~/projects/bookshelf> npm test\n\nbookshelf@0.7.7 test /home/sven/projects/bookshelf\nmocha -b -t 5000 --check-leaks -R spec test/index.js\n\nUnit Tests\n    Collection\n      \u2713 should have a tableName method, returning the tableName of the model \n      \u2713 should have an idAttribute method, returning the idAttribute of the model \n      \u2713 should initialize the items passed to the constructor \n      \u2713 should use the reset method, to reset the collection \n      \u2713 should use _prepareModel to prep model instances \n      \u2713 contains a mapThen method, which calls map on the models, and returns a when.all promise \n      \u2713 contains an invokeThen method, which does an invoke on the models, and returns a when.all promise \n      #set()\n        \u2713 should delete old models and add new ones by default \n        \u2713 should not remove models with {remove: false} option set \n        \u2713 should not merge new attribute values with {merge: false} option set \n        \u2713 should accept a single model, not an array \n        \u2713 should accept Models \n        \u2713 should not add models with {add: false} option set \n    Sync\n      prefixFields\n        \u2713 should prefix all keys of the passed in object with the tablename \n        \u2713 should run after format \n    SQL Model\n      #save\n        \u2713 should clone the passed in options object \nIntegration Tests\n    \u2713 should allow creating a new Bookshelf instance with \"new\" \n    Dialect: mysql\n      1) \"before all\" hook\n17 passing (5s)\n  1 failing\n1) Integration Tests Dialect: mysql \"before all\" hook:\n     Error: timeout of 5000ms exceeded\n      at null. (/home/sven/projects/bookshelf/node_modules/mocha/lib/runnable.js:139:19)\n      at Timer.listOnTimeout [as ontimeout] (timers.js:112:15)\nnpm ERR! Test failed.  See above for more details.\nnpm ERR! not ok code 0\n```\nThat looks like a technical issue, not a test failure due to code modifications. How do I resolve this?\n. Both PostgreSQL and SQLite pass fine. It appears to only be an issue with MySQL. I've checked whether my MySQL server is running, thinking it might have been a connection issue, but it's running fine and the configuration matches that in the test (password-less root, bookshelf_test database).\n. Both PostgreSQL and SQLite pass fine. It appears to only be an issue with MySQL. I've checked whether my MySQL server is running, thinking it might have been a connection issue, but it's running fine and the configuration matches that in the test (password-less root, bookshelf_test database).\n. Right - I still haven't added a test for the new functionality, though. I don't really have any experience with Mocha, so it'd be quite hard for me to write a test without being able to try it out it locally. Is this a problem?\n. Right - I still haven't added a test for the new functionality, though. I don't really have any experience with Mocha, so it'd be quite hard for me to write a test without being able to try it out it locally. Is this a problem?\n. Alright, I've added the relevant tests, and it appears to pass all of them without breaking any existing stuff. Looks like it's good to go :)\n. Alright, I've added the relevant tests, and it appears to pass all of them without breaking any existing stuff. Looks like it's good to go :)\n. For metadata/reference purposes: this pull request would fix #238.\n. For metadata/reference purposes: this pull request would fix #238.\n. I do understand that structured data is more practical, but the problem with Dash is that it's only available for OS X, and that (to my knowledge) it's not open-source, so can't easily be ported either. DevDocs is an open-source platform that's available to anybody on any platform with a browser. Perhaps DevDocs should support the Dash format? I'm not sure if that's possible, from both a legal and a practical point of view.\n. It might if the changes are significant. As far as I can tell, Bookshelf uses the same documentation format as Underscore (is this from a particular generator of some sort?), and small changes likely won't break it.\nThat said, do you know of a specification for the Dash format anywhere? If there's a complete spec, I'll bug the DevDocs developers with that. If it's feasible, then I'd definitely not be against them adopting the Dash format.\n. Perhaps it's an idea to introduce a .toJSONAsync() method (in the virtuals plugin) that returns a promise, that will only resolve after any child promises have finished resolving?\n. @bendrucker Can you give a (basic) code example of how that would work with the fetching event?\n. I'd say that two critical things for relations are as follows:\n1. Refined relation queries\nIt ought to be possible to define certain constraints on relations beyond the foreign key - think something along these lines (see also the second point below):\njavascript\nnode: function(){\n    return this\n        .belongsTo(\"Node\", \"node_id\", \"perma_id\")\n        .where( { is_latest_revision: true } );\n}\n2. Column names\nRight now, relations make certain assumptions; they sometimes assume things about the column naming scheme (like was the case with polymorphic relations prior to my patch for this), and they assume that the primary key is always the key that is used for foreign keys. Neither assumption is correct.\nA practical example of the second issue: in a revisioned table, a revision may be identified by a particular primary key, while foreign keys in other tables may be refering to the persistent (revision-independent) ID of an object, and where it is expected to simply resolve to the latest revision for that object ID (this also ties into my first point above, regarding refined relations).\n. @bkniffler I'd imagine that if models become decoupled from a Bookshelf instance (ie. stateless), that shouldn't be too hard to write a third-party module for, even if it isn't in core.\n. For clarification - the thing I was describing was to automatically create an \"error subclass\" for each model, so that you could handle NotFoundErrors by looking for eg. User.NotFoundError or Post.NotFoundError.\n. Does this also affect Knex, or just Bookshelf?\nAlso, I feel like closing old issues is the wrong thing to do here. It's not going to make any actual issues go away, and may result in information about hard-to-reproduce issues (that occur semi-regularly but are rarely reported) getting lost in the shuffle for a long time. A coordinated triaging effort is probably more useful.\n\nI just have one (probably unpopular) suggestion and that is to drop babel. Since node versions 0.10 and 0.12 are no longer supported is it really still necessary?\n\nThe first version of Node.js with full-ish ES6 support was Node.js 6.x, so Babel is not totally unnecessary yet, as Node 4.x is still supported.\nEDIT: For the sake of completeness, the Node.js support schedule can be found here, and feature support can be found here.. > We are willing to re-open any issues when devs speak up for it. There were 420 open issues. I clamped them down to 175.\nThe developer reporting it may no longer be around, even if the rest of the users would still benefit from the fix.\n\nDue to work, studies etc. @Playrom, @ricardograca and I would likely never get around to work on most of the issues.\n\nUnderstandable, but that can be solved through a coordinated triaging effort. That does not have to be undertaken by just the maintainers; anybody can contribute to that. I suspect that even \"close all the unanswered question-marked issues\" alone would already significantly reduce the work required, without affecting issue resolution.\nI'd personally be happy to help triage some issues (reviewing them, leaving comments on whether they should be closed or are already fixed, etc.) as I find the time to do so. At that point, maintainers just need to look at the comments left and follow up with a close/label/etc. I'd imagine there'd be more users willing to do so, if asked.\n\nalso if someone get some bad behaviour a simple search can prompt and old issue that can be reopened without any problem\n\nThis isn't realistic. GitHub's issue search is pretty crap, and if somebody doesn't already know exactly what they are looking for (and especially for hard-to-reproduce bugs that is very likely to be the case), they won't find anything, decide that they don't have enough data to file an issue, and just not bother.. > We are trying to do the best for the project, don't hate us please. We want to create a good community with a lot of developers to thrive the future of bookshelf\nNo worries, absolutely no animosity intended. I'm just trying to help get the best possible result here for Bookshelf :)\n\nok if we can find a nice group of people that can triage all the past issue for me it is not a problem to reopen them all!\n\nHereby the request to anybody reading this thread: please leave a comment if you'd like to help out with an effort to triage old issues!\nTriaging would mostly just involve reading the issues, classifying them (is it a question? a bug report?), and determining whether they are still relevant (is the bug fixed already? is the issue reproducible, or does it need more information?), then leaving a comment with the verdict. It can be done whenever people have time, doesn't require scheduling.. > Also as far as the 'questions' go.. it's not uncommon for projects to only field actual issues and bug reports. I'm sure we can find some reasonable middle ground.\nPerhaps a reasonable metric would be \"is this already covered in the documentation?\". If yes, close it and point to the documentation; if no, treat it as a documentation bug (and update the documentation with the answer, instead of just posting the answer in the issue thread). Things that shouldn't be in the documentation in the first place (eg. \"how do I combine Bookshelf with X\") should then just be directed to StackOverflow or such.\n(Also, GitHub really needs better facilities for dealing with usage questions...). > This won't be easy because most of the time there's no code example on how to reproduce the bug.\nThese are probably a good candidate for \"ask for a minimal testcase, close the issue after 2 weeks if none has been provided, unless there's a good reason for it\" or a similar policy. The issue template should also probably be updated to ask for such a testcase more explicitly, as it's currently a bit vague on what's expected and what's optional.\n\nHowever sometimes the questions are about advanced usages of Bookshelf that may even require dropping down to knex. Is this something we want in the docs?\n\nI think it's reasonable to explain non-obvious and frequently-asked-about cases in the documentation, but not everything should be listed there. For example, \"how do I represent a multi-level many-to-many relationship with Bookshelf and Knex\" is a question that's worth covering in the documentation, but \"how do I use Bookshelf with Express\" probably is not.\n\nI think the best thing to do is to go over the issues that are not labeled and figure out what they are and apply a label.\n\nIt's worth noting that only maintainers/collaborators can add labels, so to spread the workload amongst other users it would probably be ideal to:\n\nHave a central issue thread tracking old issues\nAsk 'triagers' to leave a comment on a thread suggesting a label / confirming reproducibility / etc.\nAsk them to then leave a comment on the central issue thread to notify the maintainers when triage for an issue is \"done\".\n\nThis means that maintainers would only need to track a single thread to know where labels need to be applied, issues need to be closed, and so on.. ",
    "JBustin": "@bendrucker : how the use of belongsToMany could resolve @kaemu problem ?\nThank you\n. Hello, when do you think this issue will be done ?\nThanks\n. Hello, when do you think this issue will be done ?\nThanks\n. ",
    "jkuri": "+1 for overriding the primaryKey in cases like this.\n. ",
    "kousha-icracked": "This is still a problem. Has there been a fix for it yet?\n. This is still a problem. Has there been a fix for it yet?\n. ",
    "chenghung": "+1 for developer can specify primary key\n. still happened on lodash 4.16.6.. still happened on lodash 4.16.6.. +1 because id attribute is unique, no need to count distinct id.. +1 because id attribute is unique, no need to count distinct id.. thanks for reply, I've read that docs before.\nlet me clarify my question again:\nIs it better that calling save() with patch option not only update attributes passed to save() method but only includes previous changed attribute through set() method ?. ",
    "lumberj": "@ricardogama that doesn't solve this particular case\n. @ricardogama that doesn't solve this particular case\n. Was this issue ever revisited?\n. Was this issue ever revisited?\n. ",
    "shortstuffsushi": "Ok, I can live with that explanation. You may want to clarify a bit in the docs, though -- \nbelongsTo: model.belongsTo(Model, [otherKey]) \nThe belongsTo defines an inverse one-to-one relation, ... referenced by the otherKey in the target Model. By default, the other key is assumed to be the singular form of the target Model with a _id suffix.\nEmphasis mine, on both of the \"target model\" portions. Those lead me to post this in the first place, it seems the docs say that both hasOne and belongTo use the field in the Target Model.\n. Ok, I can live with that explanation. You may want to clarify a bit in the docs, though -- \nbelongsTo: model.belongsTo(Model, [otherKey]) \nThe belongsTo defines an inverse one-to-one relation, ... referenced by the otherKey in the target Model. By default, the other key is assumed to be the singular form of the target Model with a _id suffix.\nEmphasis mine, on both of the \"target model\" portions. Those lead me to post this in the first place, it seems the docs say that both hasOne and belongTo use the field in the Target Model.\n. In terms of that hasOne/belongsTo? Or the target model wording issue I mentioned?\n. In terms of that hasOne/belongsTo? Or the target model wording issue I mentioned?\n. Alright, sounds good. Thanks all for clarifying.\n. Alright, sounds good. Thanks all for clarifying.\n. Yep, that looks great. Thanks\n. Yep, that looks great. Thanks\n. I'm not entirely sure I follow all of that, but I think I got most of the gist. However, there are several complicating factors that seem to be preventing it from \"just working.\" One is the fact that I needed the initialize on the collection (I probably should have mentioned that), the other is that I need dot notation to work.\nBasically, I have a Collection of Foos, each of which has a Collection of Bars, and each Bar has the computed property (which is computed off of a third Collection of Bazs on Bar).\nWhat I was trying was like this:\nFoo.Collection.forge()\n  .query({...})\n  .fetch({\n    withRelated: [ 'barRelation.bazs' ],\n    withComputed: [ 'barRelation.bazsComputed' ]\n  })\n  .then(...)\nI know this is probably getting pretty convoluted, but it would be great to get this working. I tried reading through the code to find how the dot notation works for relations, but didn't find anything that specifically helped.\n. Yeah, I'm still not sure what direction I'm going to take it -- whether that property will be useful in all cases or just the one that I'm working on. I'll probably just move the logic into its consumer for now, which isn't too bad since it's still server side at least. I had seen the split method, but I haven't pieced together how the whole thing is working yet (what it does with those split pieces), maybe I'll eventually try to model something off of that, if it seems useful. We'll see. Anyway, thanks for the suggestions.\n. After looking a bit further, using a 'text' type is more appropriate for long strings (missed that before). If you intend to store an object, though, is there a good way to do so?\n. After looking a bit further, using a 'text' type is more appropriate for long strings (missed that before). If you intend to store an object, though, is there a good way to do so?\n. Also, and this may be a bug, toJSON on a through relation is keeping its _pivot_xxx fields, which doesn't seem right. Those are ORM generated fields, which shouldn't come through, right?\n. Also, and this may be a bug, toJSON on a through relation is keeping its _pivot_xxx fields, which doesn't seem right. Those are ORM generated fields, which shouldn't come through, right?\n. I agree, and have implemented it as such. I just wasn't sure what the standard was when I first encountered the issue. The Postgres suggestion is an interesting one, and one that I've been thinking about moving to for a while now. Perhaps this will be all the reason I need.\n. I agree, and have implemented it as such. I just wasn't sure what the standard was when I first encountered the issue. The Postgres suggestion is an interesting one, and one that I've been thinking about moving to for a while now. Perhaps this will be all the reason I need.\n. Interesting, I had searched for an issue around this, but was unable to find one. Definitely a duplicate, glad to see it's being worked on though :thumbsup: \n. Interesting, I had searched for an issue around this, but was unable to find one. Definitely a duplicate, glad to see it's being worked on though :thumbsup: \n. Working around it for now is fine, but do you think this is something worth addressing within the library? It seems like it should work, there doesn't seem to be anything indicating it won't.\n. Working around it for now is fine, but do you think this is something worth addressing within the library? It seems like it should work, there doesn't seem to be anything indicating it won't.\n. Ahhh yes, now it makes sense. I was just using the wrong one. I'm not sure why I always struggle so much with the associations with this library, I can't seem to keep them straight. Oh well, thanks as always for the help.\n. Ahhh yes, now it makes sense. I was just using the wrong one. I'm not sure why I always struggle so much with the associations with this library, I can't seem to keep them straight. Oh well, thanks as always for the help.\n. To be a little clearer or more concrete, this is what I'm seeing with my models\n```\n\npost.replies().models\n< Array[0]\npost.related('replies').models\n< Array[1]\n```\n. Interesting, that looks like a pretty extensive body of work (though I in large part agree with your analysis). Looking forward to how that turns out :thumbsup:\n\nWith regard to this issue, it seems you're saying that in both of this cases, I'm still not quite doing it right (since I've actually already got the relation fetched, forgot to mention that). So, in that case, would I want a third option, like post.relations.replies.models, right?\n. Ahh, ok. Awesome, thanks for explaining.\n. ",
    "tkellen": "I'm accomplishing this by putting a list of dependents on each model's constructor and recursively descending them to build delete queries.\nSample Models:\n``` js\nvar Word = BaseModel.extend({});\nvar Page = BaseModel.extend({\n  words: function () {\n    return this.hasMany(Word, 'page_id');\n  }\n}, { dependents: ['words'] });\nvar Chapter = BaseModel.extend({\n  pages: function () {\n    return this.hasMany(Page, 'chapter_id');\n  }\n}, { dependents: ['pages'] });\nvar Book = BaseModel.extend({\n  chapters: function () {\n    return this.hasMany(Chapter, 'book_id');\n  }\n}, { dependents: ['chapters'] });\n```\nCalling cascadeDestroy on a book instance would run the following:\nsql\nDELETE FROM word WHERE page_id IN (SELECT id FROM page WHERE chapter_id IN (SELECT id FROM chapter WHERE book_id IN (1)));\nDELETE FROM page WHERE chapter_id IN (SELECT id FROM chapter WHERE book_id IN (1));\nDELETE FROM chapter WHERE book_id IN (1);\nDELETE FROM book WHERE id IN (1);\nHere is my BaseModel:\n``` js\nvar _ = require('lodash');\nvar sequence = require('when/sequence');\nvar instanceProps = {\n  cascadeDestroy: function () {\n    var self = this;\n    var queries = this.constructor.cascadeDeletes(this.get('id'));\n    var deleteDependents = sequence(queries.map(function (query) {\n      return query.del.bind(query);\n    }));\n    return deleteDependents.then(function () {\n      return self.destroy();\n    });\n  });\n};\nvar classProps = {\n  // recursively build a tree of dependent tables\n  depMap: function () {\n    var map = {};\n    var deps = this.dependents;\n    deps.forEach(function (dep) {\n      var relation = this.prototypedep.relatedData;\n      map[dep] = {\n        model: relation.target,\n        key: relation.foreignKey,\n        deps: relation.target.depMap()\n      }\n    }, this);\n    return map;\n  },\n  // build an array of queries that must be executed in order to\n  // delete a given model.\n  cascadeDeletes: function (parent) {\n    var queries = [];\n    var deps = this.depMap();\n    Object.keys(deps).forEach(function (dep) {\n      var query;\n      var relation = deps[dep];\n      var table = relation.model.prototype.tableName;\n      if(.isNumber(parent)) {\n        query = DB.knex(table).column('id').where(relation.key, parent);\n      } else {\n        query = DB.knex(table).column('id').whereRaw(relation.key+' IN ('+parent.toString()+')');\n      }\n      queries.push(query);\n      queries.push(relation.model.cascadeDeletes(query).reverse());\n    }, this);\n    return .flatten(_.compact(queries)).reverse();\n  },\n};\nmodule.exports = Bookshelf.Model.extend(instanceProps, classProps);\n```\nref: tgriesser/knex#162\n. I'm accomplishing this by putting a list of dependents on each model's constructor and recursively descending them to build delete queries.\nSample Models:\n``` js\nvar Word = BaseModel.extend({});\nvar Page = BaseModel.extend({\n  words: function () {\n    return this.hasMany(Word, 'page_id');\n  }\n}, { dependents: ['words'] });\nvar Chapter = BaseModel.extend({\n  pages: function () {\n    return this.hasMany(Page, 'chapter_id');\n  }\n}, { dependents: ['pages'] });\nvar Book = BaseModel.extend({\n  chapters: function () {\n    return this.hasMany(Chapter, 'book_id');\n  }\n}, { dependents: ['chapters'] });\n```\nCalling cascadeDestroy on a book instance would run the following:\nsql\nDELETE FROM word WHERE page_id IN (SELECT id FROM page WHERE chapter_id IN (SELECT id FROM chapter WHERE book_id IN (1)));\nDELETE FROM page WHERE chapter_id IN (SELECT id FROM chapter WHERE book_id IN (1));\nDELETE FROM chapter WHERE book_id IN (1);\nDELETE FROM book WHERE id IN (1);\nHere is my BaseModel:\n``` js\nvar _ = require('lodash');\nvar sequence = require('when/sequence');\nvar instanceProps = {\n  cascadeDestroy: function () {\n    var self = this;\n    var queries = this.constructor.cascadeDeletes(this.get('id'));\n    var deleteDependents = sequence(queries.map(function (query) {\n      return query.del.bind(query);\n    }));\n    return deleteDependents.then(function () {\n      return self.destroy();\n    });\n  });\n};\nvar classProps = {\n  // recursively build a tree of dependent tables\n  depMap: function () {\n    var map = {};\n    var deps = this.dependents;\n    deps.forEach(function (dep) {\n      var relation = this.prototypedep.relatedData;\n      map[dep] = {\n        model: relation.target,\n        key: relation.foreignKey,\n        deps: relation.target.depMap()\n      }\n    }, this);\n    return map;\n  },\n  // build an array of queries that must be executed in order to\n  // delete a given model.\n  cascadeDeletes: function (parent) {\n    var queries = [];\n    var deps = this.depMap();\n    Object.keys(deps).forEach(function (dep) {\n      var query;\n      var relation = deps[dep];\n      var table = relation.model.prototype.tableName;\n      if(.isNumber(parent)) {\n        query = DB.knex(table).column('id').where(relation.key, parent);\n      } else {\n        query = DB.knex(table).column('id').whereRaw(relation.key+' IN ('+parent.toString()+')');\n      }\n      queries.push(query);\n      queries.push(relation.model.cascadeDeletes(query).reverse());\n    }, this);\n    return .flatten(_.compact(queries)).reverse();\n  },\n};\nmodule.exports = Bookshelf.Model.extend(instanceProps, classProps);\n```\nref: tgriesser/knex#162\n. This sort of thing will be implemented in another library that sits on top of Bookshelf.\n. This sort of thing will be implemented in another library that sits on top of Bookshelf.\n. Whoops, yes!\n. Whoops, yes!\n. I think it might be possible to support this now?\nhttps://github.com/brianc/node-pg-native\n. I think it might be possible to support this now?\nhttps://github.com/brianc/node-pg-native\n. Yes, I can get the prototype, but it seems like this should be on the prototype, it doesn't change from instance to instance.\n. Augh.  I am not making any sense (muddling prototypical inheritance with class based inheritance because that terminology is used in Backbone/Bookshelf).\nWhat I'm really trying to say is that I think it should be on the constructor\njs\nvar Account = Bookshelf.Model.extend({tableName:'account'});\nAccount.tableName\nBut honestly, it doesn't matter.  Ignore me.\n. You're right, but you'd have to do that on each extended model, or override extend on your base model.  Would you consider a PR that does this automatically in Bookshelf?  I can see this being used elsewhere, for example, on extend getting a list of fields from a table and making it available for the instances/constructor, too.\n. Nah, there isn't a case, it's just a weird impedance mismatch in my brain.  Prototype is technically the right place for it to be, it's just confusing because Backbone/Bookshelf refer to instances and class properties when talking about extension.\n. Did you guys decide not to make the active record stuff another layer on top of bookshelf?\n. Did you guys decide not to make the active record stuff another layer on top of bookshelf?\n. :+1:\n. Will this be in a patch release?\n. Sweet!\n. Whoops, I updated my comment to reflect the correct output (no ID is passed in 0.6.8. on my end).\n. Figured it out.  It was my overriding of format, which is meant to strip invalid fields on save.\njs\nconst Employee = DB.Model.extend({\n  tableName: 'employee',\n  format: function (params) {\n    var fields = _.intersection(Object.keys(params), this.constructor.fields);\n    return _.pick(params, fields);\n  },\n}, {\n  fields: [\n    'id',\n    'first',\n    'last',\n    'date_start',\n    'date_end'\n  ]\n});\nThe params in 0.6.2 are { id: 5 } and in 0.6.8 they are { 'employee.id': 5 }.\n. Is there a prescribed way of doing this that wouldn't cause conflicts?\n. I guess I could just map over my fields adding tableName+'.'.\nI'm curious, what changed internally to require the table prefix?\n. No worries.  Thanks Tim!\n. @tgriesser still super excited about this.  We're using Bookshelf/Knex on numerous internal projects at Bocoup now.  I spent some time today doing a really rough extraction of the little framework around them I've been using here: http://github.com/endpoints.  I haven't extracted the model layer yet.\n. To be more specific, it seems to me that when you query a collection you should get models back by default, no?\n. Actually you're right.  I see now that the issue is in my default serialize method for APIs:\nhttps://github.com/endpoints/controller/blob/master/lib/serialize.js#L8\nit's getting a collection, not an array.  Thanks for the sanity check :)\n. Could you set the constructor name to something useful for collections so I can detect it without bringing in Bookshelf itself to do an identity check?\n. Yeah, that'll do the trick for now.  It's a bit gross, but less gross than the chained promise I have up there.  Thanks Tim!\n. cc @bobholt\n. cc @bobholt\n. This is great stuff @tgriesser!  Sorry for the slow reply.  Some thoughts:\nActive Record vs Data Mapper\nI'm in support of decoupling models from their underlying connection. I'm curious if this change in abstraction would help with getting/caching columnInfo in a transparent manner?\nCollections\nI've never really had a need for collections.  I just define static properties on the model that do return this.collection().query(function() {...});\nAttributes\n<3 <3\nRelations\nThe declarative approach to query building you've outlined in for pulling in relations seems like it could be a huge source of leaking abstractions and additional (unneeded) complexity. If this sort of thing were to be supported it feels like it belongs in Knex as some alternative way to build queries.\nSession\nWould LOVE to do away with this insanity.\nTransactions\n:+1:\nObject Lifecycles\nAgreed 100%.  I do that in all of my base models already.\nI've had this sitting open in a tab for a few days... just posting now to get it out there.  I will respond more when I can.  Thanks for sharing this Tim!\n. I guess you could already do something like this with a single model using related, but you can't for collections. \n. annnd nevermind again, i guess i can use load.\n. cc @bobholt once this (or something like it) lands, we can wrap up https://github.com/endpoints/endpoints/pull/40\n. Yup! I generally try to avoid chaining ternary operators but I will update\nthis PR tonight to that pattern\nOn Feb 23, 2015 6:52 PM, \"Tim Griesser\" notifications@github.com wrote:\n\nWould keep\nvar columnsInQuery = _.some(knex._statements, {grouping:'columns'});\nbut instead following by:\nif (!.isArray(columns)) columns = columns ? [columns] : columnsInQuery ? [.result(this.syncing, 'tableName') + '.*'] : []\nrather than:\nreturn columnsInQuery ? knex : knex.select(columns);\nstill accomplish what you're after?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/pull/633#issuecomment-75664508.\n. updated! i included more verbose notes to any future readers, as well.\n. Could we get this merged and released @tgriesser?\n\ncc @bobholt\n. Could we get this merged and released @tgriesser?\ncc @bobholt\n. Here are some examples of how to do this sort of thing in Ruby:\nhttp://sequel.jeremyevans.net/rdoc/files/doc/advanced_associations_rdoc.html\n. For more context, it would be helpful to be able to access knex in places like this:\nhttps://github.com/endpoints/example/blob/master/src/modules/chapters/model.js#L14\n...without having to require the bookshelf or knex instance directly.\n. :+1:\n. Would be nice if the bare array still had a model property--I use that a lot in endpoints when passing around collections. This would be impossible to infer if the collection was empty.\n. He wants to be able to statically analyze which methods on a model are relations. Right now relations in bookshelf are just anonymous functions.\n. Sure, say you're writing a hypermedia api and you want to enumerate the relations on a model when serializing them. Right now there is no way to do that without something like this:\nhttps://github.com/endpoints/endpoints-example/blob/master/src/modules/books/model.js#L49-L56\n. Without a static listing of relations, there is no way to produce something like this:\njson\n{\n  \"data\":{\n    \"id\":\"1\",\n    \"type\":\"books\",\n    \"attributes\":{\n      \"date_published\":\"1954-07-29\",\n      \"title\":\"The Fellowship of the Ring\"\n    },\n    \"relationships\":{\n      \"chapters\":{\n        \"links\":{\n          \"self\":\"/v1/books/1/chapters\",\n          \"related\":\"/v1/books/1/relationships/chapters\"\n        }\n      },\n      \"firstChapter\":{\n        \"links\":{\n          \"self\":\"/v1/books/1/firstChapter\",\n          \"related\":\"/v1/books/1/relationships/firstChapter\"\n        }\n      },\n      \"series\":{\n        \"links\":{\n          \"self\":\"/v1/books/1/series\",\n          \"related\":\"/v1/books/1/relationships/series\"\n        },\n        \"data\":{\n          \"id\":\"1\",\n          \"type\":\"series\"\n        }\n      },\n      \"author\":{\n        \"links\":{\n          \"self\":\"/v1/books/1/author\",\n          \"related\":\"/v1/books/1/relationships/author\"\n        },\n        \"data\":{\n          \"id\":\"1\",\n          \"type\":\"authors\"\n        }\n      },\n      \"stores\":{\n        \"links\":{\n          \"self\":\"/v1/books/1/stores\",\n          \"related\":\"/v1/books/1/relationships/stores\"\n        }\n      },\n      \"photos\":{\n        \"links\":{\n          \"self\":\"/v1/books/1/photos\",\n          \"related\":\"/v1/books/1/relationships/photos\"\n        }\n      }\n    },\n    \"links\":{\n      \"self\":\"/v1/books/1\"\n    }\n  }\n}\n. Not tested and a bit redundant, but a possible idea to consider:\n``` js\nBookshelf.hasMany = function (fn) {\n  var fn = fn.bind(this);\n  fn.hasManyRelation = true;\n  return fn;\n};\nModel.extend({\n  author: Bookshelf.hasMany(function () {\n    return this.hasMany(require(...));\n  });\n})\n```\n. ",
    "NotBobTheBuilder": "Cool, I didn't realise Ghost is bookshelf based! I'll take a look!\n. Sweet! Any idea how far down the road that may be?\nIn the meantime, are there any open bugs/feature requirements I can help out with?\n. Cool! I'm currently looking into porting something to Node, Bookshelf looks like the ORM for me!\nI'm planning on documenting as I go, I've set up this repo to keep track of my progress.\nI'll happily send in a few pull requests for the docs too, if you like?\n. Agreed - it seems like ARP is something that should sit inside Bookshelf, as opposed to on top. Ofc I'm saying that without having seen what the new project might do, so my opinions are probably on false premises.\n. Valid point; the Backbone philosophy is to do as little as possible, allowing for developer extensibility. It seems reasonable to extend that to here.\nHaving said that, checking whether your model carries attributes for which there aren't fields in the database seems like something everyone will have to do.\nMy thought on the schema-magic, specifically, has come from my experience with Django (and other ORM frameworks, which I haven't dug into as much) where you define models and their relations and the database is created for you. Bookshelf looks like it does that, but I know now that's left to the developer.\n. I didn't mean to imply this should be required - rather just a uniform name for what the key on the model should be [eg permittedValues].\nA logical extension of this would be to have a validate method which then checks that, if permittedValues !== undefined, all the keys in model.attributes are also in permittedValues.\n. That makes sense; consider me convinced!\n. Awesome - that fixed it, thanks!\nThe only thing I've noticed is that the referenced models have \"pivot\" fields, as so:\n{\n  \"id\": 1,\n  \"title\": \"A great talk about such wonderful things\",\n  \"description\": \"\",\n  \"speakers\": [\n    {\n      \"id\": 3,\n      \"name\": \"charles\",\n      \"talks\": null,\n      \"_pivot_talk_id\": 1,\n      \"_pivot_user_id\": 3\n    }\n  ],\n},\nHow do I suppress the _pivot_talk_id and _pivot_user_id fields?\nRelatedly, is there a way to have the speakers.talks values be a list of talk IDs?\n. Cool. Thanks!\n. Cool. Thanks!\n. ",
    "benbarber": "That's perfect, thanks.\n. ",
    "whatyoubendoing": "Joins would be awesome!\n. Cant wait for ES6 features to hit bookshelf. With the coming of IO.js hopefully developers start adopting more ES6 features for their libraries. Wondering if bookshelf would look at adopting a more verbose ORM's like doctrine e.g..\n``` js\nclass User  extends Bookshelf.Model{\n  constructor() {\n    this.attributes = {};\n    this.tableName = 'users';\n  } \nget email () {\n    return this.attributes.email;\n  }\nset email (val) {\n    this.attributes.email = val;\n  }\n}\nUser = bookshelf.makeModel(User);\nvar user = new User();\nuser.email = 'john@example.co.nz';\nuser.save();\n```\n. Same.\n. @kevinob11 @jordansexton I'd suggest objection - https://github.com/Vincit/objection.js/ It also plays nicley with es6 & 7.\n. ",
    "daviddutch": "Any news on this?\n. ",
    "DeadEye0112": "Any news on this ? Is there some workaround for this problem ? Thanks !\n. I don't think you'll be able to achieve better than this. user.role().attach() is the way to go for saving Many-to-Many relations and it returns the updated Collection (role in this case). .return() seems to be the best solution.. Don't fetch it, delete it directly:\nnew Models.SensorCategory({SEC_id:parseInt(id)}).destroy({require: true})\n.then(...). You are hitting a circular reference issue.\nFrom test.js, you require order.js and from order.js, you require test.js\nUse the Bookshelf model registry to avoid this issue: https://github.com/tgriesser/bookshelf/wiki/Plugin:-Model-Registry. ",
    "javiercbk": "Is there somebody working on this feature? I would like to contribute by:\n\u2022 Adding attributes names to models (we may be forced in order to avoid property collisions)\n\u2022 Adding support to joins using what @tgriesser suggested\njs\nstreet: function() {\n   return this.joins(Street); // \"left\", | \"left outer\" | \"inner\" | \"right\"\n}\nAnyone would like to add something? I would if somebody more experienced in the project jumps in and gives me some guidance.. Is there somebody working on this feature? I would like to contribute by:\n\u2022 Adding attributes names to models (we may be forced in order to avoid property collisions)\n\u2022 Adding support to joins using what @tgriesser suggested\njs\nstreet: function() {\n   return this.joins(Street); // \"left\", | \"left outer\" | \"inner\" | \"right\"\n}\nAnyone would like to add something? I would if somebody more experienced in the project jumps in and gives me some guidance.. I think this is a duplicate of #141 which dates from 2013...so no luck for either of us. I think this is a duplicate of #141 which dates from 2013...so no luck for either of us. ",
    "vongohren": "It looks like https://vincit.github.io/objection.js/ can handle this. Maybe take some inspiration from there?. Or maybe its been hyped up as difficult so it seems like a daunting task? Has anyone started to jot down some important factors around this? Personally I don't know if im capable of doing it, but having some thoughts from people who have started to think about the difficulties would be great. This is great information, as said I'm not super capable on SQL so just to expectation control it a bit, and inform that I am not the right person for the job. But it gives a lot insight from a knowledgeable person within the community!. Pluss one on this question! . @ricardogama here is some code https://gist.github.com/vongohren/edd7f3632d7edb7a0fb97b72b316a369\nMalith figured out that if we comment out hasTimestamps:true at https://gist.github.com/vongohren/edd7f3632d7edb7a0fb97b72b316a369#file-bookshelf_error_reproduction-js-L35\nThe plugin works. But now you can atleast reproduce it, and also know a reason to why. A question is if you(@ricardograca ) have any insight into why it might behave like that?. ",
    "pale2hall": "This would be a really helpful feature.\nI have a table with Organizations, and another table with Users (super simplified diagram below)\n\nI'd like to be able to search \"john\" and find companies with the primary contact being John Smith, or find a company called \"John's Auto Body\".\n. This would be a really helpful feature.\nI have a table with Organizations, and another table with Users (super simplified diagram below)\n\nI'd like to be able to search \"john\" and find companies with the primary contact being John Smith, or find a company called \"John's Auto Body\".\n. Seems like some good thoughts and ideas toward https://github.com/bookshelf/bookshelf/issues/959. Seems like some good thoughts and ideas toward https://github.com/bookshelf/bookshelf/issues/959. ",
    "HazemElAgaty": "Any updates on this?. I think this problem could be solved by morphTo, I am not sure I am using it right tho.. ",
    "FvckSh1t": "@tgriesser  Nice! xD\n. Nice, it works! \nI saw the issue you referenced and learnt much.\nThanks!\n. ",
    "ahdinosaur": "thanks! that should be doable, as i'm not sure what data i would need to store within Edges, however at the moment i have on('saving') validations to enforce the graph to be a DAG within Edge.\nwhat's the difference between your example and\nparents: function () {\n  return this.belongsToMany(Vertex).through(Edge, 'targetId' 'sourceId');\n},\nchildren: function () {\n  return this.belongsToMany(Vertex).through(Edge, 'sourceId', 'targetId');\n},\n?\nEDIT: as a remark for a different issue, it appears using the above with attach still bypasses the Edge .on('saving') validations.\n. since belongsToMany seems to be the correct relation, closing issue.\n. oh interesting, thanks.\nadding\ninitialize: function () {\n    var parents = this.parents();\n    parents.on('all', function () { console.log(arguments); }, parents);\n    var children = this.children();\n    children.on('all', function () { console.log(arguments); }, children);\n  },\nto Vertex doesn't log anything.\ni would think 'saving' events should be fired because by attaching a Vertex, an Edge is being persisted to the database (shown using debug: true)\n{ sql: 'insert into \"edges\" (\"sourceId\", \"targetId\") values (?, ?)',\n  bindings: [ 1, 1 ],\n  __cid: '__cid1' }\ni'm also interested in learning other ways of using the parent/child relations that do fire 'saving' events, if attach is not appropriate.\n. ",
    "Tape": "I agree it does feel like a plugin-ish feature. The impact on the codebase is very minimal and is strictly opt-in. I'm open for more opinions on the matter.\n. While it's generally bad practice to write APIs using direct-from-database serialization, there's a few situations I would use visible/hidden properties (for example an application specific layer) where some fields are not necessary.\nAn example of which is if I'm fetching a list of books to be rendered via Angular, I don't necessarily care about having the category_id or author_id fields (those would be associations loaded in their given properties). I understand the risk involved if the schema is going to change, and since I am the sole consumer of this private API I'm ok with that. More than likely at that point a redesign was probably going to happen anyway.\nThat's the best use-case I can come up with. Again this is strictly opt-in and if people view it as bad practice that's fine, it can simply be ignored. It was a feature I first saw in Laravel's Eloquent and liked it. I'll go ahead and see about converting it to a plugin.\n. Go ahead @tgriesser, I haven't had much time to give it a go, I've been working on porting an app to Bookshelf. I may come across some time in the new few days as I have more ideas actually using it in practice. If you're able to do it right now though go right ahead.\n. Go ahead @tgriesser, I haven't had much time to give it a go, I've been working on porting an app to Bookshelf. I may come across some time in the new few days as I have more ideas actually using it in practice. If you're able to do it right now though go right ahead.\n. Sounds good to me, thanks for the quick reply.\n. Sounds good to me, thanks for the quick reply.\n. Helping to clean up my own tickets. This is covered by Model.collection() now.\n. ",
    "recursivefunk": "I'm having this issue as well. Keep in mind if you're on heroku and are using a worker process in addition to a web process and they both connect to the database you are potentially doubling your connection number. For instance, if you're configuration is maxed at 10 but two processes connect you're looking at the max of 20 overall. In addition, if you use a tool to explore your data locally, that tool will connect and count against the limit. So, two processes with a max of 10 (assuming you're at the max) and a third party tool to view data potentially puts you at 21 connections and will cause errors. \n. ",
    "ariden83": "when you do bookshelf.knex.client.pool.destroy()\nhow to recreate it ?. when you do bookshelf.knex.client.pool.destroy()\nhow to recreate it ?. ",
    "ecdeveloper": "I'm experiencing a similar issue when trying to do a bulk update. This seems to be related. I have the following code: \njavascript\nTable1Model.query(qb => {\n  qb\n    .join('table2', 'table2.id', 'table1.table2_id')\n    .where('table1.deleted', null)\n    .where('table2.id', 123);\n})\n.save({\n  'deleted': new Date()\n}, {\n  method: 'update'\n});\nIt generates the following query: \nsql\nupdate `table1` inner join `table2` on `table2`.`id` = `table1`.`table2_id`\nset `Modified` = ?, `deleted` = ?\nwhere `table1`.`deleted` is null\nand `table2`.`id` = 123\nWhich causes eventually the ER_NON_UNIQ_ERROR error for Modified and Deleted. ",
    "taojang": "hi Johannes,\nthanks for the quick reply!\nhere is the debug output from the real scenario\n{ sql: 'select `boat_has_route`.* from `boat_has_route` where `dwh_nid` = ? limit 1',\n  bindings: [ 67271 ],\n  __cid: '__cid1' }\n{ sql: 'select `boat`.* from `boat` where `boat`.`boatID` in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\n{ sql: 'select `boat_has_route_for_bs`.* from `boat_has_route_for_bs` where `boat_has_route_for_bs`.`boatID` in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid1' }\n{ sql: 'select `seasonal_price`.* from `seasonal_price` where `routeID` is null and `seasonal_price`.`boatID` in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\nI'm querying one entry from table 'boat_has_route' which has a belongsTo relationship to boat table on boatID. Boat has a hasMany relationship to table boat_has_route_for_bs. boat_has_route_for_bs has a hasMany relationship to seasonal_price. routeID is existing in boat_has_route_for_bs, and I define the relationship between boat_has_route_for_bs and seasonal_price as follow:\njavascript\n  seasonalPrices: function() {\n    return this.hasMany(SeasonalPrices, 'boatID').query('where', 'routeID', '=', this.get('routeID'));\n  }\nbut from the debug info, this.get('routeID') returns undefined.\nTao\n. hi Johannes,\nthanks for the quick reply!\nhere is the debug output from the real scenario\n{ sql: 'select `boat_has_route`.* from `boat_has_route` where `dwh_nid` = ? limit 1',\n  bindings: [ 67271 ],\n  __cid: '__cid1' }\n{ sql: 'select `boat`.* from `boat` where `boat`.`boatID` in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\n{ sql: 'select `boat_has_route_for_bs`.* from `boat_has_route_for_bs` where `boat_has_route_for_bs`.`boatID` in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid1' }\n{ sql: 'select `seasonal_price`.* from `seasonal_price` where `routeID` is null and `seasonal_price`.`boatID` in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\nI'm querying one entry from table 'boat_has_route' which has a belongsTo relationship to boat table on boatID. Boat has a hasMany relationship to table boat_has_route_for_bs. boat_has_route_for_bs has a hasMany relationship to seasonal_price. routeID is existing in boat_has_route_for_bs, and I define the relationship between boat_has_route_for_bs and seasonal_price as follow:\njavascript\n  seasonalPrices: function() {\n    return this.hasMany(SeasonalPrices, 'boatID').query('where', 'routeID', '=', this.get('routeID'));\n  }\nbut from the debug info, this.get('routeID') returns undefined.\nTao\n. here is the row I've got from 3rd query\n// irrelevant columns removed\n[ { boatID: 1,\n    routeID: 2,\n    seasonalPrices: [] } ]\nand I'm querying like\njavascript\nvar boatHasRoute = new BoatHasRoute({id: someid});\n// bshbhr is the relation name of boat_has_route_for_bs\nboatHasRoute.fetch({withRelated: ['boat', 'boat.bshbhr', 'boat.bshbhr.seasonalPrices']}).then(...);\nThanks,\nTao\n. here is the row I've got from 3rd query\n// irrelevant columns removed\n[ { boatID: 1,\n    routeID: 2,\n    seasonalPrices: [] } ]\nand I'm querying like\njavascript\nvar boatHasRoute = new BoatHasRoute({id: someid});\n// bshbhr is the relation name of boat_has_route_for_bs\nboatHasRoute.fetch({withRelated: ['boat', 'boat.bshbhr', 'boat.bshbhr.seasonalPrices']}).then(...);\nThanks,\nTao\n. sorry for the late reply and thank you for your help! Here are my models\n``` javascript\nvar Boat = bookshelf.Model.extend({\n  tableName   : 'boat',\n  idAttribute : 'boatID',\n  // seasonal prices will be related with bshbhr\n  bshbhr: function() {\n    return this.hasMany(BookingSystemsHasBoatHasRoute, 'boatID');\n  }\n});\nvar BoatHasRoute = bookshelf.Model.extend({\n  tableName   : 'boat_has_route',\n  idAttribute : 'dwh_nid', // boatID, routeID also exist in this table\n  boat: function() {\n    return this.belongsTo(Boat, 'boatID');\n  }\n});\nvar BookingSystemHasBoatHasRoute = bookshelf.Model.extend({\n  tableName   : 'boat_has_route_for_bs',\n  idAttribute: 'boatID', // should be ['boatID', 'routeID']\n  seasonalPrices: function() {\n    return this.hasMany(SeasonalPrices, 'boatID').query('where', 'routeID', '=', this.get('routeID'));\n  }\n});\nvar SeasonalPrice = bookshelf.Model.extend({\n  tableName   : 'seasonal_price' // routeID, boatID are existing in this table\n});\n// then I use\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nboatHasRoute.fetch({withRelated: ['boat', 'boat.bshbhr', 'boat.bshbhr.seasonalPrices']}).then(...);\n```\n. sorry for the late reply and thank you for your help! Here are my models\n``` javascript\nvar Boat = bookshelf.Model.extend({\n  tableName   : 'boat',\n  idAttribute : 'boatID',\n  // seasonal prices will be related with bshbhr\n  bshbhr: function() {\n    return this.hasMany(BookingSystemsHasBoatHasRoute, 'boatID');\n  }\n});\nvar BoatHasRoute = bookshelf.Model.extend({\n  tableName   : 'boat_has_route',\n  idAttribute : 'dwh_nid', // boatID, routeID also exist in this table\n  boat: function() {\n    return this.belongsTo(Boat, 'boatID');\n  }\n});\nvar BookingSystemHasBoatHasRoute = bookshelf.Model.extend({\n  tableName   : 'boat_has_route_for_bs',\n  idAttribute: 'boatID', // should be ['boatID', 'routeID']\n  seasonalPrices: function() {\n    return this.hasMany(SeasonalPrices, 'boatID').query('where', 'routeID', '=', this.get('routeID'));\n  }\n});\nvar SeasonalPrice = bookshelf.Model.extend({\n  tableName   : 'seasonal_price' // routeID, boatID are existing in this table\n});\n// then I use\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nboatHasRoute.fetch({withRelated: ['boat', 'boat.bshbhr', 'boat.bshbhr.seasonalPrices']}).then(...);\n``\n. thank you Johannes. The incremental loading works fine! But then I have a question that how can I correctly attach those loaded relations back to original instance ofBoatHasRoute?\n. thank you Johannes. The incremental loading works fine! But then I have a question that how can I correctly attach those loaded relations back to original instance ofBoatHasRoute`?\n. @johanneslumpe thanks for answering my further question. But I would like to archieve something like this\njavascript\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nreturn boatHasRoute.fetch({require: true, withRelated: ['boat', 'boat.bshbhr']})\n.then(function (res) {\n  return res.related('boat')\n  .related('bshbhr')\n  // I would like to load seasonal prices for all bshbhr\n  .each(function(item) {\n    item.load('seasonalPrices'); // here I can not call .then\n  });\n})\n.then(function(res) {\n  var obj = res.toJSON(); // I expect the res with all relations correctly loaded\n  // do other logic on obj ...\n});\nand I'm stucked again...\n. @johanneslumpe thanks for answering my further question. But I would like to archieve something like this\njavascript\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nreturn boatHasRoute.fetch({require: true, withRelated: ['boat', 'boat.bshbhr']})\n.then(function (res) {\n  return res.related('boat')\n  .related('bshbhr')\n  // I would like to load seasonal prices for all bshbhr\n  .each(function(item) {\n    item.load('seasonalPrices'); // here I can not call .then\n  });\n})\n.then(function(res) {\n  var obj = res.toJSON(); // I expect the res with all relations correctly loaded\n  // do other logic on obj ...\n});\nand I'm stucked again...\n. I figured out that I could use something like\njavascript\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nreturn boatHasRoute.fetch({require: true, withRelated: ['boat', 'boat.bshbhr']})\n.then(function (res) {\n  return res.related('boat')\n  .related('bshbhr')\n  .invokeThen('load', 'seasonalPrices').then(function() {\n    return res;\n  });\n})\n.then(function(res) {\n  var obj = res.toJSON(); // I expect the res with all relations correctly loaded\n  // do other logic on obj ...\n});\nI hope this would be the right way to do it. Please correct me if I'm wrong (seems to be very likely...)\n. I figured out that I could use something like\njavascript\nvar boatHasRoute = new BoatHasRoute({dwh_nid: 1});\nreturn boatHasRoute.fetch({require: true, withRelated: ['boat', 'boat.bshbhr']})\n.then(function (res) {\n  return res.related('boat')\n  .related('bshbhr')\n  .invokeThen('load', 'seasonalPrices').then(function() {\n    return res;\n  });\n})\n.then(function(res) {\n  var obj = res.toJSON(); // I expect the res with all relations correctly loaded\n  // do other logic on obj ...\n});\nI hope this would be the right way to do it. Please correct me if I'm wrong (seems to be very likely...)\n. @bendrucker thank you for the suggestion, I will be careful in the future\nthank you all for all the helps and suggestions. I think now my problem is solved. I never thought that an opensource project could have such a great community support. Thanks!\n. @bendrucker thank you for the suggestion, I will be careful in the future\nthank you all for all the helps and suggestions. I think now my problem is solved. I never thought that an opensource project could have such a great community support. Thanks!\n. ",
    "visigoth": "i am running and hacking on Ghost: https://github.com/TryGhost/Ghost\nmy branch is one commit ahead of the tag 0.3.3 (in which i use Tag's posts accessor to obtain all the posts for a particular tag).\nthat method can be found here: https://github.com/TryGhost/Ghost/blob/master/core/server/models/tag.js#L34\n. link to correct branch: https://github.com/TryGhost/Ghost/blob/0.3.3/core/server/models/tag.js#L34\n. also of note is that Ghost 0.3.3 uses bookshelf 0.5.7\n. i see what you mean about the cyclic dependency.  Post declares belongsToMany(Tags) and Tag declares belongsToMany(Posts).  i tried quickly changing Post to hasMany, but i got the same error.  i started fresh and regenerated the db with this and still got the same error.\n. cool; that worked.  seems like a common problem; what's the real solution?\n. ",
    "mjhamm75": "Or assign a variable to the Users like\n   var users = new Users();\n    users.fetch().then(function(data) {\n        console.log(data);\n    ];\n. Or assign a variable to the Users like\n   var users = new Users();\n    users.fetch().then(function(data) {\n        console.log(data);\n    ];\n. I just realized it.  I was using the wrong kind of relation.  btw - I am writing up some documentation and tutorials to make peoples transition to Bookshelf easier.  I will submit a pull request in the next week or so.  I hope you will have time to give some feedback.\n. Everything is perfect.\n. I see that the api allows me to pass in the 'users_subservices', 'user_id', 'subservice_id', and then I get my response, but why isn't it mapping by itself?\n. I am not.  You can see that User has many Certifications'.  I thought be adding an array it would of been pushed into multiple rows in thecertificationstable.  What is the proper way to insert multiple values at a time?\n. Doesnt that also present a problem if on insert that it thinks it is updating.  \nievar userCert = new UsersCertifications({ user_id: req.params.id, certification_id: req.body.id });\n userCert.save();I am pulling both of those id's out of the request to insert, but BS will think that I am wanting to update an existing record.  \nHow would that be fixed?\n. Doesnt that also present a problem if on insert that it thinks it is updating.  \nievar userCert = new UsersCertifications({ user_id: req.params.id, certification_id: req.body.id });\n userCert.save();I am pulling both of those id's out of the request to insert, but BS will think that I am wanting to update an existing record.  \nHow would that be fixed?\n. Making theidAttributenull worked fine.  Thanks for the quick help.\n. Making theidAttribute` null worked fine.  Thanks for the quick help.\n. ",
    "grzegorzgolec": "I would be grateful if you could give me a code example how to do it. I want to catch duplicate entry on saving model\nnew Device({\"device_chash\": chash }).save().then(function(model){ ...\nWith simple try { ... } catch ( ...  around above statement it doesn't catch any errors.\n. I would be grateful if you could give me a code example how to do it. I want to catch duplicate entry on saving model\nnew Device({\"device_chash\": chash }).save().then(function(model){ ...\nWith simple try { ... } catch ( ...  around above statement it doesn't catch any errors.\n. Nice! thanx for your time :)\n. Nice! thanx for your time :)\n. Yes license_id is idAttribute in my model.\n. It is ok but is it possible to call it directly on Model ?\n. It is ok but is it possible to call it directly on Model ?\n. Thanks :)\n. Thanks :)\n. I want to cache result of model and collection queries. Could you give me a hint how to pass cached models to on result callback i think of something like this  model(...).fetch().then(function( CACHED_RESULT  ){.... }) \n. Thx I will try the first solution :)\n. ",
    "ktmud": "Thanks for the explanation and quick reply!\n. At the end of the day, for the specific password hashing task, I choosed to use bcrypt.hashSync API.\nFollowing your tips on issue #192 , I did separated passwords in another table. So there will be many async tasks no matter what. But I'm trying out koa and es6 generator functions recently, the yield magic saved a lot of headaches on Promises for me.\n``` javascript\nvar auth = require_('lib/auth')  // just a wrapper on bcrypt\nvar Passport = db.model({\n  tableName: 'passport',\n  idAttribute: 'user_id',\n  set: function(name, value) {\n    var args = Array.prototype.slice.call(arguments)\n    if (name == 'password') {\n      args[1] = auth.crypt(value)\n    } else if (name.password) {\n      name.password = auth.crypt(name.password)\n    }\n    return db.proto.set.apply(this, args)\n  },\n  comparePassword: function(passport) {\n    return auth.compare(passport, this.get('password'))\n  }\n})\nUser.prototype.passport = function() {\n  return this.hasOne(Passport)\n}\nUser.prototype.setPassword = function *(password) {\n  var pass = this.passport()\n  var fetched = yield pass.fetch()\n  if (fetched) {\n    return fetched.save({ password: password }, { patch: true })\n  } else {\n    pass.set('password', password)\n    return pass.save()\n  }\n}\n```\nAn example of model usage (filling up database with test data):\n``` js\nvar User = require_('models/user')\nfunction addUser(uid, screenname, password, level) {\n  level = (level === undefined) ? User.LEVEL.NORMAL : level\n  return function *() {\n    var user = yield User.upsert(uid, { name: screenname, level: level })\n    yield user.setPassword(password)\n    return user\n  }\n}\nexports.fillup = function *() {\n  // add super admin\n  var admin = yield addUser('super', 'Super Admin', 'super', User.LEVEL.SUPER)\nyield _.range(1, 10).map(function(i) {\n    return addUser('test' + i, 'Test ' + i, 'test')\n  })\n}\n```\nNo more callbacks and then catch... The code becomes much cleaner.\n. ",
    "mcmire": "Right, but I don't want to affect the query that's performed to fetch the relations, I want to affect the first query. In other words, I want to say this:\nSELECT * FROM activity_group WHERE ...\nthen loop through the activity groups, pull the performer_id's and do:\nSELECT * FROM roundtable_user WHERE id in (?)\nThen, loop through all of the roundtable users and assign them to the relevant activity groups.\n. Right, but I don't want to affect the query that's performed to fetch the relations, I want to affect the first query. In other words, I want to say this:\nSELECT * FROM activity_group WHERE ...\nthen loop through the activity groups, pull the performer_id's and do:\nSELECT * FROM roundtable_user WHERE id in (?)\nThen, loop through all of the roundtable users and assign them to the relevant activity groups.\n. Ok, cool. Yeah I don't want the WHERE ... IN on activity_group, but other than that, that's what I want.\nSo that begs the question... what does withRelated do, exactly?\n. Ok, cool. Yeah I don't want the WHERE ... IN on activity_group, but other than that, that's what I want.\nSo that begs the question... what does withRelated do, exactly?\n. @bendrucker I mean that instead of WHERE IN I just want a simple where. It actually doesn't matter what the where is though here (in fact I got it wrong in the original comment), the point is that I want to scope activity groups to particular conditions, and I want to ensure that the roundtable users that are tied to activity groups are preloaded so that I'm not doing a query for every activity group for the user.\nI know about the query method, but it doesn't seem that I can add related objects if I do that. In other words it seems to me that you can either use fetch + withRelated OR query, but not both. Right?\n. @bendrucker I mean that instead of WHERE IN I just want a simple where. It actually doesn't matter what the where is though here (in fact I got it wrong in the original comment), the point is that I want to scope activity groups to particular conditions, and I want to ensure that the roundtable users that are tied to activity groups are preloaded so that I'm not doing a query for every activity group for the user.\nI know about the query method, but it doesn't seem that I can add related objects if I do that. In other words it seems to me that you can either use fetch + withRelated OR query, but not both. Right?\n. @tgriesser Okay, thanks for that. For some reason I thought query returned an instance of Knex, but I see now it just modifies an internal instance. Perhaps it would be useful to extend the documentation on fetch to mention how you can use query to modify the query before it's fetched? (Also, Collection#fetch doesn't mention anything about withRelated like Model#fetch does.)\nI'll look into load, thanks.\n. @tgriesser Okay, thanks for that. For some reason I thought query returned an instance of Knex, but I see now it just modifies an internal instance. Perhaps it would be useful to extend the documentation on fetch to mention how you can use query to modify the query before it's fetched? (Also, Collection#fetch doesn't mention anything about withRelated like Model#fetch does.)\nI'll look into load, thanks.\n. Perfect, thank you!\n. ",
    "sgentile": "What if you wanted the 'withRelated' to not be a separate query executed, but instead be a join ?\nie. get the activity group with the performer where the performer name is 'steve' ?\n. I'm having a similiar situation, but to take this a step further:\n{ symbol: 'AAPL', id: 3, quantity: 5984774, fund_id: 1, fund: {} }\nI want to actually have the fund returned\nie.\nHolding.where({symbol: 'AAPL'}).query(function() {\n   this.where('holdings.fund_id', function() {\n     this.select('id').from('funds').where('symbol', 'TSTF');\n   })\n}).fetch({withRelated:'fund'}).then(...\n. I should add - here is my 'User' object:\njs\nmodule.exports = function (baseModel, bookshelf) {\n    return baseModel.extend({\n        tableName: 'users',\n        tenants: function(){\n            return this.belongsToMany('Tenant', 'tenants_users_roles', 'user_id', 'tenant_id');\n        },\n        roles: function(){\n            return this.belongsToMany(\"Role\", 'tenants_users_roles', 'user_id', 'role_id');\n        }\n    });\n};\n. I should add - here is my 'User' object:\njs\nmodule.exports = function (baseModel, bookshelf) {\n    return baseModel.extend({\n        tableName: 'users',\n        tenants: function(){\n            return this.belongsToMany('Tenant', 'tenants_users_roles', 'user_id', 'tenant_id');\n        },\n        roles: function(){\n            return this.belongsToMany(\"Role\", 'tenants_users_roles', 'user_id', 'role_id');\n        }\n    });\n};\n. Thanks - I had mistakenly thought it read from the migration - but it makes sense that it doesn't\nAppreciate the guidance! \n. I'm having a difficult time trying to implement count, I looked in the tests and see an example, but when I implement it I get errors.\nExamples is:\nI need to get the blog and the number of posts \nreturn new Blog({'id': id}).posts().count().where(...).fetch(...)\ngives error:  TypeError: Uncaught error: (intermediate value).where(...).fetch(...).posts is not a function\nin my model I have:\nposts: function () {\n                return this.hasMany(\"Post\", \"blogId\");\n            }\nAll works find when I do a withRelated - but I don't want to pull down all the posts, I just want a count ?\n. ",
    "Ishtiaque-Shaad": "Hello,\nhow can I write down a bookshelf query same as mysql's \"between ...... and\" query\nthanks\n. ",
    "danschumann": "Very happy to see such a responsive repository.\n. can't you make a unique index on certain columns?  that or solve the problem of trying to submit the same data twice.\n. Yea I don't see this as being a javascript problem per say, more of a mysql\none.  The ghost example seems to prevent calling add on the same user model\ninstance twice, but if there were 2 requests, 2 user models, and both\nfetches happened before both saves, the ghost example doesn't work.\nThe only pure javascript solution is to fetch for a user, add him, then\nfetch again to see if there are 2, and if so, delete one.  this way, it\ndoesn't matter which one wins, the second to receive the final fetch loses.\n  This isn't as good as mysql solutions because the database could go down\nbefore the delete, however unlikely.  As well as the performance overhead.\nOn Wed, Feb 19, 2014 at 9:05 PM, Ben Drucker notifications@github.comwrote:\n\nClosed #225 https://github.com/tgriesser/bookshelf/issues/225.\n\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/225\n.\n. Now it's ignoring admin_id even when fetching directly...\n\nconsole.log(req.locals.admin.id);\nUsers.forge().fetch({where: {admin_id: req.locals.admin.id}, withRelated: ['messages']})\noutputs\n1\n{ sql: 'select `users`.* from `users`',  bindings: [],  __cid: '__cid1' }\n. The syntax might have been wrong on the second one..\nUsers.forge().query({where: {admin_id: req.locals.admin.id}}).fetch({withRelated: ['messages']})\nworks\n. They're all 1, attributes.id, get('id'), in both spots.  The model has already been fetched so the faq shouldn't apply.\nHowever... the typeof is number....\n. By the way, why can't we put a where in a fetch?\n. here's what loads the admin\n```\nvar\n  when  = require('when'),\n  Admin = require('../models/admin').Admin;\n// Loads admin as well\nmodule.exports = function(req, res, next) {\nconsole.log(\"ENSURE ADMIN\".red);\nwhen().then(function() {\n    if (req.session.admin_id)\n      return Admin.forge({id: req.session.admin_id}).fetch();\n  })\n  .then(function(admin) {\n    // They either didn't have session.admin_id, or they did and for some reason its deleted\n    if (!admin)\n      return Admin.forge().save();\n    else\n      return admin;\n  })\n  .then(function(admin){\n    req.locals.admin = admin;\n    req.session.admin_id = admin.id;\n    next();\n  });\n};\n```\nits not doing much fancy stuff, in most cases it just fetches\n. Yea i guess you could do that, as long as you checked to see if the last argument was an options object.  It'd be cheaper than looping and you'd still have the options argument if necessary\n. ",
    "katherine-barn2door": "Could some of this discussion be added to the docs? \nI've read them several times and it seemed like this was not possible (to delete more than one row in a single statement). It also seemed implied that destroy will always do one row at a time, but it would be nice to call that out: if you want to \"DELETE WHERE\" for multiple rows, don't use destroy.\n. I've also been wondering, is it possible to do a join when deleting?\nFor example, delete all the offers for a seller where the address was Ohio (or a subselect; either syntax but it's the same idea):\nDELETE FROM offers USING states\n  WHERE seller_id = 61\n    AND state_id = states.id \n    AND states.name = 'Ohio';\n. ",
    "albertkim": "I feel that this is a pretty basic orm feature that Bookshelf is missing. DELETE FROM WHERE queries should be fairly common on tables dealing with data such a tokens, which are fine to blow away.\n. I'm trying to implement transactions and avoid passing the database context object down every single service level module that interacts with it. I thought CLS would be the best method, but I too am having trouble with the context persisting through the bookshelf.transaction method.\n. ",
    "Znarkus": "model.query().whereIn('id', [1, 2, 3]).del().then(... doesn't seem to work anymore. model.query(qb => { qb.whereIn.. }).destroy() works fine though.\n. model.query().whereIn('id', [1, 2, 3]).del().then(... doesn't seem to work anymore. model.query(qb => { qb.whereIn.. }).destroy() works fine though.\n. Sorry I was too quick, got confused by the error signature.\n. We have no trouble inserting data via Bookshelf to a JSONB column using:\n```\nconst data = { some: 'data', number: 5 }\nmodeInstance.save({\n  our_jsonb_column: data\n}, { patch: true })\n```\nWhat happens if you don't manually serialize the data and let Bookshelf handle it?\n. I think this should be reported to bookshelf-page instead.\n. Ok! So according to your stacktrace this line is faulting:\nqb.countDistinct.apply(qb, [tableName + '.' + idAttribute]);\nDoes it work if you remove the query(function (qb) {}) part of your code? Please try to do some more debugging on your end and/or provide more information.\n. @vellotis Only transacting. \nUsing attach and passing an object is something we've used successfully before.\n. No, I circumvented the problem by creating via the pivot model directly.\n. Yes that would be an alternative solution, but pretty verbose/complex. Thank you though!\nEdit: Actually went with this solution, but a simplified version with hardcoded table name. Also bookshelf defaults to select files.*\n. @absolux Thank you, but neither \"status.id\" or \"process_statuses.id\" worked:\n```\nknex:query { bindings: [ '1', '2', '3', '4' ], sql: \n'select \"process_statuses\".*, \"process_groups_statuses\".\"id\" as \"_pivot_id\", \"process_groups_statuses\".\"group_id\" as \"_pivot_group_id\", \"process_groups_statuses\".\"process_statuses\".\"id\" as \"_pivot_process_statuses.id\" \nfrom \"process_statuses\" \ninner join \"process_groups_statuses\" \non \"process_groups_statuses\".\"process_statuses\".\"id\" = \"process_statuses\".\"id\" \nwhere \"process_groups_statuses\".\"group_id\" in (?, ?, ?, ?)' } +18ms\nerror: invalid reference to FROM-clause entry for table \"process_statuses\"\n```\n. @absolux Thank you, but neither \"status.id\" or \"process_statuses.id\" worked:\n```\nknex:query { bindings: [ '1', '2', '3', '4' ], sql: \n'select \"process_statuses\".*, \"process_groups_statuses\".\"id\" as \"_pivot_id\", \"process_groups_statuses\".\"group_id\" as \"_pivot_group_id\", \"process_groups_statuses\".\"process_statuses\".\"id\" as \"_pivot_process_statuses.id\" \nfrom \"process_statuses\" \ninner join \"process_groups_statuses\" \non \"process_groups_statuses\".\"process_statuses\".\"id\" = \"process_statuses\".\"id\" \nwhere \"process_groups_statuses\".\"group_id\" in (?, ?, ?, ?)' } +18ms\nerror: invalid reference to FROM-clause entry for table \"process_statuses\"\n``\n. Removingthroughworked. Not sure whythrough` doesn't work here.\nstatuses: function () {\n    return this\n      .belongsToMany('ProcessStatus', 'process_groups_statuses', 'group_id', 'status_id')\n  }\n. Removing through worked. Not sure why through doesn't work here.\nstatuses: function () {\n    return this\n      .belongsToMany('ProcessStatus', 'process_groups_statuses', 'group_id', 'status_id')\n  }\n. Nevermind, it didn't work. Or rather; it works if I run it by ProcessGroup.fetchAll({ withRelated: 'statuses' }), but not like this:\nreturn ProcessGroup\n    .forge()\n    .statuses()\n    .query({ where: { 'process_groups_statuses.group_id': groupId } })\n    .fetch(opts)\nGetting:\nError: Undefined binding(s) detected when compiling SELECT query: \nselect \"process_statuses\".*, \"process_groups_statuses\".\"group_id\" as \"_pivot_group_id\", \"process_groups_statuses\".\"status_id\" as \"_pivot_status_id\" \nfrom \"process_statuses\" \ninner join \"process_groups_statuses\" \non \"process_groups_statuses\".\"status_id\" = \"process_statuses\".\"id\" \nwhere \"process_groups_statuses\".\"group_id\" = ? and (\"process_statuses\".\"deleted_at\" is null or \"process_statuses\".\"restored_at\" is not null) and \"process_groups_statuses\".\"group_id\" = ?\n. Nevermind, it didn't work. Or rather; it works if I run it by ProcessGroup.fetchAll({ withRelated: 'statuses' }), but not like this:\nreturn ProcessGroup\n    .forge()\n    .statuses()\n    .query({ where: { 'process_groups_statuses.group_id': groupId } })\n    .fetch(opts)\nGetting:\nError: Undefined binding(s) detected when compiling SELECT query: \nselect \"process_statuses\".*, \"process_groups_statuses\".\"group_id\" as \"_pivot_group_id\", \"process_groups_statuses\".\"status_id\" as \"_pivot_status_id\" \nfrom \"process_statuses\" \ninner join \"process_groups_statuses\" \non \"process_groups_statuses\".\"status_id\" = \"process_statuses\".\"id\" \nwhere \"process_groups_statuses\".\"group_id\" = ? and (\"process_statuses\".\"deleted_at\" is null or \"process_statuses\".\"restored_at\" is not null) and \"process_groups_statuses\".\"group_id\" = ?\n. Thanks, that fixed it.\n. Thanks, that fixed it.\n. You are right, but I think it was overridden before? As pluck() is now.\n. Thank you for investigating, I was probably misremembering. \n. ",
    "p-baleine": "The outputed SQL statements of my example are as follows:\nbash\nselect \"users\".* from \"users\"\nbash\nselect\n  \"genres\".*,\n  \"posts\".\"id\" as \"_pivot_id\",\n  \"posts\".\"genre_id\" as \"_pivot_genre_id\"\nfrom\n  \"genres\" inner join \"posts\" on \"posts\".\"genre_id\" = \"genres\".\"id\"\n   inner join \"users\" on \"posts\".\"id\" = \"users\".\"post_id\"\nwhere\n  \"users\".\"id\" in (?)\nThe key of joining seems to be right. \nThe issue is in the key at the time of creating the result of the two above-mentioned SQL.\nI sent PR of correction to this. \n. The outputed SQL statements of my example are as follows:\nbash\nselect \"users\".* from \"users\"\nbash\nselect\n  \"genres\".*,\n  \"posts\".\"id\" as \"_pivot_id\",\n  \"posts\".\"genre_id\" as \"_pivot_genre_id\"\nfrom\n  \"genres\" inner join \"posts\" on \"posts\".\"genre_id\" = \"genres\".\"id\"\n   inner join \"users\" on \"posts\".\"id\" = \"users\".\"post_id\"\nwhere\n  \"users\".\"id\" in (?)\nThe key of joining seems to be right. \nThe issue is in the key at the time of creating the result of the two above-mentioned SQL.\nI sent PR of correction to this. \n. ",
    "leore": "@bendrucker We are actually porting over our entire API to hapi.js and bookshelf.js\nStill running into a problem here is updated code:\n``` coffee\ndb = require('../db.coffee')\nProxy = db.Model.extend(\n  tableName: \"proxies\"\n  hasTimestamps: [\"date_created\", \"date_modified\"]\n  constructor: () ->\n    @on \"saving\", (model, attrs, options) ->\n      model.set model.idAttribute, \"prefix_\"  if model.isNew()\n)\nmodule.exports = Proxy\n```\nthen calling\ncoffee\nnew Proxy().save().then (model) ->\n    reply('success')\nJust trying to get it so it inserts those ids into the db, I have everything else working\n. @bendrucker We are actually porting over our entire API to hapi.js and bookshelf.js\nStill running into a problem here is updated code:\n``` coffee\ndb = require('../db.coffee')\nProxy = db.Model.extend(\n  tableName: \"proxies\"\n  hasTimestamps: [\"date_created\", \"date_modified\"]\n  constructor: () ->\n    @on \"saving\", (model, attrs, options) ->\n      model.set model.idAttribute, \"prefix_\"  if model.isNew()\n)\nmodule.exports = Proxy\n```\nthen calling\ncoffee\nnew Proxy().save().then (model) ->\n    reply('success')\nJust trying to get it so it inserts those ids into the db, I have everything else working\n. @bendrucker hangout would be great. Im leore.avidar@gmail.com\n. @bendrucker hangout would be great. Im leore.avidar@gmail.com\n. @johanneslumpe not exactly.I'd like to abstract it one level below so I dont have to rewrite this toJSON method for each of my models.\nIdeally it would look something like this:\ncoffeescript\ndb.Model.prototype.toJSON = () ->\n@attributes[\"object\"] = model.type \n@attributes\nI somehow would need access to type. Which I dont have\n. @johanneslumpe not exactly.I'd like to abstract it one level below so I dont have to rewrite this toJSON method for each of my models.\nIdeally it would look something like this:\ncoffeescript\ndb.Model.prototype.toJSON = () ->\n@attributes[\"object\"] = model.type \n@attributes\nI somehow would need access to type. Which I dont have\n. Thanks for the help guys. This worked.\n. Thanks for the help guys. This worked.\n. yes the fact that they are not equal is throwing me off too.\nThe first is the value that I am saving.\nThe second value is the one I receive when I call fetch.\nI am using PG.\nI parse the value after I fetch from the DB.\n. the actual column is a date. Should we use another type?\n. the column was data and i know switched it to timestamptz and it worked\n. ",
    "ericchaves": "Hey guys, my 2cents on the custom message subject. In my error classes I use a naming pattern  of Prefix+<ErrorCategory>+Error like BsfEmptyResponseError.\nAll errors inherits from a common parent and I also accept an options as second argument with extended properties and some variables that control how the error should be created (for example, if it should capture the stack or not).\nThe code below illustrates it:\n``` js\nvar util = require('util');\n// To create new error categories just add it's name to the array\nvar errors = ['Custom', 'Authentication','Encryption'];\nfunction BshError(message, options) {};\nutil.inherits(BshError, Error);\nmodule.exports['BshError'] = BshError;\nerrors.forEach(function (base){\n  var name = 'Bsh' + base + 'Error';\n  module.exports[name] = function(message, options){\n      var options = options || {};\n      var _stackTraceLimit = Error.stackTraceLimit;\n  if (options.stackTraceLimit){\n    Error.stackTraceLimit = options.stackTraceLimit;\n    Error.captureStackTrace(this, arguments.callee);\n  }\n\n  Error.call(this);\n  this.name = this.constructor.name;\n  this.message = message\n  Object.keys(options).forEach(function(key){this[key] = options[key]}.bind(this));\n  Error.stackTraceLimit = _stackTraceLimit; // restore stackTraceLimit to not affect other exceptions\n\n}\n  util.inherits(module.exports[name], BshError);\n});\n```\n. Sure! This code is from a user model. Notice the part after the \"debugger;\" instruction where I have an HSM (which is not really an HSM ;P ) module whose methods are all promises.\nWhen I do new User(user_data).save()\n``` js\non_saving: function(model, attrs, options){\n    var self = this;\n    // change Gender\n    if (self.attributes.gender && self.attributes.gender == 'male')\n        self.attributes.gender = 'M';\n    else if (self.attributes.gender && self.attributes.gender == 'female')\n        self.attributes.gender = 'F';\n// serialize extra attributes into json field\nvar extras = self.omit(self.permitted_attributes);\nself.attributes = self.pick(self.permitted_attributes);\n\nif (!_.isEmpty(extras))\n  self.attributes.json = JSON.stringify(extras);\ndebugger;\nif (self.attributes.document && !HSM.is_encrypted(self.attributes.document)){\n  HSM.hash(self.attributes.document)\n  .then(function(hashed){\n    self.attributes.document_hash = hashed;\n    HSM.encrypt(self.attributes.document)\n      .then(function(cipher){\n        self.attributes.document = cipher;\n      });\n  });\n}\n\n},\n```\nI consume the user model on a controller class like below (forgive the ugly code, I haven't learn how to save a model with it's relations on a single call yet.)\n``` js\nuser = Hoek.applyToDefaults(about_me, user);\n      Bookshelf.transaction(function(t) {\n        new User(user)\n          .save(null, {transacting: t})\n          .then(function(usr){\n            debugger;\n            user = usr.toJSON();\n            delete user.json\n            credential.user_id = user.id;\n            new Credential(credential)\n              .save(null, {transacting: t})\n              .then(function(cred){\n                User.generate_otp(user.id)\n                .then(function(otp){\n                  user.otp = otp;\n                  t.commit(user);\n                }, t.rollback);\n              }, t.rollback);\n      },t.rollback)\n\n  }).then(function(user){\n    reply(user).code(201).header('Location', '/users/' + user.id);\n  },function(err){\n    if (/^ER_DUP_ENTRY: Duplicate entry/.test(err.message))\n      reply(Hapi.error.conflict(err.clientError.message));\n    else\n      reply(Hapi.error.badRequest(err.message));\n  });\n\n```\nwhen I inspect the return from save (user = usr.toJSON()) the attributes were encrypted by the HSM module, however when I check the database by hand they are not, which I assume is a result of the saving event finishing it's work and allowing the model to persist the data before the promises on the event returns. later on the promises finished and the attributes in memory are updated. \nCould this be the case?\n. update: I just confirmed that by moving from promises to sync version of HSM's methods it all worked as expected. Should the events have a callback, maybe?\njs\nif (self.attributes.document && !HSM.is_encrypted(self.attributes.document)){\n       self.attributes.document_hash = HSM.hashSync(self.attributes.document);\n       self.attributes.document = HSM.encryptSync(self.attributes.document);\n}\n. Hi @bendrucker  and @tgriesser, thanks both  for the great advices. Since I'm starting with the Promises world I admit I'm still struggling with it a bit and your tips were a great help.\n@tgriesser is there a way in Bookshelf to create a new model instance with related data (similar to the way we do fetch them) ?\n. @bendrucker I was looking for something this:\n``` js\nUser = Bookshelf.Model.extend({\n  tableName: 'users',\n  credentials: function(){\n      return this.hasMany(Credential)\n  }\n})\nvar Credential = Bookshelf.Model.extend({\n  tableName: 'credentials',\n  user: function(){\n    return this.belongsTo(User)\n  }\n});\nUser.forge({\n  username: 'Eric',\n  credentials: [{\n      token: 'my_token',\n      expires_at: '2014-12-31'\n    }]\n  }).save()\n  .then(function(user){\n    // a new user would be inserted and a new credential be created, associated to this user.\n    // a failure when creating either would rollback the entire insert.\n    console.log(user.toJSON())\n    /\n      {\n        id: 1,\n        username: 'Eric',\n        credentials: [{\n          id: 1,\n          user_id: 1,\n          token: 'my_token',\n          expires_at: '2014-12-31'\n        }]\n      }\n    /\n  })\n```\nOnce again thanks for all the inputs and help.\n. I think I finally got it right. It took me some time to figure out how Bookshelf.transaction works. At first it confuses me because the Bookshelf.transaction(handler(t)) didn't look like a promise (it was more like a callback) but when I figured that it is a promise and t.commit and t.rollback they're resolve/reject handlers it all come together. \nIn the end my final code become like this:\njs\nProvider.validate_token(credential)\n  .then(function(data){\n    return Hoek.applyToDefaults(data, payload);\n  }).then(function(user){\n    var _user = null;\n    return Bookshelf.transaction(function(t){\n      new User(user).save(null,{ transacting: t})\n      .then(function(new_user){\n        _user = new_user.toJSON();\n        delete _user.json;\n        credential.user_id = _user.id;\n        return new Credential(credential).save(null, {transacting: t})\n      }).then(function(cred){\n        return User.generate_otp(cred.toJSON().user_id)\n      }).then(function(otp){\n        _user.otp = otp;\n        t.commit(_user);\n      }).catch(t.rollback);\n    });\n  }).then(function(user){\n    reply(user).code(201).header('Location', '/users/' + user.id);\n  }).catch(function(err){\n      if (/^ER_DUP_ENTRY: Duplicate entry/.test(err.message))\n        reply(Hapi.error.conflict(err.clientError.message));\n      else\n        reply(Hapi.error.badRequest(err.message));\n  });\nwhich despite it's much, much more cleaner and spot-on to the \"logical flow\" (first create user, then create a credential, then create an OTP, and then reply. Anything different is an error, so rollback when needed and reply with an error.\nCongratulations to you all for the great work done in both Bookshelf and Knex, and once again thanks for the help and lectures.\n. @tgriesser I don't think the test is the problem (I was watching those values while debugging) but I tried your suggestion anyway and still having the issue. \nI did found thou that this error only happens when I save the model with {patch:true} options. Changing it to false made it work as expected.\nCredential({id: cid}).save({password: data.password},{patch: false});\nThis however confuses me about how save/upadate is done. What is the difference between  new Credential({id: cid}).save({password: data.password},{patch: false}); and new Credential({id: cid}).save({password: data.password},{patch: true});? \nI use this type of code a lot to update only certain fields whose id is known (instead of fetching then updating) and also use the saving event to handle internal fields (password, soft deletion, auditing tracks). Am I doing it wrong?\nRegarding the error specifically, it seems to me that the query is being populate prior to the saving event. The error message not only is trying to update the password field, but it also referencing the source (unencrypted) value and does not update the token field (which is set before the saving event is triggered.\nI'm pasting the debugger error here, may it give you guys some hint.\nSelf is the model and this is it's state after I executed my on_saving but before exiting the handle (ie. model was not yet persisted).\n```\n\nself\n{ attributes: \n   { token: '$2a$10$T4nD2CZO8oEO/A.OJxIxAeLM3OeBdmJ1fhudEkuzfFHPTm/xgJBXa',\n     id: 1,\n     updated_at: Fri Apr 18 2014 01:33:36 GMT-0300 (BRT) },\n  _previousAttributes: {},\n  changed: \n   { token: '$2a$10$T4nD2CZO8oEO/A.OJxIxAeLM3OeBdmJ1fhudEkuzfFHPTm/xgJBXa',\n     id: 1,\n     updated_at: Fri Apr 18 2014 01:33:36 GMT-0300 (BRT) },\n  relations: {},\n  cid: 'c7',\n  id: 1,\n  _events: { saving: [ [Object] ] },\n  _knex: null }\n```\n\nand this is the error raised once the actually saving takes place ('88162595c58939c4ae0b35f39892e6e7' is the unencrypted password).\ndebug> c\n< { [Error: ER_BAD_FIELD_ERROR: Unknown column 'password' in 'field list', sql: update `credentials` set `password` = ?, `updated_at` = ? where `id` = ?, bindings: 88162595c58939c4ae0b35f39892e6e7,Fri Apr 18 2014 01:33:36 GMT-0300 (BRT),1]\n<   sql: 'update `credentials` set `password` = ?, `updated_at` = ? where `id` = ?',\n<   bindings: \n<    [ '88162595c58939c4ae0b35f39892e6e7',\n<      Fri Apr 18 2014 01:33:36 GMT-0300 (BRT),\n<      1 ],\n<   clientError: \n<    { name: 'RejectionError',\n<      message: 'ER_BAD_FIELD_ERROR: Unknown column \\'password\\' in \\'field list\\'',\n<      cause: \n<       { [Error: ER_BAD_FIELD_ERROR: Unknown column 'password' in 'field list']\n<         code: 'ER_BAD_FIELD_ERROR',\n<         errno: 1054,\n<         sqlState: '42S22',\n<         index: 0 },\n<      stack: 'Error: ER_BAD_FIELD_ERROR: Unknown column \\'password\\' in \\'field list\\'\\n    at Query.Sequence._packetToError (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/mysql/lib/protocol/sequences/Sequence.js:30:14)\\n    at Query.ErrorPacket (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/mysql/lib/protocol/sequences/Query.js:82:18)\\n    at Protocol._parsePacket (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/mysql/lib/protocol/Protocol.js:202:24)\\n    at Parser.write (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/mysql/lib/protocol/Parser.js:62:12)\\n    at Protocol.write (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/mysql/lib/protocol/Protocol.js:37:16)\\n    at Socket.Connection.connect (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/mysql/lib/Connection.js:72:28)\\n    at Socket.EventEmitter.emit (events.js:95:17)\\n    at Socket.<anonymous> (_stream_readable.js:746:14)\\n    at Socket.EventEmitter.emit (events.js:92:17)\\n    at emitReadable_ (_stream_readable.js:408:10)\\n    at emitReadable (_stream_readable.js:404:5)\\n    at readableAddChunk (_stream_readable.js:165:9)\\n    at Socket.Readable.push (_stream_readable.js:127:10)\\n    at TCP.onread (net.js:526:21)\\n    --------------------\\n    at Protocol._enqueue (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/mysql/lib/protocol/Protocol.js:110:48)\\n    at Connection.query (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/mysql/lib/Connection.js:165:25)\\n    at promisified (eval at makeNodePromisifiedEval (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/knex/node_modules/bluebird/js/main/promisify.js:195:12), <anonymous>:2:220)\\n    at exports.Client.ServerBase.extend.runQuery (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/knex/clients/server/mysql.js:40:61)\\n    at tryCatch1 (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/knex/node_modules/bluebird/js/main/util.js:63:19)\\n    at Promise$_callHandler [as _callHandler] (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/knex/node_modules/bluebird/js/main/promise.js:695:13)\\n    at Promise$_settlePromiseFromHandler [as _settlePromiseFromHandler] (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/knex/node_modules/bluebird/js/main/promise.js:711:18)\\n    at Promise$_settlePromiseAt [as _settlePromiseAt] (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/knex/node_modules/bluebird/js/main/promise.js:868:14)\\n    at Promise$_settlePromises [as _settlePromises] (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/knex/node_modules/bluebird/js/main/promise.js:1006:14)\\n    at Async$_consumeFunctionBuffer [as _consumeFunctionBuffer] (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/knex/node_modules/bluebird/js/main/async.js:74:12)\\n    at Async$consumeFunctionBuffer (/Volumes/Macintosh_HD/ericchaves/Projects/wifime/portal2/api/node_modules/knex/node_modules/bluebird/js/main/async.js:37:14)\\n    at process._tickDomainCallback (node.js:459:13)' } }\n. Ok, I think I got the point of patch now. If I had done Credential({id: cid, provider:'some_provider'}).save({password: data.password },{patch: true}); the provider attribute wouldn't be saved while with patch: false it would, right?\nIf you don't mind, allow me to ask why you see this handling on saving event as an anti-pattern?\nfinal note: I'm gradually \"promisifying\" all the code, it just take some time. ;)\n. ",
    "rattrayalex": "+1\n. ",
    "MajorBreakfast": "@tgriesser also maintains a validation library which because of it also being promise based works hand in hand with bookshelfjs\nHere's an example:\nhttp://runnable.com/UvPwh-56Bb5SAABL/validations-with-bookshelf-js-for-node-js-and-webserver\n. ",
    "HeinrichFilter": "Sorry about the failing tests, I'm still new to the whole process.\nI'll fix the tests and add them to the pull request.\nDoes the change make sense in principal though? It's just that when I got the error message I tried to add {insert: true} as an option and that didn't work. So I thought I'd update the error message to reflect what worked for me (and is in the documentation)\n. ",
    "chris-rock": "Thanks Ben. Okay. So if I got you right, you would use Bookshelf.knex and then directly create the instance via knex.\n. Thanks Ben. Okay. So if I got you right, you would use Bookshelf.knex and then directly create the instance via knex.\n. cool. thats sound good. seperation of concern is always great.\n. cool. thats sound good. seperation of concern is always great.\n. ",
    "JoshGlazebrook": "I also came accross this question coming from Sequelize. I'd say a good example of a way to do this would be to look at how Ghost generates its schema. \nhttps://github.com/TryGhost/Ghost/blob/master/core/server/data/schema.js\nhttps://github.com/TryGhost/Ghost/blob/master/core/server/data/migration/index.js#L75\nYou could probably even take the same approach, but mold it to where you could define the scheme once, and use it both in generating the tables and for validations with checkit or something else.\n. I also came accross this question coming from Sequelize. I'd say a good example of a way to do this would be to look at how Ghost generates its schema. \nhttps://github.com/TryGhost/Ghost/blob/master/core/server/data/schema.js\nhttps://github.com/TryGhost/Ghost/blob/master/core/server/data/migration/index.js#L75\nYou could probably even take the same approach, but mold it to where you could define the scheme once, and use it both in generating the tables and for validations with checkit or something else.\n. ",
    "Keltpkr": "Hello,\nAnd is there an easy way to automatickly generate models and collections modules from database setted up with relations ?\n. ",
    "ezmiller": "I think the fact that there isn't auto generation of tables should be better identified in the documentation. I spent a lot of time googling before I found this discussion.\n. Yes how would you do a delete all with Bookshelf with the current api?\n. Found one way of doing it in the above #1144, e.g.:\nUser.where('id', '!=', 0).destroy()\n. ",
    "geanjunior": "Hi,\nWith dotnet, the Entity Framework has a great feature to work with Code First approach.\nThe cli tool of framework can create migration file based on changes in model classes.\nI know that is most easy to make it with a strong typed language, but has something like this in bookshelf?. ",
    "sessa": "Looks like it failed the travis build -- I will take a deeper look tomorrow.\n. Will definitely add some tests next week. \n. ",
    "fritx": "yeah, I met the same problem as yours..\nI rewrited fetch method on collection to forcely fetch each model after collection fetches:\njs\nfetch: function(options) {\n  options = options || {};\n  var forModel = options['each'];\n  return db.Collection.__super__fetch.call(this, options)\n    .then(function(collection) {\n      return collection.invokeThen('fetch', forModel)\n        .then(function () {\n            return collection;\n        });\n    });\n}\n. yeah, I met the same problem as yours..\nI rewrited fetch method on collection to forcely fetch each model after collection fetches:\njs\nfetch: function(options) {\n  options = options || {};\n  var forModel = options['each'];\n  return db.Collection.__super__fetch.call(this, options)\n    .then(function(collection) {\n      return collection.invokeThen('fetch', forModel)\n        .then(function () {\n            return collection;\n        });\n    });\n}\n. yeah, thanks @bendrucker, you alarmed me..\n:[  I think we had written too much code mistakenly into the model.fetch! \n. yeah, thanks @bendrucker, you alarmed me..\n:[  I think we had written too much code mistakenly into the model.fetch! \n. Hey @bendrucker,\nIn my project, maybe for convinence, we have lots of things done in model.fetch,\nsuch as some calculating...\nI come up with an idea, to avoid unnecessary DB calls as you mentioned:\nCould I regard the model.fetch as \"[sync] + calculate\", and write the code like:\njs\n// db.Model\nfetch: function(options){\n  if (options['free']) return Promise.resolve(this);\n  return db.Model.__super__.fetch.call(this, options);\n}\n// db.Collection\nfetch: function(options){\n  options = options || {};\n  var forModel = options['each'];\n  forModel['free'] = true;\n  return db.Collection.__super__.fetch.call(this, options)\n    .then(function(collection) {\n      return collection.invokeThen('fetch', forModel)\n        .then(function () {\n            return collection;\n        });\n    });\n}\n. Hey @bendrucker,\nIn my project, maybe for convinence, we have lots of things done in model.fetch,\nsuch as some calculating...\nI come up with an idea, to avoid unnecessary DB calls as you mentioned:\nCould I regard the model.fetch as \"[sync] + calculate\", and write the code like:\njs\n// db.Model\nfetch: function(options){\n  if (options['free']) return Promise.resolve(this);\n  return db.Model.__super__.fetch.call(this, options);\n}\n// db.Collection\nfetch: function(options){\n  options = options || {};\n  var forModel = options['each'];\n  forModel['free'] = true;\n  return db.Collection.__super__.fetch.call(this, options)\n    .then(function(collection) {\n      return collection.invokeThen('fetch', forModel)\n        .then(function () {\n            return collection;\n        });\n    });\n}\n. > It's not a good idea to have Model.prototype.fetch sometimes fetch the model and other times just run some side-effects. It's brittle and will potentially create headaches for you with future API changes in Bookshelf.\nIt makes sense. Thanks!\nI find I had taken out a how-bad-it-is sample :[ @bogus34 \nAnd not until @bendrucker shared his code, I have found that Promise is so great! :)\n. > It's not a good idea to have Model.prototype.fetch sometimes fetch the model and other times just run some side-effects. It's brittle and will potentially create headaches for you with future API changes in Bookshelf.\nIt makes sense. Thanks!\nI find I had taken out a how-bad-it-is sample :[ @bogus34 \nAnd not until @bendrucker shared his code, I have found that Promise is so great! :)\n. Oops, sorry, @bendrucker , I found my issue was brain-leaking, this in fetch of a model/collection seems to be the instance itself, isn't it?\nIn fact, my code was:\nfetch: function () {\n        return syCollection.__super__.fetch.apply(this, arguments)\n            .then(function (collection) {\n                return collection.invokeThen('fetch')\n                    .then(function(){\n                        return collection;\n                    });\n            });\n    }\n( from: https://github.com/node-fun/siyuan/blob/master/models/base.js#L226 )\nAnd I was afraid I had applied the super fetch mistakenly...\n. Oops, sorry, @bendrucker , I found my issue was brain-leaking, this in fetch of a model/collection seems to be the instance itself, isn't it?\nIn fact, my code was:\nfetch: function () {\n        return syCollection.__super__.fetch.apply(this, arguments)\n            .then(function (collection) {\n                return collection.invokeThen('fetch')\n                    .then(function(){\n                        return collection;\n                    });\n            });\n    }\n( from: https://github.com/node-fun/siyuan/blob/master/models/base.js#L226 )\nAnd I was afraid I had applied the super fetch mistakenly...\n. Get it, thanks\nBut am I going to remove all those fetching/creating-like handlers, or remove the return statements inside only?\n. Get it, thanks\nBut am I going to remove all those fetching/creating-like handlers, or remove the return statements inside only?\n. @bendrucker Oh I know what you mean:\nIt doesn't have to resolve a value while it can still reject an error\nI rewrite those event listeners in sub classes, so I wanted to ensure something\nBut it is unnecessary\nThanks :)\n. @bendrucker Oh I know what you mean:\nIt doesn't have to resolve a value while it can still reject an error\nI rewrite those event listeners in sub classes, so I wanted to ensure something\nBut it is unnecessary\nThanks :)\n. @bendrucker, I override a fetching listener the way:\nfetch: function () {\n        return Event.__super__.fetch.apply(this, arguments)\n            .then(function (event) { ... });\n    }\n( From: https://github.com/node-fun/siyuan/blob/master/models/event.js#L18 )\nSo It seems I have to resolve/reject inside the handlers\nAm I using the event listeners blindly before inspecting the source code?\n. @bendrucker, I override a fetching listener the way:\nfetch: function () {\n        return Event.__super__.fetch.apply(this, arguments)\n            .then(function (event) { ... });\n    }\n( From: https://github.com/node-fun/siyuan/blob/master/models/event.js#L18 )\nSo It seems I have to resolve/reject inside the handlers\nAm I using the event listeners blindly before inspecting the source code?\n. Oh god... I was thinking the two are the same..\nThanks!\n. Oh god... I was thinking the two are the same..\nThanks!\n. ",
    "diorahman": "Is it possible to override the query builder at fetching? Tried it but it was failed. I tried to extend the https://github.com/lanetix/node-bookshelf-soft-delete to have checking when withRelated is specified.\n. @rhys-vdw  I guess it should be in memory\nhttps://github.com/lanetix/node-bookshelf-soft-delete/issues/18\n. ",
    "wbyoung": "Or just documentation would help as well. :)\n. @bendrucker looks good\u2026 thanks!\n. @tgriesser looking forward to seeing the work you're doing on this! :)\n. @tgriesser awesome, thanks. Did the docs get updated with this as well? If not, I'd be happy to add a little documentation while playing around with it (no guarantee on how quick that'll be).\n. @bendrucker thanks for the feedback. What you've said makes a lot of sense and I appreciate the detail you've given about the architecture of the project. I'll think a little about whether or not this is something that I'd want to take on. I like the idea of the flexibility that it provides, but it may not be worth the effort to implement.\nI'm still new to this tool, so I'll keep playing around with it. I may try tackling this some time down the road just to understand the project better. We'll see.\nYou can feel free to close this if you want for the time being. You have good architectural reasons for this not being worth considering at this time.\n. Oh, and here's some simple data to insert if it helps make things easier to test:\nsql\ninsert into people (name) values ('Sara'), ('Brittany'), ('John'), ('Sue');\ninsert into cars (model) values ('Golf'), ('Outback'), ('Civic'), ('F150');\ninsert into cars_drivers (car_id, person_id) values (1, 1), (1, 2), (2, 3), (3, 4), (4, 4);\n. Right, but a the Post-Author relationship is one-to-many. It's the one side of that the the belongsTo is concerned with, but it's not used exclusively in one-to-one relationships. I just find the wording in the documentation confusing.\n. Yeah, I guess I just read the phrases one-to-many and one-to-one as implying both sides. I'll add this to my todo list, do some research to see how other ORMs word things, and hopefully send in a pull request soon.\n. @johanneslumpe ok, good to know. I'll close this for the same reason as #343, then. It'd be nice to see, but it seems you guys have some big changes coming up. I'll continue to play around with things and perhaps I'll come back to these ideas later and ping you guys about how to make them work if you don't get to them first.\n. ",
    "nareshbhatia": "This issue should probably be closed since knex.destroy() has been implemented and documented.\n. Thanks @bendrucker. I understand the forein key issue, however I don't understand the multiple queries. Are you saying that the model only knows about the relationships - they are explicitly declared. However since the colums/properties are not declared, bookshelf does not know how to alias them - is this correct? (that's probably why sequelize explicitly declares all attributes) \n. Thanks @bendrucker. I understand the forein key issue, however I don't understand the multiple queries. Are you saying that the model only knows about the relationships - they are explicitly declared. However since the colums/properties are not declared, bookshelf does not know how to alias them - is this correct? (that's probably why sequelize explicitly declares all attributes) \n. Totally agree. I was wondering if you can have looked at http://mybatis.github.io/mybatis-3/ which is a simple data mapper in Java, as opposed to a full fledged ORM like Hibernate. It tries to keep things simple just like you are, and has been very successful in the Java world.\n. Totally agree. I was wondering if you can have looked at http://mybatis.github.io/mybatis-3/ which is a simple data mapper in Java, as opposed to a full fledged ORM like Hibernate. It tries to keep things simple just like you are, and has been very successful in the Java world.\n. Looking forward to it. Thanks for all this wonderful work!\n. Looking forward to it. Thanks for all this wonderful work!\n. That works! Thanks.\n. Both these solutions work for me! Thanks for the quick response.\n. Awesome! Great discussion. Sticking with check constraint.\n. Awesome! Great discussion. Sticking with check constraint.\n. Good one! Thanks for your help, @ricardograca.\n. @rhys-vdw I get the following runtime error:\nvar Org = bookshelf.model('User', bookshelf.model('BaseModel').extend({\n                                                              ^\nTypeError: Cannot read property 'extend' of undefined\nI suspect that extend is a method of Model (upperCase). It is not a method of model.\n. @rhys-vdw I get the following runtime error:\nvar Org = bookshelf.model('User', bookshelf.model('BaseModel').extend({\n                                                              ^\nTypeError: Cannot read property 'extend' of undefined\nI suspect that extend is a method of Model (upperCase). It is not a method of model.\n. Thanks. That fixes the error and everything works!\n. Thanks. That fixes the error and everything works!\n. ```\nvar resource = new Resource({\n    uid: uid,\n    type: 'org'\n});\nreturn resource.save()\n    .then(function(resource) {\n        var org = new Org({\n            uid: uid,\n            name: orgData.name,\n            resource: resource\n        });\n    return org.save();\n});\n\n.\nvar resource = new Resource({\n    uid: uid,\n    type: 'org'\n});\nreturn resource.save()\n    .then(function(resource) {\n        var org = new Org({\n            uid: uid,\n            name: orgData.name,\n            resource: resource\n        });\n    return org.save();\n});\n\n```\n. Thanks so much! That was definitely not obvious in the documentation.\n. Thanks so much! That was definitely not obvious in the documentation.\n. Ah, I see. But I cannot have any reference from Resource to Org. Resource is part of an independent reusable context and should not know anything about Orgs. \n. Ah, I see. But I cannot have any reference from Resource to Org. Resource is part of an independent reusable context and should not know anything about Orgs. \n. Well, I would like different kinds of domain entities to refer to Resources, not Orgs only. So while Orgs can refer to Resources, Resources do not necessarily refer to Orgs. Think of it as a look up table - I can look up a Country table from many different domain tables.\nMoreover the solution from @ricardograca is working perfectly fine for my use case. It keeps my Resource sub-system completely isolated and reusable.\nHope this clarifies. I don't think I am trying to do anything unreasonable.\n. Good catch! I replaced id with idAttribute. Now I am seeing the correct 3 queries being produced, but securities is still coming out empty. Here are the queries:\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [],\n  sql: 'select \"holdings\".* from \"holdings\"' }\n{ __cid: '__cid2',\n  method: 'select',\n  options: undefined,\n  bindings: [ 1, 2, 3, 4, 5, 6 ],\n  sql: 'select \"funds\".* from \"funds\" where \"funds\".\"id\" in ($1, $2, $3, $4, $5, $6)' }\n{ __cid: '__cid3',\n  method: 'select',\n  options: undefined,\n  bindings:\n   [ 1,\n     2,\n     3,\n     4,\n     ...\n     1087 ],\n  sql: 'select \"securities\".* from \"securities\" where \"securities\".\"symbol\" in (\n  $1, $2, $3, $4, ..., $1085, $1086, $1087)' }\n  [ { id: 1,\n    quantity: 331962,\n    fund_id: 1,\n    symbol: 'A',\n    fund: { id: 1, symbol: 'SPX', name: 'S&P 500', benchmark_id: null },\n    security: {} },\n    ...\n  ]\nAlso once we get the correct output, how can I constrain to only the country code that I need?\n. Not getting any errors! The output above is a straight copy-and-paste, obviously truncated in 2 places as shown.\n. I simplified the query to just this:\nfunction getHoldingsInCountry(countryCode) {\n    return new Holding({id: 1})\n        .fetch({\n            withRelated: ['security']\n        });\n}\nAnd I still get this:\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ 1, 1 ],\n  sql: 'select \"holdings\".* from \"holdings\" where \"holdings\".\"id\" = $1 limit $2' }\n{ __cid: '__cid2',\n  method: 'select',\n  options: undefined,\n  bindings: [ 1 ],\n  sql: 'select \"securities\".* from \"securities\" where \"securities\".\"symbol\" in ($1)' }\n{ id: 1, quantity: 331962, fund_id: 1, symbol: 'A', security: {} }\n. Unfortunately, that's not true. Securities table is a reference (lookup) table with symbol as its primary key. Other tables can have reference to it (using symbol as a foreign key), but the securities table itself cannot have back references to those tables. Here's the DDL for holdings and securities tables:\n```\nCREATE TABLE holdings (\n  id SERIAL PRIMARY KEY,\n  quantity DECIMAL(19, 4) NOT NULL\n);\nCREATE TABLE securities (\n  symbol VARCHAR(8),\n  name VARCHAR(64) NOT NULL,\n  price_last DECIMAL(19, 4) NOT NULL,\n  price_close_1d DECIMAL(19, 4) NOT NULL,\n  price_close_1yr DECIMAL(19, 4) NOT NULL,\n  return_1d DECIMAL(19, 4) NOT NULL,\n  return_1yr DECIMAL(19, 4) NOT NULL\n);\nALTER TABLE securities\n  ADD PRIMARY KEY (symbol);\nALTER TABLE holdings\n  ADD COLUMN fund_id INTEGER NOT NULL,\n  ADD COLUMN symbol VARCHAR(8) NOT NULL;\nALTER TABLE holdings\n  ADD CONSTRAINT holdings_fund_id_foreign FOREIGN KEY (fund_id)\n  REFERENCES funds (id);\nALTER TABLE holdings\n  ADD CONSTRAINT holdings_symbol_foreign FOREIGN KEY (symbol)\n  REFERENCES securities (symbol);\n``\n. That's it! You hit the nail on the head. My bad for not understanding the difference betweenhasOneandbelongsTo`. Now that I re-read the docs, it is clear. Also the diagrams on the rubyonrails site were very helpful.\nNow I can get all nested objects all the way to country:\nreturn new Holding()\n    .fetchAll({\n        withRelated: ['fund', 'security', 'security.country']\n    });\nFinal question: how do I constrain this to a specific country?\n. Thanks for the tip on simplifying the withRelated part.\n. Based on #202, I modified the query as follows:\nfunction getHoldingsInCountry(countryCode) {\n    return new Holding()\n        .fetchAll({\n            withRelated: ['fund', {'security' : function(qb) {\n                qb.where('country_code', countryCode);\n            }}]\n        });\n}\nThis is still not constraining the result to the specified country, but it is getting close. See debug output below:\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [],\n  sql: 'select \"holdings\".* from \"holdings\"' }\n{ __cid: '__cid2',\n  method: 'select',\n  options: undefined,\n  bindings: [ 1, 2, 3, 4, 5, 6 ],\n  sql: 'select \"funds\".* from \"funds\" where \"funds\".\"id\" in ($1, $2, $3, $4, $5, $6)' }\n{ __cid: '__cid3',\n  method: 'select',\n  options: undefined,\n  bindings:\n   [ 'SZ',\n     'A',\n     'AA',\n     'AAPL',\n     'ABBV',\n     ...\n     'SAPE',\n     'CASH' ],\n  sql: 'select \"securities\".* from \"securities\" where \"country_code\" = $1 and \"securities\".\"symbol\" in ($2, $3, ..., $505)' }\n[ { id: 1,\n    quantity: 331962,\n    fund_id: 1,\n    symbol: 'A',\n    fund: { id: 1, symbol: 'SPX', name: 'S&P 500', benchmark_id: null },\n    security: {} },\n  ...\n  { id: 955,\n    quantity: 44102,\n    fund_id: 2,\n    symbol: 'TYC',\n    fund: { id: 2, symbol: 'USE', name: 'US Equity', benchmark_id: 1 },\n    security:\n     { symbol: 'TYC',\n       name: 'Tyco Intl Ltd',\n       price_last: 44.72,\n       price_close_1d: 44.45,\n       price_close_1yr: 33.78,\n       return_1d: 0.6074,\n       return_1yr: 31.9026,\n       sector_code: 'ID',\n       country_code: 'SZ',\n       region_code: 'EU' } },\n  ...\n]\nNote that all holdings are listed, but security is populated for only those that are traded in the specified country. I think the issue is that the where clause specified in the query builder is being added to the where clause that is generated by default.\nsql: 'select \"securities\".* from \"securities\" where \"country_code\" = $1 and \"securities\".\"symbol\" in ($2, $3, ..., $505)' }\nSo not quite there, but getting close!\n. So it seems that I cannot constrain the holdings by country this way.\n. Quick update on this issue. I finally decided to use Knex to hand-craft the query as I needed and then wrote a very simple library to covert the resultset into JavaScript objects. The library is called JoinJS. People wrestling with these kinds of issues may find it useful.\n. ",
    "jordwest": "Ah, you are right - within Chrome I'm seeing the TypeError you described, although in node.js console.log with null context works fine.\nThe then(console.log) was really just for illustration. Actually, I'm not even seeing a TypeError - the issue I'm having is that neither the then nor the catch callbacks are ever called. No output and no errors are ever thrown - leaving the promise in a perpetual unresolved state.\n. Ah, you are right - within Chrome I'm seeing the TypeError you described, although in node.js console.log with null context works fine.\nThe then(console.log) was really just for illustration. Actually, I'm not even seeing a TypeError - the issue I'm having is that neither the then nor the catch callbacks are ever called. No output and no errors are ever thrown - leaving the promise in a perpetual unresolved state.\n. @bendrucker No SQL output is printed\n@tgriesser Yes, I'm using sqlite3 and putting the transaction in the fetch fixes the issue. Is it expected behaviour for the fetch to halt if the {transacting: t} is forgotten? I'll put together an integration test if that would help.\n. Ahah good catch. We're using sqlite3 for portability as there won't ever be more than one user at a time nor high query volume. I'll just have to be extra careful not to forget the {transacting: t}.\nThanks for looking into this.\n. Also see issues #24 and #130 \n. Also see issues #24 and #130 \n. Just had another go at solving this. The result is much simpler and less intrusive on existing code.\nThis now exposes a _newId variable on the model which is copied to the insert query on save if defined. This occurs after the 'saving' event in case the user wants to check isNew() during the save event.\nOne issue at the moment is that the id is set regardless of whether the model is successfully saved or not. Looking into how this could be fixed.\n. @sidazhang For the project I was working on, I ended up going with plain knex.js (rather than fighting with the backbone/bookshelf way) and this PR was sort of abandoned. If there is interest in merging it I'd be happy to have another go.\n. ",
    "ruedamanuel": "No, I shortened it for \"clarity\" but I was sloppy. Just made the edits in the original post.\n. Actually, the t.rollback wrapped in a function as you suggested fixed the issue\n\n, function(){\n     t.rollback(message);\n}\n\nPlease update bookshelfjs.org docs as it shows the call to t.rollback as a standalone function\n\n//From http://bookshelfjs.org/#Bookshelf-transaction\n.then(function(rows) {\n      t.commit([model.get('name'), rows.length]);\n    }, t.rollback);\n\nThanks for the quick response!\n. ",
    "cultofmetatron": "wow sounds like it,  looks like its time for a refactor tommorrow.  Thx for letting me know\n. I see what you mean. I fetch and then in the next promise chain, I can access the roles via related as a bookshelf collection.\nFor anyone else out there that runs into the same issue, here's the working code.\n``` javascript\nit('user should be able to create a role through roles', function(done) {\n    var user = db.models.User.forge({email: 'foobar@example.com', password: 'foobar' });\n    var role = db.models.Role.forge({name: 'administrator' });\n    Promise.all([user.save(), role.save()])\n    .spread(function(user, role) {\n      return Promise.all([user, user.roles().attach(role)]);\n    })\n    .spread(function(user) {\n      //var roles = user.roles();\n      return user.fetch({\n        withRelated: ['roles']\n      });\n    })\n    .then(function(user) {\n      console.log('user roles', user.related('roles').at(0).get('name'));\n      return user.roles();\n}).then(function(roles) {\n  done();\n});\n\n});\n```\nThanks, if you're ever in san francisco, come down to soma. drinks on us!\n. I see what you mean. I fetch and then in the next promise chain, I can access the roles via related as a bookshelf collection.\nFor anyone else out there that runs into the same issue, here's the working code.\n``` javascript\nit('user should be able to create a role through roles', function(done) {\n    var user = db.models.User.forge({email: 'foobar@example.com', password: 'foobar' });\n    var role = db.models.Role.forge({name: 'administrator' });\n    Promise.all([user.save(), role.save()])\n    .spread(function(user, role) {\n      return Promise.all([user, user.roles().attach(role)]);\n    })\n    .spread(function(user) {\n      //var roles = user.roles();\n      return user.fetch({\n        withRelated: ['roles']\n      });\n    })\n    .then(function(user) {\n      console.log('user roles', user.related('roles').at(0).get('name'));\n      return user.roles();\n}).then(function(roles) {\n  done();\n});\n\n});\n```\nThanks, if you're ever in san francisco, come down to soma. drinks on us!\n. also tried this \n``` javascript\n db.models.User.prototype.addDriverProfile = function(role, params) {\n    return db.models.DriverProfile.forge({\n      user_id : this.id\n    }).save()\n      .bind(this)\n      .then(function(driverProfile) {\n        return this.fetch({\n          withRelated: 'driverProfile'\n        });\n      })\n  };\n```\ndoesnt work either\n. also tried this \n``` javascript\n db.models.User.prototype.addDriverProfile = function(role, params) {\n    return db.models.DriverProfile.forge({\n      user_id : this.id\n    }).save()\n      .bind(this)\n      .then(function(driverProfile) {\n        return this.fetch({\n          withRelated: 'driverProfile'\n        });\n      })\n  };\n```\ndoesnt work either\n. there is a user_id in the table, striaight out of the migrations file\njavascript\nknex.schema.table('driverprofiles', function(t) {\n      t.integer('user_id')\n        .unsigned()\n        .references('id')\n        .inTable('users')\n        //.onDelete('CASCADE');\n        // .onUpdate(...) // optional\n      t.integer('company_id')\n        .unsigned()\n        .references('id')\n        .inTable('companies')\n        //.onDelete('CASCADE');\n    }),\nhere's what the latest version of that file itself looks like \n``` javascript\n  db.models.DriverProfile.prototype.user = function() {\n    return this.belongsTo(db.models.User, 'user_id');\n  };\ndb.models.User.prototype.driverProfile = function() {\n    return this.hasOne(db.models.DriverProfile, 'user_id');\n  };\ndb.models.User.prototype.addDriverProfile = function(role, params) {\n    console.log('adding driver profile')\n    console.log('########################### ', this.id);\n    var driverProfile = db.models.DriverProfile.forge({\n      user_id: this.id  //if I comment out this line, the record writes but without the association\n                               //as is it doesn't even write the record\n    });\nreturn driverProfile\n  .save()\n  .catch(function(e) {\n    console.log('caught an error', e);\n    return driverProfile;\n  })\n  .bind(this)\n  .then(function(driverProfile) {\n    console.log('driverProfile successfully saved')\n    return this.fetch({\n      withRelated: 'driverProfile'\n    });\n  })\n\n};\ndb.models.User.prototype.addRole = function(role) {\n    var params = Array.prototype.slice.call(arguments, 1);\n    if (_.isString(role)) {\n      //get an existing role or create it if it doesn't exist\n      role = db.models.Role.forge({name: role}).fetch({require: true })\n        .catch(function(e) {\n          return db.models.Role.forge({name: role}).save();\n        });\n    } else {\n      role = Promise.resolve(role);\n    }\n    return role.bind(this).then(function(role) {\n      return this.triggerThen.apply(this, ['roleAdded', role].concat(params))\n        .bind(this).then(function() {\n          this.addRole(role.get('name'));\n        });\n    });\n  };\n```\nwhen I run this test with debug enabled\n``` javascript\nit('should let me create a driver profile if the user is a driver', function(done) {\n    var user = db.models.User.forge({ email: 'test@example.com', password: 'foobar' });\n    var role = db.models.Role.forge({ name:  'driver'});\nPromise.all([user.save(), role.save()])\n.spread(function(user, role) {\n  return user.addRole(role);\n}).then(function() {\n  console.log('this runs?')\n  done();\n  return 5;\n})\n\n});\n```\nthis is what pops out...\n```\nadding driver profile\n#####################  1\nthis runs?\n\u2024{ sql: 'insert into \"driverprofiles\" (\"user_id\") values (?) returning \"id\"',\n  bindings: [ 1 ],\n  __cid: '__cid2' }\n{ sql: 'select \"roles\".* from \"roles\" where \"roles\".\"name\" = ? limit 1',\n  bindings: [ 'driver' ],\n  __cid: '__cid4' }\n```\nstill not working. any thoughts?\n. rewrote my addRole function\n``` javascript\ndb.models.User.prototype.addRole = function(role) {\n    var params = Array.prototype.slice.call(arguments, 1);\n    if (_.isString(role)) {\n      //get an existing role or create it if it doesn't exist\n      role = db.models.Role.forge({name: role}).fetch({require: true })\n        .catch(function(e) {\n          //should trigger if there is no role of that name\n          return db.models.Role.forge({name: role}).save();\n        });\n    } else {\n      role = Promise.resolve(role);\n    }\n    return role.bind(this).bind(this).then(function(role) {\n      console.log('inside the add role promise ', role);\n      return this.roles().attach(role)\n      .bind(this)\n      .then(function(user) {\n        console.log('XXXXXXXXXXXXXXXXXXXXXXXXXXX')\n        return this.fetch({\n          withRelated: ['roles']\n        });\n      })\n      .then(function(user) {\n        console.log('YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY');\n        return [user, role];\n      });\n    })\n    .spread(function(user, role) {\n      return user.triggerThen.apply(user, ['roleAdded', role]).then(function() {\n        console.log('driver profile added');\n        return user;\n  })      \n})\n\n};\n```\nhere's the output\n```\nadding role\ninside the add role promise  { attributes: { name: 'driver', id: 1 },\n  _previousAttributes: { name: 'driver', id: 1 },\n  changed: {},\n  relations: {},\n  cid: 'c2',\n  _knex: null,\n  id: 1 }\n{ sql: 'insert into \"users_roles\" (\"role_id\", \"user_id\") values (?, ?)',\n  bindings: [ 1, 1 ],\n  __cid: '__cid3' }\nXXXXXXXXXXXXXXXXXXXXXXXXXXX\n{ sql: 'select \"users\". from \"users\" where \"users\".\"email\" = ? and \"users\".\"username\" = ? and \"users\".\"salt\" = ? and \"users\".\"password_hash\" = ? and \"users\".\"id\" = ? limit 1',\n  bindings:\n   [ 'test@example.com',\n     'test@example.com',\n     '$2a$08$xdOmXB5J7b0gJ0n29DLMxO',\n     '$2a$08$xdOmXB5J7b0gJ0n29DLMxO5y84lvJICi6Gg3Lvnu7pmAesTcMkYJe',\n     1 ],\n  __cid: '__cid4' }\n{ sql: 'select \"roles\"., \"users_roles\".\"user_id\" as \"_pivot_user_id\", \"users_roles\".\"role_id\" as \"_pivot_role_id\" from \"roles\" inner join \"users_roles\" on \"users_roles\".\"role_id\" = \"roles\".\"id\" where \"users_roles\".\"user_id\" in (?)',\n  bindings: [ 1 ],\n  __cid: '__cid3' }\nYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY\nadding driver profile\n#####################  1\ndriver profile added\nthis runs?\n\u2024{ sql: 'insert into \"driverprofiles\" (\"user_id\") values (?) returning \"id\"',\n  bindings: [ 1 ],\n  __cid: '__cid4' }\n```\nstill not working though :(\n. ok figured it out, it was actually that the mocha test was closing the test before the addDriverProfile resolved because I left off the return in the hadnler for role added.\nThanks for the help.\n. Thats the wierd part, the withRelated not withstanding, it seems error when running a fetch. what kinds of things cause this?\nhere's the table schema for the driverProfiles\n``` javascript\nknex.schema.table('driverprofiles', function(t) {\n  t.integer('user_id')\n    .unsigned()\n    .references('id')\n    .inTable('users')\n    //.onDelete('CASCADE');\n    // .onUpdate(...) // optional\n  t.integer('company_id')\n    .unsigned()\n    .references('id')\n    .inTable('companies')\n    //.onDelete('CASCADE');\n})\n\n```\nif I don't fetch, I have the user just fine with the roles() tabel attached but trying to call fetch on it again gives problems.\n. \"bookshelf\": \"~0.6.4\",\n \"knex\": \"~0.5.7\",\n. \"bookshelf\": \"~0.6.4\",\n \"knex\": \"~0.5.7\",\n. thanks for the feedback,  I'm going to remove the extraneous binds and do a full audit and try to find an approach I haven't considered. \nI'm trying to create the driver profile, save it, then call User.fetch(). User being the 'this'. The specific bind you are referring to is to an instance of user which is hadling the roleAdded event and  trying to fetch() with driverprofile as a  related argument befire the then on triggerThen resolves. is that the wrong approach? \n. thanks for the feedback,  I'm going to remove the extraneous binds and do a full audit and try to find an approach I haven't considered. \nI'm trying to create the driver profile, save it, then call User.fetch(). User being the 'this'. The specific bind you are referring to is to an instance of user which is hadling the roleAdded event and  trying to fetch() with driverprofile as a  related argument befire the then on triggerThen resolves. is that the wrong approach? \n. ",
    "rkmax": "@bendrucker It would be amazing to configure something like\n``` js\nvar ModelB = bookshelf.Model.extends({\n  fetchEager: ['other'],\n  relatedBs: function() {\n    return this.hasMany(ModelB)   \n  },\n  other: function() {\n    return this.belongsTo(ModelC);\n  }\n});\n// without withRelated because always i want load other\nnew ModelB.forge({id: 1}).fetch().then(function(modelb) {\n  modelb.related('other');\n});\n```\n. I have this issue but i'm using bookshelf 0.7.9\n. @germanger recently I've faced the same problem and I have to make queries with the properties of relations, recently I wrote this library bookshelf-paginator.\n. @tgriesser any idea What's the best place to put a cache for queries?. My app is almost on the street and I need optimize some endpoints.\nSome approach that I can reuse without touching my models or controllers would be good\n. @bendrucker check the update\n. @bendrucker how i can do the following\njs\nadminAccounts: function(access) {\n    return this.belongsToMany(Account).query({where: {access: access}});\n},\ngetAdminAccounts: function(access) {\n    return this.related('adminAccounts', access);\n}\n. @bendrucker check the update, I had forgotten to add a method\n. @bendrucker no, I'm asking if that is the correct way to do that\n. @tgriesser exists a \"bookshelf\" way to do this kind of query? because i dont want hardcode all tables\n. :+1: for this feature\n. I found this syntax very useful\nupdate\nAdd the alias to the query\n```\nvar Chapter = Bookshelf.Model.extend({\n   'pages': function() {\n      return this.hasMany('Page');\n   }\n});\nvar Page = Bookshelf.Model.extend({\n   'book': function() {\n      return this.belongsTo('Book');\n    },\n   'chapters': function() {\n      return this.belogsToMany('Chapter);\n   }\n});\nvar Book = Bookshelf.Model.extend({\n   'pages': function() {\n      return this.hasMany('Page');\n    }\n});\n```\nStyle 1\nBook\n  .query().as('b')\n  .join('pages', 'p')\n  .join('p.chapters', 'c')\n  .where('c.name', '=', 'Associations').fetchAll({...}).then(function(books) { ... });\nStyle 2\nPage\n  .query('b')\n  .join('chapters', 'c')\n  .join('book', 'b')\n  .where('c.name', '=', 'Associations')\n  .where('b.isbn', 'LIKE', '978-3-16-148410%').fetchAll({..}).then(function(pages) { ... });\n. I have the same problem\nExample \nnew Model()\n        .fetch({withRelated: ['modelb', 'modelb.modelcs']})\nI have attached the 'fetched' event on modelb and modelc but aren't triggered\n. Currently when i do the previous, only the saving on descendant is called. even only with define the initialize function on descendants the other initialize is never called\n. many thanks @ricardograca \n. I recently found if I want update the model passing null in save method I have to do somethig like\nModels.Pref.forge({id: 1}).setPreferences(body.pref).save(null, {method: 'update'});\n. In my case its not just a warning. The response is affected. I did not too much testing but this it's not happening with 0.7.9 version\n. it's a bit complicated, but The endpoint where the problems rises, I did a .fetchAll() with about ~140 items and also fetch many relations something like\njs\nModel.fetchAll({withRelated: [\n  'modela.modelb.modelc',\n  'modeld',\n  'modele.modelf',\n  'modelg',\n]}).then(function(colection) {\n   // return the collection\n})\nSome models has attached the event fetching\n. So following your instructing will be like:\n```\nvar Parent = bookshelf.Model.extend({...})\nvar Child = Parent.extend({\n  initialize: function() {\n    Parent.prototype.initilize.apply(this, argument);\n  }\n})\n```\nin that way?\n. @ricardograca Nothing is wrong, I want to know if those are equals, for example if do somechange, example remove a property from model.attributes will affect the rest or remove something from attrs affect the other\n. I misunderstood your point at first. let me check\n. thanks @bendrucker, I understand that part, but somethimes I need saving event, example for validations before save (updating or creating)\n. @rhys-vdw the query es called correctly but still is return the wrong result. if I try the same query manually I get the correct result\n. I've found the problem. I forgot return a promise and the runtime don't wait the result that's why, @rhys-vdw thanks for your help\n. @rhys-vdw but if the fetching event is thrown, should be triggered fetched too, right?\n. Well I've attached a fetched event but this event is triggered only when i do .fetch() but not when I do .load()\n. I think the more intuitive is the third one, remove {patch:true} from .save() and append a .patch() method\n. For .patch() method? No, I understand that the idea behind the .patch method is persist only the properties you are passing are arguments, right? I think it's not necessary because in that case .patch will mimic .save\n. I'm using 0.7.9. I dont have any trigger on my tables\n. no, the problem persis\n. no, the problem persis\n. I'm thinking the problem is I'm using timestamp and not timestamptz on postgres, so postgres is converting the values. because if you see the first image you can see a 5 hours diff, that is my timezone (UTC-5) or maybe another thing is forcing the conversion\n. I'm thinking the problem is I'm using timestamp and not timestamptz on postgres, so postgres is converting the values. because if you see the first image you can see a 5 hours diff, that is my timezone (UTC-5) or maybe another thing is forcing the conversion\n. No @ricardograca\n. Yes I want exactly like @tkellen said, I'll check that project thanks\n. Exactly, I'm building a helper for handle all api stuff like strongloop loopback\n. Thank you\n. I get a error: property doesn't exist on the table\n. I get a error: property doesn't exist on the table\n. I get\nupdate \"resources\" set \"id\" = $1, \"is_private\" = $2, \"tags\" = $3, \"title\" = $4, \"topics\" = $5, \"type\" = $6, \"updated_at\" = $7, \"url\" = $8 where \"id\" = $9 - no existe la columna \u00abtags\u00bb en la relaci\u00f3n \u00abresources\u00bb\nI property i need remove is tags I did before save I get if I dump model.attributes I dont see it, on create the object works fine but on update I need remove also from attrs\n. I get\nupdate \"resources\" set \"id\" = $1, \"is_private\" = $2, \"tags\" = $3, \"title\" = $4, \"topics\" = $5, \"type\" = $6, \"updated_at\" = $7, \"url\" = $8 where \"id\" = $9 - no existe la columna \u00abtags\u00bb en la relaci\u00f3n \u00abresources\u00bb\nI property i need remove is tags I did before save I get if I dump model.attributes I dont see it, on create the object works fine but on update I need remove also from attrs\n. the value of tags is an array [ {..}, {..}, {..}], I remove it before save because I handle it in another place\nI use Promise.method to bubble up all throw new Error(...) I have my .catch() in only one place\n. the value of tags is an array [ {..}, {..}, {..}], I remove it before save because I handle it in another place\nI use Promise.method to bubble up all throw new Error(...) I have my .catch() in only one place\n. Yes,  I means it's removed from the model.attributes but if you don't remove from attrs then it's passed to the update query but this only happens on updated creating don't present this problem\n. Yes,  I means it's removed from the model.attributes but if you don't remove from attrs then it's passed to the update query but this only happens on updated creating don't present this problem\n. ``` js\nvar Model = bookshelf.Model.extend({\n  handleLater: {}\n  initialize: function() {\n    this.on('saving', function(model) {\n       if (model.has('value')) {\n          model.handleLater['value'] = model.get('value');\n          model.unset('value');     \n       }\n    });\n  }\n})\nModel.forge({id: 5}).fetch().then(function(model) {\n   return model.save({'value':'hello'}};\n);\n});\n```\nThe previous is generating the update model where id = 5 set value = 'hello';\n. @rhys-vdw I think maybe has relation with multiples  saving events attach to the model, because My models extends from Another and this model his own saving event listener, my extend call\nParent.prototype.initialize.apply(this, arguments);\n. Yes. it's called\n. @rhys-vdw I've updated the example\n. my bad, @rhys-vdw Looking my code I found I'm using .set().save()\n\n. ",
    "AntJanus": "@rkmax @bendrucker is there any way currently that allows default eagerly fetched models like described above? \n. @rkmax @bendrucker is there any way currently that allows default eagerly fetched models like described above? \n. @tgriesser would your update solution update the timestamps as well? So that if I did:\nUser\n  .query()\n  .where('id', 25)\n  .update({ enabled: false }).then(...\nThe updated_at column would yield a new timestamp?\n. @malte-wessel what do you do right now to do it? I can't see a way around either looping through the collection and running all of them together with async or using Knex directly and doing a whereIn. \n. @malte-wessel what do you do right now to do it? I can't see a way around either looping through the collection and running all of them together with async or using Knex directly and doing a whereIn. \n. @ezmiller @sirgalleto you save/delete/create via invokeThen, it's not just very efficient because it loops through all of the models in the collection and runs the delete function on all of them. Like so:\njs\nUsers\n  .forge({ id: 1 }, { id: 2 })\n  .invokeThen('delete')\n  .then(() => {})\nIf you're talking about deleting all of the models, you pretty much have to drop back down into using knex which makes sense. An ORM is not supposed to support plain query stuff. \nBasically what this createAll and deleteAll would accomplish is:\n\nfaster queries. It's faster to do a where in on IDs rather than individual delete queries\nthe API makes more sense because you're deleting without having to either use Promise.all or having to specify by string what method to use.\n\n. Ahh, thanks, I misunderstood the Registry docs:\nAnywhere you'd normally require a model, you can refer to it using its name supplied to Bookshelf.model.\nI guess that only applied to relations. :)\n. @bendrucker so I updated the model so work like so:\n``` js\nvar bookshelf = require('../db');\nvar Directory = require('./directory');\nmodule.exports = bookshelf.collection('Directories', {\n  model: Directory\n});\n```\nGetting the same error as before. \nI didn't see an example in the docs regarding building a collection with the registry plugin other than the syntax: bookshelf.collection(name, [Collection]). \n. didn't notice it in the docs. my bad.\n. didn't notice it in the docs. my bad.\n. @rhys-vdw I'd like to give this PR a shot. can you point me in some general direction on where to get started on this? I'll go through the library source code but would love some pointers.\nThanks!\n. Phew. I'm so glad that the function wasn't removed! And I'm glad to know it works just as I thought it would! :)\n. I'm looking at the API and something doesn't make sense to me. For example, this.morphOne has a second argument and doesn't matter if you have a 3rd argument as far as I understand so:\njs\nthis.morphOne('whatever', 'entity'); //links to entity_type and entity_id\nthis.morphOne('whatever', 'entity', ['custom_type', 'custom_id']); //links to custom_type and custom_id, so why even use the second argument?\nthis.morphOne('whatever', 'entity', ['custom_type', 'custom_id'], 'my own type'); //and you have to use it in order to get to the 4th argument\nIs there a better way to do this? For instance, \"smart\" arguments like:\njs\nthis.morphOne('whatever', 'entity'); //checks entity_type and entity_id \nthis.morphOne('whatever', ['custom_type', 'custom_id']); //checks custom_type and custom_id\nthis.morphOne('whatever', ['custom_type', 'custom_id'], 'my own type'); //uses 'my own type' as a morphValue and uses custom_type and custom_id\nthis.morphOne('whatever', 'entity', 'my own type'); //uses 'my own type' as morphValue and entity_type and entity_id as lookup columns\n. ",
    "hulbert": "@tgriesser Curious if there is an obvious workaround for modifying queries that are fetched via withRelated. I've been able to get pretty far so far with the following, which adds a special column AS into the SQL to have the database translate a geographic point into something more readable. However, I just realized that the fetching and/or fetching:collection events are not fired for withRelated.\nI'm not seeing an obvious way to accomplish this, even as a workaround, for withRelated so curious if there is a stop-gap I could use. \nExample of my modification:\n``` js\nvar onFetchAddCoordinateTranslation = function(model, columns, options) {\n    var coordinatesToGeoJson = bookshelf.knex.raw('ST_AsGeoJSON(coordinates) as coordinates_geojson')\n    var applyToCoordinates = _.some(columns, function(value) {\n        return (value === 'account_addresses.' || value === '' || value === 'coordinates')\n    })\n    if (applyToCoordinates) columns.push(coordinatesToGeoJson)\n}\nbookshelf.Model.extend({\n    initialize: function() {\n        this.on('fetching', onFetchAddCoordinateTranslation)\n        this.on('fetching:collection', onFetchAddCoordinateTranslation)\n    }\n})\n```\n. @rhys-vdw thanks for taking the time to respond & appreciate your thoughts. I am very much looking forward to the next iteration of Bookshelf in an ES6-style but hope that doesn't rule out making improvements to Bookshelf as it is today.\n\nFurthermore, I appreciate the reasoning behind this, but I'm unconvinced that it's necessary. Mutability is an expected and well understood part of JS development. Personally I think that this change would fix a class of errors so rare that it doesn't justify the change.\n\nIn a lot of cases, I would agree with this. However, Bookshelf/Backbone-style is creating its own inheritance style which seems to mimic more traditional OO languages like Java. The Bookshelf docs say this about Bookshelf#extend's second argument: \n\noptional classProperties to be attached directly to the constructor function\n\nIn Java, a class property can only be defined as static so it's strange to have a mutable class property, even in a language like JS, since the concept of a class property seems to be copied from other OO languages and not native to JS. Finally, I would ask what the use cases are for modifying a class property like Account.CHARACTER_LIMIT at runtime? To me it seems like this is a side effect of the plainest way to implement class properties in the extension code and not an intentional design decision.\nI do understand that Bookshelf's extend comes from Backbone so that may be a case where consistency is preferable. Funnily enough, Backbone internally calls them \"static properties\" despite being mutable https://github.com/jashkenas/backbone/blob/master/backbone.js#L1824\nMy biggest concern is in node, if one of these class property is modified in one module then it will be changed everywhere in the node runtime (i.e. they are not on the prototype so the slate is not essentially wiped clean on each Model#forge). \n. @rhys-vdw thanks for your time, great explanation of this issue. I was indeed conflating static with static constant in Java as well which did little but muddy the waters.\nI do think there is a place for constant class properties in Javascript but doesn't sound like ES6 adds them anyways, and you do a great job defending the flexibility of JS. I think the tension lies in Javascript offering things like const and Object#freeze but that not being usable in all places.\n\nCould I ask if you actually did accidentally reassign something as you describe, or if you just think the API could be more \"correct\"?\n\nNo accident yet, but my team as a form of habit tends to declare things that don't need to be modified as such up front (either with const or some combination of Object#freeze. If that causes problems with testing then we find ways to work around that rather than spoil the whole codebase for the sake of testing.\nFrankly I appreciate the flexibility of Javascript and don't want to turn it into Java but at the same time Javascript has added features like const\u2014but then they are available inconsistently. I.e. in this case we'd prefer to store CHARACTER_LIMIT on Account but not being able to set it as constant means we may implement it differently (i.e. in some map of constants).\nFinally, would it be advisable to do something like this when declaring a model or can that cause issues with Bookshelf?\n``` js\nvar Account = bookshelf.Model.extend({\n    tableName: 'accounts'\n})\nObject.defineProperty(Account, 'CHARACTER_LIMIT', { \n    value: 5,\n    writable: false,\n    enumerable: true\n})\n```\n. @rhys-vdw like the idea of refreshing generally, I've noticed a lot of devs struggling with partially vs fully filled models as they pass through a chain of promises.\n\njs\nbookshelf('SomeItem').forge({id: 5}).fetch()`\n// Error: `fetch` is undefined.\n// You can't \"fetch\" a model you already have...\n\nhow would do the initial fetching of SomeItem whose id is 5? \nAnd would one still be able to do this to get many instances of a model, and have a concept of an assignable model class (rather than having to continually call bookshelf('SomeItem')? \njs\nlet SomeItem = bookshelf('SomeItem')\nSomeItem.query(fn).fetchAll()`\n. @rhys-vdw wanted to enable these for NODE_ENV=test not just 'development'. Ended up modifying our app-wide config to do something like:\njs\nif (process.env.NODE_ENV !== 'production') {\n    process.env.BLUEBIRD_DEBUG = 1\n}\nThen just have to make sure to load that config file before loading bookshelf anywhere. This hits the spot for us for now, though hopefully this will help someone else in the future.\n. @rickharrison we wrote a function that:\n\ntakes a Model, primary keys, and any settings to pass to bookshelf including withRelated\nusing Highland stream library, pages through (with some configurable parallelism) the primary keys fetching the main Model + its relations (again, in pages)\nper page, does our serialization which includes calling bookshelf's toJSON\nreturns a stream of this\n\nThis lets us pass the stream to our web framework which we've written middleware for to stringify JSON from a stream. \nEnd-to-end, it increases the total time to fetch all the data but:\n\nwhen a connection is slow, slows down the fetching of data from the database via backpressure\nshrinks the page size to deal with Bookshelf being slow at eager joining as N increases\nallows event loop ticks to happen after each page is toJSON'd and stringified\n\nUsage, then, is to issue a query to get the PK's of some model you want and then pass those PKs to this function and get a stream back.\nIt's a bit coupled to our in-house serialization but happy to answer questions. ",
    "connrs": "Hi @tgriesser,\nAnother giant :+1: from me. :heart: this project (and Knex.) I've recently been migrating some hand-rolled data-mappers to bookshelf.js models and I'm over the moon. I'm also quite happy monkey patching soft deletes in. Having support natively baked in would be fantastic.\nIn particular, I'd be especially interested in having soft delete support for (through) join tables as we always have created/updated/deleted (_at & _by) on all tables.\nThanks so much for a great project\n. ",
    "olso": "Is this being worked on?\n. ",
    "santiagovazquez": "Another :+1: from me. I would love to have this feature.\n. ",
    "apolishch": "It is worth noting that we at lanetix have written and are using\nhttps://www.npmjs.com/package/bookshelf-soft-delete\n. ",
    "gabssnake": "Thanks for the plugin @apolishch, I was hopping this was built-in\n. ",
    "majimboo": "I tried it with this\nvar query = this.query();\nquery.where({id: 1}).count().then(function (result) {\n  console.log(result);\n  return result;\n});\nBut now its telling me that totalGroups is not defined.\n. How would that work? I'm new to this.\n. I was also trying to return a contacts relationship.\ncontacts: function() {\n  return this.hasMany('Contact', 'uid_by');\n}\nBut the thing is I could either be the uid_by or uid_to, So the relationship had to be\nreturn this.hasMany('Contact', 'uid_by OR uid_to');\nBut of course that is wrong, any idea on how to do that with bookshelf?\n. Keeps, telling me [object] has no count though.\nand lastly how should I call this? Do I fetch this as \"withRelated\"?\n...cannot read propertyFk of undefined.\n. So I was trying this\nvar avatar = Bookshelf\n              .knex('user_avatars')\n              .where('id', '=', this.get('avatar_id'))\n              .select('user_avatars.id');\nas part of my virtuals for a user.\nBut it keeps crashing with an error about json circular, cannot convert?\n. So I was trying this\nvar avatar = Bookshelf\n              .knex('user_avatars')\n              .where('id', '=', this.get('avatar_id'))\n              .select('user_avatars.id');\nas part of my virtuals for a user.\nBut it keeps crashing with an error about json circular, cannot convert?\n. using this, as suggested by bendrucker\ncontacts: function () {\n  return Contact.collection().query(function (qb) {\n  qb.where('uid_by', '=', this.id).orWhere('uid_by', '=', this.id);\n }.bind(this));\nerrors to cannot read property 'parentFk' of undefined.\n. For the contacts relationship, I'm calling it like so. (i used npm to install bookshelf, could version be an issue?)\n```\nnetworkCount: function() {\n  return Network.collection().query('where', 'parent', '=', 0).count('*');\n},\ncontacts: function() {\n  return Contact.collection().query(function (qb) {\n  qb.where('uid_by', '=', this.id).orWhere('uid_by', '=', this.id);\n  }.bind(this));\n},\ntoken: function() {\n  return this.hasOne('Token');\n},\n```\n\nIf I remove everything and just leave token; it works.\n.fetch({ withRelated: ['token', 'contacts', 'networkCount'] })\nAs for the virtuals:\nvirtuals: {\n  user_id: function() {\n    return this.get('id');\n  },\n  avatar: function() {\n     var avatar = Bookshelf\n          .knex('user_avatars')\n          .where('id', '=', this.get('avatar_id'))\n          .select('user_avatars.id'); \n     return avatar;   \n  }\n},\n. Yes I did on another file,\nBookshelf.PG = Bookshelf.initialize({\n  client: 'pg',\n  connection: {\n    // your connection config\n  }\n});\nMy models are working well, I'm trying to run the query on a controller.\n. Yes I did on another file,\nBookshelf.PG = Bookshelf.initialize({\n  client: 'pg',\n  connection: {\n    // your connection config\n  }\n});\nMy models are working well, I'm trying to run the query on a controller.\n. Actually I was just wondering if bookshelfjs has any dependency with node, or is it purely javascript? (which if it is then should work with any javascript platform)\n. Actually I was just wondering if bookshelfjs has any dependency with node, or is it purely javascript? (which if it is then should work with any javascript platform)\n. Vertx does support CommonJS.\nAs by does it depend on node in anyway, maybe I should ask if bookshelf is written in pure javascript (commonjs) or does it borrow some api from nodejs itself?\nThanks.\n. I will try to dig deeper into this and give you a much more educated proposal and implementation possibilities. I am very interested in getting bookshelf working as an ORM with vertx.\nThanks both.\n. It keeps telling me .session is undefined.\nMy code looks like:\nComment\n.collection()\n.query('where', 'reply_to', '=', post_id)\n.query('whereNull', 'deleted_at')\n.query('orderBy', 'created_at', 'DESC')\n.query('limit', limit)\n.query('offset', page)\n.fetch({withRelated: ['author', 'author.avatar', 'author.cover', 'attachments', 'likes','likes.author','likes.author.avatar', 'likes.author.cover', 'parent']})\n.then(\n// successful query\nfunction (comments) {\n  comments.session = req.session;\n  res.json(200, { code: 200, comments: comments });\n},\nand I access it on the virtuals like: this.session.user_id.\n. Oh, yup that works. Thanks man. Couldn't get the likes to work though. getting the related data is telling me Cannot read property 'user_id' of undefined from your first reply.\n. I tried \nconsole.log(_.contains(_.pluck(this.related('likes'), 'user_id')));\nThis returns 3 false, then it errors Cannot read property 'user_id' of undefined.\nThe fetch is the same as above.\nThe like relation is an array of objects. each object containing user_id.\n. And how about attaching the session to relationship, like when I am trying to get the post with its comments, where the posts has a is_removable is the currently logged in user is an admin and the comment has is_removable too. true if session userid is the poster or an admin.\n. Well finally what I did is something like:\n```\nfunction (post) {\n  post.related('comments').each(function(comment) {\n    comment.attributes.is_removable = (comment.get('user_id').toString() === req.session.auth.user_id || req.session.auth.user_id ===  '682') ? true : false;\n    comment.attributes.is_liked = .contains(.pluck(_.pluck(comment.related('likes').models, 'attributes'), 'user_id'), req.session.auth.user_id);\n  });\npost.attributes.is_removable = (post.get('user_id').toString() === req.session.auth.user_id || req.session.auth.user_id ===  '682') ? true : false;;\n  post.attributes.is_liked = .contains(.pluck(.pluck(post.related('likes').models, 'attributes'), 'user_id'), req.session.auth.user_id);\n  res.json({ code: 200, post: post }, 200);\n},\n``\n. I used thecollection.lengthit worked.\n. Hello, I too am getting this error withmariasql (latest)`. 2 years later and still no alias for the property with mariasql ^^\nUnhandled rejection Error: select users.* from users - No database selected\n    at Error (native)\n. ",
    "gaarf": "+1 optionitis. Also I'd be concerned about how this integrates with virtuals plugin.\n. no, it was something else... can you write a test case for your issue? I tried this and it obviously passed:\nit('maintains inheritance', function () {\n  equal(true, (new (bookshelf.Model.extend({}))()) instanceof bookshelf.Model);\n});\n. That makes sense. Thank you!\n. That makes sense. Thank you!\n. I don't think so.... \nvar BackboneModelMinus = _.omit(Backbone.Model.prototype, modelOmitted);\n_.extend(ModelBase.prototype, BackboneModelMinus, Events, {\n...\nseems right to me.\n. I don't think so.... \nvar BackboneModelMinus = _.omit(Backbone.Model.prototype, modelOmitted);\n_.extend(ModelBase.prototype, BackboneModelMinus, Events, {\n...\nseems right to me.\n. I'll add a test.\n. I'll add a test.\n. @ahdinosaur I implemented the fn.toString idea.\n@tgriesser LMK if you want a PR for this. Maybe it's a little brittle (?)\nhttps://github.com/gaarf/bookshelf/blob/parseRelations/plugins/relationships.js\nthis.forge().relationships(); :+1: \n. I just set hasTimestamps: true in the model definition, make sure table schema has DATETIME columns named updated_at & created_at, and it just works (at least with MySQL).\n. @austinrivas badass!\n. ",
    "ericclemmons": "I'm assuming this fixes the bug I just discovered where if you do Bookshelf.plugin('virtuals') without defining any virtuals, the models come back as not instanceof Bookshelf.Model?\n. ",
    "kasztelan": "I agree belongsTo relation should always have key specified but in this situation I'm dealing with not one model but a collection - some of the models inside have keys, some don't. I can't really do anything about it as it's a legacy database I'm writing new API for. \nMaybe you could first get all keys from collection and only make sql query if any of them is not null? Right now if the first model in ports collection doesn't have definition_identifier key then the sql is not executed at all. If that model is last in collection the sql executes but the IN clause contains all proper ids plus null which is as you said unecessary.\n. I agree belongsTo relation should always have key specified but in this situation I'm dealing with not one model but a collection - some of the models inside have keys, some don't. I can't really do anything about it as it's a legacy database I'm writing new API for. \nMaybe you could first get all keys from collection and only make sql query if any of them is not null? Right now if the first model in ports collection doesn't have definition_identifier key then the sql is not executed at all. If that model is last in collection the sql executes but the IN clause contains all proper ids plus null which is as you said unecessary.\n. Yes, I think that would work.\n. Yes, I think that would work.\n. ",
    "aef-": "Thanks for the suggestions/tips, will write a lil plugin\n. Thanks for the suggestions/tips, will write a lil plugin\n. Can this be opened as a bug? I'm experiencing this in 0.8.2.\n. Can this be opened as a bug? I'm experiencing this in 0.8.2.\n. I started work on https://github.com/aef-/bookshelf-imageclip, contributions welcome!\n. ",
    "jtwebman": "We actually figured out an even easier way to handle it. We put all our relationship functions in an object relationships and the move them out on extend. This way you know which methods are relationships for related.\nhttps://github.com/pk4media/bookshelf-relationships\n. Thanks looking forward to the changes, do you have a branch that I can take a look at?\nWe are also building an Express JSONAPI bookshelf tool to make it easy to make JSON API's. This was a small part of it to make it easier.\n. ",
    "ruifortes": "Another example.\nLets imagine models Product, Supplier, SupplierProduct(obviouslly a product supplied by a supplier) and Quote is a price stated by a supplier for a product so it related to SupplierProduct and has a date field.\nSupplierProduct model has a composite key with product_id and supplier_id.\nQuote model PK uses SupplierProduct key but because I want to store previous quotes it also contains a date field in the PK\n```\nvar Product = bookshelf.Model.extend({\n    tableName: 'products',\n    supplierProducts: function() {\n        return this.hasMany(SupplierProduct)\n    },\n    suppliers: function() {\n        return this.belongsToMany(Supplier, ('supplierproducts'))\n    }\n})\nvar Supplier = models.Supplier = bookshelf.Model.extend({\n    tableName: 'suppliers'\n})\nvar SupplierProduct = bookshelf.Model.extend({\n    idAttribute: ['product_id', 'supplier_id'],\n    tableName: 'supplierproducts',\n    quotes: function() {\n        return this.hasMany(Quotes)\n    }\n})\nvar Quote = models.Quote = bookshelf.Model.extend({\n    idAttribute: ['product_id', 'supplier_id', 'date'],\n    tableName: 'quotes'\n})\n```\nHow should I retrive SupplierProduct with related quotes? The following doesn't work.\nvar supProd = new models.SupplierProduct({product_id: 2,supplier_id: 23})\n            .fetch({withRelated: 'quotes'})\n            .then(function(model) {\n                res.send(model)\n            })\n. ",
    "aembke": "@bendrucker pg just returns the hstore column value as a string as you would see it via the psql client. on a related note, our team uses hstore under bookshelf quite a bit and we're thinking about open sourcing the model/collection extensions and serialization layer between hstore and json. when it comes to packing this up we're a bit unsure of how it'd be easiest to integrate into bookshelf without stepping on anybody's toes. the current idea is to create an hstore plugin that extends the default model and collection. or would it make more sense to try to integrate the hstore logic within the bookshelf base objects? none of us have ever really used the plugin system so it's a bit unclear what the desired API surface over a plugin is. \nthe actual API surface to the hstore functionality is only really about three functions and an added declaration of hstore columns on the model. the serialization/deserialization process is pretty straightforward but it gets a bit tricky around querying against hstore data since postgres uses a set of operators not supported directly by knex. we have a query building function that we've just been wrapping in a knex.raw object, but ideally there'd be a cleaner way to query against hstore data. \nhere's a gist that roughly describes what we're doing now, albeit not in a very elegant way. I'm thinking it'd make the most sense to just create a hstore plugin that extends the default model and collection with the event callbacks implemented in the gist. that doesn't solve the querying issue since there's still some ambiguity around the operators, but it's a start. \n. Interesting, good point. fortunately our use case hasn't bumped up against that yet, but it's an something that I think warrants a second look at our approach from the ground up. I'll take a look.\n. Agreed, this will take some rethinking to support complex relations. Another interesting case is when pivot tables contain hstore columns. The declaration of their intended deserialization would, at first glance, seem to possibly require a small change to the withPivot function. Aside from serialization issues it seems the nastiest part is the querying process since there's some ambiguity around operators when the hstore is represented as a simple object. Hopefully sometime in the next couple of weeks I'll have a chance to consider a deeper solution to handling relations and querying that may require a more complex API surface over querying that I originally planned. I had hoped to avoid any real complexity here because if any of the changes seep into core bookshelf code it could create some ugly portability issues with other databases. Ideally all of this could be contained in a plugin or something along those lines. Maybe in the meantime somebody else who is using bookshelf with hstore under different use cases can have a look at our first attempt and possibly offer some insight. \n. ",
    "kevinob11": "Did this end up getting implemented?\n. @rhys-vdw Is this conversation on-going somewhere? Is most of the work just being done on the next branch? I've made a big bet on a project replacing waterline in sailsjs with bookshelf. I'm excited about the next version and love some of the ideas being discussed here. I'd love to be able to know where to look to get an idea of what progress / changes are going into the next version.\n. @b3njamin not sure I'm ready to jump ship right away after a couple of weeks of integrating this with sailsjs, objection looks young, but does look pretty nice. @rhys-vdw bookshelf isn't going to be abandoned correct? What is current sentiment among maintainers?\n. This just totally saved me, can't believe I missed that as well.\n. Sure, I actually ended up monkey patching the model.save method and added a model.saveGraph method so I could fire the saved event only after all nested saves have been completed. It has been working perfectly for my purposes. The link below is the the repo that contains all of this, you can find the save logic in the lib folder in appropriately named files. I'm happy to contribute any of this back to bookshelf, I just haven't had the time to do it yet.\nhttps://github.com/praece/sails-bookshelf\nOne note I think saveGraph right now only works on one to many relationships. It would be pretty manageable to add others, I just haven't gotten around to it yet since I haven't needed it.\n. Sure #1248 \n. No problem :)\n. ",
    "misleb": "+1\n. ",
    "totoleo": "+1\n. +1\n. ",
    "nicholasgubbins": "+1\n. Thanks for your quick response. Nope, having looked through the documentation and code again, I had a fundamental misunderstanding of how collections function - I had previously assumed that through defining a collection CX for model X, all further collections of Model X, regardless of how they were instantiated (whether through CX.forge() or X.collection() or a withRelated: X, where the relation is a hasMany) would use the custom collection definition. I now realise that a custom collection is only instantiated when directly instantiated.\nI guess what they say about those who make assumptions is true....\n. Hmm that was actually throwing errors, namely \"TypeError: (intermediate value) is not a function\". I have discovered that by setting the relation reference as the collection name does the trick:\nagain NB i'm using the registry package;\ne.g\n``` javascript\n//define first model\nvar Model1 = bookshelf.Model.extend({});\nvar m1 = bookshelf.model('Model1', Model1); //set name on registry\n//define collection of first model\nvar Collection1 = bookshelf.Collection.exend({\n  model: m1\nvar c1 = bookshelf.collection('Collection1', Collection1); //set name on registry\n//now we can access this custom collection with added function foo \n//whenever a collection of Model1s are instantiated through a \n//relation by adding the collection name as the relation\nvar Model2 = bookshelf.Model.extend({\n   m1s: function(){\n       return this.hasMany('Collection1'); //set reference to collection on registry instead of model 'Model1'\n   } \n});\n// and can thus do \nModel2.forge().fetch({withRelated:['m1s']})\n.then(function(m2){\n    m2.relations.m1s.foo();\n});\n```\n. ",
    "GuilhouT": "+1\n. ",
    "TinOo512": "This is also commonly used to handle roles : \n```\nuser\n - id\n - ...\nmember\n - id\n - ...\nrole_mapping\n - role_id\n - restrictable_type\n - restrictable_id\nrole\n - id\n - name\n - description\n```\nWhere a user of the platform and a member of a team can both have different roles so the restrictable_type can be equal to user or member.\nDoes it make sense ?\n. I needed this for update queries made with { patch: true } and I ended up with : \njs\ninitialize: function () {\n  Bookshelf.Model.prototype.initialize.call(this);\n  this.on('updating', (model, attrs, options) => {\n    options.query.returning('*');\n  });\n  this.on('updated', (model, attrs, options) => {\n    model.set(model.parse(head(attrs)));\n  });\n}\nI guess it could also work with those saving and saved events.\n. @ricka Yes I'm using Postgres. I never tried this workaround for insert queries only for update ones, so I can't really help you, ... I guess this wont help you much, but since my last post I updated the handler to make it work when more than one row are updated : \njs\nthis.on('updated', (model, attrs, options) => {\n  const id = model.get(model.idAttribute);\n  if (id) {\n    const findById = find(propEq('id', id));\n    const attr = findById(attrs);\n    if (attr) model.set(model.parse(attr));\n  }\n});\n. @ricka You are right it wasn't working with both insert and update so I ended up with this workaround : \njs\nthis.on('saving', (model, attrs, options) => {\n  if (options.method === 'insert') {\n    // workaround (cf. https://github.com/tgriesser/bookshelf/issues/507#issuecomment-99634467)\n    Object.defineProperty(options.query._single, 'returning', {\n      get() { return '*'; },\n      set() { return '*'; },\n      configurable: true,\n      enumerable: true,\n      writeable: true,\n    });\n  } else {\n    options.query.returning('*');\n  }\n});\nthis.on('saved', (model, attrs, options) => {\n  if (options.method === 'insert') {\n    // workaround (cf. https://github.com/tgriesser/bookshelf/issues/507#issuecomment-99634467)\n    model.set(model.parse(model.id));\n  } else {\n    const id = model.get(model.idAttribute);\n    if (id) {\n      const findById = find(propEq('id', id));\n      const attr = findById(attrs);\n      if (attr) model.set(model.parse(attr));\n    }\n  }\n});\nIt's kind of a compilation of all the answers which are using the returning * postgres feature :)\n. @matt-dalton it's from Ramda, it's just here to support multiple lines update. attrs is an array with all your updated lines, so findById find the right entity by id. It could also be done without ramda : \njs\n...\nif (id) {\n  const attr = attrs.find(attr => attr.id === id)\n  if (attr) model.set(model.parse(attr));\n}. @matt-dalton it's from Ramda, it's just here to support multiple lines update. attrs is an array with all your updated lines, so findById find the right entity by id. It could also be done without ramda : \njs\n...\nif (id) {\n  const attr = attrs.find(attr => attr.id === id)\n  if (attr) model.set(model.parse(attr));\n}. Hi,\nNeeded to fix the commented test on #1380\n. @vellotis Here is more details : \n- When I let the default columnNames in snake_case it works when helpers.js#morphCandidate is called by relations.js because my attributes are in snake_case. But when the function is called by eager.js my attributes are formated so they are in camelCase so the foreignTable is undefined in helpers.js#morphCandidate\n- I tried to specify the columnNames in camelCase in my model but obviously it works when it's call by eager.js but not relations.js\nIt seems that for relation.js the function format is correctly called, but not for eager.js as @jamesdixon already mentioned.\ncc: @rhys-vdw \n. @vellotis Here is more details : \n- When I let the default columnNames in snake_case it works when helpers.js#morphCandidate is called by relations.js because my attributes are in snake_case. But when the function is called by eager.js my attributes are formated so they are in camelCase so the foreignTable is undefined in helpers.js#morphCandidate\n- I tried to specify the columnNames in camelCase in my model but obviously it works when it's call by eager.js but not relations.js\nIt seems that for relation.js the function format is correctly called, but not for eager.js as @jamesdixon already mentioned.\ncc: @rhys-vdw \n. @DGulshan Are you using Model Registry ? Otherwise if you override format/parse it should be the same issue than mine so this fork should fix this. Feel free to try it and add :+1: if it resolve your issue :)\n. @vellotis Should I also modify the way relations.js handle this to stay consistent ?\n. @vellotis I added tests but they seem to show another bug, ...\nWithout the fix : tests throw an error as mentioned in the issue #1159.\nWith the fix : the related model is well fetched but it's not embed in the parent model, ... I'm trying to figure out what is happening, ... Any clue ?\nEDIT: I thought it was again non formatted attributes in eagerPair but it must have something else, ... I'll continue to dig later!\n. @vellotis Hi, after more digging the formatted attribute in eagerPair fix the relation morphTo. On the other way (morphOne and morphMany) still doesn't work, ... Do you have any clue where might be the problem ? Maybe we can merge this, and I'll open a new PR with the commented test to fix morphOne, morphMany ?\n. @vellotis Just to be clear, morphTo, morphMany and morphOne never worked before when you override the format and parse method of the model. Il added 3 tests to cover those relations behind a parsed model.\nOnly 2 tests are passing with the fix (those using morphTo). But the one using morphMany isn't, ... \nI agree it should be better to also fix the test which cover morphMany but I don't have any clue of what's happening here, ... Any idea where I should look into ?\n. @vellotis find it :)\nIn src/relations.js#311, model.id is called and return undefined because model.id_parsed should be called. I see two solutions : \n- Use a getter to return the parsed id when model.id is called ?\n- Thinking this feature is also mainly used to handle the snake_case formatting and the camelCase parsing the bug doesn't show up in real world project because the column id is rarely rename. Maybe we should juste warn the user to avoid formating/parsing the id ? I have more than 20 results when I do a global search in the project on model.id or m.id so I guess this cause many other bugs, ...\nWhat do you think ?\nEDIT: #1082 try to find a solution of the problem.\nEDIT2: I now parse the specified attribute instead of formatting all the model attributes\nEDIT3: My last commit add a fix and all tests are now green :smile: #1082 might be a better option ?\n. @vellotis I rebase with master to fix conflicts. I can't use the parseAttribute helper anymore in relation.js because of this PR so the parent attributes are still cloned in relation.js\nLet me know what do you think :)\n. @vellotis ping. This PR fix a really annoying bug, without it you just can't use morph relations when parse/format are override, ...\n. @vellotis ping. This PR fix a really annoying bug, without it you just can't use morph relations when parse/format are override, ...\n. @vellotis @rhys-vdw @tgriesser is there anyone who can review this ?\n. @vellotis @rhys-vdw @tgriesser The fix seems to have performance issue, so we don't use it anymore in production, ... Actually we are removing the parse/format feature which is completely broken (cf. https://github.com/tgriesser/bookshelf/issues/97#issuecomment-28725502, https://github.com/tgriesser/bookshelf/issues/1212#issuecomment-218031508). You should probably deprecated the feature !?. @vellotis @rhys-vdw @tgriesser The fix seems to have performance issue, so we don't use it anymore in production, ... Actually we are removing the parse/format feature which is completely broken (cf. https://github.com/tgriesser/bookshelf/issues/97#issuecomment-28725502, https://github.com/tgriesser/bookshelf/issues/1212#issuecomment-218031508). You should probably deprecated the feature !?. @vellotis @rhys-vdw @tgriesser because this can't be merged I also need this to be able to use bookshelf without parse/format to convert camelCase to snake_case. The PR is open since Oct 11 and clearly fix an issue from a recent PR. We choose bookshelf last summer but it seems dead, no core contributor are working on it and even worst PR are not merged, .... @vellotis @rhys-vdw @tgriesser because this can't be merged I also need this to be able to use bookshelf without parse/format to convert camelCase to snake_case. The PR is open since Oct 11 and clearly fix an issue from a recent PR. We choose bookshelf last summer but it seems dead, no core contributor are working on it and even worst PR are not merged, .... @Playrom That's a really good news! Lot of people rely on this project. Unfortunately I'm not working with bookshelf anymore so I wont really be able to help you, ... Wish all the best to the new team!. @vellotis I can't pick the right keys because they don't match the parsed attributes. It's why I need to format the attributes first. As I said in the description I could parse the morphKeys instead of format the attributes but I'm not familiar enough with the codebase so I did the same  than in relation.js. If you prefer I can do something like that : \njs\nconst parsedAttribute = _.head(_.values(m.parse({ attribute })));\nreturn m.get(parsedAttribute);\n. @vellotis same, if you prefere ? \njs\nconst parsedTypeColumn = _.head(_.values(model.parse({ typeColumn })));\nreturn model.get(parsedTypeColumn);\n. Yes my bad, it should be better to parse the specific attribute ? What do you think ?\n. Done\n. Done\n. ",
    "sairamc": "Any update on this?\n. ",
    "epoberezkin": "I want to have asynchronous change there. I posted #284 with another problem; I'd like to change encryptPasswordSync there to async. I also have another situation when I can't get away with synchronous equivalent - so instead of defining it in model I will have to put it in update method which currently is generic and used for all models or even in express route. But I think the change should be in the model (in theory :)...\n. Thanks, I guess I can assuming that what subscriber returns will be the new model.\nSo please correct me if I am wrong:\nvar Model = Bookshelf.Model.extend({\n    initialize: function() {\n        this.on('saving', function(model, attrs, options) { // what are options btw?\n            return formatAsync(attrs, options).then(function(attrs) {\n                return new Model(attrs);\n            });\n        })\n    }\n})\nOr should subscriber function return attrs rather than model?\nI could try to change whatever uses format to support promises, it would be cleaner - what do you think?\nThank you!\n. Thanks!\nThat all makes sense actually - parse/format should really be used for \"formatting\" and events for model mutations.\n. ",
    "quintenb": "Never mind. I think I just found it. It had to do with the way I was loading the models. The syntax was correct.\n. ",
    "danieldiekmeier": "For anyone coming from Google (like me), here is the current link to the Wiki for the Registry plugin: https://github.com/tgriesser/bookshelf/wiki/Plugin:-Model-Registry. ",
    "cabhishek": "@johanneslumpe Thanks. Looks like thats the case. I was able to fetch fields using withPivot but since my through table is big I was looking to for more automated way. \n. ",
    "levifelling": "Similarly, is there a way to call a database function within a query or insert statement? Select * from user where login = 'login' and password = md5('password');\nupdate: found solution https://github.com/tgriesser/knex/issues/185\n. Similarly, is there a way to call a database function within a query or insert statement? Select * from user where login = 'login' and password = md5('password');\nupdate: found solution https://github.com/tgriesser/knex/issues/185\n. ",
    "sebgie": "Thank you :+1:!\n. ",
    "stefanhenze": "That worked, thank you.\n. ",
    "martinaglv": "I can confirm that everything works as expected with 0.6.10. Great work!\n. Thanks! Weirdly I didn't see the original issue. Hope this gets resolved.\n. ",
    "eav": "yes, I thought so but unfortunately I'm not seeing this behavior....\n. I override parse/format methods and if I declare instance variable in initialize method it becomes unavailable in parse method, so I get error.\n. ok, here is the code, it breaks on this line:  \nif (this._transforms[key]) {\nTypeError: Cannot read property 'id' of undefined\n``` js\nmodule.exports = function(Db, _) {\n  return Db.Model.extend({\n    initialize: function() { \n  this._transforms = {};\n\n  this._transformers = {\n    point: { \n      parse: function(val) {\n        if (val) {\n          var values = val.replace('(', '').replace(')', '').split(',');\n          return {\n            lat: parseFloat(values[0]),\n            lon: parseFloat(values[1])\n          };\n        }\n        return val;\n      },\n      format: function(val) {\n        return '(' + val.lat + ',' + val.lon + ')';\n      }\n    }\n  };\n},\n\naddTransform: function(key, type) { \n  this._transforms[key] = type;\n},\n\nparse: function(attrs) {\n  return _.reduce(attrs, function(memo, val, key) {\n    key = _s.camelize(key);\n    memo[key] = this._transform(key, val, 'parse');\n    return memo;\n  }, {}, this);\n},\n\nformat: function(attrs) {\n  return _.reduce(attrs, function(memo, val, key) {\n    memo[_s.underscored(key)] = this._transform(key, val, 'format');\n    return memo;\n  }, {}, this);\n},\n\n_transform: function(key, val, action) {\n  if (this._transforms[key]) {\n    var transformer = this._transformers[this._transforms[key]];\n    if (transformer) {\n      return transformer[action](val);\n    }\n  }\n  return val;\n}\n\n});\n}\n```\n. ah I see now, thanks.\n. ",
    "tybenz": "Thanks for the detailed answer! And you're right. Writing a plugin to cover some basic find/where cases would be simple. Just thought I'd ask why it wasn't provided by the library. The separation makes a lot of sense now that you've laid it out.\n. I'm working on an application that needs both a stand-alone REST API and a web interface.\nI've been reading a lot about separating out a single API for all possible clients. iOS app, web app, desktop app, etc all use the same API. I like how clean that architecture is, but I prefer to do mostly server-side scripting for my web applications when it comes to rendering pages. And, I don't like the idea of users requesting a page from the web app only to have another request fired to grab data from the REST API (on another server). The performance implications bug me.\nSo I was trying to have the best of both worlds... a REST API to serve all, but putting my web application right alongside it and allowing it to call some method directly inside of the API's codebase to retrieve the data. That way I have shared code between all, but I don't have perf problems of handling requests to get my web app and API to talk to one another.\nSo what I would like to do is build a set of controllers for my REST API, have my REST API's router call those controllers and their methods and respond with JSON, but allow my web app to call the methods directly. This lead me to believe that having my controllers simply take parameters and return data would be cleanest rather than returning a promise for each thing.\nSorry if this sounds crazy. And let me know if I need to clarify anything. Just curious if it was possible with Bookshelf/Knex. Because it would be nice to have a sync workflow for this specific setup.\n. Sorry, let me simplify it. What if I wanted to build a command-line script using BookshelfJS that lets me say \"Hey DB, give me all the rows in this table\". Why should it need to be async? If there is a function for each DB table, why shouldn't I structure my code to simply say \"Here are my inputs, give me some output\"?\nIt's functional programming in its simplest form. Take some params, do stuff, give me output. If I don't mind waiting for the results, I don't need async. Not understanding why introducing a database or a technology like nodeJS suddenly means everything must be async?\n. Thanks so much for the explanation guys. This makes a lot of sense now. I'm used to ruby (which is single-threaded also but lives with the drawbacks of blocking/sync calls). The fact that this is enforced by the language and not the library makes me I see I need to embrace it rather than fight against it. \n. Thanks! Just wasn't sure if someone already had and published it.\n. ",
    "JemiloII": "Well, where does not work with belongsToMany(). Well, where does not work with belongsToMany(). I wouldn't call this a duplicate, clearly pg-native is required by bookshelf to do something. #1542 doesn't mention anything about pg-native.. ",
    "samccone": "indeed that is what I have been doing\njs\n    return _.partial(function(tableName) {\n      return app.DB.knex(inflection.pluralize(tableName)).truncate();\n    }, model.prototype.tableName)\nhowever I wish it was not so verbose, it seems like a common enough demand/pattern to validate exposing it by default on the model instance.\n. :+1: \n. If not, I would be more than willing to implement this.\n. :cry: At the time I think it would have been nice, but now it makes sense to :skull: \n. :cry: At the time I think it would have been nice, but now it makes sense to :skull: \n. I should clarify: \nhttps://github.com/jashkenas/backbone/blob/a32e1ff1a1975f600d83ef57f99dafc3fde8ff01/backbone.js#L1110\njs\nX.extend({\n  events: {\n    \"save\": \"doSomething\"\n  }\n})\nIs what I am after.\nCurrently you have to explicitly set events via the .on syntax from backbone events.\nthoughts?\n. Hey @tgriesser going to +1 this issue,\nPerhaps adding a method saveAndFetch() might be a nice addition to the api namespace... If you are open to this more than willing to PR up this sucker. \n. TIL, obviously my searching was non optimal.\nDo you this maybe should be mentioned somewhere as a caveat or something like that?\nthanks!\n. yeah that sounds like a real nice thing\n\n. Yeah I see your concern, it has just been a big win for codebases that I have been in as far as readability goes.\nconverting code from\ninitialize: function() {\n  this.on(\"save\": \"...\")\n  this.on(\"X\", \"...\")\n}\nto a more literate* style\nonSave: ..\nonX: ..\nIt also does wonders for reducing the setup complexity of initialize.\n\nOn this note it might be again interesting to investigate an events hash where you can bind to model events in a single location.\nevents: {\n  save: ..\n  fetch: ..\n}\n\nJust some thoughts, on the kinda unexpected differences between the backbone world on bookshelf.\n. kk\n. ",
    "kimmobrunfeldt": "\nThere's forShare and forUpdate which do the appropriate locking on postgres & mysql, but they're only made available after you call .transacting.\n\nHow can I use .transacting() method with bookshelf? I would like to e.g. save my bookshelf model:\nI thought something like this would work: model.save(null).transacting(trx).forShare(); But there is no method called transacting.\n. @rhys-vdw I don't think my comments are off topic at all. The issues I'm commenting give some advice, but miss details how to exactly solve / workaround the issue. Thus I'm looking for more details and want to share the exact solutions to everyone else reading the issue threads. It's hard to find examples from documentation and sometimes they are buried to the issues. If you don't think that's useful, I'm happy to take advice how to do better.\nIn this case, I already was using options.transacting, but it doesn't provide forShare or forUpdate locking options. Just a few minutes ago I found your comment from this issue. Thanks for sharing the code. \n. @bendrucker or @tgriesser any updates of this issue? It seems weird that this issue has been open for an year now. This is a basic need in any app. Could you provide some information or thoughts related to this issue?\nI would really want to see this feature implemented. I would expect it to be usable e.g. like this:\njavascript\nreturn Model\n.forge({\n    // My other search queries\n    authorId: params.authorId,\n    category: params.category,\n    otherField: params.otherField\n})\n.limit(100)\n.offset(0)\n.fetchAll()\n.then(function(collection) {\n    return collection.toJSON();\n});\nIf you are not planning to implement this, please provide users even an example of how to achieve it with .query()\n. I got my use case working with the following code. Note: the previous examples are not taking transactions into account. .save may be called with {transacting: trx} option and it should be passed to the .refresh() call.\n``` js\nvar bookshelf = Bookshelf(knex);\n// Needed because postgres autogenerates created_at\n// timestamp. Otherwise it wouldn't be returned on model.save().\nvar save = bookshelf.Model.prototype.save;\nbookshelf.Model.prototype.save = function(_, fetchOpts) {\n    return save.apply(this, arguments).then(function(model) {\n        // fetchOpts contains transaction info\n        return model ? model.refresh(fetchOpts) : model;\n    });\n};\n``\n. I got my use case working with the following code. Note: the previous examples are not taking transactions into account. .save may be called with{transacting: trx}` option and it should be passed to the .refresh() call.\n``` js\nvar bookshelf = Bookshelf(knex);\n// Needed because postgres autogenerates created_at\n// timestamp. Otherwise it wouldn't be returned on model.save().\nvar save = bookshelf.Model.prototype.save;\nbookshelf.Model.prototype.save = function(_, fetchOpts) {\n    return save.apply(this, arguments).then(function(model) {\n        // fetchOpts contains transaction info\n        return model ? model.refresh(fetchOpts) : model;\n    });\n};\n``\n. @rhys-vdw Using.query('forUpdate')works fine for me. It will generate an SQL select withFOR UPDATE`. I'm not sure if separate options are needed for this(what this PR provides) but in any case it would be useful to document the locking capabilities of bookshelf too. Knex already has these documented.\n. @rhys-vdw Thanks for the insight. Yes the schema can be cached you are right. I said a bit incorrectly about the validation, I have implemented it so that it is done when 'saving' event is fired.\nI'm just a bit worried why is the initialization called so many times. I didn't investigate it any further but my performance improved ~4x when replacing Bookshelf collection fetching with \"raw\" Knex queries.\n. @rhys-vdw Oh ok. Didn't even realize they'll be converted to models(of course they are) since I'm interested only from the json repr of them. Nope, there was 10 models created and 10 initialize calls.\n. I'll close this one. The solution for me at least: if the models and collections are too much overhead, go with knex queries but remember to still validate your inputs.\n. Ok thanks.\n. I don't yet have any problems but I wanted to know how this is done internally in Bookshelf. I tried to skim through some code but didn't find the place where date attribute is converted to timestamp field for database.\n. Thanks. Looking at the code: typeof moment() is \"object\" which means knex calls JSON.stringify to the object. This doesn't look very good:\n``` javascript\n\nJSON.stringify(moment())\n'\"2015-06-15T11:40:47.369Z\"'\nmoment().toJSON()  // this is what probably should be called\n'2015-06-15T11:40:58.349Z'\n```\n. I'll get back to this at some point. Sorry but have no time to test it in more detail now. I'm not encountering any bug currently. But by looking at the code, it looks like a risk of bug: \n\nIf I don't handle moment objects in  parse function, dates are(or it seems so) be passed to database driver as correct ISO dates but with surrounding quotes. \n. I'll get back to this at some point. Sorry but have no time to test it in more detail now. I'm not encountering any bug currently. But by looking at the code, it looks like a risk of bug: \nIf I don't handle moment objects in  parse function, dates are(or it seems so) be passed to database driver as correct ISO dates but with surrounding quotes. \n. ",
    "jgable": "The use case is for TryGhost/Ghost#1563, we need to try and detect when a Post's status is changed from draft to published in order to set a X-Cache-Invalidate header on the request.\nI'm thinking of listening to the saving and saved listeners and just assigning a this.updatedAttributes or something for comparing.  \nI'll try to report back if that works. \n. I ended up adding the following to our base models and it seems to provide the functionality I'm looking for:\n``` js\nsaving: function (newObj, attr, options) {\n    // Store the previous attributes so we can tell what was updated later\n    this._updatedAttributes = newObj.previousAttributes();\n},\n// Get attributes that have been updated (values before a .save() call)\nupdatedAttributes: function () {\n    return this._updatedAttributes || {};\n},\n// Get a specific updated attribute value\nupdated: function (attr) {\n    return this.updatedAttributes()[attr];\n}\n```\nI couldn't get the options.previousAttributes to work for me, but this approach seems to be working.\n. ",
    "gaastonsr": "This is a bug right? I'm having the same problem, I do:\n```\n/ user has \"jdoe\" as nickname /\nuser.save({\n    nickname: 'updated'\n})\n.then(function(model) {\n    console.log(model.previous('nickname'));\n});\n```\nAnd I get \"updated\", is not supposed to return \"jdoe\"?\n. Do you have a test case so we can help you?\n. Do you have a test case so we can help you?\n. I confirmed a while back that previousAttributes has a bug. I don't know if that claim is still valid. I would recommend you to workaround the problem by saving your attributes before your actions and make use of them later as it they were extracted from previous attributes.\n```\nvar previousAttributes = model.toJSON();\n// your actions\nmodel.update();\n// and later use them\nconsole.log(previousAttributes.email); // old email!\n```\n. I confirmed a while back that previousAttributes has a bug. I don't know if that claim is still valid. I would recommend you to workaround the problem by saving your attributes before your actions and make use of them later as it they were extracted from previous attributes.\n```\nvar previousAttributes = model.toJSON();\n// your actions\nmodel.update();\n// and later use them\nconsole.log(previousAttributes.email); // old email!\n```\n. The problem is the patch number, current version of knex is 0.11.1 and bookshelf expects 0.11.\nCan we update bookshelf so it does not care about updates on the patch number?\n. Seems like this is fixed now.\n. Update to the last version. This should be fixed now.\n. In the save method although we don't have a default value explicitly set it works as if it was true.\nhttps://github.com/bookshelf/bookshelf/blob/dd3f4086f46aa54bc12196c0920b243c8cbe37b5/src/model.js#L1023\nIn the destroy method, require has to be explicitly set to a truth-y value for it to work.\nhttps://github.com/bookshelf/bookshelf/blob/dd3f4086f46aa54bc12196c0920b243c8cbe37b5/src/model.js#L1132\n\nReading the whole model codebase I don't see any default value for options in any method... maybe the docs are misleading?\n\nI think it is and other fellows as myself could be confused.\nI understand that this is a breaking change and existing applications could rely on it so maybe we should update the documentation?. ",
    "austinrivas": "You can actually run bookshelf methods synchronously by using Fibers. I do this extensively in my Meteor applications that access Postgres.\nI use the  npm  meteor package which provide the Async object for Fiber flow control.\nBy wrapping async methods in a Fiber you can call them syncronously like so\ncoffeescript\nif Meteor.isServer\n      # Calling save() persists the model to PostgreSQL\n      # Notice that this only saves the model, not its related models\n      model = new self.model()\n      saveSync = model.saveSync doc\n      unless saveSync.error\n        # calling persist related retrieves the related fields for this document\n        # it then persists the joined document to mongoDB\n        fetchRelatedModel = model.fetchSync withRelated: model.relatedTables\n        unless fetchRelatedModel.error\n          self.meteorCollection.upsert { id: model.id }, { $set: model.toJSON() }\n          self.log \"mongodb:#{ self.getTableName() }:upsert:#{ doc._id }\"\n          # return true signals that the document has been sucessfully persisted\n          # TODO: still returns false because otherwise a duplicate doc is created\n          return false\nThe general pattern is \ncoffeescript\n # wrap Bookshelf to provide syncronous db query methods\n  class BookshelfCollection extends Bookshelf.PostgreSQL.Collection\n    # wraps the asyncronous fetch method to run in a syncronous fiber\n    fetchSync: ( options ) ->\n      self = @\n      if Meteor.isClient\n        self.error \"BookshelfModel.fetchSync() can only be called on the server.\"\n      if Meteor.isServer\n        # Async is provided by arunoda's awesome `npm` package\n        # runSync blocks this fiber until execution is complete\n        Async.runSync ( done ) ->\n          # call the original Bookshelf.fetch method\n          self.fetch( options )\n          # terminate the fiber when Bookshelf.fetch's promise returns\n          .then ( result, error ) ->\n              # handle errors in the promise\n              if error\n                self.error \"#{ self.model.getTableName() }:collection:fetch:error\", error\n              # done terminates the fiber and returns to the syncronous method\n              done error, result\n. @bendrucker would you mind elaborating on the post save hook for saving related model? This is currently something I am trying to implement. A link to some code or a quick rundown on the pattern would save me a lot of time bashing my head against the keyboard :)\n. Honestly my use case is pretty unique at the moment. I'm using bookshelf to persist mongoDB documents back to postgresql from the allow hooks in a meteor application, but that example helped a lot, thanks!\n. @gaarf if you are interested in meteor / postgre integration you'll prob find my mediator class useful\n Mediator \n Notification Model Mixin \nPersist Model Mixin\nIt listens for pg notifications signaling when a watched table has changed, and then fires an event that is caught by my bookshelf models, which fetches the fully joined model ( or a mutation of it ) and persists it to mongodb. This lets me use meteor reactivity with pg relational data.\nI also use fibers to run bookshelf methods syncronously source\nLetting me write some code that looks like this\ncoffeescript\nUsers.allow\n  insert: ( userId, doc ) -> \n      # Calling save() persists the model to PostgreSQL\n      # Notice that this only saves the model, not its related models\n      return false unless isAuthorized userId\n      model = new User()\n      saveSync = model.saveSync doc\n      unless saveSync.error\n        # calling persist related retrieves the related fields for this document\n        # it then persists the joined document to mongoDB\n        fetchRelatedModel = model.fetchSync withRelated: model.relatedTables\n        unless fetchRelatedModel.error\n          User.meteorCollection.upsert { id: model.id }, { $set: model.toJSON() }\n          model.log \"mongodb:#{ self.getTableName() }:upsert:#{ doc._id }\"\n          # return true signals that the document has been sucessfully persisted\n          return true\n      return false\nThanks Bookshelf!\n. ",
    "fernandoguedes": "Thanks! This solution worked for me.\n. ",
    "olalonde": "Thanks!\n. Thanks! I think I've made some progress:\n``` javascript\n  initialize: function () {\n    this.validationErrors = {};\n    this.on('saving', this.validate, this);\n  },\nvalidate: function (model, attrs, options) {\n    var self = this;\n    // TODO sync validations\n    return this.validateUniqueUsername()\n      .then(function (validates) {\n        if (!validates) self.validationErrors.username = [ 'exists' ];\n      })\n      .then(function () {\n        return self.validateUniqueEmail();\n      })\n      .then(function (validates) {\n        if (!validates) self.validationErrors.email = [ 'exists' ];\n      })\n      .then(function () {\n        if (Object.keys(self.validationErrors).length) {\n          throw self.validationErrors;\n        }\n      });\n  },\nvalidateUniqueUsername: function (cb) {\n    return User.forge({ username: this.get('username') }).fetch().then(function (existingUser) {\n      if (existingUser) return false;\n      return true;\n    });\n  },\nvalidateUniqueEmail: function (cb) {\n    return User.forge({ email: this.get('email') }).fetch().then(function (existingUser) {\n      if (existingUser) return false;\n      return true;\n    });\n  }\n```\nFeel free to close this issue... It's not really an issue, more like myself taking notes for future reference :) I have a question about the code above though. Would there be an easy way to be able to chain the self.validateUniqueEmail like this?\njavascript\n    return this.validateUniqueUsername()\n      .then(function (validates) {\n        if (!validates) self.validationErrors.username = [ 'exists' ];\n      })\n      .validateUniqueEmail()\n      .then(function (validates) {\n        if (!validates) self.validationErrors.email = [ 'exists' ];\n      })\n      .then(function () {\n        if (Object.keys(self.validationErrors).length) {\n          throw self.validationErrors;\n        }\n      });\nI guess I could perhaps do:\njavascript\n    return this.validateUniqueUsername()\n      .then(function (validates) {\n        if (!validates) self.validationErrors.username = [ 'exists' ];\n      })\n      .then(self.validateUniqueEmail.bind(self))\n      .then(function (validates) {\n        if (!validates) self.validationErrors.email = [ 'exists' ];\n      })\n      .then(function () {\n        if (Object.keys(self.validationErrors).length) {\n          throw self.validationErrors;\n        }\n      });\nOr maybe I should just chain all  my calls at the beginning and call .then only once?\n. Ok great... I wanted to learn a bit more about promises before using checkit :) Thanks for pointing out https://github.com/petkaantonov/bluebird/blob/master/API.md#promisebinddynamic-thisarg---promise and the refactoring.. looks a lot better like this. I will probably ditch my code for checkit now :)\n. Yeah, I was just worried it might conflict with other properties but I guess I can just be careful :+1: \n. Thanks. I'll have a look at hapi and/or ES6.\n. Interesting, I didn't think of using events to customise my save logic. I like your approach. I will try it :)\n. Yes, that's what I was worried about as well (no guaranteed about event order execution). Does save even 'wait' for events to be handled?\nFor now, I just use custom save methods, like saveDeep which saves a model and child models recursively.\nLet's assume the following fictional models:\nBook model has many Author and Author has many Addresses. I implemented a saveDeep method on Book as well as on Author. Book.saveDeep always initiate a transaction because it is never part of a greater transaction. It calls author.saveDeep(t), passing the transaction. However I would also like to be able to call author.saveDeep() from other places in my code which is a bit tedious because I always have to initiate a transaction before doing so and pass it like so: author.saveDeep(t). So I would like saveDeep to use an existing transaction if it is passed as an argument and otherwise to create a new one.\nI haven't tested this code at all but it seems something like this might work:\n``` javascript\nsaveDeep: function (params, opts) {\n  var self = this;\n  // Not part of a greater transaction, initiate one.\n  if (!opts.transacting) {\n    return bookshelf.transaction(function (t) {\n      return self.saveDeep(params, { transacting: t, mustCommit: true });\n    });\n  }\n// this could be save or saveDeep\n  return this.someMethodThatUsesTransaction(params, opts)\n    .then(function () {\n      // do stuff\n    })\n    .then(function () {\n      if (opts.mustCommit) return opts.transacting.commit();\n    }).catch(function () {\n      return opts.transacting.rollback();\n    });\n};\n// Ideally, we want to get rid of the boiler plate code\n// and do something like:\nsaveDeep: optionalTransaction(function (params, opts) {\n  return this.someMethodThatUsesTransaction(params, opts)\n    .then(function () {\n      // do stuff\n    });\n});\n// optionalTransaction could be implemented like this:\nfunction optionalTransaction (fn) {\n  return function boilerplate(params, opts) {\n    var self = this;\n    // Not part of a greater transaction, initiate one\n    // and try again.\n    if (!opts.transacting) {\n      return bookshelf.transaction(function (t) {\n        return boilerplate.apply(self, [ params, { transacting: t, mustCommit: true } ]);\n      });\n    }\n// this could be save or saveDeep\nreturn fn.apply(self, [ params, opts ])\n  .then(function () {\n    if (opts.mustCommit) {\n      return opts.transacting.commit();\n    }\n  })\n  .catch(function () {\n    return opts.transacting.rollback();\n  });\n\n};\n}\n``\n. Thanks for the suggestions and feedback. I will try your solution(s) and report here eventually. :)\n. Oops, I was mistaken, I forgot to add the { transacting: t } option to the paragraph insert. That being said, I'm still wondering about how toset constraintson a transaction. Can I pass the transaction to .raw?\n. Bump. It would be nice if there was something in the docs on using es6 class syntax.\n. Strange, which static functions don't get inherited? Just glanced at the code and couldn't see anything funky. Theextend()method just seems to create a new constructor and copy passed properties to its prototype or directly on the constructor (static functions). Isn't what classChild extends Parentdoes? Also, why do some static function getinherited` while others don't?\n. Ok so my insert looked like this\njavascript\n          User\n            .forge(attrs)\n            .save(null, { transacting })\nThe weird thing is that it would actually insert all the attributes to the database but .on('saving') would just see { updated_at, created_at }.\nI modified the code like this:\njavascript\n          User\n            .forge(attrs)\n            .save(attrs, { transacting })\nAnd now it still works but the .on('saving') callback sees all attributes. I am wondering if there's any way to call .save() with the {transacting} option without having to specify the first argument so that it does a regular .save() but with a transaction.\n. All I can say is I think this is great news. Bookshelf felt like an unmaintained project for a while.. ",
    "nategood": "Might not be a bad idea to make a short reference to the fact that schema migration support exists in the bookshelf README. I too was curious about this and had a hard time tracking it down. Happy to open a PR if its welcome.\n. ",
    "solderjs": "Awesome. I copied over some of my code and sample-fied it:\nhttps://github.com/tgriesser/bookshelf/wiki/Getting-Started\n. I think there's a bug with this. I've got a query where it comes back with lots of relations, but as soon as I .limit(10) comes back with 0 relations for most models.\n. Thanks again!\n. The problem with this approach is that if I switch from SQLite in development to PostgreSQL in production I'm now stringifying when I shouldn't be.\n. Thanks.\nSooner or later I'll get back to the wiki and update with the knex stuff and relation stuff I've learned.\n. I changed the model's idAttribute to the the camelCase name (instead of the db row name) and it now updates instead of doing an insert.\nThis would probably be good to note in the documentation.\n. It turns out this causes bugs with relations too: https://github.com/tgriesser/bookshelf/issues/397\n. oops, I misunderstood the docs. I thought model.changed reflected whether or not the internal hash had changed, but I see now that it's actually the internal hash.\nSeems like Object.keys(model.changed).length is the functional equivalent of isDirty()\n. This is why I should go to bed before 2am... or at least not open issues after that time.\nThanks.\n. Here's my use case:\nEverytime a user logs in with oauth I have to query the logins table using typedUid which is a manual composite of their login id (i.e. 1274648392) and the login provider (i.e. facebook).\nIf it doesn't fetch a record, I create a new one.\nIf the record doesn't have an associated account, I create one of those as well.\nOn the account I'm going to loop through a limited number of fields and set them. 99% of the time it's setting them to the same thing it was already set to (my facebook url probably didn't change, my preferred name probabably didn't change, my facebook email probably didn't change, etc).\nIf I'm creating the account, I'm going to attach() it to the login.\nOn the login I'm going to loop over all of the fields and set them. Most of them actually get stored as a json column called xattrs, but 90% of the time they don't change and the string is the same string and hasChanged() returns false (or at least changed was an empty object).\nAt this point nothing has actually changed most of the time because most of the time it's returning users. But sometimes it's new users. And occasionally the returning user has changed their info.\nThen I want to call save().\nI'm familiar with shortcuts like findOrCreate() and save() that behaves as a noop when nothing has changed. I understand that you don't have tie to code the world and everyone wants a pony, but if you think those are good and practical ideas then, since I have to write the logic anyway, I may figure out enough of framework to do a pull request for that at some point.\nSide question: Is it possible to attach() a new model? It seemed like last night I had to make sure I saved it first.\nIn generally I've just got a lot of new/dirty/exists if-branching that feels (to me) like it belongs in the ORM rather than in the application.\nAnother aside: If you have time for an hour of consulting sometime next week, I'd really like to have you take a look at my code, tell me what I'm doing \"the wrong way\" and explan the \"right way\" to me. I'm imagining that when I'm done with this specific part of my project there will only be 3 tables and maybe 500 lines of actual code.\n. I'm wanting to know which key names correspond to which tables when using hasMany().through(). I was getting some really weird query results and \"column doesn't exist\" errors that didn't make sense.\nI'm not understanding why a primary key on the join table matters. If it's a many-to-many, it doesn't seem like you would use the primary key except to update columns in the join table.\nI guess it doesn't matter that much though. Now that I figured out that I was supposed to be using belongsToMany() for the many-to-many rather than hasMany().through() my code works.\n. My guess was wrong... digging deeper...\n. Alright, I've got something that works, I'll update the wiki.\n. That works for me. :-)\n. FYI: related('schedule') is returning undefined.\n. I double checked for typos.\n``` javascript\n  var Orm = require('bookshelf').initialize(knex)\n    , Db = {}\n    ;\nDb.Schedules = Orm.Model.extend({\n    tableName: 'schedules'\n  , idAttribute: 'id'\n  , hasTimestamps: ['createdAt', 'updatedAt']\n  , format: function (attrs) {\n      if ('text' === schedColumns.xattrs.type) {\n        //attrs.xattrs = JSON.stringify(attrs.xattrs);\n        attrs = zipXattrs('xattrs', toCamelCaseArr(Object.keys(schedColumns)), 'text')(attrs);\n      } else {\n        attrs = zipXattrs('xattrs', toCamelCaseArr(Object.keys(schedColumns)), 'json')(attrs);\n      }\n      Object.keys(schedColumns).forEach(function (key) {\n        if ('datetime' === schedColumns[key].type) {\n          if (!attrs[key]) {\n            return;\n          }\n          if ('number' === typeof attrs[key]) {\n            attrs[key] = new Date(attrs[key]).toISOString();\n          }\n          if ('object' === typeof attrs[key]) {\n            attrs[key] = attrs[key].toISOString();\n          }\n        }\n      });\n      if ('text' === schedColumns.event.type) {\n        attrs.event = JSON.stringify(attrs.event);\n      }\n      return attrs;\n    }\n    // parse while retrieving\n  , parse: function (attrs) {\n      if ('text' === schedColumns.xattrs.type) {\n        //attrs.xattrs = JSON.parse(attrs.xattrs);\n        attrs = inflateXattrs('xattrs')(attrs);\n      } else {\n        attrs = inflateXattrs('xattrs')(attrs);\n      }\n      if ('text' === schedColumns.event.type) {\n        attrs.event = JSON.parse(attrs.event);\n      }\n      attrs.xattrs = attrs.xattrs || {};\n      return attrs;\n    }\n  });\nDb.Appointments = Orm.Model.extend({\n    tableName: 'appointments'\n  , idAttribute: 'id'\n  , hasTimestamps: ['createdAt', 'updatedAt']\n  , schedule: function () {\n      this.belongsTo(Db.Schedules, 'schedule_id');\n    }\n  , format: zipXattrs('xattrs', toCamelCaseArr(Object.keys(apptColumns)))\n  , parse: inflateXattrs('xattrs')\n  });\n```\n. Hmmm... does the return make a difference? I'm pretty sure I've left out the return in other places and had it work, but I added it and now things seem to work more as expected.\njavascript\n  , schedule: function () {\n      return this.belongsTo(Db.Schedules, 'schedule_id');\n    }\n. Ok, I'll make note of that.\n. It turns out that the place it was working was after appt had been saved.\nI still have the same problem before it's saved:\njavascript\nconsole.log(\"appt.related('schedule')\");\nconsole.log(appt.related('schedule'));\nappt.related('schedule').attach(schedule)\njavascript\n{ attributes: {},\n  _previousAttributes: {},\n  changed: {},\n  relations: {},\n  cid: 'c4',\n  relatedData:\n   { type: 'belongsTo',\n     target:\n      { [Function]\n        super_: [Object],\n        collection: [Function],\n        forge: [Function],\n        where: [Function],\n        query: [Function],\n        fetchAll: [Function],\n        extend: [Function],\n        __super__: [Object] },\n     targetTableName: 'schedules',\n     targetIdAttribute: 'id',\n     foreignKey: 'schedule_id',\n     parentId: undefined,\n     parentTableName: 'appointments',\n     parentIdAttribute: 'id',\n     parentFk: undefined } }\n[TypeError: Object [object Object] has no method 'attach']\n. But that related('schedule') is empty (see no attributes). How can I tell it to use the schedule instance that's already loaded instead of fetching it again?\nI create a NEW appointment object.\nI have the parent schedule object in scope.\nI don't want to fetch/load the schedule object, I already have it. I just want to say \"Oh, and here's your schedule object\".\n. has this been fixed? I think it just bit me too.\nis there a workaround?\n. I'm hitting the same issue\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ '47869dedc01dda5aaa3ba826b9fbd6bf', 1 ],\n  sql: 'select \"logins\".* from \"logins\" where \"logins\".\"typed_uid\" = ? limit ?' }\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ undefined ],\n  sql: 'select \"accounts\".*, \"accounts_logins\".\"login_typed_uid\" as \"_pivot_login_typed_uid\", \"accounts_logins\".\"account_uuid\" as \"_pivot_account_uuid\" from \"accounts\" inner join \"accounts_logins\" on \"accounts_logins\".\"account_uuid\" = \"accounts\".\"uuid\" where \"accounts_logins\".\"login_typed_uid\" in (?)' }\nIf I run the query manually I get back a result:\nselect \"logins\".* from \"logins\" where \"logins\".\"typed_uid\" = '47869dedc01dda5aaa3ba826b9fbd6bf' limit 1;\nSame if I insert the ID manually, I get back a result\nselect \"accounts\".*, \"accounts_logins\".\"login_typed_uid\" as \"_pivot_login_typed_uid\", \"accounts_logins\".\"account_uuid\" as \"_pivot_account_uuid\" from \"accounts\" inner join \"accounts_logins\" on \"accounts_logins\".\"account_uuid\" = \"accounts\".\"uuid\" where \"accounts_logins\".\"login_typed_uid\" in ('47869dedc01dda5aaa3ba826b9fbd6bf');\nAnd here's my code:\nDB.Logins\n      .forge({ typedUid: Logins.getTypedUid(loginObj) })\n      .fetch({ withRelated: ['accounts'] })\n      .then(function (login) {\n        console.log(login.related('accounts').length); // 0\n      })\n{ idAttribute: 'typedUid'\n  , accounts: function () {\n      return this.belongsToMany(Db.Accounts, 'accounts_logins', 'login_typed_uid', 'account_uuid');\n    }\n    // format before saving\n  , hasTimestamps: ['createdAt', 'updatedAt']\n  }\nIt should be noted that I snake-ify on format (from model to db) and camel-ize on parse (from db to model)\n. I'm hitting the same issue\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ '47869dedc01dda5aaa3ba826b9fbd6bf', 1 ],\n  sql: 'select \"logins\".* from \"logins\" where \"logins\".\"typed_uid\" = ? limit ?' }\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ undefined ],\n  sql: 'select \"accounts\".*, \"accounts_logins\".\"login_typed_uid\" as \"_pivot_login_typed_uid\", \"accounts_logins\".\"account_uuid\" as \"_pivot_account_uuid\" from \"accounts\" inner join \"accounts_logins\" on \"accounts_logins\".\"account_uuid\" = \"accounts\".\"uuid\" where \"accounts_logins\".\"login_typed_uid\" in (?)' }\nIf I run the query manually I get back a result:\nselect \"logins\".* from \"logins\" where \"logins\".\"typed_uid\" = '47869dedc01dda5aaa3ba826b9fbd6bf' limit 1;\nSame if I insert the ID manually, I get back a result\nselect \"accounts\".*, \"accounts_logins\".\"login_typed_uid\" as \"_pivot_login_typed_uid\", \"accounts_logins\".\"account_uuid\" as \"_pivot_account_uuid\" from \"accounts\" inner join \"accounts_logins\" on \"accounts_logins\".\"account_uuid\" = \"accounts\".\"uuid\" where \"accounts_logins\".\"login_typed_uid\" in ('47869dedc01dda5aaa3ba826b9fbd6bf');\nAnd here's my code:\nDB.Logins\n      .forge({ typedUid: Logins.getTypedUid(loginObj) })\n      .fetch({ withRelated: ['accounts'] })\n      .then(function (login) {\n        console.log(login.related('accounts').length); // 0\n      })\n{ idAttribute: 'typedUid'\n  , accounts: function () {\n      return this.belongsToMany(Db.Accounts, 'accounts_logins', 'login_typed_uid', 'account_uuid');\n    }\n    // format before saving\n  , hasTimestamps: ['createdAt', 'updatedAt']\n  }\nIt should be noted that I snake-ify on format (from model to db) and camel-ize on parse (from db to model)\n. I changed \nreturn this.belongsToMany(Db.Accounts, 'accounts_logins', 'login_typed_uid', 'account_uuid');\nto\nreturn this.belongsToMany(Db.Accounts);\nand got this error\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ undefined ],\n  sql: 'select \"accounts\".*, \"accounts_logins\".\"login_typedUid\" as \"_pivot_login_typedUid\", \"accounts_logins\".\"account_uuid\" as \"_pivot_account_uuid\" from \"accounts\" inner join \"accounts_logins\" on \"accounts_logins\".\"account_uuid\" = \"accounts\".\"uuid\" where \"accounts_logins\".\"login_typedUid\" in (?)' }\nPossibly unhandled Error: SQLITE_ERROR: no such column: accounts_logins.login_typedUid\nThat seems to suggest that format isn't being called on the appropriate field before it's translated to the database.\nI changed typedUid / typed_uid to hashid (since it deserved a name change anyway) and I'm getting a different error now... I'll have to investigate further.\n. I changed \nreturn this.belongsToMany(Db.Accounts, 'accounts_logins', 'login_typed_uid', 'account_uuid');\nto\nreturn this.belongsToMany(Db.Accounts);\nand got this error\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ undefined ],\n  sql: 'select \"accounts\".*, \"accounts_logins\".\"login_typedUid\" as \"_pivot_login_typedUid\", \"accounts_logins\".\"account_uuid\" as \"_pivot_account_uuid\" from \"accounts\" inner join \"accounts_logins\" on \"accounts_logins\".\"account_uuid\" = \"accounts\".\"uuid\" where \"accounts_logins\".\"login_typedUid\" in (?)' }\nPossibly unhandled Error: SQLITE_ERROR: no such column: accounts_logins.login_typedUid\nThat seems to suggest that format isn't being called on the appropriate field before it's translated to the database.\nI changed typedUid / typed_uid to hashid (since it deserved a name change anyway) and I'm getting a different error now... I'll have to investigate further.\n. Fixed.\n. Fixed.\n. squash?\n. squash?\n. squashed, I think.\n. squashed, I think.\n. normal behavior\n```\n\nvar d = new Date()\nundefined\nd.toJSON()\n'2014-08-07T20:48:08.842Z'\nJSON.stringify(d)\n'\"2014-08-07T20:48:08.842Z\"'\n```\n\nactual behavior\n```\nMyModel.forge().fetch().then(function (myModel) {\n  console.log(JSON.stringify(myModel.toJSON()));\n});\n{ created: {}\n, name: \"joe\"\n, touched: {}\n}\n```\nworkaround\n```\nMyModel.forge().fetch().then(function (myModel) {\n  var json = myModel.toJSON()\n    ;\n['created', 'touched'].forEach(function (key) {\n    json[key] = json[key].toJSON()\n  });\nconsole.log(JSON.stringify(json));\n{ created: '2014-08-07T20:48:08.842Z'\n  , name: \"joe\"\n  , touched: '2014-08-07T20:48:08.842Z'\n  }\n});\n```\n. In PostgreSQL there are two date types - with and without timezone. Maybe the PG layer has a custom date object for the one with timezone?\nbookshelf v0.7.7\nknex v0.6.22\nI think I actually called json[k] = json[k].toISOString() and not json[k] = json[k].toJSON() I'll have to go back and check.\n. Here's a direct snippet:\n```\nvar json\n  ;\nfoobar.related('bazs').some(function (baz) {\n  console.log(baz.get('time_start'));\n  console.log(baz.get('time_start').toJSON);\n  console.log(baz.get('time_start').toJSON.toString());\n  console.log(JSON.stringify(baz.toJSON()));\n  return true;\n});\njson = foobar.toJSON();\njson.bazs.forEach(function (baz) {\n  ['last_updated', 'created'].forEach(function (k) {\n    baz[k] = baz[k] && baz[k].toISOString();\n    baz[k + '0'] = baz[k] && baz[k].toJSON();\n    baz[k + '1'] = baz[k];\n  });\n});\nres.send(json);\n```\nMon Jun 14 2027 13:00:00 GMT-0700 (PDT)\n[Function: toJSON]\nfunction toJSON() { [native code] }\n{... \"created\":\"2014-06-17T00:40:52.979Z\",\"last_updated\":\"2014-06-17T22:23:29.901Z\",\"duration\":{}...}\nPossibly unhandled TypeError: Object 2014-06-02T00:00:00.000Z has no method 'toJSON'\n. And postgres says\ncreated              | timestamp without time zone | not null default now()\n last_updated         | timestamp without time zone | not null default now()\n duration             | interval                    | default '00:00:00'::interval\n. So before calling .toJSON it is a date object, but after calling .toJSON it is .... ??!?!? a string object that stringifies to an empty object?!?!\n. that's when I stringify the bookshelf model\nwhen I stringify the result of toJSON it comes out weird\njust a sec...\n. I was mistaken.\nThere's a deepCopy function that is called in an override to res.send and the deepCopy is the the thing doing the 'object' === typeof check incorrectly.\n::ashamed::\n. +1\nI've run into the same problem and ended up doing a custom FooModel.collection().query(function (qb) { ... }) to solve it.\n. +1\nI've run into the same problem and ended up doing a custom FooModel.collection().query(function (qb) { ... }) to solve it.\n. I'll have to double check with parse to make sure that the duration isn't coming in as a date instead of a string and then getting copied in a naive way (which would have the same symptom).\n. I'll have to double check with parse to make sure that the duration isn't coming in as a date instead of a string and then getting copied in a naive way (which would have the same symptom).\n. P.S. I do see that it says .through(JoinModel, [throughFk], [otherKey]), but that's still not clear to me without some example relation as context.\n. P.S. I do see that it says .through(JoinModel, [throughFk], [otherKey]), but that's still not clear to me without some example relation as context.\n. But then when it saves, it would save to a different id, right?\nUPDATE id = xyz WHERE id = old_id\n. But then when it saves, it would save to a different id, right?\nUPDATE id = xyz WHERE id = old_id\n. ",
    "sandrocsimas": "OK @bendrucker, thanks you for the response\n. OK, you are right. I reviewed my code and i'm wrong, sorry.\nI will close this issue.\n. Sorry for the noob question, rs.\ninstanceof Bookshelf.Collection is the answer\n. Ok, i remembered what i needed. The fetch always make a select with where clause including all attributes.\n@bendrucker, is there a way to make a fetch only selecting the model by id?\nActually i need to create another model with the current id.\nUser.forge({id: user.id}).fetch().then(function(userFetched) {\n  // Some code here...\n});\n. @demisx, look at this plugin i created: https://github.com/sandro-csimas/bookshelf-filteration\n. @demisx, look at this plugin i created: https://github.com/sandro-csimas/bookshelf-filteration\n. js\nexports.removePlace = function(user, place) {\n  return new Promise(function(resolve, reject) {\n    entities.requestTransaction(null, function(transaction) {\n      return $.getPlace(place.id).bind({}).then(function(place) {\n        this.place = place.clone();\n        var circle = Circle.forge({id: place.get('circle_id')});\n        return getMemberPermission(circle, user);\n      }).then(function(permission) {\n        if(neitherOwnerNorAdmin(permission)) {\n          throw messages.apiError('place.remove.noPermission', 'User has no permission to remove the place.');\n        }\n        return UserActivity.where({place_id: place.id}).save({place_id: null, parameters: JSON.stringify({place_name: this.place.get('name')})}, {method: 'update', patch: true, transacting: transaction});\n      }).then(function() {\n        return place.destroy({transacting: transaction});\n      }).then(function() {\n        cache.removePlacePosition(this.place).catch(function(err) {\n          logger.error('Error removing place %d from cache.', this.place.id, err);\n        });\n        activities.placeRemoved(this.place).catch(function(err) {\n          logger.error('Error creating an user activity of \"place %d removed\".', this.place.id, err);\n        });\n        return;\n      });\n    }).then(function() {\n      resolve();\n    }).catch(messages.APIError, function(err) {\n      reject(err);\n    }).catch(function(err) {\n      console.log(err.stack)\n      console.log(err)\n      reject(messages.apiError('place.remove.error', 'Error removing place.', err));\n    });\n  });\n};\n. Before i delete the place, i need to update all UserActivity rows because user_activity table has a foreign key to place table.\n. I want to execute for example\nupdate user_activity set parameters = '{place_name: \"Home\"}', place_id = null where place_id = 2;\n. @rhys-vdw, the query is generated correctly, but even with require false, the error is throwed. There is no user_activity with place_id 2, but this is an excpected behavior. I know that save does not save in bulk, but he generated the correct update.\nI will try your code. Thanks!\nUPDATE: Your code works fine!!!\n. @tgriesser, what do you think ahout the code i mentioned? It is valid?\nUserActivity.where({place_id: place.id}).save({place_id: null, parameters: JSON.stringify({place_name: this.place.get('name')})}, {method: 'update', patch: true, transacting: transaction});\nThis code generated the correct query.\n. I have a similar code that uses destroy. Even with no registers to delete, its working.\nreturn InvitedInformation.where({invitation_id: invitation.id}).destroy({transacting: transaction});\n. Hi @rhys-vdw, i asked to @tgriesser because this can be an improvment to bookshelf. I think it will be nice to execute an update this way.\nThe update updates no rows, but i note that when the method is update, the error is only throwed if require is not false. What i've missing? I pass require false and the error is throwed anyway.\n} else if (method === 'update' && resp === 0) {\n    if (options.require !== false) {\n        throw new this.constructor.NoRowsUpdatedError('No Rows Updated');\n    }\n}\n. I post all the function in the previous comments. \nreturn UserActivity.where({place_id: place.id}).save({place_id: null, parameters: JSON.stringify({place_name: this.place.get('name')})}, {method: 'update', patch: true, transacting: transaction});\nAdding require: false here is not working.\nThe testcase you mentioned it has an ID setted. In my case i'm making an update with where clause.\n. @bsiddiqui, I try again with require: false and it's working, I don't know what happened. I may have made a mistake or started to work after update the bookshelf version. I will close this question.\n. @rhys-vdw, i remove the {transacting: transaction} purposely to demonstrate the error. The problem is that the circle already exists (has an id), in this case i just want to update the circle inside a transaction and create a new user_activity associated with no transaction. I know this logic does not make sense, but i think it should be work.\nIn my opinion the first update (with transaction) would be commited only if the second save (without transaction) is resolved.\n. @rhys-vdw, i remove the {transacting: transaction} purposely to demonstrate the error. The problem is that the circle already exists (has an id), in this case i just want to update the circle inside a transaction and create a new user_activity associated with no transaction. I know this logic does not make sense, but i think it should be work.\nIn my opinion the first update (with transaction) would be commited only if the second save (without transaction) is resolved.\n. @ricardograca, i want to do the update (first save) in a transaction and the insert (second save) with no transaction. When the insert (second save) happens, the program locks.\nThis line is executed:\nreturn circle.save(null, {scenario: 'edition', transacting: transaction});\nWhen reach this line, the program does not proceed:\nreturn UserActivity.forge({circle_id: circle.id, user_id: user.id, type: 'circle_updated', particular: 0, occurrence_date: new Date()}).save();\nBut when i set the transacting options, works fine. My question is why is not working with the transacting option (the program remains in this line forever). \nI'm using MySQL. This is an expected behavior?\n. @rhys-vdw, this line locks the program:\nreturn UserActivity.forge({\n        circle_id: circle.id,\n        user_id: user.id,\n        type: 'circle_updated',\n        particular: 0,\n        occurrence_date: new Date()\n      }).save();  // No transaction\nThis save does not require any information from the previous update. It only uses an existent id in of circle.id. Why this line is blocking the promise?\nI mentioned that this code doesn't make sense because the correct is to use transaction in this save, but when i was evolving the code, this happened.\nThis is what i'm trying to understand.\n. Yes!! Sorry for my english!\nThe promise is never solved. UserActivity.forge({...}).save(); is never solved when the first save has the transacting option.\n. ",
    "babsonmatt": "@johanneslumpe I follow what you are saying, and my SocialLogin does have a user_id field as expected, problems are arising when I attempt to make changes to a user object obtained from a relationship with a SocialLogin (it's attempting to update user_id on user table) when I update and call save on the user object.\nPerhaps I'm misunderstanding, but I'm not sure why user_id is being inserted in the UPDATE statement for the user model.  If I obtain a user object directly (new User) updating works just fine, only when I obtain the user from the SocialLogin model does this problem arise.\n. @bendrucker Correct, when I obtain a user from SocialLogin, as in my original post, the attempt to save the user object results in Error: ER_BAD_FIELD_ERROR: Unknown column 'user_id' in 'field list' on the user table.\nI can't debug right this moment but when I'm able to this evening I'll definitely follow up.\nThanks for your help.\n. I put together a really quick example that demonstrates the issue I'm having here.\n```\nBookshelf = require 'bookshelf'\ndb = Bookshelf.db = Bookshelf.initialize\n  client: \"mysql\"\n  connection:\n    host: \"127.0.0.1\"\n    user: \"matt\"\n    password: \"password\"\n    database: \"db\"\n    charset: \"UTF8_GENERAL_CI\"\nBaseModel = db.Model.extend\n  hasTimestamps: true\nUser = BaseModel.extend\n  tableName: 'user'\nsocial_login: ->\n    @hasOne SocialLogin\nSocialLogin = BaseModel.extend\n  tableName: 'social_login'\n# doesn't work\n  user: ->\n    @belongsTo User\n# works\n  # user: ->\n  #   @belongsTo User, 'id'\nnew SocialLogin(id: 1).fetch(withRelated: 'user').then (social_login) ->\n  user = social_login.related 'user'\n  user.set 'points', 5000\n  user.save()\n```\nThe save call results in the following:\nPossibly unhandled Error: ER_BAD_FIELD_ERROR: Unknown column 'user_id' in 'field list', sql: update `user` set `created_at` = ?, `deleted_at` = ?, `earned_points` = ?, `email` = ?, `first_name` = ?, `id` = ?, `last_name` = ?, `organization_id` = ?, `points` = ?, `updated_at` = ?, `user_id` = ?, `username` = ? where `id` = ?\nModifying the user relationship on the SocialLogin model to the following (adding the foreign key as 'id') seems to resolve the issue... no idea why, as the social_login table has a user_id column, and the user table has primary key 'id'.\nuser: ->\n  @belongsTo User, 'id\nHopefully this isn't just some silly mistake on my end, I appreciate everyone's time.\n. No prob, and I didn't realize that @tgriesser, thanks for the suggestion\n. @bendrucker, just confirming that related user does have an id property\n. My example might have been a little too simple, I'm trying to actually introduce it somewhere in the following query:\n```\nUser.query(function (q) {\n        q.distinct()\n            .innerJoin('orders', function () {\n                this.on('users.id', '=', 'orders.user_id')\n                    .andOn('orders.amount', '>', 100);\n            })\n            .innerJoin('addresses', function () {\n                this.on('users.id', '=', 'addresses.user_id')\n                    .andOn('addresses.state', '=', 'New York');\n            });\n    })\n    .fetchAll({ withRelated: ['orders', 'addresses'] })\n    .then(function (users) {\n});\n\n```\nIs it at all possible to do that?  If you don't mind, could you also explain how I could count the above query as well as an alternative?\nMuch appreciated!\n. this.constructor.prototype.tableName maybe?\n. Hey @rhys-vdw, thanks for taking the time to help out.  I gave what you said above a shot, but oddly enough this is what happens:\nbindings: [ 13450, 13450 ]\nsql: 'select \"atoms_edges\".* from \"atoms_edges\" where \"dest\" = $1 and \"atoms_edges\".\"src\" in ($2)'\nFor some reason it appears to ignore the 'orWhere' and uses an 'and'\nAny ideas? Thanks!\n. Seems like it wont accept an orWhere without a where, 'or' is preserved if I chain a 2nd .orWhere.\nIs there a way to move the .orWhere clause to appear after the initial \"atoms_edges\".\"src\" in ($2) or way to override the 'and' to an 'or' being auto inserted by the hasMany?\n. Thanks a lot for the help @rhys-vdw, much appreciated!\n. @rhys-vdw I ended up using knex.raw and row_number() / rank() along with partition by with postgresql\nExample from postgresql docs:\nsql\nSELECT depname, empno, salary, enroll_date\nFROM\n  (SELECT depname, empno, salary, enroll_date,\n          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos\n     FROM empsalary\n  ) AS ss\nWHERE pos < 3;\n. @rhys-vdw I ended up using knex.raw and row_number() / rank() along with partition by with postgresql\nExample from postgresql docs:\nsql\nSELECT depname, empno, salary, enroll_date\nFROM\n  (SELECT depname, empno, salary, enroll_date,\n          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos\n     FROM empsalary\n  ) AS ss\nWHERE pos < 3;\n. ",
    "russplaysguitar": "thanks!!\n. ",
    "lancecarlson": "@tgriesser I'm not sure how you handle composite keys here... withPivot will allow you to pull more columns out from your associative table but it is not generating multiple on's in my join.\n. @eltonk Why don't you create all of the fields your table that you need and then update the field in your table after you've received the download URL from Amazon S3? Are you trying to make an S3 upload plugin? \n. ",
    "akonyushevskiy": "Any progress on this?. ",
    "mickhansen": "@simg Any resources/benchmarks for performance improvements with arrays over join tables/foreign keys - and how do they fare if you need to do reverse lookups too?\n. @tgriesser Not something i've previously given any thought, but i like the idea. Especially if it could eventually be expanded into an ecosystem of helpers (i.e. possible diffing against database tables)\nI would definitely like to help work on a standard. Ideally also look at getting it integrated into Sequelize, but time will tell whether that works out, we are currently looking at decoupling model definitions and connection a model to a database instance.\nI would like to see the schema files be as database agnostic as possible, rather than SQL types directly (also help with general inference rather than string parsing).\nIt would not necessarily have to be a schema break in either project, new methods could be added to load definitions from .schema files (or whatever convention we end up with).\nLooking forward to a good discussion, i'm really happy with @tgriesser reaching out, there's definitely room with both projects (seeing as we have quite different approached to query apis, which cater to different user wants).\n. @tgriesser Not something i've previously given any thought, but i like the idea. Especially if it could eventually be expanded into an ecosystem of helpers (i.e. possible diffing against database tables)\nI would definitely like to help work on a standard. Ideally also look at getting it integrated into Sequelize, but time will tell whether that works out, we are currently looking at decoupling model definitions and connection a model to a database instance.\nI would like to see the schema files be as database agnostic as possible, rather than SQL types directly (also help with general inference rather than string parsing).\nIt would not necessarily have to be a schema break in either project, new methods could be added to load definitions from .schema files (or whatever convention we end up with).\nLooking forward to a good discussion, i'm really happy with @tgriesser reaching out, there's definitely room with both projects (seeing as we have quite different approached to query apis, which cater to different user wants).\n. ",
    "daliwali": "I just stumbled upon this thread while searching for \"array foreign key\". There is an implementation which uses foreign key arrays. However, like others have mentioned in this thread, it lacks a true foreign key constraint. This is worked around by the higher level implementation doing related updates, ensuring referential integrity but at the application level.\n. I just stumbled upon this thread while searching for \"array foreign key\". There is an implementation which uses foreign key arrays. However, like others have mentioned in this thread, it lacks a true foreign key constraint. This is worked around by the higher level implementation doing related updates, ensuring referential integrity but at the application level.\n. ",
    "garkin": "This is a must have optimization feature.\n. ",
    "ryanfmurphy": "That's very interesting, I've been wondering what the performance impacts would be of using arrays for *-to-many relationships.\n. ",
    "wjagodfrey": "So where does this leave us? With no way of implementing this functionality? There is clearly a desire to have it. My usecase is a migration of several tens of millions of high-demand articles from a legacy system, which uses this kind of relationship in at least one place. I don't really want to be hacking around with my ORM to get this behaviour working without a join table.\n. I can respect your stance, but I linked to an issue that other users are\nstruggling with along with a description of one of the relationships -\npostgres int array foreign keys.\nI'm talking about database queries. Bookshelf just simply cannot do certain\nthings. Given one of the first things you see on the homepage is \"you can\ndrop down to knex where needed\", I'm disappointed this behaviour doesn't\nexist. If it does then I retract this sentiment. I agree that web API requests\nare out of scope, but this is not that.\nOn Aug 23, 2016 11:04 AM, \"Jordan Sexton\" notifications@github.com wrote:\n\nWhat are these \"requests\"? Are they web requests? What data are you\nreferring to? What do any of this have to do with an ORM?\nThere is not nearly enough detail to tell what you're looking for a\nsolution to, but on face it sounds like it's out of scope for any ORM\nanyway. While I appreciate that you're frustrated and in a hurry, nothing\nin this issue appears to be an issue with Bookshelf, and there's a lot that\nseems specific to your use case. If you need to manipulate data\nasynchronously before handing it to your model, you can do that. It sort of\nsounds like you need some custom business logic around handling your data,\nbut this isn't obviously the domain of an ORM.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1353#issuecomment-241577704,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AFd5UKbv9JHBJMAmr2g7uDQ5z2IcuyUQks5qiirjgaJpZM4JqWdb\n.\n. If you look at what I'm saying, I'm not asking for postgres foreign key arrays to be supported by Bookshelf.\n\nI would say that a small number of people using them is still a \"clear\" desire for them, no matter how small that number is.\nI've seen that issue. I'm not in a position to modify the migration database, and I need access to a foreign key in a row on the primary table. I may be able to write this in sql without first extracting the foreign key from an initial request, but there doesn't seem to be a nice way of integrating this into a model, have it implicitly called on fetch, and have it feed into the primary model's parse method. Leaves me with two layers of remapping.\nIf you can show me a way to:\n- run arbitrary queries, either through Bookshelf or knex, every time a model is fetched\n- give these queries access to the response of the initial query\n- have the result appended to the Bookshelf result in the same way that related attributes currently are\n- but have the complete result passed to the parse method of the model (unlike related attributes)\nThen I will be happy.\nNot that I mind. I have a solution that works. It is just not as tidy as it ideally would be.\n. Very nice, thank you for the help @jordansexton \n. It actually believe it will. I can move my logic wholesale into the fetched event. Cheers! Fingers crossed.\n. ",
    "SohumB": "That would be nice! So should I work on the second simpler PR, then, to split the synchronous and asynchronous bits of Sync() apart?\n. I can't even manage to run the tests - the require('bookshelf') calls in test/integration.js fail. npm linking doesn't help, so I'm out of ideas.\n. Nope, linux.\n. It does indeed.\n```\n% npm test\n\nbookshelf@0.7.6 test /home/sohum/versioned/bookshelf\nmocha -b -t 5000 --check-leaks -R spec test/index.js\n\nmodule.js:340\n    throw err;\n          ^\nError: Cannot find module 'bookshelf'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n    at Module.require (module.js:364:17)\n    at require (module.js:380:17)\n    at module.exports (/home/sohum/versioned/bookshelf/test/integration.js:23:15)\n    at Suite. (/home/sohum/versioned/bookshelf/test/index.js:52:27)\n    at context.describe.context.context (/home/sohum/versioned/bookshelf/node_modules/mocha/lib/interfaces/bdd.js:74:10)\n    at Object. (/home/sohum/versioned/bookshelf/test/index.js:51:1)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Module.require (module.js:364:17)\n    at require (module.js:380:17)\n    at /home/sohum/versioned/bookshelf/node_modules/mocha/lib/mocha.js:172:27\n    at Array.forEach (native)\n    at Mocha.loadFiles (/home/sohum/versioned/bookshelf/node_modules/mocha/lib/mocha.js:169:14)\n    at Mocha.run (/home/sohum/versioned/bookshelf/node_modules/mocha/lib/mocha.js:356:31)\n    at Object. (/home/sohum/versioned/bookshelf/node_modules/mocha/bin/_mocha:366:16)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Function.Module.runMain (module.js:497:10)\n    at startup (node.js:119:16)\n    at node.js:906:3\nnpm ERR! Test failed.  See above for more details.\nnpm WARN This failure might be due to the use of legacy binary \"node\"\nnpm WARN For further explanations, please read\n/usr/share/doc/nodejs/README.Debian\nnpm ERR! not ok code 0\n```\n. And we're up and running! (Well, except for #426.) Thanks. I'm surprised you guys didn't run into this problem before...\nSo yeah, refreshEntireModel and disableImplicitReturning. Thoughts?\n. It absolutely is, yea. I suspect it's just some different code path/optimisation fence on my local postgres, and your tests probably should either specify or not depend on object order in arrays.\n. I'm happy to write the query, but it'd be nice to have an interface and a canonical place to put that query in, so that it works as a regular Relation, feeding into withRelated and etc. \nThe use case here is that this is effectively a three-way join table, between users, groups, and venues. Users can be assigned groups at venues. Users can also just be assigned groups for the null venue, which is interpreted as for all venues.\nEven barring that latter wrinkle, what would be the best way of handling an n-way join table in Bookshelf?\n. ",
    "meekr": "Below is my config, thanks!\nBookshelf.initialize({\n            client: 'mysql',\n            connection: {\n                host    : '127.0.0.1',\n                user    : 'root',\n                password: 'xxxxxxxx',\n                database: 'evclub-db',\n                charset : 'utf8'\n            },\n            debug: false\n        });\n. Anyway, I ran 2 instances of node projects, one with bookshelf 0.6.1, the other with 0.6.10. Since gibberish characters stored in database can be read properly via models, so I let one instance read data out and post it the other instance, which store the characters correctly.\n. mysql Ver 14.14 Distrib 5.1.73, for redhat-linux-gnu\nI tried versions of bookshelf, with 0.6.6 saving Chinese character in database with correct encoding, with 0.6.5 or version below saving Chinese character in database as un-readable.\n. Sorry, it's defined as 2.1.0 in package.json.\n. Yes, same in both projects. 2.1.0 is the actual version installed, as \"npm list mysql\" displays.\n. Thank you any way, at least I did correct the encoding via additional coding to save old data.\nOne more info, I setup up https://github.com/TryGhost/Ghost, version 0.4.1, on my mac months ago, and Chinese characters stored in mysql database were all gibberish. Thanks!\n. ",
    "aanfuso": "Thank you very much, I've tried like 5 adapters and all were doing weird stuff, when I finally found bookshelf I thought it was similar to the others. All up and working now. \nThanks and sorry for the stupid question.\n. ",
    "rickharrison": "Thanks, appreciate that. Just to confirm, is it ok if I pass in something that is not falsy? I.E. hashPassword: true\n. +1 - I need this. Thanks!\n. My end goal is to get just the items. Wouldn't that result in a list of tags with associated items, and thus, an item could appear more than once in the list?\n. My target query is this:\nSELECT DISTINCT items.* FROM items JOIN items_tags ON items.id = items_tags.item_id JOIN tags on items_tags.tag_id = tags.id WHERE tags.name IN ('foo', 'bar') ORDER BY items.id ASC;\nShould I just avoid bookshelf and run this through knex?\n. Cool, this is what I have now ended up with:\n```\nvar model = ItemModel.forge();\nvar query = model.query()\n  .innerJoin('items_tags', 'items.id', 'items_tags.item_id')\n  .innerJoin('tags', 'items_tags.tag_id', 'tags.id')\n  .groupBy('items.id')\n  .orderBy('items.id', 'asc');\nif (tags && tags.length > 0) {\n  query = query.whereIn('tags.name', tags).where(function () {\n    this.where('tags.condition', true);\n    this.orWhere('tags.otherId', otherId);\n  });\n}\nvar result = yield model.fetchAll();\n```\n. Cool thanks for the heads up.\n. +1 on default. As a postgres user, this would be a great addition.\n. Thanks. This part of the documentation is a little confusing:\nconstructor / initializenew Collection([models], [options]) \nWhen creating a Collection, you may choose to pass in the initial array of models. The collection's comparator may be included as an option. Passing false as the comparator option will prevent sorting. If you define an initialize function, it will be invoked when the collection is created.\nI wanted the models to be sorted on fetchAll so I ended up using this:\n``` js\ncollection: function (rows, options) {\n    var opts = _.extend({}, options, { comparator: function (rule) {\n      return -1 * rule.get('amount');\n    }});\nvar original = BaseModel.collection.apply(this, [rows, opts]);\noriginal.sort();\n\noriginal.on('fetched', function () {\n  original.sort();\n});\n\nreturn original;\n\n}\n``\n. I'm not a backbone guy either haha so I wasn't sure if it was supposed to sort automatically or not. It appears that it _is_ supposed to sort when new models are added, but it currently does not. Anyway, this works. Appreciate the help!\n. After work today, I'm leaving for a 1.5 week vacation. I promise I will when I get back though!\n. I don't think that relations have any default order by at the moment. Do you think it makes sense to default to order by id ASC?\n. For postgres, it would be nice not to do the additional fetch and just usereturning('*')`\n. @hulbert Did you ever figure out any solutions to these types of issues?. ",
    "ipoddubny": "Well, we have this exact case: a daemon is periodically fetching collection of tasks from a db table, and new tasks get started, old tasks get deleted, and changed tasks get restarted.\nReset would drop all the old models, and no \"change\" events would be fired.\nThis pull request fixes crash on the second fetch of the same collection, when there are changes in a table.\n. ",
    "strarsis": "Possibly related: https://github.com/tgriesser/bookshelf/issues/1333\n. So this issue also persists with a recent postgresql server.\nHow can I further debug this?\n. So the reason why this fails is that upsert isn't even implemented in underlying knex yet: https://github.com/tgriesser/knex/issues/54\n. ",
    "Axure": "So no fix for this?\n. ",
    "liorsion": "I have a model Task\nTask.forge({status: Faker.random.number(1000)}.save // this is the initial save, just so we have something\n   .then(function(task) {\n          var savedAttributes = {status: Faker.random.number(1000)} // different value\n          task.save(savedAttributes,{patch: true}); // problem\n});\non the other hand, if I'd do:\ntask.set('status', Faker.random.number(1000))\ntask.save()\nall the \"changed\" attribute would be accurate.\n. @bendrucker I'll try to get back with failing tests.\n@tgriesser usually on callbacks and events - once something was saved (usually updated) I want to have a general way of knowing what changed and act on it.\n. ",
    "brianc": "Word!\n. ",
    "peteut": "I had a related issue with collection#create (.related('related').create({ })), saveConstraints returns model.set(data) but should return model.set(model.parse(data)). \n. https://github.com/tgriesser/bookshelf/compare/master...peteut:4b15b012707edb8c0c9250380a8ec73f3cef6c91 worked for me. Maybe this is not related?\n. https://github.com/tgriesser/bookshelf/compare/master...peteut:4b15b012707edb8c0c9250380a8ec73f3cef6c91 worked for me. Maybe this is not related?\n. I was too lazy and didn't create a test case and pull request. Sorry for that.\nCould you please give it a try? Thanks a lot!\nOn Monday, May 4, 2015 2:28 PM, Rhys van der Waerden notifications@github.com wrote:\nIt may do, I can check if you like. Is there a reason why it hasn't been merged yet?\n\u2014\nReply to this email directly or view it on GitHub.\n. I was too lazy and didn't create a test case and pull request. Sorry for that.\nCould you please give it a try? Thanks a lot!\nOn Monday, May 4, 2015 2:28 PM, Rhys van der Waerden notifications@github.com wrote:\nIt may do, I can check if you like. Is there a reason why it hasn't been merged yet?\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks for that!\n. ",
    "LordSputnik": "Just wondering what the status of this is? #771 doesn't seem to have fixed it - not sure if it was meant to. Thanks!\n. In order to get the behaviour specified on 5th August (reproduced below), isn't it also necessary to change model.related to return null when the relation is null? Currently, I believe it's returning undefined when the foreign key is set to null, at least for a belongsTo relationship. Should this be a new issue?\n// Person exists without a home:\nPerson.where({id: 1}).fetch({withRelated: 'home'}).then(JSON.stringify);\n// We get:\n'{ \"id\": 1 }'\n// We expect:\n'{ \"id\": 1, home: null }'\n. In order to get the behaviour specified on 5th August (reproduced below), isn't it also necessary to change model.related to return null when the relation is null? Currently, I believe it's returning undefined when the foreign key is set to null, at least for a belongsTo relationship. Should this be a new issue?\n// Person exists without a home:\nPerson.where({id: 1}).fetch({withRelated: 'home'}).then(JSON.stringify);\n// We get:\n'{ \"id\": 1 }'\n// We expect:\n'{ \"id\": 1, home: null }'\n. I've added some minimal code which reproduces the issue at: https://gist.github.com/LordSputnik/2ce27c6f260685b74eef\nThis is with bookshelf 0.8.2, according to the package.json in node_modules/bookshelf\n. Apologies for the duplicate, I normally check well but this time only glanced through the first page!\n. Thanks very much. I didn't see anything about this in the documentation for the fetching event - there, it says that the options parameter will contain the options passed to fetch, which doesn't include the query. Perhaps the docs could be updated to indicate what properties are added to the options parameter? (unless I've missed that information somewhere?)\n. Thanks very much. I didn't see anything about this in the documentation for the fetching event - there, it says that the options parameter will contain the options passed to fetch, which doesn't include the query. Perhaps the docs could be updated to indicate what properties are added to the options parameter? (unless I've missed that information somewhere?)\n. Sure, I'll see if I can get round to it tomorrow.\n. Sure, I'll see if I can get round to it tomorrow.\n. I had a brief look at how the existing mechanism works, but I don't have time to explore implementing any changes at the moment. Maybe will get to it in a few months' time, if nobody has done it by then.\n. ",
    "gregbty": "Yeah I am porting over code from another orm/framework so I am going to promisify everything once that's complete.\nYes I am using the latest version.\n. Here is my new code:\n``` javascript\nvar strategy = new LocalStrategy(function (username, password, cb) {\n      var message = 'Your email or password is incorrect.';\n  process.nextTick(function () {\n    db.User\n      .where({email: username})\n      .query(function (qb) {\n        qb.whereNotNull('companyId').orWhere({systemAdmin: true});\n      })\n      .fetch()\n      .then(function (user) {\n        if (!user)\n          throw message;\n\n        return compare(password, user.get('password'))\n          .then(function (match) {\n            if (!match)\n              throw message;\n\n            return user;\n          })\n      })\n      .catch(db.User.NotFoundError, function () { /**  Removing this block makes this code function correctly **/\n        throw message;\n      })\n      .nodeify(cb);\n  });\n});\n\n```\nThis is really all i get:\njavascript\nTypeError: Cannot call method 'nodeify' of undefined\n    at init\\passport.js:35:12\n    at process._tickCallback (node.js:419:13)\n. Here is my new code:\n``` javascript\nvar strategy = new LocalStrategy(function (username, password, cb) {\n      var message = 'Your email or password is incorrect.';\n  process.nextTick(function () {\n    db.User\n      .where({email: username})\n      .query(function (qb) {\n        qb.whereNotNull('companyId').orWhere({systemAdmin: true});\n      })\n      .fetch()\n      .then(function (user) {\n        if (!user)\n          throw message;\n\n        return compare(password, user.get('password'))\n          .then(function (match) {\n            if (!match)\n              throw message;\n\n            return user;\n          })\n      })\n      .catch(db.User.NotFoundError, function () { /**  Removing this block makes this code function correctly **/\n        throw message;\n      })\n      .nodeify(cb);\n  });\n});\n\n```\nThis is really all i get:\njavascript\nTypeError: Cannot call method 'nodeify' of undefined\n    at init\\passport.js:35:12\n    at process._tickCallback (node.js:419:13)\n. That throw was just a test but it doesn't matter what I place in that block I get that error. I do think it is related to the issue you linked. That was the example I used.\n. That throw was just a test but it doesn't matter what I place in that block I get that error. I do think it is related to the issue you linked. That was the example I used.\n. Works fine. Thanks.\nOff topic:\nIf I want to force relations that do not exist to be null when I pass in withRelated what method do I need to look at/override?\nFor example if there is a relationship between a Pet and Owner but the Pet has no Owner, I want the property of owner to be null rather than an empty object (current behavior).\n. Works fine. Thanks.\nOff topic:\nIf I want to force relations that do not exist to be null when I pass in withRelated what method do I need to look at/override?\nFor example if there is a relationship between a Pet and Owner but the Pet has no Owner, I want the property of owner to be null rather than an empty object (current behavior).\n. Thanks for the quick responses.\n. Thanks for the quick responses.\n. I really apologize for this...I ended up putting a couple of logging statements in the sync file to determine which format function was being called since it was being called for other models. It turns out that I had overridden my base format (the one I use to override the bookshelf default format) in my subclass model. It does work as intended. Thanks.\n. ",
    "clouddueling": "My temporary workaround:\n``` javascript\nvar checkit = require('checkit'),\n    _       = require('lodash');\nmodule.exports = function(bookshelf) {\nreturn bookshelf.Model.extend({\n    tableName: 'user_goals',\n    guarded: [\n      'id',\n      'account_id',\n      'user_id',\n      'updated_at',\n      'created_at',\n      'deleted_at'\n    ],\ninitialize: function() {\n  this.on('saving', this.validateSave);\n},\n\nvalidateSave: function() {\n  var self = this;\n  _.each(self.guarded, function(attr) {\n    if (!_.isUndefined(self.attributes[attr])) {\n      delete self.attributes[attr];\n    }\n  });\n}\n\n});\n};\n```\n. My temporary workaround:\n``` javascript\nvar checkit = require('checkit'),\n    _       = require('lodash');\nmodule.exports = function(bookshelf) {\nreturn bookshelf.Model.extend({\n    tableName: 'user_goals',\n    guarded: [\n      'id',\n      'account_id',\n      'user_id',\n      'updated_at',\n      'created_at',\n      'deleted_at'\n    ],\ninitialize: function() {\n  this.on('saving', this.validateSave);\n},\n\nvalidateSave: function() {\n  var self = this;\n  _.each(self.guarded, function(attr) {\n    if (!_.isUndefined(self.attributes[attr])) {\n      delete self.attributes[attr];\n    }\n  });\n}\n\n});\n};\n```\n. ",
    "marco-fiset": "Any developments on this feature?\n. ",
    "npow": "Thanks for the info! Now my problem is figuring out when to call destroy(). I have the following code which is rather ugly. Is there a better way to do it?\nvar num = 5;\nvar num_saved = 0;\nfor (var i = 0; i < num; ++i) {\n  Store.forge({ ... }).save().then(function () {\n    num_saved++;\n    if (num_saved === num) {\n      knex.destroy(function () {});\n    }\n  });\n}\n. Thanks for the info! Now my problem is figuring out when to call destroy(). I have the following code which is rather ugly. Is there a better way to do it?\nvar num = 5;\nvar num_saved = 0;\nfor (var i = 0; i < num; ++i) {\n  Store.forge({ ... }).save().then(function () {\n    num_saved++;\n    if (num_saved === num) {\n      knex.destroy(function () {});\n    }\n  });\n}\n. Thanks, that would do the trick! \n. ",
    "matanster": "+1\ncould be mentioned in the api docs that the connection pool makes the process eternal unless destroyed\n. @bendrucker I think it kind of implies the opposite by saying \"if you ever need to...\". May have missed a word somewhere... sorry for the hassle.\n. ",
    "kjs3": "This didn't seem to cause other people here any issue but I wasn't able to get my js task to exit by merely requireing knex and calling .destroy(). I had to get the bookshelf instance used in my model files and access knex through that. So the following is for anyone else who was stumped by this.\nprocess.exit() worked perfectly well but not closing things out the \"right\" way was bugging me.\n``` javascript\n// knexfile.js\nmodule.exports = {\n  test: {\n    // stuff\n  },\ndevelopment: {\n    // stuff\n  },\nproduction: {\n    // stuff\n  }\n}\n```\n``` javascript\n// bookshelf.js\nvar dbConfig = require('./knexfile')[process.env.NODE_ENV]\nvar knex = require('knex')(dbConfig)\nmodule.exports = require('bookshelf')(knex)\n```\n``` javascript\n// some js task file\n// i.e. not a server and I want this to exit\nvar bookshelf = require('./bookshelf')\nvar User = require('./models/user.js') // <- this file also requires my bookshelf module to create a model\nvar cannedUsers = [\n  {name: 'foo', email: 'foo@example.com'},\n  {name: 'bar', email: 'bar@example.com'},\n  {name: 'baz', email: 'baz@example.com'}\n]\nvar userPromisesArray = cannedUsers.map(user => {\n  return new User(user).save()\n    .then((user) => {\n      console.log('User created: ', user.get('name'))\n    })\n})\nPromise.all(userPromisesArray)\n.then(() => {\n  return User.count()\n})\n.then(count => {\n  console.log(count + ' users created')\n  return bookshelf.knex.destroy()\n})\n.then(()=>{\n  console.log('Bye!')\n})\n```\n. ",
    "jbruni": "@bendrucker - Not sure about OP, but I'd like to see many-to-many polymorphic support in the way Laravel's Eloquent has: https://laravel.com/docs/5.1/eloquent-relationships#many-to-many-polymorphic-relations\nI`ve just requested the feature also here: https://github.com/tgriesser/bookshelf/issues/719\n. @tgriesser @ricardograca Any news on this subject? Thank you.\n. Yes... it would be great to have many-to-many polymorphic support, just like Laravel's Eloquent:\nhttps://laravel.com/docs/5.1/eloquent-relationships#many-to-many-polymorphic-relations\n. ",
    "dennismonsewicz": "I have the following test:\n```\n'use strict';\nvar assert = require('chai').assert;\nvar proxyquire = require('proxyquire');\nvar sinon = require('sinon');\nvar Bluebird = require('bluebird');\nvar Bookshelf = require('bookshelf');\ndescribe('set-hero/controllers/projects/schedules/getScheduleById', function() {\n    var controller;\n    var server;\n    var Schedule = Bookshelf.Model;\n    var Project = Bookshelf.Model;\n    var request;\n    var dbSchedule;\n    var Bookshelf = {};\n    var project;\nbefore(function(done) {\n    project = new Project();\n    dbSchedule = {\n        'id': 1,\n        'name': 'Foo Schedule',\n        'project_id': 1,\n        'total_days': 4,\n        'create_user': 1,\n        'create_date': '2015-08-12 18:30:00',\n        'update_user': 1,\n        'update_date': '2015-08-12 18:35:00'\n    };\n    server = {\n        plugins: {\n            'db-package': {\n                schedule: Schedule\n            }\n        }\n    };\n    request = {\n        app: {\n            currentProject: function() {\n                return Bluebird.resolve(project);\n            }\n        },\n        params: {\n            scheduleId: 1\n        }\n    };\n    controller = proxyquire('../src/set-hero/controllers/projects/schedules/getScheduleById', {}).handler(server);\n    done();\n});\n\nit('returns a schedule', function(done) {\n    var schedule = new Schedule();\n    sinon.stub(schedule, 'fetch').resolves(dbSchedule);\n\n    var reply = function(x) {\n        console.log(x);\n        done();\n    }\n\n    controller(request, reply);\n});\n\n});\n```\nWhen I run the test suite I get \nvar Schedule = Bookshelf.Model;\n                            ^\nTypeError: Cannot read property 'Model' of undefined\n. ",
    "elliotf": "Yes, I'm closing this #414 and #415 and doing a PR on knex.  That was a brain fart on my part.\n. I mistakenly created #415 and #414 on bookshelf rather than knex.  I'm going to do a PR for the workaround on knex.\n. Continuing with my trends of brain farts, I'm reopening this, because this is a problem for users until it's either documented, fixed, or a workaround is set in place (likely in knex)\n. @tgriesser doing so in tgriesser/knex#368 but the mariasql client is failing the integration suite.\n. I was the one that mentioned the bug with Promise.all..    I'm assuming it has to do with the fact that Promise.all kicks everything off in parallel, but aborts early on the first error.\nMaybe the transaction/connection isn't checking to see if it's been aborted?\nAs far as the attach() goes, it doesn't appear that it's paying attention to the transacting: t options when attaching via a through table (see _processModelPivot in lib/relation.js .)\n. ",
    "Sequoia": "Could this be added to the docs or something at least? I'm new to knex, if you tell me where it's appropriate to note this I'll send PR. Majorly confusing cuz neither knex nor bookshelf docs mention this gotcha.\n. ",
    "StarpTech": "Running into the same issue. Running into the same issue. ",
    "JamesStallings": "likewise, over two years later.\nby now, mariadb is the default database system on just about every modern linux release in common use.. ",
    "ongmingyang": "This worked, thanks tgriesser!\n. Noted with thanks!\n. Noted with thanks!\n. You are right on the first count: all intermediate data is junk to me and I'd only like to have the information from the very last table.\n. You are right on the first count: all intermediate data is junk to me and I'd only like to have the information from the very last table.\n. ",
    "PrototypeAlex": "Ah right, thanks. I didn't think about it in that light.\n. ",
    "franciscocardoso": "Any news on this @cbollerud?\n. Wrong approach. Closing it.\n. ",
    "cbollerud": "This is the first response I\u2019ve seen on it.  There are many cases where I would find composite keys useful.  As a workaround I have either created a surrogate key or hacked the id a bit.  Neither of these is a good solution.  If I can find some time I\u2019d be happy to fork a possible fix.  From what I can tell, composite keys were only partially implemented, which causes issues for certain use cases.\nChris\n\nOn Jan 9, 2015, at 3:22 AM, Francisco Cardoso notifications@github.com wrote:\nAny news on this @cbollerud https://github.com/cbollerud?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/tgriesser/bookshelf/issues/420#issuecomment-69322619.\n. \n",
    "isaacdurazo": "I'm glad you guys like it. @tgriesser I'm leaning towards the orange one.\n. All set @tgriesser and @bendrucker  :)\n. All set @tgriesser and @bendrucker  :)\n. ",
    "jgr3go": "This affects mysql as well, for columns that have database defaults, so I think it should be the default for everything.   In mysql:\nUser.forge({ name: \"jgr3go\" }).save().then(user => {\n    console.log(user.toJSON()); // {id: 1, name: \"jgr3go\" }\n    return user.refresh();\n}).then(user => {\n    console.log(user.toJSON()); // {id: 1, name: \"jgr3go\", is_admin: 0 }\n});\nI actually had to override the save method to call refresh in my models, so this pull would be useful for non postgres people also. \nbookshelf.Model.extend({\n    save () {\n        return bookshelf.Model.prototype.save.apply(this, arguments)\n            .then(model => { \n                return model.refresh();\n            });\n   },\n   ...\n. Unfortunately I wouldn't expect it any time soon. This project appears dead.  I ended up pointing my project at my fork with the changes. . Looks like a race condition to me.  knex.migrate.latest() is a promise, since it takes a while, but your first test likely runs before the migration is complete.   You should find a way to resolve the migration before any of your tests start running and see if that fixes it. . Looks like a race condition to me.  knex.migrate.latest() is a promise, since it takes a while, but your first test likely runs before the migration is complete.   You should find a way to resolve the migration before any of your tests start running and see if that fixes it. . ",
    "ricka": "@rhys-vdw Did this lose steam?  I'd personally love to see this in place, and I think everyone agrees it is universally a great idea.\n. I'm trying to implement this with the following:\njavascript\ninitialize: function () {\n  this.on('creating', (model, attrs, options) => {\n    options.query.returning('*');\n  });\n  this.on('created', (model, resp, options) => {\n    model.set(model.parse(head(resp)));\n  });\n}\nHowever, I only ever get back one element in resp, which is the id of the record created.  Is there some other way I should be doing this to make sure I get all fields for the newly created record?\n. @rhys-vdw I believe that @pignatenko found the area of concern in #507 in this comment.\nIt looks like the code referenced is currently here.  Does that look right, and if so, would the fix be checking for this.query._single.returning there and using it instead of syncing.idAttribute if it exists?\n. @TinOo512 I'm trying your method as it seems the cleanest, however, no matter what I put in the string to the options.query.returning function, I only ever get an array with one value in it, which is the id of the item just inserted.  I've tried '*', just a different field, and an array with all fields. I'm trying this for insertions with Postgres, and I see the returning parameter set in query builder, but no luck.  Are you using Postgres, and did you ever try extending this past updates?\n. ",
    "johnmenick": "And so it is. Thanks.\n. ",
    "tzookb": "any idea how to get the orderByRaw?\nI use this\nVisit.collection().query(function (qb) {\n           qb.groupBy(['src', 'track', 'page']);\n           qb.where({club: 1});\n        })\n        .orderByRaw('DAY(created) \n        .fetch()\n        .then(function(data) {\n            data.forEach(function(item) {\n                console.log(item.id);\n            })\n        });\nI get the error:\n.orderByRaw is not a function\n. ",
    "chadxz": "Your orderByRaw call needs to be inside the query callback\n. Your orderByRaw call needs to be inside the query callback\n. looks like it should be either new Defray().query(...) or Defray.query(...) but not new Defray.query(...)\nnot sure if that will help.\np.s. these types of questions are better asked on Stack Overflow, which it looks like you did in parallel... might wanna give that a chance first before asking usage questions here.\n. did you try Model.where(criteria).fetchAll() already?\n. did you try Model.where(criteria).fetchAll() already?\n. I have a PR open to document these static methods: #1086\n. I have a PR open to document these static methods: #1086\n. ",
    "juliussss": "Thanks Ben, updated in original comment.\n. ",
    "alexnaspo": "Is there an example of the updatePivot in the documentation anywhere?\n. ",
    "connorbrathwaite": "also curious as to a cleaner solution for this, brief sample of my current implementation similar to @juliussss's\n``` javascript\nexport async function update(ctx) {\n  const story = ctx.body.story\nawait story.save(ctx.request.body.story, { patch: true })\n  await story.celebrities().detach()\n  await story.celebrities().attach(ctx.request.body.celebrities)\nconst response = await story.load('celebrities')\nctx.body = { story: response }\n}\n```\n. @awebdeveloper unfortunately not, have yet to revisit this portion of my project since.\n. @rhys-vdw thanks for that, much appreciated!\n. ",
    "ryanking8215": "I am testing bookshelf.\nI use this way:\njavascript\nnew Model().where(...<your filter>).fetchAll()\n.then(function(collection){\n    var totalcount = collection.length\n    // pagination\n    collection.query(function(qb){\n          qb.limit().offset()\n    }).fetch({withRelated:['relation if needed']})\n    .then(function(new_collection){\n            // the result\n    })\n})\nthe defect is you need enough memory to carry all the collection.\nmaybe using count() and limit(),offset() is a proper way, but it need query twice and no bookshelf's business, its all about knex.\nany good idea?\n. I read the doc again and found the way:\njavascript\nnew Student({no:1}).scores().updatePivot({score:90},{query:{where:{course_no:2}}})\nPlease close it, thanks\n. @coolaj86 you can use plugin \"visibility\", see https://github.com/tgriesser/bookshelf/wiki/Plugin:-Visibility\n. @coolaj86 you can use plugin \"visibility\", see https://github.com/tgriesser/bookshelf/wiki/Plugin:-Visibility\n. ",
    "apneadiving": "Seems it was answered here: https://github.com/tgriesser/bookshelf/issues/50\n. Seems it was answered here: https://github.com/tgriesser/bookshelf/issues/50\n. actually sorry but I cant implement it, so it's not that obvious...\nCould we have a working example please?\nWould even be better if all methods could inherit the method\n. actually sorry but I cant implement it, so it's not that obvious...\nCould we have a working example please?\nWould even be better if all methods could inherit the method\n. We should get rid of some query's fields \u00e0 la sequelize https://github.com/sequelize/sequelize/blob/master/lib/model.js#L893\n. We should get rid of some query's fields \u00e0 la sequelize https://github.com/sequelize/sequelize/blob/master/lib/model.js#L893\n. Do you have a roadmap for the count refactoring mentionned here please? \nHow do you guys create an api without this info? (when filters are involved)\n. Do you have a roadmap for the count refactoring mentionned here please? \nHow do you guys create an api without this info? (when filters are involved)\n. Actually it seems .count exists when I see the ghost js code here.\nIs it simply not documented? \nWell it exists on the knex object actually, I understand the difference.\n. Actually it seems .count exists when I see the ghost js code here.\nIs it simply not documented? \nWell it exists on the knex object actually, I understand the difference.\n. Any news for pagination roadmap please?\n. err, no reset resets the collection but doesnt touch the database.\n. err, no reset resets the collection but doesnt touch the database.\n. thanks for the example!\n. thanks for the example!\n. ",
    "slawo": "+1 for pagination\n. ",
    "VictorQueiroz": "I use something like this:\n``` js\nexports.list = function (req, res) {\n    var query = req.query;\nvar page, per_page, skip = null, limit = null, paginator = null;\n\npage = Number(query.page || 1);\nper_page = Number(query.per_page || 4);\n\npaginator = new Paginator(page, per_page);\n\nlimit = paginator.getLimit();\nskip = paginator.getOffset();\n\nItem\n    .query(function (qb) {\n        qb.limit(limit).offset(skip);\n    })\n    .fetchAll({\n        withRelated: ['display']\n    })\n    .then(function(items) {\n        return Item\n        .query()\n        .count()\n        .then(function (count) {\n            count = count[0]['count(*)'];\n\n            return {\n                count: count,\n                rows: items\n            };\n        });\n    }, function (err) {\n        res.json(err);\n    }).then(function (result) {\n        var count = result.count;\n        var items = result.rows;\n\n        paginator.setCount(count);\n        paginator.setData(items);\n\n        return res.json(paginator.getPaginator());\n    });\n\n};\n```\nPaginator\n``` js\n'use strict';\nvar _ = require('underscore');\nfunction Paginator (page, perPage) {\n    this.currentPage = (!.isNumber(page) ? Number(page) : page) || 1;\n    this.perPage = (!.isNumber(perPage) ? Number(perPage) : perPage) || 4;\n    this.lastPage = 0;\n    this.data = [];\nreturn this;\n\n}\nPaginator.prototype.setCount = function (count) {\n    this.count = Number(count);\nreturn this;\n\n};\nPaginator.prototype.getLastPage = function () {\n    this.lastPage = Math.ceil((this.count / this.perPage - 1) + 1);\nreturn this.lastPage;\n\n};\nPaginator.prototype.setData = function (data) {\n    this.data = data;\nreturn this;\n\n};\nPaginator.prototype.getPaginator = function () {\n    this.getLastPage();\nif(!this.pages) {\n    this.getPages();\n}\n\nreturn this;\n\n};\nPaginator.prototype.getCurrentPage = function () {\n    return this.currentPage;\n};\nPaginator.prototype.getLimit = function () {\n    return this.perPage;\n};\nPaginator.prototype.getPages = function () {\n    this.pages = [];\nvar i;\n\nfor(i=1; i<this.lastPage + 1; i++) {\n    this.pages.push(i);\n}\n\nreturn this.pages;\n\n};\nPaginator.prototype.getOffset = function () {\n    return (this.currentPage - 1) * this.perPage;\n};\nmodule.exports = Paginator;\n```\nThe only ongoing is that if you need to do some query in .query() before .count(), then it will not work, so, if you need to do a search with a pagination, it's not going to happen :/\n. ``` js\nexports.update = function (req, res) {\n    var quest = req.body;\nQuest\n    .query({\n        where: {\n            Id: req.params.quest\n        }\n    })\n    .save(quest)\n    .then(function (quest) {\n        res.json(quest);\n    }).catch(function (err) {\n        res.json(err);\n    });\n\n};\nexports.store = exports.update;\n```\nDid the job for me :+1: \n. When I use attach, I got this:\nPossibly unhandled TypeError: Object [object Object] has no method 'add'\n    at Runner_MySQL.<anonymous> (/home/victorqueiroz/public_html/server-api/node_modules/bookshelf/lib/relation.js:482:18)\n    at Runner_MySQL.tryCatcher (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/util.js:24:31)\n    at Promise._settlePromiseFromHandler (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/promise.js:483:31)\n    at Promise._settlePromiseAt (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/promise.js:562:18)\n    at Async._drainQueue (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/async.js:84:12)\n    at Async._drainQueues (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/async.js:89:10)\n    at Async.drainQueues (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/async.js:14:14)\n    at process._tickCallback (node.js:419:13)\nAnd it isn't a belongsToMany relationship. Account has one Referrer, and belongs to many Referral which are not what I'm trying to access, I'm trying to update the hasOne pivot, with relate the Account with his only Referrer.\n. Relationship model methods:\njs\nreferrer: function () {\n    return this.hasOne('Account').through('AccountReferrer', 'id', 'referrer_id');\n},\nreferrals: function () {\n    return this.belongsToMany('Account', 'account_referrer', 'account_id', 'referrer_id');\n},\nTable 'accounts':\nPrimary key: id\n(...)\nTable 'account_referrer':\nPrimary key: id\nAccount key: account_id\nReferrer key: referrer_id\n. I just want to say that a user has been indicated for another and then registered himself, and a user can do alot of indications (referrals), and I don't want to add another column in account table, prefer to deal with it separately, it is wrong in some way?\n. What about the error that I received when I use .attach()?\n. Sorry, I misunderstand you. I want bookshelf create a row at account_referrer filling the column account_id with the actual Account model id, and the referrer_id with the desired Referrer model id. Got it?\nShould be like that:\njs\nvar referrerId = 20;\naccount.related('referrer').attach(referrerId);\nid: ?\naccount_id: 1\nreferrer_id: 20\n. Actually, yes. But I got that error:\nPossibly unhandled TypeError: Object [object Object] has no method 'add'\n    at Runner_MySQL.<anonymous> (/home/victorqueiroz/public_html/server-api/node_modules/bookshelf/lib/relation.js:482:18)\n    at Runner_MySQL.tryCatcher (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/util.js:24:31)\n    at Promise._settlePromiseFromHandler (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/promise.js:483:31)\n    at Promise._settlePromiseAt (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/promise.js:562:18)\n    at Async._drainQueue (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/async.js:84:12)\n    at Async._drainQueues (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/async.js:89:10)\n    at Async.drainQueues (/home/victorqueiroz/public_html/server-api/node_modules/bluebird/js/main/async.js:14:14)\n    at process._tickCallback (node.js:419:13)\n. Take a shot: https://github.com/VictorQueiroz/cloaked-octo-hipster\n. I made a update, see if it's enough, please. Just run:\nnode .\nThe only database you need to put on your MySQL server is auth_database.sql with the name of auth, and run the script to test.\nI just can't find a way to parse MySQL to SQLite3, and make things more easy for you, sorry.\n. Ok, thank's for your help, there is any workaround for today? Can I use the pivot directly to make the modification? Or something?\n. I came here to say that the inverse of the situation, did the job for me, thank's. As simple as that. Haha.\njs\nAccount.forge({\n    id: 1\n}).fetch({\n    withRelated: ['referrer', 'referrals']\n}).then(function( account) {\n    return Account.forge({\n        id: 2\n    }).fetch({\n        withRelated: ['referrals']\n    }).then(function (referrer) {\n        return referrer.referrals().attach(account);\n    });\n})\n. ",
    "biancarosa": "@tgriesser Are you thinking about implementing this in the future? Or just adding a example in the docs?\nI've had the same issue earlier today and it took me some time, so I'm willing to take a look and maybe contribute.\n. ",
    "anyong": ":+1: \nBeen very happy with bookshelf so far, but it seems that everyone is doing different stuff for pagination when it should be a fairly common task. A plugin seems in order...\n. I wasn't too keen on the plugins @rkmax or @bhoriuchi wrote, since they take the pagination functions out of the bookshelf models, and rkmax's depends on bookshelf-model-loader which I don't want. I wanted something that I could plug in with the rest of my normal bookshelf plugins registry, virtuals, etc.\n@rhys-vdw I've added a gist with the beginnings of a plugin to support pagination, would you mind looking at it to see how it can be improved?\nCurrent issues:\n- It can paginate any queries that can be passed to the knex query builder\n- Not a very good API as the method takes 3 rather awkward parameters - I'm not sure how that can be separated out into different chainable calls as in the standard bookshelf library. Better API would be:\njs\nModel.query(...).paginate(options).fetchAll(...);\n- fullQuery function at the top is copied from bookshelf - I'm not sure if there is a better way to reuse that code without just duplicating it\n- fullQuery gets called twice, once for the total count and once for the rows with limit/offset. It would be nice if there's a way to capture the query builder after the first call and reuse it for the second call - not sure if that's possible?\n- I can add in a limit/offset option as currently it just does limit/page number, but that's pretty straightforward.\nI think with a little work and some more input this can be a good go-to pagination plugin, and if the API can look like the line above then maybe it could be included in bookshelf directly.\nhttps://gist.github.com/anyong/559c91fb4b6add5d5ae9640f57f4f281\n. @rhys-vdw the difficulty I'm having is figuring out how to make a copy of the original query the user has built so far. A shallow copy of the querybuilder doesn't work, because it's missing the limit and offset functions. A deep copy doesn't work, because it throws errors about not having packages installed (I guess they are required somewhere up the prototype chain?)\nHow can I copy the query builder to perform the two separate queries (one for paging, one for counting)?\n. I've made a PR, and in the meanwhile I'm releasing my own package on npm as bookshelf-page that has the exact same patches as my PR and should be interchangeable if/when the PR gets accepted.\nAnyone who is interested in a prepackaged pagination solution for bookshelf is welcome to give it a try!\n. Would anyone else care to comment on how the resulting pagination metadata (total size, current page, etc.) should be passed back?\nThere are three possibilities as I see it.\n1. Add a pagination property to the returned Collection instance\n(This is the currently implemented solution.)\njs\n// Collection Instance\n{\n  models: [...],\n  pagination: {\n    total: 1623, // total found\n    page: 7, // current page\n    limit: 15, // requested page size\n    offset: 90, // current offset\n    rowCount: 15 // returned row count\n  }\n}\n2. Use the metadata as the envelope object and the Collection as an attribute on it:\njs\n// Metadata object\n{\n  total: 1623,\n  page: 7,\n  ...\n  entities: <Collection>\n}\n3. Return the Collection and a pagination metadata object separately in an Array, so it would look like: [collection, metadata] This actually works nicely if you use array destructuring, so your .then call looks like:\njs\n.then(([collection, metadata]) => {\n// ...\n});\nAnd they are kept separate and both easily accessible.\nSo, what do you prefer, 1, 2, or 3?\n. @nodeit Yeah, that seems to be the consensus. You can install separately as bookshelf-page to use until the PR is accepted.\n. @nodeit Yeah, that seems to be the consensus. You can install separately as bookshelf-page to use until the PR is accepted.\n. @arden The devs are busy people! I've been in touch with @rhys-vdw and he should be able to integrate bookshelf-page pretty soon hopefully, so until then just keep using the plugin if you like it and please help by reporting any issues over at anyong/bookshelf-page. Thanks!\n. @Vanuan that's ridiculous. There are plenty of cases where pagination is still the way to go. \"Load more\" is much harder to implement nicely (infinite scroll is almost always a terrible, UX), and is not nearly as useful as normal pagination for many types of business data where full accountings are needed and we can't just pop items in or out at will.\nThere are other solutions than limit/offset/count, but unless you've got a lot (a lot!) of rows, the basics still work just fine.\n. A business that keeps track of those kinds of things doesn't mind waiting\n1.4 seconds to know they have the right data. You're talking about this\ntopic as if the only people concerned are average internet consumer-users\nwith a 0.1 second attention span, on a public server vulnerable to DDOS.\nAnd 1 million records is a lot for many uses. A SME does not have 1 million\nsales, employees, customers, or inventory.\nThere are very good use cases for not bothering to count and collate all\nthe data available, and there are very good use cases for doing so; just as\nthere are use cases for pagination and there are use cases for lazy loading\n(although I have yet to see a really great implementation, as I said).\nMy point is simply that offset+limit is really \"good enough\" for many\ncases. If you have millions of rows of anything, figuring out how to switch\nfrom offset+limit to something faster is what I would probably consider a\ngood problem to have, if you know what I mean.\nOn Wed, May 4, 2016 at 12:07 AM, John Yani notifications@github.com wrote:\n\nIt depends on what you consider to be a lot. Let's take 1 million records\nas an example. Not too little, not too much.\nselect * from companies order by id offset 1 limit 30;\nExecution time: 1.374 ms\nselect * from companies order by id offset 1000 limit 30;\nExecution time: 3.226 ms\nselect * from companies order by id offset 1000000 limit 30;\nExecution time: 1243.758 ms\nSo far so good. 30 pages with 30 results per page will get you less than 3\nms, and it's probably enough for most of users. But to prevent DDoS attacks\nwe'd need to limit an offset parameter.\nWhat about counting?\nA simple unfiltered count is too slow for a day-to-day usage:\nselect COUNT(*) from companies;\nExecution time: 1422.770 ms\nShould we use limit here too, displaying \"10000+ records found\" to the\nuser?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/435#issuecomment-216578585\n. Let's please discuss and resolve the last comment here before this gets merged, please! Once it's in, we don't want to go changing the API.\n. rowCount is probably not necessary, pageCount makes more sense. I was using the word limit since the two main types of pagination are \"by page\" (typically referred to with \"page\" and \"page size\") and offset/limit, but the limit and page size are the same thing.\n\nOne option would be to have the API accept either offset/limit or page/pageSize, and return only the appropriate keys on the collection. Since most end users are using either one or the other but not both, this could make sense.\n. Alright. There are still people who prefer offset/limit though (for whatever reason) and it doesn't really add much code to use both, so we'll go with the API where Model#fetchPage can be passed either offset, limit or page, pageSize but not both or a mixture of the two, and the pagination metadata will include whichever two properties the user is calling with.\nAdditionally, I think maybe total should actually be called rowCount in the pagination metadata, as this fits well with pageCount. So the final API would be:\n``` js\nCar.fetchPage({page: 3, pageSize: 20}).then(result => //...)\n// result:\n{\n  models: [...],\n  pagination: {\n    rowCount: 1623, // total rows found\n    pageCount: 82, // total pages\n    page: 3, // current page\n    pageSize: 20 // requested page size\n  }\n}\n// OR\nCar.fetchPage({offset: 40, limit: 20}).then(result => //...)\n// result:\n{\n  models: [...],\n  pagination: {\n    rowCount: 1623, // total rows found\n    pageCount: 82, // total pages\n    offset: 40, // current page\n    limit: 20 // requested page size\n  }\n}\n```\nThe default option if called with a no arguments will be {page: 1, pageSize: 10}\nHow does that sound?\n. I've implemented both. You can pass either and get back either, with page/pageSize as the default.\n. I'm not sure what you mean. My plugin is also available separately as\nbookshelf-page if you want to include it as a dependency or something.\nOn Apr 12, 2016 1:27 AM, \"James Dixon\" notifications@github.com wrote:\n\n@anyong https://github.com/anyong checked out your plugin. Very nice\nwork! Do you happen to know if it's possible to include your plugin as part\nof another plugin? I'm working on a plugin that applies JSONAPI params to\nBookshelf queries and part of the params defined by the spec related to\npagination.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/pull/1183#issuecomment-208462917\n. I'm not sure what you mean. My plugin is also available separately as\nbookshelf-page if you want to include it as a dependency or something.\nOn Apr 12, 2016 1:27 AM, \"James Dixon\" notifications@github.com wrote:\n@anyong https://github.com/anyong checked out your plugin. Very nice\nwork! Do you happen to know if it's possible to include your plugin as part\nof another plugin? I'm working on a plugin that applies JSONAPI params to\nBookshelf queries and part of the params defined by the spec related to\npagination.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/pull/1183#issuecomment-208462917\n. Great, thanks!\n. @ricardograca either way is fine with me. . \n",
    "bhoriuchi": "I also wrote a library for this https://github.com/bhoriuchi/bookshelf-pagemaker that allows you to define a pagination format complete with the ability to customize field names and query string params. Sorry for the limited documentation.\n. wouldn't this work for creating a commit event\njs\nvar _self = this;\nBookshelf.transaction(function(t) {\n    if (t.client.listeners('commit').length === 0) {\n        t.client.on('query', function(q) {\n            if (q.sql === 'COMMIT;') {\n                t.client.emit('commit', _self);\n                _self.emit('commit', _self);\n            }\n        });\n        t.client.on('commit', function(obj) {\n            // do something\n        });\n    }\n});\nor would this still be fired on a rollback?\n. ",
    "jamesdixon": "Was just curious if there have been any recent developments on this as far as best practice?\n. Thanks @rhys-vdw and no problem! I ended up just implementing a very simplistic paging option using offset() and limit() for the time being until the need arises for something more advanced.\n. @tgriesser is this something that's actively being worked on?\nI'm building an API using the JSON API spec and according to the spec, when an object has relationships, at a minimum, those relationships and corresponding ids should be returned as part of the object. That way, persistence layers consuming JSON API (such as Ember Data) have a reference to that relationship and can either load that relation locally or make the appropriate call to retrieve it. The other option is to include the related data as part of the payload, which is what I'm doing now. Either way, whether you're including just the id of the relationship or the relation data itself, it requires a lookup on the backend. Ideally, I'd like to be able to cache those relation ids on first lookup so that they can be retrieved quickly on subsequent fetches. If the model is new or updated, that cache can be invalidated/updated.\nAll that said, this discussion is becoming very relevant and wanted to know more.\nThanks!\n. I'm somewhat trying to do the opposite and return local time, but regardless of how the data is stored, the server setting, etc, the date is always returned as UTC.\n. Just an FYI that this issue is still present in 0.8.2\n. Super useful info!\n. Thank you @rhys-vdw! Appreciated :+1: \n. Thank you @rhys-vdw! Appreciated :+1: \n. Good lord. This must be a sign that I should go to sleep and think about what I've done...\nThank you and sorry!\n. Good lord. This must be a sign that I should go to sleep and think about what I've done...\nThank you and sorry!\n. @jameslaneconkling @rhys-vdw was there ever any resolution for this issue? I'm encountering the same exact issue -- record is inserted, but the two errors mentioned above are being thrown. \nCheers.\n. @rogerschlachter I haven't come across this in a while and can't recall what I did to fix it, but I am using knex-postgis and haven't had any save issues.\n. @rhys-vdw this is fantastic! going to give it a shot. thank you!\n. @rhys-vdw will do!\n. @emaddoma I'm running into the exact same situation. What approach did you end up taking?\n. @dsauerbrun I just ran into this as well. Were you ever able to resolve this?\n. @dsauerbrun no worries. appreciate it. I just ended up refetching the model and it seems to work\n. Thanks @blah238. Here's the complete method:\n``` javascript\n  create: (businessId, services, transaction) => {\n    // get model references\n    const ServiceGroup = Bookshelf.model('ServiceGroup');\n// set options\nlet options = {};\n\n// if the update should be part of a transaction, add it to the options\nif (!_.isEmpty(transaction)) {\n  options.transacting = transaction;\n}\n\nreturn Promise.try(() => {\n\n  // iterate through the list of services\n  _.forEach(services, (service) => {\n    /**\n     *  If object does NOT have an id, that means it is new and has not been\n     *  created so in that case it should be created and a new group should\n     *  then also be created.\n     */\n\n    if (_.isUndefined(service.id)) {\n\n      // associate the service with the business id\n      service.businessId = businessId;\n\n      ServiceGroup\n        .forge()\n        .save(null, options)\n        .then((serviceGroup) => {\n\n          // associate new service with new service group\n          service.serviceGroupId = serviceGroup.get('id');\n\n          // create the new service\n          return Service.forge(service).save(null);\n        });\n\n    } else {\n\n      /**\n       * If object has an id, that means it has already been created.\n       * In that case create a new instance of the service or surcharge\n       * and remove the old one from being active. In this case a new group\n       * should not be created. The new instance should associate with the same\n       * group as the last object.\n       */\n\n      // mark previous instance as Inactive\n      service.active = false;\n\n      // update the previous instance\n      Service\n        .update(service.id, service.businessId, service, transaction)\n        .then((updatedService) => {\n\n          // activate and remove the id of the service\n          delete service.id;\n          service.active = true;\n\n          // create the new instance\n          return Service.forge(service).save(null);\n        });\n    }\n\n  }); // forEach\n\n}); // end promise.try\n\n},\n```\nGiven your explanation of when the tx resolves, it sounds like it has something to do with the way I've setup the promise. As you can see, I'm looping through a list of services and didn't attempt to return them as I was thinking it would break out of the loop before it had finished. Hence, I attempted to use Promise.try() to start the chain. However, maybe it's a combination of those things that's just wrong.\n. Thanks @rhys-vdw - I figured this was just an issue with my mechanics. I'll give that a shot!\n. Thanks again to both of you - using Promise.map() worked beautifully!\n. Thanks, @rhys-vdw! This worked beautifully!\n. Thanks, @rhys-vdw! This worked beautifully!\n. @bsiddiqui that worked great! the only bummer was having to convert my camelCase keys to snake_case before passing them into .where(). I don't suppose you have an elegant solution to that as well? :+1: \nThanks again!\n. @bsiddiqui that worked great! the only bummer was having to convert my camelCase keys to snake_case before passing them into .where(). I don't suppose you have an elegant solution to that as well? :+1: \nThanks again!\n. Yeah, I currently override the parse and format functions, but it doesn't seem they apply to anything that is passed to knex directly. From what I've read, where() is a knex convenience method, so in this case it doesn't apply. I considered just going back and changing all of my instances to be snake_case, but I feel like it's going to be a real pain :)\n. Yeah, I currently override the parse and format functions, but it doesn't seem they apply to anything that is passed to knex directly. From what I've read, where() is a knex convenience method, so in this case it doesn't apply. I considered just going back and changing all of my instances to be snake_case, but I feel like it's going to be a real pain :)\n. Yeah, I only did snake_case because it was the recommended format for postgres, but I'm wondering if changing it to camel case on the postgres side would have any negative impact. It is definitely getting annoying.\n. Thanks for chiming in, @rhys-vdw! Good suggestion on the filter() method. Going to implement that now :)\nOn a similar topic, do you have any idea why when calling fetchAll() on a model, you have to use where to constrain the results, but with fetch() it just uses the attributes set on the model? It seems like inconsistent behavior between the two given they are similar in essence. Figuring out some of these things has definitely thrown me for a loop :)\nThanks as always.\nCheers,\nJames\n. Believe it or not, I swear I searched for some of these things :) \nRegardless, good to know I'm not going crazy.\nThanks! Looking forward to the fixes!\n. @rhys-vdw ran into another instance where format() should probably be applied. I passed the columns option to fetchAll() and discovered that it also does not apply format() and was therefore bitten by the casing bug again. Possibly on withRelated as well? Thoughts?\n. @rhys-vdw I ended up taking a different approach, but I'll see if I can't dig up the code so this can be reproduced.\n. Thanks, @rhys-vdw -- really appreciate it!\n. @rhys-vdw any eta on when you might push out that update? Thanks!\n. @vellotis?\n. @tayden-hakai you may want to check out #879 \n. @tayden-hakai not sure if you ever got this working, but I tried the solution you posted and it worked for me. The only difference is that I didn't make _locationToText a separate function. Were you able to resolve?\n. I honestly think the solution you provided is better than what's in the link. The solution in the link is complex and untested.\n. @anyong checked out your plugin. Very nice work! Do you happen to know if it's possible to include your plugin as part of another plugin? I'm working on a plugin that applies JSONAPI params to Bookshelf queries and part of the params defined by the spec related to pagination.\n. This appears to be the offending line: https://github.com/tgriesser/bookshelf/blob/6ba28f5acec8ea256a63d6268bdb4d8e4ea0634d/src/base/collection.js#L563\nThe clone method uses a variable called collectionProps that lists what should be picked from the what's passed in, but the missing items are not in that variable.\nNot sure what the best way to resolve this would be without affecting other things.\n. I'm using the fetching event to modify the query before it's executed.\nThe relation is a simple belongsTo('Staff').\n. As I mentioned in the original issue, I can see that the query gets executed properly, but no results are returned in the relation. This only happens when using withRelated\n. @vellotis thanks for your suggestion. The method you recommended does work and I had tried it, but question is why through() doesn't work with withPivot()? I've seen examples elsewhere of that combination in use -- in fact, it seems like through() is really syntactic sugar for what you described using belongsToMany(). I could be wrong, but check out the queries for both methods:\n``` sql\n-- using through() and withPivot(); service_id is not selected\nSELECT \"pet\".*,\n       \"appointment_service\".\"id\" AS \"_pivot_id\",\n       \"appointment_service\".\"appointment_id\" AS \"_pivot_appointment_id\",\n       \"appointment_service\".\"pet_id\" AS \"_pivot_pet_id\"\nFROM \"pet\"\nINNER JOIN \"appointment_service\" ON \"appointment_service\".\"pet_id\" = \"pet\".\"id\" WHERE \"appointment_service\".\"appointment_id\" IN (?)\n-- specifying relation in belongsToMany() and withPivot(); service_id is selected\nSELECT \"pet\".*,\n       \"appointment_service\".\"appointment_id\" AS \"_pivot_appointment_id\",\n       \"appointment_service\".\"pet_id\" AS \"_pivot_pet_id\",\n       \"appointment_service\".\"service_id\" AS \"_pivot_service_id\"\nFROM \"pet\"\nINNER JOIN \"appointment_service\" ON \"appointment_service\".\"pet_id\" = \"pet\".\"id\" WHERE \"appointment_service\".\"appointment_id\" IN (?)\n```\nIs it a bug?\n. Yeah, I suppose that makes sense, but would be good to get some clarity around this. Regardless, using this setup may not work for me anyways as a pet may have multiple services and when retrieving service_id, even with multiple entries containing different service_ids, it appears that Bookshelf only takes the first entry and therefore I only see one service. Need to figure out a better way to model this.\n. I was finally able to get different ids injected into the above query by temporarily changing the idAttribute on the model from id to parent_id. The query is correct and parameters being passed are also correct, but the relationships are empty when the model is returned.\nHere's a snapshot of what I have:\n``` javascript\n// appointment model\n    pets() {\n    return this.belongsToMany('Pet', 'appointment_pet', 'parent_id');\n},\n\n},\n// Returns all appointments\n    fetchAll(businessId, options) {\n    options = options || {};\n\n    // If a start and end date are passed, return all appointments\n    // within that range, with recurrences expanded.\n    if (!_.isUndefined(options.startDate) &&\n        !_.isUndefined(options.endDate)) {\n\n        const startDate = Moment(options.startDate);\n        const endDate = Moment(options.endDate);\n\n        // Disable paging unless the date range is greater than 60 days\n        if (Moment.duration(endDate.diff(startDate)).asDays() <= 60) {\n            options.page = false;\n        }\n\n        // temporarily change id attribute so `parent_id` is used when looking up the relation\n        Appointment.prototype.idAttribute = 'parent_id';\n\n        return Appointment\n            .query((qb) => {\n\n                qb.from(Bookshelf.knex.raw('get_appointments(?, ?, ?) AS appointment', [businessId, startDate.toISOString(), endDate.toISOString()]));\n            })\n            .fetchAll({\n                withRelated: [{\n                    pets: (qb) => {\n                        qb.select(['appointment_id as parent_id', 'pet.*']);\n                    }\n                }]\n            });\n    }\n\n    // Otherwise, return all appointments\n    return Appointment.findAll({ businessId: businessId }, options);\n},\n\n```\nI see the following debug output:\n{ method: 'select',\n  options: {},\n  bindings:\n   [ null,\n     '35a2941c-d73f-4cf3-87de-bfbcbc92fbc5',\n     '5de28a57-ce4c-4fcc-865a-54cf97e08c6c',\n     'bf4b6784-b96a-4321-8335-e449aa8dcda1',\n     '695edc54-3a93-42a5-a3e0-b331f26912cf',\n     '76a99204-9659-4270-904c-2c42e5c40a15',\n     '28437e3c-abc1-4fd6-8c26-5543c09ab730',\n     '350da29d-0e82-4e6c-b9fe-be31c64655b4',\n     'bcaee041-c9ec-4a34-8c0d-8f21d2d79197',\n     '91380fcc-2f0d-4344-a24b-dc37abe3931f',\n     '31796797-5041-4fae-815b-0f2c368654b0',\n     '94800af3-fd23-4b59-af88-15b1f622e8e1',\n     'aa8c202d-249e-4ffc-ab55-e535f2c2121f',\n     '8a1fd093-45a6-4864-8c52-ea8851740f77',\n     '5f91ad6f-4231-4d18-b718-d99fcc17a18b',\n     '5f879e43-a44f-41dd-b9dd-11f06af4cc8d' ],\n  sql: 'select \"pet\".*, \"appointment_pet\".\"parent_id\" as \"_pivot_parent_id\", \"appointment_pet\".\"pet_id\" as \"_pivot_pet_id\" from \"pet\" inner join \"appointment_pet\" on \"appointment_pet\".\"pet_id\" = \"pet\".\"id\" where \"appointment_pet\".\"parent_id\" in (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'}\nRunning this command in postgres, I see the correct output, but still no relations. I saw #1203 and tried adding the parent_id explicitly to the select, but still no luck.\n@vellotis have you ran into anything like this?\n. Thanks, @vellotis!\n. Has anyone had any luck in resolving this issue?. Has anyone had any luck in resolving this issue?. @henriquehirako I'm getting the impression that Bookshelf has been abandoned. Knex is still in active development, but there hasn't been a commit in this repo since February and it had already decreased dramatically before then.. @vellotis any chance this gets merged soon? . @vellotis any chance this gets merged soon? . Sorry to be a pest, but is it possible to have one of the maintainers merge this fix soon?. Sorry to be a pest, but is it possible to have one of the maintainers merge this fix soon?. @vellotis what is this \"real\" physical world/people that you speak of? \ud83d\ude06 . @chamini2 mind sharing your solution? Ran into this myself.\n. @chamini2 mind sharing your solution? Ran into this myself.\n. @Znarkus there isn't an issue with a JSON object; the issue occurs when inserting a JSON Array. Ex:\njs\n[\n  { serviceName: 'Poop', 'petName': 'JJ', checked: true },\n  { serviceName: 'Pee', 'petName': 'Mario', checked: true },\n]\n@vellotis I'm using @ricardogama's bookshelf-json-columns library, which I believe does the same thing. Have you tried inserting a JSON array like my above example?\nI'm pretty convinced that this is a bug in Bookshelf as I'm able to insert a JSON array through Knex without an issue. \n. @dpiccone I would utilize the bookshelf-json-columns plugin. The aforementioned issue is specifically related to JSON arrays, but the plugin should work fine for a standard JSON object.\n. @dpiccone I would utilize the bookshelf-json-columns plugin. The aforementioned issue is specifically related to JSON arrays, but the plugin should work fine for a standard JSON object.\n. @cjnqt use the plugin I mentioned above. @ricardogama just released a new version that resolves this issue.\n. @cjnqt use the plugin I mentioned above. @ricardogama just released a new version that resolves this issue.\n. @ricardogama thanks for this PR! I just ran into this issue and this was a lifesaver. Cheers!\n. @vxcamiloxv did you ever get this to work properly?\nThis also doesn't work for me using Bookshelf 0.12.1.\n. @leebenson, I know you've already closed this and @fl0w already gave a great answer, but I felt inclined to chime in.\nI'd wholeheartedly agree with what @fl0w has to say. Bookshelf is great, except when it's not. But as you alluded to, designing and maintaining an ORM is no easy task. Especially when you're designing not for one, but for multiple databases. We're using Bookshelf in production and there have been a number of issues that have been difficult to navigate and are still lingering. I too have found myself dropping down to Knex for simple things that should ultimately be trivial with Bookshelf. That said, it's a good piece of software, but may not fit everyone's needs, especially with the lack of activity. With all that said, I'm certainly appreciative of everything that's been done by the Bookshelf team.\nMuch of what I said is nearly identical to what was said by @fl0w. My real reason for chiming in was more the lack of a core Node ORM, much like Rails has ActiveRecord or Elixir has Ecto. While it's great to have the variety in the Node community, I also believe that an ORM is a complex piece of software that can be greatly helped by a focused, drive community effort. With so many ORM projects scattered throughout the ecosystem, I feel like it's always going to be a battle.. @leebenson, I know you've already closed this and @fl0w already gave a great answer, but I felt inclined to chime in.\nI'd wholeheartedly agree with what @fl0w has to say. Bookshelf is great, except when it's not. But as you alluded to, designing and maintaining an ORM is no easy task. Especially when you're designing not for one, but for multiple databases. We're using Bookshelf in production and there have been a number of issues that have been difficult to navigate and are still lingering. I too have found myself dropping down to Knex for simple things that should ultimately be trivial with Bookshelf. That said, it's a good piece of software, but may not fit everyone's needs, especially with the lack of activity. With all that said, I'm certainly appreciative of everything that's been done by the Bookshelf team.\nMuch of what I said is nearly identical to what was said by @fl0w. My real reason for chiming in was more the lack of a core Node ORM, much like Rails has ActiveRecord or Elixir has Ecto. While it's great to have the variety in the Node community, I also believe that an ORM is a complex piece of software that can be greatly helped by a focused, drive community effort. With so many ORM projects scattered throughout the ecosystem, I feel like it's always going to be a battle.. Alternatively, if anyone is using Bookshelf and handling their authorization outside of it, I'd love to hear about it.. Alternatively, if anyone is using Bookshelf and handling their authorization outside of it, I'd love to hear about it.. ",
    "nodeit": "@anyong option 1 as implemented would be my preference.\n. @anyong I am doing so now. Thanks for the plugin, looks great!\n. ",
    "arden": "bookshelf update is so slowly, i'm think bookshelf-page is very great as bookshelf plugin, but integrate this as bookshelf's plugin is so slowly, i'm hope quickly, because paginate function is so so so common function for users. this discuss from 2014 year to 2016 year. oh my god.\n. @anyong OK\uff0cthanks.\n. custom pagination metadata by developer self: \nhttps://github.com/anyong/bookshelf-page/issues/5\n. when the bookeshelf-page can move to bookshelf as plugin?\n. when the bookeshelf-page can move to bookshelf as plugin?\n. custom pagination metadata by developer self: \nhttps://github.com/anyong/bookshelf-page/issues/5\n. ",
    "lawli3t": "I have a similar issue and cant seem to find a solution:\ni have those two models:\n``` javascript\nconst db = require(\"../db\");\nvar Track = db.Model.extend({\n    tableName: \"tracks\",\nartist: function() {\n    return this.belongsTo(\"Artist\");\n},\nalbum: function() {\n    return this.belongsTo(\"Album\")\n},\nplaylists: function() {\n    return this.belongsToMany(\"Playlist\");\n}\n\n});\nmodule.exports = db.model(\"Track\", Track)\n```\n``` javascript\nconst db = require(\"../db\");\nvar Playlist = db.Model.extend({\n    tableName: \"playlists\",\ntracks: function () {\n    return this.belongsToMany(\"Track\");\n}\n\n});\nmodule.exports = db.model(\"Playlist\", Playlist);\n```\nand try to query them like so:\n``` javascript\n// definition of db\nglobal.db = {\n  Artist: require(\"./models/artist\"),\n  Album: require(\"./models/album\"),\n  Playlist: require(\"./models/playlist\"),\n  Track: require(\"./models/track\"),\n}\n//query\ndb.Playlist.forge().fetchAll({withRelated: \"tracks\"}).then((playlists) => {\n  var json = playlists.toJSON();\n  deferred.resolve(json);\n});\n```\nbut get an empty array in playlists.tracks\ndebug output:\njavascript\n{ method: 'select',\n  options: {},\n  timeout: false,\n  cancelOnTimeout: false,\n  bindings: [],\n  __knexQueryUid: 'e8a13009-e636-41f5-aedf-5ed7841b52fa',\n  sql: 'select \"playlists\".* from \"playlists\"' }\n{ method: 'select',\n  options: {},\n  timeout: false,\n  cancelOnTimeout: false,\n  bindings: [ 3, 4 ],\n  __knexQueryUid: 'd4a96e37-9639-4cf9-9ed7-e7bea11402cc',\n  sql: 'select \"tracks\".*, \"playlists_tracks\".\"playlist_id\" as \"_pivot_playlist_id\", \"playlists_tracks\".\"track_id\" as \"_pivot_track_id\" from \"tracks\" inner join \"playlists_tracks\" on \"playlists_tracks\".\"track_id\" = \"tracks\".\"id\" where \"playlists_tracks\".\"playlist_id\" in (?, ?)' }\nmy database:\n``` sql\nBEGIN TRANSACTION;\nCREATE TABLE \"tracks\" (\"id\" integer not null primary key autoincrement, \"name\" varchar(255), \"artist_id\" integer, \"album_id\" integer, \"file\" varchar(255), \"duration\" float, \"track_nr\" integer, \"quality\" integer, foreign key(\"artist_id\") references \"artists\"(\"id\"), foreign key(\"album_id\") references \"albums\"(\"id\"));\nCREATE TABLE \"playlists\" (\"id\" integer not null primary key autoincrement, \"name\" varchar(255), \"created_at\" datetime, \"updated_at\" datetime);\nCREATE TABLE \"playlists_tracks\" (\"track_id\" integer, \"playlist_id\" integer, foreign key(\"track_id\") references \"tracks\"(\"id\"), foreign key(\"playlist_id\") references \"playlists\"(\"id\"));\nINSERT INTO tracks VALUES (1,'xx',1,1,'/xxx',1.0,1,1);\nINSERT INTO playlists_tracks VALUES (1,3);\nINSERT INTO playlists VALUES (3,'playlist',NULL,NULL);\nINSERT INTO playlists VALUES (4,'ghjghj',NULL,NULL);\nCOMMIT;\n```\nif i run the generated query in the database i get 1 result, which leads me to the conclusion that the problem must reside somewhere in my code\n. I have a similar issue and cant seem to find a solution:\ni have those two models:\n``` javascript\nconst db = require(\"../db\");\nvar Track = db.Model.extend({\n    tableName: \"tracks\",\nartist: function() {\n    return this.belongsTo(\"Artist\");\n},\nalbum: function() {\n    return this.belongsTo(\"Album\")\n},\nplaylists: function() {\n    return this.belongsToMany(\"Playlist\");\n}\n\n});\nmodule.exports = db.model(\"Track\", Track)\n```\n``` javascript\nconst db = require(\"../db\");\nvar Playlist = db.Model.extend({\n    tableName: \"playlists\",\ntracks: function () {\n    return this.belongsToMany(\"Track\");\n}\n\n});\nmodule.exports = db.model(\"Playlist\", Playlist);\n```\nand try to query them like so:\n``` javascript\n// definition of db\nglobal.db = {\n  Artist: require(\"./models/artist\"),\n  Album: require(\"./models/album\"),\n  Playlist: require(\"./models/playlist\"),\n  Track: require(\"./models/track\"),\n}\n//query\ndb.Playlist.forge().fetchAll({withRelated: \"tracks\"}).then((playlists) => {\n  var json = playlists.toJSON();\n  deferred.resolve(json);\n});\n```\nbut get an empty array in playlists.tracks\ndebug output:\njavascript\n{ method: 'select',\n  options: {},\n  timeout: false,\n  cancelOnTimeout: false,\n  bindings: [],\n  __knexQueryUid: 'e8a13009-e636-41f5-aedf-5ed7841b52fa',\n  sql: 'select \"playlists\".* from \"playlists\"' }\n{ method: 'select',\n  options: {},\n  timeout: false,\n  cancelOnTimeout: false,\n  bindings: [ 3, 4 ],\n  __knexQueryUid: 'd4a96e37-9639-4cf9-9ed7-e7bea11402cc',\n  sql: 'select \"tracks\".*, \"playlists_tracks\".\"playlist_id\" as \"_pivot_playlist_id\", \"playlists_tracks\".\"track_id\" as \"_pivot_track_id\" from \"tracks\" inner join \"playlists_tracks\" on \"playlists_tracks\".\"track_id\" = \"tracks\".\"id\" where \"playlists_tracks\".\"playlist_id\" in (?, ?)' }\nmy database:\n``` sql\nBEGIN TRANSACTION;\nCREATE TABLE \"tracks\" (\"id\" integer not null primary key autoincrement, \"name\" varchar(255), \"artist_id\" integer, \"album_id\" integer, \"file\" varchar(255), \"duration\" float, \"track_nr\" integer, \"quality\" integer, foreign key(\"artist_id\") references \"artists\"(\"id\"), foreign key(\"album_id\") references \"albums\"(\"id\"));\nCREATE TABLE \"playlists\" (\"id\" integer not null primary key autoincrement, \"name\" varchar(255), \"created_at\" datetime, \"updated_at\" datetime);\nCREATE TABLE \"playlists_tracks\" (\"track_id\" integer, \"playlist_id\" integer, foreign key(\"track_id\") references \"tracks\"(\"id\"), foreign key(\"playlist_id\") references \"playlists\"(\"id\"));\nINSERT INTO tracks VALUES (1,'xx',1,1,'/xxx',1.0,1,1);\nINSERT INTO playlists_tracks VALUES (1,3);\nINSERT INTO playlists VALUES (3,'playlist',NULL,NULL);\nINSERT INTO playlists VALUES (4,'ghjghj',NULL,NULL);\nCOMMIT;\n```\nif i run the generated query in the database i get 1 result, which leads me to the conclusion that the problem must reside somewhere in my code\n. ",
    "demmer": "Great. Thanks!\n. Great. Thanks!\n. ",
    "ericeslinger": "For future visitors, here's what I did in my workaround to add some general-purpose query mapping into the Bookshelf model.\nhttps://gist.github.com/ericeslinger/a83e74501e9901c8b795\n. For future visitors, here's what I did in my workaround to add some general-purpose query mapping into the Bookshelf model.\nhttps://gist.github.com/ericeslinger/a83e74501e9901c8b795\n. Rad, thanks. I just worked around this by doing:\ncoffeescript\n  authorize: (user, level)->\n    draftPromise = if @attributes.target_id?\n      Promise.resolve @\n    else\n      Draft.forge({id: @get('id')}).fetch()\n    draftPromise.then (d)->\n      #do some stuff\nwhich does the job for now but is a kludge.\n. This is correct - NPM is now complaining about an unmet peer dependency, because I'm using knex 0.11.1 and bookshelf wants 0.9.4 wants < 0.11.0 from knex.\n. ",
    "StephanHoyer": "It seem like. I just upgraded, but same behavior occurs. This is my parse-function:\njavascript\n  parse: function parse(dbData) {\n    return _.zipObject(_.map(dbData, function(data, key) {\n      // there is a problem with morph relations an formated keys\n      // https://github.com/tgriesser/bookshelf/issues/443\n      if (key != 'placeable_type' && key != 'placeable_id') {\n        key = _str.camelize(key);\n      }\n      return [key, data];\n    }));\n  },\n. Other solution would be to allow a format and parse function for one key (e. G. formatKey).\nThis can also be called at the related keys in the mentioned file.\n. Just what I need ATM... would be great to have this\n. Just what I need ATM... would be great to have this\n. ",
    "IcanDivideBy0": "+1\n. ",
    "hellboy81": "\nweirdly complex and painstaking .. much better to pick easier life and use node mysql or any other ORM. \nnode mysql\n\nAn build sql strings manually, OK\n\nORM\n\nwhich?\n\nThis sucks badly\n\nOK\n. ",
    "vishchiv": "Take a look on this answer http://stackoverflow.com/questions/36639073/transaction-for-collection. Take a look on this answer http://stackoverflow.com/questions/36639073/transaction-for-collection. @absolux \nThanks for a reply, I didn't figure out it right away. I cannot use UTC date due to application business requirements so now I'm using this solution >> https://github.com/tgriesser/bookshelf/issues/246 .. @absolux \nThanks for a reply, I didn't figure out it right away. I cannot use UTC date due to application business requirements so now I'm using this solution >> https://github.com/tgriesser/bookshelf/issues/246 .. I'm also wondering if this possible. I'm also wondering if this possible. @kirrg001 ok, here it is #2022. This way I will close this ticket.. ",
    "villelahdenvuo": "I made a simple test:\n``` javascript\nvar bookshelf = require('../db/database');\nvar chai = require('chai');\nchai.should();\nchai.use(require('chai-as-promised'));\nvar Test = bookshelf.Model.extend({\n  tableName: 'form_test'\n});\ndescribe('Form entry test', function () {\n    it('should have save_id', function () {\n        var entry = Test.where('save_id', '81dae66e-27de-4a79-8bd1-fdb6ae430578').fetch()\n    entry.should.eventually.have.property('attributes')\n            .that.has.property('save_id', 'not this');\n});\n\n});\n```\nAnd it outputs:\n```\n  Form entry test\n    \u2713 should have save_id \nPossibly unhandled AssertionError: expected { Object (id, save_id, ...) } to have a property 'save_id' of 'not this', but got '81dae66e-27de-4a79-8bd1-fdb6ae430578'\n1 passing (42ms)\n```\nThe problem could be fixed by calling Promise.onPossiblyUnhandledRejection(null);, but I don't know how to get to it elegantly.\n. @tgriesser You're right, I tried it at one point, but I must have failed something else, because it wasn't working. With the reduced example it works. Thanks for the quick reply!\n. Also got bitten by this bug. I have a fetched:collection listener, but it is being called when I do Model.fetch() and my code is expecting a collection not a model.\n. I did some digging and I think I found the culprit. When the event code was refactored to use Lodash's word function, it started splitting events with colons into multiple events: https://github.com/tgriesser/bookshelf/compare/0.9.1...0.9.2#diff-c874145af93ab1534cfa36243da25a76R111\n```\n\n_.words('fetched:collection')\n[\"fetched\", \"collection\"]\n``\n. Just gotta supply the old regex for the words function, I think that should do the trick. \n. @rhys-vdw Thanks for the quick fix release! :palm_tree: \n. Like @rhys-vdw said you can just do:new Bar({ blah: blah.val, fooId: foo.id });`\n. \n",
    "alexkirsz": "Yup.\n. ",
    "alliejanoch": "Sure, no problem. Should be taken care of now.\n. Yeah, no problem: I have models Organization, User and Project (among others, but these are the ones relevant here). A User can be attached to Organizations, and a User can also be attached to Projects. Projects belong to an Organization. \nSo say I have Project P, and it belongs to Organization O. If User U is attached to organization O, then it should be ok to attach P to U. But, if U is not attached to O, then I want to throw an error before attaching (thus the attaching event). In other words, users shouldn't  be able to attach to projects unless they are attached to the organization that the project belongs to. I'm not using the attached event.\n. Yeah, no problem: I have models Organization, User and Project (among others, but these are the ones relevant here). A User can be attached to Organizations, and a User can also be attached to Projects. Projects belong to an Organization. \nSo say I have Project P, and it belongs to Organization O. If User U is attached to organization O, then it should be ok to attach P to U. But, if U is not attached to O, then I want to throw an error before attaching (thus the attaching event). In other words, users shouldn't  be able to attach to projects unless they are attached to the organization that the project belongs to. I'm not using the attached event.\n. Yea, I think that is a good point. I'm going to close this.\n. Yea, I think that is a good point. I'm going to close this.\n. ",
    "tkambler": "I also need this and am surprised that no one else has asked about it. I've only been using Bookshelf for a few days and almost immediately ran into this.\n. I also need this and am surprised that no one else has asked about it. I've only been using Bookshelf for a few days and almost immediately ran into this.\n. Assume the following models / collection are in place:\n```\nvar States = bookshelf.Collection.extend({\n    'model': State,\n    'comparator': 'year_joined'\n});\nvar Country = bookshelf.Model.extend({\n    'states': function() {\n        return this.hasMany(States);\n    }\n});\nvar State = bookshelf.Model.extend({\n    'country': function() {\n        return this.belongsTo(Country);\n    }\n});\n```\nA country has many states, each of which have a \"year_joined\" attribute that indicates when they joined the country.\nAssume the following data:\n```\ncountries: [\n    {\n        'id': 1,\n        'name': 'USA'\n    }\n]\nstates: [\n    {\n        'id': 1,\n        'name': 'TN',\n        'year_joined': 1801\n    },\n    {\n        'id': 2,\n        'name': 'CA',\n        'year_joined': 1800\n    }\n]\n```\nIf I fetch a country with the following code, I would expect the models under the nested \"states\" relationship to already be in the expected order:\nCountry.where({\n    'id': 1\n}).fetch({\n    'withRelated': ['states']\n}).then(function(country) {\n    console.log(country.toJSON());\n}).catch(function(err) {\n});\nCurrently, they are not. I also shouldn't have to pass an \"ORDER BY\" clause each time I fetch the country, if a comparator has already been defined on the nested collection.\n. I'm fairly new to Knex, so I didn't realize you could pass an \"orderBy\" within the relationship function. I just attempted to do so, and am now seeing a bad query get generated:\n... order by \"position\" undefined' }\n. OK - I was able to resolve that error. Apparently you have to pass a sort direction, otherwise it passes \"undefined\" - Seems like the default behavior should be to default to ASC.\nBack to the original issue - I agree that passing the sort within the query is the preferred approach, when possible. That said, if a collection has a comparator assigned to it, it seems to me that the default and expected behavior should be to respect that comparator as soon as models are added to the collection (including from within the constructor).\n. I'm not sure what the default behavior in Backbone is. I'll confirm and get back to you.\nRE: undefined sort order:\nbookshelf 0.7.7\nknex 0.7.3\nPostgreSQL 9.3\n```\nvar Section = bookshelf.Model.extend({\n'tableName': 'sections',\n\n'fieldsets': function() {\n    var Fieldsets = require('../../collections/fieldsets');\n    return this.hasMany(Fieldsets).query('orderBy', 'position'); // this result in the query's order being \"undefined\"\n}\n\n}\n``\n. I suppose so. As it stands, I have to hard code that in myself after everysave(), which isn't ideal. If you're afraid that this is bad from an efficiency standpoint, I suppose this could have some sort of on / off configuration setting... but the use case is so common, I almost don't see the point. Plenty of people modify incoming records via store procedures, etc..., that fetching after save almost has to be done.\n. I could also see this being a setting on the model level. X model auto-fetches after save, Y model does not. In my case, they all would. :)\n. That should work for now - thanks.\n. @tgriesser I overrode Model'ssavemethod, as in your previous example. That now presents a new problem... Fetching updated data for the model viamodel.fetch()creates a query with a 'where' clause that queries every column defined on the model. This is causing several other issues. I've tried to update thefetchcall so that it only queries off of theid` column, but have yet to figure out how to do it. Here's what I've got:\nvar save = bookshelf.Model.prototype.save;\nbookshelf.Model.prototype.save = function() {\n    return save.apply(this, arguments).then(function(model) {\n        return new Promise(function(resolve, reject) {\n            var q = {\n                'where': {\n                    'id': model.get('id')\n                }\n            };\n            model.resetQuery().query(q).fetch().then(function(m) {\n                resolve(m);\n            }).catch(function(err) {\n                reject(err);\n            });\n        });\n    });\n};\nI thought resetQuery would do it - but it doesn't seem to?\n. Nor does this work:\nmodel.resetQuery().where({\n    'id': model.get('id')\n}).fetch().then(function(m) {\n    resolve(m);\n}).catch(function(err) {\n    reject(err);\n});\n. Check out this query I'm getting:\nsql\nselect \"assessments\".* from \"assessments\" where \"id\" = $1 \nand \"assessments\".\"id\" = $2 \nand \"assessments\".\"client_id\" = $3 \nand \"assessments\".\"created_at\" = $4 \nand \"assessments\".\"updated_at\" = $5 \nand \"assessments\".\"submitted_at\" is null \nand \"assessments\".\"form_id\" = $6 \nand \"assessments\".\"assessor_id\" = $7 \nand \"assessments\".\"member_id\" = $8 \nand \"assessments\".\"private_key\" = $9\nand \"assessments\".\"public_key\" = $10 \nand \"assessments\".\"data\" = $11 \nand \"assessments\".\"status\" = $12 limit $13\n. I'm temporarily working around this with:\nvar save = bookshelf.Model.prototype.save;\nbookshelf.Model.prototype.save = function() {\n    return save.apply(this, arguments).then(function(model) {\n        return new Promise(function(resolve, reject) {\n            knex(model.tableName).where({\n                'id': model.get('id')\n            }).limit(1).then(function(result) {\n                model.set(result[0]);\n                resolve(model);\n            }).catch(function(err) {\n                reject(err);\n            });\n        });\n    });\n};\n. Thanks :+1: \n. @ricardograca Are you using PostgreSQL? Only PostgreSQL supports returning\n. @ricardograca Are you using PostgreSQL? Only PostgreSQL supports returning\n. @jclem Did you try my example from October? While I feel this type of thing should be baked in to Bookshelf as an option, I've been using this w/ default values since October without issue.\n. @jclem Did you try my example from October? While I feel this type of thing should be baked in to Bookshelf as an option, I've been using this w/ default values since October without issue.\n. Done.\n. ",
    "jondlm": "Sure! The name of my schema is actually idento, not schema:\nnew User().fetchAll({withRelated: ['sessions']}).then(function(items) {\n  reply(items);\n});\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [],\n  sql: 'select \"idento\".\"users\".* from \"idento\".\"users\"' }\n{ __cid: '__cid2',\n  method: 'select',\n  options: undefined,\n  bindings: [ 1, 2 ],\n  sql: 'select \"idento\".\"sessions\".* from \"idento\".\"sessions\" where \"idento\".\"sessions\".\"idento\".\"user_id\" in ($1, $2)' }\nIt's definitely constructing the query incorrectly. I was hoping there would be something like tableSchema alongside the tableName attribute.\nI also tried adding a raw query to my knex init (for pg) to get around the problem:\nknex.raw(\"set session schema 'idento';\");\nBut that doesn't stick for all queries. Thanks for your help! Loving the library so far.\n. Sure thing! I would make:\n{ __cid: '__cid2',\n  method: 'select',\n  options: undefined,\n  bindings: [ 1, 2 ],\n  sql: 'select \"idento\".\"sessions\".* from \"idento\".\"sessions\" where \"idento\".\"sessions\".\"idento\".\"user_id\" in ($1, $2)' }\ninto\nselect \"idento\".\"sessions\".*\nfrom \"idento\".\"sessions\"\nwhere \"idento\".\"sessions\".\"user_id\" in (1, 2);\nThe general syntax is database.schema.table, as seen on the postgres docs. That's generally true on most databases, I suspect it's true for mysql as well.\n. @aol-nnov ahh that's a clever work-around. I'll give that a go for the time being. Thanks for the tip!\n. @aol-nnov ahh that's a clever work-around. I'll give that a go for the time being. Thanks for the tip!\n. I found another way to solve this problem after delving deep into the belly of knex and its unit tests:\n```\nvar r = require('project-base');\nvar settings = require(r + 'config/settings.js');\nvar Promise = require(r + 'node_modules/knex/node_modules/bluebird/');\nvar knex = require('knex')({\n  client: 'pg',\n  debug: true,\n  connection: {\n    host: settings.postgres.host,\n    user: settings.postgres.user,\n    password: settings.postgres.password,\n    database: settings.postgres.database,\n    port: settings.postgres.port\n  },\n  pool: {\n    afterCreate: function(connection, callback) {\n      Promise.promisify(connection.query, connection)(\"SET SESSION SCHEMA 'idento';\", []).then(function() {\n        callback(null, connection);\n      });\n    }\n  }\n});\n```\nThat makes it so every query I execute goes against the idento schema. Obviously this isn't helpful if some of your tables span schemas. Note, my solution is postgres specific.\n. ",
    "aol-nnov": "@jondlm, to workaround this issue I was using a full variant of belongsTo call (http://bookshelfjs.org/#Model-belongsTo) where in the second argument you need to provide thable name along with schema name.\nvar entity1 = orm.Model.extend({\n    tableName: 'store.entity1',\n    color: function() {\n        return this.belongsToMany(Entity2, 'store.entity2', 'entity1_fk', 'entity2_key');\n    }\n});\na bit more verbose, but it solves the issue  though\nHTH,\nAndrey\n. @jondlm, to workaround this issue I was using a full variant of belongsTo call (http://bookshelfjs.org/#Model-belongsTo) where in the second argument you need to provide thable name along with schema name.\nvar entity1 = orm.Model.extend({\n    tableName: 'store.entity1',\n    color: function() {\n        return this.belongsToMany(Entity2, 'store.entity2', 'entity1_fk', 'entity2_key');\n    }\n});\na bit more verbose, but it solves the issue  though\nHTH,\nAndrey\n. @rhys-vdw , I can confirm that tableName: 'schema.table' works fine with bookshelf version 0.9.1 and knex version 0.9.0\n. oh, my! I might be blinded!\nI was absolutely sure, I created timestamp with timezone columns!\nevil autocompletion, argh!!\nsorry for disturbing!\n//Just changed column types and it worked like a charm.\n. @bendrucker, very true!\n@ricardograca, thanks for pointing out!\n. ",
    "BarnabasAspray": "Thanks very much for this, jondlm! Your solution works well for me. \n. ",
    "raaymax": "+1 \n\"set session schema\" is not a solution for me.\nI use set search_path with many schemas and some of them have same table names (i can't change that).\nsome \"schemaName\" field in model would by great :)\n. ",
    "battlemidget": "Very interested in the withSchema support as well\n. Very interested in the withSchema support as well\n. ",
    "aledbf": "+1\n. ",
    "richardsimko": "Knex has released withSchema now, any plans on supporting it? It would be nice to be able to do for example Model.fetchAll().withSchema('schema'), since I'm using schemas for tenant separation, defining it in the models wont' work for me.\n. Knex has released withSchema now, any plans on supporting it? It would be nice to be able to do for example Model.fetchAll().withSchema('schema'), since I'm using schemas for tenant separation, defining it in the models wont' work for me.\n. My idea was to use schemas for tenant separation and as such I would had needed a solution where I could supply the schema during a query. Perhaps similarly to how transactional works?\n. Any ETA on merging this? Currently the combination of snake_case in the database and camelCase on the models is broken because of the issue fixed in this PR.\nI rewrote the example in the docs to the following as a workaround:\nparse: function(attrs) {\n  const _this = this;\n  return _.reduce(attrs, function(memo, val, key) {\n    memo[_.camelCase(key)] = val;\n    if (key === _this.idAttribute) {\n      memo[key] = val;\n    }\n    return memo;\n  }, {});\n},\n. Ping @tgriesser or any other contributors\n. @vellotis No, I'm afraid I don't. All that does is save the value returned from calling relationName() into this.relations['relationName'] and recalling it if it's already set. This should mean that calling relationName() the first time should give the same result as .related('relationName') yet it doesn't (See my question above).\n. @vellotis No, I'm afraid I don't. All that does is save the value returned from calling relationName() into this.relations['relationName'] and recalling it if it's already set. This should mean that calling relationName() the first time should give the same result as .related('relationName') yet it doesn't (See my question above).\n. Indeed, using where() worked out just fine, thanks! :)\n. This seems to be causing #1502, can anyone with a  bit more knowledge of the code share some insight on why that might be happening?. @vellotis @ricardogama any feedback on this causing #1502 ? It's a blocker for us to update Bookshelf right now.. The culprit is here: https://github.com/tgriesser/bookshelf/blob/1860604f57accdce19c6a1af0ef65bbdaf5b8531/src/relation.js#L398\nIf this.parentIdAttribute doesn't match the name of the attribute in the target model it doesn't work. Of course in this case they won't match because obviously one is in snake_case and the other in camelCase.\nAt this point model is not an instance of my model but instead just an instance of BookshelfModel otherwise calling .parse on it could have worked.\nAny workarounds are welcome as well as suggested fixes, I think I've done as much as I'm able to with my limited knowledge of the code base.\nActually on second though the behavior on that line has changed completely and I'm wondering if that may be an accident? It's changed from model.id (I.e. the ID of the target model) to model.get(this.parentIdAttribute) (I.e. the ID of the parent model fetched from the target model). I may be wrong here but those aren't supposed to be the same?. Any updates on this @tgriesser ? It's a blocker for us to update to more recent versions right now.. @ricardogama Sadly this.attribute('parentIdAttribute') seems to return undefined at that point.. Thanks for your input! May I ask what you use instead? We've also been looking at alternatives for the same reason but I haven't found a good alternative yet.. Great, thanks for the tip! I'll have a look at that as an alternative.\nDon't fret about the bugs, as long as no critical issues are discovered in 0.10.2 we can just refrain from updating for now.\nFor our use case, resetting it to just\ngroupedKey = model.id;\n\nseems to work, however I'm unsure if that works with foreignKeyTarget as well, I would assume that there was a reason for changing it in the first place ;). ",
    "codematix": "+1\n. I second @RichardSimko's suggestion. I too have the same use case where I switch schemas based on the tenant sending a request to my API. Hence I would feel having a way to dynamically specify the schema at the time of save, destroy or query would be ideal.\nAnother idea is to have a method on bookshelf called withSchema(schemaName, fn) which accepts the name of schema and a function that provides a schema isolated instance of bookshelf from where I can access models attached to the specified schema.\n``` javascript\nbookshelf.withSchema('schema1', (schema1) => {\n  const User = schema1.model('User');\nUser\n    .forge({ id: 'jdoe@foo.com' })\n    .fetch()\n    .then((jdoe) => { / do something with jdoe / })\n    .catch((err) => { / handle error / });\n});\n```\n. ",
    "albertovasquez": "@tobymarsden have you encountered any side effects with your update to Sync?\n. Thanks for the quick reply.  Am going to try that approach until something a little more permanent is available.  Thanks!\n. @tobymarsden unfortunately that solution breaks as you expected, during relationships.   For multi-tenant architectures we do need a proper solution.   Thanks for that .. took me 80% of the way.\n. @rhys-vdw What would be nice is if we could specify per model a schemaName attribute.  That it will use even if we pass a withSchema option with save, insert etc (using @tobymarsden path above).   The reason this is needed on multi-tenant solutions is we might have schema for each user/tenant but still have a public schema for all users that contains information not specific to each tenant.  Without having the schemaName attribute override we would append the schema passed via options on all tables.  This has caused some issues that I can't see a workaround at the moment.\n. ",
    "natew": "@tobymarsden's patch actually is allowing me to use bookshelf now, at least with the queries I've tried (regular selects + a select withRelation) and no problems. Would be better than nothing, at least for me.\n. ",
    "rmharrison": "withSchema support would be greatly appreciated. Same problem with hasMany() and belongsT0()\n. Currently using a similar workaround with pluck(). Suspect that wanting to fetch just the ids is a fairly common use-case. \nRead through available bookshelf plugins on npm. None seem to support id only on withRelated.\n@rhys-vdw Plugin, or would you be open to a PR that used columns alongside withRelated, e.g.?\nParent.forge().fetch({withRelated: ['child'], columns: ['parent_attr', 'child.id']})\n. Usenet answer: Out of scope. Closed.\nShort answer: If you have to ask that question, you shouldn't. :-p\nMedium answer: Seriously. Watch this video: Youtube: How NOT to Store Passwords!\nLong answer\n1. Use a fully-featured service and established 3rd party identity providers\nFor the vast majority of B2C apps, you and your users will be happier using an established identity provider (Openid, GitHub, Facebook, LinkedIn, Gmail, etc). For B2B, they'll want SSO (Single-Sign-On). You can have multiple identify providers. The choice is largely a business decision.\nOn the tech-side, 3rd party providers like auth0 (industry leader, but there are about a dozen others) offer this as a service. Other services like Firebase do even more.\nBasically, no real reason to do it yourself. All of the above feature nifty web consoles for user management and tons of other features that aren't worth building yourself.\n2. Do it yourself with a 3rd party identity provider\nPassport-JS is the standard and supports all of the major providers. Optionally, you can choose to persist a straight-forward user / session table. No messing about with secure password storage, etc.\n3. Do it yourself\nOnly if:\n- Educational project / for the lulz\nOR\n- You know what you're doing\n- Have a compelling reason to not do (1) and (2), e.g. an on-premise requirement, highly regulated industry, etc.\n. Given that this is just a README change, spurious fail on 0.12 me thinks (pass: 0.10, 4, 6)\n1) Integration Tests Dialect: mysql \"before all\" hook for \"should allow swapping in another knex instance\":\n     Error: timeout of 5000ms exceeded. Ensure the done() callback is being called in this test.\n. ",
    "hillscottc": "Thanks to @jondlm for the afterCreate tip. \nHere is what I am using. No bluebird required.\nconst Bookshelf = bookshelf(\n  knex({\n    client: 'pg',\n    debug: 'true',\n    connection: config.databaseUrl,\n    pool: {\n      min: 0,\n      max: 10,\n      afterCreate: function (conn, cb) {\n        conn.query(\"SET SESSION SCHEMA 'my-schema-name-here';\", function (err) {\n          cb(err, conn);\n        });\n      }\n    }\n  }));. Thanks to @jondlm for the afterCreate tip. \nHere is what I am using. No bluebird required.\nconst Bookshelf = bookshelf(\n  knex({\n    client: 'pg',\n    debug: 'true',\n    connection: config.databaseUrl,\n    pool: {\n      min: 0,\n      max: 10,\n      afterCreate: function (conn, cb) {\n        conn.query(\"SET SESSION SCHEMA 'my-schema-name-here';\", function (err) {\n          cb(err, conn);\n        });\n      }\n    }\n  }));. ",
    "mgarf": "after create won't work for mmsql. Any update on when this becomes a property to set when creating a model.. ",
    "Gringox": "@johanneslumpe you are 100% right!\nThank you for your quick response and sorry for the noob question.\n:)\n. ",
    "andresz1": "Ok! ty :)\n. Ok! ty :)\n. ",
    "malte-wessel": "Hey @AntJanus I made a gist of my current implementation: \nhttps://gist.github.com/malte-wessel/872dc16c1ffb367af49c\nIt differs a bit from the above described methods.\nCheers!\n. Hey @AntJanus I made a gist of my current implementation: \nhttps://gist.github.com/malte-wessel/872dc16c1ffb367af49c\nIt differs a bit from the above described methods.\nCheers!\n. ",
    "sgmccli": "+1\n. ",
    "sirgalleto": "Is this the only workaround? Is not the cleanest solution \ud83e\udd14 . There are many reasons to clean a model, in my case I was looking for an approach to clean all my database as a part of my integration tests. For that, I have used knex-cleaner. \nI think could work for another of you.. ",
    "asap": "@MartinMuzatko I'm actually trying something like that and I'm getting:\n```\nawait Address\n  .where({\n    primary: true,\n    customer_id: model.get('customer_id'),\n  })\n  .fetchAll()\n  .invokeThen('save', { primary: false });\n// Error:\nAddress.where(...).fetchAll(...).invokeThen is not a function\n```\nUltimately, what I'm trying to accomplish is the concept of a \"primary\" address for a customers. If we add a new \"primary\" address, I want to go through and set all other \"primary\" addresses for that customer to false.. So, after posting this and doing more digging, this worked for me:\nawait Address\n  .where({\n    primary: true,\n    customer_id: model.get('customer_id'),\n  })\n  .save({\n    primary: false\n  }, {\n    method: 'update',\n    patch: true,\n  });. ",
    "wolfgangschoeffel": "What also works is specifying book_id as unsigned:\njavascript\nfunction up() {\n    knex.schema.createTable('books', function(table) {\n    table.increments('id').primary();\n    table.string('name');\n  }).createTable('summaries', function(table) {\n    table.increments('id').primary();\n    table.string('details');\n    table.integer('book_id').unique().unsigned().references('books.id');\n  });\n};\n. ",
    "matyo91": "@bendrucker : yes, i did write manualy on browser file, because when i did gulp build, i got too much diff in deps.js and bookshelf.js, didn't understand why. I do not want to break something ...\n@tgriesser : i understand, but i can explain my issue. I got a node module (or browser) where I want to use bookshelf.\nThe problem is I have to make all my exports as function as :\nmodule.exports = (bookshelf) ->\n  Model = bookshelf.Model()\n  return Model\nevery where in my files as bookshelf become a strong dependency\nI prefer use it as \nbookshelf = require('bookshelf')\nModel = bookshelf.Model()\nmodule.exports = Model\nThe problem when using bookshelf or knex is that you alway have to instanciate the connection.\nAnd for me, i want to extends my models without having to carring about the connection, because the modules are like a part of framework.\nThen it will be in my server module (for instance), that require my main modules, i will there instanciate my connection.\nYou have an example for http://mongoosejs.com/ where you can make\nmongoose.connect('mongodb://localhost/test')\nwhen you want.\nSecondly, for my purpose, i use dependency injection and writing module.exports as function do return different instances of the same model class or collection class.\nSo that why ... I must instanciate bookshelf with the default sqlite client (memory), then switch it with the real one (mysql)\nThat's weird ... but i came on this change. If you have better idea i take it !\n. I finnaly fixit myself by this trick (without changing the bookshelf git repository) :\n```\nmyBookshelf.coffee :\nknex = require(\"knex\")({\n  \"client\": 'sqlite',\n  \"connection\": {\n    \"filename\": ':memory:'\n  }\n})\nbookshelf = require(\"bookshelf\")(knex)\nbookshelf.Model::_builder = bookshelf.Collection::_builder = (tableName) ->\n  builder = bookshelf.knex(tableName)\n  instance = this\n  builder.on \"query\", (data) ->\n    instance.trigger \"query\", data\n    return\nmodule.exports = bookshelf\n```\nthen\nbookshelf = require('myBookshelf')\nbookshelf.knex = require(\"knex\")({ ... 'mysql' ...})\nvery bad, but it fit for me.\nSorry for the trouble. Hope it help's someone.\n. Of course.\nHere is a case :\n``` coffee\ncreated = (model) ->\n  othermodel = new Model\n    model_id: model.id\n  othermodel.save().then ->\n    console.log 'othermodel save'\npromise = Promise.resolve()\npromise.then ->\n  model = new Model()\n  model.once 'created', created\n  model.save().then ->\n    console.log 'model save'\n```\nSo here : 'model save' will display but not 'othermodel save'\nBut if you make model.on 'created', created\nThis will work\nThis may be more relevant for 'destroying' event\n``` coffee\ndestroying = (model) ->\n  othermodels = new Collection()\n  .query\n    where: model_id: model.id\n  .fetch().then ->\n    console.log 'othermodel find'\npromise = Promise.resolve 666\npromise.then (id) ->\n  model = new Model id: id\n  model.once 'destroying', destroying\n  model.destroy().then ->\n    console.log 'model.id is undefined', model.id\n    console.log 'model save'\n``\n. YestriggerThentraverse well all triggers and return aPromiseLib.all` for waiting all promises completion as\ncoffee\ntriggerThen = (name) ->\n  dfds = []\n  ...\n  try\n    if (evts) push.apply(dfds, triggerEvents(evts, args))\n    if (allEvents) push.apply(dfds, triggerEvents(allEvents, arguments))\n  catch (e)\n    return PromiseLib.reject(e)\n  return PromiseLib.all(dfds)\nSo no problem in that part.\nThe problem here come from Backbone.Events.once function source code that just encapsulate Backbone.Events.on event into _.once sub function but do not return the original function value. I just added the return keyword from the source that's the only change.\nWhen applying model.once, Backbone.Events.once transform the function by not returning any value (the promise or what else). So  dfds become an array of 1 undefined value and PromiseLib.all resolve it directly. And the nested promises inside the event function are not executed\nAt the opposite, when you make an model.on, triggerEvents(evts, args) do trigger the function and get the return value and all works well.\n. Okey, i did a new pull request at #485 \n. ",
    "jpstone": "Any way to turn off the auto commit/rollback? If I need to save related data to multiple tables, and one of those fails, the transaction commits. Auto commits/rollbacks seem to work fine if you have just one Promise.map to a single related table, but if you have multiple Promise.maps to multiple tables, it doesn't catch errors in the second (or third, what have you) Promise.map.\nI switched to using knex directly which allows me to specify the commits/rollbacks and it worked fine, but I lose bookshelf's events when I do that.\nHow can I turn off the auto commits/rollbacks?\n. Never mind, I just had to remove the \"return\" within the transaction on the promise.\n. Here's the code:\nhttps://gist.github.com/jpstone/5332364ed65308a447ac\nFor both hidden and visible, I was expecting it to work like it did for a single record. I was taken by surprise to see them fail for multiple records.\nMy virtual values each show up as undefined, while my hidden columns simply show up.\n. Now that I think about it, this might not be working because my parse() isn't parsing fetchAll requests, only fetch. Since the columns are in snake_case when fetching all, this might be why it's failing.\nI opened an issue for the parse() not working (962).\n. Sure enough, this issue is happening because parse() isn't working on fetchAll(), only fetch(). I tested by changing my this.get('columnName') to this.get('column_name') and the virtuals worked.\nYou can close this and refer to issue https://github.com/tgriesser/bookshelf/issues/962\n. Here's the code:\nhttps://gist.github.com/jpstone/5332364ed65308a447ac\nFor both hidden and visible, I was expecting it to work like it did for a single record. I was taken by surprise to see them fail for multiple records.\nMy virtual values each show up as undefined, while my hidden columns simply show up.\n. Now that I think about it, this might not be working because my parse() isn't parsing fetchAll requests, only fetch. Since the columns are in snake_case when fetching all, this might be why it's failing.\nI opened an issue for the parse() not working (962).\n. Sure enough, this issue is happening because parse() isn't working on fetchAll(), only fetch(). I tested by changing my hidden: ['columnName'] to hidden: ['column_name'] and the visibility plugin worked.\nYou can close this and refer to issue https://github.com/tgriesser/bookshelf/issues/962\n. So I can stay DRY. I'm simply following the recommendation from this issue:\nhttps://github.com/tgriesser/bookshelf/issues/828#issuecomment-121093846\nIf that's the problem, why does it work when doing fetch(), but not fetchAll()?\n. I'm not extending the model as a plugin--I'm just including it in my bookshelf.js config file and exporting bookshelf. So the Model class is already extended before anything actually uses it. I don't see the difference between doing this and doing it as a plugin...am I incorrect in that thought? If so, how?\nAgain, the parse method works fine with .fetch(), so the extended Model appears to be replicating properly. It just fails with fetchAll(). What can explain this?\nCan you be more specific into what you think is wrong with my implementation?\n. If that's the case, I wouldn't expect it to work at all. But it works for fetch() just fine...\n. So I did it the way the docs recommended by moving my extension of the Model class to a separate file and registering it as a plugin.\nExact same behavior.\n. Haha yeah, I went ahead and did that before your comment just now. That resolved it.\nThanks for your help!\n. Hi Ricardo,\nThanks for the response. I am going to try your solution in just a minute.\nI wanted to show you why I was creating models on the fly...reason being, I wanted my \"tableName.model.js\" files to contain both my schema and my bookshelf models for easy reference, and then load all my tables/models in one fell swoop (with knex migrations and bookshelf). I then load my models that I export from my bookshelf.js file into my model.controller.js file (where I do my CRUD stuff).\nHere is my bookshelf.js file, which may give you an idea:\n```\n'use strict';\nvar _ = require('lodash');\nvar knex = require('knex')(require('./knexfile')[process.env.NODE_ENV])\nvar bookshelf = require('bookshelf')(knex);\nvar Promise = require('bluebird');\nvar EventEmitter = require('events');\nvar events = new EventEmitter();\nvar configTables = ['users', 'user_types', 'roles', 'wo_statuses',\n'wo_types', 'pricing_types', 'parts', 'labor_types', 'labor_rates', 'customers'];\nbookshelf.plugin(['bookshelf-camelcase', 'virtuals', 'visibility']);\nvar proto = bookshelf.Model.prototype;\nvar Model = bookshelf.Model.extend({\nconstructor: function () {\n    proto.constructor.apply(this, arguments);\n    this.on('saved', function (model) {\n      model.load(this.relationshipArray || [])\n      .then(function (model) {\n        events.emit(this.tableName + ':saved', model);\n      });\n      if (configTables.indexOf(this.tableName) > -1) {\n        model.load(this.relationshipArray || [])\n        .then(function (model) {\n          events.emit('config:saved', {\n            tableName: .camelCase(this.tableName),\n            model: model\n          });\n        });\n      }    \n    });\n    this.on('created', function (model) {\n      model.load(this.relationshipArray || [])\n      .then(function (model) {\n        events.emit(this.tableName + ':created', model);\n      });\n      if (configTables.indexOf(this.tableName) > -1) {\n        model.load(this.relationshipArray || [])\n        .then(function (model) {\n          events.emit('config:created', {\n            tableName: .camelCase(this.tableName),\n            model: model\n          });\n        });\n      }\n    });\n    this.on('updated', function (model) {\n      model.load(this.relationshipArray || [])\n      .then(function (model) {\n        events.emit(this.tableName + ':updated', model);\n      });\n      if (configTables.indexOf(this.tableName) > -1) {\n        model.load(this.relationshipArray)\n        .then(function (model) {\n          events.emit('config:updated', {\n            tableName: .camelCase(this.tableName),\n            model: model\n          });\n        });\n      }\n    });\n    this.on('destroyed', function (model) {\n      model.load(this.relationshipArray || [])\n      .then(function (model) {\n        events.emit(this.tableName + ':destroyed', model);\n      });\n      if (configTables.indexOf(this.tableName) > -1) {\n        model.load(this.relationshipArray || [])\n        .then(function (model) {\n          events.emit('config:destroyed', {\n            tableName: .camelCase(this.tableName),\n            model: model\n          });\n        });\n      }\n    });\n    this.on('commit:updated', function (model) {\n      model.load(this.relationshipArray || [])\n      .then(function (model) {\n        events.emit(this.tableName + ':commit:updated', model);\n      });\n      if (configTables.indexOf(this.tableName) > -1) {\n        model.load(this.relationshipArray || [])\n        .then(function (model) {\n          events.emit('config:commit:updated', {\n            tableName: .camelCase(this.tableName),\n            model: model\n          });\n        });\n      }\n    });\n    this.on('commit:destroyed', function (model) {\n      model.load(this.relationshipArray || [])\n      .then(function (model) {\n        events.emit(this.tableName + ':commit:destroyed', model);\n      });\n      if (configTables.indexOf(this.tableName) > -1) {\n        model.load(this.relationshipArray || [])\n        .then(function (model) {\n          events.emit('config:commit:destroyed', {\n            tableName: .camelCase(this.tableName),\n            model: model\n          });\n        });\n      }\n    });\n    this.on('commit:created', function (model) {\n      if (model.load) {\n        model.load(this.relationshipArray || [])\n        .then(function (model) {\n          events.emit(this.tableName + ':commit:created', model);\n        });\n        if (configTables.indexOf(this.tableName) > -1) {\n          console.log(model instanceof bookshelf.Collection)\n          model.load(this.relationshipArray || [])\n          .then(function (model) {\n            events.emit('config:commit:created', {\n              tableName: .camelCase(this.tableName),\n              model: model\n            });\n          });\n        }\n      } else {\n        events.emit(this.tableName + ':commit:created', model);\n        if (configTables.indexOf(this.tableName) > -1) {\n          events.emit('config:commit:created', {\n            tableName: .camelCase(this.tableName),\n            model: model\n          });\n        }\n      }\n    });\n    this.on('commit:saved', function (model) {\n      model.load(this.relationshipArray || [])\n      .then(function (model) {\n        events.emit(this.tableName + ':commit:saved', model);\n      });\n      if (configTables.indexOf(this.tableName) > -1) {\n        model.load(this.relationshipArray || [])\n        .then(function (model) {\n          events.emit('config:commit:saved', {\n            tableName: _.camelCase(this.tableName),\n            model: model\n          });\n        });\n      }\n    });\n  },\nset: function (key, val, options) {\n    var attrs;\n    if (key == null) return this;\n// Handle both `\"key\", value` and `{key: value}` -style arguments.\nif (typeof key === 'object') {\n  attrs = key;\n  options = val;\n} else {\n  (attrs = {})[key] = val;\n}\nreturn proto.set.call(this, _.omit(attrs, _.isObject), options);\n\n}\n});\nbookshelf.Model = Model;\nexports.Company = require('../api/company/company.model')\n.init(bookshelf);\nexports.Role = require('../api/role/role.model')\n.init(bookshelf);\nexports.User = require('../api/user/user.model')\n.init(bookshelf);\nexports.UserType = require('../api/user-type/user-type.model')\n.init(bookshelf);\nexports.WoType = require('../api/wo-type/wo-type.model')\n.init(bookshelf);\nexports.WoStatus = require('../api/wo-status/wo-status.model')\n.init(bookshelf);\nexports.Part = require('../api/part/part.model')\n.init(bookshelf);\nexports.WorkOrder = require('../api/work-order/work-order.model')\n.init(bookshelf);\nexports.Customer = require('../api/customer/customer.model')\n.init(bookshelf);\nexports.CustomerContact = require('../api/customer-contact/customer-contact.model')\n.init(bookshelf);\nexports.CustomerSite = require('../api/customer-site/customer-site.model')\n.init(bookshelf);\nexports.PricingType = require('../api/pricing-type/pricing-type.model')\n.init(bookshelf);\nexports.LaborType = require('../api/labor-type/labor-type.model')\n.init(bookshelf);\nexports.LaborRate = require('../api/labor-rate/labor-rate.model')\n.init(bookshelf);\nexports.CustomerStatus = require('../api/customer-status/customer-status.model')\n.init(bookshelf);\nexports.bookshelf = bookshelf;\nexports.knex = knex;\nexports.events = events;\n```\nAnd then a model.controller.js example:\n```\n'use strict';\nvar Customer = require('../../config/bookshelf').Customer;\nvar CustomerSite = require('../../config/bookshelf').CustomerSite;\nvar CustomerContact = require('../../config/bookshelf').CustomerContact;\nvar Bookshelf = require('../../config/bookshelf').bookshelf;\nvar events = require('../../config/bookshelf').events;\nvar Promise = require('bluebird');\nvar _ = require('lodash');\nvar deleteKeys = function (customer) {\n  var keys = ['sites', 'contacts'];\n  keys.forEach(function (key) {\n    if (customer[key]) {delete customer[key]}\n  });\n  return customer;\n};\n// Get all customers\nexports.index = function(req, res, next) {\n  Customer.collection()\n  .fetch({withRelated: Customer.forge().relationshipArray})\n  .then(function (customers) {\n    return res.status(200).json(customers.toJSON());\n  })\n  .catch(function (err) {\n    return next(err);\n  });\n};\n// Create customers\nexports.create = function (req, res, next) {\n  var customerId;\n  Bookshelf.transaction(function (t) {\n    Customer.forge(req.body)\n    .set(req.body)\n    .save(null, {transacting: t})\n    .tap(function (customer) {\n      customerId = customer.id;\n      return Promise.map(req.body.sites, function (site) {\n        return CustomerSite.forge(site)\n        .save({customerId: customerId}, {transacting: t})\n      });\n    })\n    .tap(function () {\n      return Promise.map(req.body.contacts, function (contact) {\n        return CustomerContact.forge(contact)\n        .save({customerId: customerId}, {transacting: t});\n      });\n    })\n    .then(t.commit)\n    .catch(t.rollback);\n  })\n  .then(function (model) {\n    model.emit('commit:created', model);\n  })\n  .then(function () {\n    return Customer.where({id: customerId})\n    .fetch({withRelated: Customer.forge().relationshipArray});\n  })\n  .then(function (customer) {\n    return res.status(200).json(customer.toJSON());\n  })\n  .catch(function (err) {\n    console.log(err.stack);\n    return next(err);\n  });\n};\n// Get a single customer\nexports.show = function (req, res, next) {\n  Customer.where({id: req.params.id})\n  .fetch({require: true})\n  .then(function (customer) {\n    return customer.fetch({withRelated: this.relationshipArray});\n  })\n  .then(function (customer) {\n    return res.status(200).json(customer.toJSON());\n  })\n  .catch(Customer.NotFoundError, function () {\n    return res.status(404).json({err: 'Customer not found'});\n  })\n  .catch(function (err) {\n    return next(err);\n  });\n};\n// Delete a customer\nexports.destroy = function(req, res) {\n  Bookshelf.transaction(function (t) {\n    Promise.map(req.body.sites, function (site) {\n      return CustomerSite.forge({id: site.id})\n      .destroy({require: true, transacting: t});\n    })\n    .tap(function () {\n      return Promise.map(req.body.contacts, function (contact) {\n        return CustomerContact.forge({id: contact.id})\n        .destroy({require: true, transacting: t});\n      });\n    })\n    .then(function () {\n      return Customer.forge({id: req.body.id})\n      .destroy({require: true, transacting: t});\n    })\n    .then(t.commit)\n    .catch(t.rollback);\n  })\n  .then(function () {\n    return res.status(204);\n  })\n  .catch(function (err) {\n    res.status(500).json(err);\n  });\n};\n// Update existing customer\nexports.update = function(req, res, next) {\n  Bookshelf.transaction(function (t) {\n    Customer.forge({id: req.body.id})\n    .set(req.body)\n    .save(null, {transacting: t})\n    .tap(function () {\n      return Promise.map(req.body.sites, function (site) {\n        if (site.destroy) {\n          return CustomerSite.forge({id: site.id})\n          .destroy();\n        } else {\n          return CustomerSite.forge(site)\n          .save({customerId: req.body.id}, {transacting: t})\n        }\n      });\n    })\n    .tap(function () {\n      return Promise.map(req.body.contacts, function (contact) {\n        if (contact.destroy) {\n          return CustomerContact.forge({id: contact.id})\n          .destroy();\n        } else {\n          return CustomerContact.forge(contact)\n          .save({customerId: req.body.id}, {transacting: t});\n        }\n      });\n    })\n    .then(t.commit)\n    .catch(t.rollback);\n  })\n  .then(function (model) {\n    model.emit('commit:updated', model);\n  })\n  .then(function () {\n    return Customer.where({id: req.body.id})\n    .fetch({require: true, withRelated: Customer.forge().relationshipArray});\n  })\n  .then(function (customer) {\n    return res.status(200).json(customer.toJSON());\n  })\n  .catch(function (err) {\n    console.log(err.stack);\n    return next(err);\n  });\n};\n```\nWith that, I didn't find an easy way to have the already-constructed models in my tableName.model.js file, so I just constructed them on the fly. \nDo you have a better way to do this in such a way that I can keep my file structure?\n. Thanks!\nWhere might I be repeating myself unnecessarily? \n. I searched for rooms \"bookshelf\" and \"knex\" but neither returned a result. What's the room name?\n. Hi Ricardo,\nYour suggestion worked! Thanks so much. I also stopped created modules on the fly and the registry plugin is working great. Also, I was able to reduce my bookshelf.js file to this, after reconsidering your DRY comment:\n```\n'use strict';\nvar _ = require('lodash');\nvar knex = require('knex')(require('./knexfile')[process.env.NODE_ENV])\nvar bookshelf = require('bookshelf')(knex);\nvar Promise = require('bluebird');\nvar EventEmitter = require('events');\nvar events = new EventEmitter();\nvar configTables = [\n  'users',\n  'user_types',\n  'roles',\n  'wo_statuses',\n  'wo_types',\n  'pricing_types',\n  'parts', 'labor_types',\n  'labor_rates',\n  'customers'];\nvar modelModules = [\n  'company',\n  'role',\n  'user',\n  'userType',\n  'woType',\n  'woStatus',\n  'part',\n  'workOrder',\n  'customer',\n  'customerContact',\n  'customerSite',\n  'customerStatus',\n  'pricingType',\n  'laborType',\n  'laborRate'\n];\nbookshelf.plugin(['bookshelf-camelcase', 'virtuals', 'visibility', 'registry']);\nvar proto = bookshelf.Model.prototype;\nvar Model = bookshelf.Model.extend({\nconstructor: function () {\n    proto.constructor.apply(this, arguments);\n    this.on('saved', function (model) {\n      onEvent('saved', model);\n    });\n    this.on('created', function (model) {\n      onEvent('created', model);\n    });\n    this.on('updated', function (model) {\n      onEvent('updated', model);\n    });\n    this.on('destroyed', function (model) {\n      onEvent('destroyed', model);\n    });\n    this.on('commit:updated', function (model) {\n      onEvent('commit:updated', model);\n    });\n    this.on('commit:destroyed', function (model) {\n      onEvent('commit:destroyed', model);\n    });\n    this.on('commit:created', function (model) {\n      onEvent('commit:created', model);\n    });\n    this.on('commit:saved', function (model) {\n      onEvent('commit:saved', model);\n    });\n  },\nset: function (key, val, options) {\n    var attrs;\n    if (key == null) return this;\n// Handle both `\"key\", value` and `{key: value}` -style arguments.\nif (typeof key === 'object') {\n  attrs = key;\n  options = val;\n} else {\n  (attrs = {})[key] = val;\n}\nreturn proto.set.call(this, _.omit(attrs, _.isObject), options);\n\n}\n});\nbookshelf.Model = Model;\nmodelModules.forEach(function (module) {\n  var n = .kebabCase(module);\n  var m = .camelCase(module);\n  var modelName = m[0].toUpperCase() + m.substr(1);\n  var model = require('../api/' + n + '/' + n + '.model').init(bookshelf);\n  exports[modelName] = bookshelf.model(modelName, model);\n});\nexports.events = events;\nexports.bookshelf = bookshelf;\nexports.knex = knex;\nfunction onEvent(event, model) {\n  if (model.load) {\n    model.load(this.relationshipArray || [])\n    .then(function (model) {\n      events.emit(this.tableName + ':' + event, model);\n    });\n    if (configTables.indexOf(this.tableName) > -1) {\n      model.load(this.relationshipArray || [])\n      .then(function (model) {\n        events.emit('conifg:' + event, {\n          tableName: _camelCase(this.tableName),\n          model: model\n        });\n      });\n    }\n  }\n}\n```\n. ",
    "alexwhitman": "I have the following code in a restify route which loads the model, adds the fee data to the model and then outputs JSON.\n``` js\n new Course({ progcode: request.params.code, termcode: termcode })\n    .fetch({ withRelated: [ 'degreeType', 'degreeLocation', 'departments' ] })\n    .then(function(course) {\n        if ( ! course) {\n            return next(new restify.NotFoundError());\n        }\n    course.fees(function(error, fees) {\n        course.set('fees', fees);\n        response.json(CourseConverter(course.toJSON()));\n        return next();\n    });\n});\n\n```\ncourse.fees() is a function on the model which runs a raw knex query using model attributes as query parameters and does some post processing on the retrieved data.  The fees table structure doesn't lend itself to using a normal relationship.  The table can't be changed as it's used in a production app and I'm trying to add an API on top of it.\nWhile the above code works it seems a bit hacky and is even uglier when retrieving a collection of Course objects with fetchAll().\n. @bendrucker Thanks for the improved code, I'll test it tomorrow.\nThe CourseConverter is just https://github.com/dregenor/jsonMapper used to tidy up the JSON.\n. Just to follow up on this, the code works with some minor tweaks:\njs\nnew Course({ progcode: request.params.code, termcode: termcode })\n    .fetch({ withRelated: [ 'degreeType', 'degreeLocation', 'departments' ] })\n    .tap(function(course) {\n        return course.fees().then(course.set.bind(course, 'fees'));\n    })\n    .then(function(course) {\n        response.json(CourseConverter(course.toJSON()));\n        next();\n    })\n    .catch(function() {\n        next(new restify.NotFoundError());\n    });\nRight now I'm not going to include the fees data when getting a collection, only for specific items.  I'm going to look at generating a view for the data so that a correct relationship can be used.\nThanks for the help @bendrucker.\n. ",
    "freshsun": "Hi bendrucker, i modified your gist so catch() call is after save() and it still output \"possibly unhandled error\".\nhttps://gist.github.com/freshsun/46a4a6ad6e49a3d2897c\nPossibly unhandled error: duplicate key value violates unique constraint \"test_table_test_column_unique\"\n    at Connection.parseE (/server/node_modules/pg/lib/connection.js:526:11)\n    at Connection.parseMessage (/server/node_modules/pg/lib/connection.js:356:17)\n    at Socket.<anonymous> (/server/node_modules/pg/lib/connection.js:105:22)\n    at Socket.emit (events.js:95:17)\n    at Socket.<anonymous> (_stream_readable.js:764:14)\n    at Socket.emit (events.js:92:17)\n    at emitReadable_ (_stream_readable.js:426:10)\n    at emitReadable (_stream_readable.js:422:5)\n    at readableAddChunk (_stream_readable.js:165:9)\n    at Socket.Readable.push (_stream_readable.js:127:10)\n. Just verify that It's a problem of my test code. I do apologize for this. Thank you bendrucker.\n. ",
    "scottpersinger": "How do I attach that? I tried about 5 different forms:\n  model.triggerThen(\"created\")\n  new model().triggerThen(\"created\")\n  collection.triggerThen\nnone of them worked.\n. ",
    "chimmelb": "Thank you for those examples, that's great. Thanks for the tip on on mismatch as well. I will be aware of that as it comes up. \nCould I ask how Bookshelf saves (creates) to the DB with multiple nested objects? Let's say we're creating a new survey with 3 questions and 5 answers for each question. I could see Bookshelf doing it in 19 inserts: one for survey, one for 3 questions, one for 15 answers. I could also see  3 queries again: one for survey, one for 3 questions, one for 15 answers. \nI would guess updates are different and would be a on DB query for each item to updated. (Though I could see all the updates for a particular table in a single statement, but that might be overkill).\nThanks again for answering, I appreciate knowing what's going on behind the scenes when working with an ORM. You can close the issue, or leave it open for reference!\n. Thank you for those examples, that's great. Thanks for the tip on on mismatch as well. I will be aware of that as it comes up. \nCould I ask how Bookshelf saves (creates) to the DB with multiple nested objects? Let's say we're creating a new survey with 3 questions and 5 answers for each question. I could see Bookshelf doing it in 19 inserts: one for survey, one for 3 questions, one for 15 answers. I could also see  3 queries again: one for survey, one for 3 questions, one for 15 answers. \nI would guess updates are different and would be a on DB query for each item to updated. (Though I could see all the updates for a particular table in a single statement, but that might be overkill).\nThanks again for answering, I appreciate knowing what's going on behind the scenes when working with an ORM. You can close the issue, or leave it open for reference!\n. OK, thank you for the answer. I realize this is a odd-ball case in DB design . . . which means I will rework the DB to fit convention! : )\n. Not across the board, just for this particular query. I like that objects are nested on returning, so want to keep Bookshelf for this query instead of just Knex. \nAlso, FYI, Promise.reduce won't work on the returned collection, as it isn't an array. I went with workaround 2, collection.toJSON(), then .reduce'd the array like normal. \nIf there was another trick, let me know! (And if one doesn't quickly come to mind, this issue can be closed)\n. ",
    "skwee357": "@bendrucker Thats a legitimate answer! Thank you. Might I bug you a bit more?\nI assume such functionality should be implemented inside the collection. However the docs on collections does not show any examples on how to actually work with collections.\nHow I can iterate over the collection, inside a collection instance method?\nThanks!\n. @bendrucker Thats a legitimate answer! Thank you. Might I bug you a bit more?\nI assume such functionality should be implemented inside the collection. However the docs on collections does not show any examples on how to actually work with collections.\nHow I can iterate over the collection, inside a collection instance method?\nThanks!\n. Thanks. Ill figure it out from there!\n. Thanks. Ill figure it out from there!\n. In case anyone is interesting in using bookshelf 10.4 and wants to have correct updated_at time, you can have one common base Model in which you will overwrite the timestamp() function to have the correct updated_at value.\nYou can also implement it as plugin, and then once the issue is closed, you can simply remove the plugin from your code. @Playrom I believe there is an issue with the following code:\njavascript\nif (createdAtKey && method === 'insert' && canEditCreatedAtKey) {\n  attributes[createdAtKey] = now;\n}\nAssuming we have createdAtKey and the method is indeed insert but the user supplied that canEditCreatedAtKey is false, for new resources, created_at would not be set at all (hence causing error if the field is defined as NOT NULL in the DB and does not have default).\nThe following code solves this:\njavascript\nif (createdAtKey && (method === 'insert' || !this.get(createdAtKey) || canEditCreatedAtKey) {\n  attributes[createdAtKey] = now;\n}\nIf we have createdAtKey and either one of:\n The method is insert - This covers new resources\n No created_at set yet - This can happen if you do not use incremental primary key, but uuid for example, and since you generate the uuid on the code side and not the DB side, method will never be insert because isNew() will always be false.\n* canEditCreatedAtKey - This covers the case when the user can edit the createdAtKey\nTell me what do you think. As for\njavascript\nif (updatedAtKey && canEditUpdatedAtKey) {\n  attributes[updatedAtKey] = now;\n}\nI think we should add && this.hasChanged() in there as well.\nWDYT?. This is an interesting point.\nHowever consider that sometimes you do not control explicitly what fields are being updated. Example: your model.get(\"username\") === \"skwee357\", then your API is getting called with {username: \"skwee357\"}. When you save this to database, the model did not in fact change, would you want to update the updated_at? I know I don't, this is the reason why I'm introducing this fix. I know before PR #1607 it worked like this way (at least from what I remember).\nAlso this kind of hides the touch functionality. If you want touch functionality, I think its better to introduce something like model.touch(), instead of hiding this functionality in doing an empty update of the model. What do you think?\nAs for created_at. Consider the following:\nconst b = new Book({id: uuid.v4()});\nb.save();\nYou still have books table with primary key id, however the primary key is not generated by the DB, but in code (there are many reasons for this: you want some non trivial primary key, you want to allow your clients to generate primary key for offline sync in mobile and etc).\nIn that case model.isNew() === false, hence \"new\" model is being inserted while not being new as bookshelf sees it.. Will do! It will take some time, hopefully Ill get to it by weekend.. I agree with you about only one place for the constant. I think it should be in the base model.\nI do believe and think it is necessary that created_at and updated_at should be overwrite-able by the user. If we can do it without random keys like canEditUpdatedAtKey or canEditCreatedAtKey, I think it is better to do it without it. We can write a test to check wether model.save({created_at: '1970-01-01 00:00:00'); works and if so, get rid of all this mess can or can not edit the keys.\nI'm not sure that passing {method: 'insert'} to create a model with predefined ID is very user intuitive. I'm ready to open a discussion on this.\nOther than this I agree with you!. Set the created_at field only if its undefined / not set, then it dosent matter if the method is insert or update. This however could cause an issue if you do something like this model.save({created_at: null}); but why would you want to do this \ud83d\ude31, though who knows what people might do.... Sorry, of course you can not update non existing row. What I meant to say is that created_at should be set not only if the method is insert (this is what I do as part of this PR). It should be set if it was not previously set and the user is not overwriting it manually.\nAnd yes, I do believe everything related to created_at and updated_at should be handled inside the timestamp() method.. What I meant by \"not previously set\" is that it was not supplied by the user explicitly, i.e. model.save({created_at: new Date()}); or model.set('created_at', new Date()). If during the save to DB, created_at is undefined, we need to set it.\nHowever this raises another issue, you can do something like Model.fetch({columns: ['id']}), I'm not sure how bookshelf would save such model since it has partial model columns. So if the user did not fetch the created_at field, bookshelf might think it was not set, and will try to set it. Never fetched partial model though, so no idea.\nI suggest we open a wiki / shared document and write there all the possible scenarios of how timestamps should be updated. We can use ROR or Django for reference to see how they do it. I'm ready to contribute my part there. What do you think?. I fully agree with you.\nExpect I'm not sure what you mean in the Rails part. How exactly rails handles it and why bookshelf can not do the same?. I'm ok with setting created_at only if the method is insert. And I think if timestamps are provided explicitly by the user (like in your example), we need to save what the user provided. In any other case, set created_at on insert and updated_at on any request that hits the DB. What do you think?. Sorry for the late reply. New year, vacation etc...\nWell, technically, you are right. But since Bookshelf is more Active Record rather than Data Mapper, the only way for Bookshelf to know whether the model is new or not - is to look at its ID.\nIf we dont have an ID attribute (its undefined, null, empty - whatever) - the model is new.\nIf we have an ID attribute - the model is not new.\nWhen new model is saved, we perform an insert query. When non new (I'll call it dirty from now on) model is saved, we will perform an update query.\nHowever the ID attribute can be set by the application. Example I've already gave: I generate the ID as UUID in my application code, rather than letting the database to generate the ID for me. This mean that new models can have ID, which make bookshelf think that those models are dirty rather than new thus requiring bookshelf to perform an update query when saving such model, rather than insert query.\nAssuming I bring the test back, lets look at a simple table:\nsql\nCREATE TABLE IF NOT EXISTS `test` (\n    `id` CHAR(36) NOT NULL,\n    `created_at` datetime NOT NULL,\n    `updated_at` datetime NOT NULL,\n    PRIMARY KEY( `id` )\n);\nWhen I create a model from this table and I generate the ID (which is UUID for example), the method will always be update, because this is the way active record and bookshelf works. Here is the code. And if we dont update created_at on method=update, the query will fail, because created_at is not nullable.\nI'm open to discuss a better solution, but this is a limiting factor of active record pattern. If you determine the \"new\"-ness of a model by looking at the value of its ID attribute rather than doing a trip to the DB to see if record with such ID exists, you might run into this edge case. Not everyone wants to let the database manage IDs. Its not working all the time. Once again, the same example - client generated UUID.\nThis is a non intuitive edge case - I agree. And once again, I'm open for discussion about possible solutions, but currently this is the only solution I've found.\nHappy new year! :). See my previous comment. By the way, I'm not sure why the tests fails now. It looks like some discrepancy in 0.003ms\nNeed to take a deeper look at it. Awesome! Ping me if you would like to discuss or have some ideas, I'm open to listen to other solutions as well! :). ",
    "marclar": "Awesome -- thanks, @tgriesser. I'm realizing it might also belong in a controller, but useful to know how to do this.\n. Awesome -- thanks, @tgriesser. I'm realizing it might also belong in a controller, but useful to know how to do this.\n. ",
    "danielstjules": "@tgriesser That's good news, thanks for letting me know!\n. @tgriesser That's good news, thanks for letting me know!\n. Quick followup. So will this be a departure from bookshelf itself, if you're moving towards building something more closely related to SQLAlchemy's architecture (more datamapper than activerecord)? As in a completely different project?\n. Quick followup. So will this be a departure from bookshelf itself, if you're moving towards building something more closely related to SQLAlchemy's architecture (more datamapper than activerecord)? As in a completely different project?\n. ",
    "skysteve": "+1 if it's listed in the docs as \"working like backbone\" backbone will auto sort when initialized or when a model is added if there's a comparator, was about raise a bug before I saw this\n. thanks for the quick reply :) what's the logic behind removing collections?\nI've only started using bookshelf about 2-3 weeks ago having come from a backbone background and find collections rather useful. I know I can just hard code my bookshelf version and they'll continue to work, but seems a shame to remove them. \n. Hey, after a comment on another issue I thought I'd raise my support for collections here rather confusing another thread...\nFirst off I've only been using bookshelf for about 2-3 weeks so please tell me if I'm missing something. I do however come from a backbone background of about 2-3 years.\nI find collections great for keeping models clean to handle instance specific tasks and collections great for handling multiple instance specific tasks.I don't have a collection for every model in my project, so I can see how they may be viewed as pointless in some applications but where I do have them I find them very useful. \nAt the moment I'm mostly using collections to load a group of models with a given query or a cache for model's I've already fetched and then retrieving them using collection.find rather than having to implement this manually using an array. And in some places I'm using other underscore methods like filter which again saves implementing it manually. But some collections also have helper methods on them which save me re-writing the code or confusing the model. \ne.g. (if you need some context let me know)\n```\ngetAccountToFetch : function () {\n            //try to find the account we were last loading - it'll have a cursor that's not 0\n            var current = this.find(function (model) {\n                var cursor = model.get('cursor') || null;\n            return (!_.isNull(cursor) && cursor !== '0');\n        });\n\n        //if we have one let's carry on\n        if (current) {\n            return current;\n        }\n\n        //otherwise get the account we refreshed the longest ago\n        return this.min(function (model) {\n            return model.get('lastFetched');\n        });\n    }\n\n```\nThat said, collections aren't perfect, for example I would argue that the model.fetchAll method and collection.fetchOne are very confusing/pointless as model.fetchAll is just collection.fetch and collection.fetchOne is just model.fetch. And there's no way to save everything in a collection (that I can find) which means you end up having to do something like\ncollection.each(function (model) {\n          return model.save();\n});\n. ",
    "jclem": "I definitely need the returning behavior, personally. I have a schema where I can't reliably fetch the record I just saved because there is no unique column to fetch by. Also, I'd very much like to avoid the extra query, anyway. I avoid using Bookshelf models altogether in some places because of this issue, and just have to build knex queries.\n. The above doesn't make any difference for me (PostgreSQL). This makes it really difficult to use any sort of fields with default values.\n. The above doesn't make any difference for me (PostgreSQL). This makes it really difficult to use any sort of fields with default values.\n. @tkambler That would certainly work, but I'd prefer not to have to perform two database calls for every call to save (see @rickharrison's comment). For some reason Bookshelf is always just asking for returning \"id\".\n. @tkambler That would certainly work, but I'd prefer not to have to perform two database calls for every call to save (see @rickharrison's comment). For some reason Bookshelf is always just asking for returning \"id\".\n. It appears that this is actually only the case on \"creating\" for me. When updating a model, it honors @ricardograca's example above, but not when doing the initial insert.\n. It appears that this is actually only the case on \"creating\" for me. When updating a model, it honors @ricardograca's example above, but not when doing the initial insert.\n. @tgriesser It uses both. It uses this query:\nsql\nselect \"models\".* from \"models\" where \"models\".\"data\" = $1 and \"models\".\"id\" = $2 limit $3\nWhere I would expect this:\nsql\nselect \"models\".* from \"models\" where \"models\".\"id\" = $1 limit $2\nIf I have an idAttribute set, typically using any other fields to build a select query is unnecessary when trying to fetch a single record. This also has the disadvantage of building select queries around columns that I do not have indexes on.\n. Really the issue here isn't that a #fetch fails when there is a JSON column, it's that the behavior of #fetch is not what I think people would typically expect, and it assumes that any column type has an \"=\" operator that can be used in a SELECT query.\n. Thanks @tgriesser!\n. @tgriesser Just checking back in on this, is there any progress? This is consistently my biggest frustration with Bookshelf, which I love, otherwise.\nNote If it helps understand my need a little better this is what my base model in my current app looks like.\n. @ricardograca That's the default fetch behavior. It uses every single attribute set on the model: \"Fetches a model from the database, using any attributes currently set on the model\" (from the docs).\nI'd expect a query like\nsql\nSELECT \"invite_tokens\".* FROM \"invite_tokens\" WHERE \"invite_tokens\".\"token\" = $1 LIMIT 1;\n. @ricardograca That's the default fetch behavior. It uses every single attribute set on the model: \"Fetches a model from the database, using any attributes currently set on the model\" (from the docs).\nI'd expect a query like\nsql\nSELECT \"invite_tokens\".* FROM \"invite_tokens\" WHERE \"invite_tokens\".\"token\" = $1 LIMIT 1;\n. @ricardograca It's not so much about a bug in behavior as it is what I consider to be a design flaw.\nThe example is from a test\u2014the token was updated by a web request, so I'd like to reload it. The primary key (idAttribute in the model) is \"token\".\nThe reason I'm \"trying to limit the query on something that is already part of the query to begin with\" is because the documentation states that this is how to limit the query on Model#fetch. The surprising part isn't necessarily that it's in the WHERE clause twice, but rather that anything other than the primary key is used in that clause.\nThe actual Model API does nothing to indicate that when calling model.query(), the query already is populated by every single attribute present on the model. That seems counterintuitive to me.\nConsider this scenario:\njavascript\nModel.collection().query({ where: { id: 1 } }).fetchOne().then(model => {\n  return model.fetch();\n});\nI would expect these two lines to run the same query, but one fetches only by the \"id\" attribute, and the other unexpectedly uses every single attribute on the model.\nThis is similar to this issue that I opened. Given a model with a JSON column \"data\", I do not think any user would expect new Model({ data: {} }).fetch() to try and do a SELECT ... WHERE using the JSON data (in this case, I'd expect some sort of error since there's no idAttribute present on the model I called fetch on, but that's a matter of convention, I believe). This should at least be configurable.\nIn general, I think that Model#fetch using every single column isn't great behavior, partially because of the unexpected inefficiency of doing a select over every single attribute present on the model.\nAll this being said, what this issue was actually about is that query().fetch() doesn't do what the documentation suggests.\n. @ricardograca It's not so much about a bug in behavior as it is what I consider to be a design flaw.\nThe example is from a test\u2014the token was updated by a web request, so I'd like to reload it. The primary key (idAttribute in the model) is \"token\".\nThe reason I'm \"trying to limit the query on something that is already part of the query to begin with\" is because the documentation states that this is how to limit the query on Model#fetch. The surprising part isn't necessarily that it's in the WHERE clause twice, but rather that anything other than the primary key is used in that clause.\nThe actual Model API does nothing to indicate that when calling model.query(), the query already is populated by every single attribute present on the model. That seems counterintuitive to me.\nConsider this scenario:\njavascript\nModel.collection().query({ where: { id: 1 } }).fetchOne().then(model => {\n  return model.fetch();\n});\nI would expect these two lines to run the same query, but one fetches only by the \"id\" attribute, and the other unexpectedly uses every single attribute on the model.\nThis is similar to this issue that I opened. Given a model with a JSON column \"data\", I do not think any user would expect new Model({ data: {} }).fetch() to try and do a SELECT ... WHERE using the JSON data (in this case, I'd expect some sort of error since there's no idAttribute present on the model I called fetch on, but that's a matter of convention, I believe). This should at least be configurable.\nIn general, I think that Model#fetch using every single column isn't great behavior, partially because of the unexpected inefficiency of doing a select over every single attribute present on the model.\nAll this being said, what this issue was actually about is that query().fetch() doesn't do what the documentation suggests.\n. I want to be clear that I'm not asking how to fetch a model by a single property. I know I can do a completely new query with Model.collection().query(), etc. What's frustrating is that:\n1. The query().fetch() behavior differs from what is documented.\n2. There is no easy way to reload a model instance, a common need in route unit testing.\n. I want to be clear that I'm not asking how to fetch a model by a single property. I know I can do a completely new query with Model.collection().query(), etc. What's frustrating is that:\n1. The query().fetch() behavior differs from what is documented.\n2. There is no easy way to reload a model instance, a common need in route unit testing.\n. I was referring specifically to:\n\nIf you need to constrain the query performed by fetch, you can call the query method before calling fetch.\n\nCalling query allows expansion of the query, but not constraint of the query.\n. I was referring specifically to:\n\nIf you need to constrain the query performed by fetch, you can call the query method before calling fetch.\n\nCalling query allows expansion of the query, but not constraint of the query.\n. Awesome! Thanks @tgriesser.\n. @tgriesser BTW, is the rewrite stuff pushed anywhere in a branch?\n. ",
    "matt-dalton": "I'm a bit confused by a part of your solution @TinOo512 . Where you've got const findById = find(propEq('id', id));, what are find and propEq? Are these functions you've imported from somewhere?. I'm a bit confused by a part of your solution @TinOo512 . Where you've got const findById = find(propEq('id', id));, what are find and propEq? Are these functions you've imported from somewhere?. ",
    "sscovil": "Worth noting that the above solution posted by @TinOo512 effectively breaks the behavior of the required option (at least in v0.10.3). When using that option on a save, Model.NoRowsUpdatedError is not thrown.\nI was able to resolve that problem using this:\n```javascript\n  initialize: function() {\n    this.on('saving', (model, attrs, options) => {\n      if (options.method === 'insert') {\n        Object.defineProperty(options.query._single, 'returning', {\n          get() { return ''; },\n          set() { return ''; },\n          configurable: true,\n          enumerable: true,\n          writeable: true,\n        });\n      } else {\n        options.query.returning('*');\n      }\n    });\nthis.on('saved', (model, attrs, options) => {\n  if (options.method === 'insert') {\n    model.set(model.parse(model.id));\n  } else {\n    const id = model.get(model.idAttribute);\n    if (id) {\n      const attr = attrs.find(attr => attr.id === id);\n      if (attr) {\n        model.set(model.parse(attr));\n      } else if (options.require) {\n        throw new this.constructor.NoRowsUpdatedError();\n      }\n    }\n  }\n});\n\n}\n``. Can you show what your models look like?. Try passing an options object as the second argument and overriding therequire` value:\njs\nlet user = await User.findOne({email}, { require: false })\nAccording to the plugin docs, it sets require to true by default (that's the option that makes the Bookshelf fetch method throw an error if no results are found).. Thanks @absolux! I tried that, but select is not a function. I believe that is only available via the Knex query builder.... That works. Thanks again, this is amazing! I had no idea you could do that. Much nicer.\nFor completeness, here is what I ended up with:\n```js\nfunction fetchAllGroupsByMemberId(memberId, debug = false) {\n  const groupIds = GroupMember\n    .query()\n    .select('group_id')\n    .where('id', memberId);\nreturn Group\n    .where('id', 'IN', groupIds)\n    .query(qb => qb.debug(debug))\n    .fetchAll({ withRelated: ['members'] });\n}\n```\nThis generates the following SQL:\nsql\nselect \"groups\".*\nfrom \"groups\"\nwhere \"id\" in (\n  select \"group_id\"\n  from \"groups_members\"\n  where \"id\" = ?\n). Have you tried doing something like this?\njs\nbookResolver = bookId => {\n  return new Book({ id: bookId })\n    .fetch()\n    .then(model => model.toJSON());\n}\nThis Promise will resolve with the model attribute values.. You'll want to use the PostgreSQL array_append function. Not sure how to do it with Bookshelf, but here is an example of how you would do it with Knex: https://github.com/tgriesser/knex/issues/879#issuecomment-117402785. ",
    "irehleecka28": "Is this still open or a final solution had been implemented and commited? Thanks. Is there a final solution already? The workaround by @sscovil throws Undefined binding(s) detected when compiling SELECT query.. ",
    "dhiraj-optus": "getting below error on save.\nknex:query insert into schema.tablename (\"id\") values (?) returning \"id\" undefined\nIs there any way to suppress returning. The user has only insert grant on table and not select grant.\n. ",
    "jackhouse": "Hi Ben,\nSchema\ntable: gameplans\nPK: id\ntable: gameplans_groups\nCOMPOUND PK: gameplan_id, group_id\ntable: groups\nPK: id\ntable: groups_questions\nCOMPOUND PK: group_id, question_id\ntable questions\nPK: id\nIntended outcome:\nGiven a gameplan id, I need to get the groups associated with said gameplan (gameplans_groups); from each group, I need to get the questions (groups_questions).\nIn short: gameplan id -> array of question id 's\nThank you\n. Thank you Ben.\nI started using a raw query. Now I have different issues.\n\"..for that, although definitely use bindings for the values.\"\nI'm using the following:\nknex.raw('INSERT IGNORE INTO new_trivia_db1.tags (label, tag_category_id) VALUES ' + insert_values)\nwhere insert_values is a string. I would prefer to use something like\nknex.raw('INSERT IGNORE INTO new_trivia_db1.tags (label, tag_category_id) ?', [['label', id], ['label', id],...['label', id]])\nbut the syntax escapes me, please advise.\nThanks again\n. ",
    "ryanatkn": "Looks good. Thanks for the quick patch. Knex and Bookshelf are wonderful libraries, thank you for your work!\n. ",
    "gemabarni": "I noticed something while using this function on v0.10.3: If I don't specify the id column in the list none of the columns get fetched. Should it work this way?\n(Also, I could not find this function anywhere in the docs.). ",
    "onury": "Thanks @bendrucker. fetch({ columns: ['code'] }) did it for me. I was talking about using visible or hidden in the model definition (via visibility plugin); to only get a single column. But that would fetch it all first then filter, I guess.. which is not quite efficient.\nThe main example in Bookshelf readme uses toJSON to output the collection data. I thought, a collection fetched from a model would always have this method.\nFor the array of strings; never mind... I'll use _.pluck().\n. Ah, great tip! Thanks a lot.\n. ",
    "jucrouzet": "Hello @tgriesser, any chance to see it merged ?\nThanks,\n. For update needs to be used in a transaction before updating the selected row :\njs\n          Bookshelf.transaction(function buildTransaction(trx) {\n            return (\n              RenewalModel.forge({\n                type: type,\n                status: 'new',\n              })\n                .query('limit', 1)\n                // => Specify here the FOR UPDATE\n                .fetch({transacting: trx})\n                .then(function onFetchResult(instance) {\n                  return instance ?\n                    (instance.save({status: 'pending'}, {patch: true, transacting: trx})) :\n                    Promise.resolve(null);\n                })\n            );\n          })\nAs the knex .forUpdate() method should be used on a .transacting(trx), I can use .query('forUpdate')\nThe workaround solution working right now is working on the fetching event : \njs\n.once('fetching', function(model, columns, options) {\n  options.query.forUpdate();\n})\nI will have a look to create a PR using Babel.\nThank you,\n. For update needs to be used in a transaction before updating the selected row :\njs\n          Bookshelf.transaction(function buildTransaction(trx) {\n            return (\n              RenewalModel.forge({\n                type: type,\n                status: 'new',\n              })\n                .query('limit', 1)\n                // => Specify here the FOR UPDATE\n                .fetch({transacting: trx})\n                .then(function onFetchResult(instance) {\n                  return instance ?\n                    (instance.save({status: 'pending'}, {patch: true, transacting: trx})) :\n                    Promise.resolve(null);\n                })\n            );\n          })\nAs the knex .forUpdate() method should be used on a .transacting(trx), I can use .query('forUpdate')\nThe workaround solution working right now is working on the fetching event : \njs\n.once('fetching', function(model, columns, options) {\n  options.query.forUpdate();\n})\nI will have a look to create a PR using Babel.\nThank you,\n. ",
    "mgartner": "After thinking about it more, maybe it's always better in a case like this to first fetch the row, then perform a save. It's another round-trip to the database, but that's not the end of the world.\nI would love to get some other opinions on this before working on a solution.\nAt the very least this should throw a specific error (not necessarily NotFound) so that it can be caught without catching all errors.\n. @bendrucker @tgriesser now requires explicit false.\n. The odd thing is that the column type is numeric(10, 2), and we have other columns with the same type that return a number just fine. How could we be seeing different behavior for the same column type?\n. ",
    "shedar": "Maybe it also worth adding 'require' option to 'save' method, to specify if I worry about updated rows at all. And don't throw Error of any kind if require===false. Zero affected rows maybe an expected workflow.\nFor example, When I want to update token lifetime I always have a chance to execute two updates in same second. Even if I check attribute value before update, updates can be executed by different node instances. In such case mysql will return 0 affected rows. But it's not an exception at all for me.\nFor now I catch all error on this update, which is not a good solution, but I can't figure out a better one.\n. ",
    "tkrotoff": "This issue has not been fixed: NotFoundError is still not thrown\n. @rhys-vdw would be better re-open this issue instead of creating a new one.\nInvestigations:\nTypeScript\nconst id = 'unknown';\nnew FooBar({id})\n  .save({foo: 'bar'}, params)\n  .then(fooBar => ...) // Path 1\n  .catch(FooBar.NotFoundError,\n    () => next(createError(404, `'${id}' not found`))) // Path 2\n  .catch(FooBar.NoRowsUpdatedError,\n    () => next(createError(422, `model '${id}' not updated`))) // Path 3\n  .catch(error =>\n    next(createError(500, error))); // Path 4\n- With params = {patch: true, require: false} => takes path 1 (no error)\n- With params = {patch: true, require: true}  => takes path 3 (NoRowsUpdatedError)\n- Path 2 is never taken\n- Path 4 is only taken if something goes completely wrong (500 Internal Server Error)\nEdit: make it more clear\n. @rhys-vdw I've edited my previous comment to make it more clear\nThere is a misunderstanding here :)\nIf I try to update a model given a non-existing id, do you confirm that NotFoundError will never be thrown? (even when playing with the save() params) => the error thrown instead is NoRowsUpdatedError (and it means the same thing).\nI thought this issue was about \"there is no user with the id 1234, a notFound error should be throw\".\nThus the above example should be rewritten as:\nTypeScript\nconst id = 'unknown';\nnew FooBar({id})\n  .save({foo: 'bar'}, params)\n  .then(fooBar => ...)\n  //.catch(FooBar.NotFoundError, ...\n  .catch(FooBar.NoRowsUpdatedError,\n    () => next(createError(404, `'${id}' not found`)))\n  .catch(error =>\n    next(createError(500, error)));\nright?\n. > the final solution to this problem ended up not being a notFoundError, but a NoRowsUpdatedError instead\nOk, got it, my mistake then.\n. I've switched all my code from var Account = bookshelf.Model.extend({ ... }) to TypeScript classes (class Account extends bookshelf.Model<Account> { ... }) and all my unit tests pass as before. They heavily test NotFoundError, NoRowsUpdatedError and NoRowsDeletedError; example:\nTypeScript\nconst id = req.body.id;\nnew Account({id})\n  .fetch({require: true})\n  .then(account =>\n    res.status(HttpStatus.OK_200).send(account.toJSON())\n  )\n  .catch(Account.NotFoundError, () =>\n    next(createError(HttpStatus.NotFound_404, `'${id}' not found`))\n  )\n  .catch(error => next(error));\n``` TypeScript\nit('should not get an unknown account', done => {\n  const id = -1;\nrequest(app).get(/Accounts/${id})\n    .expect(HttpStatus.NotFound_404)\n    .then(res => {\n      expect(res.body).toEqualErrorObject({\n        status: HttpStatus.NotFound_404,\n        stack: NotFoundError: '${id}' not found,\n        message: '${id}' not found,\n        name: 'NotFoundError'\n      });\n      done();\n    });\n});\n```\nI was surprised and did more investigations and my conclusion is that ~~everything works as expected~~. Edit: it does not work.\n@rhys-vdw \n1. Are you sure that \"Bookshelf's extend method [...] decorates the class with specific instantiations of these errors\" does not work with ES6 classes? Is there a unit test somewhere to confirm?\n2. ~~If it does not work as you say, why does it with TypeScript (ES5 output) and not with Babel?~~\n(My previous obsolete and deleted post was: \"Meanwhile how to solve the NotFoundError and friends problem while inheriting from Bookshelf.Model?\")\n. TypeScript\n.catch(Account.NotFoundError, error => /* could be either account or user */ );\nOk I see; my mistake.\nTemporary solution:\n``` TypeScript\nimport * as createError from 'create-error';\nclass Account extends bookshelf.Model {\n  get tableName() { return 'Accounts'; }\n// Redefine errors\n  static NotFoundError = createError('NotFoundError');\n  static NoRowsUpdatedError = createError('NoRowsUpdatedError');\n  static NoRowsDeletedError = createError('NoRowsDeletedError');\n}\n```\n. @ricardograca empty => \nJavaScript\nModelBase {\n  attributes: {},\n  _previousAttributes: {},\n  changed: {},\n  relations: {},\n  cid: 'c15',\n  id: undefined,\n  _knex: null\n}\nEdit: this is in the case of an unknown model and require: false\n. @ricardograca \n\nUsing the object notation in a withRelated call [...] There's an example in the docs.\n\nI don't see anything related in the docs.\n. @ricardograca ok, I was expecting an example for \"the object notation\": withRelated: ['company.user.country', 'company.user.role']\n. @dj-hedgehog \nPlease re-open this issue, the dotted notation is still not properly documented.. @rhys-vdw no pb, I've seen that you use \"no-trailing-spaces\": 1 :+1: \n. Obviously Travis CI does not fail because of this commit => network error (ECONNRESET)\n. @rhys-vdw now you can :)\nThere are more errors that can be fixed: https://validator.w3.org/checklink?uri=http%3A%2F%2Fbookshelfjs.org (some of the errors presented are wrong - quite strange) + Model#attributes links don't show up/exist: I kept them since Model really have an attributes property.\nWould be nice to check the links using node-simplecrawler. For that we need to have a CLI (https://github.com/cgiffard/node-simplecrawler/issues/185) and call it from jsdoc.sh.\n. @dj-hedgehog \nPlease re-open. This is still a valid documentation issue.. @dj-hedgehog\nThis is might not be a top priority but it's still valid.\nModel.through() documentation still returns a Collection. It propably should be a Model. Please don't close old issues.. @Playrom\n\nthere are almost 500 issues, a lot of them back in years [...] we need to [...] focus [on] the most recent or important issues and prs...\n\nFixing important issues and PRs and closing all issues are just totally unrelated.\nYou can tag important issues and PRs and sort them without disturbing users.\nThere are GitHub projects with far more issues than Bookshelf and still thriving.\n\nalso if someone get some bad behaviour in bookshelf usage a simple search can prompt an old issue which can be reopened without any problem\n\nThis will almost never happen. GitHub search defaults to open issues + a user cannot reopen an issue: you need an admin for that and users won't ask 90% of the time.\nWhat will happen instead: users will open new issues instead of contributing to related existing issues since they are closed => losing unvaluable informations.\n\nAlso people subscribe to issues in order to be notified, now they will never know a particular feature has been released or a bug has been fixed.\n=> what you have done here is cut the historical user base from the project.\n\nHere my workflow to understand:\neach time I have a problem with one of my dependency (feature needed or a bug):\n- find the related issue(s)/PR(s) or create a new one\n- comment on the issue if valuable\n- subscribe to it\n- add a TODO or FIXME in my code and the link to the GitHub issue\nwhen getting a notification (email) about a feature implemented or a bug fix:\n- search my projects for the related piece of code\n- rework my code\n- add comments on the related GitHub issue if valuable\n. @dj-hedgehog\n\nThis way we see which of the old issues are still considered important so we can prioritise our efforts.\n\nYou can tag important issues instead. ",
    "pepperpepperpepper": "Yep. This was embarrassing\nawesome library by the way!\n. ",
    "Couto": "It's not perfect, since I'm now the entire responsible of syncing, formating and parsing of the returned values with the model, but it should work indeed.\nThanks for the tip :)\n. ",
    "emadd": "Awesome.  Thanks!\n. Beautiful!  Thank you.\n. ",
    "aaronmoodie": "Thanks @bendrucker. looking at this a bit too late last night I think. \n. thanks @rhys-vdw. This is getting me a little further, but still hitting issues. I've renamed things to make it a little clearer. \n``` javascript\nreturn new this().query(function(query) {\n  var trackIds = bookshelf.knex('tracks')\n    .select('tracks.id')\n    .sum('votes as points')\n    .join('votes', 'tracks.id', 'votes.track_id')\n    .groupBy('tracks.id');\nquery.join(trackIds.as('y'), 'y.id', 'tracks.id')\n    .orderByRaw('(y.points - 1)/POW(((UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(x.timestamp))/3600)+2, 1.5) DESC')\n    .limit(limit)\n    .offset(offset)\n})\n```\nIf I use .select('id') I'm getting error: column reference \"id\" is ambiguous. With the code as it is above, I'm getting error: function sum(votes) does not exist. \nI have this set up as part of the Tracks Collection\njavascript\nvar Tracks = bookshelf.Collection.extend({\n  model: Track\n}, {\n  getPopular: function(limit, offset) {\n    // above query\n  }\n});\nIs it the way that I'm referencing the collection that's the issue? When I tried just a simple var TrackIds = bookshelf.knex.select('id') the error contained hint: 'There is a column named \"id\" in table \"tracks\", but it cannot be referenced from this part of the query.'\n. Thanks @rhys-vdw \ud83d\ude09\nOk, so got everything working, and here is the code. I'm using Postgres, so have updated the raw query for that. The issue was I was using .sum() instead of .count() \u2013 thanks for pointing that out! \nI'm going to move this out of the Collection and over to the Model as you suggested however. Thanks again for the help!\n``` javascript\nreturn new this().query(function(query) {\n  var trackIds = bookshelf.knex('tracks')\n    .select('tracks.id')\n    .count('votes as points')\n    .join('votes', 'tracks.id', 'votes.track_id')\n    .groupBy('tracks.id');\nquery.join(trackIds.as('y'), 'y.id', 'tracks.id')\n    .orderByRaw('(y.points - 1)/pow(to_char(now() - tracks.created_at, \\'HH24\\')::int + 2, 1.5) DESC')\n    .limit(limit)\n    .offset(offset);\n})\n```\n. ",
    "briandela": "Agreed. That would be bullet proof. If we didn't have that ability is there a currently known way?\nI'm definitely will to do a pull request - any pointers to where it should go and any design considerations ye would like (e.g. not adding a dependency to something like http://momentjs.com/, etc.) \n. @tgriesser @bendrucker  Any thoughts on this?\n. @tgriesser is there a potential 'fix' for this or is the recommendation to ignore the global leak of __core-js_shared__ and `core.\nJust asking as right now we can't move from 0.8.2 to 0.9.1 due to this causing our CI servers to fail the builds. I can add an explicit override for the leaks, but just wondering if it can be addressed and if so, I can hold off for a bit.\n. ",
    "robertd": "I've set timezone to UTC in my postgres.conf. However, Bookshelf/Knex still stores the timestamps in postgres in local time, but when it comes back from my API it looks like this.\n{\n    \"display_name\": \"john_doe\",\n    \"contact_email\": \"john@doe.net\",\n    \"created_at\": \"2015-01-30T22:25:23.446Z\",\n    \"updated_at\": \"2015-01-30T22:25:23.446Z\",\n    \"id\": 5\n}\nTimestamps fields in the DB are without time zone\nIf I try to run insert query directly through PgAdmin with now(), timestamps are stored as UTC.\n. I've set timezone to UTC in my postgres.conf. However, Bookshelf/Knex still stores the timestamps in postgres in local time, but when it comes back from my API it looks like this.\n{\n    \"display_name\": \"john_doe\",\n    \"contact_email\": \"john@doe.net\",\n    \"created_at\": \"2015-01-30T22:25:23.446Z\",\n    \"updated_at\": \"2015-01-30T22:25:23.446Z\",\n    \"id\": 5\n}\nTimestamps fields in the DB are without time zone\nIf I try to run insert query directly through PgAdmin with now(), timestamps are stored as UTC.\n. I ended up using straight knex\nknex('books')\n    .join('chapters', 'books.id', 'chapters.book_id')\n    .select('*')\n    .where('chapters.title', '=', 'Title')\n. I've tried it but I'm getting empty results for books.\nnew Chapter({\n            title: 'Title'\n          })\n          .fetch({ withRelated: ['books'] })\n          .then(function(chapter){\n            reply(chapter);\n          })\n          .catch(function(err) {\n            return reply(Boom.wrap(err, 400));\n          });\nmodels\n```\nvar Books = Bookshelf.extend({\n    tableName: 'books',\nchapters: function () {\n      return this.hasMany('Chapter', 'book_id');\n    },\nhasTimestamps: true\n\n});\n};\nvar Chapter = Bookshelf.extend({\n    tableName: 'chapters',\nbooks: function () {\n  return this.belongsTo('Book');\n},\n\nhasTimestamps: true\n\n});\n};\n```\noutput\n{\n\"title\": \"Title\",\n\"id\": 3,\n\"book_id\": 1,\n\"created_at\": null,\n\"updated_at\": null,\n\"books\": {}\n}\ndebug output\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ 'Title', 1 ],\n  sql: 'select \"chapters\".* from \"chapters\" where \"chapters\".\"title\" = $1 limit $2' }\n{ __cid: '__cid2',\n  method: 'select',\n  options: undefined,\n  bindings: [ undefined ],\n  sql: 'select \"books\".* from \"books\" where \"books\".\"id\" in ($1)' }\nBindings are undefined for books  bindings: [ undefined ],\nAm I missing anything?\n. My knex migrations\n```\n//Books\nexports.up = function(knex, Promise) {\n  return knex.schema.createTable('books', function (table) {\n    table.increments('id').primary().notNull();\n    table.string('name', 100).notNull();\n    table.timestamps();\n  });\n};\nexports.down = function(knex, Promise) {\n  return knex.schema.dropTableIfExists('books');\n};\n//Chapters\nexports.up = function(knex, Promise) {\n  return knex.schema.createTable('chapters', function (table) {\n    table.increments('id').primary().notNull();\n    table.string('title', 50).notNull();\n    table.integer('book_id').notNull().references('id').inTable('books');\n    table.timestamps();\n  });\n};\nexports.down = function(knex, Promise) {\n  return knex.schema.dropTableIfExists('chapters');\n};\n``\n. btw... thanks for your help figuring this out\n. I also noticed that in many-to-many relationships this works (when I have 3 tables) but not in one-to-many it doesn't (2 tables)\n. I do havebook_id` in Chapters.\nexports.up = function(knex, Promise) {\n  return knex.schema.createTable('chapters', function (table) {\n    table.increments('id').primary().notNull();\n    table.string('title', 50).notNull();\n    table.integer('book_id').notNull().references('id').inTable('books');\n    table.timestamps();\n  });\n};\n. I'm using hasMany in Books model (from API docs model.hasMany(Target, [foreignKey])) where Target is   Chapter and foreign key is book_id in chapters table\n. That was a typo. Sorry. I was copy pasting stuff.\u00a0\n\u2014\nSent from Mailbox\nOn Tue, Feb 10, 2015 at 11:39 AM, Ben Drucker notifications@github.com\nwrote:\n\nRight, your database is correct. The hasMany doesn't matter here. Relations are not automatically bidirectional. You have to define both sides. The side that matters here is that a chapter belongsTo a book, meaning that a chapter has a key book_id that corresponds to the id of a row in books. \nWe're on the same page there. Here's where an issue becomes evident. You say the output is:\njs\n{\n\"title\": \"Title\",\n\"id\": 3,\n\"user_id\": 1,\n\"created_at\": null,\n\"updated_at\": null,\n\"books\": {}\n}\nWhat happened to the book_id column?\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/issues/616#issuecomment-73756295\n. It is book_id. I was using user/roles example but then I opted out for books/chapters. \n\n\u2014\nSent from Mailbox\nOn Tue, Feb 10, 2015 at 11:39 AM, Ben Drucker notifications@github.com\nwrote:\n\nRight, your database is correct. The hasMany doesn't matter here. Relations are not automatically bidirectional. You have to define both sides. The side that matters here is that a chapter belongsTo a book, meaning that a chapter has a key book_id that corresponds to the id of a row in books. \nWe're on the same page there. Here's where an issue becomes evident. You say the output is:\njs\n{\n\"title\": \"Title\",\n\"id\": 3,\n\"user_id\": 1,\n\"created_at\": null,\n\"updated_at\": null,\n\"books\": {}\n}\nWhat happened to the book_id column?\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/issues/616#issuecomment-73756295\n. I'll check it out right now. Btw I'm using pg for db and hapi-bookshelf-models.\n. bookshelf-616 works just fine with my pg setup. Codewise everything seems same/similar. I wonder if hapi-bookshelf-models is the problem.\n\nI'm going wrap your test with hapi-bookshelf-models and give it a try.\n. Haha that will not be necessary :) https://github.com/robertd/bookshelf-demo is working just fine with hapi-bookshelf-models\nIt's definitely something with my code/setup. Something is telling me that it's .fetch({ withRelated: ['books'] }). It should be .fetch({ withRelated: ['book'] }). Will let you know tomorrow :)\nThanks for all your help Ben :+1: \n. Changed it from books to book and for some reason it only works when I specify foreign key in Chapters model. Otherwise I get empty book: {}\nbook: function () {\n      return this.belongsTo('Book', 'book_id');\n    },\nDoes it matter if my table names are something like xyz_books and xyz_chapters. Far fetched question but worth asking I guess :)\n. Aha!...so that's the culprit. :)\nThanks a bunch Ben ;)\n. ",
    "dzstara": "We store data from multiple timezones and this issue is important to us, is it possible to open it again?. ",
    "grantchiu011101": "hi @briandela \nseller.sellerTypes().attach([1, 2], {transacting: transaction});\nit only handle seller_id and seller_type_idfields\nbut if you \nseller.sellerTypes().attach({\n    seller_type_id: 1,\n    created_at: moment().format(YY-MM-DD, HH:ii:ss),\n    updated_at: moment().format(YY-MM-DD, HH:ii:ss)\n}, {transacting: transaction});\nit is just a work around solution\n. ",
    "lichtner": "ok, but how can I modify some attributes of model before save?\nI supposed to use format (from homepage: The format method is used to modify the current state of the model before it is persisted to the database.)\n. I used it for change date and time format from momentjs format to mysql format 00:00:00. E.g.:\njs\nformat: function (attrs) {\n  attrs.timeFrom = moment(attrs.timeFrom).format('HH:mm:ss');\n  return attrs;\n}\nBut this broke fetch because timeFrom attribute is not exist in this time.\nI try to ask another way. What is best practice if I want to modify some attribute before persist? Or can I define setter for attribute in other way? Could you write me here please same very simple example to achieve this? Thanks.\n. ok thanks\n. Sorry, I found it withPivot.\n. Sorry, I found it withPivot.\n. thanks it works, \nit is sad, that no mention about it in doc :(\n. ",
    "wrouesnel": "I too would like an answer to this - I'm querying against potentially huge tables, it'd be nice to enforce the dataset only returns the subset I'm looking for in the model.\n. Ok figured this out: this is a version of what happens when you have circular dependencies because you're not using the registry plugin.\nChanging the code to use the registry plugin, and everything seems to be working properly.\nThis needs to be stressed way more in the documentation then it is - because it's easy to run into with even a slightly complex mapping, and produces errors that do not make, nor seem to rise from, anywhere sensible.\n. I'm somewhat confused then as to what the belongsTo() hints are providing in my models then as opposed to a hasOne() hint?\ni.e. the query I basically want to run is something like\nsql\nSELECT node.*, notification.* FROM notifications\nINNER JOIN node ON notification.nodeid=node.nodeid\nWHERE notification.answeredby IS NULL\nwhich you could also separate as 2 queries\nsql\nSELECT notification.* FROM notifications\nWHERE notification.answeredby IS NULL\nand\nsql\nSELECT node.* FROM nodes\nWHERE nodeid IN (<nodeids we got from the top one>)\nWhich feels like they should be implied by belongsTo() (as opposed to hasOne())\n. Actually a node hasMany() notifications. My previous example was just to ask how belongsTo() differs from hasOne() - since a notification hasOne() node as much as it belongsTo() a node.\nWhat I'd like to be able to do with that model is something like:\njavascript\ncollection = Node.forge({ notifications: {answeredby: null} } )\n                       .fetchAll({withRelated: 'notifications' });\nand get back a collection of nodes executed by a query like that.\n. I ended up writing a function which just does the inversion for me manually - i.e. I query on notifications { answeredby: null } with the related nodes, then monkey around with the bookshelf data structure to reverse the object graph.\nI'd like to add this directly as a bookshelf function, but the need to make it work was a priority. I can post the function I wrote when I get a chance.\n. ",
    "dbryand": "FYI, I solved this by modifying the relatedData before returning the relation:\n``` javascript\n// Event Model\nparty: function() {\n    var relation = this.hasOne('Party');\n    relation.relatedData.targetIdAttribute = 'event_source_id';\n    relation.relatedData.parentIdAttribute = 'source_id';\n    relation.relatedData.parentId = this.get('source_id');\n    relation.relatedData.parentFk = this.get('source_id');\nreturn relation;\n\n},\n```\n. Thanks @bendrucker.\n. ",
    "awebdeveloper": "care to explain a bit about your table structure \n. You can look into this\nhttps://github.com/tgriesser/bookshelf/issues/545\n. i guess this is still valid . ",
    "1mike12": "pg most likely does this because you want to preserve zeros and not let that information disappear. For instance, you want $10.00 to become \"10.00\", not drop the 2 decimal points and be converted to a number and lose information as 10. What we want to happen is when we run \njavascript\nClass.fetchAll({\n        withRelated: [\"SubClass\"]\n    })\nTo have it do \n'select \"classes\".* from \"classes\" where \"classes\".\"deleted_at\" is null' \n'select \"subclasses\".* from \"subclasses\" where \"deleted_at\" is null and \"subclasses\".\"class_id\" in (?)\"\nRight now, the second query doesn't have the second deleted_at is null clause. The plugin needs a way to detect when withRelated calls are being made so that we can slap in the check for soft deletion. \nInstead, the workaround we have to manually keep doing is \njavascript\nClass.fetchAll({\n        withRelated: [\"subclasses\", {\n            \"subclasses\": function(qb){\n                qb.whereNull(\"deleted_at\")\n            }\n        }]\n    })\nWhat I got so far\nSo I can see where the withRelated is actually being handled in bookshelf/src/model.js: \njavascript\n_doFetch... \n.tap(function(response) {\n        if (options.withRelated) {\n          return this._handleEager(response, _.omit(options, 'columns'));\n        }\n      })\nAnd I can see how the query is being manipulated by the plugin, \n``` javascript\nfunction addDeletionCheck(softFields, opts){\n    var deletedAtField = softFields[0];\n    var restoredAtField = softFields[1];\n/*eslint-disable no-underscore-dangle*/\nif (this._knex) {\n    var table = this._knex._single.table;\n    /*eslint-enable no-underscore-dangle*/\n\n    deletedAtField = table + '.' + softFields[0];\n    restoredAtField = table + '.' + softFields[1];\n}\n\nthis.query(function(qb){\n    qb.where(function(){\n        var query = this.whereNull(deletedAtField);\n        if (softFields[1]) {\n            query.orWhereNotNull(restoredAtField);\n        }\n    });\n});\n\nif (opts.withRelated) {\n    //??? what do\n}\n\n}\n```\nBut from here I am way out of my element and have no idea how to hook into the withRelated part, or if it's even possible\n. @ricardograca can you please reopen?\n. perfect exactly what I was looking for. Thanks!\n. perfect exactly what I was looking for. Thanks!\n. thanks for the help @vellotis !\n. @vellotis I just wrote a quick plugin to do this task. It didn't feel right to rewrite the whitelist for attributes when the info is all there. \nhttps://github.com/1mike12/bookshelf-strip-save\n@rhys-vdw can you add this to the plugins page too?\n. @andrejkaurin I fixed my problem by updating knex. I was on 0.9.0, from November 2015, and updating to latest as of this writing,0.12.16 it is now working\n. ",
    "CaptainJojo": "Hello, I have the same problem, I want get element with queyr directly on json column.\nExemple:\nI have column name 'data' in my table, this column is type json.\nI want get all elements with 'data' have key 'team' =  'PSG', \nI test :\n```\ncollection.query('where', \"data\", \"#>\", \"'{team, PSG}'\");\nError: \"The operator \\\"#>\\\" is not permitted\"\n```\nOR\n```\ncollection.query('whereRaw', \"data->'team'->>'PSG'\");\nError:  \"argument of WHERE must be type boolean, not type text\"\n```\nAny idea ?\n. ",
    "maximgubar": "+1\n. ",
    "bs85": "Good to see you sharing the concerns I've had with Bookshelf (besides everything amazing it does)\nWe use a single tenant database model, meaning I have to initialize my models for every client. It works but it's far from ideal..\nMoving away from Backbone would be great for performance. In some tests I ran, fetching a thousand models would easily spend close to 200ms in the set() method from lib/base/model, multiplied by the number of relations.\nI changed the way attributes were assigned and got a 15x performance increase for the hydration:\njs\nfor (var attr in attrs) {\n  val = attrs[attr];\n  if (!_.isEqual(prev[attr], val)) {\n    this.changed[attr] = val;\n    if (!_.isEqual(current[attr], val)) hasChanged = true;\n  } else {\n    delete this.changed[attr];\n  }\n  unset ? delete current[attr] : current[attr] = val;\n}\nbecomes\njs\nif (Object.keys(current).length === 0) {\n    current = attrs;\n  }else{\n    // For each `set` attribute, update or delete the current value.\n    for (var attr in attrs) {\n      unset ? delete current[attr] : current[attr] = val;\n    }\n  }\n}\nKeeping track of changes could be a parameter, or you could just initialize what's required on the first actual change, not the initial fetch. Big collections in read only would benefit a lot.\n. ",
    "pablobcb": "The new transaction api wouldnt let me to share a transaction object between expressjs/restify middlewares, would it?\n. The new transaction api wouldnt let me to share a transaction object between expressjs/restify middlewares, would it?\n. ",
    "thomasdashney": "As a user coming from Sails.js/Waterline and looking for a more \"Data Mapping\" approach to things, Bookshelf.js looks really exciting. Especially all of the changes proposed here!\nIf I start writing my project now using Bookshelf 0.7, how tricky do you anticipate the transition to be with all of the breaking changes?\n. ",
    "jedd-ahyoung": "Don't know if this is the right place, but I'd like to be able to provide a context for my queries on a specific model or set of models. For instance, if a user logs into a multi-user application, I only want queries to target rows that involve that user ID. I can do that manually, but I think I'd like an API like this:\nvar model = bookshelf('tasks').context({ \n        tasks: user_id: user.user_id\n    });\nI'm not yet sure if this is really possible with bookshelf. It looks as though calling model.where() doesn't returns a chainable object, but not the root model object. I'd like to be able to set a clause on the model object that I could use for all subsequent calls to that model. I have more experimentation to do, but I'd love to learn what I can do to make this work.\n. @ricardograca It could, for certain cases, like issuing complex queries only specifying active tasks (as an example). In other cases, I think it could work as something that you could set per lifecycle; in the previous example, I'd like to be able to set the user in the bookshelf query per HTTP request without having to make multiple where clauses.\nI've been trying to set this up manually. Perhaps this functionality is already available with Bookshelf.Collections.extend.\n. ",
    "dylancwood": ":+1: \n@tgriesser: Do you have any thoughts regarding the implementation of this?\n\nCamel Case\nparse and transform and such are pretty weak, and they're mostly used for camel casing attrs, so we'll just add this as an option, keeping the model as the transform layer for the keys so we don't need to go to and from all the time when coming from the db. Then we'll advertise the parse and transform\n\nIf you are willing, I would like to help by implementing this to your specifications. The simplest way may be to apply case conversion in the set, get and toJSON methods of the base/Model, as well as add a call to convertKeysToSnakeCase anywhere that format is currently called. \nIs this something that could be added into Bookshelf now-ish, then updated as necessary as the other new features mentioned above roll in?\n. I am also experiencing this issue, and believe that issue #957 is also related. I've written a rather long explanation and solution, so please bare with me.\nProblem\nmodel.id\nThe problem is that model.id is undefined when the related models are being grouped into the parent model (link). The model.id property should be set immediately after the model is retrieved from the database: handleResponse() calls model.set(), which sets model.id). Unfortunately, model.set() uses model.idAttribute in order to set model.id. @kisayista's idAttribute is snake_case, but the model has already been through the model.parse function, and contains camelCase property names. Because idAttribute is snake_case and the property names are camelCase, model.set() is not able to set model.id.\nmodel.idAttribute vs parentResponse\nSo, if @kisayista changes the attributeId to camelCase, it should fix this problem. Unfortunately, it will introduce another problem: if idAttrubute is camelCase, then the query bindings for the related query will be undefined (link):\neagerKeys: function(response) {\n    const key = this.isInverse() && !this.isThrough()\n      ? this.key('foreignKey')\n      : this.parentIdAttribute;\n    return _(response).pluck(key).uniq().value();\n  }\nthis.parentIdAttribute is the same as model.idAttribute of the parent model (camelCase), but the resp object is the raw response of the parent object, and is in snake_case format.\nSolution\nAs mentioned by @rhys-vdw in #957, the true solution to this could involve an intensive refactor of how parsed, formatted and raw states are handled.  I think that this would be well worth it, but will inevitably be a breaking change. \nI'll describe my favorite simple solution, and hopefully @tgriesser  or @rhys-vdw will have some feedback.\nCompute and store a parsedIdAttribute on the model on construction:\nin lib/base/model.js line 26\n}\n+ this.parsedIdAttribute = Object.keys(this.parse({[this.idAttribute]: null}))[0];\nthis.set(attrs, options);\nand use the parsed idAttribute as a fallback when setting model.id in lib/base/model.js, line 63:\n- if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n+ if (this.idAttribute in attrs) {\n+   this.id = attrs[this.idAttribute];\n+  } else if (this.parsedIdAttribute in attrs) {\n+   this.id = attrs[this.parsedIdAttribute]\n+ }\nDiscussion\nPatching either problem will fix the issue. I think that we can more easily patch the first problem than the second one. Even if we were able to make a small patch which fixed the second problem by enabling the use of camelCase idAttribute in eagerKeys, things would still be imperfect: the idAttrubute would be camelCase, but the hasMany foreign key would still need to be specified in snake_case (unless further changes were made). I advocate that all references to column names & model properties should follow the same convention within the model definition. Since conversion to camelCase is purely an ad-hoc result of the parse function, it makes sense to use the database's convention in the model (snake_case in this case).\nI would also suggest adding something to this effect to the docs, as it has been a major pain point for me and my colleagues. Additionally, it would be neat to add a check in the eagerPair function that checks whether the number of relations matches the number of pairings performed.  If they do not match, something is wrong, and we could throw an informative error.\nI would love to submit a PR for all these changes, but want to gage enthusiasm first. \nThanks\n. Bump :+1: \n. Bump :+1: \n. It is possible to set parsedIdAttribute on a single line, but I broke it up here for increased readability.\n. ",
    "Mbertu": "First of all thank you.\nThe instructors table has a fk on the user_id column.\nThe relation is a one (or none)-to-one, the instructor must have an user reference, but the user can have no instructor associated.\nIs that enough?\n. I've got what i need by using a custom knex query forcing the query builder to execute the leftjoin between the tables (by explict leftJoin() method invocation).\nNow the question is: is this the best way to do such a thing with bookshelf?\nThank you.\nMichele Bertuccioli\n. ",
    "imjoshholloway": "Does the add even method work with Polymorphic Associations?\nI couldn't get it to actually add the record in the database. I resorted to just manually creating the model afterwards.\n. @ricardograca I'm inclined to agree. I've resorted to doing the following:\njavascript\nsaving: function (model, attrs, options) {\n    var promises = [];\n    promises.push(this.checkParentId(model, attrs, options));    \n    return Promise.all(promises).then(this.validate.bind(this));\n}\nThe only frustrating thing is that I need to make sure I call the validate method everytime I override the saving method.\n. @ricardograca I'm inclined to agree. I've resorted to doing the following:\njavascript\nsaving: function (model, attrs, options) {\n    var promises = [];\n    promises.push(this.checkParentId(model, attrs, options));    \n    return Promise.all(promises).then(this.validate.bind(this));\n}\nThe only frustrating thing is that I need to make sure I call the validate method everytime I override the saving method.\n. @ricardograca at the minute it is, but it will contain multiple promises once finished. I've got about 3 other checks that need to happen similar to the checkParentId one.\n. @ricardograca at the minute it is, but it will contain multiple promises once finished. I've got about 3 other checks that need to happen similar to the checkParentId one.\n. ",
    "jescalan": "Hey Ben,\nThanks for the quick response. I've put a number of hours into this (mostly testing it with a huge test case), and it's actually been really difficult and incredibly frustrating. I'm sure a part of this is because I'm not as familiar with bookshelf as you guys are, but nonetheless I would love to get even a slight bit of guidance on the best way to approach this.\nMy initial thought was to use the destroying event to find the relations, then zero them out. I tried something like this to do so (the before_destroy event is correctly linked and firing, and assuming this is in a \"destination\" model that has many \"tips\").\njs\nbefore_destroy: function(){\n  When.map(this.related('tips'), function(m){ m.save(destination_id: null); });\n}\nThis seemed legit to me -- before deleting the model, it zeroes out the relation so that there's no conflict when it's deleted. However, I'm still getting the same foreign key constraint. Are there any more properties I need to clear out before it can successfully be deleted? Do I need to clear out this.related('tips') somehow? Do I need to re-fetch the dependencies somehow before deleting as well?\nEDIT: Never mind, this is a stupid error, i just needed to map this.related('tips').models. This is almost working now, will update again once it's fully working and tested with how I did it in case anyone else is looking here in the future\nEDIT 2: Ok, I do have this working now with the following code:\njs\nW.map(@related('tips').models, (m) -> m.save(destination_id: null))\nSilly mistake leaving out the models property. However, I do still have one small issue -- when I have a reference to the model whose relation was removed, after it's relation is removed when I call fetch on the model, it returns undefined for some reason. However, if I just use where to run a search for the model by id, it comes back fine. While this slightly bothers me, it's enough to know that the code is working right, so yay!\n. Ah thanks, this is super helpful, really appreciate it. I'll try switching it over to that way and see if that improves things. And yeah I assumed that the null fetch probably had something to do with the fact that properties had changed (what else could it be), so that seems like the issue you linked is the right explanation. It doesn't look like that issue has been resolved though -- does fetch run a select including every property on the model? I do agree with the author that this does seem silly when you could just use the id...\n. Makes sense. I assume you mean major? But yeah this is entirely fine, just wanted to make sure I wasn't doing something else wrong with the fetch thing. Replacing it with a fresh find by id for now is not an issue at all.\nThanks again for your great work on this library and your time helping out with this question. Really appreciate it Ben :grinning: \n. Oh of course hah, sounded funny when you said it that way for some reason.\n. ",
    "mike-kelly": "That did it - thanks.\nI had to set the foreign key and other key in belongsToMany explicitly, as the join query was then looking for column tag_tag_id in the join table. \nSo for anyone else with this issue - the convention would be to have id as the primary key in the tags table, and tag_id as the foreign key in the join table  - that way everything would work out of the box.\n. Having updated my table designs, I still get an error when I don't declare the keys explicitly in belongsToMany().\nIt seems, contrary to the documentation, which says:\nThe default key names in the joining table are the singular versions of the model table names, followed by _id\n...that the default key names in the joining table are the singular versions of the model table names, followed by underscore, followed by the model's idAttribute.\nTherefore when I explicitly declare the Tag model's idAttribute to be tag_id, the default key name in the joining table is tag_tag_id. \nThis is not what I want - so having renamed the pk in tags to id I simply set the idAttribute to match.\n. Not an expectation, just reporting what appears to be the case - if I declare the Tag model's idAttribute, it seems to be used as part of the default key in the belongsToMany function. So, taking the example in the first post above, if have this in the Tag model:\nidAttribute: 'xyz',\ntableName: 'tags',\nthen the default key (the key used if it is not explicitly declared) in belongsToMany becomes tag_xyz instead of tag_id as suggested in the docs.\nSo when accessing /cards I get error: column cards_tags.tag_xyz does not exist\n. Thanks, this is really useful. Polymorphic relations is new territory for me but looking into it is already clarifying the possible approaches to take here.\n(BTW, in morphOne() shouldn't the name parameter just be the prefix, i.e. plugin instead of plugin_type?)\n. ",
    "bsiddiqui": "js\n  return knex.schema.createTable('test_table', function (table) {\n    table.increments('id');\n    table.string('name');\n    table.timestamps();\n  });\n. @bendrucker only customizations to the model here: https://github.com/enjoy/bookshelf-modelbase/blob/master/lib/index.js\n. @bendrucker were you able to reproduce or is this just on my end?\n. Great thanks!\nOn Fri, Jan 16, 2015 at 9:52 AM Ben Drucker notifications@github.com\nwrote:\n\nClosed #572 https://github.com/tgriesser/bookshelf/issues/572.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/572#event-220222511.\n. @jtwebman awesome plugin - definitely would be nice to have a list of plugins somewhere on the site kind of like hapi does for plugins\n. @jtwebman awesome plugin - definitely would be nice to have a list of plugins somewhere on the site kind of like hapi does for plugins\n. @ricardograca does the same thing about initialize overriding apply to plugins? As in, if you have a plugin that utilizes initialize for events, will it override other plugins that are utilizing initialize?\n. @ricardograca does the same thing about initialize overriding apply to plugins? As in, if you have a plugin that utilizes initialize for events, will it override other plugins that are utilizing initialize?\n. Ok so doing something like this would cause unexpected behavior because it overrides bookshelf.Model\n\nLooks like this adds custom methods without overriding bookshelf.Model but how would you do it if you wanted to modify the model prototype so you could hook into events?\n. Ok thanks that's really helpful. If you have two plugins, both of which override bookshelf.Model and have a custom initialize()\njs\nbookshelf.plugin(require('plugin1'))\nbookshelf.plugin(require('plugin2'))\nDoes adding that second plugin override the first plugins initialize function if it doesn't call the parent's initialize() method? Assuming it would because, while bookshelf.Model doesn't doesn't do anything, the first plugin changes bookshelf.Model so it does do something\n. @ricardograca yeah you're right - just tested. Thanks!\n. This is super useful, thanks!\n. This is super useful, thanks!\n. @sandro-csimas where did you try adding require: false?\nHere is the query you posted: \njs\nreturn UserActivity\n.where({ place_id: place.id })\n.save({ \n  place_id: null, \n  parameters: JSON.stringify({ place_name: this.place.get('name') })\n}, {\n  method: 'update', \n  patch: true, \n  transacting: transaction\n});\nI just tested a similar query but added require: false as an option for save and it didn't throw an error.\njs\nreturn UserActivity\n.where({ place_id: place.id })\n.save({ \n  place_id: null, \n  parameters: JSON.stringify({ place_name: this.place.get('name') })\n}, {\n  method: 'update', \n  patch: true, \n  transacting: transaction,\n  require: false // see if this helps\n});\n. ok that's helpful, thanks!\n. ok that's helpful, thanks!\n. @rhys-vdw yeah definitely think it would be nice to rename - would clear up some confusion\n. @rhys-vdw yeah definitely think it would be nice to rename - would clear up some confusion\n. @rhys-vdw tried to an update using the signatures mentioned here\njs\nUser.where({ id: 1 }).save('first_name', 'Basil', { patch: true, method: 'update' })\nworks effectively, but\njs\nUser.where({ id: 1 }).save({ first_name: 'Basil' }, { patch: true, method: 'update' })\nproduces a select with an undefined id \n. @rhys-vdw a select - the first query, however, does an update\n. @rhys-vdw also, doing that query without method: 'update' does an insert since the model isNew unless an id has been set on the model - but, I agree, it should be an update anytime you include patch\n. @rhys-vdw looks like\njs\nUser.where({ id: 1 }).save({ first_name: 'Basil' }, { patch: true, method: 'update' })\nruns a select and then a update, which is why it fails when I add require: true bc the select doesn't find the undefined model\nIt's a bit odd that that is different than using save with key, value\n. @ricardograca I believe so\n. @lichtner have you tried\njs\nPersonModel.query({ \n   where: { firstName: 'aaa', lastName: 'bbb' }, \n   orWhere: { firstName: 'bbb', lastName: 'aaa' }\n}).fetchAll()\nYou can read more about the knex query build here: http://knexjs.org/\n. @lichtner have you tried\njs\nPersonModel.query({ \n   where: { firstName: 'aaa', lastName: 'bbb' }, \n   orWhere: { firstName: 'bbb', lastName: 'aaa' }\n}).fetchAll()\nYou can read more about the knex query build here: http://knexjs.org/\n. @rhys-vdw looks like this is fixed by https://github.com/tgriesser/bookshelf/pull/915\nBoth the README and docs have the equal sign\n. @rhys-vdw looks like this is fixed by https://github.com/tgriesser/bookshelf/pull/915\nBoth the README and docs have the equal sign\n. @rhys-vdw sorry that was just a typo - wouldn't the way you wrote it still add the query on Orders instead of OrdersUser\nthat will result in orders WHERE user_id=1\nand I want to add orders_users WHERE user_id=1\n. @rhys-vdw the relation is on address so it does a join on orders_users.address_id, it appears that your suggestion adds query I needed orders_users.user_id\nThat's pretty cool, didn't know you could do that\n. @rhys-vdw happy to fix this and some of the docs PRs - would you prefer a single PR or a separate PR for each issue?\n. @rhys-vdw happy to fix this and some of the docs PRs - would you prefer a single PR or a separate PR for each issue?\n. @rhys-vdw yeah that's what I thought but unfortunately it doesn't work like that. \nThe options is present when the eager relation is handled though\n. @rhys-vdw yeah that's what I thought but unfortunately it doesn't work like that. \nThe options is present when the eager relation is handled though\n. Yeah would love to turn this into a discussion thread. \nI agree that it wouldn't be intuitive to pass on options from the original fetch to eager relation fetch by default but I do think it would be helpful to expand the behavior so that we have the option to\n. Yeah would love to turn this into a discussion thread. \nI agree that it wouldn't be intuitive to pass on options from the original fetch to eager relation fetch by default but I do think it would be helpful to expand the behavior so that we have the option to\n. Yeah I like that, especially since it's syntatically similar to withRelated\n. Yeah I like that, especially since it's syntatically similar to withRelated\n. Could also make it an option in the relation object\njs\nwithRelated: [{\n   'relation': {\n      query: function (qb) {\n          return qb.where(...)\n      },\n      require: true\n    }\n}]\nBut I'd probably prefer your suggestion\n. Could also make it an option in the relation object\njs\nwithRelated: [{\n   'relation': {\n      query: function (qb) {\n          return qb.where(...)\n      },\n      require: true\n    }\n}]\nBut I'd probably prefer your suggestion\n. @jamesdixon you can do something like this:\njs\nreturn Appointment.where({ id: id, businessId: businessId }).save(data, { patch: true })\nIf your where clause doesn't include id then just pass the method: 'update' option to save\n. @jamesdixon you can do something like this:\njs\nreturn Appointment.where({ id: id, businessId: businessId }).save(data, { patch: true })\nIf your where clause doesn't include id then just pass the method: 'update' option to save\n. I used to do that as the default with bookshelf-modelbase but removed it recently. I'll probably add it as an option in a future version.\nThe way I implemented it was by overriding the model's format function.\nHere's a sample for something that should work: \njs\n    // camelCase attributes -> snake_case db columns\n    format: function (attrs) {\n      return _.reduce(attrs, function (memo, val, key) {\n        memo[_.str.underscored(key)] = val;\n        return memo;\n      }, {});\n    },\n. I used to do that as the default with bookshelf-modelbase but removed it recently. I'll probably add it as an option in a future version.\nThe way I implemented it was by overriding the model's format function.\nHere's a sample for something that should work: \njs\n    // camelCase attributes -> snake_case db columns\n    format: function (attrs) {\n      return _.reduce(attrs, function (memo, val, key) {\n        memo[_.str.underscored(key)] = val;\n        return memo;\n      }, {});\n    },\n. Oh yeah you're totally right, where is just a convenience method for queryBuilder.where.\nThat's a lot of the reason I ditched snake_casing a while ago - just felt like it was a constant battle.\n. Oh yeah you're totally right, where is just a convenience method for queryBuilder.where.\nThat's a lot of the reason I ditched snake_casing a while ago - just felt like it was a constant battle.\n. @rhys-vdw it's be great if bookshelf hooked into knex queries like that but I agree with Ben's original comment on your post about it being unexpected behavior if where is just a proxy for query.where \n. @rhys-vdw it's be great if bookshelf hooked into knex queries like that but I agree with Ben's original comment on your post about it being unexpected behavior if where is just a proxy for query.where \n. Gotcha ok so it was actually an insert that was returning an array and that looks documented. \nMistake on my part.\nMight be nice to document save being used in this way since it seems like the most \"Bookshelf\" way to do an update. \n. Gotcha ok so it was actually an insert that was returning an array and that looks documented. \nMistake on my part.\nMight be nice to document save being used in this way since it seems like the most \"Bookshelf\" way to do an update. \n. @jamesdixon if you don't mean the tableName what do you mean by the model's name? Do you mean the name in bookshelf-registry?\n. @rhys-vdw yeah that looks much cleaner - I just tried adding this to my baseModel but it doens't look like it's modifying the query\n``` js\ninitialize: function () {\n    bookshelf.Model.prototype.initialize.call(this)\n    this.on('fetching', function (model, column, options) {\n      if (this.softDelete === true && options.withDeleted !== true) {\n        return this.query.whereNull('deleted_at') // this code is being run\n      } else {\n        return\n      }\n    })\n  }\n```\nBut it doesn't seem to be updating the query\njs\nUser.forge({ id: 1000 }).fetch()\n/* =>  \n{  method: 'select',\n    options: {},\n    bindings: [ 1000, 1 ],\n    sql: 'select \"users\".* from \"users\" where \"users\".\"id\" = ? limit ?' }\n*/\nWhich is odd bc this obviously works\njs\nUser.forge({ id: 1000 }).query.whereNull('deleted_at').fetch()\n. Yeah that makes sense - this.query doesn't work because this references the model prototype?\n. I also added this to the fetching:collection event so it works for fetchAll as well and noticed it runs two selects even though it looks like the skipDeleted function is only called once per call\njs\n{ \n  method: 'select',\n  options: {},\n  bindings: [],\n  sql: 'select * from \"users\" where \"deleted_at\" is null' \n}\n{ \n  method: 'select',\n  options: {},\n  bindings: [],\n  sql: 'select \"users\".* from \"users\" where \"deleted_at\" is null' \n}\n. @rhys-vdw will do - one more question: I was getting an ambiguous reference error in some queries so I made the query more specific \njs\nreturn options.query.whereNull(_.result(this, 'tableName') + '.' + 'deleted_at')\nbut I get the wrong query when using withRelated\njs\n{ method: 'select',\noptions: {},\nbindings: [],\nsql: 'select * from \"users\" where \"addresses\".\"deleted_at\" is null' }\ninstead of \njs\n{ method: 'select',\n  options: {},\n  bindings: [ 1000 ],\n  sql: 'select \"users\".*, \"users_addresses\".\"id\" as \"_pivot_id\", \"users_addresses\".\"address_id\" as \"_pivot_address_id\", \"users_addresses\".\"user_id\" as \"_pivot_user_id\" from \"users\" inner join \"users_addresses\" on \"users_addresses\".\"user_id\" = \"users\".\"id\" where \"users_addresses\".\"address_id\" in (?)' }\n. Looks like it's only when using through and think the issue is here\nIt appears the query is being added to the through select constraint \n\n. Changing it to model doesn't change the query, unfortunately - I would expect it to add the query to the through relation, assuming it's extending from a softDelete model\nAssuming this relation on a Home model:\njs\nusers: function () {\n   return this.belongsToMany('User').through('UsersHomes')\n})\nRunning the following query:\njs\nHome.forge({ id: 1 }).fetch({ withRelated: 'users' })\nI'd expect it to add a 'where \"users_homes\".\"deleted_at\" is null' and a 'where \"users\".\"deleted_at\" is null' since all the models involved have the skipDeleted event\nAnd if it's not possible to do that because of how through works, that's fine, but I'd expect it to at least add 'where \"users\".\"deleted_at\" is null' so I get the same functionality as defining the relations like this:\njs\n  // this works as expected\n  users: function () {\n    return this.belongsToMany('User')\n    .query('whereNull', 'users.deleted_at')\n    .through('UsersHome')\n  }\nBut that doesn't happen because only the through model's fetching event is triggered (UsersHome). If anything, I'd think only the User model's fetching event would be triggered since the through relationship is just a join but it's actually \"fetching\" Users\n. @rhys-vdw just checking-in again on this issue. Does my explanation of the issue in my last comment make sense?\n. @rhys-vdw started looking into this again and found it was prematurely running because of the return statement. I removed it and it's almost at where I'd like it to be\n``` js\n    initialize: function () {\n      modelPrototype.initialize.call(this)\n  this.on('fetching', skipDeleted)\n  this.on('fetching:collection', skipDeleted)\n\n  function skipDeleted (model, column, options) {\n    if (this.softDelete === true && options.withDeleted !== true) {\n      options.query.whereNull(result(model, 'tableName') + '.' + 'deleted_at')\n    }\n  }\n},\n\n```\nThe issue I'm having is with joins.\nGiven this relation: \njs\n  addresses: function () {\n    return this.belongsToMany('Address').through('UsersAddress')\n  },\nThe query User.forge({ id: 1 }).fetch({ withRelated: 'addresses' }) produces the following query\njs\n{ \n  method: 'select',\n  options: {},\n  bindings: [ 1000, 1001, 1002, 1003, 1004 ],\n  sql: 'select \"addresses\".*, \"users_addresses\".\"id\" as \"_pivot_id\", \"users_addresses\".\"user_id\" as \"_pivot_user_id\", \"users_addresses\".\"estate_id\" as \"_pivot_estate_id\" from \"addresses\" inner join \"users_addresses\" on \"users_addresses\".\"estate_id\" = \"addresses\".\"id\" where \"users_addresses\".\"deleted_at\" is null and \"users_addresses\".\"user_id\" in (?, ?, ?, ?, ?)' \n}\nAs you can see it added where \"users_addresses\".\"deleted_at\" properly to the join but did not filter the target Address model with a where \"addresses\".\"deleted_at\"\nDo you have any suggestions on how to fix that?\n. Ah ok. Wanted to add the table name so that which model received an empty response was clear in an API\n. Ok thanks!\n. @ricardograca what more information would you like? It might be an issue resulting from some bookshelf dep\n. Great, I'll add it\n. ",
    "nporteschaikin": "Thanks, @bendrucker.  I'll write up some tests before the end of the week.\n. @bendrucker You mentioned this in #573.  Sounds great!  I'm working extensively with Bookshelf on an API I'm writing and putting these together as I go along.  :)\n. @bendrucker You mentioned this in #573.  Sounds great!  I'm working extensively with Bookshelf on an API I'm writing and putting these together as I go along.  :)\n. @oscar-g The plugin has worked well for me! \n. @oscar-g The plugin has worked well for me! \n. ",
    "rpnzl": "+1 - I've been looking around the open issues but haven't seen much movement on this topic, are there plans to address this in an upcoming release?\n. Got it, thank you for the update!\n. I went ahead and rebased/squashed, let me know if you need anything else!\n. ",
    "ihinsdale": "@rpnzl, thanks for taking on the PR. @bendrucker, what are the next steps for reviewing this and hopefully merging it before the next release?\n. Awesome! Thanks @rpnzl and @bendrucker!\n. @rhys-vdw @refactorized \nOne approach to populating created_at and updated_at timestamps with values generated by the database rather than by the application would be a plugin like this, which monkey-patches Model.prototype.timestamp:\n```\nvar knex = require('knex')({ ... });\nvar bookshelf = require('bookshelf')(knex);\nvar _ = require('lodash');\nvar dbTimestamps = function(Bookshelf) {\n  var Model = Bookshelf.Model.prototype;\nBookshelf.Model = Bookshelf.Model.extend({\n    timestamp: function (options) {\n      if (!this.hasTimestamps) return {};\n  var applicationTimestampAttributes = Model.timestamp.apply(this, arguments);\n  var dbTimestampAttributes = _.mapValues(applicationTimestampAttributes, function(val, key) {\n    return 'now()';\n  });\n\n  this.set(dbTimestampAttributes, options);\n\n  return dbTimestampAttributes;\n}\n\n});\n};\nbookshelf.plugin(dbTimestamps);\n```\nThis makes Bookshelf defer to the database in setting the timestamp value, which I've specified with the now() datetime function which in Postgres returns the date and time at the start of the current transaction.\nThis way avoids the overhead of having to create an update trigger for every table that you want to have the timestamps.\n@rhys-vdw\nI think it'd be pretty straightforward to support this behavior via e.g. a useDbTimestamps option: \nmodel.save(null, { useDbTimestamps: true ))\nIf this feature is welcome and you think it'd be helpful, I can create a PR.\nEDIT: It'd probably make more sense to put the option on the model definition rather than pass it to every invocation of .save().\nEDIT2: This approach encounters issues discussed in #1321 and #507 of how to refresh the model with the values for created_at and updated_at that are saved in the database. The plugin approach implemented above currently causes the values for created_at and updated_at on the model after saving to equal 'now()'. \n. @rhys-vdw @refactorized \nOne approach to populating created_at and updated_at timestamps with values generated by the database rather than by the application would be a plugin like this, which monkey-patches Model.prototype.timestamp:\n```\nvar knex = require('knex')({ ... });\nvar bookshelf = require('bookshelf')(knex);\nvar _ = require('lodash');\nvar dbTimestamps = function(Bookshelf) {\n  var Model = Bookshelf.Model.prototype;\nBookshelf.Model = Bookshelf.Model.extend({\n    timestamp: function (options) {\n      if (!this.hasTimestamps) return {};\n  var applicationTimestampAttributes = Model.timestamp.apply(this, arguments);\n  var dbTimestampAttributes = _.mapValues(applicationTimestampAttributes, function(val, key) {\n    return 'now()';\n  });\n\n  this.set(dbTimestampAttributes, options);\n\n  return dbTimestampAttributes;\n}\n\n});\n};\nbookshelf.plugin(dbTimestamps);\n```\nThis makes Bookshelf defer to the database in setting the timestamp value, which I've specified with the now() datetime function which in Postgres returns the date and time at the start of the current transaction.\nThis way avoids the overhead of having to create an update trigger for every table that you want to have the timestamps.\n@rhys-vdw\nI think it'd be pretty straightforward to support this behavior via e.g. a useDbTimestamps option: \nmodel.save(null, { useDbTimestamps: true ))\nIf this feature is welcome and you think it'd be helpful, I can create a PR.\nEDIT: It'd probably make more sense to put the option on the model definition rather than pass it to every invocation of .save().\nEDIT2: This approach encounters issues discussed in #1321 and #507 of how to refresh the model with the values for created_at and updated_at that are saved in the database. The plugin approach implemented above currently causes the values for created_at and updated_at on the model after saving to equal 'now()'. \n. +1\n. Great! Thanks for the fast reply. Isn't what's currently on http://bookshelfjs.org for v0.9.1? In any case, I've got what I need!\n. ",
    "ahmed232323": "there is two queries being run:\n'select \"contacts\".* from \"contacts\" where \"contacts\".\"contact_id\" = ? limit ?'\nand\n'update \"contacts\" set \"contact_name\" = ? where \"contactId\" = ?'\nthe primary key is not being parsed on the second  query it should be \"contact_id\", not \"contactId\"\nthis is the complete output while turn the debug on\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ 1, 1 ],\n  sql: 'select \"contacts\".* from \"contacts\" where \"contacts\".\"contact_id\" = ? limit ?' }\n{ __cid: '__cid1',\n  method: 'update',\n  options: undefined,\n  bindings: [ 'Contact AAA', 1 ],\n  sql: 'update \"contacts\" set \"contact_name\" = ? where \"contactId\" = ?' }\nPossibly unhanded Error: No rows were affected in the update, did you mean to pass the {method: \"insert\"} option?\n    at null.<anonymous> (C:\\Users\\ahmed\\Documents\\projects\\webapp\\tests\\bs_test\\node_modules\\bookshelf\\lib\\model.js:223:17)\n    at tryCatch1 (C:\\Users\\ahmed\\Documents\\projects\\webapp\\tests\\bs_test\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\util.js:29:21)\n    at Promise._settlePromiseFromHandler (C:\\Users\\ahmed\\Documents\\projects\\webapp\\tests\\bs_test\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\promise.js:588:13)\n    at Promise._settlePromiseAt (C:\\Users\\ahmed\\Documents\\projects\\webapp\\tests\\bs_test\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\promise.js:756:18)\n    at Async._drainQueue (C:\\Users\\ahmed\\Documents\\projects\\webapp\\tests\\bs_test\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\async.js:83:12)\n    at Async._drainQueues (C:\\Users\\ahmed\\Documents\\projects\\webapp\\tests\\bs_test\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\async.js:88:10)\n    at Async.drainQueues (C:\\Users\\ahmed\\Documents\\projects\\webapp\\tests\\bs_test\\node_modules\\bookshelf\\node_modules\\bluebird\\js\\main\\async.js:13:14)\n    at process._tickCallback (node.js:442:13)\nthanks you for quick reply :-) \n. yep\nOn Mon, Jan 19, 2015 at 11:52 PM, Ben Drucker notifications@github.com\nwrote:\n\nOk, so the issue is that idAttribute isn't being formatted in the latter\ncase.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/583#issuecomment-70558470.\n. \n",
    "pignatenko": "This is my work around.\nI set idModel to the database column name in snake case.\nThen on construction I force attributes to contain both snake case and camel case versions of it, and force parsing. I also set the id properly.\n```\n    idAttribute: 'table_id',\nconstructor: function(attributes, options) {\n  if (attributes && attributes.tableId) {\n    /* eslint-disable camelcase */\n    attributes.table_id =\n      attributes.tableId;\n    this.id = attributes.table_id;\n  }\n\n  if (options && options.parse === false) {\n    bookshelf.Model.call(this, attributes, options);\n  } else {\n    var finalOptions = options ? options : {};\n    finalOptions.parse = true;\n    bookshelf.Model.call(this, attributes, finalOptions);\n  }\n\n},\n```\n. ",
    "michaelbearne": "Still working on hasOne and belongsToMany\n. ",
    "Ygilany": "is this to be merged soon?\n. ",
    "ashwanikumar04": "Is this issue fixed or any work around for this? I am also facing the same issue.\n. ",
    "callemac88": "how can i make for updated_at be auto as well??? thank you\n. Whend i do in it i get this error: \n{ [Error: create table if not exists users (id int unsigned not null auto_increment primary key, name varchar(255), email varchar(255), password varchar(255), rol enum('Admin', 'superUser', 'User'), birthdate date, movil varchar(255), code varchar(255), state enum('active', 'inactive'), created_at timestamp not null default now(), updated_at timestamp not null default now()) - ER_TOO_MUCH_AUTO_TIMESTAMP_COLS: Incorrect table definition; there can be only one TIMESTAMP column with CURRENT_TIMESTAMP in DEFAULT or ON UPDATE clause]\n  code: 'ER_TOO_MUCH_AUTO_TIMESTAMP_COLS',\n  errno: 1293,\n  sqlState: 'HY000',\n  index: 0 }\nHere is the code i am using:\nknex.schema.createTableIfNotExists('users', function (table) {\n  table.increments('id').primary()\n  table.string('name')\n  table.string('email')\n  table.string('password')\n  table.enu('rol', ['Admin', 'superUser', 'User'])\n  table.date('birthdate')\n  table.string('movil')\n  table.string('code')\n  table.enu('state', ['active', 'inactive'])\n  // table.timestamps()\n  table.timestamp('created_at').notNullable().defaultTo(knex.raw('now()'))\n  table.timestamp('updated_at').notNullable().defaultTo(knex.raw('now()'))\n})\n  .catch(function (err) {\n    console.error(err)\n  })\nthank you\n. Thank you ricardograca, I update to MYSQL 5.6 and now is working BUT does not work ATTRIBUTE    on update CURRENT_TIMESTAMP \nHow can i add this to the create table?\nThanks\n. I did it, for a automatic update you must do:\ntable.timestamp('updated_at').defaultTo(knex.raw('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP'))\n. ",
    "JimOKelly": "Why isn't that the default? :)\nGlad I finally found this\n. whoa, this name calling is uncalled for completely. its also to do with knex not bookshelf!\nSent from my iPhone\n\nOn Jun 21, 2016, at 6:58 PM, Rhys van der Waerden notifications@github.com wrote:\n@refactorized there is no function called timestamps in the Bookshelf API.\nAnd the fact that using Bookshelf mitigates this is not a valid reason. Things are feeling way to tightly coupled here.\nBookshelf doesn't mitigate anything. It allows insertion of timestamps if you don't have triggers. That is all. You can create your columns however you like.\nAutomatic time-stamps should happen, and be specified, on the database level.\nSome databases don't support having multiple columns with timestamps. Some users don't want to trigger timestamp updates on every update/insert, and would prefer to omit them on certain changes. There is not necessarily a portable solution here.\nThis is fucking dumb.\nYou know what's dumb? The fact you're complaining about a feature that you don't even want to use, on the issue tracker of a different project.\nThis is what you need to do:\nRefrain from insulting the free software that people have made for you to use\nGo to the correct issue tracker (knex's in this case)\nSearch for an issue dealing with the problem (or create one if it doesn't exist)\nSubmit a pull request fixing the problem.\nGo away forever.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "refactorized": "This is frustrating Automatic time-stamps should happen, and be specified, on the database level.  If you have some (abhorrently documented) shortcut, namely timestamps(),  then why wouldn't it set this up by default?\nAnd the fact that using Bookshelf mitigates this is not a valid reason.  Things are feeling way to tightly coupled here. \n. @rhys-vdw \nA. Sorry.\nB. No Really, Sorry.\nC. I have amended my comment to be a tad less inflammatory. \nD. But why we are talking about things, bookshelf and knex work together, and are made the same people, and knex is practically necessary for using bookshelf. so I don't think this grievance is especially misplaced.\nThe problem here is that the docs are exceedingly unclear in not only what is, but what should be.  I would make a effort to fix something, if I actually understood what would count as fixed here. So maybe help me out understanding this.\nWe are talking about a default, convenience function - I would imagine the entire point of that default would be to provide the simplest and most useful configuration.  I am not claiming auto-incrementing should be automatic, and without specification when declaring types - but the incerments() function serves no other purpose by to make things easier, so it's kind of confusing agreed?\nFurthermore, if behavior varies based on underlying implementations, then the default is broke, or the function should not even exist.  At very least there should be examples and caveats.  The best documentation right now for this library is on other peoples blogs, which will not evolve with the changes in your library.\nIt gets really frustrating to get information on these issues from blogs and inexplicably closed issues like this.  Maybe I don't get github issue culture - but I have seen several closed issues for problems that were not solved and this is for possibly the most used SQL library for node.  \nSo who do I talk to? I want to help - I certainly don't want to bitch about something when I am perfectly capable of fixing it, but I also don't want to create duplicate issues to the ones that are already closed without real resolution.\nE. Seriously, I am sorry, I don't usually fly off the handle online, I generally try to keep things very classy, and fit for real, constructive discourse. - this felt like something no one cared about, your immediate response has demonstrated otherwise.  Thank you for your input. \n. Alright, cool - I will take this to the knex issues, and see what I can do.  Thanks.\n. ",
    "sheam": "What is the status of this? hasTimestamps: true, stopped working when we upgraded from 8.2 to 10.2. We are on Postgres.. Perfect. Thanks.\nThe code I inherited was overriding the timestamp function. When I upgrade Bookshelf from 8 to latest, this behaviour became broken. Add the line you suggested fixed the issue.. ",
    "AndrewKiri": "Neither table.timestamps().defaultTo(knex.raw('now()')); nor table.timestamps().defaultTo(new Date()); works for my setup, which is node 8.9.1, mysql server 5.7.2, mysql npm package 2.15.0 and knex 0.14.2.\nIt returns Cannot read property 'defaultTo' of undefined \nThe actual thing that made it working is: table.timestamps(true, true) which sets both useTimestamps and defaultToNow true.. ",
    "Surreal9": "Does this still work? I just tried it but it fails with a RangeError: Maximum call stack size exceeded after it appears to loop on recursively calling .toJSON \n. I guess by changing it from calling Bookshelf.Model.prototype.toJSON to Bookshelf.Model.prototype.serialize instead it appears to work..\n. Oh there it is, thank you very much!\n. Thanks so much for the timely response! Why would someone use .tap over .then with bookshelf?\n. You're not the hero I deserve, but the hero I need :) Thanks again!\n. ",
    "oscar-g": "Is there a chance we'll see this pull merged?\n@nporteschaikin, has this plugin worked well for you?\n. Is there a chance we'll see this pull merged?\n@nporteschaikin, has this plugin worked well for you?\n. Personally, I think a cast plugin out-of-the-box would make bookshelf more attractive and complete as an orm.  However, it looks like the planned features will change some fundamental code in bookshelf...so maybe they'll want to focus on that before adding more stock plugins.\n. ",
    "jadengore": "@ricardograca Should we consider merging this anyway? I know there has been talk since January of moving plugins into their own npm modules, but it still has not been done. We might as well merge until we update to the proposed newer API.\nEdit: Same goes for #573 and #386.\n. :+1: LGTM. Any thoughts @rhys-vdw? Tests maybe?\n. @javascrewpt How did you solve the Unhandled rejection Error: Transaction query already complete, run with DEBUG=knex:tx for more info?\n. @ricardograca I'm concerned about leaving it as undefined because it is technically not. When the fetch returns nothing, that means we know nothing is there. A null value explicitly represents that.\nI vote the behavior changes to null so that users know there is nothing in the database that represents their Bookshelf model.\n. @ricardograca My question is why I'm getting null now on v0.8.1 instead of undefined. If developers have already had to work around this for a while, wouldn't it be good to see some feedback first and see if people besides me are getting null?\n. I'm not sure, actually. I've really only used v0.8.1 of Bookshelf on a project.\n. @rhys-vdw I'll submit a PR for this sometime today.\n. @rhys-vdw You're welcome! Love to help out!\n. Thanks a bunch @rhys-vdw! Love being able to contribute to a project I use!\n. Thanks a bunch @rhys-vdw! Love being able to contribute to a project I use!\n. @cspotcode Thank you for logging this issue! Would you like to PR?\nIf not I can open one tonight!\n. @rhys-vdw Updated! Let me know if things look good!\n. :+1: \n. @madarche Thanks for logging this!\n. @ezra-quemuel I have used Bookshelf with STI on a project. I've never run into a case where I don't know the type of model I am working with however. What I would do is something like User.extend({}) for a Student and Employee, and then extend their prototypes with helper methods that add their respective type column to queries on fetching.\nI think @ricardograca is on the right track here. To do this I use event emitters as well, so I would say that event emitters are definitely the way to go in your case.\n. @rhys-vdw Think we should move forward on this documentation/API change, I just ran into this issue myself.\nIt makes a lot of sense to default require to true, in most cases people will have expectations on the model existing in the database when calling destroy.. @rhys-vdw Think we should move forward on this documentation/API change, I just ran into this issue myself.\nIt makes a lot of sense to default require to true, in most cases people will have expectations on the model existing in the database when calling destroy.. @standyro Now that we have updated Knex to 0.9.0, if you update your version of Bookshelf to the latest release tag you should have the proper version of Knex with this functionality.\nClosing this since it has been addressed.\n. @ricardograca A quick update, it looks like most of the description for the PR applies to this branch: https://github.com/VideoAmp/bookshelf/commits/feature/add_comments.\n@standyro Feel free to PR this and we can discuss more!\n. You can eager load relations using Model.load or the withRelated option on Model.fetch, example with latter below:\n``` js\nvar model = test\n  .forge({ id: 1 })\n  .fetch({ withRelated: ['test2'] });\nmodel.related('test2'); // returns result from eager loading of test2\n```\nDoes that make sense? If you eager load your relations then you do not have to load them later with a call to load.\n. I agree with @jamesdixon, especially if the project you are working on is at scale.\nI will close this issue for now, since I believe it has been addressed.\n. There are a couple ways you can improve this query. Consider:\nDefray\n  .forge({ purchaseId: purchaseId })\n  .fetch()\n  .then(function(model){\n    // do something\n  });\nTo walk through this, forge is a helper function that creates a new model without new, and it adds the purchaseId that you are getting (2 in your example). Calling fetch() will perform the SQL query from the data provided on the model, and will return the corresponding Defray.\nHope this helps! I'm going to close this for now.\n. @Cyberuben You could use Bookshelf's Model/Collection parse method to manipulate the response of UserMeta into what you want. However, I would not recommend this approach. \nKeep in mind that Bookshelf is treating your UserMeta model as a collection of UserMeta models, but you are trying to manipulate this collection into a model representation. I think a smarter approach than using parse and model.toJSON() would actually be a custom serializer.\nExample below:\nuser_serializer.js\n``` js\nvar getMetadata = function(usermetas) {\n  var meta = {};\n  usermetas.forEach(function (metaRow) {\n      meta[metaRow.meta_key] = metaRow.meta_value;\n  });\nreturn meta;\n};\nvar UserSerializer = function(user) {\n  var meta = user.related('UserMeta') ?\n    getMetadata(user.related('UserMeta')) :\n    null;\nreturn {\n    id: user.get('id'),\n    email: user.get('email'),\n    registration_date: user.get('registration_date'),\n    is_admin: user.get('is_admin'),\n    meta: meta\n  };\n}\nmodule.exports = UserSerializer;\n```\nAnd now, to replace the code above:\n``` js\nvar serialize = require('path/to/user_serializer');\ndb.bookshelf\n  .model(\"User\")\n  .forge({id: result})\n  .fetch({require: true, withRelated: [\"meta\"]})\n  .then(function (model) {\n      callback(serialize(model));\n  });\n```\nHope that helps!\n. @tkrotoff Good find! I can fix this up and mention your help. Thanks.\n. What database are you using? If it's something like Postgres, this is configured as part of Knex migrations. Documentation can be found here on Knex migrations.\n. @rmharrison The problem comes from how Knex is serializing your columns parameter. Query comes out like this:\nsql\nSELECT \"jsonbcol->'value'\" FROM device_data;\nThis is coming back as an error because in SQL, it is an expression that has to be evaluated rather than a column. The quotes are causing Postgres to interpret your expression as a column.\nI think you should just consider allowing Bookshelf to pull in all of your models, and then to map the data you need after the fact. It will simplify the query, and JS will be able to do this much faster in memory anyways. Maybe something like this:\njs\nDeviceData.forge().fetchAll().then((collection) => {\n  return collection.map((model) => {\n    return model.get('jsonbcol').value;\n  });\n});\nWith that in mind, if you only want to return that specific column, I recommend you drop down to using Knex directly. Example of that below:\njs\nknex.select(knex.raw(\"jsonbcol->\\'value\\'\"))\n    .from('device_data')\n    .then((rows) => {\n        return _.map(rows, '?column?'));\n    });\nLet me know if you have any more questions!\n. @pmettraux Great, please resolve merge conflicts then I will begin my review :smile: . @Playrom We can keep this in mind for maybe a 1.0 release, in the meantime we can update docs.. I'm not sure about linting rules of this project, but please follow format above (spaces between if and else). first*. same comment on style as above. Some recommended cleanup here would be to make virtualName reference a variable. Maybe this on line 207:\njs\nconst { [virtualName]: virtual } = virtuals;\nAnd then an example for the return value above:\njs\nreturn virtual.get ? virtual.get.call(model, params) : virtual.call(model, params);. space between function params. we can make this a const:\njs\nconst paramsForVirtualName = params ? params[virtualName] : null;. space after comma. Instead of making these 3 conditions all one test, make this three separate tests and nest the model example above inside of a context block.. A cleaner way to do this would be to use forge instead of new.\n```js\nvar m = bookshelf.Model\n  .extend({\n     virtuals: {\n       fullName: function(param) {\n           return this.get('firstName') + ' ' + param;\n       },\n   fullNameDouble: function(param1,param2) {\n       return this.get('firstName') + ' ' + param1 + ' ' + param2;\n   }\n }\n\n})\n  .forge({firstName: 'Joe', lastName: 'Shmoe'});\n```\nsame goes for below. retrieved is a bit better than getted (not a word). This object in the docs should be multi-lined. controll => control. space here between params. Maybe a little bit of spacing between these examples to make things easier to see. we should say lastName is the param here instead of just param. ",
    "vmharrel": "@awebdeveloper - How did you solve your issue of cross db joins?. ",
    "c990802": "Bookshelf can solve this for you. Give it a shot at relation types: http://bookshelfjs.org/#Model-relation-types\n. Bookshelf can solve this for you. Give it a shot at relation types: http://bookshelfjs.org/#Model-relation-types\n. From the documentation: \n\nA simple helper function to instantiate a new Model without needing new.\n\nSo new Model({name: \"blah\"}).fetch() is equivalent to Model.forge({name: \"blah\"}).fetch()\n. From the documentation: \n\nA simple helper function to instantiate a new Model without needing new.\n\nSo new Model({name: \"blah\"}).fetch() is equivalent to Model.forge({name: \"blah\"}).fetch()\n. +1\nIn 0.9.2 something's broken in the events system. In our case we have the event fetched being called when doing a fetchAll(). This is causing major breaks on code as we rely on an instance of model being returned.\nCode sample:\njavascript\n// Controller\nQuotation.forge().where({order_id: this.id, voided: false}).fetchAll();\n// Model\nthis.on('fetched', function(model, attrs, options){\n  var promises = [\n    model.extendWithValidateQuotationLink(),\n    model.extendWithQuotationTotal()\n  ];\n  return Promise.all(promises);\n});\nAs stated, in 0.9.2 the event fetched is being fired.\n. ",
    "julianonunes": "\nThat was over a year ago. Whats the situation now?\n\nI'd like to know that too. Should I still keep using only Model?. ",
    "kvslee": "Will, would you mind of sharing how you resolved this question?\n. Thanks Rhys for your response. Sorry that I could not understand your point. It may be my fault not to paraphrase my issue clearly. \nI have many locations_codes starting c and l. So, when I use the second query, I expect that the JSON should show only bib records where location_code starts with 'l' (excluding all other 'c' location_ codes).\n.query(function (qb) {\n            qb.where('location_code', 'LIKE', 'l%')\n            });\nI am curious that my query syntax is right. Can I call .query method two times to the returned model object? Without the second query, JSON correctly display biblocation property where location_code starts with c and l. However, with adding the second query, biblocation property shows an empty array (although it should show all location_codes that starts with l. \n. Thanks Rhys for your response. Sorry that I could not understand your point. It may be my fault not to paraphrase my issue clearly. \nI have many locations_codes starting c and l. So, when I use the second query, I expect that the JSON should show only bib records where location_code starts with 'l' (excluding all other 'c' location_ codes).\n.query(function (qb) {\n            qb.where('location_code', 'LIKE', 'l%')\n            });\nI am curious that my query syntax is right. Can I call .query method two times to the returned model object? Without the second query, JSON correctly display biblocation property where location_code starts with c and l. However, with adding the second query, biblocation property shows an empty array (although it should show all location_codes that starts with l. \n. Thanks Rhys again. I set up {debug: true} now on knex. Where can I monitor the sql output now? Output does show neither in Chrome console nor in command console. I believe that the sql output should be very helpful.\n. Thanks Rhys again. I set up {debug: true} now on knex. Where can I monitor the sql output now? Output does show neither in Chrome console nor in command console. I believe that the sql output should be very helpful.\n. Thanks Ben and Rhys. I find that debug was not properly set up on knex (it was my fault). Fixed that and now I can see the sql output properly. SQL itself looks fine to me. But I find the source of my problem.\nWhen I add the second query, it looks fine to me. \njs\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ 'l%', '420907917533', '420907917559', '420913573824' ],\n  sql: 'select \"bib_record_id\", \"location_code\" from \"location\" \n  where \"location_code\" LIKE $1 and \"location\".\"bib_record_id\" in ($2, $3, $4)' }\nOriginally, my intention was to find all records where \"location_code\" LIKE 'l%' first and then limit the number of listed records. But the second query on biblocation was being executed with the limit method at the same time.  \nMy select statement was like this:\njs\nexports.bib = function(req, res) {\n    Bib.forge()\n   .query({limit: 3})\n   .fetchAll({columns: ['id', 'record_num'], withRelated: ['biblocation']})\n   .then(function(bib) {\n        res.json(bib.toJSON());\n    })\n};\nHow can I accomplish my goal: listing all bib records where \"location_code\" LIKE 'l%' first and then limit?  \nThanks again for all helps.\n. Thanks Ben and Rhys. I find that debug was not properly set up on knex (it was my fault). Fixed that and now I can see the sql output properly. SQL itself looks fine to me. But I find the source of my problem.\nWhen I add the second query, it looks fine to me. \njs\n{ __cid: '__cid1',\n  method: 'select',\n  options: undefined,\n  bindings: [ 'l%', '420907917533', '420907917559', '420913573824' ],\n  sql: 'select \"bib_record_id\", \"location_code\" from \"location\" \n  where \"location_code\" LIKE $1 and \"location\".\"bib_record_id\" in ($2, $3, $4)' }\nOriginally, my intention was to find all records where \"location_code\" LIKE 'l%' first and then limit the number of listed records. But the second query on biblocation was being executed with the limit method at the same time.  \nMy select statement was like this:\njs\nexports.bib = function(req, res) {\n    Bib.forge()\n   .query({limit: 3})\n   .fetchAll({columns: ['id', 'record_num'], withRelated: ['biblocation']})\n   .then(function(bib) {\n        res.json(bib.toJSON());\n    })\n};\nHow can I accomplish my goal: listing all bib records where \"location_code\" LIKE 'l%' first and then limit?  \nThanks again for all helps.\n. Thanks Ben and Rhys. I will close this issue and reopen another one, because its title is no longer what I want to ask. I find that the second .query method works on the returned model object. I really appreciate your helps. Besides, thanks you teach me how to debug and how to use fence my code! \n. Thanks Ricardo. I tried it and got this result. It does not show any 'related' table (location)'s attributes. \njson\n[\n{\nid: \"420907917533\",\nrecord_num: 1122525\n},\n{\nid: \"420907917559\",\nrecord_num: 1122551\n},\n{\nid: \"420913573824\",\nrecord_num: 6778816\n}\n]\nIs your code intended to do the same to the following? This code can join two tables properly (bib and location).\njavascript\nexports.bib = function(req, res) {\n    Bib.forge()\n   .query({limit: 3})\n   .fetchAll({columns: ['id', 'record_num'], withRelated: ['biblocation']})\n   .then(function(bib) {\n        res.json(bib.toJSON());\n    })\n};\nMy problem is that I cannot filter bib records only by a location starting with 'l' (where location.location_code LIKE 'l%') while using query({limit: 3}) at the same time. I should run first the filter (only 'l' location) BEFORE the query({limit: 3}) is applied. \n. I defined the bib_record_id both as foreign key and as a column name in Bib Model's biblocation method. The association to biblocation seems fine. Below is what I got. \nBen, would you mind of elaborating a little more on how to omit that column during serialization? I used toJSON() before passing the returned model to the response callback. Is it not enough?   \nRecardo, thanks for pointing the issue #629. That would be helpful in the future. \njson\n[\n{\nid: \"420907917533\",\nrecord_num: 1122525,\n    biblocation: [\n    {\n    bib_record_id: \"420907917533\",\n    location_code: \"cllrf\"\n    }\n    ]\n},\n{\nid: \"420907917559\",\nrecord_num: 1122551,\n    biblocation: [\n    {\n    bib_record_id: \"420907917559\",\n    location_code: \"cllst\"\n    }\n    ]\n},\n{\nid: \"420913573824\",\nrecord_num: 6778816,\n    biblocation: [\n    {\n    bib_record_id: \"420913573824\",\n    location_code: \"cejou\"\n    }\n    ]\n}\n]\n. Thanks Ben. I got your point that it is safer to fetch (rather than overriding columns) and filter the returned json properties during toJSON serialization process.  Do you have any suggested sample for the serialization? I am also curious that toJSON may not copy the nested arrays and objects.\nI have lots of fun to learn Bookshelf. It is an awesome library. Thanks for introducing it to me.  \nI think that I find a solution to my question from the issue #340.  I could joined the tables (bib and location) before fetching Bib records. In this way, I could apply \"LIKE\" condition against location.location_code. This gives me the results that I wanted.  \njavascript\nexports.bib = function(req, res) {\n    Bib.forge()\n   .query({limit: 3})\n    .query(function (qb) {\n        qb.join('location', 'location.bib_record_id', '=', 'bib.id')\n    .where('location.location_code', 'LIKE', 'l%')\n     })\n   .fetchAll({withRelated: ['biblocation']})\n   .then(function(bib) {\n        res.json(bib.toJSON());\n    })\n};\n. ",
    "AdamPuzio": "Here is my Field model:\n```\n/*\n * Field Model\n /\n'use strict';\nvar db = require('../lib/database');\nvar DocDefField = require('./doc_def_field');\nvar DocumentEditionValue = require('./document_edition_value');\nvar FieldModel = db.Model.extend({\n    tableName: 'fields'\n, doc_def_field: function(){\n    return this.hasMany('DocDefField');\n}\n\n, document_edition_values: function(){\n    return this.hasMany('DocumentEditionValue');\n}\n\n}, {\n});\nmodule.exports = db.model('Field', FieldModel);\n```\nFor now, I'm using var ModelName = db.Model.extend(), followed by module.exports = db.model('ModelName', ModelName);\nI started changing that to module.exports = db.model('ModelName', {}), but it didn't seem to help (although I only did it for a few models, not all of them). \n. Hmm... I guess I confused myself when I read this:\nYou still have to require the model somewhere to make sure Bookshelf.model is called. Here we're requiring it at the top of each file to make sure it's loaded into the registry, but we don't actually need to assign it to a variable.\nDo I need to manually require() each of the models somewhere on run? I assumed everything in the models/ directory was automatically loaded. I removed require() for all of the associated models, but I'm still getting:\n[Error: The model DocumentEdition could not be resolved from the registry plugin.]\nI'm attempting to use the Document model from a controller like this:\n```\nvar DocumentModel = require('../../models/document');\n...\nrouter.get('/browse', function (req, res) {\n    var query = {};\n    DocumentModel.forge(query).fetch({\n        withRelated: [\n            'children'\n            , 'document_editions'\n            , 'active_edition'\n            , 'parent'\n            , 'children.parent'\n        ]\n    }).then(function(results){\n        var docs = [results.toJSON()];\n        res.render('zeta/pages/documents/browse', {documents: docs});\n    })\n    .catch(function(err){\n        console.log(err);\n        res.send('Error');\n    });\n});\n\n```\nIf I remove the \"withRelated\" associations for \"document_editions\" and \"active_edition\" (both of which are associated to the DocumentEdition model), it works fine. With either or both of those references, it fails.\n. ",
    "MatthewPhinney": "This appears to be the same issue as https://github.com/tgriesser/bookshelf/issues/583.\n. ",
    "kbjorklid": "I ran across this problem today. The way I solved it was to just fetch the model directly after save. Something to this effect:\njavascript\n    function createNew(data) {\n        return User.forge(data)\n            .save({}, {method : 'insert'})\n            .then(function (data) {\n                return findById(data['id']);\n            });\n    }\nThe findById does what you'd expect and returns a promise.\n. ",
    "silistri": "Hello\nWhere is this dependency going away ?!\nI would like to use backbone as dependency of another library but the release required by bookshelf conflicts with the expected one.\nIs it planned to upgrade bookshelf dependencies ?\nWill bookshelf dependencies maintained in the future ?\nThank you very much\n. Thank you for your reply...\nCurrently, my team would like to use bookshelf with nodejs-webkit in order to create an HTML5 desktop application.\nWe were interested by the relationship between backbone and bookshelf because it allowed us to link bookshelf results directly to backbone views.\nWe will turn to another solution.\nThank you very much for the clarification.\n. Thank you for your reply...\nCurrently, my team would like to use bookshelf with nodejs-webkit in order to create an HTML5 desktop application.\nWe were interested by the relationship between backbone and bookshelf because it allowed us to link bookshelf results directly to backbone views.\nWe will turn to another solution.\nThank you very much for the clarification.\n. ",
    "brian-mann": "Ah yes, very good.  I see that now and will move over there.\n. Ah yes, very good.  I see that now and will move over there.\n. ",
    "redhotvengeance": ":+1: That's what I thought. Many thanks.\n. :+1: That's what I thought. Many thanks.\n. ",
    "stantoncbradley": "good to know.  does Knex sanitize or only Bookshelf.  I think this should be documented in FAQ\nEDIT: pg package Knex uses does so yes, at least for postgres\n. ",
    "mdaparte": "thanks demisx , this worked for me\n. ",
    "jorgemejia": "Is it possible to use max() instead count() I want to do something like that but i only want the max value for a column. @absolux  thanks I found a solution\nnew model().query(\"where\", Bookshelf.knex.raw(\"DATE(colum_datetime)\"), \"=\", date_var). ",
    "gustavobap": "Well, I am trying to define an inheritance relationship between two models, in which the child model have access to the parent attributes. This is common behavior with OO languages, and this can be represented in the database using Single or Multiple Table Inheritance. \nYou mean I must define  a One to One relationship to represent inheritance ? To be more specific I want to define an User model with username and password, and a Customer model inheriting those attributes from User, so I could abstract the specific type of user at the login function for example.\n. Well, I am trying to define an inheritance relationship between two models, in which the child model have access to the parent attributes. This is common behavior with OO languages, and this can be represented in the database using Single or Multiple Table Inheritance. \nYou mean I must define  a One to One relationship to represent inheritance ? To be more specific I want to define an User model with username and password, and a Customer model inheriting those attributes from User, so I could abstract the specific type of user at the login function for example.\n. Hi, bendrucker, thankyou for your help. I would like to implement this model:\n\nThis means Operator and Customer shoud have access to the User's parent_attribute.\nI am trying to do something like this (I will omit the Permission model for sake of simplicity):\nmigrations:\nexports.up = function(knex, Promise){\n  knex.schema.createTable('usr', function(table){\n    table.increments 'id'\n    table.string 'parent_attr'\n  }).then(function(){ \n    knex.schema.createTable( 'operator', function(table){\n      table.integer('usr_id'\n        .unsigned()\n        .references 'id'\n        .inTable 'usr'\n        .notNullable());\n      table.integer('age');\n    });\n  }).then(function(){ \n    knex.schema.createTable( 'customer', function(table){\n      table.integer('usr_id'\n        .unsigned()\n        .references 'id'\n        .inTable 'usr'\n        .notNullable());\n      table.integer('phone');\n    });  \n  });\n}\nuser model:\n```\nknexConfig = require('../../knexfile');\nknex = require('knex')(knexConfig.development);\nBookshelf = require('bookshelf')(knex);\nPermission = require('./permission');\nvar User = Bookshelf.Model.extend({ \n  tableName: 'usr'\n  permissions: function() {\n    return this.hasMany(Permission);\n  }\n});\n```\noperator model:\n```\nvar User = require './user'\nvar Operator = User.extend({\n  tableName: 'operator'\n});\nmodule.exports = Operator;\n```\ncustomer model:\n```\nvar User = require './user'\nvar Customer = User.extend({\n  tableName: 'customer'\n});\nmodule.exports = Operator;\n```\nthen I should be able to do this\n```\nnew Operator(id: 1)\n  .save({age: 1, parent_attr: 'I am operator, specialized user'}, {patch: true});\nnew Customer(id: 2)\n  .save({phone: 55555, parent_attr: 'I am customer, specialized user'}, {patch: true});\n```\n. Hi, bendrucker, thankyou for your help. I would like to implement this model:\n\nThis means Operator and Customer shoud have access to the User's parent_attribute.\nI am trying to do something like this (I will omit the Permission model for sake of simplicity):\nmigrations:\nexports.up = function(knex, Promise){\n  knex.schema.createTable('usr', function(table){\n    table.increments 'id'\n    table.string 'parent_attr'\n  }).then(function(){ \n    knex.schema.createTable( 'operator', function(table){\n      table.integer('usr_id'\n        .unsigned()\n        .references 'id'\n        .inTable 'usr'\n        .notNullable());\n      table.integer('age');\n    });\n  }).then(function(){ \n    knex.schema.createTable( 'customer', function(table){\n      table.integer('usr_id'\n        .unsigned()\n        .references 'id'\n        .inTable 'usr'\n        .notNullable());\n      table.integer('phone');\n    });  \n  });\n}\nuser model:\n```\nknexConfig = require('../../knexfile');\nknex = require('knex')(knexConfig.development);\nBookshelf = require('bookshelf')(knex);\nPermission = require('./permission');\nvar User = Bookshelf.Model.extend({ \n  tableName: 'usr'\n  permissions: function() {\n    return this.hasMany(Permission);\n  }\n});\n```\noperator model:\n```\nvar User = require './user'\nvar Operator = User.extend({\n  tableName: 'operator'\n});\nmodule.exports = Operator;\n```\ncustomer model:\n```\nvar User = require './user'\nvar Customer = User.extend({\n  tableName: 'customer'\n});\nmodule.exports = Operator;\n```\nthen I should be able to do this\n```\nnew Operator(id: 1)\n  .save({age: 1, parent_attr: 'I am operator, specialized user'}, {patch: true});\nnew Customer(id: 2)\n  .save({phone: 55555, parent_attr: 'I am customer, specialized user'}, {patch: true});\n```\n. Maybe Bookshelf doesn't have an inheritance association yet (I guessed it was implicit in the extend function), but shouldn't the Operator and Customer models inherit the database attributes from User like they inherit it's relations  ?\nSo I could do\noperator.get('age');\noperator.get('parent_attribute');\nas I can do\noperator.related('permissions')\n. Maybe Bookshelf doesn't have an inheritance association yet (I guessed it was implicit in the extend function), but shouldn't the Operator and Customer models inherit the database attributes from User like they inherit it's relations  ?\nSo I could do\noperator.get('age');\noperator.get('parent_attribute');\nas I can do\noperator.related('permissions')\n. There is way to access the database attributes through the prototype chain like normal properties ?\nvar father = {a: 1};\nvar sun = {b: 2};\nObject.setPrototypeOf(sun, father);\nsun.a //1\n. There is way to access the database attributes through the prototype chain like normal properties ?\nvar father = {a: 1};\nvar sun = {b: 2};\nObject.setPrototypeOf(sun, father);\nsun.a //1\n. I see. You mean to user virutals plugin to add getters and setters for the parent's attributes in the children models ? I guess this will work, I just wanted to know if this is the recommended strategy.\nThanks a lot for your time and congratulations, this is a great project \n. I see. You mean to user virutals plugin to add getters and setters for the parent's attributes in the children models ? I guess this will work, I just wanted to know if this is the recommended strategy.\nThanks a lot for your time and congratulations, this is a great project \n. ",
    "oleole90": "Thanks in 2016! :baby_bottle: \n. Thanks in 2016! :baby_bottle: \n. It's exactly what I was looking for. Thanks.\n. It's exactly what I was looking for. Thanks.\n. ",
    "luggage66": "Oops. Duplicate of #486\n. Ohh, awesome. I didn't expect such a fast response. I was trying to fix it myself by poking around and came up with: https://github.com/tgriesser/knex/compare/master...luggage66:master\n. I use ES6 with something like: \n```\nexport class ProductionSheet extends bookshelf.Model\n{\n    get tableName() { return 'ProductionSheet'; }\nget defaults() {\n    return {\n        property1: 'blah',\n        property1: null\n    }\n}\n\n// START Relations\ntimesheet() { return this.belongsTo('Timesheet', 'timesheet'); }\ntaskType() { return this.belongsTo('TaskType', 'taskType'); }\nworksheets() { return this.hasMany('AuditWorksheet', 'productionSheet'); }\n// END Relations\n\n}\n``\n. There are still problems with ES6, especially collections. There are some static functions used that don't get 'inherited'. Models work, though, for the most part.\n. No, the (ES6)extendsonly does the instance properties (the prototype). None of the statics. Coffeescripts'sextends**does** copy both the properties on the prototype and the constructor just like the supplied.extend()`.\nI don't remember what was broken on the collections but for models, the fetch option { require: true } fails due to the errors it uses being static properties on the model: https://github.com/tgriesser/bookshelf/blob/master/src/model.js#L1219\n. UPDATE: The below code is not actually doing what I think. Some coffeescript classes in the chain screwed it up, not ES6 classes which seem to get .forge(), .collection(), etc.\nHere is some hackery I am testing out that just copies bookshelf 0.8.2 static properties to the inherited class: https://gist.github.com/luggage66/8920135a556fc33b06ac (it's an es6 decorator, but you can just call it as a function).\nIt at least copies collection, forge, fetchAll, etc.\n. Yea, I had some coffeescript classes in the mix (don't ask) that cause things to break from 0.8.1 -> 0.8.2 and I misinterpreted the evidence.\nI finished converting them all to es6 and now I can use 0.8.2 (except for the known Error problem, of course).\nYea, I'll take a look at the fixing the Error types. I think, with static getters, I can generate (and cache) error types on demand so that we can:\n.catch(User.NotFoundError, (error) => ....)\nor, if you want to catch all NotFoundErrors for any model:\n.catch(bookshelf.NotFoundError, error => ...)\nwithout the special extended() function that creates those types now when model.extent({ instance, static}) is called. That would prevent browser use in IE < 9, if that matters to you.\n. ",
    "orangejinjo": "@bendrucker Thanks for the quick response. How do you recommend I go about retrieving all of the related data for the collection? Unfortunately I can't find this is in the documentation if a way to do this is already available. (I replaced Post.collection().fetch() with Post.fetchAll() but these appear to do the same thing.)\nIs there a method on the fetched collection to retrieve just the category models, or will I need to iterate though the collection manually and push each unique post.category into a \"categories\" array?\n. ",
    "cuteboi": "Sorry for this reopen, but wanted to give a workaround for emberdata side loading of IDs.\nSo far, I've been doing this:\nresponse.site = JSON.parse(JSON.stringify(site));\n        response.site.devices = site.related('devices').pluck(\"id\");\n@jas , you could just do your conversion to returned object, and modify the output before it goes to a response.\nThis is my complete code sample using bookshelf-model-loader:\n```\n    yield new ResourceModel({id: this.params.id}).fetch(\n      {\n        withRelated: 'devices'\n      }).then(function (site) {\n        \"use strict\";\n        console.log()\n        response.site = JSON.parse(JSON.stringify(site));\n        response.site.devices = site.related('devices').pluck(\"id\");\n      });\nthis.body = response\n\n```\n. Why, yes it is what I was looking for.  It didn't dawn on me such a thing\nexisted.  Thanks for pointing this out.  Now to close this.\nRegards,\nAnthony Hernandez\nOn Tue, Apr 7, 2015 at 10:12 AM, Ricardo Gra\u00e7a notifications@github.com\nwrote:\n\nYou are probably looking for this instead:\nhttp://bookshelfjs.org/#Model-format\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/687#issuecomment-90603317.\n. Thanks for the update, I'll test a modification from that location you stated, and provide a PR for point number 2.\n\nThanks for pointing in the right direction. I hate digging through source I didn't code for something documentation says otherwise.  Why search if it may be obscure, but in this case it wasn't so obscure.\n. Nope, I saw how it works for bookshelf. I just wanted to get a source of where the \"standard\" came from.  And I'll make sure to look through the labels first next time.\n. ",
    "lulzimfazlija": "No, it doesnt work :s, would have been awesome if I could just add .where('is_publish',1); straightly from model\n. No, it doesnt work :s, would have been awesome if I could just add .where('is_publish',1); straightly from model\n. when I add .where('is_publish',1) it shows me a msg like \"tracks is not defined on the model.\"\n. when I add .where('is_publish',1) it shows me a msg like \"tracks is not defined on the model.\"\n. How did u intend to handle such cases? \n. How did u intend to handle such cases? \n. @bendrucker how do you mean, where in the code the condition \"where\" should be added?\n. @bendrucker how do you mean, where in the code the condition \"where\" should be added?\n. @bendrucker \nerror: Cannot call method 'through' of undefined\" after I replaced this.hasMany('track').through('album').where('is_publish',1) with this.hasMany('track').where('is_publish',1).through('album') in channel model\nis_publish is in album table\n. @bendrucker \nerror: Cannot call method 'through' of undefined\" after I replaced this.hasMany('track').through('album').where('is_publish',1) with this.hasMany('track').where('is_publish',1).through('album') in channel model\nis_publish is in album table\n. well guys, this did the job return this.hasMany('track').through('album').query('where', 'is_publish', '=', 1); it works now.... Thank you\n. well guys, this did the job return this.hasMany('track').through('album').query('where', 'is_publish', '=', 1); it works now.... Thank you\n. ",
    "stoxx": "This still happens with bookshelf 0.10.4. If type is null, errors during load, if set to valid or nonsense but id is null, load succeeds. I don't really know how to check if similar issue is exactly the same root cause, without actually going and fixing the root cause... I believe this to be separate issue, specific to polymorphic relation. If target key is null or something unmapped (no such tablename), the error message is\nerror: Error: The target polymorphic model was not found\n. I expected result like a regular nullable relation, mapped target remains undefined. This is the behavior i get when i set target_type to one of my poly-mapped entities, but leave the id null. So i have a workaround.\nSorry i don't really have a distributable test case at arm's reach.. ",
    "obcan": "PostgreSql, Knex@0.7.3, Bookshelf@0.7.9\n. Ha, it was my stupid mistake. Many thanks for your help. So I have a solution.\njavascript\nqb.select('*').from(function() {\n    this.select(knex.raw('*, 3 as custom_column')).from('model').as('model');\n}).where('custom_column', '=', 3);\n. ",
    "gfarrell": "AFAICT relation.withPivot is for selecting not inserting, and I'm talking about the latter. There should be a way to attach, specifying values on the pivot table, without hitting the database with two queries.\n. I was curious as to why it was being done in this slightly roundabout manner. The new keyword isn't exactly new.\n. Might look into it but am not using ES6 classes in my own code so it could be a while.\nOn Mon, Oct 5, 2015 at 12:52 AM, Rhys van der Waerden\nnotifications@github.com wrote:\n\n@gfarrell No idea, not my code. Would you be willing to provide a PR to fix this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/issues/924#issuecomment-145403315\n. Might look into it but am not using ES6 classes in my own code so it could be a while.\n\nOn Mon, Oct 5, 2015 at 12:52 AM, Rhys van der Waerden\nnotifications@github.com wrote:\n\n@gfarrell No idea, not my code. Would you be willing to provide a PR to fix this?\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/issues/924#issuecomment-145403315\n. \n",
    "claym": "Why is this closed? This is definitely a bug / issue - I'm running into it now, is there a proposed solution?\nUnfortunate, \"change the database\" isn't an option for me.\n. It also impacts update statements, and I don't believe there's a way to override that.\u00a0\n-Clay\nOn Sun, Mar 22, 2015 at 12:47 PM, Ricardo Gra\u00e7a notifications@github.com\nwrote:\n\nThe thing is that .where is a shortcut to .query('where', ...), which itself is a shortcut to the underlying knex instance's query builder. Knex is lower level than Bookshelf and doesn't know anything about it, which means that knex doesn't know anything about Bookshelf models, and since the .parse() method is a Bookshelf method that only affects Bookshelf models, it doesn't come into play when calling .where().\nRight now the only \"solution\" is that you have to remember that by calling .where() you're accessing lower-level methods, so model logic doesn't apply. If you're using .parse() to transform the names of database columns you'll have to use the original untransformed names when using .where(), just like you have to when using .query().\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/issues/650#issuecomment-84652335\n. Correct. If i set my idAttribute to \"categoryId\", I get this:\n\n```\nchart.set('categoryId', id);\nsql: 'update \"category_chart\" set ... where \"categoryId\" = $8',\nUnhandled rejection error: column \"categoryId\" does not exist\n```\nhowever if I set idAttribute to \"category_id\" it doesn't recognize that categoryId is the same as the idAttribute and it errors with\nUnhandled rejection Error: A model cannot be updated without a \"where\" clause or an idAttribute.\n. ```\nvar CategoryChart = BaseObject.extend({\n    tableName: \"category_chart\",\n    idAttribute: \"category_id\"\n    // idAttribute: \"categoryId\"\n});\nvar chart = new CategoryChart();\n// this doesn't work either\n// var chart = CategoryChart.forge({categoryId:id});          \nchart.set('categoryId', id);\nreturn chart.save({}, {method:'update'});\n```\n. This pretty much breaks any sort of updates if you mix camelcase and snake,\nwhich is going to happen pretty much any time you work with legacy systems.\nThis should be pretty high priority on the fix list.\nOn Sun, Mar 22, 2015 at 3:57 PM, Ricardo Gra\u00e7a notifications@github.com\nwrote:\n\nYeah, that's issue #642\nhttps://github.com/tgriesser/bookshelf/issues/642. Unfortunately I\ncan't help you in this case since I never encountered that problem, but\nother users might be able to offer some assistance.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/650#issuecomment-84688697.\n. And #642 is closed too. Not sure I understand how they handle issues here :)\n. Thank you! I was sitting here staring at my project trying to figure if I needed to rip out bookshelf or try to change my database.\n. has there been any progress on this? anything i can do to help test?\n. So, best just not to use classes? That's disappointing.\u00a0\n\n-Clay\nOn Wed, May 27, 2015 at 8:36 AM, Ben Drucker notifications@github.com\nwrote:\n\nBookshelf expects tableName to be on the prototype and it's possible idAttribute is the same. There is no way to add prototype properties with the class syntax, including under the current ES7 class properties. Bookshelf models don't really play nicely with class. You have to manually add everything to the prototype after the class is defined.\nReply to this email directly or view it on GitHub:\nhttps://github.com/tgriesser/bookshelf/issues/756#issuecomment-105891138\n. \n",
    "brandoncollins7": "When I use parse, I am not even getting any relations show up AT ALL in my result. I can deal with the columns not formatting but why are the relations being completely excluded?. When I use parse, I am not even getting any relations show up AT ALL in my result. I can deal with the columns not formatting but why are the relations being completely excluded?. ",
    "7kasper": "An option for now might be to use the plugin bookshelf-spotparse. I wrote it because I was struggling with this issue.\nAfter setting up the format and parse you can use the spot() function which can be used like this:\njavascript\nUser.spot({username: 'PietHein', password: 'decryptedpassword'})\n.fetch().then(user => console.log(user.get('status') + user.get('password')));\n// Prints: decryptedpassword\nand is based on this on what @rhys-vdw commented a long time ago.\n. > Adding 'docs' tag because this example could be added to the docs under Model#changed.\nFor anyone looking for something intuitive you can also use my plugin bookshelf-update which is a simple wrapper around that.. ",
    "robwilkerson": "I have a similar question I was just about to ask. I have a Listing model that belongsTo Unit. Unit belongsTo Property and Property belongsTo Neighborhood. I need to pull listings based on a neighborhood id, for example.\nhttps://gist.github.com/robwilkerson/e912e2c920542307875e\nYou can pretty much ignore what's there right now. I started trying random things at some point and still haven't gotten it to work. Maybe someone could take a look at that and point us in the right direction. I think it's the same question.\n. Was the gist, in addition to the model associations, not enough info? If not, what else can I provide that might be useful?\n. Ah, no sooner have I posted this than the SQL exposes the issue. I have the value of my addressable_type in my addresses table set to Listing rather than listings. I expected that value to be a singular value rather than the plural version.\n. Argh! Somewhere in all of my trial and error, I left out the attributes object: self.attributes.X = .... /punitive head slap.\n. Ha, actually I like the setter much better. Thanks, @bendrucker.\n. Geocode doesn't use Bluebird. The promise created by the geocode() call \"has no method 'bind'\". Am looking for the analogy, but this works in the meantime. :smile:  \nThanks again.\n. Sweet. Implemented as shown to great fanfare. Much appreciated.\n. In this case, I have a single object I need to save. I'm not so much interested in the save operation itself as much as a way to reference the model for saving. What I have now is a Listings route that explicitly requires the Document model and performs a Document.forge(...).save(...) operation.\nWhat I'd like to do is drop the explicit var Document = require('./document') and access the Document model through the Listing model the way I can in CakePHP (Listing->Document->save()) or perhaps in Rails as well. Maybe I'd need to create a separate association to do something like that.\nDoes that make a little more sense? My goal/preference was to only require the Listing model in the Listings route and then use associations to access any other models I may need (assuming they are, in fact, associated). Thought that might be possible, but haven't managed to get it right.\n. I'm still digging into this and I'm starting to wonder whether I'm using forge() incorrectly. I pretty much call Model.forge() every time I'm doing something with what I consider a separate object. This calls the initialize() method every time and seems to stack the event calls.\nWhat's the best practice for when to use the .forge() method when doing something on a model (fetching, saving, etc.)?\n. For anyone doing a search later...\nFinally tracked this and got it fixed, I think.  Seems that the primary issue was the way I was calling the parent object's initialize() method. When I started playing with Bookshelf, I was figuring things out by inspecting what I had. In doing so, I had the following code in my custom model (e.g. User):\ninitialize: function() {\n    this.constructor.__super__.initialize();  // <--- Problem\n    this.on('saving', this.encryptPassword);\n},\nThis seemed to work and it made for pretty readable code. The key to the fix was this change:\ninitialize: function() {\n    App.prototype.initialize.call(this);  // App is my base model\n    this.on('saving', this.encryptPassword);\n},\nIt makes sense now, but the original way \"worked\" and read better to me so it seemed correct enough until the fallout started appearing. The call to the prototype method is how it's shown in the docs, but no reason was given so it didn't really hit me that this was at the heart of the issue.\nAnyway, I seem to be back on track. Thanks again for all of the help.\n. So, I think the problem was that I had the same line of code in multiple models. When I mentioned that the change \"shifts the order\", I think what it really did was remove the garbage created by the line of code I removed, but there was still garbage generated by the other models that had similar code.\n. @bendrucker I assume you mean that I can't manipulate that value before updating? I thought/assumed that it would only update any explicitly passed key value, but would set its value to whatever it was last assigned. Sounds like that value is immutable once sent, if I understand you correctly, no?\n. Okay. I was treating options.patch as a white list for saving, of sorts, not realizing that it's a bit deeper than that. I'll have to read up on that a little more. It's definitely more complex that I initially thought.\nThanks again.\n. This hasn't happened again, so closing this under the assumption that I hosed something up and later fixed it or it was an environmental issue that has fixed itself.\n. It looks like this was a result of my having forgotten to call the parent format() method. This seems to work: \n```\nformat: function(attrs, options) {\n    // jshint unused:false\n_.each(attrs, function(val, key) {\n    if (_.isObject(val) || _.isArray(val)) {\n        attrs[key] = JSON.stringify(val);\n    }\n});\n\nreturn AppModel.prototype.format.call(this, attrs, options);\n\n},\n```\n. I'm still learning myself so someone may jump in with a better solution, but this works for me (assuming you have your models correctly configured):\nBook.forge({ id: req.params.id })  // Which book are we dealing with?\n    .paragraphs()  // Navigate to its related paragraphs. Could also be .related('paragraphs')\n    .query({ where: { 'id': <paragraph_id> } })  // Specify the paragraph we want\n    .fetchOne({ require: true })  // Fetch that paragraph, error if it doesn't exist\n    .then(function(paragraph) {\n        return paragraph.save({ key: val, key1: val1, key2: val2 }, { patch: true });\n    })\n    .then(function() {\n        return res.status(204).send();\n    })\n    .catch(Book.NotFoundError, function() {\n        return res.status(404).send();\n    });\n. @MrJadaml : To be honest, it looks like I didn't. It's been a while since I've touched this project so I don't really remember where it stood, but my test code looks exactly like what I posted so I'm guessing that test just fails. Wish I could be more help.\n. @MrJadaml : To be honest, it looks like I didn't. It's been a while since I've touched this project so I don't really remember where it stood, but my test code looks exactly like what I posted so I'm guessing that test just fails. Wish I could be more help.\n. @vellotis Aaaaah, no. The guid field is a unique key, but not the PK. I didn't see that accessing a belongsTo association had that specific stipulation. Thanks for pointing out (and explaining) the details.\n. Thanks for having a look, @vellotis. Books model below:\n``` javascript\n'use strict';\n// Node modules\n// None\n// Utility modules\nlet _ = require('lodash');\n// Application modules\nlet Mandrel = require('./mandrel');\n// Associated models\nrequire('./book_format');\nlet Book = Mandrel.extend({\n    tableName: 'catalog_books',\n//\n// ASSOCIATIONS\n//\n\n/**\n * Returns the book's format.\n *\n * @return {BookFormat} A BookFormat model.\n */\nformat: function() {\n    return this.belongsTo('BookFormat');\n},\n\n//\n// CUSTOM METHODS\n//\n\n/**\n * Returns the most appropriate project matching a given ISBN for a given\n * course duration. Our catalog is really a set of book \"products\". The\n * same book could be purchased in several ways. For each ISBN, this\n * we have to find the right product.\n *\n * @param  {String} isbn      The book's 13 (preferred) or 10 character ISBN.\n * @param  {Integer} duration The length of the course in days.\n * @return {Promise<Book>}    A promise passing a single book \"product\".\n */\nfindByIsbn: function(isbn, duration) {\n    return this.query(function(qb) {\n        qb.where('distributable', 1);\n\n        if (isbn.length === 13) {\n            return qb.where('print_isbn_canonical', isbn)\n                .orWhere('isbn13', isbn);\n        }\n        else {\n            return qb.where('isbn10', isbn);\n        }\n    })\n    .fetchAll()  // Books with matching ISBN values\n    .then(function(products) {\n        if (products.length < 2) {\n            return products.length === 1\n                ? products.at(0)\n                : [];\n        }\n\n        // eslint-disable-next-line newline-after-var\n        let rental = products.chain()\n            .filter(function(product, i, coll) {\n                let sku = product.get('sku');\n\n                return /R\\d+$/.test(sku)\n                    && Number(sku.split('R').pop()) >= duration;\n            })\n            .min(function(product, i, coll) {\n                let rentalLength = Number(product.get('sku').split('R').pop());\n\n                return rentalLength;\n            })\n            .value()\n        ;\n        // Yeah, I don't know why we end up at Infinity of no rentals\n        // are found, but we do.\n        if (rental !== Infinity) {\n            return rental;\n        }\n\n        return products.max(function(product, i, coll) {\n            let p = product.toJSON();\n\n            // Remove the false-y values and count the length.\n            return _.compact(_.values(p)).length;\n        });\n    });\n}\n\n});\nmodule.exports = Mandrel.model('Book', Book);\n```\n. For whatever it's worth, I've worked around the issue by not initializing a book instance:\njavascript\nexports.get = function(req, res) {\n    Book.where('guid', req.params.guid)\n        .fetch({ require: true })\n        .then(function(book) {\n            return res.send(book);\n        })\n        .catch(Book.NotFoundError, function() {\n            return res.status(404).send();\n        });\n};\nI guess that might even be marginally more performant. For the life of me, though, I still can't find where I'm creating that loop. I'd really love to know where I've gone wrong...\n. Oh, wow. I don't think I'd have ever realized that. At the risk of sounding patronizing or something...nice work, @vellotis. Really. I could've looked at that until the end of time and never gotten there. Thanks.\n. ",
    "patbenatar": "@jadengore yeah this should definitely be tested :+1: \u2014 If y'all are open to the idea, I'll find some time to add tests\n. @ricardograca It came out of a use case on a project I'm working on. I tried to explain the context of it in the original description, let me know if it doesn't make sense or if I can expand on this:\nIf a record has null values for modified_by_type and modified_by_id, and article.modifiedBy() is called, it will currently throw \"The target polymorphic model was not found\" because there is (understandably) insufficient information to lookup the type of the associated model.\nThis change allows for the developer to not have to be concerned with whether that column is set, but rather call the modifiedBy function reliably for both records that have this association present and those that don't. The NullMorphToAssociation would ideally be a duck type of the expected return value from a call to morphTo.\n. @rhys-vdw I think you're right. Originally I went with a null object to give us a means to imitate the (buggy #753) interface of belongsTo returning an empty model:\n``` javascript\n// existing belongsTo:\nsomeModel.aBelongsToRelation().fetch(function(relatedModel) {\n  // => relatedModel is null if relation isn't present\n})\n// and the same interface for morphTo:\nsomeModel.aMorphToRelation().fetch(function(relatedModel) {\n  // => relatedModel is null if relation isn't present\n})\n```\nI agree that returning null rather than empty models or null objects in both cases would be more clear. Would you like me to make that change as well as update to the new ES6 src/ and add some tests?\nJust to be clear, this would make for use like so:\njavascript\nvar relatedModel = someModel.aMorphToRelation()\nif (relatedModel) {\n  relatedModel.fetch(function(fetchedRelatedModel) {\n    // ...\n  })\n} else {\n  // relation isn't present\n}\n. @rhys-vdw I think I'm following you \u2014 and that is what's currently implemented in this PR. The null object (NullMorphToRelation) allows us to return an interface that implements fetch when we don't know what model to return (because the _type column is empty).\n. @rhys-vdw :beers: \nAgreed, it's far from perfect. I'm not sure how best we could handle that case.. Without _type set, we don't know what model to return for the relation. Without the developer providing the desired model, the best we could do is guess. Perhaps use the first model provided in morphTo?\n``` javascript\nEngine = bookshelf.Model({\n  vehicle() { return this.morphTo('vehicle', 'Car', 'Truck', 'Boat'); }\n});\nvar engine = Engine.forge()\nengine.vehicle() #=> an empty instance of Car\n```\nThis would more closely resemble the behavior of belongsTo, but it's quite an assumption to make that the developer is looking for an instance of the first model type.\n. @rhys-vdw agreed. Sleep on it and let me know what you think.\n. ",
    "kirrg001": "\nThe proposed solution just implements the fetch method which means that if the user tries to use any other method on the fake relation model it will just lead to a different error.\n\nYeah agree 100%, this doesn't look right. We don't want to return fake instances.\nIf we have to solve this, we need to come up with something else.\n\nIf a record has null values for modified_by_type and modified_by_id, and article.modifiedBy()\n\nWhy would article.modifiedBy() return null? \ud83e\udd14\n. I would be happy about a reply \ud83d\udc4d \n. yeah thanks \ud83d\udc4d \n. I've created a PR, see https://github.com/tgriesser/bookshelf/issues/1443\nHappy about review \ud83d\udc4d \n. @MarkHerhold Hey \ud83d\udc4b\nNode 0.10 & 0.12 were dropped already, see https://github.com/tgriesser/bookshelf/commit/98b541a030b064239c1001578bec5db37730ebbf\nYour fork is just out of sync.\n. https://github.com/tgriesser/bookshelf/commit/be0bbcdf90fe4f4ce43fb8d55cf5e9173531ed62. @VanessaRLewis Hey \ud83d\udc4b\nI don't think this is possible. I would suggest you keep track of your tables and columns in a JS/JSON file.. @mborst You can use the format fn to modify the dates before they are written into the database.. The options object is usually used for very general options e.g. transaction, method.\nThat's why i am not sure your suggestion fits good. The plugin you have written is also a good choice \ud83d\udc4d Otherwise the format function can be used to transform the created_at/updated_at into the format you need. . @vishchiv Can you please open this issue in knex? Thanks \ud83d\udc4b. Seems to be related to npm@2, see https://github.com/npm/npm/issues/8850.\n@vellotis Can we rewrite the postinstall hook to not use lodash?. Can't reproduce it anymore. I assume that the npm fetch of lodash took too long yesterday. The postinstall hook is triggered without waiting that all dependencies are installed (only npm@2).\nI would still like to remove the custom dependencies from Bookshelfs postinstall hook. Can happen again.. Got it again, locally.. Closed via https://github.com/bookshelf/bookshelf/commit/cd9e9d26b3d62fd4f0daeca24eb43578a905c904.\nThanks to @Playrom \ud83d\udc4d . I can reserve some time and release a new version in the next days.. I lost my write access to the repo, because of the Github organisation change.\n. > I assume you meant \"to run it in parallel\" here.\nYes sorry \ud83d\ude0e\n\nI've looked at the entire history of this part of the code\n\nI also had a look and couldn't find a good reason. Thanks for double checking \ud83d\udc4d . > This is mostly ok.\nThanks for review. Will update as soon as possible.. @ricardograca I've pushed a commit with your suggestions. Ready to squash + merge if you are ok with it \ud83d\udc4d . @ricardograca Hey. is there any chance that this get's released by the end of this week? \ud83d\ude01\nThanks :). > You can go ahead and merge all of your approved PRs though.\n\ud83d\udc4d \n. > I'd say probably not, but it won't be much later after that. \nTill Monday would be very, very, very helpful. Ghost wants to ship a feature beginning of next week and i would love to avoid using a tarball link or a fork \ud83d\ude01 Thanks in advance!. It wasn't for me \ud83e\udd14But i was on 0.10.3 when writing these tests. Maybe it is already fixed. Let me double check.. >   1) Integration Tests Dialect: mysql Relations Bookshelf Relations Eager Loading - Collections eager loads \"belongsToMany\" models correctly and parent is not undefined:\n     TypeError: Cannot read property 'should' of undefined\n      at . (test/integration/relations.js:229:68)\n  From previous event:\n      at Context. (test/integration/relations.js:228:14)\nSo yeah on 0.10.3 this test fails when i remove my code adaptions.\nBut it does not on latest master. Then it was probably already fixed. I just wonder where \ud83e\udd14I need to check the history.\nWe could still merge test improvements to assert that relatedData has the correct values.. > Probably fixed in #1716.\nYeah maybe. \n\nreturn new EagerRelation(this.models, response, new this.model()).fetch(options);\n\nthis.models are already instantiated models (the collection). I don't understand why we have to instantiate new this.model() empty as third parameter to then call target.belongsToMany. \nFurthermore:\nhttps://github.com/bookshelf/bookshelf/blob/master/src/base/eager.js#L52\nThis calls e.g. tags: function() { return this.belongsToMany(...); }\nAnd the result is always relation.relatedData.parentId=undefined. So i think the fix which was merged happens too late?\n. > Are you going to investigate?\nYes will do. But not before next week \ud83d\udc4dWill report back here.\nI don't mind which fix we take as long as it's the correct one :). I have not investigated much, but my gut feeling tells me to keep the fix in master as is.\nBecause my fix instantiates for every model in the collection a new eager relation (performance decrease). I am not saying my fix is incorrect, i think the problem is that the relation code needs to be reconsidered as a whole if we want to improve the code.\nI'll just update my PR to check that the relational data is not undefined.. @ricardograca This must be a local issue. I am not getting this error. I have yarn v1.3.2.\nBut you can simply use npm - doesn't matter.. I did another quick test. I've added one more query. First i fetch 10 posts (limit 10, offset 0), then i fetch one relation.\nFor bookshelf i am using withRelated: ['tags']. For Knex i am using the proper notation (innerJoin, whereIn, orderBy) and for MySQL i just copied the raw query from the knex DEBUG log. I ensured all queries return the same response on the MySQL shell.\n\nwrk -t20 -c300 -d60s --timeout 30s http://localhost:2369/\n\nNode 6.12.x\nAVG MySQL: 271.61ms\nAVG Knex: 459.66ms\nAVG Bookshelf: 1.18s \ud83d\ude12\nperfexample-with-relation.zip\n. > The extra long execution time of Bookshelf is expected in this case since it doesn't use JOIN\nBut all of the targets (MySQL, Knex, Bookshelf) from this test are using the exact same queries. Why is it expected that Bookshelf is ~600ms slower? Can you please explain further?\nThanks!. > but if that's not the case who knows what makes it slow\nFair. I didn't expect an answer. Just wondered if somebody knows why it's so much slower. But that's what also other ORM's suffer from - i've tested some, all of them have pretty poor performance. Probably caused by all the object creation and iterations.. @ricardograca Thanks for sharing \ud83d\udc4d I can help testing, so we can compare numbers again.. The changes sound logical to me \ud83d\udc4d \nIf timestamps are enabled:\n- on insert, both created_at and updated_at are automatically set\n  - but Bookshelf respects custom values for both properties\n- on update, only updated_at is automatically set\n  - if you don't provide a custom value for updated_at and nothing else has changed, updated_at won't change\n  - if you provide a custom value, updated_at will change\nIf timestamps are disabled:\n- respects custom values for updated_at and created_at\n\n\nThe options.date functionality of .save() to set both timestamp attributes with the same value is deprecated and will be removed in the next version. It's already possible to achieve the same effect by setting the timestamp attributes with the wanted values and saving.\n\nAgree\n\nIn theory, changing the creation date of a resource is a question mark, but up to the developer.\nThanks for sharing \ud83d\udc4d . > and in the case of #1583 it introduced a bug that prevented the updated_at attribute from being automatically updated in some cases.\nWe just discovered this bug in Ghost. Our updated_at field doesn't get updated anymore.\nWhen does the patch release goes out? \ud83d\ude0eThis is critical bug.. I am fine with releasing the breaking change. We did it last time (see 0.13 breaking changes), so we can continue with it until we have a 1.0.. @ricardograca lalalalala not looking at any further bookshelf emails anymore \ud83d\ude48. @ricardograca Sorry for delay - i was on vacation \ud83d\ude0eWill look at it asap.. Is this line still needed? \ud83e\udd14 Because we no longer reset the previous attributes in the reset fn. Just curious.. If i fetch relations with withRelated, the relational models have _previousAttributes: {}.. @ricardograca Great to hear - i'll look at them asap :). > If i fetch relations with withRelated, the relational models have _previousAttributes: {}.\nThis is resolved \ud83d\udc4d \n\nBut when i install this PR as tarball, i am having a different problem. Maybe unrelated to this PR.\n\nonFetchingCollection ('fetching:collection')\n\nThis event no longer passes the options - it's always undefined.\nFirst argument: is correct, the collection\nSecond argument: a function (?)\nThird argument: undefined (which should be options). @ricardograca If you have a guess, let me know. I've also debugged a little, suddenly the options and columns values change after the fetching event.. @ricardograca great \ud83d\udc4d Let me know what it was :). Thanks! I'll look again at both on Monday \ud83d\ude43. Sorry for late feedback.\nIf i forge a new model e.g. models.Post.forge(data), why is the previousAttributes set to the attributes? \ud83e\udd14This was different before and i wonder if we should really change it.\nIt's weird, because there can be situations where you don't expect that previous attributes are set, because the model is new.. Example: If you have previously used model.hasChanged(key) in a generic context, it was\n\ntrue if the model was new\ntrue if the key of the model got updated (model is not new). @ricardograca Will look at this asap. I am currently a little time constrained.. @ricardograca Will look at this asap. I am currently a little time constrained.. @ricardograca Yes, on my list for this week \ud83d\udc4d . @ricardograca Could you pls rebase? \ud83d\udc4d . Let's say i fetch a user and it returns\n\n{attributes: {status: active, ...more attributes...}, previousAttributes: {}}\nNow i call user.set('status', 'active') and user.save() (status did not change !)\nI am listening on the user updated event and i receive:\n{attributes: {status: active}, previousAttributes: {}, changed: {}}\nIs that expected? I am wondering why the previous attributes object is empty in the updated event \ud83e\udd14 I think as soon as you save a model without fields being modified, i am receiving _previousAttributes: {}, which feels inconsistent? Let me know :)\nI think the behaviour was different before?. I am on the correct commit. I just double checked.\nSteps:\n\nfetch\nuser status is active\nuser.set('status', 'active')\nuser.save()\nupdated event -> prev attrs are empty. > Oh yeah, I remember you had a custom property in Ghost models for storing the proper previous attributes, before this change. Could it be related to that?\n\nI have commented out all the logic for that.\n\nHere is the gist: https://gist.github.com/ricardograca/da68dc091fcbe15c395558c166fd7200\n\nThanks will test asap!!. The gist works for me too. It must be something else. I am looking into it now.. I figured it out. That was quick \ud83e\udd23\nhttps://gist.github.com/kirrg001/b8650a544db01541828d50fbcd1a227d\nBookshelf returns an empty _previousAttributes object if you fetch on a collection.\nAnd if you then operate on a model of this collection, you end up that all further operations e.g. event hooks contain an empty previous attributes object.\n. Do you know why \".changed\" get's reseted after the sync? \ud83e\udd14 \n. Yes agree, but it would be still helpful to know \"what has changed\", otherwise you need to diff previous and current attributes yourself.\nExample use case:\nYou want to trigger a webhook after a resource was updated and want to highlight which fields have changed.. One related question: Do you know why model.changed is empty on \"destroying\"?\nIs that a bug or a wanted behaviour? If I delete a model, all fields will change, because we theoretically null them. . will update \ud83d\udc4d . will update \ud83d\udc4d . ",
    "Ashesh007": "My sql query is like this\nbookshelf.knex('wa_user')\n    .select('id', 'name', 'phone_no')\n    .whereIn('phone_no' , [  contacts ])\n    .then(function(userData) {\n      //console.log(userData);\n      callback(null, userData);\n })\nand error shown like as follow\n{ [error: function phone_no(bigint, bigint, integer, bigint, bigint, integer, bigint, bigint) does not exist]\n  name: 'error',\n  length: 260,\n  severity: 'ERROR',\n  code: '42883',\n  detail: undefined,\n  hint: 'No function matches the given name and argument types. You might need to add explicit type casts.',\n  position: '54',\n  internalPosition: undefined,\n  internalQuery: undefined,\n  where: undefined,\n  schema: undefined,\n  table: undefined,\n  column: undefined,\n  dataType: undefined,\n  constraint: undefined,\n  file: 'parse_func.c',\n  line: '306',\n  routine: 'ParseFuncOrColumn' }\n. ",
    "ansem78": "IMHO, parse is not a source of ton of confusion. It only does what people expect: format attributes values in reading operations. format, on the other way, is really confusing. Why does it have to manipulate attributes in reading operations? format, by its name, is supposed to format attributes values just before saving the model to the DB. Bookshelf already has methods to omit attributes (this is the main reason, if I understand, format is called in reading operations, too). For me, the simplest and correct ways to read/write would be:\nRead: DB -> parse(dbRawData) -> Model\nWrite: Model -> format(modelAttributes) -> DB\nIf I want to omit some attribute, I can use Model.omit(). parse and format should do exactly the same thing: format attributes values when reading (parse) and writing (format). To add/set/remove attributes before saving, only a validation method registered on saving event might be used.. Bookshelf is really a great ORM IMHO, but some features should be heavily revised. The main thing that should be improved a lot is the documentation. Many points are not clear and sometimes contradictory. The examples are too simple for a real-life development and are sometimes incomplete and/or confused. Collections should be removed and treated as simple arrays and all options passed to Model.fetch() (withRelated, columns, etc.) should also be valid for all models in a collection (fetchAll() does not accept these options and forces to implement collections). When retriving a model, its relations should be accessible when the model is sent to the client as a JSON object (now I have to manually set up a property in the model using Model.related() before sending it to the client). For example, if I retrieve a relation by calling a role() method on a user model, the user object should have a \"role\" property with the role object.. Hmm...I have not considered to convert the model to JSON before the method returns it. I am a beginner with Bookshelf and now I have set up the Express API routes to return JSON with response.json(model). In this way, the response JSON data have not any relation set. I read that calling toJSON() will convert the model with all its relations. But I thought the response.json() Express method acts the same way. I will try to convert model to JSON before sending the response. Thanks for the suggest.\nFor the docs, just for example, I read: \"The format method is used to modify the current state of the model before it is persisted to the database\". But the next paragraph says: \"Do note that format is used to modify the state of the model when accessing the database\". This is contradictory. The first statement is correct, but the second implicitly says that also a reading operation calls format, that is obviously false.. @ricardograca I have tested parse() and format() with a console.log(). When I perform a reading operation (Model.fetch()) parse() is called, but format() is not. I have never removed any attribute in the format() method, so now I understand what you say. format() will influence fetch() operation by removing attributes, but is this behavior correct and/or really useful? I mean, if I read data, I expect Bookshelf will internally call parse() to format attributes (and only the attributes I read: all or a subset using the option \"columns\"). If I want to remove one or more attributes, I can either read only the attributes I want, or use Model.set() with the \"unset\" option to remove unwanted attributes. So, format() can be used as a \"shortcut\" to manipulate the model attributes in a reading operation and also affects the saved model, if I have understand.\nMaybe I am wrong and don't think to all possible scenarios, but I find this a bit confusing. I think the simplest patterns to read and write models would be:\nRead: DB -> dbRawData.parse() (fetch()) -> Model\nWrite: jsObject -> Model.format() -> DB\nwith parse() and format() unable to add/remove attributes. But, as I said, I am a beginner with Bookshelf and ORMs and I have surely not consider all possibile cases.. ",
    "henryboldi": "The changes made here make you redefine errors when using ES6 classes. See #756 \n. @kripod Great work! I'd love to see some of these improvements merged into bookshelf.\n. ",
    "robsm": "+1\n. ",
    "ecgeiser": "Maybe an api where the standard case would look like\nBook\n    .whereRelated('Author', 'last_name', '=', 'Twain')\n    .fetchAll();\nbut you could dip into the query builder for more options\nBook\n    .whereRelated(['Author': function(qb)\n        qb\n            .where('last_name', '=', 'Twain')\n            .orWhere('last_name', '=', 'Clemens')\n    ])\n    .fetchAll();\nAnother idea would be to model it on the withRelated api, so something like\nBook\n    .fetch({byRelated: [{\n        'Author': function(qb)\n            qb\n                .where('last_name', '=', 'Twain')\n                .orWhere('last_name' '=', 'Clemens')\n        }]\n    });\nIt would also be great if there were an option to specify whether you want to fetch the relations with the models or only return the models.\n. ",
    "garbin": "@tgriesser  any progress on this feature?\n. My bad... typo, is require, not required.\n. +1\n. +1. +1. ",
    "brunocascio": "+1. Any updates here?. Great, thanks!. ",
    "muddydixon": "I see, i will be going to try solutions. But please merge this pr if you can.\nI think it better that replace simple-extend module.\n. Oops, I misunderstand your rep. \nOk, i try it!\n. Done! check plz!\n. @xaka Yes BookshelfModel.NotFoundError is used implicitly because of backward compatibility.\nIf SomeModel.NotFoundError is used without overriding NotFoundError in static Properties, exception is not occurred.\nBut I agree your opinion, I want to implement distinct NotFoundError for each model that is extended from Errors.NotFoundError too.\nIts not ideal, anyway my p-r solves addressing problem to some extent, \n. @xaka I sent new commit in that per-model Errors were set in default.\nPlease review it.\n. I'm sorry for late.\nIn previous commit, Model own properties are overridden in each time to extend.\nFor example,\n```\nvar Hoge = bookshelf.Model.extend({\n  tableName: \"bookshelf\"\n});\n// Model.NotFoundError => \"HogeNotFoundError\"\nvar Fuga = bookshelf.Model.extend({\n  tableName: \"bookshelf\"\n});\n// Model.NotFoundError => \"FugaNotFoundError\"\n// thus\nnew Hoge.NotFoundError() // => \"FugaNotFoundError\" awesome!!!\n```\nI fixed this!\nAnd added test.\n. I'm sorry for late.\nIn previous commit, Model own properties are overridden in each time to extend.\nFor example,\n```\nvar Hoge = bookshelf.Model.extend({\n  tableName: \"bookshelf\"\n});\n// Model.NotFoundError => \"HogeNotFoundError\"\nvar Fuga = bookshelf.Model.extend({\n  tableName: \"bookshelf\"\n});\n// Model.NotFoundError => \"FugaNotFoundError\"\n// thus\nnew Hoge.NotFoundError() // => \"FugaNotFoundError\" awesome!!!\n```\nI fixed this!\nAnd added test.\n. ",
    "javascrewpt": "thanks for your response. I'm just curious, how come it works in the example below? If I select another attribute besides avg and count, I get the desired result?\n. You are correct; if I select anything else than the reference ID of the other table, it does not work. So, are such queries anomalies, considering that you said that 'You can't do arbitrary queries right now with relations. '?\n. thanks for your time and answers!\n. Here's what happens when I run the code above:\n{ __cid: '__cid1', sql: 'begin transaction;' }\n{ __cid: '__cid1',\n  method: 'insert',\n  options: undefined,\n  bindings: [ 'Transaction John' ],\n  sql: 'insert into \"participants\" (\"name\") values (?)' }\n{ __cid: '__cid1',\n  method: 'insert',\n  options: undefined,\n  bindings: [ 'Transaction Doe' ],\n  sql: 'insert into \"participants\" (\"name\") values (?)' }\n{ __cid: '__cid1',\n  method: 'insert',\n  options: undefined,\n  bindings: [ 1000, 'LA' ],\n  sql: 'insert into \"towns\" (\"town_number\", \"town_title\") values (?, ?)' }\n[ReferenceError: p4 is not defined]\n{ __cid: '__cid1', sql: 'rollback;' }\n{ __cid: '__cid1',\n  method: 'insert',\n  options: undefined,\n  bindings: [ 3, 1, 'Transaction street name', 1 ],\n  sql: 'insert into \"addresses\" (\"house_number\", \"participant_id\", \"street_name\"\n, \"town_id\") values (?, ?, ?, ?)' }\n. It appears to be an issue with Promise.all (the second time I use it), as suggested on #bookshelf (\"I think the problem is with Promise.all()\"). \nI refactored the code as follows (and it works, although I'm still not use about attaching many-to-many things in transaction).\nWhy is Promise.all an issue the second time I use it??? Is it a bug?\n``` javascript\nrouter.get('/transaction', function(req, res){\nbookshelf.transaction(function(t){\n    return Promise.all([\n        new Participant({name: 'Transaction John'}).save(null, {transacting: t}),\n        new Participant({name: 'Transaction Doe'}).save(null, {transacting: t}),\n        new Town({town_number: 1000, town_title: 'LA'}).save(null, {transacting: t})\n    ]).spread(function(p1, p2, t1){\n            //WORKS IF I DON'T USE Promise.all AGAIN!\n            return Promise.try(function(){\n\n                return new Address({\n                    house_number: 3,\n                    street_name: 'Transaction street name',\n                    town_id: t1.get('id'),\n                    participant_id: p1.get('id')        \n                }).save(null, {transacting: t});\n            }).then(function(r1){\n\n                return new Address({\n                    house_number: 3,\n                    street_name: 'Transaction street name 2',\n                    town_id: t1.get('id'),\n                    participant_id: p1.get('id')        \n                }).save(null, {transacting: t});\n            }).then(function(r2){\n                //STILL NOT SURE ABOUT USING {transacting: t} HERE!\n                p1.friends().attach(p4, {transacting: t});\n            });\n\n    }).then(function(){\n        return Promise.resolve();\n    }).catch(function(error){\n        return Promise.reject(error);\n    });\n\n}).then(function(){\n    res.json('success');        \n}).catch(function(error){\n    res.json(error);\n});\n\n});\n```\n. thank you for your input. the promise.all thing bugs me, because when I use it for the first time, it works ok. After .spread it starts to behave unpredictably.\nAbout .attach you might be right. so, if I can't use transacting: t, what's the alternative? perhaps the developers might be able to shed some light on this...\n. Yes, this appears to solve the issue with Promise.all!\nI now get the following error: Unhandled rejection Error: Transaction query already complete, run with DEBUG=knex:tx for more info\nThis even works with attach(), right? Or so it seems.\n. Yes, this appears to solve the issue with Promise.all!\nI now get the following error: Unhandled rejection Error: Transaction query already complete, run with DEBUG=knex:tx for more info\nThis even works with attach(), right? Or so it seems.\n. Well, I guess you could delete the property from the object... I'm not sure that there's a method that would unload this once it's already loaded.\n. Thank you! I've discussed this with tgriesser and he suggested the same. So, a new model for the junction table is the way to go.\n. Thank you! I've discussed this with tgriesser and he suggested the same. So, a new model for the junction table is the way to go.\n. ",
    "thebergamo": "+1\n. Will be very useful if the @vellotis PR will be accepted. I'm having this problem. . I've some projects running on Bookshelf and I really like the way the things are doing. I've faced with a lot of problems since to find information regarding how to use something to problems with transactions and other things.\nWhat are the next steps? Count me in o/. ",
    "korzhyk": "For this purpose Bookshelf has an .query() method which return knex QueryBuilder http://bookshelfjs.org/#Model-instance-query and you can use this like you want: \njavascript\nAccount.query().where('user_id', 1).increment('balance', 10)\n. ",
    "VanessaRLewis": "What was the typo?. Ok, thanks\nOn Apr 19, 2017 1:58 PM, \"Katharina Irrgang\" notifications@github.com\nwrote:\n\n@VanessaRLewis https://github.com/VanessaRLewis Hey \ud83d\udc4b\nI don't think this is possible. I would suggest you keep track of your\ntables and columns in a JSON file.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1550#issuecomment-295439560,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AL37wCFcpSvPhTOZSGZ0PwxAShOAu2U1ks5rxnWHgaJpZM4M61Bh\n.\n. I want to do a join on all 4 tables and be able to query the columns of any of the 4 tables simultaneously. \nIn SQL my query would be:\nselect * \nfrom aps, switchs, wlcs, venues\nwhere aps.switch_id = switchs.id\nand aps.wlc_id = wlcs.id\nand aps.venue_name = venues.name\nand wlcs.name = 'w1'\nand venues.name = 'v1'\nand switchs.ip = '1.2.3.4';\nThe where queries are all \"=\" operators and can be dynamically changed.\nSince the where method in Bookshelf can take an object of hash of attributes  (http://bookshelfjs.org/#Model-instance-where), I considered only the \"=\" cases and used an Object apQ to pass my where queries on aps table as below\n\nAp.query(function(qb){\n    qb.where(apQ);\n})\n.fetchPage({\n    limit:3, \n    offset:0, \n    withRelated: [\n    {wlc:function(qb){qb.column('id','name','ip');}},\n    'switch'\n    ]})\n.then(function (resultCol){\n    console.log(resultCol.toJSON());\n})\n.catch(function (err){\n    console.log(\"Err\",err);\n});\nThis gives me an output of 3 Ap records with all of their related switch info & only the 'id','name','ip' of their related wlc info. (ie, 3 Ap json objects with nested Wlc & Switch Json Objects)\nHowever, when I tried the following to query the wlc as well as the ap tables at the same time, it doesn't work.\nAp.query(function(qb){\n    qb.where(apQ);\n})\n.fetchPage({\n    limit:3, \n    offset:0, \n    withRelated:[\n    {wlc:function(qb){qb.column('id','name','ip').where(wlcQ)}},\n    'switch'\n    ]})\n.then(function (resultCol){\n    console.log(resultCol.toJSON());\n}).catch(function (err){\n    console.log(\"Err\",err);\n});\nI get 3 Ap objs (& nested switch & wlc objects ) which satisfy the clauses in apQ obj (ie queries on the ap table) but do not satisfy the queries in the wlcQ obj (queries on the wlc table), in fact, I get an AP object with an empty nested wlc Obj when the record doesn't satisfy the queries in wlcQ.\n. Solved this using knex.raw(). ",
    "zation": "@bendrucker thanks for your response! But seems I didn't explain my question well. I will rewrite this question.\n. ",
    "taurencoder": "@bendrucker I think his expression leads some misunderstanding. The issue is not relatedModel.initialize() cannot get called, but the fetched and fetching events are only triggered on the top level model. Take his code for example:\njs\nvar Organization = Bookshelf.Model.extend({  \n    tableName: 'organizations',\n    initialize: function() {\n        this.on('fetched', this.doSomething);\n    },\n    doSomething: function() {\n        ...\n    },\n    users: function() {\n        return this.hasMany(User);\n    }\n});\nIn this case, doSomething() cannot get called. I'm wondering how can we listen to the related model's fetching events.\n. ",
    "FredKSchott": "In that case I still get the same result (it tries to save all attributes in the hash, even the ones that haven't actually changed)\n// In this example, hashOfProperties has all of the same attributes as item except for one change: foo = 'bar'\nitem.save(hashOfProperties, {patch: true});  \n// What I'd expect: 'update \"items\" set \"foo\" = $1 where \"id\" = $2'\n// What I see: 'update \"items\" set \"assignee\" = $1, \"checked\" = $2, \"created_at\" = $3, \"creator_id\" = $4, \"deleted_at\" = $5, \"id\" = $6 ... where \"id\" = $15''\n. ",
    "kaatt": "@rhys-vdw Is there any trade-off in setting item.save(item.changed, {patch: true}); as default behavior?\n. ",
    "santiagodoldan": "Maybe it could be a good idea to add an update function that hides the {patch: true} part.. ",
    "elnaz": "Thanks. Sorry I missed the original issue.\n. ",
    "jdwolk": "@tgriesser @ricardograca sorry for the dup question and thx for the quick response\n. @tgriesser @ricardograca sorry for the dup question and thx for the quick response\n. ",
    "molomby": "+1; Lazy load functionality for relations would be extremely useful. \n. ",
    "arnold-almeida": "Agree.\nShould be something that can be enable similar to \nModel.fetch({ lazyLoad : true, require : true })\n. @rhys-vdw Abandoned? \n. ",
    "ffranco-daitan": "Hello @ricardograca thanks for the quick response.\nProduct can't hasMany Description because:\n1) Product has i18n_id but Description's PK is i18n_id\n2) Description is a table which contains internationalized names and descriptions for various entities on my system, such as products, manufacturers, etc...\nAs for what I'm asking is for a way to construct the JOIN without having to manually pass the table names and fks as arguments. Looks like the JOINs mentioned in https://github.com/tgriesser/bookshelf/issues/141 are the way to go...  Is there a roadmap for that?\nAlso, for the \"bonus\" question, I'm guessing the answer is the same as above, that is, wait for support for custom JOINs ?\n. Hello @ricardograca thanks for the quick response.\nProduct can't hasMany Description because:\n1) Product has i18n_id but Description's PK is i18n_id\n2) Description is a table which contains internationalized names and descriptions for various entities on my system, such as products, manufacturers, etc...\nAs for what I'm asking is for a way to construct the JOIN without having to manually pass the table names and fks as arguments. Looks like the JOINs mentioned in https://github.com/tgriesser/bookshelf/issues/141 are the way to go...  Is there a roadmap for that?\nAlso, for the \"bonus\" question, I'm guessing the answer is the same as above, that is, wait for support for custom JOINs ?\n. ",
    "helios1138": "is there some kind of workaround solution for this until it's fixed?\n. @rhys-vdw well, exactly what is in this issue description, to call query(...something).count() on related collection :)\n. @rhys-vdw unfortunately master fails on install. I guess I'm gonna have to try replicate this fix on 0.9.1 tag\n. @rhys-vdw indeed it does seem to fix this issue, will it be possible to release 0.9.2 with this fix?\n. @rhys-vdw awesome!\n. I see\n. I see. If there is a roadmap for some kind of bookshelf 2.0, could we expect to have this included?\n. That's ok, it actually works pretty great as it as, and those few places where it doesn't are easily avoided.\n. Last time I checked there was no way to do this since bookshelf uses subqueries rather than joins to fetch relations. So you have to use joins inside a query() yourself.\n. actually it would've been great to have some kind of query helper for this so you could do something like this:\nModel\n  .query('join', Model.related('others'))\n  .where('others.is_active', true)\n  .fetch()\nor this:\nModel\n  .query(q => Model.related('others').joinTo(q))\n  .where('others.is_active', true)\n  .fetch()\nShould be pretty straitforward since all the information is already there in .relatedData and there is no need for rewriting relation fetching itself.\n. Ah yes, I missed that. Makes sense now.\n. @ricardograca  Well pretty much what is in the title: I have a belongsToMany(Something).through(Other) relation and I'm calling .detach() (without arguments) on it which should delete all records from pivot table related to this entity. And it doesn't work. It makes a single delete request by some id from pivot table instead of doing it by relatedId (like it does if using belongsToMany() without through()). I tried related.detach(), related.detach(related.toArray()), related.detach(related.map(model => model.get('id'))) - nothing works.\n. ",
    "Uhsac": "Yeah I read the doc and I tried :\nmodels.related('users.posts')\nmodels.related('users').related('posts')\nBut it don't work\n. Yeah I read the doc and I tried :\nmodels.related('users.posts')\nmodels.related('users').related('posts')\nBut it don't work\n. ",
    "federicobond": "Great, thanks! Let me know if you need any feedback or help.\n. Great, thanks! Let me know if you need any feedback or help.\n. ",
    "ArthurMialon": "Hi @elliotlings @jbruni  !  To deal with that I hacked belongsToMany.\njs\n  pictures: function () {\n    return this\n      .belongsToMany('Picture', 'picture_mapping', 'imageable_id', 'picture_id')\n      .query(qb => {\n        qb.where('imageable_type', 'user');\n      });\n  },\n. \ud83d\udc4d +1\n. ",
    "gdw2": "I'm having the same problem.\n. ",
    "kc5ez": "@rhys-vdw \nI am also trying to save/update a table that has composite keys. since bookshelf doesn't support composite keys, should we just get rid of composite key completely and use another ORM? \nWhat is a workaround? \nCan you provide an example of using the where clause in the save function? I've tried it but still trying to return 'id' (which does not exist)\n. @rhys-vdw \nI am also trying to save/update a table that has composite keys. since bookshelf doesn't support composite keys, should we just get rid of composite key completely and use another ORM? \nWhat is a workaround? \nCan you provide an example of using the where clause in the save function? I've tried it but still trying to return 'id' (which does not exist)\n. ",
    "Cl1608Ho": "\nUnfortunately bookshelf does currently not support composite keys.\n\nHas this changed in the past ~2 years?. Sorry for the late response. I think this could and should be implemented as a plugin by monkey patching fetch and the related functions.\nThe plugin would keep an internal cache that let's fetch() and related resolve immediately, unless the model is marked as dirty. This happens either if it was saved or any other models that belongsTo it (if necessary).\nThis would allow people to opt in to caching when needed (or better, not automatically opt in if not wanted).. bump. ",
    "natorojr": "Looks like it was removed while merging in 0.8.0:\nhttps://github.com/tgriesser/bookshelf/compare/0.7.9...0.8.0#diff-06839c8096f01eff9d98771e1734651dL94\n. Looks like it was removed while merging in 0.8.0:\nhttps://github.com/tgriesser/bookshelf/compare/0.7.9...0.8.0#diff-06839c8096f01eff9d98771e1734651dL94\n. Working locally, but I'll wait to close this issue until I've verified it in the next release.\n. Re fixes #721 \n. Re fixes #721 \n. ",
    "GTrebaol": "I think it's because the relations are not automatically attached to the entity.\nI'm facing the same \"problem\", a simple example is in a REST situation. You send the entity through the put method, but you can NOT send it with the relations since it won't save the entity. Basically in my situation I just have to be careful not sending the relations from the front end. But I admit that automatically removing the relations before saving would be really cool.\n{\ncode: \"ER_BAD_FIELD_ERROR\"\nerrno: 1054\nsqlState: \"42S22\"\nindex: 0\n}\n. ",
    "abramsba": "I've gotten the database to update, though I've used where() instead with an option of method. Though, if I leave out the update it will try to insert the row instead \njs\n   _.each( words_table, function(value, key) {\n     var word_model = Word.forge();\n     word_model\n       .where({ user: from, word: key })\n       .save({ count: value }, { method: 'update' })\n       .then(function(m) { console.log(m); });\n   });\n. I've gotten the database to update, though I've used where() instead with an option of method. Though, if I leave out the update it will try to insert the row instead \njs\n   _.each( words_table, function(value, key) {\n     var word_model = Word.forge();\n     word_model\n       .where({ user: from, word: key })\n       .save({ count: value }, { method: 'update' })\n       .then(function(m) { console.log(m); });\n   });\n. I just noticed this in the documentation, is it possible to have multiple idAttribute keys or does bookshelf only support 1? I've tried passing it as an array or an object, but I'm not having any lucky. \n. I just noticed this in the documentation, is it possible to have multiple idAttribute keys or does bookshelf only support 1? I've tried passing it as an array or an object, but I'm not having any lucky. \n. Ok, I'll just assume then that my issue has to do with compound keys. In either case, I've come up with this for now.\njs\n  _.each( words_table, function(value, key) {\n     var word_model = Word.forge({user: from, word: key});\n     word_model.fetch().then(function(m) {\n       if ( m == null ) {\n         word_model.save({count: value}).then(function(m) {});\n       }\n       else {\n         var current_count = m.get('count');\n         Word.forge().where({ user: from, word: key }).save({ count: current_count+value }, { method: 'update' });\n       }\n     });\n   });\n. Ok, I'll just assume then that my issue has to do with compound keys. In either case, I've come up with this for now.\njs\n  _.each( words_table, function(value, key) {\n     var word_model = Word.forge({user: from, word: key});\n     word_model.fetch().then(function(m) {\n       if ( m == null ) {\n         word_model.save({count: value}).then(function(m) {});\n       }\n       else {\n         var current_count = m.get('count');\n         Word.forge().where({ user: from, word: key }).save({ count: current_count+value }, { method: 'update' });\n       }\n     });\n   });\n. ",
    "hagabaka": "So this would allow putting withRelated in the model definition instead of options to fetch. Is there an easy way to make this work throughout the inheritance hierarchy? For example, if B extends A, and A has withRelated: 'r1' and B has withRelated: 'r2', it might make sense for B to auto-fetch both r1 and r2, since B inherits A's r1 relation.\n. @vellotis I tried it, but the event doesn't seem to be actually firing when fetching a collection, e.g. library.books().fetch(). I put a console.log and it doesn't print, and if I define eagerLoad on Book, it doesn't get applied (it would if this worked as intended, right?).\n. So my goal is to make this apply recursively in related models, for example, given\nA = Model.extend({withRelated: 'b', ...})\nB = Model.extend({withRelated: ['c, d'], ...})\nC = Model.extend({withRelated: ['e', 'f', 'g'], ...})\nThen a.fetch() would automatically fetch with b, b.c, b.c.e, b.c.f, b.c.g, b.d. And it seems possible by expanding the withRelated option recursively through CollectionBase.model like this skeleton code:\n```\nfunction expandRelationNames(names, model, prefix) {\n  return names.map(relationName => {\n    relation = modelrelationName\n    relatedModel = relation.model\n    subRelations = relatedModel.withRelated\n    return expandRelationNames(subRelations, relatedModel, relationName + '.')\n  }).flatten().concat(names)\n}\nModel.extend({\n  fetch: function(options) {\n    // ...\n    options.withRelated = expandRelationNames(withRelated, this, '')\n  }\n})\n```\nThere would need to be some way to prevent infinite recursion, maybe just by limiting the depth of built withRelated entries. It also needs additional logic to handle existing dots in withRelated. Also, there is still the problem that when you call fetch on a collection, this doesn't get triggered (fetching:collection seems to be only triggered for Model.fetchAll()).\n. @vellotis I'm using MySQL Ver 14.14 Distrib 5.6.30. Yes, the schema is still changeable, and I'm referring to Class Table Inheritance (aka Table Per Type Inheritance).\n. ",
    "JordanForeman": "@dj-hedgehog I stumbled across this issue from a quick Google search and noticed that you just closed it today. I can only speak for myself, but I would still consider this a pretty good enhancement to pursue, and worth keeping open if only as a wishlist item.. ",
    "tbranyen": "Ping @tgriesser any thoughts on this? I know @tkellen mentioned that you're currently in a rewrite, does this work temporarily for you?\n. @rhys-vdw the significance of invert is confusing me, can you explain what you mean there? as for a breaking change, i was worried someone would say that since all the tests passed.  Can you help me write a test that expresses the breaking change such that  this PR fails?\n. @rhys-vdw the significance of invert is confusing me, can you explain what you mean there? as for a breaking change, i was worried someone would say that since all the tests passed.  Can you help me write a test that expresses the breaking change such that  this PR fails?\n. ",
    "Yu1989": "Oh I'm sorry that I forgot to mention that in this scenario, there's no banner with url 'old', so no rows will be updated. I caught and printed out the error. It was [Error: No rows were affected in the update, did you mean to pass the {method: \"insert\"} option?], and I believe it was a string, not an instance of NoRowsUpdatedError\n. ",
    "ericadamski": "Any progress on this issue?. ",
    "adomasven": "Hi, any updates on this one? I am getting problems with how bookshelf handles mysql timeouts in 0.7, but in 0.8 .clone is broken. I am running bookshelf at production level and it would be nice to have a resolution of any kind.\n. I can't spot the problem with setProps? What are you referring to, exactly? \nI am willing to eventually, but it wouldn't be another week or two, before I sit down with our code to do some refactoring and bugfixing, which would involve a PR for this one too. I'd be really grateful if you submitted a fix for this, though @rhys-vdw .\n. Ah, I was about to go test this and make sure it works. Will report if anything is broken. But regardless, cheers for this one!\n. ",
    "MrJadaml": "I am also interested in this. @robwilkerson how did you end up moving forward with this?\n. I am also interested in this. @robwilkerson how did you end up moving forward with this?\n. ",
    "rbhalla": "latestTask: function(){\n    return this.hasOne(Task)\n      .query(function(qb) {\n        qb.orderBy('id', 'desc')\n      });\n  }\nPretty simple I guess, but I didn't make the mental leap to associating hasOne with an instance of Task.\n. This issue already has a discussion here https://github.com/tgriesser/bookshelf/issues/44 so I'm closing this\n. I had a similar problem and couldn't figure it out. I ended up with this suboptimal solution:\nmodel.query(q => this._applyQuery(query, q))\n    .fetchAll()\n    .then(models => models.map(model => model.destroy()))\n    .all()\nthis will do n+1 queries, where n is the amount of models to be deleted. Hopefully this helps anyone else who stumbles upon this in the meantime.\n. ",
    "offmadisonave": "+1\n. Awesome.  Thanks so much!\n. Awesome.  Thanks so much!\n. ",
    "chamini2": "I'm doing the pull request to this, should the serializer return undefined or null in relations that return true for isNew?\n. Hi, has this issue been resolved in any way? I'm interested in composite primary keys.\nCould this be handled with a parse / format hack?. Hi, has this issue been resolved in any way? I'm interested in composite primary keys.\nCould this be handled with a parse / format hack?. I think the key thing to check is the change in the generated queries.\n. Hey, @vellotis, I started working on this but I'm not being able to get all the tests to run. So I would appreciate it if you could take a look?\n. Hey @vellotis, now the tests pass! It was failing in the eager loading because was comparing table names against morphValue\n. Now I pass the morphValue here (src/eager#63) to be used here (src/relations#121)\n. Ok, the following message was sent in the Gitter chat but had no response, so I'm pasting it here to see if we get some responses:\n\nHello everyone,\nI've been working in the PR #1326 to add a morphValues option for the morphTo relation. The idea is to implement the counterpart of the morphValue option for morphOne and morphMany.\nThe PR is ready functionality wise but @vellotis and I have been discussing the new API for the morphTo relation and we would like some other opinions in the subject, and would like if the addition didn't break any old Bookshelf code:\nPassing the target model and morphValue in an array of size two, kind of like columnNames (i.e. [Author, 'profile_pic']). For this options, keep the registry plugin in mind.\nThis API could have two different behaviours with columnNames (which is also an array):\nOption 1\nTo set morphValues and no columnNames: pass null in columnNames.\njs\nmorphTo('imageable', null, ['Site', 'cover_photo'], ['Author', 'profile_pic'])\n// columnNames: null\n// morphValues: ['Site', 'cover_photo'] ['Author', 'profile_pic' ]\nThis option always knows which are morphValues and which are columnNames without a doubt.\nOption 2\nTo set morphValues and no columnNames: simply pass the morphValues.\njs\nmorphTo('imageable', ['Site', 'cover_photo'], ['Author', 'profile_pic'])\n// columnNames: null\n// morphValues: ['Site', 'cover_photo'] ['Author', 'profile_pic' ]\nThis option has to test 'Site' as a model in the registry plugin and when it successfully finds it, decides it's not a columnNames.\nIf we pass a columnNames:\njs\nmorphTo('imageable', ['imgtype', 'imgid'], ['Site', 'cover_photo'], ['Author', 'profile_pic'])\n// columnNames: ['imgtype', 'imgid']\n// morphValues: ['Site', 'cover_photo'] ['Author', 'profile_pic' ]\nThis tests 'imgtype' as a model in the registry plugin and when it doesn't finds it, decides it's a columnNames.\nWhen using the registry plugin, you could specify there are no columnNames using the null to be explicit about it.\n\nPros & Cons\nWe should also consider which one is easier to write documentation for.\nOption 1\n\n+ No trick to it, just works as expected\n- More verbose\n\nOption 2\n\n+ Less verbose\n- Could ignore some programmer errors (passing a model with a typo and the registry plugin assumes is the columnNames)\n\n\nPlease comment any pro or con I didn\u2019t consider, or any better options!\n. Ok, the following message was sent in the Gitter chat but had no response, so I'm pasting it here to see if we get some responses:\n\nHello everyone,\nI've been working in the PR #1326 to add a morphValues option for the morphTo relation. The idea is to implement the counterpart of the morphValue option for morphOne and morphMany.\nThe PR is ready functionality wise but @vellotis and I have been discussing the new API for the morphTo relation and we would like some other opinions in the subject, and would like if the addition didn't break any old Bookshelf code:\nPassing the target model and morphValue in an array of size two, kind of like columnNames (i.e. [Author, 'profile_pic']). For this options, keep the registry plugin in mind.\nThis API could have two different behaviours with columnNames (which is also an array):\nOption 1\nTo set morphValues and no columnNames: pass null in columnNames.\njs\nmorphTo('imageable', null, ['Site', 'cover_photo'], ['Author', 'profile_pic'])\n// columnNames: null\n// morphValues: ['Site', 'cover_photo'] ['Author', 'profile_pic' ]\nThis option always knows which are morphValues and which are columnNames without a doubt.\nOption 2\nTo set morphValues and no columnNames: simply pass the morphValues.\njs\nmorphTo('imageable', ['Site', 'cover_photo'], ['Author', 'profile_pic'])\n// columnNames: null\n// morphValues: ['Site', 'cover_photo'] ['Author', 'profile_pic' ]\nThis option has to test 'Site' as a model in the registry plugin and when it successfully finds it, decides it's not a columnNames.\nIf we pass a columnNames:\njs\nmorphTo('imageable', ['imgtype', 'imgid'], ['Site', 'cover_photo'], ['Author', 'profile_pic'])\n// columnNames: ['imgtype', 'imgid']\n// morphValues: ['Site', 'cover_photo'] ['Author', 'profile_pic' ]\nThis tests 'imgtype' as a model in the registry plugin and when it doesn't finds it, decides it's a columnNames.\nWhen using the registry plugin, you could specify there are no columnNames using the null to be explicit about it.\n\nPros & Cons\nWe should also consider which one is easier to write documentation for.\nOption 1\n\n+ No trick to it, just works as expected\n- More verbose\n\nOption 2\n\n+ Less verbose\n- Could ignore some programmer errors (passing a model with a typo and the registry plugin assumes is the columnNames)\n\n\nPlease comment any pro or con I didn\u2019t consider, or any better options!\n. How about a \u2764\ufe0f for option 1 and \ud83c\udf89 for option 2 as a voting system? Or comment if you prefer.\n. How about a \u2764\ufe0f for option 1 and \ud83c\udf89 for option 2 as a voting system? Or comment if you prefer.\n. Went for option \ud83c\udf89.\n. Bump!. Bump for new maintainers: @Playrom. I would be glad to see this in Bookshelf.. Done, @Playrom. I had to update some expected results for the newly added DBMS.. Is that alright, @dj-hedgehog @Playrom?. Is that alright, @dj-hedgehog @Playrom?. Well, the idea is to change the morphTo API to accept this new option, but all previous use cases would work the same. As you can see in the tests, I only added the option to some relations, to show that it's used only where needed.. Well, the idea is to change the morphTo API to accept this new option, but all previous use cases would work the same. As you can see in the tests, I only added the option to some relations, to show that it's used only where needed.. I don't really understand \ud83d\ude15, does it accept withRelated?\n. The registry plugin expects either model objects or strings with the name you registered the model:\n``` js\n// User.js\nvar bookshelf = require('../config/bookshelf');\nvar User = bookshelf.Model.extend({\n  tableName     : 'users',\n  hasTimestamps : true\n// rest of model ...\n});\nmodule.exports = bookshelf.model('User', User);\n```\n``` js\n// Project.js\nvar bookshelf = require('../config/bookshelf');\nvar Project = bookshelf.Model.extend({\n  tableName     : 'projects',\n  hasTimestamps : true,\nuser : function() {\n    return this.belongsToMany('User');  // <--- here\n  },\n  // rest of model ...\n});\nmodule.exports = bookshelf.model('Project', Project);\n```\nNotice that there are no requires for User in the Project file.\nWhat I imagine could be happening is that you require('./Users') in the Project \nfile and require('./Projects') in the User file, son when Project is being parsed\nby Javascript it hasn't yet parsed the User so it doesn't know what it is yet.\nResolve this by using strings instead of the Model objects and stop the cyclic requires (which is exactly what the registry plugins works for). \n. I think this is currently not possible in bookshelf, but I think it could be a valuable addition. If so, maybe I can give it a go at implementing it!\n. I think this is currently not possible in bookshelf, but I think it could be a valuable addition. If so, maybe I can give it a go at implementing it!\n. Closed with #1397\n. Hey @ricardogama, look at the solution I was going for in #1407. I already handled the eager case for belongsTo: consider how I did it since it was hard to track the source of it not loading the model in eager but loading in normal fetch.\nI think it may be easier to write the value of the new foreignKeyTarget on targetIdAttribute instead of checking for a new foreignKeyTarget and the current code already makes it work by itself. Just a comment :)\n. Awesome, @ricardogama! I'll be looking forward to this merge!\n. I think this could be applied to other relations, but I'm not sure. Also, the targetIdAttribute could be changed to targetKey, because is no longer only the idAttribute.\n. This PR is almost ready. @ricardogama, I know you said you were working on it, but I'm in a bit of a hurry \ud83d\ude04, hope it isn't a problem.\nI was writing tests for the through options and it seems there's some problems with the otherKey option, it's either ignoring it or I don't understand what it does.\n@vellotis, please take a look for any feedback, I wrote tests for belongsTo, hasMany hasOne belongsToMany and belongsTo.through but the problems appeared with hasMany.through so I stopped there.\n. Could we maybe discuss what's the expected behaviour / API for through relations to achieve a better solution, I'm not even sure what the extra parameters to through do exactly.\n. What about merging and removing babel if the issue resolves to that later?. @Playrom I think this small refactoring will make modifying the registry plugin going forward easier.. A problem I have had with contributing to Bookshelf in the past is that I find that much functionality is handled in a single method of a class. There are many types of Relations, but try to handle them all in a single Relation class, so that class has to do a lot of checks in the methods. That makes reading the code really hard.\nDoing #1407 was really hard because when trying to find where something was being done, it was all abstracted into methods inside methods, like nothing really does anything, just delegates the problem further down. This PR was then closed in favor of #1397, but I lived the experience even if it wasn't merged.\nI think this project could benefit from removing a bit of that abstraction and handling specific cases with specific solutions, instead of trying to abstract everything into one class and make it handle the complexity.\nI know this may look like a rant and of bad taste, I really ask that you do not take it that way, instead I just wanted to give my point of view on how contributing was since I see so many people with intentions to make this a great project again.. @maxnordlund, I also like SQLy abstractions more than JSy asbtractions, you are ultimately querying a DB, so why hide it?\nI recommend using Objection.js for this point of view. Where I work, we are currently migrating our backend from Bookshelf to Objection.js and for our case and preferences (we like SQL a lot), is perfect.. You could useparse with format\nparse(attrs) {\n  attrs.id = econde(attrs.id); // _.update(attrs, 'id', encode);\n  return attrs;\n}\nformat(attrs) {\n  attrs.id = decode(attrs.id); // _.update(attrs, 'id', decode);\n  return attrs;\n}. Another alternative is using the Visibility plugin:\nModel.extend({\n  hidden: ['id'],\n  parse(attrs) {\n    attrs.enconded_id = encode(attrs.id);\n  },\n  submodules() {\n    return this.hasMany(Modules, 'parent_id', 'id');\n  }\n})\nThat way you create relationships using id but the users only see enconded_id.. This would mean both:\njs\nlet Photo = bookshelf.Model.extend({\n  tableName: 'photos',\n  imageable: function() {\n    return this.morphTo('imageable', [\"ImageableType\", \"ImageableId\"], [Post, \"cover\"], Site);\n  }\n});\nand\njs\nlet Photo = bookshelf.Model.extend({\n  tableName: 'photos',\n  imageable: function() {\n    return this.morphTo('imageable', [Post, \"cover\"], Site);\n  }\n});\nWould be valid?\n. Hey, but these changes do not change the original API, only change it if the morph values are specified (which wasn't part of the API before).\nThe call this.morphTo('imageable', Site, Author) continues to be valid (the registry plugin version also continues to be valid), the condition isArray(arguments[1]) will give false, which effectively drops only one argument (imageable) and sets column names as null\n. I actually had it like that before and thought it would be more readable this way, I can change it back, what do you think?\n. I think I'm not conveying my point. I'll give some examples with their results to see if we agree:\n``` js\nmorphTo('imageable', 'Site', 'Author')\n// columnNames: null\n// morphValues: ['Site', 'sites'] ['Author', 'authors' ]\nmorphTo('imageable', 'Site', ['Author', 'profile_pic'])\n// columnNames: null\n// morphValues: ['Site', 'sites'] ['Author', 'profile_pic' ]\nmorphTo('imageable', null, ['Site', 'cover_photo'], ['Author', 'profile_pic'])\n// columnNames: null\n// morphValues: ['Site', 'cover_photo'] ['Author', 'profile_pic' ]\nmorphTo('imageable', ['Site', 'cover_photo'], ['Author', 'profile_pic'])\n// columnNames: ['Site', 'cover_photo']\n// morphValues: ['Author', 'profile_pic' ]\nmorphTo('imageable', null, 'Site', ['Author', 'profile_pic'])\n// columnNames: null\n// morphValues: ['Site', 'sites'] ['Author', 'profile_pic' ]\n```\nNOTE: these examples all use the registry plugin, but would have the same behaviour passing the model objects.\nSo no old code would break (first example), but we need null for specifying morphValues for each model.\nWhat would you have expected differently from these or am I missing some case?\n. I don't know if making the registry and non-registry calls work differently is a good idea.\nMaking these:\n``` js\nmorphTo('imageable', [Site, 'cover_photo'], [Author, 'profile_pic'])\n// columnNames: null\n// morphValues: [Site, 'cover_photo'] [Author, 'profile_pic']\nmorphTo('imageable', ['Site', 'cover_photo'], ['Author', 'profile_pic'])\n// columnNames: ['Site', 'cover_photo']\n// morphValues: ['Author', 'profile_pic']\n```\nwould make migrating from a non-registry code to code with registry more difficult.\n. This line seems to make no difference if it's null or 'language_iso_code'\n. Why not do instead:\njs\nparse: function(attrs) {\n  return _.mapKeys(attrs, (, k) => _.camelCase(k));\n}. ",
    "bogas04": "Sorry if it's off topic, but is there official doc for using ES6 class syntax with Model.extend now that several months have passed ?\n. ",
    "kripod": "I started to work on a Knex-based ORM which aims to provide easy model integration with ES6+:\nhttps://github.com/kripod/knexpress\nMy goal is to achieve feature parity with Bookshelf.js with as few lines of code as possible.\n. @henryboldi Well, Knexpress mounts every Knex method dynamically, while Bookshelf has a predefined set of functions to operate from. Bookshelf was not built to utilize ES6 classes natively, that's why I decided to create a project of my own.\nBesides the points above, I would also be very glad to see my class-related ideas being implemented to Bookshelf. (At the moment, I'm working on implementing support for relations in Knexpress.)\n. https://github.com/tgriesser/bookshelf/issues/1089\nThere is no need for an extra query, see my last line mentioning the solution\n. As an even better temporary solution, I override the Model object:\njs\nlet proto = bookshelf.Model.prototype;\nbookshelf.Model = bookshelf.Model.extend({\n  save: function () {\n    return proto.save.call(this, arguments)\n      .then((res) => {\n        // Fixes bookshelf #1076\n        return new this.constructor(res.attributes, { parse: true });\n      });\n  }\n});\nThus, the following code should return the properly formatted object:\njs\nnew User({name: 'Ann'})\n  .save()\n  .then((user) => { return user; })\n  .then((user) => { return console.log(user); });\n. Whoops, it looks like this is a duplicate of #1076\n. No, I mean that every kind of custom validator function could be used. But your idea is also compelling to me.\n. Also, I'd like to use this functionality to store and validate objects crafted from a REST API request, for example, in express:\n``` js\nlet user = new User({\n  username: req.body.username,\n  email: req.body.email\n});\nif (!user.validationErrors()) {\n  // Hooray, there are no validation errors!\n  user.save();\n}\n```\n. Here is some code I crafted for validation purposes using the most popular validation package available:\n``` js\nimport bookshelf from 'bookshelf'\nimport validator from 'validator';\nlet Orm = bookshelf(); // Add a knex instance here\nOrm.Model = Orm.Model.extend({\n  validationErrors: function () {\n    let output = {};\nfunction addError(propertyName, errorName) {\n  let propertyErrors = output[propertyName] || [];\n  propertyErrors.push(errorName);\n  output[propertyName] = propertyErrors;\n}\n\n// Validate every rule of each property with the optionally given arguments\nfor (let propertyName in this.validations) {\n  let propertyValue = this.get(propertyName);\n  let validation = this.validations[propertyName];\n  if (propertyValue == null) {\n    // Handle the 'isRequired' property\n    if (validation.isRequired) {\n      addError(propertyName, 'isRequired');\n    }\n\n    // Step to the next validatable property\n    continue;\n  }\n\n  for (let functionName in validation) {\n    // Skip special validation functions\n    if (functionName === 'isRequired') {\n      continue;\n    }\n\n    // The argument can be a boolean for argumentless validation, or an\n    // array of options passed to the validator\n    let args = validation[functionName];\n    let isValid = new Function(\n      'validator',\n      'return ' + (\n        typeof args === 'boolean' ?\n          `validator.${functionName}('${propertyValue}') == ${args}` :\n          `validator.${functionName}('${propertyValue}', ${args.join()})`\n      )\n    )(validator);\n\n    // Handle validation errors if needed\n    if (!isValid) {\n      addError(propertyName, functionName);\n    }\n  }\n}\n\nreturn Object.keys(output).length > 0 ? output : null;\n\n}\n});\n```\nOrm.Model.validationErrors() returns an object which contains all the validation errors grouped by properties. For example:\njs\n{\n  email: ['isRequired', 'isEmail'],\n  username: ['isAlphanumeric']\n}\n. I have implemented my idea as a separate bookshelf plugin:\nhttps://github.com/kripod/bookshelf-validate\n. Thanks for the reply! Then, there could be a boolean option for initializing Bookshelf instances, indicating whether automatic case conversion should happen.\n. @ricardograce I'm sorry, but unfortunately, I lost my interest for this project.. ",
    "dantman": "Does es6 extends copy static getters as-is?\nIf so, couldn't the SomeModel.NotFoundError be handled by making NotFoundError a memoized getter that creates the subclass of NotFoundError from this.. Does es6 extends copy static getters as-is?\nIf so, couldn't the SomeModel.NotFoundError be handled by making NotFoundError a memoized getter that creates the subclass of NotFoundError from this.. > If you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nThe importance of this issue should be self-evident. Bookshelf classes still require custom functions to create classes and don't work with ES6 classes and all their new features. Things like the classProperties on extends are obsolete ways of doing things and the extends don't allow you to create getters/setters.. > If you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nThe importance of this issue should be self-evident. Bookshelf classes still require custom functions to create classes and don't work with ES6 classes and all their new features. Things like the classProperties on extends are obsolete ways of doing things and the extends don't allow you to create getters/setters.. > If you think this issue needs to be re-evaluated please post a comment on why this is still important and we will re-open it.\nKnex being unmaintained hasn't changed how verbose transacting is.. @kirrg001 @ErisDS @vellotis . No, babel files simply apply to all files in the directory they are in and sub-directories under them. So moving .babelrc to src/ only changes things so that the .babelrc doesn't apply to anything outside of src/. And from what I can see your tests and the root bookshelf.js do not use transpiled syntax.. Note that react-native has its own set of babel features automatically transpiled. If you use any features that Node adds support for but react-native doesn't include in the set of features to transpile, then bookshelf will break in react-native anyways even if you try to fix things this way.. > @dantman I don't think Bookshelf aims to support react-native, unless I'm missing something.\nReact Native has a sqlite library, you can add a custom driver to knex to integrate support, and knex has already accepted a PR related to react-native support. I see no reason not to support react-native.. > Two hours of bug-checks with failed tests because I didn't execute \"npm run build\" after every change.\n\nWhy is build not automatically run before every test?\n\nYou don't need to ditch babel to run tests without running build, you just use babel-register.. > Two hours of bug-checks with failed tests because I didn't execute \"npm run build\" after every change.\n\n\nWhy is build not automatically run before every test?\n\nYou don't need to ditch babel to run tests without running build, you just use babel-register.. \n",
    "rockingskier": "Hi @rhys-vdw, thanks for the reply.\nAlthough I can't get this working at the moment I think I can see what the aim is.\nI had previously been using a through model (extending my BaseModel) as this seemed very logical to me however I could not access any of the pivot data.  There are very few (if any) examples of accessing through data during a fetch.\nI had asked on Stack Overflow but it was suggested I remove the through model which then brought me to the formatting issue.\nThis was my initial plan of attack:\n``` javascript\n  var RecipeIngredient = BaseModel.extend({\n    tableName: 'recipe_ingredients',\ndefaults: {\n  measurement: null,\n  sortOrder: null,\n  recipeId: null,\n  ingredientId: null\n},\n\nrecipe: function () {\n  return this.belongsToMany('Recipe');\n},\n\ningredient: function () {\n  return this.belongsToMany('Ingredient');\n}\n\n}));\n```\njavascript\n  // Recipe\n  ingredients: function () {\n    return this\n      .belongsToMany('Ingredient')\n      .through(['RecipeIngredient']);\n  }\nDuring a fetch I cannot see measurement or sortOrder.\nI feel like I am either missing some crucial information or the point of this. :(\n. TBH I don't know which data structure I prefer.  I don't really like the the extra nesting or the _pivot_ prefix but I need to pick one that fits this situation the best.  Normally I would probably stick with nested however flattened feels \"better\" in this instance.\nI have tried 3 options, withPivot, through and through.withPivot.\n.withPivot(['measurement'])\njson\n{\n   \"id\": 1,\n   \"name\": \"Banana Cake\",\n   \"ingredients\": [\n     {\n       \"id\": 1,\n       \"name\": \"Banana\",\n       \"_pivot_recipe_id\": 1,\n       \"_pivot_ingredient_id\": 1,\n       \"_pivot_measurement\": \"2\",             \"<--\": \"Measurement\"\n     }\n   ]\n }\n.through('RecipeIngredient')\njson\n{\n   \"id\": 1,\n   \"name\": \"Banana Cake\",\n   \"ingredients\": [\n     {\n       \"id\": 1,\n       \"name\": \"Banana\",\n       \"_pivot_id\": 1,                           \"<--\": \"ID\",\n       \"_pivot_recipe_id\": 1,\n       \"_pivot_ingredient_id\": 1\n     }\n   ]\n }\n.through('RecipeIngredient').withPivot(['measurement'])\njson\n{\n   \"id\": 1,\n   \"name\": \"Banana Cake\",\n   \"ingredients\": [\n     {\n       \"id\": 1,\n       \"name\": \"Banana\",\n       \"_pivot_id\": 1,                           \"<--\": \"ID\",\n       \"_pivot_recipe_id\": 1,\n       \"_pivot_ingredient_id\": 1\n     }\n   ]\n }\nAs you can see I when the through is used no other pivot data is returned and the id of the pivot table is returned.\nIf you are interested I've dropped the code into a repo, its highly simplified and contains a pre-populated DB for you entertainment.\n. Thanks for your help!\nI'll certainly try and put something together for you although it might take a few weeks to get to (currently on hols)\n. ",
    "jdstep": "To clarify: \"JavaScript\" was misspelled as \"javascript\" three times in the index.html. This commit fixes the spelling.\n. ",
    "ezra-quemuel": "``` javascript\nvar Target = bookshelf.Model.extend({\ndataset: function() {\n    return this.belongsTo(Dataset, 'dataset_id');\n  },\n});\nvar TargetCollection = bookshelf.Collection.extend({model: Target});\nvar Dataset = bookshelf.Model.extend({\ntarget: function() {\n    return this.hasMany(TargetCollection);\n  },\n  schema: function() {\n    return this.hasMany(SchemaCollection);\n  }\n});\nvar Schema = bookshelf.Model.extend({\ndataset: function() {\n    return this.belongsTo(Dataset, 'dataset_id');\n  },\n});\nvar SchemaCollection = bookshelf.Collection.extend({model: Schema});\n```\nThese are the definitions (though not necessarily defined in that order). Is that enough info?\n. still seem to be having the same issue..\n. javascript\n{ method: 'select',\n  options: {},\n  bindings: \n   [ 'tiny.csv',\n     'COMPLETE',\n     { '135': [Object] },\n     Tue Jun 09 2015 17:32:46 GMT-0700 (PDT),\n     Tue Jun 09 2015 17:32:58 GMT-0700 (PDT),\n     1,\n     1,\n     1,\n     38,\n     '38',\n     1 ],\n  sql: 'select \"dataset\".* from \"dataset\" where \"dataset\".\"name\" = ? and \"dataset\".\"description\" is null and \"dataset\".\"status\" = ? and \"dataset\".\"labels\" = ? and \"dataset\".\"created_at\" = ? and \"dataset\".\"modified_at\" = ? and \"dataset\".\"created_by\" = ? and \"dataset\".\"modified_by\" = ? and \"dataset\".\"owner_id\" = ? and \"dataset\".\"id\" = ? and \"dataset\".\"metadata\" is null and \"dataset\".\"id\" = ? limit ?' }\nthere are some columns i omitted from the model definition present in the query (on purpose)\n. One more note: This seems to happen when I try to run a fetch() on a related() model twice, meaning:\njavascript\ntargetInstance.related('dataset').fetch().then(function () {\n  return targetInstance.related('dataset').fetch({\n    withRelated: [{\n                'schemas': function (qb) {\n                    qb.limit(1);\n                    qb.orderBy('modified_at', 'DESC');\n                }\n            }]\n  });\n});\nNot actually using this code but this seems to be the way to consistently reproduce it on my end. I will work on getting a test case running with it tomorrow.\n. So what I'd like is to have a \"type\" column so that when i do something like:\njs\nUser.forge({id: 7}).fetch().then(function (user) {\n   //here user would be either a \"Student\" or \"Employee\" model that inherits from User\n   //based on the \"type\" defined\n});\n. Right, but lets say at the time of fetching the model instance i dont know whether I should be using the Employee model or the Student model (which may share some of the same methods defined with different behavior). Given a user id, I'd like to be automatically load the appropriate model (in this scenario either \"Student\" or \"Employee\").\nhow do I make sure that User is instantiated as a Student/Employee based on the \"type\" defined? (its not an external relationship).\n. I have a section of code that sends a message to a User.  It does not know if that User is a student or an employee.  In the case it is an employee it needs to run extra functionality.  In previous platforms with STI I have built something like:\nfunction updateUser(userId, updateMessage){\n  User.forge({id: userId}).fetch().then(function (user) {\n    user.functionFoo(updateMessage);\n  });\n}\nWhere functionFoo is implemented on both Student and Employee models, with the Employee having the extra functionality I need executed.  Currently in Bookshelf this would execute User.functionFoo and not the child class (as defined by type).\n. Using this case:\nconst User = bookshelf.Model.extend({\n  fetch() {\n    return super.fetch().then(handleUserFetched);\n  }\n});\nWould it be possible to return the new Model without re-fetching? The idea is that if there are event handlers defined that it only triggers the subModel handlers.\nsuch as:\n```\nconst User = bookshelf.Model.extend({\n  initialize() {\n    this.on('fetched', //do something);\n  }\nconst Student = User.extend({\n  initialize() {\n    this.on('fetched', //do something else);\n  }\n```\nThe intended behavior is to have event handlers from Student fire and not User.\n. ",
    "mborst": "I think this issue is still valid, for exactly the reason it states.. Thanks! But I think using format here is kind of sub-optimal. Seems very unintuitive to really modify the data there. Plus how would I pass in the date into format?\nFor now I have written a plugin that patches hasTimestamp in the suggested way, which makes the most sense imho. Or do you disagree with the general idea of this suggestion?. It's not about formatting it, I would really change it! Plus, I would also need to pass the timestamp I want to use into format, which would be a far bigger change.\nTo maybe make what I want to achieve more clear:\nhttps://github.com/estate/bookshelf-paranoia/pull/21. Halfway. I also want to use it for the updated_at timestamp. That's why I wrote a plugin that applies the patch mentioned above (picking the user supplied date from options). That way, I can use the same interface as the paranoia plugin allows (see here). Ok, so this would be the PR: #1592. If you agree with it in principle, I could provide tests and documentation.. Ok, so this would be the PR: #1592. If you agree with it in principle, I could provide tests and documentation.. To be honest, I don't agree that the other PR fixes this issue. This PR is actually not even a fix, but rather a feature. I also think that while allowing to overwrite those fields explicitly as done in #1583 is fine, using this in place of the feature presented here is against the concept of the hasTimestamp feature, which handles the selection of the proper field to touch (createdAt vs updatedAt). Now, the client code always has to figure out if the operation will be an insert or an update, which is unnecessary in the solution presented here. WDYT?. The idea is that in some cases one wants to control what bookshelf thinks of as now, e.g. when you write state changes to two different places, like the db and a log. Now that #1583 is merged, you could manually do that, but that would not have the same convenience as using hasTimestamp, which handles updating the correct timestamp, i.e. updated_at on update, created_at on insert. IMHO, the feature proposed here is the sweet spot. . I also noticed that the other PR was merged with failing tests. I fixed the indent there.. Ok, then linting is not part of the test suite. You could consider adding it.. Thanks for taking the time!\nI still can't quite figure out what happened with the other merge, because from a quick glance at the package.json it seems like the linting is run in the CI. But e367622 fixes wrong indentation that could be merged into master... will investigate when I find the time.. @ricardograca I disagree with the notion that options.date should be deprecated. Why do you think so?\nI assume you think that manually setting createdAt and updatedAt when saving takes care of this, but don't i have to be always aware if the record is currently created or updated then? That was my motivation when introducing this feature: I can stupidly pass in date: myIdeaOfWhatTimeItIs in every save call in my application code and the library then takes care that this timestamp is used where applicable!. @ricardograca I disagree with the notion that options.date should be deprecated. Why do you think so?\nI assume you think that manually setting createdAt and updatedAt when saving takes care of this, but don't i have to be always aware if the record is currently created or updated then? That was my motivation when introducing this feature: I can stupidly pass in date: myIdeaOfWhatTimeItIs in every save call in my application code and the library then takes care that this timestamp is used where applicable!. I am using this in practice as stated: I pass in myIdeaOfWhatTimeItIs everywhere as date, and assume that the library takes care of handling the rest.\nIn my opinion, I shouldn't have to care about what exactly the library will do in my application code. My brain is already full with the application logic. I know the library will set the right fields, because the developer (in this case I) spent time thinking about it once and took care that in any case, the right timestamps are filled with the right values. That's what I mean by \"stupid\": I don't need to care, because it has been solved once.. Updated.. ",
    "ashleygwilliams": ":+1: \n. ",
    "JbIPS": "Yeah, just saw that, I'm working on a fix right now ;)\n. All green ! :)\n. You're welcome! Did you have a new patch release on npm planned? Just to know if I need to link to git or not\n. ",
    "terfex": "Cheers, it looks like some work is being done on Microsoft SQL in knex as well. https://github.com/tgriesser/knex/issues/240\n. No probs.\nFrom: Rhys van der Waerden [mailto:notifications@github.com]\nSent: Monday, 15 June 2015 12:02 PM\nTo: tgriesser/bookshelf\nCc: Tom G. Foxwell\nSubject: Re: [bookshelf] Support for other SQL databases (#791)\nYeah, or at least it was discussed 5 months ago. If you want to follow this up further try over at knex. I'm going to close this one. Cheers.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/tgriesser/bookshelf/issues/791#issuecomment-111898495.\n. ",
    "dxuehu": "Awesome :) thanks. Looking forward to the new docs!\n. ",
    "epeli": "Awesome,  thanks! \n. ",
    "thaume": "Yep I do load them at application start, I was just wondering how I am supposed to register them so I can do bookshelfInstance.plugin('registry');\n. Hey @rhys-vdw thanks! This is exactly what I was looking for! I guess I could have read the code a little more :)\n. Well I always read the doc :) (pushing many people to do it daily, it would be a shame not to apply it to myself haha).\nYes exactly, the base model can get huge. I would also like to build a collection of serializers based on the needs of each apps.\nThanks again, have a nice day !\n. ",
    "secretfader": "Any information on how to handle that last case? If I could ensure that it all happens during the same transaction cycle, that definitely sounds like the preferred method. \nAnd thanks for that great sample. You rock!\n. @rhys-vdw All good here. Thanks for following up! \n. ",
    "andre1sk": "You need to have a unique constraint in DB, transaction isolation level has very little to do with your issue. The only way you could insure there is no race condition without having a unique constraint is to write lock table before checking and releasing lock after the save.\n. Unfortunately the only way is to write lock a table and that would be a very bad idea. Serializable does not prevent writing new rows to a table. It makes sure that data your transaction selects is not changed by other transactions. (You could structure a select in serializable transactions in such a way that it would effectively lock the table). In any case the only thing you would achieve is DB throwing a could not serialize access error instead of unique constrain violation error.\n. ",
    "abalmos": "@rhys-vdw I like your suggestion. Setting values on the model and persisting changes back to a database are different and the API ought to reflect that.\nI often find myself wanting to call set several times throughout application logic and then persist it all back once at the end (as a 'patch').\n. In the past I've had to do something like:\n``` js\nvar RELATIONSHIP_REGEX = /(hasOne(|hasMany(|belongsTo(|belongsToMany()/;\nif (_.isFunction(target[relationName]) && \n    target[relationName].toString().match(RELATIONSHIP_REGEX)) {\n        relation = targetrelationName;\n}\nif (!relation) throw new Error(relationName + ' is not defined on the model.'\n```\nTo avoid issues when relationName and names of helper methods on the model clash.\nIf someone has a better solution, I would love to hear it.\n. @rhys-vdw I have needed to use that code as part of a REST API that \"auto-expands\" relations based on a query parameter that enumerates what keys should be returned. Bookshelf throws when you ask for a relation that doesn't exist and my field can include keys that are not relations. Therefore, to call load correctly I had to filter the key list down to just the names that are truly relations. I didn't want to manage both a list of valid relations and the relation methods.\nIt may be that this is out of scope for Bookshelf and should be handled by a higher layer (I have it in a custom plugin). \n+1 on relations not be defined as instance methods. The current design is not only strange, it forces me to carefully avoid name conflicts between by instance methods and column names. Typically you don't notice the issue until runtime. \n. :+1: on the proposed PR \n. ",
    "fereidani": "yes , for sure , it's look better , thanks\nbut if we're sure all the arguments are functions it's better performance strategy to use (elem !== undefined).\ni suggest  : \n```\n      if ((target[relationName])!==undefined) {\n        relation = targetrelationName;\n      }\n  if (!relation) throw new Error(relationName + ' is not defined on the model.');\n\n```\n. tnx @rhys-vdw .\ni will update it asap.\n. hi i send another pull request , sorry for delay .\n. hi i send another pull request , sorry for delay .\n. i think problem is in relation.js :\n```\n  init: function(parent) {\n    this.parentId          = parent.id;\n    this.parentTableName   = .result(parent, 'tableName');\n    this.parentIdAttribute = .result(parent, 'idAttribute');\nif (this.isInverse()) {\n  // use formatted attributes so that morphKey and foreignKey will match\n  // attribute keys\n  var attributes = parent.format(_.clone(parent.attributes));\n\n  // If the parent object is eager loading, and it's a polymorphic `morphTo` relation,\n  // we can't know what the target will be until the models are sorted and matched.\n  if (this.type === 'morphTo' && !parent._isEager) {\n    this.target = Helpers.morphCandidate(this.candidates, attributes[this.key('morphKey')]);\n    this.targetTableName   = _.result(this.target.prototype, 'tableName');\n    this.targetIdAttribute = _.result(this.target.prototype, 'idAttribute');\n  }\n  this.parentFk = attributes[this.key('foreignKey')];\n} else {\n  this.parentFk = parent.id;\n}\n\n```\nproblem is here : this.parentFk = attributes[this.key('foreignKey')];\nthis.parentFk does not set correctly .\ni can't solve it yet ... need some help ... tnx\n. @rhys-vdw thank you for your answer .\ni think we have 3 choices .\n1.throw an error for developers to understand they should include foreign key in select list\n2.write a fallback function for when foreign key or keys are not fetched from table like this :\nif foreign key(s) is(are) not defined\n    fetch foreign keys via Id parameter(s)\n then\n   fetch relations\n3.force select foreign key(s) ( not really my choice )\ni can help to write any of these but all of them have advantage and disadvantage .\nFirst one cons :\nLosing plasticity\nSecond one cons :\nRun extra query\nThird one cons :\nUnexpected results\nData Leakage (Security problems)\nLittle overhead\nPersonally i'll go with first one .\nI would be happy to hear your opinion .\n. ",
    "rocketmannot": "Hi @rhys-vdw, thank you for amazingly quick response. I am looking forward for updated docs.\n. ",
    "kisayista": "Things are a little busy over the next couple of days work-wise, but I should have a test case by the end of the week. Thanks @rhys-vdw.\n. ",
    "chubas": "+1, encountered this issue and the workaround worked for me. I'm with the idea of throwing a warning at first until the underlying problem is solved, but I agree this is more an edge case.\n. ",
    "austingray": "+1 on throwing a warning or throwing some examples up in the docs, woulda saved a newbie like me a few hours :smoking: \n. I second this feature request, it is exactly what I'm trying to do, but I'm also trying to insert into each object.\n. I second this feature request, it is exactly what I'm trying to do, but I'm also trying to insert into each object.\n. @rhys-vdw Thank you so much for the response. I will play with this and let you know how it goes.\n. @rhys-vdw Thank you so much for the response. I will play with this and let you know how it goes.\n. Haven't been able to get this to work but then again my understanding of how it all works is pretty weak. Here is a gist of my problem if that helps at all. https://gist.github.com/austingray/707b7dd4798ed958a638. I have created a workaround for my particular problem, but I don't know how scalable it is.\n. Welp I'm back to needing help with this same query. This query has been the bane of my app. Anyway, I kind of spell it out here: http://stackoverflow.com/questions/32540746/accessing-nested-relations-in-bookshelf-js - any insight into how to make the above work for this particular problem would be greatly appreciated.\n. ",
    "gordysc": "Ah, great @rhys-vdw , thanks for the detailed explanation!  Looking forward to #814!\n. Oh, awesome!  I like this approach 10x better than doing my own serialize function.  Thanks @rhys-vdw !!\n. Yup, I am using all 3 plugins haha.  Love them.\n. ",
    "jturn": "Glad to help!\n. ",
    "emaddoma": "Never mind.  I refactored to this...\n```\nmodule.exports = bookshelf.model('User', bookshelf.Model.extend({\n    // db table\n    tableName: 'users',\n    // properties that should not be exposed\n    hidden: ['email', 'password'],\n    // relationships\n    accounts: function() {\n        return this.hasMany('AccountUser', 'user_id');\n    }\n}));\nmodule.exports = bookshelf.model('AccountUser', bookshelf.Model.extend({\n    tableName: 'account_users',\n    //relationships\n    user: function() {\n        return this.belongsTo('User', 'user_id').query(function(q){\n            q.where('disabled', false);\n        });\n    },\n    account: function() {\n        return this.belongsTo('Account', 'account_id');\n    },\n    role: function() {\n        return this.belongsTo('Role', 'role_id');\n    },\n    rights: function() {\n        return this.belongsToMany('Right').through('AccountUserRight');\n    }\n}));\nnew User({\n    email: username.toLowerCase().trim()\n}).fetch({\n    withRelated: ['accounts','accounts.role','accounts.account','accounts.rights','facilities']\n})\n```\n. Never mind.  I refactored to this...\n```\nmodule.exports = bookshelf.model('User', bookshelf.Model.extend({\n    // db table\n    tableName: 'users',\n    // properties that should not be exposed\n    hidden: ['email', 'password'],\n    // relationships\n    accounts: function() {\n        return this.hasMany('AccountUser', 'user_id');\n    }\n}));\nmodule.exports = bookshelf.model('AccountUser', bookshelf.Model.extend({\n    tableName: 'account_users',\n    //relationships\n    user: function() {\n        return this.belongsTo('User', 'user_id').query(function(q){\n            q.where('disabled', false);\n        });\n    },\n    account: function() {\n        return this.belongsTo('Account', 'account_id');\n    },\n    role: function() {\n        return this.belongsTo('Role', 'role_id');\n    },\n    rights: function() {\n        return this.belongsToMany('Right').through('AccountUserRight');\n    }\n}));\nnew User({\n    email: username.toLowerCase().trim()\n}).fetch({\n    withRelated: ['accounts','accounts.role','accounts.account','accounts.rights','facilities']\n})\n```\n. Interesting approach.  Thanks for the response!\n. Interesting approach.  Thanks for the response!\n. @jamesdixon I pretty much left it as I originally noted above.  We have so few spatial columns, we decided to just move on.  rhys-vdw's answer might be worth looking into\n. ",
    "jiminikiz": "And for the record, the above Models will cause a bug with certain queries and objects. Might be safer with:\n```javascript\n// baseModel.js\nconst bookshelf = require('bookshelf')(/ ... /)\nconst _ = require('lodash');\nmodule.exports = bookshelf.Model.extend({\n  // convert keys from snake_case to camelCase\n  parse: (attrs) => .mapKeys(attrs, (val, key) => .camelCase(key)),\n// convert keys from camelCase to snake_case\n  format: (attrs) => .mapKeys(attrs, (val, key) => .snakeCase(key))\n});\n```. ",
    "ardsouza": "Not exactly. I'm saying that if your Model contains an idAttribute like\njs\nvar User = db.Model.extend({\n  tableName: 'users',\n  idAttribute: 'user',\n})\nand you initiate and save your model with\njs\nUser.forge({user: 'something'}).save()\nyou will receive the error 'No Rows Updated' because User.isNew() returns false\nedit: I'm using this schema so maybe this could be the issue\njs\nbookshelf.knex.schema.createTable('users', function(table) {\n    table.string('user', 255).primary();\n})\n. I would decouple isNew() from id. Adding a new property to the base Model that handles isNew() would have no effect on existing functionality as far as I can tell. Beyond that I'm not sure and would have to read a bit more into how this is currently being handled.\n. For whatever reason\njs\nUser.forge({user: 'something'}).save(null, {method: 'insert'});\nsets the createdAt property of the table entry to nothing\n. 0.8.1\n. ",
    "damiandennis": "This feature seems a little strange and is based on the assumption that all tables in the database use an auto-increment id. I have some tables which would not make sense having an extra autoincrement id when the key getting inserted is unique, I suppose It is easy enough to work around this limitation, +1 for the withId(5).\n. This feature seems a little strange and is based on the assumption that all tables in the database use an auto-increment id. I have some tables which would not make sense having an extra autoincrement id when the key getting inserted is unique, I suppose It is easy enough to work around this limitation, +1 for the withId(5).\n. ",
    "Malgalad": "@ricardograca, the intended result is that we fetch limit with offset rows from table_Bs, but fetch only those rows that satisfy where condition in table_As (through many-to-many relation). In SQL it looks like\nselect \"table_Bs\".\"info\" from \"table_Bs\" inner join \"table_A_table_B\" on \"table_Bs\".\"id\" = \"table_A_table_B\".\"table_B_id\" inner join \"table_As\" on \"table_As\".\"id\" = \"table_A_table_B\".\"table_A_id\" where \"table_As\".\"key\" = ? limit ?\nAs for select - yeah, my bad, it should be in query builder on in columns.\n. @ricardograca Yeah, that's right. That's a shame. At least, if I have to use Knex querying, can I get relations from model, so that I don't need to write them manually? In other words, if I have some model\nvar model = bookshelf.model('Table_B', {\n  tableName: 'table_B',\n  tableA: function() {\n    return this.belongsToMany(bookshelf.model('Table_A'));\n  }\n});\ncan I transform this model.tableA into query code that I can use in knex query builder?\nqb.innerJoin('table_A_table_B', 'table_Bs.id', 'table_A_table_B.table_B_id');\nqb.innerJoin('table_As', 'table_As.id', 'table_A_table_B.table_A_id');\n. ",
    "Nodiril": "I have been facing this issue and the solution I thought was best is to first fetch table_a id's.\nYou can the do something like\nbookshelf.model('Table_b').query({limit: 10, offset: 0}).fetchAll({\n  withRelated: ['table_A_table_B', {\n    'table_A_table_B.table_As': function (qb) {\n      qb.where('table_As.id', 'in' , tables id's fetched previously)\n    }\n  }],\n  columns: ['info']\n}). ",
    "halfdan": "@rhys-vdw Correct. \n. @rhys-vdw Good point - previousAttributes is accessible, so I guess this is a no-issue. Thanks for the quick responses!\n. ",
    "PaulOlteanu": "With knex's schema building, I created a user table with an id column, and an email column (amongst other things):\njavascript\nbookshelf.knex.schema.hasTable('users').then(function(exists) {\n    if (!exists) {\n        return bookshelf.knex.schema.createTable('users', function(table) {\n            table.increments('id').primary();\n            table.text('email').unique().notNullable();\n            // More stuff\n        });\n    }\n});\nMy user model is (currently) as follows:\njavascript\n    var User = bookshelf.Model.extend({\n    tableName: 'users',\n    initialize: function() {\n        this.on('creating', function() {\n            return bluebird.all([this.genSalt()]);\n        });\n        return false;\n    },\n    validateSave: function() {\n        // TODO: Checks to prevent invalid users\n        return true;\n    },\n    genSalt: function(cb) {\n        var self = this;\n        return bcrypt.genSaltAsync()\n            .then(function(salt) {\n                self.set('salt', salt);\n            });\n    },\n    hashPassword: function() {\n        // TODO\n        return true;\n    }\n});\nThe problem is that when I implement the validation function, I don't know of a way to prevent the database from actually trying to save the user. For example, if I create 2 users with the same email, the user won't be saved, but the next user I create will have an id of 3 instead of 2 (because id got incremented from the invalid user)\nIs there a way to stop the save from inside validateSave, or from the event handler for the creating event to prevent this from happening?\n. For some reason, that also adds _pivot_store_id, and _pivot_item_id. Even if I specify columns in the fetch to be ['name', 'description']\nAlso, is there another way to ask for help other than filling your repo with issues?\n. For some reason, that also adds _pivot_store_id, and _pivot_item_id. Even if I specify columns in the fetch to be ['name', 'description']\nAlso, is there another way to ask for help other than filling your repo with issues?\n. So if I have 2 variables that I need to check, I have to write multiple queries then? That's unfortunate...\n. So if I have 2 variables that I need to check, I have to write multiple queries then? That's unfortunate...\n. That's perfect. Thanks\n. ",
    "mrbeskin": "Hey, Rhys, I am also following this issue - thank you for the prompt reply. I have a follow up question. You mentioned the default idAttribute is set to \"id\". Am I correct in my understanding that there is currently not built-in support for using a non-id natural key as the primary key? \n. Hey, Rhys, I am also following this issue - thank you for the prompt reply. I have a follow up question. You mentioned the default idAttribute is set to \"id\". Am I correct in my understanding that there is currently not built-in support for using a non-id natural key as the primary key? \n. ",
    "LukeL99": "@rhys-vdw Thanks for the prompt reply. Is id required on pivot tables as well? Is this documented anywhere that I just missed? May I suggest a section on database considerations to use this framework in the documentation?\n. @rhys-vdw Thanks for the prompt reply. Is id required on pivot tables as well? Is this documented anywhere that I just missed? May I suggest a section on database considerations to use this framework in the documentation?\n. ",
    "nathanmarks": "@rhys-vdw \nI'm completely stuck on this.\nI have a table with a composite PK (through table for a many-to-many association).\nI created a model for this table so I can use my bookshelf helpers (findOrCreate, etc) but I can't do a thing with it due to returning \"id\" + no composite PK support in bookshelf.\nIs there any solution for this other than removing the bookshelf model and using raw queries for that table?\n. @rhys-vdw It worked. Awesome.\nFor some reason after reading through this thread I thought it was not supported by bookshelf -- did something change since this was posted? Or did I misinterpret something?\n. Awesome, well I appreciate the help. Works for my purpose perfectly. Thanks!\n. Is there a test for it?\n. @kripod that fix causes errors for me:\nerror: column \"0\" of relation \"reports\" does not exist\n. @ricardograca Your solution (refresh) is causing my model instance to populate with both versions (camel and snake case) of the keys (except timestamps!)\nThis is output is also coming through toJSON() which means I need to filter the data anyways to remove the snake case'd properties before returning it to an API call.\nFor eg, here is what I end up with:\n{ page_id: 20,\n      url_metrics:\n       { pageAuthority: 60.20293377897001,\n         externalEquityLinks: 0,\n         domainAuthority: 1 },\n      updatedAt: Sat Feb 20 2016 17:59:12 GMT-0500 (EST),\n      createdAt: Sat Feb 20 2016 17:59:12 GMT-0500 (EST),\n      id: 20,\n      pageId: 20,\n      urlMetrics:\n       { pageAuthority: 60.20293377897001,\n         externalEquityLinks: 0,\n         domainAuthority: 1 } }\n. ",
    "itsvtk": "@rhys-vdw\nEven though i have primary key column in my table, i am still getting an error stating missing column. \nThe primary key column name is \"BookID\" in a table called \"Book\". \nWhen I save a record using bookshelft, it is throwing an exception.\nUnfortunately I can't change the column name from \"BookID\" to \"Id\" in Book table. \nPlease advise. \nThanks,\n. @rhys-vdw\nEven though i have primary key column in my table, i am still getting an error stating missing column. \nThe primary key column name is \"BookID\" in a table called \"Book\". \nWhen I save a record using bookshelft, it is throwing an exception.\nUnfortunately I can't change the column name from \"BookID\" to \"Id\" in Book table. \nPlease advise. \nThanks,\n. ",
    "digia": "Awesome. Thank you!\n. Awesome. Thank you!\n. ",
    "nathanboktae": "Thanks!\n. ",
    "spwizard": "The issue seems to be with this\nSQL : \"insert into \"orders\" (\"created_at\", \"products\", \"totalitems\", \"totalprice\", \"updated_at\", \"userid\") values ($1, $2, $3, $4, $5, $6) returning \"id\"\"\nthis is what its trying to put into $2\njs\n\"{\"{\\\"DishId\\\":\\\"R00265\\\",\\\"Name\\\":\\\"Miso Soup\\\",\\\"Description\\\":\\\"Seaweed, tofu, spring onion, soy bean broth (unlimited refills).\\\",\\\"PriceInGBP\\\":220,\\\"Quantity\\\":2}\",\"{\\\"DishId\\\":\\\"R00500\\\",\\\"Name\\\":\\\"Spicy Seafood Udon\\\",\\\"Description\\\":\\\"Shrimps, salmon, squid, vegetables, udon noodles, spicy broth.\\\",\\\"PriceInGBP\\\":430,\\\"Quantity\\\":2}\"}\"\njs\nvar createOrder = function(req, res, done) {\n  new Order(req.body).save().then(function(order) {\n    res.json(order);\n  });\n};\nThanks\n. No its not\ninvalid input syntax for type json\n. rhys thanks for your help. It appears the solution is to JSON.stringify the array products first.\nBy doing this I can now run queries like \nSelect Distinct userId, products\nfrom orders where products @> '[{\"Quantity\" : 2}]';\nvar createOrder = function(req, res, done) {\n  var newOrder = {}\n  newOrder.totalprice = req.body.totalprice;\n  newOrder.totalitems = req.body.totalitems;\n  newOrder.userid = 2;\n  newOrder.products = JSON.stringify(req.body.products)\n  new Order(newOrder).save().then(function(order) {\n    res.json(order);\n  });\n};\n. Thanks for that.\n. ",
    "Voles": "I'm currently using a null value which doesn't throw errors when creating instances of a model with multiple column id's. My model definition:\nBookshelf.Model.extend({\n  tableName: 'table1_table2',\n  idAttribute: null\n}). I'm currently using a null value which doesn't throw errors when creating instances of a model with multiple column id's. My model definition:\nBookshelf.Model.extend({\n  tableName: 'table1_table2',\n  idAttribute: null\n}). ",
    "rbdr": "The models do seem to be duplicates. If I do a toJSON I get something like:\njavascript\n[\n{ id: 8,\n  name: 'A Role',\n  createdAt: Tue Aug 11 2015 12:52:15 GMT-0500 (CDT),\n  updatedAt: Tue Aug 11 2015 12:52:15 GMT-0500 (CDT),\n  _pivot_id: 8,\n  _pivot_groupId: 1,\n  _pivot_roleId: 8 },\n{ id: 8,\n  name: 'A Role',\n  createdAt: Tue Aug 11 2015 12:52:15 GMT-0500 (CDT),\n  updatedAt: Tue Aug 11 2015 12:52:15 GMT-0500 (CDT),\n  _pivot_id: 8,\n  _pivot_groupId: 1,\n  _pivot_roleId: 8 },\n{ id: 8,\n  name: 'A Role',\n  createdAt: Tue Aug 11 2015 12:52:15 GMT-0500 (CDT),\n  updatedAt: Tue Aug 11 2015 12:52:15 GMT-0500 (CDT),\n  _pivot_id: 8,\n  _pivot_groupId: 1,\n  _pivot_roleId: 8 }\n...]\n. I was using 0.7.9 when this happened, updated to see if it had been fixed, and it's also present in 0.8.1\n. ",
    "rogerschlachter": "@rhys-vdw @jameslaneconkling \nWere either of you ever able to resolve this? I know it was a while ago, but I'm running into the same issue. \n@jamesdixon \nWere you able to get any traction on this? Or anything close?  Struggling a bit right now. And I've got a few places where I'll need to insert geometry data from GeoJSON. \n. @tayden-hakai \nThis is very helpful as I'm trying to do the same thing.  Were you able to do the reverse ( st.geomFromGeoJSON() ) on saving?\n. @tayden-hakai \nThanks for the quick response. I'll dig into that a little more.  \nThis seems to work great on the table with the geometry field.  Now I need to figure out how to apply it when fetching it as related data.  I have the idea of a Site, which has many Areas.  An Area contains the geometry field. So right now if I fetch an Area, I see the geoJSON, but if I grab a Site with the related Areas, I don't get the geoJSON on those areas. \n. I agree that the docs are pretty minimal right now. Examples like you've suggested would be great. I think a lot of the docs are inside the code and pulled out though so I'm guessing it'd be a bigger effort to do more?. I agree that the docs are pretty minimal right now. Examples like you've suggested would be great. I think a lot of the docs are inside the code and pulled out though so I'm guessing it'd be a bigger effort to do more?. ",
    "technikyle": "Thanks for the feedback @rhys-vdw. I agree with your comments. \nI do see the chaining formatted differently too. Is there a standard? I prefer not to indent, but I can just leave it alone.\nI saw there were some places where @example was used and others where it was not. It sounds like you do not generally use @example? In that case, would you mind explaining how the code examples are formatted correctly? When I run JSDoc, they do not format correctly, but they look correct at Bookshelfjs.org.\nHow about I redo my updates only including the following:\n- hasMany example\n- remove white space\nIf so, would you rather have that as one pull request or separate requests?\n. @rhys-vdw I changed my pull request to only include the model.hasMany example. Let me know if you have any more suggestions for changes.\n. @rhys-vdw I changed my pull request to only include the model.hasMany example. Let me know if you have any more suggestions for changes.\n. ",
    "blah238": "Sorry, that was just an oversimplification. The query I have in mind is to count the models that have one of several values, e.g. Model.query().whereIn('value', values).count(). Perhaps whereIn could get the same treatment as Model.where() in Bookshelf?\n. That works great. What's the difference exactly?\n. Take a look at the built-in Visibility plug-in: https://github.com/tgriesser/bookshelf/wiki/Plugin:-Visibility\nThis lets you specify a hidden property on your model with an array of fields to exclude during toJSON calls.\nI don't believe this will prevent the hidden columns from being queried however, perhaps someone else has a suggestion if that is specifically what you're looking for.\nedit: Visibility, not Virtuals plugin\n. ",
    "vschoettke": "In my case @rhys-vdw the .fetch() is done in the isNew() function, as a result of switching from auto increment to pre-generated UUIDs. This was the least intrusive way and kept the logic code the same.\nIf there is another simple way of using pre-generated UUIDs as ID? (without supplying the method to every save command)\n. ",
    "SamMorrowDrums": "I'm having this problem with .save(). I'm using CamelCase, and I have to do model.set(\"file_oid\", model.get(\"fileOid\"));, with idAttribute: \"file_oid\".\nWhat's the plan for this? (this setup works, but if I don't set up the second attribute, which then gets overwritten when converting back to underscores, then it doesn't realise it's an update and tries to add a new row to the DB).\n. ",
    "kentnek": "Any update on this?. ",
    "noveogroup-amorgunov": "Any updates? I have similar problem :cry: . ",
    "Uptown76": "Thanks mate.\n. ",
    "drewhamlett": "Thanks man this looks great!\n. ",
    "dsauerbrun": "@jamesdixon sorry man, just worked around it :\\\n. ",
    "tjwudi": "I know why it is happening. require('knex') actually exposes a class not a object. We should use new Knex(config) instead. The bookshelf documentation is wrong.\n. ",
    "w3aran": "Seems I have similar issue. Any progress on the bug fixes?\n. ",
    "hessryanm": "Sorry @rhys-vdw, I wasn't aware there was a separate repo for knex (although it makes sense).\nWe have not tried updating, because we're afraid of what that might do to our existing codebase.  Since we found a workaround (by returning a rejected promise rather than throwing), we decided it wasn't worth the risk of updating.\n. ",
    "kahwooi": "I did not set any idAttribute. After I set it, it is working now. Thank you.\n. Hi @vellotis Thanks. It is working correctly.\n. ",
    "dougshamoo": "Sure, sorry about that.\n. ",
    "podliy16": "Same with saved and updated events.\n. ",
    "Rokt33r": "I decided to solve this problem with RAW query, ON DUPLICATE KEY UPDATE.\n\nI found this solution here. http://stackoverflow.com/questions/2366813/on-duplicate-key-ignore\n\nThis code is an example, I made, which solve a similar problem.\n``` js\n    var _ = require('lodash')\n    var article = this\n    var currentTags = article.related('Tags').pluck('name')\n    var tagsToDetach = .difference(currentTags, tags)\n    var tagsToAttach = .difference(tags, currentTags)\nreturn knex.raw('INSERT INTO Tags (name, createdAt) VALUES ' + tagsToAttach.map(function(tag){return '(?, now())'}) + ' ON DUPLICATE KEY UPDATE name=name;', tagsToAttach)\n  .then(function () {\n    return knex.raw('INSERT INTO ArticleTag (ArticleId, TagId) SELECT ? as ArticleId, id as TagId FROM Tags WHERE name in (' + tagsToAttach.map(function(tag){return '?'}).join(', ') +') ON DUPLICATE KEY UPDATE TagId=TagId;', [article.id].concat(tagsToAttach))\n  })\n  .then(function () {\n    return knex('ArticleTag').whereIn('TagId', knex.select('id').whereIn('name', tagsToDetach).from('Tags')).andWhere({ArticleId: article.id}).del()\n  })\n\n```\nI'll update this issue after I rewrite the above code.\n. Ah, It works fine because Member user and Team user are in same table, 'Users'.\nThanks you for updating the document and I'll try attaching-catch-updatePivot later!\n. I have same problem.\nIn my case, it works perfectly on my local environment(Node v4.2.1).\nbut, on my Elastic beanstalk instance, it doesn't.(Node v4.2.1 same version)\nError: Cannot find module 'babel-runtime/helpers/classCallCheck'\n    at Function.Module._resolveFilename (module.js:337:15)\n    at Function.Module._load (module.js:287:25)\n    at Module.require (module.js:366:17)\n    at require (module.js:385:17)\n    at Object.<anonymous> (/var/app/current/node_modules/bookshelf/lib/base/events.js:7:24)\n    at Module._compile (module.js:435:26)\n    at Object.Module._extensions..js (module.js:442:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:311:12)\n    at Module.require (module.js:366:17)\n    at require (module.js:385:17)\n    at Object.<anonymous> (/var/app/current/node_modules/bookshelf/lib/bookshelf.js:15:15)\n    at Module._compile (module.js:435:26)\n    at Object.Module._extensions..js (module.js:442:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:311:12)\n. ",
    "madarche": "@rhys-vdw thanks a lot for your answer! This is exactly what I need.\n. Cool, peerDependencies sounds good.\nThanks!\n. @rhys-vdw thanks a lot for all your hard work! Works like a charm.\n. ",
    "MartinCa": "Thanks for the comment @rhys-vdw, you are right about the misleading scoped variable relation caused by my change. I have commited your suggested changes above to the fix.\n. ",
    "thebillkidy": "Hi, Thanks for this response, it made me realise what was wrong and I got a solution that works!\nSo in short, I was manually picking the keys with fixtures so that I could use that id for created_by fields in other tables. Because of that the Postgresql system would not increment the sequence and that is why it failed.\nI solved it by running a raw query on the end:\nknex.schema.raw(\"select setval('\" + table + \"_id_seq',\" +  dbData[table].length + \")\")\nThis will basically fix the sequence and set it the last inserted element. Now whenever I add objects with .save it will do this correctly and increment the sequence by itself.\nThanks for helping!\n. Hi, Thanks for this response, it made me realise what was wrong and I got a solution that works!\nSo in short, I was manually picking the keys with fixtures so that I could use that id for created_by fields in other tables. Because of that the Postgresql system would not increment the sequence and that is why it failed.\nI solved it by running a raw query on the end:\nknex.schema.raw(\"select setval('\" + table + \"_id_seq',\" +  dbData[table].length + \")\")\nThis will basically fix the sequence and set it the last inserted element. Now whenever I add objects with .save it will do this correctly and increment the sequence by itself.\nThanks for helping!\n. I can not believe I just looked over that return all the time ... Thanks! You literally saved my day haha!\n. ",
    "xiechao06": "@rhys-vdw  thanks a lot, I wonder if the document could write down what you say, I think it is very error-prone when handling pagination-like queries. \n. @rhys-vdw by the way, I found the snippets you given don't work. clone will clear the query either. \n\n. ",
    "mohas": "@skylinezum how wrong? I have the same issue but can't figure it out\n. Thank you for replaying\n. ",
    "s2t2": "FYI I'm getting this error message when I try to reference the model from another file. \nHere's my code:\n``` js\n// db.js\nvar config      = require('./db/config');\nvar env         = process.env.NODE_ENV || 'development';\nvar knex        = require('knex')(config[env]);\nvar bookshelf = require('bookshelf')(knex);\nbookshelf.plugin('registry'); // use the \"model-registry\" plugin. https://github.com/tgriesser/bookshelf/wiki/Plugin:-Model-Registry\nmodule.exports = bookshelf;\n```\n``` js\n// app/models/robot.js\nvar db = require(\"../../db\");\nvar Robot = db.Model.extend({\n  tableName: 'robots'//,\n  //hasTimestamps=true\n});\nmodule.exports = db.Model('Robot', Robot);\n```\nIf I use a lowercase model, as in module.exports = db.model('Robot', Robot);, the error goes away.\n. FYI I'm getting this error message when I try to reference the model from another file. \nHere's my code:\n``` js\n// db.js\nvar config      = require('./db/config');\nvar env         = process.env.NODE_ENV || 'development';\nvar knex        = require('knex')(config[env]);\nvar bookshelf = require('bookshelf')(knex);\nbookshelf.plugin('registry'); // use the \"model-registry\" plugin. https://github.com/tgriesser/bookshelf/wiki/Plugin:-Model-Registry\nmodule.exports = bookshelf;\n```\n``` js\n// app/models/robot.js\nvar db = require(\"../../db\");\nvar Robot = db.Model.extend({\n  tableName: 'robots'//,\n  //hasTimestamps=true\n});\nmodule.exports = db.Model('Robot', Robot);\n```\nIf I use a lowercase model, as in module.exports = db.model('Robot', Robot);, the error goes away.\n. @eltonk yes upper vs lower case fixed it for me although the stack overflow question posted by @hudecsamuel might be worth checking out.\n. ",
    "skylinezum": "db.model is correct. If you look at the plugin:-model-registry link I show above. you are supposed to export with lowercase model\nIf you think about it, Model is probably the class name and should be capitalized, while model is a constructor with those two parameters, so it would be lower case.\n. ",
    "hudecsamuel": "I had the same problem,  make sure you are calling save and update functions on instance \nhttp://stackoverflow.com/questions/36727399/bookshelf-registry-plugin-and-node-cirrcular-dependency-errors\n. ",
    "catamphetamine": "For me this error was happening because I called this.model({...}).destroy() while the correct call would be new this.model({...}).destroy()\n. I've got an alternative solution.\nThe error is thrown in this case\n``` js\n    const User = bookshelf.Model.extend\n    ({\n        tableName : 'users',\n\n        authentication_tokens()\n        {\n            return  this.hasMany(Authentication_token)\n        }\n    })\n\n    const Authentication_token = bookshelf.Model.extend\n    ({\n        tableName : 'authentication_tokens',\n\n        user()\n        {\n            return  this.belongsTo(User)\n        },\n\n        access_history()\n        {\n            return  this.hasMany(Authentication_token_access_history)\n        }\n    })\n\n```\nWhich becomes (notice the use of models registry object)\n``` js\n        const models = {}\n    models.User = bookshelf.Model.extend\n    ({\n        tableName : 'users',\n\n        authentication_tokens()\n        {\n            return  this.hasMany(models.Authentication_token)\n        }\n    })\n\n    models.Authentication_token = bookshelf.Model.extend\n    ({\n        tableName : 'authentication_tokens',\n\n        user()\n        {\n            return  this.belongsTo(models.User)\n        },\n\n        access_history()\n        {\n            return  this.hasMany(models.Authentication_token_access_history)\n        }\n    })\n\n``\n. Oh, no,dataonly containedundefined` keys.\nAnd, there's a better way:\njs\nthis.model.where(where).save(data, { method: 'update', patch: true })\n. ",
    "badave": "I had this issue happen to me and was really confused as to what was causing it.  This will happen if you try to save a model in another model.  For example, model.set({ attr: otherModel }) and then model.save().  Not saving a model in another model solves the problem - you can save the the JSON of the model safely and you may even be able to use model.attributes, but you can't use the model itself.\n. ",
    "benjaminmcdonald": "Some better feedback for the developer on this error would be helpful. A warning that you forgot the \"new\" keyword. Some better feedback for the developer on this error would be helpful. A warning that you forgot the \"new\" keyword. ",
    "WebDevMichael": "I had this error when I called the model as a function by accident.\nRobot().where({ mycol: 1 }).fetchAll();\nRemoving the parenthesis solved it:\nRobot.where({ mycol: 1 }).fetchAll();. ",
    "loryman": "I created #1699 for the visibility: false feature, let me know what you think. It seems like that changing \"knex\": \">=0.6.10 <=0.13.0\" to \"knex\": \">=0.6.10 <=0.14.0\" in peerDependencies works for me.. ",
    "Claud": "Cannot read property '_applyScenario' of undefined\nCannot read property 'activeScenario' of undefined...\n. Update model.\njs\nTest.forge({id: req.params.id}).fetch().then((model) => {\n                if (!model) {\n                    return next(new Error())\n                }\n                return model.save(req.body).then((model) => {\n                    return model.refresh().then(() => {\n                        res.status(200).send(model.toJSON());\n                    }).catch((error) => {\n                        next(error);\n                    });\n                }).catch((error) => {\n                    next(error);\n                });\n            }).catch((error) => {\n                next(error);\n            });\nThe plugin works well, if I create a model (code from initialize).\n. It is abstraction code. I can not share real project. \nI see procces in debuger, all works (model is find on previous step and i try update it), but code generate \"TypeError: Cannot read property '_applyScenario'\" \nError generation on this step attrs = this._applyScenario(attrs, this.activeScenario, this.scenarios); in save method, i see this in debuger.\n. js\nModel.fetch().then((model) => {\n    return model.save({....}, {patch: true}).then(model => model);\n});\n. This code is working if i use {patch: true}, but with {patch: false} is not working.\njs\nthis.on('saving', (model, attrs, options) => {\n    delete attrs.password;\n    delete attrs.password_repeat;\n    delete attrs.old_password;\n});\nTwo different way. How do it in one style?\n. This is interesting, thank you. It would be better if \"bookshelf\" keeps the changed data of the this.attributes. It is one object for change.\n. ",
    "durai-optisol": "hi @rhys-vdw  please help me.\ni found all data from the database in 1st tabel name is Car\nit linked with 2nd withrelated table(engine)  have a fuel type. if it is petrol then show me all data which have a petrol type . if condition is wrong then no need to display that tabel.\nmy problem is \ntable has displayed but if condition is wrong its return a empty object.... \nplease help me . \nCar.where({}).fetch({withRelated: {\n  engine: query => query.where('fuel', fuel_type)\n}}).then(cars =>{\nreturn res.status(200).json({\n        status: \"Success\",\n        statusCode: 200,\n        cars: cars,\n  })\n}). ",
    "frknbasaran": "Because I was got \"max connection limit\" error from mysql.\nMy model file looks like below\n``` javascript\nvar config = require('../config'),\n    knex = require('knex')(config.database),\n    Bookshelf = require('bookshelf')(knex);\nmodule.exports = Menu = Bookshelf.Model.extend({\n    tableName: 'menus',\n    parent: function () {\n        return this.belongsTo(Menu, 'parent');\n    }\n});\n```\n``` javascript\nvar Bookshelf = require('bookshelf')(global.knex);\nvar MenuModel = require('../../models/Menu');\nvar Menus = Bookshelf.Collection.extend({\n    model: MenuModel\n})\nvar CRUD = {\n    getList: function (conditions, orderBy) {\n    console.log(\"Menu:CRUD.getList()\")\n\n    orderBy = orderBy || \"asc\";\n\n    var deferred = Promise.pending();\n\n    Menus\n        .query(function (qb) {\n            qb.orderBy(\"id\", orderBy);\n            conditions.forEach(function (condition) {\n                if (condition.key == \"parent\" && condition.val == \"0\")\n                    console.log(\"All records listing..\")\n                else qb.where(condition.key, condition.rel, condition.val)\n            })\n        })\n        .fetch({\n            withRelated: [{\n                'parent': function (qb) {\n                    qb.column('id', 'name')\n                }\n            }]\n        })\n        .then(function (menus) {\n            deferred.fulfill(menus);\n        })\n        .catch(function (err) {\n            console.log(err)\n            deferred.reject({message: err.message})\n        })\n\n    return deferred.promise;\n\n}\n\n};\nmodule.exports = CRUD;\n```\nthis query and others throw \"There is no pool defined on the current client\" error.\n. When I print my \"Menus\" collection object to console, I get this out: EmptyError: Function ErrorCtor\n. Yes it's called from my router, I was added my file structure below.\n\nRequests handled on router, router call helper module and helper module call relational crud function from my crud modules.\nfor example;\n``` javascript\n// routes/menu.js\n// GET /api/menus\nrouter.route('/')\n .get(Req(\"query\", [\"rp\", \"p\"]), function (req, res) {\n        menuHelper\n            .getList([\n                {\"key\": \"required_permission\", \"rel\": \"<=\", \"val\": req.query.rp},\n                {\"key\": \"parent\", \"rel\": \"=\", \"val\": req.query.p}\n            ])\n            .then(function (menus) {\n                res.json({\"error\": false, \"data\": menus});\n            })\n            .catch(function (err) {\n                res.json({\"error\": true, \"message\": err.message});\n            })\n})\n\n```\nRouter call below function from crud module\n``` javascript\n// crud/menu.js\nvar Bookshelf = require('bookshelf')(global.knex);\n/\n * Database Object Models\n * /\nvar MenuModel = require('../../models/Menu');\n/\n * Database Object Collections\n * /\nvar Menus = Bookshelf.Collection.extend({\n    model: MenuModel\n})\n...\ngetList: function (conditions, orderBy) {\n    console.log(\"Menu:CRUD.getList()\")\n\n    orderBy = orderBy || \"asc\";\n\n    var deferred = Promise.pending();\n\n    Menus\n        .query(function (qb) {\n            qb.orderBy(\"id\", orderBy);\n            conditions.forEach(function (condition) {\n                if (condition.key == \"parent\" && condition.val == \"0\")\n                    console.log(\"All records listing..\")\n                else qb.where(condition.key, condition.rel, condition.val)\n            })\n        })\n        .fetch({\n            withRelated: [{\n                'parent': function (qb) {\n                    qb.column('id', 'name')\n                }\n            }]\n        })\n        .then(function (menus) {\n            deferred.fulfill(menus);\n        })\n        .catch(function (err) {\n            console.log(err)\n            deferred.reject({message: err.message})\n        })\n\n    return deferred.promise;\n\n}\n}\n...\n```\nWhen I put to console \"Menus\" objects value looks somethings went wrong because object is empty.\n. ",
    "http91": "@ricardograca it's an old fk from my old design (before moving to polymorphic relations), removed now.\n. I solved it.\nI added a new method to activity, like below.\nuserRelated : function() {\n    return this.belongsTo(user,'related_user');\n  }\nAnd here's the updated query. I don't know whether it's the right way or not in terms of optimization, but it works.\nuser.where({\n    id: 43\n  }).fetchAll({\n    withRelated: ['feed.userRelated', 'feed.activityTypes']\n  }).then(function(data) {\n    data = data.toJSON();\n    res.send(data);\n  });\nRight now feed, userRelated and activityTypes return without a problem, everything is in data in JSON format.\nPlease feel free to contribute if you think there's a better way :)\n. It took me a while to discover that (still laughing at myself), thanks.\n. TL;DR\nYou don't have to add user_id if you're following the convention (which you are). You only need to add these on situations where *_id is something like this : friend_id, receiver_id, etc.\n\nI haven't been using Bookshelf.js for a long time, so I'm not an expert. Here's my solution.\nTables and stuff.\nCREATE TABLE users\n(\n    id INT(11) PRIMARY KEY NOT NULL AUTO_INCREMENT,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\nCREATE TABLE images\n(\n    id INT(11) PRIMARY KEY NOT NULL AUTO_INCREMENT,\n    thumbnail VARCHAR(255),\n    user_id INT(11),\n    CONSTRAINT images_users_id_fk FOREIGN KEY (user_id) REFERENCES users (id)\n);\nCREATE INDEX images_user_id_index ON images (user_id);\nDUMMY DATA FOR TESTING PURPOSES\n```\nINSERT INTO play.users (username, email) VALUES ('first user', 'first@g.com');\nINSERT INTO play.users (username, email) VALUES ('second user', 'second@g.com');\nINSERT INTO play.users (username, email) VALUES ('third user', 'third@g.com');\nINSERT INTO play.images (thumbnail, user_id) VALUES ('thumb4.jpg', 3);\nINSERT INTO play.images (thumbnail, user_id) VALUES ('thumb6.jpg', 3);\nINSERT INTO play.images (thumbnail, user_id) VALUES ('thumb3.jpg', 2);\nINSERT INTO play.images (thumbnail, user_id) VALUES ('thumb5.jpg', 2);\nINSERT INTO play.images (thumbnail, user_id) VALUES ('thumb1.jpg', 1);\nINSERT INTO play.images (thumbnail, user_id) VALUES ('thumb2.jpg', 1);\n```\ndb.js\n```\nvar knex = require('knex')({\n  client: 'mysql',\n  connection: {\n    host: '127.0.0.1',\n    port: 3306,\n    user: 'root',\n    password: 'root',\n    database: 'play',\n    charset: 'utf8'\n  },\n  pool: {\n    min: 0,\n    max: 100\n  }\n});\nvar db = require('bookshelf')(knex);\nmodule.exports = db;\n```\napp.js (You usually keep your models in a separate file, but I want to keep this answer short, so...)\n```\nvar db = require('./db.js');\nvar user = db.Model.extend({\n  tableName: 'users',\n  hasTimestamps: false,\n  images : function() {\n    return this.hasMany(image);\n  }\n});\nvar image = db.Model.extend({\n  tableName: 'images',\n  hasTimestamps: false,\n  owner : function() {\n    return this.belongsTo(user);\n  }\n});\napp.get('/test', function(req,res) {\n// give a user's id, fetch his/her all images.\n  user.where('id',2).fetchAll({withRelated : ['images']}).then(function(data) {\n    res.send(data);\n  });\n// give an image's id and fetch its owner.\n  image.where('id',3).fetchAll({withRelated : ['owner']}).then(function(data) {\n    res.send(data);\n  });\n});\n```\nProblem solved.\n. ",
    "nnarhinen": "with {debug: true } I can see it's not in the update sql at all.\nI tried to make a dead simple reproducable case but it seems it's not misbehaving with a simple model.\nMy model (and table) has two JSON columns and two TEXT columns. The text columns do not get stored. I think I have to dig deeper into the query building mechanism to find the reason for this.\n. PEBKAC.. I had declared a format() method for my model for formatting output to API. And in the format method I deleted the text fields.. Didn't realize bookshelf has a special meaning for that method name.. Sorry for the noise.\n. ",
    "haimich": "Same here!\n. ",
    "konobi": "The dotted notation for deep relations doesn't seem to be documented anywhere. Is that a current feature?\n. ",
    "sjonnet19": "Np. Glad to help.\n. ",
    "mezod": "Makes sense! Thanks @ricardograca :)\n. Thanks!\n. great thanks, for anyone reading, in mysql you need to add \"end\". Also it has to be then 1 else 0, the code below worked for me\nvar sortColumn = 'column_name';\nModel.query('orderBy',\n  // First sort by whether the column is null or not.\n  knex.raw('case ?? when \" \" then 1 else 0 end', sortColumn),\n  // Break ties on the content of column.\n  sortColumn\n).fetchAll();\n. just wanted to say that the solution I gave before doesn't work. It does put nulls at the end but sorts the rest of the collection by, apparently, the ids, and not the sortColumn I define. It's like it ignores the third param of the query. Trying stuff we've come up with:\nvar sortColumn = 'column_name';\nModel.query('orderBy',\n// First sort by whether the column is null or not.\n  knex.raw('case ?? when \" \" then 1 else 0 end', sortColumn))\n.query('orderBy', sortColumn)\n.fetchAll();\nwhich seems to do the trick, eventhough it doesn't make much sense to me by looking at the code. So any explanation of why this could work would be cool!\nHope this helps...\n. { method: 'select',\n options: {},\n bindings: [],\n sql: 'select count(*) as `count` from `users`' }\n. I think it's relevant because it's a bug that several people have stumbled upon.. done!. ",
    "icukeng": "It is actually the whole test code. I'm expecting this code to save the item to DB, but it fails somewhere deep in bluebird or bookshelf.\n. It is actually the whole test code. I'm expecting this code to save the item to DB, but it fails somewhere deep in bluebird or bookshelf.\n. ",
    "jnkrls": "Hi, the problem it's that City model has a composite key. If I try to do it with addreses.city it will only retrieve city_department and I need city_department and city_province. \nTry it with query builder but I can't find I way to pass the second parameter\njavascript\nreturn new Store()\n    .fetchAll({\n        withRelated: ['addresses', {'addresses.city': function(qb){\n            qb.where('province',?);}}] // '?' have to be city_province attribute from each address model from the result query\n    }).then(function(stores){\n         res.send(stores.toJSON());\n    );\nI also try to query on the model, but this.attributes.city_province it's always undefined\njavascript\nvar Address = bookshelf.Model.extend({\n    tableName: 'address',\n    idAttribute: 'id',\n    store: function(){\n        return this.belongsTo(Store,'store_id');\n    },\n    city: function(){\n        return this.belongsTo(City,'city_department')\n                    .query('where','district', '=',this.attributes.city_province);\n    }\n}\n. This are the queries from the debug.\n{ method: 'select',\n  options: {},\n  bindings: [],\n  sql: 'select `store`.* from `store`' }\n{ method: 'select',\n  options: {},\n  bindings: [ 1, 2 ],\n  sql: 'select `address`.* from `address` where `address`.`store_id` in (?, ?)' }\n{ method: 'select',\n  options: {},\n  bindings: [ 15 ],\n  sql: 'select `city`.* from `city` where `city`.`department` in (?)'\nWhen it fetch address.city always use the primary key defined on the model (`idAttribute = id) so in my example city_department = 15. But I need to be city_department = 15 and city_province = ? where '?' depends on the value from the result.\n. I just notice that, my bad....sorry (problem with the copy&paste, because it's actually a composite key with 3 keys, but I try to minimize it using just 2 here). I'm using MySQL, this is how my schema and model are right now:\n\n``` javascript\nvar Store = bookshelf.Model.extend({\n    tableName: 'store',\n    idAttribute: 'id',\n    addresses: function(){\n        return this.hasMany(Address,'store_id');\n    }\n};\nvar Address = bookshelf.Model.extend({\n    tableName: 'address',\n    idAttribute: 'id',\n    store: function(){\n        return this.belongsTo(Store,'store_id');\n    },\n    city: function(){\n        return this.belongsTo(City,'city_department');\n    }\n}\nvar City = bookshelf.Model.extend({\n    tableName: 'city',\n    idAttribute: 'department', //this is a composite pk (department and province)\n    addresses: function(){\n        return this.hasMany(Address,'city_department');\n    }\n}\n```\nAnd this is how I fetch one store (with it respective address and city):\njavascript\nreturn new Store({\n        'id': 1\n    })\n    .fetch({\n        withRelated: ['addresses.city']\n    }).then(function(stores){\n         res.send(stores.toJSON());\n    );\nDebug:\n{ method: 'select',\n  options: {},\n  bindings: [ 1, 1 ],\n  sql: 'select `boutique`.* from `boutique` where `boutique`.`id` = ? limit ?' }\n{ method: 'select',\n  options: {},\n  bindings: [ 1 ],\n  sql: 'select `address`.* from `address` where `address`.`boutique_id` in (?)' }\n{ method: 'select',\n  options: {},\n  bindings: [ 15 ],\n  sql: 'select `city`.* from `city` where `city`.`department` in (?)'\nAnd the result :\njson\n{\n    \"id\": \u200b1,\n    \"name\": \"Store 1\",\n    \"addresses\": \n    [\n        {\n            \"id\": \u200b2,\n            \"address\": \"Store 1, Av 1\",\n            \"store_id\": \u200b1,\n            \"city_department\": \u200b15,\n            \"city_province\": \u200b1,\n            \"city\": {\n                \"department\": 15,\n                \"province\": 0,\n                \"name\": \"Department 15\"\n            }\n        },\n        {\n            \"id\": \u200b3,\n            \"address\": \"Store 1, Av 2\",\n            \"store_id\": \u200b1,\n            \"city_department\": \u200b15,\n            \"city_province\": \u200b1,\n            \"city\": {\n                \"department\": 15,\n                \"province\": 0,\n                \"name\": \"Department 15\"\n            }\n        }\n    ]\n}\nAs you can see when I use  withRelated: ['addresses.city'] it queries just department on the whereclause . And I need to query department and province so I can see it related city.\nAs a mention before I've try to do it with query builder, but from all examples I could find it just use stactic values.\njavascript\nreturn new Store()\n    .fetchAll({\n        withRelated: ['addresses', {'addresses.city': function(qb){\n            qb.where('province',1);}}] //Here I use 1 just to see if it work, and it does, but I need it to be dynamic according from the address.city_province \n    }).then(function(stores){\n         res.send(stores.toJSON());\n    );\nThis is where I'm stuck, and I can't seem to find a way to do it, unless the only way it's using a raw query with knex.\n. Hi @rhys-vdw, that works if after I fetch all Stores (with related address, not cities) and then loop through each address and fetch each city, which seems more work than just do it Knex. I was hoping it was a simpler way to do it with Bookshelf. Thanks for the help.\n. Hi @rhys-vdw, that works if after I fetch all Stores (with related address, not cities) and then loop through each address and fetch each city, which seems more work than just do it Knex. I was hoping it was a simpler way to do it with Bookshelf. Thanks for the help.\n. ",
    "codeclown": "No, here's a simplified model definition:\n```\nlet dateTimeFields = ['created_at', 'updated_at'];\nlet Organization = baseModel.extend({\n    hasTimestamps: true,\n    dateTimeFields: [...dateTimeFields, 'plan_active_until']\n};\n```\nJust quickly tried basically moving the array to hasTimestamps and using it in format instead of dateTimeFields, with no luck.\nWhat I don't understand is that plan_active_until is altered before it gets to format.\n. It really doesn't. As the code above shows, initial date is 7 days ahead. Then I submit it to Model.save. From there Bookshelf calls format, in which the first thing I do is print the date, and it is not same as initially.\nI'm not saying Bookshelf removes 7 days, but somewhere the Moment-instance is reset to current date. But I don't use the hasTimestamps as an array, so Bookshelf shouldn't touch plan_active_until in any special way.\nWhat I might end up doing (trying) is just passing the date as a string for save, instead of a Moment-object. If you have any ideas why the Moment-instance is being reset, that would solve this issue.\n. As you (and I) expected, it was an issue with my custom format/parse setup.\nBasically I wasn't checking if an attribute was undefined. In that case the attribute should not be modified, but I set it to null. So, after this specific save event there were other operations where I didn't input plan_active_until to save and therefor it was turned to null before saving to DB.\n. As you (and I) expected, it was an issue with my custom format/parse setup.\nBasically I wasn't checking if an attribute was undefined. In that case the attribute should not be modified, but I set it to null. So, after this specific save event there were other operations where I didn't input plan_active_until to save and therefor it was turned to null before saving to DB.\n. ",
    "jcrben": "When implementing this, please consider a recommended pattern for splitting it into multiple files.. ",
    "agarzola": "After a little more testing, it would seem that it\u2019s casting the org\u2019s id to the admins table id, meaning that it returns the admins row with id 1, no matter what its user_id or org_id might be. I think this might be the case because when I fetch the user with id 1 (which has no admins rows pointing to it at all), I still get the org when I do user.related('org').\n. And when I fetch user with id 2, which does have a row in the admins table, no org is associated with it at all.\n. Thank you for your prompt response!\nRe: Schema \u2014 As I mentioned above, my admins table has an org_id column and a user_id column. It\u2019s basically a join table that ties a user record with an org record by referencing each of them.\nRe: How .through() works \u2014 Actually, that is precisely the opposite. The Target model is User (hence this.hasMany('User')). Admin is what the documentation refers to as an Interim model (also referred to as a JoinModel a little further down). Going by the terminology used in the documentation, the query should search the admin table for any rows with this Org\u2019s id to fetch the value found in each record\u2019s user_id field (\u201cthe singular form of the Target model\u2019s tableName, followed by _id\u201d).\nWhile I am obviously receptive to any indication that I might be using this tool incorrectly, I should clarify that I do not suspect this is the case.\n. Oh, I see how that can cause my misunderstanding of this feature.\nSo, what would be the correct way to establish the relationship on the Org and User models where that relationship is expressed via an admins junction table that makes reference to each of them via org_id and user_id columns?\nOur tables look exactly like this, essentially:\n\nWhere actor == user, film == org and actor_film_mapping == admins.\n. Thanks a lot, guys! @rhys-vdw: I apologize, I was too eager with my comparison above.\nOur users and orgs tables have the typical id identifier, and only in the admins table do we refer to them by user_id and org_id. Is this an antipattern, or is there a way to express that in the models?\nAdditionally (and, again, I apologize), our admins junction table does have primary key (also just id).\n. That\u2019s fair; I didn\u2019t mean to make it harder for anyone, but you\u2019re right. I apologize.\nSchemas:\n// admins table schema\nid: increment (primary)\nuser_id: int\norg_id: int\n// users table schema\nid: increment (primary)\nfirstName: string\nlastName: string\nemail: string\n// orgs table schema\nid: increment (primary)\nname: string\nAt the moment, a modified version of your examples above worked for me. See below:\n``` javascript\n// models/User.js\nvar bookshelf = require('../bookshelf')\nvar User = bookshelf.Model.extend({\n  tableName: 'users',\n  mailingAddress: function () {\n    return this.belongsTo('Address', 'mailingAddress_id')\n  },\n  org: function () {\n    return this.hasOne('Org').through('Admin', 'id')\n  },\n  virtuals: {\n    fullName: function () {\n      return this.get('firstName') + ' ' + this.get('lastName')\n    },\n    admin: function () {\n      return (this.related('org').id ? true : false)\n    }\n  },\n  hidden: ['password']\n})\nmodule.exports = bookshelf.model('User', User)\n```\n``` javascript\n// models/Org.js\nvar bookshelf = require('../bookshelf')\nvar Org = bookshelf.Model.extend({\n  tableName: 'orgs',\n  mailingAddress: function () {\n    return this.belongsTo('Address', 'mailingAddress_id')\n  },\n  admins: function () {\n    return this.belongsToMany('User').through('Admin')\n  }\n})\nmodule.exports = bookshelf.model('Org', Org)\n```\n``` javascript\n// models/Admin.js\nvar bookshelf = require('../bookshelf')\nvar Admin = bookshelf.Model.extend({\n  tableName: 'admins'\n})\nmodule.exports = bookshelf.model('Admin', Admin)\n```\nNote two things:\n1. The Org model returns the correct admin only if its relationship to the User model is expressed as return this.belongsToMany('User').through('Admin'), while the User model is expressed using return this.hasOne('Org').through('Admin', 'id'). I don\u2019t quite understand why the difference in the methods (.belongsToMany() vs .hasOne()) in this relationship since neither table make reference to the admins table nor each other (the admins junction table being the only place where this relationship is expressed in the database). Your above suggestions makes more sense to me (where they both use .belongsToMany()). Any idea why this is?\n2. Including user and org methods on the Admin model doesn\u2019t seem to have any effect on the outcome. I imagine this is to be expected, as those methods are for my use and not really for Bookshelf to be able to use the Admin model as a JoinModel. Please correct me if I\u2019m wrong.\nThanks again!\n. Thanks for the explanation of the differences between those relationship methods! Coming from having used mongoDB for quite a while now, I'm still wrapping my head around relational DBs.\nYour explanation makes sense to me, and like you I find the current state of events odd. I would expect .hasOne('Org').through('Admin') on the User model and .hasMany('User').through('Admin') on the Org model to produce the relations we want. However, when I use .hasMany() on the Org model the result is different (and incorrect). In that case, the user that I get on farm.related('admins') shares the farm\u2019s id. Most importantly, I would expect the behavior to be consistent from either end, yet this seems not to be the case.\n. Hey, @rhys-vdw. Could you clarify what you mean by the exact relation definition?\nI just found something which I think is a clue as to what\u2019s wrong. I re-seeded my test db to ensure none of the records share primary ids, and that makes user.related('org') return no org at all using the latest User model described above. When I tried removing the 'id' parameter from the .through('Admin') method on the User model, I got this error:\n\nError: select \"farms\"._, \"admins\".\"id\" as \"_pivot_id\", \"admins\".\"user_id\" as \"_pivot_user_id\" from \"farms\" inner join \"admins\" on _\"admins\".\"id\" = \"farms\".\"admin_id\"* where \"admins\".\"user_id\" in (12) - SQLITE_ERROR: no such column: farms.admin_id\n\n(Note we switched from orgs to farms between yesterday and today because we realized there\u2019s a good case for having multiple types of groupings in the future. I hope this isn\u2019t confusing; only the name changed, not the schema or the relationships.)\nI think what\u2019s going on is that it is not using admins as a junction table. Rather, it is trying to find a reference to the admins\u2019s primary key in the farms table. Maybe this is how a JoinModel is supposed to work and I need to use something different for a junction table?\nI know that your first solution above (where User and Org/Farm each call each other with this.hasMany/One('Admin')) will return the correct entries, but it returns the junction table entry: { id: 32, farm_id: 5, user_id: 12 }, which I would then need to expand through the Admin model methods. That would mean I end up having to do something like user.related('farm').related('farm') to get to the farm that a user admins. I\u2019d like to avoid this as much as possible, as it\u2019s not very intuitive.\n. Re-reading the .through() documentation and examples, I think it was designed to assist relationships in a single direction. So, if User has one Farm through Admin, Bookshelf expects Admin to also have one Farm. A junction table is different in that User and Farm each has one or many references in the admins table.\nhasOne().through() expects this: User > Admin > Farm, where the farms table would include a admin_id column. A junction table is more like this: User > Admin < Farm, where the admins table is expected to include the references to the other two tables via user_id and farm_id.\n. How do I override the table name when using .belongsToMany()?\nThanks for the resource! It certainly explains a lot. From that document, I see that has_many :through association describes my needs exactly. From that document:\n\nOn the other hand, the has_and_belongs_to_many association is slightly different in that it does not establish a join model at all, so the junction table doesn\u2019t really require a primary id key:\n\nI\u2019m perfectly comfortable using this second paradigm, as I don\u2019t expect to need to query the admins table directly through a model anyway. However, while one Farm might have multiple admins, any one User may only admin a single farm. Naturally, when I use this.belongsToMany('Farm').through('Admin'), user.related('farm') returns a collection of farms with a single farm. Any way to make it so it returns the one farm?\n. Thanks a million, @ricardograca!\nthis.belongsToMany('Farm', 'admins') works like a charm on both models. this.belongsToMany('Farm', 'admins').first(), however, throws an error:\n\nTypeError: Cannot read property 'relatedData' of undefined\n. Full error stack below:\n\nTypeError: Cannot read property 'relatedData' of undefined\n      at EagerRelation.<anonymous> (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/lib/eager.js:26:30)\n      at EagerRelation.tryCatcher (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/util.js:26:23)\n      at EagerRelation.eagerFetch (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/method.js:15:34)\n      at EagerRelation.<anonymous> (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/lib/base/eager.js:68:33)\n      at EagerRelation.tryCatcher (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/util.js:26:23)\n      at EagerRelation.fetch (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/method.js:15:34)\n      at _handleEager (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/lib/model.js:1296:56)\n      at null.<anonymous> (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/lib/model.js:675:21)\n      at Object.tapHandler (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/finally.js:63:31)\n      at Object.tryCatcher (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/util.js:26:23)\n      at Promise._settlePromiseFromHandler (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/promise.js:507:31)\n      at Promise._settlePromiseAt (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/promise.js:581:18)\n      at Promise._settlePromises (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/promise.js:697:14)\n      at Async._drainQueue (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/async.js:123:16)\n      at Async._drainQueues (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/async.js:133:10)\n      at Immediate.Async.drainQueues [as _onImmediate] (/Users/agarzola/git/cropshare-webapp/node_modules/bookshelf/node_modules/bluebird/js/main/async.js:15:14)\n      at processImmediate [as _immediateCallback] (timers.js:383:17)\n. In the user model, like so:\njavascript\nvar User = bookshelf.Model.extend({\n  tableName: 'users',\n  // ...\n  farm: function () {\n    return this.belongsToMany('Farm', 'admins').first()\n  },\n  // ...\n})\n.related('farm').first() on an already fetched user works, though.\n. Hey, @rhys-vdw. Your suggestion was the first thing I tried. As I documented above, here\u2019s the error that produces:\n\nError: select \"farms\".*, \"admins\".\"id\" as \"_pivot_id\", \"admins\".\"farm_id\" as \"_pivot_farm_id\" from \"farms\" inner join \"admins\" on \"admins\".\"farm_id\" = \"farms\".\"id\" inner join \"users\" on \"admins\".\"id\" = \"users\".\"admin_id\" where \"users\".\"id\" in (12) - SQLITE_ERROR: no such column: users.admin_id\n     at Error (native)\n\nNotice how it\u2019s expecting users table to have an admin_id column, which it aims to use to find a row in the admins table: inner join \"users\" on \"admins\".\"id\" = \"users\".\"admin_id\".\n. It\u2019s as if .belongsTo().through() expects This to have a interim_id so that it can find the Interim, which will have a target_id so that it can find Target. I think that\u2019s how it\u2019s designed to work. Likewise, .hasOne().through() expects Interim to have a this_id (which is true in this case) but then also applies that \u201chas logic\u201d to expect Target to have an interim_id.\nThis is what I meant earlier when I said that .through() is meant to work in one direction: This HAS > Interim HAS > Target or This BELONGSTO > Interim BELONGSTO > Target. There seems to be no way to express This HAS > Interim BELONGSTO > Target.\nThis is inconsistent with the way ActiveRecord explains the has-through relation in the documentation that @ricardograca linked to. This is the diagram they use to describe it:\n\nNotice how This and Target each has_many of each other :through the Interim. The Interim belongs_to This and Target.\n. I see, so follow up question: overriding the Model.set() method should work when using Model.save(), correct? I took a gander at Model.save() and saw that it uses Model.set() before inserting or updating.\nIf not, I suppose I could do something similar with Model.save() where I cycle through current attributes get rid of anything not in allowedAttributes, then parentSave.call(this)?\nIf I have to define these attributes anywhere in my code, I\u2019d rather do it in a model than in application code because redefining data structures \u2014which should only really be defined by the DB\u2019s schema\u2014 should at least happen somewhere related to data structure, and not some arbitrary application library.\nThanks!\n. I see, so follow up question: overriding the Model.set() method should work when using Model.save(), correct? I took a gander at Model.save() and saw that it uses Model.set() before inserting or updating.\nIf not, I suppose I could do something similar with Model.save() where I cycle through current attributes get rid of anything not in allowedAttributes, then parentSave.call(this)?\nIf I have to define these attributes anywhere in my code, I\u2019d rather do it in a model than in application code because redefining data structures \u2014which should only really be defined by the DB\u2019s schema\u2014 should at least happen somewhere related to data structure, and not some arbitrary application library.\nThanks!\n. Update on this: Overriding Model.set() was not the best solution for my situation because it interferes with joins. I use joins when fetching and because Model.set() would filter out any keys not corresponding to a column on the table, everything I selected from the joined table would get ignored.\nThat tells me that Model.set() is called in a much wider variety of situations than I would like to mess with, so I decided to specifically target Model.save() instead. My solution follows Rhys\u2019 idea of creating a WhitelistModel that overrides the method in question to filter out unwanted keys before actually saving. It looks like this:\n``` javascript\n// models/WhitelistModel.js\nvar bookshelf = require('../bookshelf')\nvar parentSave = bookshelf.Model.prototype.save\nvar _ = require('lodash')\nvar WhitelistModel = bookshelf.Model.extend({\n  allowedAttributes: [],\n  save: function (key, value, options) {\n    this.attributes = _.pick(this.attributes, this.allowedAttributes)\n    return parentSave.call(this, key, value, options)\n  }\n})\nmodule.exports = WhitelistModel\n```\n``` javascript\n// models/Order.js\nvar bookshelf = require('../bookshelf')\nvar WhitelistModel = require('./WhitelistModel')\nvar Order = WhitelistModel.extend({\n  tableName: 'orders',\n  // some relationships here\u2026\n  allowedAttributes: [\n    'id', 'farm_id', 'internalIdentifier', 'comment'\n  ]\n})\nmodule.exports = bookshelf.model('Order', Order)\n```\n``` javascript\n// models/Detail.js\nvar bookshelf = require('../bookshelf')\nvar WhitelistModel = require('./WhitelistModel')\nvar Detail = WhitelistModel.extend({\n  tableName: 'details',\n  allowedAttributes: [ 'id', 'order_id', 'client_id' ]\n})\nmodule.exports = bookshelf.model('Detail', Detail)\n```\nThis way, I get the best of both worlds: Model.set() is left intact, allowing me the flexibility to continue joining arbitrary tables on fetch; and Model.save() strips out any disallowed columns before inserting a new record. Now I can write my application code in a way that is (almost completely) data structure agnostic, which was my goal:\n``` javascript\nfunction createOrder (order) {\n  return Bookshelf.transaction(trx => {\n    return Order.forge(order).save(null, { transacting: trx })\n    .tap(newOrder => {\n      order.order_id = newOrder.id\n      return Detail.forge(order).save(null, { transacting: trx })\n    })\n  })\n}\ncreateOrder(order)\n```\nI pass the order object to both the Order model and the Detail model w/o worrying about breaking it down into separate, schema-compliant objects.\nThanks for pointing me in the right direction, @rhys-vdw!\n. Update on this: Overriding Model.set() was not the best solution for my situation because it interferes with joins. I use joins when fetching and because Model.set() would filter out any keys not corresponding to a column on the table, everything I selected from the joined table would get ignored.\nThat tells me that Model.set() is called in a much wider variety of situations than I would like to mess with, so I decided to specifically target Model.save() instead. My solution follows Rhys\u2019 idea of creating a WhitelistModel that overrides the method in question to filter out unwanted keys before actually saving. It looks like this:\n``` javascript\n// models/WhitelistModel.js\nvar bookshelf = require('../bookshelf')\nvar parentSave = bookshelf.Model.prototype.save\nvar _ = require('lodash')\nvar WhitelistModel = bookshelf.Model.extend({\n  allowedAttributes: [],\n  save: function (key, value, options) {\n    this.attributes = _.pick(this.attributes, this.allowedAttributes)\n    return parentSave.call(this, key, value, options)\n  }\n})\nmodule.exports = WhitelistModel\n```\n``` javascript\n// models/Order.js\nvar bookshelf = require('../bookshelf')\nvar WhitelistModel = require('./WhitelistModel')\nvar Order = WhitelistModel.extend({\n  tableName: 'orders',\n  // some relationships here\u2026\n  allowedAttributes: [\n    'id', 'farm_id', 'internalIdentifier', 'comment'\n  ]\n})\nmodule.exports = bookshelf.model('Order', Order)\n```\n``` javascript\n// models/Detail.js\nvar bookshelf = require('../bookshelf')\nvar WhitelistModel = require('./WhitelistModel')\nvar Detail = WhitelistModel.extend({\n  tableName: 'details',\n  allowedAttributes: [ 'id', 'order_id', 'client_id' ]\n})\nmodule.exports = bookshelf.model('Detail', Detail)\n```\nThis way, I get the best of both worlds: Model.set() is left intact, allowing me the flexibility to continue joining arbitrary tables on fetch; and Model.save() strips out any disallowed columns before inserting a new record. Now I can write my application code in a way that is (almost completely) data structure agnostic, which was my goal:\n``` javascript\nfunction createOrder (order) {\n  return Bookshelf.transaction(trx => {\n    return Order.forge(order).save(null, { transacting: trx })\n    .tap(newOrder => {\n      order.order_id = newOrder.id\n      return Detail.forge(order).save(null, { transacting: trx })\n    })\n  })\n}\ncreateOrder(order)\n```\nI pass the order object to both the Order model and the Detail model w/o worrying about breaking it down into separate, schema-compliant objects.\nThanks for pointing me in the right direction, @rhys-vdw!\n. ",
    "forstermatth": "Yea, Ill throw one up later today.\n. I'd love to see a split view introduction of how to use the library separate and more visible than the API docs, similar to the Stripe or Objection.js docs.. Would using CircleCI 2.0 be an option?. ",
    "chrisbroome": "As promised, here's the association definition with the SQL output:\nbelongsToMany('Author', 'author_book')\nSQL\n    select `author`.*\n         , `author_book`.`book_id` as `_pivot_book_id`\n         , `author_book`.`author_id` as `_pivot_author_id`\n      from `author`\ninner join `author_book` on `author_book`.`author_id` = `author`.`id`\n     where `author_book`.`book_id` in (?)\n\n.belongsTo('Author').through('AuthorBook')\nSQL\n     select `author`.*\n          , `author_book`.`id` as `_pivot_id`\n          , `author_book`.`author_id` as `_pivot_author_id`\n       from `author`\n inner join `author_book` on `author_book`.`author_id` = `author`.`id`\n inner join `book` on `author_book`.`id` = `book`.`author_book_id`\n      where `book`.`id` in (?)\nNotice that the _pivot_id is incorrect\n\nbelongsTo('Author').through('AuthorBook', 'author_id', 'book_id')\nSQL\n     select `author`.*\n          , `author_book`.`id` as `_pivot_id`\n          , `author_book`.`author_id` as `_pivot_author_id`\n       from `author`\n inner join `author_book` on `author_book`.`author_id` = `author`.`id`\n inner join `book` on `author_book`.`id` = `book`.`author_id`\n      where `book`.`id` in (?)\nNotice that book_id is never used.\n\nTo make the last example more clear, I'll give one last example with column names that don't exist just to emphasize the point:\nbelongsTo('Author').through('AuthorBook', 'through_foreign_key', 'other_key')\nSQL\n    select `author`.*\n         , `author_book`.`id` as `_pivot_id`\n         , `author_book`.`author_id` as `_pivot_author_id`\n      from `author`\ninner join `author_book` on `author_book`.`author_id` = `author`.`id`\ninner join `book` on `author_book`.`id` = `book`.`through_foreign_key`\n     where `book`.`id` in (?)\n\nThe fix\nThe SQL produced by the first case, belongsToMany('Author', 'author_book') is the correct SQL. In order to get belongsTo to output this SQL, we could let it accept a second parameter that specifies the join table to use \u2013 exactly like what belongsToMany does now. For example:\nJavaScript\nthis.belongsTo('Author', 'author_book');\nwould produce the same SQL as belongsToMany. The only thing that would change is that a Model would be returned with the first result, instead of Collection.\n. Yep. Here's hasMany('Author').through('AuthorBook')\nSQL\n    select `author`.*\n         , `author_book`.`id` as `_pivot_id`\n         , `author_book`.`book_id` as `_pivot_book_id`\n      from `author`\ninner join `author_book` on `author_book`.`id` = `author`.`author_book_id`\n     where `author_book`.`book_id` in (?)\nThis is incorrect because there is no author`.`author_book_id column\nThe primary problem with the belongsTo('Author').through('AuthorBook') SQL is that the join table's id is being used as the _pivot_id. I'll try to break this down as best I can. I'm not sure how to get line numbers to show up in language blocks, so I just added them in comments myself.\nSQL\n     select `author`.* -- line 1\n          , `author_book`.`id` as `_pivot_id` -- line 2\n          , `author_book`.`author_id` as `_pivot_author_id` -- line 3\n       from `author` -- line 4\n inner join `author_book` on `author_book`.`author_id` = `author`.`id` -- line 5\n inner join `book` on `author_book`.`id` = `book`.`author_book_id` -- line 6\n      where `book`.`id` in (?) -- line 7\nLine 2 should be ,author_book.book_idas_pivot_book_id`\nLine 6 should beinner join book on author_book.book_id = book.id -- line 5. I'm in the process of fixing this issue in my fork. Looking through the tests, I see that the use case forbelongsTo().through()` is to get a model's grandparent.\nBlog has many Post.\nPost has many Comment.\nComment belongs to Blog through Post.\nI think this is the source of my confusion because this is not the use case that I was describing above. Therefore I think no changes should be made to the belongsTo.through relationship type.\nThe relationship I'm describing is having an optional foreign key live on a join table (rather than as a nullable foreign key in the table itself).\nHere's an example schema for such a relationship where a user has either zero or one shopping carts. In other words, a shopping cart belongs to a user.\n``` SQL\nCREATE TABLE user (\n  id integer NOT NULL PRIMARY KEY,\n  name varchar(255) NOT NULL\n);\nCREATE TABLE cart (\n  id integer NOT NULL PRIMARY KEY\n);\nCREATE TABLE user_cart (\n  id integer NOT NULL PRIMARY KEY,\n  user_id integer NOT NULL,\n  cart_id integer NOT NULL\n);\nALTER TABLE user_cart ADD CONSTRAINT user_cart_user_id_fk FOREIGN KEY (user_id) REFERENCES user (id) ON DELETE CASCADE ON UPDATE CASCADE;\nALTER TABLE user_cart ADD CONSTRAINT user_cart_cart_id_fk FOREIGN KEY (cart_id) REFERENCES cart (id) ON DELETE CASCADE ON UPDATE CASCADE;\nALTER TABLE user_cart ADD CONSTRAINT user_cart_user_id_unique UNIQUE (user_id);\n```\nNote that the UNIQUE constraint confines this to be a zero or one type of relationship.\nMaybe the solution is to support explicit hasZeroOrOne and hasZeroOrOne.through relationships as described in #753. Also, I actually like the name hasOptional better.\n. ",
    "invernizzie": "It really gets to me how no one understood @ezra-quemuel's need. It's really so simple.\nHe needs to get a different model \"class\" instantiated depending on the type saved to the DB.\nSince some prefer concrete examples, let me try.\nI need to implement user login for an education application where there are two user types: Teachers and Students. They implement different behavior, but share the same data and both are users, so the best way to go would be to save them to a single table (\"users\") but get a specific instance of the proper type when fetching. There's a specific requirement here that makes it specially useful to share a table: unique usernames.\nWhat I have during the login operation is the username and password. I find the user given its username and password (disregard security issues):\njavascript\nUser.forge({username: req.params.username, password: req.params.password})\n.fetch()\n.then(user => {\n  user.doPostLoginStuff()\n})\nI want a polymorphic dispatch of user.doPostLoginStuff() because Teacher and Student have different implementations of such a method. So I would really love to be able to tell bookshelf \"use the 'type' column to identify the type of my model and instantiate Student or Teacher as necessary\".\nThis is a basic inheritance feature of ORMs. Some will even create the \"type\" column for you and assign its proper value at save time, without the client programmer even knowing how it's done. I'm not asking for that much, simply a way of hooking into bookshelf to getting it to work. I could do something like this:\n``` javascript\nconst USER_TYPES = {\n  'student': require('./Student'),\n  'teacher': require('./Teacher')\n}\nconst User = bookshelf.Model.extend({\n  / instance methods (shared user behavior) /\n}, {\n  findByUsername(username) {\n    this.forge({username}).fetch()\n    .then(user => {\n      const UserType = USER_TYPES[user.type]\n      // Next line probably messes up relations, another pain point.\n      // But there might be a way to solve that too.\n      return UserType.forge(user.attributes)\n    })\n  }\n})\n```\nBUT! And that's a big but, when users are fetched as members of a collection, this is not used. And there's no way to change the type of a JS object, there's no way around that using event handlers. This should be handled when, after a SELECT is complete, bookshelf instantiates models for each row.\n. It really gets to me how no one understood @ezra-quemuel's need. It's really so simple.\nHe needs to get a different model \"class\" instantiated depending on the type saved to the DB.\nSince some prefer concrete examples, let me try.\nI need to implement user login for an education application where there are two user types: Teachers and Students. They implement different behavior, but share the same data and both are users, so the best way to go would be to save them to a single table (\"users\") but get a specific instance of the proper type when fetching. There's a specific requirement here that makes it specially useful to share a table: unique usernames.\nWhat I have during the login operation is the username and password. I find the user given its username and password (disregard security issues):\njavascript\nUser.forge({username: req.params.username, password: req.params.password})\n.fetch()\n.then(user => {\n  user.doPostLoginStuff()\n})\nI want a polymorphic dispatch of user.doPostLoginStuff() because Teacher and Student have different implementations of such a method. So I would really love to be able to tell bookshelf \"use the 'type' column to identify the type of my model and instantiate Student or Teacher as necessary\".\nThis is a basic inheritance feature of ORMs. Some will even create the \"type\" column for you and assign its proper value at save time, without the client programmer even knowing how it's done. I'm not asking for that much, simply a way of hooking into bookshelf to getting it to work. I could do something like this:\n``` javascript\nconst USER_TYPES = {\n  'student': require('./Student'),\n  'teacher': require('./Teacher')\n}\nconst User = bookshelf.Model.extend({\n  / instance methods (shared user behavior) /\n}, {\n  findByUsername(username) {\n    this.forge({username}).fetch()\n    .then(user => {\n      const UserType = USER_TYPES[user.type]\n      // Next line probably messes up relations, another pain point.\n      // But there might be a way to solve that too.\n      return UserType.forge(user.attributes)\n    })\n  }\n})\n```\nBUT! And that's a big but, when users are fetched as members of a collection, this is not used. And there's no way to change the type of a JS object, there's no way around that using event handlers. This should be handled when, after a SELECT is complete, bookshelf instantiates models for each row.\n. ",
    "tbug": ":+1:\nI checked both things before opening the PR, so it should both build and pass the tests :)\nI'll see if I get time to change it tomorrow (Time is 02:21 here)\n. ",
    "MartinMuzatko": "I already would be happy to get related data as flat object. Right now, by invoking .toJSON I get the related data as nested objects. The API consumer is not interested or concerned with how especially 1:1 relations are handled, but would rather have the data extended on the main object. Is that possible yet with bookshelf?. What about toJSON? I thought the withRelated property is here to eagerly load the relations.\ntoJSON does not take that into account.. We are facing the very same problem.\nWe created a lot of information system methods to satisfy specific information needs and now we are faced with needing transactions.\nWe would need to update EVERY single method with another parameter, which makes adding new parameters to the function very painful in the future.\nWe would need to pass along the transacting handle in every function call.\nI had the same thoughts implementing such a mechanism.\nInstead of passing the options to withTransaction, I would rather use the spread operator the other way around for my implementation, just in case the same madness is required for another parameter.\n``` js\nwithTransaction() {\n    const t = getTransaction()\n    if (t) return { transacting: t }\n    return {}\n}\nfindByEmail() {\n    User.where({ email }).fetch({require: true, ...withTransaction()})\n}\n```\nAlso, I don't know if there is harm in always using transacting: t, if t is null for usual actions.\n@pldin601 by the way, I think you want to do transactions.shift(), this removes the first element. unshift without parameter does nothing with the array.. By the way. I found that sending two transactions at the same time does not work with this approach.\nYou would need a queue for the transactions, otherwise you would end up always using the last handle.\nE.g.:\njs\nawait Promise.all([\n    doInTransation(async () => {\n        await User.insert(1)\n        await User.insert(2)\n    }),\n    doInTransation(async () => {\n        await User.insert(3)\n        await User.insert(4)\n    })\n])\nThere, you always end up with two callbacks using the same handle.\nThe two callbacks are simultaneously started with both handles present. Within the call of .save or .fetch, you always use the last handle.\nFor this you get a SubError after the timeout - that the transaction cannot complete.. Yes. Right now we want to get the columns to validate which fields are allowed to set and which need to be filled in. So if there are fields missing, we can tell what exactly is missing.. Right now, I also do not clearly see the benefit of doing .get('attribute'), other than it being shorter than model.attributes.attribute by 3 characters.\nHaving a documentation why to use .get or what other features it holds, would be nice. ",
    "oscaroceguera": "My solution was : \n```\ncategories: function () {\n    return this.belongsTo('Category', 'category_id');\n  }\n```\nposts : function () {\n      return this.hasMany('Post');\n   }\n. ",
    "tulathorn": "Hi I also have this problem and cannot solve with solution above. Here is my code.\n../user/model.js\n```javascript\nconst Bookshelf = require('../bookshelf')\nconst Reservation = require('../reservations/model')\nconst User = Bookshelf.model('User', {\n  tableName: 'UserInfo',\n  reservations: function() {\n    return this.hasMany(Reservation, 'UserID', 'UserID')\n  }\n})\nmodule.exports = User\n```\n../reservation/model.js\n```javascript\nconst Bookshelf = require('../bookshelf')\nconst User = require('../users/model')\nconst Reservation = Bookshelf.model('Reservation', {\n  tableName: 'Reservations',\n  userInfo: function() {\n    return this.belongsTo(User, 'UserID', 'UserID')\n  }\n})\nmodule.exports = Reservation\n```\nThe error said: \"A valid target model must be defined for the Reservations belongsTo relation\". ",
    "espiler": "@ricardograca When I use your code I get the model id I've passed in, but the model is never saved to the db, and I am not usually immediately destroying a model I've just created. Better, though, it looks like works properly if I fetch before destroying. Therefore, I can pass the needed model info to the 'destroying' event if I use: \nm.Customer.where({id: 9}).fetch()\n.then( function(customer){\n    customer.destroy()\n});\nI'll have to do that for now, but it seems unnecessarily long for a simple destroy, especially because the original m.Customer.where({id: 9}).destroy(); does, in fact, destroy customer 9, assumedly by just building a query that does so. I would suggest a fetch (initial SELECT query) to be implicit when using a 'destroying' event, in order to provide this kind of information under the hood. Thanks! \n. Thanks, I can work with that. More clear now on new model()  for uses other than CREATE operations, and I'll put a fetch in my destroying event when having other model attributes is necessary. \n. ",
    "mugli": "Ghost (a blogging platform) uses bookshelf: https://github.com/TryGhost/Ghost/tree/master/core/server/models\n. Soapee (Soap Making Community and Resources) uses bookshelf: https://github.com/nazar/soapee-api/tree/master/src/models\n. I'll love to, please let me find a few more so that it becomes worth adding there. Should I add this as a new question under F.A.Q or you prefer it anywhere else?\n. NodeZA (Node.js information portal and social platform for developers in South Africa) uses bookshelf: https://github.com/qawemlilo/nodeza/tree/master/models\n. Sunday Cook (A social cooking event platform) uses bookshelf: https://github.com/sunday-cooks/sunday-cook/tree/master/server/bookshelf\n. FlyptoX (Open-source Node.js cryptocurrency exchange) uses bookshelf: https://github.com/FlipSideHR/FlyptoX/tree/master/server/models\n. ",
    "crdueck": "I can create a PR, but should the docs be changed to reflect the current behaviour or vise-versa?\nPersonally I'd rather require=true by default since it's much more convenient to catch a NoRowsDeletedError (using a promise library) than check the returned model for null. Also this would be consistent with Model#save which does have require=true by default.\n. Resolved by https://github.com/bookshelf/bookshelf/pull/1779. Resolved by https://github.com/bookshelf/bookshelf/pull/1779. ",
    "a0viedo": "@ricardograca thank you!\n. ",
    "miguelcobain": "@rhys-vdw Three things:\n1. Thank you!\n2. You probably mean .save().then(student => instead of .save(student =>, correct?\n3. Each item of courses should also have a studentId, but it looks like bookshelf is trying to save them with a null value. Do I need to set studentIdto each of the join models?\n. > Side note: I noticed that this property of create is not documented, if you try it out could you confirm that it works?\nI can confirm that it works!\nHow would the code look like if recursive saving with withRelated worked?\n. @rhys-vdw Something came up that I think is somewhat related with this issue. So I thought to include it here for anyone that may need it.\nThe problem is related with orphans. Example:\n- I save an object like:\njson\n{\n  \"firstName\": \"Miguel\",\n  \"lastName\": \"Andrade\",\n  \"courses\": [\n    {\n      \"course_id\": 1,\n      \"discount\": 0.23\n    },\n    {\n      \"course_id\": 4,\n      \"discount\": 0.33\n    }\n  ]\n}\nBoth inner objects got ids 1 and 2 respectively.\n- Then, the user removes one of the inner models and clicks save, so I'm now saving:\njson\n{\n  \"firstName\": \"Miguel\",\n  \"lastName\": \"Andrade\",\n  \"courses\": [\n    {\n      \"id\": 1,\n      \"course_id\": 1,\n      \"discount\": 0.23\n    }\n  ]\n}\nThis should issues an update, but it is intended to also generate a DELETE for the now orphan courses id 2.\nThis is a similar feature as JPA orphanRemoval (more info).\nHow could I get a similar behavior? My first instinct is to use underlying knex to DELETE courses NOT IN the list of ids I'm saving.\nA code example would help a lot.\nAlso, I can create a separate issue for orphanRemoval, if you feel that it is within the scope of this project, and not just a help request. :)\nThanks.\n. ",
    "aj0strow": "Yeah that works, but it bothers me to hit database twice. I realize it doesn't matter for 99% projects, but it's logically incorrect, u know?\n. Yeah, went with using Knex directly and removed Bookshelf from the project. \n. Here's what I'm using. Start with a unique constraint. \n``` js\n// migration file\nknex.table(\"table_name\", t => {\n  t.unique(\"unique_column_name\")\n  t.unique(\"compound_index\", \"part_two\")\n})\n```\nThen count duplicates on each create or save, respecting transactions, and filtering out the current model from the count. \njs\nfunction assertUnique(/* columns */) {\n  const columns = _.toArray(arguments)\n  if (columns.length === 0) {\n    throw new Error(\"please pass unique columns\")\n  }\n  return function(model, attributes, options) {\n    const hasChanged = _.some(columns, column => {\n      return model.hasChanged(column)\n    })\n    if (model.isNew() || hasChanged) {\n      return this.constructor.query(q => {\n        columns.forEach(column => {\n          q.where(column, '=', model.get(column))\n        })\n        if (!model.isNew()) {\n          q.where(model.idAttribute, '<>', model.id)\n        }\n      })\n      .count({ transacting: options.transacting })\n      .then(n => {\n        if (n > 0) {\n          return bluebird.reject({\n            name: \"DuplicateError\",\n            message: columns.join(\", \")\n          })\n        }\n      })\n    }\n  }\n}\nThen run the assertion for any model with unique constraints. \n``` js\n// users\n  this.on(\"saving\", assertUnique(\"email\"))\n// posts\n  this.on(\"saving\", assertUnique(\"md5_hash\"))\n  this.on(\"saving\", assertUnique(\"user_id\", \"title\"))\n```\nIt should work for most use cases. \n. ",
    "timothykang": "A similar issue exists with Boolean values. SQLite stores and returns integers (0 and 1) instead, causing inconsistency between saved and fetched models:\n```\nnew Model({ foo: 'bar', baz: true }).save()\n    .then(function (model) {\n        console.log(model.toJSON());\n        // { \"foo\": \"bar\", \"baz\": true }\n    });\nModel.where({ foo: 'bar' }).fetch()\n    .then(function (model) {\n        console.log(model.toJSON());\n        // { \"foo\": \"bar\", \"baz\": 1 }\n    });\nModel.fetchAll()\n    .then(function (collection) {\n        console.log(collection.where({ 'baz': true }).length)\n        // 0\n        console.log(collection.where({ 'baz': 1 }).length)\n        // 1\n    });\n```\nI echo the desire for consistency, to reduce the pain of using methods like Collection.where() across database dialects.\nSeeing as how Bookshelf abstracts away database interaction using Knex, however, I wonder if the solution would need to reside in Knex instead.\n. ",
    "MWGitHub": "Thanks, a getter function using the registry plugin worked great! \nFor some reason when I tried\nget someProperty() {\n  return bookshelf.model('Bar').anotherProperty;\n}\nthe registry plugin didn't have 'Bar' in models yet but with getSomeProperty it did.\n. ",
    "lucaspiller": "I'm also having this issue. Fetching the records works correctly:\n```\n\ntag.belongsToMany(Item, 'taggings').fetch({debug: true})\n{ method: 'select',\n  options: {},\n  bindings: [ 1 ],\n  sql: 'select \"items\".*, \"taggings\".\"tag_id\" as \"_pivot_tag_id\", \"taggings\".\"item_id\" as \"_pivot_item_id\" from \"items\" inner join \"taggings\" on \"taggings\".\"item_id\" = \"items\".\"id\" where \"taggings\".\"tag_id\" = ?' }\n```\n\nBut fetching the count doesn't:\n```\n\ntag.belongsToMany(Item, 'taggings').count({debug: true})\n{ method: 'select',\n  options: {},\n  bindings: [],\n  sql: 'select count(*) as \"count\" from \"items\"'\n```\n\nI'm using bookshelf 0.9.2 and knex 0.10.0.\n. I'm also having this issue. Fetching the records works correctly:\n```\n\ntag.belongsToMany(Item, 'taggings').fetch({debug: true})\n{ method: 'select',\n  options: {},\n  bindings: [ 1 ],\n  sql: 'select \"items\".*, \"taggings\".\"tag_id\" as \"_pivot_tag_id\", \"taggings\".\"item_id\" as \"_pivot_item_id\" from \"items\" inner join \"taggings\" on \"taggings\".\"item_id\" = \"items\".\"id\" where \"taggings\".\"tag_id\" = ?' }\n```\n\nBut fetching the count doesn't:\n```\n\ntag.belongsToMany(Item, 'taggings').count({debug: true})\n{ method: 'select',\n  options: {},\n  bindings: [],\n  sql: 'select count(*) as \"count\" from \"items\"'\n```\n\nI'm using bookshelf 0.9.2 and knex 0.10.0.\n. ",
    "cauboy": "Thanks for your answer. hasTimestamps is set to true as you said.\nYour solution is just fine for the moment. The ease is worth the extra query :)\n. Nice! Thanks for mentioning it.\n\nAm 13.01.2016 um 22:37 schrieb Krist\u00f3f Poduszl\u00f3 notifications@github.com:\n1089 https://github.com/tgriesser/bookshelf/issues/1089\nThere is no need for an extra query, see my last line mentioning the solution\n\u2014\nReply to this email directly or view it on GitHub https://github.com/tgriesser/bookshelf/issues/1076#issuecomment-171442371.\n. @kripod\nShouldn't it be\n\n#!javascript\nreturn proto.save.apply(this, arguments)\nin your example (apply instead of call)?\n\n@ricardograca: sorry for addressing you wrongly in my first draft\n. @kripod\nShouldn't it be\n#!javascript\nreturn proto.save.apply(this, arguments)\nin your example (apply instead of call)?\n\n@ricardograca: sorry for addressing you wrongly in my first draft\n. ",
    "fredrikolovsson": "@cauboy & @ricardograca, I believe format should be replaced with parse in the issue name and the first two comments (the documentation link in the first comment correctly points to parse) \ud83d\ude04 \nAs an alternative to doing refresh() or overriding save(), I tried parsing the response attributes, which worked for me. Going back to the original example it would be like this instead:\njavascript\nnew User({name: \"Ann\"}).save().then(function(user) {\n  console.log(user.parse(user.attributes));\n});\n@ricardograca do you think it would make sense to add [parse=false] bool as an option to save()? If yes, I could try to make a PR for it.\n. ",
    "lukywong": "found out prototype.serialize.call(this, options)\n. Hi @vellotis, I tried using your way, error remains.\n. ",
    "jwhitmarsh": "I tried this code from here \n```\nvar BaseModel = bookshelf.Model.extend({\n/**\n * Orders the query by column in order\n * @param column\n * @param order\n */\norderBy: function (column, order) {\n    return this.query(function (qb) {\n        qb.orderBy(column, order);\n    });\n}\n\n});\nvar MyModel = BaseModel.extend({...});\nMyModel.orderBy('id', 'desc').fetchAll();\n```\nBut unfortunately that isn't working.\nTypeError: MyModel.orderBy is not a function\nIs there a way to add methods to a Model (or BaseModel that we can extend)?\n. No sooner after writing that, I fixed it:\n```\nvar BaseModel = bookshelf.Model.extend({...}, { // fix is here\n/**\n * Orders the query by column in order\n * @param column\n * @param order\n */\norderBy: function (column, order) {\n    return this.query(function (qb) {\n        qb.orderBy(column, order);\n    });\n}\n\n});\n```\nWhy does it have to be the second parameter of .extend()?\n. No probs, just a simple fetchAll is enough to replicate it:\nthis.Model // where this.Model === the Pack model\n      .fetchAll({\n        withRelated: ['locale']\n      });\nThat returns the result I posted in the OP. \n. No probs, just a simple fetchAll is enough to replicate it:\nthis.Model // where this.Model === the Pack model\n      .fetchAll({\n        withRelated: ['locale']\n      });\nThat returns the result I posted in the OP. \n. @ricardogama Yes. Thanks for your quick reply - let me know if there's anything I can do to help. . Apologies @ricardogama . \nI am calling save() with a where() clause. . Ah wait - apologies, I hadn't gone deep enough. This is actually failing because doing a get() is returning an object with created_at and updated_at set to Invalid Date. (I was then blindly passing the object through to save() which is why the error was throwing there). \nSo this is exactly the same as #1791. I'll close this. . Apologies if this is not the place to put this - thank you for this great fix, but one (rare) GOTCHA is that case statements in an order statement stop working now that all relationships are called with the distinct keyword. It's taken me a while to work out what was causing my errors so just wanted to put this out there. \nMy solution was to create a \"computed\" column using case in the select and to apply the order to that. Again, just in case someone in the future is experiencing the same thing. \nsql\nselect * \nfrom table \norder by \n    case when col1 is not null then col1 else col2 end\nbecomes \nsql\nselect *, \ncase when col1 is not null then col1 else col2 end as order_col \nfrom table\norder by order_col\n(obviously all achieved via knex, not raw sql). No probs. In the instance that I'm fixing it it's a fairly complicated query, but this is the key bit:\n``\nquery.column([\n    'sections.*', \n    this.database.knex.raw(\n        case when section_order > 0 then section_order else section_order_draft end as order_col\n    `)\n]);\nquery.orderByRaw(order_col);\n```\nfor reference, this used to look like:\n```\n// no need to define query.columns()\nquery.orderByRaw( \n    case when section_order > 0 then section_order end, case when section_order < 0 then section_order_draft end\n)\n```\nThe \"fixed\" way is actually much neater and, like I said, I only wanted to post this in case someone stumbled across it in the future (relevant XKCD https://xkcd.com/979/)\n. ",
    "smilingpoplar": "never mind, just inherit & use a base model\n. ",
    "Wtower": "The above makes great documentation on the subject. Ricardo thanks a lot for your timely response, it is very helpful. Haven't thought of that at all, I will give a try and get back.\n. In case of an app with a separate reusable module (which would contain the models), db.js (the first piece of code) would have to live in the app, so the requires of the models would have to point to the module path, correct?\nIs there some way to make bookshelf initialisation into the module? This would need to provide the configuration into the module somehow.\n. To answer my own question:\nThe important stuff is in the model's code. Ricardo's sample properly illustrates how to code the model. \nThen in a reusable's index file:\nfunction MyModule(db) {\n  this.user = require('./models/user')(db);\n}\nmodule.exports = function(db) {\n  return new MyModule(db);\n};\nIn the application's bookshelf file:\n```\nvar knexFile = require('../knexfile.js');\nvar knex = require('knex')(knexFile.development);\nvar bookshelf = require('bookshelf')(knex);\nbookshelf.plugin('registry');\nmodule.exports = bookshelf;\n// example of using a model from a reusable module\nvar user = require('mymodule')(bookshelf).user;\nmodule.exports.user = user;\n```\n. ",
    "vmasto": "I meant if it could be achieved within a model rather than using Array#map. Thanks, I'll look into serialize.\nAre there any drawbacks in making it permanent if I want my data to look like that all the time?\n. ",
    "danielepiccone": "Thanks @rhys-vdw, but using the plugin some fields will be always hidden/shown.\nI have an use case where I want to omit some fields just when serializing the model.\n. Thanks @rhys-vdw, but using the plugin some fields will be always hidden/shown.\nI have an use case where I want to omit some fields just when serializing the model.\n. :ok_hand: thanks\n. :ok_hand: thanks\n. Thanks for #1105 which is good to know.\nWhen I do \nProfile.collection().query(function(qb) {\n  qb.where('user_id', '=', 123)\n}).fetch()\n  .then(function(collection) {...\nis fine but when I camelcase the parameter in the condition it doesn't get transformed, which means .format is not called\nProfile.collection().query(function(qb) {\n  qb.where('userId', '=', 123)\n}).fetch()\n  .then(function(collection) {...\nI get \n{ method: 'select',\n  options: {},\n  bindings: [ 123 ],\n  sql: 'select \"profiles\".* from \"profiles\" where \"userId\" = ?' }\nwhile I am expecting user_id...\n. :ok_hand: thanks\n. I added a PR here #1149\nShould I also run npm run jsdoc to update the rest of the files?\n. I am experiencing the same error\nIt could be related to the registry plugin.\nreturn this.morphTo('concernable', 'Staff', 'Customer');\ninstead of \nreturn this.morphTo('concernable', Staff, Customer);\n. I am experiencing the same error\nIt could be related to the registry plugin.\nreturn this.morphTo('concernable', 'Staff', 'Customer');\ninstead of \nreturn this.morphTo('concernable', Staff, Customer);\n. :bow: \n. :bow: \n. Hi guys, I have the same issue here, using bookshelf 0.10 and Postgres 9.5\nA simple schema where profile_parts is a JSON column, saving this values in there \nprofileParts: [ { type: 'PROFILE', value: { link: 'https://foo.bar', image: testImage.id } } ]\nproduces this query \n{ method: 'insert',\n  options: {},\n  timeout: false,\n  cancelOnTimeout: false,\n  bindings: \n   [ '2016-08-26T11:23:12.485+02:00',\n     'USD',\n     'XXXXX',\n     '{\"{\\\\\"type\\\\\":\\\\\"PROFILE\\\\\",\\\\\"value\\\\\":{\\\\\"link\\\\\":\\\\\"https://foo.bar\\\\\",\\\\\"image\\\\\":\\\\\"70d0d7e0-e0ca-45b5-be48-252d9623b9e8\\\\\"}}\"}',\n     '123',\n     '2016-08-26T11:23:12.485+02:00',\n     'XXXX1',\n     'XXXX' ],\n  __knexQueryUid: '70b1c370-861f-46eb-b943-9ca318777d72',\n  sql: 'insert into \"vendors\" (\"created_at\", \"currency\", \"name\", \"profile_parts\", \"rate\", \"updated_at\", \"user_id\", \"verification_state\") values (?, ?, ?, ?, ?, ?, ?, ?) returning \"id\"',\n  returning: 'id' }\nThe value is not just escaped but the wrapping [...] are replaced with {...}\nand I got the same error invalid input syntax for type json'\nI am not using any plugin as referenced in https://github.com/seegno/bookshelf-json-columns/issues/7, just plain bookshelf\n. Might relate to https://github.com/tgriesser/knex/issues/1349#issuecomment-210627588\n. ",
    "phramos": "@dpiccone You can try to use omit-depp-lodash.\nI used a combination of the Visibility plugin and the omit-deep-lodash and this solved the problem for me. ",
    "dukeofsussex": "The problem is that even though the query is correct in my opinion and according to phpmyadmin, no stats are retrieved and I get an empty array back\n. I\u00b4m a 100% certain, I queried the db with the debug sql manually and it returned 4 entries.\nI need to convert the id, because when it is returned as an int, I lose the precision on the last few digits (instead of '76561198173039321' I receive '76561198173039300')\nConcerning the debug output: That\u00b4s a mistake on my behalf, I took the wrong log lines, it should be CONVERT of course, not CAST.\nEDIT\nWhat is odd is that it works with a \"normal\" int, but not with a bigint, passed as a string\n. @ricardograca: Shall I move this issue to Knex instead?\n. ",
    "AppSynergy": "Sure, no problem.\nI saw it more as an issue with the specific example given on\nhttp://bookshelfjs.org/, rather than an issue with knex.\nOn 25 January 2016 at 12:32, Ricardo Gra\u00e7a notifications@github.com wrote:\n\nThis is not a bookshelf issue. Can you open a similar issue over on knex's\nrepository?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1102#issuecomment-174492104\n.\n. Sure, no problem.\n\nI saw it more as an issue with the specific example given on\nhttp://bookshelfjs.org/, rather than an issue with knex.\nOn 25 January 2016 at 12:32, Ricardo Gra\u00e7a notifications@github.com wrote:\n\nThis is not a bookshelf issue. Can you open a similar issue over on knex's\nrepository?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1102#issuecomment-174492104\n.\n. I don't think it does work, not with mySQL anyhow. You need the unsigned, afaics.\n\nHas come up a few times on knex/issues.\nI can submit a PR for the tutorials if you like.\n. I don't think it does work, not with mySQL anyhow. You need the unsigned, afaics.\nHas come up a few times on knex/issues.\nI can submit a PR for the tutorials if you like.\n. ",
    "npatmaja": "Hi @rhys-vdw,\nThanks for the reply.\n\n\nIt will be very nice if this feature is available.\n\nLet's confirm what's actually going on here first. I just had a look at the detach code, and it's pretty straight forward. Perhaps not too hard to modify.\n\nYes, sorry for jumping into it too early.\nI just recreated my test case in another isolated mysql db, and found out that detach actually does a delete operation, which means that I have some error in either my code or database schema design/implementation previously. However, in my current test case, the detach doesn't delete all the rows in the interim table, as shown below in debug's mode print out:\n``\n{ method: 'select',\n  options: {},\n  bindings: [ 4, 1 ],\n  sql: 'selectmeta_field_int.* frommeta_field_intwheremeta_field_int.product_test_id= ? limit ?' }\n{ method: 'del',\n  options: {},\n  bindings: [ 5 ],\n  sql: 'delete frommeta_field_intwhereid` = ?' }\n```\nThe meta_field_int table before doing detach looks like:\n| id | product_test_id | meta_field_id | value |\n| --- | --- | --- | --- |\n| 5 | 4 | 5 | 50 |\n| 6 | 4 | 4 | 30 |\nand after the detach operation:\n| id | product_test_id | meta_field_id | value |\n| --- | --- | --- | --- |\n| 6 | 4 | 4 | 30 |\nAnd here's my bookshelf models and table definition for the above test case\n```\n// the detach operation\nProduct.forge({ id: 4 }).fieldInteger().detach();\n// model definition\nlet Product = bookshelf.Model.extend({\n  tableName: 'product_tests',\n  fieldInteger: function() {\n    return this.belongsToMany(MetaField)\n      .through(MetaFieldInt)\n      .withPivot(['value']);\n  }\n});\nlet MetaFieldInt = bookshelf.Model.extend({\n  tableName: 'meta_field_int',\n  product: function() {\n    return this.belongsTo(Product);\n  },\ncolumn: function() {\n    return this.belongsTo(MetaField);\n  }\n});\nlet MetaField = bookshelf.Model.extend({\n  tableName: 'meta_fields',\n  fieldInteger: function() {\n    return this.belongsToMany(Product)\n      .through(MetaField);\n  }\n});\n// DDL\nCREATE TABLE meta_fields (\n  id int(11) NOT NULL AUTO_INCREMENT,\n  code varchar(10) DEFAULT NULL,\n  PRIMARY KEY (id)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\nCREATE TABLE product_tests (\n  id int(11) NOT NULL AUTO_INCREMENT,\n  code varchar(10) DEFAULT NULL,\n  PRIMARY KEY (id)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\nCREATE TABLE meta_field_int (\n  id int(11) NOT NULL AUTO_INCREMENT,\n  product_test_id int(11) NOT NULL,\n  meta_field_id int(11) NOT NULL,\n  value int(11) DEFAULT '0',\n  PRIMARY KEY (id,product_test_id,meta_field_id),\n  KEY fk_1x (meta_field_id),\n  KEY fk_2x (product_test_id),\n  CONSTRAINT fk_1x FOREIGN KEY (meta_field_id) REFERENCES meta_fields (id) ON DELETE NO ACTION ON UPDATE NO ACTION,\n  CONSTRAINT fk_2x FOREIGN KEY (product_test_id) REFERENCES product_tests (id) ON DELETE NO ACTION ON UPDATE NO ACTION\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\n```\nJust wondering, is the above behaviour is expected, or am I missing something in my code? \nRegarding my original case, I will look into it further and will post it here if I have any update on it :)\n. Hi @rhys-vdw,\nThanks for the reply.\n\n\nIt will be very nice if this feature is available.\n\nLet's confirm what's actually going on here first. I just had a look at the detach code, and it's pretty straight forward. Perhaps not too hard to modify.\n\nYes, sorry for jumping into it too early.\nI just recreated my test case in another isolated mysql db, and found out that detach actually does a delete operation, which means that I have some error in either my code or database schema design/implementation previously. However, in my current test case, the detach doesn't delete all the rows in the interim table, as shown below in debug's mode print out:\n``\n{ method: 'select',\n  options: {},\n  bindings: [ 4, 1 ],\n  sql: 'selectmeta_field_int.* frommeta_field_intwheremeta_field_int.product_test_id= ? limit ?' }\n{ method: 'del',\n  options: {},\n  bindings: [ 5 ],\n  sql: 'delete frommeta_field_intwhereid` = ?' }\n```\nThe meta_field_int table before doing detach looks like:\n| id | product_test_id | meta_field_id | value |\n| --- | --- | --- | --- |\n| 5 | 4 | 5 | 50 |\n| 6 | 4 | 4 | 30 |\nand after the detach operation:\n| id | product_test_id | meta_field_id | value |\n| --- | --- | --- | --- |\n| 6 | 4 | 4 | 30 |\nAnd here's my bookshelf models and table definition for the above test case\n```\n// the detach operation\nProduct.forge({ id: 4 }).fieldInteger().detach();\n// model definition\nlet Product = bookshelf.Model.extend({\n  tableName: 'product_tests',\n  fieldInteger: function() {\n    return this.belongsToMany(MetaField)\n      .through(MetaFieldInt)\n      .withPivot(['value']);\n  }\n});\nlet MetaFieldInt = bookshelf.Model.extend({\n  tableName: 'meta_field_int',\n  product: function() {\n    return this.belongsTo(Product);\n  },\ncolumn: function() {\n    return this.belongsTo(MetaField);\n  }\n});\nlet MetaField = bookshelf.Model.extend({\n  tableName: 'meta_fields',\n  fieldInteger: function() {\n    return this.belongsToMany(Product)\n      .through(MetaField);\n  }\n});\n// DDL\nCREATE TABLE meta_fields (\n  id int(11) NOT NULL AUTO_INCREMENT,\n  code varchar(10) DEFAULT NULL,\n  PRIMARY KEY (id)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\nCREATE TABLE product_tests (\n  id int(11) NOT NULL AUTO_INCREMENT,\n  code varchar(10) DEFAULT NULL,\n  PRIMARY KEY (id)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\nCREATE TABLE meta_field_int (\n  id int(11) NOT NULL AUTO_INCREMENT,\n  product_test_id int(11) NOT NULL,\n  meta_field_id int(11) NOT NULL,\n  value int(11) DEFAULT '0',\n  PRIMARY KEY (id,product_test_id,meta_field_id),\n  KEY fk_1x (meta_field_id),\n  KEY fk_2x (product_test_id),\n  CONSTRAINT fk_1x FOREIGN KEY (meta_field_id) REFERENCES meta_fields (id) ON DELETE NO ACTION ON UPDATE NO ACTION,\n  CONSTRAINT fk_2x FOREIGN KEY (product_test_id) REFERENCES product_tests (id) ON DELETE NO ACTION ON UPDATE NO ACTION\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\n```\nJust wondering, is the above behaviour is expected, or am I missing something in my code? \nRegarding my original case, I will look into it further and will post it here if I have any update on it :)\n. ",
    "dannymidnight": "Hey @rhys-vdw, so this PR is about fixing a bug found when calling the model and collection methods  on the registry plugin in a different calling context as currently those methods are unsafely assuming that this is bound to the bookshelf object. My changeset makes that guarantee as seen in the test cases. \nI'm assuming this bug would generally only ever be encountered when a project is using some kind of pre-compilation step which in my case (using babel) was causing this to be undefined.\n. ",
    "dstringvc": "\"database is a global\" No reason other than transcription error. Tried to provide sample code that is more generic than my actual solution.\nbookshelf is global because it's used in other modules.\n. ",
    "mawoole": "Hi,\nI try your code below and it's work, but I would like to retrieve only some (and not all ) columns of activities (or feed). \nPlease, can you tell me how to do it?\nThanks\nuser.where({\n    id: 43\n  }).fetchAll({\n    withRelated: ['feed.userRelated', 'feed.activityTypes']\n  }).then(function(data) {\n    data = data.toJSON();\n    res.send(data);\n  });. Hi,\nI try your code below and it's work, but I would like to retrieve only some (and not all ) columns of activities (or feed). \nPlease, can you tell me how to do it?\nThanks\nuser.where({\n    id: 43\n  }).fetchAll({\n    withRelated: ['feed.userRelated', 'feed.activityTypes']\n  }).then(function(data) {\n    data = data.toJSON();\n    res.send(data);\n  });. ",
    "mytototo": "Hey @ricardograca.\nThank you very much for your quick answer. Just tried what you suggested and it works well. :-)\nI've read the Bookshelf documentation and sometimes examples are incomplete or explanations are not well detailed-- especially on associations' methods and migrations. That's too bad because the Knex documentation is really good!\nAnyway, we can consider this issue as closed.\nAgain, thanks a lot for your help.\n. No worries I completely understand. How can we help improving the documentation? I've searched for doc repos for Bookshelf and Knex but didn't find anything....\n. Awesome! Thanks a lot @ricardograca I appreciate.\n. ",
    "Aurelsicoko": "I have the same problem. The models are exactly the same as @mytototo : User and Article.\n``` javascript\nvar User, Article;\nUser = bookshelf.Model.extend({\n  tableName: 'user',\n  article: function() {\n    return this.hasMany(Article);\n  }\n});\nArticle = bookshelf.Model.extend({\n  tableName: 'article',\n  author: function() {\n    return this.belongsTo(User);\n  }\n});\n```\nWhen I tried to do this request but the author key is empty.\njavascript\nArticle.forge({id: 1}).fetch({\n    withRelated: 'author'\n});\nExpected:\njson\n{\n    \"id\": 1,\n    \"title\": \"Article 1\",\n    \"author\": {\n         \"id\": 3,\n         \"firstname\": \"John\",\n         ...\n    }\n}\nCurrent response:\njson\n{\n    \"id\": 1,\n    \"title\": \"Article 1\",\n    \"author\": {}\n}\nIt seems the value is not populated into the object. I enabled the debug option, and I got this:\nbash\n method: 'select',\n  options: {},\n  bindings: [ '1', 1 ],\n  sql: 'select \"article\".* from \"article\" where \"article\".\"id\" = ? limit ?' }\n{ method: 'select',\n  options: {},\n  bindings: [ undefined ],\n  sql: 'select \"user\".* from \"user\" where \"user\".\"id\" in (?)' }\n. @ricardograca: Thanks for this quick answer, I appreciate! I tried to specify the foreign key but it didn't work too and I can't pluralize the table names to fix it... Maybe I did something wrong?\n``` javascript\nUser = bookshelf.Model.extend({\n  tableName: 'user',\n  articles: function() {\n    return this.hasMany(Article, 'author');\n  }\n});\nArticle = bookshelf.Model.extend({\n  tableName: 'article',\n  author: function() {\n    return this.belongsTo(User, 'articles');\n  }\n});\n```\n. I tried to pluralize the table names and specified the foreign key for testing and it doesn't work too. I had still the same issue, the relation value isn't binding into the next request... \nDatabase schema:\n``\nCREATE TABLEarticle(idinteger NOT NULL PRIMARY KEY AUTOINCREMENT,created_atdatetime,updated_atdatetime,titlevarchar(255),authorinteger,\n    FOREIGN KEY(author) REFERENCESuser(id`)\n);\nCREATE TABLE user (\n    id    integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n    created_at    datetime,\n    updated_at    datetime,\n    firstname varchar(255)\n);\n```\nModels definition:\n```\nUser = bookshelf.Model.extend({\n  tableName: 'user',\n  articles: function() {\n    return this.hasMany(Article, 'author');\n  }\n});\nArticle = bookshelf.Model.extend({\n  tableName: 'article',\n  author: function() {\n    return this.belongsTo(User, 'articles');\n  }\n});\n```\nLogs:\n{ method: 'select',\n  options: {},\n  bindings: [ '1', 1 ],\n  sql: 'select \"articles\".* from \"articles\" where \"articles\".\"id\" = ? limit ?' }\n{ method: 'select',\n  options: {},\n  bindings: [ undefined ],\n  sql: 'select \"users\".* from \"users\" where \"users\".\"id\" in (?)' }\nWhen I tried this request, it works. I got all the articles of this user.\nUser.forge({id: 3}).fetch({\n    withRelated: 'articles'\n});\nHowever, on the other side, it's not working as I said.\nArticle.forge({id: 1}).fetch({\n    withRelated: 'author'\n});\n. @ricardograca: Sorry, I updated my previous post with the database schema and the model definitions.\n. @ricardograca: Did you have time to take a look at this (my) issue? I'm sorry to insist but I'm blocked on it. Thanks for your time!\n. @ricardograca: Thanks a lot, it works!\n. @absolux Thanks for your time! I got this error Error: ER_NO_SUCH_TABLE: Table 'professionnal.cities' doesn't exist. It's a correct behavior because this table is located in the cities database.. @absolux Thanks for your time! I got this error Error: ER_NO_SUCH_TABLE: Table 'professionnal.cities' doesn't exist. It's a correct behavior because this table is located in the cities database.. @absolux Thanks for your help, I found another solution. There is a ton of issues caused by this kind of association, so I decided to migrate the cities databases into the professional. . @absolux Thanks for your help, I found another solution. There is a ton of issues caused by this kind of association, so I decided to migrate the cities databases into the professional. . Oh, you're right! There is a typo in my table name. The name is professionnal_cities with two n.. Oh, you're right! There is a typo in my table name. The name is professionnal_cities with two n.. ",
    "Snack-X": "And looks like CI is good. Will it be OK?\n. ",
    "cuttlas": "Oh well. Thank you all!\n. ",
    "sapabg": "Is there any progress on this?. ",
    "TehNrd": "So my SQL skill are a bit on the weak side and I suppose I could just do the following with knex.raw but it seems a bit heavy handed. Is there a better way to accomplish this?\nEmployee.query(function(qb){ \n    //I am completely drawing a blank on how to structure this part of the query\n    qb.where('manager_id',bookshelf.knex.raw('(select id from employees where department = ?)', ['HR']));\n})\n.fetchAll()\n.then(function(models) {\n    console.log(models)\n});\n. Gosh dang it, I knew this question would warrant that type of reply. :-) Some of those I had found and some I missed. Even the ones I found, for some reason, I failed to fully comprehend solution or the answer was go do 'this' but there were not any example solutions provided. (Issues search leaves something to be desired).\nEssentially this is the query I needed to perform. As trivial as it is, this is what I kept getting snagged up on.\nSELECT *\n  FROM employee\n  WHERE manager_id = (select Id from employee WHERE department = 'HR')\nFor some reason in my head I thought this required some sort of join. (I'm terrible at SQL, but knex helps a lot!) My second post above does address this issue. I suppose it doesn't need to use knex.raw() but in this case that is actually shorter and simpler than building the select with knex.\n. ",
    "absolux": "@Uptown76  try out with\npersonWithAccounts.related('accounts').at(0).related('pivot').get('role_id');\n. Can you test after removing from sheet model file the line below\n\nconst Schedule = require('./schedule')\n\nI think its because of the circular dependency, sheet requires schedule and in turn schedule requires sheet\n. Try something like Foo.where({ name: 'baz' }).fetch({ withRelated: 'bars' }), it will fetch a Foo model with name baz and its related Bar models\n. read docs please\nhttp://bookshelfjs.org/#Collection-instance-detach\n. ``` js\nvar mdl = Model.forge(data)\nmdl.save().then(function () {\n  return mdl.fetch()\n})\n```\nOr redefine the save method to fetch fresh data after inserting\n. Here is my vision of your situation:\n``` js\nvar Paypal = Model.extend({\n  tableName: 'paypal_responses',\npayment: function() {\n    return this.morphOne('Payment', 'gateway')\n  }\n})\nvar WireTransfer = App.Model.extend({\n  tableName: 'wire_transfers',\npayment: function() {\n    return this.morphOne('Payment', 'gateway')\n  }\n}\nvar Payment = App.Model.extend({\n  tableName: 'payments', // it should be a table, not a view\ngateway: function() {\n    return this.morphTo('gateway', 'WireTransfer', 'Paypal')\n  },\nrequest: function() {\n    return this.belongsTo('Request', 'reference_code')\n  }\n})\nvar Request = App.Model.extend({\n  tableName: 'requests',\npayments: function() {\n    return this.hasMany('Payment', 'reference_code')\n  }\n}\n```\nAt last the payments table, will have the following columns:\n- id\n- gateway_id // related to paypal or wire transafer id\n- gateway_type \n- reference_code\n- ...\n. Indeed @chamini2 \nIt will be another manner to represent inheritance with tables, logically both paypal and wire_transfer are payment methods, but only the Payment model knows about the order request.\nI think bookshelf can handle { withRelated: [\"payments.gateway\"] }\n. Hello @rublev \nI notice that both subscriptions and plans tables contain user_id foreign key. so you can ge all specific user plans without the need for subscriptions table. No?\n. You got that error because the User Model is not yet registered in the registery !\nSo, you can register each model in your app by name and use those names instead of constructors. Look at this wiki how to do that.\nOr, instead, disable the registry plugin and require the related models inside the relations methods, like below:\n``` js\nvar bookshelf = require('../config/bookshelf')\nmodule.exports = bookshelf.Model.extend({\n  tableName: 'project',\n  hasTimestamps: true,\n  user:function() {\n    return this.belongsToMany(require('./User'));\n  },\n  frame: function () {\n    return this.hasMany(require('./Frame'));\n  }\n})\n```\nHope it helps \n. First of all, Privilege model should belong to both Role and Permission, not has one of each of them\n``` js\nvar Privilege = BBModel.extend({\n  tableName: 'privileges',\npermission: function() {\n    return this.belongsTo('Permission')\n  },\nrole: function() {\n    return this.belongsTo('Role')\n  }\n})\n```\n. Try this\n``` js\nvar User = BBModel.extend({\ntableName: 'users',\nhasTimestamps: ['createdAt', 'updatedAt'],\n/\n   * @returns a promise instead of a relation instance\n   /\n  permissions: function () {\n    var self = this\n    return PermissionCollection.query(qb => {\n      qb.innerJoin('privileges', 'permissions.id', 'privileges.permission_id')\n      qb.innerJoin('roles_users', 'privileges.role_id', 'roles_users.role_id')\n      qb.where({'roles_users.id': self.id})\n    }).fetch(['permissions.'])\n  },\nroles: function () {\n    return this.belongsToMany('Role')\n  }\n})\n```\nHope it works\n. @dvp0, permissions() doesn't return a relation object, so you cannot use it for eager loading.\nfollowing is possible, \njs\nusr.permissions().then(collection => { ... })\nbut not\njs\nUser.fetch({ withRelated: 'permissions' }).then(...)\n. > But without the registery plugin Im not able to do circular relationship? Like A to B but not B to A\n@orgertot try requiring the model inside the relation method, like\njs\nmodule.exports = internBookshelf.model('Case', {\n  tableName: 'cases',\n  hasTimestamps: true,\n  player: function() {\n    return this.belongsTo(require('./player'), 'playerid')\n  }\n  ...\n}\n...\nmodule.exports = externBookshelf.model('Player', {\n  tableName: 'players',\n  idAttribute: 'playerid',\n  hasTimestamps: false,\n  cases: function() {\n    return this.hasMany(require('./case'), 'playereid')\n  }\n  ...\n}\n. @alexey2baranov if you modify your code as below, only a single query is needed to fetch user's addresses,\njs\nUser.forge({ email: \"joe@example.com\", name: \"joe\" }).save().then(user => {\n  return Address.forge({ value: \"surgut\", user_id: user.get(\"id\") }).save().then(() => {\n    return user.load('addresses')\n  })\n})\n.then(user => {\n  console.log('Got user:', user.get('name'))\n  console.log('Got addresses:', user.related('addresses'))\n})\n. @ryanvanderpol could you try belongsToMany instead of hasMany\njs\n...\nchildren: function(){\n  return this.belongsToMany('User', 'relatives', 'parent_id', 'child_id')\n}\nparents: function () {\n  return this.belongsToMany('User', 'relatives', 'child_id', 'parent_id')\n}\n...\n. Just add the table name as prefix .where('brands.name', 'brandname')\n. Just add the table name as prefix .where('brands.name', 'brandname')\n. Maybe Brand.prototype.tableName, or directly within a model instance model.tableName.\nIs that what are you looking for ? \n. Maybe Brand.prototype.tableName, or directly within a model instance model.tableName.\nIs that what are you looking for ? \n. @Znarkus Try this\njs\nstatuses: function () {\n  return this\n    .belongsToMany('ProcessStatus')\n    .through('ProcessGroupStatus', 'group_id', 'status_id')\n}\n. @Znarkus Try this\njs\nstatuses: function () {\n  return this\n    .belongsToMany('ProcessStatus')\n    .through('ProcessGroupStatus', 'group_id', 'status_id')\n}\n. Sorry @Znarkus, I made a mistake. In fact it is status_id not status.id.\nI have just updated my previous comment\n\nNevermind, it didn't work.\n\ntry this instead\njs\nProcessGroup.forge({ id: groupId }).statuses().fetch(ops)\n. Sorry @Znarkus, I made a mistake. In fact it is status_id not status.id.\nI have just updated my previous comment\n\nNevermind, it didn't work.\n\ntry this instead\njs\nProcessGroup.forge({ id: groupId }).statuses().fetch(ops)\n. @lailo-ch \nActually No. because without the card_id field its impossible to attach feedbacks to their cards after an eager load.\nSo, I suggeste you to add a method to Card model which retrieves a card and its feedback ids\njs\nCard.findWithFeedbacks = function (publicId) {\n  return this.forge().query(function(qb) {\n    qb.where('status', '!=', cardStatus.DELETED);\n    qb.andWhere('public_id', '=', publicId);\n  })\n  .fetch().then(card => {\n    return card.feedback().pluck('id')\n    // store the ids somewhere and return the card\n    .then(ids => card.fbIds = ids).return(card)\n  })\n}\nIt's not an optimal solution, but it will give an insight to a better one\n. @lailo-ch \nActually No. because without the card_id field its impossible to attach feedbacks to their cards after an eager load.\nSo, I suggeste you to add a method to Card model which retrieves a card and its feedback ids\njs\nCard.findWithFeedbacks = function (publicId) {\n  return this.forge().query(function(qb) {\n    qb.where('status', '!=', cardStatus.DELETED);\n    qb.andWhere('public_id', '=', publicId);\n  })\n  .fetch().then(card => {\n    return card.feedback().pluck('id')\n    // store the ids somewhere and return the card\n    .then(ids => card.fbIds = ids).return(card)\n  })\n}\nIt's not an optimal solution, but it will give an insight to a better one\n. @gajus \nI think if you set model's hasTimestamps property as ['created_time', 'updated_time'] it will work.\n. @gajus \nI think if you set model's hasTimestamps property as ['created_time', 'updated_time'] it will work.\n. @vishchiv \nThe DateTime types are stored without time zone informations, and when you fetch those columns data, Bookshelf or any other library can't guess the missing time zone, and will use the server time zone instead.\nMy suggestion for you, is to use a Timestamp instead of DateTime (depending on your case), or always save dates in UTC, and change the time zone on display.. @vishchiv \nThe DateTime types are stored without time zone informations, and when you fetch those columns data, Bookshelf or any other library can't guess the missing time zone, and will use the server time zone instead.\nMy suggestion for you, is to use a Timestamp instead of DateTime (depending on your case), or always save dates in UTC, and change the time zone on display.. Hi @mochini \nThat kind of relationships is not yet supported by bookshelf. \nYou can nest relations by dot notation like roles.rights\njs\nUser.where({ id }).fetch({ withRelated: ['roles.rights'] }).then(user => { ... })\nIt will make 2 select queries to brain data, but it works. Hi @mochini \nThat kind of relationships is not yet supported by bookshelf. \nYou can nest relations by dot notation like roles.rights\njs\nUser.where({ id }).fetch({ withRelated: ['roles.rights'] }).then(user => { ... })\nIt will make 2 select queries to brain data, but it works. Hello @sombriks \nYou should override the primaryKey of the model as you did for the tableName. Hello @sombriks \nYou should override the primaryKey of the model as you did for the tableName. @sombriks \nYou are using a many to many relationship between catolico and lembrete, so you can use attach directly without saving manually the foreign keys \n```js\nconst Reminder = Bookshelf.Model.extend({\n  tableName: \"lembrete\",\ncatholics: function () {\n    return this.belongsToMany(Catholic, \"lembretecatolico\", \"idlembrete\", \"idcatolico\")\n  }\n})\nconst Catholic = Bookshelf.Model.extend({\n  tableName: \"catolico\",\nreminders: function () {\n    return this.belongsToMany(Reminder, \"lembretecatolico\", \"idcatolico\", \"idlembrete\")\n  }\n})\n// for example, after saving the reminder, you can attach the related Catholics\nnew Reminder({...}).save().then(reminder => reminder.catholics().attach(req.body)).then(...)\n```\nuseful links\nstackoverflow\ndocs\nHope it helps. @sombriks \nYou are using a many to many relationship between catolico and lembrete, so you can use attach directly without saving manually the foreign keys \n```js\nconst Reminder = Bookshelf.Model.extend({\n  tableName: \"lembrete\",\ncatholics: function () {\n    return this.belongsToMany(Catholic, \"lembretecatolico\", \"idlembrete\", \"idcatolico\")\n  }\n})\nconst Catholic = Bookshelf.Model.extend({\n  tableName: \"catolico\",\nreminders: function () {\n    return this.belongsToMany(Reminder, \"lembretecatolico\", \"idcatolico\", \"idlembrete\")\n  }\n})\n// for example, after saving the reminder, you can attach the related Catholics\nnew Reminder({...}).save().then(reminder => reminder.catholics().attach(req.body)).then(...)\n```\nuseful links\nstackoverflow\ndocs\nHope it helps. @sombriks \nAfter some research, I found the line responsible for the save, which call the knex builder, uses the idAttribute as returning value for the insert knex method.\nIf you give it '*', it will works, but only for insert. @sombriks \nAfter some research, I found the line responsible for the save, which call the knex builder, uses the idAttribute as returning value for the insert knex method.\nIf you give it '*', it will works, but only for insert. @RobAWilkinson try to replace hasMany->through with belongsToMany. @dwoowb \njs\nlanguages () {\n  return this.belongsToMany('Language', 'userLanguages', 'userId', 'languageId')\n}\nVisit the docs for more info. @jgardezi have you tried with debug: true config option ?. @Aurelsicoko Could you try\njs\ncities: function () {\n  this.belongsToMany(City, 'professional_cities').query(qb => qb.withSchema('professional'))\n}. You are welcome @Aurelsicoko \nBut, just a last question, what is the exact name of the joining table ? \nbecause in the error message, the missing table is professionnal_cities, but in the sample code it is professional_cities. There is an additional N in professional. You are welcome @Aurelsicoko \nBut, just a last question, what is the exact name of the joining table ? \nbecause in the error message, the missing table is professionnal_cities, but in the sample code it is professional_cities. There is an additional N in professional. Or Vitamin. Or Vitamin. @moeinrahimi \nHave you tried FetchPage(). @moeinrahimi \nHave you tried FetchPage(). @pradeeptimeinc \nlook at insertId property of the result object. @pradeeptimeinc \nlook at insertId property of the result object. Yes because MySQL doesn't support returning. It always returns the last inserted id for auto increment primary keys.. @ilovett which databse are you using ?. @sheam \nYou missed this.set(vals, options) see the line 500. @jorgemejia whereRaw would help you\njs\n// or, but be aware that 'date' datatype is not supported in SQLite\nqb.whereRaw('cast(datetime_col as date) = ?' , date). @jorgemejia could you please close this issue. @mariosouto could you provide the code of withDogsCount. @mariosouto because you are using an event to add the dogs counter, it should be added only for the pager not the internal bookshelf's counter query, so update getOwnerPage\n```js\nfunction * getOwnerPage(houseId, page, pageSize) {\n  const ownerPage = yield models.Owner\n  .query({ where: { house_id: houseId } })\n  .fetchPage({ page, pageSize, pager: true }) // add a pager flag to the fetch options\nreturn {\n    owners: ownerPage.models.map(formatOwner),\n    pages: ownerPage.pagination.pageCount,\n    count: ownerPage.pagination.rowCount\n  }\n}\nThen update your Owner eventjs\nconst Owner = {\n  tableName: 'owners'\ninitialize() {\n    this.on('fetching:collection', (model, columns, options) => {\n      // only add the additional column when the pager option is present\n      if ( options.pager === true ) withDogsCount(options.query)\n    })\n  }\n}\nHope it helps. @darkghoul79 regarding to your scenario, an order has many owners, so your should use `belongsToMany` insteadjs\nbuyer() {\n  return this.belongsTo('User' , 'buyerId')\n}\nowners() {\n  return this.belongsToMany('User', 'Items', 'orderId', 'buyerId')\n}\n. @Speedrockracerjs\nbs.transaction((t) => {\n  let options = { transacting: t }\nreturn new Book({ id: book_id })\n    .fetch({ require: true, ...options })\n    .then((book) => Promise.all([\n      // save the chapter\n      book.related('chapters').create({ title: 'Awesome chapter' }, options),\n  // and save the pages \n  Promise.map(pages, (page) => page.save(null, options))\n]))\n.spread((chapter, pages) => {\n  return Promise.map(pages, (page) => {\n    return new ChapterPage({\n      page_id: page.id,\n      chapter_id: chapter.id,\n      // extra pivot data\n    }).save(null, options)\n  })\n  // add this line to load the chapter related pages\n  .then(() => chapter.load(['chapterPages'])\n})\n\n})\n.then((chapter) => {\n  // chapter will contain now the related pages\n})\nHope it helps. @jay763190097js\nmodel.fetch({\n  withRelated: [ { 'file': qb => qb.select('name') } ]\n})\n. @jay763190097 another suggestion based on @einsqing's commentjs\nlet banner = await this.model('ads').findAll((qb) => {\n  qb.where('status', '1')\n    .leftJoin('files', 'files.id', 'ads.file_id')\n    .select('id', 'name', 'rank', 'status', 'url', 'file_id', 'files.name as filename')\n})\n. @sscoviljs\n// create a sub query\nconst groupIds = GroupMember.where('id', 123).select('group_id').query()\n// then fetch\nGroup.where('id', 'in', groupIds).fetchAll({ withRelated: ['members'] })\n. Then you can usejs\nconst groupIds = GroupMember.query().select('group_id').where('id', 123)\n. @Ultear can you provide the code which calls the method `reviewsAverage()` ?. @Ultear you have to remove the `fetch()` call from `reviewsAverage()`js\nreviewsAverage: function () {\n  return this.reviews().query(qb => {\n    qb.avg('service_rate as service_rate_avg')\n    qb.avg('price_rate as price_rate_avg')\n  })\n}\n. @Ultear I have missed to select also the `place_id` column which is required to populate the `reviewsAverage` array.\nI have updated my previous comment. @YOO629 if for each row of A there is a corresponding row on B (one to one) you can use `leftJoin` instead of `innerJoin`.js\nqb.leftJoin('b', 'b.foreign_key', 'a.primary_key').innerJoin('c', 'c.foreign_key', 'a.primary_key')\n. @mossiso You can also use a `belongsToMany` relationship between `categories` and `locations`js\nvar Categories = Database.Model.extend({                                        \n  tableName: 'Categories',                                                      \n  hasTimestamps: true,                                                          \n  tools: function() {                                                           \n    return this.hasMany('Tools', 'category_id')                       \n  },\n  locations: function () {\n    return this.belongsToMany('Locations', 'Tools', 'category_id', 'location_id')\n }\n})\n// usage\nCategories.forge().orderBy('name').fetchAll({ withRelated: ['tools', 'locations'] }).then(...)\n```. @mfbx9da4 What version of bookshelf do you encounter this issue?. ",
    "kozer": "The actual question is how i can implemet this.I mean its easier to loop my filters and gradua\u013aly build an object and then return it from a helper function. Has anyone has an idea how i can abstract things in bookshelf?I dont want to have all my logic in a function.\n. I close this issue, as i see i can pass an object to query function, and i think this is what i was looking for.\nThank you all for your answers!\n. No, they have different values.\n. Well as i see, when i changed my driver to mysql, this bug is not happening. I will close this when i am sure 100% that this is the case.\nI mot sure how can i avoid this, as i get these results from parsing a website.\nMemory allocation is huge, and locally i have a good pc to handle it.\nBut on server, i havent, so i will have problems.\nIs anyone knows how can i do better?\n. ",
    "franceer": "Any inputs on this ?\n. Any inputs on this ?\n. ",
    "leebenson": "Exactly the same issue. .detach() with no args removes one row in the pivot table, and not all (expected).\n. Btw, the SQL being run when doing .belongsToMany('SomeTable').through('SomeOther').detach() is:\n\nselect pivot.* from pivot where pivot.main_id = ? limit ?\ndelete from pivot where id = ?\n\nThat last query should probably be main_id and not simply id, right?\n. (I can't believe 9 months later, no-one else has run into this? seems pretty fundamental to delete old associations before adding new ones...)\n. Agreed, this should be documented. I spent 3 hours trying to hunt down a bug when running a this.belongsTo('User').fetch() relation, that always resulted in the following error when inserting a record via .save() for the first time:\n\nError: Undefined binding(s) detected when compiling SELECT query: select users.* from users where users.id = ? limit ?\n\nIt turns out it was simply because user_id was undefined. Adding this to my model...\njs\ndefaults: () => ({\n  user_id: null,\n}),\n... prevents the error.\nThanks to this line of code from the Ghost repo for pointing out that it existed at all.\n. Thanks @fl0w, I appreciate you taking the time to express your experience. You've touched on exactly what my concern is. I've been burned on ORMs before that seem to save on keystrokes but then wind up requiring endless workarounds and monkey patching to either get models to fit, or side-step bugs that never get fixed. Granted, I could fix and submit a PR just like anyone... but I'm choosing a lib to save time, and that could be a rabbit hole that's easier side-stepped just by controlling the SQL that gets fired back manually with knex.\nI think I'm probably over-engineering an issue that doesn't exist. Knex is probably as 'high level' as I need. Thanks again for sharing your experience.\n. Good comments, @jamesdixon. Your thoughts echo my own. I'm very appreciative of the hard work the community has put in developing this (free!) software, but have hit its limitations in production way too soon for it to be useful to my particular use case.\nI agree that an ORM is a complex piece of software, and I think a lot of projects tackling something of this magnitude tend to stagnate and lose interest over time. It's common for core contributors to lose interest, get busy, move on to other stuff, or for users to move on to the latest thing - all the typical human stuff. This happens too often and you wind up with a project that has 'de facto' status in NPM, yet still has unresolved issues reaching back several years.\nUsers like me find themselves pinballing from one package to another, trying to find something that doesn't break after 2 days of usage \ud83d\ude04 \nI also think part of the problem with ORM in general, is the user's expectations. Sometimes it feels like ORM is engineering a problem that doesn't always exist. SQL gives us a rich query language and adding an abstraction on top nearly always takes away from it. There's also a huge performance issue that plights an ORM that is trying to appeal to a broad audience, but has a very slim use case inside of a production project (this is the reason I switched from Sequelize to Bookshelf in the first place, btw - 1.5 second execution times for 15ms of SQL didn't seem a worthwhile trade-off!)\nAll said and done, moving to knex solved 100% of the problems I experienced fighting with both Sequelize and Bookshelf. It turns out, I didn't need an ORM at all - I just needed a better way to compose 'raw' SQL. Knex solved that, and everything else was easily done in user-land. The idea of being able to abstract away relationships or even underlying DB engines is a bit of a pipedream, IMO... and totally unnecessary. I've moved DB engines exactly zero times, and it's always much faster to plan for necessary relationships/joins ahead of time rather than rely in dynamic functions and query plans provided by an ORM. Hand coding that stuff was a lot faster than trying to use ORM boilerplate and then going down the rabbit hole of patching fundamental issues with the library.\nSo, my bottom line advice to anyone reading who is fighting with the same problem: Just use knex. It probably does everything you need it to, and anything it doesn't, you'll probably get better performance characteristics writing yourself.. Good comments, @jamesdixon. Your thoughts echo my own. I'm very appreciative of the hard work the community has put in developing this (free!) software, but have hit its limitations in production way too soon for it to be useful to my particular use case.\nI agree that an ORM is a complex piece of software, and I think a lot of projects tackling something of this magnitude tend to stagnate and lose interest over time. It's common for core contributors to lose interest, get busy, move on to other stuff, or for users to move on to the latest thing - all the typical human stuff. This happens too often and you wind up with a project that has 'de facto' status in NPM, yet still has unresolved issues reaching back several years.\nUsers like me find themselves pinballing from one package to another, trying to find something that doesn't break after 2 days of usage \ud83d\ude04 \nI also think part of the problem with ORM in general, is the user's expectations. Sometimes it feels like ORM is engineering a problem that doesn't always exist. SQL gives us a rich query language and adding an abstraction on top nearly always takes away from it. There's also a huge performance issue that plights an ORM that is trying to appeal to a broad audience, but has a very slim use case inside of a production project (this is the reason I switched from Sequelize to Bookshelf in the first place, btw - 1.5 second execution times for 15ms of SQL didn't seem a worthwhile trade-off!)\nAll said and done, moving to knex solved 100% of the problems I experienced fighting with both Sequelize and Bookshelf. It turns out, I didn't need an ORM at all - I just needed a better way to compose 'raw' SQL. Knex solved that, and everything else was easily done in user-land. The idea of being able to abstract away relationships or even underlying DB engines is a bit of a pipedream, IMO... and totally unnecessary. I've moved DB engines exactly zero times, and it's always much faster to plan for necessary relationships/joins ahead of time rather than rely in dynamic functions and query plans provided by an ORM. Hand coding that stuff was a lot faster than trying to use ORM boilerplate and then going down the rabbit hole of patching fundamental issues with the library.\nSo, my bottom line advice to anyone reading who is fighting with the same problem: Just use knex. It probably does everything you need it to, and anything it doesn't, you'll probably get better performance characteristics writing yourself.. ",
    "JDillon522": "So you're saying this should work? \nnew database.User()\n   .query({\n      where: {id: 123},\n      andWhere: {male: true},\n      andWhere: {college: 'penn state'},\n      orWhere: {college: 'harvard'}\n    })\n    .fetch()\nIt doesnt get the right results. It'll get any entries where id: 123, male: true, college: 'penn state' or any entries with college: harvard.\nI need to know how to best/properly do an orWhere() call inside of an andWhere() call.\n. I think I found the answer: \nnew database.User()\n   .query(function(qb) {\n      var temp = where({id: 123}).andWhere({male: true});\n      return temp.where({college: 'penn state'}).orWhere({college: 'harvard'});\n    })\n    .fetch()\nI think it would be good to demonstrate this in the docs where you can make really advanced queries via a function call.\n. ",
    "codebulb": "Alternatively, please suggest how to implement this with the current API.\nI tried it with\nconst destroyed = []\nmyModel.fetchAll().then(function (collection) {\n  collection.each(function(it) {\n    destroyed.push(it.destroy())\n  })\n})\nPromise.all(destroyed).then(function (entity) {\n  // ok\n}).catch(function (error) {\n  // failed\n})\nbut the problem is that if one of the it.destroy() fails (e.g. because of a foreign key violation), the entire thing fails with \nUnhandled rejection Error: ER_ROW_IS_REFERENCED_2: Cannot delete or update a parent row: a foreign key constraint fails...\n(Note: Maybe I didn't exactly understand how to work with promises in this case.)\n. OK, so I found a workaround. The obvious solution is to use a where() clause that is always true:\nmyModel.where('id', '!=', '0').destroy().then(...)\nThis settles my interest in this issue. Feel free to close it.\n. ",
    "benkk": "OK cool, thanks for your response.\nLike I said the for loop isn't part the usual system, I added it to replicate an issue in a larger system process ie the list of data sources are generated from database calls and methods.\nI'll refactor the example tomorrow to remove the for loop and make it more Promise friendly and resubmit.\n. Here is another representation of what's going on. I have a list of elements within a page and I'm looping through these to get the data. I've now added a Promise.all with no success. The resulting data sets still have mixed up rows even though the call is completing successfully.\nI understand that I could load in the data earlier (at page load) but I need to load each element, check the data and permissions for each one so it's not a simple query.\nLike I mentioned above I can refactor this but I'm concerned this may occur when under high intensity of concurrent calls.\nThanks\n// Create Site Class\nfunction SiteObj(id) {  \n```\n// Get site and loop through data row for the site\nnew Site({id: 1}).fetch().then(function(result) {\n    this.site = result;\n    console.log('Site: ' + this.site.toJSON());\n// Load list of page elements and their related data        \nvar elementArray = [\n    {\"name\": \"ele1\", \"source\": \"company\"},\n    {\"name\": \"ele2\", \"source\": \"company1\"},         \n    {\"name\": \"ele3\", \"source\": \"services\"},                     \n    {\"name\": \"ele4\", \"source\": \"services1\"},\n    {\"name\": \"ele5\", \"source\": \"ABC\"},\n    {\"name\": \"ele6\", \"source\": \"XYZ\"},\n    {\"name\": \"ele7\", \"source\": \"123\"},\n    {\"name\": \"ele8\", \"source\": \"LMO\"},\n    {\"name\": \"ele9\", \"source\": \"EFG\"},\n    {\"name\": \"ele10\", \"source\": \"A\"},                                                           \n];\n\n// Create the promise array     \nvar dataPromiseArray = [];\nfor (var x = 0; x < elementArray.length; x++)\n{\n        dataPromiseArray.push(this.loadData(elementArray[x]));\n}\n\n// Promise all to ensure all done\nPromise.all(dataPromiseArray).then(function() {\n    console.log(\"all the dataArray were created\");\n});\n\n}.bind(this)).catch(function(err) {\n  console.error(err);\n});\n```\n}\n// Load data for site\nSiteObj.prototype.loadData = function(element){\n```\nreturn new Promise(function(fulfill, reject) {\n// Create query \nvar idLookup = element.source;\nvar theQuery = function(query) { \n        query.column('id','alias').limit(1).andWhere('alias', '=', idLookup);   \n}\n\n// Execute DB call\nthis.site.related('dataSources').query(theQuery).fetch()\n    .then(function(result) {\n        if (result != null) {\n            console.log ('Data idLookup: ' + idLookup + ' ' + JSON.stringify(result));  \n            fulfill(idLookup);\n        }\n    })\n\n}.bind(this));\n```\n}\n// Init Site Obj\nvar theSite = new SiteObj();\n---- RESULT ----\nSite: [object Object]\nData idLookup: company [{\"id\":1,\"alias\":\"company\"}]\nData idLookup: company1 [{\"id\":2,\"alias\":\"company1\"}]\nData idLookup: services [{\"id\":8,\"alias\":\"services\"}]\nData idLookup: services1 [{\"id\":13,\"alias\":\"LMO\"}]\nData idLookup: ABC [{\"id\":13,\"alias\":\"LMO\"}]\nData idLookup: XYZ [{\"id\":13,\"alias\":\"LMO\"}]\nData idLookup: 123 [{\"id\":13,\"alias\":\"LMO\"}]\nData idLookup: LMO [{\"id\":13,\"alias\":\"LMO\"}]\nData idLookup: EFG [{\"id\":14,\"alias\":\"EFG\"}]\nData idLookup: A [{\"id\":3,\"alias\":\"A\"}]\nall the dataArray were created\n. Sorry if the example is confusing. I've ripped code out of a bigger system to try to demonstrate the issue.\nThe setTimeout is only there to show that if the calls are not concurrent then it works as expected. If the calls are fired at the same time then the results are mixed.\nI've tried passing the site object model as a parameter and it has no difference.\nIs assigning a bookshelf item to an object variable bad practice?\nJust to recap what I'm trying to achieve. A webpage has a list elements (eg header, content, news, quick links, list of new members, contact form & footer) that are displayed on a page. Each element can have a data source (eg list of news, list of links, list of users etc).\nElements are loaded dynamically as every page is configured by the content publisher. \nThe page processor loads all the elements from the database (forming elementArray), checks the permissions (removed for simplicity) and loads the data for each element. It's while loading this data that I've noticed that the data result is not correct occasionally.\nI've done this example (with example for loops and setTimeouts) to demonstrate what is happening in the system.\nI can refactor the code but I'm worried about this occurring on a busy multi-user system. I'm considering a next step of testing this under high intensity to ensure this doesn't happen between users querying the same table.\nAny ideas would be appreciated.\n. ",
    "Scottjutsu": "Thanks for your reply, @ricardograca .  I do expect timestamps to be updated.  The problem I'm seeing is that on the initial forge/save, the timestamps are added to attrs, but do not make it into the knex query.  I provided the update info to show that the timestamps do make it into the query on update.\n. Sorry about the confusion.  I tried hasTimestamps: true but the result is the same.\n. I did have more going on (checkit, logging), but I stripped it all out in the process of debugging.  The name property was just picked up by the parent model for logging.\nOk, let me see if I can whip up a sample.  At least it's good to know that I'm not missing something on the face of this code.  :+1: \n. Like.forge(item).save(null, {method: 'insert'})\nLike.forge().save(item, {method: 'insert'})\nNo joy.\n. Nevermind, I'm an idiot.  I monkey-patched bookshelf back during 0.8.1 to let me manually override the timestamps if desired and forgot to remove the patch after upgrade.\nSee, I knew I had screwed something up.  Thanks for your help (and patience) @ricardograca !\n. ",
    "BKStephens": "I am running into this as well.\nLooking at the tests, it looks like Account withRelated concernable should work:\nhttps://github.com/tgriesser/bookshelf/blob/master/test/integration/relations.js#L545\nit('eager loads morphTo (photos -> imageable)', function() {\n  return Photo.fetchAll({withRelated: ['imageable']}).tap(checkTest(this));\n});\nhttps://github.com/tgriesser/bookshelf/blob/master/test/integration/helpers/objects.js#L215 \nvar Photo = Bookshelf.Model.extend({\n  tableName: 'photos',\n  imageable: function() {\n    return this.morphTo('imageable', Site, Author);\n  },\n  imageableParsed: function() {\n    return this.morphTo('imageable', SiteParsed, AuthorParsed);\n  }\n});\nhttps://github.com/tgriesser/bookshelf/blob/master/test/integration/helpers/objects.js#L54\nvar Site = Bookshelf.Model.extend({\n...\n  photos: function() {\n    return this.morphMany(Photo, 'imageable');\n  },\n...\n});\n. ",
    "DGulshan": "Facing the exact same issue in 0.10.2\n```\nvar Post = bookshelf.Model.extend({\n  tableName: 'posts',\n  comments: function() {\n    return this.morphMany(Comment, 'keyable');\n  }\n});\nvar Comment = bookshelf.Model.extend({\n  tableName: 'comments',\n  keyable: function() {\n    return this.morphTo('keyable', Post);\n  }\n});\n```\nI found that the function is called by eager.js (same as in @TinOo512 's case)  foreignTable's value is Post but the value in candidates comes as posts in helpers.js#morphCandidate\n. ",
    "ashercoren": "Is there any workaround for this bug?\nMy models are camelCased, and when I call .fetch(withRelated{['myCamelCasesMorphTo']} I get the The target polymorphic model was not found error.. Is there any workaround for this bug?\nMy models are camelCased, and when I call .fetch(withRelated{['myCamelCasesMorphTo']} I get the The target polymorphic model was not found error.. ",
    "fghpdf": "I solved it.\nI short some things\nIt should be this\nnew model.Defray().where('purchaseId', '=', purchaseId).query().select().then(function(){\n  do something;\n});\nthank you very much!\nBy the way,you are right,query() chould`t use new directly.\n. ",
    "smalbs": "for what it's worth, I've been persisting geojson as geom postgres type by hooking into the 'saving' event:\n```\nthis.on( 'saving', function ( model, columns, options ) {\n        const geojson = model.get( 'geojson' );\n\n        if ( typeof geojson === \"object\" ) {\n\n            const lat   = geojson.coordinates[ 1 ],\n                  lng   = geojson.coordinates[ 0 ],\n                  point = St.geomFromText( `Point(${lng} ${lat})`, 4326 );\n            model.set( pointColumn, point );\n        }\n\n} );\n```\n. ",
    "ChaosExAnima": "Derp. Yeah, that did it. Thanks!\n. ",
    "Rush": "This should fix it. https://github.com/tgriesser/create-error/pull/8\nI'd appreciate this being merged and create-error version bumped.\n. I was researching camelizing keys in Bookshelf models in my own app, is there any progress on this issue?\n. I was researching camelizing keys in Bookshelf models in my own app, is there any progress on this issue?\n. ",
    "alphanso": "Okay. Is it declarative i.e can I use it without an initiated Knex or Bookshelf instance?\n. ",
    "suparpat": "Me too. I got it to work by:\nOn command line, navigating to node_modules/bookshelf and do npm install\nSeems like one or more packages are missing from the dependencies field in packages.json, which is in devDependencies field.\n. ",
    "thebinarypenguin": "I still get this error. See sample code below.\n```\nmodule.js:340\n    throw err;\n    ^\nError: Cannot find module 'babel-runtime/helpers/classCallCheck'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:289:25)\n    at Module.require (module.js:366:17)\n    at require (module.js:385:17)\n    at Object. (/home/ethan/incubator/bookshelf-babel-issue/node_modules/bookshelf/lib/base/events.js:7:24)\n    at Module._compile (module.js:435:26)\n    at Object.Module._extensions..js (module.js:442:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:313:12)\n    at Module.require (module.js:366:17)\n    at require (module.js:385:17)\n    at Object. (/home/ethan/incubator/bookshelf-babel-issue/node_modules/bookshelf/lib/bookshelf.js:15:15)\n    at Module._compile (module.js:435:26)\n    at Object.Module._extensions..js (module.js:442:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:313:12)\n```\ntest.js\n``` js\n'use strict';\nconst config = {\n  client: 'sqlite3',\n  connection: {\n    filename: 'database.sqlite',\n  },\n  useNullAsDefault: true,  // SQLite specific config\n  debug: true,\n};\nconst knex      = require('knex')(config);\nconst bookshelf = require('bookshelf')(knex);\nconst Note = bookshelf.Model.extend({\ntableName: 'notes',\n// Called by the constructor when a new instance of the model is created\n  // \"this\" is a reference to the newly-created model instance\n  initialize: function () {\nthis.on('creating', (model) => {\n\n  const now = new Date().toISOString();\n\n  model.set({\n    created_at: now,\n    updated_at: now,\n  });\n});\n\nthis.on('updating', (model) => {\n\n  const now = new Date().toISOString();\n\n  model.set({\n    updated_at: now,\n  });\n});\n\n},\n});\n```\npackage.json\njson\n{\n  \"name\": \"bookshelf-babel-issue\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"bookshelf\": \"^0.9.3\",\n    \"knex\": \"^0.10.0\",\n    \"sqlite3\": \"^3.1.3\"\n  }\n}\nI'm running node v4.2.4 and npm 3.8.5\n. @rhys-vdw Excellent! I can also confirm that 0.9.4 works in my aforementioned environment. :+1: \n. apologies for duplicating #1044 \nThe code above was indeed < 0.9.4 however once I fixed that I still get one leak\nThe following leaks were detected:__core-js_shared__\n. ah, okay. Well I'm glad 0.9.4 got it down to only one leak. I might look into the issue if I have the time but I've never used Babel before so I'm not promising anything. Thanks\n. ",
    "davebaol": "@thebinarypenguin \nYou have to wait for bookshelf 0.9.4.\nAlternatively, you can specify \"bookshelf\": \"0.9.2\" in your package.json (note the missing ^)\n@tgriesser \n0.9.3 is clearly broken and you have fixed this issue already, so please can you release 0.9.4 soon ? :)\n. Great, thanks!\n. ",
    "davidpaulhunt": "Ugh this was due to the events registration issue caused by Lodash's words method. Updated to latest release and all is well again.\n. ",
    "thomasdelobel": "To be coherent with the next versions of lodash, .rest should be banned to use instead .drop which do by default what the _.rest was expected for.\nYes, PR in progress :)\n. Wow and flat your columnNames ?\nIt could be done in part this way, but in the case where \"columnNames\" is defined, \"candidates\" must be .shift() of _.drop(candidates) to remove the columnNames (arguments[1]) and keep only the Candidates\n. Wow and flat your columnNames ?\nIt could be done in part this way, but in the case where \"columnNames\" is defined, \"candidates\" must be .shift() of _.drop(candidates) to remove the columnNames (arguments[1]) and keep only the Candidates\n. ",
    "kuldeepaggarwal": "fetchAll is returning 2objects but they are identical rather I should get 2 unidentical objects.\n. @rhys-vdw I apologize but I don't have standalone script. I can push changes to my branch if you say.\n. @rhys-vdw Knex query is correct: \nknex:query insert into `binary_uuid_test` (`name`, `uuid`) values (?, ?) +4ms\nknex:query insert into `binary_uuid_test` (`name`, `uuid`) values (?, ?) +0ms\nknex:query select `binary_uuid_test`.* from `binary_uuid_test` +3ms\n. They are exactly same. See this commit\n. Here are the objects:\n[\n  { uuid: <Buffer d9 6d 40 d1 fc c9 11 e5 9b 8d 87 b1 68 72 76 b9>, name: 'Kuldeep Aggarwal' },\n  { uuid: <Buffer d9 6d 40 d1 fc c9 11 e5 9b 8d 87 b1 68 72 76 b9>, name: 'Kuldeep Aggarwal' }\n]\n. No, database have different values. I have verified that knex is returning correct result and also checked that database has 2 different record having different values. The bug is arising somewhere in bookshelf when we map knex result to Model object.\n. I have just found that knex is returning correct results(2 different results having different uuid). Reason for this issue could be that we may be grouping(not sure, using _.groupBy on uuid as a key) the result somewhere in the ORM and because when we call toString()(internally called by javascript Object class) method on Buffer object (only for those buffer objects which are similar, like in our case) then it gives us same utf-8 encoding string(invalid string) because this buffer does not contain valid utf-8 characters encoded.\nWe can fix this issue by calling toString('hex') explicity then it will solve the issue, but this fix needs to be applied across the ORM and tested thoroughly.\n. Because type of column is binary, so Bookshelf converts binary to Buffer and vice versa\n. @rhys-vdw This way the column in db will have string value not varbinary type value, right?\n. Oops, I got your point here :+1: \n. Just a final point to get the better understanding, format is called after object is initialized from DB -> Model Object and parse is called when object is saved to DB. right?\n. But Bookshelf is also using _.groupBy while eager loading the relations. see this line\n. ",
    "jakelazaroff": "\nIsn't the same as saying created_at > [starting_date], limit [count]? You shouldn't need to do two fetches.\n\nNot quite \u2014 it might be something like created_at > [starting_date], min [count]. The algorithm is basically\u2026\n1. select all the items in a date range\n2. if there aren't more than a certain number of items, move the date range back\n3. goto 1\nAs far as I know, there's no way to do that in SQL without multiple queries.\nWhat Bookshelf seems to be doing with the withRelations query is allowing query builder methods to affect the set of items that are returned, but not allowing promise methods to affect it. then isn't a query method, so I don't think turning on query tracing would affect it.\nThe then function is indeed getting called and I've confirmed that I'm filtering the results there, but when I check the relation in the model that's returned from the fetch method it's the full unfiltered list.\n. > Isn't the same as saying created_at > [starting_date], limit [count]? You shouldn't need to do two fetches.\nNot quite \u2014 it might be something like created_at > [starting_date], min [count]. The algorithm is basically\u2026\n1. select all the items in a date range\n2. if there aren't more than a certain number of items, move the date range back\n3. goto 1\nAs far as I know, there's no way to do that in SQL without multiple queries.\nWhat Bookshelf seems to be doing with the withRelations query is allowing query builder methods to affect the set of items that are returned, but not allowing promise methods to affect it. then isn't a query method, so I don't think turning on query tracing would affect it.\nThe then function is indeed getting called and I've confirmed that I'm filtering the results there, but when I check the relation in the model that's returned from the fetch method it's the full unfiltered list.\n. ",
    "VividVisions": "I just realised that format and parse are the functions to use here. Works!\n. ",
    "michaelgmcd": "Is there any clarification needed here? I'm still stuck on this.\n. ",
    "Genchou": "Hi http91, thank you for you answer.\nYou are not replying about my issue though, which is about saving an entity (and not fetching it, which goes smoothly by the way).\nI tried a couple of things yesterday but nothing really worked. I think there is a gaping hole in the documentation about how to set and save a relation in a model. There are lots of examples for fetching, almost none for saving.\njavascript\nvar picture = new Picture({\n    // other attributes\n    user: loggedUser // doesn't work\n});\npicture.set({ user: loggedUser }); // doesn't work\npicture.user = loggedUser; // doesn't work\npicture.user(loggedUser); // doesn't work\npicture.related(\"user\") = loggedUser; // doesn't work\nuser.pictures().add(picture); // doesn't work\nuser.pictures().attach(picture); // doesn't work\nWhen saving the picture object using those methods, I either get the error mentioned in the opening issue or the user is simply not saved in the database.\nThe only working solution I found was to directly set a user_id attribute in the picture object.\n``` javascript\npicture.user_id = loggedUser.id;\n// Picture model\nvar Picture = Bookshelf.Model.extend({\n    tableName: \"pictures\",\n    hasTimestamps: true,\n    user: function() { return this.belongsTo(\"User\", \"user_id\"); },\n});\nmodule.exports = Bookshelf.model(\"Picture\", Picture);\n```\nI don't know if this is the correct way to do it, but as I said, I have no idea how to do it properly.\n. ",
    "teebot": "You're welcome. Thanks for Bookshelf \u2665\ufe0f\n. ",
    "renarsvilnis": "Just noticed the same issue.\nEDIT: 0.9.5 fixes this.\n. ",
    "nabilfreeman": "I am running 0.9.5 and this isn't fixed...\n. I am running 0.9.5 and this isn't fixed...\n. @chamini2 in my experience it accepts it, but does not produce a useful result.\n. +1 - we are getting around it by checking relation && relation.get('id').\nBookshelf has really come on in leaps and bounds over the past 18 months, so I know it's only a matter of time before this is fixed \ud83e\udd17. +1 - we are getting around it by checking relation && relation.get('id').\nBookshelf has really come on in leaps and bounds over the past 18 months, so I know it's only a matter of time before this is fixed \ud83e\udd17. ",
    "StavroMueller": "Sure thing, I'll see what I can come up with.\n. ",
    "JC3": "@vellotis @rhys-vdw I am browsing through the PR list and saw this. It appears somewhat related to https://github.com/tgriesser/bookshelf/pull/1474 although mine appears to be a slightly different approach. Any thoughts?. @vellotis @rhys-vdw I am browsing through the PR list and saw this. It appears somewhat related to https://github.com/tgriesser/bookshelf/pull/1474 although mine appears to be a slightly different approach. Any thoughts?. It appears it's not possible, so I refactored a bit, basically like:\n```\nfunction processPeople (people, house) { \n    var ps = people.toJSON();\n    var hs = house ? house.toJSON() : undefined;\n    for (p of ps) {\n        let p_house = p.house ? p.house : hs;\n        // use p_house instead of p.house\n    }\n}\n// this works, since house is fetched per person:\nPerson.fetchAll({withRelated:[\"house\"]}).then(function (people) {\n    processPeople(people);\n});\n// now in this case, we pass the house to processPeople()\nHouse.forge({id:id}).fetch({withRelated[\"persons\"]}).then(function (house) {\n    processPeople(house.related(\"persons\"), house);\n});\n```\nNot appropriate for all cases (e.g. does not support people from multiple houses that were obtained via house.related) but better.\nIt would be nice if there were some way to do this with Bookshelf.. It appears it's not possible, so I refactored a bit, basically like:\n```\nfunction processPeople (people, house) { \n    var ps = people.toJSON();\n    var hs = house ? house.toJSON() : undefined;\n    for (p of ps) {\n        let p_house = p.house ? p.house : hs;\n        // use p_house instead of p.house\n    }\n}\n// this works, since house is fetched per person:\nPerson.fetchAll({withRelated:[\"house\"]}).then(function (people) {\n    processPeople(people);\n});\n// now in this case, we pass the house to processPeople()\nHouse.forge({id:id}).fetch({withRelated[\"persons\"]}).then(function (house) {\n    processPeople(house.related(\"persons\"), house);\n});\n```\nNot appropriate for all cases (e.g. does not support people from multiple houses that were obtained via house.related) but better.\nIt would be nice if there were some way to do this with Bookshelf.. Actually reopening this as a feature request.. Actually reopening this as a feature request.. All right, I found a solution, at least.\nFirst step is to make a function that computes the value and saves it be a member of the bookshelf model. So, for the example from my post, I'd define the following function in Thing when extending the model:\n... = bookshelf.Model.extend({\n\n    ...\n\n    updateSomeValue: function (options) {\n        return this.save({ \n            value: computeSomeValueSync(this)\n        }, options);\n    }\n\n});\n\nWhere options is the options to pass to save, which we can use to pass the transaction through. Easy enough. Then, we can do the equivalent of Promise.map with Collection#invokeThen, like this:\nBookshelf.transaction(function (t) {\n    return Thing.fetchAll({transacting:t}).then(function (things) {\n        return things.invokeThen(\"updateSomeValue\", {transacting:t});\n    });        \n}).tap(function () {\n    console.log(\"update complete\");\n});\n\nThere, invokeThen essentially does what I intended to do with Promise.map -- returns a promise that becomes fulfilled once all the promises returned by Thing#updateSomeValue are fulfilled.\nIt's only mildly inconvenient in that I have to add the model method, but it does make a bit of sense at least. The interface is a little weird because the docs are tough to piece together. But, at least it's possible.\nStill open to other ideas.. All right, I found a solution, at least.\nFirst step is to make a function that computes the value and saves it be a member of the bookshelf model. So, for the example from my post, I'd define the following function in Thing when extending the model:\n... = bookshelf.Model.extend({\n\n    ...\n\n    updateSomeValue: function (options) {\n        return this.save({ \n            value: computeSomeValueSync(this)\n        }, options);\n    }\n\n});\n\nWhere options is the options to pass to save, which we can use to pass the transaction through. Easy enough. Then, we can do the equivalent of Promise.map with Collection#invokeThen, like this:\nBookshelf.transaction(function (t) {\n    return Thing.fetchAll({transacting:t}).then(function (things) {\n        return things.invokeThen(\"updateSomeValue\", {transacting:t});\n    });        \n}).tap(function () {\n    console.log(\"update complete\");\n});\n\nThere, invokeThen essentially does what I intended to do with Promise.map -- returns a promise that becomes fulfilled once all the promises returned by Thing#updateSomeValue are fulfilled.\nIt's only mildly inconvenient in that I have to add the model method, but it does make a bit of sense at least. The interface is a little weird because the docs are tough to piece together. But, at least it's possible.\nStill open to other ideas.. I did npm install like 4 more times and the errors were less each time until eventually it looked like it worked... so I'm closing this for now until I have more info.. I did npm install like 4 more times and the errors were less each time until eventually it looked like it worked... so I'm closing this for now until I have more info.. Rationale: This is extremely useful for conveniently passing context/session-dependent computed properties to web front-ends and template engines via Model#toJSON. Consider the following example:\n```\nmodule.exports.User = bookshelf.Model.extend({\nisEditableBy : function (editor) {\n   // return true if editor's user privileges grant permission to edit `this`.\n}\n\n});\n```\nNow consider, for example, a user list view generated by Pug that wants to give UI indicators to show whether each user displayed can be edited by the currently logged in user (let's say we're using Express and req.user contains the currently logged in user model). There are currently no great ways to pass this info through:\nOption 1: Pass JSON objects to front-end\nExpress:\nUser.fetchAll().then(function (users) {\n    res.render(\"users\", {\n        user: req.user.toJSON(),\n        users: users.toJSON()\n    });\n});\nPug:\nfor u in users\n   ...\nFails. Since toJSON has been called, template engine no longer has access to model methods such as User#isEditableBy().\nOption 2: Pass models to front-end.\nExpress:\nUser.fetchAll().then(function (users) {\n    res.render(\"users\", {\n        user: req.user,\n        users: users\n    });\n});\nFor template engines:\n\nExtremely cumbersome. It is unfortunately not trivial to iterate over the models in a collection (see also: http://stackoverflow.com/a/33906138), so template code becomes unwieldy (I'm actually leaving examples out because e.g. callback-based iteration becomes quite complicated in, say, Pug).\nFragile. Template engines must now have knowledge that Bookshelf is in use and can no longer operate on pure JSON objects. For example, they must rely on Bookshelf API calls like #toJSON and various model methods, which greatly hurts interoperability.\n\nFor passing JSON to the client (e.g. ajax endpoints):\n\nImpossible. Models cannot be passed to the client side, and pure JSON objects lose model methods.\n\nOption 3: Build JSON manually\nusers.toJSON() on the Express side then iterate through and add computed properties manually. \nObviously, this is not a good approach. As mentioned above, iteration is non-trivial, and even if it were, implementing this still comes with a of pain, which I'll leave up to your imagination. Also it's a lot of work to make up for something that is easily solvable by a change on the Bookshelf side.\nSolution: Parameterized Virtuals\nBoth of those options kind of stink. Parameterized virtuals make the task extremely straightforward. A computed property can be added to the User model:\n```\nmodule.exports.User = bookshelf.Model.extend({\nvirtuals {\n   editable : function (editor) {\n      return editor && this.isEditableBy(editor);\n   }\n},\n\nisEditableBy : function (editor) {\n   // return true 'editor's user privileges grant permission to edit `this`.\n}\n\n});\n```\nThen on the Express side, JSON objects can be passed:\nUser.fetchAll().then(function (users) {\n    res.render(\"users\", {\n        user: req.user.toJSON(),\n        users: users.toJSON({virtuals:true, param:req.user})\n    });\n});\nAnd on e.g. the Pug side it becomes extremely straightforward:\nfor u in users\n   if u.editable\n      ...\n\nThis change is primarily focused on JSON output. I think it adds a lot of flexibility and convenience to the library, in any situation where JSON objects are convenient. Plus, it's a non-breaking change, and it really involves very trivial changes to the virtuals plugin, for a fairly large benefit.. Rationale: This is extremely useful for conveniently passing context/session-dependent computed properties to web front-ends and template engines via Model#toJSON. Consider the following example:\n```\nmodule.exports.User = bookshelf.Model.extend({\nisEditableBy : function (editor) {\n   // return true if editor's user privileges grant permission to edit `this`.\n}\n\n});\n```\nNow consider, for example, a user list view generated by Pug that wants to give UI indicators to show whether each user displayed can be edited by the currently logged in user (let's say we're using Express and req.user contains the currently logged in user model). There are currently no great ways to pass this info through:\nOption 1: Pass JSON objects to front-end\nExpress:\nUser.fetchAll().then(function (users) {\n    res.render(\"users\", {\n        user: req.user.toJSON(),\n        users: users.toJSON()\n    });\n});\nPug:\nfor u in users\n   ...\nFails. Since toJSON has been called, template engine no longer has access to model methods such as User#isEditableBy().\nOption 2: Pass models to front-end.\nExpress:\nUser.fetchAll().then(function (users) {\n    res.render(\"users\", {\n        user: req.user,\n        users: users\n    });\n});\nFor template engines:\n\nExtremely cumbersome. It is unfortunately not trivial to iterate over the models in a collection (see also: http://stackoverflow.com/a/33906138), so template code becomes unwieldy (I'm actually leaving examples out because e.g. callback-based iteration becomes quite complicated in, say, Pug).\nFragile. Template engines must now have knowledge that Bookshelf is in use and can no longer operate on pure JSON objects. For example, they must rely on Bookshelf API calls like #toJSON and various model methods, which greatly hurts interoperability.\n\nFor passing JSON to the client (e.g. ajax endpoints):\n\nImpossible. Models cannot be passed to the client side, and pure JSON objects lose model methods.\n\nOption 3: Build JSON manually\nusers.toJSON() on the Express side then iterate through and add computed properties manually. \nObviously, this is not a good approach. As mentioned above, iteration is non-trivial, and even if it were, implementing this still comes with a of pain, which I'll leave up to your imagination. Also it's a lot of work to make up for something that is easily solvable by a change on the Bookshelf side.\nSolution: Parameterized Virtuals\nBoth of those options kind of stink. Parameterized virtuals make the task extremely straightforward. A computed property can be added to the User model:\n```\nmodule.exports.User = bookshelf.Model.extend({\nvirtuals {\n   editable : function (editor) {\n      return editor && this.isEditableBy(editor);\n   }\n},\n\nisEditableBy : function (editor) {\n   // return true 'editor's user privileges grant permission to edit `this`.\n}\n\n});\n```\nThen on the Express side, JSON objects can be passed:\nUser.fetchAll().then(function (users) {\n    res.render(\"users\", {\n        user: req.user.toJSON(),\n        users: users.toJSON({virtuals:true, param:req.user})\n    });\n});\nAnd on e.g. the Pug side it becomes extremely straightforward:\nfor u in users\n   if u.editable\n      ...\n\nThis change is primarily focused on JSON output. I think it adds a lot of flexibility and convenience to the library, in any situation where JSON objects are convenient. Plus, it's a non-breaking change, and it really involves very trivial changes to the virtuals plugin, for a fairly large benefit.. Is Bookshelf no longer under development?. Oh I'm sorry, I somehow missed your earlier replies. Responding quickly\nfrom phone but I'll reply properly as soon as I can. J\nOn Jul 21, 2017 6:40 AM, \"Giorgio Romano\" notifications@github.com wrote:\n@JC3 https://github.com/jc3 any updates?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/pull/1474#issuecomment-316969020,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AFY68PgTTX8VRAg1B6pdg2RF61pVxnlMks5sQIApgaJpZM4LNZTC\n.\n. Of course I'm not angry, ha. But I do have some perspective on your\noriginal question that you might find useful on your quest here. J\nOn Jul 21, 2017 11:52 AM, \"Giorgio Romano\" notifications@github.com wrote:\n\nI've developed a better alternative to yours, taking some bits of code, I\nhope you are not angry about that :D\nI'm writing the PR, I'll @ you when it is up\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/pull/1474#issuecomment-317038564,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AFY68BtqTPl4GvvQIpefHyd-9cYcFupvks5sQMlZgaJpZM4LNZTC\n.\n. @Playrom Sorry about the delay. To answer your original question:\nIf there are multiple virtual how can I decide the params for each one?\n\nI considered this when designing this code, and it's already possible pretty easily without any additional interface complexity. You can pass any object you want as the parameter and the virtuals can read any field they want. For example:\n```\nsomeModel.toJSON({virtuals:true, param:{\n   firstVirtual: { x: 1 },\n   secondVirtual: { x: 2 }\n}})\n...\nvirtuals: {\n    firstVirtual: function (parameter) {\n      console.log(parameter.firstVirtual.x);\n      return ...;\n    },\n    secondVirtual: function (parameter) {\n      console.log(parameter.secondVirtual.x);\n      return ...;\n    }\n}\n```\nAlso there's no need to actually name the parameter fields the same as the virtuals, I just did that for the example. (In fact I'd recommend against that when possible, encouraging proper data layer design and using business names instead e.g. param.currentUser, etc, for various reasons -- basically if you find yourself having to specify virtual names in param fields it's probably a small red flag that you haven't separated your view/logic/data layers well enough, but I digress.)\nGiven that this is already possible, I strongly recommend against increasing interface complexity for this purpose. Bookshelf is already confusing enough, simplicity is always good as long as the requirements are met (which they seem to be).\nDoes this address your issues?. @Playrom Sorry about the delay. To answer your original question:\n\nIf there are multiple virtual how can I decide the params for each one?\n\nI considered this when designing this code, and it's already possible pretty easily without any additional interface complexity. You can pass any object you want as the parameter and the virtuals can read any field they want. For example:\n```\nsomeModel.toJSON({virtuals:true, param:{\n   firstVirtual: { x: 1 },\n   secondVirtual: { x: 2 }\n}})\n...\nvirtuals: {\n    firstVirtual: function (parameter) {\n      console.log(parameter.firstVirtual.x);\n      return ...;\n    },\n    secondVirtual: function (parameter) {\n      console.log(parameter.secondVirtual.x);\n      return ...;\n    }\n}\n```\nAlso there's no need to actually name the parameter fields the same as the virtuals, I just did that for the example. (In fact I'd recommend against that when possible, encouraging proper data layer design and using business names instead e.g. param.currentUser, etc, for various reasons -- basically if you find yourself having to specify virtual names in param fields it's probably a small red flag that you haven't separated your view/logic/data layers well enough, but I digress.)\nGiven that this is already possible, I strongly recommend against increasing interface complexity for this purpose. Bookshelf is already confusing enough, simplicity is always good as long as the requirements are met (which they seem to be).\nDoes this address your issues?. @jadengore The original implementation of this is at  https://github.com/bookshelf/bookshelf/pull/1474 and is also ready to go aside from documentation (just to be clear on history here, I did #1474 a few months back and submitted a PR, then @Playrom spotted it recently and proposed this PR as an alternate implementation -- see the comments there). In particular, regarding @Playrom's implementation, see https://github.com/bookshelf/bookshelf/pull/1474#issuecomment-317250620, which I'll reproduce here:\n\n@Playrom Sorry about the delay. To answer your original question:\n\nIf there are multiple virtual how can I decide the params for each one?\n\nI considered this when designing this code, and it's already possible pretty easily without any additional interface complexity. You can pass any object you want as the parameter and the virtuals can read any field they want. For example:\n```\nsomeModel.toJSON({virtuals:true, param:{\n   firstVirtual: { x: 1 },\n   secondVirtual: { x: 2 }\n}})\n...\nvirtuals: {\n    firstVirtual: function (parameter) {\n      console.log(parameter.firstVirtual.x);\n      return ...;\n    },\n    secondVirtual: function (parameter) {\n      console.log(parameter.secondVirtual.x);\n      return ...;\n    }\n}\n```\nAlso there's no need to actually name the parameter fields the same as the virtuals, I just did that for the example. (In fact I'd recommend against that when possible, encouraging proper data layer design and using business names instead e.g. param.currentUser, etc, for various reasons -- basically if you find yourself having to specify virtual names in param fields it's probably a small red flag that you haven't separated your view/logic/data layers well enough, but I digress.)\nGiven that this is already possible, I strongly recommend against increasing interface complexity for this purpose. Bookshelf is already confusing enough, simplicity is always good as long as the requirements are met (which they seem to be).\nDoes this address your issues?\n\n(The above comments are re: my version not Playrom's -- https://github.com/bookshelf/bookshelf/pull/1474/files).\nY'all do whatever you want, and feel free to choose whichever implementation you like better (I don't actually use Bookshelf any more, it has a lot of other much bigger issues compared to other node ORM's - https://stackoverflow.com/questions/41914802/how-do-i-properly-update-models-with-bookshelf-js and https://github.com/bookshelf/bookshelf/issues/1471 scratches the surface on some big ones), but those are my thoughts.\nJ. @jadengore The original implementation of this is at  https://github.com/bookshelf/bookshelf/pull/1474 and is also ready to go aside from documentation (just to be clear on history here, I did #1474 a few months back and submitted a PR, then @Playrom spotted it recently and proposed this PR as an alternate implementation -- see the comments there). In particular, regarding @Playrom's implementation, see https://github.com/bookshelf/bookshelf/pull/1474#issuecomment-317250620, which I'll reproduce here:\n\n@Playrom Sorry about the delay. To answer your original question:\n\nIf there are multiple virtual how can I decide the params for each one?\n\nI considered this when designing this code, and it's already possible pretty easily without any additional interface complexity. You can pass any object you want as the parameter and the virtuals can read any field they want. For example:\n```\nsomeModel.toJSON({virtuals:true, param:{\n   firstVirtual: { x: 1 },\n   secondVirtual: { x: 2 }\n}})\n...\nvirtuals: {\n    firstVirtual: function (parameter) {\n      console.log(parameter.firstVirtual.x);\n      return ...;\n    },\n    secondVirtual: function (parameter) {\n      console.log(parameter.secondVirtual.x);\n      return ...;\n    }\n}\n```\nAlso there's no need to actually name the parameter fields the same as the virtuals, I just did that for the example. (In fact I'd recommend against that when possible, encouraging proper data layer design and using business names instead e.g. param.currentUser, etc, for various reasons -- basically if you find yourself having to specify virtual names in param fields it's probably a small red flag that you haven't separated your view/logic/data layers well enough, but I digress.)\nGiven that this is already possible, I strongly recommend against increasing interface complexity for this purpose. Bookshelf is already confusing enough, simplicity is always good as long as the requirements are met (which they seem to be).\nDoes this address your issues?\n\n(The above comments are re: my version not Playrom's -- https://github.com/bookshelf/bookshelf/pull/1474/files).\nY'all do whatever you want, and feel free to choose whichever implementation you like better (I don't actually use Bookshelf any more, it has a lot of other much bigger issues compared to other node ORM's - https://stackoverflow.com/questions/41914802/how-do-i-properly-update-models-with-bookshelf-js and https://github.com/bookshelf/bookshelf/issues/1471 scratches the surface on some big ones), but those are my thoughts.\nJ. Btw, just as a note: Forcing virtual parameters to be split across functions and not allowing them to be shared (which this implementation appears to do, rather than my earlier implementation) is likely a really bad idea, as it completely removes the ability to have business-level parameters and forces entangling of layers (the view/business layers must now know the names of the virtuals).\nFor example, consider a model with three virtuals, all which need some combination of parameters, (or whatever). In my implementation:\nvirtuals: {\n    fullName: function (parameter) {\n       // use parameter.currentUser\n       // use parameter.somethingElse\n    },\n    isEditable: function (parameter) {\n       // use parameter.currentUser\n       // use parameter.editMode\n       // use parameter.somethingElse\n    },\n    isDeletable: function (parameter) {\n       // use parameter.currentUser\n       // use parameter.editMode\n    }\n}\nWith this, business/view can convert to JSON and provide business-level data:\n// we don't know or care what the virtuals are, we only care about providing information.\n    // the model will use it appropriately.\n    model.toJSON({virtuals:true, param:{\n       currentUser: ...,\n       editMode: ...,\n       somethingElse: ...\n    });\nThere, if the model changes, we don't care. We don't need to know anything about its implementation details, or all of its field names or anything here, and if we change any of that this code can remain as-is. All we care about is providing the required business objects.\nBut if you force it to be function-level, all of a sudden not only do the other layers get messy, but now, unlike above, your business/view layers must know what the virtuals are, and you must update them everywhere any time you make changes to the model:\n// dang, now we have to make our view layer virtual-aware. plus way more redundant code:\n    model.toJSON({virtuals:true, param:{ \n       fullName: {\n         currentUser: ...,\n         somethingElse: ...\n       },\n       isEditable: {\n         currentUser: ...,\n         editMode: ...,\n         somethingElse: ...\n       },\n       isDeletable: {\n         currentUser: ...,\n         editMode: ...\n       },\n    });\nWhat happens when you add another field to the model that uses these parameters? Now you've got to go back and update all this intermediate code that otherwise just wants to blindly convert models to JSON and not care about what is/isn't a virtual field. Or, for example, if you change the model so that isDeletable requires somethingElse, you've got a lot more business/view code to double-check and tweak now. \nHopefully it is clear that this is no good. Bookshelf already has major issues with layer separation (the opposite of the intent of an ORM), and this kind of thing would add to that, for no real reason, as parameter.isEditable.currentUser could still be referenced by isEditable if that type of thing were necessary in my original implementation (i.e. no new functionality is added by limiting virtuals to function scope -- you can already achieve that in a simple manner in #1474 -- , but much unnecessary complexity is forced on application design).\nConsider this fair warning if you go this route.\n. Btw, just as a note: Forcing virtual parameters to be split across functions and not allowing them to be shared (which this implementation appears to do, rather than my earlier implementation) is likely a really bad idea, as it completely removes the ability to have business-level parameters and forces entangling of layers (the view/business layers must now know the names of the virtuals).\nFor example, consider a model with three virtuals, all which need some combination of parameters, (or whatever). In my implementation:\nvirtuals: {\n    fullName: function (parameter) {\n       // use parameter.currentUser\n       // use parameter.somethingElse\n    },\n    isEditable: function (parameter) {\n       // use parameter.currentUser\n       // use parameter.editMode\n       // use parameter.somethingElse\n    },\n    isDeletable: function (parameter) {\n       // use parameter.currentUser\n       // use parameter.editMode\n    }\n}\nWith this, business/view can convert to JSON and provide business-level data:\n// we don't know or care what the virtuals are, we only care about providing information.\n    // the model will use it appropriately.\n    model.toJSON({virtuals:true, param:{\n       currentUser: ...,\n       editMode: ...,\n       somethingElse: ...\n    });\nThere, if the model changes, we don't care. We don't need to know anything about its implementation details, or all of its field names or anything here, and if we change any of that this code can remain as-is. All we care about is providing the required business objects.\nBut if you force it to be function-level, all of a sudden not only do the other layers get messy, but now, unlike above, your business/view layers must know what the virtuals are, and you must update them everywhere any time you make changes to the model:\n// dang, now we have to make our view layer virtual-aware. plus way more redundant code:\n    model.toJSON({virtuals:true, param:{ \n       fullName: {\n         currentUser: ...,\n         somethingElse: ...\n       },\n       isEditable: {\n         currentUser: ...,\n         editMode: ...,\n         somethingElse: ...\n       },\n       isDeletable: {\n         currentUser: ...,\n         editMode: ...\n       },\n    });\nWhat happens when you add another field to the model that uses these parameters? Now you've got to go back and update all this intermediate code that otherwise just wants to blindly convert models to JSON and not care about what is/isn't a virtual field. Or, for example, if you change the model so that isDeletable requires somethingElse, you've got a lot more business/view code to double-check and tweak now. \nHopefully it is clear that this is no good. Bookshelf already has major issues with layer separation (the opposite of the intent of an ORM), and this kind of thing would add to that, for no real reason, as parameter.isEditable.currentUser could still be referenced by isEditable if that type of thing were necessary in my original implementation (i.e. no new functionality is added by limiting virtuals to function scope -- you can already achieve that in a simple manner in #1474 -- , but much unnecessary complexity is forced on application design).\nConsider this fair warning if you go this route.\n. ",
    "nixgadget": "@vitorbaptista @rhys-vdw thanks for the tips guys. Gives me a good direction now.\n. @rhys-vdw will there be a new release for this bug ?\n. @rhys-vdw Thanks. Due to some changes in babel (in the latest release) its breaking the build with this error. \n. ",
    "xfg": "I want to know too.\n. ",
    "yuriploc": "@vellotis Yes, I was messing up with the name tableName. Thank you\n. ",
    "justincy": "This isn't good enough. The lodash requires need to be updated to address the same issue that was fixed in knex: https://github.com/tgriesser/knex/issues/1214. \n. Knex v0.11 uses lodash v4 while bookshelf v0.9.4 uses lodash v3. That discrepancy broke my code which uses lodash v4. I guess that would be my problem but bookshelf deps should probably also be updated to not allow lodash v4 and raise an error on install as opposed to runtime.\n. Some of the require statements inside of bookshelf in the form of\nrequire('lodash/module/module') threw errors just as described in the knex\nissue I linked to above.\nOn May 11, 2016 5:16 PM, \"Rhys van der Waerden\" notifications@github.com\nwrote:\n\n@justincy https://github.com/justincy how did it break your code?\nLodash is not exposed by bookshelf, and npm can handle different versions\nof the same library.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/pull/1227#issuecomment-218606822\n. But I don't remember where in the code it is and I won't have time to look\ntoday.\nOn May 12, 2016 6:27 AM, \"Justin York\" justincyork@gmail.com wrote:\nSome of the require statements inside of bookshelf in the form of\nrequire('lodash/module/module') threw errors just as described in the knex\nissue I linked to above.\nOn May 11, 2016 5:16 PM, \"Rhys van der Waerden\" notifications@github.com\nwrote:\n\n@justincy https://github.com/justincy how did it break your code?\nLodash is not exposed by bookshelf, and npm can handle different versions\nof the same library.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/pull/1227#issuecomment-218606822\n. \n\n",
    "colophonemes": "I'm having this issue too. It looks like the GitHub repo has the right version in package.json, but the NPM package needs updating.\n. Awesome, thanks!\nOn Wed, 18 May 2016 at 5:31 PM, Gaston Sanchez notifications@github.com\nwrote:\n\nUpdate to the last version. This should be fixed now.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1241#issuecomment-220083404\n. \n",
    "edorozco": "Thanks.. \n. ",
    "blakeandrewwood": "Ah okay thanks for letting me know.\n. ",
    "skywickenden": "@rhys-vdw I am indeed using Maria.\n. ",
    "ryanvanderpol": "+1 here.  Took me a while to figure out that it was fetchPage that was causing the problem! Can we get this PR merged in please?. It's a little subtle, but those are not actually equivalent statements.  In ES6 arrow functions maintain the context of their container and your object literal is not the context you think it is.  See this article for more details on this.\nI think what you actually want is the following\nconst User = bookshelf.Model.extend({\n  initialize() {\n    this.on('saving', this.validateSave);\n  }\n});\n. It's a little subtle, but those are not actually equivalent statements.  In ES6 arrow functions maintain the context of their container and your object literal is not the context you think it is.  See this article for more details on this.\nI think what you actually want is the following\nconst User = bookshelf.Model.extend({\n  initialize() {\n    this.on('saving', this.validateSave);\n  }\n});\n. A little more testing and I can also add this data point: changing the plugin so that it creates a new Promise that has an internal setTimeout that doesn't resolve until the other event is finished also exhibits the same issue as the original code.  eg:\n``\nthis.on('saved', (model, attrs, options) => {\n           return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                        events.emit(${this.tableName} saved`, model)\n                        .then(() => resolve())\n                        .catch(err => reject(err));\n                }, 1000);\n     });\n\n});\n```\nNotice how this is different from the way I'm using setTimeout in my previous post -- this time I'm returning a Promise that doesn't resolve until the second event is finished executing.  \nThis leads me to believe that the event emitted by Bookshelf is creating some sort of blocking effect (eg. whatever Bookshelf internal code that executes AFTER the saved event is finished needs to happen before any subsequent fetch call will pick up the newly inserted record.). A little more testing and I can also add this data point: changing the plugin so that it creates a new Promise that has an internal setTimeout that doesn't resolve until the other event is finished also exhibits the same issue as the original code.  eg:\n``\nthis.on('saved', (model, attrs, options) => {\n           return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                        events.emit(${this.tableName} saved`, model)\n                        .then(() => resolve())\n                        .catch(err => reject(err));\n                }, 1000);\n     });\n\n});\n```\nNotice how this is different from the way I'm using setTimeout in my previous post -- this time I'm returning a Promise that doesn't resolve until the second event is finished executing.  \nThis leads me to believe that the event emitted by Bookshelf is creating some sort of blocking effect (eg. whatever Bookshelf internal code that executes AFTER the saved event is finished needs to happen before any subsequent fetch call will pick up the newly inserted record.). ",
    "henriquehirako": "Any news on this?. @jamesdixon Yes, I'm getting this impression too. Hopefully we are wrong!. ",
    "vencax": "i do fetchPage on result of query call but end up without any opts in fetchPage. I cannot understand why ... result of babelification is:\n```\nbookshelf.Collection.prototype.fetchPage = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\nreturn fetchPage.apply.apply(fetchPage, [this.model.forge()].concat(args));\n\n};\n```. ",
    "sandorfr": "I agree, the behavior your pointed should be correct. However implementation with sql in no trivial, especially with the knex -> mssql -> tds/alternative drivers. sql server requires to wrap the statement with :\nsql\nSET IDENTITY_INSERT [ database_name . [ schema_name ] . ] table { ON | OFF }\nI think I can update my fix by checking the actual values and to drop idAttribute only if the values are the same. This will allow this behavior (which will fail in SQL until a fix for that matter is done) while fixing the original issue.\nLet me know what you think about that. Bonus question I don't see any integration test for mssql, should I bootstrap this with tests around my fix?\n. Just updated the PR to allow updating ids. It will fail on mssql unless people call SET IDENTITY_INSERT first. I think this has too much side effects on SQL Server to be safely transparent to the library consumer. \n. @vellotis Sure I can add the tests. I'll take some time next week to do so. \nRegarding Mssql Tests, I will work on this later this month since I found additional issue which I'm not sure how to address but writing the tests will be easy.\n. @vellotis  It seems like the behavior mentioned by @rhys-vdw (updating id of an existing object) is not yet available and should be treated as another improvement issue. There is already general tests for the current behavior.\nI tried the to add the following integration test which ended up with sqlite3 Model save updates id property of an existing object. \njavascript\n it('updates id property of an existing object', function() {\n        var createdSiteId;\n        return new Site({name: 'A Site'}).save()\n          .then(function(m) {\n            console.log('fectching')\n            createdSiteId = m.get('id');\n            return new bookshelf.Collection(null, {model: Site}).fetch();\n          })\n          .then(function(c) {\n            equal(c.last().id, createdSiteId);\n            equal(c.last().get('name'), 'A Site');\n            return c;\n          })\n          .then(function (c) {\n            var createdSite = c.last();\n            createdSite.set('id', createdSiteId + 50);\n            createdSite.set('name', createdSite.get('name') + \" Updated\");\n            return createdSite.save();\n          })\n          .then(function() {\n            return new bookshelf.Collection(null, {model: Site}).fetch();\n          }) \n          .then(function(c) {\n            equal(c.last().id,  createdSiteId + 50);\n            equal(c.last().get('name'), 'A Site Updated');\n            return c.last();\n          })\n          .then(function(c) {\n            return c.destroy();\n          });\n      });\n. Any update on this?. Any update on this?. Well no really, the tests are already there, the feature that would consist of updating the is of an existing object is just not implemented and beyond the scope of that PR.\nTo be honest I gave up on contributing to that project. . This is a very small bug fixe that has been left hanging for years without\nany answer on concerns I raised above.\nAs I\u2019m saying the PR is not introducing any changes but fixing a bug. There\nare already test in place for updates. The feature of updating the Id of an\nexisting object is just not implemented at all (at least by the time of the\nPR). I realized that when I actually tried to add test for that feature.\nIt\u2019s actually in the comments above...\nSo yes I really don\u2019t know what you hope me to do, but I\u2019m for sure not\ngonna fight against windmill.\nOn Mon 8 Jan 2018 at 08:39, Ricardo Gra\u00e7a notifications@github.com wrote:\n\nThere are no tests in PR #1260\nhttps://github.com/bookshelf/bookshelf/pull/1260. If you're not willing\nto add at least one test to check for the correct behavior of that change I\nmight be able to add one.\nI'm planning on doing a release soon, but that won't include changes, only\nsmall bug fixes. The release after that will include changes, like the one\nbeing proposed in #1260 https://github.com/bookshelf/bookshelf/pull/1260\n.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/issues/1259#issuecomment-355854902,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACiXpt5N35O_yBm0KOP3Em5E-MW1vAWMks5tITmUgaJpZM4Ik4Lb\n.\n. \n",
    "victorsoliveira": "Any defined deadline for this issue ?\n. ",
    "oirad": "The PR of @sandorfr solved this issue for me as well, is this planned to be merged at some point?. @tmcdonnell87 I started working on integrating the tests for mussel but did not get around finishing yet. If you have a bit more time have a look at: https://github.com/oirad/bookshelf/tree/fix-mssql-1259\nI use the following to create the needed databases to run the tests:\ndocker run --rm -e 'POSTGRES_PASSWORD=root' -e 'POSTGRES_USER=root' -e 'POSTGRES_DB=bookshelf_test' -p 5432:5432 -d postgres:9.6.3-alpine\ndocker run --rm -e 'MYSQL_ROOT_PASSWORD=root' -e 'MYSQL_DATABASE=bookshelf_test' -p 3306:3306 -d mysql:5.7.18\ndocker run --rm -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Test1234' -p 1433:1433 -d microsoft/mssql-server-linux:ctp-2.0. ",
    "tmcdonnell87": "Yes, I'm stuck on this as well. Any reason we can't merge for 10.4?\n. ",
    "ahmedcanuck": "Hey @rhys-vdw, this is what I'm seeing. Could possibly be something I'm missing with npm package options:\nnpm install\nnpm WARN package.json fifteenfourtynine@1.0.0 No README data\nnpm WARN unmet dependency /Users/booradley/WebstormProjects/fifteenfourtynine/node_modules/bookshelf requires lodash@'^3.8.0' but will load\nnpm WARN unmet dependency /Users/booradley/WebstormProjects/fifteenfourtynine/node_modules/lodash,\nnpm WARN unmet dependency which is version 4.13.1\nnpm WARN unmet dependency /Users/booradley/WebstormProjects/fifteenfourtynine/node_modules/checkit requires lodash@'^2.4.0 || ^3.0.0' but will load\nnpm WARN unmet dependency /Users/booradley/WebstormProjects/fifteenfourtynine/node_modules/lodash,\nnpm WARN unmet dependency which is version 4.13.1\nnpm WARN unmet dependency /Users/booradley/WebstormProjects/fifteenfourtynine/node_modules/knex requires lodash@'^3.7.0' but will load\nnpm WARN unmet dependency /Users/booradley/WebstormProjects/fifteenfourtynine/node_modules/lodash,\nnpm WARN unmet dependency which is version 4.13.1\n. @ezmiller  I realized that after posting and hence why I deleted my message. It was relevant in our case since we were trying to allow the following of more than just users. \nBut in your case this doesn't make sense.\nWhat I'd personally do in your case is do it the way @vellotis suggested :)\n. The above mentioned ones look great! I would add pagination which is a crucial feature but doesn't seem to be working in the latest version.\n. oops, this actually works\n. ",
    "robdiciuccio": "+1. +1. ",
    "pmettraux": "Any news on this ? The issue is still here. https://github.com/tgriesser/bookshelf/pull/1561. Shit tests fail, my bad. Ok fixed. I have been working on a fork since nobody was answering. Now obviously conflicts appeared. The entire discussion is here : https://github.com/bookshelf/bookshelf/pull/1272. I do not have time these days, sorry. I do not have time these days, sorry. ",
    "Whoaa512": "@rhys-vdw, ping\n. ",
    "kamronbatman": "@rhys-vdw This looks like it's ready to merge!\n. @vellotis I added testing and all tests passed.. @Playrom - Yes, this is a non-breaking change specifically for the visibility plugin.. Thanks!. @wenderjean You should try Promise.map with concurrency set.  I know this slows down your processing, but that should resolve the issue.  Your other option might be to use a mysql script instead.. @wenderjean You should try Promise.map with concurrency set.  I know this slows down your processing, but that should resolve the issue.  Your other option might be to use a mysql script instead.. ",
    "vitornogueira": "I tried and still the same :disappointed: \n``` javascript\nconst db = require('../libs/db')\nmodule.exports = db.Model.extend({\n  tableName: 'sheets',\n  uuid: true,\n  hasTimestamps: true,\n})\n```\n. @vellotis I also tried but failed.\nsheets migration:\n``` javascript\nexports.up = knex => knex.schema.createTable('sheets', table => {\n  table.uuid('id').primary()\n  table.uuid('schedule_id')\n    .notNullable()\n    .references('id')\n    .inTable('schedules')\n  table.string('title').notNullable()\n  table.json('data').notNullable()\n  table.index(['schedule_id', 'title'], 'schedule_sheet_title')\n  table.timestamps()\n})\nexports.down = knex => knex.schema.dropTable('sheets')\n```\njavascript\n// select\nSchedule\n  .where({ route_id: request.params.id })\n  .fetchAll({\n    required: true,\n    withRelated: [{\n      sheets: qb => qb.select('id', 'title'),\n    }],\n    columns: ['id', 'title', 'description', 'type', 'url', 'updated_at'],\n  })\n  .then(schedules => {\n    reply(schedules)\n  })\n. @vellotis \njson\n{\n  \"method\": \"select\",\n  \"options\": {},\n  \"timeout\": false,\n  \"bindings\": \n   [ \"84c20fcf-e35c-4bbc-adba-76a1de202042\",\n     \"e4bfe6dc-27e9-4e10-ac83-127c4d56655f\",\n     \"b58212e8-27bb-41bc-a64e-eba9a65fe1f8\" ],\n  \"sql\": \"select 'id', 'title' from 'sheets' where 'sheets'.'schedule_id' in (?, ?, ?)\"\n}\n. Thank you @absolux and @vellotis. I change my API and now is ok :wink: \nI'm studying node.js and I create this project: https://github.com/vitornogueira/itapebus-api.\nComments and suggestions are welcome.\n. ",
    "acburdine": "So there seems to be a bug with the model clone method, and since I haven't touched that function/lodash shouldn't have broken it with new functions, I haven't a clue as to why it's breaking :/\n. So I figured out why this is happening, although I'm not sure how to fix it.\nThe clone method in src/base/model.js doesn't seem to have access to the full prototype in extended objects. Essentially, the only things that the clone method has access to is the methods on the prototype of the base model. Any instance variables/functions and prototype methods added in subclasses aren't available to the clone method. \ud83d\ude15 \nI think this is due to a bug in the extend utility, but haven't figured out how to make it work....\n. I FIGURED IT OUT!\nOr rather, I fixed it.\nSo my best guess is that the update to lodash 4 only revealed a system that shouldn't have worked in the first place. There were several instances throughout the codebase where the parent class prototype functions weren't being applied correctly. I still haven't a clue why it didn't fail earlier.\nExamples of this:\njs\nBookshelfModel = ModelBase.extend({\n     // lines removed for brevity\n    clone() {\n        const parentClone = ModelBase.prototype.clone(...arguments);\n    }\n});\nNot sure if it's a bug with Babel, but this essentially gets converted to:\njs\nBookshelfModel = ModelBase.extend({\n     // lines removed for brevity\n    clone: function () {\n        const parentClone = ModelBase.prototype.clone.apply(ModelBase.prototype, arguments); // should be `apply(this, arguments)`\n    }\n});\nwhich is why the clone method didn't have access to the correct class properties.\nI did some cleanup of the extend function as well (based it off of class-extend).\nJust ironing out a few more test bugs and then this should be good to go.\n. @rhys-vdw I have the changelog edits needed for 0.10 sitting on my computer. I can submit them as a part of this PR (if you're ready to release 0.10) or wait until you are and then submit the changelog edits then.\n. ...and it's green!\n. @rhys-vdw any update on this?\n. @rhys-vdw Should be good to go now \ud83d\udc4d \n. @erisds I don't, but I can create one :)\n. Alright, give me a few hours and I'll see what I can do :smile:\n. @rhys-vdw As far as I can tell, Ghost's test suite passes. I went through all of the server code and didn't see any instances of methods that were removed in the update.\nThe test suite does have a couple of failures, but I am fairly certain they are due to test bugs in Ghost's code (there's been a lot of new changes recently and some of the bugs are still being worked out).\n/cc @ErisDS \n. I'm perfectly fine with that, just didn't know if you wanted to do a breaking change or not :)\n. definitely. I'm assuming this would be for 1.0?\n. The issue with updating the lodash API is unless I add in aliases for certain methods, many of the methods will go away (a lot of Lodash aliases were removed), which constitutes a breaking change \ud83d\ude15 \n. Right, I forgot \ud83d\ude04 \nanother thing I can do is remove as much as I can of the internal usage of lodash when it's applied to the other classes and switch it out for calling Lodash directly.\nExample: collection.invokeMap => _.invokeMap as much as I can. That way, if we want to in the future drop all lodash methods from certain classes we can without any major code refactoring on the part of bookshelf.\n. ",
    "ijc-90": "tkz for the quick response. It's exactly after the fetch, when we call the \"then\" function\nTypeError: Cannot read property 'triggerThen' of undefined\n      at app/models/base_model.js:9:1450\n      at tryCatcher (node_modules/bluebird/js/release/util.js:16:23)\n      at MappingPromiseArray._promiseFulfilled (node_modules/bluebird/js/release/map.js:57:38)\n      at MappingPromiseArray.PromiseArray._iterate (node_modules/bluebird/js/release/promise_array.js:113:31)\n      at MappingPromiseArray.init (node_modules/bluebird/js/release/promise_array.js:77:10)\n      at new MappingPromiseArray (node_modules/bluebird/js/release/map.js:25:10)\n      at map (node_modules/bluebird/js/release/map.js:139:12)\n      at Promise.map (node_modules/bluebird/js/release/map.js:143:12)\n      at null.<anonymous> (app/models/base_model.js:9:1341)\n      at tryCatcher (node_modules/bluebird/js/release/util.js:16:23)\n      at null.<anonymous> (node_modules/bluebird/js/release/method.js:15:34)\n      at node_modules/bookshelf/lib/base/events.js:180:25\n      at tryCatcher (node_modules/bookshelf/node_modules/bluebird/js/main/util.js:26:23)\n      at MappingPromiseArray._promiseFulfilled (node_modules/bookshelf/node_modules/bluebird/js/main/map.js:56:38)\n      at MappingPromiseArray.init (node_modules/bookshelf/node_modules/bluebird/js/main/promise_array.js:92:18)\n      at MappingPromiseArray.init (node_modules/bookshelf/node_modules/bluebird/js/main/map.js:29:23)\n      at Async._drainQueue (node_modules/bookshelf/node_modules/bluebird/js/main/async.js:128:12)\n      at Async._drainQueues (node_modules/bookshelf/node_modules/bluebird/js/main/async.js:133:10)\n      at Immediate.Async.drainQueues [as _onImmediate] (node_modules/bookshelf/node_modules/bluebird/js/main/async.js:15:14)\n. This is the code testing (forgot to show the \"forge\" in the code up, i will edit it now):\nFiscalNotes\n                .forge({\n                    id: 1, \n                })\n                .fetch({ withRelated: ['type.gateway'] })\n. I'll copy it as it is:\n```\n\"use strict\";\nvar bookshelf = require('../bookshelf');\nvar errors = require('../errors');\nvar Checkit = require('checkit');\nvar _ = require('lodash');\nvar Promise = require('bluebird');\nbookshelf.plugin(require('bookshelf-soft-delete'));\nvar BaseModel = bookshelf.Model.extend({\n    soft: ['deleted_at'],\n    hasTimestamps: true,\ninitialize: function () {\n    this.on('saving', this.validate.bind(this));\n\n    this.on('fetched', Promise.method(function (model, attributes, options) {\n        if (!(options && options.withRelated)) {\n            return;\n        }\n\n        return Promise.map(options.withRelated, function (relation) {\n            return model.related(relation);\n        })\n        .map(function (model) {\n            return model.triggerThen('fetched', model, model.attributes);\n        });\n    }));\n},\n\nvalidations: {},\nconditionalValidations: [],\nvalidate: function () {\n    var model = this;\n    var checkit = new Checkit(this.validations);\n\n    _.each(this.conditionalValidations, function(validation){\n        checkit.maybe.apply(checkit, validation);\n    });\n\n    return checkit.run(this.attributes)\n        .catch(function(err){\n            throw new errors.ValidationError(model, err);\n        });\n}\n\n}, {\n    extend: function (instanceProps, staticProps, pluralName) {\n        var model = bookshelf.Model.extend.apply(this, [].slice.call(arguments));\n        return model;\n    }\n});\nBaseModel.transaction = bookshelf.transaction.bind(bookshelf);\nBaseModel.bookshelf = bookshelf;\nmodule.exports = BaseModel;\n```\n. thank you! I'll look into it\n. Yes! thank you very much\n. ",
    "spamguy": "Reopening because, after a lot of editing, I can't see a way to commit my transaction and use asCallback at the same time.\n. ",
    "jmm": "Thanks for the reply @rhys-vdw. I'm not sure when I'd have the chance, so I'm all for it if someone else wants to do it sooner.\n. If you're following that convention, yeah that'd make sense. Technically you can do anything since you're pre v1.\n. ",
    "valtlfelipe": "Any update on this?\n. Just using withRelated on a model with a belongsTo relationship.\nNow I have no access to my project, but later I can post some code.\n. I'm using bookshelf 0.9.5 and knex 0.11.5.\nMy base model:\njs\nbookshelf.Model.extend({\n    hasTimestamps: true\n});\nMy model:\njs\nbaseModel.extend({\n    tableName: 'components',\n    group: function() {\n        return this.belongsTo('Group', 'group_id');\n    }\n});\nIf I do a query like those:\njs\nthis.model.fetchPage({\n    page,\n    pageSize,\n    withRelated: ['group']\n});\n// or\nthis.model.where('id', id).fetch({withRelated: ['group']});\nThe object that returns is like this one if no relation found:\njs\n{\n    id: 4,\n    name: \"Teste 2222\",\n    description: \"\",\n    created_at: \"2016-06-18T21:03:55.000Z\",\n    updated_at: \"2016-08-23T02:36:54.000Z\",\n    group_id: null,\n    group: { }\n}\n. ",
    "Nick-Riggs": "We've also encountered this. Here are some of my findings: \n1) This only occurs when using the pagination plugin's fetchPage method. fetch() works as expected.\n2) This is a performance issue as fetchPage isn't just attaching a empty object for the relation, it's actually firing the queries against the database looking for null value relations. fetch() does not do this. . +1 We'd like to see this merged as we are having the same issue. . ",
    "patrickdevivo": "+1 seeing the same issue. +1 seeing the same issue. ",
    "smitt04": "+1. This happens when you pass a function into where. It doesn't even get inside the callback function. It errors before that.. +1. This happens when you pass a function into where. It doesn't even get inside the callback function. It errors before that.. Running node 6.9.1. Have not tried older versions of node yet.. Running node 6.9.1. Have not tried older versions of node yet.. This appears to be a problem with knex.. This appears to be a problem with knex.. I submitted issue: https://github.com/tgriesser/knex/issues/1851. I submitted issue: https://github.com/tgriesser/knex/issues/1851. ",
    "Titozzz": "Thank you very much,\nWill update my code then  :smile: \n@vellotis \n. Hi,\nI'm aware of the knex orderby, I just wanted to know if there was a way to do this with bookshelf. Maybe it would be nice to add an optional bool value to disable this part in the helper.\n. ",
    "andrezzoid": "@vellotis thanks for your response, but Collection#updatePivot would require me to call it for each product id, not very efficient :disappointed: \n. Thanks very much for your help @vellotis.\n. ",
    "raj-optisol": "After removing this _.pick(options, 'transacting') from fetch() only query started executing.. But its not gave me desired output.\n``` javascript\nUser = bookshelf.Model.extend({\n  tableName: 'users',\n  initialize: function() {\n    this.on('saving', this._assertEmailUnique);\n  },\n  _assertEmailUnique: function(model, attributes, options) {\n    if (this.hasChanged('email')) {\n      return this\n        .query('where', 'email', this.get('email'))\n        .fetch()\n        .then(function (existing) {\n      // Currently it throw an error if 'email' is existing\n      // existing = new bookshelf.Model()\n      // console.log(!existing) // true\n      if (existing) throw new Error('duplicate email');\n\n    });\n}\n\n}\n});\n```\nand also changed query like this .query('where', 'email', '=', this.get('email'))\nI checked with existing email, its not finding anything in the DB.. returning like its new always.. \n. Fixed: Querying on this will constrain your query to the current record, you need to query from scratch, using plain User\njavascript\nUser = bookshelf.Model.extend({\n  tableName: 'users',\n  initialize: function() {\n    this.on('saving', this._assertEmailUnique);\n  },\n  _assertEmailUnique: function(model, attributes, options) {\n    if (this.hasChanged('email')) {\n      return User\n        .query('where', 'email', this.get('email'))\n        .fetch()\n        .then(function(existing) {\n          if (existing) {\n            throw new Error('Duplicated email: User id #' + existing.id);\n          }\n        });\n    }\n  }\n});\n. @vellotis  Thanks for your response..  Ok then any idea for building feature like in Rails to_sql ??\n. ",
    "raj-adroit": "@rhys-vdw If i add unique constraint on the column, it won't insert and throw error, How can i catch and show/parse that error ?\n. ",
    "nmagerko": "I had it wrong. It should have been:\nFoo.prototype.bars = function () {\n    return this.belongsToMany(Bars).through(FooBar).fetch();\n}\nThat will return a Collection containing all of the Bar models that are related to this Foo model via the FooBar join table.\n. Thanks! I'll take a look over there :). Thanks! I'll take a look over there :). ",
    "Paxa": "If you run with DEBUG=knex:query it will print queries but it will be something like:\nknex:query select \"users\".* from \"users\" where \"company_id\" = ? limit ? +3ms\nIf you need to see more - you can patch current code and add custom logging:\njs\nvar util = require('util');\nvar knexClient = require('knex/lib/client');\nvar origQuery = knexClient.prototype.query;\nknexClient.prototype.query = function (connection, obj) {\n  console.log(`SQL: ${obj.sql}  --  ${util.inspect(this.prepBindings(obj.bindings))}`);\n  return origQuery.apply(this, arguments);\n};\nOutput will be:\nSQL: select \"users\".* from \"users\" where \"company_id\" = ? limit ?  --  [45, 1]\n. If you run with DEBUG=knex:query it will print queries but it will be something like:\nknex:query select \"users\".* from \"users\" where \"company_id\" = ? limit ? +3ms\nIf you need to see more - you can patch current code and add custom logging:\njs\nvar util = require('util');\nvar knexClient = require('knex/lib/client');\nvar origQuery = knexClient.prototype.query;\nknexClient.prototype.query = function (connection, obj) {\n  console.log(`SQL: ${obj.sql}  --  ${util.inspect(this.prepBindings(obj.bindings))}`);\n  return origQuery.apply(this, arguments);\n};\nOutput will be:\nSQL: select \"users\".* from \"users\" where \"company_id\" = ? limit ?  --  [45, 1]\n. ",
    "cjnqt": "But if you'd like to get a hold of the generated SQL without executing it (just like knex toString() function) \u2013 how would you go about implementing it?\nmodel.query() is a good start, but we can't do \nmodel.save({key: val}).query( qb => { \n   qb.toString()...\n})\nright?\n. But if you'd like to get a hold of the generated SQL without executing it (just like knex toString() function) \u2013 how would you go about implementing it?\nmodel.query() is a good start, but we can't do \nmodel.save({key: val}).query( qb => { \n   qb.toString()...\n})\nright?\n. Yes, events changes stuff, but finally knex will create the query and send it to db. What I am looking for is a way to expose knex's toString function in bookshelf so that knex returns the query rather than send it to db. \nNot implementing a new toString-function in bookshelf\n. I guess it would be good for testing, but my use case is this: \nI work with financial data and use transactions a lot. Sometimes I'd like wrap a large amount of queries within a transaction, and in these cases the regular syntax for transactions isn't working out that well. So I have looked for another way of creating transactions.\nI first tried to simply write a long SQL-query for these cases (BEGIN; QUERY1; QUERY2; ...; COMMIT) and run with knex.raw() but knex parameter binding (knex.raw(sql, {bindings}) requires that the provided sql only contains one query. So that isn't a good options. I think it would be nice to be able to write: \n```\nvar sql = [\n'BEGIN',\nbookshelf.model('User').forge().save({some:data}).toString(),\nbookshelf.knex.raw( 'SOME RAW SQL', {data: bindings}).toString(),\nbookshelf.model('Other').forge().save({some:data}).toString(),\n... many more queries here...\n'COMMIT'\n].join(';')\nknex.raw( sql ).then(...)\n```\nEasily join together a large amount of queries into a sql string.\n. Any news regarding this?\n. Any news regarding this?\n. ",
    "RobAWilkinson": "@vellotis is it possible to write to 2 seperate Databases in a single transaction?\nI'm trying to create a system where a record of every sql query is saved in an external DB. . @vellotis is it possible to write to 2 seperate Databases in a single transaction?\nI'm trying to create a system where a record of every sql query is saved in an external DB. . sorry for the lack of response thank you @vellotis . Looks like you can call db._models. Closing. ",
    "daleknauss": "Has there been any movement on this feature and/or alternatives found? I find myself with an identical need and not sure how to proceed.. Has there been any movement on this feature and/or alternatives found? I find myself with an identical need and not sure how to proceed.. ",
    "Playrom": "yes it's ok\nOnly one thing,  I'm a bit concerned for the change to the morphTo api, I don't want to break existing usage.... \nhave you tried to test it without your update to the integrations test?. I've merged #1531 , we can now work on this PR. @TinOo512 @ricardogama are you still working on this issue and PR?  we could merge the PR\na new team is in charge of the project :) we are starting to review the PRs\nif you want to discuss about the future take a look at #1511 . Great!\nreply when you have more news and in case I'll merge it :)\nAlso if you could explain more in detail the problems and the fix it will be awesome :) just for documentation and a simple analysis of the issue :). Thanks for your work! PR Merged!\na new team is in charge of the project :) we are starting to review the PRs\nif you want to discuss about the future take a look at #1511 . I'll look in to this PR and merge into the branch as soon as possible :) I've created an implementation for the same problem but I think yours is better. If there are multiple virtual how can I decide the params for each one?\nmodel.toJSON({virtuals:true, param:42});\nis a bit not explicative, maybe the param entry in the json could be a json object?\nmodel.toJSON({\n        virtuals:true, \n        params:{\n            virtualName1:foo,\n            virtualName2:{\n              paramName1:bar,\n              paramName2:hello\n        }\n  });\nor maybe it can be restructured this way ( with the default values to be retro compatible)\nmodel.toJSON({\n        virtuals:{\n          enabled:true, \n          params:{\n            virtualName1:foo,\n            virtualName2:{\n              paramName1:bar,\n              paramName2:hello\n          }\n     }\n  });\nwhat to you think?\nalso @dj-hedgehog take a look. @JC3 any updates? . Fix Merged!. a new team is in charge of the project :) we are starting to review the PRs\nThanks for your work :) \nif you want to discuss about the future take a look at #1511 . a new team is in charge of the project :) we are starting to review the PRs\nThanks for your work :) \nif you want to discuss about the future take a look at #1511 . we could fork the project in the case he will not respond, but we have to promote the fork across the pull request and the issues in this repository to help and direct the community\nthere are 430 issues and 60 PR, I think that the demand is high. I think the same as @dj-hedgehog, I can help but I can't be the only one ( also because there are a tons of backlog PR and Issues to look at ). I think the same as @dj-hedgehog, I can help but I can't be the only one ( also because there are a tons of backlog PR and Issues to look at ). we could create a slack team to organise the work, what do you think?. we could create a slack team to organise the work, what do you think?. Thanks \ud83d\udc4d\ud83c\udffb. Thanks \ud83d\udc4d\ud83c\udffb. Fixed with #1531 . Fixed with #1531 . I've merged #1531 which is related to #1527 , can you check now?. I've merged #1531 which is related to #1527 , can you check now?. Thank you for the work \ud83d\udc4d  merged . I've only a concern about this change\njs\nvar foo = null\nif (bar == false) foo = \"jack\";\nUser.forge({ name: foo }).fetch()\nin this case maybe the developer want to know with an error if the variable is null. I've only a concern about this change\njs\nvar foo = null\nif (bar == false) foo = \"jack\";\nUser.forge({ name: foo }).fetch()\nin this case maybe the developer want to know with an error if the variable is null. Ok my understanding is that the events are triggered if using models but not using collections right, because there is not an implementation right?. #1542  Duplicate. You can use Knex function \"columnInfo\"\nhttp://knexjs.org/#Builder-columnInfo. You can use Knex function \"columnInfo\"\nhttp://knexjs.org/#Builder-columnInfo. maybe this has been fixed with #1583 , is it the same problems, am I correct?. maybe this has been fixed with #1583 , is it the same problems, am I correct?. ok!\ncan you provide a PR in the same style as #1583 but for the update_at timestamp?\nI will merge it to the master :). closing here, discuss in #1592 . closing here, discuss in #1592 . It could be either a knex or a bookshelf bug, it should be investigated. It could be either a knex or a bookshelf bug, it should be investigated. is it still a thing?. is it still a thing?. actually travis build correctly for Node 4, mmm. actually travis build correctly for Node 4, mmm. maybe we should rewrite the post install as you proposed in April. maybe we should rewrite the post install as you proposed in April. @mochini are you using bookshelf 0.10.4? we have shipped a fix. @mochini are you using bookshelf 0.10.4? we have shipped a fix. there is not an implementation for something like this, maybe you can duplicate the collection before editing\nif you want to make a proposal for the implementation of such a feature we can discuss about it :) . there is not an implementation for something like this, maybe you can duplicate the collection before editing\nif you want to make a proposal for the implementation of such a feature we can discuss about it :) . I think it is not possible, if you want to work on an implementation , or design this feature, open a new Issue with a description of your solution/proposal \nthanks \ud83d\udc4d . I think it is not possible, if you want to work on an implementation , or design this feature, open a new Issue with a description of your solution/proposal \nthanks \ud83d\udc4d . ok guys, I'm here for you! what's the state of this PR? . can you guys provide with a comment a PR description as in the new template PULL-REQUEST-TEMPLATE.md?\nI'm willing to merge this PR but I want to read a clear description of the effects and behaviour \n@vellotis @pmettraux \n. can you guys provide with a comment a PR description as in the new template PULL-REQUEST-TEMPLATE.md?\nI'm willing to merge this PR but I want to read a clear description of the effects and behaviour \n@vellotis @pmettraux \n. @jadengore if you can do us the favour  to review this whole fix it would be awesome \ud83d\udc4d . @jadengore if you can do us the favour  to review this whole fix it would be awesome \ud83d\udc4d . @pmettraux can you resolve conflicts? or I have to do it? :). @pmettraux can you resolve conflicts? or I have to do it? :). ok I'll do it don't worry :). ok I'll do it don't worry :). Fixed with #1531 . Fixed with #1531 . Thanks for your work! :) \nmerged \ud83d\udc4d . See #1570 for updates :). See #1570 for updates :). @sgraham785  \ncan you test your fix and in case submit a PR ? :). Issues Solved with #1597 , thank you :). after the save you can obtain the id from the model in the then function of the promise. I think this fix is useful, can you edit your pr to pass the Trevis checks? \nOnce passed I'll merge it. Test Passed! Merged to master, thank you :) \ud83d\udc4d. old question, closed.\nreopen it if necessary or if the discussion restarts.. can you enter debug mode with knex and check the raw sql query end messages?\nI think you are hitting some size limit, I don't know where. I've merged #1597 who solve the knex version problems\nThe tests shows that knex 0.13 doesn't break bookshelf\nthank you for this PR but it is now not necessary anymore \ud83d\udc4d . @fcarreiro we are going to publish an \"announcement\" as issue really really soon\nI'm actually working right now to create the 0.10.4 version to fix all the bugs merged in the last month, the only issue is that @tgriesser is the only one of us with power on npm. Thanks for the PR\nprovide the tests and I'll merge to the codebase \ud83d\udc4d  . mmm I will check on it. @jadengore I love the error driven programming so I'm for this change, the problem is that it will break a lot of existing code in production. added in 0.11 milestone. correct the bug, update the PR and I think we can merge\nI think it's preferable to have a correct installation procedure then the presence of some checks. \ud83d\udc4d . I think we are going to publish a new release really soon, to fix all the bug fixes merged in the last month\nAnd we'll start an open call for feature and help in the development really soon! stay tuned :). @ricardograca  open an issue about that, I'm open to a discussion about this point ( I hate babel  and no-es6  javascript ). @tkrotoff @joepie91 there are almost 500 issues, a lot of them back in years, and there were 7 months of total nightmare in this repo this year, without any kind of support... \nwe need to be realistic and focus the most recent or important issues and prs...\nalso if someone get some bad behaviour in bookshelf usage a simple search can prompt an old issue which can be reopened without any problem. @ricardograca @joepie91 ok if we can find a nice group of people that can triage all the past issue for me it is not a problem for me to reopen them all! ( but @dj-hedgehog will be very angry for a few hours lost :D ). Just All the issues must be triaged, not just a few, it would be useless...\nWe are trying to do the best for the project, don't hate us please. We want to create a good community with a lot of developers to thrive the future of bookshelf. ok nice idea @joepie91 \nby the way I think that all the questions can be set as close as dead without any thinking. I totally agree with @joepie91 , also the lack of code example and explanations in the issues is the reason why I wrote the new issue/pr templates, their usage will make the triage of new entries a lot easier!\nregarding the triage I think that yes the first priority is to label all the issues , assign yourself as assignee and maybe to set a milestone for the issue\nregarding the questions I think that their presence in the issues is essential, we don't have any real community on stackoverflow so a lot of people will always come here to ask for advice...\nthe best treatment I think is to leave the question open for a brief period and treat them as docs issue (if the question is not stupid) as suggested :)\nIt's important also to have a deeper use of the tools offered by GitHub, such as assignee, milestones and projects. @rhys-vdw every answer is a good answer!\nand we are the one that have to thanks you for your past work on bookshelf! :). @rhys-vdw every answer is a good answer!\nand we are the one that have to thanks you for your past work on bookshelf! :). @atrauzzi ?. @atrauzzi ?. @joelmukuthu I love the fact that it's full ES6 <3\nIf you want feel free to open some issues or PRs , if you have coded something not currently present in bookshelf we will surely evaluate to add that code! :). bookshelf have issues, it's impossible to deny, but for my own experience I think that objection is sometimes an overkill, sometimes too complicated\nBookshelf is in a sweet spot between the easy of use and the power using, I think we need to improve our functionalities while maintain the simple way of usage that is our the core aspect. discussion is useful :) we can improve in a lot of different ways, feel free to open some issue, I will put in our project backlog for discussion and future release :). discussion is useful :) we can improve in a lot of different ways, feel free to open some issue, I will put in our project backlog for discussion and future release :). hi guys,\nThe answer is simple, I can't develop bookshelf alone, I currently don't have the time or the capabilities to have this responsibility \nWhat I can do is to manage the project, such as merging PRs, organise the work of the contributors etc...\nI've created a Google Form in order to know how many people wants to help and to start working on the future\nhttps://goo.gl/forms/JSstGiMqJ2TGMa2N2\nPlease Sign Up If you want to help, without any help I can't make any promises. Exactly, but we are at the point that a lot of people are insteread but there are not A lot of useful PRs, so we need to talk each other. thank you very much @mrhwick , I think you are a better \"head\" then me in this moment, I just have currently so many personal organizational problem .... @dj-hedgehog check this one. I made some changes as suggested, please review it. sorry, I just don't write a lot of formal text, especially in English, so I'm a bit rusty :(. yeah , max priority this fix and the test @dj-hedgehog . thanks for the catch! \ud83d\udc4d \nwe have to understand how to differenciate between the model being updated know and the version already saved... any advice?\nin case this is impossible I will revert the change in the next release...\nin the mean time @jackwanders  can you describe this test of yours? is it possible to adapt it for our codebase? we are in need for a check for this piece of code :). without #1583 it's impossible to update easily the created_at and updated_at columns, because they are managed exclusively by bookshelf\nIn theory this is great and for the majority of cases this is the right behaviour, but for some edge cases, like the one proposed by @nil1511 , one would want more refined controls. in #1607 I propose a change, discuss there and tell me if you are ok with that  . Fixed with #1607 . Fixed with #1607 . as soon as we'll fix some other issue we will push a new 0.10 dot release. as soon as we'll fix some other issue we will push a new 0.10 dot release. asap. fixed with #1609 . fixed with #1609 . I'm in favour of this change , but we need to discuss a bit about this change...\nif someone is using bookshelf with babelify I think this removal will not change anything right?  I suppose they already compile bookshelf in their development. I think that react native is an important technology (that I hate), so we need to be careful to not to break the usage of bookshelf there, because it can be a source of a not-low usage\nBut on the other hand I think it is a waste of time to implement something only for the sake of react-native. Pros to not use babel anymore.\nTwo hours of bug-checks with failed tests because I didn't execute \"npm run build\" after every change.. Pros to not use babel anymore.\nTwo hours of bug-checks with failed tests because I didn't execute \"npm run build\" after every change.. @dantman ye I think I will add a \"npm run build &&\" in the test scripts. @dantman ye I think I will add a \"npm run build &&\" in the test scripts. @ricardograca do you think this change in documentation wording is fine?. @ricardograca do you think this change in documentation wording is fine?. the solution is that if you use the names of your timestamps columns as attributes in a save, the columns will set with your provided values, otherwise they will update as standard\nthe fix is merged in master branch, and It will released with a new version soon. the solution is that if you use the names of your timestamps columns as attributes in a save, the columns will set with your provided values, otherwise they will update as standard\nthe fix is merged in master branch, and It will released with a new version soon. hi guys, bad summer here so I couldn't follow the project\nI will look at it Asap. yes. yes don't worry :). nice catch!. nice catch!. yeah , this is the tricky part of nodejs and promises, you may don't understand the whole concept of non-blocking execution\nI think it's a different issue then #1484 . yeah , this is the tricky part of nodejs and promises, you may don't understand the whole concept of non-blocking execution\nI think it's a different issue then #1484 . I may suggest that the execution is so slow because you are trying to access the db concurrently\ncan you try to structure the code as suggested by Ricardo? I think that will be faster then executing your current code. mmmm the code for fetch and save is pretty simple, I don't see any promises with a bad set up..\nmaybe you can help us in track this \"bug\" :). never heard of It, seems nice\nbut it's a premium service, I think we don't have a budget. never heard of It, seems nice\nbut it's a premium service, I think we don't have a budget. @JC3 look at this. thank you @jadengore ! :) \ud83d\udc4d . thank you @jadengore ! :) \ud83d\udc4d . I wanted some more straightforward ways of passing parameters, but maybe it's more \"js-style\" to use son object as parameters, as you say mmm I think we can use this procedure\nregarding the split between parameters I see your point, but I can respond to you that you could use a a this.get(virtualAttribute) to get some info inside other virtual function, so maybe you could create a new attribute if you really need a value in a lot of different virtual ?. I wanted some more straightforward ways of passing parameters, but maybe it's more \"js-style\" to use son object as parameters, as you say mmm I think we can use this procedure\nregarding the split between parameters I see your point, but I can respond to you that you could use a a this.get(virtualAttribute) to get some info inside other virtual function, so maybe you could create a new attribute if you really need a value in a lot of different virtual ?. currently I don't have a lot of time, but I hope to return in full force soon \ud83d\udc4d . we don't have linting rules regarding this kind of problem, btw I'll edit. nice cleanup. Definitely . all the tests in the project use the \"new\" paradigm so I think it's better the current code. ",
    "racheldelman": "@Playrom any idea when this will be released?. yes @ricardograca . ",
    "mohammedBalhaddad": "@Playrom any update for the release ? thanks a lot. ",
    "hashtd": "I got similar issue similar issue with following error\ncode: '22P02',\n  detail: 'Expected \":\", but found \"}\".',\n  hint: undefined,\n  position: undefined,\n  internalPosition: undefined,\n  internalQuery: undefined,\n  where: 'JSON data, line 1: {\"{\\\\\"l\\\\\":\\\\\"b\\\\\"}\"}',\n& using plugin bookshelf-json-columns\nissue was model had initialize method\nclass MyModel extends Bookshelf.Model {\n   initialize(attributes, options) {\n       //my staff\n   }\n   static jsonColumns = ['foo', 'bar'];\n}\n\nafter adding Bookshelf.Model.prototype.initialize.apply(this, arguments); in initialize method solved the issue\nclass MyModel extends Bookshelf.Model {\n   initialize(attributes, options) {\n       //after staff\n       Bookshelf.Model.prototype.initialize.apply(this, arguments);\n   }\n   static jsonColumns = ['foo', 'bar'];\n}\n\n. ",
    "andrejkaurin": "No sorry, I tried bookshelf-page also so I copied by mistake wrong error. Same error is on pagination.js file. I updated my question to not refer to the bookshelf page but pagination plugin.\n. Yes, there is a problem.\nI tried it without query(function (qb) {}) , with query() but without callback method, using limit/offset as well as page/pageSize, etc. Nothing seems to work and always the same error.\nqb.countDistinct is defined nowhere in pagination.js so I assume that is part of bookshelf library itself?\n. ",
    "mashaalmemon": "@chamini2 @vellotis  I had the same question myself. It appears that withRelated does seem to work for me. However the method to access of the related information is not clear. I had to google quite a bit to wrap my head around it. I hope this helps:\nAssuming that 'relatedTable' is the model we are joining to:\njs\n   yourModel.fetchAll({withRelated: ['relatedTable']})\nWill work. When promise is resolved you must use the model.related() function on the collection returned. Assuming that the collection returned is stored in yourModels, you could access the related data like so:\njs\n  var relatedTableData = yourModels.related('relatedTable'); \n  // access properties inside relatedTableData as you would any model\nTo read more about model.related follow this link to the bookshelfjs documentation.\n. The closest issue I could find was this old ticket #90. An idea which seems like it'd be useful was put forth, but I don't think it was actioned. Note #90 was closed when the maintainer was changed last year (it seems) and so this older ticket was closed.\nI think we can have multiple/dynamically created knex objects with connections to the appropriate databases. Knex has no limitations this way as I understand it. Instantiate a knex object per database connection.\n@ricardograca Didn't see anything in the knex repo re how to deal with Bookshelf.js and share models across different knex objects.\n@fl0w, That sounds about right. Just not sure how to go about doing that. . The closest issue I could find was this old ticket #90. An idea which seems like it'd be useful was put forth, but I don't think it was actioned. Note #90 was closed when the maintainer was changed last year (it seems) and so this older ticket was closed.\nI think we can have multiple/dynamically created knex objects with connections to the appropriate databases. Knex has no limitations this way as I understand it. Instantiate a knex object per database connection.\n@ricardograca Didn't see anything in the knex repo re how to deal with Bookshelf.js and share models across different knex objects.\n@fl0w, That sounds about right. Just not sure how to go about doing that. . ",
    "yansenarmandau": "Hi @vellotis \nthanks for your response, i just test using lodash times like:\n``` javascript\n_.times(10, function() {\n  // do transaction query\n})\n```\nfor clarification this issue should be solved now by adding .query('forUpdate')\njavascript\nBookshelf.transaction(function (t) {\nreturn Lender.forge({id: lenderId}).fetch({transacting: t}).query('forUpdate').then(function (lender) { \n   var lenderJson = lender.toJSON() \n   var newBalance = parseInt(lender.attributes.balance) - investAmount\n   lenderJson.balance = newBalance\n   return Lender.forge({id: lenderId}).save(lenderJson, {method: 'update', transacting: t}).then(function (lenderUpdated) {\n        return lenderUpdated\n     })\n  })\n})\nSELECT FOR UPDATE is needed if using Serializable Isolation Level => if not wrong\nim using PosgreSQL\nthis issue can be close now.\nsorry for my english\n. ",
    "alexey2baranov": "Thanks for replay\n. ",
    "anandhuajayakumar": "Hi @vellotis \nHow can I rollback the insert query, when there is an error\nI want to rollback all the insert that happened. Hi @vellotis \nHow can I rollback the insert query, when there is an error\nI want to rollback all the insert that happened. @ricardograca, I want to do the whole operation rollback, so how can I do It?. @fl0w In my case I have to do an insert when the update fails. . ",
    "lyfeyaj": "@tgriesser \n@vellotis \nAny advises on it? I need this feature badly.... \ud83d\ude4f \n. @vellotis \nThanks for your reply.\nI just checked PR #1326, and find out that it has not been merged.... , and both the implementation and use case are much complicated.\nAnd this PR does similar things, but with fewer lines of codes, maybe a better alternative to PR #1326\n. @tgriesser @vellotis Can this PR be merged? Or, any more advises?\n. Any updates on this PR? 2 months had been passed since I submitted this PR. And neither this PR or #1326 has any further action....\n. Any updates on this PR? 2 months had been passed since I submitted this PR. And neither this PR or #1326 has any further action....\n. ",
    "jhnferraris": "@vellotis \nI'm sorry I did not follow. Can you give me a code snippet on the correct usage?\n. I see. So I needed to declare this:\n```\nbookshelf.plugin('pagination')\n```\nbefore I'm going to use fetchPage. I'll try this out. Thank you!\nMaybe the author can update the documentation to specify the declaration of the plugin. For the meantime, I'm closing this issue.\n. ",
    "casoetan": "Hi.\nActually that was the error. Fixed with\njs\nlet User = bookshelf.Model.extend({\n  tableName: 'users',\n  hasTimestamps: true,\n  type: function() { return this.belongsTo(UserType, 'type_id') }, // Added the type_id\n}, {\n  findAll: Promise.method(args =>\n    User\n      .forge()\n      .fetchAll({ withRelated: 'type' })\n      .then(users => users.toJSON()))\n)\nThanks.\n. Hi.\nActually that was the error. Fixed with\njs\nlet User = bookshelf.Model.extend({\n  tableName: 'users',\n  hasTimestamps: true,\n  type: function() { return this.belongsTo(UserType, 'type_id') }, // Added the type_id\n}, {\n  findAll: Promise.method(args =>\n    User\n      .forge()\n      .fetchAll({ withRelated: 'type' })\n      .then(users => users.toJSON()))\n)\nThanks.\n. ",
    "diamondarts": "As a fix, I suggest to change line 979 in the code snippet above to\nif (method === 'insert' && this.id == null && this.idAttribute) {\nAs mentioned above, this.idAttribute is an empty string in case of multiple primary keys. So the rest of the code in the if-clause doesn't make sense anyway.\n. As a fix, I suggest to change line 979 in the code snippet above to\nif (method === 'insert' && this.id == null && this.idAttribute) {\nAs mentioned above, this.idAttribute is an empty string in case of multiple primary keys. So the rest of the code in the if-clause doesn't make sense anyway.\n. ",
    "intensite": "I experience a similar issue after upgrading from Bookshelf 9.5 to 14.2  ( big jump I know )\nUnfortunately however I had to rollback to the old version because I keep getting errors while inserting data.  \nIn my case the models have a single primary key.\nAs the original poster, the \n```\nAround line 1131:\nreturn this.triggerThen(\n            method === 'insert' ? 'saving creating' : 'saving updating',\n            this,\n            attributesToSave,\n            options\n          )\n            .bind(this)\n            .then(function() {\n              return syncoptions.method;\n            })\n            .then(function(resp) {\n              // After a successful database save, the id is updated if the model was created\n              if (method === 'insert' && this.id == null) {\n                const updatedCols = {};\n                updatedCols[this.idAttribute] = this.id = resp[0];  <<<--- This line\n                const updatedAttrs = this.parse(updatedCols);     \n````\nThe line updatedCols[this.idAttribute] = this.id = resp[0];\nGenerates an error because resp is undefined\n\nTypeError: Cannot read property '0' of undefined\n    at Child. (/home/sremillard/projects/erp/node_modules/bookshelf/lib/model.js:1131:63)\n    at Child.tryCatcher (/home/sremillard/projects/erp/node_modules/bluebird/js/release/util.js:16:23)\n    at Promise._settlePromiseFromHandler (/home/sremillard/projects/erp/node_modules/bluebird/js/release/promise.js:512:31)\n    at Promise._settlePromise (/home/sremillard/projects/erp/node_modules/bluebird/js/release/promise.js:569:18)\n    at Promise._settlePromise0 (/home/sremillard/projects/erp/node_modules/bluebird/js/release/promise.js:614:10)\n    at Promise._settlePromises (/home/sremillard/projects/erp/node_modules/bluebird/js/release/promise.js:694:18)\n    at _drainQueueStep (/home/sremillard/projects/erp/node_modules/bluebird/js/release/async.js:138:12)\n    at _drainQueue (/home/sremillard/projects/erp/node_modules/bluebird/js/release/async.js:131:9)\n    at Async._drainQueues (/home/sremillard/projects/erp/node_modules/bluebird/js/release/async.js:147:5)\n    at Immediate.Async.drainQueues [as _onImmediate] (/home/sremillard/projects/erp/node_modules/bluebird/js/release/async.js:17:14)\n    at runCallback (timers.js:705:18)\n    at tryOnImmediate (timers.js:676:5)\n    at processImmediate (timers.js:658:5)\n\nThe database is Microsoft SQL Server. ",
    "bartvanremortele": "How can I get the tablename from a model? Its dynamic and we reuse the same crud api logic for models that dont require a specific implementation\n. How can I get the tablename from a model? Its dynamic and we reuse the same crud api logic for models that dont require a specific implementation\n. ",
    "vitorbaptista": "Sorry to bother, as I imagine you all are busy. However, did you have the time to check this issue? If my reasoning is correct, I'm happy to submit a PR to Bookshelf.\n. ",
    "scalhoun": "This actually seems to work fine as well giving me the privacy data:\nconst medium = await Medium.where({ id }).fetchAll({ withRelated: ['privacy'] });\n  res.status(200).json(medium.first());\n. This actually seems to work fine as well giving me the privacy data:\nconst medium = await Medium.where({ id }).fetchAll({ withRelated: ['privacy'] });\n  res.status(200).json(medium.first());\n. For now this is how I'm dealing with the query.  When I named this thread I was pretty burnt out, probably shouldn't have said subquery.\nnew Book().query(qb => {\n    qb.join('credits', 'books.id', '=', 'credits.book_id');\n    qb.where('credits.votes', '>', 2);\n  }).fetchAll({ withRelated: ['chapters', 'credit'] })\n    .then(books => {\n      console.log(books.toJSON());\n    })\n. ",
    "TMcLoone": "+1 I'm having  this issue right now too\n. +1 I'm having  this issue right now too\n. ",
    "ghoover": "@vellotis I am passing in an argument to the constructor.  The ability to pass in custom contexts seems to have screwed that up a bit.  What is the accepted manner of passing arguments to the constructor and using the default context?\n. ",
    "martinmurciego": "The same thing happens to me. Wishing to make a fetchAll () from the model, it turns out that it does not catch me the fetching / fetched event.. In a certain professional context, as in an academic one, it is necessary to implement the audit trails / log generation or simply audit trails. Where it is useful to show the values \u200b\u200bthat have changed in record fields of the database that have been modified. It is usually useful for this purpose to use the database engine triggers with their old and new objects to retrieve previous and current values. Maybe they serve libraries that implement the difference between objects and especially nested-object. The bookshelf feature of showing the previous and current values \u200b\u200bnot of the fields on saving or on saved does not seem to be very useful for this purpose yet.\nI have read that in some cases it was implemented on fields that store JSON. It would be desirable to manage JSON for these fine as for meta-information. Maybe this would avoid having to generate excessive inserts and less overhead. But it would have to be tried and discussed extensively.. Thanks for updat es.. At some point it seems a good idea to generate audit trails / logs: #1535, but do not take that path through models. It has some possible uses as previous validations to save, apply filters in case of retrieving information from a model or generate updates / eliminations in cascade or apply restrictions. But it would be interesting to consider the transaction object in these events.\n```js\nvar Promise = require('bluebird');\nvar bookshelf = require(\"../config/ormConf\");\nvar Menu = module.exports = bookshelf.Model.extend({\n    tableName: 'menues',\n    hasTimestamps: ['created_at', 'updated_at', 'deleted_at'], \n    constructor: function() {\n        bookshelf.Model.apply(this, arguments);\n        this.on(\"fetching\", function(model, attributes, options) {\n            //options.query.where('type', '=', 'menu');\n            console.log('\\nSe intenta consultar informacion de menu...\\n');\n        })\n    this.on(\"fetched\", function(model, attributes, options) {\n        //options.query.where('type', '=', 'menu');\n        console.log('\\nSe consulto informacion de menu exitosamente\\n');\n    })\n    this.on(\"creating\", function(model, attrs, options) {\n        //options.query.where('type', '=', 'book');\n        console.log('\\nSe intenta agregar un nuevo...\\n');\n    });\n    this.on(\"created\", function(model, attrs, options) {\n        //options.query.where('type', '=', 'book');\n        console.log('\\nSe agrego un nuevo menu con exito...\\n');\n    });\n    this.on('updating', function(model, attrs, options) {\n        //options.query.where('type', '=', 'book');\n        console.log('\\nSe modificara informacion de Menu\\n');\n        console.log('Campos a modificar:');\n        console.log(attrs);\n    });\n    this.on(\"updated\", function(model, affectedRows, options) {\n        //options.query.where('type', '=', 'book');\n        console.log('\\nSe modifico informacion de Menu con exito...\\n');\n        console.log('\\nNumero de Filas Afectadas: ', affectedRows);\n        // console.log('\\nAtributos:\\n', model.get('attributes'));\n        console.log('\\nAtributos previos:\\n', this._previousAttributes);\n        console.log('\\nAtributos cambiados:\\n', this.get('changed'));\n    })\n    this.on(\"saving\", function(model, attrs, options) {\n        //options.query.where('type', '=', 'book');\n        if (options.method == 'update') {\n            if (options.patch == true) {\n                console.log('\\nSe intenta actualizar solo algunos campos...\\n');\n            } else {\n                console.log('\\nSe intenta actualizar todos los campos...\\n');\n            }\n        } else {\n            console.log('\\nSe intenta agregar...\\n');\n            //VALIDACION DE USUARIO A REGISTRAR\n            return Menu.validar(this);\n        }\n    });\n\n    this.on(\"saved\", function(model, resp, options) {\n        //options.query.where('type', '=', 'book');\n        if (options.method == 'update') {\n            if (options.patch == true) {\n                console.log('\\nSe actualizaron solo algunos campos...\\n');\n            } else {\n                console.log('\\nSe actualizaron todos los campos...\\n');\n            }\n        } else {\n            console.log('\\nSe intenta agregar...\\n');\n            //VALIDACION DE USUARIO A REGISTRAR\n            return Menu.validar(this);\n        }\n        if (options.transacting) {\n            console.log('\\nOperacion dentro de una transaccion ...\\n');\n        }\n        console.log('\\nRespuesta de la base de datos: ', resp, '\\n');\n    });\n    this.on('destroying', function (model, attrs, options) {\n      //options.query.where('type', '=', 'book');\n      console.log('se elimino registro de un menu...');\n    });\n    this.on('destroyed', function (model, attrs, options) {\n      //options.query.where('type', '=', 'book');\n      //Auditar \"Hard\" DELETE en Model\n      console.log('se elimino registro de un menu...');\n    });\n\n},\n{\n    orderBy: function(column, order){ \n        return this.query(function(qb){\n            return qb.orderBy(column, order);\n        });\n}\n\n});\n```. Yes, it is only implemented for collections and not for models. \nI have not honestly used collections to suggest anything.. Only in this way did the fetched event fire (using collections):\n/collections/users.js:\n```js\nvar bookshelf = require(\"../config/ormConf\"); \nvar userModel = require(\"../models/users\"); \nvar users = module.exports = bookshelf.Collection.extend({ \n  model: userModel,\n  constructor: function() {\n    bookshelf.Collection.apply(this, arguments);\n    this.on(\"fetching\", function(collection, attributes, options) {\n      console.log('\\nIt tries to consult information of several users...\\nColumns: ' +\n                  JSON.stringify(attributes) + '\\n');\n    })\n    this.on('fetched', function(collection, reponse, options) {\n      console.log('\\n\\nInformation is consulted from several users with success. It tries ' +\n                  'to consult information of several users!!!\\n' + JSON.stringify(reponse) +\n                  '\\n');\n    })\n  }\n});\n```\n/controllers/users.js:\n```js\nvar bookshelf = require(\"../config/ormConf\");\nvar userModel = require(\"../models/users\"); \nvar userCollection = require(\"../collections/users\"); \nmodule.exports = {\n  list: function list(req, res) {\n    var qb = userCollection.query();\n    return usuarioCollection\n      .query(function(qb) {})\n      .fetch({require: true})\n      .then(function(results) {\n        // return usuarioModel.orderBy('id', 'ASC').fetchAll().then(function(results) {\n        res.status(200).json(results);\n      }).catch(function(err) {\n        res.status(400).json(err);\n      });\n  }\n}\n``. I do not know what can cause an infinite loop or something like that. The only thing that I have implemented is events in the model for creating, creating, fetching, fetched, saving and saved that perform logging at the moment. I am still studying its behavior because I thought to register audit trails / logs of operations at the model level. Because they ask me for some record of audit trails at least in important entities of the system. I work with Postgres and node v6. I was generating messages: Warning: Possible EventEmitter memory leak detected. 11 fetching listeners added. Use emitter.setMaxListeners () to increase limit. What I did was add the line to my app.js:require('events').EventEmitter.prototype._maxListeners = 100;`\nBut I can not save save with model.forge () one by one iterating.. ",
    "sorokinsh": "It would be great to check if isAttribute is an array and do something like:\njs\nidAttribute: ['keyOne', 'keyTwo'];\nsql\nselect count(distinct(`keyOne`, `keyTwo`)) from `table`;\nIt would be very helpful to use it instead of raw queries. Thank you.\n. ",
    "nicogreenarry": "Ah, got it. Thanks.\n. ",
    "vanesyan": "Node.js community is strongly encourage people to actively drop support for both 0.10 and 0.12 and update at least to v4. Dropping the 0.xx version also makes it easier to develop the bookshelf + reduce workarounds to make code runnable on that platform versions. Maintance of v0.10 of Node.js will be dropped on October, means that no new projects will be started on the version as well as on v0.12 witch will be dropped at the end of December. My suggestion is to support the next version of bookshelf only on v4+, but making the 0.10.x the last version of bookshelf that supports Node.js v0.xx\n. ",
    "gabrielecirulli": "Thanks for your response.\nAs far as I can understand from what you explained, it seems that you exclude JSON fields as a safe measure because they won't really work in a query.\nI think that any time this safeguard will kick in, it will lead to unintended consequences for the application, such as the one I've shown above. Due to the loosely-typed nature of JavaScript, it may be very hard for a developer to cover all possible places where this could happen.\nSo, if you're willing to have a discussion about this, I would propose two alternatives that I think might lead to a better (and possibly safer) experience for developers:\n- Adding a configuration option to Bookshelf itself which will make it throw any time it encounters an unexpected JSON field in a query;\n- Making Bookshelf throw by default (obviously a breaking change, so maybe not as straightforward).\nWhat do you think?\n. Seeing as there's no surface for global configuration in Bookshelf right now, maybe a property to be altered via Model.extend(...) may be more suitable.\n. ",
    "engineerVIP": "JS is a weak type of language ah, this phenomenon is very normal\n. JS is a weak type of language ah, this phenomenon is very normal\n. ",
    "lvffilho": "And how about inserting a Page with and existint book only with json?\nPage.create({content: 'test', book: {id: 27, name: 'book'}}).then();\n. Only works with id? Relation is only for query then?\nI thought it was like hibernate.... have reference of object not id.\nbut ok... tnx\n. ",
    "OlivierCoilland": "An as-good-a-night-with-2-young-kids-can-be later I guess it \"works as intended\".\nMy association is about books, so I get my books back deduplicated and the pivot table data is irrelevant.\nBut I still find this counterintuitive. I might have spent too much time with Laravel and Eloquent.\n. ",
    "chiangf": "@vellotis: Sure! Let's say that my table looks like this\nBar:\n- id: Just a simple ID\n- foo_id: FK to Foo table\nSo, it could look something like this:\n| id | foo_id |\n| --- | --- |\n| 1 | 123 |\n| 2 | 234 |\n| 3 | NULL |\nThe first 2 rows have an related Foo table but id=3 does not.\nWhen I try doing Bar.where({ id: 3 }).fetch({ withRelated: ['foo'] }), I'm noticing that it's doing a DB query looking for Bar with id=3, which is expected. However, I'm also seeing a separate DB query looking for Foo with id=null.\nSo I was wondering if there was a way to avoid fetching the related foo field if it's NULL and thus has no relations?\n. @tgriesser Just tried it, I still see a db hit\n{\n  method: 'select',\n  options: {},\n  timeout: false,\n  cancelOnTimeout: false,\n  bindings: [ null ],\n  __knexQueryUid: '28ebda03-8933-4911-b1ce-5ce02ee05c91',\n  sql: 'select foo.* from foo where foo.id is not null and foo.id in (?)'\n}\nSo, I'm assuming that it will still be calling the db but returning 0 rows (since it'll fail on foo.id is not null)\n. ",
    "levity": "I guess it's safe to assume this isn't possible?. ",
    "MarkHerhold": "@vellotis could you merge this in when you get a chance?\n. I think I just asked a somewhat similar question over in the knex repo too where subqueries are my stumbling block. Hope you get this figured out. :+1: \n. I'm dumb.\njs\ntypeof model.toJSON() // 'object'\n. @ricardogama I had not seen this! I'll switch to using master directly if it's in a usable state.\nI gave your PR a read (great job BTW :+1:) and I think I would use hasMany(Target, foreignKey, foreignKeyTarget), is this correct?\nSo for example:\n``` js\nlet Bowls = bookshelf.Model.extend({\n  tableName: 'bowls',\n  plates: function() {\n    return this.hasMany(Plates, 'color', 'color');\n  }\n});\nlet Plates = bookshelf.Model.extend({\n  tableName: 'plates',\n  bowls: function() {\n    return this.hasMany(Bowls, 'color', 'color');\n  }\n});\nBowls.where({id: 1}).fetch({withRelated: ['plates']}).then(function(bowls) {\n  // should produce ...\n});\n```\nThanks @ricardogama !\n. @ricardogama Finally tried it out by npm installing master. It works amazingly well! Great work and thank you!\n. @ErisDS Have you been able to contact @tgriesser to get publish rights?. Ping @kirrg001 . Ping @kirrg001 . @kirrg001 I think the PR is actually fine because the only change is an addition of v7. As in the comment, I didn't actually remove 0.10 or 0.12.\nAt any rate, can you just add v7 to travis and I can close this PR?. @kirrg001 I think the PR is actually fine because the only change is an addition of v7. As in the comment, I didn't actually remove 0.10 or 0.12.\nAt any rate, can you just add v7 to travis and I can close this PR?. ",
    "nimsathi": "User error - it should have been {transacting: t} instead of {transaction: t}.\nIt works perfectly as designed.\n. ",
    "miketerpak": "In the meantime I am dealing with the relation being undefined instead of null, but optimally I want to be able to show that the field is there and is not set in the payload.\n. ",
    "p4bloch": "@MarkHerhold I also struggled with this one. It is not as clear in the docs since JSON.stringify is referenced and for me it looked like .toJSON would do the same. Thanks for filing this issue :). @MarkHerhold I also struggled with this one. It is not as clear in the docs since JSON.stringify is referenced and for me it looked like .toJSON would do the same. Thanks for filing this issue :). ",
    "GabrielNicolasAvellaneda": "Clearly the API is wrong, JSON means Javascript Object Notation which is a serialized representation of a Javascript Object, in other words a string. There should be a model.toObj() and model.toJSON() should produce a string.. ",
    "gabmontes": "@vellotis thanks for the answer. Do you agree this should be stated in the docs? I can send a PR. \n. ",
    "msmichellegar": "Managed to find a solution here: https://joepettit.com/bookshelf-js/\njs\nnew Model({name: 'foo'}).fetch().then(function(instance) {\n    Model.forge().where({id: instance.id}).destroy().then(function() {\n        // etc\n    });\n});\n. Managed to find a solution here: https://joepettit.com/bookshelf-js/\njs\nnew Model({name: 'foo'}).fetch().then(function(instance) {\n    Model.forge().where({id: instance.id}).destroy().then(function() {\n        // etc\n    });\n});\n. ",
    "tmorehouse": "in my case, the generated columns are actually JSON data extracts, to allow for indexing based on a value inside a JSON field.\nGenerated columns can be either STORED (actual value is stored in DB) or VIRTUAL (materialized when the row is read).  Indexing is supported on either type.\n. Thanks!  This would be something that I think should be part of Booksehelf, or available as an official plugin.\n. ",
    "jonstuebe": "issue is coming from knex\n. issue is coming from knex\n. ",
    "pruhstal": "@tgriesser Any thoughts on how to improve my current method of doing this (listed at the bottom of this post)?\n. @kirrg001 Wow that looks very nice! \nOnly thing is, I'm having a hard time trying to modify it for my needs. \nHere is what I'm doing (and btw, I'm loading this with bookshelf.plugins on both my BookReview.js model and my Book.js model. \nDoes it also need to be loaded on the User model?\n```\nvar _ = require('lodash');\nmodule.exports = function (Bookshelf) {\n  var modelProto = Bookshelf.Model.prototype,\n    Model,\n    countQueryBuilder;\ncountQueryBuilder = {\n    books: {\n      book_reviews: function addPostCountToTags(model) {\n        model.query('columns', 'books.*', function (qb) {\n          qb.count('book_reviews.id')\n            .from('book_reviews')\n            .leftOuterJoin('book_reviews', 'book_reviews.id', 'book_reviews.book_id')\n            .whereRaw('book_reviews.book_id = books.id')\n            .as('count__book_reviews');\n      // if (model.isPublicContext()) {\n      //   // @TODO use the filter behavior for posts\n      //   qb.andWhere('book_reviews.page', '=', false);\n      //   qb.andWhere('book_reviews.status', '=', 'published');\n      // }\n    });\n  }\n},\nusers: {\n  book_reviews: function addPostCountToTags(model) {\n    model.query('columns', 'users.*', function (qb) {\n      qb.count('book_reviews.id')\n        .from('book_reviews')\n        .whereRaw('book_reviews.user_id = users.id')\n        .as('count__book_reviews');\n\n      // if (model.isPublicContext()) {\n      //   // @TODO use the filter behavior for posts\n      //   qb.andWhere('posts.page', '=', false);\n      //   qb.andWhere('posts.status', '=', 'published');\n      // }\n    });\n  }\n}\n\n};\nModel = Bookshelf.Model.extend({\n    addCounts: function (options) {\n      if (!options) {\n        return;\n      }\n  var tableName = _.result(this, 'tableName');\n\n  if (options.include && options.include.indexOf('count.book_reviews') > -1) {\n    // remove post_count from withRelated and include\n    options.withRelated = _.pull([].concat(options.withRelated), 'count.book_reviews');\n\n    // Call the query builder\n    countQueryBuilder[tableName].book_reviews(this);\n  }\n},\nfetch: function () {\n  this.addCounts.apply(this, arguments);\n\n  if (this.debug) {\n    console.log('QUERY', this.query().toQuery());\n  }\n\n  // Call parent fetch\n  return modelProto.fetch.apply(this, arguments);\n},\nfetchAll: function () {\n  this.addCounts.apply(this, arguments);\n\n  if (this.debug) {\n    console.log('QUERY', this.query().toQuery());\n  }\n\n  // Call parent fetchAll\n  return modelProto.fetchAll.apply(this, arguments);\n},\n\nfinalize: function (attrs) {\n  var countRegex = /^(count)(__)(.*)$/;\n  _.forOwn(attrs, function (value, key) {\n    var match = key.match(countRegex);\n    if (match) {\n      attrs[match[1]] = attrs[match[1]] || {};\n      attrs[match[1]][match[3]] = value;\n      delete attrs[key];\n    }\n  });\n\n  return attrs;\n}\n\n});\nBookshelf.Model = Model;\n};\n```\nAlso, would it matter that my query to fetch the reviews initially fetches the users by withRelated?\nreturn new Reviews()\n    .query(function(qb) {\n      qb.where(where);\n      if (limit) {\n        qb.limit(limit);\n      }\n    })\n    .orderBy('created_at', 'DESC')\n    .fetch({\n      withRelated: [{'user': function(qb) {\n        qb.column('id', 'username', 'photo');\n      }}],\n      include: 'count.book_reviews'\n    })\n    .then(function(collection) {\n      console.log(collection);\n      return collection.toJSON();\n    });\n. ",
    "Natanael1234": "Thanks for reply! \nI'm using the where method. But the problem with the where method is that it don't trigger the on fetching event.\nI always need to make som validations on the criteria before to excecute the query.\n. Vellotis, thanks for reply. \nI need to test a parameter of the query right before to execute it. If the parameter is wrong the query must not be executed. Once the parameter is tested and approved I must to execute a query filtered according this parameter. \n. ",
    "juliogc": "Same here! Any solution to work with this?. Same here! Any solution to work with this?. ",
    "guzuomuse": "+1. ",
    "bimohxh": "I found this too,and the callback in destroyed params model is null. so, what is the solution? is a new version to upgrade?. so, what is the solution? is a new version to upgrade?. ",
    "carldanley": "I'm also getting the same thing... Does anyone know which dependencies don't break things so I can at least have something working while I develop (until this gets fixed) ? ie - what release broke this?\n. Nevermind, running npm install lodash@4.15.0 fixed it for me.\n. ",
    "andremsantos": "I didn't get it to work on my end. I'm using lodash@4.15.0 as @carldanley indicated.\nmy pagination object is returning:\npagination: { page: 1, pageSize: 100, pageCount: NaN }\npageCount: NaN and I don't have a rowCount...\nAny suggestions?. \"bookshelf\": \"^0.14.2\"\n\"knex\": \"^0.16.3\"\n\"lodash\": \"^4.15.0\" as per @carldanley  suggests\nI was previously using and had the same issue:\n\"bookshelf\": \"^0.10.3\",\n\"knex\": \"^0.13.0\",\n\"lodash\": \"^4.17.4\",\nafter updating the packages the issue still persists \nIf you need more info please let me know\n. @ricardograca \n\nIf you could get a reproducible test case that would help a lot. Here's an example: https://gist.github.com/ricardograca/da68dc091fcbe15c395558c166fd7200\n\nI made the file as you suggested. It's working. I didn't use mysql as I use in my project. Gonna change the example file to use de same database of my project and see what happens. Brb with info.. @ricardograca it worked well... as expected. Any suggestions on how I could debug on my project?. Ok I found my issue... I was using parse in my model to format the createdAt field. And then returning the response.\nHow could I use parse with fetchPage?. let inventories = await new Inventory().orderBy('id', 'DESC').fetchPage({\n        pageSize: size,\n        page: number\n      }). I was doing something like this:\nparse: function(response) {\n    if (response.createdAt) {\n      response.createdAt = moment(response.createdAt).fromNow()\n    }\n    return response\n  },\nIt seems to be ok now...strange... I must have some kind of bug in the parse method\nThanks for the help and sorry for the false alarm. ",
    "oscaroox": "@VisheshVadhera The fetchAll function fires the \"fetching:collection\" and \"fetched:collection\" events\nhttp://bookshelfjs.org/#Model-instance-fetchAll\nThe fetchPage is a wrapper around the fetchAll funcion so it also fires the same events.. @kai23 just a wild guess, but i think you need to also select the id in the table moderation\nquery.select('id', 'comment', 'created-at'). @kai23 after looking at your models i've noticed that a File can have many moderations, meaning that you\nwould have to select the foreign key of the file with the comment and created_at.\nIt should work if you also select the foreign key\nquery.select('comment', 'created_at', 'file_id'). @kai23 because a moderation belongsTo a File through the foreign key column file_id.\nSince your not selecting the foreign key file_id that points to the file you're selecting it will just return nothing.\nExcuse my english.. @kai23 did you try that sql statement?\ni dont think it would work, but i havent written sql in awhile. @kai23 bookshelf uses knex beneath so im not sure how knex builds op queries,\nBut good to hear that this issue is solved. @nitish24p  bookshelfjs doesn't use joins when using withRelated function, you could write the join queries yourself using the knex quiry builder\nModel.query (qb => {\n   qb.join (...)\n});. ",
    "VisheshVadhera": "@oscaroox Thanks!. ",
    "RobertHerhold": "Ping @kirrg001 . Ping @kirrg001 . ",
    "salarAsadi": "How do you do an increment on a field of question model?\nthis is the knex example, I want to do it using bookshelf\nknex('accounts').where('userid', '=', 1).decrement('balance', 5). How do you do an increment on a field of question model?\nthis is the knex example, I want to do it using bookshelf\nknex('accounts').where('userid', '=', 1).decrement('balance', 5). ",
    "Xylem": "The workaround for this, until it gets fixed, is to use\ncollection.fetchPage([{\n    page: ctx.query.page,\n    pageSize: ctx.query.pageSize\n}])\ninstead of\ncollection.fetchPage({\n    page: ctx.query.page,\n    pageSize: ctx.query.pageSize\n}). ",
    "tslater": "Is there any way we could get this merged?. ",
    "mdhornet90": "@JC3 I know this is closed, but another option is to use collection.slice() with no parameters, which returns a shallow copy of the underlying model array that backs the collection.. Removing that library unfortunately did not resolve the issue.\nThis is the data being passed in the attach statement as I have it above:\nuserId = 0212350e-bc54-40a6-bf90-5f892b78a296\ntagIds = [17dc3887-90c3-407f-ba44-7c1c9e57f2fe]\nHere's the error, which contains the bindings that are ultimately being passed to the users_tags:\ndb_1   | 2018-06-29 17:14:48.477 UTC [64] ERROR:  null value in column \"id\" violates not-null constraint\ndb_1   | 2018-06-29 17:14:48.477 UTC [64] DETAIL:  Failing row contains (null, 0212350e-bc54-40a6-bf90-5f892b78a296, 17dc3887-90c3-407f-ba44-7c1c9e57f2fe, 2018-06-29 17:14:48.476935+00, 2018-06-29 17:14:48.476935+00).\ndb_1   | 2018-06-29 17:14:48.477 UTC [64] STATEMENT:  insert into \"users_tags\" (\"userId\", \"tagId\") values ($1, $2)\nLet me know if you need anything else.. I'll also try to come up with a minimum repro sample over the weekend.. I finally have an update (life happens) and some good news: under the right conditions I can make this problem go away and attach works exactly as I was hoping it would.\nThe root cause of the bad behavior I was seeing was indeed due to the use of uuid's broadly across all models. They don't seem to be auto-created during attach even when the BookshelfUuid library is used, so unless that join table has an \"increments\" primary key type, this won't work out of the box.\nHowever! Using the insight provided by @rluba in this response, I was able to construct an object to send to attach that includes a dynamically generated uuid as well as the extra pivot fields I wanted to include (which solves another issue I was getting ready to tackle).\nI still have to evaluate whether I want to use auto-incrementing or a uuid for these join tables, but being able to construct an arbitrary object to send in attach is an excellent feature and deserves documentation (the docs make it seem like it would only accept ids or actual model objects).. I finally have an update (life happens) and some good news: under the right conditions I can make this problem go away and attach works exactly as I was hoping it would.\nThe root cause of the bad behavior I was seeing was indeed due to the use of uuid's broadly across all models. They don't seem to be auto-created during attach even when the BookshelfUuid library is used, so unless that join table has an \"increments\" primary key type, this won't work out of the box.\nHowever! Using the insight provided by @rluba in this response, I was able to construct an object to send to attach that includes a dynamically generated uuid as well as the extra pivot fields I wanted to include (which solves another issue I was getting ready to tackle).\nI still have to evaluate whether I want to use auto-incrementing or a uuid for these join tables, but being able to construct an arbitrary object to send in attach is an excellent feature and deserves documentation (the docs make it seem like it would only accept ids or actual model objects).. Terrific, I have a workaround in place in our code for now, but when I have an opportunity I'll point to master and see if it's resolved.. ",
    "jbrumwell": "This isn't an issue with bookshelf itself, but I can help you over on mock-knex :). This isn't an issue with bookshelf itself, but I can help you over on mock-knex :). ",
    "mattiloh": "You can customize the JSON-output of a model by overriding its serialize method.. You can customize the JSON-output of a model by overriding its serialize method.. ",
    "drazafsky": "I'm having the same problem. Did you ever find a solution?. I'm having the same problem. Did you ever find a solution?. ",
    "firdausramlan": "Any way to use count instead of countDistinct? Maybe make it configurable?. ",
    "danielplascenciattr": "any solution now???\n@tgriesser , @chenghung , @amk221 . any solution now???\n@tgriesser , @chenghung , @amk221 . Thank you very much @ricardograca I've never guess that xD but you are right that must be better documented.\nEven though, I think that it would work because I was checking a little bit and the records are actually fetched from the database but in some point (in bookshelf) those records are dropped.. Thank you very much @ricardograca I've never guess that xD but you are right that must be better documented.\nEven though, I think that it would work because I was checking a little bit and the records are actually fetched from the database but in some point (in bookshelf) those records are dropped.. ",
    "LuisBonsembiante": "https://github.com/bookshelf/bookshelf/pull/1827. @ricardograca thank for your response, the problem is when the ORM refered to a table partitioning, in first instance the partitioning not support that because restrict the foreign keys, and somithing similar happen with the primary key... if a create a new register of this table I dont have the primary key.\nFor example if a do something like that where('username', username).fetch({withRelated: 'xxx'})\nThanks. @ricardograca thank for your response, the problem is when the ORM refered to a table partitioning, in first instance the partitioning not support that because restrict the foreign keys, and somithing similar happen with the primary key... if a create a new register of this table I dont have the primary key.\nFor example if a do something like that where('username', username).fetch({withRelated: 'xxx'})\nThanks. Hi guys, sorry for the delay im very busy this weeks....As I said, the solution work for my project very well...@ricardograca you need something  at this point of me? @fl0w please tell mw if you need something else..regards. what kind of test?...because you need a database to probe this. ",
    "sombriks": "Hi @absolux !\nThank you for the answer, however i have a composite key and i don't know how to set it on bookshelf... any guidance?. Hi @absolux !\nThank you for the answer, however i have a composite key and i don't know how to set it on bookshelf... any guidance?. Hi @absolux thanks for the response!\nAs soon as possible i'll experiment with the idAttribute. \nI just modified the code to use knex directly in those specific save, however as soon as i come back to this point in the code i'll test this way you found. Thank you so much. . Hi @absolux thanks for the response!\nAs soon as possible i'll experiment with the idAttribute. \nI just modified the code to use knex directly in those specific save, however as soon as i come back to this point in the code i'll test this way you found. Thank you so much. . @ricardogama the editor gave me this hint. but now i am not sure if it's real. \n\n. @ricardograca hahaha, my bad.\nand about the deprecation, you are right, https://github.com/bookshelf/bookshelf/blob/master/src/base/model.js#L620\nthis is visual studio code lying to me.. ",
    "kai23": "Hi, sadly, I get the same \"error\" : nothing is showing up in the moderation key. Oh. It works. \nBut why ? Is it because it's not an innerJoin done inside ?\nEdit: thanks !. @oscaroox I get it, but I thought I could do something like\nsql\nSELECT \"moderation\".\"comment\", \"moderation\".\"created_at\", \"file.*\" FROM file f\nINNER JOIN moderation m ON m.file = f.id\nORDER BY m.created_at DESC\nAnd that, somehow, almost magically, I would have a \njson\n{\n  \"id\":\"123\",\n  [...]\n  \"moderation\": {\n    \"comment\": \"Hello\",\n    \"created_at\": \"2017-01-01 14:34:22\"\n  }\nDon't you think it's possible ? . @oscaroox This one works (tested now)\nsql\nSELECT \"moderation\".\"comment\", \"moderation\".\"created_at\", f.* FROM file f\nINNER JOIN moderation \"moderation\" ON \"moderation\".\"file\" = f.id\nORDER BY \"moderation\".\"created_at\" DESC\nI could call my aliases the way I want, but it's to show how I imagine the final request.. Yes thanks for the hint. I'll close now.. ",
    "s-lyn": "I found the solution:\n```javascript\nfunction increaseCounter() {\n  bookshelf.transaction(function (trx) {\nreturn Demo.forge().set('id', 1).once('fetching', function(model, columns, options) {\n  options.query.forUpdate(); // (!!) Solution here\n}).fetch({transacting: trx}).then(function (model) {\n  var counter = model.get('counter');\n\n  // (!!!) Update counter after 500 ms\n  return Promise.delay(500).then(function () {\n    var newCounterValue = counter + 1;\n    console.log('Previous value:', counter);\n    console.log('New value:', newCounterValue);\n    return model.set({counter: newCounterValue}).save(null, {transacting: trx});\n  });\n});\n\n});\n}\n```. ",
    "dwoowb": "@absolux could you clarify your comment with an example? Not sure how replacing hasMany->through with belongsToMany for example here:\nlanguages() {\n      return this\n        .hasMany('Language', 'id')\n        .through('UserLanguage', 'id', 'never_being_used');\n    }\nwould allow me to get this relation: User.related('languages')?. ",
    "toiye": "If you want to skip importing bluebird, you could also do this to make your calls sequentially: \nreturn array.reduce((promise, item) => {\n    return promise\n    .then((result) => {\n        return somePromiseFunction(item)\n    })\n}, Promise.resolve()). ",
    "wenderjean": "Thank you guys for the answer, apparently It solved my problem.. ",
    "NPCRUS": "Lambda is pretty bad at showing errors. Also, lambda doesn't handle and save any console.* functions\nSo, this is my approach to debug lambda.\nHope it should help\n```\nmodule.exports.hanlder = (event, context, callback) => {\n    try {\n    //do something\n\n    somePromise()\n        .then(res => {\n            //do something\n        })\n        .catch(err => {\n            callback(null, {\n                body: err.message,\n                statusCode: 500,\n                headers: {\n                    'Access-Control-Allow-Origin': '*',  \n                    'Access-Control-Allow-Credentials': true,\n                    'Content-Type': 'text/plain'\n                }\n            })\n        })\n\n} catch(ex) {\n    callback(null, {\n        body: ex.message,\n        statusCode: 500,\n        headers: {\n            'Access-Control-Allow-Origin': '*',  \n            'Access-Control-Allow-Credentials': true,\n            'Content-Type': 'text/plain'\n        }\n    })\n}\n\n}\n```. ",
    "jferrettiboke": "Almost all the code that I read on the documentation is related with the API. IMHO, I think is better to have two kind of docs. An API documentation (like now) and a more easy-readable documentation to expose examples (by categories: migrations, relationships...) using Bookshelf. I mean something like Laravel docs and Laravel API docs.. Almost all the code that I read on the documentation is related with the API. IMHO, I think is better to have two kind of docs. An API documentation (like now) and a more easy-readable documentation to expose examples (by categories: migrations, relationships...) using Bookshelf. I mean something like Laravel docs and Laravel API docs.. ",
    "Dannymatos73": "yes please\nOn Feb 2, 2017 8:03 PM, \"Eries Trisnadi\" notifications@github.com wrote:\n\nI want to get the next data and parse it to an existing object, I do\nsomething like these\nIndexController.route('/posts/:slug')\n.get(function(req, res, next) {\n  var slug = req.params.slug\n  Post\n  .where({slug: slug}).fetch({withRelated: ['user'], require: true})\n  .then(function(post){\n    var nextPost = Post.findById(post.id + 1).then(function(res) {\n      return res.toJSON()\n    }).catch(function() {\n      return false\n    }),\n        pages = {\n          url: req.baseUrl + '/',\n          next: nextPost\n        }\n    console.log(nextPost)\n    res.render('posts/single', {user: req.user, post: post.toJSON(), pages: pages, message: req.flash('info')})\n  })\n  .catch(function(err) {\n    next()\n  })\n})\nNo errors show up, but when I look up to the console.log(nextPost), it\nwas not the data that I wanted. I just get these\nzdumb@labsx:~/git/soraio$ node app\nKnex:warning - sqlite does not support inserting default values. Set the useNullAsDefault flag to hide this warning. (see docs http://knexjs.org/#Builder-insert).\nPromise {\n  _bitField: 2097152,\n  _fulfillmentHandler0: undefined,\n  _rejectionHandler0: undefined,\n  _promise0: undefined,\n  _receiver0: undefined,\n  _boundTo:\n   constructor {\n     attributes: { id: 5 },\n     _previousAttributes: {},\n     changed: { id: 5 },\n     relations: {},\n     cid: 'c4',\n     id: 5,\n     _knex: null } }\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1510, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AYUM0KVqOjcDOqy9G4A_0Q0LDAw-QQQrks5rYqb-gaJpZM4L18GW\n.\n. yes please\n\nOn Feb 2, 2017 8:03 PM, \"Eries Trisnadi\" notifications@github.com wrote:\n\nI want to get the next data and parse it to an existing object, I do\nsomething like these\nIndexController.route('/posts/:slug')\n.get(function(req, res, next) {\n  var slug = req.params.slug\n  Post\n  .where({slug: slug}).fetch({withRelated: ['user'], require: true})\n  .then(function(post){\n    var nextPost = Post.findById(post.id + 1).then(function(res) {\n      return res.toJSON()\n    }).catch(function() {\n      return false\n    }),\n        pages = {\n          url: req.baseUrl + '/',\n          next: nextPost\n        }\n    console.log(nextPost)\n    res.render('posts/single', {user: req.user, post: post.toJSON(), pages: pages, message: req.flash('info')})\n  })\n  .catch(function(err) {\n    next()\n  })\n})\nNo errors show up, but when I look up to the console.log(nextPost), it\nwas not the data that I wanted. I just get these\nzdumb@labsx:~/git/soraio$ node app\nKnex:warning - sqlite does not support inserting default values. Set the useNullAsDefault flag to hide this warning. (see docs http://knexjs.org/#Builder-insert).\nPromise {\n  _bitField: 2097152,\n  _fulfillmentHandler0: undefined,\n  _rejectionHandler0: undefined,\n  _promise0: undefined,\n  _receiver0: undefined,\n  _boundTo:\n   constructor {\n     attributes: { id: 5 },\n     _previousAttributes: {},\n     changed: { id: 5 },\n     relations: {},\n     cid: 'c4',\n     id: 5,\n     _knex: null } }\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1510, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AYUM0KVqOjcDOqy9G4A_0Q0LDAw-QQQrks5rYqb-gaJpZM4L18GW\n.\n. please explain what you would like from me\n\nOn Feb 3, 2017 10:33 PM, \"Amila Welihinda\" notifications@github.com wrote:\n\nDoes this library support sharing a sqlite database across multiple node\nprocesses?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1512, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AYUM0LpbgK3fmm5geYcM5Ev2O4eHwjOaks5rZBvAgaJpZM4L3D7_\n.\n. please explain what you would like from me\n\nOn Feb 3, 2017 10:33 PM, \"Amila Welihinda\" notifications@github.com wrote:\n\nDoes this library support sharing a sqlite database across multiple node\nprocesses?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/tgriesser/bookshelf/issues/1512, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AYUM0LpbgK3fmm5geYcM5Ev2O4eHwjOaks5rZBvAgaJpZM4L3D7_\n.\n. \n",
    "lowsprofile": "I end up to do this after do some test.\nIf anyone could do better than I, please reopen this issue :)\n```javascript\n/*\n  * GET /posts/:slug rules.\n  * @param pid {post_slug}.\n  /\nIndexController.route('/posts/:slug')\n.get(function(req, res, next) {\n  var slug = req.params.slug\n  Post\n  .fetchAll({withRelated: ['user', 'project']})\n  .then(function(posts) {\n    var post = false, pages\n    posts = posts.toJSON()\n    for (var i = 0; i < posts.length; i++) {\n      if (posts[i].slug === slug && posts[i].publish){\n            post = posts[i]\n            pages = {\n              uri: req.baseUrl,\n              next: posts[i+1] ? posts[i+1].slug : false,\n              prev: posts[i-1] ? posts[i-1].slug : false\n            }\n      }\n    }\n    if(!post){\n      var err = new Error('Not Found')\n      err.status = 404\n      throw err\n    }\n    res.render('posts/single', {user: req.user, post: post, pages: pages, message: req.flash('info')})\n  })\n  .catch(function(err) {\n    next(err)\n  })\n})\n```. I end up to do this after do some test.\nIf anyone could do better than I, please reopen this issue :)\n```javascript\n/*\n  * GET /posts/:slug rules.\n  * @param pid {post_slug}.\n  /\nIndexController.route('/posts/:slug')\n.get(function(req, res, next) {\n  var slug = req.params.slug\n  Post\n  .fetchAll({withRelated: ['user', 'project']})\n  .then(function(posts) {\n    var post = false, pages\n    posts = posts.toJSON()\n    for (var i = 0; i < posts.length; i++) {\n      if (posts[i].slug === slug && posts[i].publish){\n            post = posts[i]\n            pages = {\n              uri: req.baseUrl,\n              next: posts[i+1] ? posts[i+1].slug : false,\n              prev: posts[i-1] ? posts[i-1].slug : false\n            }\n      }\n    }\n    if(!post){\n      var err = new Error('Not Found')\n      err.status = 404\n      throw err\n    }\n    res.render('posts/single', {user: req.user, post: post, pages: pages, message: req.flash('info')})\n  })\n  .catch(function(err) {\n    next(err)\n  })\n})\n```. ",
    "zamiang": "Starting a new project and was considering using this but due to lack of activity, elected to go with Objection.js. Extremely happy with it vs the other contender (sequelize). Objection is, like bookshelf, built on Knex. It has an active gitter and works very well with typescript.. ",
    "pradeeptimeinc": "@absolux so no matter what i specify in .returning('id') it will always return insertId ?? So  even if  i write .returning('rollNo') it is returning me insertId only \n. @absolux so no matter what i specify in .returning('id') it will always return insertId ?? So  even if  i write .returning('rollNo') it is returning me insertId only \n. ",
    "jesobreira": "\nWhy is insertId not on the docs? Is this going to be removed?. \nWhy is insertId not on the docs? Is this going to be removed?. ",
    "joselcvarela": "I am passing by this struggle too.\nIn my case I am expecting to see default values applied on model after create method on collection.\nFor example, I have a table named users which have various columns including name and additionalInfo. The latest is a jsonb column and defaults to '{ website: '' }'\nWhen I call\nconst user = Users.create({ name })\nthe variable user doesn't have the additionalInfo field\nI am using Postgres 11.1\n@ricardograca can you help?. ",
    "callmez": "1816 . #1816 . +1 . +1 . not work for for...in\njavascript\nlet dataRows = await MyTable.where({someValue: 7}).fetchAll();\nfor (let key in dataRows) {\n   // ouput 'model'\n}. ",
    "rbong": "Merged in - can't explain why one of the tests is failing yet, working on getting it passing again.. Had to make some changes to the recent test alterations.\nInstead of using orderBy('id', 'ASC'), had to change it to orderBy('table.id', 'ASC'), because for some reason oracle specifically considers 'id' to be ambiguous. This same thing is done in Knex tests.. Also fixed on #1527, either should work.. ",
    "alsonkemp": "The build is failing because of an upgrade to knex 0.12.7.  PR #1531 fixes this.. This will fix build failures on PRs #1528 and #1529 .. Oops.  I did not mean to close this PR.  Reopening.. ",
    "coryallegory": "The typo appears to have been fixed by https://github.com/bookshelf/bookshelf/commit/fe355f6fd6ec280ca72a980ac453468bcda0cb55\nRecommend closing this pull request.. The typo appears to have been fixed by https://github.com/bookshelf/bookshelf/commit/fe355f6fd6ec280ca72a980ac453468bcda0cb55\nRecommend closing this pull request.. Typos still exist, someone should just merge this in and get some of these obvious pull requests closed.\n@Playrom you appear to be active recently :). Typos still exist, someone should just merge this in and get some of these obvious pull requests closed.\n@Playrom you appear to be active recently :). the docs might be problematic once 0.13.1 is published \u00af_(\u30c4)_/\u00af. ",
    "feute": "I would like this to be added to the documentation. There is the list of events, but I don't (or didn't) know what to return or how to manipulate the flow of the events.\nSo far, I've used promises, I don't know if this is the best practice, or if it's the only way to do it, but I saw it somewhere, I think:\njs\ninitialize: function () {\n  this.on('updating', (model, affectedRows, options) => {\n    return new Promise((resolve, reject) => {\n      // do some stuff\n      // ...\n      // call resolve() if you want to continue with the event, in this case,\n      // it would update the model; or call reject() to stop it, leaving the model\n      // as it was.\n    })\n  })\n}. ",
    "pApApAw": "I'm having the same issue. . ",
    "prieston": "The reason is that fetching event refers to the models. Use \"fetching:collection\" instead for fetchAll.. Because it happens on every ten requests in the database. I did the same test at online github projects that uses bookshelf and I get the same warning. My thought is that bookshelf opens a new connection on every request.. Sorry, my mistake.. I listened to you when you said this is an express related warning so run over all of my project. The warning is not bookshelf specific. The problem is that I was using app.use to log the warnings so in every request this middleware was being used. So the maxEventListenerWarning was referring to the process.on function.! My bad! Thank you really pointed the direction to look at!. ",
    "nitish24p": "@tgriesser or anyone who can answer this. ",
    "yusufsyaifudin": "@rapzo thanks, it works, but I concern about coding standard. I use ESLINT which extends airbnb-base configuration and it returns following error when I wrote like you have mentioned above:\n[eslint] Expected 'this' to be used by class method 'tableName'. (class-methods-use-this)\nI know it can be disabled by an inline comment, but I think it is not the best idea since what ESLINT recommendation is really make sense, why should I write getter which only return a value if they cannot be set (ESLINT recommendation is using static getter instead)? But, if I set a setter like:\n```\nclass User extends Database.Model {\nconstructor() {\n    super();\n  }\nget tableName() {\n    return this.tableName;\n  }\nset tableName(table) {\n    this.tableName = table;\n  }\n}\n```\nwill return error Maximum call stack size exceeded\nSorry, maybe this topic is not relevant to my first question anymore, but as I said before, I just think that ESLINT with Airbnb's coding standard really makes sense. I think this is not appropriate to discuss such this thing here, so I will close this issue, or maybe it can be a feature suggestion for the next release.\nFinally, perhaps I will write it in the ES5 style using Database.Model.extend({}), but, again, as I coming from OOP language like Java, I prefer to use class instead.\nAnyway, thanks in advance.. ",
    "adamjaffeback": "FYI, it uses fetchAll:\njavascript\nModelName\n.query(qb => qb.columnInfo())\n.fetchAll()\n.then(res.json)\n.catch(next);. @ricardogama thanks for the merge. I agree with you, the only failure in tests was during the installation of oracledb (link to Travis CI logs).\nIt only fails against Node 7...and it doesn't look like it was just me; it started popping up 4 days ago on #1710. This is related to oracle/node-oracledb#811. I'll open an issue, as it looks like this won't be going away.. Solution could make use of #1609, which states: \"OracleDB tests will be loaded and executed only when oracledb is installed\". However, this hinges on OracleDB failing gracefully during install and not exiting CI with an error.. ",
    "Antman261": "I don't see how dropping down to knex.raw() is an acceptable solution for such a common use case in an ORM? I like Django ORM's way of handling this, where related params are part of the where clause via double underscores in the key, so all your where conditions are entered in the same place, i.e.\nMyModel.objects.filter(some_attr=12, some_relation__its_attr=123) would now look for \nSELECT * // ommitted for clarity\nFROM my_model\nJOIN some_relation ON my_model.id = some_relation.foreign_key_id \nWHERE my_model.some_attr = 12 AND some_relation.its_attr = 123\nWhy can't bookshelf let me do something as simple as\nnew MyModel({some_attr: 12, \"some_relation.its_attr\": 123}).fetch({ withRelated: [\"some_relation\"] });\nThen it could retrieve the related models in a single query and include their columns in its where clause.\n\u00af_(\u30c4)_/\u00af thoughts?. ",
    "mochini": "i am also seeing this with bluebird:\n```\n\nbookshelf@0.10.4 postinstall /Users/mochini/Workspace/mycce2/node_modules/bookshelf\nnode ./scripts/build.js lib \"npm run build\"\n\nmodule.js:487\nthrow err;\n^\n\nError: Cannot find module 'bluebird'\n    at Function.Module._resolveFilename (module.js:485:15)\n    at Function.Module._load (module.js:437:25)\n    at Module.require (module.js:513:17)\n    at require (internal/module.js:11:18)\n    at Object. (/Users/mochini/Workspace/mycce2/node_modules/bookshelf/scripts/build.js:5:15)\n    at Module._compile (module.js:569:30)\n    at Object.Module._extensions..js (module.js:580:10)\n    at Module.load (module.js:503:32)\n    at tryModuleLoad (module.js:466:12)\n    at Function.Module._load (module.js:458:3)\n```. i am also seeing this with bluebird:\n```\n\nbookshelf@0.10.4 postinstall /Users/mochini/Workspace/mycce2/node_modules/bookshelf\nnode ./scripts/build.js lib \"npm run build\"\n\nmodule.js:487\nthrow err;\n^\n\nError: Cannot find module 'bluebird'\n    at Function.Module._resolveFilename (module.js:485:15)\n    at Function.Module._load (module.js:437:25)\n    at Module.require (module.js:513:17)\n    at require (internal/module.js:11:18)\n    at Object. (/Users/mochini/Workspace/mycce2/node_modules/bookshelf/scripts/build.js:5:15)\n    at Module._compile (module.js:569:30)\n    at Object.Module._extensions..js (module.js:580:10)\n    at Module.load (module.js:503:32)\n    at tryModuleLoad (module.js:466:12)\n    at Function.Module._load (module.js:458:3)\n```. ",
    "mariosouto": "@absolux Sure!\n```javascript\nfunction withDogsCount(qb) {\n  return qb.select(knex.raw(\n    '(select count(*) from dogs where dogs.owner_id = owners.id)::integer as dogs_count'\n  ));\n}\n```. It worked! Thanks so much! \ud83c\udf89 . ",
    "darkghoul79": "I was able to tweak it in order generate the right query,\n```\nseller() {\n    // return this.belongsTo('User', 'sellerId', 'id') .through(\"Items\"), 'id', 'orderId')\n    const relation = this.belongsTo('User', 'sellerId', 'id') .through(\"Items\", 'id', 'orderId')\nrelation.relatedData.throughIdAttribute = 'orderId'\nreturn relation\n\n}\nBut unfortunately, its not returning  `owner` info/record. . @absolux sorry my scenario was wrong and i've already updated. \nThe objective is an order belongs to one buyer and an order can have multiple items. and an item belongs to one seller. that's why i didn't add `sellerId`(merchant/owner of the item) in orders.. @vellotis yeah I've thought of that and that would be my last option. I've managed to tweak and make it generate the correct query..\nseller() {\n    // return this.belongsTo('User', 'sellerId', 'id') .through(\"Items\"), 'id', 'orderId')\n    const relation = this.belongsTo('User', 'sellerId', 'id') .through(\"Items\", 'id', 'orderId')\nrelation.relatedData.throughIdAttribute = 'orderId'\nreturn relation\n\n}\nhowever it is just returning empty. But the query is correct (still checking to why it's not returning the result). . I managed to make it work! Just upgraded bookshelf to `^0.10.3`\nbuyer() {\n     return this.belongsTo('User').through('Item', 'id', 'sellerId', 'orderId')\n}\n```. ",
    "jwickens": "Hi this would be great to get merged. ",
    "pbassut": "This is happening with hasOne too. \nLost a few hours on it :)\nThanks for the great work!. @ricardograca I was going to when I brought it up. Was in a hurry but wanted to post this as sort of a reminder.. Done: https://github.com/bookshelf/bookshelf/issues/1771. ",
    "seqs": "+1. ",
    "cteevin": "Hey, I think I found the right way, I hope I can help someone else with this, mixing Bookshelf and Knex worked for me.\nThis code solved my problem, I have tested it by running 50 threads all of them updating thousands of times the same row and worked perfect, I used the example from here, all the credits for Evan\n```\nlet clientId = 15;\nlet additionalCredits = 350;\nlet initialCredits = 0;\nreturn bookshelfjs.transaction(function (t) {\n  return Clients.where({ clientId: clientId })\n  .query((q) => { q.forUpdate(); })\n  .fetch({ transacting: t })\n  .then((client) => {\n    initialCredits = client.attributes.credits;\n    client.set('credits', client.attributes.credits + additionalCredits);\n    client.set('lastUpdate', '2017-05-12 09:45:12');\n    return client.save(null, { transacting: t });\n  })\n  .then((client) => {\n    return {\n      result: {\n        clientId: clientId,\n        initialCredits: initialCredits,\n        additionalCredits: additionalCredits,\n        finalCredits: client.attributes.credits,\n        lastUpdate: client.attributes.lastUpdate\n      }\n    };\n  });\n});\n```. ",
    "jay763190097": "@absolux \ni tried it,but it return \n{ \n.....\nfile:{}\n}. @absolux\nThis is my code.\n```\nasync findAll(callback = {}, options) {\n    let data;\n    if (typeof callback === 'function') {\n        data = await this.query(function(qb) {\n            //qb.orderBy('id', 'desc');\n            callback(qb);\n        }).fetchAll(options);\n    } else {\n        data = await this.query({ where: callback }).fetchAll(options);\n    }\n\n    return this.handle(data);\n}\n\n\n let banner = await this.model('ads').findAll(function(qb){\n            qb.where('status','=','1');\n        },{\n            columns:['id','name','rank','status','url','file_id'],\n            withRelated:[{'file':qb => qb.select('name')}]\n        });\n```. @absolux Thanks! It did work. @einsqing \u611f\u8c22\u6307\u5bfc\uff01. ",
    "gustblima": "solved using \nnpm install knex@0.12.0 --save-exact. ",
    "ultrox": "I tried just reinstalling with knex@0.12.0, but didn't work on my end, so I did this:\n\nrm -rf node_modules\nnpm cache clean\nChanged package.json knex@0.13.0 to knex@0.12.0\nnpm install. \n",
    "sgraham785": "can the knex peer dependency version be updated? or will that break?\ncurrent:\n\"peerDependencies\": {\n    \"knex\": \">=0.6.10 <0.13.0\"\n  }\nsuggested:\n\"peerDependencies\": {\n    \"knex\": \">=0.6.10 <=0.13.0\"\n  }\nhaven't tested yet but may submit PR. that doesn't support the documentation in README. Thank you! sorry I was never able to get around to this. Thank you! sorry I was never able to get around to this. ",
    "countergram": "I think everything is discarded through the collection version of fetchPage\nreturn fetchPage.apply.apply(fetchPage, [this.model.forge()].concat(args));\nThe concat doesn't work properly here. It only doesn't throw because an object can be treated as an array (just doesn't do much w/o numeric keys).. Might be a different issue. ",
    "nil1511": "Can you trigger test on Travis? I am not able to trigger using empty commit.. ",
    "vpfaulkner": "You are right, it was a statement length issue. We restructured the query similar to\nknex('foo').whereIn('barId', knex('bar').select('id').where('count', 0));\nand fixed the problem.. You are right, it was a statement length issue. We restructured the query similar to\nknex('foo').whereIn('barId', knex('bar').select('id').where('count', 0));\nand fixed the problem.. ",
    "fcarreiro": "Nice.\nDo we know if the minor version bump actually breaks something from Bookshelf?. @Playrom awesome! I've also seen that you have been working a lot merging and fixing PRs, thats great! Nice to see bookshelf coming back to life. Any planned date for a release including the changes that you have been merging?. @Playrom looking forward to it. Keep up the good work!. ",
    "YOO629": "thanks @absolux, using a left join instead works for me.. thanks @absolux, using a left join instead works for me.. Figured it out (I think).\nMy models table has a one to many relationship with model_related_table. It looks like some kind of exclusion happens when there are repeats. The fix was to just add a qb.distinct('models.*') to my query.\nAnyways, closing this since it's a non-issue and just user error. :). ",
    "atrauzzi": "Redis, rethink, mongodb, couchbase, aerospike, neo4j.. Redis, rethink, mongodb, couchbase, aerospike, neo4j.. ",
    "Unsigno": "Hi all , i am new here :) but i will try to help. \nI still can not say much about functionality, but I can speak from a new user's point of view. And I do not have very good news, from Google I find little more than the documentation itself, and there are only few examples of some functions mixed with the API that are not enough to start using it. And attracting new users is an important point to keep a project alive.\nThat's why I propose a reorganization of the documentation, separate the examples of the API, creating a  \"Getting started\" section to include them and add new ones. Maybe keeping a dropdown to continue showing them in the API (how now are, but hidden by default)\n( Example ) \nI found Bookshelf by polymorphic models, and looks fine, the documentation shows how to define the models, but no more. Now i dont know if they manage the type internally, if i can create a ExtendedModel and automatically creates the BaseModel... I can define polymorphic models but i dont know how it works or how use it .\nMaybe for people that know how Bookshelf works this sounds exaggerated, but forget your knowledge and try finding basic questions on Google .\nIf you agree with this point, I can help with it. If not I will try to collaborate with some PR.\nI wish you 0 bugs and compilation errors :p\nBest regards, Unsigno .. ",
    "guidsen": "If you need some extra hands. I'm willing to give up some weekend hours to contribute. Let me know!. Excuse me, this belongs in the Knex repository.. ",
    "theklr": "Have there been any updates on progress?. ",
    "israelshirk": "@mrhwick Thanks for stepping up and throwing some org into this mess.\n\n\nWorst case, publishing might come in the form of bookshelf2 if we can't get access to NPM; or, we could just ping the guys at NPM and point them at this thread - they're decent enough people and understand how this stuff works.\n\n\nI'm a bit time-limited but understand the codebase, database theory, etc well enough to do some contributions.  I'd be glad to start off by just doing some simple triage on issues and going issues-first if I can get a reviewer and a grassroots decision on ES6/ES7 if that seems like a good starting point.\n\n\nFor the moment, I'll ping NPM and see if they can assign @mrhwick ownership of the NPM repo so we can have single ownership and he can delegate from there.. Ticket submitted to support@npmjs.org.. Looks like he got access already.  Kudos to whoever got that going!. Don\u2019t see one out there and this seems like pretty low-hanging fruit for the community.  I\u2019ll get a PR out for non-babel and take a look at react-native (which I happen to love...  compared to the alternatives) later today in a different PR.. @mrhwick ^. \n\n",
    "TJKoury": "Maybe someone has already done this, but is there explicit support for JSON Schema and JSON-LD?  I'd like to be able to convert a JSON Schema doc to a database table directly (without following $refs), and convert outputs to JSON-LD.  I'd be willing to work on it, if there's nothing out there yet.. ",
    "maxnordlund": "Here goes my two cents. I really would like to be able to use ES6 classes, which I believe is already the plan but worth mentioning again. Related to that is implementing some of the newer protocols, iterator/async iterator and awaitable (which is really just thenable).\nNow that a major redesign is in progress I think it would be prudent to look at some of the other ORM:s out there. not just in Node, but also in general. On top of my head I'm thinking of SQLAlchemy and Djangos ORM in Python, Active Record and Data Mapper in Ruby, and finally Ecto in Elixir. (Of course I've read the plan to move away from Active Record toward Data Mapper, but still it's good to get some inspiration).\nI'm really looking forward to see where this is going, as its not everyday an established ORM takes time to do such an major overhaul.. TL;DR All abstractions leak, and it's important to always provide a safe escape hatch for those funky queries.\nI use Django at work and have found it confusing and a bit frustrating to work with. It's some small things, like avoiding SQLy method names, e.g. where, to Pythonic ones, e.g. filter. Speaking of which, filter actually represents both WHERE and HAVING, which makes it kinda confusing to use. Same goes for group by vs annotate, where the abstraction gets in the way.\nWhat I'm trying to get at, is the more abstracted the ORM gets, the harder it becomes to debug but it also makes it easy to do the common things like getting a single row/object via primary key. You end up needing to know just how the ORM transforms your method calls into SQL. At least for me when writing group by queries using Django I start with the SQL and work my way backwards.\nThis is also the argument of SQLy vs JavaScripty, where I personally like the SQL variant more. That also forces the developer to get to know how the database works, which helps debugging and profiling bad queries.\nOn the other hand I do love the convenient short cuts, like Post.get(), and post.save(). Especially if the latter can take an arbitrary object graph and insert/update as needed while doing it in the correct order to ensure foreign keys are setup properly. (Sounds harder then it is, you can use DFS/BFS to bucket the objects per model/table and then DFS reverse foreign key relations to automatically ensure correct dependency order.) Even better if it uses batch insert, and/or insert on conflict update.\nThat, and join handling which quickly becomes tedious IMO, with preloading of relations to avoid N+1 quires. I'm sure there are more stuff an ORM helps with that a raw SQL library won't do, but if it can be done by the query builder, why reimplement it?. Hm, I think I wasn't very clear on what I meant. I also wasn't very nice, and I apologize for that, expressing one opinion shouldn't feel so full of vitriol.\nI love when the ORM helps me write some of the tricker queries, like JOIN's, using the knowledge provided by the developer. This also applies for loading related models in an performant way, i.e. using either JOIN(s) or SELECT * FROM table WHERE id in (...).\nI'm very grateful when the ORM helps me save an object graph in the correct order, setting foreign keys as it goes, using bulk INSERT's and UPDATE's where necessary etc.\nThen there's validation, eager or lazy, but having a structured way of validating an object is so helpful. Is this field required? Is it inside of this range? ... This can then be used for displaying errors to the user in some sort of <form>.\nAt the same I want to be able to drop down to writing quires by hand, using the builder or just raw strings. Some ORM's make this difficult, which can be frustrating to work with. Other makes it a breeze, and it makes you happy. For example, Django allows for adding extra fields from GROUP BY queries to your models, which allows stuff like counting related models.\nSpeaking about query builders, I prefer them over raw SQL since they help you avoid injection attacks. They are also reusable, which makes it easy to append WHERE conditions to some long JOIN chain.\n\n\nI recommend using Objection.js for this point of view. Where I work, we are currently migrating our backend from Bookshelf to Objection.js and for our case and preferences (we like SQL a lot), is perfect.\n\n@chamini2 actually for my hobby project I did end up using that. But I think there're a lot of potential in Bookshelf and hope to use it in the future.",
    "dantaub": "What I would really like to see is core or plugin support for the interface layer between the backend and frontend. I understand that many people use Backbone on the frontend since the APIs are compatible, but I see no reason why Bookshelf models (absent the DB connections) couldn't be used directly, assuming one follows best practices regarding attribute whitelists, like those available in the 'visibility' plugin. . That's a good start -- it would be nice to have a stripped-down build of Bookshelf with minimal dependencies that we could include client side. Coupled with a caching system, that could be pretty powerful. I had been thinking just to create a parallel build process that creates classes or objects from Bookshelf models for frontend inclusion. Another compatible design is a plugin that, given some model, reduces the boilerplate needed to create Node CRUD routes that obey permissions set on the reqs (this could build on the ideas in the advanced-serialization plugin, or depend on some middleware to set the permissions).. ",
    "Saeris": "Just wanted to chime in here with something to take into consideration. It might be worth spending some time to evaluate modern use cases for ORMs, case in point: using Bookshelf in conjunction with GraphQL.\nI started off one of my GraphQL projects using Bookshelf in my resolvers for queries and mutations. This worked fine up until I had to start doing more complex queries that involved deep nesting of types, leading to an N+1 bottleneck. I've since started using join-monster to better handle this situation. Another issue I've had some trouble with was performing upserts, where I may be performing an update mutation on a given type to either modify a few columns on an existing row, or creating a new one entirely assuming there isn't a match on the primary keys for that row. For this I'm using bookshe;f-modelbase.\nI'm not entire sure what changes should be made to better support my use-case. It's more than likely I'm just not using Bookshelf correctly to begin with or I just have some fundamental misunderstanding or SQL/ORMs. Both are more than likely, given that I only started doing more full-stack development a year ago, having formerly been exclusively front-end focused. I just know I've spent a long time being confused over Bookshelf's documentation.\nWhat I do understand pretty well is how GraphQL is changing the API landscape. At it's core, it's designed to help reduce the number of network round-trips between client and server down to a minimum, which it's very good at. This, however, does shift a lot of the overhead to the back-end, where now it's much easier to create a bottleneck between the API layer and back-end data sources. Ideally, Bookshelf would do as much optimization under the hood as possible so the database doesn't get hammered with lots of queries. That's what's beyond my area of expertise.\nI can try to contribute as much as I can to discussing that particular topic.\nOther than that, +1 on using modern syntax features such as async/await.\nMight be worth considering using Rollup to compile to different module formats and picking up Typescript/Flow. Looks like there's some hesitance to use Babel in this project. I'd say go all-in with it, because with a combination of modern code bundling tools and babel-preset-env it should be easy to polyfill support for older versions of Node.. ",
    "jdrelick-va": "@Saeris I know you posted a while ago but I just thought I'd recommend taking a look at using dataloaders to solve your GraphQL n+1 issues. It is an approach designed to solve exactly that while also adding some useful caching capabilities. Dataloaders are especially useful in a db-per-service microservice architecture where joins are simply not possible.. ",
    "jackwanders": "Just found this issue after debugging a test in a project of mine that depends on model[updatedAtKey] actually updating on save() and can verify this line as the root cause. It's a no-op for any update operation where model[updatedAtKey] already contains a value.. > we have to understand how to differenciate between the model being updated know and the version already saved... any advice?\nFrom this question, I infer that there is a desire to only change the value of the updatedAtKey field if there is a legitimate change to the entity being saved, as opposed to changing the value of the updatedAtKey upon every save, regardless of whether there is any real change to the record. Is that correct?\nBased on the old code here, it appears the logic was that the updatedAtKey field always changed. Is it inappropriate to simply keep that contract in place?\n. Looking at the pull request from which this change originated (https://github.com/bookshelf/bookshelf/pull/1583), it appears that the intent is this:\n\nIf a save is executed on a model, and the new set of attributes includes either createdAtKey or updatedAtKey, then apply those values to the appropriate fields of the model.\n\nHowever, that's not what the code is doing, based on my understanding of the logic.  Let's take a simple example model:\njavascript\nvar car = Model.forge({\n  make: 'Ford'\n  model: 'Mustang',\n  color: 'red'\n})\nLet's then say that I change the color of the car:\ncar.save({color: 'blue'});\nThis call would eventually hit this line which executes the .timestamp() function which adds created_at and updated_at attributes to the hash of attributes that are being updated, if appropriate.\nHere is the current code in question within .timestamp() (with comments added by me)\n```javascript\n// attributes = {color: 'blue'}\n// this.attributes = {make: 'Ford', model: 'Mustang', color: 'red', created_at: '2017-07-19T14:05:01.402Z', updated_at: '2017-07-19T14:05:01.402Z'}\nif (updatedAtKey) {\n    // if the model already has a 'updated_at' value, add that current value to the hash of\n    // attributes that are being updated\n    attributes[updatedAtKey] = this.attributes[updatedAtKey]\n      ? new Date(this.attributes[updatedAtKey])\n      : now;\n  }\nif (createdAtKey && method === 'insert') {\n    // if the model already has a 'created_at' value, add that current value to the hash of\n    // attributes that are being updated\n    attributes[createdAtKey] = this.attributes[createdAtKey]\n      ? new Date(this.attributes[createdAtKey])\n      : now;\n  }\n// attributes = {color: 'red', created_at: '2017-07-19T14:05:01.402Z', updated_at: '2017-07-19T14:05:01.402Z'}\n  this.set(attributes, options);\n```\nFrom this, it's obvious that not only is the updated_at field not being updated to the current time, but the assumed goal of consuming an updated_at value provided in attributes is not being realized either.\nI would assume that the code should look like this:\n```javascript\nif (updatedAtKey) {\n  attributes[updatedAtKey] = attributes[updatedAtKey]\n    ? new Date(attributes[updatedAtKey])\n    : now;\n}\nif (createdAtKey && method === 'insert') {\n  attributes[createdAtKey] = attributes[createdAtKey]\n    ? new Date(attributes[createdAtKey])\n    : now;\n}\nthis.set(attributes, options);\n```\nNote that now we are using the updated_at and created_at values provided via the incoming attributes hash, and not those that already exist within the model. This would seem to achieve the goal set out in #1583.. ",
    "magnuspaaske": "@Playrom What's the timeline for this making it into a numbered release?. @Playrom What's the timeline for this making it into a numbered release?. Great, looking forward :). Great, looking forward :). @icflorescu The issue is solved in the master but no new version has been released yet.. Thanks. Looking forward to the fix getting into a numbered release :). Thanks. Looking forward to the fix getting into a numbered release :). Figured it out \u2013\u00a0there was a circular relationship between the collection and the model, with the collection being required before the model was created.. ",
    "icflorescu": "Is there any way I can assist in turning this into a release sooner?. Can you please reopen this?. ",
    "jeffhallrsn": "+1 A release of this would be useful please. I'm having to downgrade 0.13.0.. ",
    "ruffrey": "On an internal app, my team's tests ensure the update timestamp is working (with a custom name). \nIt no longer fails on this PR after doing npm i git+https://github.com/bookshelf/bookshelf#8a0914b49cb2059d4d800524abb54d4869a33afb (vs npm i bookshelf@latest).\nThanks!. On an internal app, my team's tests ensure the update timestamp is working (with a custom name). \nIt no longer fails on this PR after doing npm i git+https://github.com/bookshelf/bookshelf#8a0914b49cb2059d4d800524abb54d4869a33afb (vs npm i bookshelf@latest).\nThanks!. Just checking in - any idea on a timeline to publish a patch to npm?. ",
    "switz": "This really should be released ASAP.. ",
    "bloxmobnico": "@ricardograca Yes I know I can run them sequentially by running the fetchAll inside the then function of the save. I understand how async programming works. Technically I am not running them in parallel either because node is single threaded by default (Unless I created 2 instances of node each running on a different core). It's executing the then functions asynchronously (but still on the same thread) depending on when the DB responds and which promise finishes first. \n@Playrom The reason why I am doing this is because in my implementation I don't care in what order or when the fetchAll finishes. I care that the save finishes as fast as possible to be able to go to my next logic. \nThe reason why I was thinking it was similar to #1484 is because if I wrap thefetchAll in a timeout everything works as expected.. Yes I do agree that putting the queries in sequential order will work for this case. Specially because (like I said before) I don't really care when the fetchAll finishes. \n(But) I do think that there is an issue with the save function and the way the promises are set up, because this doesn't happen with other function like fetch. I can also confirm this is an issue because I have done the same actions using pure knex and it works as expected. So it definitely doesn't have to do with accessing the db concurrently.. ",
    "AgatheG": "Ho I see. \nMaybe a safe way would be to set a unique ID per fetching/fetch pairs  like this : \nbookshelf.on('fetching', (event) => {\nconst id = uniqueId(event);\nserver.app.fetching[id + ''] = new Date().valueOf();\n});\nbookshelf.on('fetched', (event) => {\nconst id = uniqued(event);\nserver.statsd.gauge('db_query', new Date().valueOf() - server.app.fetching[id+'']);\n});\n... or am I totally mistaken? I am still a bit new to bookshelf. Yep it actually seems like it :)\nIs there an easy work around then?. ",
    "greenkeeper[bot]": "Version 3.1.0 just got published.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 15 commits.\n\n1e33b74 Update docs/changelog.md and set new release id in docs/_config.yml\n3e0fe34 Add release documentation for v3.1.0\n24207cd 3.1.0\n94e262d Update Changelog.txt and AUTHORS for new release\naf6348c Merge pull request #1519 from fatso83/sandbox-wrong-config-passed\nf8b4ea1 Update sandbox docs\n127aafc Add missing docs on sandbox config change\ncacd10d Fix relative links\n1f2d2e3 Merge pull request #1515 from sinonjs/create-factory-functions\n75ad693 Merge pull request #1516 from fatso83/1512-sandbox-stub-props-on-prototype\nb4a3f42 Fix regression on sandbox.stub(obj,protoMethod)\nece1ee5 Add regression test case\n6648f1b Use new sandbox and fake server factory functions in documentation\n4c2aa41 Add factory functions for sandbox and fake server\nec74e94 Add support for passing a function to stub.throws(...). (#1511)\n\nSee the full diff\n\n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nAdd stub#resolvesThis\n\nFix #1521 by caching references to Array.prototype.filter (#1523)\nFix #1368 by adding stub#resolvesThis (#1517)\n\n\n\nCommits\nThe new version differs by 15 commits.\n\nf1d6e75 Update docs/changelog.md and set new release id in docs/_config.yml\nf6374e8 Add release documentation for v3.2.0\n1b81ec6 3.2.0\naea2654 Update Changelog.txt and AUTHORS for new release\n81c23fb Merge pull request #1523 from fatso83/1521-stub-array-filter-fails\n052a2d0 Add requirements to pull request template\n56ca580 Cache other references to Array.prototype.filter\n531f872 Cache reference to filter in stubbing calls\n3df68a7 fixes issue #1368 by adding stub#resolvesThis (#1517)\n6689cab Merge pull request #1522 from sinonjs/centered-readme-header-with-logo\nbe66ebb Fix \"npm based CDNs\" link\nb005f1d Contered header with logo in readme\n996d502 Merge pull request #1520 from fatso83/jsdelivr\nb376dcf Add hints on using CDNs in docs and README\n3ad5e05 Add props for default file in CDN delivery\n\nSee the full diff\n\n. ## Version 3.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 15 commits.\n\ndbef9aa Update docs/changelog.md and set new release id in docs/_config.yml\n97b0535 Add release documentation for v3.2.1\n359e78b 3.2.1\n590ae7d Update Changelog.txt and AUTHORS for new release\nd9cae73 Merge pull request #1532 from EyalAr/master\n4f40409 fix fakeServerWithClock.create function mock to return a unique value\n4310343 Merge pull request #1533 from noisecapella/gs/fix_undefined\nf87b512 resolvesThis should override previous throws\na85a355 fix tests that stub nise.fakeServer.create & fakeServerWithClock.create\n5c3fb95 preserve context of functions from nise: fakeServer, fakeServerWithClock\nb509f4e add tests for issue #1531\n28bcedc Merge pull request #1530 from noisecapella/gs/regression_onfirstcall\n7b53434 Fix regression for issue #1526 regarding onFirstCall().throws()\n350717d Remove superfluous \n2a04615 Fix docs regression introduced by #1523\n\nSee the full diff\n\n. ## Version 3.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 24 commits.\n\ne9f40a2 Rename Changelog.txt to History.md\n40edb3e Update docs/changelog.md and set new release id in docs/_config.yml\n27986c8 Add release documentation for v3.3.0\n85f30b5 3.3.0\n7d45683 Update Changelog.txt and AUTHORS for new release\n10906a7 Merge pull request #1560 from servel333/nested_property_matcher\na54b38c Fixes docs for error.\n04ba963 Adds sinon.match.hasNested\n5fbd9ee Merge pull request #1549 from killmenot/fix-1442\n0a34cf5 Merge pull request #1550 from kuba-orlik/patch-1\na90f3ce Merge pull request #1558 from fatso83/fix-eslint-error\n32e4516 Update code to stricter linting\n212e91d Fix eslint peerDependencies error\n5606815 Fix double backticks in inline code examples\naf30213 fix #1442\n\nThere are 24 commits in total.\nSee the full diff\n\n. ## Version 4.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 11 commits.\n\n95908f4 Add release notes for 4.0.0\n460907b Update docs/changelog.md and set new release id in docs/_config.yml\n6f599a6 Add release documentation for v4.0.0\nfba2e29 4.0.0\nc838e22 Update History.md and AUTHORS for new release\n3837635 Merge pull request #1569 from fatso83/1566-update-deps\n3d3a044 Explicitly update fake xhr lib 'nise'\n5ec0ae0 Merge pull request #1564 from fatso83/amended-1563\ncf32e6d Update deps lock file\n37ff38b Removes dependency to \"build\"\n34fc2ba Remove support for stubbing undefined props (#1557)\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 16 commits.\n\nec9126c Update docs/changelog.md and set new release id in docs/_config.yml\n1222a0f Add release documentation for v4.0.1\n1bf1f2d 4.0.1\n1545c26 Update History.md and AUTHORS for new release\ne9fab2d Merge pull request #1579 from fatso83/upgrade-deps\nf2252b4 Upgrade nise and lolex versions\nd81a937 Fix doc typo: scenarious -> scenarios\naf3a645 Merge pull request #1577 from evan-007/fix_doc_typo\n7c9c881 Remove extra backtick from fake-xhr-and-server docs\ncf9bf05 Merge pull request #1575 from mroderick/tidy-up-docs\n2e8abad Remove obsoleted lib/sinon/sandbox-stub.js\n28e70d1 Use an include for migration guides\n3c68adc Move migration guides to new section\n6197ff3 Merge pull request #1565 from fatso83/patch-docs\ndfb9ee6 Add migration guide for 4.0\n\nThere are 16 commits in total.\nSee the full diff\n\n. ## Version 4.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 21 commits.\n\n39e5737 Update docs/changelog.md and set new release id in docs/_config.yml\nc2bd7b1 Add release documentation for v4.0.2\nda24e94 4.0.2\ncea60e8 Update History.md and AUTHORS for new release\nd4dcfca Document the stub.reset breaking change (#1590)\naab1917 Merge pull request #1596 from mroderick/fix-preversion-to-use-history.md\n5dbe685 Update 'nise' to latest version (#1593)\n578b9ea Update History.md and AUTHORS for new release\n499b698 Fix preversion.sh to stage History.md\n1e5fd0f Remove unneeded characters\n2a69d51 fix typo in contributing\n6cc71ec Document how to trigger progress events (#1585)\ne49fcf1 Fix broken test-coverage task\n527086a Use supports-color module to test if system supports colors\n78782b4 Merge pull request #1580 from mroderick/dependency-hygeine\n\nThere are 21 commits in total.\nSee the full diff\n\n. ## Version 4.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 22 commits.\n\nc0a71c6 Update docs/changelog.md and set new release id in docs/_config.yml\na2b873a Add release documentation for v4.1.0\n0a6a660 4.1.0\n3b36972 Update History.md and AUTHORS for new release\n201a652 Issue 1598 (Feature Request): Implemented sandbox.createStubInstance, tests, and documentation.\nd49180d Merge pull request #1603 from mroderick/fix-more-markdown\n2d2631c Docs: fix pre commit hook\n9fa87e7 Docs: remove trailing quote from heading\n46ffad3 Docs: verify documentation using markdownlint\naa10bb7 Docs: remove use of  element\n294ada0 Docs: remove use of  \n77e5d31 Docs: reduce unnecessary inline HTML\nb14a261 Docs: fix invalid syntax of backticks in headers\n579e029 Docs: fix trailing punctuation in headers\n7b04012 Docs: remove extraneous blank lines\n\nThere are 22 commits in total.\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n3a0e28b Update docs/changelog.md and set new release id in docs/_config.yml\n989e15b Add release documentation for v4.1.1\ndf3adf0 4.1.1\n0e9bf90 Update History.md and AUTHORS for new release\n9d9c372 Remove \"engines\" from package.json\n\nSee the full diff\n\n. ## Version 4.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n12567cf Update docs/changelog.md and set new release id in docs/_config.yml\n2af9818 4.1.2\n164fd2e Update History.md and AUTHORS for new release\n8de60ac Update Lolex to include fix for #872\nbcc6960 Remove deprecated methods from documentation (#1613)\nec3f489 Ignore coveralls module when checking for unused dependencies\n5693d38 Prefer node 8 for single run tests in Travis CI\n\nSee the full diff\n\n. ## Version 4.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 12 commits.\n\n39b0849 Update docs/changelog.md and set new release id in docs/_config.yml\n6f9af25 4.1.3\nc6bd1de Update History.md and AUTHORS for new release\n911c498 Spy passes through calling with new (#1626)\n271d84a Update external_howtos.yml\ne96ff8c CircleCI Integration (#1479)\n88e9132 Upgrade type-detect dependency to 4.0.5\n45c4d57 Move yieldsAsync* documentation to the first yieldsAsync*\n8c54024 Remove sinon.restore(object|method) from v3.x+ docs\n9ae6f73 Remove sinon.log from 2.x+ docs\n0111ed0 Update markdownlinter-cli to official v0.4.0\n109e7b7 Add markdownlint to dependencies\n\nSee the full diff\n\n. ## Version 4.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.4.1\n\nec93614 Fix: no-multi-spaces to avoid reporting consecutive tabs (fixes #9079) (#9087) (Teddy Katz)\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n0d9da6d 4.4.1\n1ea9a6c Build: changelog update for 4.4.1\nec93614 Fix: no-multi-spaces to avoid reporting consecutive tabs (fixes #9079) (#9087)\n\nSee the full diff\n\n. ## Version 4.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.5.0\n\ndecdd2c Update: allow arbitrary nodes to be ignored in indent (fixes #8594) (#9105) (Teddy Katz)\n79062f3 Update: fix indentation of multiline new.target expressions (#9116) (Teddy Katz)\nd00e24f Upgrade: chalk to 2.x release (#9115) (Stephen Edgar)\n6ef734a Docs: add missing word in processor documentation (#9106) (Teddy Katz)\na4f53ba Fix: Include files with no messages in junit results (#9093) (#9094) (Sean DuBois)\n1d6a9c0 Chore: enable eslint-plugin/test-case-shorthand-strings (#9067) (\u859b\u5b9a\u8c14\u7684\u732b)\nf8add8f Fix: don't autofix with linter.verifyAndFix when fix: false is used (#9098) (Teddy Katz)\n77bcee4 Docs: update instructions for adding TSC members (#9086) (Teddy Katz)\nbd09cd5 Update: avoid requiring NaN spaces of indentation (fixes #9083) (#9085) (Teddy Katz)\nc93a853 Chore: Remove extra space in blogpost template (#9088) (Kai Cataldo)\n\n\n\nCommits\nThe new version differs by 12 commits.\n\nff8c4bb 4.5.0\n480bbee Build: changelog update for 4.5.0\ndecdd2c Update: allow arbitrary nodes to be ignored in indent (fixes #8594) (#9105)\n79062f3 Update: fix indentation of multiline new.target expressions (#9116)\nd00e24f Upgrade: chalk to 2.x release (#9115)\n6ef734a Docs: add missing word in processor documentation (#9106)\na4f53ba Fix: Include files with no messages in junit results (#9093) (#9094)\n1d6a9c0 Chore: enable eslint-plugin/test-case-shorthand-strings (#9067)\nf8add8f Fix: don't autofix with linter.verifyAndFix when fix: false is used (#9098)\n77bcee4 Docs: update instructions for adding TSC members (#9086)\nbd09cd5 Update: avoid requiring NaN spaces of indentation (fixes #9083) (#9085)\nc93a853 Chore: Remove extra space in blogpost template (#9088)\n\nSee the full diff\n\n. ## Version 4.6.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.6.0\n\n56dd769 Docs: fix link format in prefer-arrow-callback.md (#9198) (Vse Mozhet Byt)\n6becf91 Update: add eslint version to error output. (fixes #9037) (#9071) (\u859b\u5b9a\u8c14\u7684\u732b)\n0e09973 New: function-paren-newline rule (fixes #6074) (#8102) (Teddy Katz)\n88a64cc Chore: Make parseJsonConfig() a pure function in Linter (#9186) (Teddy Katz)\n1bbac51 Fix: avoid breaking eslint-plugin-eslint-comments (fixes #9193) (#9196) (Teddy Katz)\n3e8b70a Fix: off-by-one error in eslint-disable comment checking (#9195) (Teddy Katz)\n73815f6 Docs: rewrite prefer-arrow-callback documentation (fixes #8950) (#9077) (Charles E. Morgan)\n0d3a854 Chore: avoid mutating report descriptors in report-translator (#9189) (Teddy Katz)\n2db356b Update: no-unused-vars Improve message to include the allowed patterns (#9176) (Eli White)\n8fbaf0a Update: Add configurability to generator-star-spacing (#8985) (Ethan Rutherford)\n8ed779c Chore: remove currentScopes property from Linter instances (refs #9161) (#9187) (Teddy Katz)\naf4ad60 Fix: Handle error when running init without npm (#9169) (Gabriel Aumala)\n4b94c6c Chore: make parse() a pure function in Linter (refs #9161) (#9183) (Teddy Katz)\n1be5634 Chore: don't make Linter a subclass of EventEmitter (refs #9161) (#9177) (Teddy Katz)\ne95af9b Chore: don't include internal test helpers in npm package (#9160) (Teddy Katz)\n6fb32e1 Chore: avoid using private Linter APIs in astUtils tests (refs #9161) (#9173) (Teddy Katz)\nde6dccd Docs: add documentation for Linter methods (refs #6525) (#9151) (Teddy Katz)\n2d90030 Chore: remove unused assignment. (#9182) (\u859b\u5b9a\u8c14\u7684\u732b)\nd672aef Chore: refactor reporting logic (refs #9161) (#9168) (Teddy Katz)\n5ab0434 Fix: indent crash on sparse arrays with \"off\" option (fixes #9157) (#9166) (Teddy Katz)\nc147b97 Chore: Make SourceCodeFixer accept text instead of a SourceCode instance (#9178) (Teddy Katz)\nf127423 Chore: avoid using private Linter APIs in Linter tests (refs #9161) (#9175) (Teddy Katz)\n2334335 Chore: avoid using private Linter APIs in SourceCode tests (refs #9161) (#9174) (Teddy Katz)\n2dc243a Chore: avoid using internal Linter APIs in RuleTester (refs #9161) (#9172) (Teddy Katz)\nd6e436f Fix: no-extra-parens reported some parenthesized IIFEs (fixes #9140) (#9158) (Teddy Katz)\ne6b115c Build: Add an edit link to the rule docs\u2019 metadata (#9049) (Jed Fox)\nfcb7bb4 Chore: avoid unnecessarily complex forEach calls in no-extra-parens (#9159) (Teddy Katz)\nffa021e Docs: quotes rule - when does \\n require backticks (#9135) (avimar)\n60c5148 Chore: improve coverage in lib/*.js (#9130) (Teddy Katz)\n\n\n\nCommits\nThe new version differs by 31 commits.\n\n8f01a99 4.6.0\nc0acbf2 Build: changelog update for 4.6.0\n56dd769 Docs: fix link format in prefer-arrow-callback.md (#9198)\n6becf91 Update: add eslint version to error output. (fixes #9037) (#9071)\n0e09973 New: function-paren-newline rule (fixes #6074) (#8102)\n88a64cc Chore: Make parseJsonConfig() a pure function in Linter (#9186)\n1bbac51 Fix: avoid breaking eslint-plugin-eslint-comments (fixes #9193) (#9196)\n3e8b70a Fix: off-by-one error in eslint-disable comment checking (#9195)\n73815f6 Docs: rewrite prefer-arrow-callback documentation (fixes #8950) (#9077)\n0d3a854 Chore: avoid mutating report descriptors in report-translator (#9189)\n2db356b Update: no-unused-vars Improve message to include the allowed patterns (#9176)\n8fbaf0a Update: Add configurability to generator-star-spacing (#8985)\n8ed779c Chore: remove currentScopes property from Linter instances (refs #9161) (#9187)\naf4ad60 Fix: Handle error when running init without npm (#9169)\n4b94c6c Chore: make parse() a pure function in Linter (refs #9161) (#9183)\n\nThere are 31 commits in total.\nSee the full diff\n\n. ## Version 4.6.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.6.1\n\nbdec46d Build: avoid process leak when generating website (#9217) (Teddy Katz)\ncb74b87 Fix: avoid adding globals when an env is used with false (fixes #9202) (#9203) (Teddy Katz)\nf9b7544 Docs: Correct a typo in generator-star-spacing documentation (#9205) (Ethan Rutherford)\ne5c5e83 Build: Fixing issue with docs generation (Fixes #9199) (#9200) (Ilya Volodin)\n\n\n\nCommits\nThe new version differs by 6 commits.\n\nd65c540 4.6.1\n61c845c Build: changelog update for 4.6.1\nbdec46d Build: avoid process leak when generating website (#9217)\ncb74b87 Fix: avoid adding globals when an env is used with false (fixes #9202) (#9203)\nf9b7544 Docs: Correct a typo in generator-star-spacing documentation (#9205)\ne5c5e83 Build: Fixing issue with docs generation (Fixes #9199) (#9200)\n\nSee the full diff\n\n. ## Version 4.7.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.7.0\n\n787b78b Upgrade: Espree v3.5.1 (fixes #9153) (#9314) (Brandon Mills)\n1488b51 Update: run rules after node.parent is already set (fixes #9122) (#9283) (Teddy Katz)\n4431d68 Docs: fix wrong config in max-len example. (#9309) (\u859b\u5b9a\u8c14\u7684\u732b)\n7d24dde Docs: Fix code snippet to refer to the correct option (#9313) (Ruben Tytgat)\n12388d4 \ufffdChore: rewrite parseListConfig for a small perf gain. (#9300) (\u859b\u5b9a\u8c14\u7684\u732b)\nce1f084 Update: fix MemberExpression handling in no-extra-parens (fixes #9156) (jackyho112)\n0c720a3 Update: allow autofixing when using processors (fixes #7510) (#9090) (Teddy Katz)\n838df76 Chore: upgrade deps. (#9289) (\u859b\u5b9a\u8c14\u7684\u732b)\nf12def6 Update: indent flatTernary option to handle return (fixes #9285) (#9296) (Teddy Katz)\ne220687 Fix: remove autofix for var undef inits (fixes #9231) (#9288) (Victor Hom)\n002e199 Docs: fix no-restricted-globals wrong config. (#9305) (\u859b\u5b9a\u8c14\u7684\u732b)\nfcfe91a Docs: fix wrong config in id-length example. (#9303) (\u859b\u5b9a\u8c14\u7684\u732b)\n2731f94 Update: make newline-per-chained-call fixable (#9149) (Jo\u00e3o Granado)\n61f1093 Chore: avoid monkeypatching Linter instances in RuleTester (#9276) (Teddy Katz)\n28929cb Chore: remove Linter#reset (refs #9161) (#9268) (Teddy Katz)\nabc8634 Build: re-run browserify when generating site (#9275) (Teddy Katz)\n7685fed Fix: IIFE and arrow functions in no-invalid-this (fixes #9126) (#9258) (Toru Nagashima)\n2b1eba2 Chore: enable eslint-plugin/no-deprecated-context-methods (#9279) (Teddy Katz)\n981f933 Fix: reuse the AST of source code object in verify (#9256) (Toru Nagashima)\ncd698ba Docs: move RuleTester documentation to Node.js API page (#9273) (Teddy Katz)\n4ae7ad3 Docs: fix inaccuracy in npm run perf description (#9274) (Teddy Katz)\ncad45bd Docs: improve documentation for rule contexts (#9272) (Teddy Katz)\n3b0c6fd Chore: remove extraneous linter properties (refs #9161) (#9267) (Teddy Katz)\nc3231b3 Docs: Fix typo in array-bracket-newline.md (#9269) (\u5b8b\u6587\u5f3a)\n51132d6 Fix: Formatters keep trailing '.' if preceded by a space (fixes #9154) (#9247) (i-ron-y)\n88d5d4d Chore: remove undocumented Linter#markVariableAsUsed method (refs #9161) (#9266) (Teddy Katz)\n09414cf Chore: remove internal Linter#getDeclaredVariables method (refs #9161) (#9264) (Teddy Katz)\nf31f59d Chore: prefer smaller scope for variables in codebase (#9265) (Teddy Katz)\n3693e4e Chore: remove undocumented Linter#getScope method (#9253) (Teddy Katz)\n5d7eb81 Chore: refactor config hash caching in CLIEngine (#9260) (Teddy Katz)\n1a76c4d Chore: remove SourceCode passthroughs from Linter.prototype (refs #9161) (#9263) (Teddy Katz)\n40ae27b Chore: avoid relying on Linter#getScope/markVariableAsUsed in tests (#9252) (Teddy Katz)\nb383d81 Chore: make executeOnFile a pure function in CLIEngine (#9262) (Teddy Katz)\n5e0e579 Chore: avoid internal SourceCode methods in Linter tests (refs #9161) (#9223) (Teddy Katz)\nadab827 Chore: remove unused eslint-disable comment (#9251) (Teddy Katz)\n31e4ec8 Chore: use consistent names for apply-disable-directives in tests (#9246) (Teddy Katz)\n7ba46e6 Fix: shebang error in eslint-disable-new-line; add tests (fixes #9238) (#9240) (i-ron-y)\n8f6546c Chore: remove undocumented defaults() method (refs #9161) (#9237) (Teddy Katz)\n82d8b73 Docs: Fix error in example code for sort-imports (fixes #8734) (#9245) (i-ron-y)\na32ec36 Update: refactor eslint-disable comment processing (#9216) (Teddy Katz)\n583f0b8 Chore: avoid using globals in CLIEngine tests (#9242) (Teddy Katz)\nc8bf687 Chore: upgrade eslint-plugin-eslint-plugin@1.0.0 (#9234) (\u859b\u5b9a\u8c14\u7684\u732b)\n3c41a05 Chore: always normalize rules to new API in rules.js (#9236) (Teddy Katz)\nc5f4227 Chore: move logic for handling missing rules to rules.js (#9235) (Teddy Katz)\nbf1e344 Chore: create report translators lazily (#9221) (Teddy Katz)\n2eedc1f Chore: remove currentFilename prop from Linter instances (refs #9161) (#9219) (Teddy Katz)\n5566e94 Docs: Replace misleading CLA links (#9133) (#9232) (i-ron-y)\nc991630 Chore: remove ConfigOps.normalize in favor of ConfigOps.getRuleSeverity (#9224) (Teddy Katz)\n171962a Chore: remove internal Linter#getAncestors helper (refs #9161) (#9222) (Teddy Katz)\na567499 Chore: avoid storing list of problems on Linter instance (refs #9161) (#9214) (Teddy Katz)\ned6d088 Chore: avoid relying on undocumented Linter#getFilename API in tests (#9218) (Teddy Katz)\n\n\n\nCommits\nThe new version differs by 55 commits.\n\n439e8e6 4.7.0\n2ec62f9 Build: changelog update for 4.7.0\n787b78b Upgrade: Espree v3.5.1 (fixes #9153) (#9314)\n1488b51 Update: run rules after node.parent is already set (fixes #9122) (#9283)\n4431d68 Docs: fix wrong config in max-len example. (#9309)\n9d1df92 Chore: Revert \"avoid handling Rules instances in config-validator\" (#9295)\n7d24dde Docs: Fix code snippet to refer to the correct option (#9313)\n12388d4 \ufffdChore: rewrite parseListConfig for a small perf gain. (#9300)\nce1f084 Update: fix MemberExpression handling in no-extra-parens (fixes #9156)\n0c720a3 Update: allow autofixing when using processors (fixes #7510) (#9090)\n838df76 Chore: upgrade deps. (#9289)\nf12def6 Update: indent flatTernary option to handle return (fixes #9285) (#9296)\ne220687 Fix: remove autofix for var undef inits (fixes #9231) (#9288)\n002e199 Docs: fix no-restricted-globals wrong config. (#9305)\nfcfe91a Docs: fix wrong config in id-length example. (#9303)\n\nThere are 55 commits in total.\nSee the full diff\n\n. ## Version 4.7.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.7.1\n\n08656db Fix: Handle nested disable directive correctly (fixes #9318) (#9322) (Gyandeep Singh)\n9226495 Revert \"Chore: rewrite parseListConfig for a small perf gain.\" (#9325) (\u859b\u5b9a\u8c14\u7684\u732b)\n\n\n\nCommits\nThe new version differs by 4 commits.\n\n2f064d9 4.7.1\n0d0bd7b Build: changelog update for 4.7.1\n08656db Fix: Handle nested disable directive correctly (fixes #9318) (#9322)\n9226495 Revert \"Chore: rewrite parseListConfig for a small perf gain.\" (#9325)\n\nSee the full diff\n\n. ## Version 4.7.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.7.2\n\n4f87732 Fix: Revert setting node.parent early (fixes #9331) (#9336) (Teddy Katz)\n\n\n\nCommits\nThe new version differs by 3 commits.\n\ne164397 4.7.2\nb7818ba Build: changelog update for 4.7.2\n4f87732 Fix: Revert setting node.parent early (fixes #9331) (#9336)\n\nSee the full diff\n\n. ## Version 4.8.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.8.0\n\n3f2b908 New: add option to report unused eslint-disable directives (fixes #9249) (#9250) (Teddy Katz)\nff2be59 Fix: dot notation rule failing to catch string template (fixes #9350) (#9357) (Phil Quinn)\nb1372da Chore: remove sourceCode property from Linter (refs #9161) (#9363) (Teddy Katz)\ncef6f8c Docs: remove line about removing rules from semver policy (#9367) (Teddy Katz)\n06efe87 Fix: Add meta element with charset attribute. (#9365) (H1Gdev)\n458ca67 Docs: update architecture page (fixes #9337) (#9345) (Victor Hom)\n1c6bc67 Fix: special EventEmitter keys leak information about other rules (#9328) (Teddy Katz)\nd593e61 Docs: update eslint.org links to use https (#9358) (Teddy Katz)\n38d0cb2 Fix: fix wrong code-path about try-for-in (fixes #8848) (#9348) (Toru Nagashima)\n434d9e2 Fix: Invalid font-size property value issue. (#9341) (H1Gdev)\na7668c2 Chore: Remove unnecessary slice from logging utility (#9343) (Gyandeep Singh)\n2ff6fb6 Chore: remove unused arguments in codebase (#9340) (Teddy Katz)\n\n\n\nCommits\nThe new version differs by 14 commits.\n\n8ebb034 4.8.0\n916a2d7 Build: changelog update for 4.8.0\n3f2b908 New: add option to report unused eslint-disable directives (fixes #9249) (#9250)\nff2be59 Fix: dot notation rule failing to catch string template (fixes #9350) (#9357)\nb1372da Chore: remove sourceCode property from Linter (refs #9161) (#9363)\ncef6f8c Docs: remove line about removing rules from semver policy (#9367)\n06efe87 Fix: Add meta element with charset attribute. (#9365)\n458ca67 Docs: update architecture page (fixes #9337) (#9345)\n1c6bc67 Fix: special EventEmitter keys leak information about other rules (#9328)\nd593e61 Docs: update eslint.org links to use https (#9358)\n38d0cb2 Fix: fix wrong code-path about try-for-in (fixes #8848) (#9348)\n434d9e2 Fix: Invalid font-size property value issue. (#9341)\na7668c2 Chore: Remove unnecessary slice from logging utility (#9343)\n2ff6fb6 Chore: remove unused arguments in codebase (#9340)\n\nSee the full diff\n\n. ## Version 4.9.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.9.0\n\n85388fb Fix: Correct error and test messages to fit config search path (#9428) (Jonathan Pool)\n62a323c Fix: Add class options for lines-around-comment (fixes #8564) (#8565) (Ed Lee)\n8eb4aae New: multiline-comment-style rule (fixes #8320) (#9389) (\u859b\u5b9a\u8c14\u7684\u732b)\ndb41408 Chore: avoid applying eslint-env comments twice (#9278) (Teddy Katz)\nfebb897 Chore: avoid loose equality assertions (#9415) (Teddy Katz)\n2247efa Update: Add FunctionExpression to require-jsdoc (fixes #5867) (#9395) (Kai Cataldo)\n6791d18 Docs: Corrected noun to verb. (#9438) (Jonathan Pool)\nb02fbb6 Update: custom messages for no-restricted-* (refs #8400) (Maja Wichrowska)\n02732bd Docs: Reorganized to avoid misunderstandings. (#9434) (Jonathan Pool)\nd9466b8 Docs: Correct time forecast for tests. (#9432) (Jonathan Pool)\nf7ed84f Docs: Add instruction re home-directory config files (refs #7729) (#9426) (Jonathan Pool)\n30d018b Chore: Add Aladdin-ADD & VictorHom to README (#9424) (Kai Cataldo)\n2d8a303 Docs: fix examples for prefer-numeric-literals (#9155) (Lutz Lengemann)\nd7610f5 Docs: Add jquery warning to prefer-destructuring (#9409) (Thomas Grainger)\ne835dd1 Docs: clarify no-mixed-operators (fixes #8051) (Ruxandra Fediuc)\n51360c8 Docs: update block-spacing details (fixes #8743) (#9375) (Victor Hom)\n6767857 Update: fix ignored nodes in indent rule when using tabs (fixes #9392) (#9393) (Robin Houston)\n37dde77 Chore: Refactor SourceCode#getJSDocComment (#9403) (Kai Cataldo)\n9fedd51 Chore: Add missing space in blog post template (#9407) (Kevin Partington)\n7654c99 Docs: add installing prerequisites in readme. (#9401) (\u859b\u5b9a\u8c14\u7684\u732b)\n786cc73 Update: Add \"consistent\" option to array-bracket-newline (fixes #9136) (#9206) (Ethan Rutherford)\ne171f6b Docs: add installing prerequisites. (#9394) (\u859b\u5b9a\u8c14\u7684\u732b)\n74dfc87 Docs: update doc for class-methods-use-this (fixes #8910) (#9374) (Victor Hom)\nb4a9dbf Docs: show console call with no-restricted-syntax (fixes #7806) (#9376) (Victor Hom)\n8da525f Fix: recognise multiline comments as multiline arrays (fixes #9211) (#9369) (Phil Quinn)\nc581b77 Chore: Error => TypeError (#9390) (\u859b\u5b9a\u8c14\u7684\u732b)\nee99876 New: lines-between-class-members rule (fixes #5949) (#9141) (\u859b\u5b9a\u8c14\u7684\u732b)\n9d3f5ad Chore: report unused eslint-disable directives in ESLint codebase (#9371) (Teddy Katz)\n1167638 Update: add allowElseIf option to no-else-return (fixes #9228) (#9229) (Thomas Grainger)\n4567ab1 New: Add the fix-dry-run flag (fixes #9076) (#9073) (Rafa\u0142 Ruci\u0144ski)\n\n\n\nCommits\nThe new version differs by 32 commits.\n\n235c7dd 4.9.0\nb6f31a9 Build: changelog update for 4.9.0\n85388fb Fix: Correct error and test messages to fit config search path (#9428)\n62a323c Fix: Add class options for lines-around-comment (fixes #8564) (#8565)\n8eb4aae New: multiline-comment-style rule (fixes #8320) (#9389)\ndb41408 Chore: avoid applying eslint-env comments twice (#9278)\nfebb897 Chore: avoid loose equality assertions (#9415)\n2247efa Update: Add FunctionExpression to require-jsdoc (fixes #5867) (#9395)\n6791d18 Docs: Corrected noun to verb. (#9438)\nb02fbb6 Update: custom messages for no-restricted-* (refs #8400)\n02732bd Docs: Reorganized to avoid misunderstandings. (#9434)\nd9466b8 Docs: Correct time forecast for tests. (#9432)\nf7ed84f Docs: Add instruction re home-directory config files (refs #7729) (#9426)\n30d018b Chore: Add Aladdin-ADD & VictorHom to README (#9424)\n2d8a303 Docs: fix examples for prefer-numeric-literals (#9155)\n\nThere are 32 commits in total.\nSee the full diff\n\n. ## Version 4.10.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.10.0\n\nbb6e60a Fix: Improve the doc for no-restricted-modules rule (fixes #9437) (#9495) (vibss2397)\nc529de9 Docs: Amend rule document to correct and complete it (refs #6251). (#9498) (Jonathan Pool)\nf9c6673 Chore: Add tests to cover array and object values and leading commas. (#9502) (Jonathan Pool)\n9169258 Chore: remove npm run check-commit script (#9513) (Teddy Katz)\n7d390b2 Docs: Revise contributor documentation on issue labels. (#9469) (Jonathan Pool)\nd80b9d0 Fix: no-var don't fix globals (fixes #9520) (#9525) (Toru Nagashima)\nb8aa071 Fix: allow linting the empty string from stdin (fixes #9515) (#9517) (Teddy Katz)\n350a72c Chore: regex.test => string.startsWith (#9518) (\u859b\u5b9a\u8c14\u7684\u732b)\nde0bef4 Chore: remove obsolete eslintbot templates (#9512) (Teddy Katz)\n720b6d5 Docs: Update ISSUE_TEMPLATE.md (#9504) (\u859b\u5b9a\u8c14\u7684\u732b)\n2fa64b7 Fix: should not convert non-consecutive line comments to a single blo\u2026 (#9475) (\u859b\u5b9a\u8c14\u7684\u732b)\n9725146 Fix: multiline-comment-style fix produces invalid code (fixes #9461). (#9463) (\u859b\u5b9a\u8c14\u7684\u732b)\nb12cff8 Fix: Expected order of jsdoc tags (fixes #9412) (#9451) (Orlando Wenzinger)\nf054ab5 Docs: add .md to link (for github users) (#9501) (\u859b\u5b9a\u8c14\u7684\u732b)\n5ed9cfc Docs: Correct violations of \u201cVariable Declarations\u201d in Code Conventions (#9447) (Jonathan Pool)\n3171097 Docs: Clears confusion on usage of global and local plugins.(#9492) (Vasili Sviridov)\n3204773 Chore: enable max-len. (#9414) (\u859b\u5b9a\u8c14\u7684\u732b)\n0f71fef Docs: Unquote booleans in lines-between-class-members docs (#9497) (Brandon Mills)\nb3d7532 Docs: use consistent terminology & fix link etc. (#9490) (\u859b\u5b9a\u8c14\u7684\u732b)\n87db8ae Docs: Fix broken links (#9488) (gpiress)\n51bdb2f Docs: Incorrect link to related rule (#9477) (Gavin King)\n1a962e8 Docs: Add FAQ for when ESLint cannot find plugin (#9467) (Kevin Partington)\n8768b2d Fix: multiline-comment-style autofixer added trailing space (#9454) (Teddy Katz)\ne830aa1 Fix: multiline-comment-style reports block comments followed by code (#9450) (Teddy Katz)\nb12e5fe Docs: Repair broken links and add migration links. (#9473) (Jonathan Pool)\neca01ed Docs: Add missing info about special status of home-dir config files. (#9472) (Jonathan Pool)\neb8cfb1 Fix: change err report in constant condition (fixes #9398) (#9436) (Victor Hom)\nda77eb4 Chore: Revise no-config-file test to prevent false failure. (#9443) (Jonathan Pool)\n47e5f6f Docs: ensure \"good commit message\" examples actually follow guidelines (#9466) (Teddy Katz)\nebb530d Update: Don't ignore comments (no-trailing-spaces) (#9416) (Chris van Marle)\n5012661 Build: fix npm run profile script (fixes #9397) (#9455) (Teddy Katz)\necac0fd Docs: Remove blockBindings references (#9446) (Jan Pilzer)\n0b89865 Chore: ensure tests for internal rules get run (#9453) (Teddy Katz)\n052c504 Docs: suggest deleting branches after merging PRs (#9449) (Teddy Katz)\nb31e55a Chore: move internal rules out of lib/ (#9448) (Teddy Katz)\na7521e3 Docs: improve examples for multiline-comment-style (#9440) (Teddy Katz)\n\n\n\nCommits\nThe new version differs by 38 commits.\n\n9deb1b1 4.10.0\n6d19001 Build: changelog update for 4.10.0\nbb6e60a Fix: Improve the doc for no-restricted-modules rule (fixes #9437) (#9495)\nc529de9 Docs: Amend rule document to correct and complete it (refs #6251). (#9498)\nf9c6673 Chore: Add tests to cover array and object values and leading commas. (#9502)\n9169258 Chore: remove npm run check-commit script (#9513)\n7d390b2 Docs: Revise contributor documentation on issue labels. (#9469)\nd80b9d0 Fix: no-var don't fix globals (fixes #9520) (#9525)\nb8aa071 Fix: allow linting the empty string from stdin (fixes #9515) (#9517)\n350a72c Chore: regex.test => string.startsWith (#9518)\nde0bef4 Chore: remove obsolete eslintbot templates (#9512)\n720b6d5 Docs: Update ISSUE_TEMPLATE.md (#9504)\n2fa64b7 Fix: should not convert non-consecutive line comments to a single blo\u2026 (#9475)\n9725146 Fix: multiline-comment-style fix produces invalid code (fixes #9461). (#9463)\nb12cff8 Fix: Expected order of jsdoc tags (fixes #9412) (#9451)\n\nThere are 38 commits in total.\nSee the full diff\n\n. ## Version 4.11.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.11.0\n\nd4557a6 Docs: disallow use of the comma operator using no-restricted-syntax (#9585) (\u859b\u5b9a\u8c14\u7684\u732b)\nd602f9e Upgrade: espree v3.5.2 (#9611) (Kai Cataldo)\n4def876 Chore: avoid handling rules instances in config-validator (#9364) (Teddy Katz)\nfe5ac7e Chore: fix incorrect comment in safe-emitter.js (#9605) (Teddy Katz)\n6672fae Docs: Fixed a typo on lines-between-class-members doc (#9603) (Moinul Hossain)\n980ecd3 Chore: Update copyright and license info (#9599) (\u859b\u5b9a\u8c14\u7684\u732b)\ncc2c7c9 Build: use Node 8 in appveyor (#9595) (\u859b\u5b9a\u8c14\u7684\u732b)\n2542f04 Docs: Add missing options for lines-around-comment (#9589) (Cl\u00e9ment Fiorio)\nb6a7490 Build: ensure fuzzer tests get run with npm test (#9590) (Teddy Katz)\n1073bc5 Build: remove shelljs-nodecli (refs #9533) (#9588) (Teddy Katz)\n7e3bf6a Fix: edge-cases of semi-style (#9560) (Toru Nagashima)\ne5a37ce Fix: object-curly-newline for flow code (#9458) (Tiddo Langerak)\n9064b9c Chore: add equalTokens in ast-utils. (#9500) (\u859b\u5b9a\u8c14\u7684\u732b)\nb7c5b19 Fix: Correct [object Object] output of error.data. (#9561) (Jonathan Pool)\n51c8cf0 Docs: Disambiguate definition of Update tag (#9584) (Jonathan Pool)\nafc3c75 Docs: clarify what eslint-config-eslint is (#9582) (Teddy Katz)\naedae9d Docs: fix spelling in valid-typeof example (#9574) (Maksim Degtyarev)\n4c5aaf3 Docs: Fix typo in no-underscore-dangle rule (#9567) (Fabien Lucas)\n3623600 Chore: upgrade ajv@5.3.0 (#9557) (\u859b\u5b9a\u8c14\u7684\u732b)\n1b606cd Chore: Remove an indirect dependency on jsonify (#9444) (Rouven We\u00dfling)\n4d7d7ab Update: Resolve npm installed formatters (#5900) (#9464) (Tom Erik St\u00f8wer)\naccc490 Fix: Files with no failures get \"passing\" testcase (#9547) (Samuel Levy)\nab0f66d Docs: Add examples to better show rule coverage. (#9548) (Jonathan Pool)\n88d2303 Chore: Add object-property-newline tests to increase coverage. (#9553) (Jonathan Pool)\n7f37b1c Build: test Node 9 on Travis (#9556) (Teddy Katz)\nacccfbd Docs: Minor rephrase in no-invalid-this. (#9542) (Francisc)\n8f9c0fe Docs: improve id-match usage advice (#9544) (Teddy Katz)\na9606a3 Fix: invalid tests with super (fixes #9539) (#9545) (Teddy Katz)\n8e1a095 Chore: enable a modified version of multiline-comment-style on codebase (#9452) (Teddy Katz)\ncb60285 Chore: remove commented test for HTML formatter (#9532) (Teddy Katz)\n06b491e Docs: fix duplicate entries in changelog (#9530) (Teddy Katz)\n2224733 Chore: use eslint-plugin-rulesdir instead of --rulesdir for self-linting (#9164) (Teddy Katz)\n9cf4ebe Docs: add .md to link(for github users) (#9529) (\u859b\u5b9a\u8c14\u7684\u732b)\n\n\n\nCommits\nThe new version differs by 35 commits.\n\n1a9a6a5 4.11.0\nef4d268 Build: changelog update for 4.11.0\nd4557a6 Docs: disallow use of the comma operator using no-restricted-syntax (#9585)\nd602f9e Upgrade: espree v3.5.2 (#9611)\n4def876 Chore: avoid handling rules instances in config-validator (#9364)\nfe5ac7e Chore: fix incorrect comment in safe-emitter.js (#9605)\n6672fae Docs: Fixed a typo on lines-between-class-members doc (#9603)\n980ecd3 Chore: Update copyright and license info (#9599)\ncc2c7c9 Build: use Node 8 in appveyor (#9595)\n2542f04 Docs: Add missing options for lines-around-comment (#9589)\nb6a7490 Build: ensure fuzzer tests get run with npm test (#9590)\n1073bc5 Build: remove shelljs-nodecli (refs #9533) (#9588)\n7e3bf6a Fix: edge-cases of semi-style (#9560)\ne5a37ce Fix: object-curly-newline for flow code (#9458)\n9064b9c Chore: add equalTokens in ast-utils. (#9500)\n\nThere are 35 commits in total.\nSee the full diff\n\n. ## Version 4.12.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.12.0\n\n76dab18 Upgrade: doctrine@^2.0.2 (#9656) (Kevin Partington)\n28c9c8e New: add a Linter#defineParser function (#9321) (Ives van Hoorne)\n5619910 Update: Add autofix for sort-vars (#9496) (Trevin Hofmann)\n71eedbf Update: add beforeStatementContinuationChars to semi (fixes #9521) (#9594) (Toru Nagashima)\n4118f14 New: Adds implicit-arrow-linebreak rule (refs #9510) (#9629) (Sharmila Jesupaul)\n208fb0f Fix: Use XML 1.1 on XML formatters (fixes #9607) (#9608) (Daniel Reigada)\n6e04f14 Upgrade: globals to 11.0.1 (fixes #9614) (#9632) (Toru Nagashima)\ne13d439 Fix: space-in-parens crash (#9655) (Toru Nagashima)\n92171cc Docs: Updating migration guide for single-line disable (#9385) (Justin Helmer)\nf39ffe7 Docs: remove extra punctuation from readme (#9640) (Teddy Katz)\na015234 Fix: prefer-destructuring false positive on \"super\" (fixes #9625) (#9626) (Kei Ito)\n0cf081e Update: add importNames option to no-restricted-imports (#9506) (Benjamin R Gibson)\n332c214 Docs: Add @platinumazure to TSC (#9618) (Ilya Volodin)\n\n\n\nCommits\nThe new version differs by 15 commits.\n\nf4a65c6 4.12.0\n1cd1627 Build: changelog update for 4.12.0\n76dab18 Upgrade: doctrine@^2.0.2 (#9656)\n28c9c8e New: add a Linter#defineParser function (#9321)\n5619910 Update: Add autofix for sort-vars (#9496)\n71eedbf Update: add beforeStatementContinuationChars to semi (fixes #9521) (#9594)\n4118f14 New: Adds implicit-arrow-linebreak rule (refs #9510) (#9629)\n208fb0f Fix: Use XML 1.1 on XML formatters (fixes #9607) (#9608)\n6e04f14 Upgrade: globals to 11.0.1 (fixes #9614) (#9632)\ne13d439 Fix: space-in-parens crash (#9655)\n92171cc Docs: Updating migration guide for single-line disable (#9385)\nf39ffe7 Docs: remove extra punctuation from readme (#9640)\na015234 Fix: prefer-destructuring false positive on \"super\" (fixes #9625) (#9626)\n0cf081e Update: add importNames option to no-restricted-imports (#9506)\n332c214 Docs: Add @platinumazure to TSC (#9618)\n\nSee the full diff\n\n. ## Version 4.12.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.12.1\n\n1e362a0 Revert \"Fix: Use XML 1.1 on XML formatters (fixes #9607) (#9608)\" (#9667) (Kevin Partington)\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n58216b6 4.12.1\nfc9d27b Build: changelog update for 4.12.1\n1e362a0 Revert \"Fix: Use XML 1.1 on XML formatters (fixes #9607) (#9608)\" (#9667)\n\nSee the full diff\n\n. ## Version 8.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv8.0.1\nv8.0.1\nHandle optionalCatchBinding: #521\n\n\nCommits\nThe new version differs by 2 commits.\n\n6c7e3d0 8.0.1\n5742b71 Adding optionalCatchBinding to plugins. (#521)\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.0.1\n4.0.1 / 2017-10-05\n\ud83d\udc1b Fixes\n\n#3051: Upgrade Growl to v1.10.3 to fix its peer dep problems (@dpogue)\n\n\n\nCommits\nThe new version differs by 6 commits.\n\neb8bf8d Release v4.0.1\n3b485ea update CHANGELOG.md for v4.0.1 [ci skip]\n96e5c1a upgrade eslint to v4.8.0\nd7cff37 Update growl to 1.10.3\n0cdd921 remove preversion script; test on publish; closes #2999\nf49c0ce Fix changelog issues/pr URLs (#3047)\n\nSee the full diff\n\n. ## Version 4.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.1.0\n4.1.0 / 2017-12-28\nThis is mainly a \"housekeeping\" release.\nWelcome @Bamieh and @xxczaki to the team!\n\ud83d\udc1b: Fixes\n\n#2661: progress reporter now accepts reporter options (@canoztokmak)\n#3142: xit in bdd interface now properly returns its Test object (@Bamieh)\n#3075: Diffs now computed eagerly to avoid misinformation when reported (@abrady0)\n#2745: --help will now help you even if you have a mocha.opts (@Zarel)\n\n\ud83c\udf89 Enhancements\n\n#2514: The --no-diff flag will completely disable diff output (@CapacitorSet)\n#3058: All \"setters\" in Mocha's API are now also \"getters\" if called without arguments (@makepanic)\n\n\ud83d\udcd6 Documentation\n\n#3170: Optimization and site speed improvements (@Munter)\n#2987: Moved the old site repo into the main repo under docs/ (@boneskull)\n#2896: Add maintainer guide (@boneskull)\nVarious fixes and updates (@xxczaki, @maty21, @leedm777)\n\n\ud83d\udd29 Other\n\nTest improvements and fixes (@eugenet8k, @ngeor, @38elements, @Gerhut, @ScottFreeCode, @boneskull)\nRefactoring and cruft excision (@38elements, @Bamieh, @finnigantime, @boneskull)\n\n\n\nCommits\nThe new version differs by 409 commits.\n\n6b9ddc6 Release v4.1.0\n3c4b116 update CHANGELOG for v4.1.0\n5be22b2 options.reporterOptions are used for progress reporter\nea96b18 add .fossaignore [ci skip]\nadc67fd Revert \"[ImgBot] optimizes images (#3175)\"\nae3712c [ImgBot] optimizes images (#3175)\n33db6b1 Use x64 node on appveyor\n4a6e095 Run appveyor tests on x64 platform. Might enable sharp installation\n3abed9b Lint netlify-headers script\n119543e Add preconnect for doubleclick domain that google analytics results in contacting\nbd5109e Remove crossorigin='anonymous' from preconnect hints. Only needed for fonts, xhr and es module loads\n123ee4f Handle the case where all avatars are already loaded at the time when the script exexecutes\n64deadc Specific value for inlining htmlimages to guarantee logo is inlined\n8f1ded4 https urls where possible\nd5a5125 Be explicit about styling of screenshot images\n\nThere are 250 commits in total.\nSee the full diff\n\n. After pinning to 3.5.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 2.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\ne1177ec 2.2.2\ne2a4aa4 fix .visible when called after .enable is set to false\nede3103 add failing test for .visible bug\n6adf579 2.2.1\ndc092b4 Add .visible for emitting text only when enabled (fixes #192)\n4372d27 Add Awesome mentioned badge\n\nSee the full diff\n\n. ## Version 2.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv2.3.0\n\nAdded a .visible() method for emitting text only when Chalk is enabled. This can be useful for purely cosmetic content that shouldn't be shown when there are no colors, like when piping the output. dc092b4\nTypeScript type definitions improvements. 7be154c\n\nv2.2.0...v2.3.0\n\n\nCommits\nThe new version differs by 2 commits.\n\n14e0aa9 2.3.0\n7be154c TypeScript fixes (#217)\n\nSee the full diff\n\n. ## Version 4.13.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.13.1\n\nb72dc83 Fix: eol-last allow empty-string to always pass (refs #9534) (#9696) (Kevin Partington)\nd80aa7c Fix: camelcase destructure leading/trailing underscore (fixes #9700) (#9701) (Kevin Partington)\nd49d9d0 Docs: Add missing period to the README (#9702) (Kevin Partington)\n4564fe0 Chore: no-invalid-meta crash if no export assignment (refs #9534) (#9698) (Kevin Partington)\n\n\n\nCommits\nThe new version differs by 6 commits.\n\n234cd26 4.13.1\n3b0833f Build: changelog update for 4.13.1\nb72dc83 Fix: eol-last allow empty-string to always pass (refs #9534) (#9696)\nd80aa7c Fix: camelcase destructure leading/trailing underscore (fixes #9700) (#9701)\nd49d9d0 Docs: Add missing period to the README (#9702)\n4564fe0 Chore: no-invalid-meta crash if no export assignment (refs #9534) (#9698)\n\nSee the full diff\n\n. After pinning to 8.0.3 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. ## Version 8.1.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 2 commits.\n\nd84b236 8.1.1\ne4bed5a Fix: Prevent parseForESLint() behavior from changing after parse() is called (fixes #558)(#559)\n\nSee the full diff\n\n. ## Version 8.1.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 3 commits.\n\n36bf8b4 8.1.2\n5aaf0e1 Fix: add Literal type to visitorKeys (#562)\nbf9092a Fix: ignore eval (fixes #560) (#561)\n\nSee the full diff\n\n. After pinning to 4.1.4 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 2.3.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 4.3.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 2.3.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 5.0.5 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 5.0.5 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 2.3.2 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 2.3.2 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 5.1.0 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 5.1.0 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. ## Version 5.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n68883b0 Update docs/changelog.md and set new release id in docs/_config.yml\n6c20e74 Add release documentation for v5.0.2\n415c78f 5.0.2\n1a31c0e Update History.md and AUTHORS for new release\n6b47a83 Fix #1770: Reset history on sandbox reset\n7d1eff1 Remove bithound (#1773)\n32484d2 Fix broken link in docs\n93d182f Add link to sinon.replace from fake\n92dc963 Add missing links for documentation\n\nSee the full diff\n\n. ## Version 5.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n5155c01 Update docs/changelog.md and set new release id in docs/_config.yml\n75ffac0 Add release documentation for v5.0.3\n347eeb5 5.0.3\n454d77d Update History.md and AUTHORS for new release\n2a3696d Fix #1775: Default sandbox does not restore stubs, spies, mocks\n724dd6c Improve documentation for fakes\nf45dc6e Removed unused link to the google group\n80eca7a Update home page to use fakes for the examples\n57fac55 Fix syntax error in example\n\nSee the full diff\n\n. ## Version 5.0.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 12 commits.\n\n374f593 Update docs/changelog.md and set new release id in docs/_config.yml\nf298d51 Add release documentation for v5.0.5\n90a4212 5.0.5\n7055663 Update History.md and AUTHORS for new release\ne5b43de Refuse to replace already replaced values\nd4467e7 Update docs/changelog.md and set new release id in docs/_config.yml\n7e08393 Add release documentation for v5.0.4\n6fcf7b2 5.0.4\nb8d65ff Update History.md and AUTHORS for new release\n3a66331 Fix #1781: Reject non-function values a f argument to fake\n5503f73 Remove node@4, add node@10\ncfccaf3 Update migration-guides.md\n\nSee the full diff\n\n. ## Version 5.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\nc0eb019 Update docs/changelog.md and set new release id in docs/_config.yml\n4b33872 Add release documentation for v5.0.6\n2d6900d 5.0.6\na22c3f0 Update History.md and AUTHORS for new release\n8f34417 Remove support-sinon.js as postinstall\n\nSee the full diff\n\n. ## Version 5.0.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 17 commits.\n\n3685ee4 Update docs/changelog.md and set new release id in docs/_config.yml\n6b5d7fb Add release documentation for v5.0.8\n94f9264 5.0.8\nbe117c7 Update History.md and AUTHORS for new release\n9c64c8f Merge pull request #1803 from jdalton/is-es-module.js\n5983a6d Add isSealed check to is-es-module.\ne2c7132 Update markdownlint-cli\n082f8e8 Update dependencies to appropriate semver-minor versions\na321764 Fix sandbox documentation\nb578cf7 Update insecure dependencies\n96b7cad Update issue templates\nec00981 Typo'd fake to fakes\n43c45c8 Update docs/changelog.md and set new release id in docs/_config.yml\n431dab9 Add release documentation for v5.0.7\ne4d1899 5.0.7\n\nThere are 17 commits in total.\nSee the full diff\n\n. ## Version 5.0.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 17 commits.\n\n3685ee4 Update docs/changelog.md and set new release id in docs/_config.yml\n6b5d7fb Add release documentation for v5.0.8\n94f9264 5.0.8\nbe117c7 Update History.md and AUTHORS for new release\n9c64c8f Merge pull request #1803 from jdalton/is-es-module.js\n5983a6d Add isSealed check to is-es-module.\ne2c7132 Update markdownlint-cli\n082f8e8 Update dependencies to appropriate semver-minor versions\na321764 Fix sandbox documentation\nb578cf7 Update insecure dependencies\n96b7cad Update issue templates\nec00981 Typo'd fake to fakes\n43c45c8 Update docs/changelog.md and set new release id in docs/_config.yml\n431dab9 Add release documentation for v5.0.7\ne4d1899 5.0.7\n\nThere are 17 commits in total.\nSee the full diff\n\n. ## Version 5.0.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n86b930c Update docs/changelog.md and set new release id in docs/_config.yml\n033aa60 Add release documentation for v5.0.9\n3321085 5.0.9\n9f321d5 Update History.md and AUTHORS for new release\ne862196 Upgrade @std/esm to esm.\n\nSee the full diff\n\n. ## Version 5.0.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n86b930c Update docs/changelog.md and set new release id in docs/_config.yml\n033aa60 Add release documentation for v5.0.9\n3321085 5.0.9\n9f321d5 Update History.md and AUTHORS for new release\ne862196 Upgrade @std/esm to esm.\n\nSee the full diff\n\n. After pinning to 5.1.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 6.0.0 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 3.2.1 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. ## Version 3.3.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 8 commits ahead by 8, behind by 11.\n\nfe4ae79 chore(release): 3.3.2\n305d877 fix: typo\ne134f0d chore(release): 3.3.1\nf2a60f2 fix: fix #284 by setting function name in try-catch\nc662540 chore(release): 3.3.0\nd9033cf fix: fix #229\n5d0c7af chore: fixup CHANGELOG\n48ef127 Publish v3.3.0 (#283)\n\nSee the full diff\n\n. ## Version 0.15.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.15.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.15.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.15.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. - The devDependency knex was updated from 0.14.6 to 0.16.0.\nUpdate to this version instead \ud83d\ude80. - The devDependency knex was updated from 0.14.6 to 0.16.1.\nUpdate to this version instead \ud83d\ude80. - The devDependency knex was updated from 0.14.6 to 0.16.2.\nUpdate to this version instead \ud83d\ude80. - The devDependency knex was updated from 0.14.6 to 0.16.3.\nUpdate to this version instead \ud83d\ude80. - The devDependency lint-staged was updated from 7.3.0 to 8.0.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v8.0.1\n8.0.1 (2018-10-29)\nBug Fixes\n\ngit: Use resolveGitDir to resolve to .git for git commands (#518) (da42f8a), closes #514\n\n\n\nCommits\nThe new version differs by 2 commits.\n\nda42f8a fix(git): Use resolveGitDir to resolve to .git for git commands (#518)\n592486f docs: Update readme to include info about partially staged files support\n\nSee the full diff\n\n. - The devDependency lint-staged was updated from 7.3.0 to 8.0.2.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v8.0.2\n8.0.2 (2018-10-29)\nBug Fixes\n\ngit: Use resolveGitDir in hasPartiallyStagedFiles (#520) (af99172), closes #514\n\n\n\nCommits\nThe new version differs by 1 commits.\n\naf99172 fix(git): Use resolveGitDir in hasPartiallyStagedFiles (#520)\n\nSee the full diff\n\n. - The devDependency lint-staged was updated from 7.3.0 to 8.0.3.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v8.0.3\n8.0.3 (2018-10-30)\nBug Fixes\n\nAllow to use lint-staged on CI (#523) (225a904)\n\n\n\nCommits\nThe new version differs by 1 commits.\n\n225a904 fix: Allow to use lint-staged on CI (#523)\n\nSee the full diff\n\n. - The devDependency lint-staged was updated from 7.3.0 to 8.0.4.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v8.0.4\n8.0.4 (2018-10-31)\nBug Fixes\n\npackage: update staged-git-files to version 1.1.2 (ce434d3)\n\n\n\nCommits\nThe new version differs by 6 commits.\n\n5e165a3 Merge pull request #513 from okonet/greenkeeper/staged-git-files-1.1.2\n07fd087 Merge branch 'master' into greenkeeper/staged-git-files-1.1.2\n00047de docs: fix typo (#527)\nbedba5a refactor: Use object spread (#524)\nc4e8a2d chore(package): update lockfile yarn.lock\nce434d3 fix(package): update staged-git-files to version 1.1.2\n\nSee the full diff\n\n. - The devDependency mocha was updated from 5.2.0 to 6.0.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v6.0.1\n6.0.1 / 2019-02-21\nThe obligatory round of post-major-release bugfixes.\n\ud83d\udc1b Fixes\nThese issues were regressions.\n\n#3754 - Mocha again finds test.js when run without arguments (@plroebuck)\n#3756 - Mocha again supports third-party interfaces via --ui (@boneskull)\n#3755 - Fix broken --watch (@boneskull)\n#3759 - Fix unwelcome deprecation notice when Mocha run against languages (CoffeeScript) with implicit return statements; returning a non-undefined value from a describe callback is no longer considered deprecated (@boneskull)\n\n\ud83d\udcd6 Documentation\n\n#3738 - Upgrade to @mocha/docdash@2 (@tendonstrength)\n#3751 - Use preferred names for example config files (@Szauka)\n\n\n\nCommits\nThe new version differs by 9 commits.\n\n6d3d6b4 Release v6.0.1\n2146ece update CHANGELOG.md for v6.0.1\n7c9221d backout deprecation of value returned from suite; closes #3744\nb7cfceb fix --watch not finding any files to execute; closes #3748\nb836d73 Upgrade docdash version - issue #3663\n7926f47 fix --ui issues, closes #3746\n00f2ed9 dev dep upgrades from \"npm audit\" and \"npm upgrade\"\n34afb1a fix(cli/run.js): Revert default glob to match Mocha-5.2\n6d5a0db Bring the example congfiguration file in line with the documentation. (#3751)\n\nSee the full diff\n\n. ",
    "pldin601": "I created a bookshelf plugin to solve this issue https://www.npmjs.com/package/bookshelf-cls-transaction. ",
    "jasonvillalon": "Hi,\nThank you for reply.\ni already tried to convert it on parse. sorry i didnt mention it. thing is that my schema is something like this:\nid: uuid\nparent_id: uuid\njavascript\nsubmodules() {\n  return this.hasMany(Modules, 'parent_id', 'id');\n}\nand when i fetch the records using\njavascript\n.fetchAll({withRelated: ['submodules', 'submodules.submodules']\ni receive error that the encrypted id is not a valid uuid since it is encoded. looks like i cannot format ids on parse when there is related hasMany in model.\nis there a way to decode the id before passing them when fetching related records?\nthanks in advance. Hi!\nThank you for your reply. the combination of your 2 suggestions solved my problem.\nwhat happen is all primary keys which is \"id\" is added as hidden using visiblity plugin\nand all the foreign keys are manually encoded and decoded in parse and format methods.\nencoding and decoding id (primary key) in parse and format will cause of unpopulated related records.\nand the reason why i cannot add the foreign keys in hidden is that it will not being populated when fetching withRelated.\nAll in all. thank you very much. closing this issue now.\nBest Regards,\nJason Villalon. ",
    "ammonshepherd": "I figured it out after all. I can access the data when I add tools.location to the query:\nCategories.forge().orderBy('name', 'ASC').fetchAll({withRelated: ['tools', 'tools.location']}).then(function(categories) {\n    data = categories.JSON;\n    res.send(data);\n});. ",
    "cmallet": "Yes, I want to change the aircraft within a given leg.\nI fetched them both (actually I have all the aircrafts), and i want to replace the leg aircraft. \nBasically I would assume I can set it, just like changing an attribute by calling aircraft.set('attr', value) . But relations seems to behave differently.\nNow I don't know if that's appropriate, but I don't want to update anything in the database yet. I want to work with this modified leg before saving it, and manipulate it by calling leg.related('aircraft'). I need this to return the latest aircraft assigned, updated or not.. \nHope this makes it clearer, thank you. OK.. I've tried set and experienced that the relation was actually not change. Is it the same API as for attributes, using set('relationName', relation) ?\nHere's my test :\nlogger.debug(leg.related('aircraft').get('registration')); // XXX\nleg.set('aircraft', aircraft);\nlogger.debug(aircraft.get('registration')); // YYY\nlogger.debug(leg.related('aircraft').get('registration')); // still XXX. ",
    "rapzo": "leg.related('aircraft').set(<aircraft payload>)\nThis is documented in the docs.. Dunno if this is a closed business already but, as said before, y'all can count me in.\nI've a couple projects that depend on bookshelf and it won't change that in a near future so, helping out and bringing new stuff in can be high in my priorities' stack.. Cheers mate!\nOn Tue, Oct 31, 2017, 19:15 Matthew Hardwick notifications@github.com\nwrote:\n\n@rapzo https://github.com/rapzo\nI'll add you to the maintainers list.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/issues/1660#issuecomment-340876974,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAJBTN4CGjXR6nExWWYmvrRgMKPWy8sSks5sx3G2gaJpZM4P3UAG\n.\n. I got a vagrant running a lts ubuntu version without much hassle.\nI'll try to put up a Vagrantfile with bash commands that ease the testing\nsetup as soon as i find the time (prolly weekends).\n\nOn Mon, Oct 16, 2017 at 10:18 PM, Adam Cofer notifications@github.com\nwrote:\n\nhttps://www.npmjs.com/package/mock-knex seems to work well in the first\ncouple of unit tests I've written with it, FWIW.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/issues/1661#issuecomment-337046312,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAJBTKPi4KuiThSEZX4tVMOLpcZAlHG0ks5ss8gIgaJpZM4P3aWf\n.\n\n\n-- \nRui Pedro Lima\n. +1\nOn Tue, Oct 17, 2017, 12:23 Ricardo Gra\u00e7a notifications@github.com wrote:\n\n@mrhwick https://github.com/mrhwick So, if Bookshelf abstracts the\ndatabase interface details shouldn't the query builder interface be\nremoved? Currently that's a source for a lot of confusion since you have to\nuse actual database column names when accessing the query builder, whereas\nBookshelf aliased column names are used everywhere else. It's also not\nclear when you're using Bookshelf model methods and Knex methods in case if\nyou're a new user.\nThe only problem with that is that Bookshelf would become very limited in\nwhat it can do if users are suddenly unable to access Knex methods. Maybe\nthis just means that Bookshelf should implement the functionality that is\nmissing instead of forcing users to use the query builder.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/issues/1661#issuecomment-337200849,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAJBTHO83XTh6pbCXvuv9okQfQZ2up3Nks5stI5LgaJpZM4P3aWf\n.\n. If i'm not mistaken with what i did, it will invoke the now, which boils\ndown to when the save is about to occur.\n\nOn Tue, Oct 17, 2017 at 11:06 AM, Ricardo Gra\u00e7a notifications@github.com\nwrote:\n\nWith your proposal what would happen if I retrieve a model from the\ndatabase, manually change the updated_at timestamp and then save the\nmodel without setting the forceTimestamps option? And what would happen\nif I do the same thing but without manually changing updated_at?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/pull/1667#issuecomment-337183388,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAJBTFXIqeAsu0Zjp7P4ZNRIQmFtwkmxks5stHwWgaJpZM4P7XpQ\n.\n\n\n-- \nRui Pedro Lima\n. Now that you mention it, i probably should add more tests to it...\nBut mainly was, if the timestamp keys are in the payload and save doesn't\nhave the option, the timestamps will be regenerated, for context, the\nupdated_at, and override what came from what the service is connected to.\nPersonally i don't trust the payload. One should never do. And after the\nbump we had to force that those columns are blacklisted from the payload\nbefore getting into a save/update process.\nAgain, it's a proposal, more than anything. If everybody are happy with the\ncurrent behaviour i'll close it. But IMHO, i don't agree to what is\ncurrently happening. I prefer the updated_at to be updated closely to the\nactual database write than anything else.\nOn Tue, Oct 17, 2017 at 11:16 AM, Rui Pedro Lima ruipedro.lima@gmail.com\nwrote:\n\nIf i'm not mistaken with what i did, it will invoke the now, which boils\ndown to when the save is about to occur.\nOn Tue, Oct 17, 2017 at 11:06 AM, Ricardo Gra\u00e7a notifications@github.com\nwrote:\n\nWith your proposal what would happen if I retrieve a model from the\ndatabase, manually change the updated_at timestamp and then save the\nmodel without setting the forceTimestamps option? And what would happen\nif I do the same thing but without manually changing updated_at?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/pull/1667#issuecomment-337183388,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAJBTFXIqeAsu0Zjp7P4ZNRIQmFtwkmxks5stHwWgaJpZM4P7XpQ\n.\n\n\n--\nRui Pedro Lima\n\n\n-- \nRui Pedro Lima\n. Yes. You just put it out with better words!\nBasically i'm trying to bring back the old behaviour but allowing to keep\nthe current if the flag is set (for those who want it or find it useful).\nOn Tue, Oct 17, 2017 at 11:37 AM, Ricardo Gra\u00e7a notifications@github.com\nwrote:\n\n... the timestamps will be regenerated, for context, the updated_at, and\noverride what came from what the service is connected to.\nI don't understand what you mean by \"regenerated\". It's also not very\nclear what you mean by \"what the service is connected to\". What service?\nI'm also not too sure what is the current timestamp behavior but I'm\nalmost certain the old behavior (prior to version 0.10.4) was correct and\nwhat most people expected. Not sure why it was changed.\nSo, with your change it will be required to set forceTimestamps in order\nfor a user to manually change any of the created_at or updated_at columns\nright? However updated_at will still be updated automatically each time a\nmodel is saved?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/pull/1667#issuecomment-337190810,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAJBTKyQ9y0eRQTLGve_d4WJPESwDjNLks5stINrgaJpZM4P7XpQ\n.\n\n\n-- \nRui Pedro Lima\n. Can you provide some dummy seeds to probe this out?. Can you share some code, in runkit for example. I use bookshelf with koa works alright.. If it helps in some way, run your code with DEBUG=knex:tx,knex:query,knex:bindings. It will give you a clear picture of what goes in a transaction and what doesn't.\nFrom an empiric stand point, i'd say you're missing {transacting} in the options object in the midst of queries inside the transaction.\nPlease add some real case example otherwise we should close the issue.. SQLite tests run in memory so i don't think the overhead of opening a random port and piping data into the container worth the hassle.\nI'll give a try patching with this image in https://hub.docker.com/r/azeemdin/oracledb/ although it doesn't look official and might lack support down the line.\nBut shouldn't it be engine independent? I mean, that's knex territory, right?\n. Travis uses docker for running its tests https://travis-ci.org/bookshelf/bookshelf/jobs/295316556#L33\nBut i'll look into, trying to get builds from my fork with a similar config. Will get back here when i get some results.. Been trying some mixed configs into this but it looks like travis is, somehow, using 3306 and 5432 already for no reason. Maybe we should have each node version tests to run in a container as well, that way we use docker to connect themselves instead of using travis stuff.\nKnex's dudes are into it as well, maybe i'll try and extend there as well.\nOne problem though, that oracledb stuff... It cries because a container doesn't have 1GB of memory available... Won't be easy.. Can you elaborate a bit more the question?. I'll give a round on this, although, we could move the format up a bit instead of running it twice, even for a single key, it looks harder to read than it'd be with a single call.. Did you try sessions().where() ?\nP.S.: I'd advise you to use bookshelf's registry or you may end up with\ncircular dependencies.\nOn Thu, Dec 7, 2017, 09:56 Jefrey Sobreira Santos notifications@github.com\nwrote:\n\nI'm following the docs to do the following:\nvar sessions = require('../models/sessions.js');\n        var users = require('../models/users.js');\n    sessions.where('key', sess_key).fetchOne({withRelated: ['users']}).then(function(row) {\n        callback(false, row.related('users'));\n    }).catch(function(err) {\n        callback(err);\n    });\n\nBut this is what I get:\nTypeError: sessions.where is not a function\nsessions.js is:\nmodule.exports = function() {\n    return global.db.bookshelf.Model.extend({\n        tableName: 'sessions',\n        hasTimestamps: true\n    });\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/issues/1704, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAJBTJ2ATdldflLofjBnLEkdQcm0vDkuks5s97ZCgaJpZM4Q5Rru\n.\n. \n",
    "syakuronabdan": "Got it.\n\nIt's outputting exactly what you told it to.\n\nIt should be\nselect id_dropshipper , nama_produk ...\nInstead of\nselect count(distinct \"produk\".\"id_produk\")\nWhich would only give me 1 column, thus has different number of column with the union. ",
    "AmrSalama": "@ricardograca Tanks for your replay,\nThe relation keys is in the User model authenticatable_type, authenticatable_type its polymorphic relation.\nI tried to see if the mentioned line is triggered or not, and this part of code is reached !\nhttps://github.com/bookshelf/bookshelf/blob/c872a96c20616a18eb6aa47e361b6ec82b2d7269/src/sync.js#L151\noptions.columns return undefined !. ",
    "mihaicracan": "I've got your point but actually the relations are defined on the Bookshelf level, right? Because under User model we are describing the relation like:\ncountries() {\n    return this.belongsToMany('Country', 'UserCountryMapping', 'userId', 'countryId');\n} \nMaybe my solution it's not the one, but there would have to be a way to retrieve all users which have a country named \"X\" without using the INNER JOINs, because this defeats the purpose of modeling relations under each Model.\nMaybe something like this then:\nUser.whereHas('Country', q => {\n    q.where('name', 'France');\n});\n.fetchAll()\nWhat is your opinion on the basics of the point?. I have a better understanding of the situation now. Thank you for your time and attention, Ricardo!. ",
    "mfbx9da4": "\u251c\u2500 bookshelf@0.10.3. \ud83d\udc4d \n. ",
    "abZameen": "Thanks for the reference @ricardograca . ",
    "gjuchault": "Well the example was supposed to clarify the example. It's customizing the join table. A three-way relationship is adding a relation between the join table and another table.\nSomething like:\nUser [n:n] Page {through} PageManager\nPageManager [1:1] Role\nWe have the join table PageManager, that could have a relationship to Page.. ",
    "acofer": "https://www.npmjs.com/package/mock-knex seems to work well in the first couple of unit tests I've written with it, FWIW.. ",
    "vieiralucas": "I would like this to work:\n```js\n/\n * user schema:\n *   email: string not null\n *   name: string\n/\nconst user = await User.forge({email: 'email@domain.com'}).save()\nconsole.log(user.toJSON())\n// this is what I get: { \"email\": \"email@domain.com\" }\n// this is what I want: { \"email\": \"email@domain.com\", \"name\": null }\n```\nMy question is: Is this issue about this feature?\n. Yes, because my schema doesn't say that it is a not null field, so in the database it is set to null and I want to know this after the save call\nSame applies for defaults, imagine that name defaults to empty string\n```js\n/\n * user schema:\n *   email: string not null\n *   name: string default ''\n /\nconst user = await User.forge({email: 'email@domain.com'}).save()\nconsole.log(user.toJSON())\n// this is what I get: { \"email\": \"email@domain.com\" }\n// this is what I want: { \"email\": \"email@domain.com\", \"name\": \"\" }\n. Currently I would need to call `refresh` after `save`\nBut I want to avoid going two times to the database if possible.. Yeah, but as the issue suggests, can we support it and fallback to calling `refresh`?\nMaybe like this:js\nconst user = await User.forge({ email: 'email@domain.com' }).save({ withRefresh: true })\n```\nAnd this will avoid two trips when PostgreSQL but fallback to calling refresh before resolving the Promise. I'll take a look at the plugin. May I try to work on this and perhaps send a PR?. May I try to work on this and perhaps send a PR?. ",
    "the-gardener": "I've got the same problem when product.id is defined as idAttribute in the Model.. @ricardograca I am not sure about that. Just want to make it clear that I am using bookshelf model along with query builder and got this problem when I set product.id as idAttribute in the model. Without the idAttribute, I got expected result.. ",
    "osher": "thanks.... BTW - it would be helpful to mention format in the doc on parse and vise versa. P.S - I don't know if it matters, we're using Bookshelf.plugin(['registry','visibility'])\nLMK if more information is needed to diagnose / solve. I think the bug is here:\nhttps://github.com/bookshelf/bookshelf/blob/master/src/sync.js#L200\n198> update: Promise.method(function(attrs) {\n199>    const syncing = this.syncing, query = this.query;\n200>    if (syncing.id != null) query.where(syncing.idAttribute, syncing.id);\n201>    if (_.filter(query._statements, {grouping: 'where'}).length === 0) {\n202>      throw new Error('A model cannot be updated without a \"where\" clause or an idAttribute.');\n203>    }\n204>    return query.update(syncing.format(_.extend(Object.create(null), attrs)));\n205>  }),\nI can see same problem with .del()\nhttps://github.com/bookshelf/bookshelf/blob/master/src/sync.js#L210. For anybody that met the bug and is waiting for the fix - add this to your project.\nThis be applied before bookshelf is used\n```javascript\n{ //FIX: https://github.com/bookshelf/bookshelf/issues/1676\n  //TBD: remove when the issue is closed\n  const filter = require('lodash/filter');\n  const extend = require('lodash/extend');\n  const Promise = require('bluebird');\n  Object.assign(require('bookshelf/lib/sync').prototype, {\n    update: Promise.method(function (attrs) {\n      var syncing = this.syncing,\n          query = this.query;\n      //FIX\n      if (syncing.id != null) query.where(syncing.format({[syncing.idAttribute]: syncing.id}));\n      //FIXEnd\n      if (filter(query._statements, { grouping: 'where' }).length === 0) {\n        throw new Error('A model cannot be updated without a \"where\" clause or an idAttribute.');\n      }\n      return query.update(syncing.format(extend(Object.create(null), attrs)));\n    }),\n// Issues a `delete` command on the query.\ndel: Promise.method(function () {\n  var query = this.query,\n      syncing = this.syncing;\n  //FIX\n  if (syncing.id != null) query.where(syncing.format({[syncing.idAttribute]: syncing.id}));\n  //FIXEnd \n  if (filter(query._statements, { grouping: 'where' }).length === 0) {\n    throw new Error('A model cannot be destroyed without a \"where\" clause or an idAttribute.');\n  }\n  return this.query.del();\n})\n\n})\n}\n```. Any news? I'm planning a workshop about bookshelf, I would be honored if my contribution makes it to a release before that \ud83d\ude09 . Lost you there, you mean just to do it in two lines instead of one, or create a more reusable method and call it from there?\nLMK - I'll comply\n. P.S - I met more bugs around the same problem which appears in different places around delete and updates, although I'm yet sure if the root cause is in Bookshelf itself, or in bookshelf-modelbase plugin.\nI tend to go for creating a method that provides a selector/filter/where clause that should be used wherever a key to a table is needed.\nNot just a private function, but a part of the API.\nIf all implementations will pull table key from this API - it will also make supporting compound keys in the future easy peasy\n. anything?. Yup. looks very similar. I think mine uses less operations, but it's so negligible that it doesn't worth the discussion.\nI don't care which of them you take, as long as the issue is fixed \ud83d\udc4d  \ud83d\ude09 . I hear you.\nI'll find time for it soon...\nOn Tue, Feb 6, 2018 at 8:06 PM, Ricardo Gra\u00e7a notifications@github.com\nwrote:\n\n@ricardograca requested changes on this pull request.\nGreat. This just needs a test case then and I'll merge it.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/pull/1680#pullrequestreview-94446061,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAxBHTJYDWiob8l30RHVrObLl5hlbK2dks5tSJSfgaJpZM4QPVXz\n.\n. ok, done. There you go \ud83d\ude03 \n@ricardograca  - I think the ball is in your court again\n\nUpdated: Sorry it took so long, I misread the picture.... @ricardograca \nUh...\nIs there something I have to do to handle the change-request except the commits I pushed?. +1 \ud83d\udc4d . super.\n. wow. here's the  bug:\nhttps://github.com/bookshelf/bookshelf/blob/master/src/model.js#L1282\njavascript\n1282>  where(...args) {\n1283>    return this.query('where', ...args);\n1284>  }\nneed a way to transform field names here, while supporting all the overloaded forms of knex#query...\n. im not that deep into knex.\nbefore I start a PR with all the tests and complexity, can anybody look and say a word about the direction?\nI assume we should do something in the sporit of:\njavascript\n  where(...args) {\n    if (!args.length) return this.query('where', []);\n    const whereObj = args.length === 1 ? args[0] : { [ args.shift() ] : args }\n    return this.query('where', [this.format(whereObj]);\n  }. \nWell. What I had to do to get the project working is refactor out all usage of Model#parse and Model#format - i.e  -work with the exact DB field names, and override Model#serialize.\nThis kept clear that inside the model all the field names are snake_case, and it transforms to camelCase only on the way out.\nUPDATED:  on 2nd read I decided to express things better, sorry for all the mail users.\nIt does mean however that if you want to do things like:\n(req, res, next) => Entity.upsert(req.body).then(r => res.json(r.toJSON()), next)\nYou have to have a middleware that transforms camelCase to snake_case on the request object (yes, a mutation. a gotcha. side effects... not functional \ud83d\ude1e).\nIt also means you cannot relay on on('saving' validations - because they will emit rejects on wrong field names, so you need a validation middleware before the transformer middleware - which, by the way has to deal with req.query,  and possibly req.params, as well as req.body.\n(or alternatively - a layer to translate rejected field names before they're emitted to the user. same same...)\nIf I could relay on Model#parse and Model#format - it would have been better, because then - I wouldn't need both of middlewares, because on('saving' validation would do the trick and pass the same names (as demonstrated in tutorial using checkit).\n. ",
    "marianacapelo": "Hi! I understand that the issue is closed. Still, I wanted to say that I faced the exact same situation, and this issue actually helped me. \nThe docs are very clear indeed, @ricardograca. But it still took me a while to figure out what was happening. \nI think this behaviour can come off as unexpected, specially if the model has \"saving\" handlers setting some of its values. This was my case - I was doing some math operation and setting the result as the model's attribute value. It was working fine - except when updating a model instance. The calculated field was not being updated, even though the handler was updating it, and the attribute was marked as changed before the save -- which seemed strange to me.\nBuuuut, you know, the docs are correct. Just thought I would present an use case for this.. I'm really sorry for the delayed response...\nI didn't get a chance to test this, but would it be wrong to save all the updated attributes with the {patch: true}option? This way we would still be respecting the \"patch\" action, and not leaving updated values behind.. @ricardograca, here's a sample for my use case.\nIn both save actions (insert and update with patch option) the calculatePrice handler is called, and unit_price attribute is correctly updated and marked as changed, but the patching only takes into account the attributes sent as argument for the save method - and so the unit_price value is not updated in the last case.\n``javascript\n/**\n * Model for item table - with AIid, numericunit_price_wo_tax,taxandunit_price` fields, etc.\n */\nconst Item = Bookshelf.Model.extend({\n  tableName: 'item', \ninitialize() {\n    this.constructor.super.initialize.apply(this, arguments);\n    this.on('saving', this.calculatePrice);\n  },\n/*\n   * Calculates and assigns unit_price attribute value. \n   /\n  calculatePrice(model, attrs, options) {\n    const priceWithoutTax = this.get('unit_price_wo_tax');\n    this.set('unit_price', priceWithoutTax + priceWithoutTax * this.get('tax'));\n    console.log(this.hasChanged('unit_price')); // always logs true\n  },\n});\n// Creating item instance\nconst instance = await Item.forge().save(\n  { unit_price_wo_tax: 10, tax: 0.23 },\n  { method: 'insert' }\n);\nconsole.log(instance.attributes); // shows unit_price of 12.3\n// Fetching item instance and updating unit price without tax\nconst sameInstance =  await Item.forge({ id: instance.get('id') }).fetch();\nawait sameInstance.save({ unit_price_wo_tax: 100 }, { method: 'update', patch: true });\nconsole.log(sameInstance.attributes); // shows unchanged unit_price of 12.3\n```. ",
    "ai": "@ricardograca do you need help with it?. It is npm install problem. I think we should start from knex update in peerDependencies in this PR.. ",
    "maziey93": "@ricardograca So I am using a serviceLocator for DI, I register the model in a dependency file like so \njavascript\nserviceLocator.register('courseModel', () => {\n    const bookshelf = serviceLocator.get('bookshelf')(); //this has been registered previously obviously\n    return CourseModel(bookshelf);\n  });\nits then injected and used like so \n```javascript\nconst courseModel = serviceLocator.get('courseModel')();\ncourseModel.where({ id: courseId }).fetch({ withRelated: extraFields });\n```\nI dont see how there could still be an issue of circular dependency. @ricardograca Never mind I resolved with the idea from #792 thanks for your help\nDefined this in bookshelf.js itself\njavascript\nfs.readdirSync(pathToModels).forEach((file) => {\n    let model = require(path.join(pathToModels, file));\n    //Hydrate model with bookshelf\n    model(bookshelf)\n  });\nthen calls to models were simply\njavascript\nconst someModel = bookshelf.model('SomeModel');. ",
    "pmalouin": "The PR solves my issue. Sorry, didn't see it before filing this issue.. ",
    "Kupstas": "Same problem. Where is you fix?. ",
    "kenmorechalfant": "It appears that the problem is that .related checks first on the relations hash, finds nothing and returns an empty collection, but if you .fetch off of that then it does actually load the models.\nthingies = await user.related('thingies').fetch() // this works\nThe problem is, again, I do not know ahead of time whether the relation has been eager loaded. If I do this and the relation was eager loaded, then I do the query twice.\nI can do a manual check for this:\nthingies = user.related('thingies').length ? user.related('thingies') : await user.related('thingies').fetch()\nHowever, I believe it could be handled more consistently.\n.related() could always return a promise. If the data is already loaded then you can resolve immediately with it. Otherwise it should load the relation (i.e. call fetch() for you). Then this would work either way:\nthingies = await user.related('thingies')\nNo 'if' checks necessary. Thoughts?\nSide note: Not sure if this is totally necessary but I could imagine you might want to force .related to re-fetch; that could be an optional 2nd argument. I.e., by default if it finds any data in the relations hash it will immediately resolve with it, but if you do related('thingies', true) it will make sure the relations are the latest.. ",
    "DJAndries": "@ricardograca Updated\n. ",
    "johncpalmer": "I would also really like the ability to do this. Would make my life better, by a lot.. ",
    "throrin19": "any news about this ? I have the same problem and it's very important to make that. Sequelize do it. Why bookshelf not ?. I have the response, the problem is only with bookshelf because, in the pagination plugin, the count query can't use fetch options, it's only use the transacted option.\nSo, the problem is on bookshelf part, not with other plugins, and the pagination plugin is not compatible with all other bookshelf plugins who override the query on fetching event depends on fetch options.\nSee the fetch part on pagination, it use the fetch passing options : https://github.com/bookshelf/bookshelf/blob/fc667332707ea978ff5e8db879fdb81479c15d54/lib/plugins/pagination.js#L153\nBut, in the count part, it's ignore this parameters : https://github.com/bookshelf/bookshelf/blob/fc667332707ea978ff5e8db879fdb81479c15d54/lib/plugins/pagination.js#L183\nif we change the count part like that : \n[fetchMethodName]({ ...fetchOptions, transacting })\nIt works fine\n. Sorry for my language and my precipitation,\nfor the count part, we can use all fetchOptions while omitting other basic params : \n[fetchMethodName](_.omit(fetchOptions, 'require', 'columns', 'withRelated', 'lock'))\nAnd we can use all custom fetch params used by all bookshelf plugins. I hope I make correct tests, I try if the count lost standard options and keep custom options. Great !! Have you a release date for this PR integration in bookshelf ? I realy need this in my current development. ",
    "syangdev": "@ricardograca Yea, I don't have time. This is also my first time collaborating on open source project too, so forgive me. I just wanted to show a simple solution. Please note that this bug probably affects a many to many relationship too.. ",
    "Oxyrus": "Thank you so much @ricardograca  !\n  . ",
    "mkhanal": "Error was because of the bookshelf-camelcase plugin.\nThis worked fine after I wrote my own plugin to update the column name to upper case.. ",
    "chentsulin": "Hi @ricardograca, @dj-hedgehog, \nI created PR #1883 which implemented prettier + precommit idea.\n(follow knex PR: https://github.com/tgriesser/knex/pull/2697). Hi @ricardograca, @dj-hedgehog, \nI created PR #1883 which implemented prettier + precommit idea.\n(follow knex PR: https://github.com/tgriesser/knex/pull/2697). Added those config:\n\"bracketSpacing\": false,\n\"semi\": false,\n\"printWidth\": 120. @ricardograca\nI set trailingComma to none, semi to true, those changes save ~4000 line changes. \nBefore:\n\nAfter\n\n. I guess that there are no so many contributors still using node v4 to develop bookshelf, so It's not a big deal to merge this.. The main reason is that knex uses lint-staged.\nAnd some reference:\n\n\nlint-staged \nnpm weekly downloads: 479,223\ngithub stars: 3140\n\n\npretty-quick\nnpm weekly downloads: 54,925\ngithub stars: 386. @ricardograca Sorry, I edited those lines on Github, so didn't find out the syntax error.\nI already fixed it and rebased the master.. \n\n",
    "cdaringe": "woof. thats embarrassing ;)  would you an accept a PR to do a runtime assertion or two on the input to bookshelf?. knex returns one of many dialect objects, of which there is no common base class/proto.  therefore, a direct type check on the passed knex obj isn't an option.   however, all dialects use the same client, which is a robust and easy assertion.. woof, ya.  i'm not used to seeing it .github.  i generally check the root! sending a patch now.... easy peasy.  how about that?  better? :). yep.  sorry i missed that.. ",
    "ComputerWarWizard": "Just as an update the last version that this still works correctly is 0.9.5. Every version after 0.9.5 this happens.  I tried every one so that I could find the latest version I could continue to use.  I first noticed it in 0.12.1 when I upgraded and went down from there. I know this is an unusual case but I have to deal with the mistakes of a previous developer :(. To fetch I am using\njavascript\nModels.Website.collection()\n  .orderBy('id','asc')\n  .fetch({ withRelated: {\n    locations: function(qb) {},\n    merchantAccounts: function() {}\n  } });\nAnd the model for Website is \njavascript\nvar Website = Bookshelf.Model.extend({\n    tableName: 'websites',\n  locations: function() {\n    return this.hasMany(Location, 'website_id');\n  },\n  merchantAccounts: function() {\n    return this.hasMany(MerchantAccount, 'website_id');\n  },\n  websiteTerms: function() {\n    return this.hasMany(WebsiteTerm, 'website_id');\n  },\n  currencyCode: function() {\n    return this.belongsTo(CurrencyCode, 'currency_code');\n  }\n});\nWhere Website.id = 0 and the foreign key for the related models would also be 0 then.  Hope this helps if you need more let me know and I will try to help. . Yeah this another one of those  instances of\n\nI have to deal with the mistakes of a previous developer :(\n\nlol I will be changing that soon though thanks for looking into.  I want to let you know that I love this library though :+1: . I can confirm that relations without a primary key of 0 do return correctly. I will have to check if changing it to an array works.. Ok not sure if you updated anything but I went to test to see if arrays would work, which required me to update bookshelf and I used .0.12.1 and I no longer have the problem... So if you fixed it AWESOME!!! if not I am sorry I wasted your time as I have no idea what changed that would cause it to work now.. ",
    "faustbrian": "The plugin is loaded via Bookshelf.plugin(require('./mass-assignment')) and the data is a simple object of key-value pairs that comes in via POST and has a model like this.\n```js\nconst Bookshelf = require('../bookshelf')\nconst Post = Bookshelf.Model.extend({\n  tableName: 'posts',\n  fillable: ['title', 'body']\n})\nmodule.exports = Bookshelf.model('Post', Post)\n```\njs\nreturn UserModel.forge(attributes).save(null, {method: 'insert'}).tap(m =>\n    Promise.map(user.posts, p => m.related('posts').create(p, {method: 'insert'}))\n).then(user => {\n    console.log(user)\n}).catch(error => {\n    console.log(error)\n}). How could I log the exact query bookshelf generates?\nAttributes before _.pick\njson\n{\n    \"title\": \"some-title\",\n    \"body\": \"some-body\",\n    \"not-used-field\": \"some-not-used-field\"\n}\nAttributes after _.pick\njson\n{\n    \"title\": \"some-title\",\n    \"body\": \"some-body\"\n}\nThe issue is that even though the console.log(attributes) before return bookshelf.Model.prototype.save.call(this, attributes, options) shows me the Attributes after _.pick it actually tries to store the Attributes before _.pick.\nSo this example would throw { Error: SQLITE_ERROR: no such column: not_used_field errno: 1, code: 'SQLITE_ERROR' }.. Haven't had a chance yet to work on it again, will be taking a look again tomorrow. Any hint on how I should correctly overwrite the save method or invoke my plugin?. ",
    "larryprice": "@ricardograca Thanks, I've updated the PR to pass the tests.. ",
    "alechirsch": "Is it possible that this is related to #1800 ?. @ricardograca  Will do, I just got my environment all set up for testing. @ricardograca All of the tests pass on my local machine, have you ever run into issues where tests differ between machines?. \n. I am using Node 8.9.2. It is very strange, the test that is failing here is passing consistently on my end.. Person.collection(people).fetch().load('pet') results in \"TypeError: Person.collection(...).fetch(...).load is not a function\"\nPerson.collection(people).fetch().then(collection => collection.load('pet'))\nThis results in fetching all Person records, it does not refetch the selected collection. Also, the relationships are still not loaded in after the .load is called on the result of fetch.\nAlso I would highly prefer to not need to load the entire collection again. @ricardograca Are you able to confirm this behavior, or are you seeing that it is working?. @ricardograca I wrote a gist for this scenario and it looks like it is working as expected in this case.\nhttps://gist.github.com/alechirsch/3e8923bb55e63960dfae18f7ce3e7217\nThat still doesnt explain why it wont work in my application code.. This is how I load up models in my app, maybe there is a plugin that is interfering?\n```\nconst dbConfig = require('./knexfile');\nconst knex = require('knex')(dbConfig[process.env.NODE_ENV || 'development']);\nconst bookshelf = require('bookshelf')(knex);\nconst jsonApiParams = require('bookshelf-jsonapi-params');\n// Load bookshelf plugins\nbookshelf.plugin(jsonApiParams);\n// Load up the models\nconst Models = require('bookshelf-model-loader').init(bookshelf, {\n    plugins: ['virtuals', 'bookshelf-manager', 'visibility', 'registry'],\n    path: ${__dirname  }/models\n});\nmodule.exports = {\n    bookshelf,\n    Models\n};\n```\nI am using my fork of bookshelf which has a bug fix that I merged into what will be 0.14, https://github.com/alechirsch/bookshelf#build\nThe gist is running off the same version of bookshelf since I ran it in the same repository folder. The next step I could take is to load in bookshelf the same way with all of the plugins.. ",
    "nitin-jotwani": "fixed\nMy bad :P \nI was trying to select the column which I didn't provide in model.\nqb.orderBy('createdAt', 'desc').select('column_which_is_present_in_model')\n. ",
    "brunoalvesw": "Never mind, got played by through's overload's parameters. Following the docs i managed to do it with\nrole: function() {return this.hasOne(Role).through(UserRole, 'id', 'user_id', 'role_id')\nwhich resulted in \nselect role.*, userRole.role_id as _pivot_role_id, userRole.user_id as _pivot_user_id from role inner join userRole on userRole.role_id = role.id where userRole.user_id in (?)\n. ",
    "hungtv55": "@ricardogama : it's good solution, thanks!. ",
    "davericher": "setting this to null in the model definition (updated at since it does not exist on the model) just breaks \neverything. How did this make it through\nModels.JoinLogging.create({\n            nick,\n            channel,\n            user: message.user,\n            host: message.host,\n        })\n            .catch(logger.error);\nsql: 'insert into `joinLogging` (`channel`, `host`, `nick`, `null`, `timestamp`, `user`) values (?, ?, ?, ?, ?, ?)'\nconst JoinLogging = Models.Base.extend({\n    tableName: 'joinLogging',\n    hasTimestamps: ['timestamp', null],\n    soft: false,\n});. setting this to null in the model definition (updated at since it does not exist on the model) just breaks \neverything. How did this make it through\nModels.JoinLogging.create({\n            nick,\n            channel,\n            user: message.user,\n            host: message.host,\n        })\n            .catch(logger.error);\nsql: 'insert into `joinLogging` (`channel`, `host`, `nick`, `null`, `timestamp`, `user`) values (?, ?, ?, ?, ?, ?)'\nconst JoinLogging = Models.Base.extend({\n    tableName: 'joinLogging',\n    hasTimestamps: ['timestamp', null],\n    soft: false,\n});. from 0.13.2 to 0.13.3, having a model defined with no updated_at , so hasTimestamps: ['created_at', null] for example or even just hasTimestamps: ['created_at'] will still try and insert an updated at timestamp when using the Model.create function. Thus throwing a 'no col named undefined/null' depending on how u did it.\n. from 0.13.2 to 0.13.3, having a model defined with no updated_at , so hasTimestamps: ['created_at', null] for example or even just hasTimestamps: ['created_at'] will still try and insert an updated at timestamp when using the Model.create function. Thus throwing a 'no col named undefined/null' depending on how u did it.\n. Your unit test covers .save, not .create. Your unit test covers .save, not .create. ",
    "kevindong": "New pull request opened to merge into master: #1803 \nClosing this PR.. ",
    "duard": "That is my model \n```\nimport bookshelfGestao from '../../db_gestao';\nconst TABLE_NAME = 'medicamento_temp_abcfarma';\n/*\n * medicamento_temp_abcfarma model.\n /\nclass Rede extends bookshelfGestao.Model {\nget idAttribute() {\n    return 'MED_ABC';\n  }\nget tableName() {\n    return TABLE_NAME;\n  }\n}\nexport default Rede;\n. That is my model\nimport bookshelfGestao from '../../db_gestao';\nconst TABLE_NAME = 'medicamento_temp_abcfarma';\n/*\n * medicamento_temp_abcfarma model.\n /\nclass Rede extends bookshelfGestao.Model {\nget idAttribute() {\n    return 'MED_ABC';\n  }\nget tableName() {\n    return TABLE_NAME;\n  }\n}\nexport default Rede;\n. @ricardograca how can I force the format name in that case / model  ? I need to insert data with that field.. @ricardograca how can I force the format name in that case / model  ? I need to insert data with that field.. @ricardogama\n    \"knex\": \"^0.13.0\",\n    \"bookshelf\": \"^0.10.3\",\n    \"bookshelf-camelcase\": \"^2.0.1\",\n```\nps. are you from Brazil ?. @ricardogama \nusing latest versions of knex and bookshelf and  'bookshelf-camelcase' the code works !\nusing latest versions of knex and bookshelf and  'case-converter' the code works !\nThanks. I fix it, now I can run my query \n```\n  eans = eans\n    .replace(/\"/, '')\n    .replace(/]/, '')\n    .replace('[', '');\nreturn Resource.query(q => q.orderBy('item', 'desc'))\n    .query(q => q.limit(1000))\n    .where({ cnpj: CNPJ })\n    .where('item', 'IN', [eans])\n    .fetchAll();\n```. @fl0w could you post some example please ? \n. ```\n  return Resource.query(q => q.orderBy('item', 'desc'))\n    .query(q => q.limit(1000))\n    .where({ cnpj: CNPJ })\n    .query('whereIn', 'item', [eans])\n    .fetchAll();\n``\nmy query create this SQL, return 1 record sql: 'select smart.* from smart where cnpj = \\'01159697000100\\' and item in (\\'7891522051143, 7891522200107\\') order by item desc limit 1000' }`\nbut the same select on the database give me 2 records.\nSELECTsmart.* FROMsmartWHEREcnpj= '01159697000100' ANDitemIN ('7891522051143', '7891522200107') ORDER BYitemDESC LIMIT 1000;\n. EANS =>  7891522051143, 7891522200107\njust =>  7891522051143, 7891522200107. my query with eans as array gave me an error (at end)\nthis is my eans variable : =>>>> [\"7891522051143\", \"7891522200107\"]\nthe query generated  : \nselectsmart.* fromsmartwherecnpj= \\'01159697000100\\' anditemin \\'[\\\\\"7891522051143\\\\\", \\\\\"7891522200107\\\\\"]\\' order byitemdesc limit 1000'\nthe error\nmessage: 'You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near \\'\\'[\\\\\"7891522051143\\\\\", \\\\\"7891522200107\\\\\"]\\' order byitemdesc limit 1000\\' at line 1' }. I think this is a bug with Strings in IN clause and I dont know how to execute an RAW SQL. \n. the array parameter with the EANS strings gave me this SQL  (with ERRORs)\nselectsmart.* fromsmartwherecnpj= \\'01159697000100\\' anditemin \\'[\\\\\"7891522051143\\\\\", \\\\\"7891522200107\\\\\"]\\' order byitemdesc limit 1000' }. I think it is MariaDB problem ... I'm using MariaDB 10.3 :-/. ",
    "josdotso": "Thanks!. Thanks!. Breadcrumb for others: https://github.com/tgriesser/knex/issues/2002. Breadcrumb for others: https://github.com/tgriesser/knex/issues/2002. ",
    "jesseg34": "@leebickmtu have you tried using the lodash methods?\njavascript\nlet dataRows = await MyTable.where({someValue: 7}).fetchAll();\ndataRows.forEach((row) => {\n    // do something on row/model\n}). @leebickmtu have you tried using the lodash methods?\njavascript\nlet dataRows = await MyTable.where({someValue: 7}).fetchAll();\ndataRows.forEach((row) => {\n    // do something on row/model\n}). @leebickmtu Sorry I didn't see your PR at first and I agree that supporting the native iteration format would be nice.\nOut of curiosity wouldn't it be valid to make the callback function async? I'm new to JS and want to make sure my understanding is correct. I appreciate your feedback.\n```javascript\nlet dataRows = await MyTable.where({someValue: 7}).fetchAll();\ndataRows.forEach( async (row) => {\n    try {\n        await doSomethiing(row);\n    } catch(e) {\n        //err\n    }\n}). @leebickmtu Sorry I didn't see your PR at first and I agree that supporting the native iteration format would be nice.\nOut of curiosity wouldn't it be valid to make the callback function async? I'm new to JS and want to make sure my understanding is correct. I appreciate your feedback.\n```javascript\nlet dataRows = await MyTable.where({someValue: 7}).fetchAll();\ndataRows.forEach( async (row) => {\n    try {\n        await doSomethiing(row);\n    } catch(e) {\n        //err\n    }\n}). Ah okay that makes sense, thanks!. Ah okay that makes sense, thanks!. That's just what I needed, thank you!. ",
    "leebickmtu": "@jesseg34 Yes, I was aware of them. However my use case has that whole sample code inside an async function and requires further use of await inside the loop on each row. Because lodash uses callback functions the await is not valid inside it (can only be used in async functions).\nNot sure if you noticed but I made a PR referencing this issue and implemented an iterator in CollectionBase. Was a simple add. I think supporting the javascript native for..of iteration format is nice instead of relying on lodash. Especially when making heavy use of async/await because you can avoid all the callbacks.. That would be valid in that it would make the awaited Promises within each forEach iteration synchronous. But each iteration would be asynchronous to the main function without a way to await each iteration.\nTry this for example. Each iteration will wait for the timeout to resolve back with the row to rowValue then print it. So synchronous within an iteration.\nBut they will print in the order 1,2,3,4 (not the iteration order) because each iteration is asynchronous relative to the others.\nAnd you will see 'after loop' print before any of them cause the main code can't await each iteration either.\nlet dataRows = [2,1,4,3];\ndataRows.forEach( async (row) => {\n    let rowValue = await new Promise(function(resolve, reject) {\n        setTimeout(resolve, row*1000, row);\n    });\n    console.log(rowValue);\n})\nconsole.log('after loop');. ",
    "amaranadh-wal": "If we give only created_at attribute in the array it is taking undefined in the insert query instead of updated_at. \nFor example \nexport default homeBookshelf.Model.extend({\n  tableName: 'notifications',\n  hasTimestamps: ['created_at'], ...\nFor above model declaration the query is going like \ninsert into 'notifications' ('created_at', 'initiator_id', 'initiator_type', 'notification_group_id', 'undefined', 'user_id') values ('2018-06-14 15:41:18.019', 333, 'user', 187, '2018-06-14 15:41:18.019', DEFAULT)\nIf we give like \nexport default homeBookshelf.Model.extend({\n  tableName: 'notifications',\n  hasTimestamps: ['created_at',null],\nThen the query is going like \ninsert into notifications ('created_at', 'initiator_id', 'initiator_type', 'notification_group_id', 'null', 'user_id') values ('2018-06-14 15:40:41.754', 322, 'user', 180, '2018-06-14 15:40:41.754', DEFAULT)\nSo, I have given false value for the  > hasTimestamps then it is working.\n. I am referring the published version bookshelf@0.13.3 only.\nOn Thu, Jun 14, 2018 at 4:38 PM, Ricardo Gra\u00e7a notifications@github.com\nwrote:\n\nHave you tried the code that is in this change or are you referring only\nto the published version 0.13.3?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/bookshelf/bookshelf/pull/1820#issuecomment-397257513,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AlchsrdzscGFrlb-xiHeclrQQbuuKeiAks5t8kQzgaJpZM4Tfmw6\n.\n\n\n-- \nThanks & Regards,Meda AmaranadhSr.Software Development Engineer\n\nwestagilelabs.com LinkedIn https://www.linkedin.com/in/thisisamar/\n. ",
    "pantchox": "forgot to mention the database is SQLite, and the fields i am expecting to return number are set as INTEGER in the database table schema.\nwhen doing fetch it returns as expected.. Yes\nhere is my code\njavascript\nnew Text({\n            id: text_id,\n        })\n        .save({\n            string_id: string_id\n        }, {patch: true})\n        .then(function(text) {\n            // res.send(text.toJSON()); // original results returning id as string\n            new Text({id: text.attributes.id})\n            .fetch()\n            .then(function(textx) {\n                res.send(textx.toJSON()); // this returns results as expected \n            });\n        })\n        .catch(function(err) {\n           // error handling\n        });. what i did eventually to make it work or correct expected behavior\n(to be more clear this is for update REST case)\njavascript\nnew Text({\n            id: text_id\n        })\n        .fetch({require: true})\n        .then(function(text) {\n            text\n            .save({\n            string_id: string_id || text.get('string_id')\n            }, {patch: true})\n            .then(function(updatedText) {\n                res.send(updatedText.toJSON())\n            })\n            .catch(function(err) {\n                // error handling\n            });\n        })\n        .catch(function(err) {\n            // not found error handling\n        });. ",
    "coffeeneed": "@ricardograca Thank you for your efforts :-) This is difficult, because it looks like requiring and using Bookshelf causes these errors in the console log. My project is very simple and basic -- almost vanilla boilerplate.\nI zipped the project down and uploaded it. Could you have a look? Just run npm install.\nVueboiler.zip\n. ",
    "MisooB": "@ricardograca no. Reason for the issue is most likely forEach method, which is not as synchronous as I thought it was.. thank you all for your help. I've managed to get rid of errors by following:\nrelatedSpots.forEach(async (\n      const updatedSpot = await spot.save({isDeleted: true}, {method:\"update\", patch: true, transacting: trx});\n      await knex('tasks').where({spotId: spot.id}).update('isDeleted', true);\n});\nfirst line adds 'isDeleted' flag to all spots and second one does the same with tasks. Don't know if this is super viable or not but it's working for now.. thank you all for your help. I've managed to get rid of errors by following:\nrelatedSpots.forEach(async (\n      const updatedSpot = await spot.save({isDeleted: true}, {method:\"update\", patch: true, transacting: trx});\n      await knex('tasks').where({spotId: spot.id}).update('isDeleted', true);\n});\nfirst line adds 'isDeleted' flag to all spots and second one does the same with tasks. Don't know if this is super viable or not but it's working for now.. ",
    "chase1745": "I seem to have fixed the issue by adding: \n    req.body.acquisition_date = new Date(req.body.acquisition_date);\n    req.body.updated_at = new Date(req.body.updated_at);\n\nbefore asset.set(). Is there a way to do this in format? I tried this:\n    format: function (attrs) {\n        if (attrs.acquisition_date)\n            attrs.acquisition_date = new Date(attrs.acquisition_date);\n        if (attrs.updated_at)\n            attrs.updated_at = new Date(attrs.updated_at);\n        return attrs\n    }\n\nBut it is still updating acquisition_date.. I seem to have fixed the issue by adding: \n    req.body.acquisition_date = new Date(req.body.acquisition_date);\n    req.body.updated_at = new Date(req.body.updated_at);\n\nbefore asset.set(). Is there a way to do this in format? I tried this:\n    format: function (attrs) {\n        if (attrs.acquisition_date)\n            attrs.acquisition_date = new Date(attrs.acquisition_date);\n        if (attrs.updated_at)\n            attrs.updated_at = new Date(attrs.updated_at);\n        return attrs\n    }\n\nBut it is still updating acquisition_date.. I have tried it both with and without, and get the same result either way.. I have tried it both with and without, and get the same result either way.. That makes sense. Thanks for the tip about Processor. It is working correctly!. That makes sense. Thanks for the tip about Processor. It is working correctly!. So I am running my application on AWS Lambda, and this worked locally, but when I uploaded it to Lambda, it continued to say acquisition_date was changing. I found that it always gets the date at 6 hours, and tries to update it to 0, like so: 2012-02-24T06:00:00.000Z to  2012-02-24 00:00:00.000, any ideas as to why that would be happening? I guess I could write a seperate proccessor for it that adds 6 hours so it doesn't think it has been changed.. So I am running my application on AWS Lambda, and this worked locally, but when I uploaded it to Lambda, it continued to say acquisition_date was changing. I found that it always gets the date at 6 hours, and tries to update it to 0, like so: 2012-02-24T06:00:00.000Z to  2012-02-24 00:00:00.000, any ideas as to why that would be happening? I guess I could write a seperate proccessor for it that adds 6 hours so it doesn't think it has been changed.. You're correct. Thanks again for the help and information!. You're correct. Thanks again for the help and information!. ",
    "jsdevel": "Got it.  Thanks @ricardograca !\n. ",
    "akprgm": "I have a model Client with has many relation to ConnectionRequest model.\n```js\n// Client Model\nimport { Bookshelf } from './Model';\nimport ConnectionRequest from './ConnectionRequest';\nclass Client extends Bookshelf.Model {\n  get tableName() {\n    return 'clients';\n  }\nget hasTimestamps() {\n    return true;\n  }\nget softDelete() {\n    return true;\n  }\n/ ******\n   *           RELATIONS\n   ***** /\n  sentConnectionRequests() {\n    return this.hasMany(ConnectionRequest, 'from_client_id');\n  }\n}\n```\n```js\n// ConnectionRequest Model\nimport { Bookshelf } from './Model';\nimport Client from './Client';\nclass ConnectionRequest extends Bookshelf.Model {\n  get tableName() { return 'connection_requests'; }\nget hasTimestamps() { return true; }\nget softDelete() { return true; }\n/ ******\n   *           RELATIONS\n   ***** /\n  client() {\n    return this.belongsTo(Client, 'from_client_id');\n  }\n}\nexport default Bookshelf.model('ConnectionRequest', ConnectionRequest);\n```\nNow what I am trying to get all sent connection request for a client and filter them.\neg\n```js\nconst client = Client.where({ client_id: 1}).fetch();\nconst sentConnectionRequest =  client.sentConnectionRequest().where({ to_client_id: 2});\n```\nthis gives me [].\nif i do like this, it give all connectionrequest sent by client, but i want ot filter them.\njs\nconst sentConnectionRequest = client.sentConnectionRequest().fetch();\nLogger.info(sentConectionRequest.toJSON);. is anyone looking into it?. I want to lazy eager load relation, the thing is I retrieve client in middleware from token and pass it to the controller, then depending upon the method called I want to load required relation.. js\nconst client = await Client.where({ client_id:1 }).fetch();\ncoonst sentConnectionRequest = await client.related('sentConnectionRequest').query('where', 'to_client_id', 2).fetch();\nthrows an error :-\nCannot read property 'query' of undefined\nAfter debugging found:-\nclient.related is not a function\nand why I can't access a relation like this?\njs\nconst client = await Client.where({ client_id:1 }).fetch();\ncont sentConnectionRequest = await client. sentConnectionRequest().fetch();. Got it, I can use relation like this and filter it\njs\nconst client = await Client.where({ client_id:1 }).fetch();\ncont sentConnectionRequest = await( await client. sentConnectionRequest().fetch()).where(filterObject).fetch();\nlet me know if this is the right way to do it.. Just in case anyone looking for same\nhere is how you can do it.\njs\nclient.polyRelation().create({ content: 'testing' });. Just FI\nyou can iterate over collection using normal loops as done above, but the catch is, loops don't play well with async functions. \nhere is my solution to use an async method inside loops \n```js \nconst users = await User.where(conditionOjb).fetch();\nconst loopPromise = [];\nusers.foreach((user) => {\n  const valuePromise = someMethod().then((value) => {\n    user.set('value', value);\n  }).catch((error) => {\n    // handle error\n  });\n  loopPromise.push(valuePromise);\n});\nconst modifiedUsers = Promise.all(loopPromise).then(()=> users).catch((error) => { //  handle error });\nStill looking for better solution. @fl0w will try that.  @rhys-vdw Thanks, works great.. Not an issue, works as expected.. I want to do it at the database level, there will be thousands of posts for a user and sortBy will work with pagination?. For example, in eloquent we can do something like this.php\nPost::withCount('comments')->orderBy('comments_count', 'desc')->paginate(10);\n```. ",
    "kibertoad": "\nmaintain Node.js 4 support since it's what's available by default on Ubuntu 16.04 which is still maintained\n\nThat's an interesting piece of information which explains a lot why there is still some Node.js 4 adoption around, thanks for pointing that out!. @ricardogama Isn't it going to explode on Yarn at least due to hardcoded incompatibility in bookshelf? Maybe newer versions should be unlocked already, even if not explicitly supported?. ",
    "nicolastakashi": "Sorry, @ricardograca I will try to improve the issue description.. Sorry, @ricardograca I will try to improve the issue description.. @ricardogama I hope that can help you to understand the probleme, thank you a lot.. @ricardogama I hope that can help you to understand the probleme, thank you a lot.. ",
    "jorgebucaran": "Thanks, @ricardogama! If you need help with that or if you want to use it in more places I'd love to help.. Thanks, @ricardogama! If you need help with that or if you want to use it in more places I'd love to help.. ",
    "eerenyuan": "I made that change in my fork. But It seems I messed things up: that commitment was combined with the other pull request which I later closed. and I don't know how to make that change in this one..... done:). > As you can see from the failing test case the reason for that code being that way is to enable user defined timestamps, so this PR is not going to be accepted unless you have something else to add.\nI see what you meant. Never thought of that case. committed a new version. I think logically it's identical to the master branch, just a little more intuitive---hopefully..... by the way, do you know why npm is still using an old version? Or I should use some other tool to install bookshelf. . ",
    "allouis": "Ah I didn't realise that was an ordered list.\nOkay - thanks for the linked issue and getting back to me :relaxed: . ",
    "fidenz-malith": "@ricardograca Yes I do. Sorry I didn't mention that in the code sample. . I'm have a plugin to convert cases, but I have deactivated it to test this issue. Also I'm not overriding parse in the model I'm testing.. ",
    "khawajaumarfarooq": "Can knex 0.15+ be used with bookshelf 0.14+ or not?. ",
    "relativityboy": "@ricardograca - so this issue should be closed?. ",
    "CryOnics1": "\nIs this still an issue with the latest version?\n\nyes. > What database is this? Can you provide a reproducible test case for this problem?\nPostgres. example https://pastebin.com/nHvtq7wZ\n. ",
    "6utt3rfly": "I actually wrote a unit test, but found that the problem was bigger than I initially thought... it basically boils down to code something like this:\nconst a = {};\na[new Buffer('93', 'hex')] = ['123'];\na[new Buffer('90', 'hex')] = ['456'];\nconsole.log(a, Object.keys(a).length);\nThere are several places in the code where the ID is assumed to be used as a unique object key. However, with Buffers, this doesn't always work because they get converted to a string representation which may have collisions.\nI now found that the collection _byId property also does this, so when I query and get back 2 distinct rows, it's treating it as a single result.\nI could go further and update this PR, but I thought I'd ask if you have any other thoughts first @ricardograca ?. OK - I've added tests and fixes to collections. If you need more details or changes I'm happy to do so @ricardograca . Thanks for your quick responses!!. Changes made - thanks for catching the debug:true which I forgot about! @ricardograca . ",
    "spadgeaki": "Table is created like this:\n``sql\nCREATE TABLE IF NOT EXISTSblog_post_i18n(idint(11) NOT NULL,langchar(5) COLLATE utf8_general_ci NOT NULL,titlevarchar(128) COLLATE utf8_general_ci DEFAULT NULL,content` text COLLATE utf8_general_ci,\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;\n-- Indexes for table blog_post_i18n\nALTER TABLE i18n_media_post\n ADD PRIMARY KEY (id,lang), ADD KEY lang (lang);\n```\n.fetchAll is selecting all records. I want one record from blog_post table and all its related rows from blog_post_i18n table.\n. I do, when I query\nsql\nselect `blog_post_i18n `.* from `blog_post_i18n ` where `blog_post_i18n `.`id` in (28);\nI get two rows as a result.. That didn't help. I suppose I had it covered by \njavascript\ni18n() {\n  return this.hasMany(BlogPosti18n, 'id')\n}\nalready. Second parameter in .hasMany is ForeignKey in the Target model.. @ricardograca Oh thats it! Thank you. \njavascript\nget idAttribute() {\n    return null\n}\nI will probably change my table so there is id and then foreign key called blog_post_id as bookshelf expects.. ",
    "mukul13": "thanks for the fix! \ud83d\ude04 . ",
    "elliotlings": "It appears this has to do with underlying Knex library with MariaDB.\nRelated to: https://github.com/tgriesser/knex/issues/1276.\nI have fixed this issue by using parse in the model:\n```\nconst Thing = bookshelf.Model.extend({\n    tableName: 'things',\n    parse: function (attrs) {\n        if (isNaN(attrs.assigned_user_id)) {\n            attrs.assigned_user_id = null;\n        }\n    return attrs;\n},\nassignedUser() {\n    return this.belongsTo(User, 'assigned_user_id', 'id');\n},\n\n});\n```\n. ",
    "reachmehere89": "Thanks for your reply. It was some other module which was creating this issue and not related to bookshelf.. ",
    "ozergul": "Also my table structures\nPosts\n```js\nexports.up = function(knex, Promise) {\n    return knex.schema.createTable('posts', function(t) {\n        t.increments('id').primary();\n    t.dateTime('createdAt').notNull().defaultTo(knex.fn.now())\n    t.dateTime('updatedAt').nullable();\n\n    t.string('title').notNull();\n    t.string('content').notNull();\n    t.string('slug').notNull();\n\n    t.integer('user_id').notNull();\n    t.integer('status').notNull();\n})\n\n};\nexports.down = function(knex, Promise) {\n    return knex.schema.dropTable('posts');\n};\n```\nTags\n```js\nexports.up = function(knex, Promise) {\n    return knex.schema.createTable('tags', function(t) {\n        t.increments('id').primary();\n        t.string('term').notNull();\n        t.string('slug').notNull();\n   })\n};\nexports.down = function(knex, Promise) {\n    return knex.schema.dropTable('tags');\n};\n```\nCategories\n```js\nexports.up = function(knex, Promise) {\n    return knex.schema.createTable('categories', function(t) {\n        t.increments('id').primary();\n        t.string('term').notNull();\n        t.string('slug').notNull();\n   })\n};\nexports.down = function(knex, Promise) {\n    return knex.schema.dropTable('categories');\n};\n```\nPosts_Tags\n```js\nexports.up = function(knex, Promise) {\n    return knex.schema.createTable('posts_tags', function(t) {\n        t.increments('id').primary();\n        t.integer('post_id').unsigned().references('posts.id');\n        t.integer('tag_id').unsigned().references('tags.id');\n   })\n};\nexports.down = function(knex, Promise) {\n    return knex.schema.dropTable('posts_tags');\n};\n```\nPosts_Categories\n``` js\nexports.up = function(knex, Promise) {\n    return knex.schema.createTable('posts_categories', function(t) {\n        t.increments('id').primary();\n        t.integer('post_id').unsigned().references('posts.id');\n        t.integer('category_id').unsigned().references('categories.id');\n   })\n};\nexports.down = function(knex, Promise) {\n    return knex.schema.dropTable('posts_categories');\n};\n```\n. Same situation but the solution not fixed my problem: https://github.com/bookshelf/bookshelf/issues/1724\nCan you help @ricardograca. ",
    "jrschumacher": "Pending on final implementation of tgriesser/knex#2977 to support sqlite. ",
    "dmamills": "You are definitely on the right track using morphTo since the relation you are trying to describe between your tables is polymorphic.\nOn your base services table you should have your service_type and service_id field. This is what bookshelf will use to find the correct relationship.\nservice: function() {\n    return this.morphTo('service', Car, Cruise. Hotel, ....);\n }\nSee this part of the documentation for more details. Hope that helps!. Since you are dealing with the query builder, you should be looking at the knex documentation it does have support for aliasing, which is what I've linked to. I hope that helps!. ",
    "dbrownll": "Thanks for your feedback, we ideally will want to migrate json columns to jsonb columns for indexing capabilities anyway, and jsonb does have a comparison operator. We might be able to work around it for now using DISTINCT ON (profiles.id) profiles.* as you mentioned. ",
    "reediculous456": "model.fetchAll() is what throws the error I provided. Also, I'm not calling model.createTable() because I have already created my database on the server. In other projects where i've used bookshelf I just needed to supply the tablename to connect to an existing table.\nPG Database Dump\n```\n...\nCREATE TABLE \"Roles\" (\n    id serial PRIMARY KEY,\n    code text,\n    name text\n);\n...\nCREATE TABLE \"Users\" (\n    id serial PRIMARY KEY,\n    username text NOT NULL,\n    password text NOT NULL,\n    name text NOT NULL,\n    email text NOT NULL,\n    store_name text,\n    role integer DEFAULT 2 NOT NULL,\n    active text DEFAULT 'true'::text NOT NULL\n);\n...\nALTER TABLE ONLY \"Users\"\n    ADD CONSTRAINT \"Users_role_fkey\" FOREIGN KEY (role) REFERENCES \"Roles\"(id);\n...\n```\nPackage.json\n{\n  \"name\": \"\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"dev\": \"./node_modules/.bin/nodemon --watch src/libs --watch src/routes --watch src/utils --watch src/index.js src/index.js\",\n    \"lint\": \"./node_modules/.bin/eslint src/** && ./node_modules/.bin/ejslint views/**\",\n    \"fix-lint\": \"./node_modules/.bin/eslint src/** --fix\",\n    \"gulp\": \"./node_modules/.bin/gulp\",\n    \"gulp-dev\": \"./node_modules/.bin/gulp && ./node_modules/.bin/gulp watch\",\n    \"prod\": \"node src/index.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"\"\n  },\n  \"author\": \"Wesley Reed\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"bcrypt\": \"^3.0.3\",\n    \"bookshelf\": \"^0.14.2\",\n    \"bootstrap\": \"^4.2.1\",\n    \"bootstrap-colorpicker\": \"^2.5.2\",\n    \"bootstrap-datepicker\": \"^1.5.1\",\n    \"bootstrap-select\": \"^1.7.4\",\n    \"cookie-parser\": \"~1.4.3\",\n    \"datatables\": \"^1.10.18\",\n    \"datatables-buttons\": \"^1.0.3\",\n    \"datatables.net-buttons\": \"^1.2.2\",\n    \"debug\": \"~2.6.9\",\n    \"ejs\": \"^2.6.1\",\n    \"ejs-lint\": \"^0.3.0\",\n    \"express\": \"^4.16.4\",\n    \"express-session\": \"^1.15.6\",\n    \"font-awesome\": \"^4.5.0\",\n    \"jquery\": \"^3.3.1\",\n    \"knex\": \"^0.15.0\",\n    \"lodash\": \"^4.17.11\",\n    \"moment\": \"^2.10.6\",\n    \"pg\": \"^7.8.0\",\n    \"popper.js\": \"^1.14.7\",\n    \"restify\": \"^4.1.1\",\n    \"serve-favicon\": \"^2.5.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.0.0\",\n    \"@babel/core\": \"^7.0.0\",\n    \"@babel/node\": \"^7.0.0\",\n    \"@babel/plugin-proposal-class-properties\": \"^7.0.0\",\n    \"@babel/plugin-proposal-decorators\": \"^7.0.0\",\n    \"@babel/plugin-proposal-do-expressions\": \"^7.0.0\",\n    \"@babel/plugin-proposal-export-default-from\": \"^7.0.0\",\n    \"@babel/plugin-proposal-export-namespace-from\": \"^7.0.0\",\n    \"@babel/plugin-proposal-function-bind\": \"^7.0.0\",\n    \"@babel/plugin-proposal-function-sent\": \"^7.0.0\",\n    \"@babel/plugin-proposal-json-strings\": \"^7.0.0\",\n    \"@babel/plugin-proposal-logical-assignment-operators\": \"^7.0.0\",\n    \"@babel/plugin-proposal-nullish-coalescing-operator\": \"^7.0.0\",\n    \"@babel/plugin-proposal-numeric-separator\": \"^7.0.0\",\n    \"@babel/plugin-proposal-optional-chaining\": \"^7.0.0\",\n    \"@babel/plugin-proposal-pipeline-operator\": \"^7.0.0\",\n    \"@babel/plugin-proposal-throw-expressions\": \"^7.0.0\",\n    \"@babel/plugin-syntax-dynamic-import\": \"^7.0.0\",\n    \"@babel/plugin-syntax-import-meta\": \"^7.0.0\",\n    \"@babel/plugin-transform-regenerator\": \"^7.0.0\",\n    \"@babel/polyfill\": \"^7.0.0\",\n    \"@babel/preset-env\": \"^7.3.1\",\n    \"babel-core\": \"^6.26.3\",\n    \"babel-eslint\": \"^9.0.0\",\n    \"babel-loader\": \"^8.0.4\",\n    \"babel-polyfill\": \"^6.26.0\",\n    \"eslint\": \"^2.13.1\",\n    \"gulp\": \"^4.0.0\",\n    \"gulp-babel\": \"^8.0.0\",\n    \"gulp-clean-css\": \"^2.3.2\",\n    \"gulp-concat\": \"^2.6.0\",\n    \"gulp-sass\": \"^2.3.2\",\n    \"gulp-uglify\": \"^2.0.1\",\n    \"gulp-util\": \"^3.0.6\",\n    \"husky\": \"^1.3.1\",\n    \"nodemon\": \"^1.18.9\"\n  }\n}. My bad, that database dump is out of date. ## PG Database Dump\n```\n...\nCREATE TABLE roles (\n    id serial NOT NULL,\n    code text,\n    name text\n);\n...\nCREATE TABLE users (\n    id serial NOT NULL,\n    username text NOT NULL,\n    password text NOT NULL,\n    name text NOT NULL,\n    email text NOT NULL,\n    store_name text,\n    role integer DEFAULT 2 NOT NULL,\n    active text DEFAULT 'true'::text NOT NULL\n);\n...\nALTER TABLE ONLY roles\n    ADD CONSTRAINT \"Roles_pkey\" PRIMARY KEY (id);\nALTER TABLE ONLY users\n    ADD CONSTRAINT \"Users_pkey\" PRIMARY KEY (id);\nALTER TABLE ONLY users\n    ADD CONSTRAINT \"Users_username_key\" UNIQUE (username);\nALTER TABLE ONLY users\n    ADD CONSTRAINT \"Users_role_fkey\" FOREIGN KEY (role) REFERENCES roles(id);\n...\n```. Oh my gosh I'm an idiot \ud83d\ude02\ud83d\ude05 Thanks so much!. Also, thanks for the tip on the scripts! I'll have to pass that on to the rest of my team. ",
    "davidgf": "Thank you for accepting it :smile: Do you know when the fix could be released in npm?. ",
    "wdamaral": "Thanks Ricardo.\nQuestion answered.. ",
    "xaka": "You probably want to keep it align with other lines so it looks consistent \n. Looks like the bookshelf is using single quotes so you probably want to replace double quotes here\n. ",
    "shakdoesgithub": "would it make more sense to pass in fetchOptions directly here?\nI'm using the bookshelf-paranoia plugin and it passes in withDeleted option,  which pulls in records if they're softdeleted or not.  Since it doesn't get passed to the pagination plugin, it only counts rows that are not soft deleted.. ",
    "MatiasOlivera": "I understand, just missing the page in the wiki.. ",
    "rbrtmrtn": "@ricardograca I see what you mean, I think I misconstrued what that sentence was saying. Let me revert that and format them as code, if that works?. @ricardograca sorry about that -- my fingers were moving too fast \ud83d\ude07. "
}