{
    "njdehoog": "Thanks!\nCurrently the only way to control the size is by setting the preferredRowSize property, although this doesn't enforce a maximum size.\nEnforcing a maximum size would be useful, although I'm not sure how to accomplish this yet. Feel free to issue a pull request if you come up with a solution.\n\nOn 9 nov. 2013, at 15:13, wimaha notifications@github.com wrote:\nHi,\nvery nice Controll!\nIs it possible to change the behavior so that the images are not enlarged?\n\u2014\nReply to this email directly or view it on GitHub.\n. The sample code you're showing here returns a random size, and thus a different size every time the prefferedSizeForItemAtIndexPath method is called. The prefferedSizeForItemAtIndexPath is called multiple times throughout the layout process and expects a consistent size to be returned for each index path.\n\nIf you want to test with random sizes you should store them in an array and implement the delegate method like this\nobjective-c\nreturn [[self.sizes objectAtIndex:indexPath.item] CGSizeValue];\nAlso make sure to set the contentMode on the cell's image view to aspect fill in this case.\n. I've replicated your example with this code and it works perfectly:\n```\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    self = [super initWithCoder:aDecoder];\n    if (self) {\n    _sizes = [NSMutableArray array];\n\n    NSMutableArray *images = [[NSMutableArray alloc] init];\n    for (int i = 1; i <= NUMBER_OF_IMAGES; i++) {\n        NSString *imageName = [NSString stringWithFormat:@\"photo-%02d.jpg\", i];\n        UIImage *image = [UIImage imageNamed:imageName];\n        [images addObject:image];\n\n        CGSize size = [image size];\n        size.width += arc4random()%2000;\n        size.height += arc4random()%2000;\n        [_sizes addObject:[NSValue valueWithCGSize:size]];\n    }\n    _images = [images copy];\n}\n\nreturn self;\n\n}\npragma mark - UICollectionViewFlowLayoutDelegate\n\n(CGSize)collectionView:(UICollectionView )collectionView layout:(NHBalancedFlowLayout )collectionViewLayout preferredSizeForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    return [[self.sizes objectAtIndex:indexPath.item] CGSizeValue];\n}\n``\n. Thanks for reporting this. Would you mind posting the values forsequenceandnumberOfPartitionsat the time it crashes, so I can reproduce the issue by calling the method with these values?\n. On line 20 ofNHLinearPartition.mI've changedif (k > n)toif (k >= n)`. This should solve the problem. I've also added the following unit test to see if it worked:\n\n```\n- (void)testNumberOfPartitionsEqualToSequenceCount\n{\n    NSArray *sequence = @[@346, @146, @125];\n    NSInteger numberOfPartitions = 3;\nNSArray *partition = [NHLinearPartition linearPartitionForSequence:sequence numberOfPartitions:numberOfPartitions];\nXCTAssertNotNil(partition, @\"should return valid partition\");\n\n}\n```\nLet me know if this solves your problem.\n. I've updated the podspec file. If you would create a PR for the cocoapods repo that would be great.\n. Thanks!\n. I spent some time researching it this morning, but I haven't figured out the flaw in the implementation of the algorithm yet. I'm planning to look into it further once I have more time. If adding the break works for you then I suggest going with that for now.\n. I've finally had some time to dig into this issue, and I'm quite sure this issue is fixed now. The latest version is 0.1.2.\nPlease let me know if this solved your issue.\n. Thanks for doing the research on this. I was expecting this could be a problem with larger data sets, but I had not tested this yet.\nYou're probably right that using a pure C implementation for the algorithm would increase performance dramatically. I don't have a lot of experience writing C code myself, so I might not get around to doing something about this for a while. If you are able to write a better/faster implementation of the algorithm, please issue a pull request, and I'll merge it back in.\n. Every time you do a reload on the collection view it needs to recalculate the positioning information for all the cells. That's probably what's causing the lag. Do you know the sizes of the images before you download them? Because then you wouldn't have to reload the cells.\n. When an operation completes you could ask the collection view for the corresponding cell by calling cellForItemAtIndexPath, and then set the image directly, without reloading the cell.\n. The main performance issues should be fixed in: 817a6ab\n. That's not on my to do list right now, but feel free to add it and issue a pull request. It would be a great feature to have.\n. This works the same as it would with any implementation of UICollectionView. Please refer to the UICollectionView documentation.\n. Sorry it that it took me a while to merge this. I was on holiday.\nThanks for implementing this header and footer support. It looks great! The only thing I changed is that the header and footer views are stretched to fit the size of the collection view, as this is the behavior in UICollectionViewFlowLayout. See the documentation for headerReferenceSize:\n\nDuring layout, only the size that corresponds to the appropriate scrolling direction is used. For example, for the vertical scrolling direction, the layout object uses the height value returned by your method. (In that instance, the width of the header would be set to the width of the collection view.) If the size in the appropriate scrolling dimension is 0, no header is added.\n. I haven't had the time to look into this yet, but it might be related to this issue: #16.\n. Great stuff @lickylick!\n. Thanks! I missed that.\n. I'm not sure I understand what you are trying to achieve. Could you explain what the end result should look like?\n. Thanks for the explanation. I don't think it will cause any problems if you change the superclass to be UICollectionViewFlowLayout, although I can't make any promises.\n\nThe main issue however would seem to be how you would handle resizing of the cells when reordering. Are you planning to recalculate the layout every time the selected cell is dragged to a different position?\n. I think it is possible, but I'm not sure how I would implement it. Normally when you reorder items, the items are of the same size, so you don't have to do any resizing. This situation will be a bit trickier to solve, especially if you want to make it look natural. Let me know if you've figured it out though! I would love to see your solution.\n. The reason for not subclassing UICollectionViewFlowLayout is that it currently does not support all the delegate methods defined in UICollectionViewDelegateFlowLayout, so that might be confusing.\nLet me know if you can find the origin of the crash, then maybe I could fix it.\n. Thanks for the pull request. If you undo changing the super class to UICollectionViewFlowLayout and explain how you're solving the crash I would be happy to merge it back.\n. Fixed in #16 \n. Thanks for the fix, and apologies for the delay in merging it back.\n. This seems to undo a lot of the optimizations made here: #9. Have you tested the performance against the latest version?\n. Yeah try that. Those modifications have dramatically improved performance already.\n. Thanks for pointing that out. Fixed now: b877f1c27acccafe767b44897d00535bef967fdc\n. Thanks for issuing a pull request. I would need to look at this a bit more thoroughly before merging it back, because right now the entire layout would be invalidated many times during scrolling, and I think that will adversely affect performance.\n. The behavior of the layout mechanism is that it always tries to fill the available space. The issue with implementing a maximumRowHeight is that it would break the layout mechanism's ability to do that.\nCan you explain the kind of behavior that you would expect? Is this only an issue when displaying one or two items?\n. Thanks for the explanation. I'm not sure that this component offers the functionality that you're looking for. You might want to try and write your own custom collection view layout. This article offers a good starting point: http://www.objc.io/issue-3/collection-view-layouts.html\n. Are you adding every new batch of items to a different section, or are all the images in the same section. The layout is calculated per section, so adding a new section should allow the previous section to remain unchanged. Although I'm not sure if it would redo the calculation for the previous sections as well.\n. That's right. The implementation of the layout algorithm is such that it tries to determine the best possible layout based on every image in a section, so every time you add a new image it is likely to affect the layout. \n. As a quick workaround I would suggest using larger thumbnails, so that there is a bit of room for error. In terms of a more solid solution, I'm not sure what it would take to achieve that at this moment. This would require some changes to the logic of the layout algorithm. I would be happy to do some consulting for you if you'd like me to help you figure it out. Otherwise feel free to fork the project and contribute.\n. @thelordy Please create an issue in @graetzer's fork to discuss this issue.\n. Have you been able to pinpoint the line of code that causes the crash?\n. Hi Steven, I think adding support for supplementary views is a good idea. For me this is currently not a priority to work on, but feel free to take a shot at it and issue a pull request.\n. The layout object is created as part of the storyboard. You can drag in a collection view layout object in interface builder, and change the class to be NHBalancedFlowLayout. \n. I'm running the demo with XCode 6 GM and it looks fine. Did you make any changes to the demo project?\n. \n. Yes I see the problem occur now. Doing a bit of digging, trying to figure out what is going on.\n. So far it looks like this is some kind of auto layout issue. The layout is correct, but the image views within the cells are not given the correct size\n. For some reason the contentView is not layed out correctly. I've found a workaround that seems to work for now. Just add these lines in ImageCell.m\n- (void)layoutSubviews\n{\n    [super layoutSubviews];    \n    self.contentView.frame = self.bounds;\n}\n. It's better not to override setBounds directly, but instead use layoutSubviews. Layoutsubviews will only be triggered when actually necessary.\n. Looks like the same issue as this one: https://github.com/njdehoog/NHBalancedFlowLayout/issues/27\n. No worries. Glad you solved it\n. Please be a little bit more specific about the problem you're running into. What is the expected behavior and what are you seeing? Does your app work with a regular flow layout?\n. Glad you were able to solve it!\n. That is currently outside the scope of this project. You might try looking at a solution like this: https://github.com/kaishin/ImageScout\n. Well it can work, but to calculate the layout you'll need to know the image sizes in advance.\n. @cooler333 As mentioned in the README, this project is no longer maintained. Please check out https://github.com/graetzer/NHBalancedFlowLayout for a more up-to-date version.\n. @graetzer Thanks for your PR. I am no longer maintaining this project. Would you mind if I just point people to your fork in the README?\n. Honestly it's been too long since I looked at this code, and I don't have the time to maintain it at the moment. I updated the REAME. Thanks again.\n. Thanks!\nCurrently the only way to control the size is by setting the preferredRowSize property, although this doesn't enforce a maximum size.\nEnforcing a maximum size would be useful, although I'm not sure how to accomplish this yet. Feel free to issue a pull request if you come up with a solution.\n\nOn 9 nov. 2013, at 15:13, wimaha notifications@github.com wrote:\nHi,\nvery nice Controll!\nIs it possible to change the behavior so that the images are not enlarged?\n\u2014\nReply to this email directly or view it on GitHub.\n. The sample code you're showing here returns a random size, and thus a different size every time the prefferedSizeForItemAtIndexPath method is called. The prefferedSizeForItemAtIndexPath is called multiple times throughout the layout process and expects a consistent size to be returned for each index path.\n\nIf you want to test with random sizes you should store them in an array and implement the delegate method like this\nobjective-c\nreturn [[self.sizes objectAtIndex:indexPath.item] CGSizeValue];\nAlso make sure to set the contentMode on the cell's image view to aspect fill in this case.\n. I've replicated your example with this code and it works perfectly:\n```\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    self = [super initWithCoder:aDecoder];\n    if (self) {\n    _sizes = [NSMutableArray array];\n\n    NSMutableArray *images = [[NSMutableArray alloc] init];\n    for (int i = 1; i <= NUMBER_OF_IMAGES; i++) {\n        NSString *imageName = [NSString stringWithFormat:@\"photo-%02d.jpg\", i];\n        UIImage *image = [UIImage imageNamed:imageName];\n        [images addObject:image];\n\n        CGSize size = [image size];\n        size.width += arc4random()%2000;\n        size.height += arc4random()%2000;\n        [_sizes addObject:[NSValue valueWithCGSize:size]];\n    }\n    _images = [images copy];\n}\n\nreturn self;\n\n}\npragma mark - UICollectionViewFlowLayoutDelegate\n\n(CGSize)collectionView:(UICollectionView )collectionView layout:(NHBalancedFlowLayout )collectionViewLayout preferredSizeForItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    return [[self.sizes objectAtIndex:indexPath.item] CGSizeValue];\n}\n``\n. Thanks for reporting this. Would you mind posting the values forsequenceandnumberOfPartitionsat the time it crashes, so I can reproduce the issue by calling the method with these values?\n. On line 20 ofNHLinearPartition.mI've changedif (k > n)toif (k >= n)`. This should solve the problem. I've also added the following unit test to see if it worked:\n\n```\n- (void)testNumberOfPartitionsEqualToSequenceCount\n{\n    NSArray *sequence = @[@346, @146, @125];\n    NSInteger numberOfPartitions = 3;\nNSArray *partition = [NHLinearPartition linearPartitionForSequence:sequence numberOfPartitions:numberOfPartitions];\nXCTAssertNotNil(partition, @\"should return valid partition\");\n\n}\n```\nLet me know if this solves your problem.\n. I've updated the podspec file. If you would create a PR for the cocoapods repo that would be great.\n. Thanks!\n. I spent some time researching it this morning, but I haven't figured out the flaw in the implementation of the algorithm yet. I'm planning to look into it further once I have more time. If adding the break works for you then I suggest going with that for now.\n. I've finally had some time to dig into this issue, and I'm quite sure this issue is fixed now. The latest version is 0.1.2.\nPlease let me know if this solved your issue.\n. Thanks for doing the research on this. I was expecting this could be a problem with larger data sets, but I had not tested this yet.\nYou're probably right that using a pure C implementation for the algorithm would increase performance dramatically. I don't have a lot of experience writing C code myself, so I might not get around to doing something about this for a while. If you are able to write a better/faster implementation of the algorithm, please issue a pull request, and I'll merge it back in.\n. Every time you do a reload on the collection view it needs to recalculate the positioning information for all the cells. That's probably what's causing the lag. Do you know the sizes of the images before you download them? Because then you wouldn't have to reload the cells.\n. When an operation completes you could ask the collection view for the corresponding cell by calling cellForItemAtIndexPath, and then set the image directly, without reloading the cell.\n. The main performance issues should be fixed in: 817a6ab\n. That's not on my to do list right now, but feel free to add it and issue a pull request. It would be a great feature to have.\n. This works the same as it would with any implementation of UICollectionView. Please refer to the UICollectionView documentation.\n. Sorry it that it took me a while to merge this. I was on holiday.\nThanks for implementing this header and footer support. It looks great! The only thing I changed is that the header and footer views are stretched to fit the size of the collection view, as this is the behavior in UICollectionViewFlowLayout. See the documentation for headerReferenceSize:\n\nDuring layout, only the size that corresponds to the appropriate scrolling direction is used. For example, for the vertical scrolling direction, the layout object uses the height value returned by your method. (In that instance, the width of the header would be set to the width of the collection view.) If the size in the appropriate scrolling dimension is 0, no header is added.\n. I haven't had the time to look into this yet, but it might be related to this issue: #16.\n. Great stuff @lickylick!\n. Thanks! I missed that.\n. I'm not sure I understand what you are trying to achieve. Could you explain what the end result should look like?\n. Thanks for the explanation. I don't think it will cause any problems if you change the superclass to be UICollectionViewFlowLayout, although I can't make any promises.\n\nThe main issue however would seem to be how you would handle resizing of the cells when reordering. Are you planning to recalculate the layout every time the selected cell is dragged to a different position?\n. I think it is possible, but I'm not sure how I would implement it. Normally when you reorder items, the items are of the same size, so you don't have to do any resizing. This situation will be a bit trickier to solve, especially if you want to make it look natural. Let me know if you've figured it out though! I would love to see your solution.\n. The reason for not subclassing UICollectionViewFlowLayout is that it currently does not support all the delegate methods defined in UICollectionViewDelegateFlowLayout, so that might be confusing.\nLet me know if you can find the origin of the crash, then maybe I could fix it.\n. Thanks for the pull request. If you undo changing the super class to UICollectionViewFlowLayout and explain how you're solving the crash I would be happy to merge it back.\n. Fixed in #16 \n. Thanks for the fix, and apologies for the delay in merging it back.\n. This seems to undo a lot of the optimizations made here: #9. Have you tested the performance against the latest version?\n. Yeah try that. Those modifications have dramatically improved performance already.\n. Thanks for pointing that out. Fixed now: b877f1c27acccafe767b44897d00535bef967fdc\n. Thanks for issuing a pull request. I would need to look at this a bit more thoroughly before merging it back, because right now the entire layout would be invalidated many times during scrolling, and I think that will adversely affect performance.\n. The behavior of the layout mechanism is that it always tries to fill the available space. The issue with implementing a maximumRowHeight is that it would break the layout mechanism's ability to do that.\nCan you explain the kind of behavior that you would expect? Is this only an issue when displaying one or two items?\n. Thanks for the explanation. I'm not sure that this component offers the functionality that you're looking for. You might want to try and write your own custom collection view layout. This article offers a good starting point: http://www.objc.io/issue-3/collection-view-layouts.html\n. Are you adding every new batch of items to a different section, or are all the images in the same section. The layout is calculated per section, so adding a new section should allow the previous section to remain unchanged. Although I'm not sure if it would redo the calculation for the previous sections as well.\n. That's right. The implementation of the layout algorithm is such that it tries to determine the best possible layout based on every image in a section, so every time you add a new image it is likely to affect the layout. \n. As a quick workaround I would suggest using larger thumbnails, so that there is a bit of room for error. In terms of a more solid solution, I'm not sure what it would take to achieve that at this moment. This would require some changes to the logic of the layout algorithm. I would be happy to do some consulting for you if you'd like me to help you figure it out. Otherwise feel free to fork the project and contribute.\n. @thelordy Please create an issue in @graetzer's fork to discuss this issue.\n. Have you been able to pinpoint the line of code that causes the crash?\n. Hi Steven, I think adding support for supplementary views is a good idea. For me this is currently not a priority to work on, but feel free to take a shot at it and issue a pull request.\n. The layout object is created as part of the storyboard. You can drag in a collection view layout object in interface builder, and change the class to be NHBalancedFlowLayout. \n. I'm running the demo with XCode 6 GM and it looks fine. Did you make any changes to the demo project?\n. \n. Yes I see the problem occur now. Doing a bit of digging, trying to figure out what is going on.\n. So far it looks like this is some kind of auto layout issue. The layout is correct, but the image views within the cells are not given the correct size\n. For some reason the contentView is not layed out correctly. I've found a workaround that seems to work for now. Just add these lines in ImageCell.m\n- (void)layoutSubviews\n{\n    [super layoutSubviews];    \n    self.contentView.frame = self.bounds;\n}\n. It's better not to override setBounds directly, but instead use layoutSubviews. Layoutsubviews will only be triggered when actually necessary.\n. Looks like the same issue as this one: https://github.com/njdehoog/NHBalancedFlowLayout/issues/27\n. No worries. Glad you solved it\n. Please be a little bit more specific about the problem you're running into. What is the expected behavior and what are you seeing? Does your app work with a regular flow layout?\n. Glad you were able to solve it!\n. That is currently outside the scope of this project. You might try looking at a solution like this: https://github.com/kaishin/ImageScout\n. Well it can work, but to calculate the layout you'll need to know the image sizes in advance.\n. @cooler333 As mentioned in the README, this project is no longer maintained. Please check out https://github.com/graetzer/NHBalancedFlowLayout for a more up-to-date version.\n. @graetzer Thanks for your PR. I am no longer maintaining this project. Would you mind if I just point people to your fork in the README?\n. Honestly it's been too long since I looked at this code, and I don't have the time to maintain it at the moment. I updated the REAME. Thanks again.\n. ",
    "wimaha": "Thanks for the answer.\nI'm using the preferredRowSize property and the result is near perfect!\nI will close the issue. If there will be a solution for defining a max size for each image, someone could issue a pull request.\n. I don't know why, but the header/footer support causes some problems with NSFetchedResultsController. See: https://github.com/AshFurrow/UICollectionView-NSFetchedResultsController/issues/22#issuecomment-32678905\n. Thanks for the answer.\nI'm using the preferredRowSize property and the result is near perfect!\nI will close the issue. If there will be a solution for defining a max size for each image, someone could issue a pull request.\n. I don't know why, but the header/footer support causes some problems with NSFetchedResultsController. See: https://github.com/AshFurrow/UICollectionView-NSFetchedResultsController/issues/22#issuecomment-32678905\n. ",
    "firebird0001": "Finally I found the problem - wrong constraints in my custom cell .xib, absolutely my fault.\nThis is a great control! Thank you for your time.\n. Finally I found the problem - wrong constraints in my custom cell .xib, absolutely my fault.\nThis is a great control! Thank you for your time.\n. ",
    "KrauseFx": "Sure\nSequence: [346, 146, 125]\nnumberOfPartitions: 3\nYou can see the values of the other variables in the screenshot. Let me know if you need more information. \nThank you!\n. I guess it's very easily possible to reproduce when you load the images from a web server and reloadData after you add each image. That's exactly what I do.\n. Thanks for the fast fix - yes, this solves the crash. \nCould you do a Cocoapods release for that fix? Should I prepare a PR?\n. Great. Yes, I submitted the PR: https://github.com/CocoaPods/Specs/pull/5951\n. Unfortunately the same problem occurred again after adding more images: https://www.dropbox.com/s/ysqya81zm7d2vba/Screenshot%202013-12-06%2018.26.04.png\nSequence: [346, 150, 125, 71, 137]\nnumberOfPartitions: 4\nThanks again\n. Do you have a simple, temporary workaround? Is it okay to to add a 'break' when i equals 0 to just skip one image? It's ok to skip one image, instead of crashing the whole app.\n. Thanks for realising the update. I haven't had problems for a month now, so it seems to be working :+1: \n. Sure\nSequence: [346, 146, 125]\nnumberOfPartitions: 3\nYou can see the values of the other variables in the screenshot. Let me know if you need more information. \nThank you!\n. I guess it's very easily possible to reproduce when you load the images from a web server and reloadData after you add each image. That's exactly what I do.\n. Thanks for the fast fix - yes, this solves the crash. \nCould you do a Cocoapods release for that fix? Should I prepare a PR?\n. Great. Yes, I submitted the PR: https://github.com/CocoaPods/Specs/pull/5951\n. Unfortunately the same problem occurred again after adding more images: https://www.dropbox.com/s/ysqya81zm7d2vba/Screenshot%202013-12-06%2018.26.04.png\nSequence: [346, 150, 125, 71, 137]\nnumberOfPartitions: 4\nThanks again\n. Do you have a simple, temporary workaround? Is it okay to to add a 'break' when i equals 0 to just skip one image? It's ok to skip one image, instead of crashing the whole app.\n. Thanks for realising the update. I haven't had problems for a month now, so it seems to be working :+1: \n. ",
    "ddaddy": "I'm also seeing performance issues with this :(\nIt's looks really good in my app, but after implementing it the performance is poor when initially adding the images to the cell's.\nI download images on a background thread for each cell and when finished I call 'reloadItemsAtIndexPaths' for that cell. At this point the scrolling gets really jittery.\nIf I change the layout to a standard UICollectionViewFlowLayout it flies.\n. I have all the necessary background operations to make it all run smoothly. Like I said above, it runs perfectly fine when I substitute this layout for a standard one. The bottleneck is with the actual refresh of the cell or collectionView\n. How can I add the image to the cell without reloading the cell?\nA lot of the images are on the device. I use an NSOperationQueue to check each one and if it's not available it downloads it from the net. The NSOperation returns with an image either from disc or web.\nI guess the recalculation is just too complex and I may have to look at a simpler approach.\nThanks for your work.\n. That's an idea, I hadn't thought of that.\nI'll try now, thanks.\n. I'm also seeing performance issues with this :(\nIt's looks really good in my app, but after implementing it the performance is poor when initially adding the images to the cell's.\nI download images on a background thread for each cell and when finished I call 'reloadItemsAtIndexPaths' for that cell. At this point the scrolling gets really jittery.\nIf I change the layout to a standard UICollectionViewFlowLayout it flies.\n. I have all the necessary background operations to make it all run smoothly. Like I said above, it runs perfectly fine when I substitute this layout for a standard one. The bottleneck is with the actual refresh of the cell or collectionView\n. How can I add the image to the cell without reloading the cell?\nA lot of the images are on the device. I use an NSOperationQueue to check each one and if it's not available it downloads it from the net. The NSOperation returns with an image either from disc or web.\nI guess the recalculation is just too complex and I may have to look at a simpler approach.\nThanks for your work.\n. That's an idea, I hadn't thought of that.\nI'll try now, thanks.\n. ",
    "mwyman": "ddaddy, in general you should not be reloading the cells when network connections come back with the image. You should really check out something like AFNetwork's asynchronous image views, as they can have much better scrolling performance in large collections or table views.\n. ddaddy, in general you should not be reloading the cells when network connections come back with the image. You should really check out something like AFNetwork's asynchronous image views, as they can have much better scrolling performance in large collections or table views.\n. ",
    "sambudda": "Also if I touch the same picture again how do I de-select the same picture\n. Never mind I figured out a different way. The way I know if an image is highlighted is by changing the alpha of cell image. Please add that feature for users in future. Again thanks for a wonderful project.\nHere's a complete code for anyone else who wants to use this in future\n@property (nonatomic, strong) NSArray images;\n@property (nonatomic, strong) NSArray itemSizes;\n@property (nonatomic, strong) NSMutableArray imgsArray;\n@property (nonatomic, strong) NSMutableArray selectedItemArray;\n@end\n@implementation ViewController\n@synthesize imgsArray;\n@synthesize selectedItemArray;\n- (id)initWithCoder:(NSCoder *)aDecoder\n  {\n  self = [super initWithCoder:aDecoder];\n  if (self)\n  {\nNSMutableArray *images = [[NSMutableArray alloc] init];\n  imgsArray = [[NSMutableArray alloc] init];\n  selectedItemArray = [[NSMutableArray alloc] init];\n  for (int i = 1; i <= NUMBER_OF_IMAGES; i++)\n  {\n      NSString *imageName = [NSString stringWithFormat:@\"photo-%02d.jpg\", i];\n      [images addObject:[UIImage imageNamed:imageName]];\n      [imgsArray addObject:imageName];\n  }\n  _images = [images copy];\n}\nreturn self;\n  }\npragma mark - UICollectionViewFlowLayoutDelegate\n\n(CGSize)collectionView:(UICollectionView )collectionView layout:(NHBalancedFlowLayout )collectionViewLayout preferredSizeForItemAtIndexPath:(NSIndexPath *)indexPath\n  {\n  return [[self.images objectAtIndex:indexPath.item] size];\n  }\n\npragma mark - UICollectionView data source\n\n(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView\n  {\n  return 1;\n  }\n(NSInteger)collectionView:(UICollectionView *)view numberOfItemsInSection:(NSInteger)section;\n  {\n  return [self.images count];\n  }\n(UICollectionViewCell )collectionView:(UICollectionView )collectionView cellForItemAtIndexPath:(NSIndexPath )indexPath;\n  {\n  ImageCell cell = [collectionView dequeueReusableCellWithReuseIdentifier:@\"ImageCell\" forIndexPath:indexPath];\n  cell.imageView.image = nil;\n\n/*\n  - Decompress image on background thread before displaying it to prevent lag\n    /\n    NSInteger rowIndex = indexPath.row;\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\nUIImage *image = [UIImage decodedImageWithImage:[self.images objectAtIndex:indexPath.item]];\n\ndispatch_async(dispatch_get_main_queue(), ^{\n    NSIndexPath *currentIndexPathForCell = [collectionView indexPathForCell:cell];\n    if (currentIndexPathForCell.row == rowIndex) {\n        cell.imageView.image = image;\n    }\n});\n});\n\n//TESTING\n  if([selectedItemArray containsObject:indexPath])\n  {\n      cell.alpha = 0.7;\n  }\n  else\n  {\n      cell.alpha = 1.0;\n  }\nreturn cell;\n  }\n- (void)collectionView:(UICollectionView )collectionView didSelectItemAtIndexPath:(NSIndexPath )indexPath\n  {\n  //NSLog(@\"%s ..\", PRETTY_FUNCTION);\nNSString *nameSelected = [imgsArray objectAtIndex:indexPath.row];\n  NSLog(@\"nameSelected: %@ ...\", nameSelected);\nUICollectionViewCell *datasetCell =[collectionView cellForItemAtIndexPath:indexPath];\n  //datasetCell.alpha = 0.7; // highlight selection\nif([selectedItemArray containsObject:indexPath])\n  {\n      //it does remove it\n      [selectedItemArray removeAllObjects];\n      datasetCell.alpha = 1.0;\n  }\n  else\n  {\n      //add it\n      [selectedItemArray removeAllObjects];\n      [selectedItemArray addObject:indexPath];\n      datasetCell.alpha = 0.7;\n}\n}\n- (void)collectionView:(UICollectionView )collectionView didDeselectItemAtIndexPath:(NSIndexPath )indexPath {\n  NSLog(@\"%s\", PRETTY_FUNCTION);\nUICollectionViewCell datasetCell =[collectionView cellForItemAtIndexPath:indexPath];\n  datasetCell.alpha = 1.0; //deselect\n  }\n- (BOOL)collectionView:(UICollectionView )collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath\n  {\n  NSLog(@\"%s\", PRETTY_FUNCTION);\n  return YES;\n  }\n. Also if I touch the same picture again how do I de-select the same picture\n. Never mind I figured out a different way. The way I know if an image is highlighted is by changing the alpha of cell image. Please add that feature for users in future. Again thanks for a wonderful project.\nHere's a complete code for anyone else who wants to use this in future\n@property (nonatomic, strong) NSArray images;\n@property (nonatomic, strong) NSArray itemSizes;\n@property (nonatomic, strong) NSMutableArray imgsArray;\n@property (nonatomic, strong) NSMutableArray selectedItemArray;\n@end\n@implementation ViewController\n@synthesize imgsArray;\n@synthesize selectedItemArray;\n- (id)initWithCoder:(NSCoder *)aDecoder\n  {\n  self = [super initWithCoder:aDecoder];\n  if (self)\n  {\nNSMutableArray *images = [[NSMutableArray alloc] init];\n  imgsArray = [[NSMutableArray alloc] init];\n  selectedItemArray = [[NSMutableArray alloc] init];\n  for (int i = 1; i <= NUMBER_OF_IMAGES; i++)\n  {\n      NSString *imageName = [NSString stringWithFormat:@\"photo-%02d.jpg\", i];\n      [images addObject:[UIImage imageNamed:imageName]];\n      [imgsArray addObject:imageName];\n  }\n  _images = [images copy];\n}\nreturn self;\n  }\npragma mark - UICollectionViewFlowLayoutDelegate\n\n(CGSize)collectionView:(UICollectionView )collectionView layout:(NHBalancedFlowLayout )collectionViewLayout preferredSizeForItemAtIndexPath:(NSIndexPath *)indexPath\n  {\n  return [[self.images objectAtIndex:indexPath.item] size];\n  }\n\npragma mark - UICollectionView data source\n\n(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView\n  {\n  return 1;\n  }\n(NSInteger)collectionView:(UICollectionView *)view numberOfItemsInSection:(NSInteger)section;\n  {\n  return [self.images count];\n  }\n(UICollectionViewCell )collectionView:(UICollectionView )collectionView cellForItemAtIndexPath:(NSIndexPath )indexPath;\n  {\n  ImageCell cell = [collectionView dequeueReusableCellWithReuseIdentifier:@\"ImageCell\" forIndexPath:indexPath];\n  cell.imageView.image = nil;\n\n/*\n  - Decompress image on background thread before displaying it to prevent lag\n    /\n    NSInteger rowIndex = indexPath.row;\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\nUIImage *image = [UIImage decodedImageWithImage:[self.images objectAtIndex:indexPath.item]];\n\ndispatch_async(dispatch_get_main_queue(), ^{\n    NSIndexPath *currentIndexPathForCell = [collectionView indexPathForCell:cell];\n    if (currentIndexPathForCell.row == rowIndex) {\n        cell.imageView.image = image;\n    }\n});\n});\n\n//TESTING\n  if([selectedItemArray containsObject:indexPath])\n  {\n      cell.alpha = 0.7;\n  }\n  else\n  {\n      cell.alpha = 1.0;\n  }\nreturn cell;\n  }\n- (void)collectionView:(UICollectionView )collectionView didSelectItemAtIndexPath:(NSIndexPath )indexPath\n  {\n  //NSLog(@\"%s ..\", PRETTY_FUNCTION);\nNSString *nameSelected = [imgsArray objectAtIndex:indexPath.row];\n  NSLog(@\"nameSelected: %@ ...\", nameSelected);\nUICollectionViewCell *datasetCell =[collectionView cellForItemAtIndexPath:indexPath];\n  //datasetCell.alpha = 0.7; // highlight selection\nif([selectedItemArray containsObject:indexPath])\n  {\n      //it does remove it\n      [selectedItemArray removeAllObjects];\n      datasetCell.alpha = 1.0;\n  }\n  else\n  {\n      //add it\n      [selectedItemArray removeAllObjects];\n      [selectedItemArray addObject:indexPath];\n      datasetCell.alpha = 0.7;\n}\n}\n- (void)collectionView:(UICollectionView )collectionView didDeselectItemAtIndexPath:(NSIndexPath )indexPath {\n  NSLog(@\"%s\", PRETTY_FUNCTION);\nUICollectionViewCell datasetCell =[collectionView cellForItemAtIndexPath:indexPath];\n  datasetCell.alpha = 1.0; //deselect\n  }\n- (BOOL)collectionView:(UICollectionView )collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath\n  {\n  NSLog(@\"%s\", PRETTY_FUNCTION);\n  return YES;\n  }\n. ",
    "laucel": "I'm having the same problem as @wimaha, solved by removing header/footer support. Any other suggestions?\n. I'm having the same problem as @wimaha, solved by removing header/footer support. Any other suggestions?\n. ",
    "sneakyness": ":+1: this rules\n. :+1: this rules\n. ",
    "GalaTech": "I apologize for the lack of clarity. I am needing to combine your control with another: https://github.com/lxcid/LXReorderableCollectionViewFlowLayout\nI really need your functionality, but I'm also wanting the ability to reorder the collectionView. The problem is that your control subclasses from UICollectionViewLayout and this other control subclasses from UICollectionViewFlowLayout. I need to somehow put them together, but like I said, they subclass from two different superclasses. Is it safe to move yours to subclass from UICollectionViewFlowLayout rather than what is now? In doing so I should have a better base for combining the two classes. \nThanks!\n. I appreciate you getting back with me! I actually hadn't looked into how I was planning to fully implement it, but do you think that would be a pretty big problem/is it possible to do it this way?\nThanks!\n. I apologize for the lack of clarity. I am needing to combine your control with another: https://github.com/lxcid/LXReorderableCollectionViewFlowLayout\nI really need your functionality, but I'm also wanting the ability to reorder the collectionView. The problem is that your control subclasses from UICollectionViewLayout and this other control subclasses from UICollectionViewFlowLayout. I need to somehow put them together, but like I said, they subclass from two different superclasses. Is it safe to move yours to subclass from UICollectionViewFlowLayout rather than what is now? In doing so I should have a better base for combining the two classes. \nThanks!\n. I appreciate you getting back with me! I actually hadn't looked into how I was planning to fully implement it, but do you think that would be a pretty big problem/is it possible to do it this way?\nThanks!\n. ",
    "rvi": "OK got it. I just send you  a pull request, with subclassing.\n. Ok Will do tomorrow !\nSent from my iPhone\n\nOn 13 f\u00e9vr. 2014, at 16:53, Niels de Hoog notifications@github.com wrote:\nThanks for the pull request. If you undo changing the super class to UICollectionViewFlowLayout and explain how you're solving the crash I would be happy to merge it back.\n\u2014\nReply to this email directly or view it on GitHub.\n. It's not only the check, you have to return nil if you don't want the app crash. I tried few things on removing header and footer.\n\n_Imagine we want only the header, no footer. _\nThis methods should return nil for no footer: \n- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;\nAnd this method, declared in UICollectionViewDatasource :\n```\n- (UICollectionReusableView )collectionView:(UICollectionView )collectionView viewForSupplementaryElementOfKind:(NSString )kind atIndexPath:(NSIndexPath )indexPath\n{\n    UICollectionReusableView *view = nil;\nif ([kind isEqualToString:UICollectionElementKindSectionHeader]) {\n    view = [collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:@\"HeaderView\" forIndexPath:indexPath];\n}\nelse if ([kind isEqualToString:UICollectionElementKindSectionFooter]) {\n    view = nil; // [collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:@\"FooterView\" forIndexPath:indexPath];\n}\nreturn view;\n\n}\n```\nNote:  The crash is  not in your code, but in _createPreparedSupplementaryViewForElementOfKind: which is a private API of UICollectionView.\nIs that more clear now ?\n. Thanks @chiahsien  ! :+1: \nThat's not the code of the Layout (only the demo project). I updated my comment.\n. No problem ! Thanks for this awesome layout :)\nSent from my iPhone\n\nOn 16 f\u00e9vr. 2014, at 11:07, Niels de Hoog notifications@github.com wrote:\nThanks for the fix, and apologies for the delay in merging it back.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes I'm totally agree. If I've got some time to investigate, I'll improve my code, and pull request back.\n. Sorry, didn't saw it !\n. OK got it. I just send you  a pull request, with subclassing.\n. Ok Will do tomorrow !\n\nSent from my iPhone\n\nOn 13 f\u00e9vr. 2014, at 16:53, Niels de Hoog notifications@github.com wrote:\nThanks for the pull request. If you undo changing the super class to UICollectionViewFlowLayout and explain how you're solving the crash I would be happy to merge it back.\n\u2014\nReply to this email directly or view it on GitHub.\n. It's not only the check, you have to return nil if you don't want the app crash. I tried few things on removing header and footer.\n\n_Imagine we want only the header, no footer. _\nThis methods should return nil for no footer: \n- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;\nAnd this method, declared in UICollectionViewDatasource :\n```\n- (UICollectionReusableView )collectionView:(UICollectionView )collectionView viewForSupplementaryElementOfKind:(NSString )kind atIndexPath:(NSIndexPath )indexPath\n{\n    UICollectionReusableView *view = nil;\nif ([kind isEqualToString:UICollectionElementKindSectionHeader]) {\n    view = [collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:@\"HeaderView\" forIndexPath:indexPath];\n}\nelse if ([kind isEqualToString:UICollectionElementKindSectionFooter]) {\n    view = nil; // [collectionView dequeueReusableSupplementaryViewOfKind:kind withReuseIdentifier:@\"FooterView\" forIndexPath:indexPath];\n}\nreturn view;\n\n}\n```\nNote:  The crash is  not in your code, but in _createPreparedSupplementaryViewForElementOfKind: which is a private API of UICollectionView.\nIs that more clear now ?\n. Thanks @chiahsien  ! :+1: \nThat's not the code of the Layout (only the demo project). I updated my comment.\n. No problem ! Thanks for this awesome layout :)\nSent from my iPhone\n\nOn 16 f\u00e9vr. 2014, at 11:07, Niels de Hoog notifications@github.com wrote:\nThanks for the fix, and apologies for the delay in merging it back.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes I'm totally agree. If I've got some time to investigate, I'll improve my code, and pull request back.\n. Sorry, didn't saw it !\n. \n",
    "chiahsien": "From Apple's document for - (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath, it says\n\nReturn Value\nA configured supplementary view object. You must not return nil from this method.\n\nThe point is: You must not return nil for this method.\n. From Apple's document for - (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath, it says\n\nReturn Value\nA configured supplementary view object. You must not return nil from this method.\n\nThe point is: You must not return nil for this method.\n. ",
    "fingerco": "I'm not sure why it looks like it deleted things. It should be the exact same code just refactored in these ways:\nNSArrays are initialized with a capacity (known from the variables used to iterate in the for loops). This prevents the arrays from having to reallocate memory as objects are added to them.\nInstead of an NSDictionary which is then sorted to find the minimum, a running minimum is created. This speeds everything up because allocating a dictionary and adding to it takes up a lot of time relative to changing an NSInteger.\nYou may want to make sure that this is a complete refactor but my tests with the latest release lowered the time to process from 2 seconds to around 2/5ths of a second.\n. On further inspection it looks like it removed that optimization. I'll integrate it and modify this request.\n. It would seem that this performance issue was due to me using an outdated version of the library (the homepage suggests an outdated version) and this was a fix for that. Keep up the good work!\n. I'm not sure why it looks like it deleted things. It should be the exact same code just refactored in these ways:\nNSArrays are initialized with a capacity (known from the variables used to iterate in the for loops). This prevents the arrays from having to reallocate memory as objects are added to them.\nInstead of an NSDictionary which is then sorted to find the minimum, a running minimum is created. This speeds everything up because allocating a dictionary and adding to it takes up a lot of time relative to changing an NSInteger.\nYou may want to make sure that this is a complete refactor but my tests with the latest release lowered the time to process from 2 seconds to around 2/5ths of a second.\n. On further inspection it looks like it removed that optimization. I'll integrate it and modify this request.\n. It would seem that this performance issue was due to me using an outdated version of the library (the homepage suggests an outdated version) and this was a fix for that. Keep up the good work!\n. ",
    "jonathantrevor": "A current workaround is to say you have 1 or 2 more items than you actually have and return fake cells and sizes for them. But that isnt ideal.\n. Im trying to lay out a number of items, between 1 and 100. I'd like them to NOT be constrained by the frame they are in (Im adding them to a parent scroll view) but for each row to roughly be around 100px (for example). So I create the collection view in a really tall frame first, layout the contents, and then resize to fit the height. This strategy works really when I have 3 or more but if I have less than 3 OR all of the images are really tall (say 1000px) then I dont get any reduction in height since the layout manager CAN layout the items and \"fit\" them in the row. So its not only an issue with fewer than 3 items - but thats the easiest to see it happening on.\nSo Im currently adding in fake small cells to force the row closer to the minmum height I specify. I guess I could also try and limit the height and do some kind of average guess of the height I'll need for, say 3, items per row.\nThanks for the quick response.\n. A current workaround is to say you have 1 or 2 more items than you actually have and return fake cells and sizes for them. But that isnt ideal.\n. Im trying to lay out a number of items, between 1 and 100. I'd like them to NOT be constrained by the frame they are in (Im adding them to a parent scroll view) but for each row to roughly be around 100px (for example). So I create the collection view in a really tall frame first, layout the contents, and then resize to fit the height. This strategy works really when I have 3 or more but if I have less than 3 OR all of the images are really tall (say 1000px) then I dont get any reduction in height since the layout manager CAN layout the items and \"fit\" them in the row. So its not only an issue with fewer than 3 items - but thats the easiest to see it happening on.\nSo Im currently adding in fake small cells to force the row closer to the minmum height I specify. I guess I could also try and limit the height and do some kind of average guess of the height I'll need for, say 3, items per row.\nThanks for the quick response.\n. ",
    "futuretap": "I'd like to see a maximum cell size, too. Of course this would mean that the requirement of always filling the row horizontally can't be fulfilled anymore. Nevertheless this would help in the standard case of of a single picture that's zoomed up to 100% row width.\n. I'd like to see a maximum cell size, too. Of course this would mean that the requirement of always filling the row horizontally can't be fulfilled anymore. Nevertheless this would help in the standard case of of a single picture that's zoomed up to 100% row width.\n. ",
    "limenutt": "Yes, currently I'm using only one section and was looking for workaround without adding new section for every new batch. But looks like it is the only solution, am I right?\n. Yes, currently I'm using only one section and was looking for workaround without adding new section for every new batch. But looks like it is the only solution, am I right?\n. ",
    "graetzer": "If anybody else has this issue have a look at my fork https://github.com/graetzer/NHBalancedFlowLayout\n. Sure I think that's the best idea, if you don't want to test and merge the code. \n. If anybody else has this issue have a look at my fork https://github.com/graetzer/NHBalancedFlowLayout\n. Sure I think that's the best idea, if you don't want to test and merge the code. \n. ",
    "thelordy": "@graetzer How can i change the layout of your fork so i can have only 1 or 2 photo per row? Thanks.\n. @graetzer How can i change the layout of your fork so i can have only 1 or 2 photo per row? Thanks.\n. ",
    "rashidasgari": "Thanks for answering so quickly! I just managed to implement it and its working fine. \n. Thanks for answering so quickly! I just managed to implement it and its working fine. \n. ",
    "loicgriffie": "No i haven't made any changes. I just downloaded the demo zip from github and run from xcode 6 GM. As you can see on the screenshot i have a layout that do not work properly. Don't you have the same layout as the one posted ?\n. Ok I see. can you try the same but with iOS 7.1 simulator instead of iOS 8 on iphone 6 ?\n. This is weird. I downloaded xcode 5 and tried the demo project on iOS 7.1 simulator and had the same issue. Then i clean the project and tried again. All is ok. I'll try the same with xcode 6 and let you know\n. I have installed back xCode 6 GM and the problem do not exists on iPhone 6 simulator with iOS 8. But even if i clean the problem occurs with iOS 7.1 iPhone 5S. Do you confirm the same ?\n. I have also fixed it using the following code in the ImageCell.m\n- (void)setBounds:(CGRect)bounds\n  {\n  [super setBounds:bounds];\nself.contentView.frame = bounds;\n  }\n. Ok. thanks for your great lib and your support\n. No i haven't made any changes. I just downloaded the demo zip from github and run from xcode 6 GM. As you can see on the screenshot i have a layout that do not work properly. Don't you have the same layout as the one posted ?\n. Ok I see. can you try the same but with iOS 7.1 simulator instead of iOS 8 on iphone 6 ?\n. This is weird. I downloaded xcode 5 and tried the demo project on iOS 7.1 simulator and had the same issue. Then i clean the project and tried again. All is ok. I'll try the same with xcode 6 and let you know\n. I have installed back xCode 6 GM and the problem do not exists on iPhone 6 simulator with iOS 8. But even if i clean the problem occurs with iOS 7.1 iPhone 5S. Do you confirm the same ?\n. I have also fixed it using the following code in the ImageCell.m\n- (void)setBounds:(CGRect)bounds\n  {\n  [super setBounds:bounds];\nself.contentView.frame = bounds;\n  }\n. Ok. thanks for your great lib and your support\n. ",
    "tungvoduc": "Sorry, I forgot to attach the screenshots. It's not my app, it's your Demo. What I did was deleting Main.storyboard file and insert those lines into theses files and the problem occurs. Could it be because of ImageCell auto layout?\n\n\n. Yes !! The problem was because I didn't add constraint to the cell. I fixed it. Thank you. I love your project and your quick response.\n. Sorry, I forgot to attach the screenshots. It's not my app, it's your Demo. What I did was deleting Main.storyboard file and insert those lines into theses files and the problem occurs. Could it be because of ImageCell auto layout?\n\n\n. Yes !! The problem was because I didn't add constraint to the cell. I fixed it. Thank you. I love your project and your quick response.\n. ",
    "cooler333": "+1\n. +1\n. ",
    "sameer-bsb": "its like i need preferredColumnSize property \n. its like i need preferredColumnSize property \n. ",
    "ftp27": "I located this issue. Content gets wrong height when one of sections has 0 count of cells.\n. I located this issue. Content gets wrong height when one of sections has 0 count of cells.\n. "
}