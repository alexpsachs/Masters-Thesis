{
    "RReverser": "I've heard about this issue before and suspect that Safari maybe doesn't play video from dynamic Blob URLs, but 1) I can't debug and check this since don't have and can't install Safari on my Windows machine and 2) Safari is actually the only (?) browser that supports HLS natively on all the platforms, so this isn't worth time since convert+play approach isn't efficient there.\n. Hi, no, I don't actually decode H.264 images but use browser's native abilities for that. You may want to pack your image into, for example, MP4 by wrapping into corresponding binary structure, or have look at https://github.com/mbebenita/Broadway for decoder emscripten-converted implementation in JS.\n. Sorry, I don't have video-without-audio sample to test it on. Could you please try moving trak array (at line 235) to separate variable and conditionally .push(...) it's second element only when audioSize > 0?\n. Could you please commit that and send pull request so this issue won't appear for new users?\n. Thanks a lot!\n. Thanks for feedback. I planned to improve debugging in jBinary for pretty long time, but that wasn't highly requested, so I didn't spend any time on that. For some architectural reasons, it's not easy (and even not always possible) to detect field name being currently processed, in runtime. Instead, I just implemented and published jBinary v2.0.7 that utilizes Chrome / Firefox Dev Tools that allows to give debug name to closures. Now stack of that error looks like following:\n\nI believe this should help in debugging since you can see type signatures, field names and byte offsets inside current jBinary instance and so faster detect source of problem.\nNow regarding video sample - as stated on main page of repo, I implemented functionality heavily relying on official specifications (which are sometimes pretty crazy things to read and translate to code) and playing with video samples in HEX editor.\nApparently, a lot of tools have own deviations from specs, and specs theirselves are not always clear about edge cases, so there are deviations between some real samples and expected structures which result to errors like above. I tried to cover functionality for properly constructed chunks&streams, but, obviously, couldn't cover all the possible deviations since almost each sample that results in error needs separate studying for understanding source of problem and fixing / workarounding in structures.\nIf you could help to detect source of problem and fix structures correspondingly, that would be highly appreciated. Let me know if you need anything more from me (I hope after these debugging improvements it should go somewhat easier).\n. @maxlapshin Did you try to figure out reason of bug?\n. Didn't descriptive stack traces improvement help?\n. @maxlapshin I've added nodejs branch with adapted code and your sample so you can run\nbash\n$ node .\ninside and it will try to convert sample.ts (your file) to sample.mp4. Currently it throws the same error stack:\n\nOffset that it shows, is inside temporary pesStream instance of jBinary which contains (at least, should contain) only collected PES packets. You can insert\njavascript\nrequire('fs').writeFileSync('sample.pes', pesStream.read('blob', 0));\nat line 32 of index.js to save PES stream only as stream.pes synchronously (so it will be completely saved before error is thrown) and open this file in HEX editor. After navigating to given offset (364570) you can see that there is really Transport Stream Packet header:\n\nWhy wasn't it filtered out and appeared in PES stream, needs additional investigations and your help would be highly appreciated.\n. > I think that it will help if you output DTS of each extracted PES packet.\nThat's easy to add - just follow structure defined in pes.js and put\njavascript\nif (packet._hasDTS) console.log(packet.dts);\non line 35 of index.js, right after\njavascript\nvar packet = pesStream.read('PESPacket');\nLast DTS it outputs is -2085236713 but not sure how it helps here.\n\nBetter to use bit 2 in mpegts, which is start.\n\nI'm not sure what do you mean. Is this bit part of NAL unit type? When length is not explicitly given in PESPacket, I'm looking for 00 00 01 [code] pattern, where code has forbidden bit set so it successfully finds packets of audio (C0), video (E0) and other streams.\n. > I mean that you'd better use flag payloadStart: https://github.com/RReverser/mpegts/blob/gh-pages/mpegts-to-mp4/mpegts.js#L162 to look for next PES beginning\nBut payloadStart is part of Transport Stream header so detection based on it may fail on cases when TS packet's raw stream contains two PES packets (and that's possible according to spec).\nAlso, fixing end detection could help in this particular case but original problem is definitely not in PESPacket structures but somewhere in Packet types defined in  https://github.com/RReverser/mpegts/blob/gh-pages/mpegts-to-mp4/mpegts.js since, as we see when saving sample.pes as I described above, Transport Stream packet somehow appears in PES stream before it even begins being parsed. That could happen only somewhere in initial gathering of PES stream: https://github.com/RReverser/mpegts/blob/nodejs/index.js#L16-L25\nProbably payload._rawStream is not extracted correctly in some cases so it gathers next TS packet's header as part of raw stream of current one.\n. Yeah, as you can see from https://github.com/RReverser/mpegts/blob/nodejs/mpegts-to-mp4/mpegts.js#L64-L66, it's actually expected to be 188 minus header size.\nAnd yes, there are 2 TS packets with raw streams that for some reason have length of 188 bytes.\n. Interesting, just understood that ES length calculation was not totally correct since streams may start not on 188x offsets, fixed and got another error on file.write call in index.js:\n\nNot finished, but good progress :)\n. I mean not field value but real calculated length of raw stream that I'm using in each TS packet.\n. So that error is fixed now in c67216c75585c505e4dd710115c5605a7a59ea82.\n. And improved stack traces by filtering out not interesting parts so now we have error with stack that looks like:\n\n. Nice, looks like problem is that Node.js Buffer can't write given creation_time as UInt32 since it's out of bounds allowed for this type.\n. @maxlapshin Ok, looks like this final error was only Node.js related and conversion itself was fixed earlier in c67216c so your video sample is now converted successfully. Thanks for investigations and help!\n. > I can also share my test suite for mpegts decoder library, there are about 30 MB of different files from various muxers.\n@maxlapshin Could you actually share this test suite so I could look for other problems here? Thanks.\n. @maxlapshin Ping.\n. It's possible, but I don't see any benefits of such conversion since browser support MP4 and not MPEGTS. If you want to do this, you should go to https://github.com/RReverser/mpegts/tree/gh-pages/mpegts-to-mp4 and find custom types (jBinary.Type(...) and jBinary.Template(...)) which are missing write method and implement it accordingly to reading. Then you need to write opposite of https://github.com/RReverser/mpegts/blob/gh-pages/mpegts-to-mp4/worker.js.\nAll this would take time for sure :) I can help you with any questions on jBinary or resources to read.\n. I'll be happy to help with any questions, but have to warn that it's serious challenge (at least, was for me). But I was developing jBinary in parallel, and most of data structures could be reused, so may be somewhat more easy for you to create back-converter.\nGood luck!\n. Bug description is pretty useless without sample files.\nCould you attach links to those files please?\n. You can't just \"upload\" stream by putting only m3u8 file. If you look at Network tab, you'll see that all the requests to *.ts files return \"404 Not Found\".\n. Check out contents of any of those files. Your web server returns code 200 by mistake, but contents of any of .ts files are \"404 Not Found\".\n. Not much. As you said, it looks like format/encoding incompatibility problem, but can't investigate deeper for now due to lack of time.\n. @phamvinhthanh Name is easy to see in profile :)\n\nHow can I disable debug log? I think firefox lag issue is from writing debug to console log.\n\nNot sure about that since this lag exists in Chrome as well, but you can add conditional flag for logs and send PR if that helps.\n. @phamvinhthanh Tried to turn off all the console calls locally - didn't help at all. Unfortunately.\n. Sorry, I don't really understand your question nor what you're trying to do. Can you please show code example?\n. As I asked - can you please show code example? I don't understand why would it crash because of creating separate worker (it shouldn't) nor why you're switching HLS streams at all.\n. This lib is not for multiple videos but for HLS video stream.\n. Smooth playing of video chunks theirselves has nothing to do with library - it's rather problem with your codecs and/or machine. If you mean not smooth switching - unfortunately, it's not possible to overcome until browsers support Media Streaming Extension with H.264.\n. Unfortunately, I don't have any of these devices to play with (and emulators don't show the full picture).\nIn any case, I think using native support wherever possible is the correct approach, as this library does repackaging in background thread, which requires more CPU resources than native libs, and so will consume battery pretty fast, which is important limitation of mobile devices.\n. Nope, no idea why. That's why I need at least some logs from device.\n. @DaKaZ Nope, unfortunately, you need to have entire generated file information (i.e. information collected from all the original chunks in the stream) in order to provide even progressive download. That's why MP4 isn't suitable for streaming unless it's used for small separate chunks in Adaptive Streaming protocol like Apple HLS.\n. Yeah, for some reason recently FF started reducing size of it (on desktop too), need to play with it to figure out why. I also have FF OS device, but actually didn't try there yet.\n. But not in Developer Edition 37.0a2.\n. Um, no, we are not missing it and this is reflected in other issues.\n. I don't see where it would make sense. There is no native HLS players available in browsers (except as for iOS which is way too specific to target).\n. Even if it's possible, it just doesn't make sense for this project as it's target is exactly to avoid usage of JWPlayer and similar (any Flash-based players actually) and you propose to use those even for regular MPEG04 files which are supported by HTML5 natively.\n. It's Windows, 37.0a2:\n\n. @Gagaro Any ideas on it?\n. @gliese1337 Cool to know, thanks!\n. This should be fixed now.\n. I don't really see what exact problem this PR solves while adding additional complexity through yet another dependency management (Bower). This library is already exposed to npm and can be used externally from there, and is very well built with browserify/webpack/whatever.\n. Well, I like the separate HLSPlayer, but I don't really want to use any extra dependency manager nor builder in this example.\n. > from what we understood form the demo you send .ts file on each couple of seconds\nNo, it's being sent as soon as available (without extra latency but conversion itself which is pretty fast compared to playback). Websocket won't help here, as the main issue is absence of native support and thus you always will have subtle difference between source stream and output.\nP.S. Sorry for missing this issue.\n. I did, but, at least at that moment H.264 wasn't supported in most MSE implementations. Not sure what is the current status of this.\n\nFrom: \u00d8yvind Smestadmailto:notifications@github.com\nSent: \u200e4/\u200e24/\u200e2015 19:03\nTo: RReverser/mpegtsmailto:mpegts@noreply.github.com\nSubject: [mpegts] Use MSE ? (#17)\nJust wondering if you have considered using a Video element for display and feeding it with data using MSE (http://html5-demos.appspot.com/static/media-source.html)?\nI am wondering if this could help avoid the glitches between segments currently experienced.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/RReverser/mpegts/issues/17\n. Yes, but still has problems which prevent smooth streaming: https://github.com/RReverser/mpegts/issues/20#issuecomment-113539572\n. Closing this issue in favor of merged discussion in #20.\n. Regular MPEG-TS files won't work since they use same format but have different structure from stream chunks.\n. Yeah, exactly. Sorry for getting to this so long, but happy that you figured it out on your own.\n. This is pretty interesting task but requires time and money investments which I don't currently have.\n. > does play (90% CPU)\nThat's weird - never got more that 10% on my PC.\n. Dunno, maybe due to high resolution. Also depends on CPU.\nHow much are you getting with demo on Github Pages?\n. That's really weird. Tried right now - getting 6% avg. in Firefox, 9% avg. in Chrome, both on Windows x64 machine with i7.\n\"choppy\" is a known issue (see README) ant completely unrelated to performance, it's just how browsers handle beginning of chunk (basically same problem as with MSE).\n. > then when it runs out of chunks and need new ones then the same thing happens\nConversion never stops - initially, yes, for bufferization purposes and making playback as smooth as possible, a lot of chunks is being scheduled for conversion (although obviously only one is always converted at a time, no multithreading here except as for splitting conversion process from UI).\n. But in any case, I do agree that scheduling could be done more wisely and I'd be totally open to any improvements here via PR.\n. It's really not about speed of conversion itself but purely about scheduling - if it wouldn't try to download & schedule conversion of 20 chunks at once, but would limit count of them to, say, 3, then CPU wouldn't be highloaded that much. As I said above, I'll be happy to accept any PRs in this area.\n. Nope, it won't be. As I already said, pure conversion is exactly 5-10% that you're seeing after the initial buffering (see \"Conversion never stops\" comment above - it's still converting under this load; 80% is just due to worker being also busy with loading a lot of binary files besides the conversion itself).\n. @modest Interesting thought. Do you mean comparing quality with previously saved, and if it matches, omit repeated moov atom?\n. Sounds good. Willing to try & PR?\n. There is no such thing as \"player object\" here - you can see how play/pause works at these lines: https://github.com/RReverser/mpegts/blob/gh-pages/index.html#L36-L49 (those are the methods tracked on this.currentVideo.play / this.currentVideo.pause and handled specifically).\nNote that this is self-contained stream player demo that is not intended to work as a library (since converting it to such requires dedicated time and efforts).\n. Of course, it already uses blob URLs inside. Canvas drawing is needed for avoiding gaps between videos.\n. This shouldn't happen. Please install stack-displayname to your project as dev dependency for better logs and also you can use lines from https://github.com/RReverser/mpegts/blob/gh-pages/node.js#L3-L24 for even more clear output.\nThen, you should see error stack trace being built from type names, field names and binary offsets instead of anonymous internal functions - hopefully that will help to track the issue more precisely.\n. > I've done it now but the error is still the same.\n\nAnyway my problem is not about understanding where the problem is.\n\nThat's exactly why I suggested steps above. They don't fix anything, just help to see error in better format to understand where and why it occurs.\nThis has nothing to do with jBinary internals, most likely problem with some definition, but I can't say anything for sure without prepared stacktrace.\n. Could you please show me your stacktrace prepared in this way?\n. > I copied the code to the beginning of my node script and installed stack-displayname, but the result is the same as before.\nI hope you did notice that given block depends on process.env.NODE_ENV === 'development' condition that needs to be either satisfied by setting NODE_ENV=\"development\" in environment variables or just removed so that the import happens unconditionally?\n. > PESPacket -> hasPTS -> Flag -> getType('dependentField').\nThis is pretty weird since Flag shouldn't perform getType (and if it would, online demo would also break). Not sure what's happening there.\n. You should not download it, but visit online at http://rreverser.github.io/mpegts/. It won't work locally due to security limitations.\n. Um, are you trying to clone my web app into own one? Because if not, I don't really understand your intentions and needs.\n. It just works without installation, but you need local server. Also, you might want to see #21.\n. Sure. Node.js endpoint does that as following: https://github.com/RReverser/mpegts/blob/gh-pages/node.js#L37\n. Hmm, are you sure you're not just observing beginning of the moov atom right after mdat?\n. > Furthermore, if you call stream.getBytes(stream.tell(), 0) in the console to see what bytes are actually supposed to be written\nAt which point are you calling it in console? Is there a chance that it might be an audio being added after you logged it?\nIf that's not it, honestly, I don't have better suggestions at the moment on why you might be seeing a difference.\n. > which does in fact not have any audio when you play it back\nActually it does (if original file contained valid AAC too). You can see that in online demo as well.\n. Ah, I missed that you were talking about post-commented code. Thought you were trying to say that library doesn't work with audio at all. Sorry for confusion :)\n. Duplicate of #20 (and #17). Please look through the issues before opening new one.\n. You had to use static HTTP server to open it.. This is not the task for this module. Moreover, m3u8 is just a text file (playlist).\n. No, MKV is unrelated to MPEG-TS.\n. Thank! It's somewhat unclear though from the bug why loadedmetadata can't be used reliably for this (as far as I understand from the issue discussion, this is assumed to be correct behavior even though Chrome / Edge return correct sizes).\n. Generally this should be totally possible, except I didn't really parse keyframes and can't help with the image encoding format.\nIs there any particular reason you don't want to go the easier way - just creating temporary <video src>, setting time to the needed one, starting load manually with .load (then browser will send range request as well) and drawing that video element to the canvas?\n. I think you can, yes, but that would require a bit of work.. Feel free to PR any working URL :)\n. Ok finally found some good-looking and working stream, updated demo.. It's not promoted as \"apple\" certainly :) I don't know why you decided so.\n. And, as you could see, Apple HTTP Live Streaming is a link in README because it's name of the format (Apple relates to format being developed by Apple, not to library).\n. No, as you could see in docs and in previous responses, it parses Apple HLS format - not motion jpeg.\n. Documentation for what? This is not a library, just a self-contained player demo that I created several years ago.\nIf you feel like there is something that should be documented though, feel free to send a PR.. Fixed.. ",
    "NickHowden": "Yes, that works perfectly. Many thanks for the speedy response.\nNick\nOn Feb 25, 2014 1:29 PM, \"Ingvar Stepanyan\" notifications@github.com\nwrote:\n\nSorry, I don't have video-without-audio sample to test it on. Could you\nplease try moving trak array (at 235) to separate variable and\nconditionally .push(...) it's second element only when audioSize > 0?\n\nReply to this email directly or view it on GitHubhttps://github.com/RReverser/mpegts/issues/3#issuecomment-36006729\n.\n. \n",
    "maxlapshin": "I failed to do it.\nIt is very hard for me to get through javascript stacktraces =(\nOn May 12, 2014, at 5:59 PM, Ingvar Stepanyan notifications@github.com wrote:\n\n@maxlapshin Did you try to figure out reason of bug?\n\u2014\nReply to this email directly or view it on GitHub.\n. I don't see any easy-to-find error in https://github.com/RReverser/mpegts/blob/gh-pages/mpegts-to-mp4/mpegts.js#L157\n\nHere is my code for extracting ts payload from mpegts:\n``` erlang\nts_payload(<<16#47, :18, 0:1, 1:1, :4, Payload:184/binary, _/binary>>)  -> \n  Payload;\nts_payload(<<16#47, :18, 1:1, 1:1, :4, AdaptationLength, _AdaptationField:AdaptationLength/binary, Rest/binary>>) when AdaptationLength =< 183 ->\n  Length = 183 - AdaptationLength,\n  case Rest of\n    <> -> Payload;\n    _ -> eof\n  end;\nts_payload(<<16#47, :18, 1:1, 1:1, :4, AdaptationLength, _/binary>>) ->\n  {error, {invalid_adaptation_field, AdaptationLength}};\nts_payload(<<16#47, :18, 1:1, 0:1, :4, _/binary>>) ->\n  {error, only_adaptation_field};\nts_payload(<<16#47, :18, 0:1, 0:1, :4, :184/binary, /binary>>)  -> \n  erlang:error(invalid_payload).\n```\n_:18 syntax means \"skip 18 bits\",  0:1 means \"one bit must be 0\".\nI think that it will help if you output DTS of each extracted PES packet.\nPerhaps, problem is here:\nhttps://github.com/RReverser/mpegts/blob/gh-pages/mpegts-to-mp4/pes.js#L57\nH264 MUST have forbidden bit set to zero, but not always have it.\nBetter to use bit 2 in mpegts, which is start.\nI can also share my test suite for mpegts decoder library, there are about 30 MB of different files from various muxers.\n. I mean that you'd better use flag payloadStart: https://github.com/RReverser/mpegts/blob/gh-pages/mpegts-to-mp4/mpegts.js#L162\nto look for next PES beginning.\nYour detection method may fail because sometimes H264 NAL units has forbidden bit set to 1 and it is generally ok, because you cannot do anything with it.\n. Check size of _rawStream here.\nIt must be usually 184 and sometimes a bit smaller for adaptation field.\n. I completely ignore ES length in flussonic. It is usually useless.\n. ",
    "Jaetoh": "Hi !\nI try to upload a file .ts with the npm package but jBinary send me back this error \n[TypeError: Unexpected value (8 !== 0).]\nI really don't succed to fix it even with this topic. Could anyone help me ? Thanks\n. ",
    "krzysztofantczak": "Well, right... there is no point to keep .ts files, but i have few use cases where ts files are better fit (m3u8 support on file chunk level) and converting them on-the-fly would be awesome since it's really fast process + it spares a lot of disk space. I'll try to go with Your tips and for sure it will take some time since i've never touched binary data before. Thanks for quick answer ;-)\n. ",
    "verzachris": "Thanks for getting back to me;\nI've just uploaded them here http://www.verdelli.net/RReverser-mpegts/mpegts-atn.html\n. It looks to me that files are there, look to the attached image:\n\n. You were right, somehow uploading the file to the ftp server didn't not succeeded. \nNow they should be fine, similar error though.\n. Hi @RReverser ,\nhave you had the chance to look into the issue ?\nthank you.\n. ",
    "trong": "The same problem:\nTypeError: Unexpected value (54 !== 71).\n    at Object.defaultTypeSet.const.Template.read (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:312:23)\n    at jBinary.<anonymous> (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:231:25)\n    at jBinary.<anonymous> (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:225:34)\n    at jBinary.proto._action (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:227:79)\n    at jBinary.proto.read (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:230:21)\n    at jBinary.<anonymous> (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:396:105)\n    at jBinary.<anonymous> (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:398:25)\n    at jBinary.proto.inContext (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:131:31)\n    at Object.defaultTypeSet.object.Type.read (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:394:32)\n    at jBinary.<anonymous> (/Users/trong/node_modules/mpegts_to_mp4/node_modules/jbinary/dist/node/jbinary.js:231:25)\nhttps://dl.dropboxusercontent.com/u/17497896/ts-for-test/1060-50Num4789207.ts\nhttps://dl.dropboxusercontent.com/u/17497896/ts-for-test/1060-50Num4789208.ts\n. ",
    "gliese1337": "I've just also run into this. I get a steady stream of these errors when trying to play a stream from Brightcove's CDN.\n(I would provide the URL, but I'm not sure if that would be violating copyright licenses or not, so, sorry.)\n. It's an off-by-one error in the SPS parser. You start reading SPS data one byte off from the right spot, so it produces junk values for the height and width of the video. Chrome ignores the height and width that you put in when decoding an MP4 file, and recovers the proper dimensions from the raw SPS blob. Firefox, on the other hand, seems to ignore the SPS blob and uses the dimensions you provide.\nI know this because I wrote my own SPS parser for https://github.com/gliese1337/HLS.js/\nIf I start it off-by-one, I get identical output to your SPS parser.\n. I'm seeing something similar. It gets thrown somewhere inside the calle to \"nalStream.read('NALUnit');\"\n. Never mind, figured it out myself- it seems obvious in retrospect. The PES reader is just concatenating the data from multiple TS packets in between Payload Unit Start Indicators, which is entirely sensible. \n. Quite certain. The boundaries of atoms are fairly obvious on visual inspection.\nThese are the last few bytes of the video data (in ASCII, because it's easier to see patterns that way) for one of the video segments I've tested: I\u00d6*\u00eb/\u201c~\u00ba\u00ea\u0016\u00e2w\u00ef\u00cb\u0018\nThe next few bytes after that look like this: !\u001a\u00cf\u00ff\u007f\u00ff\u00ff\u00ff\u00a1\u00b5R\u02dcT\u0018\nThe first few bytes of the moov atom look like this: :\u00c9moov   lmvhd\nand occur 82352 bytes later. That's 82352 bytes (in this particular instance) of random/compressed-looking junk with no obvious patterns.\n. I'm checking it here, which should be after any audio data is written, and tested with this line commented out so that no audio data should be written anyway.\nA little further testing indicates that the extra data is indeed identical to the audio data. So now the mystery is, how the heck does audio data end up in the file (which does in fact not have any audio when you play it back) given that said audio data does not show up when calling stream.getBytes(stream.tell(), 0)....\nGuess I'll do a little more playing around and let you know if anything sensible turns up.\n. Oh, I know the videos are supposed to have audio. Getting them to work with audio is the easy, default bit. The weird part is when I comment things out and make alterations with the intention of removing audio, and in fact succeed such that the video playback is now silent (and verify that the video file itself is silent by saving a blob URL to disk and playing it in Windows Media, so it's not just accidentally muting the web page), and then find that the audio data nevertheless is still present in the file.....\n. ",
    "rongconzx": "I have 4 videos play on one page. At the time, i only show 1 video so every 5 min i need to change  next video by call new trigger . So thread worker.js is created consecutive. This is root cause made my web crash. How to can i kill this thead when i change to next video ?\n. I found the cause of crashing, it is because virtual memory of browser become 2GB! Now I want to find a way to prevent memory to increase too much.\nIn my web app, there are SEVERAL videos to be play and each time the web app switch to play a new video, I trigger a 'playVideo' event so that your browser.js code is executed in the corresponding event handler of 'playVideo' event:\n$(document).on('playVideo' ,function (event, id, canvasID, link) {\n            // preconfiguration using <script>'s data-attributes values\n    var scripts = document.getElementsByTagName('script'),\n    ....\n    //Your browser.js code here\n    ...\n});\nAfter triggering playVideo' event several times, memory become huge and browser crash!\nI guess that there is other way to play several videos without memory issue?\n. Thank for your information. But find new issue for your library. Videos aren't smoothly on chorme new version(version 39) and IE 11 on  window 8. please check it !\n. ",
    "Wedmer": "As most of mobile devices have native support for hls you can make conditional video tag.\n. ",
    "AdrianDroid": "Unfortunately, HLS support on Android is far from perfect, it is broken / buggy across different brands of phones. With those old devices around, I will need a alternative solution.\nStrangely, this lib don't seem to be work on ANY of my testing devices. I am still pinpointing why. \nEven the The Galaxy Note 4, With run on Android 4.4 and latest chrome, have failed me.  \nI have done a few test case, AJAX with type BLOB (with mp4/webm) works fine. But once it load to ArrayBuffer/ convert from ArrayBuffer to BOLB, the video failed to work.\n. Perfectly understand that. There are limitation that we must use HTML / WebView :< \nanyhow, any idea how would ArrayBuffer to BOLB fail in ALL mobile device but not desktop ? \n. ",
    "DaKaZ": "I am a little late to the conversation, but as I am dealing with the fact that HLS is completely broken on Android 4.4.3 and 4.4.4 (which is all Galaxy S5s on Verizon!) I am looking for alternatives as well.  I have a theory that I think could work with this library and I'll be happy to experiment with it if you can just give me your opinion quickly.\nBasically, my theory is this.  Our app is in appcelerator titanium, so I basically have a V8 javascript core to work from.  I was planning on having my app pre-load the first X chunks of each video and store in a local .mp4 file.  When a user goes to play that file, the app would then proceed to fetch the rest of the chunks and append to the existing MP4 file.  \nMy question is this: is this even possible to append to the MP4 while playing it?  I know MPEG2-TS quite well but not MP4.  Doesn't the MOOV box have to be updated as new GOPs are added to the file?  Would the native mobile player (android or iOS) even be able to handle that?  I know MP4 supports progressive download so maybe I need to know what my file will look like when its all done and then append it?  Although this would completely break if we have rate adaptive HLS files (which we do since we are mobile).  \nI am open to any and all suggestions, but my basic psuedo code would look like this:\n1. Pre-fetch first 5 chunks of HLS video, convert to base MP4\n2. When video starts playing, stream in remaining chunks, convert to MP4, append to base file\nNote: we don't allow scrubbing so need to support ff/rew.  Only pause.\nPlease let me know your thoughts.\nThanks\n. ",
    "Gagaro": "Hi,\nI've tested the demo on Firefox OS (2.1). It seems to kinda works. Video is very small, it cuts sometimes (change of chunk ?), audio works fine. Does anyone have some experience using this library on this OS ?\nThanks\n. Thanks for the quick answer. I'll probably try some things on FF OS with this library later this week. I'll tell you if I figure out anything.\n. It works fine with FF 35 on windows.\n. Sorry, I didn't really looked at it yet. It's still on my todo list though.\n. ",
    "modest": "@DaKaZ @RReverser I think you guys are missing a key part of MP4.\nTraditional MP4 files needed a complete index at the beginning of the file (in the \"moov\" atom).\nMP4-based streaming formats (like MPEG-DASH) take advantage of a feature of the MP4 format called fragments.  With a fragmented MP4, you do not need a complete sample table to write the MP4 headers.  In this format, the file contains:\n- a description of the tracks, with no sample table (moov)\n- 1 or more fragments, each with:\n  - a sample table (moof) \n  - 2-10 seconds of media data (mdat), followed by another header\nThis is the right way to implement streaming MP4 and avoid playback gaps.  If this project were updated to use fragmented MP4 with the Media Source Extensions API, it could achieve flawless HLS playback.\n. You should expect some choppiness / increased load every time a \"moov\" atom (beginning of an .mp4) is appended, as this causes the H.264 decoder to reinitialize. It's necessary if you are switching video resolutions, but avoidable if you are continuing at the same quality level. \n. @RReverser Yeah, that's usually how MPEG-DASH and Smooth Streaming are parsed.\nIf you stream 2 segments at 720p then 2 segments at 1080p, the buffer looks like:\n[ftyp]  [moov for 720p]  [moof][mdat]  [moof][mdat]  [moov for 1080p]  [moof][mdat]  [moof][mdat]\n. ",
    "guypaskar": "For example, I know few video websites that would like to use hls when possible but they do not want to duplicate their library. (They have mp4 library currently).\nThe idea , is to download the file as mp4  convert it to ts files and feed it to an hls player (not a native one) , say, jwplayer or similar (create the manifest on the fly)\nIs this even possible? I'm wondering about supporting all the player's needs like seeking etc.\n. When you put it this way, I agree. \nHowever, html5 supports hls with media source extension, it also supports dash playing which supports mp4.\nThe thought is , to have one type of file which is mp4 that can be played in both protocols and also natively.\nIt might not be related to this project but I was wondering to know if it is even possible.\n. ",
    "naktinis": "Problem still there. So is this a bug in Firefox or in mpegts?\n. ",
    "albany551": "The addition of bower wasn't totally necessary, for sure, but the idea of the PR is to package up the library to be used externally in websites (i.e. not in a node.js environment). The existing browser example had a bit of necessary glue code that is now nicely encapsulated - all you need to do is create a canvas and decorate it with the HLSPlayer() method.\nI totally get it if this obscures the purpose here (demoing the technique), so definitely disregard the PR if it's not worth it.\n. ",
    "osmestad": "If this feature test is to be belived:\nhttps://www.youtube.com/html5\nIt currently says OK for \"MSE & H.264\" in: Chrome (42), Safari (8)\nAnd fails for: Opera (25), Firefox (37)\nOn OSX (haven't tested on Windows/Linux).\nA better overview Is here:\nhttp://www.jwplayer.com/html5/mediasource/\n. The overview page was moved it seems: http://www.jwplayer.com/mediasource/\n. ",
    "FranklinWaller": "The MediaSource extension seems to be (ok) supported. Only Firefox has some whitelist issues. The rest seems to be able to support it.\n. ",
    "nickdesaulniers": "^ is accurate.  http://nickdesaulniers.github.io/netfix/#/5/1\n. ",
    "zoltan-fedor": "Hi @MaMazav ,\nI would be interested in the same (currently using vlc browser add-in to play mpeg-ts in the browser, but that plugin is going away). Any success with mpeg-ts low-latency realtime video displaying?\n. Hi @MaMazav ,\nActually I ended up trying your branch https://github.com/MaMazav/mpegts/tree/Streaming-ts-by-WebSocket and was able to recreated the UDP to WebSocket streaming of mpeg-ts. Unfortunately I managed to max out the CPU on the client side with the conversion so much, that the video screen doesn't display, while the original version of non-realtime HLS streaming by @RReverser does play (90% CPU), but obviously that is very far from realtime.\nI guess for now I will have to stay with vlc then...\n. Thanks. I see that the resolution of this issue of MSE has been moved to Chrome version 45. I guess we will return to it then.\n. When I wrote 90% CPU, I meant 90% of a single core.\nAlso, this is a 1920x1080 .H264 mpeg-ts feed coming from a Logitech C920 webcam which can do .H264 encoding on hardware, so I can get 1920x1080 pixel video feed out of it with no problem.\nCould this be this high resolution casing the CPU to go up to 90% (and the screen become sluggish)\n. You are right, I get the same high CPU with the demo page too (http://rreverser.github.io/mpegts/).\nIt basically maxes out one of the CPU and the screen is choppy.\nUsing Chrome v43 on a Windows 7 x64.\nAlso tried it on a different compure (i7) in Chrome v43 on Linux Mint - the result is the same. A single core of the CPU is maxed out and the video is choppy, although less choppy than the Windows one (but this machine has a better CPU, so maybe that's why)\n. I have checked it again. The \"choppy\"-nes I was referring to is not the one between the chunks, but the one caused by the CPU being maxed out (it is more frequent, every second or so).\nLooking at the JS console, when I start playing the demo video it starts by converting 21 chunks - while the CPU maxes out - this is when there is choppiness. Then when it finishes converting the 21 chunks the video plays smooth (CPU usage is down to 5-10%), then when it runs out of chunks and need new ones then the same thing happens.\nIt looks that converting the new chunks happens with max CPU speed - maxing out the CPU and causing the choppiness while the converting is happening.\n. I think the question more is whether we could limit the \"speed\" of conversion, so it is not taking up 100% of the CPU core. I would guess, that if it is only taking up 80%, then that slight \"choppiness\" wouldn't be visible.\n. Wouldn't the CPU load be the same, except that it would last less long, eg. converting 3 chunks instead of 20. I think it would still max out the CPU core, just for 3/20th of the time of how it is now.\n. ",
    "MaMazav": "This branch was only a try to make a Proof Of Concept of that. I stopped working on it when understood that until the following issue in Chrmium will not be solved the minimal latency will be the difference between key frames:\nhttps://code.google.com/p/chromium/issues/detail?id=229412\n. Thanks for reply. I've done it now but the error is still the same.\nAnyway my problem is not about understanding where the problem is. I've debugged jBinary and understood that the problem is that it tries to parse 'dependentField' parameter of 'Flag' as a type instead of as a parameter name. It happens on the hasPTS field of PESPacket. I just don't know why it happens because I don't know jBinary internals.\n. Oh sorry, I was unclear. By saying \"I've done it now but the error is still the same\" I meant that I could not make it work and the error and stacktrace is shown in the same way as before. I copied the code to the beginning of my node script and installed stack-displayname, but the result is the same as before.\nAnyway I debugged it and found that it fails within the following \"stack\":\nPESPacket -> hasPTS -> Flag -> getType('dependentField').\nI ended up by workaround, so the issue is irrelevant for me, but I can try provide more information if you still want to solve the bug.\nThanks anyway\n. I tried to comment out the condition, but the stack trace is still unclear.\nAs an alternative, I created a small piece of code which reproduces the problem. Just npm install mpegts and jbinary in the folder and execute the following code:\n```\n// Enable advanced stack in dev mode.\n//if (process.env.NODE_ENV === 'development') {\n    require('stack-displayname');\nError.stackTraceLimit = Infinity;\nvar prevPrepareStackTrace = Error.prepareStackTrace;\nError.prepareStackTrace = function(error, frames) {\n    var firstNamedIndex = 0, firstNonNamedIndex = 0;\n    var filteredFrames = frames.filter(function(frame, index) {\n        if ('displayName' in frame.getFunction()) {\n            if (!firstNamedIndex) {\n                firstNamedIndex = index;\n            }\n            firstNonNamedIndex = index + 1;\n            return true;\n        } else {\n            return false;\n        }\n    });\n    return prevPrepareStackTrace(error, frames.slice(0, firstNamedIndex).concat(filteredFrames).concat(frames.slice(firstNonNamedIndex)));\n};\n\n//}\nvar PES = require('./node_modules/mpegts_to_mp4/mpegts_to_mp4/PES.js');\nvar jBinary = require('jbinary');\nvar payload = [0xC0, 0xC0, 0xA0, 0xC0, 0xFF, 0xEE];\nvar pesHeaderLength = 11;\nvar packetToSerialize = {\n    streamId: 0xC0,\n    length: payload.length,\n    scramblingControl: 0,\n    priority: 0,\n    dataAlignmentIndicator: 0,\n    hasCopyright: 0,\n    isOriginal: 1,\n    //_hasPTS: 0,\n    //_hasDTS: 0,\n    //_hasESCR: 0,\n    //_hasESRate: 0,\n    dsmTrickMode: 0,\n    //_hasAdditionalCopyInfo: 0,\n    //_hasPESCRC: 0,\n    //_hasExtension: 0,\n    dataLength: 5,\n    data: payload\n};\nvar pesWriter = new jBinary(payload.length + pesHeaderLength, PES);\npesWriter.write('PESPacket', packetToSerialize);\n```\n. ",
    "cadesalaberry": "You should have a look at http://rreverser.github.io/mpegts/\nTry and replace the data-hls= field line 36 with your URL in the web inspector.\n. ",
    "chovy": "All I need to include is browser.js for this to work?\nI can't include a script tag in my template file (I'm using single page app framework, and that's just not how things work these days).\nI can load browser.js via a script tag in my index.html, but how do I get access to the player object? I would need for it to be a global I can use in my controller.\nCan I use a video tag? Please provide more real world examples :)\n. try the cpan feed\n. http://cspan1-lh.akamaihd.net/i/cspan1_1@304727/master.m3u8\n. ",
    "snaptopixel": "Thanks for the quick reply @RReverser do you know how THEOplayer is doing it?\n. ",
    "ranjithgithub": "I am trying to make  web application out of the source code  , so can you please guide to build a web application?\n. I have cloned code form https://github.com/RReverser/mpegts.git.\nused same web app included in the code for testing. \nMy intention was to test different HTTP live streaming contents by changing the \"data-hls\" attribute.  I am doing something  wrong here ? \n. Hi,\nI would like to know if my approach in previous comment is meaningful?\nIf so please guide in resolving the \"Cross-Origin Request Blocked\" issue.\n. ",
    "jyavenard": ".loadedmetadata provides the info as read in the metadata of the file. That is the init segment when using MSE or depending on the content being played. The metadata stored in the file may not always be correct and be different to the actual content size only determined once the first frame is decoded and ready to play. At this stage readyState=2 and loadeddata is fired. \nSo for the exact frame size of the first frame, with MSE loadeddata is best to use. \n. ",
    "TheNotary": "Could you elaborate on that a bit?\n. ",
    "broyeztony": "Hi there,\nAbove url does not work for me. Assumed it is the master - child m3u8 structure and need to feed in the end target m3u8 that has the .ts segment.\nManaged to see the load / converted console message using the classic: \nhttp://184.72.239.149/vod/smil:BigBuckBunny.smil/chunklist_w1519320440_b560000.m3u8\nBut somehow i only hear the sound and not see any video.\nAny idea ?\nAlso, noticed the hiccups in the sound when the new converted segment is produced.\nCongrats for the great work. \n. ",
    "rares-lupascu": "i assumed because of this \"This is Apple HTTP Live Streaming JavaScript player created by performing realtime ....\"\ncan i at least ask if i can use it to display the result of Google's Open Spherical Camera API method called \"camera.getLivePreview\"? they say it returns motion jpeg as binary data\ni did not manage to parse the response ... that's how i ended up here\nthanks\n. "
}