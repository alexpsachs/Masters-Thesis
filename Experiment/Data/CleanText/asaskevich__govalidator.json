{
    "asaskevich": "Great! I worked with ValidateStruct and wanted to make it work like your variant. It's really great. I already merge this request, and will write some new tests for new features. Thank you!\n. All requests merged, thanks!\n. I will have a look later. If you manage to do it before, I'll be only too happy!\n. Travis CI will be removed, wercker is much better for testing. Merged.\n. It's sometimes happen on Travis. I think that it's global problem with some golang boxes.\n. Is it possible to enable this flag on wercker?\n. Unused CI removed, I left only wercker and drone.io\n. I should to revert #8 for it?\n. Great, merged! Thank you.\n. Looks great, will be rewritten! :+1: \n. Looks like default golang packages uses this way for tests:\nhttps://github.com/jnwhiteh/golang/blob/master/src/html/escape_test.go\nArrays was my own idea, and I was not sure, that it's completely easy to use. But it's better than a lot of 'if' conditions on the first commits. :smile: \n. Usefull and great fixes.  :+1: \n. Looks great, it will be merged. :+1: \nI think that possible to name functions as:\ngo\nIsUTFLetter(str string) bool\nIsUtfAlpha(str string) bool\nOtherwise, we can to create short aliases for those functions.\n. Hi, @slugmobile, can you take a look at the #33, maybe there are some mistakes?\n. So simple and beautiful! Great :+1:\nP.S. There are some tests in another files, I think that they can be organized in similar way.\n. Is it necessary to have different CI for one project? Sometimes TravisCI falls on tests, that works well on wercker. In any case, thanks, PL merged. :smiley: \n. On Travis it's often fails with Go v1.3 (less on v1.0.x or v1.3.x, and never on v1.2.x) and Escape function:\n=== RUN TestEscape\n--- FAIL: TestEscape (0.00 seconds)\n    utils_test.go:155: Case  0 : expected  &lt;img alt=&quot;foo&amp;bar&quot;&gt;  when result is  &amp;lt;img alt=&quot;foo&amp;bar&quot;&amp;gt;\nI hope that it's already fixed with one of pull requests.\n. Thanks again! :+1:\n. Thanks again :+1:\n. Thanks :+1: \n. Thank you :+1:\n. Accepted, it will be realized in short time. :+1: \n. @oryband, I hope that it already ready to use: https://github.com/asaskevich/govalidator/commit/29b13e16b483f7731146f9f5e16c8ed1772ba26f\n. IsURL function already checks short url's:\nhttps://github.com/asaskevich/govalidator/blob/master/validator_test.go#L266\nDid you mean anything else?\n. Description of some functions are copies of same functions from validator.js. You can improve docs, I will be glad, if anyone will help me with it. :smiley: \n. Please, take a look at the #31 , maybe problem is fixed yet.\n. Maybe IsURL can be replaced with IsRequestURL if they have similar behaviour?\n. Great! :+1: Thanks.\n. Can I close this issue?\n. I think that all tests already fixed, I close #13, thanks :+1: \n. I wrote to the author of these functions (Pull Request #21)\n. Thanks again :+1: , it's also mistake on regexps from parent project, I opened new issue here https://github.com/chriso/validator.js/issues/346\n. Thank you. It seems also that every Is-Function that works on numbers allows \"-\" but not \"+\". \nLike IsFloat(\"+1.0\") returns FALSE while IsFloat(\"1.0\") and IsFloat(\"-1.0\") return TRUE. \nSame behavior can be found in IsFloat, IsInt, IsUTFNumeric, IsAlphanumeric and IsNumeric.\nPlease, check it. I hope that this issue fixed. :smile: \n. If these functions returns true on '-1', I think, that they should return similar answer on '+1'. Plus sign has similar sense as minus sign, IMO. So, if any function works with numbers and returns 'true' in cases with minus sign,  they should return 'true' also in case with plus sign. I made this behaviour just for IsInt, IsNumeric and IsFloat, so I agree with you and these functions should be fixed.\n. I hope that I can close this issue.\n. I'm agree, plus sign must be replaced with asterisk, e.g. here:\nhttps://github.com/asaskevich/govalidator/blob/master/patterns.go#L15-L17.\nI open same issue on the repository of validator.js, because it has same problem: https://github.com/chriso/validator.js/issues/345\n. Please, check it. I hope that this issue fixed.\n. Thanks :+1: \n. It's great! :smile: I can give to you RW rights for the repository so you will commit new changes without my permission.\n. Thank you :+1: \n. Thanks :+1: \n. Thanks :+1: \n. Thanks :+1: I sure that IsURL is equivalent  to IsRequestURL, but, for example, IsRequestURL require existence of scheme.\n. I also agree that it will be great to use something like equal(value). Unfortunately, I haven't any better solution, you can ask @slugmobile for help, as he is author of validation of structs. I hope, that he can advice better solution as he fully knows  process of struct validation.\n. Sorry for delay, I very busy at last days -- , I will review your work in the next weekend. Hope that all fine with your exams today. \n. Hi, as I see, there are a lot of work that already done. Great :smile: . govalidatorcore and govalidators looks cool. I think that your idea is much better than current implementation of my govalidator. Sorry for the long delay, I was really busy -- \n. Issue is out-of-date or very old, I closed it. So, if it necessary, you can create a new one or reopen this.\n. Looks great, I like it :+1: \n. Not a problem! If you had some questions, you can ask them :smile:\n. I can give you collaborator rights, so you will able to commit directly to this repository. If you wish, of course.\n. Not a problem. You can ask me for collaborator's rights in any time. :smile: \n. Wecker CI says to me that build of this PL is failed. I accepted #46 , is it necessary to do something with this PL?\n. Thanks. I accepted #46, maybe issue already fixed?\n. Hope, that yes. If there are some issues with it, please, reopen it.\n. Take a look to this issue: https://github.com/asaskevich/govalidator/issues/30\nI think, they're similar.\n. Okey, I will review IsURL and make its behavior same to IsRequestURL\n. I have no enough time to do better documentation :( I think that same functions should have same behavior, e.g. IsAlpha and IsUnicode should to return same answer for empty strings. I already looked at your updates with docs, it's awesome. It can be moved to govalidator after completing. \n. Issue is out-of-date or very old, I closed it. So, if it necessary, you can create a new one or reopen this.\n. @bom-d-van @imothee thanks, looks great :+1: \n. Yes, any PLs are welcome! :+1: \n. Thanks, it's already here: go get gopkg.in/asaskevich/govalidator.v1\n. Please, check relevance of the issue with current version of the library. Issue is seems to be very old, I closed it. So, if it necessary, you can create a new one or reopen this. \ud83d\ude03 \n. json.Marshal, that used inside function, adds double quotes. I think that it can be replaced with fmt.Sprintf(\"%v\", obj) that works like this:\n``` go\npackage main\nimport (\n    \"fmt\"\n)\ntype Outer struct {\n    A int\n    B int\n    InnerItem Inner\n}\ntype Inner struct {\n    C float64\n    D complex64\n}\nfunc main() {\n    println(fmt.Sprintf(\"%v\", 1))                                                         //=> 1\n    println(fmt.Sprintf(\"%v\", \"abc\"))                                                   //=> abc\n    println(fmt.Sprintf(\"%v\", 'a'))                                                        //=> 97\n    println(fmt.Sprintf(\"%v\", true))                                                    //=> true\n    println(fmt.Sprintf(\"%v\", Outer{10, 20, Inner{1.45, 1.5 + 3.5i}})) //=> {10 20 {1.45 (1.5+3.5i)}}\n    println(fmt.Sprintf(\"%v\", 1.5))                                                      //=> 1.5\n    println(fmt.Sprintf(\"%v\", 1.0 + 10i))                                            //=> (1+10i)\n}\n```\nI will try to replace json.Marshal with fmt.Sprintf if all tests will be OK.\n. Yes, it works not only with strings, package already has basic support of structures validation. I think that package should to have various functions for validating integers, arrays, maps etc, like func InRange(num, l, r int) bool or anything like func IsString(v interface{}) bool. Also, it will not be superfluous, to have functions for working with arrays like Any(f predicate), Filter(f predicate), Map, Count, All, etc where predicate is func (item interface{}) bool.\nIt's just some features planned for the next releases. But if you have ideas or patches - you are welcome :smile: \n. Thanks! :+1: \n. Thanks, it will usefull function :smile: \n. All fine, but I'm not sure about issue that you referenced to this PR. I will try to take a look on it in short time\n. #58 Issue require some test cases with which I can be sure that's all ok\n. I think, tests should be checked and reviewed - pull request fails with this error:\n--- FAIL: TestValidateStruct (0.00s)\n    validator_test.go:1613: Case  0 : expected  true  when result is  false\n    validator_test.go:1614: Age: Unkown Validator @#;\n. Thanks again for your work, it's great :+1: \n. Fixed in #70 \n. Good idea, but at this moment I haven't thoughts how to solve it :smile: I will keep in mind this issue, maybe I'll find solution. Now you can do something using ErrorByField function, I hope that it will a bit helpful\n. Please, take a look at #141, they are similar.\n. Can you provide an example of usage that gives error?\n. Can you try to run go get -u github.com/asaskevich/govalidator and try again?\n. Fixed in #70 \n. At this moment it gives error like this: Title: My123 does not validate as alpha;AuthorIP: 123 does not validate as ipv4;. I create function ErroByField(e error, field string) that will return error for specified field of struct or empty string otherwise, I hope that it will be helpful. For example:\n`` go\ntype Post struct {\n    Title    stringvalid:\"alpha,required\"Message  stringvalid:\"ascii\"AuthorIP stringvalid:\"ipv4\"`\n}\npost := &Post{\"My123\", \"duck13126\", \"123\"}\nresult, err := govalidator.ValidateStruct(post)\ntitleError := govalidator.ErrorByField(err, \"Title\")\nif titleError != \"\" {\n    println(titleError) // -> My123 does not validate as alpha\n}\n```\nYou can reopen it if there are any problems with it\n. It's really great! As I understood, can I create ParamValidator type that accepts various arguments separated by | and declare them inside ParamTagMap and ParamTagRegexMap?  Can you provide a bit of docs about it to README file (maybe examples)? \n. Thank you, it's working fine :+1: Issues can be closed.\n. Thank you again :smile: \n. Yes, all works fine, here is test: https://github.com/asaskevich/govalidator/blob/master/validator_test.go#L621\nI will close this issue, but if you find anything strange, let me know, please\n. :+1: \n. thanks :+1: \n. Thanks :+1: \n. Yes, thank you :smile: \n. I think that possible to pass options like below:\ngo\ntype ValidateStructParams struct {\n   FieldRequired bool,\n   // etc\n}\nand then\ngo\ngovalidator.ValidateStruct(objStruct, &ValidateStructParams{ /* etc */ } )\nAnyway, thanks for PL and idea. Not sure that I'll implement it soon, so if you would like to do it - you are welcome :smile: \n. Thanks, ErrorsByField just a prototype of the function that can behave like current implementation. I think, it should return something like complex object (like json) that can be easily used :)\n. :+1: \n. Thanks, any extraordinary tests are appreciated :+1: \n. Thanks, if there were opened issues suitable for this PL, they can be closed :+1: \n. @alioygur but it will break BC with active projects. Maybe in future there will be something like validators, that returns errors and validators, that returns warnings etc. I closed it, but feel free to send pull request. \ud83d\udc4d \n. I'm referring to your issue #85, but currently I haven't enough time to look into the project and resolve this issue. So if you can to fix it, it would be great\n. Fixed, thanks to @nkcraddock \n. Yes, currently it works with strings, but here is PL with supporting custom types, like int: https://github.com/asaskevich/govalidator/pull/91\nLook on it, maybe it will be useful for your issue\n. #141 \n. Thank you, sorry for delay\n. Example in README:\ngovalidator.CustomTypeTagMap.Set(\"customMinLengthValidator\", CustomTypeValidator(func(i interface{}, context interface{}) bool {\n  switch v := context.(type) { // this validates a field against the value in another field, i.e. dependent validation\n  case StructWithCustomByteArray:\n    return len(v.ID) >= v.CustomMinLength\n  }\n  return false\n}))\n. Thanks for your work, custom type's validation is very necessary and useful :smile: \n. Are you sure about your code snippet? Here is syntax issue with struct tag on the field Mobile - it should be:\ngo\nMobile string `valid:\"numeric,required\"`\nYou forgot to put double quote at the end of tag.\n. As was described in struct here: https://github.com/asaskevich/govalidator/blob/master/validator_test.go#L1668\nAnd in test: https://github.com/asaskevich/govalidator/blob/master/validator_test.go#L1829\nCan you give a short snippet with sample?\n. Could you provide a full working example of this issue please?\n. Thanks :)\n. Take a look here: https://github.com/asaskevich/govalidator/blob/master/utils.go#L154\n. Thanks, it can be useful :)\n. :+1: \n. You can use different tags as one:\ngo\ntype validEnrollment struct {\n        MasterEfin       string           `valid:\"alphanum,required\" xml:\"MasterEfin\"`\n}\n``` \ud83d\ude04\n. Thanks, :smile: \n. @krak3n could you put your example into pull request with sample of usage and small note in docs please?\n. @retr0h it should return something like Env.Name: invalid_alphanum does not validate as alphanum or Env.name ...?. I hope that this issue was resolved with one of merged PRs. You can reopen issue if not.. Thanks :+1: \n. You can define custom error messages for your fields in ValidateStruct and then translate them with your i18n library\n. Hi, @meirwah can you provide some tests for this function or maybe @mwmahlberg already resolved this issue with #108?\n. Could you make a PL with this function and tests for it please?\n. Great, thanks :+1: \n. Hi, I'm sorry for so long delay, there was some issues with access to my github account. Thanks for this pull request, :+1:\n. Does this issue appear currently?\n. Hi @F21 and @waltton , I'm sorry for so long delay, there was some issues with access to my github account. Thanks for this pull request, :+1:, merged\n. Thanks :+1: \n. Fixed in #123 \n. Yes, there are some problems, I'm not able to merge it until these'll not resolved\n. @annismckenzie I resolved problems in my commit before the merge (https://github.com/asaskevich/govalidator/commit/6e6a915217c1762995302368a4e880b84e3daf2a) :)\n. @gummybears did you attempted to use ~ symbol instead of -?\ntype Ticket struct {\n  Id        int64     `json:\"id\"`\n  FirstName string    `json:\"firstname\" valid:\"required~First name is blank\"`\n.... @maxvi did you resolve your issue? :smile: Could you refactor and then put your example into README please? \n. Can you provide URLs which causes wrong validation result? I'll take a look\n. Thanks. Is there any special cases that also unresolved in the  current IsURL implementation?\n. > https://github.com/asaskevich/govalidator/commit/5b6e9375cbf581a9008064f7216e816b568d6daa#diff-bf215ece4e5166da723b1e19a0d6b1cdR620\n. I'm not able to merge this pull request - some tests are failed. Also, I agree that \"newline\" char is not good idea for delimiter. So, handwritten parser which able to extract validators, functions and their arguments (strings, regexes, numbers, booleans), will be much better solution. Not sure, that I'll will work on it in near future. \n_But @Rhaseven7h _: you pull request has some changes in tests and core code that will be great to add to master branch. Could you please create new PL with those changes (without changing delimiter)?\n. Yes, now we have support for custom error messages.. Hi, @vahe yes, if err != nil result will be equal to false\nI added comment to the source code:\nhttps://github.com/asaskevich/govalidator/blob/master/validator.go#L533\n. Yes, ValidateStruct supports nested structs: https://github.com/asaskevich/govalidator/blob/master/validator.go#L882\n. Alright, https://github.com/asaskevich/govalidator/blob/master/validator_test.go#L1799\n. Better to follow RFC \ud83d\ude04 But I'm not sure that this regex will validate valid (as it said in RFC) and invalid (according to RFC) emails.\n. @LennartOlsen already, sorry for two-month delay \ud83d\ude1e \n. Agree with @andrewwatson\nrequire means existence of value but not zero equality. Sometimes you need to validate data that recieved from user, e.g. forms from webpages or input in various text fields in your desktop/mobile/web UI. So, this is the main reason to have such validators. Although according to the code, ValidateStruct should accept any fields that can be casted to string, but seems that it doesnt work. \n. I think that there are no difference, first example just a wrapper\n. It will break back compatibility. Could you please put info about changes into the following section of README?\n. Yeah, I can accept it \ud83d\ude04 but what about multiple validators, e.g.:\ngo\ntype Driver struct{\n    Name string `valid:\"-\"`\n    Car CustomCarType `valid:\"customCarTypeValidator1,customCarTypeValidator2~Custom Error Message\"`\n}\n. Hi, sorry for the delay.\nI meant two validators with two custom messages:\ngo\ntype Driver struct{\n    Name string `valid:\"-\"`\n    Car CustomCarType `valid:\"customCarTypeValidator1~First Error,customCarTypeValidator2~Second Error\"`\n}\nWill it print two messages or only first failed if both of validators will be failed?\n. @alessandropietrobelli, look at example above, will it print two messages or only first if both of validators will fall? I would like to merge it, but there is misunderstanding with behavior of function. @alessandropietrobelli sorry for no actions with this pull request for so long time. Could you resolve conflicts with current version of package and I will be able to merge it, please?. Hi @alessandropietrobelli there are some failed tests\n./validator_test.go:11:66: cannot convert func literal (type func(interface {}, interface {}) bool) to type CustomTypeValidator\n./validator_test.go:14:65: cannot convert func literal (type func(interface {}, interface {}) bool) to type CustomTypeValidator\n./validator_test.go:2817:48: cannot convert func literal (type func(interface {}, interface {}) bool) to type CustomTypeValidator\nCould you check it please?. @alessandropietrobelli could you check failed tests, please?. Feel free to make a pull request\n. Hi! Currently its not possible with help of library, but you could to create your own middleware that will accept an object and validate all necessary fields inside itself, something like this:\ngo\nimport v \"github.com/asaskevich/govalidator\"\n...\ntype User struct {\n  Name string\n  Email string\n}\n...\nfunc ValidateMyStruct(u User) bool {\n  return v.IsEmail(u.Email)\n}\n. Could you provide a little snippet with full example of issue please? \n. Did you attempted reverse order of validators in tag? It seems to be issue when version overrides optional\n. Okay, I hope, it's possible to refactor regex for IsURL. There are some issues with IsURL, I'm looking for the solution\n. Please, check added tests, hope issue fixed:\nhttps://github.com/asaskevich/govalidator/commit/7b3beb6df3c42abd3509abfc3bcacc0fbfb7c877#diff-bf215ece4e5166da723b1e19a0d6b1cdR639\n. IsURL uses regexp that omits some valid urls, take a look at #150 \n. Please, check added tests, hope issue fixed:\nhttps://github.com/asaskevich/govalidator/commit/7b3beb6df3c42abd3509abfc3bcacc0fbfb7c877#diff-bf215ece4e5166da723b1e19a0d6b1cdR639\n. No, you could check only first returned value, but if you would like to see what happened in deep, you may have a look at second err value.\n. Could you provide stringified examples, please?\nSomething like https:///notvalid/path. Yes, it seems to be solved with valid: \"required\" tag.. @KonishchevDmitry thanks\n@kohkimakimoto yes, already. There are failed tests:\n--- FAIL: TestCustomValidator (0.00s)\n    validator_test.go:2089: Got an unexpected result for struct with custom always false validator: true %!s(<nil>)\n@KonishchevDmitry @kohkimakimoto can you review it?. Already resolved, thanks to everybody.. Can't find solution commit but there is the line responsible for it: https://github.com/asaskevich/govalidator/blob/6c3cb3214c0bf1206da40f9cb4eef372a5788307/validator.go#L904\nMaybe an issue was in https://golang.org/pkg/reflect/#StructTag.Get function that splits the string by space.. You can use stringlength which works as you expect\ntype demo struct {\n   Name string valid:\"stringlength(2|4)\"\n}. @rmohr sorry for no actions with this pull request for so long time. Could you resolve conflicts with current version of package and I will be able to merge it, please?. No, project is alive :) I will review PRs and issues in my free time. Maybe create alias, something like \"isTimestamp\" or \"IsISODate\" ?. @yezooz can you make proposed changes with second argument? I'll merge it. Great!. Its already in merged PR #185, thanks!. Now it works with pointers and nested structs, isn't it? If not, reopen this issue with an example that shows expected behaviour, please.. It is somewhere here: https://github.com/asaskevich/govalidator/blob/master/validator.go#L1087\n. I agree with IsNumeric case, but IsInt is still valid. \nIsInt check if the string is an integer. Empty string is valid.. @genofire @marcobeierer Could you add some tests before merging please? . Thank you, @kohkimakimoto . Could you provide an example of valid url that marked as invalid by package please?. Is it expected behaviour now? If not, reopen it, please.\n```go\npackage main\nimport (\n    \"github.com/asaskevich/govalidator\"\n    \"fmt\"\n)\ntype Test struct {\n    Num int json:\"-\" valid:\"gtzero\"\n}\nfunc main() {\n    govalidator.CustomTypeTagMap.Set(\"gtzero\", govalidator.CustomTypeValidator(func(i interface{}, context interface{}) bool {\n        switch i := i.(type) {\n        case int:\n            return i > 0\n        }\n        return false\n    }))\nt := &Test{\n    Num: -1,\n}\n\nfmt.Println(govalidator.ValidateStruct(t))\n\n}\nshell\n$ go run main.go\nfalse Num: -1 does not validate as gtzero\n. Could you add some tests for it, please?. @andreychernih it would be great! . https://github.com/asaskevich/govalidator/blob/master/patterns.go#L16\nOnly letters and numbers are allowed.. Hope it is already fixed in #240, isn't it?. @Gouthamve https://github.com/asaskevich/govalidator/commit/6c3cb3214c0bf1206da40f9cb4eef372a5788307#diff-bf215ece4e5166da723b1e19a0d6b1cdR667 resolved, sure. Update your package, please. This issue is already fixed and now the package uses JSON field name instead of struct field name.go\npackage main\nimport (\n    \"github.com/asaskevich/govalidator\"\n    \"fmt\"\n)\ntype Test struct {\n    Num int json:\"numValue\" valid:\"gtzero\"\n}\nfunc main() {\n    govalidator.CustomTypeTagMap.Set(\"gtzero\", govalidator.CustomTypeValidator(func(i interface{}, context interface{}) bool {\n        switch i := i.(type) {\n        case int:\n            return i > 0\n        }\n        return false\n    }))\nt := &Test{\n    Num: -1,\n}\n\nfmt.Println(govalidator.ValidateStruct(t))\n\n}\nshell\n$ go run main.go\nfalse numValue: -1 does not validate as gtzero\n``. It will be much better if there are will be some tests for it. Thanks :). Unfortunately untested but seems to be fixed already. I close it because I merged the fix. If it will reappear, reopen this issue, please.. Not sure. Could you describe by example/readme why do you need it, please?. There is a support forInRangebut it works only with float numbers.\nhttps://github.com/asaskevich/govalidator/blob/aa5cce4a76edb1a5acecab1870c17abbffb5419e/numerics.go#L42\nI think there must be different functions for float and decimal numbers e.g.InRangeFloat32andInRangeInt. Merged, thanks!. But there is no definition of functions to use them in struct tags, will be resolved. @emirhanmarlali there are some conflicts in thevalidator.go. Could you take a look on it, please?. Could you please describe with a little example what do you mean?. Thank you!. Thank you!. @blind-oracle yes, it makes sense\n@aymane-mzily current merged implementation will go to another function, something likeIsEmailExists, and the previous implementation based on regexp will be returned as pureIsEmail` function.\nAlso, in future PRs, check that all tests are passing with go test ., please.. Fixed https://github.com/asaskevich/govalidator/commit/7d2e70ef918f16bd6455529af38304d6d025c952#diff-2c21fb78980d1744f15f8637f5c8700bR55. There is an issue with commas and extracting regexp as an argument of matches. \nhttps://github.com/asaskevich/govalidator/blob/master/validator.go#L766\nThere was a similar issue, and currently, there is only one suggestion - you could implement a custom validator:\ngovalidator.TagMap[\"username_valid\"] = govalidator.Validator(func(str string) bool {\n    return govalidator.Matches(str, \"^[0-9]{3,5}$\")\n})\nand use it\ngo\ntype User struct {\n    Username    string `valid:\"username_valid,required\"`\n    ....\n}. https://github.com/asaskevich/govalidator/commit/7d2e70ef918f16bd6455529af38304d6d025c952#diff-2c21fb78980d1744f15f8637f5c8700bR55. Thank you!. Thank you!. @madislohmus  I'll be able to merge it after resolving conflicts. Could you please take a look at it?. Thank you!. @tretkow @andrewmunro I'll be able to merge it after resolving conflicts. Could you please take a look at it?. Thank you. Could you please review unit tests?\n--- FAIL: TestIsDNSName (0.01s)\n    validator_test.go:1727: Expected IsDNS(\"a.b.\") to be true, got false\nFAIL\nFAIL    github.com/asaskevich/govalidator   0.451s. Thank you!. @marcsantiago could you please take a look at unit tests?\n./validator.go:1202:26: invalid argument customErrorMessage (type tagOption) for len\n./validator.go:1225:45: cannot use customErrorMessage (type tagOption) as type string in argument to fmt.Errorf\n./validator.go:1225:95: too few values in struct initializer\n./validator.go:1228:127: too few values in struct initializer\n./validator.go:1230:130: too few values in struct initializer\nFAIL    github.com/asaskevich/govalidator [build failed]. @marcsantiago which Go version are you using? Tests are falling at golang:1.9. Could you please review unit tests? \nshell\n--- FAIL: TestValidateStruct (0.00s)\n    validator_test.go:2689: Expected ValidateStruct({\"John\" \"john@yahoo.com\" \"123G#678\" '\\x14' %!q(*govalidator.Address=&{Street 123456}) [{\"Street\" \"123456\"} {\"Street\" \"123456\"}]}) to be false, got true\nFAIL\nFAIL    github.com/asaskevich/govalidator   0.394s. Thank you!. Nice, thank you!. @antho1404 @jamiekurtz I reverted https://github.com/asaskevich/govalidator/pull/286 now it should be fine. ",
    "nullboundary": "No problem! Let me know if you have any questions about any of the code changes.\n. Just submitted a pull request correcting the behaviour of UTFDigit and UTFNumeric. Both return true only for -1, 1, +1. \n. Hi slugmobile here (changed my username). \nLooks like some interesting work going on here, definitely like where this is going. However I would caution against adding too much tag validation logic. Since the validator is easily extendable anyway, if the tags are too specific it just adds unnecessary complexity. In this new version insuring a pattern for easily extending the validator should be emphasized as well. Personally in my own projects I am already doing many of these types of validation checks by adding my own validation functions to the tag map. This method does look more concise though and I would say the current tag map solution is getting a bit unwieldy and can't really go on extending forever so this looks promising. \nYour solution does make validation checks much more powerful, but I think its also important to remember whats is useful and what is too specific. So far its looking good, but this could easily evolve into its own validation tag mini language. Not to say that wouldn't be useful in some cases, but over all I think keeping the tags simple and effective should be a priority. At certain point its just easier and more maintainable to write a function in Go then to have a very complex tag validation string. Just something to keep in mind while designing the library. \nAlso this definitely should go into its own branch. Its radically different from the current version, so this should probably be 2.0 or something. The current branch could be maintained for awhile and when this one is ready the project can move over to it. \nMy 2cents.\n. Hi, maybe I confused you. I didn't want to set you off track. I would say to don't worry about reducing code, but think more about how you use the library. The interface so to speak. If you are really not sure what to do next, maybe you can start with trying to make some of the current features compatible with your code. While doing that you might think of some better ways to proceed. \n. ",
    "attilaolah": ":bowtie: \n. I could reproduce that locally when I run it enough times.\nAlso, it might be a good idea to enable the -race flag on CI, which might give us some clues as well.\n. > Is it possible to enable this flag on wercker?\nSure, see #16.\n. Wercker works perfectly though.\n. Travis is also reporting build failures, perhaps that should be removed as well.\n. Cool, thanks!\n. This will need a rebase once #8 is merged.\n. No need, let me rebase.\n. Done, this applies cleanly now.\n. > For an example of a similar but a bit more flexible approach see this slide from a recent talk\nTrue, []struct{\u2026} is way more flexible. I like to use them in tests as well.\nMy rule of thumb is: if I only need two sets of values, and one of the sets is unique (and the order of tests doesn't matter \u2014 it shouldn't anyway), I use a map. Simpler to set up. It is usually enough for the input=\u2026, expected=\u2026 case.\n. :+1: \n. ",
    "deiwin": "For an example of a similar but a bit more flexible approach see this slide from a recent talk\n. ",
    "stevenwilkin": "Glad I could help @asaskevich !\nHaving 2 CI services does seem a bit of an extravagance, getting rid of 1 would free up resources for other projects. Have you noticed any pattern with the Travis failures?\n. ",
    "oryband": "waiting excitedly for an update :)\n. @asaskevich oh I didn't realize that. Thanks. Better document this in the function.\nYou can close this issue.\n. @asaskevich maybe we should reopen this until this issue is fixed.\nI just wasted an hour not knowing that TagMap validation functions don't work on nested int types in structs.\n. @asaskevich please make sure i didn't break anything\n. @bolshoy\n. ",
    "jbreitbart": "IsRequestURL works as expected, thanks. I still find IsURL confusing\n. ",
    "Dadie": "I don't see any old tests left, so issue can be closed (IMO). Also, maybe the way how test should look like should be documented somewhere.\n. Thank you. It seems also that every Is-Function that works on numbers allows \"-\" but not \"+\". Like IsFloat(\"+1.0\") returns FALSE while IsFloat(\"1.0\") and IsFloat(\"-1.0\") return TRUE. Same behavior can be found in IsFloat, IsInt, IsUTFNumeric, IsAlphanumeric and IsNumeric. \n. First of all, thanks ^^ IsInt and IsFloat seems to work now just fine. IsInt(\"+1\") returns TRUE as does IsFloat(\"+1.0\"). \nBut now IsNumeric(\"+1\") returns TRUE while IsAlphanumeric(\"+1\"), IsUTFNumeric(\"+1\") and IsUTFDigit(\"+1\") return FALSE\nThe question is, should every function here return TRUE on \"+1\" and \"-1\" or should only IsFloat and  IsInt return TRUE (as '+' and '-' isn't a digit, alpha or numeric character).\n. Thanks, works now just fine, can be closed (IMO)\n. IsURL more or less checks whether a given URL is a valid \"web url\" (like http://foo.bar) or not, while IsRequestURL and IsRequestURI uses the Stdlib \"net/url\" Parser (http://golang.org/pkg/net/url/) to check whether the given string is a valid URI for an HTTP Request or not. IsRequestURL also checks whether the URI is conform to RFC3986 (http://tools.ietf.org/html/rfc3986) or not.\nI think the tests shows how they behave quite well:\nIsURL (https://github.com/asaskevich/govalidator/blob/master/validator_test.go#L559) \nIsRequestURL (https://github.com/asaskevich/govalidator/blob/master/validator_test.go#L610)\nIsRequestURI (https://github.com/asaskevich/govalidator/blob/master/validator_test.go#L660)\n. Yay, it took me only... 2 Weeks (and a failed exam ._.'') but I somewhat made a prototype. I'll try to add more tests to the prototype in the next days.\nhttps://github.com/Dadie/govalidatorcore\nhttps://github.com/Dadie/govalidators\nWhat the prototype changes: tags are now calls to validation methods. (So goodbye to the old look-up-map for functions). \ne.g.\ngo\ntype Foo struct {\n    bar string `valid:\"ascii,ascii.Confirms(),ascii.upperCase(),ascii.equal(1234)\"`\n}\nThe prototype will now look for an validator with name \"ascii\". ascii and ascii.Confirms() is equal and checks just whether the Confirms() method of the \"ascii\"-validator returns TRUE or FALSE. Same is with ascii.upperCase() and ascii.equal(1234). The validatorcore looks up whether the \"ascii\"-validator has methods called \"upperCase(value interface{})\" and \"equal(value interface{}, equaltostr string)\" and applies the arguments to the methods.\n(end of example)\nAlso the validators and the govalidator(core) are now separated entities. So my hope is we could have  stable validator packages and unstable validator packages. Maybe even versionize the packages like \"govalidator_0_2_0_unstable\".  \nAnyway, this is only a prototype. This is not how the final commit would look like. The code isn't that nice structured, performance is really bad and I probably missed a lot of error checking :/ But it shows what my initial idea was (and goes even further)\nedit:\nAlso the validator now works with any type. So bar intvalid:\"ascii,ascii.Confirms()\"` is also valid. Still a good \"ascii\"-validator will return \"unmatchable type\"-Errors.\nedit2:\nAdded some more validators to the prototype.\n. I've done a bit of trial and error in the design of the prototype and now the prototype is full modular. Currently there is only one validator package module (govalidators). But it could be split in for example govalidator_ascii , govalidator_integer , govalidator_string et cetera. This way, one would only need to import the needed validators.\nAs always, I'm happy for any kind of comment.\nedit:\nAdd README to govalidatorcore and govalidators\n. no problem ^^ I just rewrote a lot of the prototype anyway :P. The reason for the rewriting was \"reasoning\" Ba Dum Tish . My next (feature) goal for the Prototype would be concurrency for validators. \nAfter that I would call the prototype \"feature complete\". The next step would then be optimizing (reduce memory usage, code, reflect usage, cpu usage). \n. I shouldn't have sad it would then be \"feature complete\", now I'm having a lot of new ideas, e.g. how to handle Arrays and Structs! The Idea is to validate whether none, all or at least one value of an slice, array, map is valid.\nHere an example:\ngo\ntype Foobar struct {\n    ints1     []int `valid:\"EACH(integer.IsLess(10))\"`\n    ints2     []int `valid:\"ANY(integer.IsLess(10))\"`\n    ints3     []int `valid:\"NONE(integer.IsLess(10))\"`\n}\nAlso currently it is only possible to conjugate the Validators. So validating something like \"i > 0 || i = -5\" isn't currently possible! My Idea here would be introducing (similar to the EACH,ANY,NONE) the Keywords OR, AND, XOR, NOT. OR, AND, XOR should be able to use as Infix and prefix \"operator\". NOT would replace the !. (this would allow validators name to start with an !)\nHere an example:\ngo\ntype Foobar struct {\n    orInfix   int   `valid:\"integer.IsLess(10) OR integer.IsEqual(15)\"`\n    orprefix  int   `valid:\"OR(integer.IsLess(10),integer.IsEqual(15))\"`\n    andInfix  int   `valid:\"integer.IsLess(10) AND integer.IsEqual(15)\"`\n    andprefix int   `valid:\"integer.IsLess(10) AND integer.IsEqual(15)\"`\n    xorInfix  int   `valid:\"integer.IsLess(10) XOR integer.IsEqual(15)\"`\n    xorprefix int   `valid:\"XOR(integer.IsLess(10),integer.IsEqual(15))\"`\n    complexer int   `valid:\"(integer.IsLess(10) XOR integer.IsEqual(15)) AND NOT integer.IsEqual(0)\"`\n}\n. Thanks for comment @nullboundary, I'll keep that in mind. Keeping the validator simple, useful, powerful and not overcomplex is a goal I lost somewhere ._.'' . The current prototype has to much hassle (e.g Reasons, Errors, Results, Validators).\nAnd yes, for a short time I even thought of using OCL as language with some extensions. I'm quite happy I didn't went that far. I already felt in my last comment, that the AND/OR/XOR/NOT syntax may creates quite long and maybe not good readable or understandable validations.\nSo again thanks for reminding me :)\nAlso the current prototype is planed to be 100% legacy-compatible. So I hope no one  will really notice the internal changes (and possible version jump).\n. no problem ^^ I'm one of this old \"analog-dudes\" that doesn't notoriously check mails, github and co. daily. So a \"delay\" of a few days is more or less not existing for me xD\nAnyway, I also like the Idea but I'm currently not that happy about my (prototype) implementation. I don't know how to reduce the code even more  and simplify the system without sacrificing features ._.''\nSo currently I'm circling in my room,  thinking how to change the design. But I haven't found a better approach so far. Which also means I'm open for any kind of idea/approach/design :D \n. You didn't set me off track, more or less you did the opposite. \"Reducing code\" maybe wasn't the best way to phrase it. The library should be as powerful as needed but as easy and clear to use as possible. Good code with few lines is often quite easy and clear (hence 'reducing code'). And I totally lost focus on that and just made an overengineered \"Monster\" which wasn't that easy to use and that clear. Currently the code is (IMO) much more useful and clear than the first initial design.\nSo yes, my current focus isn't about simply reducing the LoC but reducing every not needed overhead and making the API more clear and easy to use. I'll try doing what you sad and will add more features of the current govalidator. \nMaybe this way I'll find some good ideas ^^\n. Thanks again for that offer, but as of now I'd like to stick with Pullrequests. They give me more control over myself and give others an opportunity to comment and/or discuss.\n. First of all, thanks. In deed, there seems something to be wrong. Thanks for point it out.\nAs v has the type reflect.Value anyway, why not replace the whole function? \ngo\n            isNil := v.Interface() == nil\n            isZero := v.Interface() == reflect.Zero(v.Type()).Interface()\n            if isNil || isZero {\n                err := fmt.Errorf(\"non zero value required for type %s\", t.Name)\n                return false, err\n            }\nThis should also do the trick, or is there any kind of reason (or benefit) to use an anonymous function?\n. What coincidence hehe :D, #45 stated (and fixed) the same error (only a few hours earlier). #45 and #46 should fix this bug. So yeah, you're totally right and thanks for reporting it. As soon as #45 or #46 is merged, the bug should be gone forever (or at least I hope so ._.''). \nYour example returns with #45 and #46 result == false and err ==  \"non zero value required for type Title\", still the error message isn't that useful. Maybe I'll rewrite some of the error messages to be more helpful ^^\n. Thank for mention ^^ I changed the test in #60 but not in #61 (my fault ._.''). I rebased to master, now everything should work fine.\n. I somewhat expected this kind of issue in near future. At \"fault\" is the commit e743b6953f1e4f94e41310d96f1f353691383eaa\nThe thing is, so far \"String\" is the only Kind the current govalidator is able to validate. The only \"validation\" that works on every Kind is \"required\". All other \"validations\" currently only work on Kind \"String\".\nUntil e743b6953f1e4f94e41310d96f1f353691383eaa the validation of any non \"String\" Kind field was simply skipped. I thought skipping them wasn't a good design, as it might lead to thinking the current struct is valid even though I might no be.\nHalf-OT:\nCurrently I'm working on a \"big Patch\" that allows validation on any Kind. Current Prototype of the \"big Patch\" is govalidatorcore with govalidators. The prototype should be backward compatible, but as a prototype it might changes a lot over time.\n. ",
    "manucorporat": "Hi, it's Manu. Creator and maintainer of the the Gin Framework.\nWe have been having problems with our current validation library, and I am evaluating alternatives.\nI wonder if this feature will be available soon.\nBtw, +1 for min(), max() instead of lessEqual()... it could work for integer and string length.\n. ",
    "rubenhazelaar": "Hopefully there are more people waiting for this feature. For me this one would be great. There is one for strings (\"length(min|max)\"; broken according to #93), however for me personally I would want to use it to limit integers. . ",
    "dlsniper": "Nvm, I've read the docs again and found it.\n. ",
    "stansm": "Sorry, I've just fixed the code to work for me as I didn't have much time to rewrite it. So I left anonymous function there as it was in the trunk. Just wanted to let you know that there is an error.\nI don't think it's needed there and it adds unnecessary overhead. Your proposed implementation is better and my code passes tests with it :)\n. ",
    "myzie": "Great, thanks @Dadie for the heads up.\n. ",
    "raulgzm": "Yeah! It\u00b4s working. Thanks a lot!\n2015-03-07 10:22 GMT+01:00 Alex Saskevich notifications@github.com:\n\nTake a look to this issue: #30\nhttps://github.com/asaskevich/govalidator/issues/30\nI think, they're similar.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/asaskevich/govalidator/issues/48#issuecomment-77681012\n.\n\n\nRa\u00fal.\n. ",
    "imothee": "Thank you! \nI agree with the formatting and the returned data structures and was just about to write this myself.\n. I did not actually check the low level code for validity but I think there are some problems with the way the casting/assignment in the commit is done.\nEg. validateStruct returns a type error which cannot be ranged as type Errors. Additionally, Errors is a slice of type error, not Error.\nIt also returns different types \"error\" vs Error vs Errors in different sections. There should be more consistency with typeCheck returning *Error or only \"error\" types rather than Error{t.Name, err} in some cases.\nI would be happy to work on a better way of managing consistency as I think it is important.\n. Good point, I see what you were trying to achieve now and agree that keeping API consistency is a good thing. Thank you for explaining that.\nMy mental complexity is mapping in validation 'fails' with normal error cases. In my perfect world you would have something more like\nvalid, invalidFields, err := validateStruct()\nBecause to me, separating an error occurred (ie. if the library had to validate against a server and there was a network issue) from \"these fields are invalid\" makes more sense and leads to more explicit code.\nHowever I was not considering breaking changes to the API and I agree that returning an error as the error itself is more natural so I am happy to deal with the complexity in my code and not the library!\n. ",
    "bom-d-van": "\nThank you! \nI agree with the formatting and the returned data structures and was just about to write this myself.\n\nCool. If it's alright, could you merge the request? Thanks\n. :+1: \n. IMO, I think returning an error is more natural in the world of go.\nIf you don't care about the error content and just want to stop the processing of your program, you just check if err != nil. If you want to inspect the error, you could do:\ngolang\nif errs, ok := err.(govalidator.Errors); ok {\n    for _, err := range errs {\n        if e, ok := err.(govalidator.Error); ok { ... }\n    }\n}\nThis change offers us the capability to inspect the error without changing the original api. However, this is just my opinion, may be you have a better idea. Looking forward to yours.\n. ",
    "nemccarthy": "This would be super handy! . ",
    "mcuadros": "Awesome!\n. ",
    "robmurtha": "Ok I can see the purpose is for output vs conversion. Perhaps a\nToQuotedString(obj interface{}) interface would be a more intuitive name\nbut I'm not asking for a change, I've been using Sprintf. Thanks I like\nyour package.\nOn Sat, May 2, 2015 at 5:29 AM, Alex Saskevich notifications@github.com\nwrote:\n\njson.Marshal, that used inside function, adds double quotes. I think that\nit can be replaced with fmt.Sprintf(\"%v\", obj) that works like this:\npackage main\nimport (\n    \"fmt\"\n)\ntype Outer struct {\n    A int\n    B int\n    InnerItem Inner\n}\ntype Inner struct {\n    C float64\n    D complex64\n}\nfunc main() {\n    println(fmt.Sprintf(\"%v\", 1))                                                         //=> 1\n    println(fmt.Sprintf(\"%v\", \"abc\"))                                                   //=> abc\n    println(fmt.Sprintf(\"%v\", 'a'))                                                        //=> 97\n    println(fmt.Sprintf(\"%v\", true))                                                    //=> true\n    println(fmt.Sprintf(\"%v\", Outer{10, 20, Inner{1.45, 1.5 + 3.5i}})) //=> {10 20 {1.45 (1.5+3.5i)}}\n    println(fmt.Sprintf(\"%v\", 1.5))                                                      //=> 1.5\n    println(fmt.Sprintf(\"%v\", 1.0 + 10i))                                            //=> (1+10i)\n}\nI will try to replace json.Marshal with fmt.Sprintf if all tests will be\nOK.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/asaskevich/govalidator/issues/54#issuecomment-98339388\n.\n\n\nRob Murtha\n302-359-5943\nhttp://www.linkedin.com/in/robmurtha\nhttp://www.twitter.com/robmurtha\n. ",
    "sebest": "Good to know!\nthanx\n. ",
    "leadinglocally": "https://pbs.twimg.com/profile_images/560826135676588032/j8fWrmYY_normal.jpeg\nThis image URL is invalid according to this package\n. ",
    "nathj07": "I think this and #66 are the symptoms of the same thing. I'm looking into this now and hope to have a pull request on it soon\n. I actually have a pull request (just opened) that adds a few tests. I'll try to handle this issue in there. It shouldn't be too tricky.\n. I'll try to tackle Issue #66 with this change, I'll close until done.\n. Note: the final commit references the wrong issue number. The issues here are #62 and #66 \n. Hmm, I'm away from my machine at the moment. I can try to take a look next\nweek.\nOff the top of my head I think we may need to check  the various components of the URL struct after using url.Parse, that way we can check the schem, host, path etc of the URL as well as the reflex validation we currently have. It should be a straight forward fix I think.\nOn 19 Aug 2015 11:51, \"Anton Sekatski\" notifications@github.com wrote:\n\nSadly but it's still not working correctly: govalidator.IsURL(\"google\") -\nit's not a valid url but it returns true\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/asaskevich/govalidator/pull/70#issuecomment-132538352\n.\n. Would you be able to add a test case to prove this please? I generally like how much coverage this library has.\n. Thanks, I'll keep an eye out for it.\nOn 19 Aug 2015 18:10, \"Andriy Rakhnin\" notifications@github.com wrote:\nI'll refactor it...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/asaskevich/govalidator/pull/80#issuecomment-132697912\n.\n. Seems like a reasonable test to me. I'll leave it up to @asaskevich for the final say.\n. Been working on this with a colleague and having:\n\ntype UserDataPatch struct {\n    GivenName     string `json:\"givenName,omitempty\"`\n    FullName      string `json:\"fullName,omitempty\" valid:\"length(1|2)\"`\n    Password      string `json:\"-\" gorm:\"-\"`\n    ... etc \u2026\n}\nresults in the FullName being considered valid. \nWe then looked at the tests and added in the following:\nTo TestLengthStruct:\n{LengthStruct{\"\"}, false},\nand to to TestStringLengthStruct we added:\n{StringLengthStruct{\"\"}, false},\nBoth tests fail. However, adding {\"\", \"1\", \"2\", false}, to TestByteLength passes.\nIf need be I can make a PR with the updated tests. Not sure how you want to tackle this. I'm happy to fix it up if you have any particular approach in mind.\n. Still open and needs resolution. I haven't had time to look into it yet.\n. Nice, looks good to me. A helpful catch\n. ",
    "franklinkim": ":+1: any update on this one!? very interested in being able to validate other types than strings!\n. ",
    "dipbhi": "Here you go:\n```\npackage main\nimport (\n    \"fmt\"\n    validator \"github.com/asaskevich/govalidator\" \n)\nfunc main() {\n    // Works\n    fmt.Println(validator.IsNumeric(\"1\"))\n// Generates compilation error\n// undefined: govalidator.IsNegative\nfmt.Println(validator.IsNegative(-1))\n\n}\n```\n. It's working now!\n. ",
    "sivagollapalli": "@kfei I have just added test for Wikipedia URL. But test has been passed.\n. ",
    "annismckenzie": "What I'd really like instead of the library-global switch would be a new ValidateStructWithOptions() method that you could call with the fieldsRequiredByDefault (I'm bad at naming things sigh) option set to true. That way one could selectively call this on a specific struct.\n. Thanks for merging that! :)\nAs for passing options: the idea is nice but would break backwards compatibility which is something I'd like to avoid. The proposal is also not that flexible because it's not field-specific. I have two more use-cases that I'd like to run by you \u2013 should I create issues for that? Thank you again for this awesome library!\n. Awesome, thanks! Yeah, I will take a look at enhancing that to return a nested map instead and keep it backwards compatible (don't know if that's possible, though).\n. My bad. I'm the one who added that feature. I'll add a test and will hopefully resolve this issue. Did you by any chance implement your own fix for this and use the forked version vendored in your project? Don't want to do this work twice if that can be avoided.\n. Yep, sure am \u2013 no worries. Waiting on Alex on how to proceed; as you can see, #123 introduces a BC break but applying just 13f9f0094fc734d9c446c2ba16c9dee3e0417f7d onto the current master fixes this issue without introducing a [code] BC break. If you forked and vendored the library you can also just apply the respective commit (or stay with your fix for now).\n. This is now fixed \u2013 can you re-check please?\n. Erm, this is weird. Why did you merge this when a) the Wercker build failed and b) the IsHost function was removed (as noted above by @waltton)?\n. Oh, now I see. Should've taken a look at the merge commit. Still, it might be better in the future to fix these mistakes in a commit and push it to the merge request. :)\n. Alright, this is now done. I took care of #118 and fixed #116. Unfortunately, the BC break was unavoidable \u2013 the only good thing is that projects updating the library after this is merged will get broken builds (bear with me here\u2026) and the fix is mechanical in nature: just update the function signature from\ngo\n  // old signature\n  func(i interface{}) bool\nto\ngo\n  // new signature\n  func(i interface{}, o interface{}) bool\nand you're done.\nI added a few tests that were missing but otherwise didn't change anything so as to not introduce regressions.\nI have no clue why the Wercker build is failing, executing all tests locally takes about 0.5s but the Wercker build takes a minute before it fails. Maybe it's running into a timeout?\n. Fixing the data race introduced another BC break:\ngo\n  // before\n  CustomTypeTagMap[\"customByteArrayValidator\"] = CustomTypeValidator(func(i interface{}, o interface{}) bool {\n    // ...\n  })\nto\ngo\n  // after\n  CustomTypeTagMap.Set(\"customByteArrayValidator\", CustomTypeValidator(func(i interface{}, o interface{}) bool {\n    // ...\n  }))\nAgain, deeply sorry for the inconvenience. :-/\n. You can find an example in the readme: https://github.com/asaskevich/govalidator#custom-validation-functions. :). I would add this validation as a custom validator (either using the tag map or using the custom type validation, see the updated README for examples of using both). This keeps your intentions clear, your struct clean and the regex out of the struct tags.\n. An example of using the tag map is here: https://github.com/asaskevich/govalidator/issues/131#issuecomment-220292538.\n. This is supported and also tested in the unit tests \u2013 would close.\n. A quick example would be great, a failing unit test would be even better \u2013 you can find the custom validation tests here: validator_test.go#L1924. When #123 lands you'll also have access to the struct being validated in the custom validation function; that should cut down on the amount of code necessary for your scenario.\nNow, I don't really get what you're saying. The custom validation function runs when it's defined on a field and you are responsible for returning true or false all on your own. If there's some condition where a zero-value is acceptable then return true in that instance. Required or optional validation tags are ignored when custom validators are defined on a field. I don't really see why the custom validation wouldn't be triggered. Are you using a custom validation function defined inline and access closure variables/objects from the outside to figure out whether to validate or not?\n. I'm against changing the regex to this oversimplistic one \u2013 you may add your own struct validation tag or your own custom validation function.\ngo\n  rxEmailLax = regexp.MustCompile(\"^.+@.+$\")\n  govalidator.TagMap[\"email_lax\"] = govalidator.Validator(func(str string) bool {\n    return rxEmailLax.MatchString(str)\n  })\n. Let me ask you this: what real-world email address that you currently need to handle failed the validator? The list above is, to be frank, a bit weird.\nLooking at them, here's the list with checkboxes \u2013 unchecked means it fails validation:\n- [x] blah@gmail.com\n- [x] test@d.verylongtoplevel\n- [ ] holy..moly.@gmail.com\n- [x] email+tag@gmail.com\n- [ ] \" \"@example.com\n- [ ] \u201cAbc\\@def\u201d@example.com\n- [ ] \u201cFred Bloggs\u201d@example.com\n- [ ] \u201cJoe\\Blow\u201d@example.com\n- [ ] \u201cAbc@def\u201d@example.com\n- [x] customer/department=shipping@example.com\n- [x] $A12345@example.com\n- [x] !def!xyz%abc@example.com\n- [x] somename@example.com\n- [ ] much.\u201cmore\\ unusual\u201d@example.com\n- [ ] very.unusual.\u201c@\u201d.unusual.com@example.com\n- [ ] very.\u201c(),:;<>[]\u201d.VERY.\u201cvery@\\ \"very\u201d.unusual@strange.example.com\n- [x] !#$%&'*+-/=?^`{}|~@example.com\n- [x] Miles.O'Brian@example.com\n- [x] postmaster@\u2601\u2192\u2744\u2192\u2603\u2192\u2600\u2192\u263a\u2192\u2602\u2192\u2639\u2192\u271d.ws\n- [ ] allen@[127.0.0.1]\n- [ ] allen@[IPv6:0:0:1]\n- [ ] root@localhost\n- [ ] john@com\nWhich one of those unchecked would you like fixed first? Looking at the regex I see that it's a monster. Will try to check for an alternative as well.\n. Interesting. GitHub tries to autolink these addresses and the validator succeeds in a few where GitHub does not link them as one email address (just parts of it). All of the unchecked ones are not recognized by GitHub either.\n. You're right. To be honest, I have never seen or met someone with an email address looking like the ones above that are unchecked. Emojis, backslashes, \u2026 \u2013 who remembers this stuff? :D\nOh, one jumped out at me from the corporate world: \u201cFred Bloggs\u201d@example.com. These I have seen once.\nWaiting on @asaskevich to chime in.\n. Which feature are you referring to? This PR was not a feature implementation but a refactoring with no BC breaks.. ",
    "rakhnin": "I'll refactor it...\n. ",
    "chrisjones-brack3t": "I just ran into the same issue and agree that []error should be returned rather than a concatenated string of errors. Maybe the better solution is to provide another ValidateStruct type function that returns []error. Then you're not breaking anything.\n. ",
    "tapocol": "The underlying data structure is []error. However, ValidateStruct function signature just makes the return value be the error interface:\ngo\n    var errs Errors\n    // ... folded code\n    if len(errs) > 0 {\n        err = errs\n    }\n    return result, err\nhttps://github.com/asaskevich/govalidator/blob/1a4bf7e7a98e6a6484254ac41c52ef20ec30814e/validator.go#L499\nThe Errors type is []error:\ngo\ntype Errors []error\nhttps://github.com/asaskevich/govalidator/blob/1a4bf7e7a98e6a6484254ac41c52ef20ec30814e/error.go#L3\nI believe if someone changed the return types of function to (bool, Errors), returned nil if len(errs) == 0 and removed the variable err in the function and return errs instead, it would not be a breaking change.\n. ",
    "alioygur": "I don't agree with this.\nYou can get errors like this.\n``` go\n_, err := govalidator.ValidateStruct(v)\nif err != nil {\n    errs := err.(govalidator.Errors)\n}\n```\n. I think the ValidateStruct function should return only error.\nif returned value not equal to nil, I will know that validation failed. otherwise I know it passed.\n. bytes count always greater than runes so there is no problem :). ",
    "paulwalker": "What about adding a slice of field errors on the returned single error instance itself? What is the error type btw? Is there any metadata returned?. ",
    "nkcraddock": "This is a blocker for me, so I'm going to submit a pr later.\n. @asaskevich Can you check this and merge it in? I've added some new test cases and all existing tests pass. \n. No worries. Thanks for the merge.\n. ",
    "samora": "@asaskevich This is embarrassing. Thanks a lot. Very surprising gofmt does not detect the typo.\n. ",
    "raitucarp": "what is the status of this issue?\n. What is the status of this issue?\n. ",
    "carlisia": "The length validator is broken. \nUse case: change zero to, say, 10 here:\nhttps://github.com/asaskevich/govalidator/blob/master/validator_test.go#L2342\nThen make food an empty string here:\nhttps://github.com/asaskevich/govalidator/blob/master/validator_test.go#L2342\nThis test will incorrectly pass.\n. ",
    "aldidana": "maybe this will help you\n162 .",
    "kidtronnix": "+1!!!!\n. Hmmm i see your point and in some ways it is more flexible. But also the the json tag is what the user will practically see for any restful JSON applications, which I believe will be a alot of use cases.\nCould we potentially have some way of specifying a custom tag field? \n. ",
    "waltton": "If the intent is make the messages more user friendly I think that would be better use a field for these only purpose.\n. Hey @chatwithrajaram, create a PR from your fork, is more easy to review the code and all that.\n. Running some tests I saw some problems.\nSeems that you remove the function IsHost by mistake.\nAlso in validator_test.go at the line 2265 there's the error \"too few values in struct initializer\". To fix it, the fields could by named, or the third field need to be passed.\n. Be careful, this can break the code of many people. I don't think that's a great idea change this separador. Keep the \",\" and use something like \",,\" inside an expression that needs the \",\" maybe would be a better solution\n. Take a look at #121\n. Take a look at  #121\n. If you say that a integer is required the only value that make sense to be considered as not valid is zero. But if you use a pointer to a integer that can be null the zero maybe considered as a valid value.\n. Go is a strongly typed language, there's no need to verify if the value inside a variable of type int is a int. If you try to validate a variable of type string the verification would make more sense.\n. ",
    "krak3n": "We wanted the same thing, we ended up using reflect to get the validation subject struct fields, extract their json tags to get the field name we want to return in responses, something like this:\n``` go\nfunc ValidationError(ctx echo.Context, s interface{}, err error) error {\n    switch err.(type) {\n    case govalidator.Errors:\n        // Use reflect to get the raw struct element\n        typ := reflect.TypeOf(s).Elem()\n        if typ.Kind() != reflect.Struct {\n            return UnexpectedError(ctx, errors.New(\"validation subject is not a struct\"))\n        }\n    // This is will contain the errors we return back to user\n    errs := map[string]string{}\n    // Errors found by the validator\n    errsByField := govalidator.ErrorsByField(err.(govalidator.Errors))\n    // Loop over our struct fields\n    for i := 0; i < typ.NumField(); i++ {\n        // Get the field\n        f := typ.Field(i)\n        // Do we have an error for the field\n        e, ok := errsByField[f.Name]\n        if ok {\n            // Try and get the `json` struct tag\n            name := strings.Split(f.Tag.Get(\"json\"), \",\")[0]\n            // If the name is - we should ignore the field\n            if name == \"-\" {\n                continue\n            }\n            // If the name is not blank we add it our error map\n            if name != \"\" {\n                errs[name] = e\n                continue\n            }\n            // Finall if all else has failed just add the raw field name to the\n            // error map\n            errs[f.Name] = e\n        }\n    }\n\n    // Return the validation error\n    mapper := &Errors{Message: \"Validation Error\", Errors: errs}\n    return ErrorHandler(422, mapper, ctx)\n}\n\n// If the error type is not a govalidator.Errors, return a 500\nreturn UnexpectedError(\n    ctx,\n    fmt.Errorf(\"Expected govalidator.Errors, got %s\", reflect.TypeOf(err)))\n\n}\n``\n. @asaskevich sure, I'll try and do it over the weekend \ud83d\ude03 \n. @paroxp I didn't get to it last weekend but hopefully this weekend, it's just going to be documentation how how you could use reflection to get thejson,xmlor what ever otherstruct` tag to get the field name you want to use for the error value.\n. Ended up doing this for the time being:\ngo\n    errors := map[string]string{}\n    for _, err := range errs {\n        gvErrors := err.(govalidator.Errors)\n        for _, gvError := range gvErrors {\n            e := gvError.(govalidator.Error)\n            validationErrors[strings.ToLower(e.Name)] = strings.TrimSpace(e.Err.Error())\n        }\n    }\n. ",
    "paroxp": "Looking forward to this PR. \nIs it just going to use the json:\"value\" as it's field name, or perhaps different approach will be taken?\nThanks.\n. ",
    "IAD": "do we have updates or solution?\n. ",
    "retr0h": "What about nested field names?\nIf we validate the following, we get Name: invalid_alphanum does not validate as alphanum.  However, we cannot identify which failed when nested fields contain the same name.\ntype Resource struct {\n    Name string `json:\"name\" valid:\"alphanum\"`\n    Version string `json:\"version\" valid:\"required\"`\n    Env struct {\n        Name string `json:\"name\" valid:\"alphanum\"`\n        Value string `json:\"value\" valid:\"required\"`\n    }\n}. ",
    "saifabid": "^ Yes, that would be the expected behavior, however is not the case currently. @asaskevich * . ",
    "chatwithrajaram": "I implemented custom error message by forking this code. Please take a look at my github account.\nhttps://github.com/chatwithrajaram/govalidator\nYou can configure custom error message with below format.\nvalidationTab~custom error messge\nExample: required~username is manatory\nIf you don't specify custom error message, it will fall back to default behaviour\n. I created pull request. Please take a look.\nOn Thu, Mar 31, 2016 at 7:43 PM, Waltton Santana notifications@github.com\nwrote:\n\nHey @chatwithrajaram https://github.com/chatwithrajaram, create a PR\nfrom your fork, is more easy to review the code and all that.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/asaskevich/govalidator/issues/104#issuecomment-203956910\n\n\nBest Regards,\nRajaram Ganjikunta\n. ",
    "mwmahlberg": "I actually added this via a regex in #108 as IsDNSName (struct tag dns) . Note however that there is a bug which I just discovered which accepts host:port combinations (see issue #109 for updates).\n. @asaskevich I am not sure that would actually make sense. As far as I can see, this request actually is covered in #108 \n. @asaskevich If you are to include #111 , this PR can be omitted (branched too late).\n. Includes #110 \n. No problem about the delay ;)\n. lgtm Have it running on a project.\nMaybe we could add the functionality that actually for nested structs, the parent struct name would be added to the error message. For example Name.First instead of Name That should be relatively easy when making\nErrorsByField(e error)map[string]string\ncall something like\nerrorsByField(prefix string, e error) map[string]string\nwhen entering the recursion.\n. Reviewed 2 of 2 files at r1.\nReview status: all files reviewed at latest revision, all discussions resolved.\n\nComments from Reviewable\n Sent from Reviewable.io \n. ",
    "F21": "Seeing the same issue here.\n. Any chance this can be merged? Running into this issue when validating nested structs as well.\n. ",
    "shardnit": "I am also bumping in the same issue. ValidateStruct() method doesn't validate embedded structs. Following is a very simple example to reproduce the befaviour:\n``` go\npackage main\nimport (\n    \"fmt\"\n\"github.com/asaskevich/govalidator\"\n\n)\ntype User struct {\n    Name string valid:\"alpha,required\"\n    Address\n}\ntype Address struct {\n    City string valid:\"alpha,required\"\n}\nfunc main() {\n    user1 := &User{}\n    ok, _ := govalidator.ValidateStruct(user1)\n    fmt.Println(ok) //false\nuser2 := &User{Name: \"test\"}\nok, _ = govalidator.ValidateStruct(user2)\nfmt.Println(ok) // true?!\n\n}\n``\n. Sorry for the false alarm. I should have addedvalidtag forAddressembedded struct inUser`.\n. hey sorry for the delay in getting back on this issue. I did have a temporary fix for this but looks like you are ahead than me. Let me know if I can help.\n. \ud83d\udc4d \n. ",
    "dav-": "I was encountering this problem as well.\nIt should be noted that the embedded struct type definition must be public. Here's a working example:\n``` go\npackage main\nimport (\n    \"fmt\"\nvalid \"github.com/asaskevich/govalidator\"\n\n)\n// PersonData contains the data for a Person\ntype PersonData struct {\n    Name   string valid:\"required,alpha\"\n    Email  string valid:\"required,email\"\n    Age    int    valid:\"required\"\n    Hopes  string valid:\"null\"\n    Dreams string valid:\"null\"\n}\n// Person represents a Person with hopes and dreams\ntype Person struct {\n    PersonData valid:\"required\"\n    ID         int\n    OtherField string\n}\n// Speak instructs the person to talk about themselves\nfunc (p *Person) Speak() {\n    fmt.Printf(\"Hello, my name is %s and I am %d. My ID is %d. I want to be an %s and %s.\\n\", p.Name, p.Age, p.ID, p.Hopes, p.Dreams)\n}\nfunc main() {\n    data := PersonData{\n        Name:   \"Steve\",\n        Age:    8,\n        Email:  \"steve@steve.steve\",\n        Hopes:  \"astronaut\",\n        Dreams: \"live in Candyland\",\n    }\nperson := Person{\n    PersonData: data,\n    ID:         1,\n    OtherField: \"foo\",\n}\n\nperson.Speak()\n\n_, err := valid.ValidateStruct(data)\nfmt.Println(\"PersonData:\", err)\n\n_, err = valid.ValidateStruct(person)\nfmt.Println(\"Person:\", err)\n\n}\n```\nOutput:\nHello, my name is Steve and I am 8. My ID is 1. I want to be an astronaut and live in Candyland.\nPersonData: Hopes: astronaut does not validate as null;Dreams: live in Candyland does not validate as null;\nPerson: Hopes: astronaut does not validate as null;Dreams: live in Candyland does not validate as null;;\n. ",
    "thumbsized": "3 years later and I still cannot find this functionality.. I needed a []string to be non-empty and setting it to \"required\" worked.. ",
    "korovkin": "can we please also support urls that contain \"_\" ? \n. this is breaking out current setup: where machines are dev_001.service.xxx. sure, for example: http://hello_world.example.com or hello_world.example.com\n. ",
    "Raggaer": "Is there any example on how to add a custom message? Thanks\n. ",
    "wilsontamarozzi": "Custom message example\ngolang\n`valid:\"required~My custom message for require,length(2|60)~My custom message for length\"`. I'm sorry for my english.\nIn my project it works normally.\nhttps://github.com/wilsontamarozzi/panda-api/blob/master/services/models/people.go#L20\nWhen placing a tag, you can not use the TAB to indent, the tags should only contain one space between the others.. ",
    "gummybears": "Tried to validate a record with a custom message like explained, but it does not work. I see \nempty records appearing in the database. \n```\npackage main\nimport (\n  \"fmt\"\n  \"time\"\n  \"github.com/asaskevich/govalidator\"\n)\ntype Ticket struct {\n  Id        int64     json:\"id\"\n  FirstName string    json:\"firstname\" valid:\"required-First name is blank\"\n  LastName  string    json:\"lastname\"  valid:\"required-Last name is required\"\n  Email     string    json:\"email\"     valid:\"required-Email is required\"\n  Licence   string    json:\"licence\"   valid:\"required-Licence plate is required\"\n  Complaint string    json:\"complaint\" valid:\"required-Complaint is required\"\n  Date      string    json:\"datum\"\n  CreatedAt time.Time json:\"createdAt\"\n  UpdatedAt time.Time json:\"updatedAt\"\n  DeletedAt time.Time json:\"-\"\n}\nfunc main() {\n  lv_ticket := Ticket{}\n  _, lv_err := govalidator.ValidateStruct(lv_ticket)\n  fmt.Printf(\"error should be set, but is not '%v'\\n\",lv_err)\n}\n```. Hmm, no, but to be honest I found the go-ozzo/ozzo-validation package easier to use.\nThanks for your help.. ",
    "karanvpurohit": "I am Facing similar issue\n. ",
    "maxvi": "you can use something like this\n`` go\n    type City struct {\n        ID uint\n        Name stringvalid:\"city\"`\n        CountryID uint\n    }\ntype Country struct {\n    ID uint\n    Name string\n    Cities []City\n}\n\ngovalidator.CustomTypeTagMap.Set(\"city\", govalidator.CustomTypeValidator(func(i interface{}, o interface{}) bool {\n\n            // i - field that need to be validated\n            // o - model of current City\n\n            c := City{}\n            DB.Where(City{\n                    CountryID: o.(City).CountryID,\n                    Name: i.(string),\n            }).Find(&c)\n\n            if c.ID > 0 {\n                    return false\n            }\n\n            return true\n}))\n\n```\n. seems like it's already in README https://github.com/asaskevich/govalidator/#adding-a-custom-validator\n. ",
    "ayeshapatel": "can u give example\n. ",
    "andrewwatson": "seems like the easy fix is to add a matching whitespace glob to the regex in the parts that are doing alphanumeric?. In Go structs, the \"zero value\" of an int is 0.  It's impossible to know if someone created the struct without setting the value of the int or they deliberately used 0 as the value.  It seems like this test was designed to catch the former, not the latter.\nMaybe instead of \"required\" it should be a \"non-zero\" validation?. seems like it would be easy enough to try and compile the regex and detect failure, no?. ",
    "juliusv": "Sure. The example from https://github.com/prometheus/prometheus/issues/1579 is http://prometheus-alertmanager.service.q:9093, but any other example with a single-letter TLD will fail to validate.\n. Thanks a bunch, that should fix the 1-char TLD problem at least :)\nClosing the issue.\n. ",
    "rhaseven7h": "Just noticed the CI on wercker failed, but can't see the results.\nJust FYI made sure all tests passed before sending the PR, added one relevant test and forgot to mention, and made changes where it was needed.\nForgot to mention, with this change, an invalid regular expression will now cause a panic instead of being ignored silently.\nSince it would break backwards compatibility (it will) probably a better solution should be put on the table, but for new users, or next top version change, it is as good as any.\n. I know. two dots would also be a no-no since it is a valid and maybe often used expression for regular expressions, mayb something like:\ngo\nstruct Something {\n    Field string `valid:\"matches(rxmorethan3),required\" rxmorethan3=\"^.{3,}$\"`\n}\nWhat do you think?\n. ",
    "vahe": "Thanks!\n. ",
    "OlgaDnepr": "Hi,\nI've got the same error. My custom validator doesn't validate empty fields.  I believe that the problem is in line 813 in validator.go file:\nif isEmptyValue(v) {\n        // an empty value is not validated, check only required\n        return checkRequired(v, t, options)\n    }. ",
    "geedchin": "@OlgaDnepr hi, how did you  deal with the issue? . ",
    "veqryn": "Fair enough.\nWhat about improving the current regex to cover more of the above examples?\n. I guess this sort of depends on how much more complicated you want the regex to get...\nYou could probably handle the holy..moly.@gmail.com address without much difficulty, but everything else looks quite tough to handle.\nAnd whether you want to handle the last 4 (the IP based and the domains lacking a dot), might be debatable for some of your users.\n. ",
    "epelc": "@asaskevich any reason why mail.ParseAddress isn't being used?\n. @dolmen I was thinking you could get the Address field. It's definitely not ideal though.\nI wasn't aware html5 had a different spec for email formats.. ",
    "dolmen": "Instead it would be better to use the regexp provided in the HTML5 specification for e-mail input fields:\nhttps://www.w3.org/TR/html5/forms.html#valid-e-mail-address\nThe HTML5 spec explains why the specification RFC5322 is broken and should not be followed.. @epelc Is \"Alice <alice@example.com>\" really something you want to accept in a field for an e-mail address?\nIsEmail is a matcher. Not an extractor like mail.ParseAddress.. ",
    "emersion": "\nUsing regular expressions to parse email addresses\n\nhttps://drewdevault.com/2017/08/13/When-not-to-use-a-regex.html. ",
    "macrael": ".mil addresses are not recognized. I too suggest a simpler regex for this. I like the advice on this site: https://www.regular-expressions.info/email.html though the HTML definition mentioned above also looks good.. ",
    "0sc": "I see the email validation was updated sometime after this thread. Was there a standard settled for? Currently, it marks entries such as \"]\"@bar.com,\")\"@bar.com, &@bar.com, \"@bar.com, '@bar.com.. ",
    "ptman": "Single character domains also seem to fail, like a@b.com, while a@bc.com is ok.. Maybe use the regex used by HTML5 browsers to validate type=email inputs: https://www.w3.org/TR/html5/forms.html#valid-e-mail-address. We had a problem with email addresses that had a three component domain, e.g. foo@bar.baz.com. Solved by switching to HTML5 regex.. ",
    "omeid": "This feature completly lacks documentation and is rather confusing for new comers.. Whops, I commented on the wrong pull request, but validation tag options still doesn't seem to be documented. Unless I am missing something here.. ",
    "LennartOlsen": "@mwmahlberg i like your idea of adding a prefix, but it seems that another soultion to actually follow the structure would be nicer like maybe:\nerror = map[string]interface{} = {\n     \"name\":string(\"error\")\n     \"childobject\": map[string]string = {\n          \"childname\":string(\"error\")\n     }\n}\nI dont know if its in any way possible but it would be cool\n@asaskevich what is the ETA of this pull request?\n. ",
    "snake14": "I have noticed the same issue.  I have been unable to get the matches command to process even the simplest expression like \\d.  I tried escaping the slash, surrounding with escaped quotes, single quotes, and various other things, but had no success.\n. ",
    "RJacksonm1": "Looks like this was fixed by 755af07baba135f1ec2678ad646ecb1d93a1096d\n@asaskevich issue can be closed \ud83d\ude09. ",
    "binku87": "\nTake a look at #121\n\nI known this. But using this way you need to write required~Can't be blank multipart times, right?\nI need a way to custom on global. such as govalidator.CustomTypeTagMessageMap.Set(\"required\", \"Can't be blank\").\n. ",
    "tugbadm": "Did you add this on code? How should I validate the non-zero fields? The \"required\" tag still does not work. Or, this won't be implemented? @asaskevich . ",
    "Narven": "So whats the point of having func IsInt(str string) bool in the validator? Increase the code size? Go is a strongly typed language when ur validating ur code... To my knowledge govalidator is not to validate ur code, is to validate input data. So if im going to validate that everything is a string... theres no point of having a validator. If i need to validate that I'm inserting an INT into a database INT field... i need to make sure that it is an INT, not a string or an email.\n. ",
    "marcobeierer": "@asaskevich first of all, thank you for this nice library.\nJust a short notice: the use of int validation on type int64 did work in the past. I discovered the issue when a test failed just after updating govalidator today. However I'm not sure why the int64 was validated as int :-)\nWhen I scanned my code for other occurrences of int validation, I found one use case where I validate a string field as int. I could work around this and change the type to int instead of string, but having the int validation rule is handier as the the value comes in as string, is just validated and not further processed by the system and leaves the system as string.\n. Hi @elico \nI'm sorry, I missed your comment in January.\nIt's hard to remember what exactly the problem was at the time, but I can confirm that it has been fixed in the meantime.\nI made a local fork back then and added case reflect.Int: in the typeCheck function to fix the problem. The same change has been done in the master branch of the repo.\nhttps://github.com/asaskevich/govalidator/blob/master/validator.go#L1047 . @genofire \nI had a quick look at your implementation and see two problems:\n\nThis only works on string values and not on int/int64 values because of the check at https://github.com/asaskevich/govalidator/blob/master/validator.go#L828 . I think a clean solution would require some changes to the ParamValidator in general, because it only supports string values currently.\nIt does not allow negative ranges like for example range(-3|5). This could easily fixed in the regular expression.. @genofire @asaskevich I could fix point 2 and implement some tests in the next days. I will also have a look at my first point above, but am not sure anymore if the conclusion is correct. I implemented range as a custom validator and therefore some additional changes were necessary, but I have to recheck if this is also true for the native solution of @genofire.. \n",
    "elico": "@marcobeierer I have tried to understand the issue you are describing but was unable to understand it well.\nSo to make it clear to me: is the issue about the validator ie\nvalid:\"int,required\nAs of time ago some code was changed and I am not sure about code example that will demonstrate this issue.\n(it would be a bit easier for me to see a full piece of code that I can run to see this issue). @marcobeierer OK I hope it works for @jsuarezik . ",
    "jsuarezik": "I created a PR with a small solution :') . @marcobeierer would you check my PR ? I was having the same bug and to the date it is still not fixed. . ",
    "junhsiehevo": "Okay. Thanks.\n. ",
    "alessandropietrobelli": "Hi @asaskevich , what do you think if I write on README that this changes are related to new version called v5?\nSomething like this\nLet me know\n. I've also added this to descrive custom error messages\nCustom error messages\nPut ~ after validator to display your custom error message\nFrom v5 and above, you can use %s to return the value\n``` go\nimport \"github.com/asaskevich/govalidator\"\ntype Driver struct{\n    Name string valid:\"-\"\n    Car CustomCarType valid:\"customCarTypeValidator~Custom Error Message\"\n}\n// v5 and above\ntype Driver struct{\n    Name string valid:\"-\"\n    Car CustomCarType valid:\"customCarTypeValidator~Custom Error Message value %s not valid\" //Add %s if you want to return current value\n}\n```\n. Nice question, as it is structured now the code it will print the same error message\n. Hi Alex,\nI will check and let you know in the next days.\nThank you\nAle\nOn Sun, Sep 3, 2017 at 11:54 AM Alex Saskevich notifications@github.com\nwrote:\n\n@alessandropietrobelli https://github.com/alessandropietrobelli sorry\nfor no actions with this pull request for so long time. Could you resolve\nconflicts with current version of package and I will be able to merge it,\nplease?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/asaskevich/govalidator/pull/144#issuecomment-326795194,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACxS2aW-qj0aNaiUe0ux92rtaWNL6PXxks5sendygaJpZM4JQnE9\n.\n. Hi Alex,\nfaster than I thought.\n\nIt should work, check it. ",
    "hotrush": "i think it is clear enough. if you validate a couple of fields - you need to receive a couple of errors, not a one cocatenated string\n. ",
    "codepushr": "+1 ... I even tried using a pointer so that the zero value is nil but still no success. I basically want both true/false to be \"right\" choices when required is used. I sort of understand the thinking behind this but at least support the right behaviour when a *bool is used!\nEDIT:\nI'm implementing a HTTP PATCH. There I need my bool to be a pointer - any chances \"required\" will support this?\n. ",
    "wangdrew": "I'm also having the same issue here, would love to know the reasoning!\n. ",
    "richardlt": "Hi, I faced the same issue with custom validators. In fact I just looked at the code in validator.go and I'm not sure to understand why the isEmptyValue check is done after custom validators execution. \nline 727 on master\ngolang\n    if isEmptyValue(v) {\n        // an empty value is not validated, check only required\n        return checkRequired(v, t, options)\n    }\nBecause in isEmptyValue there is a return at the end that is doing a reflect equal test, I think this should work for all custom types if those lines are moved just after options parsing on line 705.\nThanks for your help.. #185 This is the PR associated to my message. Found another problem with this feature.\nI'm using *string as a field i want to validate like that valid:\"url,length(0|100),optional\", because it's a pointer the method will recursively call typeCheck at the end of the switch/case. \nIn the inner call of typeCheck for string value if my field is an empty string the isEmptyCheck will return with true value because it's an optional field. But because options list entries were not deleted the defer from the first typeCheck call will return an error.. I fixed it in #185 need someone to approve changes. Thanks . Can you merge it ?. Hi, look better with json tag name but this code should take care of extra data in tag for example json:\"myFields,omitempty\"in this case the all tag (myFields,omitempty) is returned instead of just the field name (myFields) :/. ",
    "andrewwatkin": "Use case: A custom validator on a struct to check for certain combinations of fields. But any one field can be empty.\nThe isEmptyValue() short circuit in typeCheck() breaks this.\nI don't see why empty fields should be bypassed by custom checks.. ",
    "huygn": "Thanks!\n. ",
    "arxdsilva": "Also passing (but should not): \n&url.URL{\n    Scheme: \"https\",\n    Host:   \"\",\n    Path:   \"notvalid/path\",\n}\n&url.URL{\n    Scheme: \"https\",\n    Host:   \"notvalid\",\n    Path:   \"\",\n},\n. ",
    "zupzup": "https://notvalid/path and https://notvalid are the stringified versions of the above example, which are both valid URLs (e.g.: http://localhost and http://localhost/some/path). ",
    "nejcpenko": "Hi @daseinhorn,\nHave you tried adding valid:\"required\" to the Struct field? \ngo\ntype MainStruct struct {\n    Content []ChildStruct `json:\"content\" valid:\"required\"`\n}\n. ",
    "kohkimakimoto": "I need it. Can you please merge it?. The validators don't be processed if the validated value is empty. \nsee https://github.com/asaskevich/govalidator/blob/master/validator.go#L754\nBut InTestCustomValidator, the tested structs don't have a value. I think that these test code are incorrect. I'll fix the test code by another PR.\n. Please review it.. @KonishchevDmitry I don't know that the reason to check empty values before custom validators are processed. But this behavior was committed intentionally by https://github.com/asaskevich/govalidator/pull/158/commits/e31e072e4202b573c60052012a798ccc332daccc. So I thought that I should follows this behavior and I fixed test code.\nI think that your question is good. Please discuss it with @asaskevich \n. #158 is same issue. I closed my PR.. ",
    "KonishchevDmitry": "\nBut in TestCustomValidator, the tested structs don't have a value. I think that these test code are incorrect. I'll fix the test code by another PR.\n\n@kohkimakimoto, @asaskevich, but why? I can understand that all predefined validators have the \"default behaviour\" that they validate only non-zero values, but why we should apply this behaviour to custom validators? In my world \"custom\" means, that you can write something beyond the defaults. There are a lot of cases, when this decision to not check zero values is not suitable for us. The Go's world, I think, is the only place where missing value is equal to empty value, and if we don't give to custom validators an ability to override this default, we won't be able to properly validate JSON requests which are designed with traditional notion that empty value is not equal to missing value.\nSo I intentionally placed custom validators check before\ngo\nif isEmptyValue(v) {\n        // an empty value is not validated, check only required\n        return checkRequired(v, t, options)\n}\nand wrote these tests intentionally with empty structs to check that custom validators are always processed, even when the data is empty, because the only one who knows how to handle empty values - is the custom validator's logic.. ",
    "colindickson": "i think what avelino means is that if \"valid\" is not the first struct tag, then govalidator doesn't work properly.  example:\n``\ntype Foo struct {\n    Email stringjson: \"email\" valid:\"email\"`\n}\nfunc main() {\n    fmt.Println(govalidator.ValidateStruct(&Foo{\"not_an_email\"}))\n}\n```\nthis outputs:\ntrue \nwhich is incorrect\nbut if you fix the ordering of the struct tags to make \"valid\" first:\n``\ntype Foo struct {\n    Email stringvalid:\"email\" json: \"email\"`\n}\nfunc main() {\n    fmt.Println(govalidator.ValidateStruct(&Foo{\"not_an_email\"}))\n}\n```\nthen this will give the expected result: \nfalse Email: not_an_email does not validate as email;. ",
    "emirhanmarlali": "@colindickson i think the problem is the space between json: and \"email\"\nin this example json tag also won't work\n``golang\ntype Foo struct {\n    Email stringjson: \"email\" valid:\"email\"`\n}\nfunc main() {\n    foo := &Foo{\"not_an_email\"}\n    fmt.Println(govalidator.ValidateStruct(foo)) // prints => true \nbody, _ := json.Marshal(foo)\nfmt.Println(string(body)) // prints => {\"Email\":\"not_an_email\"}\n\n}\n```\nJson marshaller uses exposed attribute name Email \nThe syntax is incorrect so remaining  tags won't be processed.\nBut in this example; \n``golang\ntype Foo struct {\n    Email stringvalid:\"email\" json: \"email\"`\n}\nfunc main() {\n    foo := &Foo{\"not_an_email\"}\n    fmt.Println(govalidator.ValidateStruct(foo)) // prints => false Email: not_an_email does not validate as email;\nbody, _ := json.Marshal(foo)\nfmt.Println(string(body)) // prints => {\"Email\":\"not_an_email\"}\n\n}\n``\nFirst tag is processed then syntax error appears. So validation tag works correctly but json marshaller uses exposed attribute nameEmail`.\nCorrect example 1:\n``golang\ntype Foo struct {\n    Email stringvalid:\"email\" json:\"email\"`\n}\nfunc main() {\n    foo := &Foo{\"not_an_email\"}\n    fmt.Println(govalidator.ValidateStruct(foo)) // prints => false email: not_an_email does not validate as email;\nbody, _ := json.Marshal(foo)\nfmt.Println(string(body)) // prints => {\"email\":\"not_an_email\"}\n\n}\nCorrect example 2:golang\ntype Foo struct {\n    Email string json:\"email\" valid:\"email\"\n}\nfunc main() {\n    foo := &Foo{\"not_an_email\"}\n    fmt.Println(govalidator.ValidateStruct(foo)) // prints => false email: not_an_email does not validate as email;\nbody, _ := json.Marshal(foo)\nfmt.Println(string(body)) // prints => {\"email\":\"not_an_email\"}\n\n}\n```. ",
    "avelino": "@asaskevich what does the solution commit? I'd like to understand the error. ",
    "favadi": "It is either I misunderstand the purpose of IsFilePath, or it is completely broken.\n. I don't understand the regex at: https://github.com/asaskevich/govalidator/blob/7b3beb6df3c42abd3509abfc3bcacc0fbfb7c877/patterns.go#L44, because AFAIK, almost everything except '/' is accepted for unix file name.\n. ",
    "Gnouc": "@favadi \n\nbecause AFAIK, almost everything except '/' is accepted for unix file name.\n\neverything except NUL byte and / is accepted as unix file name.\nFor this one, it's unix path, so everything except NUL byte is ok.\nThis current implementation is completely broken for unicode, which is norm these days.\n. ",
    "nikolay-turpitko": "Never answered, code reference is not accurate any more, not sure if it's still relevant.. ",
    "anthonyu": "@asaskevich please review/merge when you have a chance.. ",
    "rmohr": "@asaskevich Thank you for your response. Will try to rebase asap.. ",
    "jack-chung": "This fix has since disappeared from the code (overwritten by a later merge). Can you please put it back?. ",
    "denouche": "https://github.com/asaskevich/govalidator/pull/205. Thank you for your time !. I do this PR again, since it was apparently deleted by a merge ... :hankey: \nhttps://github.com/asaskevich/govalidator/issues/170#issuecomment-298899074. ",
    "yezooz": "That was a bit premature, need to add tests. \nCould you at least tell me if it's something you need, please?. Hi @bbrks \nIt's a great suggestion, I'll implement it this way.\nThanks. Sure, could do that. @asaskevich yep, will do. @asaskevich kept IsRFC3339 but it now relies on new IsTime function as @bbrks suggested. ",
    "bbrks": "Hi @yezooz,\nI have a suggestion for this validator. Rather than relying on regexp, you can use the time.Parse() function from stdlib to validate for RFC3339.\nLet me know what you think.\nHere's a benchmark and some example code I threw together.\nYou can see from the benchmarks it's roughly twice as fast:\n10:37 $ go test -v -bench .\n=== RUN   TestIsRFC3339\n=== RUN   TestIsRFC3339New\n--- PASS: TestIsRFC3339 (0.00s)\n--- PASS: TestIsRFC3339New (0.00s)\nBenchmarkIsRFC3339-8          200000          6078 ns/op\nBenchmarkIsRFC3339New-8       500000          3281 ns/op\nPASS\nok      github.com/bbrks/tmp    2.958s\nmain.go\n```go\npackage main\nimport (\n    \"regexp\"\n    \"time\"\n)\nvar rxRFC3339 = regexp.MustCompile(^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$)\nfunc IsRFC3339(str string) bool {\n    return rxRFC3339.MatchString(str)\n}\nfunc IsRFC3339New(str string) bool {\n    _, err := time.Parse(time.RFC3339, str)\n    return err == nil\n}\n```\nmain_test.go\n```go\npackage main\nimport \"testing\"\nvar tests = []struct {\n    param    string\n    expected bool\n}{\n    {\"2016-12-31 11:00\", false},\n    {\"2016-12-31 11:00:00\", false},\n    {\"2016-12-31T11:00\", false},\n    {\"2016-12-31T11:00:00\", false},\n    {\"2016-12-31T11:00:00Z\", true},\n    {\"2016-12-31T11:00:00+01:00\", true},\n    {\"2016-12-31T11:00:00-01:00\", true},\n    {\"2016-12-31T11:00:00.05Z\", true},\n    {\"2016-12-31T11:00:00.05-01:00\", true},\n    {\"2016-12-31T11:00:00.05+01:00\", true},\n}\nfunc TestIsRFC3339(t *testing.T) {\n    t.Parallel()\n    for _, test := range tests {\n        actual := IsRFC3339(test.param)\n        if actual != test.expected {\n            t.Errorf(\"Expected IsRFC3339(%q) to be %v, got %v\", test.param, test.expected, actual)\n        }\n    }\n}\nfunc TestIsRFC3339New(t *testing.T) {\n    t.Parallel()\n    for _, test := range tests {\n        actual := IsRFC3339New(test.param)\n        if actual != test.expected {\n            t.Errorf(\"Expected IsRFC3339(%q) to be %v, got %v\", test.param, test.expected, actual)\n        }\n    }\n}\nfunc BenchmarkIsRFC3339(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        for _, test := range tests {\n            IsRFC3339(test.param)\n        }\n    }\n}\nfunc BenchmarkIsRFC3339New(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        for _, test := range tests {\n            IsRFC3339New(test.param)\n        }\n    }\n}\n``. @asaskevich I adviseIsTime(str, format string)` which would accept constants from Go's time package or custom formats.\nThen IsRFC3339() can be changed to:\nreturn IsTime(str, time.RFC3339). ",
    "jasonlam604": "Is the build breaking on these (master seems to have broken tests):\n--- FAIL: TestStringMatchesComplexStruct (0.00s)\n    validator_test.go:2194: Expected ValidateStruct({\"$()\"}) to be false, got true\n    validator_test.go:2194: Expected ValidateStruct({\"$(\\\"\\\")\"}) to be false, got true\n    validator_test.go:2194: Expected ValidateStruct({\"AZERTY\"}) to be false, got true\n    validator_test.go:2194: Expected ValidateStruct({\"$AZERTY\"}) to be false, got true\n--- FAIL: TestOptionalCustomValidators (0.00s)\n    validator_test.go:2549: Expected nil err with optional validation, got boom;;WithoutCustomError:  does not validate as f2;;OptionalFirst:  does not validate as f2;;\n    validator_test.go:2553: Expected validation to return true, got false\nFAIL\nexit status 1. +1. You can probably use Matches with one of the 2 expressions:\n\n^[\\w\\s]+$\n^[a-zA-Z0-9\\s]+$\n. Submitted pull request #240 . After taking a quick look, the issue I believe is in validator.go see method parseTagIntoMap, after\n\noptions := strings.SplitN(tag, \",\", -1)\nin the for loop, apply Trim to each index value\n. I think this is expected behavior, unless I'm not understanding the documentation correctly.  See the main README.  Search for Activate behavior to require all fields have a validation tag by default. It explains what you are seeing and yes \"-\" would mark a specific field except from the check.. Submitted pull request #239 . Wondering if IsBlank should be implemented?  Where IsNull would produce false on \\n \\t and IsBlank would product true, IsBlank would include the use of strings.TrimSpace(). I'm seeing this instead\nfalse fk_seller_id: non zero value required;role: non zero value required\nSame input:\nt:= &CreateRole{Role : CreateRoleInfo {Name: \"selleruserrole4\",Type: \"active\",Status: \"selleruser\"}}\n. I am not sure what you are asking, IsAlpha will determine if the text contains only text.\n```\npackage main\nimport (\n    \"fmt\"\n    \"github.com/asaskevich/govalidator\"\n)\nfunc main() {\n    fmt.Println(\"Is Alpha? \", govalidator.IsAlpha(\"your-string-var-here\"))\n}\n```\nIf you are looking to validate a specific custom format, use Matches then, does that help?\n. Yes, that is expected behavior empty string is considered 0  . Fixed, pull request #268 includes unit tests. ",
    "suciuvlad": "@wilsontamarozzi you could also use type assertion\nresult, err := govalidator.ValidateStruct(userParams)\nif err != nil {\n  errs := err.(govalidator.Errors).Errors()\n  for _, e := range multiple {\n    fmt.Println(e.Error())\n  }\n}. ",
    "jackn3o": "@suciuvlad \nthx for your suggestion, but in the end only able to get result in []string\ncan the range get the e's name in order to get result of map[string]string. ",
    "morriswinkler-simple": "Cool @asaskevich, could you point me to the commit that introduced that.. Thanks. ",
    "Syam": "+1. +1. ",
    "9r1nc3w1ll": "+1. ",
    "umarniz": "Golang does not export variables that are not capital, this means this variable will not be viewable outside of the package.\nI am assuming this will cause the govalidator not be able to see it too as it works via reflection and the variables beginning with small letters aren't exported for reflection either.\n. Tagging @asaskevich for review and merge.\nBTW fantastic job on the library, respect for your effort! \nI noticed a few tests were failing though which I couldn't go in too much detail as I don't understand the exact logic behind them, just started using this library this morning :). ",
    "tokidoki11": "Thanks, didnt know that \ud83d\ude05. ",
    "genofire": "lol, i have not found time to write tests ...\n(not sure about the way on this repo ...). ",
    "leth": "Nice! Thanks :). ",
    "bboozzoo": "ping. thanks. Thanks.. ",
    "leerobertw": "+1\nI'm trying to validate a struct that contains a slice of URLs . Ultimately, I'm trying to validate the JSON used to populate the struct.. ",
    "simonwhitefrvr": "Was this ever resolved it does it require a fully custom validator?. ",
    "ghost": "+1\nIt also not works with domain r.fullstory.com. ",
    "rezam90": "I just found the validation in go here:\ngo-luhn\nseems to work properly.\n. ",
    "krhubert": "Done. ",
    "yuz989": "+1, would be great to support custom ParamValidator. ",
    "naoric": "I know this one is pretty old, and you guys probably know how to do this, but just in case someone else like me stumbles upon this issue - I found a way to do this:\n``\ntype User struct {\n  CompanyID stringvalid:\"exists(a|b)\"`\n}\nvar existingValidatorRegex = regexp.MustCompile(\"^exists\\((.+)\\|(.+)\\)$\")\nfunc InitValidators() {\n    ParamTagMap[\"exists\"] = ParamValidator(existingValidator)\n    ParamTagRegexMap[\"exists\"] = existingValidatorRegex\n}\nfunc existingValidator(val string, params ...string) bool {\n    fmt.Println(val, params)\n    return params[0] == \"a\" && params[1] == \"b\"\n}\n```\nI'm not sure if the official API supports this but it seems to be working. \nPlease let me know if I'm wrong. . ",
    "petherin": "@naoric This is how we've been forced to do it too. It seems to work, but it'd be nicer to have a neater way of doing this.. ",
    "okisetiawan0101": "You can create something like this. I've implemented it in my code and it works.\nHere is the simple example with 1 parameter (you can add more parameters as you want)\n```\n// Add your own struct validation tags with parameter\ngovalidator.ParamTagMap[\"animal\"] = govalidator.ParamValidator(func(str string, params ...string) bool {\n    species := params[0]\n    return str == species\n})\n//register the regex for validate\ngovalidator.ParamTagRegexMap[\"animal\"] = regexp.MustCompile(\"^animal\\((\\w+)\\)$\")\n```\nIf you validate this struct, the validator will return true\ntype Post struct {\n    Test string `valid:\"animal(dog)\"`\n}\nIf you validate this struct, the validator will return false\ntype Post struct {\n    Test string `valid:\"animal(cat)\"`\n}. ",
    "nsitbon": "go\ntype User struct {\n    Email string `valid:\"matches(^.+?@.+?\\\\..),required\"`\n    Password string `valid:\"-\"`\n}. ",
    "ruseinov": "I did the fix for nested struct, will take a look to introduce a pointer check too.. @ROYOSTI I'll take a look now, actually I think slices/maps should be ignored, because there's no validating them anyway.\n@asaskevich what do you have to say about that?. @ROYOSTI @arnavsharma93 I also think, since this is the case, it is just easier to supply valid:\"-\" for these fields. It is generally not a good practice to silently ignore things.\nIn that case we shouldn't make any changes, that's if I understood you correctly. Right now the behaviour is that an error is thrown when trying to validate a map/slice.\nIf you are referring to a slice of Structs - please let me know.. ah, ok. @ROYOSTI I'll take a look as soon as I can, pretty busy with work atm, this change would need a proper test. ",
    "ROYOSTI": "@ruseinov: Any idea when this will be fixed?. @ruseinov:\nIn my code I have something like this:\n```\npackage req\ntype UserSave struct {\n    User *model.User json:\"user\"\n}\n```\nAnd in my user model I have all the validation rules:\n```\npackage model\ntype User struct {\n    ID          bson.ObjectId bson:\"_id\" json:\"id\"\n    FirstName   string        bson:\"first_name\" json:\"first_name\" valid:\"required\"\n    LastName    string        bson:\"last_name\" json:\"last_name\": \"valid:\"required\"\n}\n```\nBut when model.User is a pointer the validation doesn't work. When I remove the pointer it works perfectly. ",
    "blind-oracle": "I've done the pull request, please somebody review it and merge.. Thanks!. Do I get it correctly that I can't do the simplest thing - validate an int* field in struct against a range - with govalidator? :). I've created a PR with a quick & dirty fix: https://github.com/asaskevich/govalidator/pull/263. I'd kinda wanted to make the LookupMX functionality optional.\nMaybe we should add another function that does the same but without lookup?\nBecause in worst case this call can take several seconds (in case of DNS or network fuckup) and in many cases it's not tolerable.. ",
    "nikgibbens": "I retract this bug. I see there is an isASCII function. I mistook isPrintableASCII to mean it will print, but I think it means \"visible printable characters.\". ",
    "brian-brazil": "Did #194 not cover this?. With the latest code, that's a false.. ",
    "gouthamve": "Hmm, interestingly:\ngovalidator.IsURL(\"aio1_alertmanager_container-63376c45:9093\") ---> false\nAnd I did do a go get -u\n@brian-brazil Can you try this?\n```\npackage main\nimport (\n    \"fmt\"\n\"github.com/asaskevich/govalidator\"\n\n)\nfunc main() {\n    fmt.Println(govalidator.IsURL(\"aio1_alertmanager-container-63376c45:9093\"))\n}\n```. ",
    "pgier": "It's false because of the call to url.Parse (https://github.com/asaskevich/govalidator/blob/master/validator.go#L57).  This will return an error for something like \"my_server.example.com:80\", but will accept both \"http://my_server.example.com:80\" and \"myserver.example.com:80\".  The first colon in the string is interpreted as the scheme delimiter, unless it contains an invalid character such as an underscore, in which case it tries to interpret the string as a relative path which cannot contain a colon.\nSo you hit a combination of including a colon and underscore, without including the \"//\" to indicate a hostname.\nSome examples: https://play.golang.org/p/VLHe7vPO1I\nIn go 1.7 and earlier this didn't cause an error, but it changed to be more strict in 1.8 (https://github.com/golang/go/commit/c5ccbdd22bdbdc43d541b7e7d4ed66ceb559030e). ",
    "homina": "oh nevermind, i resolved the issue, thank you anyway. ",
    "johnnywidth": "My bad, maybe i used to bad uuid generator.. ",
    "RajatVaryani": "Please close the issue. It's fixed. @asaskevich . ",
    "sabloger": "I need it to validate request inputs!. ",
    "iyedbennour": "Already fixed.. ",
    "vanng822": "Solution is using \nCustomTypeTagMap. ",
    "iiinsomnia": "trim space  \\n  \\t eg.. ",
    "stapelberg": "Specifically, this is upstream commit https://github.com/golang/go/commit/ba1018b4549f3edc257221cc8e49221255e03290#diff-9667474d33400190658e4758cf28dbf5. And this issue was discussed upstream at https://github.com/golang/go/issues/23657. ",
    "jmunson": "A bool is either true or false, so I'm not sure \"required\" is really something you want to check for since it does not really make sense in that context.\nYou might want a pointer to a bool, which could then be nil, true, or false.  Or something like a sql.NullBool which behaves similarly. . If you're storing it in a bool, then it will be zero.  Let me demonstrate the issue I'm talking about with a table comparing how this would be stored in a bool, or in a pointer to a bool.\n|user action|bool value|*bool value|\n|-------------|-----------|-------------|\n|submits true value|1|1\n|submits false value|0|0|\n|submits no value|0|nil|\nAs long as you're trying to represent this in a bool, its impossible to tell the difference between someone submitting false, and someone not submitting anything.\nWith your variable being a pointer to a bool, it defaults to nil, which means its not pointing to a valid bool.  Then you can validate that such that the pointer must point to a valid bool and you'll know it exists.\nThis is similar to how sql.NullBool works.  Databases have this same issue where they need to differentiate between true, false, and not existing.\nA sql.NullBool is a small struct containing a bool, and then a \"Valid\" bool to keep track of whether this NullBool.Bool has been set. With a NullBool, someone not supplying input would produce a sql.NullBool{Bool: 0, Valid:0}  where someone supplying a false valid would produce sql.Nullbool{Bool 0, Valid: 1}. ",
    "shivkumarsingh7": "Yes, @jmunson , But when we are taking input from users, validation should be there. What if user not passing any value to bool parameter.. ",
    "AlexAslan": "Hello @jmunson. We have a similar case with a struct that contains a *bool where we try to json decode the body of an http request, but it seems that the ValidateStruct does not the data provided for that field properly. If we mark the attribute as required, then \nSample code we used:\ndecoder := json.NewDecoder(request.Body)\n    if err = decoder.Decode(&mySctruct); err != nil {\n        fmt.Println(err)\n    }\n       fmt.Println(\"MY_CUSTOM_BOOL: \", myStruct.myBool) // this prints <nil> as it should if in json \"my_bool\": null. But it fails the validation if \"my_bool\" is true || false\n    if ok, err := govalidator.ValidateStruct(myStruct); err != nil {\n        validationError := map[string]interface{}{\"validationError\": err}\n        json.NewEncoder(writer).Encode(validationError)\n        return\n    } else {\n        fmt.Printf(\"OK: %v\\n\", ok)\n    }\nDo you have any suggestions? Are we doing something wrong here?. ",
    "dulumao": "```golang\ngovalidator.TagMap[\"boolean\"] = govalidator.Validator(func(str string) bool {\n        boolMap := map[string]bool{\n            // true\n            \"1\":    true,\n            \"true\": true,\n            \"on\":   true,\n            \"yes\":  true,\n            // false\n            \"\":      false,\n            \"0\":     false,\n            \"false\": false,\n            \"off\":   false,\n            \"no\":    false,\n        }\n    if state, ok := boolMap[strings.ToLower(str)]; ok {\n        return state\n    }\n\n    return false\n})\n\n```. ",
    "zhaoyeuchao": "Thank you for your help\uff01\nIt seems that this is a feature of the Golang.\nSo\uff0cI understood. Now, I don\u2019t want to get true with IsInt(a) when the a is empty, I can decide the \u201ca\u201d is not empty string first.\nThank you very much.\nI  close this issue.. ",
    "pmilanez": "Failed for me too. I've checked and this UUID is a valid one: Valid, The UUID is db87461e-19b2-47ef-8531-98006921aaa1, It is UUID Version 4.. ",
    "tutabeier": "Is this still open or was fixed?\nI'm trying to validate a field using valid:\"matches(^\\d{5}$)\" and the tests are passing with the wrong format.\nUsing v9.. ",
    "jejefferson": "Validation error depends on capital/lower case field name of struct. In this example second validation fails:\npackage main\nimport (\n    \"fmt\"\n    \"github.com/asaskevich/govalidator\"\n)\ntype StructLower struct {\n    total float32 `valid:\"float,required\"`\n}\ntype StructCapital struct {\n    Total float32 `valid:\"float,required\"`\n}\nfunc main() {\n    testStruct := StructLower{total: 45.32}\n    _, err := govalidator.ValidateStruct(&testStruct)\n    if err != nil {\n        fmt.Println(err.Error())\n    }\n    testStruct2 := StructCapital{Total: 53.3535}\n    _, err = govalidator.ValidateStruct(&testStruct2)\n    if err != nil {\n        fmt.Println(err.Error())\n    }\n}. ",
    "joshlreese": "Would it be possible to get a v10 tag for this, considering it's been some time since a release?. ",
    "sagarrakshe": "@asaskevich this ticket can be closed.. ",
    "rockertux": "Yes. Last example in this section of the docs: https://github.com/asaskevich/govalidator#custom-validation-functions. ",
    "andrewmunro": "@alex.saskevich @asaskevich I have this issue too! Any chance we can get this merged?. ",
    "Robinnnnn": "I'm facing this issue as well. ",
    "SlightlyCyborg": "https://github.com/asaskevich/govalidator/blob/7d2e70ef918f16bd6455529af38304d6d025c952/validator.go#L708 \nthis seems to be the problem. However, my slice I think is a nil slice, not an empty slice, so I will explicitly use make to generate the slice so it validates properly.. Nope, making the slice an empty slice didn't work....so IDK.. It seems that the recursive call to Interface() ends up turning the empty slice into a nil slice.. ",
    "balaji39mit": "@SlightlyCyborg : Assume you are having some structs which has required fields, but the struct is nil. In this case, whether the ValidateStruct is returning true? It would be much helpful when you post the issue with an example. TIA.. ",
    "fossabot": "Your license scan is passing -- congrats!\nYour badge status is now updated and ready to merge:\n. ",
    "sharkboy1976": "error path was added in master 26 days ago. thx for letting me know :(. ",
    "jesse-c": "Do you mean a single dot? E.g. www.test.com.? If so, a dot at the end is valid because it's a FQDN.. As I've commented on #284, this might not be an issue (just adding here so it's not missed). I'm not 100% sure what is suppose to be covered by DNSName, but a dot at the end of domains is valid.. Intuitively I thought this might be to do with the > 255, and testing it out it looks like it might be.\ngore> govalidator.IsDNSName(\"1.1.1.255\")\n(bool)false\ngore> govalidator.IsDNSName(\"1.1.1.256\")\n(bool)true\nEdit: So the call to IsIP fails (as you'd hope with invalid IPs), then the DNS regex doesn't check if the last label is only digits or that all the labels are digits (effectively doubly-checking if it's an IP or not).. ",
    "marcsantiago": "Of course, sorry about that, I'll give it a look today.. Interesting, all my test pass locally and I've been using my fork in\nproduction since the PR\n=== RUN   TestEach\n=== PAUSE TestEach\n=== RUN   TestMap\n=== PAUSE TestMap\n=== RUN   TestFind\n=== PAUSE TestFind\n=== RUN   TestFilter\n=== PAUSE TestFilter\n=== RUN   TestCount\n=== PAUSE TestCount\n=== RUN   TestToInt\n--- PASS: TestToInt (0.00s)\n=== RUN   TestToBoolean\n--- PASS: TestToBoolean (0.00s)\n=== RUN   TestToString\n--- PASS: TestToString (0.00s)\n=== RUN   TestToFloat\n--- PASS: TestToFloat (0.00s)\n=== RUN   TestToJSON\n--- PASS: TestToJSON (0.00s)\n=== RUN   TestErrorsToString\n=== PAUSE TestErrorsToString\n=== RUN   TestAbs\n=== PAUSE TestAbs\n=== RUN   TestSign\n=== PAUSE TestSign\n=== RUN   TestIsNegative\n=== PAUSE TestIsNegative\n=== RUN   TestIsNonNegative\n=== PAUSE TestIsNonNegative\n=== RUN   TestIsPositive\n=== PAUSE TestIsPositive\n=== RUN   TestIsNonPositive\n=== PAUSE TestIsNonPositive\n=== RUN   TestIsWhole\n=== PAUSE TestIsWhole\n=== RUN   TestIsNatural\n=== PAUSE TestIsNatural\n=== RUN   TestInRangeInt\n=== PAUSE TestInRangeInt\n=== RUN   TestInRangeFloat32\n=== PAUSE TestInRangeFloat32\n=== RUN   TestInRangeFloat64\n=== PAUSE TestInRangeFloat64\n=== RUN   TestInRange\n=== PAUSE TestInRange\n=== RUN   TestContains\n=== PAUSE TestContains\n=== RUN   TestMatches\n=== PAUSE TestMatches\n=== RUN   TestLeftTrim\n=== PAUSE TestLeftTrim\n=== RUN   TestRightTrim\n=== PAUSE TestRightTrim\n=== RUN   TestTrim\n=== PAUSE TestTrim\n=== RUN   TestWhiteList\n=== PAUSE TestWhiteList\n=== RUN   TestBlackList\n=== PAUSE TestBlackList\n=== RUN   TestStripLow\n=== PAUSE TestStripLow\n=== RUN   TestReplacePattern\n=== PAUSE TestReplacePattern\n=== RUN   TestEscape\n=== PAUSE TestEscape\n=== RUN   TestUnderscoreToCamelCase\n=== PAUSE TestUnderscoreToCamelCase\n=== RUN   TestCamelCaseToUnderscore\n=== PAUSE TestCamelCaseToUnderscore\n=== RUN   TestReverse\n=== PAUSE TestReverse\n=== RUN   TestGetLines\n=== PAUSE TestGetLines\n=== RUN   TestGetLine\n=== PAUSE TestGetLine\n=== RUN   TestRemoveTags\n=== PAUSE TestRemoveTags\n=== RUN   TestSafeFileName\n=== PAUSE TestSafeFileName\n=== RUN   TestNormalizeEmail\n=== PAUSE TestNormalizeEmail\n=== RUN   TestTruncate\n=== PAUSE TestTruncate\n=== RUN   TestPadLeft\n=== PAUSE TestPadLeft\n=== RUN   TestPadRight\n=== PAUSE TestPadRight\n=== RUN   TestPadBoth\n=== PAUSE TestPadBoth\n=== RUN   TestIsAlpha\n=== PAUSE TestIsAlpha\n=== RUN   TestIsUTFLetter\n=== PAUSE TestIsUTFLetter\n=== RUN   TestIsAlphanumeric\n=== PAUSE TestIsAlphanumeric\n=== RUN   TestIsUTFLetterNumeric\n=== PAUSE TestIsUTFLetterNumeric\n=== RUN   TestIsNumeric\n=== PAUSE TestIsNumeric\n=== RUN   TestIsUTFNumeric\n=== PAUSE TestIsUTFNumeric\n=== RUN   TestIsUTFDigit\n=== PAUSE TestIsUTFDigit\n=== RUN   TestIsLowerCase\n=== PAUSE TestIsLowerCase\n=== RUN   TestIsUpperCase\n=== PAUSE TestIsUpperCase\n=== RUN   TestHasLowerCase\n=== PAUSE TestHasLowerCase\n=== RUN   TestHasUpperCase\n=== PAUSE TestHasUpperCase\n=== RUN   TestIsInt\n=== PAUSE TestIsInt\n=== RUN   TestIsHash\n=== PAUSE TestIsHash\n=== RUN   TestIsExistingEmail\n=== PAUSE TestIsExistingEmail\n=== RUN   TestIsEmail\n=== PAUSE TestIsEmail\n=== RUN   TestIsURL\n=== PAUSE TestIsURL\n=== RUN   TestIsRequestURL\n=== PAUSE TestIsRequestURL\n=== RUN   TestIsRequestURI\n=== PAUSE TestIsRequestURI\n=== RUN   TestIsFloat\n=== PAUSE TestIsFloat\n=== RUN   TestIsHexadecimal\n=== PAUSE TestIsHexadecimal\n=== RUN   TestIsHexcolor\n=== PAUSE TestIsHexcolor\n=== RUN   TestIsRGBcolor\n=== PAUSE TestIsRGBcolor\n=== RUN   TestIsNull\n=== PAUSE TestIsNull\n=== RUN   TestIsDivisibleBy\n=== PAUSE TestIsDivisibleBy\n=== RUN   TestIsByteLength\n=== PAUSE TestIsByteLength\n=== RUN   TestIsJSON\n=== PAUSE TestIsJSON\n=== RUN   TestIsMultibyte\n=== PAUSE TestIsMultibyte\n=== RUN   TestIsASCII\n=== PAUSE TestIsASCII\n=== RUN   TestIsPrintableASCII\n=== PAUSE TestIsPrintableASCII\n=== RUN   TestIsFullWidth\n=== PAUSE TestIsFullWidth\n=== RUN   TestIsHalfWidth\n=== PAUSE TestIsHalfWidth\n=== RUN   TestIsVariableWidth\n=== PAUSE TestIsVariableWidth\n=== RUN   TestIsUUID\n=== PAUSE TestIsUUID\n=== RUN   TestIsCreditCard\n=== PAUSE TestIsCreditCard\n=== RUN   TestIsISBN\n=== PAUSE TestIsISBN\n=== RUN   TestIsDataURI\n=== PAUSE TestIsDataURI\n=== RUN   TestIsBase64\n=== PAUSE TestIsBase64\n=== RUN   TestIsBase64String\n=== PAUSE TestIsBase64String\n=== RUN   TestIsBase64RawString\n=== PAUSE TestIsBase64RawString\n=== RUN   TestIsISO3166Alpha2\n=== PAUSE TestIsISO3166Alpha2\n=== RUN   TestIsISO3166Alpha3\n=== PAUSE TestIsISO3166Alpha3\n=== RUN   TestIsISO693Alpha2\n=== PAUSE TestIsISO693Alpha2\n=== RUN   TestIsISO693Alpha3b\n=== PAUSE TestIsISO693Alpha3b\n=== RUN   TestIsIP\n=== PAUSE TestIsIP\n=== RUN   TestIsPort\n=== PAUSE TestIsPort\n=== RUN   TestIsDNSName\n=== PAUSE TestIsDNSName\n=== RUN   TestIsHost\n=== PAUSE TestIsHost\n=== RUN   TestIsDialString\n=== PAUSE TestIsDialString\n=== RUN   TestIsMAC\n=== PAUSE TestIsMAC\n=== RUN   TestFilePath\n=== PAUSE TestFilePath\n=== RUN   TestIsLatitude\n=== PAUSE TestIsLatitude\n=== RUN   TestIsLongitude\n=== PAUSE TestIsLongitude\n=== RUN   TestIsSSN\n=== PAUSE TestIsSSN\n=== RUN   TestIsMongoID\n=== PAUSE TestIsMongoID\n=== RUN   TestIsSemver\n=== PAUSE TestIsSemver\n=== RUN   TestIsTime\n=== PAUSE TestIsTime\n=== RUN   TestIsRFC3339\n=== PAUSE TestIsRFC3339\n=== RUN   TestIsISO4217\n=== PAUSE TestIsISO4217\n=== RUN   TestByteLength\n=== PAUSE TestByteLength\n=== RUN   TestRuneLength\n=== PAUSE TestRuneLength\n=== RUN   TestStringLength\n=== PAUSE TestStringLength\n=== RUN   TestIsIn\n=== PAUSE TestIsIn\n=== RUN   TestValidateMissingValidationDeclarationStruct\n--- PASS: TestValidateMissingValidationDeclarationStruct (0.00s)\n=== RUN   TestFieldRequiredByDefault\n--- PASS: TestFieldRequiredByDefault (0.00s)\n=== RUN   TestMultipleFieldsRequiredByDefault\n--- PASS: TestMultipleFieldsRequiredByDefault (0.00s)\n=== RUN   TestFieldsRequiredByDefaultButExemptStruct\n--- PASS: TestFieldsRequiredByDefaultButExemptStruct (0.00s)\n=== RUN   TestFieldsRequiredByDefaultButExemptOrOptionalStruct\n--- PASS: TestFieldsRequiredByDefaultButExemptOrOptionalStruct (0.00s)\n=== RUN   TestInvalidValidator\n--- PASS: TestInvalidValidator (0.00s)\n=== RUN   TestCustomValidator\n--- PASS: TestCustomValidator (0.00s)\n=== RUN   TestStructWithCustomByteArray\n=== PAUSE TestStructWithCustomByteArray\n=== RUN   TestValidateNegationStruct\n--- PASS: TestValidateNegationStruct (0.00s)\n=== RUN   TestLengthStruct\n--- PASS: TestLengthStruct (0.00s)\n=== RUN   TestStringLengthStruct\n--- PASS: TestStringLengthStruct (0.00s)\n=== RUN   TestStringMatchesStruct\n--- PASS: TestStringMatchesStruct (0.00s)\n=== RUN   TestIsInStruct\n--- PASS: TestIsInStruct (0.00s)\n=== RUN   TestRequiredIsInStruct\n--- PASS: TestRequiredIsInStruct (0.00s)\n=== RUN   TestEmptyRequiredIsInStruct\n--- PASS: TestEmptyRequiredIsInStruct (0.00s)\n=== RUN   TestFunkyIsInStruct\n--- PASS: TestFunkyIsInStruct (0.00s)\n=== RUN   TestValidateStruct\n--- PASS: TestValidateStruct (0.00s)\n=== RUN   TestRequired\n--- PASS: TestRequired (0.00s)\n=== RUN   TestErrorByField\n=== PAUSE TestErrorByField\n=== RUN   TestErrorsByField\n=== PAUSE TestErrorsByField\n=== RUN   TestValidateStructPointers\n--- PASS: TestValidateStructPointers (0.00s)\n=== RUN   TestValidateStructParamValidatorInt\n--- PASS: TestValidateStructParamValidatorInt (0.00s)\n=== RUN   TestIsCIDR\n=== PAUSE TestIsCIDR\n=== RUN   TestOptionalCustomValidators\n--- PASS: TestOptionalCustomValidators (0.00s)\n=== RUN   TestJSONValidator\n--- PASS: TestJSONValidator (0.00s)\n=== RUN   TestValidatorIncludedInError\n--- PASS: TestValidatorIncludedInError (0.00s)\n=== RUN   TestIsRsaPublicKey\n--- PASS: TestIsRsaPublicKey (0.00s)\n=== RUN   TestInIntArr\n=== PAUSE TestInIntArr\n=== CONT  TestEach\n=== CONT  TestIsExistingEmail\n--- PASS: TestEach (0.00s)\n=== CONT  TestReplacePattern\n=== CONT  TestReverse\n--- PASS: TestReverse (0.00s)\n=== CONT  TestIsEmail\n=== CONT  TestIsDNSName\n=== CONT  TestIsVariableWidth\n=== CONT  TestIsISO3166Alpha3\n--- PASS: TestIsEmail (0.00s)\n=== CONT  TestIsBase64String\n--- PASS: TestIsBase64String (0.00s)\n=== CONT  TestIsDataURI\n--- PASS: TestIsISO3166Alpha3 (0.00s)\n=== CONT  TestIsISO3166Alpha2\n--- PASS: TestReplacePattern (0.00s)\n=== CONT  TestIsBase64\n=== CONT  TestIsUUID\n=== CONT  TestIsISBN\n--- PASS: TestIsVariableWidth (0.00s)\n--- PASS: TestIsISO3166Alpha2 (0.00s)\n=== CONT  TestIsCreditCard\n--- PASS: TestIsUUID (0.00s)\n=== CONT  TestIsBase64RawString\n--- PASS: TestIsDNSName (0.00s)\n=== CONT  TestIsFullWidth\n=== CONT  TestIsPrintableASCII\n--- PASS: TestIsFullWidth (0.00s)\n--- PASS: TestIsBase64RawString (0.00s)\n=== CONT  TestIsHexcolor\n=== CONT  TestIsASCII\n--- PASS: TestIsPrintableASCII (0.00s)\n=== CONT  TestIsJSON\n--- PASS: TestIsASCII (0.00s)\n=== CONT  TestIsMultibyte\n--- PASS: TestIsHexcolor (0.00s)\n=== CONT  TestIsByteLength\n--- PASS: TestIsJSON (0.00s)\n=== CONT  TestIsDivisibleBy\n=== CONT  TestIsRGBcolor\n--- PASS: TestIsMultibyte (0.00s)\n--- PASS: TestIsByteLength (0.00s)\n=== CONT  TestIsHalfWidth\n=== CONT  TestStructWithCustomByteArray\n=== CONT  TestInIntArr\n--- PASS: TestIsDataURI (0.00s)\n--- PASS: TestIsHalfWidth (0.00s)\n=== CONT  TestIsCIDR\n--- PASS: TestIsRGBcolor (0.00s)\n=== CONT  TestErrorsByField\n--- PASS: TestIsCIDR (0.00s)\n=== CONT  TestErrorByField\n--- PASS: TestIsISBN (0.00s)\n--- PASS: TestErrorByField (0.00s)\n=== CONT  TestByteLength\n--- PASS: TestInIntArr (0.00s)\n=== CONT  TestStringLength\n--- PASS: TestIsBase64 (0.00s)\n=== CONT  TestIsIn\n=== CONT  TestRuneLength\n--- PASS: TestIsIn (0.00s)\n=== CONT  TestIsTime\n--- PASS: TestByteLength (0.00s)\n=== CONT  TestIsISO4217\n=== CONT  TestIsRFC3339\n=== CONT  TestIsMAC\n--- PASS: TestStringLength (0.00s)\n--- PASS: TestRuneLength (0.00s)\n--- PASS: TestIsISO4217 (0.00s)\n=== CONT  TestIsMongoID\n--- PASS: TestIsMAC (0.00s)\n--- PASS: TestIsMongoID (0.00s)\n--- PASS: TestIsCreditCard (0.01s)\n=== CONT  TestIsSSN\n--- PASS: TestIsRFC3339 (0.00s)\n=== CONT  TestIsLongitude\n--- PASS: TestIsTime (0.00s)\n--- PASS: TestStructWithCustomByteArray (0.00s)\n=== CONT  TestFilePath\n--- PASS: TestErrorsByField (0.00s)\n=== CONT  TestIsFloat\n=== CONT  TestIsNull\n=== CONT  TestIsLatitude\n=== CONT  TestIsHexadecimal\n--- PASS: TestIsDivisibleBy (0.00s)\n--- PASS: TestIsFloat (0.00s)\n=== CONT  TestIsAlphanumeric\n=== CONT  TestIsInt\n--- PASS: TestIsLongitude (0.00s)\n=== CONT  TestIsHash\n--- PASS: TestIsNull (0.00s)\n=== CONT  TestHasLowerCase\n--- PASS: TestIsInt (0.00s)\n=== CONT  TestIsUpperCase\n--- PASS: TestIsHexadecimal (0.00s)\n=== CONT  TestHasUpperCase\n--- PASS: TestIsUpperCase (0.00s)\n=== CONT  TestIsUTFNumeric\n=== CONT  TestIsLowerCase\n--- PASS: TestHasLowerCase (0.00s)\n--- PASS: TestIsLowerCase (0.00s)\n--- PASS: TestIsLatitude (0.00s)\n=== CONT  TestIsUTFDigit\n--- PASS: TestIsSSN (0.00s)\n--- PASS: TestIsAlphanumeric (0.00s)\n--- PASS: TestIsUTFNumeric (0.00s)\n=== CONT  TestIsNumeric\n=== CONT  TestIsUTFLetterNumeric\n=== CONT  TestIsUTFLetter\n=== CONT  TestIsHost\n=== CONT  TestIsDialString\n--- PASS: TestIsUTFLetterNumeric (0.00s)\n--- PASS: TestIsUTFDigit (0.00s)\n=== CONT  TestIsPort\n=== CONT  TestRemoveTags\n--- PASS: TestIsNumeric (0.00s)\n--- PASS: TestIsPort (0.00s)\n=== CONT  TestPadRight\n=== CONT  TestIsAlpha\n=== CONT  TestPadBoth\n--- PASS: TestPadRight (0.00s)\n--- PASS: TestIsUTFLetter (0.00s)\n--- PASS: TestHasUpperCase (0.00s)\n--- PASS: TestIsDialString (0.00s)\n--- PASS: TestPadBoth (0.00s)\n=== CONT  TestPadLeft\n--- PASS: TestIsAlpha (0.00s)\n=== CONT  TestSafeFileName\n=== CONT  TestIsURL\n--- PASS: TestPadLeft (0.00s)\n=== CONT  TestTruncate\n--- PASS: TestRemoveTags (0.00s)\n=== CONT  TestIsRequestURL\n=== CONT  TestIsWhole\n--- PASS: TestIsRequestURL (0.00s)\n=== CONT  TestLeftTrim\n--- PASS: TestIsWhole (0.00s)\n=== CONT  TestInRange\n--- PASS: TestLeftTrim (0.00s)\n=== CONT  TestIsSemver\n--- PASS: TestInRange (0.00s)\n--- PASS: TestTruncate (0.00s)\n=== CONT  TestContains\n=== CONT  TestInRangeFloat64\n--- PASS: TestIsSemver (0.00s)\n=== CONT  TestTrim\n--- PASS: TestInRangeFloat64 (0.00s)\n--- PASS: TestContains (0.00s)\n=== CONT  TestBlackList\n=== CONT  TestStripLow\n--- PASS: TestSafeFileName (0.00s)\n--- PASS: TestIsHost (0.00s)\n=== CONT  TestInRangeInt\n--- PASS: TestTrim (0.00s)\n=== CONT  TestIsNatural\n=== CONT  TestGetLines\n--- PASS: TestIsNatural (0.00s)\n=== CONT  TestNormalizeEmail\n=== CONT  TestGetLine\n--- PASS: TestBlackList (0.00s)\n=== CONT  TestWhiteList\n--- PASS: TestIsHash (0.01s)\n=== CONT  TestIsRequestURI\n--- PASS: TestGetLines (0.00s)\n--- PASS: TestGetLine (0.00s)\n--- PASS: TestIsRequestURI (0.00s)\n=== CONT  TestRightTrim\n--- PASS: TestInRangeInt (0.00s)\n=== CONT  TestIsNonNegative\n=== CONT  TestIsPositive\n--- PASS: TestIsNonNegative (0.00s)\n--- PASS: TestStripLow (0.00s)\n=== CONT  TestIsNonPositive\n--- PASS: TestIsPositive (0.00s)\n=== CONT  TestInRangeFloat32\n=== CONT  TestIsISO693Alpha3b\n--- PASS: TestWhiteList (0.00s)\n=== CONT  TestSign\n--- PASS: TestIsNonPositive (0.00s)\n--- PASS: TestSign (0.00s)\n=== CONT  TestIsNegative\n--- PASS: TestInRangeFloat32 (0.00s)\n=== CONT  TestIsIP\n=== CONT  TestCamelCaseToUnderscore\n--- PASS: TestIsNegative (0.00s)\n--- PASS: TestCamelCaseToUnderscore (0.00s)\n--- PASS: TestRightTrim (0.00s)\n=== CONT  TestFilter\n=== CONT  TestIsISO693Alpha2\n--- PASS: TestFilter (0.00s)\n=== CONT  TestUnderscoreToCamelCase\n--- PASS: TestIsISO693Alpha3b (0.00s)\n--- PASS: TestIsIP (0.00s)\n=== CONT  TestEscape\n=== CONT  TestFind\n--- PASS: TestUnderscoreToCamelCase (0.00s)\n=== CONT  TestCount\n--- PASS: TestFind (0.00s)\n--- PASS: TestEscape (0.00s)\n=== CONT  TestAbs\n--- PASS: TestIsISO693Alpha2 (0.00s)\n=== CONT  TestMap\n--- PASS: TestAbs (0.00s)\n=== CONT  TestMatches\n=== CONT  TestErrorsToString\n--- PASS: TestCount (0.00s)\n--- PASS: TestNormalizeEmail (0.00s)\n--- PASS: TestMap (0.00s)\n--- PASS: TestErrorsToString (0.00s)\n--- PASS: TestMatches (0.00s)\n--- PASS: TestIsURL (0.03s)\n--- PASS: TestFilePath (0.17s)\n--- PASS: TestIsExistingEmail (0.73s)\nPASS\nok  github.com/marcsantiago/govalidator (cached). go version go1.10.2 darwin/amd64. I think the fails are unrelated to the PR, if you diff the changes\ncustomErrorMessage\nwas never touched, in fact every change is additive with thier own tests...\nwith the exception of println to fmt.Println in the validator_test.go file. ",
    "GolubAlexander": "This regexp pattern also checks chinese hieroglyphs.\nhttps://en.wikipedia.org/wiki/Email_address#Internationalization_examples. ",
    "jamiekurtz": "+1. Thanks, that fixed it.. ",
    "antho1404": "Perfect, that was fast \ud83d\ude03 . ",
    "arsoba": "@gvem try to delete spaces between valid: and validation rules.\nvalid: \"alphanum~Field Title must be alphanumeric, required~Field Title is empty\" to\nvalid:\"alphanum~Field Title must be alphanumeric, required~Field Title is empty\". Hi @tutabeier \nYou have an error. There is not len validator. You can use length or runelength.\nOr even better to use ISO3166Alpha2 to validate country code.. ",
    "jackwilsdon": "Looks like the only supported schemas are ftp, tcp, udp, ws, wss, http and https.. After looking, is this repository even available on CircleCI? I notice there's also a .travis.yml too.... ",
    "stevenkitter": "i have the same demand.. ",
    "wadtech": "Personally I'd use a custom validation message that is some identifier for your i18n translations.\n```\ntype exampleStruct struct {\n  Name  string `\n  Email stringvalid:\"email~EMAIL_INVALID\"`  //    email is not correct || email \u683c\u5f0f\u9519\u8bef \n}\n```\nThen you can use EMAIL_INVALID to look up the correct multi language strings you need.\n. @clearcodecn I've put together a quick gist with what I mean.\nhttps://gist.github.com/wadtech/c8a62a42a0ff618aa95f4c0b854b52f6\nNo promises that it's good Go, but hopefully that helps understand my thinking.\nedit: I've guessed at the correct locale from what google translate tells me, so sorry if that's incorrect.. In my experience translated content is independent from the calling code, so having a module specifically designed to provide translations means you can inject the dependency and have one code path that does validation etc.\nPersonally I'd create a module to handle translations that can be set to a locale. Then I'd refactor your validations to use some constant that can be passed to your translation service.\nThat way each language will be separate in VCS without having to rewrite actual code or keep locale-specific copies of business logic.\nI don't think there's a lazy way unfortuntely!\nI updated my gist with an example of what that would look like at high level.. Ah I see!\nI think that it's one of those areas that is never very satisfying, no matter the model you choose for storing translations it always ends up being a bit of a mess.\nThe only thing I could suggest is to prefix your constants in the language file so LANG_EMAIL_INVALID or something then you can use your IDE to find instances of the constant not in the translation files.\nAs you say, even if you could do this with the struct tags they would end up being enormous and unweildy.\nMaybe a task in your build process or CI that looks for unused translations could be an option, that way team members can be responsible for ensuring that they don't leave behind unused strings - or fail to include ones they need!. ",
    "clearcodecn": "can you show me a deep demo ? I am a little rookie ... \nI know that I can use reflect package to find the struct comment that I need . \nI did not know how to use custom validation message to impl it. Yeah . The translation is correct . \ud83d\ude04 \nI understand . thank you . \nBecause of my lazy . I want to write like this : \ntype person struct {\n    Name  string `valid:\"-\"`\n    Email string `valid:\"email\"` //    en: email is not correct || zh_CN: email \u683c\u5f0f\u9519\u8bef\n}\nbut just It seems impossible.\nI have to defined too much code like : EMAIL_INVALID\nIn our project we defined Thousands of code , but when the struct changed , we have to change the code . And the file always like: zh_CN.go, en.go , always conflict in vcs .\nThe code is difficult to maintain \ud83d\ude22 . \nIf you have any idea like this using comment to write error msg with i18n translations , tell me please .\n. I just say by chinese and english translate by google translate .\nchinese\n\u6211\u975e\u5e38\u660e\u767d\u4f60\u7684\u505a\u6cd5\uff0c\u5e94\u8be5\u662f\u76ee\u524d\u4e3a\u6b62\u6700\u6b63\u786e\u7684\u505a\u6cd5\uff0c\u6211\u60f3\u8ba8\u8bba\u7684\u95ee\u9898\u662f\uff1a\n\u6211\u4eec\u73b0\u5728\u7684\u4ee3\u7801\u6839\u636e\u8bed\u8a00\u72ec\u7acb\u6210\u5355\u4e2a\u6587\u4ef6\uff0c\u4f8b\u5982\uff1a\n|- language\n|---- zh_CN.go\n|---- en.go \n|---- code.go \n\u6bcf\u4e2a\u6587\u4ef6\u91cc\u9762\u7684\u5199\u6cd5\u50cf\u4e0b\u9762\u8fd9\u6837\uff1a\n```\n// code.go\nconst (\n    EMAIL_INVALID = 100001   // some error code \n)\nfunc Translate(lang string, code int) string {\n      if lang == \"zh_CN\" {\n            return zhCN[code] \n      }\n}\n// zh_CN.go\nvar zhCN = map[int]string {\n     EMAIL_INVALID: \"email \u683c\u5f0f\u9519\u8bef\",\n}\n// en.go \nvar en = map[int]string {\n     EMAIL_INVALID: \"invalid email\",\n}\n```\n\u4f46\u662f\u5f53\u9519\u8bef\u7684\u53d8\u91cf\u53d8\u5f97\u5f02\u5e38\u591a\u7684\u65f6\u5019\uff0c\u7248\u672c\u66f4\u65b0\u8fed\u4ee3\u4e86\u5f88\u957f\u7684\u4e00\u6bb5\u5468\u671f\uff0c\n\u5bfc\u81f4\u7684\u60c5\u51b5\u662f\u8bf7\u6c42\u7684\u7ed3\u6784\u4f53\u968f\u7740\u7248\u672c\u53d1\u751f\u53d8\u5316\uff0c\u5f88\u591a\u8f83\u8001\u7684code\u7531\u4e8e\u662f\u5199\u5728tag\u91cc\u9762\uff0c\n\u5230\u4e86\u73b0\u5728\u5177\u4f53\u6709\u6ca1\u6709\u4f7f\u7528\u5b83\u6211\u4eec\u4e00\u6982\u4e0d\u77e5\uff0c\u5e76\u4e14\u6211\u4eec\u4e0d\u6562\u8f7b\u6613\u5220\u9664\u53d8\u91cf\u5373\u4f7f\u770b\u8d77\u6765\u6ca1\u6709\u88ab\u4f7f\u7528\n\u6bd5\u7adftag\u7684\u5f15\u7528code\u7801\u5f97\u4e0d\u5230IDE\u7684\u652f\u6301.\n\u56e0\u6b64\u6211\u60f3\u80fd\u5426\u4f7f\u7528\u6ce8\u91ca\u6765\u4f5c\u4e3a\u591a\u8bed\u8a00\u652f\u6301\uff0c\u53ef\u95ee\u9898\u662f\u5728\u8bed\u8a00\u5f88\u591a\u7684\u65f6\u5019 \u6ce8\u91ca\u5c06\u4f1a\u5199\u7684\u975e\u5e38\u7684\u957f\n\u4e5f\u4e0d\u592a\u597d\u7ef4\u62a4\u3002\n\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u73b0\u5728\u5b9e\u9645\u4e0a\u4f7f\u7528\u7684\u662f\u4f60\u63a8\u8350\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u6211\u611f\u89c9\u7ef4\u62a4\u633a\u56f0\u96be\u7684\u3002\nenglish by google translate\nI understand your approach very well. It should be the most correct practice so far. The questions I want to discuss are:\nOur current code is independent of the language into some single file, for example:\n|- language\n|---- zh_CN.go\n|---- en.go\n|---- code.go\nThe way each file is written like this:\n```\n// code.go\nConst (\n\u00a0\u00a0\u00a0\u00a0EMAIL_INVALID = 100001 // some error code\n)\nFunc Translate(lang string, code int) string {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0If lang == \"zh_CN\" {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Return zhCN[code]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n}\n// zh_CN.go\nVar zhCN = map[int]string {\n\u00a0\u00a0\u00a0\u00a0\u00a0EMAIL_INVALID: \"email \u683c\u5f0f\u9519\u8bef\",\n}\n// en.go\nVar en = map[int]string {\n\u00a0\u00a0\u00a0\u00a0\u00a0EMAIL_INVALID: \"invalid email\",\n}\n```\nBut when the wrong variable becomes abnormally much, the version update iterates over a long period of time.\nThe situation is that the structure of the request changes with the version, and many older codes are written in the tag.\nWe don\u2019t know if we have used it now, and we don\u2019t dare to delete the variables easily even if they don\u2019t seem to be used.\nAfter all, tag reference code is not supported by IDE.\nSo I want to be able to use comments as multi-language support, but the problem is that when the language is very large, the comments will be written very long.\nNot too good to maintain.\nIn other words, we are actually using the method you recommended, but I feel that maintenance is very difficult.. Thanks for your answer . CI sounds like a good idea . \ud83d\ude04 . ",
    "HaraldNordgren": "@asaskevich Ping. ",
    "bhenderson": "I love answering my own questions!\nvalid:\",optional\" works, although its a little weird because I don't want all the sub fields to be optional, but its a fix that works for me!. ",
    "Daanikus": "Hi there!\nDan from CodeLingo here. This PR is testing out a new service. I'd love to hear your feedback or answer your questions. We're keen to learn how we can best help dev teams without getting in your way.\nDan & the CodeLingo Team. ",
    "Adirio": "::FFFF:127.0.0.1 is a valid IPv6 address that contains .\nYou could swap it for return ip != nil && !strings.Contains(str, \":\").. If ports could be appended at the end, both method would need to be changed to strings.Count(str, \":\") < 2 and strings.Count(str, \":\") >= 2 respectively.. "
}