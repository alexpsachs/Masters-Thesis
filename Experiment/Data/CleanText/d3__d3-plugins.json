{
    "mbostock": "I'd love to see this implemented. The strategy I'd try first is to ignore links that generate cycles in the initial layout, and then add them back in again to draw the loops.\n. Right, computeNodeBreadths is where you'll get an infinite loop unless you detect cycles. So that's the first thing (where you ignore links that generate cycles). The second thing is we probably need to handle loopback links and render them differently. Loopback links still exit the right side, but then they need to loopback to the source and enter on the left side. Probably the sankey.link implementation needs to special-case loopback links and generate a different path for them.\n. @prakashsd You can do this by having multiple nodes that represent A & B at different times (A1, B1, A2, B2). Such a diagram is sometimes called an \u201calluvial diagram\u201d. If you have further questions, please ask on Stack Overflow or the D3.js Slack; these issues are for bug reports and active feature development.. Thanks for the fix!\n. Added you to the contributors team; you now have push privileges.\n. If Kai & Rich would like to host their graph-related code under a different license, they are welcome to add a separate license to their plugin directory or host it separately.\n. Yes, we should support inverse projections as much as possible. (Some will require numeric integration.)\nI was imaging that d3.geo.projection could take two projection functions, forward and inverse (duals of each other). If the inverse projection isn't specified then that projection won't have an inverse method exposed.\n. hammerInverse feels simpler to me.\n. If we can, I'd like to implement this on top of (a forthcoming but already started) d3.geo.rotate. All projections should be able to support an origin; if the origin is non-zero, input features are rotated using d3.geo.rotate before projecting. A user could also use d3.geo.rotate prior to invoking the projection, which would offer better performance if the projection will be used multiple times (for example, you could rescale without recomputing the rotation). The d3.geo.rotate API could also offer the third dimension for rotation in addition to translating the origin.\n. /cc @jasondavies \n. Related #9\n. FYI, partially supported via a new projection.rotate method. See discussion in #16 for details.\n. Yep, fixed! Also removed projection.rotate.\n. /cc @jasondavies \nI created a test for d3.geo.rotate here: http://bl.ocks.org/3734273.\nI'd love to see two changes:\n- The easy one: Takes as input GeoJSON rather than coordinates, and returns GeoJSON accordingly.\n- The hard one: Splits GeoJSON features when they cross the antemeridian; a MultiPolygon might grow more Polygons, a Polygon might become a MultiPolygon, a LineString might become a MultiLineString, etc. It might also be necessary to rejoin GeoJSON features that were split for the default antemeridian, such as Russia (although this sounds difficult). And I'm not sure about Antarctica. I think the logic might need to have checks such as if the polar distance between points is greater than some threshold, split the feature.\n. I guess I should generalize \"cross the antemeridian\" to \"cross the graticule border\" since we plan on supporting rotation in x and z, too.\n. Impressive demo and excellent progress!\n. It seems simpler to me just duplicate the internal constants.\n. Happy with this for now.\n. If there's a standard set of interruptions I could see providing a standard set of graticule outlines, too. I think using 1e-6 or 1e-9 as a relative offset should be fine; Number.MIN_VALUE only works reliably as an offset from zero.\n. That's pretty amazing.\n. Wow!\n\n. I think I've developed a pretty good pattern for reusable interrupted projections that could be incorporated into the extended projections plugin. Here are two examples:\n- Interrupted sinusoidal\n- Interrupted Goode homolosine\nThey use separate implementations for singly- and doubly-interrupted projections (the latter being when the northern hemisphere is divided differently from the southern hemisphere). However, since the implementations are so similar, it seems reasonable to me to just have a doubly-interrupted projection implementation, perhaps with a convenience option for setting both hemispheres to use the same interruptions.\nIt might be worth using a name other that \u201cgore\u201d to define the interruptions. That one\u2019s a bit hard to search on the internet. :frowning: \n. I think between d3.geo.polyhedron and d3.geo.interrupt we have this covered. Closing.\n. Can you save me some trouble and link to demos (e.g., using http://bl.ocks.org) of the new features?\n. /cc @jasondavies Let me know if this sounds good to you. How hard do you think splitting features in d3.geo.rotate will be? We could probably punt on that for the integration (but still hopefully get it working later), since we don't yet support it in core. Also I left out d3.geo.clip, but that could either be a separate plugin or get integrated into core in the future as well.\n. I've added a projection.rotate method. I originally called it projection.origin, but it's not actually backwards-compatible with the old method due to the interaction with parallels (for single- and double-paralleled projections such as Albers). To illustrate with an example, with the old Albers implementation, you might say:\njs\nvar projection = d3.geo.albers()\n    .origin([-98, 38])\n    .parallels([29.5, 45.5])\n    .scale(1000)\n    .translate([width / 2, height / 2]);\nIn the new version, if you rotate so that the origin is 98\u00baW, 38\u00baN, and you specify the same parallels of 29.5\u00baN, 45.5\u00baN, then these parallels will be parallel straight lines (as far as I can tell).\njs\nvar projection = d3.geo.albersEqualArea()\n    .rotate([98, -38])\n    .parallels([29.5, 45.5])\n    .scale(1000)\n    .translate([width / 2, height / 2]);\nExample: http://bl.ocks.org/3760031\nSo what you actually want to do is only rotate 98\u00baW, and then change the translate y-value so that the origin is once again in the center of the canvas:\n``` js\nvar origin = [-98, 38];\nvar projection = d3.geo.albersEqualArea()\n    .rotate([-origin[0], 0])\n    .parallels([29.5, 45.5])\n    .scale(1000)\n    .translate([0, 0]);\nprojection\n    .translate([width / 2, height / 2 - projection(origin)[1]]));\n```\nExample: http://bl.ocks.org/3734308\nThat's a bit more code (and not backwards-compatible), so I think it's worth further thought on rotate vs. origin and how to support either or both. Also, if the projection is rotated, it will also rotate the graticule, which makes it somewhat less useful unless you compensate for the rotation by correspondingly changing the graticule extent. And having to negate the origin to construct the rotation angle is slightly tedious.\nI think it's still a good idea to have a d3.geo.rotate function which operates on GeoJSON features. Though I was also thinking that we might be able to perform the clipping automatically in d3.geo.path by clipping features to the graticule extent (which could be reported by the projection when it needs to be smaller, and otherwise defaults to the default d3.geo.graticule extent?). However, now that I think about it, you'd need to first rotate, then clip, then project. Which suggests that the projection can't encapsulate the rotation, unless the projection also has a way of indicating when going from the previous point to the next point crosses the graticule boundary.\nHmm. More thought is required!\n. Nice work. Sorry I derped up the latitude rotation! I was wondering why it wasn't symmetric and then I remembered the poles. :)\nI thought maybe it might be worth optimizing the case where you only rotate one of {\u03c6,\u03b3}, but I think that's probably a rare enough case that we should only worry about optimizing the much simpler \u03bb rotation.\nAs for oblique, what about rotate([\u03bb, \u03c6, \u03b3])?\n. I had a couple more thoughts last night.\nFirst, when rendering features, the immediate need is to worry about cutting rather than clipping. By cutting I mean breaking a feature into two or more parts where it crosses the antemeridian; this is needed to avoid discontinuities, while clipping is needed to avoid showing back-facing features. For cutting I believe all we need to worry about are coordinates that span the antemeridian, which we can detect by sequential coordinates \u03bb\u2080, \u03bb\u2081 where |\u03bb\u2081 - \u03bb\u2080| > 180\u00ba (meaning the shorter path between the two coordinates crosses the antemeridian). Then we compute the intersection with the antemeridian, and use that to insert an additional vertex to split the feature into two parts, which are then rendered separately. So, a very simple form of clipping.\nSecond, I think those self-intersecting polygons are probably caused by Antarctica. There's an interesting condition when a geographic feature  covers a pole: you get artificial coordinates \u27e8180\u00baW, 90\u00baS\u27e9 and \u27e8180\u00baE, 90\u00baS\u27e9. If you didn't have these coordinates, then how would you know whether Antarctica is a land mass that covers the south pole, or a land mass with a hole at the south pole? Likewise, you need these coordinates to fill in the area south of Antarctica's boundary, as in the Miller projection. But then of course with other projections such as stereographic you end up with a visual artifact where these artificial coordinates are unnecessary and cause spurious lines to the pole. So really we need some way of indicating whether the projection ignores these coordinates.\n. Oh, and we still need to decouple rotation from projection for cutting. The first pass is to rotate the geometry, the cut along the antemeridian, then project coordinates. It might be possible to do this by temporarily clearing the projection's origin and oblique, but I suspect there's a better way to do it. Also we probably want a way to expose the underlying coordinate rotation methods.\nI've also been wondering if we should have a way to expose the raw projection methods, so that it's easier to derive new projections without setting scale(1) and translate([0, 0]).\n. Well, one thing I was considering for the raw projections was just a dict of them as d3.geo.projections, with the same interface as the current internal (immutable) constructors. For example, you might say d3.geo.projections.satellite(P, \u03c9) to get a raw satellite projection.\nIn this case it might be cleaner to hang the invert function off of the forward projection, rather than having separate satellite and satelliteInverse methods. (As you suggested previously.) The other nice thing about this is that you can share constants across the forward and inverse projection, such as:\n``` js\nfunction conicEquidistant(\u03c60, \u03c61) {\n  var cos\u03c60 = Math.cos(\u03c60),\n      n = (cos\u03c60 - Math.cos(\u03c61)) / (\u03c61 - \u03c60),\n      G = cos\u03c60 / n + \u03c60;\nfunction forward(\u03bb, \u03c6) {\n    var \u03c1 = G - \u03c6;\n    return [\n      \u03c1 * Math.sin(n * \u03bb),\n      G - \u03c1 * Math.cos(n * \u03bb)\n    ];\n  }\nforward.invert = function(x, y) {\n    var \u03c10_y = G - y;\n    return [\n      Math.atan2(x, \u03c10_y) / n,\n      G - sgn(n) * Math.sqrt(x * x + \u03c10_y * \u03c10_y)\n    ];\n  };\nreturn forward;\n}\n```\nSince we need to decouple rotation from projection for cutting, it almost feels to me like the rotation should be applied to the d3.geo.path object rather than the d3.geo.projection. Perhaps you could set an optional rotation on the d3.geo.path instance in addition to the projection. I know it's sometimes convenient for the projection to do the rotation internally, but it's not too burdensome if they are decoupled and it certainly makes it cleaner to do the cutting.\nOf course, if the rotation is decoupled from the projection, then the parallels will be relative to the rotated coordinates, which might be weird. And it's not obvious how we could make a backwards-compatible projection.origin.\n. I've added a d3.geo.rotation. But I am considering changing the raw projections (and raw inverse projections) to take a single coordinates argument rather than (\u03bb, \u03c6) or (x, y). This might cause more garbage collection overhead but I'm hoping it will make them easier to compose.\nWith that change, I would get rid of the forward / inverse projection composition in rotate and rotateInverse. Then we could expose rotateInverse as rotate.inverse, and lastly d3.geo.rotation would simply expose rotate.\n. Hmm. Rotating the cut line could work, assuming it's not much more complicated than rotating before cutting? I'll think some more.\nI'll defer on changing the raw projection signature from (\u03bb, \u03c6); I agree that's worked well so far. I'm working on coupling the forward and inverse raw projections now.\n. Also, automatic resampling would be nice. For example the bottom of Antarctica on Larriv\u00e9e and conic conformal. I think we already have the facility to do this in d3.geo.circle. It might be nice if we could detect when resampling is necessary in d3.geo.path, based on the projection.\n. Had a thought. What if projections had a projectLine(lineString) method, and similarly projectRing or projectPolygon for a closed sequence of coordinates, instead of just the current project(point)? This could allow the projection to decide the appropriate action to take, for example cutting or resampling. It could default to return lineString.map(project), which is equivalent to what we do right now. But it would also allow much greater flexibility. For example azimuthal projections could ignore points at \u27e8\u00b1180\u00ba,\u00b190\u00ba\u27e9.\n. Nice, thank you for detangling the concepts of rotate and origin. That makes a lot of sense and is a critical fix! Here's a slightly modified proposal:\n- Remove projection.origin and projection.oblique.\n- Add back projection.rotate([\u03bb, \u03c6, \u03b3]).\n- Add projection.center([\u03bb, \u03c6]) which determines the appropriate offset to center the specified longitude and latitude at the \u27e8x,y\u27e9 specified by projection.translate([x, y]). The name \u201ccenter\u201d is consistent with popular JavaScript mapping libraries and avoids conflict with the old \u201corigin\u201d method.\n- For backwards-compatibility, we can implement projection.origin as (ignoring getter, temporarily):\njs\nprojection.origin = function(coordinates) {\n  return projection.rotate([-coordinates[0], 0]).center([0, coordinates[1]]);\n};\nIt's tempting to deprecate projection.origin because it can be specified as a rotate and center, but this will be the common path for most projections so I think it makes sense to retain as a supported API.\n. > So it's not a matter of ignoring points at the poles, it's just a matter of detecting a sequence of points [a, b, a] and replacing with [a].\nYour thinking as to why that cut exists in Antarctica is consistent with mine: it exists so that Antarctica displays correctly on cylindrical projections (among others\u2026 I think it's needed for winkel3 as well, for example). But for projections that need to remove cuts, such as azimuthals, I fear generalizing that to [a, b, a] \u21a6 [a] could cause false positives. I guess you could argue that [a, b, a] is a degenerate coordinate sequence, but isn't it safe to assume the cuts are always be at \u27e8\u00b1180\u00ba,\u00b190\u00ba\u27e9?\n. > I was just thinking that the cuts aren't only at the poles.\nAh, okay, yes. I agree. So \u27e8\u00b1180\u00ba,*\u27e9.\nI've checked in the new projection.rotate and projection.center. However, I think retaining projection.origin and projection.oblique is a bad idea. For one thing, I realized that projection.origin means different things for different projections; the backwards-compatible implementation I described only applies to Albers (and possibly other conic projections?). For azimuthal projections then origin maps directly to a flipped rotate.\nAlso, I realized that it isn't precisely backwards-compatible even for Albers because the projection.center remains consistent even if you change the projection.translate. So currently albersUsa is broken, but I think we can patch in a backwards-compatible origin for the existing projections that need it.\n. (Actually I take that back. It is backwards-compatible with albers.origin. I just forgot to initialize default origin and parallels for d3.geo.albers that were centered on the USA. But I still think it's a good idea to minimize support for projection.origin.)\n. OK, the required items are all done. I think as long as we can finalize the new projection API (current proposal: projection.point as an alias for projection, projection.line for lineString, projection.polygon for linearRing) and figure out a clean separation between D3 core and the extended geo/projections plugin, then we are ready to merge and release D3 2.11. I'd love to have simple cutting and maybe resampling for this release too, but that could always follow in a patch release provided we can commit to the API now.\n. A few other items on my list:\n- If projections resample automatically, then d3.geo.graticule doesn't need a precision setting; resampling can be performed by projections as needed (and skipped for cylindrical projections!).\n- We could potentially replace projectionMutator with a projection.raw or projection.unit property that stores the normalized underlying projection. That has the benefit of simplifying the API and exposing the raw projections. The downside is that someone could reassign the raw projection in a weird way, and it's an awkward way to create a raw projection if that's all you want.\n- I'd like to not expose singleParallelProjection and doubleParallelProjection, since that adds extra weight to the API. But at the same time, doubleParallelProjection is needed by d3.geo.albers and by some of the extended projections, so it's not obvious whether we can share the code without exposing it from core.\n- We probably still want to go through the code and consolidate constants (e.g., \u03c0 / 180).\n. > otherwise I'm not sure how it would correctly clip polygons with holes\nAh, hrm, I hadn't considered that, but you're right. I'll wait and see how your clip merge goes, and then we'll see what we see. :)\n. I'm hoping projections don't need to understand GeoJSON features; ideally, that can be encapsulated in d3.geo.path. On the other hand, if this proves to be a simpler way of communicating geometry (rather than separate methods that are specific to each geometry type), you might give it a shot.\n. FYI, I am currently attempting the merge into the new d3/projection branch.\n. OK, initial merge is in, but I might make some changes as we decide what parts to expose in the public API.\n. Had an interesting idea I'd like to try (if you don't beat me to it): adaptive resampling. Rather than specifying resampling precision in degrees as we do currently, we could express a precision \u03b5 in px. For each sequential pair of input coordinates AC, interpolate B = (A + C) / 2. Then project, A \u21a6 A\u2032, B \u21a6 B\u2032, C \u21a6 C\u2032. If we can estimate the improvement by subdividing AC into AB and BC, we can determine whether to keep subdividing recursively.\nFor example, a Douglas\u2013Peucker approach: Compute D\u2032, the point along A\u2032C\u2032 that is closest to B\u2032. If the projected distance |B\u2032D\u2032| > \u03b5, subdivide AB and BC recursively. Alternatively Visvalingham: Compute the area of the triangle A\u2032B\u2032C\u2032.\nThis nice thing is that this should hopefully minimize the amount of work required to draw straight lines, while also providing beautiful results when curves are needed. Assuming it works.\n. Also would it be easier to move development to the projection branch? I noticed you copied d3.geo.path into d3-plugins, but the d3/projection branch should be ready for development, too.\n. > So we definitely need some kind of resampling for rotated graticules (or we could use high precision and then simplify). \nRight. Hopefully the adaptive resampling will be effective for this and other cases?\n. I had another thought, since another remaining task is to try to make this as fast as possible. I think there's a way that we can minimize the number of temporary internal data structures created and also efficiently support rendering to canvas as well as SVG. We only need to support three operations for rendering:\n- moveTo(x, y)\n- lineTo(x, y)\n- closePath()\nSo we could define this as a context interface that gets passed to the projection for projection.line, projection.polygon, etc. For SVG we could implement this as:\njs\nvar buffer = [];\nprojection.line(coordinates, {\n  moveTo: function(x, y) { buffer.push(\"M\", x, \",\", y); },\n  lineTo: function(x, y) { buffer.push(\"L\", x, \",\", y); },\n  closePath: function() { buffer.push(\"Z\"); },\n});\nFor canvas:\njs\nprojection.line(coordinates, context);\n. OK, here's an updated list of what we still need to do:\n- Should resampling be turned on or off by default? I'm tempted to leave it off for simplicity and speed, but if it's fast and correct enough, I'd like to leave it on by default. For example I had to disable it in the sterographic projection example because it was slow.\n- Also, the sterographic example now exhibits an occasional artifact which I suspect is related to antemeridian cutting: at certain angles a black line that splits the screen. I'd rather not disable antemeridian cutting, so perhaps we can figure out what's causing the artifact and fix it?\n- Lastly, what is the current state of clipping? I updated the gnomonic projection example to use the new projection branch, but unfortunately it appears that d3.geo.circle's clipping is insufficient to render correctly. It works with the d3.geo.clip plugin, but I'm not up-to-date on the work you've done there and I'd like to understand why d3.geo.circle doesn't work. Also, even with the d3.geo.clip plugin, the graticule outline is a bit finicky; the extent has to fit within the clip angle. Same thing with the orthographic projection example.\n- Should we expose raw projections as d3.geo.foo.raw? Seems like a good idea to me for reusability.\nI will also work on tests.\n. Thank you for the detailed response.\n\nI'd like to rewrite d3.geo.circle using a similar approach to antemeridian cutting with speed as the main priority. \n\nThis sounds excellent! If I understand correctly, this could also be used with the stereographic projection with an angular radius of 90\u00ba - \u03b5 to avoid the discontinuity. Assuming clipping is fast enough we could incorporate this into projections as well, and then projections would be able to set default clip angles. Then orthographic would work out of the box. You could still disable clipping by setting the clip angle to 0\u00ba.\n. Another thought. This is probably unnecessary if projections clip in spherical coordinates, but we could also clip in Cartesian coordinates post-projection to prevent Numbers of Unreasonable Size (N.O.U.S.'s). Ideally clip to \u00b11, but if that's too tight then you could probably get away with min/max \u00b110 without even doing proper clipping.\n. This would potentially eliminate the existing min/max in mercator projection, as well.\n. On second thought, that doesn't appear to work very well.\njs\nfunction projectPoint(\u03bb, \u03c6) {\n  var point = project(\u03bb, \u03c6);\n  if (point[0] > 10) point[0] = 10; else if (point[0] < -10) point[0] = -10;\n  if (point[1] > 10) point[1] = 10; else if (point[1] < -10) point[1] = -10;\n  return [point[0] * k + \u03b4x, \u03b4y - point[1] * k];\n}\nBetter to have each projection clip in spherical coordinates at a projection-appropriate angle.\n. Aside from some cleanup and polish, I think the last major thing to do here is to take your clipping work (d3.geo.clip) and use it to replace d3.geo.circle's clipping algorithm with the more robust approach. We'll need to figure out a solution to the self-intersection and precision problems\u2014at the least, artifacts are preferable to crashing.\nWe can also figure out if we want projections to clip automatically, but it seems like we could defer that to a future release. We appear to need your improved algorithm to use a number of the projections (including built-in ones such as gnomonic). And since it's a drop-in replacement for d3.geo.circle, I think it makes sense to only have one supported clipping algorithm.\n. Also, if we can improve the clipping algorithm so that it's faster thanks to only operating on pre-rotated coordinates, that would be awesome.\n. I've exposed raw projections already (at least in D3 core; not sure whether I remembered to do this in the plugin), e.g., d3.geo.orthographic.raw.\n. Hmm. I'd err towards not, since that might be cumbersome for some implementations (albersUsa, for one). Also I can't think of an immediate need to access the raw projection generically.\n. This is fixed already, right?\n. I'd prefer a more descriptive name (say, \"d3.query\"?). And again, I'll reiterate my question: why make this a D3 plugin if there are no dependencies on D3? Why not offer this as a standalone library with broader applicability?\n. The coordinate is there for client-side (dynamic) simplification. For example, as you zoom in and out of a map, you can choose which points to show or hide, and improve rendering performance. (See example.)\nIt shouldn't be outputting null, though\u2026\n. Moved to mbostock/d3#951.\n. I've pulled your fix, but I'm still seeing a few glitches in the rotating Winkel Tripel example, near the rotated antemeridian. Also, I had to disable rotating the graticule outline because it was being drawn as a L shape.\n. Related new project: TopoJSON. I believe that would let you reconstruct adjacencies\u2026 but, we'll see!\n. You have at least one circular link: {\"source\": 6, \"target\": 6, \u2026}\n. Also, please use Stack Overflow tag d3.js or the d3-js Google group for help.\n. Thanks! I took the liberty of adding you to the d3 organization so that you can update this code as needed. Or contribute other plugins. Cheers!\n. I'd be grateful if you added a note to the README that discouraged use of JSONP in favor of CORS wherever possible.\n. Thanks! I also added a link to http://enable-cors.org/.\n. Unfortunately, the problem with this fix is that the links are no longer of constant width\u2014which is generally a requirement with Sankey diagrams, as the width of the link is the primary visual encoding.\n\n. Also. Thank you for the suggestion and the helpful demonstrative examples!\n. On the contrary my dear fellow, the built-in support for geographic coordinates is a d3.geo.projection! Here's your example using the Mercator projection: \n``` js\nvar projection = d3.geo.mercator()\n    .center([-76.3429, 38.7351]) // geographic center\n    .scale(1 << 12) // zoom level in tile coordinates\n    .translate([width / 2, height / 2]);\nvar tile = d3.geo.tile()\n    .scale(projection.scale())\n    .translate(projection([0, 0]))\n    .size([width, height]);\n```\nAnd here's a live example: http://bl.ocks.org/4150951\n. Let the zoom behavior drive the projection, rather than creating a feedback loop through projection.invert. For example, with Mercator, first create the projection:\njs\nvar projection = d3.geo.mercator();\nThen, on zoom, update the scale and translate (but don\u2019t change the center, and don\u2019t use projection.invert):\njs\nprojection\n    .scale(zoom.scale())\n    .translate(zoom.translate());\nAnd that\u2019s it. Live example, showing the mouse location: http://bl.ocks.org/4132797/dc4d80534125f326349e7fefa05430293e4f5bf8\n. It gets a lot simpler if you temporarily set projection.center to compute the appropriate translate, and then reset it. For example, to zoom to San Francisco:\n``` js\nprojection\n    .scale(1 << 19)\n    .center([-122.4183, 37.7750]) // temporarily set center\n    .translate([width / 2, height / 2])\n    .translate(projection([0, 0])) // compute appropriate translate\n    .center([0, 0]); // reset\nzoom\n    .scale(projection.scale())\n    .translate(projection.translate());\n```\n. @migurski If you are referring to pixels in screen space, the abstraction is d3.geo.projection. If you are referring to the quadtree tile pyramid, the abstraction is d3.geo.tile, except there\u2019s no reason to expose the tile coordinates outside of d3.geo.tile (since you have d3.geo.projection for screen coordinates). Seems simpler to avoid exposing a third coordinate system unless necessary.\n. I completely agree there is a use for tile coordinates when you need to speak tiles, but that is not the case in the simple examples above. There is no tile coordinate system implied in my earlier snippet; there is only the geographic coordinate system and pixels. It is d3.geo.tile that internally maps pixels to tile coordinates, but it could apply any number of strategies to do so (why not hex tiles?) and my point is that it is not required to expose the tile coordinate system in order to use d3.geo.tile.\nBut, as you say, d3.geo.tile could expose the mapping from pixels to tiles, as there are useful applications of the tile coordinate system outside of simply loading them. And in essence it does that already, because d3.geo.tile returns the set of tile coordinates that are visible in the viewport. This interface could be extended to expose the direct mapping between pixels and tiles, similar to projection.\nWhat I am arguing for, albeit poorly, is that I would like to avoid coupling d3.geo.projection to tile coordinates, and likewise avoid coupling d3.geo.tile to geographic coordinates. d3.geo.projection should handle geography \u2194 pixels, and d3.geo.tile should handle pixels \u2194 tiles.\n. You might be interested in the recent wheel event fixes to d3.behavior.zoom; see mbostock/d3#1050. I wonder if you can use d3.behavior.zoom in Squares?\n. I would look at the d3.geo.tile example: http://bl.ocks.org/4132797\nAnd no, you don\u2019t need to add it for each element that gets appended, you only need to add it to the parent container.\n. Bah, sorry about that! Should be all fixed now.\n. Sorry, but this appears to have the same issue as before (non-constant-width links).\n\n. Folding into #49.\n. This appears to be a duplicate of #49.\n. Folding into #49.\n. Folding into #49.\n. This was caused by rounding error in TopoJSON. Since TopoJSON is now guaranteed to produces values within [\u00b1180\u00b0, \u00b190\u00b0], I\u2019m closing this bug as will not fix.\n. Folding into #49.\n. Folding into #49.\n. Does that work in conjunction with rotation and tilt? That's a neat trick!\n. I think tilt angles of 25\u00b0-30\u00b0 are actually not that uncommon, but you do have to crop and zoom in to avoid the high-distortion areas. The U.S.-Mexico border graphic we published yesterday uses a tilt angle of 30\u00b0, and the earlier satellite projection of the U.S. Eastern seaboard uses a tilt angle of 25\u00b0.\nHere's a test case of the Satellite projection using your proposed clipAngle definition. It works for U.S. geometry, but when clipping the entire world, nothing displays:\nhttp://bl.ocks.org/mbostock/6b676736544a8768aaed\n. Right\u2026 the distortion is out of view. There's actually no problem if you prefilter the geometry beforehand to the countries that are visible:\nhttp://bl.ocks.org/mbostock/2b977f1a962b0eb48f69\nOf course, that doesn't help much with the land case, if you have a single multipolygon that's got everything. But I like the idea of optionally being able to pass geometry though pixel-space clipping. I wonder how hard it would be to hook d3.geom.polygon's clip method up to a projection?\n. FWIW, you could use ogr2ogr's -clipdst argument to clip the geometry to the viewport (assuming you figure out how to express the projection in georeferenced coordinates), which is probably the best option for static maps since the TopoJSON file would be as-small-as-possible for the given viewport. But it'd still be good to display these difficult projections correctly, say if you wanted to fly around the earth with the satellite projection.\n. :boom:\n. Nice, thank you for implementing this!\nI see you chose not to preserve the 2\u03c0 scale multiple of the existing d3.geo.mercator. I think it's probably a good idea to not have this scale factor, as it makes it easier to use D3's mercator with GDAL (since the scale factor becomes the radius of the Earth), and it's the minimal essence of the projection. On the other hand, I think it's also important that mercator and transverseMercator function consistently.\nIdeally, we would remove the 2\u03c0 scale factor from the d3.geo.mercator. However, this would break most existing code that uses d3.geo.mercator (even if it doesn't throw an error), and so this should be considered backwards-incompatible reserved for 4.0. But, we could throw caution to the wind and call it a \"bug fix\"\u2026\nOr, we could create a new d3.geo.sphericalMercator projection without the 2\u03c0, and deprecate d3.geo.mercator. But then in 4.0, would we deprecate the sphericalMercator alias after removing the 2\u03c0 scale factor? And then in 5.0 remove sphericalMercator? That's clunky, and verbose. And also, this might be confusing since it suggests that d3.geo.mercator is not spherical, when in practice we'd control that through some other property of the d3.geo.projection. Other names might be \"mercator2\", \"fixedMercator\", \"unscaledMercator\"\u2026\nOr, we could fix only d3.geo.mercator.raw, and make d3.geo.mercator's scale function backwards-compatible by multiplying by 2\u03c0 internally. This would allow you to create your own non-scaled projection as d3.geo.projection(d3.geo.mercator.raw), while d3.geo.mercator would behave the same as it always has. This isn't a horrible solution, but it doesn't really make d3.geo.mercator consistent with d3.geo.transverseMercator, and it doesn't provide a path to deprecation for the old scale factor. So, it doesn't really accomplish anything except add junk code! :)\nDo you have a preference? I guess I'm leaning towards removing the scale factor from d3.geo.mercator, and then fixing the affected examples (such as the d3.geo.tile demo).\n. I just noticed that. OK, let's do it.\nI'm also tempted to add transverseMercator, conicConformal and conicEquidistant to core. And add conicEqualArea as an alias for Albers, but without the U.S.-centric default settings.\n. OK, filed mbostock/d3#1133 to track. Looking forward to the elliptical formulations, too. A plugin sounds like the right place to start there!\n(Also related: still thinking about how best to do static bundling for D3, so that it's easy to compile-in only the needed features.)\n. D3 is not a compatibility layer, and will never support IE8 with an SVG-to-VML fallback. Sorry. You are welcome to try using SVG Web or Rapha\u00ebl.js via R2D3, but these require non-trivial effort, and even if you get it working, they are necessarily slow because IE8 is slow. Any fallback will greatly limit what you can do.\nFor my own graphics, I try to design such that the static view conveys most of the information, while interaction or animation provides an additional level of depth. (See Ben Shneiderman's infovis mantra for further context.) This isn't always possible, of course\u2014some graphics are necessarily dynamic. But when it is, you can simply provide a screenshot as the fallback for IE8 and below, which requires minimal work on your part, and lets you devote your effort to supporting standard browsers that move the web forward.\n. Try this:\n1. Edit geo/projection/index.js to comment out the projections you don\u2019t need.\n2. Run make.\n. You can also build a custom version of D3 as described on the SMASH wiki\n. That reminds me, there\u2019s a related problem where the interpolated projection can get out of sync with its a & b projections if their center or translate changes after alpha is set. I debate whether it\u2019s a requirement that the interpolated projection be a \u201cview\u201d on its constituent projection, but at the same time there\u2019s no way to take a snapshot of a projection so the alternative is to allow undefined behavior.\nMaybe it would be cleaner to interpolate raw projection functions instead, but then you\u2019d have to expose some other API for interpolating changes to scale, center, translate, rotate, etc. Also that would avoid trying to interpolate changes in clipping behavior, which isn\u2019t possible.\n. Very cool! Thank you for this pull request.\nI\u2019ll let @jasondavies review it, but to address one point: clipPolygon has not yet been released. It was not part of 3.1.8, and is currently scheduled for 3.3.0. You probably found it in the clip-polygon branch.\n. Yep, what Jason said. My typical HTML preamble is:\nhtml\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\nThe third option available to you is to minify the code, which in the process mangles symbols and converts them to ascii characters. For example, with UglifyJS:\nbash\nuglifyjs interpolate-zoom.js -c -m -o interpolate-zoom.min.js\n. This seems like the perfect use-case for http://square.github.io/cubism/; have you tried it? Cubism horizon charts let you specify an extent (ymin/ymax).\n. I\u2019m not sure I understand the question but I believe you are asking why the fisheye stops moving when the mouse goes outside the SVG element. In those examples it is because the mousemove listener is assigned to the SVG element. If you want the fisheye to respond to the mouse anywhere in the window, you would listen to mousemove events on the window instead, while continuing to use d3.mouse to convert the mouse position to local coordinates.\n. That\u2019s the correct behavior; it\u2019s because the mouse is close to the natural position of that left-most rule. It\u2019s very hard to push the left-most rule farther to the right because the you\u2019d need to have the mouse outside the left edge of the SVG container, at which point it stops listening. Hence the point about listening to the window rather than the SVG container.\n. Fixed in fc984ac. Pretty sure these copyright notices are optional anyway, but if we\u2019re going to pedantic I might as well start with the year the file was created.\n. I think this is probably a duplicate of #37.\nPersonally, my inclination is to leave d3.geo.tile to operate only in pixel coordinates and not be tied to latitude & longitude; a better name would be d3.geom.tile. The way I intend it to be used is with a geographic projection:\n``` js\nvar projection = d3.geo.mercator()\n    .center([-76.3429, 38.7351]) // geographic center\n    .scale(1 << 12) // zoom level in tile coordinates\n    .translate([width / 2, height / 2]);\nvar tile = d3.geo.tile()\n    .scale(projection.scale())\n    .translate(projection([0, 0]))\n    .size([width, height]);\n```\nBut there\u2019s definitely an opportunity to make this usage more obvious. Open to suggestions.\n. 1 << 12 is the same as 2^12 or Math.pow(2, 12); zoom levels are powers of two.\n. If you just want a hexagon and not hexbins, then you could just write a simple function for computing the points of a hexagon and avoid the plugin entirely:\njs\nfunction hexagon(radius) {\n  var points = new Array(6), i = -1, angle = Math.PI / 3;\n  while (++i < 6) points[i] = [Math.sin(i * angle) * radius, -Math.cos(i * angle) * radius];\n  return points;\n}\n. This is not backwards-compatible, and also I don\u2019t like abbreviations (such as \u201ccoords\u201d). I\u2019ll reply to the other issue.\n. Ahem, months late, but I\u2019ve created a Plugins page in the wiki, and added a link to your plugin:\nhttps://github.com/mbostock/d3/wiki/Plugins\nThank you!\n. Correct. There is no versioning information associated with plugins. Nor is there any packaging information\u2014I don\u2019t think I registered the d3-plugins Bower package, and there\u2019s no bower.json file in the repository. Regardless, it wouldn\u2019t make sense to have a shared version for all plugins. Each plugin would presumably have a separate version and be installed separately.\n. My plan is to create a separate d3-sankey module as part of the new D3 4.0 restructuring. See d3/d3-format for an example of another D3 module.\n. I\u2019m not in favor of silently substituting the specified scale with the one derived from the maximum zoom. Typically this class is used in conjunction with the zoom behavior, so the recommended way to constrain the zoom levels is zoom.scaleExtent. If you\u2019re not using the zoom behavior, then you\u2019ll need to constrain the zoom yourself before using d3.geo.tile (or incorporate such logic into whatever control you are using).\n. Those l commands are relative to the previous point (as opposed to L, which is absolute). So that looks like the correct A \u2192 B \u2192 C \u2192 D \u2192 E \u2192 F to me. The last l command could be dropped given the z, but otherwise it should be fine. The absolute coordinates are:\nA = [0, -12]\nB = [10.4, -6]\nC = [10.4, 6]\nD = [0, 12]\nE = [-10.4, 6]\nF = [-10.4, -6]\nSo,\nm0,-12    // A\nl10.4,6   // A \u2192 B\nl0,12     // B \u2192 C\nl-10.4,6  // C \u2192 D\nl-10.4,-6 // D \u2192 E\nl0,-12    // E \u2192 F\nl10.4,-6  // F \u2192 A\nz         // A\n. This is not an issue with d3.geo.tile per se but a limitation of the example. The problem is that the tiles are removed immediately when they are no longer needed (e.g., when the nearest integer zoom level changes), rather than waiting until the new tiles that will replace them have loaded. One way to avoid flickering is to listen to the new tiles being loaded, and when new tiles completely cover an old tile, remove the old tile. This is outside the scope of d3.geo.tile, which simply computes which tiles are visible in a given viewport, and nothing else.\n. This repository contains only deprecated plugins for D3 v3. Maintained plugins are now developed in separate repositories and published to npm. For d3-sankey, see https://github.com/d3/d3-sankey.\n. See d3/d3-sankey#1.\n. This repository is deprecated. As of v4, each plugin now lives in its own repository. Some of them are under the d3 organization; others can be found using the d3-module tag on npm. See Let\u2019s Make a Plugin for an introduction to the v4 module pattern.. This repository is deprecated; please see d3-sankey.. Yes, it really doesn\u2019t work at all. This repository is deprecated and unsupported. You should try the d3-contour module:\nhttps://github.com/d3/d3-contour. This repository is deprecated. Please go here https://github.com/d3/d3-sankey if you wish to report an issue or request a feature. Thank you!. Please use Stack Overflow tag d3.js to ask for help. Although I make an effort to assist everyone that asks, I am not always available to provide help promptly or directly. Stack Overflow provides a better collaborative forum for self-help: tens of thousands of D3-related questions have already been asked there, and some answered questions may be relevant to you.\nWhen asking for help, please include a link to a live example that demonstrates the issue, preferably on bl.ocks.org. It is often impossible to debug from code snippets alone. Isolate the issue and reduce your code as much as possible before asking for help. The less code you post, the easier it is for someone to debug, and the more likely you are to get a helpful response.\nIf you have a question about D3\u2019s behavior and want to discuss it with other users, also consider the d3-js Google Group or joining the d3-js Slack.\nThank you! \ud83e\udd17. I'd love to see this implemented. The strategy I'd try first is to ignore links that generate cycles in the initial layout, and then add them back in again to draw the loops.\n. Right, computeNodeBreadths is where you'll get an infinite loop unless you detect cycles. So that's the first thing (where you ignore links that generate cycles). The second thing is we probably need to handle loopback links and render them differently. Loopback links still exit the right side, but then they need to loopback to the source and enter on the left side. Probably the sankey.link implementation needs to special-case loopback links and generate a different path for them.\n. @prakashsd You can do this by having multiple nodes that represent A & B at different times (A1, B1, A2, B2). Such a diagram is sometimes called an \u201calluvial diagram\u201d. If you have further questions, please ask on Stack Overflow or the D3.js Slack; these issues are for bug reports and active feature development.. Thanks for the fix!\n. Added you to the contributors team; you now have push privileges.\n. If Kai & Rich would like to host their graph-related code under a different license, they are welcome to add a separate license to their plugin directory or host it separately.\n. Yes, we should support inverse projections as much as possible. (Some will require numeric integration.)\nI was imaging that d3.geo.projection could take two projection functions, forward and inverse (duals of each other). If the inverse projection isn't specified then that projection won't have an inverse method exposed.\n. hammerInverse feels simpler to me.\n. If we can, I'd like to implement this on top of (a forthcoming but already started) d3.geo.rotate. All projections should be able to support an origin; if the origin is non-zero, input features are rotated using d3.geo.rotate before projecting. A user could also use d3.geo.rotate prior to invoking the projection, which would offer better performance if the projection will be used multiple times (for example, you could rescale without recomputing the rotation). The d3.geo.rotate API could also offer the third dimension for rotation in addition to translating the origin.\n. /cc @jasondavies \n. Related #9\n. FYI, partially supported via a new projection.rotate method. See discussion in #16 for details.\n. Yep, fixed! Also removed projection.rotate.\n. /cc @jasondavies \nI created a test for d3.geo.rotate here: http://bl.ocks.org/3734273.\nI'd love to see two changes:\n- The easy one: Takes as input GeoJSON rather than coordinates, and returns GeoJSON accordingly.\n- The hard one: Splits GeoJSON features when they cross the antemeridian; a MultiPolygon might grow more Polygons, a Polygon might become a MultiPolygon, a LineString might become a MultiLineString, etc. It might also be necessary to rejoin GeoJSON features that were split for the default antemeridian, such as Russia (although this sounds difficult). And I'm not sure about Antarctica. I think the logic might need to have checks such as if the polar distance between points is greater than some threshold, split the feature.\n. I guess I should generalize \"cross the antemeridian\" to \"cross the graticule border\" since we plan on supporting rotation in x and z, too.\n. Impressive demo and excellent progress!\n. It seems simpler to me just duplicate the internal constants.\n. Happy with this for now.\n. If there's a standard set of interruptions I could see providing a standard set of graticule outlines, too. I think using 1e-6 or 1e-9 as a relative offset should be fine; Number.MIN_VALUE only works reliably as an offset from zero.\n. That's pretty amazing.\n. Wow!\n\n. I think I've developed a pretty good pattern for reusable interrupted projections that could be incorporated into the extended projections plugin. Here are two examples:\n- Interrupted sinusoidal\n- Interrupted Goode homolosine\nThey use separate implementations for singly- and doubly-interrupted projections (the latter being when the northern hemisphere is divided differently from the southern hemisphere). However, since the implementations are so similar, it seems reasonable to me to just have a doubly-interrupted projection implementation, perhaps with a convenience option for setting both hemispheres to use the same interruptions.\nIt might be worth using a name other that \u201cgore\u201d to define the interruptions. That one\u2019s a bit hard to search on the internet. :frowning: \n. I think between d3.geo.polyhedron and d3.geo.interrupt we have this covered. Closing.\n. Can you save me some trouble and link to demos (e.g., using http://bl.ocks.org) of the new features?\n. /cc @jasondavies Let me know if this sounds good to you. How hard do you think splitting features in d3.geo.rotate will be? We could probably punt on that for the integration (but still hopefully get it working later), since we don't yet support it in core. Also I left out d3.geo.clip, but that could either be a separate plugin or get integrated into core in the future as well.\n. I've added a projection.rotate method. I originally called it projection.origin, but it's not actually backwards-compatible with the old method due to the interaction with parallels (for single- and double-paralleled projections such as Albers). To illustrate with an example, with the old Albers implementation, you might say:\njs\nvar projection = d3.geo.albers()\n    .origin([-98, 38])\n    .parallels([29.5, 45.5])\n    .scale(1000)\n    .translate([width / 2, height / 2]);\nIn the new version, if you rotate so that the origin is 98\u00baW, 38\u00baN, and you specify the same parallels of 29.5\u00baN, 45.5\u00baN, then these parallels will be parallel straight lines (as far as I can tell).\njs\nvar projection = d3.geo.albersEqualArea()\n    .rotate([98, -38])\n    .parallels([29.5, 45.5])\n    .scale(1000)\n    .translate([width / 2, height / 2]);\nExample: http://bl.ocks.org/3760031\nSo what you actually want to do is only rotate 98\u00baW, and then change the translate y-value so that the origin is once again in the center of the canvas:\n``` js\nvar origin = [-98, 38];\nvar projection = d3.geo.albersEqualArea()\n    .rotate([-origin[0], 0])\n    .parallels([29.5, 45.5])\n    .scale(1000)\n    .translate([0, 0]);\nprojection\n    .translate([width / 2, height / 2 - projection(origin)[1]]));\n```\nExample: http://bl.ocks.org/3734308\nThat's a bit more code (and not backwards-compatible), so I think it's worth further thought on rotate vs. origin and how to support either or both. Also, if the projection is rotated, it will also rotate the graticule, which makes it somewhat less useful unless you compensate for the rotation by correspondingly changing the graticule extent. And having to negate the origin to construct the rotation angle is slightly tedious.\nI think it's still a good idea to have a d3.geo.rotate function which operates on GeoJSON features. Though I was also thinking that we might be able to perform the clipping automatically in d3.geo.path by clipping features to the graticule extent (which could be reported by the projection when it needs to be smaller, and otherwise defaults to the default d3.geo.graticule extent?). However, now that I think about it, you'd need to first rotate, then clip, then project. Which suggests that the projection can't encapsulate the rotation, unless the projection also has a way of indicating when going from the previous point to the next point crosses the graticule boundary.\nHmm. More thought is required!\n. Nice work. Sorry I derped up the latitude rotation! I was wondering why it wasn't symmetric and then I remembered the poles. :)\nI thought maybe it might be worth optimizing the case where you only rotate one of {\u03c6,\u03b3}, but I think that's probably a rare enough case that we should only worry about optimizing the much simpler \u03bb rotation.\nAs for oblique, what about rotate([\u03bb, \u03c6, \u03b3])?\n. I had a couple more thoughts last night.\nFirst, when rendering features, the immediate need is to worry about cutting rather than clipping. By cutting I mean breaking a feature into two or more parts where it crosses the antemeridian; this is needed to avoid discontinuities, while clipping is needed to avoid showing back-facing features. For cutting I believe all we need to worry about are coordinates that span the antemeridian, which we can detect by sequential coordinates \u03bb\u2080, \u03bb\u2081 where |\u03bb\u2081 - \u03bb\u2080| > 180\u00ba (meaning the shorter path between the two coordinates crosses the antemeridian). Then we compute the intersection with the antemeridian, and use that to insert an additional vertex to split the feature into two parts, which are then rendered separately. So, a very simple form of clipping.\nSecond, I think those self-intersecting polygons are probably caused by Antarctica. There's an interesting condition when a geographic feature  covers a pole: you get artificial coordinates \u27e8180\u00baW, 90\u00baS\u27e9 and \u27e8180\u00baE, 90\u00baS\u27e9. If you didn't have these coordinates, then how would you know whether Antarctica is a land mass that covers the south pole, or a land mass with a hole at the south pole? Likewise, you need these coordinates to fill in the area south of Antarctica's boundary, as in the Miller projection. But then of course with other projections such as stereographic you end up with a visual artifact where these artificial coordinates are unnecessary and cause spurious lines to the pole. So really we need some way of indicating whether the projection ignores these coordinates.\n. Oh, and we still need to decouple rotation from projection for cutting. The first pass is to rotate the geometry, the cut along the antemeridian, then project coordinates. It might be possible to do this by temporarily clearing the projection's origin and oblique, but I suspect there's a better way to do it. Also we probably want a way to expose the underlying coordinate rotation methods.\nI've also been wondering if we should have a way to expose the raw projection methods, so that it's easier to derive new projections without setting scale(1) and translate([0, 0]).\n. Well, one thing I was considering for the raw projections was just a dict of them as d3.geo.projections, with the same interface as the current internal (immutable) constructors. For example, you might say d3.geo.projections.satellite(P, \u03c9) to get a raw satellite projection.\nIn this case it might be cleaner to hang the invert function off of the forward projection, rather than having separate satellite and satelliteInverse methods. (As you suggested previously.) The other nice thing about this is that you can share constants across the forward and inverse projection, such as:\n``` js\nfunction conicEquidistant(\u03c60, \u03c61) {\n  var cos\u03c60 = Math.cos(\u03c60),\n      n = (cos\u03c60 - Math.cos(\u03c61)) / (\u03c61 - \u03c60),\n      G = cos\u03c60 / n + \u03c60;\nfunction forward(\u03bb, \u03c6) {\n    var \u03c1 = G - \u03c6;\n    return [\n      \u03c1 * Math.sin(n * \u03bb),\n      G - \u03c1 * Math.cos(n * \u03bb)\n    ];\n  }\nforward.invert = function(x, y) {\n    var \u03c10_y = G - y;\n    return [\n      Math.atan2(x, \u03c10_y) / n,\n      G - sgn(n) * Math.sqrt(x * x + \u03c10_y * \u03c10_y)\n    ];\n  };\nreturn forward;\n}\n```\nSince we need to decouple rotation from projection for cutting, it almost feels to me like the rotation should be applied to the d3.geo.path object rather than the d3.geo.projection. Perhaps you could set an optional rotation on the d3.geo.path instance in addition to the projection. I know it's sometimes convenient for the projection to do the rotation internally, but it's not too burdensome if they are decoupled and it certainly makes it cleaner to do the cutting.\nOf course, if the rotation is decoupled from the projection, then the parallels will be relative to the rotated coordinates, which might be weird. And it's not obvious how we could make a backwards-compatible projection.origin.\n. I've added a d3.geo.rotation. But I am considering changing the raw projections (and raw inverse projections) to take a single coordinates argument rather than (\u03bb, \u03c6) or (x, y). This might cause more garbage collection overhead but I'm hoping it will make them easier to compose.\nWith that change, I would get rid of the forward / inverse projection composition in rotate and rotateInverse. Then we could expose rotateInverse as rotate.inverse, and lastly d3.geo.rotation would simply expose rotate.\n. Hmm. Rotating the cut line could work, assuming it's not much more complicated than rotating before cutting? I'll think some more.\nI'll defer on changing the raw projection signature from (\u03bb, \u03c6); I agree that's worked well so far. I'm working on coupling the forward and inverse raw projections now.\n. Also, automatic resampling would be nice. For example the bottom of Antarctica on Larriv\u00e9e and conic conformal. I think we already have the facility to do this in d3.geo.circle. It might be nice if we could detect when resampling is necessary in d3.geo.path, based on the projection.\n. Had a thought. What if projections had a projectLine(lineString) method, and similarly projectRing or projectPolygon for a closed sequence of coordinates, instead of just the current project(point)? This could allow the projection to decide the appropriate action to take, for example cutting or resampling. It could default to return lineString.map(project), which is equivalent to what we do right now. But it would also allow much greater flexibility. For example azimuthal projections could ignore points at \u27e8\u00b1180\u00ba,\u00b190\u00ba\u27e9.\n. Nice, thank you for detangling the concepts of rotate and origin. That makes a lot of sense and is a critical fix! Here's a slightly modified proposal:\n- Remove projection.origin and projection.oblique.\n- Add back projection.rotate([\u03bb, \u03c6, \u03b3]).\n- Add projection.center([\u03bb, \u03c6]) which determines the appropriate offset to center the specified longitude and latitude at the \u27e8x,y\u27e9 specified by projection.translate([x, y]). The name \u201ccenter\u201d is consistent with popular JavaScript mapping libraries and avoids conflict with the old \u201corigin\u201d method.\n- For backwards-compatibility, we can implement projection.origin as (ignoring getter, temporarily):\njs\nprojection.origin = function(coordinates) {\n  return projection.rotate([-coordinates[0], 0]).center([0, coordinates[1]]);\n};\nIt's tempting to deprecate projection.origin because it can be specified as a rotate and center, but this will be the common path for most projections so I think it makes sense to retain as a supported API.\n. > So it's not a matter of ignoring points at the poles, it's just a matter of detecting a sequence of points [a, b, a] and replacing with [a].\nYour thinking as to why that cut exists in Antarctica is consistent with mine: it exists so that Antarctica displays correctly on cylindrical projections (among others\u2026 I think it's needed for winkel3 as well, for example). But for projections that need to remove cuts, such as azimuthals, I fear generalizing that to [a, b, a] \u21a6 [a] could cause false positives. I guess you could argue that [a, b, a] is a degenerate coordinate sequence, but isn't it safe to assume the cuts are always be at \u27e8\u00b1180\u00ba,\u00b190\u00ba\u27e9?\n. > I was just thinking that the cuts aren't only at the poles.\nAh, okay, yes. I agree. So \u27e8\u00b1180\u00ba,*\u27e9.\nI've checked in the new projection.rotate and projection.center. However, I think retaining projection.origin and projection.oblique is a bad idea. For one thing, I realized that projection.origin means different things for different projections; the backwards-compatible implementation I described only applies to Albers (and possibly other conic projections?). For azimuthal projections then origin maps directly to a flipped rotate.\nAlso, I realized that it isn't precisely backwards-compatible even for Albers because the projection.center remains consistent even if you change the projection.translate. So currently albersUsa is broken, but I think we can patch in a backwards-compatible origin for the existing projections that need it.\n. (Actually I take that back. It is backwards-compatible with albers.origin. I just forgot to initialize default origin and parallels for d3.geo.albers that were centered on the USA. But I still think it's a good idea to minimize support for projection.origin.)\n. OK, the required items are all done. I think as long as we can finalize the new projection API (current proposal: projection.point as an alias for projection, projection.line for lineString, projection.polygon for linearRing) and figure out a clean separation between D3 core and the extended geo/projections plugin, then we are ready to merge and release D3 2.11. I'd love to have simple cutting and maybe resampling for this release too, but that could always follow in a patch release provided we can commit to the API now.\n. A few other items on my list:\n- If projections resample automatically, then d3.geo.graticule doesn't need a precision setting; resampling can be performed by projections as needed (and skipped for cylindrical projections!).\n- We could potentially replace projectionMutator with a projection.raw or projection.unit property that stores the normalized underlying projection. That has the benefit of simplifying the API and exposing the raw projections. The downside is that someone could reassign the raw projection in a weird way, and it's an awkward way to create a raw projection if that's all you want.\n- I'd like to not expose singleParallelProjection and doubleParallelProjection, since that adds extra weight to the API. But at the same time, doubleParallelProjection is needed by d3.geo.albers and by some of the extended projections, so it's not obvious whether we can share the code without exposing it from core.\n- We probably still want to go through the code and consolidate constants (e.g., \u03c0 / 180).\n. > otherwise I'm not sure how it would correctly clip polygons with holes\nAh, hrm, I hadn't considered that, but you're right. I'll wait and see how your clip merge goes, and then we'll see what we see. :)\n. I'm hoping projections don't need to understand GeoJSON features; ideally, that can be encapsulated in d3.geo.path. On the other hand, if this proves to be a simpler way of communicating geometry (rather than separate methods that are specific to each geometry type), you might give it a shot.\n. FYI, I am currently attempting the merge into the new d3/projection branch.\n. OK, initial merge is in, but I might make some changes as we decide what parts to expose in the public API.\n. Had an interesting idea I'd like to try (if you don't beat me to it): adaptive resampling. Rather than specifying resampling precision in degrees as we do currently, we could express a precision \u03b5 in px. For each sequential pair of input coordinates AC, interpolate B = (A + C) / 2. Then project, A \u21a6 A\u2032, B \u21a6 B\u2032, C \u21a6 C\u2032. If we can estimate the improvement by subdividing AC into AB and BC, we can determine whether to keep subdividing recursively.\nFor example, a Douglas\u2013Peucker approach: Compute D\u2032, the point along A\u2032C\u2032 that is closest to B\u2032. If the projected distance |B\u2032D\u2032| > \u03b5, subdivide AB and BC recursively. Alternatively Visvalingham: Compute the area of the triangle A\u2032B\u2032C\u2032.\nThis nice thing is that this should hopefully minimize the amount of work required to draw straight lines, while also providing beautiful results when curves are needed. Assuming it works.\n. Also would it be easier to move development to the projection branch? I noticed you copied d3.geo.path into d3-plugins, but the d3/projection branch should be ready for development, too.\n. > So we definitely need some kind of resampling for rotated graticules (or we could use high precision and then simplify). \nRight. Hopefully the adaptive resampling will be effective for this and other cases?\n. I had another thought, since another remaining task is to try to make this as fast as possible. I think there's a way that we can minimize the number of temporary internal data structures created and also efficiently support rendering to canvas as well as SVG. We only need to support three operations for rendering:\n- moveTo(x, y)\n- lineTo(x, y)\n- closePath()\nSo we could define this as a context interface that gets passed to the projection for projection.line, projection.polygon, etc. For SVG we could implement this as:\njs\nvar buffer = [];\nprojection.line(coordinates, {\n  moveTo: function(x, y) { buffer.push(\"M\", x, \",\", y); },\n  lineTo: function(x, y) { buffer.push(\"L\", x, \",\", y); },\n  closePath: function() { buffer.push(\"Z\"); },\n});\nFor canvas:\njs\nprojection.line(coordinates, context);\n. OK, here's an updated list of what we still need to do:\n- Should resampling be turned on or off by default? I'm tempted to leave it off for simplicity and speed, but if it's fast and correct enough, I'd like to leave it on by default. For example I had to disable it in the sterographic projection example because it was slow.\n- Also, the sterographic example now exhibits an occasional artifact which I suspect is related to antemeridian cutting: at certain angles a black line that splits the screen. I'd rather not disable antemeridian cutting, so perhaps we can figure out what's causing the artifact and fix it?\n- Lastly, what is the current state of clipping? I updated the gnomonic projection example to use the new projection branch, but unfortunately it appears that d3.geo.circle's clipping is insufficient to render correctly. It works with the d3.geo.clip plugin, but I'm not up-to-date on the work you've done there and I'd like to understand why d3.geo.circle doesn't work. Also, even with the d3.geo.clip plugin, the graticule outline is a bit finicky; the extent has to fit within the clip angle. Same thing with the orthographic projection example.\n- Should we expose raw projections as d3.geo.foo.raw? Seems like a good idea to me for reusability.\nI will also work on tests.\n. Thank you for the detailed response.\n\nI'd like to rewrite d3.geo.circle using a similar approach to antemeridian cutting with speed as the main priority. \n\nThis sounds excellent! If I understand correctly, this could also be used with the stereographic projection with an angular radius of 90\u00ba - \u03b5 to avoid the discontinuity. Assuming clipping is fast enough we could incorporate this into projections as well, and then projections would be able to set default clip angles. Then orthographic would work out of the box. You could still disable clipping by setting the clip angle to 0\u00ba.\n. Another thought. This is probably unnecessary if projections clip in spherical coordinates, but we could also clip in Cartesian coordinates post-projection to prevent Numbers of Unreasonable Size (N.O.U.S.'s). Ideally clip to \u00b11, but if that's too tight then you could probably get away with min/max \u00b110 without even doing proper clipping.\n. This would potentially eliminate the existing min/max in mercator projection, as well.\n. On second thought, that doesn't appear to work very well.\njs\nfunction projectPoint(\u03bb, \u03c6) {\n  var point = project(\u03bb, \u03c6);\n  if (point[0] > 10) point[0] = 10; else if (point[0] < -10) point[0] = -10;\n  if (point[1] > 10) point[1] = 10; else if (point[1] < -10) point[1] = -10;\n  return [point[0] * k + \u03b4x, \u03b4y - point[1] * k];\n}\nBetter to have each projection clip in spherical coordinates at a projection-appropriate angle.\n. Aside from some cleanup and polish, I think the last major thing to do here is to take your clipping work (d3.geo.clip) and use it to replace d3.geo.circle's clipping algorithm with the more robust approach. We'll need to figure out a solution to the self-intersection and precision problems\u2014at the least, artifacts are preferable to crashing.\nWe can also figure out if we want projections to clip automatically, but it seems like we could defer that to a future release. We appear to need your improved algorithm to use a number of the projections (including built-in ones such as gnomonic). And since it's a drop-in replacement for d3.geo.circle, I think it makes sense to only have one supported clipping algorithm.\n. Also, if we can improve the clipping algorithm so that it's faster thanks to only operating on pre-rotated coordinates, that would be awesome.\n. I've exposed raw projections already (at least in D3 core; not sure whether I remembered to do this in the plugin), e.g., d3.geo.orthographic.raw.\n. Hmm. I'd err towards not, since that might be cumbersome for some implementations (albersUsa, for one). Also I can't think of an immediate need to access the raw projection generically.\n. This is fixed already, right?\n. I'd prefer a more descriptive name (say, \"d3.query\"?). And again, I'll reiterate my question: why make this a D3 plugin if there are no dependencies on D3? Why not offer this as a standalone library with broader applicability?\n. The coordinate is there for client-side (dynamic) simplification. For example, as you zoom in and out of a map, you can choose which points to show or hide, and improve rendering performance. (See example.)\nIt shouldn't be outputting null, though\u2026\n. Moved to mbostock/d3#951.\n. I've pulled your fix, but I'm still seeing a few glitches in the rotating Winkel Tripel example, near the rotated antemeridian. Also, I had to disable rotating the graticule outline because it was being drawn as a L shape.\n. Related new project: TopoJSON. I believe that would let you reconstruct adjacencies\u2026 but, we'll see!\n. You have at least one circular link: {\"source\": 6, \"target\": 6, \u2026}\n. Also, please use Stack Overflow tag d3.js or the d3-js Google group for help.\n. Thanks! I took the liberty of adding you to the d3 organization so that you can update this code as needed. Or contribute other plugins. Cheers!\n. I'd be grateful if you added a note to the README that discouraged use of JSONP in favor of CORS wherever possible.\n. Thanks! I also added a link to http://enable-cors.org/.\n. Unfortunately, the problem with this fix is that the links are no longer of constant width\u2014which is generally a requirement with Sankey diagrams, as the width of the link is the primary visual encoding.\n\n. Also. Thank you for the suggestion and the helpful demonstrative examples!\n. On the contrary my dear fellow, the built-in support for geographic coordinates is a d3.geo.projection! Here's your example using the Mercator projection: \n``` js\nvar projection = d3.geo.mercator()\n    .center([-76.3429, 38.7351]) // geographic center\n    .scale(1 << 12) // zoom level in tile coordinates\n    .translate([width / 2, height / 2]);\nvar tile = d3.geo.tile()\n    .scale(projection.scale())\n    .translate(projection([0, 0]))\n    .size([width, height]);\n```\nAnd here's a live example: http://bl.ocks.org/4150951\n. Let the zoom behavior drive the projection, rather than creating a feedback loop through projection.invert. For example, with Mercator, first create the projection:\njs\nvar projection = d3.geo.mercator();\nThen, on zoom, update the scale and translate (but don\u2019t change the center, and don\u2019t use projection.invert):\njs\nprojection\n    .scale(zoom.scale())\n    .translate(zoom.translate());\nAnd that\u2019s it. Live example, showing the mouse location: http://bl.ocks.org/4132797/dc4d80534125f326349e7fefa05430293e4f5bf8\n. It gets a lot simpler if you temporarily set projection.center to compute the appropriate translate, and then reset it. For example, to zoom to San Francisco:\n``` js\nprojection\n    .scale(1 << 19)\n    .center([-122.4183, 37.7750]) // temporarily set center\n    .translate([width / 2, height / 2])\n    .translate(projection([0, 0])) // compute appropriate translate\n    .center([0, 0]); // reset\nzoom\n    .scale(projection.scale())\n    .translate(projection.translate());\n```\n. @migurski If you are referring to pixels in screen space, the abstraction is d3.geo.projection. If you are referring to the quadtree tile pyramid, the abstraction is d3.geo.tile, except there\u2019s no reason to expose the tile coordinates outside of d3.geo.tile (since you have d3.geo.projection for screen coordinates). Seems simpler to avoid exposing a third coordinate system unless necessary.\n. I completely agree there is a use for tile coordinates when you need to speak tiles, but that is not the case in the simple examples above. There is no tile coordinate system implied in my earlier snippet; there is only the geographic coordinate system and pixels. It is d3.geo.tile that internally maps pixels to tile coordinates, but it could apply any number of strategies to do so (why not hex tiles?) and my point is that it is not required to expose the tile coordinate system in order to use d3.geo.tile.\nBut, as you say, d3.geo.tile could expose the mapping from pixels to tiles, as there are useful applications of the tile coordinate system outside of simply loading them. And in essence it does that already, because d3.geo.tile returns the set of tile coordinates that are visible in the viewport. This interface could be extended to expose the direct mapping between pixels and tiles, similar to projection.\nWhat I am arguing for, albeit poorly, is that I would like to avoid coupling d3.geo.projection to tile coordinates, and likewise avoid coupling d3.geo.tile to geographic coordinates. d3.geo.projection should handle geography \u2194 pixels, and d3.geo.tile should handle pixels \u2194 tiles.\n. You might be interested in the recent wheel event fixes to d3.behavior.zoom; see mbostock/d3#1050. I wonder if you can use d3.behavior.zoom in Squares?\n. I would look at the d3.geo.tile example: http://bl.ocks.org/4132797\nAnd no, you don\u2019t need to add it for each element that gets appended, you only need to add it to the parent container.\n. Bah, sorry about that! Should be all fixed now.\n. Sorry, but this appears to have the same issue as before (non-constant-width links).\n\n. Folding into #49.\n. This appears to be a duplicate of #49.\n. Folding into #49.\n. Folding into #49.\n. This was caused by rounding error in TopoJSON. Since TopoJSON is now guaranteed to produces values within [\u00b1180\u00b0, \u00b190\u00b0], I\u2019m closing this bug as will not fix.\n. Folding into #49.\n. Folding into #49.\n. Does that work in conjunction with rotation and tilt? That's a neat trick!\n. I think tilt angles of 25\u00b0-30\u00b0 are actually not that uncommon, but you do have to crop and zoom in to avoid the high-distortion areas. The U.S.-Mexico border graphic we published yesterday uses a tilt angle of 30\u00b0, and the earlier satellite projection of the U.S. Eastern seaboard uses a tilt angle of 25\u00b0.\nHere's a test case of the Satellite projection using your proposed clipAngle definition. It works for U.S. geometry, but when clipping the entire world, nothing displays:\nhttp://bl.ocks.org/mbostock/6b676736544a8768aaed\n. Right\u2026 the distortion is out of view. There's actually no problem if you prefilter the geometry beforehand to the countries that are visible:\nhttp://bl.ocks.org/mbostock/2b977f1a962b0eb48f69\nOf course, that doesn't help much with the land case, if you have a single multipolygon that's got everything. But I like the idea of optionally being able to pass geometry though pixel-space clipping. I wonder how hard it would be to hook d3.geom.polygon's clip method up to a projection?\n. FWIW, you could use ogr2ogr's -clipdst argument to clip the geometry to the viewport (assuming you figure out how to express the projection in georeferenced coordinates), which is probably the best option for static maps since the TopoJSON file would be as-small-as-possible for the given viewport. But it'd still be good to display these difficult projections correctly, say if you wanted to fly around the earth with the satellite projection.\n. :boom:\n. Nice, thank you for implementing this!\nI see you chose not to preserve the 2\u03c0 scale multiple of the existing d3.geo.mercator. I think it's probably a good idea to not have this scale factor, as it makes it easier to use D3's mercator with GDAL (since the scale factor becomes the radius of the Earth), and it's the minimal essence of the projection. On the other hand, I think it's also important that mercator and transverseMercator function consistently.\nIdeally, we would remove the 2\u03c0 scale factor from the d3.geo.mercator. However, this would break most existing code that uses d3.geo.mercator (even if it doesn't throw an error), and so this should be considered backwards-incompatible reserved for 4.0. But, we could throw caution to the wind and call it a \"bug fix\"\u2026\nOr, we could create a new d3.geo.sphericalMercator projection without the 2\u03c0, and deprecate d3.geo.mercator. But then in 4.0, would we deprecate the sphericalMercator alias after removing the 2\u03c0 scale factor? And then in 5.0 remove sphericalMercator? That's clunky, and verbose. And also, this might be confusing since it suggests that d3.geo.mercator is not spherical, when in practice we'd control that through some other property of the d3.geo.projection. Other names might be \"mercator2\", \"fixedMercator\", \"unscaledMercator\"\u2026\nOr, we could fix only d3.geo.mercator.raw, and make d3.geo.mercator's scale function backwards-compatible by multiplying by 2\u03c0 internally. This would allow you to create your own non-scaled projection as d3.geo.projection(d3.geo.mercator.raw), while d3.geo.mercator would behave the same as it always has. This isn't a horrible solution, but it doesn't really make d3.geo.mercator consistent with d3.geo.transverseMercator, and it doesn't provide a path to deprecation for the old scale factor. So, it doesn't really accomplish anything except add junk code! :)\nDo you have a preference? I guess I'm leaning towards removing the scale factor from d3.geo.mercator, and then fixing the affected examples (such as the d3.geo.tile demo).\n. I just noticed that. OK, let's do it.\nI'm also tempted to add transverseMercator, conicConformal and conicEquidistant to core. And add conicEqualArea as an alias for Albers, but without the U.S.-centric default settings.\n. OK, filed mbostock/d3#1133 to track. Looking forward to the elliptical formulations, too. A plugin sounds like the right place to start there!\n(Also related: still thinking about how best to do static bundling for D3, so that it's easy to compile-in only the needed features.)\n. D3 is not a compatibility layer, and will never support IE8 with an SVG-to-VML fallback. Sorry. You are welcome to try using SVG Web or Rapha\u00ebl.js via R2D3, but these require non-trivial effort, and even if you get it working, they are necessarily slow because IE8 is slow. Any fallback will greatly limit what you can do.\nFor my own graphics, I try to design such that the static view conveys most of the information, while interaction or animation provides an additional level of depth. (See Ben Shneiderman's infovis mantra for further context.) This isn't always possible, of course\u2014some graphics are necessarily dynamic. But when it is, you can simply provide a screenshot as the fallback for IE8 and below, which requires minimal work on your part, and lets you devote your effort to supporting standard browsers that move the web forward.\n. Try this:\n1. Edit geo/projection/index.js to comment out the projections you don\u2019t need.\n2. Run make.\n. You can also build a custom version of D3 as described on the SMASH wiki\n. That reminds me, there\u2019s a related problem where the interpolated projection can get out of sync with its a & b projections if their center or translate changes after alpha is set. I debate whether it\u2019s a requirement that the interpolated projection be a \u201cview\u201d on its constituent projection, but at the same time there\u2019s no way to take a snapshot of a projection so the alternative is to allow undefined behavior.\nMaybe it would be cleaner to interpolate raw projection functions instead, but then you\u2019d have to expose some other API for interpolating changes to scale, center, translate, rotate, etc. Also that would avoid trying to interpolate changes in clipping behavior, which isn\u2019t possible.\n. Very cool! Thank you for this pull request.\nI\u2019ll let @jasondavies review it, but to address one point: clipPolygon has not yet been released. It was not part of 3.1.8, and is currently scheduled for 3.3.0. You probably found it in the clip-polygon branch.\n. Yep, what Jason said. My typical HTML preamble is:\nhtml\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\nThe third option available to you is to minify the code, which in the process mangles symbols and converts them to ascii characters. For example, with UglifyJS:\nbash\nuglifyjs interpolate-zoom.js -c -m -o interpolate-zoom.min.js\n. This seems like the perfect use-case for http://square.github.io/cubism/; have you tried it? Cubism horizon charts let you specify an extent (ymin/ymax).\n. I\u2019m not sure I understand the question but I believe you are asking why the fisheye stops moving when the mouse goes outside the SVG element. In those examples it is because the mousemove listener is assigned to the SVG element. If you want the fisheye to respond to the mouse anywhere in the window, you would listen to mousemove events on the window instead, while continuing to use d3.mouse to convert the mouse position to local coordinates.\n. That\u2019s the correct behavior; it\u2019s because the mouse is close to the natural position of that left-most rule. It\u2019s very hard to push the left-most rule farther to the right because the you\u2019d need to have the mouse outside the left edge of the SVG container, at which point it stops listening. Hence the point about listening to the window rather than the SVG container.\n. Fixed in fc984ac. Pretty sure these copyright notices are optional anyway, but if we\u2019re going to pedantic I might as well start with the year the file was created.\n. I think this is probably a duplicate of #37.\nPersonally, my inclination is to leave d3.geo.tile to operate only in pixel coordinates and not be tied to latitude & longitude; a better name would be d3.geom.tile. The way I intend it to be used is with a geographic projection:\n``` js\nvar projection = d3.geo.mercator()\n    .center([-76.3429, 38.7351]) // geographic center\n    .scale(1 << 12) // zoom level in tile coordinates\n    .translate([width / 2, height / 2]);\nvar tile = d3.geo.tile()\n    .scale(projection.scale())\n    .translate(projection([0, 0]))\n    .size([width, height]);\n```\nBut there\u2019s definitely an opportunity to make this usage more obvious. Open to suggestions.\n. 1 << 12 is the same as 2^12 or Math.pow(2, 12); zoom levels are powers of two.\n. If you just want a hexagon and not hexbins, then you could just write a simple function for computing the points of a hexagon and avoid the plugin entirely:\njs\nfunction hexagon(radius) {\n  var points = new Array(6), i = -1, angle = Math.PI / 3;\n  while (++i < 6) points[i] = [Math.sin(i * angle) * radius, -Math.cos(i * angle) * radius];\n  return points;\n}\n. This is not backwards-compatible, and also I don\u2019t like abbreviations (such as \u201ccoords\u201d). I\u2019ll reply to the other issue.\n. Ahem, months late, but I\u2019ve created a Plugins page in the wiki, and added a link to your plugin:\nhttps://github.com/mbostock/d3/wiki/Plugins\nThank you!\n. Correct. There is no versioning information associated with plugins. Nor is there any packaging information\u2014I don\u2019t think I registered the d3-plugins Bower package, and there\u2019s no bower.json file in the repository. Regardless, it wouldn\u2019t make sense to have a shared version for all plugins. Each plugin would presumably have a separate version and be installed separately.\n. My plan is to create a separate d3-sankey module as part of the new D3 4.0 restructuring. See d3/d3-format for an example of another D3 module.\n. I\u2019m not in favor of silently substituting the specified scale with the one derived from the maximum zoom. Typically this class is used in conjunction with the zoom behavior, so the recommended way to constrain the zoom levels is zoom.scaleExtent. If you\u2019re not using the zoom behavior, then you\u2019ll need to constrain the zoom yourself before using d3.geo.tile (or incorporate such logic into whatever control you are using).\n. Those l commands are relative to the previous point (as opposed to L, which is absolute). So that looks like the correct A \u2192 B \u2192 C \u2192 D \u2192 E \u2192 F to me. The last l command could be dropped given the z, but otherwise it should be fine. The absolute coordinates are:\nA = [0, -12]\nB = [10.4, -6]\nC = [10.4, 6]\nD = [0, 12]\nE = [-10.4, 6]\nF = [-10.4, -6]\nSo,\nm0,-12    // A\nl10.4,6   // A \u2192 B\nl0,12     // B \u2192 C\nl-10.4,6  // C \u2192 D\nl-10.4,-6 // D \u2192 E\nl0,-12    // E \u2192 F\nl10.4,-6  // F \u2192 A\nz         // A\n. This is not an issue with d3.geo.tile per se but a limitation of the example. The problem is that the tiles are removed immediately when they are no longer needed (e.g., when the nearest integer zoom level changes), rather than waiting until the new tiles that will replace them have loaded. One way to avoid flickering is to listen to the new tiles being loaded, and when new tiles completely cover an old tile, remove the old tile. This is outside the scope of d3.geo.tile, which simply computes which tiles are visible in a given viewport, and nothing else.\n. This repository contains only deprecated plugins for D3 v3. Maintained plugins are now developed in separate repositories and published to npm. For d3-sankey, see https://github.com/d3/d3-sankey.\n. See d3/d3-sankey#1.\n. This repository is deprecated. As of v4, each plugin now lives in its own repository. Some of them are under the d3 organization; others can be found using the d3-module tag on npm. See Let\u2019s Make a Plugin for an introduction to the v4 module pattern.. This repository is deprecated; please see d3-sankey.. Yes, it really doesn\u2019t work at all. This repository is deprecated and unsupported. You should try the d3-contour module:\nhttps://github.com/d3/d3-contour. This repository is deprecated. Please go here https://github.com/d3/d3-sankey if you wish to report an issue or request a feature. Thank you!. Please use Stack Overflow tag d3.js to ask for help. Although I make an effort to assist everyone that asks, I am not always available to provide help promptly or directly. Stack Overflow provides a better collaborative forum for self-help: tens of thousands of D3-related questions have already been asked there, and some answered questions may be relevant to you.\nWhen asking for help, please include a link to a live example that demonstrates the issue, preferably on bl.ocks.org. It is often impossible to debug from code snippets alone. Isolate the issue and reduce your code as much as possible before asking for help. The less code you post, the easier it is for someone to debug, and the more likely you are to get a helpful response.\nIf you have a question about D3\u2019s behavior and want to discuss it with other users, also consider the d3-js Google Group or joining the d3-js Slack.\nThank you! \ud83e\udd17. ",
    "bhaugen": "I'm on it.  Any pointers to where I should focus in the code?  When I halted it a few times, it was cycling through computeNodeBreadths(), but maybe that was a red herring...\n. Thanks for the continued conversation.\nWhat I did for the short term (because I got users waiting for sankeys, and their networks are acyclic) is cheat.  I already got code to detect cycles in python (where I'm assembling the data for the sankeys), so I just disabled the sankeys if your network has a cycle.\nThen I gotta get my head back on straight within computeNodeBreadths, which currently makes it spin.  Then figure out how detect and postpone cyclic links there.\nI suspect the loopback links are gonna be beyond my skill level, but we'll see.\n. Thanks, but those changes did not work for me.  Created false cycles in networks that did not have cycles, and did not handle simple cycles very well.\nHere's a network that has no cycles, before:\nhttp://locecon.org/clusters/sankey/16/\nHere it is after:\nhttps://docs.google.com/open?id=0BxlqOeaPnXHfSTloOWVWQTdFVkk\nHere's one with a cycle, using your changes:\nhttps://docs.google.com/open?id=0BxlqOeaPnXHfSGpXbVFPVkFCZjQ\nHere's the page source:\nhttps://docs.google.com/open?id=0BxlqOeaPnXHfRmtmU2UwTzFsOFE\nLet me know if you think I did not use your changed code correctly - or if you can't access those files.\n. > My code, at present, checks if the node names are the same, as opposed to node object equality. \n\nIt appears that your code uses multiple nodes with the same name (specifically, \"Groundfish\", for example), \nwhich my code doesn't account for (my bad). \nI'll try switching to object equality, and see if that makes things better.\n\nI understand the problem.  My code actually assembles the link relationships on the server, so you can't see from the page source how it's done (looking up the array indices based on object identity).  I've meant to work up a rev for sankeys to assemble the links based on node object ids rather than array indices in the sankey javascript, but haven't had time.  That would at least make explicit what is happening.\nSo if providing unique node ids would help what you are trying to do, I can easily provide them.\nThe duplicate names were a given (to me: they were created by users), and they do actually make sense on some level...\n. cfergus, thanks for persisting.  It's better; does not falsely detect cycles when nodes have the same names.  My networks with cycles look a little odd, but it also looks like I will have to change my code to take advantage of your cycle features.  I'm in crunch mode on another project, but will try that when I get a chance.\n. Yes! Works now. Thank you, Colin.\nOn Thu, Jul 17, 2014 at 3:19 PM, Colin Fergus notifications@github.com\nwrote:\n\nMy bad. I updated my gist to include the modified sankey.js alongside it.\nThe link should work now for http://bl.ocks.org/3956043\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/d3/d3-plugins/issues/1#issuecomment-49359938.\n. Those are some nice-looking cycles.\n\nOn Mon, May 18, 2015 at 7:37 PM, Stefaan Lippens notifications@github.com\nwrote:\n\nHi all, I did another implementation of this:\nsoxofaan/d3-plugins@be35a11\nhttps://github.com/soxofaan/d3-plugins/commit/be35a11fbbbce9f5b31b8b47983e690b14cf4100\nIt's simpler/less code compared to the solution of @cfergus\nhttps://github.com/cfergus, but I think the cycle detection it is more\nefficient.\nI also preserve the width of the feedback lanes (as requested above).\nThe feedback paths layout might need some more tuning, but I thought to\nalready push the current state and collect some feedback\nexamples at\nhttp://bl.ocks.org/soxofaan/bb6f91d57dc4b6afe91d/cc526b481b1bc59982e9fe511fd97d776da20b95\n(don't forget to refresh\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/d3/d3-plugins/issues/1#issuecomment-103282548.\n. But, Colin, thanks for being the pioneer!\n\nOn Tue, May 19, 2015 at 9:14 AM, Colin Fergus notifications@github.com\nwrote:\n\nSo far, looks better than my implementation. I dunno what the etiquette\nwould be, but I consider mine to be 'overtaken'. Should I include a link to\nyour version in my readme? Other preferred way to reflect this?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/d3/d3-plugins/issues/1#issuecomment-103515076.\n. I'm on it.  Any pointers to where I should focus in the code?  When I halted it a few times, it was cycling through computeNodeBreadths(), but maybe that was a red herring...\n. Thanks for the continued conversation.\n\nWhat I did for the short term (because I got users waiting for sankeys, and their networks are acyclic) is cheat.  I already got code to detect cycles in python (where I'm assembling the data for the sankeys), so I just disabled the sankeys if your network has a cycle.\nThen I gotta get my head back on straight within computeNodeBreadths, which currently makes it spin.  Then figure out how detect and postpone cyclic links there.\nI suspect the loopback links are gonna be beyond my skill level, but we'll see.\n. Thanks, but those changes did not work for me.  Created false cycles in networks that did not have cycles, and did not handle simple cycles very well.\nHere's a network that has no cycles, before:\nhttp://locecon.org/clusters/sankey/16/\nHere it is after:\nhttps://docs.google.com/open?id=0BxlqOeaPnXHfSTloOWVWQTdFVkk\nHere's one with a cycle, using your changes:\nhttps://docs.google.com/open?id=0BxlqOeaPnXHfSGpXbVFPVkFCZjQ\nHere's the page source:\nhttps://docs.google.com/open?id=0BxlqOeaPnXHfRmtmU2UwTzFsOFE\nLet me know if you think I did not use your changed code correctly - or if you can't access those files.\n. > My code, at present, checks if the node names are the same, as opposed to node object equality. \n\nIt appears that your code uses multiple nodes with the same name (specifically, \"Groundfish\", for example), \nwhich my code doesn't account for (my bad). \nI'll try switching to object equality, and see if that makes things better.\n\nI understand the problem.  My code actually assembles the link relationships on the server, so you can't see from the page source how it's done (looking up the array indices based on object identity).  I've meant to work up a rev for sankeys to assemble the links based on node object ids rather than array indices in the sankey javascript, but haven't had time.  That would at least make explicit what is happening.\nSo if providing unique node ids would help what you are trying to do, I can easily provide them.\nThe duplicate names were a given (to me: they were created by users), and they do actually make sense on some level...\n. cfergus, thanks for persisting.  It's better; does not falsely detect cycles when nodes have the same names.  My networks with cycles look a little odd, but it also looks like I will have to change my code to take advantage of your cycle features.  I'm in crunch mode on another project, but will try that when I get a chance.\n. Yes! Works now. Thank you, Colin.\nOn Thu, Jul 17, 2014 at 3:19 PM, Colin Fergus notifications@github.com\nwrote:\n\nMy bad. I updated my gist to include the modified sankey.js alongside it.\nThe link should work now for http://bl.ocks.org/3956043\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/d3/d3-plugins/issues/1#issuecomment-49359938.\n. Those are some nice-looking cycles.\n\nOn Mon, May 18, 2015 at 7:37 PM, Stefaan Lippens notifications@github.com\nwrote:\n\nHi all, I did another implementation of this:\nsoxofaan/d3-plugins@be35a11\nhttps://github.com/soxofaan/d3-plugins/commit/be35a11fbbbce9f5b31b8b47983e690b14cf4100\nIt's simpler/less code compared to the solution of @cfergus\nhttps://github.com/cfergus, but I think the cycle detection it is more\nefficient.\nI also preserve the width of the feedback lanes (as requested above).\nThe feedback paths layout might need some more tuning, but I thought to\nalready push the current state and collect some feedback\nexamples at\nhttp://bl.ocks.org/soxofaan/bb6f91d57dc4b6afe91d/cc526b481b1bc59982e9fe511fd97d776da20b95\n(don't forget to refresh\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/d3/d3-plugins/issues/1#issuecomment-103282548.\n. But, Colin, thanks for being the pioneer!\n\nOn Tue, May 19, 2015 at 9:14 AM, Colin Fergus notifications@github.com\nwrote:\n\nSo far, looks better than my implementation. I dunno what the etiquette\nwould be, but I consider mine to be 'overtaken'. Should I include a link to\nyour version in my readme? Other preferred way to reflect this?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/d3/d3-plugins/issues/1#issuecomment-103515076.\n. \n",
    "cfergus": "I've made an attempt at solving this issue. There are a few ways it could be improved, but please let me know if a pull request (or otherwise) is in order.\nExample at : http://bl.ocks.org/3921009\nFork and changes at:\ncfergus@deb7bda3522ab198fa771a21c84ca1dc4fccd95a\n. Regarding the first network featuring \"Groundfish\": \nMy code, at present, checks if the node names are the same, as opposed to node object equality. It appears that your code uses multiple nodes with the same name (specifically, \"Groundfish\", for example), which my code doesn't account for (my bad). \nI'll try switching to object equality, and see if that makes things better.\nRegarding the second network, featuring \"Restaurant -> Compost Materials\":\nThe cycle is present, but my layout is not good. You can see the cycle being rendered (in part) at the top of the screen. This is because the \"Restaurant\" node is flush with the far right of the viewbox (where the path starts), and \"Compost Materials\" node is flush with the far left (where the path ends).\nI will need to update the overall algorithm for laying out the entire sankey diagram, as well as the feedback loops, in order to make this display as one might expect. This part might take a bit longer. Open to suggestions.\n. Alright, round two. \nhttp://bl.ocks.org/3956043\nPoints of note:\n- (improvement) The viewbox is expanded to fit potential cycles at the left and right. This could be made better by only expanding when such cycles exist.\n- The equivalence is based on nodes now, so your example with nodes identically named should work out now\n- The gist example above uses randomly generated sankey data. As such, you don't know what you'll get\n- The bl.ocks view seems to have its own css, so you may just want to use the \"Open in a new window\" link to see it more fully.\n- (bug) This code doesn't seem to handle 'self-cycles', where a node loops back onto itself.\nLet me know if this seems usable!\n. My bad. I updated my gist to include the modified sankey.js alongside it. The link should work now for http://bl.ocks.org/3956043\n. So far, looks better than my implementation. I dunno what the etiquette would be, but I consider mine to be 'overtaken'. Should I include a link to your version in my readme? Other preferred way to reflect this?\n. I've made an attempt at solving this issue. There are a few ways it could be improved, but please let me know if a pull request (or otherwise) is in order.\nExample at : http://bl.ocks.org/3921009\nFork and changes at:\ncfergus@deb7bda3522ab198fa771a21c84ca1dc4fccd95a\n. Regarding the first network featuring \"Groundfish\": \nMy code, at present, checks if the node names are the same, as opposed to node object equality. It appears that your code uses multiple nodes with the same name (specifically, \"Groundfish\", for example), which my code doesn't account for (my bad). \nI'll try switching to object equality, and see if that makes things better.\nRegarding the second network, featuring \"Restaurant -> Compost Materials\":\nThe cycle is present, but my layout is not good. You can see the cycle being rendered (in part) at the top of the screen. This is because the \"Restaurant\" node is flush with the far right of the viewbox (where the path starts), and \"Compost Materials\" node is flush with the far left (where the path ends).\nI will need to update the overall algorithm for laying out the entire sankey diagram, as well as the feedback loops, in order to make this display as one might expect. This part might take a bit longer. Open to suggestions.\n. Alright, round two. \nhttp://bl.ocks.org/3956043\nPoints of note:\n- (improvement) The viewbox is expanded to fit potential cycles at the left and right. This could be made better by only expanding when such cycles exist.\n- The equivalence is based on nodes now, so your example with nodes identically named should work out now\n- The gist example above uses randomly generated sankey data. As such, you don't know what you'll get\n- The bl.ocks view seems to have its own css, so you may just want to use the \"Open in a new window\" link to see it more fully.\n- (bug) This code doesn't seem to handle 'self-cycles', where a node loops back onto itself.\nLet me know if this seems usable!\n. My bad. I updated my gist to include the modified sankey.js alongside it. The link should work now for http://bl.ocks.org/3956043\n. So far, looks better than my implementation. I dunno what the etiquette would be, but I consider mine to be 'overtaken'. Should I include a link to your version in my readme? Other preferred way to reflect this?\n. ",
    "kunalb": "Hi -- i just sent a pull request that might help (https://github.com/d3/d3-plugins/pull/39) with this.\n. ^ Just cleaned up the code a bit, and reverted the link behaviour to the original for people who prefer to keep the same width nodes, while adding a reversibleLink function as an alternative for people creating cyclic sankey diagrams.\nThe reversible link function creates three parts that get filled correctly: basically so that reversed links are filled in correctly (see the attached screenshot: the bottom image is what was, with a single path filled in, and the top svg element is the new version, with 3 paths filled in making a ribbon)\n\nNew example (slightly more complex than the previous one) with cycles: http://bl.ocks.org/kunalb/raw/5140332/\n. @itay I guess the fact that chord widths aren't constant is probably a problem because that's pretty crucial for most sankey diagrams? I couldn't figure out a way to fit everything in cleanly enough with constant width diagrams... @mbostock any suggestions? I can try and iterate on this.\n. That's fairly trivial: sent out a separate pull request: #78 \n. @pkpp1233 You could patch this diff and use reversibleLink instead of Link. See the example in the documentation for reversibleLink. \n. @josephsiu not that I know of. Put up a gist somewhere so that I can take a look?\n. @NPC Hm, looks like github doesn't allow hotlinking js files directly any more :). I set up one of the gists as an example at http://explog.in/notes/sankey/\n. @Erfabes you choose the link color when you draw the links for both the normal and reversible links -- see the example at https://github.com/d3/d3-plugins/pull/39/files#diff-3aa14326cff02f35c6674920e9334c9fR79 ; that's completely controlled by you.\n. Hi -- i just sent a pull request that might help (https://github.com/d3/d3-plugins/pull/39) with this.\n. ^ Just cleaned up the code a bit, and reverted the link behaviour to the original for people who prefer to keep the same width nodes, while adding a reversibleLink function as an alternative for people creating cyclic sankey diagrams.\nThe reversible link function creates three parts that get filled correctly: basically so that reversed links are filled in correctly (see the attached screenshot: the bottom image is what was, with a single path filled in, and the top svg element is the new version, with 3 paths filled in making a ribbon)\n\nNew example (slightly more complex than the previous one) with cycles: http://bl.ocks.org/kunalb/raw/5140332/\n. @itay I guess the fact that chord widths aren't constant is probably a problem because that's pretty crucial for most sankey diagrams? I couldn't figure out a way to fit everything in cleanly enough with constant width diagrams... @mbostock any suggestions? I can try and iterate on this.\n. That's fairly trivial: sent out a separate pull request: #78 \n. @pkpp1233 You could patch this diff and use reversibleLink instead of Link. See the example in the documentation for reversibleLink. \n. @josephsiu not that I know of. Put up a gist somewhere so that I can take a look?\n. @NPC Hm, looks like github doesn't allow hotlinking js files directly any more :). I set up one of the gists as an example at http://explog.in/notes/sankey/\n. @Erfabes you choose the link color when you draw the links for both the normal and reversible links -- see the example at https://github.com/d3/d3-plugins/pull/39/files#diff-3aa14326cff02f35c6674920e9334c9fR79 ; that's completely controlled by you.\n. ",
    "angieskazka": "hi all! ~~so was the issue actually solved? is there a demo showing it?~~ yes, works perfect!\nhowever http://bl.ocks.org/3956043 is broken \nbecause GIThub does not allow to fetch .js with raw. prefix anymore. \n@cfergus, please consider changing a link to sankey.js\n\nthanks!\n. yes, they are, as i could see yesterday\nsave the code from http://bl.ocks.org/3956043 and the referred sankey.js locally, change the link to sankey.js and run the code. it should work:\n\n. hi all! ~~so was the issue actually solved? is there a demo showing it?~~ yes, works perfect!\nhowever http://bl.ocks.org/3956043 is broken \nbecause GIThub does not allow to fetch .js with raw. prefix anymore. \n@cfergus, please consider changing a link to sankey.js\n\nthanks!\n. yes, they are, as i could see yesterday\nsave the code from http://bl.ocks.org/3956043 and the referred sankey.js locally, change the link to sankey.js and run the code. it should work:\n\n. ",
    "vlasvlasvlas": "are cycles now implemented?\n. nicee\n. this would be great... +1 !!\n. are cycles now implemented?\n. nicee\n. this would be great... +1 !!\n. ",
    "gnewton": "Any chance we can have the lanes going back in the loop (at the top of http://bl.ocks.org/3956043 ) to retain their width? Or to have it toggle-able to retain width or all squeeze down to the same width, as it is now?\nI find altering the width makes the interpretation more difficult, i.e. if you can see the width of the loop-backs this givers you the impression of their significance. Perhaps better stated, reducing their width (even though their starts and ends flair out to the right width, kind of reduces their visual impact more than I think is best for this kind of visualization...\nThat said, great work!  :-)\n. Any chance we can have the lanes going back in the loop (at the top of http://bl.ocks.org/3956043 ) to retain their width? Or to have it toggle-able to retain width or all squeeze down to the same width, as it is now?\nI find altering the width makes the interpretation more difficult, i.e. if you can see the width of the loop-backs this givers you the impression of their significance. Perhaps better stated, reducing their width (even though their starts and ends flair out to the right width, kind of reduces their visual impact more than I think is best for this kind of visualization...\nThat said, great work!  :-)\n. ",
    "Erfabes": "Hi! i\u00b4m Just wondering if its is possible to get these cycle-lanes to the bottom of the diagramm? \n. @kunalb , Thank you for your great work. Just one Question:\nIs there any possibility to change the color of the cycle-links, without changing the color of the \"normal\" links?\n. Hi! i\u00b4m Just wondering if its is possible to get these cycle-lanes to the bottom of the diagramm? \n. @kunalb , Thank you for your great work. Just one Question:\nIs there any possibility to change the color of the cycle-links, without changing the color of the \"normal\" links?\n. ",
    "prufrock": "Would it be possible to commit the changes proposed here?\n. Would it be possible to commit the changes proposed here?\n. ",
    "fordanic": "Try to use it for cycles for a single node, i.e. the node is pointing back to itself. Is there a reason why it doesn't work or is it just me? \n. Try to use it for cycles for a single node, i.e. the node is pointing back to itself. Is there a reason why it doesn't work or is it just me? \n. ",
    "soxofaan": "Hi all, I did another implementation of this:\nsoxofaan/d3-plugins@be35a11fbbbce9f5b31b8b47983e690b14cf4100\nIt's simpler/less code compared to the solution of @cfergus, but I think the cycle detection it is more efficient.\nI also preserve the width of the feedback lanes (as requested above).\nThe feedback paths layout might need some more tuning, but I thought to already push the current state and collect some feedback\nexamples at http://bl.ocks.org/soxofaan/bb6f91d57dc4b6afe91d/cc526b481b1bc59982e9fe511fd97d776da20b95 (don't forget to refresh\n. FYI: I started a friendly (subtree) fork (see #133) of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey\namong others I tweaked the cycle support some more:\n- issue: https://github.com/soxofaan/d3-plugin-captain-sankey/issues/6\n- branch: https://github.com/soxofaan/d3-plugin-captain-sankey/tree/issue-6-cycle-handling\n- demo: http://bl.ocks.org/soxofaan/7c96560677ead0425fe7\n\n. +1\n. (FYI: as maintenance of d3-plugins stalled, I started a friendly (subtree) fork (see #133) of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey)\nI'm also working on rendering cycles at soxofaan/d3-plugin-captain-sankey#6\n. FYI: I merged #91  in the master branch of my subtree fork of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey (also see #133 )\n. duplicate of #75 \n. (FYI: I started a friendly (subtree) fork (see #133) of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey)\nThis issue is handled by soxofaan/d3-plugin-captain-sankey#4\nWork on supporting rendering cycles is at soxofaan/d3-plugin-captain-sankey#6\n. rebased commit on latest master\n. Hi,\nFYI: I've merged this in the master branch of my subtree fork of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey (also see #133 )\n. FYI: \nI started a friendly (subtree) fork (see #133) of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey\nI am working on support of rendering cycles at soxofaan/d3-plugin-captain-sankey#6\n. This issue can be closed, as I fixed it in my own subtree fork:\nsoxofaan/d3-plugin-captain-sankey#4\n. Hi all, I did another implementation of this:\nsoxofaan/d3-plugins@be35a11fbbbce9f5b31b8b47983e690b14cf4100\nIt's simpler/less code compared to the solution of @cfergus, but I think the cycle detection it is more efficient.\nI also preserve the width of the feedback lanes (as requested above).\nThe feedback paths layout might need some more tuning, but I thought to already push the current state and collect some feedback\nexamples at http://bl.ocks.org/soxofaan/bb6f91d57dc4b6afe91d/cc526b481b1bc59982e9fe511fd97d776da20b95 (don't forget to refresh\n. FYI: I started a friendly (subtree) fork (see #133) of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey\namong others I tweaked the cycle support some more:\n- issue: https://github.com/soxofaan/d3-plugin-captain-sankey/issues/6\n- branch: https://github.com/soxofaan/d3-plugin-captain-sankey/tree/issue-6-cycle-handling\n- demo: http://bl.ocks.org/soxofaan/7c96560677ead0425fe7\n\n. +1\n. (FYI: as maintenance of d3-plugins stalled, I started a friendly (subtree) fork (see #133) of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey)\nI'm also working on rendering cycles at soxofaan/d3-plugin-captain-sankey#6\n. FYI: I merged #91  in the master branch of my subtree fork of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey (also see #133 )\n. duplicate of #75 \n. (FYI: I started a friendly (subtree) fork (see #133) of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey)\nThis issue is handled by soxofaan/d3-plugin-captain-sankey#4\nWork on supporting rendering cycles is at soxofaan/d3-plugin-captain-sankey#6\n. rebased commit on latest master\n. Hi,\nFYI: I've merged this in the master branch of my subtree fork of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey (also see #133 )\n. FYI: \nI started a friendly (subtree) fork (see #133) of the sankey plugin at https://github.com/soxofaan/d3-plugin-captain-sankey\nI am working on support of rendering cycles at soxofaan/d3-plugin-captain-sankey#6\n. This issue can be closed, as I fixed it in my own subtree fork:\nsoxofaan/d3-plugin-captain-sankey#4\n. ",
    "NickCiao": "Walking through computeLinkDepths to try and diagnose what's going on. Would love to know if you guys have any insights on what might be happening:\n\nedit turns out this is an issue with the data, not the vis itself.\n. mispost, sorry!\n. Walking through computeLinkDepths to try and diagnose what's going on. Would love to know if you guys have any insights on what might be happening:\n\nedit turns out this is an issue with the data, not the vis itself.\n. mispost, sorry!\n. ",
    "someshku": "Hi Stefaan, in my project we have just too many cycles making the chart difficult to comprehend. How can I move the cycle paths back to the top like Colin's while keeping your core code. \n. Hi Stefaan, in my project we have just too many cycles making the chart difficult to comprehend. How can I move the cycle paths back to the top like Colin's while keeping your core code. \n. ",
    "prakashsd": "Folks,\nIs it possible to create a chart like the one attached using sankey diagram?\n1) Cyclic Representation\nA -> B\nB -> A\n2) Same nodes in Source and Destination\nA   A\nB   B\nC   C\n3) I want to color code each bands to differentiate the categories.\nBasically, I want to show how many sessions were steered/switched from one network to the other.\nTIA!\n\n. Folks,\nIs it possible to create a chart like the one attached using sankey diagram?\n1) Cyclic Representation\nA -> B\nB -> A\n2) Same nodes in Source and Destination\nA   A\nB   B\nC   C\n3) I want to color code each bands to differentiate the categories.\nBasically, I want to show how many sessions were steered/switched from one network to the other.\nTIA!\n\n. ",
    "justincormack": "Everything should be available under the same license, as it was all code that was originally submitted for inclusion to d3. I think it would be best to have a top level license for all the plugins and if anyone else for some odd reason wants to have a plugin under a different license they can put it elsewhere.\n. Everything should be available under the same license, as it was all code that was originally submitted for inclusion to d3. I think it would be best to have a top level license for all the plugins and if anyone else for some odd reason wants to have a plugin under a different license they can put it elsewhere.\n. ",
    "stepheneb": "There see to be just two authors besides Mike: Kai Chang kai.salmon.chang@gmail.com and Rich Morin rdm@cfcl.com.\n```\n$ git log -1\ncommit d55e989449d60d0fa91972d6a3b357570aca6d6d\nAuthor: Mike Bostock mbostock@gmail.com\nDate:   Thu Jun 28 17:46:24 2012 -0700\nUse shortest path for d3.cie.interpolateLch.\n\n$ git log --all --format='%aN %ae' | sort -u\nKai Chang kai.salmon.chang@gmail.com\nKai kai.salmon.chang@gmail.com\nMike Bostock mbostock@gmail.com\nRich Morin rdm@cfcl.com\n```\nI've written to both of them asking them to respond in this issue thread.\n. There see to be just two authors besides Mike: Kai Chang kai.salmon.chang@gmail.com and Rich Morin rdm@cfcl.com.\n```\n$ git log -1\ncommit d55e989449d60d0fa91972d6a3b357570aca6d6d\nAuthor: Mike Bostock mbostock@gmail.com\nDate:   Thu Jun 28 17:46:24 2012 -0700\nUse shortest path for d3.cie.interpolateLch.\n\n$ git log --all --format='%aN %ae' | sort -u\nKai Chang kai.salmon.chang@gmail.com\nKai kai.salmon.chang@gmail.com\nMike Bostock mbostock@gmail.com\nRich Morin rdm@cfcl.com\n```\nI've written to both of them asking them to respond in this issue thread.\n. ",
    "RichMorin": "Feel free to add the standard D3 LICENSE file to my code area.\n. Feel free to add the standard D3 LICENSE file to my code area.\n. ",
    "jasondavies": "This has already been fixed in ef3dcb79.\n. Sounds great. I've made a start!\nFor the simpler projections, should we call the inverse something like hammerInverse? Or perhaps we could add hammer.invert and pass that via projection(hammer, hammer.invert)?\n. I think I've now implemented all the inverse projections that I could do easily.\n. Yes, this lets us support arbitrary aspects (oblique, transverse, polar) for free!\n. I've brought back .origin and added .oblique! I think we can close this, assuming @mbostock is in agreement.\n. This Atlantis aspect is the kind of thing we want to support easily. Your idea of rotating GeoJSON (instead of individual coordinates like it does currently) would simplify this a lot:\njs\nd3.selectAll(\"path\")\n    .data(collection.features)\n  .enter().append(\"path\")\n    .datum(rotate)\n    .attr(\"d\", d3.geo.path().projection(mollweide)\nCurrently, I'm having to clip twice (once for each hemisphere), and effectively I'm rotating for each clip operation too, since I'm specifying a clip origin for the unrotated GeoJSON. It would be much nicer to rotate first and clip afterwards, and hopefully this'll simplify the clipping algorithm somewhat too.\nA d3.geo.clip API may still be useful for azimuthal projections so that an arbitrary angle can be specified. I'll need to work more on the examples and report back!\n. Sounds good!\n. That was quick. :) Just had another idea: you could have yet another optional argument to projection denoting the number of parallels. That might be overloading it a bit too much though? You would need to pass null for a projection with no inverse but 1 or more parallels. It should also pluralise \"parallel\" automatically.\njs\nprojection(forward, inverse);\nprojection(forward, inverse, 1);\nprojection(forward, inverse, 2);\nprojection(forward, inverse, 3); // woah!\n. Ignore this, it would require changing the function signature of the first two arguments.\n. Hmm, it might be nice to reuse internal constants for inverse projections with parallels. Maybe singleParallelProjection and friends should check for a .invert property on the result of projectAt(\u03c60)? Alternatively, I suppose projectAt(\u2026) could return a two-element array?\n. Yes, that's what I settled on in the end. :)\n. It would be worth benchmarking this kind of thing too as I'm never too sure how good modern VMs are at constant folding.\n. I've been testing my inverse projections using a simple set of edge cases (poles, etc.) - I'll see about moving these into a batch of vows tests. Some projections are quite inaccurate near the poles due to slow convergence of Newton\u2013Raphson, so I think it's better to enumerate all cases rather than test for |x - inverse(forward(x))| < \u03b5.\n. /cc @mbostock\n. I think the world-countries.json file bundled with D3 contains only simple polygons (non-self-intersecting), and the clipping seems to work fine there (perhaps with an occasional glitch due to precision error).\n. Actually, I think it's simpler if d3.geo.graticule remains as it is. The outline of interruptions can be specified as a polygon instead, which can then be resampled to obtain a clipping path. I've updated the interrupted sinusoidal projection. Note how I abuse -0. :)\n. (Of course, I can't abuse -0 for other interrupt points; I'll use an offset of Number.MIN_VALUE instead).\n. Ah, good point about Number.MIN_VALUE, thanks!\n. Leaving aside polyhedral maps, the most common type of interruption might look like:\njs\n// Upper and lower interruption longitudes\u2026\nvar lobes = d3.geo.lobes([[-180, 0, 180], [-180, -90, 90, 180]]);\nlobes.outline; // similar to graticule.outline; returns a GeoJSON Polygon\nlobes.projection(d3.geo.sinusoidal()); // sets the projection in use\nlobes([\u03bb, \u03c6]); // projects a point with appropriate offset\nThis would do the menial tasks of computing relative offsets for the outline and translating the projection inputs/outputs appropriately.\n. Here's a proof of concept. This only works for cylindrical projections right now. Conic projections require rotation of gores.\n. Thanks! See also the interrupted Goode Homolosine. :)\n. LOL!\n. Looks good!  I think the resampling part can be dropped entirely, if we ensure that the outline is inset slightly towards the centroid.  This has worked well for me for polyhedra and Berghaus star.  (Note that you don't need an inset at the poles though, this should interpolate to the correct longitude automatically.)\nI'm thinking d3.geo.polyhedron might be able to handle these types of interruptions too; we are cutting the globe into spherical polygons, except that we only want to join the projected faces by a single vertex, rather than an edge.  We can do some cool things particularly with conics if we orient the projected faces according to the meridian at the join point.  Also, it has code to compute inverses (which I will optimise at some point).\nI'd be fine with including this in the plugin for now though.\nYes, I see how \"gore\" could be problematic. :)\n. Splitting features should be pretty straightforward, I think. I'll have a go soon. I was originally thinking to reuse d3.geo.clip, and that would be quite simple (just a matter of modifying the intersection condition to clip against half a great circle). I've made some progress on making it cope with non-simple (self-intersecting) polygons (see clip-complex branch).\nWe could also naively split all polygon rings into two on the clip edge, which would lead to artefacts along the edge in some situations, but perhaps not so important since most map edges will have some kind of graticule outline. This is basically the old algorithm in core.\nAs for azimuthal clipping, most of the time you want to clip against a circle on the sphere. However, in the case of the tilted perspective projection, it's a bit of a special case and the result is some kind of curve. So it would be nice to have some kind of arbitrary visibility function, which some projections could provide (i.e. azimuthal ones). Another example is the vertical perspective, for which you can calculate the precise horizon.\n. I agree about renaming d3.geo.albersEqualArea to d3.geo.conicEqualArea: it's clearer. I think I called it this originally. :)\n. Nice work!\nAnother possibility would be automatically offset the standard parallels internally. I think that would solve the parallels problem? I guess it's also an argument for keeping the rotation encapsulated in the projection, since it needs to know the rotate to be able to do this.\nI'll give the graticule some thought.\n. Hmm, I think you're already offsetting the parallels internally, I need to look at this more carefully.\n. Fixed it! Turns out you had a bug in the latitude rotation.\n. Any ideas about what to call oblique aspects? Maybe we could have projection.oblique(\u00b0)?\n. No worries! :)\nYep, I figured the cost of a few additional multiplications to support both \u03c6 and \u03b3 at once is negligible compared to the trig calls to convert to and from 3-space in rotate\u03c6\u03b3.\nA third argument for \u03b3 could work if we keep .rotate; I wasn't sure if we should just drop .rotate in favour of using .origin and .oblique though?\n. I\u2019ve had similar thoughts about cutting. I think our first concern is, as you say, to split features that cross the antemeridian. This applies to most of our whole-world projections e.g. excluding the orthographic projection (which can show a hemisphere at most) and vertical/tilted perspective projections.\nThe algorithm for doing this is pretty much the same as that used for clipping: you don't throw away polygons on the other side of the edge and just rebuild them in the same way that you would normally do for those that you keep. Similar to clipping, a na\u00efve approach could be used that doesn't properly handle holes (like we have in D3 core) - but maybe this is sufficient since a graticule outline may hide artefacts that would otherwise be visible crossing the holes. I need to investigate this though.\nI\u2019m probably trying to think ahead too much about polygonal projections and interruptions, both of which don't necessarily need additional splitting since clipPath can be used. For example, the Peirce Quincuncial ideally needs to split features along two edges arranged in a cross on the opposite hemisphere though. But I think that eventually supporting an arbitrary set of cutting edges might be quite useful for that.\nLast time I checked, line simplification almost always produces self-intersecting polygons, so I'm not sure it's just Antarctica. Antarctica seems to work fine when I'm clipping world-countries.json, for example. I'd prefer to support self-intersecting polygons if possible though. I think I've cracked it in the clip-complex branch! I see your point about the ambiguity of Antarctica. I'll need to think about whether it's possible to resolve that.\nAgreed about exposing the raw projection methods. How about .forward() and .inverse() for retrieving these from a d3.geo.projection instance?\n. Sharing constants would be nice, yes.\nComposable projections sound useful, although the \u03bb, \u03c6 arguments have been pleasant to work with thus far!\n. How about performing the cutting in d3.geo.path, using the current projection.origin and .oblique to rotate the cut line?\nFor example, most of the time we want to cut along the antemeridian at 180\u00b0E/W. So the cut line could be from <180\u00b0, -90\u00b0> to <180\u00b0, 90\u00b0>. So these start/end points could be transformed using the current .origin and .oblique to appropriate locations, and then cutting can be applied (just before projecting).\nI guess I like the idea of .origin and .oblique, but I'm not sure it's necessary to decouple the rotation if the cut line can simply be rotated too (please correct me if I'm missing something!)\n. Good idea! I think .projectLine could be a great way to add flexibility, while maintaining simple defaults for these projections. We would have a handful of simple internal implementations for these (say, one for azimuthal and another for cylindrical/conics), and something like Peirce Quincuncial could easily be implemented using a custom .projectLine that splits across two edges, perhaps using the public d3.geo.clip and d3.geo.projection.rotation APIs.\n. I've just realised there's a problem with our use of rotations to set origins. I think we're mixing two different concepts here. The concepts are:\n1. Central meridian and standard parallels. These mainly define the longitude of interest (such that its meridian can be vertical, for example when using conics), and the latitudes of \"true scale\". So if we go back to the Albers projection example of the U.S., you were right to use a rotation by longitude only, and then apply a translation so that the U.S. is in the centre of the viewport (or in other words, the \"origin\" in pixel space is the centre of the U.S.).\nHowever, rotating latitudinally introduces a slight distortion compared with just translating in pixel-space. This is because although we had adjusted the standard parallels, they are no longer parallel to the original parallels that have now been rotated! I've tried to illustrate this with an example.\nI feel like using the longitudinal rotation to set the central meridian is just a way to allow the code to be simplified by not requiring a \"central meridian\" parameter, but I'm fine with continuing to do this as I can't see any problem with it.\n2. The second concept is that of an \"origin\" of interest, which could be interpreted either way, but I feel is more about setting an appropriate translation offset so that the feature of interest is centred appropriately.\nSo in conclusion, I think we should probably:\n- restore .rotate(\u03b4\u03bb, \u03b4\u03c6, \u03b4\u03b3) and drop .origin.\n- retain .origin for azimuthal projections (using .rotate as it does now), for backwards-compatibility. I don't know if we want to add some kind of .translateTo(\u2026) convenience method for all projections though.\n. For composing functions, perhaps a simple helper could be useful for this?\njs\nfunction composable(f) {\n  return function(coordinates) {\n    return f.apply(this, coordinates);\n  };\n}\nI mainly enjoy being able to write function(\u03bb, \u03c6) { \u2026 } without the additional few lines for unpacking an array, so maybe we could wrap all projection functions with this when we need it. I don't mind calling projections with projection([\u03bb, \u03c6]) as it's just two additional characters. :)\n. Automatic resampling in d3.geo.path would be great. This would solve the issue of Antarctica in conic projections: hopefully the large delta in pixel-space would be detected, and further points would be projected in between \u27e8\u2212180\u00ba,\u221290\u00ba\u27e9 and \u27e8180\u00ba,\u221290\u00ba\u27e9, for example.\n. By the way, I think the cut in Antarctica is only there since this is along the antemeridian, and inserting it means that cylindrical projections will work out-of-the-box. I think if you assume that all land polygons are smaller than a hemisphere, then there is no ambiguity even if you apply an arbitrary rotation, since you can always detect which side of the line should be the interior.\nThe other possible resolution is the fact that we implicitly assume the exterior ring is clockwise, and the interior rings are anti-clockwise, so that the default fill rule \"just works\" in SVG. I think this alone can also resolve the ambiguity: if you have an exterior ring that appears anti-clockwise from one direction, then you know you need flip your viewpoint and fill on the other side. However, I don't think GeoJSON mandates a particular ordering at the moment, so this may be dependent on what generated the GeoJSON.\nBut I agree it would be a good idea to auto-detect any existing cuts like this and rejoin. So it's not a matter of ignoring points at the poles, it's just a matter of detecting a sequence of points [a, b, a] and replacing with [a]. I think this is more of a generic fix that should be applied to all GeoJSON features that come from shape files that automatically have such cuts, rather than just azimuthals. I guess in a way it should applied when generating the GeoJSON in the first place, but we should be liberal in what we can accept and it's easy enough to implement.\n. As for LineStrings, although this is also not in the spec., I believe it's conventional to always pick the shortest distance if there's an ambiguity e.g. you can't create a 361\u00b0 line using only two points (e.g. you could imagine trying to do this by specifying latitudes outside \u00b1180\u00b0).\n. Regarding the order of rotating, clipping and projecting, I see three possibilities:\n1. Rotate, clip and then project. The advantage is that clipping after rotating can be optimised for the common cases of antemeridian and azimuthal clipping: the antemeridian is simply \u03bb = \u00b1180\u00b0, and the azimuthal projections typically clip against z = 0 or z = some constant value in 3-space, so it seems like this can be more efficient. Although, if we have .projectLine and .projectPolygon, I guess the azimuthal projections may reuse the cos(c) term anyway, which is normally used to determine visibility of points.\n2. Clip, rotate, then project. In this case we need to rotate the clip edge first, so that the \"cut\" becomes the antemeridian when everything is rotated in the second step.\n3. Rotate, project and then clip in pixel-space. I don't think this would always really work: it would involve detecting large enough changes in pixel coordinates and inserting breaks at these points (or interpolating towards the nearest graticule outline).\nI guess this idea of encapsulating clipping/cutting in the projections means the projection can perform the operations in any order, but I thought I may as well note down my thoughts anyway. I think the first option seems best.\n. Sounds great. I like .center([\u03bb, \u03c6])!\n. > But for projections that need to remove cuts, such as azimuthals, I fear generalizing that to [a, b, a] \u21a6 [a] could cause false positives. I guess you could argue that [a, b, a] is a degenerate coordinate sequence, but isn't it safe to assume the cuts are always be at \u27e8\u00b1180\u00ba,\u00b190\u00ba\u27e9?\nCuts can appear at other latitudes too, e.g. Russia in world-countries.json? I think it's safe to assume they only appear on the antemeridian at \u00b1180\u00b0 though. I think we broadly agree; I was just thinking that the cuts aren't only at the poles.\n. Agreed. I was thinking to only keep it for azimuthal projections for backwards-compatibility with D3 core (which I see you're doing at the moment - looks good!) and perhaps even mark it as deprecated in the documentation. I think .oblique can definitely be dropped in favour of .rotate.\n. Great stuff! Perhaps I should move some of d3.geo.clip into projection.js to see how the API handles it? For example, I wonder if projection.polygon should take an array of LinearRings rather than just one LinearRing at time (otherwise I'm not sure how it would correctly clip polygons with holes).\n. Awesome. Looking forward to it!\nI'm preparing d3.geo.clip for use with the new API. Should be a pretty straightforward use of clipLine(lineString) and clipPolygon(rings) where applicable. I'll start with azimuthal projections since I can already clip against circles. Then I'll see about adding support for cutting.\n. Lookin' good.\n. First cut of clipping (for azimuthal projections) is in the new clip branch. This uses the new clipping algorithm, which has the self-intersections caveat that I mentioned previously. A potential fix for this is in the clip-complex branch (although I haven't updated this to use the new API). We could of course use the old d3.geo.circle algorithm as an alternative.\nJust to clarify about clipping, there are a couple of options:\n1. When clipping polygons, each ring can be clipped separately so that the resulting rings are also separate. This can lead to artefacts where the exterior ring crosses what should be a hole, but only along the clip line. So if there is a graticule outline like in many of the current examples, it could cover this up. However, if you didn't want an outline, such as in your Natural Earth Coastlines example, you would see the artefacts (although they only apply to holes, which are fairly rare in practice). The advantage is that it's probably more efficient to implement since you don't need to build a linked list and traverse it in a particular order, and it doesn't care about self-intersections.\n2. The new general algorithm that I've worked on for d3.geo.clip, which uses Weiler-Atherton and at the moment can't handle self-intersections, although I think I've found a fix for this. This works nicely for the Natural Earth Coastlines (although it won't work if you use straightforward line simplification since this introduces self-intersections quite quickly).\nI'm tempted to switch the the first option for the master branch (and possibly for core if it's integrated), and work further on the second for a future version. I'll see how it goes with the self-intersection fix.\nOh, and I'm excited about the automatic resampling! As well as simplifying graticules, it means clipping no longer needs to interpolate between intersection points assuming the clip edge is a great circle (which I think it is in all cases, except maybe tilted perspective).\n. Okay, I think I'll to switch to option no. 1 when I add cutting along the antemeridian. Should simplify the code a lot. :) Proper handling of holes can be restored later if we really want it.\n. The elegance!\njs\nvar path = d3.geo.path()\n    .projection(d3.geo.orthographic()\n      .rotate([0, 0, 45])\n      .translate([width / 2, height / 2]));\nI've reversed the direction of \u03b4\u03b3 as it seems more intuitive for it to denote a clockwise measurement.\n. Great idea. It\u2019s like line simplification but in reverse!\nJust realised something. I was thinking this could potentially simplify the graticules code e.g. you mentioned earlier:\n\nIf projections resample automatically, then d3.geo.graticule doesn't need a precision setting; resampling can be performed by projections as needed (and skipped for cylindrical projections!).\n\nActually, this is not quite correct if we use generic great-circle resampling, since lines of latitude (parallels) are not all great circles, so resampling in between the step points would be slightly off. So to optimise graticules, we may be better off sampling at a higher precision and applying line simplification after projecting.\nOn the other hand I think it could simplify the cutting code, since it could interpolate in between the cut points and use only as many points as are needed, which would be nice.\n. Will move this to the projection branch shortly.\n. Just a note about the graticule precision for conics. The true length of the angular step for the equatorial line is much greater than that for the graticule line at \u03c6=80\u00b0, say.\nSo, imagine rotating the graticule on a sphere, such that the equatorial line is close to the sphere's South Pole. \nSince the distortion is much greater at the poles when using cylindricals and conics, even a precision of 1\u00b0 becomes a large distance in px. And for conics, this low-precision line doesn't follow the curve so it's very obvious. Unfortunately, increasing precision to 0.1\u00b0 makes animating much slower! The same low-precision graticule line appears in cylindricals but it's not noticeable since it's approximately the right shape.\nSo we definitely need some kind of resampling for rotated graticules (or we could use high precision and then simplify). Even if we ended using great-circle resampling, that would avoid this overlap issue and would probably be good enough even though it'll be slightly off compared with true lines of latitude.\n. Yep. It will be great for cases where our input features are of low resolution relative to the local distortion of the projection.\nIf we have very high resolution features, I'm hoping that d3.simplify will do the opposite and reduce the number of points where the local projection distortion is low.\n. Ooh, I like it!\n. - I'd like to have it on by default, assuming we can work out any performance issues. It automatically resolves quite a few issues with the more distorted projections. Probably the best example is Albers.\nThe recursion depth of 16 feels too high, since this means it could insert up to 65,536 new points for a given point! It sounds like the resampling was recursing too much on the large distances produced by the stereographic projection. So clipping would also help here.\n- Some projections shouldn't cut along the whole antemeridian, since it can introduce a visible cut. In particular, various of the azimuthal projections should ideally clip against a circle of varying angles. The stereographic projection needs virtually no cutting, because the only discontinuity is at the antipode! So any cuts outside of the antipode can potentially be visible.\nSo really it's a matter of deciding how to handle polygons that subsume the antipode, because ideally we'd insert a circle at \"Infinity\" to ensure the fill is on the right side. Another way of thinking about it is that we need to clip against an infinitesimally small circle at the antipode.\nBrowsers seem to slow down when very large px values are introduced. So we should have some kind of reasonably-sized clip circle at the antipode to avoid this.\nRelated to this, I'd like the ability to vary the height of the cut. This means we could create polygonal projections (I believe) with just a single cut, with the cut height being a polygon side length. For example, imagine a cube net.\n- The d3.geo.clip plugin uses a completely new algorithm that can handle holes correctly, and doesn't introduce any artefacts along the clip edge. The only problems with it are: a) it can't handle polygonal self-intersections, which are introduced by d3.simplify, and b) there may be some occasional crashes due to precision errors. I've attempted to fix these in the clip-complex branch. Plus it's slower than naive approaches, since it has to maintain a linked list of intersection points and sort it.\nThe d3.geo.circle in core uses a more naive, but probably more robust approach, where it doesn't care about holes or introducing lines along the clip edge.\nI believe gnomonic needs to be clipped just before 90\u00b0, which might explain the problem you were seeing?  It seems to work at 89\u00b0 for me. Not sure if browser slowdown for large px values is part of the issue closer to 90\u00b0.\nI'd like to rewrite d3.geo.circle using a similar approach to antemeridian cutting with speed as the main priority. The nice thing is that we no longer have to worry about origins, since the world is already rotated for us prior to clipping. So I'd like to start off with just supporting clipping on the great circle going through \u03bb = \u00b190\u00b0. That would be useful for a number of hemispherical projections in general, and should be as fast as antemeridian cutting.\n. Gnomonic projection using d3.geo.circle at 89\u00b0.\n. Interesting idea, it could come in handy! I think clipping in spherical coordinates is still needed to begin with, especially for polygons, to make sure that a) lines don\u2019t cross the discontinuity if there is a cut and b) that an additional ring is inserted in the case of any polygons subsuming the cut. (The cut could be the \u201cpuncture\u201d at the antipode, for some projections.)\n. (Although technically if the antipode is projected to the whole outline, it has to be clipped using a very small circle, rather than a cut.)\n. For avoiding N.O.U.S.'s, a similar effect can be achieved by inverting the px coordinates of the current viewport e.g. assuming [width, height] is the furthest point, and setting the clip angle based on the angular distance from the origin.\nYou can save a few drawing operations this way. I don't think this should be part of the API, since it probably depends on knowledge of the projection in use, but it could be useful pattern/trick.\njs\nvar width = 960,\n    height = 500,\n    projection = d3.geo.stereographic().translate([width / 2, height / 2]);\nprojection.clipAngle(Math.min(179, d3.geo.greatArc()\n    .source(projection.invert(projection.translate()))\n    .target(projection.invert([width, height]))\n    .distance() * 180 / Math.PI)); // ~149\u00b0 at the default scale.\n. Remaining API design decisions:\n1. ~~Should we expose all raw projections via projection.raw()? This would make life a bit easier by removing .scale(1).translate([0, 0]) when creating composite or polyhedral projections, although admittedly this is fairly unusual, so I\u2019d be okay to leave this out for now.~~\n2. Related to the previous point, should the raw projection function that is passed to d3.geo.projection take a coordinates array instead of separate arguments for longitude and latitude? I know I said it was nicer to have separate arguments, but I\u2019m thinking the projection plugin could always have a simple wrapper to make the code more readable, and easy composition seems more beneficial (particularly if we do expose all projections via .raw).\n3. Should we extend .clipAngle to apply to antemeridian cutting? This would allow it to work in the unusual case where you have a polyhedral projection that doesn't cut from pole to pole e.g. a cube. If so, we\u2019d need some other way to distinguish circle vs. meridian clipping e.g. clip(\"meridian\" | \"circle\").\nI guess the only pertinent one is no. 2, and the others are probably okay as they are.\nEdge cases I\u2019d like to address:\n- ~~I\u2019ve spotted an anomaly in some of my own test data: probably something to do with large polygons surrounding the clip area, or self-intersections in general. I\u2019d like to try a different approach to the self-intersection fix, so this might address it.~~\n- There are some minor shortcuts taken when clipping against a circle e.g. it completely ignores two points that are outside the circle, but whose connecting line crosses the circle.\nThese are not serious enough to block a release, though.\nLastly, optimisations: I think one approach could be to use context.lineTo(x, y, z) internally to avoid converting to and from spherical coordinates unnecessarily during both clipping and resampling. I don\u2019t think this affects the public API of context.lineTo(x, y), since we already have context.lineTo(\u03bb, \u03c6) internally, but it\u2019s worth mentioning this just in case.\n. I also plan on adding some tests for edge cases that have been fixed along the way e.g. for clipping.\n. Yes, but only on a per-projection basis. I was wondering if we should automatically expose this for all projections i.e.\njs\nvar projection = d3.geo.projection(raw);\nprojection.raw(); // returns raw projection function\n. Good point. I guess the onus should be on the projection author to optionally add .raw for reusability e.g. most of the projections in the plugin.\n. This also means they\u2019ll work with the default antimeridian cutting when used in the side-by-side configuration. I believe the quincuncial configuration may not even require any cutting at all! It probably still requires an exterior line at the antipode, though, which should project to the outline.\n. Yes.  I think I left this open to deal with the quincuncial configuration.  I was thinking of adding a .quincuncial(true | false) parameter to d3.geo.guyou, although I see you've now added d3.geo.peirceQuincuncial, so maybe it's no longer necessary. :)\n. Good catch, fixed. Thanks!\n. This is because JSON can\u2019t encode Infinity:\n``` js\nJSON.stringify(Infinity)\n\n'null'\n```\n\nI plan on replacing [\u2026, \u2026, \u221e] with something more sensible. Watch this space\u2026\n. I\u2019ve removed \u221e areas in favour of the maximum effective area of topologically connected components, which means islands now get removed correctly if their maximum effective area is below the threshold, and JSON encoding should now work properly.\n. Good idea. An alternative could be a way to turn off clipping and cutting? Then you might just say:\njs\nd3.geo.projection(function(x, y) { return [x, y]; }).clip(false);\nRelated: I\u2019m still interested in having a way to change the height of the antemeridian cutting. So I\u2019m thinking something like .clipAngle would apply to either clipping or cutting. You could then switch between clipping and cutting by using .clip(\"antemeridian\" | \"circle\").\nOne nice side-benefit is that it allows for possible extensions for other types of clipping in future e.g. you could pass a function that takes a GeoJSON object and returns all the LineStrings that need to be joined up in the correct order. So you could clip against arbitrary shapes this way. I\u2019m not saying we should support this, but it\u2019s a possibility if it turns out it\u2019s useful.\nFor d3.simplify, what projection would be best if spherical coordinates are preserved? Perhaps any equal-area projection? I guess it will be useful to preserve coordinates for any cylindrical projection if you only rotate longitudinally, since distortion is constant along lines of latitude, and preserving coordinates means you get antemeridian cutting for free.\n. As well as turning off clipping, you would also need to turn off resampling to avoid introducing artefacts.\n. I assume you mean Bower. :)\nThis works fine with npm. The 3.0 refers to any git ref, in this case the 3.0 branch.\nThe d3.geo.projection plugin in master requires D3 V3 for the tests to pass. I only really added package.json so that you can easily run npm install followed by npm test.\nIt looks like Bower only supports tags at the moment, see twitter/bower#107 for a long and inconclusive discussion about it.\nSince v3.0 is under development, it might be simpler for you to wait until it's released and tagged, and just copy the plugin files that you need in the meantime.  I view d3-plugins more as a collection of plugins rather than a single versioned package, so I prefer to copy individual plugins when I use them.\n. Sorry, looks like my latest commit broke this: mbostock/d3@bedff71625cdc7e3c7ef572a12b663688649cb97.\n. While I fix this, you can roll back to mbostock/d3@ba192eaeea9ebeaa2c97d50a6d188eeb0e92a697 in the 3.0 branch.\n. Okay, fixed in jasondavies/d3@6528f372c7d01b003513c48f0cf848bc79f0a4e2.  I need to look into it in more detail to see why that was causing an issue.\n. Better fix added now. :)\n. Okay, thanks, I'll look into it.\n. I've added another fix. It passes a sm\u00f6rg\u00e5sbord of tests so far.\n. Except for the original one in this issue!\n. The projection plugin relies on D3 version 3, which is scheduled to be released this month.\n. Fixed in 443431c056107f5692b3cf51c316e616e1d8242c.\n. Hi there!  Please use the d3-js Google group or the d3.js tag on Stack Overflow for help.  These issues are for reporting defects and feature requests.\n(You can easily set the number of bands by setting chart.bands(n) e.g. see this example.  If you want to show multiple series then you can indeed just create multiple charts.)\n. This is quite simple to do, but requires a small modification to the tile plugin so that tiles with negative x-coordinates are not excluded.  Rather than include such tiles (which could cause broken images in existing examples), perhaps the best solution would be a new option, wrap([x, y]), where x and y are booleans indicating wrapping in either direction?  Most commonly wrap([true, false]) would be used for maps.\nNote that only tiles with negative coordinates are currently excluded.  The MapBox examples seem to have grey tiles for positive tile coordinates outside the quadtree, but not for negative coordinates.  It might be worth excluding these positive tiles too for consistency, since we currently have grey on the positive edges and white on the negative edges.\nAlternatively we could remove the exclusion of tiles with negative coordinates.  But this would force everyone to filter the resulting tiles to ensure they don't produce broken images, and although the code for wrapping is quite simple, it would be even simpler to have an API for such a common scenario.\n. Hmm, my wrap(\u2026) idea doesn\u2019t work because we still need to generate the negative tiles so that they can be positioned correctly.  The wrapping should occur when generating the URLs.  Here is an example of wrapping, where I\u2019ve removed the 0-clamp from the tile plugin.\n. Maybe tile.overflow, indicating whether tiles outside the quadtree should be generated in either direction?  The default could be [false, false] for backwards compatibility.\n. Possible implementation in #101.\n. Investigating.\n. Hmm. That looks like a working Gringorten?\n. Sorry, caching issue\u2026\n. Should this happen automatically when the distance is set?  It can be easily computed like this:\njs\nprojection.clipAngle(Math.acos(1 / projection.distance()) * 180 / \u03c0 - \u03b5);\n. Yes, I was surprised at the simplicity, but in fact the satellite projection is the view of a point at a given distance above the sphere\u2019s surface, which you can reason about in 2D, so the sphere becomes a circle:\nDraw a line from the satellite to the circle centre (with length D).  Then draw a line from the satellite to its horizon.  This line will be tangent to the circle at the horizon point.  Hence it will be at right-angles to the circle radius at this point, making a right-angle triangle.  We assume the radius is 1 (because D is a multiple of the radius), hence cos \u03b8 = 1 / D.\nI\u2019ve tested this with different tilt angles, and it works quite well, but it looks like tilt angles above a certain amount (around 20\u00b0 for my particular test) result in large values that cause the browser to stop drawing everything properly, and when you clamp the pixel values the projection appears to loop back on itself (above the horizon so not overlapping).  But I think it\u2019s safe to say you wouldn\u2019t actually want to use such angles as the distortion is extremely high.  As you can see, the horizon calculation still looks correct though. :)\n\n. I\u2019m tempted to say that we should automatically set the clip angle by default.  If a clip angle is manually set, then we stop automatically setting it when the satellite distance is set.  What do you think?  Alternatively, we could always set it automatically (and `delete projection.clipAngle), but I\u2019m a bit wary of taking away the ability to set a smaller clip angle.\n. Yes, as I mentioned above I think this is due to extremely large values causing problems for browsers, rather than clipping per se (the example above was generated after clamping return values inside the projection definition).\nI\u2019ll try and think of a solution for this, e.g. we could clamp to \u201csane\u201d values inside the projection as I did above.  That seems like a bit of a hack though; I\u2019d prefer to clip such large values in pixel-space, but of course this is more effort.\n. Nice georeferencing tool. :)  I agree using ogr2ogr is probably the most straightforward option for static maps, although of course it would be quite nice if we could reuse D3\u2019s clipping for this even for static maps.\nAside from pixel-space clipping, another fun possibility could be to take a viewport and project this back to the sphere using projection.invert, and use that for projection.clipPolygon (when it lands!).  Another idea is to take the d3.geo.bounds of the viewport (in spherical coordinates) and use for projection.clipExtent (which should be a little faster, at least until I optimise clipPolygon!), and use in conjunction with clipPath.  These would only really work if the viewport coordinates are all invertible i.e the view is entirely filled, so I still think pixel-space clipping is the better approach (and it may also give us a speed boost, too).\n. I\u2019m experimenting with mbostock/d3#1116.  I think I know how to fix the satellite projection.  Larger tilt values currently still lead to the hourglass effect seen in the screenshot above.  This will occur when points are projected that are greater than 90\u00b0 away from the projection\u2019s tilt.  So this is effectively when the tilt is larger than the clip angle.\nThis can be fixed by clipping a second time (!), and fortunately these points all lie in a small circle.  However, the small circle has a different origin so some rotations need to be applied (this will be simplified when we have arbitrary origins for small circles).\n. http://bl.ocks.org/mbostock/fde1a65845aef4fe33d1 has the same problem.  If the tilt is less than the clipAngle, then it works fine.  Experimental fix coming soon.\n. Here is a possible solution, which clips twice: once for the horizon (this is done via the satellite projection\u2019s clipAngle), and for large enough tilts, a second small circle positioned perpendicularly to the first.\nThe second small circle is implemented using an \u201cidentity\u201d projection whose output is in degrees (note the negative latitude to counteract the default flipped y-coordinate).  In fact, features are clipped against this first, prior to the usual satellite projection clipping.\n. We probably only need to worry about adding ellipsoidal parameters to the handful of projections that are used for large scale mapping for this (thankfully!).  Perhaps we could simply use projectionMutator for this e.g. to provide an ellipsoidal factor.\nThen, we might have a set of ellipsoidal factor definitions for different datums.  (A datum defines a radius too, which we don\u2019t necessarily need for projecting, but could be useful for measuring distances and areas precisely).  As for converting between datums, this is more complicated, but could be done if we think it would be useful.\n. Related: #53.\n. We still want ellipsoidal forms for some projections, because auxiliary latitudes do not give the \u201cpreferred form\u201d of a projection in general.\nMost notably we need an ellipsoidal form to obtain uniform scale along the central meridian for the Transverse Mercator.  The conformal auxiliary latitude applied to spherical Transverse Mercator would give us a true conformal, ellipsoidal Transverse Mercator, but the scale would not be uniform along the central meridian (however, for regular Mercator it works fine).\n. I\u2019d prefer to remove the scale factor from d3.geo.mercator and fix all affected examples.  I think we can make a special exception here as it\u2019s not exactly difficult for people to add the factor back in if they are relying on it at the moment. :)\nThis will also be consistent with d3.geo.conicConformal(0, 0), for which I\u2019ve included an unscaled raw mercator in the plugin.\n. Sounds good!  Adding the other conics would cover the vast majority of common projections used, and of course Transverse Mercator is very widely used e.g. for UTM.\nBTW, I\u2019m thinking of adding ellipsoidal formulations for slightly better accuracy for all of the above, but I can always develop that in the plugin to start with.\n. Managed to improve this to (180 - 1e-5)\u00b0 in d3/d3-geo-projection@4091b28f3d13a98d514e03bc11e480cec7543466.\n. This is unlikely to happen as d3.box relies on SVG, which IE8 doesn\u2019t support.  If you\u2019re stuck with IE8, you could try using Chrome Frame.\n. Thanks.  Adding tests for this now.\n. I\u2019m working on it.  It\u2019s a little more complicated than other projections due to clipping.\n. See here.  This relies on various modifications to D3, so I\u2019ll leave this issue open until they are fully resolved and the map is fully reusable.\n. You have a cycle in that example:\njs\n{\"source\":3,\"target\":0,\"value\":12.0},\n{\"source\":0,\"target\":3,\"value\":2.0},\n. Nice!  A minor improvement could be to use d3.geo.interpolate for center.\n. Perhaps we should consider adding projection.copy(), similar to scale.copy()?  I think we\u2019ve come across other situations where it might have been useful in the past.\n. I\u2019m not sure if it\u2019s really possible to copy projections with custom streams though, like the current implementation of d3.geo.hammerRetroazimuthal.\n. Another idea could be to allow projection.center(null), which would disable center altogether.\n. Very nice!  Yes, my site uses projection.clipPolygon, but strictly speaking you don\u2019t need it for an octahedron because antimeridian cutting (projection.clipAngle(null)) is sufficient.\nI\u2019ll send you further comments when I\u2019ve had a chance to read through properly.  I noticed that the projection itself seems to do additional work to rotate and translate octants, when this could be done by d3.geo.polyhedron (although it might need some tweaks for non-straight sides).  So hopefully we can make this code much shorter. :)\n. I think you might not be using the bullet chart quite like it should be.  If you read Stephen Few\u2019s original paper, you\u2019ll find that he mentions:\n- The featured measure: this is a single, primary measure encoded as a bar.\n- One or two comparative measures: these are encoded as short lines (markers in bullet.js).\nHe only mentions splitting the primary measure into multiple measures under \u201coptional features\u201d.  In fact, the purpose of this is to display a projected target based on the primary measure, not arbitrary comparative measures as you are doing.  In other words, the measures should be an array of [current, projected based on current, \u2026], where it is always the case that current \u2264 projected, so reordering is done to ensure the smaller measure is drawn on top of the larger.\n. I think Stephen intended the current measure to indicate the sum of some metric over part of a time interval, whereas the projected measure would be the same metric extended to cover the whole interval.\nIn your solar radiation example, you appear to be showing an efficiency ratio of energy per peak output, which can\u2019t really be summed in the same manner as if you were showing total energy (e.g. kWh), in which case the projected value will be \u2265 the current value, even if the forecast is bad.\nAnother way of thinking about it is that the splitting of the primary measure (the bar) into two makes it look like a progress bar.  So I think it would be confusing if the colours became swapped, because it will no longer work like a progress bar.\nIf you aren\u2019t using a measure that can be sensibly summed, then I think it\u2019s best to use a single measure, and any comparative measures for the past (or future) should be encoded as markers.\n. Either or both of the following should also work:\n- Use <meta charset=\"utf-8\">.\n- Use <script charset=\"utf-8\" src=\"\u2026\">.\n. Thanks!\n. You can simply swap the meaning of x and y (and rotate the hexagon primitives, of course).  Here is a simple example.\n. Interesting, thanks for the contribution.  See also Mike\u2019s collapsible indented tree.  I\u2019m not sure it necessarily needs a plugin, since the layout computation is already quite simple, but I\u2019ll let Mike comment.\n. I think it\u2019s probably clearer to include parentheses.  If no parentheses are included, then it\u2019s assumed that a numerical radius is bound to each path in that example, which is not the case in the preceding example.\n. Thanks!  It would be even faster if we used a hashtable instead of the linear search (indexOf), but that would require a unique key per object so probably not worth it in this case.\n. Hello, I'm not sure what this is for so I'm closing it.  Looks like it might be an accidental pull request.\n. These GitHub issues are for bug reports and feature requests only.  Please use StackOverflow or the d3-js group for help.\n. These GitHub issues are for bug reports and feature requests only.  It doesn\u2019t sound like an issue with the plugin.\n. Thanks for the report.  I just pushed a slightly better fix: rather than adjusting the position using arbitrary values (which won\u2019t fix the issue in all cases), I simply made the scaling factor 10, which is the maximum value returned by the circular fisheye function.\n. Thanks, I pushed a slightly better fix that handles the case where you might switch from non-vertical to vertical orientation, in which case you have to make sure the transform is removed.\n. This has already been fixed in ef3dcb79.\n. Sounds great. I've made a start!\nFor the simpler projections, should we call the inverse something like hammerInverse? Or perhaps we could add hammer.invert and pass that via projection(hammer, hammer.invert)?\n. I think I've now implemented all the inverse projections that I could do easily.\n. Yes, this lets us support arbitrary aspects (oblique, transverse, polar) for free!\n. I've brought back .origin and added .oblique! I think we can close this, assuming @mbostock is in agreement.\n. This Atlantis aspect is the kind of thing we want to support easily. Your idea of rotating GeoJSON (instead of individual coordinates like it does currently) would simplify this a lot:\njs\nd3.selectAll(\"path\")\n    .data(collection.features)\n  .enter().append(\"path\")\n    .datum(rotate)\n    .attr(\"d\", d3.geo.path().projection(mollweide)\nCurrently, I'm having to clip twice (once for each hemisphere), and effectively I'm rotating for each clip operation too, since I'm specifying a clip origin for the unrotated GeoJSON. It would be much nicer to rotate first and clip afterwards, and hopefully this'll simplify the clipping algorithm somewhat too.\nA d3.geo.clip API may still be useful for azimuthal projections so that an arbitrary angle can be specified. I'll need to work more on the examples and report back!\n. Sounds good!\n. That was quick. :) Just had another idea: you could have yet another optional argument to projection denoting the number of parallels. That might be overloading it a bit too much though? You would need to pass null for a projection with no inverse but 1 or more parallels. It should also pluralise \"parallel\" automatically.\njs\nprojection(forward, inverse);\nprojection(forward, inverse, 1);\nprojection(forward, inverse, 2);\nprojection(forward, inverse, 3); // woah!\n. Ignore this, it would require changing the function signature of the first two arguments.\n. Hmm, it might be nice to reuse internal constants for inverse projections with parallels. Maybe singleParallelProjection and friends should check for a .invert property on the result of projectAt(\u03c60)? Alternatively, I suppose projectAt(\u2026) could return a two-element array?\n. Yes, that's what I settled on in the end. :)\n. It would be worth benchmarking this kind of thing too as I'm never too sure how good modern VMs are at constant folding.\n. I've been testing my inverse projections using a simple set of edge cases (poles, etc.) - I'll see about moving these into a batch of vows tests. Some projections are quite inaccurate near the poles due to slow convergence of Newton\u2013Raphson, so I think it's better to enumerate all cases rather than test for |x - inverse(forward(x))| < \u03b5.\n. /cc @mbostock\n. I think the world-countries.json file bundled with D3 contains only simple polygons (non-self-intersecting), and the clipping seems to work fine there (perhaps with an occasional glitch due to precision error).\n. Actually, I think it's simpler if d3.geo.graticule remains as it is. The outline of interruptions can be specified as a polygon instead, which can then be resampled to obtain a clipping path. I've updated the interrupted sinusoidal projection. Note how I abuse -0. :)\n. (Of course, I can't abuse -0 for other interrupt points; I'll use an offset of Number.MIN_VALUE instead).\n. Ah, good point about Number.MIN_VALUE, thanks!\n. Leaving aside polyhedral maps, the most common type of interruption might look like:\njs\n// Upper and lower interruption longitudes\u2026\nvar lobes = d3.geo.lobes([[-180, 0, 180], [-180, -90, 90, 180]]);\nlobes.outline; // similar to graticule.outline; returns a GeoJSON Polygon\nlobes.projection(d3.geo.sinusoidal()); // sets the projection in use\nlobes([\u03bb, \u03c6]); // projects a point with appropriate offset\nThis would do the menial tasks of computing relative offsets for the outline and translating the projection inputs/outputs appropriately.\n. Here's a proof of concept. This only works for cylindrical projections right now. Conic projections require rotation of gores.\n. Thanks! See also the interrupted Goode Homolosine. :)\n. LOL!\n. Looks good!  I think the resampling part can be dropped entirely, if we ensure that the outline is inset slightly towards the centroid.  This has worked well for me for polyhedra and Berghaus star.  (Note that you don't need an inset at the poles though, this should interpolate to the correct longitude automatically.)\nI'm thinking d3.geo.polyhedron might be able to handle these types of interruptions too; we are cutting the globe into spherical polygons, except that we only want to join the projected faces by a single vertex, rather than an edge.  We can do some cool things particularly with conics if we orient the projected faces according to the meridian at the join point.  Also, it has code to compute inverses (which I will optimise at some point).\nI'd be fine with including this in the plugin for now though.\nYes, I see how \"gore\" could be problematic. :)\n. Splitting features should be pretty straightforward, I think. I'll have a go soon. I was originally thinking to reuse d3.geo.clip, and that would be quite simple (just a matter of modifying the intersection condition to clip against half a great circle). I've made some progress on making it cope with non-simple (self-intersecting) polygons (see clip-complex branch).\nWe could also naively split all polygon rings into two on the clip edge, which would lead to artefacts along the edge in some situations, but perhaps not so important since most map edges will have some kind of graticule outline. This is basically the old algorithm in core.\nAs for azimuthal clipping, most of the time you want to clip against a circle on the sphere. However, in the case of the tilted perspective projection, it's a bit of a special case and the result is some kind of curve. So it would be nice to have some kind of arbitrary visibility function, which some projections could provide (i.e. azimuthal ones). Another example is the vertical perspective, for which you can calculate the precise horizon.\n. I agree about renaming d3.geo.albersEqualArea to d3.geo.conicEqualArea: it's clearer. I think I called it this originally. :)\n. Nice work!\nAnother possibility would be automatically offset the standard parallels internally. I think that would solve the parallels problem? I guess it's also an argument for keeping the rotation encapsulated in the projection, since it needs to know the rotate to be able to do this.\nI'll give the graticule some thought.\n. Hmm, I think you're already offsetting the parallels internally, I need to look at this more carefully.\n. Fixed it! Turns out you had a bug in the latitude rotation.\n. Any ideas about what to call oblique aspects? Maybe we could have projection.oblique(\u00b0)?\n. No worries! :)\nYep, I figured the cost of a few additional multiplications to support both \u03c6 and \u03b3 at once is negligible compared to the trig calls to convert to and from 3-space in rotate\u03c6\u03b3.\nA third argument for \u03b3 could work if we keep .rotate; I wasn't sure if we should just drop .rotate in favour of using .origin and .oblique though?\n. I\u2019ve had similar thoughts about cutting. I think our first concern is, as you say, to split features that cross the antemeridian. This applies to most of our whole-world projections e.g. excluding the orthographic projection (which can show a hemisphere at most) and vertical/tilted perspective projections.\nThe algorithm for doing this is pretty much the same as that used for clipping: you don't throw away polygons on the other side of the edge and just rebuild them in the same way that you would normally do for those that you keep. Similar to clipping, a na\u00efve approach could be used that doesn't properly handle holes (like we have in D3 core) - but maybe this is sufficient since a graticule outline may hide artefacts that would otherwise be visible crossing the holes. I need to investigate this though.\nI\u2019m probably trying to think ahead too much about polygonal projections and interruptions, both of which don't necessarily need additional splitting since clipPath can be used. For example, the Peirce Quincuncial ideally needs to split features along two edges arranged in a cross on the opposite hemisphere though. But I think that eventually supporting an arbitrary set of cutting edges might be quite useful for that.\nLast time I checked, line simplification almost always produces self-intersecting polygons, so I'm not sure it's just Antarctica. Antarctica seems to work fine when I'm clipping world-countries.json, for example. I'd prefer to support self-intersecting polygons if possible though. I think I've cracked it in the clip-complex branch! I see your point about the ambiguity of Antarctica. I'll need to think about whether it's possible to resolve that.\nAgreed about exposing the raw projection methods. How about .forward() and .inverse() for retrieving these from a d3.geo.projection instance?\n. Sharing constants would be nice, yes.\nComposable projections sound useful, although the \u03bb, \u03c6 arguments have been pleasant to work with thus far!\n. How about performing the cutting in d3.geo.path, using the current projection.origin and .oblique to rotate the cut line?\nFor example, most of the time we want to cut along the antemeridian at 180\u00b0E/W. So the cut line could be from <180\u00b0, -90\u00b0> to <180\u00b0, 90\u00b0>. So these start/end points could be transformed using the current .origin and .oblique to appropriate locations, and then cutting can be applied (just before projecting).\nI guess I like the idea of .origin and .oblique, but I'm not sure it's necessary to decouple the rotation if the cut line can simply be rotated too (please correct me if I'm missing something!)\n. Good idea! I think .projectLine could be a great way to add flexibility, while maintaining simple defaults for these projections. We would have a handful of simple internal implementations for these (say, one for azimuthal and another for cylindrical/conics), and something like Peirce Quincuncial could easily be implemented using a custom .projectLine that splits across two edges, perhaps using the public d3.geo.clip and d3.geo.projection.rotation APIs.\n. I've just realised there's a problem with our use of rotations to set origins. I think we're mixing two different concepts here. The concepts are:\n1. Central meridian and standard parallels. These mainly define the longitude of interest (such that its meridian can be vertical, for example when using conics), and the latitudes of \"true scale\". So if we go back to the Albers projection example of the U.S., you were right to use a rotation by longitude only, and then apply a translation so that the U.S. is in the centre of the viewport (or in other words, the \"origin\" in pixel space is the centre of the U.S.).\nHowever, rotating latitudinally introduces a slight distortion compared with just translating in pixel-space. This is because although we had adjusted the standard parallels, they are no longer parallel to the original parallels that have now been rotated! I've tried to illustrate this with an example.\nI feel like using the longitudinal rotation to set the central meridian is just a way to allow the code to be simplified by not requiring a \"central meridian\" parameter, but I'm fine with continuing to do this as I can't see any problem with it.\n2. The second concept is that of an \"origin\" of interest, which could be interpreted either way, but I feel is more about setting an appropriate translation offset so that the feature of interest is centred appropriately.\nSo in conclusion, I think we should probably:\n- restore .rotate(\u03b4\u03bb, \u03b4\u03c6, \u03b4\u03b3) and drop .origin.\n- retain .origin for azimuthal projections (using .rotate as it does now), for backwards-compatibility. I don't know if we want to add some kind of .translateTo(\u2026) convenience method for all projections though.\n. For composing functions, perhaps a simple helper could be useful for this?\njs\nfunction composable(f) {\n  return function(coordinates) {\n    return f.apply(this, coordinates);\n  };\n}\nI mainly enjoy being able to write function(\u03bb, \u03c6) { \u2026 } without the additional few lines for unpacking an array, so maybe we could wrap all projection functions with this when we need it. I don't mind calling projections with projection([\u03bb, \u03c6]) as it's just two additional characters. :)\n. Automatic resampling in d3.geo.path would be great. This would solve the issue of Antarctica in conic projections: hopefully the large delta in pixel-space would be detected, and further points would be projected in between \u27e8\u2212180\u00ba,\u221290\u00ba\u27e9 and \u27e8180\u00ba,\u221290\u00ba\u27e9, for example.\n. By the way, I think the cut in Antarctica is only there since this is along the antemeridian, and inserting it means that cylindrical projections will work out-of-the-box. I think if you assume that all land polygons are smaller than a hemisphere, then there is no ambiguity even if you apply an arbitrary rotation, since you can always detect which side of the line should be the interior.\nThe other possible resolution is the fact that we implicitly assume the exterior ring is clockwise, and the interior rings are anti-clockwise, so that the default fill rule \"just works\" in SVG. I think this alone can also resolve the ambiguity: if you have an exterior ring that appears anti-clockwise from one direction, then you know you need flip your viewpoint and fill on the other side. However, I don't think GeoJSON mandates a particular ordering at the moment, so this may be dependent on what generated the GeoJSON.\nBut I agree it would be a good idea to auto-detect any existing cuts like this and rejoin. So it's not a matter of ignoring points at the poles, it's just a matter of detecting a sequence of points [a, b, a] and replacing with [a]. I think this is more of a generic fix that should be applied to all GeoJSON features that come from shape files that automatically have such cuts, rather than just azimuthals. I guess in a way it should applied when generating the GeoJSON in the first place, but we should be liberal in what we can accept and it's easy enough to implement.\n. As for LineStrings, although this is also not in the spec., I believe it's conventional to always pick the shortest distance if there's an ambiguity e.g. you can't create a 361\u00b0 line using only two points (e.g. you could imagine trying to do this by specifying latitudes outside \u00b1180\u00b0).\n. Regarding the order of rotating, clipping and projecting, I see three possibilities:\n1. Rotate, clip and then project. The advantage is that clipping after rotating can be optimised for the common cases of antemeridian and azimuthal clipping: the antemeridian is simply \u03bb = \u00b1180\u00b0, and the azimuthal projections typically clip against z = 0 or z = some constant value in 3-space, so it seems like this can be more efficient. Although, if we have .projectLine and .projectPolygon, I guess the azimuthal projections may reuse the cos(c) term anyway, which is normally used to determine visibility of points.\n2. Clip, rotate, then project. In this case we need to rotate the clip edge first, so that the \"cut\" becomes the antemeridian when everything is rotated in the second step.\n3. Rotate, project and then clip in pixel-space. I don't think this would always really work: it would involve detecting large enough changes in pixel coordinates and inserting breaks at these points (or interpolating towards the nearest graticule outline).\nI guess this idea of encapsulating clipping/cutting in the projections means the projection can perform the operations in any order, but I thought I may as well note down my thoughts anyway. I think the first option seems best.\n. Sounds great. I like .center([\u03bb, \u03c6])!\n. > But for projections that need to remove cuts, such as azimuthals, I fear generalizing that to [a, b, a] \u21a6 [a] could cause false positives. I guess you could argue that [a, b, a] is a degenerate coordinate sequence, but isn't it safe to assume the cuts are always be at \u27e8\u00b1180\u00ba,\u00b190\u00ba\u27e9?\nCuts can appear at other latitudes too, e.g. Russia in world-countries.json? I think it's safe to assume they only appear on the antemeridian at \u00b1180\u00b0 though. I think we broadly agree; I was just thinking that the cuts aren't only at the poles.\n. Agreed. I was thinking to only keep it for azimuthal projections for backwards-compatibility with D3 core (which I see you're doing at the moment - looks good!) and perhaps even mark it as deprecated in the documentation. I think .oblique can definitely be dropped in favour of .rotate.\n. Great stuff! Perhaps I should move some of d3.geo.clip into projection.js to see how the API handles it? For example, I wonder if projection.polygon should take an array of LinearRings rather than just one LinearRing at time (otherwise I'm not sure how it would correctly clip polygons with holes).\n. Awesome. Looking forward to it!\nI'm preparing d3.geo.clip for use with the new API. Should be a pretty straightforward use of clipLine(lineString) and clipPolygon(rings) where applicable. I'll start with azimuthal projections since I can already clip against circles. Then I'll see about adding support for cutting.\n. Lookin' good.\n. First cut of clipping (for azimuthal projections) is in the new clip branch. This uses the new clipping algorithm, which has the self-intersections caveat that I mentioned previously. A potential fix for this is in the clip-complex branch (although I haven't updated this to use the new API). We could of course use the old d3.geo.circle algorithm as an alternative.\nJust to clarify about clipping, there are a couple of options:\n1. When clipping polygons, each ring can be clipped separately so that the resulting rings are also separate. This can lead to artefacts where the exterior ring crosses what should be a hole, but only along the clip line. So if there is a graticule outline like in many of the current examples, it could cover this up. However, if you didn't want an outline, such as in your Natural Earth Coastlines example, you would see the artefacts (although they only apply to holes, which are fairly rare in practice). The advantage is that it's probably more efficient to implement since you don't need to build a linked list and traverse it in a particular order, and it doesn't care about self-intersections.\n2. The new general algorithm that I've worked on for d3.geo.clip, which uses Weiler-Atherton and at the moment can't handle self-intersections, although I think I've found a fix for this. This works nicely for the Natural Earth Coastlines (although it won't work if you use straightforward line simplification since this introduces self-intersections quite quickly).\nI'm tempted to switch the the first option for the master branch (and possibly for core if it's integrated), and work further on the second for a future version. I'll see how it goes with the self-intersection fix.\nOh, and I'm excited about the automatic resampling! As well as simplifying graticules, it means clipping no longer needs to interpolate between intersection points assuming the clip edge is a great circle (which I think it is in all cases, except maybe tilted perspective).\n. Okay, I think I'll to switch to option no. 1 when I add cutting along the antemeridian. Should simplify the code a lot. :) Proper handling of holes can be restored later if we really want it.\n. The elegance!\njs\nvar path = d3.geo.path()\n    .projection(d3.geo.orthographic()\n      .rotate([0, 0, 45])\n      .translate([width / 2, height / 2]));\nI've reversed the direction of \u03b4\u03b3 as it seems more intuitive for it to denote a clockwise measurement.\n. Great idea. It\u2019s like line simplification but in reverse!\nJust realised something. I was thinking this could potentially simplify the graticules code e.g. you mentioned earlier:\n\nIf projections resample automatically, then d3.geo.graticule doesn't need a precision setting; resampling can be performed by projections as needed (and skipped for cylindrical projections!).\n\nActually, this is not quite correct if we use generic great-circle resampling, since lines of latitude (parallels) are not all great circles, so resampling in between the step points would be slightly off. So to optimise graticules, we may be better off sampling at a higher precision and applying line simplification after projecting.\nOn the other hand I think it could simplify the cutting code, since it could interpolate in between the cut points and use only as many points as are needed, which would be nice.\n. Will move this to the projection branch shortly.\n. Just a note about the graticule precision for conics. The true length of the angular step for the equatorial line is much greater than that for the graticule line at \u03c6=80\u00b0, say.\nSo, imagine rotating the graticule on a sphere, such that the equatorial line is close to the sphere's South Pole. \nSince the distortion is much greater at the poles when using cylindricals and conics, even a precision of 1\u00b0 becomes a large distance in px. And for conics, this low-precision line doesn't follow the curve so it's very obvious. Unfortunately, increasing precision to 0.1\u00b0 makes animating much slower! The same low-precision graticule line appears in cylindricals but it's not noticeable since it's approximately the right shape.\nSo we definitely need some kind of resampling for rotated graticules (or we could use high precision and then simplify). Even if we ended using great-circle resampling, that would avoid this overlap issue and would probably be good enough even though it'll be slightly off compared with true lines of latitude.\n. Yep. It will be great for cases where our input features are of low resolution relative to the local distortion of the projection.\nIf we have very high resolution features, I'm hoping that d3.simplify will do the opposite and reduce the number of points where the local projection distortion is low.\n. Ooh, I like it!\n. - I'd like to have it on by default, assuming we can work out any performance issues. It automatically resolves quite a few issues with the more distorted projections. Probably the best example is Albers.\nThe recursion depth of 16 feels too high, since this means it could insert up to 65,536 new points for a given point! It sounds like the resampling was recursing too much on the large distances produced by the stereographic projection. So clipping would also help here.\n- Some projections shouldn't cut along the whole antemeridian, since it can introduce a visible cut. In particular, various of the azimuthal projections should ideally clip against a circle of varying angles. The stereographic projection needs virtually no cutting, because the only discontinuity is at the antipode! So any cuts outside of the antipode can potentially be visible.\nSo really it's a matter of deciding how to handle polygons that subsume the antipode, because ideally we'd insert a circle at \"Infinity\" to ensure the fill is on the right side. Another way of thinking about it is that we need to clip against an infinitesimally small circle at the antipode.\nBrowsers seem to slow down when very large px values are introduced. So we should have some kind of reasonably-sized clip circle at the antipode to avoid this.\nRelated to this, I'd like the ability to vary the height of the cut. This means we could create polygonal projections (I believe) with just a single cut, with the cut height being a polygon side length. For example, imagine a cube net.\n- The d3.geo.clip plugin uses a completely new algorithm that can handle holes correctly, and doesn't introduce any artefacts along the clip edge. The only problems with it are: a) it can't handle polygonal self-intersections, which are introduced by d3.simplify, and b) there may be some occasional crashes due to precision errors. I've attempted to fix these in the clip-complex branch. Plus it's slower than naive approaches, since it has to maintain a linked list of intersection points and sort it.\nThe d3.geo.circle in core uses a more naive, but probably more robust approach, where it doesn't care about holes or introducing lines along the clip edge.\nI believe gnomonic needs to be clipped just before 90\u00b0, which might explain the problem you were seeing?  It seems to work at 89\u00b0 for me. Not sure if browser slowdown for large px values is part of the issue closer to 90\u00b0.\nI'd like to rewrite d3.geo.circle using a similar approach to antemeridian cutting with speed as the main priority. The nice thing is that we no longer have to worry about origins, since the world is already rotated for us prior to clipping. So I'd like to start off with just supporting clipping on the great circle going through \u03bb = \u00b190\u00b0. That would be useful for a number of hemispherical projections in general, and should be as fast as antemeridian cutting.\n. Gnomonic projection using d3.geo.circle at 89\u00b0.\n. Interesting idea, it could come in handy! I think clipping in spherical coordinates is still needed to begin with, especially for polygons, to make sure that a) lines don\u2019t cross the discontinuity if there is a cut and b) that an additional ring is inserted in the case of any polygons subsuming the cut. (The cut could be the \u201cpuncture\u201d at the antipode, for some projections.)\n. (Although technically if the antipode is projected to the whole outline, it has to be clipped using a very small circle, rather than a cut.)\n. For avoiding N.O.U.S.'s, a similar effect can be achieved by inverting the px coordinates of the current viewport e.g. assuming [width, height] is the furthest point, and setting the clip angle based on the angular distance from the origin.\nYou can save a few drawing operations this way. I don't think this should be part of the API, since it probably depends on knowledge of the projection in use, but it could be useful pattern/trick.\njs\nvar width = 960,\n    height = 500,\n    projection = d3.geo.stereographic().translate([width / 2, height / 2]);\nprojection.clipAngle(Math.min(179, d3.geo.greatArc()\n    .source(projection.invert(projection.translate()))\n    .target(projection.invert([width, height]))\n    .distance() * 180 / Math.PI)); // ~149\u00b0 at the default scale.\n. Remaining API design decisions:\n1. ~~Should we expose all raw projections via projection.raw()? This would make life a bit easier by removing .scale(1).translate([0, 0]) when creating composite or polyhedral projections, although admittedly this is fairly unusual, so I\u2019d be okay to leave this out for now.~~\n2. Related to the previous point, should the raw projection function that is passed to d3.geo.projection take a coordinates array instead of separate arguments for longitude and latitude? I know I said it was nicer to have separate arguments, but I\u2019m thinking the projection plugin could always have a simple wrapper to make the code more readable, and easy composition seems more beneficial (particularly if we do expose all projections via .raw).\n3. Should we extend .clipAngle to apply to antemeridian cutting? This would allow it to work in the unusual case where you have a polyhedral projection that doesn't cut from pole to pole e.g. a cube. If so, we\u2019d need some other way to distinguish circle vs. meridian clipping e.g. clip(\"meridian\" | \"circle\").\nI guess the only pertinent one is no. 2, and the others are probably okay as they are.\nEdge cases I\u2019d like to address:\n- ~~I\u2019ve spotted an anomaly in some of my own test data: probably something to do with large polygons surrounding the clip area, or self-intersections in general. I\u2019d like to try a different approach to the self-intersection fix, so this might address it.~~\n- There are some minor shortcuts taken when clipping against a circle e.g. it completely ignores two points that are outside the circle, but whose connecting line crosses the circle.\nThese are not serious enough to block a release, though.\nLastly, optimisations: I think one approach could be to use context.lineTo(x, y, z) internally to avoid converting to and from spherical coordinates unnecessarily during both clipping and resampling. I don\u2019t think this affects the public API of context.lineTo(x, y), since we already have context.lineTo(\u03bb, \u03c6) internally, but it\u2019s worth mentioning this just in case.\n. I also plan on adding some tests for edge cases that have been fixed along the way e.g. for clipping.\n. Yes, but only on a per-projection basis. I was wondering if we should automatically expose this for all projections i.e.\njs\nvar projection = d3.geo.projection(raw);\nprojection.raw(); // returns raw projection function\n. Good point. I guess the onus should be on the projection author to optionally add .raw for reusability e.g. most of the projections in the plugin.\n. This also means they\u2019ll work with the default antimeridian cutting when used in the side-by-side configuration. I believe the quincuncial configuration may not even require any cutting at all! It probably still requires an exterior line at the antipode, though, which should project to the outline.\n. Yes.  I think I left this open to deal with the quincuncial configuration.  I was thinking of adding a .quincuncial(true | false) parameter to d3.geo.guyou, although I see you've now added d3.geo.peirceQuincuncial, so maybe it's no longer necessary. :)\n. Good catch, fixed. Thanks!\n. This is because JSON can\u2019t encode Infinity:\n``` js\nJSON.stringify(Infinity)\n\n'null'\n```\n\nI plan on replacing [\u2026, \u2026, \u221e] with something more sensible. Watch this space\u2026\n. I\u2019ve removed \u221e areas in favour of the maximum effective area of topologically connected components, which means islands now get removed correctly if their maximum effective area is below the threshold, and JSON encoding should now work properly.\n. Good idea. An alternative could be a way to turn off clipping and cutting? Then you might just say:\njs\nd3.geo.projection(function(x, y) { return [x, y]; }).clip(false);\nRelated: I\u2019m still interested in having a way to change the height of the antemeridian cutting. So I\u2019m thinking something like .clipAngle would apply to either clipping or cutting. You could then switch between clipping and cutting by using .clip(\"antemeridian\" | \"circle\").\nOne nice side-benefit is that it allows for possible extensions for other types of clipping in future e.g. you could pass a function that takes a GeoJSON object and returns all the LineStrings that need to be joined up in the correct order. So you could clip against arbitrary shapes this way. I\u2019m not saying we should support this, but it\u2019s a possibility if it turns out it\u2019s useful.\nFor d3.simplify, what projection would be best if spherical coordinates are preserved? Perhaps any equal-area projection? I guess it will be useful to preserve coordinates for any cylindrical projection if you only rotate longitudinally, since distortion is constant along lines of latitude, and preserving coordinates means you get antemeridian cutting for free.\n. As well as turning off clipping, you would also need to turn off resampling to avoid introducing artefacts.\n. I assume you mean Bower. :)\nThis works fine with npm. The 3.0 refers to any git ref, in this case the 3.0 branch.\nThe d3.geo.projection plugin in master requires D3 V3 for the tests to pass. I only really added package.json so that you can easily run npm install followed by npm test.\nIt looks like Bower only supports tags at the moment, see twitter/bower#107 for a long and inconclusive discussion about it.\nSince v3.0 is under development, it might be simpler for you to wait until it's released and tagged, and just copy the plugin files that you need in the meantime.  I view d3-plugins more as a collection of plugins rather than a single versioned package, so I prefer to copy individual plugins when I use them.\n. Sorry, looks like my latest commit broke this: mbostock/d3@bedff71625cdc7e3c7ef572a12b663688649cb97.\n. While I fix this, you can roll back to mbostock/d3@ba192eaeea9ebeaa2c97d50a6d188eeb0e92a697 in the 3.0 branch.\n. Okay, fixed in jasondavies/d3@6528f372c7d01b003513c48f0cf848bc79f0a4e2.  I need to look into it in more detail to see why that was causing an issue.\n. Better fix added now. :)\n. Okay, thanks, I'll look into it.\n. I've added another fix. It passes a sm\u00f6rg\u00e5sbord of tests so far.\n. Except for the original one in this issue!\n. The projection plugin relies on D3 version 3, which is scheduled to be released this month.\n. Fixed in 443431c056107f5692b3cf51c316e616e1d8242c.\n. Hi there!  Please use the d3-js Google group or the d3.js tag on Stack Overflow for help.  These issues are for reporting defects and feature requests.\n(You can easily set the number of bands by setting chart.bands(n) e.g. see this example.  If you want to show multiple series then you can indeed just create multiple charts.)\n. This is quite simple to do, but requires a small modification to the tile plugin so that tiles with negative x-coordinates are not excluded.  Rather than include such tiles (which could cause broken images in existing examples), perhaps the best solution would be a new option, wrap([x, y]), where x and y are booleans indicating wrapping in either direction?  Most commonly wrap([true, false]) would be used for maps.\nNote that only tiles with negative coordinates are currently excluded.  The MapBox examples seem to have grey tiles for positive tile coordinates outside the quadtree, but not for negative coordinates.  It might be worth excluding these positive tiles too for consistency, since we currently have grey on the positive edges and white on the negative edges.\nAlternatively we could remove the exclusion of tiles with negative coordinates.  But this would force everyone to filter the resulting tiles to ensure they don't produce broken images, and although the code for wrapping is quite simple, it would be even simpler to have an API for such a common scenario.\n. Hmm, my wrap(\u2026) idea doesn\u2019t work because we still need to generate the negative tiles so that they can be positioned correctly.  The wrapping should occur when generating the URLs.  Here is an example of wrapping, where I\u2019ve removed the 0-clamp from the tile plugin.\n. Maybe tile.overflow, indicating whether tiles outside the quadtree should be generated in either direction?  The default could be [false, false] for backwards compatibility.\n. Possible implementation in #101.\n. Investigating.\n. Hmm. That looks like a working Gringorten?\n. Sorry, caching issue\u2026\n. Should this happen automatically when the distance is set?  It can be easily computed like this:\njs\nprojection.clipAngle(Math.acos(1 / projection.distance()) * 180 / \u03c0 - \u03b5);\n. Yes, I was surprised at the simplicity, but in fact the satellite projection is the view of a point at a given distance above the sphere\u2019s surface, which you can reason about in 2D, so the sphere becomes a circle:\nDraw a line from the satellite to the circle centre (with length D).  Then draw a line from the satellite to its horizon.  This line will be tangent to the circle at the horizon point.  Hence it will be at right-angles to the circle radius at this point, making a right-angle triangle.  We assume the radius is 1 (because D is a multiple of the radius), hence cos \u03b8 = 1 / D.\nI\u2019ve tested this with different tilt angles, and it works quite well, but it looks like tilt angles above a certain amount (around 20\u00b0 for my particular test) result in large values that cause the browser to stop drawing everything properly, and when you clamp the pixel values the projection appears to loop back on itself (above the horizon so not overlapping).  But I think it\u2019s safe to say you wouldn\u2019t actually want to use such angles as the distortion is extremely high.  As you can see, the horizon calculation still looks correct though. :)\n\n. I\u2019m tempted to say that we should automatically set the clip angle by default.  If a clip angle is manually set, then we stop automatically setting it when the satellite distance is set.  What do you think?  Alternatively, we could always set it automatically (and `delete projection.clipAngle), but I\u2019m a bit wary of taking away the ability to set a smaller clip angle.\n. Yes, as I mentioned above I think this is due to extremely large values causing problems for browsers, rather than clipping per se (the example above was generated after clamping return values inside the projection definition).\nI\u2019ll try and think of a solution for this, e.g. we could clamp to \u201csane\u201d values inside the projection as I did above.  That seems like a bit of a hack though; I\u2019d prefer to clip such large values in pixel-space, but of course this is more effort.\n. Nice georeferencing tool. :)  I agree using ogr2ogr is probably the most straightforward option for static maps, although of course it would be quite nice if we could reuse D3\u2019s clipping for this even for static maps.\nAside from pixel-space clipping, another fun possibility could be to take a viewport and project this back to the sphere using projection.invert, and use that for projection.clipPolygon (when it lands!).  Another idea is to take the d3.geo.bounds of the viewport (in spherical coordinates) and use for projection.clipExtent (which should be a little faster, at least until I optimise clipPolygon!), and use in conjunction with clipPath.  These would only really work if the viewport coordinates are all invertible i.e the view is entirely filled, so I still think pixel-space clipping is the better approach (and it may also give us a speed boost, too).\n. I\u2019m experimenting with mbostock/d3#1116.  I think I know how to fix the satellite projection.  Larger tilt values currently still lead to the hourglass effect seen in the screenshot above.  This will occur when points are projected that are greater than 90\u00b0 away from the projection\u2019s tilt.  So this is effectively when the tilt is larger than the clip angle.\nThis can be fixed by clipping a second time (!), and fortunately these points all lie in a small circle.  However, the small circle has a different origin so some rotations need to be applied (this will be simplified when we have arbitrary origins for small circles).\n. http://bl.ocks.org/mbostock/fde1a65845aef4fe33d1 has the same problem.  If the tilt is less than the clipAngle, then it works fine.  Experimental fix coming soon.\n. Here is a possible solution, which clips twice: once for the horizon (this is done via the satellite projection\u2019s clipAngle), and for large enough tilts, a second small circle positioned perpendicularly to the first.\nThe second small circle is implemented using an \u201cidentity\u201d projection whose output is in degrees (note the negative latitude to counteract the default flipped y-coordinate).  In fact, features are clipped against this first, prior to the usual satellite projection clipping.\n. We probably only need to worry about adding ellipsoidal parameters to the handful of projections that are used for large scale mapping for this (thankfully!).  Perhaps we could simply use projectionMutator for this e.g. to provide an ellipsoidal factor.\nThen, we might have a set of ellipsoidal factor definitions for different datums.  (A datum defines a radius too, which we don\u2019t necessarily need for projecting, but could be useful for measuring distances and areas precisely).  As for converting between datums, this is more complicated, but could be done if we think it would be useful.\n. Related: #53.\n. We still want ellipsoidal forms for some projections, because auxiliary latitudes do not give the \u201cpreferred form\u201d of a projection in general.\nMost notably we need an ellipsoidal form to obtain uniform scale along the central meridian for the Transverse Mercator.  The conformal auxiliary latitude applied to spherical Transverse Mercator would give us a true conformal, ellipsoidal Transverse Mercator, but the scale would not be uniform along the central meridian (however, for regular Mercator it works fine).\n. I\u2019d prefer to remove the scale factor from d3.geo.mercator and fix all affected examples.  I think we can make a special exception here as it\u2019s not exactly difficult for people to add the factor back in if they are relying on it at the moment. :)\nThis will also be consistent with d3.geo.conicConformal(0, 0), for which I\u2019ve included an unscaled raw mercator in the plugin.\n. Sounds good!  Adding the other conics would cover the vast majority of common projections used, and of course Transverse Mercator is very widely used e.g. for UTM.\nBTW, I\u2019m thinking of adding ellipsoidal formulations for slightly better accuracy for all of the above, but I can always develop that in the plugin to start with.\n. Managed to improve this to (180 - 1e-5)\u00b0 in d3/d3-geo-projection@4091b28f3d13a98d514e03bc11e480cec7543466.\n. This is unlikely to happen as d3.box relies on SVG, which IE8 doesn\u2019t support.  If you\u2019re stuck with IE8, you could try using Chrome Frame.\n. Thanks.  Adding tests for this now.\n. I\u2019m working on it.  It\u2019s a little more complicated than other projections due to clipping.\n. See here.  This relies on various modifications to D3, so I\u2019ll leave this issue open until they are fully resolved and the map is fully reusable.\n. You have a cycle in that example:\njs\n{\"source\":3,\"target\":0,\"value\":12.0},\n{\"source\":0,\"target\":3,\"value\":2.0},\n. Nice!  A minor improvement could be to use d3.geo.interpolate for center.\n. Perhaps we should consider adding projection.copy(), similar to scale.copy()?  I think we\u2019ve come across other situations where it might have been useful in the past.\n. I\u2019m not sure if it\u2019s really possible to copy projections with custom streams though, like the current implementation of d3.geo.hammerRetroazimuthal.\n. Another idea could be to allow projection.center(null), which would disable center altogether.\n. Very nice!  Yes, my site uses projection.clipPolygon, but strictly speaking you don\u2019t need it for an octahedron because antimeridian cutting (projection.clipAngle(null)) is sufficient.\nI\u2019ll send you further comments when I\u2019ve had a chance to read through properly.  I noticed that the projection itself seems to do additional work to rotate and translate octants, when this could be done by d3.geo.polyhedron (although it might need some tweaks for non-straight sides).  So hopefully we can make this code much shorter. :)\n. I think you might not be using the bullet chart quite like it should be.  If you read Stephen Few\u2019s original paper, you\u2019ll find that he mentions:\n- The featured measure: this is a single, primary measure encoded as a bar.\n- One or two comparative measures: these are encoded as short lines (markers in bullet.js).\nHe only mentions splitting the primary measure into multiple measures under \u201coptional features\u201d.  In fact, the purpose of this is to display a projected target based on the primary measure, not arbitrary comparative measures as you are doing.  In other words, the measures should be an array of [current, projected based on current, \u2026], where it is always the case that current \u2264 projected, so reordering is done to ensure the smaller measure is drawn on top of the larger.\n. I think Stephen intended the current measure to indicate the sum of some metric over part of a time interval, whereas the projected measure would be the same metric extended to cover the whole interval.\nIn your solar radiation example, you appear to be showing an efficiency ratio of energy per peak output, which can\u2019t really be summed in the same manner as if you were showing total energy (e.g. kWh), in which case the projected value will be \u2265 the current value, even if the forecast is bad.\nAnother way of thinking about it is that the splitting of the primary measure (the bar) into two makes it look like a progress bar.  So I think it would be confusing if the colours became swapped, because it will no longer work like a progress bar.\nIf you aren\u2019t using a measure that can be sensibly summed, then I think it\u2019s best to use a single measure, and any comparative measures for the past (or future) should be encoded as markers.\n. Either or both of the following should also work:\n- Use <meta charset=\"utf-8\">.\n- Use <script charset=\"utf-8\" src=\"\u2026\">.\n. Thanks!\n. You can simply swap the meaning of x and y (and rotate the hexagon primitives, of course).  Here is a simple example.\n. Interesting, thanks for the contribution.  See also Mike\u2019s collapsible indented tree.  I\u2019m not sure it necessarily needs a plugin, since the layout computation is already quite simple, but I\u2019ll let Mike comment.\n. I think it\u2019s probably clearer to include parentheses.  If no parentheses are included, then it\u2019s assumed that a numerical radius is bound to each path in that example, which is not the case in the preceding example.\n. Thanks!  It would be even faster if we used a hashtable instead of the linear search (indexOf), but that would require a unique key per object so probably not worth it in this case.\n. Hello, I'm not sure what this is for so I'm closing it.  Looks like it might be an accidental pull request.\n. These GitHub issues are for bug reports and feature requests only.  Please use StackOverflow or the d3-js group for help.\n. These GitHub issues are for bug reports and feature requests only.  It doesn\u2019t sound like an issue with the plugin.\n. Thanks for the report.  I just pushed a slightly better fix: rather than adjusting the position using arbitrary values (which won\u2019t fix the issue in all cases), I simply made the scaling factor 10, which is the maximum value returned by the circular fisheye function.\n. Thanks, I pushed a slightly better fix that handles the case where you might switch from non-vertical to vertical orientation, in which case you have to make sure the transform is removed.\n. ",
    "radiodario": "do you mean stereographic projections? otherwise could you elaborate?\n. Also you guys might want to look at miso dataset, it provides pretty much\nthis functionality!\nhttp://misoproject.com/dataset/\nOn Mon, Oct 8, 2012 at 4:10 PM, Mike Bostock notifications@github.comwrote:\n\nI'd prefer a more descriptive name (say, \"d3.query\"?). And again, I'll\nreiterate my question: why make this a D3 plugin if there are no\ndependencies on D3? Why not offer this as a standalone library with broader\napplicability?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/d3/d3-plugins/pull/19#issuecomment-9228889.\n. do you mean stereographic projections? otherwise could you elaborate?\n. Also you guys might want to look at miso dataset, it provides pretty much\nthis functionality!\n\nhttp://misoproject.com/dataset/\nOn Mon, Oct 8, 2012 at 4:10 PM, Mike Bostock notifications@github.comwrote:\n\nI'd prefer a more descriptive name (say, \"d3.query\"?). And again, I'll\nreiterate my question: why make this a D3 plugin if there are no\ndependencies on D3? Why not offer this as a standalone library with broader\napplicability?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/d3/d3-plugins/pull/19#issuecomment-9228889.\n. \n",
    "syntagmatic": "radiodario: http://en.wikipedia.org/wiki/Inverse_function\nFor example, you could go from the x,y mouse coordinates back to the lat/long coordinates.\n. Also reminds me of Datavore and Underscore.js\nhttps://github.com/StanfordHCI/datavore\nhttp://underscorejs.org/\n. Is this example what you're looking for? http://bl.ocks.org/jasondavies/f5922ed4d0ac1ac2161f\n. =)\n. radiodario: http://en.wikipedia.org/wiki/Inverse_function\nFor example, you could go from the x,y mouse coordinates back to the lat/long coordinates.\n. Also reminds me of Datavore and Underscore.js\nhttps://github.com/StanfordHCI/datavore\nhttp://underscorejs.org/\n. Is this example what you're looking for? http://bl.ocks.org/jasondavies/f5922ed4d0ac1ac2161f\n. =)\n. ",
    "deciob": "Hemmm... from someone with a geography background I find this work amazing! The interrupted Goode Homolosine left me almost breathless. Beautiful!\n. Hemmm... from someone with a geography background I find this work amazing! The interrupted Goode Homolosine left me almost breathless. Beautiful!\n. ",
    "billierinaldi": "Here's a demo of overlapping links: http://bl.ocks.org/d/3779574/\nand a demo of using a minimum value: http://bl.ocks.org/d/3782601/\nFor the minimum value demo, I loaded two links, one with value 10 and one without a value.  I believe the \"original\" display accurately mimicks the behavior with no minimum value by setting its minValue to 0.\n. Hey, have you had a chance to take a look at the demos?  Any thoughts?\n. Here's a demo of overlapping links: http://bl.ocks.org/d/3779574/\nand a demo of using a minimum value: http://bl.ocks.org/d/3782601/\nFor the minimum value demo, I loaded two links, one with value 10 and one without a value.  I believe the \"original\" display accurately mimicks the behavior with no minimum value by setting its minValue to 0.\n. Hey, have you had a chance to take a look at the demos?  Any thoughts?\n. ",
    "tuckerpm": "I like the overlapped idea, but feel like if it could still stack certain paths it might be a little bit easier on the eye.\nFor instance, take a look at \"Thermal Generation\".  Gas could come after Solid and not cause any vertical spacing issues.  A better example would be \"Electricity Grid\".  All of those tiny lines get crushed together to form a dark blob.  If they were rotated down until they fill the height, then add another level and rotate down again, I think the visualization would be better.\nGreat job BTW!\n. I like the overlapped idea, but feel like if it could still stack certain paths it might be a little bit easier on the eye.\nFor instance, take a look at \"Thermal Generation\".  Gas could come after Solid and not cause any vertical spacing issues.  A better example would be \"Electricity Grid\".  All of those tiny lines get crushed together to form a dark blob.  If they were rotated down until they fill the height, then add another level and rotate down again, I think the visualization would be better.\nGreat job BTW!\n. ",
    "colinyzhao": "I just created a variation of the D3.js Sankey diagram to visualize the many-to-many relationships between the stacks of the entities, that I want to use for enterprise architecture application.  Here is the gist: \nhttps://gist.github.com/colinyzhao/5649114\nand the demo\nhttp://bl.ocks.org/colinyzhao/5649114\nThe height of the node is based on node value.  The link has two values, sourceCount (value) and targetCount.  The node has three more fields to further constraint the width of the link/path calculation.  Link can overlap at the source and target node.\n. I just created a variation of the D3.js Sankey diagram to visualize the many-to-many relationships between the stacks of the entities, that I want to use for enterprise architecture application.  Here is the gist: \nhttps://gist.github.com/colinyzhao/5649114\nand the demo\nhttp://bl.ocks.org/colinyzhao/5649114\nThe height of the node is based on node value.  The link has two values, sourceCount (value) and targetCount.  The node has three more fields to further constraint the width of the link/path calculation.  Link can overlap at the source and target node.\n. ",
    "muddydixon": "sorry, I failed to see your question.\nThank you. \n. And thank you radiodario.\nI bookmarked miso before but I forgot it !\n. sorry, I failed to see your question.\nThank you. \n. And thank you radiodario.\nI bookmarked miso before but I forgot it !\n. ",
    "RandomEtc": "Fixed some silly stuff and force pushed a better commit. Tests for d3-simplify pass for me now.\n. Thanks guys - I'll close this pull request. I just felt bad filing issues piece-wise against this feature if there was a (straw man) solution I could offer myself.\nI get what the value is there for now so I'll strip it myself in my conversion script.\n. Fixed some silly stuff and force pushed a better commit. Tests for d3-simplify pass for me now.\n. Thanks guys - I'll close this pull request. I just felt bad filing issues piece-wise against this feature if there was a (straw man) solution I could offer myself.\nI get what the value is there for now so I'll strip it myself in my conversion script.\n. ",
    "shawnbot": "Er yeah, Bower :)\nFair enough, though. I was just starting to like the idea of doing bower install d3-plugins to get them into a new project. I'm happy to keep a checkout of d3-plugins around and copy individual plugins as needed for now. Thanks!\n. So awesome, Mike. I'm going to close this, then, in the hopes that TopoJSON will do what I'm looking for.\n. Er yeah, Bower :)\nFair enough, though. I was just starting to like the idea of doing bower install d3-plugins to get them into a new project. I'm happy to keep a checkout of d3-plugins around and copy individual plugins as needed for now. Thanks!\n. So awesome, Mike. I'm going to close this, then, in the hopes that TopoJSON will do what I'm looking for.\n. ",
    "thudfactor": "Y'all are scary. \nSince my proof-of-concept is pulling from Github, you can see my test case working now. I'd close this but it looks like the two of you are still tracking down a few other edge cases.\n. Y'all are scary. \nSince my proof-of-concept is pulling from Github, you can see my test case working now. I'd close this but it looks like the two of you are still tracking down a few other edge cases.\n. ",
    "vallettea": "ok thanks and sorry\n2012/12/7 Mike Bostock notifications@github.com\n\nAlso, please use Stack Overflow tag d3.js or the d3-js Google group for\nhelp.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/d3/d3-plugins/issues/28#issuecomment-11141503.\n. ok thanks and sorry\n\n2012/12/7 Mike Bostock notifications@github.com\n\nAlso, please use Stack Overflow tag d3.js or the d3-js Google group for\nhelp.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/d3/d3-plugins/issues/28#issuecomment-11141503.\n. \n",
    "tmcw": "Sure, added in 6d695f262130225f6b9ff3d6205ab8e4c940059c\n. We've implemented all of the basic APIs, zoom, center, extent, etc in iD, but they're not generalized currently: https://github.com/systemed/iD/blob/master/js/id/renderer/map.js#L213 (demo: http://geowiki.com/iD/ )\n(iD's background layer also supports backbuffering and such)\n. Trying to switch to .center() with iD (after getting the aha that translate() is non-geographical) and it's pretty fearsome resolving zoomPan's talking only in translate and projection talking in geographical units and not being able to get 'non-geographical' translates together. Is there any chance of the zoom behavior talking in geographical units or the projection code being able to talk in translates?\nFor instance, right now, projection(foo) can give you the screen coords of a feature, but not the 'from origin translate' of that feature. The approach so far has been to keep the zoom behavior & projection in sync (via scale & translate). Using center, this is a lot less clear (relevant code: https://github.com/systemed/iD/blob/7cda89b75753b9ad4d300e267bae5b0f5f86995c/js/id/renderer/map.js#L135 ).\n. Ah, okay - that's essentially the approach we were doing before, though it makes functions that set center & zoom programmatically significantly more complex: https://github.com/systemed/iD/blob/master/js/id/renderer/map.js#L213\n. Anyway, I've got to :+1:  the idea of coordinates as a plugin and would be happy to write it. At the moment, a basic 'd3 + tiles demo' with zoom in and zoom out buttons is very non-obvious.\n. The advantage of the other way was that you don't pollute the global namespace at all, and there's no chance of overwriting functions. If we're going to switch approaches, this should at least use a predictable prefix to ensure that it doesn't generate an already-used name and overwrite it.\n. Yep, that would work - this is admittedly an unlikely failure but would fail pretty hard when it does.\n. I don't think so: hexagon.hexbin is a function that will be called with data to get the attribute d.\n. :-1: I would rather have code fail loudly than fail silently: if you have a d3 plugin on your page and it says \"ReferenceError: d3 not found\" then you have a hint. If it's just hums along, you don't.\n. Sure, added in 6d695f262130225f6b9ff3d6205ab8e4c940059c\n. We've implemented all of the basic APIs, zoom, center, extent, etc in iD, but they're not generalized currently: https://github.com/systemed/iD/blob/master/js/id/renderer/map.js#L213 (demo: http://geowiki.com/iD/ )\n(iD's background layer also supports backbuffering and such)\n. Trying to switch to .center() with iD (after getting the aha that translate() is non-geographical) and it's pretty fearsome resolving zoomPan's talking only in translate and projection talking in geographical units and not being able to get 'non-geographical' translates together. Is there any chance of the zoom behavior talking in geographical units or the projection code being able to talk in translates?\nFor instance, right now, projection(foo) can give you the screen coords of a feature, but not the 'from origin translate' of that feature. The approach so far has been to keep the zoom behavior & projection in sync (via scale & translate). Using center, this is a lot less clear (relevant code: https://github.com/systemed/iD/blob/7cda89b75753b9ad4d300e267bae5b0f5f86995c/js/id/renderer/map.js#L135 ).\n. Ah, okay - that's essentially the approach we were doing before, though it makes functions that set center & zoom programmatically significantly more complex: https://github.com/systemed/iD/blob/master/js/id/renderer/map.js#L213\n. Anyway, I've got to :+1:  the idea of coordinates as a plugin and would be happy to write it. At the moment, a basic 'd3 + tiles demo' with zoom in and zoom out buttons is very non-obvious.\n. The advantage of the other way was that you don't pollute the global namespace at all, and there's no chance of overwriting functions. If we're going to switch approaches, this should at least use a predictable prefix to ensure that it doesn't generate an already-used name and overwrite it.\n. Yep, that would work - this is admittedly an unlikely failure but would fail pretty hard when it does.\n. I don't think so: hexagon.hexbin is a function that will be called with data to get the attribute d.\n. :-1: I would rather have code fail loudly than fail silently: if you have a d3 plugin on your page and it says \"ReferenceError: d3 not found\" then you have a hint. If it's just hums along, you don't.\n. ",
    "ghedamat": "I understand, my knowledge of the sankey diagrams is not deep unfortunately :(\nThis fix suits my actual needs but I guess we should probably look for another solution for those graphical quirks,\nif you have any better solution/idea let me know, I'll be happy to give it a try!\n. I understand, my knowledge of the sankey diagrams is not deep unfortunately :(\nThis fix suits my actual needs but I guess we should probably look for another solution for those graphical quirks,\nif you have any better solution/idea let me know, I'll be happy to give it a try!\n. ",
    "migurski": "No kidding @tmcw that code is pretty fearsome. I\u2019m sitting this one out, no plans to use d3.tile.\n. Probably time for a pyramid-aware \u201cCoordinate\u201d abstraction between geography and pixels.\n. I\u2019m referring to the quadtree, and there\u2019s definitely reason to expose the third coordinate system. Being able to \u201cspeak tile\u201d and have English-looking words for concepts like tile-to-the-right, tile-one-zoom-out-from-this-one and so on is huge, huge, huge when you need to sync image and non-image layers. UTFGrid interaction layers, vector data loading, and multi-zoom pyramid loading to eliminate the flash of unloaded tiles are three examples. The density of the code snippets in this thread is another: the tile concept is implied in the serial calls to translate() and the recursive (?) use of projection, but it would be easier to see and reason about if exposed as a first-class concept with words and stuff.\n. Where I see the tile system implied is in the bit-shifted zoom levels passed to scale() and the calls to Math.pow in the iD code. In the mercator code, D3 already transforms the raw projection by 1/(2\u03c0) so the tile math starts there, and ends up sort-of scattered throughout the chain. I agree that it\u2019s not required to expose the coordinates to use tile, I just think it would be better and more composable implementation if it was exposed legibly.\nIn Modest Maps, I chose a coupling that\u2019s actually quite similar to the one you\u2019re trying to avoid, so this might be a matter of taste. =) MMaps projections know about tile coordinates but not about pixels, so they have an explicit post-projection affine transformation, typically from \u00b1\u03c0 to 0\u20261 for spherical mercator. Maps know about tile coordinates and pixels but not geography, so they defer to the projection to perform that translation. Tile providers link the two together.\nI\u2019ve found it very helpful for additional work to have that available.\n. Yeah so I kinda went and scratched a whole bunch of itches at once with this: https://github.com/migurski/Squares#readme\nIncludes the first-class quadtree I've been talking about, mostly ported from @RandomEtc\u2019s 2011 D3 + tiles exercise.\n. I\u2019ll have a look, thanks. The DIV-based scroll thingie does have quite different rates in FFox vs. Chrome, with Safari someplace in the middle.\n. I think d3.behavior.zoom is going to be a dead-end for me. Based on the example I could find, which I only sort-of understand, it looks like something that you call() individually for each element that gets appended in an enter selection? I need it to be something applied to the map as a whole. I\u2019ll instead port the non-DIV approach from the patch.\n. I tried both combinations, and got no movement either time. I suspect that I'm not putting the pieces together correctly, so I\u2019m not going to pursue D3 behaviors any further for the time being.\nI also tried porting over the new mousewheel support from the commit you linked to above (https://github.com/migurski/Squares/commit/1d04b8f0). It sort-of works, but Safari reports 10x the movement that Chrome does, so the zooming behavior appears wildly erratic, much moreso than with the hidden div. I'll leave it the way it was previously.\n. No kidding @tmcw that code is pretty fearsome. I\u2019m sitting this one out, no plans to use d3.tile.\n. Probably time for a pyramid-aware \u201cCoordinate\u201d abstraction between geography and pixels.\n. I\u2019m referring to the quadtree, and there\u2019s definitely reason to expose the third coordinate system. Being able to \u201cspeak tile\u201d and have English-looking words for concepts like tile-to-the-right, tile-one-zoom-out-from-this-one and so on is huge, huge, huge when you need to sync image and non-image layers. UTFGrid interaction layers, vector data loading, and multi-zoom pyramid loading to eliminate the flash of unloaded tiles are three examples. The density of the code snippets in this thread is another: the tile concept is implied in the serial calls to translate() and the recursive (?) use of projection, but it would be easier to see and reason about if exposed as a first-class concept with words and stuff.\n. Where I see the tile system implied is in the bit-shifted zoom levels passed to scale() and the calls to Math.pow in the iD code. In the mercator code, D3 already transforms the raw projection by 1/(2\u03c0) so the tile math starts there, and ends up sort-of scattered throughout the chain. I agree that it\u2019s not required to expose the coordinates to use tile, I just think it would be better and more composable implementation if it was exposed legibly.\nIn Modest Maps, I chose a coupling that\u2019s actually quite similar to the one you\u2019re trying to avoid, so this might be a matter of taste. =) MMaps projections know about tile coordinates but not about pixels, so they have an explicit post-projection affine transformation, typically from \u00b1\u03c0 to 0\u20261 for spherical mercator. Maps know about tile coordinates and pixels but not geography, so they defer to the projection to perform that translation. Tile providers link the two together.\nI\u2019ve found it very helpful for additional work to have that available.\n. Yeah so I kinda went and scratched a whole bunch of itches at once with this: https://github.com/migurski/Squares#readme\nIncludes the first-class quadtree I've been talking about, mostly ported from @RandomEtc\u2019s 2011 D3 + tiles exercise.\n. I\u2019ll have a look, thanks. The DIV-based scroll thingie does have quite different rates in FFox vs. Chrome, with Safari someplace in the middle.\n. I think d3.behavior.zoom is going to be a dead-end for me. Based on the example I could find, which I only sort-of understand, it looks like something that you call() individually for each element that gets appended in an enter selection? I need it to be something applied to the map as a whole. I\u2019ll instead port the non-DIV approach from the patch.\n. I tried both combinations, and got no movement either time. I suspect that I'm not putting the pieces together correctly, so I\u2019m not going to pursue D3 behaviors any further for the time being.\nI also tried porting over the new mousewheel support from the commit you linked to above (https://github.com/migurski/Squares/commit/1d04b8f0). It sort-of works, but Safari reports 10x the movement that Chrome does, so the zooming behavior appears wildly erratic, much moreso than with the hidden div. I'll leave it the way it was previously.\n. ",
    "tnightingale": "I'm not particularly familiar with the code and therefore not sure whether this is an ideal (or even functional) fix. I just noticed http://bl.ocks.org/4330486 is broken, and it was working for me yesterday (I had it working in a tab that I left open).\n. Ugh, looking back at 30d74327e60504d9c017194306f981a8a307ba08, this change likely breaks hexbin.mesh().\n. I'm not particularly familiar with the code and therefore not sure whether this is an ideal (or even functional) fix. I just noticed http://bl.ocks.org/4330486 is broken, and it was working for me yesterday (I had it working in a tab that I left open).\n. Ugh, looking back at 30d74327e60504d9c017194306f981a8a307ba08, this change likely breaks hexbin.mesh().\n. ",
    "d3noob": "Nice work! I like the visual technique you've used for the loop back. \n. Nice work! I like the visual technique you've used for the loop back. \n. ",
    "itay": "@mbostock: was this ever checked into the main repo? If not, is there an ETA?\nWe have a case where we are dynamically getting data for Sankey, and having it work with loops would be nice, otherwise it causes a hang.\n. Thought I'd check in again - we've tried the suggested code ourselves, and it works pretty well. I'd love to see this integrated into the official sankey code.\n. @kunalb: that's fair, thank you for pointing it out. I guess my main concern is that the current behavior with cycles is to cause the entire tab to crash essentially, since it is in an infinite loop. If it even just errored, that would be a start. Do you think it would be possible to modify your pull request to detect cycles and then throw an event?\n. @kunalb first of, thank you for adding that separate pull request. A quick question for you: with this pull request (adding cyclic link support), are there cases where some data without cycles is rendered worse than the old version (the one in d3-plugins)? Basically, is your PR regressing anything?\nIf not, it seems this is a net improvement, and one that we could iterate on. \nThe reason I'm pushing on this particular item is that we'd really like to include sankey visualization support in something that we're doing, but it's kind of a bummer that it either hangs/errors if your data has cycles. This is especially problematic for us because our data is dynamic and we can't control whether it is cyclic or not.\n@mbostock: what can we do to help get this issue solved?\n. @mbostock: was this ever checked into the main repo? If not, is there an ETA?\nWe have a case where we are dynamically getting data for Sankey, and having it work with loops would be nice, otherwise it causes a hang.\n. Thought I'd check in again - we've tried the suggested code ourselves, and it works pretty well. I'd love to see this integrated into the official sankey code.\n. @kunalb: that's fair, thank you for pointing it out. I guess my main concern is that the current behavior with cycles is to cause the entire tab to crash essentially, since it is in an infinite loop. If it even just errored, that would be a start. Do you think it would be possible to modify your pull request to detect cycles and then throw an event?\n. @kunalb first of, thank you for adding that separate pull request. A quick question for you: with this pull request (adding cyclic link support), are there cases where some data without cycles is rendered worse than the old version (the one in d3-plugins)? Basically, is your PR regressing anything?\nIf not, it seems this is a net improvement, and one that we could iterate on. \nThe reason I'm pushing on this particular item is that we'd really like to include sankey visualization support in something that we're doing, but it's kind of a bummer that it either hangs/errors if your data has cycles. This is especially problematic for us because our data is dynamic and we can't control whether it is cyclic or not.\n@mbostock: what can we do to help get this issue solved?\n. ",
    "pkpp1233": "Running into the same problem. Any best practice when dealing with circular reference or standard code to follow?\n. any idea of the best way to handle cycles if you're pulling a foreign dataset?\n. Running into the same problem. Any best practice when dealing with circular reference or standard code to follow?\n. any idea of the best way to handle cycles if you're pulling a foreign dataset?\n. ",
    "josephsiu": "@kunalb I know this is kind of old, but I tried using your sankey.js but my simple cycle sankey isn't rendering. Is there an update to D3 which breaks this?\n. @kunalb Sorry for the false alarm. It was a separate issue. Your edits worked great for cycles! Thanks!\n. @kunalb I know this is kind of old, but I tried using your sankey.js but my simple cycle sankey isn't rendering. Is there an update to D3 which breaks this?\n. @kunalb Sorry for the false alarm. It was a separate issue. Your edits worked great for cycles! Thanks!\n. ",
    "NPC": "@kunalb, both of the examples (http://bl.ocks.org/kunalb/4658510 and http://bl.ocks.org/kunalb/5140332) fail to run in Chrome, the console complains about wrong MIME type for sankey.js, not sure if this is something happened with the last changes, or just the Gists are acting up\u2026\n. @kunalb, wow, these look neat. Thanks for the updated example!\n. This is an excellent idea, I hope it gets included. As far as I understand, the x position value is an integer \u201cstep number\u201d, not an actual horizontal coordinate?\nThanks for proposing this enhancement!\n. @kunalb, both of the examples (http://bl.ocks.org/kunalb/4658510 and http://bl.ocks.org/kunalb/5140332) fail to run in Chrome, the console complains about wrong MIME type for sankey.js, not sure if this is something happened with the last changes, or just the Gists are acting up\u2026\n. @kunalb, wow, these look neat. Thanks for the updated example!\n. This is an excellent idea, I hope it gets included. As far as I understand, the x position value is an integer \u201cstep number\u201d, not an actual horizontal coordinate?\nThanks for proposing this enhancement!\n. ",
    "eformx": "@kunalb for your sankey cycle code, if I were to include a marker-end on the path, where would I put it or what kind of modifications would be required to include it?  I have tried to put it in the path objects but it doesn't show up...\nHope you can help!  Thanks for a great addition to the D3 library!\n//marker-end of path\n                 svg.append('marker')\n                    .attr('id', \"end-arrow\")\n                    .attr('markerHeight', 2.5)\n                    .attr('markerWidth', 2, 5)\n                    .attr('orient', 'auto')\n                    .attr('refX', -5)\n                    .attr('refY', 0)\n                    .attr('viewBox', '-5 -5 20 10')\n                    .append('path')\n                    .attr('d', 'M 0,0 m -5,-5 L 0,0 L -5,5 Z')\n                    //.attr(\"fill\", \"#2ca25f\")\n                    .style(\"fill\", \"#969696\")\n                    .style(\"stroke\", \"2\")\nvar path1 = linkEnter.append(\"path\")\n                    .attr(\"class\", \"link1\")\n                    .attr(\"opacity\", .5)\n                    .style(\"marker-end\", \"url(#end-arrow)\")\n                    .attr(\"fill\", null)\n                    .style(\"fill\", function (d) { return d.target.color = color(d.target.name.replace(/ .*/, \"\")); })\n                    .attr(\"d\", path(1))\n                    .attr(\"class\", \"linkish\");\n      ;\n. @kunalb for your sankey cycle code, if I were to include a marker-end on the path, where would I put it or what kind of modifications would be required to include it?  I have tried to put it in the path objects but it doesn't show up...\nHope you can help!  Thanks for a great addition to the D3 library!\n//marker-end of path\n                 svg.append('marker')\n                    .attr('id', \"end-arrow\")\n                    .attr('markerHeight', 2.5)\n                    .attr('markerWidth', 2, 5)\n                    .attr('orient', 'auto')\n                    .attr('refX', -5)\n                    .attr('refY', 0)\n                    .attr('viewBox', '-5 -5 20 10')\n                    .append('path')\n                    .attr('d', 'M 0,0 m -5,-5 L 0,0 L -5,5 Z')\n                    //.attr(\"fill\", \"#2ca25f\")\n                    .style(\"fill\", \"#969696\")\n                    .style(\"stroke\", \"2\")\nvar path1 = linkEnter.append(\"path\")\n                    .attr(\"class\", \"link1\")\n                    .attr(\"opacity\", .5)\n                    .style(\"marker-end\", \"url(#end-arrow)\")\n                    .attr(\"fill\", null)\n                    .style(\"fill\", function (d) { return d.target.color = color(d.target.name.replace(/ .*/, \"\")); })\n                    .attr(\"d\", path(1))\n                    .attr(\"class\", \"linkish\");\n      ;\n. ",
    "briantjacobs": "+1 for this. A table to understand what proj4/wkt parameters map to d3 projection function arguments would be max helpful.\n. I still struggle with knowing what proj4 parameters map to D3 projection inputs. It's frustrating because parameters from Proj4 or WKT is all I have to lean on coming over from a GIS or shapefile/raster metadata.\n@mbostock your examples above are a little confusing because in EPSG:2163, +lat_0=45  and +lon_0=-100 maps to .rotate([100, -45]). While in ESRI:102003 +lat_0=37.5 maps to .center([0, 37.5]) and +lon_0=-96 maps to  .rotate([-96, 0]).  Is the particular placement of parameters within the projection functions dependent on the projection chosen?\nSo I'm looking for help in filling out what D3 functions maps to what in this list from here http://proj4.org/parameters.html\nI've given it a start for the d3.geo.albers() example, in bold\n\n+a         Semimajor radius of the ellipsoid axis\n+alpha     ? Used with Oblique Mercator and possibly a few others\n+azi\n+b         Semiminor radius of the ellipsoid axis\n+belgium\n+beta\n+czech\n+e         Eccentricity of the ellipsoid = sqrt(1 - b^2/a^2) = sqrt( f*(2-f) )\n+ellps     Ellipsoid name (see proj -le)\n+es        Eccentricity of the ellipsoid squared\n+f         Flattening of the ellipsoid = 1-sqrt(1-e^2) (often presented as an inverse, e.g. 1/298)\n+geoc\n+guam\n+h\n+k         Scaling factor (old name)\n+K\n+k_0       Scaling factor (new name)\nD3: .rotate([xx,+lat_0 ] ): +lat_0     Latitude of origin\nD3: .parallels([+lat_1,xx ] ) :+lat_1     Latitude of first standard parallel\nD3: .parallels([xx,+lat_2 ] ): +lat_2     Latitude of second standard parallel\n+lat_b\n+lat_t\n+lat_ts    Latitude of true scale\nD3: .center([+lon_0,xx ] ): +lon_0     Central meridian\n+lon_1\n+lon_2\n+lonc      ? Longitude used with Oblique Mercator and possibly a few others\n+lsat\n+m\n+M\n+n\n+no_cut\n+no_off    No offset. If present, do not offset origin to center of projection. Only used in Oblique Mercator projection.\n+no_uoff   Backwards compatible version of +no_off.\n+no_rot\n+ns\n+o_alpha\n+o_lat_1\n+o_lat_2\n+o_lat_c\n+o_lat_p\n+o_lon_1\n+o_lon_2\n+o_lon_c\n+o_lon_p\n+o_proj\n+over\n+p\n+path\n+proj      Projection name (see proj -l)\n+q\n+R\n+R_a\n+R_A       Compute radius such that the area of the sphere is the same as the area of the ellipsoid\n+rf        Reciprocal of the ellipsoid flattening term (e.g. 298)\n+R_g\n+R_h\n+R_lat_a\n+R_lat_g\n+rot\n+R_V\n+s\n+south     Denotes southern hemisphere UTM zone\n+sym\n+t\n+theta\n+tilt\n+to_meter  Multiplier to convert map units to 1.0m\n+units     meters, US survey feet, etc.\n+vopt\n+W\n+westo\n+x_0       False easting\n+y_0       False northing\n+zone      UTM zone\n\nI've also been working with GOES-16 imagery and i don't even know where to start with this projection in D3\n+proj=geos +a=6378137.0 +b=6356752.31414 +lon_0=-89.5 +lat_0=0 +f=0.003352810681 +h=35786023 +sweep=x\nThis example by @emeeks wasn't much help with the +a +b +f +h parameters. +1 for this. A table to understand what proj4/wkt parameters map to d3 projection function arguments would be max helpful.\n. I still struggle with knowing what proj4 parameters map to D3 projection inputs. It's frustrating because parameters from Proj4 or WKT is all I have to lean on coming over from a GIS or shapefile/raster metadata.\n@mbostock your examples above are a little confusing because in EPSG:2163, +lat_0=45  and +lon_0=-100 maps to .rotate([100, -45]). While in ESRI:102003 +lat_0=37.5 maps to .center([0, 37.5]) and +lon_0=-96 maps to  .rotate([-96, 0]).  Is the particular placement of parameters within the projection functions dependent on the projection chosen?\nSo I'm looking for help in filling out what D3 functions maps to what in this list from here http://proj4.org/parameters.html\nI've given it a start for the d3.geo.albers() example, in bold\n\n+a         Semimajor radius of the ellipsoid axis\n+alpha     ? Used with Oblique Mercator and possibly a few others\n+azi\n+b         Semiminor radius of the ellipsoid axis\n+belgium\n+beta\n+czech\n+e         Eccentricity of the ellipsoid = sqrt(1 - b^2/a^2) = sqrt( f*(2-f) )\n+ellps     Ellipsoid name (see proj -le)\n+es        Eccentricity of the ellipsoid squared\n+f         Flattening of the ellipsoid = 1-sqrt(1-e^2) (often presented as an inverse, e.g. 1/298)\n+geoc\n+guam\n+h\n+k         Scaling factor (old name)\n+K\n+k_0       Scaling factor (new name)\nD3: .rotate([xx,+lat_0 ] ): +lat_0     Latitude of origin\nD3: .parallels([+lat_1,xx ] ) :+lat_1     Latitude of first standard parallel\nD3: .parallels([xx,+lat_2 ] ): +lat_2     Latitude of second standard parallel\n+lat_b\n+lat_t\n+lat_ts    Latitude of true scale\nD3: .center([+lon_0,xx ] ): +lon_0     Central meridian\n+lon_1\n+lon_2\n+lonc      ? Longitude used with Oblique Mercator and possibly a few others\n+lsat\n+m\n+M\n+n\n+no_cut\n+no_off    No offset. If present, do not offset origin to center of projection. Only used in Oblique Mercator projection.\n+no_uoff   Backwards compatible version of +no_off.\n+no_rot\n+ns\n+o_alpha\n+o_lat_1\n+o_lat_2\n+o_lat_c\n+o_lat_p\n+o_lon_1\n+o_lon_2\n+o_lon_c\n+o_lon_p\n+o_proj\n+over\n+p\n+path\n+proj      Projection name (see proj -l)\n+q\n+R\n+R_a\n+R_A       Compute radius such that the area of the sphere is the same as the area of the ellipsoid\n+rf        Reciprocal of the ellipsoid flattening term (e.g. 298)\n+R_g\n+R_h\n+R_lat_a\n+R_lat_g\n+rot\n+R_V\n+s\n+south     Denotes southern hemisphere UTM zone\n+sym\n+t\n+theta\n+tilt\n+to_meter  Multiplier to convert map units to 1.0m\n+units     meters, US survey feet, etc.\n+vopt\n+W\n+westo\n+x_0       False easting\n+y_0       False northing\n+zone      UTM zone\n\nI've also been working with GOES-16 imagery and i don't even know where to start with this projection in D3\n+proj=geos +a=6378137.0 +b=6356752.31414 +lon_0=-89.5 +lat_0=0 +f=0.003352810681 +h=35786023 +sweep=x\nThis example by @emeeks wasn't much help with the +a +b +f +h parameters. ",
    "dnltsk": "+1. +1. ",
    "amanu": "\nd3.box relies on SVG, which IE8 doesn\u2019t support.\n\nHighCharts https://github.com/highslide-software/highcharts.com solved this by rendering VML instead of SVG for IE8. It works so well https://github.com/highslide-software/highcharts.com/blob/master/js/parts/VmlRenderer.js that it can even \"export SVG\" under IE8.\nD3 is praised as THE visualization so library because it's plug-ins can render what standard charts can't. IE 8 is unfortunately still widely used in companies that make use of such visualizations, so I guess they just don't use D3 :(.\n\nIf you\u2019re stuck with IE8, you could try using Chrome Frame.\n\nThis is mostly not an alternative :(. If users are allowed to use Chrome Frame, than they're allowed to use Chrome directly, and this is not the case :(.\n. > d3.box relies on SVG, which IE8 doesn\u2019t support.\nHighCharts https://github.com/highslide-software/highcharts.com solved this by rendering VML instead of SVG for IE8. It works so well https://github.com/highslide-software/highcharts.com/blob/master/js/parts/VmlRenderer.js that it can even \"export SVG\" under IE8.\nD3 is praised as THE visualization so library because it's plug-ins can render what standard charts can't. IE 8 is unfortunately still widely used in companies that make use of such visualizations, so I guess they just don't use D3 :(.\n\nIf you\u2019re stuck with IE8, you could try using Chrome Frame.\n\nThis is mostly not an alternative :(. If users are allowed to use Chrome Frame, than they're allowed to use Chrome directly, and this is not the case :(.\n. ",
    "ghost": "thanks! :+1: \n. wow! thank you a lot! you can't imagine how useful is this! \\o/\n. thanks! :+1: \n. wow! thank you a lot! you can't imagine how useful is this! \\o/\n. ",
    "jeffyates44": "Yes I've been looking all over for this d3 projection as well! I'm wondering if jasondavies or anyone who has an interest in this matter has found a solution to this complex projection. Thanks!\n. Yes I've been looking all over for this d3 projection as well! I'm wondering if jasondavies or anyone who has an interest in this matter has found a solution to this complex projection. Thanks!\n. ",
    "jgladch": "Bump\n. Bump\n. ",
    "Edddy": "Thanks Jason! I will need to duplicate my nodes with the same name to avoid cycles\n. You will need to programmatically cycle through the results and build a safe one.\n. Thanks Jason! I will need to duplicate my nodes with the same name to avoid cycles\n. You will need to programmatically cycle through the results and build a safe one.\n. ",
    "Fresheyeball": "Wonderful. And that you for your speed response and excellent open source contribution. \n. Wonderful. And that you for your speed response and excellent open source contribution. \n. ",
    "iamvdo": "Is there any improvement since then? I can't find any other solution to interpolate projections.\nBtw, I find this solution pretty complex. For example, how to add an invert method, or how to animate clipAngle, etc. Also, why this fails with Mercator projection?\nMaybe d3-geo (or d3-geo-projection) should add a built-in function?\nIf I'm totally off-topic, please let me know ;-)\n. Is there any improvement since then? I can't find any other solution to interpolate projections.\nBtw, I find this solution pretty complex. For example, how to add an invert method, or how to animate clipAngle, etc. Also, why this fails with Mercator projection?\nMaybe d3-geo (or d3-geo-projection) should add a built-in function?\nIf I'm totally off-topic, please let me know ;-)\n. ",
    "espinielli": "Reading Jason's comment to Dymaxion request it could well be Cahill-Keyes needs the same D3 modifications Jason made for Airocean.\n. I used Jason's code from Airocean...he probably had clipPolygon included there. \n. I tried to use/define a 1-octant projection for each face but got stuck and resolved to use current \"brute force\" ;-)\nI'll have a further look but at least now there is a working implementation...: I needed some results!\n. Reading Jason's comment to Dymaxion request it could well be Cahill-Keyes needs the same D3 modifications Jason made for Airocean.\n. I used Jason's code from Airocean...he probably had clipPolygon included there. \n. I tried to use/define a 1-octant projection for each face but got stuck and resolved to use current \"brute force\" ;-)\nI'll have a further look but at least now there is a working implementation...: I needed some results!\n. ",
    "Fil": "this non-comment to vote up and follow\n. this non-comment to vote up and follow\n. ",
    "andig": "Thank you, I really appreciate the answer. While I really cannot rule out that I'm using it wrong, I don't fully follow the reasoning. \nIf you think e.g. about solar radiation it may well be that current measure is high while projected measure is lower based on weather forecast, leading to current > projected. In this case the sorting leads to colors being swapped for current + projected measure.\nIt might be more helpful to swap drawing order in this case by keep color coding of current/projected as-is?\n. Understood and very good advise. It might make more sense to have a second \"yesterdays performance\" marker similar to the \"maximum ever performance\" marker. And it looks straightforward too- only marker coloring needs to be added.\nThanks for taking the time to go through with me on this! D3 has quite some learning curve but it's just amazing..\n. Thank you, I really appreciate the answer. While I really cannot rule out that I'm using it wrong, I don't fully follow the reasoning. \nIf you think e.g. about solar radiation it may well be that current measure is high while projected measure is lower based on weather forecast, leading to current > projected. In this case the sorting leads to colors being swapped for current + projected measure.\nIt might be more helpful to swap drawing order in this case by keep color coding of current/projected as-is?\n. Understood and very good advise. It might make more sense to have a second \"yesterdays performance\" marker similar to the \"maximum ever performance\" marker. And it looks straightforward too- only marker coloring needs to be added.\nThanks for taking the time to go through with me on this! D3 has quite some learning curve but it's just amazing..\n. ",
    "danni": "We could also check to see if the name already exists in the namespace and\ngenerate another one.\nOn 26 July 2013 00:13, Tom MacWright notifications@github.com wrote:\n\nThe advantage of the other way was that you don't pollute the global\nnamespace at all, and there's no chance of overwriting functions. If we're\ngoing to switch approaches, this should at least use a predictable prefix\nto ensure that it doesn't generate an already-used name and overwrite it.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/d3/d3-plugins/pull/71#issuecomment-21556468\n.\n. We could also check to see if the name already exists in the namespace and\ngenerate another one.\n\nOn 26 July 2013 00:13, Tom MacWright notifications@github.com wrote:\n\nThe advantage of the other way was that you don't pollute the global\nnamespace at all, and there's no chance of overwriting functions. If we're\ngoing to switch approaches, this should at least use a predictable prefix\nto ensure that it doesn't generate an already-used name and overwrite it.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/d3/d3-plugins/pull/71#issuecomment-21556468\n.\n. \n",
    "eagereyes": "Alright, the charset attribute in the script tag works. Thanks!\n. Alright, the charset attribute in the script tag works. Thanks!\n. ",
    "thiloplanz": "For manually setting the x-position, see #88 \n. This patch uses a hashtable to check if nodes have already been seen, and this uses the node name as a key. However, the node name is probably not necessarily unique.\nThere is a similar situation in #105 (already merged), and there a list is used instead. Slower lookup, but proper node identity. \n. I think I am seeing the same problem (browser freezes in computeNodeBreadths), but I was not able to reproduce the problem with the example given here, even when increasing the number of links by just duplicating blocks of links in the JSON.\n. It turns out that the problem with my chart was incorrect input data that caused a cycle in the graph. \nI cannot reproduce the problem described here.\n. This is a dupe of #88.\nAs for xpos, while it is an integer \"step number\", I have found that it also works with any kind of positive number, d3 will scale it nicely to fit the page, so you could have steps \"wider\" than others (At least if you specify it for all nodes, it might mess up the normal step calculations otherwise)\n. For manually setting the x-position, see #88 \n. This patch uses a hashtable to check if nodes have already been seen, and this uses the node name as a key. However, the node name is probably not necessarily unique.\nThere is a similar situation in #105 (already merged), and there a list is used instead. Slower lookup, but proper node identity. \n. I think I am seeing the same problem (browser freezes in computeNodeBreadths), but I was not able to reproduce the problem with the example given here, even when increasing the number of links by just duplicating blocks of links in the JSON.\n. It turns out that the problem with my chart was incorrect input data that caused a cycle in the graph. \nI cannot reproduce the problem described here.\n. This is a dupe of #88.\nAs for xpos, while it is an integer \"step number\", I have found that it also works with any kind of positive number, d3 will scale it nicely to fit the page, so you could have steps \"wider\" than others (At least if you specify it for all nodes, it might mess up the normal step calculations otherwise)\n. ",
    "ChristopherHackett": "Problem is a 404 on force_labels/force_labels.js because it points to a fork which does not exist any more. \nFailed to load resource: the server responded with a status of 404 (Not Found)\nhttps://raw.github.com/ZJONSSON/d3-plugins/master/force_labels/force_labels.js\n. Problem is a 404 on force_labels/force_labels.js because it points to a fork which does not exist any more. \nFailed to load resource: the server responded with a status of 404 (Not Found)\nhttps://raw.github.com/ZJONSSON/d3-plugins/master/force_labels/force_labels.js\n. ",
    "ZJONSSON": "Github raw links fail as external references.  I fixed he gist by simply copying the code from the repo.\nShould work now.\n. Github raw links fail as external references.  I fixed he gist by simply copying the code from the repo.\nShould work now.\n. ",
    "albertosantini": "@chovy See also https://github.com/d3/d3/issues/1662.\nTwo complete solutions:\n- TechanJS\n- D3FC\n@mbostock closing this isssue?. @chovy See also https://github.com/d3/d3/issues/1662.\nTwo complete solutions:\n- TechanJS\n- D3FC\n@mbostock closing this isssue?. ",
    "aendrew": ":+1: for this. It'd be great to set it up something similar to how angular-ui/ui-utils does things, so you can pull down a specific plugin via Bower. Willing to do a PR...!\n. :+1: for this. It'd be great to set it up something similar to how angular-ui/ui-utils does things, so you can pull down a specific plugin via Bower. Willing to do a PR...!\n. ",
    "ktiedt": "I am also looking for a similar solution... \n. I am also looking for a similar solution... \n. ",
    "mobeets": "awesome, very simple--thank you!\n. awesome, very simple--thank you!\n. ",
    "hakdag": "Hi there, thanks for response.\nLooks like I couldnt express myself in a good way :) Let me try to explain it again. \nWhen I am mouse over svg element at which grid is drawn, focus changes to the mouse position. So, when cursor is in center of the svg element, cells near to the cursor are bigger than the cells far from cursor in all directions. \nFocus at center:\n\nBut! When cursor is close to edges of the svg element, cells which are in outer directions from cursor are smaller then the inner ones. For example, \nFocus near to left side:\n\nAs you can see at last screen shot, cells located at very left side of the svg element are very smaller than just next one to the right.\nI hope I explained it in a better way. And any help to fix this issue is welcome! ;)\n. Yep! That's actually what is going on. I am happy that we have same level of understanding now ;) \nBut pointing mouse cursor outside of the svg container is not acceptable solution. In my opinion, behavior is not correct. We must have same effect on every area of the svg element, just like when cursor is at center. I was expecting an answer the person who implemented fisheye.js for this issue. \nAnyway, do you have any idea how to change this behavior as I explained?\n. Hi there, thanks for response.\nLooks like I couldnt express myself in a good way :) Let me try to explain it again. \nWhen I am mouse over svg element at which grid is drawn, focus changes to the mouse position. So, when cursor is in center of the svg element, cells near to the cursor are bigger than the cells far from cursor in all directions. \nFocus at center:\n\nBut! When cursor is close to edges of the svg element, cells which are in outer directions from cursor are smaller then the inner ones. For example, \nFocus near to left side:\n\nAs you can see at last screen shot, cells located at very left side of the svg element are very smaller than just next one to the right.\nI hope I explained it in a better way. And any help to fix this issue is welcome! ;)\n. Yep! That's actually what is going on. I am happy that we have same level of understanding now ;) \nBut pointing mouse cursor outside of the svg container is not acceptable solution. In my opinion, behavior is not correct. We must have same effect on every area of the svg element, just like when cursor is at center. I was expecting an answer the person who implemented fisheye.js for this issue. \nAnyway, do you have any idea how to change this behavior as I explained?\n. ",
    "popkinj": "Thanks Mike. That makes sense.\nI guess I'm a little stumped on how the bitwise logic works. How does 1 << 12 convert into tile coordinates?\n. Ahhhh.. Thanks Mike. \u263a\n. Thanks Mike. That makes sense.\nI guess I'm a little stumped on how the bitwise logic works. How does 1 << 12 convert into tile coordinates?\n. Ahhhh.. Thanks Mike. \u263a\n. ",
    "smartinsightsfromdata": "I support this.\nTo me, without overcomplicating the issue, it would be nice in case to just add a column with the position / level desired for the representation on the X axis (from left to right).\nEnzo\n. I support this.\nTo me, without overcomplicating the issue, it would be nice in case to just add a column with the position / level desired for the representation on the X axis (from left to right).\nEnzo\n. ",
    "hongtaobai": "Like this change, I actually needed this option in one of my project.\n. Thanks. Using hashtable could be a future improvement.\nSent from my Windows Phone\n\nFrom: Jason Daviesmailto:notifications@github.com\nSent: \u200e9/\u200e3/\u200e2014 4:09 AM\nTo: d3/d3-pluginsmailto:d3-plugins@noreply.github.com\nCc: hongtaobaimailto:hongtaobai@hotmail.com\nSubject: Re: [d3-plugins] Fix memory usage issue caused by adding same node multiple times (#105)\nThanks!  It would be even faster if we used a hashtable instead of the linear search (indexOf), but that would require a unique key per object so probably not worth it in this case.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/d3/d3-plugins/pull/105#issuecomment-54281598\n. Like this change, I actually needed this option in one of my project.\n. Thanks. Using hashtable could be a future improvement.\nSent from my Windows Phone\n\nFrom: Jason Daviesmailto:notifications@github.com\nSent: \u200e9/\u200e3/\u200e2014 4:09 AM\nTo: d3/d3-pluginsmailto:d3-plugins@noreply.github.com\nCc: hongtaobaimailto:hongtaobai@hotmail.com\nSubject: Re: [d3-plugins] Fix memory usage issue caused by adding same node multiple times (#105)\nThanks!  It would be even faster if we used a hashtable instead of the linear search (indexOf), but that would require a unique key per object so probably not worth it in this case.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/d3/d3-plugins/pull/105#issuecomment-54281598\n. ",
    "danse": "I think that the idea of plugins is exactly to avoid this complexity. The problem is that the javascript community is divided about how to implement modules\n. I think that the idea of plugins is exactly to avoid this complexity. The problem is that the javascript community is divided about how to implement modules\n. ",
    "vicapow": "I would personally prefer them to be commonJS\n. Or at the very least, allow \"d3\" to be an optional dependency instead of always requiring the \"d3\" object be global.\n. I would personally prefer them to be commonJS\n. Or at the very least, allow \"d3\" to be an optional dependency instead of always requiring the \"d3\" object be global.\n. ",
    "bf": "Thanks for your immediate reply. I assumed it would be better to use an existing module instead of coming up with an own solution. Your point regarding the simplicity obviously holds - even though I wouldn't have been able to do it out of the top of my head.\nAfter working with D3.js extensively for two weeks, I would like to use this opportunity to thank you for this incredible contribution to the data visualisation world.\n. Thanks for your immediate reply. I assumed it would be better to use an existing module instead of coming up with an own solution. Your point regarding the simplicity obviously holds - even though I wouldn't have been able to do it out of the top of my head.\nAfter working with D3.js extensively for two weeks, I would like to use this opportunity to thank you for this incredible contribution to the data visualisation world.\n. ",
    "thehogfather": "Ah fair enough. Admittedly, I wasn't aware of Mike's collapsible indented tree. I wrote this for a project I'm working on and thought the layout abstraction might be useful.\n. Ah fair enough. Admittedly, I wasn't aware of Mike's collapsible indented tree. I wrote this for a project I'm working on and thought the layout abstraction might be useful.\n. ",
    "julien-f": "Any news?\n. Any news?\n. ",
    "saurfang": "The example seems has it and it wouldn't work if I take it out:\nhttp://plnkr.co/edit/bJYy9QISkiI3rpwKseiF (line 81)\nhttp://bl.ocks.org/mbostock/4248145\n. I see. That makes sense. Thanks for the clarification.\n. The example seems has it and it wouldn't work if I take it out:\nhttp://plnkr.co/edit/bJYy9QISkiI3rpwKseiF (line 81)\nhttp://bl.ocks.org/mbostock/4248145\n. I see. That makes sense. Thanks for the clarification.\n. ",
    "Fransan": "I can't reproduce this problem either.\n. I can't reproduce this problem either.\n. ",
    "haggarwal90": "I am also getting same issue. Here is the url\nhttp://jsfiddle.net/hq97qL62/\nIt works fine for 4 Nodes and 1350 links  but it breaks for 4 nodes and 1500 links.\nPlease set \"var testLinksCount = 500 ;\" to reproduce the issue .. I am also getting same issue. Here is the url\nhttp://jsfiddle.net/hq97qL62/\nIt works fine for 4 Nodes and 1350 links  but it breaks for 4 nodes and 1500 links.\nPlease set \"var testLinksCount = 500 ;\" to reproduce the issue .. ",
    "mmmtoasted": "I have also encountered this issue, is there an plan to enhance this feature allow the ky to account for the height and width of the svg?\n. I have also encountered this issue, is there an plan to enhance this feature allow the ky to account for the height and width of the svg?\n. ",
    "mgold": "Paging @jasondavies?\n. +1, unless there's already a way to do this that @emeeks missed (perhaps like this?). Hexbinning on GeoJSON is extremely useful.\n. Paging @jasondavies?\n. +1, unless there's already a way to do this that @emeeks missed (perhaps like this?). Hexbinning on GeoJSON is extremely useful.\n. ",
    "speedplane": "@NPC yes, xpos is a step number, we leave it to d3 to figure out the actual x-pixel location.\n. @NPC yes, xpos is a step number, we leave it to d3 to figure out the actual x-pixel location.\n. ",
    "aadrian": "+1\n. +1\n. ",
    "christabor": "Great, thanks for coming back to this!\n. Great, thanks for coming back to this!\n. ",
    "biovisualize": "Thanks for your excellent contribution! I just merged it.\nhttps://github.com/d3/d3-plugins/tree/master/lasso\n. Thanks for your excellent contribution! I just merged it.\nhttps://github.com/d3/d3-plugins/tree/master/lasso\n. ",
    "pm5": "I think you'll have to check out the demo for each plugin.\n. @roschler most plugin directories have a README.md file, such as this one for d3.keybinding, wherein you can find a link to some demo on bl.ocks.org.  For example, this is a demo for d3.keybinding.  Hope that helps.\n. I think you'll have to check out the demo for each plugin.\n. @roschler most plugin directories have a README.md file, such as this one for d3.keybinding, wherein you can find a link to some demo on bl.ocks.org.  For example, this is a demo for d3.keybinding.  Hope that helps.\n. ",
    "roschler": "Thanks Pomin.  Where do I find those demos?  I don't see them in the plugin directories and can't find a plugins page on the D3.js site.  Do you have a link?\n. Thanks Pomin.  Where do I find those demos?  I don't see them in the plugin directories and can't find a plugins page on the D3.js site.  Do you have a link?\n. ",
    "raimondi1337": "I tried implementing this and it draws the links  on the wrong side of the edges.\n\n. I tried implementing this and it draws the links  on the wrong side of the edges.\n\n. ",
    "timelyportfolio": ":+1: \n. :+1: \n. ",
    "thenickname": "Suggested fix: https://github.com/d3/d3-plugins/pull/126\n. Suggested fix: https://github.com/d3/d3-plugins/pull/126\n. ",
    "gronke": "Hey @fredericbonifas,\nusually OSM supports Zoom-Levels in a range of 0-19, where at zoomLevel 0 the whole world is only one tile. Each higher zoom level divides previous tile(s) in 2x2 tiles. The maximum possible level depends on your data source, so that restricting the maximum zoom level may help you.\nPull-Request https://github.com/d3/d3-plugins/pull/137\n. I agree, it's the better way to constrain the maxZoom before applying it to scale(), i.e. the part that glues tiles to their data-source and knows about zoom level limitations.\n. Hey @fredericbonifas,\nusually OSM supports Zoom-Levels in a range of 0-19, where at zoomLevel 0 the whole world is only one tile. Each higher zoom level divides previous tile(s) in 2x2 tiles. The maximum possible level depends on your data source, so that restricting the maximum zoom level may help you.\nPull-Request https://github.com/d3/d3-plugins/pull/137\n. I agree, it's the better way to constrain the maxZoom before applying it to scale(), i.e. the part that glues tiles to their data-source and knows about zoom level limitations.\n. ",
    "odorovic": "Hi,\nI hope this is an acceptable change, as it's my first one for the project. Formatting of sankey.js is a bit off, as I didn't want to create a huge diff when wrapping the code in module boilerplate.\n. That's great progress, and I'm aware of the effort. Can I somehow help amend this pull request to accommodate for that plan, or should I just stay put and wait for the restructuring?\n. Hi,\nI hope this is an acceptable change, as it's my first one for the project. Formatting of sankey.js is a bit off, as I didn't want to create a huge diff when wrapping the code in module boilerplate.\n. That's great progress, and I'm aware of the effort. Can I somehow help amend this pull request to accommodate for that plan, or should I just stay put and wait for the restructuring?\n. ",
    "veltman": "Oh, duh. Yeah, that was a dumb oversight.\n. Oh, duh. Yeah, that was a dumb oversight.\n. ",
    "kachkaev": "Partial solution: make tile url less random (at least less flickering occurs when certain zoom/pan is revisited)\n``` js\n// before\nimage.enter().append(\"image\")\n      .attr(\"xlink:href\", function(d) { return \"http://\" + [\"a\", \"b\", \"c\"][Math.random() * 3 | 0] + \".tile.openstreetmap.org/\" + d[2] + \"/\" + d[0] + \"/\" + d[1] + \".png\"; })\n// after\nimage.enter().append(\"image\")\n      .attr(\"xlink:href\", function(d) { return \"http://\" + [\"a\", \"b\", \"c\"][ (d[0] + d[1] + d[2]) % 3 ] + \".tile.openstreetmap.org/\" + d[2] + \"/\" + d[0] + \"/\" + d[1] + \".png\"; })\n```\n. @mbostock waiting for new tiles to load would be an ideal scenario, but it's probably quite difficult to implement (consider a tile split into 4 other tiles 3 out of which are already loaded and one is still on its way). Just a delay of 0.5-1s before a tile is removed can solve 90% of flickering cases. This would improve a lot of visualisations that are built on top of your example.\nEven if you think that de-flickering is outside of the team's interest, please at least consider replacing Math.random() in the tile url. See above + demo.\nCheers!\n. Partial solution: make tile url less random (at least less flickering occurs when certain zoom/pan is revisited)\n``` js\n// before\nimage.enter().append(\"image\")\n      .attr(\"xlink:href\", function(d) { return \"http://\" + [\"a\", \"b\", \"c\"][Math.random() * 3 | 0] + \".tile.openstreetmap.org/\" + d[2] + \"/\" + d[0] + \"/\" + d[1] + \".png\"; })\n// after\nimage.enter().append(\"image\")\n      .attr(\"xlink:href\", function(d) { return \"http://\" + [\"a\", \"b\", \"c\"][ (d[0] + d[1] + d[2]) % 3 ] + \".tile.openstreetmap.org/\" + d[2] + \"/\" + d[0] + \"/\" + d[1] + \".png\"; })\n```\n. @mbostock waiting for new tiles to load would be an ideal scenario, but it's probably quite difficult to implement (consider a tile split into 4 other tiles 3 out of which are already loaded and one is still on its way). Just a delay of 0.5-1s before a tile is removed can solve 90% of flickering cases. This would improve a lot of visualisations that are built on top of your example.\nEven if you think that de-flickering is outside of the team's interest, please at least consider replacing Math.random() in the tile url. See above + demo.\nCheers!\n. ",
    "Xepherox": "Perfect =)\nI had tried to change the hexbin code..\nBut switching the x/y input and rotating the result works perfect =)\n. Perfect =)\nI had tried to change the hexbin code..\nBut switching the x/y input and rotating the result works perfect =)\n. ",
    "kennynaoh": "Thanks @mbostock ,\nBy the way, I want to ask it is necessary to add /build/bundle.js on npm.\nPlease help me confirm that.\nThanks!\n. Thanks @mbostock ,\nBy the way, I want to ask it is necessary to add /build/bundle.js on npm.\nPlease help me confirm that.\nThanks!\n. ",
    "betterliyu": "Thank you for your replay.. Thank you for your replay.. "
}