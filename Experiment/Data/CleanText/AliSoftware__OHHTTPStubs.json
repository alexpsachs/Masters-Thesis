{
    "AliSoftware": "Hi there!\nThere is a possibility to remove all handlers using removeAllHandlers.\nBut if you want to remove individual handlers, I think I should specify an identifier (NSString) when adding a handler, so that you can remove a handler by its identifier in the teardown method.\nAnother (an quicker) patch would be to add a removeLastHandler method that only remove the lastly added Handler (last object of the array of handlers), as this will probably be enough for most usages\n. Thx!\n. Done ;)\n. Just commited version 1.0.2, that does not change anything in the code, but generates an independent static library, so that you can easily add it to your workspaces:\n- Add the OHHTTPStubs.xcodeproj to your application's workspace\n- Link your UnitTest target with libOHHTTPStubs.a (so that you will link with the library only for your Unit Tests but not for your final application)\n- #import <OHHTTPStubs/OHHTTPStubs.h> in your test cases to use the classes\nNote: no need to specify any Header Search Path or whatever, the library project is normally configured correctly so that it is completely transparent for you\nSee ReadMe and the wiki page for more details.\nEnjoy!\n. Hi!\nThe cast was there to generate any dummy object address other than nil.\nSo in my last commit I preferred to use a constant NSString as this dummy non-nil value instead of building an NSNumber instance for nothing to fix this.\nThanks anyway for finding this issue!\n. Good catch! Yes indeed this should be autorelease, thanks.\n. Yes that's not really an issue because you should only use OHHTTPStubs in your tests & debug code, not in production (and normally if you don't use the OHHTTPStubs symbols anywhere in your code, the code won't be included by the linker to reduce the final binary size, except if you used -all_load).\nYou should only need to use stubs in your tests & debug code, it doesn't have any sense to use it in production code.\nI'll probably add something in the README about this anyway.\nIf you guys have any idea if it is possible to detect if an application is being compiled with a production certificate using #if directives (I hardly doubt it, except if the Xcode compile adds -D flags automatically in such cases but it's doubtful) so I can add a #warning or #error in such case to prevent the compilation/linking with OHHTTPStubs in production code?\n. Nope every use of any private API have been removed since this issue and no new private API have been introduced since the numerous new versions since.\nSo this lib won't make your app being rejected from AppStore submission.\n\nNote that I still recommend to remove it before submitting, not because it would be rejected but because it had little sense to keep a lib in a release version of your app if you don't use it (you rarely stub requests in your final app :wink:) and it will make your app size lighter.\n\nAlso note that the conditional linking based on build configurations has been recently added to the master branch of CocoaPods and will thus be available in the next release of CocoaPods !\n. Thanks for your feedback!\nI am already aware about that kind of pattern, which is quite common in unit testing: you need to wait for your asynchronous action (like some request) to complete before exiting the test method (generally using a semaphore), but the wait must not block the asynchronous operation (so generally you need to continue executing the run loop or call dispatch_main) like you explained to avoid what we call a DeadLock in multithreading environment (threads locking each others)\nThis may indeed become tricky in some cases as you experienced.\nBut in this very case, even if it is another case of a DeadLock, this will probably be solved simply by executing the dispatch_after block on the running thread instead of the main thread (in fact running it on the main thread is not justified) so that all the request/response logic is executed on the same thread dedicated by the NSURLConnection class. This will avoid any deadlock between the two threads then.\nHope this will solve everything and clarify the situation, and thanks again for all your references and investigation, it will help clarifying all this stuff ;-)\n. I am clearly interested in some test coverage for OHHTTPStubs !\nAnyone who as some time to assist me in this is welcome ;-) Don't hesitate to propose some pull requests for this!\n. Sure, will do! Thx again\n. dispatch_get_current_queue() calls removed.\nIn our case, the fix was simple as we can simply schedule a timer to execute the block later. As the NSURLProtocol methods are executed on NSURLConnection's thread, which does contain a NSRunLoop, our timer will fire as expected.\nOther approaches like some while loops calling -[NSRunLoop runMode:beforeDate:] has been tested (and are used in the Unit Tests and AsyncSenTestCase.m actually) but are not really necessary here (and firing a timer still allow the runloop to run, of course)\n. @QuentinArnault this could be a good occasion to test your QATestingKit framework too ;)\n. TODO List:\n- Test the behavior when adding multiple requestHandlers (multiple calls to addRequestHandler:)\n- Test the behavior when removing a previously added requestHandler to check it is properly disabled\n- Test bandwidth estimations\n- Test if custom response headers are correctly sent/stubbed\n- Provide more Unit Tests using AFNetworking\n- Check the handling of stubbed headers, especially the \"Set-Cookie\" header with NSHTTPCookieStorage (see #10)\n. Thanks for posting this issue! I will look into it ASAP\nI recently added Unit Tests to OHHTTPStubs in order to check that it works with various cases, but I didn't add Unit Test Cases about headers and cookies, and I obviously do need to test this special feature!\nBy the way, feel free to send me a pull request with some Unit Test for your case with cookies if you can, this would be a great addition to extend test coverage and would allow me to directly use it to check if your specific case is solved by my future solution :)\n. My last commit should have fixed the issue regarding cookies, but don't hesitate to try it and check that it fixed your use case correctly and keep me posted about it. Thx!\n. You're welcome, and thanks for the feedback ;)\n(Just commited again a small fix for my previous commit, don't forget to pull it)\n. 1. To completely remove response time as your issue title asks, simply use a response time of 0.0\n2. To make OHHTTPStubs not stub a given request, simply make it return nil. Or much better, use the other and more suitable method [OHHTTPStubs shouldStubRequestsPassingTest:withStubResponse:] as explained in details the README file, to capture the url and HTTPMethod of your request but still ask not to stub it so the real request is sent to the nework (and the request hits the real world anyway)\n. Of course, don't return nil in the block because as explained in the README it will be interpreted as letting the request hit the real world, but simply return any OHHTTPStubsResponse.\nEspecially, if you don't care about the returned/stubbed response, why not return any empty stubbed response instead of having to read a JSON file to return it whereas you don't care about it?\nYou may for example return an [OHHTTPStubsResponse responseWithData:nil statusCode:200 responseTime:0 headers:nil] or even [OHHTTPStubsResponse responseWithError:nil] or whatever, just to stub with an empty response of course\u2026\n\nActually, I don't understand why you don't use a responseTime of 0.0 but keep insisting on using a responseTime of 0.1 or 0.2 ?! What don't you understand in the README about the responseTime parameter or the various OHHTTPStubsResponse methods explained here in the README that would make you want to absolutely return a json instead of nothing or want to use a responseTime other than zero for your purpose?\n. But did you profile your code using Instruments (\"Product\" menu -> \"Profile\" then choose the \"Time Profiler\" instruments) to check which part of the code eats up the most time?\nNot sure OHHTTPStubs is responsible here or if we can reduce it anyway lower that that\u2026\n. Note that the first (legacy) method you used, namely addRequestHandler:, is known to be slower than the newer one shouldStubRequestsPassingTest:withStubResponse: because the block in addRequestHandler: is called multiple times when iOS asks if OHHTTPStubs should handle the request or let other protocols handle it (which happen like 3 or 4 times for each request, I don't know why iOS does that but it's a fact), before it finally calls the block to actually perform the request one last time.\nWhereas with the latter method, the first block is also called multiple times by iOS but only returns YES or NO (and does no bother about creating an OHHTTPStubsResponse instance), and the second block building the OHHTTPStubsResponse is only called when iOS is ready to finally perform the request, hence the faster execution that avoids creating instances when it's not needed..\nIf you still use addRequestHandler: (instead of the suggested shouldStubRequestsPassingTest:withStubResponse:), you must not forget to take the onlyCheck parameter into account if you want to reduce your tests execution time a lot. All this is already explained in the README file here.\nSo maybe you didn't follow those recommendations of the README, which would explain that your test still takes ~0.2s?\n. OK. Given this code and usage of OHHTTPStubs this way, there is no way to reduce the time taken by OHHTTPStubs itself more.\nSo either you already optimized the rest of your test code and you won't be able to reduce your test time more than that, or the 0.2s are taken by some other stuff in your test code, not related to OHHTTPStubs.\nYou could try launching Instruments manually, then start your Unit Tests from Xcode, then attach Instruments to the otest process (you may add some pause at the beginning of your test code to let you some time to attach Instruments to your test process for that). This will allow you to profile your test executable and see which code takes the more time in your test code.\n. That's because you didn't RTFM.\nEverything about integrating the lib correctly in your project is described in detail in the README. Obviously, like your link warning & error and the way you #import-ed the header suggest, you didn't even read and follow those basic instructions.\nFollowing the README instructions will make the lib compile automatically with the right architecture, find the headers without having to add their path to the Header Search Path either, avoid any trouble with Build Settings conflicts between my project and yours if any (different ARC settings for example that would lead to leaks or crash), and much more.\n. Sure CPU usage isn't really a concern in Unit Tests but:\n- I also use OHHTTPStubs in environments other than Unit Tests in a lot of projects. The typical usage is when I need stubs because I am developing an iPhone application for some of my customers, that needs to connect to some of the customer's server. In a lot of cases, the server isn't fully ready when I am still developing the application (the customer is developing its plateform while we are developing our iPhone app, etc) or there are some of the API entry points not implemented yet on the server\u2026 so we can't hit the real plateform and needs some stubs.\n- I already studied this questions with some other users, about race conditions, delays and all (see also #8). Using a value of 0 is not generally a good idea and won't minimize the race conditions, even sometimes increase their risks, as using a delay of zero means that you won't let time for the scheduler to balance the execution of the various threads, so other threads will have less chance to execute a lot of instructions and will be slower. Keep in mind that having multiple threads and reducing the sleep times of each won't make things go faster\u2026 on the contrary! It will make the scheduler either keep executing the thread with the upper priority more often, and/or switch from thread to thread all the time, executing less instructions per thread each time, increasing the risk of multiple accesses for same ressources and deadlocks, and loosing time by switching thread contexts each time. It is as aggressive as using a while(1) loop. Even in Unit Tests, don't do it!\n- All other frameworks seems to have the same logic too. Look for example at how GHUnit use this, as well as AFNetworking and all. We always need a non-zero delay to avoid both CPU-intensive tasks even in Unit Tests (but again, OHHTTPStubs is also used in contexts other that Unit Tests by the way) but also to avoid the scheduler switching thread contexts all the time.\n. Given the if statement before and the math involved, this can never happen.\nif canonicalResponseTime is negative, the code goes into the if block and its value is replaced by (-canonicalResponseTime * 1000 * length) which is always positive (as length is an NSUInteger and the length of some NSData). Then requestTime is 10% of this canonicalResponseTime value and responseTime is 90% of this canonicalResposneTime so they are also always positive.\nSo there is no need to use fabs there.\n. Good idea, will merge it soon.\n. Merged in 2.0.0\n. This is not the only private API used actually (I also use the \"invoke:\" method on the object-like blocks somewhere too), and the public API is still quite recent so won't work for people still building and using my library for iOS 4.3 (yes there are some users still building for pre-5.0!). And actually using a private API somehow ensure that the appli will be rejected if we forget to remove the stubs in our application ^^ (I have some users that have one's head in the clouds sometimes ^^)\nThat is a nice suggestion though, and I will surely adopt this in the future once I will be ready to drop the support for pre-5.0 iOS versions (I hope pretty soon)\nPS : Why is the Janky github module marking this merged build as failed? Can't access the build report\n. Merged in 2.0.0\n. Can't merge automatically so I implemented myself in this commit. Closing this issue now.\nThanks!\n. May I close this Pull Request then, as this solution won't really be able to work properly?\n. stopLoading fix merged manually.\n. Hi\nDidn't know VCRURLConnection but it seems pretty straightforward to me to make it work with OHHTTPStubs. Not sure an official branch or addition would be useful.\nAfter reading the source, it seems to me that you simply need to create a VCRCassette object from your JSON file, then for each request to stub, use [cassette recordingForRequest:theRequest] to get a VCRRecording object and build an OHHTTPStubsResponse with its properties:\n```\nVCRCassette* cassette = [[VCRCassette alloc] initWithData:[NSData dataWithContentsOfFile:yourJSONFileURL]];\n[OHHTTPStubs shouldStubRequestsPassingTest:^BOOL(NSURLRequest request) {\n    return ([cassette recordingForRequest:request] != nil);\n} withStubResponse:^OHHTTPStubsResponse(NSURLRequest request) {\n    VCRRecording rec = [cassette recordingForRequest:request];\n    return [OHHTTPStubsResponse responseWithData:rec.data\n                                      statusCode:rec.statusCode\n                                    responseTime:whateverYourLike\n                                         headers:rec.headerFields];\n}];\n```\nAnd that should do the trick!\nI haven't tested it but it doesn't seems to be anything more needed.\n. Hi\nFor your information latest versions 1.2.x and 2.x.y of OHHTTPStubs now include the capability of loading files generated by the output of curl -is, that is files that include the headers (with the response status code) AND body.\nSimply put each of your responses (with their headers and body) in a *.response file (for example using curl -is http://example.iana.org >example1.response) and then use [OHHTTPStubsResponse responseNamed:@\"example1\" inBundle:nil responseTime:...] to replay them.\nNot really the same format as the JSON format used by your VCR class, but still quite the same principle as you can replay real requests easily.\n. Wow man, this seems very promising and clean, thank you so much for this whole stuff!\nDon't have my Mac this weekend and didn't have time until now to look at it in detail, check everything and merge it (as it changes a lot in the API, as you suggest it will probably lead to a v3.0), but will probably do it very soon!!\n. Hi @kcharwood \nI have pushed a revision of your merge request on a branch called \"inputstrem\" (yes, with the typo in the name ^^)\nThis refactor includes:\n- Adding some comments for documentation, adjusting the naming conventions and code indentation\n- Reinserting the previous API methods, but as deprecated, to allow people to migrate seamlessly\n  - The aim of this is to keep the old API around in order to push a version 2.1.0 so that users of 2.0.x won't need to switch to the new API right away:\n  - It will let them some time to migrate the deprecated methods to the new methods before definitely switching to 3.0.0 where all the deprecated methods will be removed eventually\n- Rearranging my code to have the methods grouped by theme, and the method in the .m in the same order as the ones in the .h\n- Removing the *2.0 for redirections. The 302 stub response will use the specified requestTime, then redirect to the location (which itself may trigger a subrequest that gets its response from a stub with its own requestTime, I suppose). We should definitely test this case (and add a Unit Test for this)\n- Handling the case when responseTime is less than the slotTime you defined. In practice for a lot of users that are not in your case of big responses and that do not need download progress but instead need quick to immediate responses, this will in fact often be the case, so this has to be handled. Definitely need to check/add a UnitTest for this too\n- Reducing the amount of constructors to avoid having a too long header file and make maintenance and evolutions less painful, and avoid having a lot of variations for each constructor. For example, I reduced the constructor working with files to only one taking a file path, and added macros to easily build a file path from a bundle or from the documents directory. Let me know what you think of this approach.\n\nThe things that are left to check (but don't have time anymore now as it's already 4am here in France\u2026) to see if every use case are correctly handled:\n- [ ] dataSize == 0 (either if we use the designed initializer with a dataSize of zero or if we affect the property to zero later, or if we create a stub with a zero-length NSData)\n- [x] responseTime == 0 (which must be possible and a valid value, because a lot of people using OHHTTPStubs are using a responseTime of zero in the Unit Tests to only check the parsing of the response for example, and are interested in stubs that return network data immediately to avoid their  long list of unit tests to take too much time executing)\n- [x] Check, check, and check every method. We may need to add some Unit Tests for tricky cases (empty data / zero dataSize, responseTime very small or zero, \u2026), but also as I did code quite blindly tonight (only checking there was no compiler error and that all Unit Tests passed), we must check that all the methods work according to what is expected at runtime, including the new OHPathForFileInBundle and OHPathForFileInDocumentsDir macros that I haven't tested at all.\n- [x] Even if it seams ok to me given the current code, double-check that the request will not take 0.25s more than the responseTime specified (as we wait for slotTime before sending the first chunk of data) \n- [x] Update the README.md file according to the new API\n\nIf you would like to review my code in my branch and check if everything seems ok to you, this would be very appreciated. When all this code is ready and approved, I'll push a 2.1.0 tag (and its associated podspec), then remove the deprecated methods (and the deprecated data property) and push a 3.0.0 tag right after with the new clean API.\n\nAnd finally, the next thing to do in 3.1.0 (or maybe before pushing 3.0.0) would then be to\n- [ ] Add a variant of responseWithHTTPMessageData:requestTime:responseTime: that works with NSInputStream instead of NSData too.\nBut I'm too tired to think about a clean way to implement it tonite ;)\n. Ok I won't have much time checking that out until next week-end anyway, will try to wrap everything up saturday or sunday.\nEnjoy your vacation ;) :beers: \n. Sorry for the late reply.\nI will do the final stuff (mentioned in the TODO list above) in the upcoming days and hopefullly merge it by saturday :beer: \n. Hi there\nI need some help debugging the code around the timing and chunking of the data.\nFor my Unit Tests, I use the NSURLConnection class with a delegate method. Let's say I use a requestTime of 1.0 and a responseTime of 2.0.\nThe problem is that even if the [client URLProtocol:didReceiveResponse:cacheStoragePolicy:] method is called after 1 second, the [client URLProtocol:didLoadData:] is called every 0.25s (slotTime) and the [client URLProtocolDidFinishLoading:] is called 3s (1.0+2.0) after the request being started, the delegate methods seems to be all called one once and only at the end (after the 3.0 second delay), instead of being called during the call flow.\nThis makes all the fuzz about sending data in chunks a bit useless if at the end all is like the whole data is sent at once\u2026 Do you have any idea what could be wrong?\n. Ok it seems that [client URLProtocol:didLoadData:] does not automatically trigger the delegate's connection:didReceiveData: and that Cocoa delays the call to the delegate until it gets enough data. I tried with a larger NSData as an input for my test and it gets called multiple times as expected, even if not as much as didLoadData: is called.\nBut I still have a problem : the connection:didReceiveResponse: delegate method is called at the same time as the first connection:didReceiveData:, exactly slotTime seconds after the corresponding call to the client URLProtocol:didReceiveResponse:cacheStoragePolicy:] method in OHHTTPStubsProtocol. I guess the call to execute_after blocks the dispatching of this delegate method call there or something.\n2013-09-02 01:34:31.519 otest[26608:2307] client.start\n2013-09-02 01:34:36.520 otest[26608:1103] client.didReceiveResponse\n2013-09-02 01:34:36.771 otest[26608:1103] client.didLoadData\n2013-09-02 01:34:37.021 otest[26608:1103] client.didLoadData\n2013-09-02 01:34:37.272 otest[26608:1103] client.didLoadData\n2013-09-02 01:34:37.273 otest[26608:303] delegate.didReceiveResponse\n2013-09-02 01:34:37.273 otest[26608:303] delegate.didReceiveData\n2013-09-02 01:34:37.523 otest[26608:2807] client.didLoadData\n2013-09-02 01:34:37.523 otest[26608:303] delegate.didReceiveData\n2013-09-02 01:34:37.774 otest[26608:2807] client.didLoadData\n2013-09-02 01:34:37.774 otest[26608:303] delegate.didReceiveData\n2013-09-02 01:34:38.025 otest[26608:1103] client.didLoadData\n2013-09-02 01:34:38.025 otest[26608:303] delegate.didReceiveData\n2013-09-02 01:34:38.276 otest[26608:1103] client.didLoadData\n2013-09-02 01:34:38.276 otest[26608:303] delegate.didReceiveData\n2013-09-02 01:34:38.526 otest[26608:1103] client.didLoadData\n2013-09-02 01:34:38.526 otest[26608:303] delegate.didReceiveData\n2013-09-02 01:34:38.777 otest[26608:1103] client.didLoadData\n2013-09-02 01:34:38.777 otest[26608:303] delegate.didReceiveData\n. TODO List\n- [ ] Check when dataSize is 0 and when it is larger that the real inputStream size\n- [x] Extract the requestTime:\u2026 responseTime:\u2026 parameters into a separate method to avoid repeating them for every method (also useful to let the caller keep the default values of 0 if he/she doesn't need any delay)\n\n\n[x] Update README.md file + Wiki + ChangeLog\n[x] Check documentation generation (for docset generated by appledoc on pod install)\n[x] Generate Podspec 2.1\n\n\n\n[ ] Prepare version 3.0 by removing deprecated methods\n. Version tagged 2.1.0-RC -> 771f0032dd4fad99fb8c029ea9fec8ac26a7de65\n(And podspec 2.1.0-RC pushed to CocoaPods too)\n\nDon't hesitate to fully test it in your real projects, and to review the README file too.\n\n(I will wait to test this RC in real world in my projects before merging the code into master, then remove deprecated methods completely to release 3.0.0 ; but meanwhile, 2.1.0-RC is out there and valid to use & test :wink: )\n. Now merged into master as official version 2.2.1 (non-RC).\n. Interesting idea, but:\n- Your pull request make the Travis build and Unit Tests fail. Please fix.\n- It would be interesting to have both a white and black list available, not only a whitelist. Like hostsWhitelist for hosts that may be stubbed (your applicationHosts set so far) and hostsBlackList for hosts never to stub (like testflight, etc)\n- You should compare the hosts by extracting the host using -[NSURL host], not absoluteUrl hasPrefix\n\nBut anyway, not sure why this feature would be useful, as you always conditionally configure your stubs, using the block provided for this, by testing the URL requested, so I don't see a case when you will accidentally stub a request to testflight or hockeyapp or such?\n. - URL must conform to RFC 1808, as this is the RFC used by NSURL to build an URL from a string, and at some point you will need to build such NSURL object to send the request on the network (and be intercepted by the stub). So it does not make sens that any URL won't conform to the RFC or you won't be able to send the request.\n- If you intend to do your comparison based not on the host but on the URL prefix, you should not name your NSSet* with \"host\" in it. But if you want to do your comparison with the hasPrefix method, this means that one should add every protocol he/she uses like http AND https for each request/host, that's not much better\n- Your solution won't work for applications that use dynamic configuration (like multiple applications I am working on), like applications reading their configuration URLs from a dynamic configuration file itself retrieved from a server. In that case it is not possible to specify a white list of hosts at all\nPS: I still don't really understand why you need that actually, so please help me understand cause maybe I'm missing something: how do you define your stubs? In my case, my stubs are defined with stuff like this:\nobjc\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n  return [request.URL.absoluteString isEqualToString:@\"http://myserver.com/foo\"];\n} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {\n  return [OHHTTPStubsResponse responseWithFile:@\"foo.txt\" \u2026];\n}];\nOr stuff like this:\n``` objc\ndefine kStubHost @\"stubs.unittests\"\n[MyWebService setBaseURL:kStubHost];\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) {\n  return [request.URL.absoluteString hasPrefix:@\"http://\" kStubHost \"/foo/\"];\n} withStubResponse:^OHHTTPStubsResponse (NSURLRequest request) {\n  NSString filename = request.URL.lastPathComponent;\n  return [OHHTTPStubsResponse responseWithFile:filename \u2026];\n}];\n```\nSo each time I define a stub in my Unit Test, I provide the URL I want to stub as the condition. I never use conditions that are always YES for example, I always explicitly tell which request(s) I want to stub\u2026 so I can't see why stuff like TestFlight may get in the way?\n. Ok I understand your issue here but don't seems to me like to be a good practice to always return YES. Why would you stub ALL your requests whatever they are pointing to, with the exact same stub response?\nI'll close it for now, but since you now are aware that you should not always return YES in the first block but put your conditions in there (and that it does not seem to have any sense to stub all the requests with the same response), if you still encounter difficulties and still think that even with this new info and explanation you still need this new method, I would maybe reopen it (after I merged my big code refactoring waiting in the other pull request)\n:beers: \n. Thanks for the feature request and the test :+1:\nThis is definitely in the road map to make it work with AFN 2.0 :beers:\nFor now my work is focused on finishing my big refactoring in the inputstrem branch (see my 2.2.x-RC tags / versions, but it seems you are using them already as you use the new removeAllStubs API :smiley:) which uses NSInputStream objects instead of NSData for a big memory and performance improvement (lazy loading of stubs, etc) but did a lot of internal changes so I have to make sure everything is fine with it first.\n\nI am quite confident in those RC versions, but the only thing I miss in this branch is adding a bunch of missing Unit Tests to be sure my test coverage is good enough and that this refactoring is good to be merged in the master. \n\nAs soon as my big inputstrem (yeah I know I missed an \"a\" in the branch name ^^) contains the missing tests and then merged into master, I'll have to work on making OHHTTPStubs compatible with AFN 2.0 right away :+1: \n(Actually, feel free to propose some Pull Requests to help me add those missing Unit Tests here and be done with this refactoring so I can hit version 3.0 sooner :wink:)\n. @jkrall It's still in my roadmap :wink:\nAny help appreciated, you could for example at least propose a Pull Request containing at least the Unit Test quoted by @johanforssell \u2014 but using my AsyncSenTestCase subclass and SenTestKit instead of XCTest and his macros, to be consistent with my other Unit Tests on OHHTTPStubs.\nI haven't started investigating yet (I hope I'll have time this weekend), if anyone has pointers on why this fails, it could save me some time too :+1: (Haven't even had time to look at iOS7's NSURLSession new mechanism :worried: )\n. Thx for the pointer on this fork! Will definitely have a look at @ndonald2 's work\n. Thanks @ndonald2 it helps a lot!\nSee #34 for some other comments and the continuation of this discussion\n. Done.\nVersion automatically-compatible with NSURLSession (with the caveat mentioned by @ndonald2 above thanks to swizzling magic, so not even the need to configure your NSURLSessionConfiguration for that, your existing code should work as is) published as 2.4.0.\nOnly caveat (but unsolvable) is that OHHTTPStubs won't work with background session, due to the intrisic nature of those sessions and the fact that they don't support custom NSURLProtocols. See README for more details)\n\nVersion 3.0.0 released as well \u2014 and available thru CocoaPods too, don't forget to update your Podfiles \u2014 which is the same as 2.4.0 but with all old & deprecated methods removed (at last!).\n. Thx for the pull request. I will study it this weekend, probably as soon as tomorrow.\nRegarding the mentioned caveats\nDon't confuse __IPHONE_OS_VERSION_MAX_ALLOWED (the version of the SDK you compile with) and __IPHONE_OS_VERSION_MIN_REQUIRED (the deployment target of the project / minimum iOS version required for the built app).\nIn my opinion, and according to Apple's \"SDK Compatibility Guide\", OHHTTPStubs should:\n- build and include the code related to NSURLSession if __IPHONE_OS_VERSION_MAX_ALLOWED >= 70000 (that is, when building with SDK 7, where the NSURLSession class is known in the headers and libs), whatever the Deployment Target is (even iOS5 or iOS6)\n- conditionally use this code at runtime by encapsulating it into tests like if ([NSURLSession class]) and respondsToSelector: calls. This way the code related to NSURLSession is included as soon as you build with SDK7, but is used at runtime only if the end user runs iOS7+ (but not when running on an iPhone/iPad still using iOS6).\nRead the SDK Compatibility Guide for more info if needed\nConcerning the comment in your last commit message\nxcshareddata is specially designed to contain what should be shared on a repository, contrary to xcuserdata which is to be excluded. In that case, it seems reasonable to me to keep it in the repo. Disabling tests directly in the scheme is designed for tests that should be disabled because of their nature (they are not to be automated, or they are work in progress, or they are not relevant anymore, etc). If you want to execute only one test, for exemple during the development phase when you test your NSURLSession unit test, Xcode5 now allows to execute tests one by one, so you shouldn't need to disable the tests in the scheme anyway. So IMHO we should keep it in the repo.\n. Indeed Travis build fails because it hasn't upgraded to Xcode5 yet (see Travis-CI issue here).\nBut actually that will help us verify that the code is still able to be build with Xcode 4.5.2 (version used by Travis). Currently the Travis Build is failing because Xcode4/SDK6 doesn't know about NSURLSessionConfiguration class and its protocolClasses method, but as explained in our discussion we should use #if __IPHONE_OS_VERSION_MAX_ALLOWED conditional to make it buildable using Xcode4 anyway and make it pass Travis build even while they still use Xcode4 ;)\n. Merged by commit ede2aa439b7af94b3cd7961d3a017976170f93d8 :smiley: \nLet me know if you are OK with my modifications.\n. Note that the Travis build still fails, but this is due to AFNetworking 2.0 code.\nAFN2 uses __IPHONE_OS_VERSION_MIN_REQUIRED everywhere, where it should use __IPHONE_OS_VERSION_MAX_ALLOWED, leading to build failure because Travis-CI is still running Xcode 4 (and SDK 6.0) and not yet running Xcode 5 / SDK 7.0.\nYou're welcome to vote for a fix in the AFNetworking repository, there are plenty of issues and people angry about it too and who want that changed so it works and build properly\u2026 (see 1410/1412/1436/1437)\n. Yep I saw the mess that @mattt did with using __IPHONE_OS_VERSION_MIN_REQUIRED (Deployment Target) instead of using __IPHONE_OS_VERSION_MAX_ALLOWED (Base SDK), and this choice of his really annoys me.\nSee also comments on #34.\nI really don't like bumping the Deployment Target of OHHTTPStubs to iOS7 just so that the Unit Tests that uses AFNetworking can compile, because not everyone uses AFNetworking 2.0 (And because of this poor choice of design by mattt of forcing us to have a Deployment Target iOS7+ for all apps that want using AFN2, I'm considering totally dropping the use of AFN2 in my projects, I really can afford dropping support for iOS6 in my apps now).\nI really want OHHTTPStubs to still be able to work with users running iOS5 and iOS6, so forcing a Deployment Target to be iOS7+ is out of the question, contrary to what @mattt did with AFN2. Instead, I am considering removing the Unit Tests that use AFN2 completely, and the AFN submodule (and just keep my own Unit Tests with NSURLSession and NSURLConnection and all). Or maybe keep my AFN submodule used for AFN Unit Tests to point to AFN 1.x. Or maybe simply wait for Travis-CI to migrate its VM to Xcode5 which should be quite soon.\n. Yep, but I do not want to force this dependency just for my Unit Tests. Because again, I don't have a dependency between OHHTTPStubs and AFNetworking, it can totally be used with OR without AFN.\nAdding a dependency to AFN2 in the podspec just for my Unit Tests to run, even if users of my lib don't use AFN, seems totally nonsense. \nI may revert my submodule pointing to AFN and try to use a Podfile instead, with no pod for the main (lib) target and \"AFNetworking\", \"~> 2.0\" for the target :Tests, will give it a try some day soon. But the more I think about it the more I realize I may drop all the Unit Tests related to AFN itself (as long as my coverage remains the same\u2026)\n. AFNetworking is in the right way to solve this see https://github.com/AFNetworking/AFNetworking/pull/1412\nStill some conversions from MIN_REQUIRED to MAX_ALLOWED required in his code, but hopefully it will be fixed soon\n. My submodule now points to my own AFN2 fork \u2014 which fixes the problem with AFN2 conditional compilation issues \u2014 so Travis-CI is back to green and passes happily now :+1:\nWaiting for my PR https://github.com/AFNetworking/AFNetworking/pull/1486 to be merged (to then switch back to the official repo and remove my fork).\n. This is due to the way the new NSURLSession class works. It was fixed since 2.4.0 already.\nSee the CHANGELOG here.\nPlease upgrade to at least 2.4.0 or even better to 3.0.0 :wink:\n. No more that what I explained in the README.\nYes there is something special with NSURLSessionConfiguration because NSURLSession objects created with an NSURLSessionConfiguration uses NSURLProtocol classes declared in the protocolClasses property of the configuration, contrary to NSURLConnection or the special case of [NSURLSession sharedSession] which use NSURLProtocol classes registered via +[NSURLProtocol registerClass:].\nBut you shouldn't need to call [OHHTTPStubs setEnabled:YES forSessionConfiguration:sessionConfig] explicitly yourself after creating [NSURLSessionConfiguration defaultConfiguration] because I installed method swizzling that takes care of that for you, so that [NSURLSessionConfiguration defaultConfiguration] returns the defaultConfiguration with the protocolClasses already including OHHTTPStubs' private NSURLProtocol.\nNote: Be sure anyway that you added the -ObjC flag to the OTHER_LINKER_FLAGS of your project (which is not related to OHHTTPStubs itself, but must be set everytime you link a project with an Objective-C static library)\n. One thing I didn't realize, you return a [[OHHTTPStubsResponse alloc] init] instead of some [OHHTTPStubsResponse responseWith\u2026]\u2026 it should do anything (like if [\u2026 responseWithData:nil]) but that's still a strange and undocumented use of my lib.\nAnyway, can you put some breakpoints in both your +sharedInstance, the +load method of NSURLSessionConfiguration+OHHTTPStubs that does the swizzling, and the methods like canInitWithRequest: of my private protocol, to see if it enters each method and in which order?\n. > Everything correct but this line is returning nil so the condition is return false\n\n[OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request]\n\n\nSo that means that your code to stubRequestsPassingTest: withStubResponse: didn't get called before your request has been sent. Or that you request to pass the test passed as the first parameter, but as in your example your test always return YES (which is not really a good practice, but still) this can't be the reason.\nVerify that [OHHTTPStubs allStubs] returns the list of stubs matching the one you created. (You may give names to your stubs as explained in the README to identify them easily)\n. > I think I found the issue, is in the singleton, when it adds the stub to the list it has this object as self\n\n<OHHTTPStubs: 0xa0df3f0>\nBut when it is accesses sharedInstance in\n[OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request]\nIts object id is:\n<OHHTTPStubs: 0xa2bceb0>\n\nCan you be more specific? I quite didn't understand your statement here ;)\n. > The line in your test example:\n\n[OHHTTPStubs setEnabled:YES forSessionConfiguration:sessionConfig];\nShouldn't be there if its enabled by default. Is there something special with NSURLSessionConfiguration?\n\nI don't know where you see this line in my test example?! I call this method nowhere in my Test Suites, indeed because it is not needed since I provided the swizzling to do it for you automagically.\nAre you sure you are using the right version of OHHTTPStubs?!\n. Ok I understand your analyze but I don't get how come the sharedInstance can point to a different object (despite the dispatch_once call). What if you put a breakpoint in sharedInstance, and especially in that part of the sharedInstance method where it affects its value, to check why it could be run twice and in which context (call stack)?! So we can understand at what point it could have been reaffected?!\nThx again for the investigation\n. waitForAsyncOperationWithTimeout is a method, not a class.\nI can't understand why the problem can be on concurrency, whereas dispatch_once is especially designed to be thread-safe, and is the official GCD way to make sure a resource or code block is executed only once, even if accessed from multiple threads. So this sounds really uncanny that you could enter into this dispatch_once block twice and make two different sharedInstances.\nCan you post your complete code somewhere? I feel like only having pieces with your comments\n. Ok I'll test that.\nBy the way, why did you use a global variables (which by definition is not thread-safe) for your onceToken and sharedInstance, instead of a static inside your sharedInstance method like we usually do? It really feels unsafe to me to give the opportunity to change the _sharedInstance variable from anywhere\n. Which doesn't make any sense, as it won't get reinitialized even if you got another test case, as your onceToken would already have been used and there's no way to reset it, right?\n. I ran you Unit Test (I guessed the superclass of your APTHttpClient was AFHTTPSessionManager?) on my machine, only went into +[OHHTTPStubs sharedInstance]'s dispatch_once block once as expected, the test passed without failing, no issue here.\n. I even added a STAssertEqualObjects(response, expectedResponseDict, @\"Unexpected response\"); at the end of your test, and if passes without a problem.\nXcode5, SDK7, test run on \"iPhone Retina (4-inch)\" and \"iPhone Retina (4-inch 64-bit)\" simulators, running iOS7.\nStill not understanding your issue.\n. Not tonite, I'm quite doing too much things at once already this evening and late for everything ^^ But maybe if you still have the issue over the weekend.\n. As said above, Xcode5 and SDK7 of course. (I couldn't even build AFNetworking 2.0 If I was not using Xcode5\u2026)\nBut I'm still using SenTestingKit as I haven't ported my tests to XCTest yet and my AsyncSenTestCase class is still a subclass of SenTestCase, and all my already written Unit Tests are using SenTestCase. (I know that only takes 2 minutes with the Xcode assistant, but as Travis-CI is still building with Xcode4 I still have to postpone the migration and am forced to keep using SenTestKit until then \u2014 but that shouldn't be an issue as SenTestKit is still supported by Xcode5).\n. Could you try again your original method (the one that didn't work) with the latest version/commit/HEAD, to let me know if it completely fixes your original issue?\nThx!\n. Note: 3.0.1 is out with this fix!\n. Hello again @danpizz \nWe are struggling with a related issue in #47 and I finally understood all the implications that you explain when you were talking about having two bundles when running Unit Tests.\nI in fact did the following test, as you could see in #47:\n- When selecting my Unit Test target (\"MyAppTests\") in my app's xcodeproj, then open the \"Target\" dropdown menu in the \"General\" tab of the test target, we have two options: either selecting the application's target (\"MyApp\") as the target for those Unit Tests, or selecting \"None\"\n- If I select \"None\", OHHTTPStubs is +initialize'd only once, we have only one singleton instance and everything works fine\n- If I select the application \"MyApp\" in this dropdown menu, when running the Unit Tests, my application's AppDelegate code gets executed (application:didFinishLaunchingWithOptions:) before my Test Bundle is loaded and my Unit Tests are executed. That's what you were talking about when you said that we end up with two bundles: the one for the application, that then loads the test bundle (quite like a \"plugin\")\n\nSo I have two questions that I hope you can help me with:\n- Do you see any case where we would need the \"Target\" dropdown menu to be set to the app's target (\"MyApp\") instead of \"None\"? In other words, would it be an acceptable solution to force users of my lib to set this dropdown to \"None\" ? I can't see why, when we create a new Xcode projet, this dropdown is set to the App's target by default instead of \"None\" and in which case is it necessary/useful to set it to the App's target ? Maybe for UI/Application Tests, but not for Functionnal/UnitTests?\n- Do you have any suggestion/idea of a way to protect my code against such case (OHHTTPStubs being loaded by two bundles, the application bundle + the test bundle), especially having some test that check if OHHTTPStubs is already loaded in another bundle and use this one instead (or at least not doing the swizzling in this case)?\nThanks in advance for your feedback\n. Maybe related to #37?\nAre you using CocoaPods to integrate OHHTTPStubs?\nDo you have a complete project to post somewhere so I can have a glimpse at your whole configuration (-ObjC flag and other flags used, integration used, etc?\nWhat is your requester.session.configuration, which kind of NSURLSessionConfiguration does it return, does the swizzling get triggered (it should, and in that case you shouldn't need to call setEnabled:forSessionConfiguration:), are you sure you're not using a backgroundSessionConfiguration, what are the protocolClasses installed, do the NSURLProtocol internal methods get triggered?\nThx\n. @alvarezloaiciga Are you talking about an issue in CocoaPods, or an issue in OHHTTPStubs, for the case when it is on both targets?\n@Goles Thx I'll take a look!\n. @Goles I don't understand your example project/workspace configuration:\n- You have a workspace containing OHHTTPStubs.xcodeproj, that builds the library libOHHTTPStubs.lib\n- You link your Unit Tests bundle to this libOHHTTPStubs.a. Great\n- BUT you also have a group External/OHHTTPStubs in your Example.xcodeproj projects, that only contains OHHTTPStubs.h and OHHTTPStubs.m and not the rest of my library ?! Why do you need adding this to your project in addition of having the lib?\nThe OHHTTPStubs.m file you added in your Example.xcodeproj/Example/External/OHHTTPStubs group is only linked with your Example application target (and not with the Unit Tests), so that's probably not the cause of the issue regarding stubs not being called in your Unit Tests, but still, this is some strange configuration of your project (that can lead to undefined and strange behavior, not knowing which implementation is used in each circumstance\u2026)\n. Also you call setEnabled:forSessionConfiguration: too late in your code.\nThe method [OHHTTPStubs setEnabled:YES forSessionConfiguration:requester.session.configuration]; is called in your code way AFTER you have created your NSURLSession with [NSURLSession sessionWithConfiguration:config] (which is done in your -[HIAPIRequests configureURLSession] method called by its init method\nAs stated in Apple's NSURLSession and NSURLSessionConfiguration documentation, an NSURLSessionConfiguration is deep-copied by the NSURLSession when it uses it to create the session, so modifying the NSURLSessionConfiguration AFTER creating the NSURLSession with it has no effect on the already-created NSURLSession\nNote that there is also a reminder in my own documentation (see the @note in the documentation of my setEnabled:forSessionConfiguration: method) that explains again that you should call this method on the NSURLSessionConfiguration BEFORE creating an NSURLSession with it. So you have no excuses here :smile:\n\nIn practice, due to my method swizzling that should be magically done by my NSURLSessionConfiguration+OHHTTPStubs category, you shouldn't even have to call setEnabled:forSessionConfiguration: so there is still an issue on my side, I will keep investigating to understand why my method swizzling does not get called. But aside from that, be aware of those issues in your code and your misuse of NSURLSessionConfiguration methods calling order.\n. Another note: your spinRunLoopWithTimeout:predicate: method lacks a XCTFail(@\"Timed out\") macro somewhere.\nIf the while loop exists not because of the predicate() turning to YES but because of the timeout being reached, the loop will exit and the test will end\u2026 and pass, whereas there has been a timeout and it should fail.\nStill not related to the original issue, but I thought you should know and fix your code on this too.\n. @alvarezloaiciga @Goles Please test the new HEAD (latest commit that includes my fix) to validate it correctly fixes your issues\n. Great :smiley: \nNote that from now on you won't need to call setEnabled:forSessionConfiguration: at all then. It is automatically done for you by the method swizzling, so you are assured that it is enabled soon enough and more importantly before you create of the NSURLSession with your NSURLSessionConfiguration.\n:arrow_right: So you can completely remove your call to setEnabled:forSessionConfiguration from your tests in the project example you gave me above.\nThe only usage you could have for setEnabled:forSessionConfiguration: would be to turn OFF stubs on a given configuration, BEFORE creating the NSURLSession with that config.\n. Ok thx.\n\nRegarding your spinRunLoopWithTimeout:predicate: method, that's better but in your code now checks for the timeout twice (once with [[NSDate date earlierDate:future] != future and once with [future timeIntervalSinceNow] <= 0.0f).\nI suggest you remove your [[NSDate date] earlierDate:future] != future test in your while condition, as:\n- It is time consuming (you create an NSDate instance with [NSDate date] at each iteration)\n- The while loop will break with an exception as soon as you reach the XCTFail\n. 3.0.1 is out with this fix!\n. Thanks for the bug report and Unit test!\nI just fixed this in Release 3.0.2.\n. What is your _session and more especially how is it created and configured?\n. I don't understand where in your code do you set the NSURLSession's delegate property?\nOf course if you don't tell which object is your delegate and has the implementation of those methods to be called, this will never happen.\nThis is not related to OHHTTPStubs at all (given your code, even without the stubs installed and even if you let your requests hit the real world, your delegate methods would never have been called anyway\u2026), so I'm closing the issue.\n. Please try making your code work even without OHHTTPStubs before filing a new issue to ensure that this is related to my component and not related to your own code.\nPlease then try to reduce the scope of your test to isolate the problem by using the simplest possible code to reproduce the issue. I'm sure that you can understand I won't have time to review all your own thousand LOC of your own project, especially if it's only to discover at the end that this is still not related to my component at all :wink: \nSo you should try and manage to create a simple Unit Test (that test unitary cases not involving a whole bunch of custom classes not relevant to the issue) that triggers the issue, and then I will consider it as a potential real issue from my component and not from your code, and have a real Unit Test case to resolve. But if you have the same issue w/o OHHTTPStubs or can't reproduce it in a simple independant Test Case, then it's probably a bug in your own code.\n. > submit a test project for you to review.\nPlease don't; I won't probably have time to review a whole project.\nProvide a Unit Test instead; the better way being to add the Unit Test directly in my project along with the other existing Unit Tests, and then propose a Pull Request (like the OP did in #39), so I can isolate and resolve the issue faster.\n. Hi @Goles \nI don't know if you managed to debug your own code, but I did some tests on my own and added a Unit Test to my own OHHTTPStubs project to test the use of NSURLSession delegates. And as you can see if you checkout my latest Unit Test and run it on your Xcode5, the test is passing without any problem and the delegate methods are called as expected.\nThis should confirm that the issue you were having with your code was not related to OHHTTPStubs at all.\n\n(Note: the test is not executed by Travis-CI yet because Travis-CI still uses Xcode4/iOS6 SDK which does not support NSURLSession)\n. I understand you didn't manage to find a failing test for any other delegate methods and download task, but only for upload?\nThat's an issue alright, but this is quite understandable: OHHTTPStubs is designed to stub network responses. Its aim is to mimic a response from a server. OHHTTPStubs was never designed to handle uploads until now.\nAnyway, that's true that it could be a great addition for OHHTTPStubs to make it handle data uploads too, simulating network speed and latency during upload too; but IMHO this is then a Feature Request more than a real bug as I never stated to handle data upload until now (the general principle of a stub is to return data, not to eat some). This is not even related to NSURLSession and was true even before its existence.\nPlease create a Pull Request with your Unit Test \u2014 describing in your request that you would like to OHHTTPStubs to support upload too \u2014 so I can follow this feature request and merge it properly.\nNote this would mean some refactoring of the startLoading method and handing NSOutputSteam in addition to the NSInputStream in place to upload data in addition to downstream the stubbed one, so that could be tricky and take some time\n. Actually, I'm not even sure it's possible to simulate upload, as NSURLProtocolClient does not allow us to signal the client that we sent data.\nSo except if you find something in the URL Loading System Programming Guide that describes a way to do this, I'm unfortunately quite sure this can't be done with a custom NSURLProtocolClient\u2026\nI'll keep searching but maybe Apple did forget to provide a way to implement our custom upload protocol\u2026\n. No I don't think it's still worthy to refactor your test as if you do it will fail and will never pass until we find a way to implement upload\u2026 which is probably not possible at all.\nSo it's still worthy to ask around in case someone finds a way to do this, but until then the Unit Test won't be useful as it would test a feature that is not implemented at all\u2026 and will probably never be if we don't find a way to.\nThx anyway and don't hesitate if you have any news about a way to do this feature.\n. No problem @jspahrsummers \nGlad you guys keep a merge-upstream branch to still keep GitHub products up-to-date with my lib :)\n. Hi,\n- Which version of OHHTTPStubs?\n- Using NSURLConnection, [NSURLSession sharedSession], or [NSURLSession sessionWithConfiguration:]?\n- Did you try breakpoints anywhere? Checked that you passed in the method that installs the stubs?\nAre you sure you did restore the context at the end of each of your test methods? Especially, maybe in the test that is just before the one you are trying there is a test that disables the stubs, and then you forget to reenable them at the end. Or forget to uninstall some stubs in the previous tests. Thus maybe test A disables the stubs, then test B runs but the stubs are still disabled if you didn't restore the context at the end of test A or in the -tearDown method. Whereas if you execute test B on its own, the stubs are not previously disabled by test A and they work fine.\nBest way to check this is to take advantage of the various debugging methods available:\n- Like give a name to your stubs (see <OHHTTPStubsDescription> protocol), and then use the allStubs method in your concerned test to check which stub are installed at the moment this problematic test of yours is run (see README for details which explains this technique).\n- You should also log in that test of yours at some point a message to tell the value of [OHHTTPStubs isEnabled] or force their setEnabled: state\n. Thanks for the feedback.\nCould you give an example / quote a code extract to explain the problem you had with your singleton? This way if others make the same mistake they can easily understand why it was not working and what they did wrong ;)\nThanks\n. Hi @evanspa \nFirst, this question is not related to OHHTTPStubs but to the URL Loading System in general, and the HTTP standard\u2014 this question can also be applied to regular NSURLRequests for which you want to send the same header multiple times.\nAnd contrary to what you state in your question, when you want to send a header with the same name multiple times, it won't look like you say on the wire. Instead, the RFC 2616 states that the various values of the header should be appended using a comma:\n\nMultiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.\n\nAnd that's exactly what the iOS URL Loading System does. For example when you build an NSMutableURLRequest and use -addValue:forHTTPHeaderField: in practice it appends the value if the field already has one, and when you request allHTTPHeaderFields (which returns an NSDictionary) it reflects this behavior:\nobjc\nNSMutableURLRequest* req = [NSMutableURLRequest new];\nstatic NSString* const kHeader = @\"Set-Cookie\";\n[req addValue:@\"abc=123; domain=example.com; path=/;\" forHTTPHeaderField:kHeader];\n[req addValue:@\"def=245;\" forHTTPHeaderField:kHeader];\n[req addValue:@\"ghi=356;\" forHTTPHeaderField:kHeader];\nNSDictionary* headersRFC2616 = [req allHTTPHeaderFields];\nNSLog(@\"headers: %@\", headersRFC2616);\n// headers: { \"Set-Cookie\" = \"abc=123; domain=example.com; path=/;,def=245;,ghi=356;\"; }\nYou can even check that the generated headers are correctly interpreted as cookies using Apple's NSHTTPCookie class:\nobjc\nNSURL* cookieOriginURL = [NSURL URLWithString:@\"http://example.com/\"];\nfor (NSHTTPCookie* cookie in [NSHTTPCookie cookiesWithResponseHeaderFields:headersRFC2616 forURL:cookieOriginURL]) {\n    NSLog(@\"= Cookie found in header: %@\",  cookie);\n}\n/*\n = Cookie found in header: <NSHTTPCookie version:0 name:\"abc\" value:\"123\" expiresDate:(null) created:2013-11-14 20:52:16 +0000 (4.06155e+08) sessionOnly:TRUE domain:\".example.com\" path:\"/\" isSecure:FALSE>\n = Cookie found in header: <NSHTTPCookie version:0 name:\"def\" value:\"245\" expiresDate:(null) created:2013-11-14 20:52:16 +0000 (4.06155e+08) sessionOnly:TRUE domain:\"example.com\" path:\"/\" isSecure:FALSE>\n = Cookie found in header: <NSHTTPCookie version:0 name:\"ghi\" value:\"356\" expiresDate:(null) created:2013-11-14 20:52:16 +0000 (4.06155e+08) sessionOnly:TRUE domain:\"example.com\" path:\"/\" isSecure:FALSE>\n*/\n\nSo that all said, that's exactly the same for when you want to stub your requests with OHHTTPStubs, no exception here. Simply concat your cookie values in the \"Set-Cookie\" header, separating them with a comma, as expected by the RFC 2616.\nYou can of course do this either by directly build your NSDictionary statically, appending the strings directly in your code\u2026 or use an NSMutableURLRequest* req just to call addValue:forHTTPHeaderField: on it, and at the end build your OHHTTPStubsResponse using [req allHTTPHeaderFields] as the headers (you may then discard your NSURLRequest that you used for the sole purpose of building the headers more easily)\n\nPS: Don't forget to finish your cookie headers with a semicolon ; otherwise the next cookie may be considered as a continuation of the path of the previous one! (leading with one cookie having the path \"example.com,def=245\" instead of separating it in the path \"example.com\" then a new cookie def=245)\n. Yes, I guess the \"repeated-header syntax\" may exist on the wire with some HTTP servers ; depending on the library used by those other softwares, maybe some repeat the Set-Cookie header instead of using the \"comma-separated syntax\". Actually, reading RFC2616, both syntax are allowed, as long as any HTTP header can be written in both syntax.\nBut anyway, that's not how iOS does it, as in my experiance the iOS' and OSX's URL Loading System always se the comma-separated syntax (probably because internally it uses NSDictionaries that can't have a header/key more than once so the \"repeated-header syntax\" would be more complex to handle otherwise\u2026)\n. Well, NSHTTPCookie and NSHTTPCookieStorage quite use the same concepts as the one you point out in Java:\nsee [NSHTTPCookieStorage setCookies:forURL:mainDocumentURL:] method that typically can take multiple NSHTTPCookie objects as its first parameter to add them all to the shared cookie storage \u2014 or simply setCookie: that can add only one at a time \u2014 :wink: \nAnd if you need to add cookies not in the NSURLCookieStorage but directly on a NSURLRequest, you can use NSHTTPCookie objects and convert them back and forth to request headers using +[NSHTTPCookie requestHeaderFieldsWithCookies:] and +[NSHTTPCookie cookiesWithResponseHeaderFields:forURL:] :+1: \n\nThe thing here is that whatever the method you use, I guess Apple chose to internally store headers in a NSDictionary, or at least they decided in the iOS&OSX URL Loading System that the header emitted uses the comma-separated syntax, so even if you add multiple cookie objects at once like in Java, the header generation will concatenate them at the end.\nI think Cocoa's URL Loading System still understand/correctly interpret incoming HTTP headers that are repeated on separate lines too, so that servers generating multiple lines for each Set-Cookie header still are interpreted correctly. That's just that when it comes to issuing an HTTP request payload, it generates the comma-separated variant as output.\nAccording to RFC2616, both are valid, as long as the headers can be written in both formats (\"it MUST be possible for headers that can be repeated to also be concatenated using comma to separate them\") with equivalent meanings.\n\nRegarding your remark with RFC6265 and the possible ambiguity with expires, it completes my \"PS\" in my above comment: to make sure there is no ambiguity, you should terminate each attribute with a semicolon, even the last attribute of your cookie. So in abc=123; Expires=Wed, 09 Jun 2021 10:18:14 GMT;,def=245 for example, as the date is considered to be \"everything between Expires= and the next semicolon\", there is no ambiguity as whereas the  comma after Wed is the end of the first cookie (first \"Set-Cookie\" header) or part of the date, because it will only consider the date attribute to be fully parsed when it hits the next semicolon (or the end of the string).\nIf you forget the last semicolon, as in abc=123; domain=.example.com; path=/,def=245 this will be considered to be a unique cookie whose path is /,def=245, whereas adding the semicolon after the / solves the ambiguity.\n. Nice one, will definitely merge this soon :+1: \nI don't have my Mac with me those days so it's hard to see this directly on GitHub, but do you confirm that you only made changes on the schemes/target generating the Example app and the Test target, but not the Static Library?\nI'm asking because I never actually tested OHHTTPStubs on a Mac target myself, so I'm especially wondering if the CocoaPods' OHHTTPStubs.podspec file is configured correctly so that you were able to add pod \"OHHTTPStubs\" to your Podfile and execute a pod install/pod update to add it in your own Mac application without any difficulty?\nNormally it should work without any problem, but as I never had the opportunity to check it in a real Mac project (only iOS projects), it seems to be the perfect occasion to confirm that using OHHTTPStubs with CocoaPods in a Mac app works properly.\nThanks for your feedback! :beers: \n. - Did you use CocoaPods to automatically configure you project for you in order to include the library transparently?\n- If you did integrate the library manually, did you check that you followed the recommended/proper way to integrate it (especially matching Configuration names in all projects, to allow implicit dependency detection, or add explicit dependency if not, following the Apple documentation and checked how you configured the Header Search Paths and all this?)\n- Did you also try to simply build the library for the iOS device (and not the simulator) first?\nAnyway, that's a problem entirely related to the way you configured Xcode and the Build Configuration, and how to integrate any static library so not particularly directly related to my lib ; so this has quite nothing to do as an issue here, I'm thus closing this issue. Maybe try asking the question on StackOverflow as it is a much proper place to ask generic questions about Xcode Build Settings and proper configuration to include any static lib.\n. Are you sure OHPathForFileInBundle(@\"patient_visit_review.json\",nil) return the path where you expect your json file to be, and that this file is correctly included in you test target so is included in your bundle when you build it for the test target?\nIf you create an OHHTTPStubsResponse with no data that would explain why you never get your response. Did you put a breakpoint in the response block somewhere at least?\n. @brennon I confirm @bobbytables answer : you initialize your client, using an NSURLSession and NSURLSessionConfiguration, before any call to OHHTTPStubs.\nOHHTTPStubs swizzle the NSURLSessionConfiguration constructors so that they include the OHHTTPStubsProtocol that allows the stubbing to take place \u2014 so that when you create a [NSURLSessionConfiguration defaultSessionConfiguration] for example, it already support the OHHTTPStubsProtocol that make the stubbing possible if any \u2014 so it should work without any change from your part.\nBut it does this swizzling in its +initialize method (I can't do it in the +load method as when the OHHTTPStubs image is loaded there is no guaranty that the NSURLSessionConfiguration class and image is already loaded yet so I cannot interact with it safely).\nSo you have to use the OHHTTPStubs class at least once (sending it any arbitrary Objective-C message) \u2014 so that its +initialize method gets called \u2014 at the beginning of your code to be sure that any subsequent NSURLSessionConfiguration created will support stubbing.\n\nIn summary, initializing your client after you setup the stub solves the problem, but you can also still initialize you client before setting up your stub as long as you call any method on the OHHTTPStubs class before creating your client. This suppose it can be as simple as (void)[OHHTTPStubs class]; or [OHHTTPStubs setEnabled:YES]; as long as a method call is invoked, because the Objective-C Runtime won't call +initialize until the first message is sent to the class.\nI'm closing this issue as the fix is given in my answer\n. Given what you describe, it seems that the method swizzling is done twice, leading to the orig_defaultSessionConfiguration variable to point to the OHHTTPStubs_defaultSessionConfiguration method instead of the defaultSessionConfiguration original Apple method, hence the recursive call.\nCan you place a breakpoint in the _OHHTTPStubs_InstallNSURLSessionConfigurationMagicSupport method to confirm that it gets called twice (whereas it should only get called once), thus making the swizzling thice?\nIf it is indeed get called twice, can you report me the call stack in each case to understand which methods trigger those two calls and why it is then called twice instead of once?\nI'll try to reproduce the bug on my side and add a protection against that in a future release but have to be sure about the reason first and be sure it will fix the issue for you too, so I'm interested in your feedback and debug informations.\n\nAnd one more question: does this happen only if you have the OHHTTPStubs pod referenced in multiple targets in your Podfile, like in the main target AND the test target (but not if it is referenced only in one or the other) ? If so, this may be a bug in CocoaPods that creates two libraries for OHHTTPStubs (one for each target) and is probably related to this similar (closed) issue ?\n. Thanks for all those tests and reports, hopefully it will help me track this nasty issue.\nI still can't understand how come the +initialize method can be called twice by the Runtime, whereas it is guarantied by Apple to be called only for the first method call of each class\u2026 this makes no sense to me, it's like there were two different OHHTTPStubs classes with the exact same name, ot that the Runtime's _class_lookupMethodAndLoadCache3 function was buggy and failed to see that it already initialized that class once before\u2026 very very odd\u2026\nI will try and reproduce the issue with the code you provide and investigate further ; unfortunately I am a bit busy lately and can't guaranty you that I'll have time to look into this this weekend.\n. @samir2303 I know that but unfortunately this cannot be the reason why the method is swizzled twice, as I already have this kind of protection against +initialize being called multiple times if a subclass does not implement it\u2026 Or maybe I have a problem in my protection code? But it does not seems like it to me\u2026\nThat's too bad because that would indeed have been a good lead, so I would have preferred that I forgot about it so that we would have the explanation and solution to this issue\u2026 but as the protection is in place, there must be another reason why +initialize is called twice\u2026 but both time for the same [OHHTTPStubs class]! :unamused: \n. @brennon could you maybe create a small project that highlight the issue and make it available so that we can easily test with the exact same conditions as yours? That would help us speed up the investigation and find what's wrong in OHHTTPStubs that causes this issue in your case.\nThx\n. I think I have a lead!\n- when I run the Unit Tests on one of my Xcode projet, the application:didFinishLoadingWithOptions: method of the application's AppDelegate is getting called (even as I am running the functionnal Unit Tests that have nothing to do with launching my real/complete application and showing its UI).\n- In there as I have a call to OHHTTPStubs, its +initialize method gets called, because that's the first time a message is sent to the OHHTTPStubs class by the hosting application\n- Then, my Unit Test code gets called, I there also have a call to  OHHTTPStubs and its +initialize method is also called.\nBut both calls are from different bundles: one from the application and one from the Test bundle! (that's actually quite what was explain in the comment of the other issue but I didn't quite understood it all the way until then)\nThat's a special case of when you run Unit Tests and made them be hosted by your application:\n- The iPhone Simulator starts running your application (thus executing its application:didFinishLoadingWithOptions: code, which is code from your application and not your Test Suite / Test Bundle)\n- Then it loads the .xctest Test Bundle (quite like if it was a plugin to the app) in memory and starts executing its testXXX methods\n\nI don't know if it can be considered as a bug of the iOS Simulator Runtime, as even if that's two different bundles/binary images loading the OHHTTPStubs in turn, that's a unique executable running the whole code so +initialize shouldn't get called a second time.\nTo avoid that behavior, and thus avoid the OHHTTPStubs class being loaded by both the host application (your app bundle's AppDelegate) and the test bundle, and +initialize being called twice, there is a simple solution: don't use your application as the target of your Unit Tests  (which if I'm not mistaken is only useful if you want to do application tests, like GUI testing, but not functionnal unit testing, right?)\nTo do that:\n- Select you application's project in your workspace on the left, then select your Unit Tests target (\"YouAppTests\")\n- Select the \"General\" tab, then in the \"Target\" dropdown menu that appears, instead of selecting your App target, select \"None\"\n\nNote that this is an issue that can happen with any other library/class that declare singletons and/or implement +initialize \u2014 it is not limited to OHHTTPStubs, and even if the solution I give above solves the issue by preventing Xcode to load both the application and the test bundls, having a protection in OHHTTPStubs's code would obviously be much better. Still trying to figure out a way to protect against the double-swizzling when that happen.\nI will keep the issue open as I would like to investigate more on that later, maybe find a way to avoid the swizzling to be done twice if people use their app as the target or their UnitTests instead of \"None\", and add some warnings about all that in the README, but first we need to understand all that strange behavior better\n. @brennon Thanks for the demo projet! But I don't understand how to use it: there is no Podfile in your repository (but there is Pods.xcconfig files, referenced in the xcodeproj but are missing), so I can't compile anything nor execute pod update\u2026 could you add them in your example repo so I can be sure to use the very same configuration as yours?\nAlso let me know if my solution above (changing the dropdown menu in the General tab of your UnitTest target to \"None\") solves your issue.\n. Hi again @brennon \nI just did a commit in a attempt to try and solve this issue at last \u2014 even when your UnitTest target uses your app as a host (and loads the OHHTTPStubs twice, once in the app bundle and once in the test bundle), so even in the case you don't apply my suggestion in my comment above. Please tell me if it solves your issue :+1: \n\nThis commit fixes two things:\n- The swizzling is now done in the +load method of an NSURLSessionConfiguration category, ensuring it only execute once instead of being executed as many times as the OHHTTPStubs class is loaded by the various bundles. This should solve the issue of the recursive call loop.\n- When the swizzled OHHTTPStubs_defaultSessionConfiguration function is called, I now use my [OHHTTPStubs setEnabled:forSessionConfiguration:] method directly instead of relying on objc_getClass(). This should solve the issue about the stubs not being called With the previous code, objc_getClass(@\"OHHTTPStubsProtocol\") would always returns the OHHTTPStubsProtocol that were loaded by the main bundle, which were only referencing stubs added from the main bundle and not stubs added in your Unit Tests that were referenced by the other OHHTTPStubsProtocol class \u2014 the one loaded by your xctest bundle\u2026 hence the issue\n\n\nTo try and use it, and confirm that it actually solves your problem, simply change your Podfile to point directly to my repo URL, so that CocoaPods loads the HEAD of my repo (instead of the latest public release):\npod \"OHHTTPStubs\", :git => \"https://github.com/AliSoftware/OHHTTPStubs\"\nThen once you do a pod update CocoaPods should tell you that you now use OHHTTPStubs (3.0.4) (version of the HEAD of my repo) and you can test your code with it. I will only push this version 3.0.4 onto CocoaPods' public PodSpec repo \u2014 and make an official release \u2014 once you actually confirm that this really solves the issue and does not introduce any regression on your side.\n\nThis mess with the iOS simulator loading two different bundles and thus loading some classes more than once is a tricky one! I hope it solves your issue at last. Please keep me posted! :beers: \n. @brennon are you sure about that?\nThe change I made, namely doing the swizzling in the +load method of a category of NSURLSessionConfiguration instead of in +initialize of OHHTTPStubs now allows the swizzling to take place very early and even if you never call any method of OHHTTPStubs before creating your first NSURLSessionConfigurations.\nThat way, you can now call [NSURLSessionConfiguration defaultConfiguration] even in the early stages of your code and in your production code without the need to call any OHHTTPStubs method beforehand and without changing anything in your production code now.\n\nThe only thing to keep in mind is that when you do GUI-testing \u2014 and thus select your app target in the \"Target\" dropdown menu in the Test Target \u2014 and have the OHHTTPStubs pod in both your targets, then you end up with two different OHHTTPStubs (and OHHTTPStubsProtocol) loaded in memory (one in each bundle), so you have kind of two independent sets of stubs (and your NSURLSessionConfigurations will register the two different OHHTTPStubsProtocol classes \u2014 one from each bundle \u2014thus testing the stubs installed by the application bundle first, then the stub created by the test bundle.\n\nThat's not really related to OHHTTPStubs itself directly, but rather to the way Xcode loads the bundles to perform GUI testing, loading the app bundle first then the test bundle. Thus loading the external libraries in both bundles (if they are referenced in each bundle) creating two duplicate but independent classes (thus two different singletons etc.)\n\nSo as a result, all stubs registered in the OHHTTPStubs loaded by the app bundle will be tested first, then only after that will stubs registered in the OHHTTPStubs loaded by the test bundle will be tested. So stubs installed by the test bundle won't override/preempt stubs installed by the app bundle.\nBut that's quite logical if you think about it, as stubs created in the application bundle are part of the application itself (like to stub a server API that is not available yet)\u2026 so it makes sense that if you have stubs created by your application code, those are tested too by your test code, right?\n\nIf you really want to manipulate (disable/remove/\u2026) stubs installed by your application code, so that they don't get in the way of the stubs you create in your test suites, you may use the Class returned by [[NSBundle mainBundle] classNamed:@\"OHHTTPStubs\"] (instead of using the OHHTTPStubs token directly) to manipulate them from your test suite:\nobjc\n- (void)setUp\n{\n    // Get the OHHTTPStubs that is loaded in the application's bundle\n    Class AppOHHTTPStubs = [[NSBundle mainBundle] classNamed:@\"OHHTTPStubs\"];\n    // and remove all its stub as we want to use only the stub we will setup in our Test Suite\n    [AppOHHTTPStubs removeAllStubs];\n}\n\n\n[x] TODO: Write a wiki page about that tricky case and talk about it in the README\n. I just did the following test that confirms what I just explained:\nI create an AFURLSessionManager instance in application:didFinishLaunchingWithOptions:,  and store it in an AppDelegate's @property(strong) sessionManager.\nI have an UIButton in my interface whose associated IBAction calls [self.sessionManager GET:parameters:success:failure:\nI also have a Test Suite that calls [OHHTTPStubs stubRequestsPassingTest:withStubResponse:] to create a stub, then calls the very same IBAction directly (to fake a tap on the button, that's the GUI-related test).\n\nAs a result:\n- When I run my application normally and tap on the UIButton, the real request gets called. (If I had created an stub in application:didFinishLaunchingWithOptions:, that stub would have been called instead)\n- But when I run my Test Suite, the stub created in my Test Suite gets called. In details:\n  - The NSURLSessionConfiguration(OHHTTPStubs)'s +load method gets called automatically and do the swizzling\n  - Then the application:didFinishLaunchingWithOptions: method gets called and create the AFURLSessionManager instance. Thanks to the swizzling the NSURLSessionConfiguration created by this AFURLSessionManager supports the OHHTTPStubsProtocol transparently \u2014 even if you have never called any method on OHHTTPStubs yet.\n  - Then the Test Suite is executed, creating the stub then calling the IBAction \u2014 that uses the AFURLSessionManager to send a network request \u2014 and the request is stubbed there.\nAnd all that without having to change a thing in the original application's code that you can keep untouched. So that seems to fit the use case you need, right?\n. Cool !\nI just released version 3.0.4 (see here).\nI will now have to write a dedicated article to explain this tricky case in details, in case other users have the same problem of having to disable the AppDelegate's stubs when running their Application Tests\u2026\n. @JustinDSN thanks for the reminder, I totally forgot about that article that I had to update.\nI just wrote every details in it and I hope it covers every use case.\nIn summary:\n- Either you really need Hosted Tests that launches the app before loading the test bundle (because you are doing UI testing) and in that case don't link any library (OHHTTPStubs included) in both targets because they will end up being loaded twice. Instead, only link those libs with the app. But that's probably not your case\n- Or you don't do UI testing and then you don't need Hosted Tests. In that case select \"None\" from the \"General\" tab of your Test target, and then your app bundle won't be loaded when you run your tests and you may link OHHTTPStubs with both the app and test targets, as those targets will be truly independent then and the app bundle won't be loaded when the tests are run.\n. @nicolasmiari-unext Background sessions are handled by the system itself, we can't hook on them as they are performed out-of-process and thus out of reach for interception. See the \"Known Limitations\" section in the README for more info.. That's indeed a strange one! I'll try to find some time next week to investigate a bit why you have a nil request (even if I'm not sure I have any leverage on this, as this is the responsibility of the OS itself).\nAnyway, please note that as explained here in the README, OHHTTPStubs uses NSURLProtocolClient to catch the network requests and this Apple class does not allow us to catch upload requests, so unfortunately those can't be stubbed.\n. This last issue is maybe related to #51 (as everything causing this assertion to be thrown is likely to be caused by a thread race-condition)?\n. I'll assume this is a duplicate of #51 and close this one. Please continue any related discussion on issue #51 :)\n. Wow why oh why didn't I do that this time?! :confused: \nI normally do that for all my @protocol every time, I wonder why I forgot this time!\n. As a side note, as stated in the README here, the OHHTTPStubsDescriptor objects are retained internally by OHHTTPStubs (up until you call removeAllStubs/removeLastStub/`removeStub: to remove them), so you are not really required to retain it yourself for it to be kept alive. You may only keep a __weak reference to them instead.\nThat behavior is quite similar to NSTimer objects for example, that are retained by the NSRunLoop in which they are scheduled \u2014 and thus don't strictly need to be retained by your own code to be kept alive \u2014 and are released when you call invalidate to unschedule them and remove them from the NSRunLoop.\n. Hi @pbernery \nThis issue was already encountered by someone else and is a tricky case when you mix Application Tests and Unit Tests. See issue #47 for more details where we finally understood what was going on.\nI was planning on writing a dedicated wiki article to explain this tricky case in details, but haven't got the time to publish it yet.\nIn summary, the problem is that when you run Application Tests, Xcode will launch your application in the simulator (and calling you UIApplication and its delegate's methods, like application:didFinishLaunchingWithOptions: and all), and then will load the test bundle as a \"plugin\" (dynamically loaded bundle) inside your application.\nAs a result, there are two different bundles loaded in memory with executable code (which is a pattern that can be encountered in OSX development when you develop plugins but are normally never encountered in iOS as iOS apps are forbidden to dynamically load executable code \u2014 that's maybe why it's not familiar to you \u2014 \u2026 except that Xcode use this OSX mechanism to execute iOS Application Tests).\nThe consequence it that the OHHTTPStubs class that you use in your \"Application Bundle\" code (like when you use it to stub your unimplemented Web Services) and the OHHTTPStubs class that you use in your \"Tests Bundle\" code are not the same classes in memory as they are the same class but duplicated in two different bundles. And thus have separated installed stubs (stubs installed in the class loaded by the Application Bundle are not shared with stubs installed in the class loaded by the Tests Bundle).\nActually, that's generally what you expect, as stubs installed by your Unit Tests should only affect Unit Tests itselves, and stubs installed by your application should only affect your application code and not your test code too. This is all because Xcode loads the application bundle first and the test bundle then separately, as two separate executable bundles.\n\nIf you don't do any Application Tests (like GUI testing) but only do Unit Tests (like functional tests to test your WebServices and all) that don't need your Application and its UI to be running:\n- Select your Project on the File Navigator,\n- then select your Unit Tests target\n- Then in the \"General\" tab of this test target, choose \"None\" in the \"Target\" dropdown that appears to avoid your application bundle to be launched before your Unit Tests bundle.\nThis way your UIApplication won't be launched, its delegate methods won't be called, and you will only have the Unit Test bundle and only one OHHTTPStubs class. Of course, as a result, as they won't be loaded by the app bundle anymore when running your tests, you will need to add all the classes you want to test (like your WebServices classes) to your Xcode's UnitTest target in order to address & test them.\n. Hi there\nJust to let you know I finally written/updated the dedicated wiki article about this issue (at last!)\nMy opinion is that you should simply not link OHHTTPStubs with your test target as it is already linked against your app target and this latter will load/host the test target ultimately. This will prevent the OHHTTPStubs lib to be loaded twice and would avoid such issues. This is also true for any other library linked against both your app and test target when you are doing application tests.\n. Hi,\nDo you have a small/minimalist example project where you can reproduce this issue?\nAs the assertion states, this seems illogical that startLoading is called if no stub has been identified to respond to the request beforehand, but maybe I missed a tricky case?\nSomething related to multihreaded & race-conditions maybe? (like canInitRequest being called at a time there are some stubs installed, but the stub being removed in between before startLoading is called, even if all of this should happen in the same runloop? But I can't see any use case where this would happen\u2026)\nAnyway, an example project would help me a lot to debug this!\n. In addition, did you try to removeAllStubs in tearDown instead of setup?\nIt seems to me more logical to clean up the stubs you installed in a test case after this test case (instead of at the beginning of the next one) and it maybe solve your crash (even if I prefer to find a proper solution to fix this issue correctly so it can never happen again)\n. Are you sure about that? Normally every Test framework correctly built (XCTest, OCUnit, GHUnit, etc\u2026) execute its tearDown method even when the test fail or generates an exception (which is catched by the test framework, to mark the test as failed \u2014 except if you XCTAssertThrow and did expect the exception to occur of course in which case it marks the test as succeeded).\nThat's what makes tearDown so interesting actually.\n. @dreed1 Thanks for the feedback.\nI probably have an idea of the cause: do both of you ensure that the request has time to receive a response \u2014 or to timeout \u2014 before the end of your test cases?\nEspecially, NSURLConnection (and any other way to send an NSURLRequest) are generally asynchronous (in a dedicated NSURLConnection thread), so if you don't wait for some time and don't block your test case code to let the request being sent (and catched by OHHTTPStubs) and instead let your test code finish before the request had time to be sent/processed, then the test code will end\u2026 and the tearDown will be called (thus removing your stub) before the request was finished processing.\nYou should at least use something like [[NSRunLoop mainRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]] for example, to let the runloop run some iterations and the request to be processed (see -(void)waitForAsyncOperations:(NSUInteger)count withTimeout:(NSTimeInterval)timeout for an example on how I do this in my own code)\n. Damn so that's not the cause\u2026\nStill interested by some code to reproduce it, understand what exactly you are doing and what can cause this\u2026\n. Ok thanks for the feedback @marcelofabri \nSo I'll start on the assumption that this only happens when you remove the stub after you sent the request but before waiting for the response to be returned (or the timeout to be exceeded), typically when you don't block your Test Case to wait for it (like when you forget to use Expecta's will operator)\nI'll try to secure all this a bit more anyway to avoid a crash in such case. Maybe just removing the assertion (and just returning directly without doing anything in startLoading when the stub is nil \u2014 even if it wasn't by the time canInitRequest: was hit) will suffice\u2026 but I think issuing some warning to let the user know that something was odd/wrong was a nice idea\u2026\nIf you have any suggestion on how I could detect and warn the user properly so that s/he realizes that s/he may have forgotten some active wait method (like the will operator) in one of his/her test case or something\u2026 and to make sure their test results are deterministic and not with a random race condition in such case\u2026 that would be nice :)\n. Ok, so I should probably change the message of the assert so that it is a bit more explanatory, like:\n\nYou started a request that was stubbed by OHHTTPStubs, but removed the stub before the request even had time to finish. If you are using OHHTTPStubs in your Unit Tests, be sure to block your test cases until the request has finished and the response has arrived, so that the test doesn't finish and the stub doesn't get removed before the response was complete! \n\nI should even definitely write a wiki article at some point to explain this use case more thoroughly and how you should make your test cases wait for the response to arrive before the test can end and its status (success/failure) can then correctly determined. I would then put a link to this article in the assertion message to help users that encounter this.\nMaybe even don't make it an assertion, but just a log message to help users understand that asynchronous tests always have to somehow block the test case at the end before all asynchronous operations are finished.\n\nWill hopefully do that this weekend, but please remind me to do so if I didn't come up with this article past next week, I got a lot on my plate and I am able to forget about it :wink:\n. I never used Expecta, but shouldn't will precisely wait / block the code/current thread, until the expectation is reached (or timeout)? Then if that's the case and if you use will in every of your tests, I don't understand why you would have the assertion, as will would wait for the request/stub to be finished and the response to be fully arrived to unblock the code and continue, right?\nMaybe you could c/p a sample test of your Test Suite here to help me understand why you would hit the assertion in your specific case?\n. This last commit should fix it, by storing the stub in a @property as soon as possible to be sure to keep it around (and by replacing the NSAssert call with a simple NSError in case this race condition should even happen again)\n:arrow_right: Version 3.1.1 has been pushed to CocoaPods with this fix.\n\n@gfontenot It retried your example project after applying this fix and wasn't able to reproduce the issue even after running your Unit Tests about 20 times.\nBut as this happens intermittently I may have been very lucky and just never got into the bad race condition since, so don't hesitate to keep me posted if you happen to fall into this issue again.\n. ping @gfontenot Is this still the issue you are dealing with on Twitter? Did you try to pod update OHHTTPStubs on your project?\n. Some code or a sample project maybe? More code, more info, etc? Logs are far from enough to help me debug this!\nWhat version of OHHTTPStubs are you using, are you sure you use the latest which fixes issues with automatic support of NSURLSession (thus AFHTTPSessionManager)?\nIt seems strange anyway regarding your logs that the log says \"Posting request 0xe1efbc0 with body:\" letting us suspect an empty body, and that your assertion states that both the request body and the expected body are empty \"\" (and that assertion fails maybe only because of different typing?) I see nowhere in your logs where you sent the XML.\nAnd finally it seems strange that you Unit test your request body (which is what you send, on which OHHTTPStubs does not have any control) instead of your response body (which is what OHHTTPStubs returns when you stubbed the request)?\nAnyway, more info is needed for me to help you on this. I'm not even sure that it is related to OHHTTPStubs itself at all.\n. I see you still check the uploaded/sent data, not the stubbed response.\nOHHTTPStubs is designed to stub network responses, to stub the data that would normally be returned by a distant server to a network request. Not to simulate data upload sent to it.\nSo this is probably related to this point \"OHHTTPStubs don't simulate data upload\" already explained in the README.\n. Yes, or at least post the code of your test case, I can't see how I could help you without seeing a minimum piece of the code you are using.\n. I just tested your project.\nI commented your XCTAssertEqualObjects(requestedBody, expectedBody) and put some breakpoints to see what was going on.\nWhen iOS calls NSURLProtocol's canInitWithRequest: method for the first set of times (as part of the URL Loding System mechanism managed by iOS and the runtime), the request passed as a parameter does not have any HTTPBody (= nil) when called thru an NSURLSession.\nEven bypassing AFNetworking and using [[NSURLSession sharedSession] dataTaskWithRequest:req] directly makes +canInitWithRequest: be called with an NSURLRequest with no HTTPBody \u2014 whether we use OHHTTPStubs or not (and use a dedicated NSURLProtocol for the test).\nSo I believe the issue you are experimenting is not related to OHHTTPStubs but to how Apple's NSURLProtocol and NSURLSession works. This leads to NSURLProtocol's +canInitWithRequest: method to be called with a request with an empty HTTPBody, because HTTPBody and HTTPBodyStream properties are handled internally and specifically by Apple for the HTTP protocol (for the specific internal NSURLProtocol originally managing the \"http://\" scheme by Apple). This seems to be supported by various StackOverflow answers like url=http://stackoverflow.com/questions/9301611/using-a-custom-nsurlprotocol-with-uiwebview-and-post-requests.\nIf you put some symbolic breakpoints on Apple's +[NSURLProtocol canInitRequest:] method you can see that this is true regardless of whether you use OHHTTPStubs or not; the request passed to the NSURLProtocol will always have a nil HTTPBody.\nI don't really understand why Apple does this, using the HTTPBody only for requests managed by Apple's internal NSURLProtocol to handle http:// scheme but not to custom protocols\u2026 maybe you should file a bugreport to Apple directly about it.\n. Thanks @lukabernardi \nIssue duped in my own bugreport.apple.com ; and maybe the problem is also present on iOS6, when using NSURLConnection (and a custom NSURLProtocol class registered using the +[NSURLProtocol registerClass:] method)?\nI guess I can close this issue and mark it as an Apple Bug.\n. Damn you're right\u2026 and as if it wasn't strange enough, NSURLConnection seems to call +canInitWithRequest: only once but NSURLSession calls it\u2026 3 times :astonished: \n. @lukabernardi Actually that's kinda strange that in your example with NSURLConnection it is only called once\u2026 because I clearly remember having identified this multi-call of +canInitWithRequest: in the past, even at the beginning of the OHHTTPStubs project (way before iOS7 and NSURLSession existed).\nThat's actually what made me refactor my API in version 2.0.0 and drove me crazy at that time in the beginning of the project too ;)\n\nIf you're interested in some digging in my code, you can see that in the previous API I had an addRequestHandler: method only one block \u2014 instead of one for the test and one for the response like now \u2014 and I did introduce the onlyCheck parameter at that time because I already saw that the +canInitWithRequest: was called a lot with the same request before startLoading was even called. So the onlyCheck parameter was a way to avoid building the response as many times as canInitWithRequest: was called for nothing\u2026\n\nNow what's strange is that this is now not the case with NSURLConnection  any more\u2026 but is back with NSURLSession :astonished: Or maybe it depends on other mysterious hidden factors\u2026\nSometimes Apple acts in mysterious ways :laughing:\n. ;) That's probably related, as every [NSURLSession fooTaskWithBar:] are proably based on the same codebase, all returning an NSURLSessionTask subclass at least\u2026 But I'm afraid to wonder how this is implemented under the hood if even with those public subclasses made available, they had the need to do a class cluster and to use private internal classes\u2026\nDidn't investigate on what those private subclasses were / looked like, and neither tried and understand why they needed such a design pattern / architecture, but I'm afraid it's related to handle differently requests to internal and external protocols\u2026\nI think I'll stop wondering and stop digging, I already went crazy long ago since version 1.0 with the multi-call to canInitWithRequest: :laughing: \nCheers :beers: \n. Given the probable toll-free-bridging needed/used to handle all this with CFNetwork internally (I guess), that's not really surprising :wink: \n. Guys, I got another workaround which seems cleaner than adding a dummy header and won't alter your requests:\n- Use [NSURLProtocol setProperty:forKey:inRequest:] to associate whatever data you need to your request (for example the request's initial HTTPBody or directly the request's parameters, or the XML-RPC method or whatnot)\n- Then test it in your stub condition block using [NSURLProtocol propertyForKey:inRequest:].\nI just confirmed that it works using @jpalten 's example project.\n\nFor those who are using AFNetworking to build the request, one can provide a custom subclass of AFHTTPRequestSerializer that calls super then add a call to [NSURLProtocol setProperty:parameters forKey:@\"parameters\" inRequest:request] to it in order to query that property in your stubs. Tested that as well and works like a charm.\n. I just wrote a small Wiki Page with all the details about this workaround and some suggestion/example on how to implement it when using AFNetworking to build your requests.\n\nThis would allow you to do stuff like this:\n```\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) {\n    NSDictionary params = [NSURLProtocol propertyForKey:@\"parameters\" inRequest:request];\n// Only stub POST requests to \"/login\" with \"user\" = \"foo\" & \"password\" = \"bar\"\nreturn [request.HTTPMethod isEqualToString:@\"POST\"] && [request.URL.path isEqualToString:@\"/login\"]\n    && [params[@\"user\"] isEqualToString:@\"foo\"] && [params[@\"password\"] isEqualToString:@\"bar\"];\n\n} withStubResponse:^OHHTTPStubsResponse (NSURLRequest request) {\n    return [OHHTTPStubsResponse responseWithData:validLoginResponseData statusCode:200 headers:headers];\n}].name = @\"foo/bar login\";\n``\n. @samskiter thx for the feedback :+1: \n. Hi all, this issue should now have a workaround thanks to #166 (which has just been merged into master)!\nYou'll now be able to use the newOHHTTPStubs_HTTPBodyproperty onNSURLRequest` if you want to test your request body in stubs even after iOS cleared the native property now.\nWill update the wiki entry and do a release soon.\n. That's a good idea, but how would you imagine the API for that?\nFor example if you write:\nobjc\nid<OHHTTPStubsDescriptor> myStub =\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n    return YES;\n} withStubResponse:^OHHTTPStubsResponse*(NSURLRequest *request) {\n    NSData* stubData = [@\"Hello World!\" dataUsingEncoding:NSUTF8StringEncoding];\n    return [OHHTTPStubsResponse responseWithData:stubData statusCode:200 headers:nil];\n}];\nHow would you then trigger the response of a specific/given request, even as this stubs every request (return YES in first block)? We can't imagine a method like [myStub triggerResponse] in that case\u2026\nAnother solution would be to add this kind of API on the OHHTTPStubsResponse object, like a -(dispatch_block_t)responseTrigger method on OHHTTPStubsResponse so you can do something like this:\nobjc\n__block dispatch_block_t sendResponseBlock = nil;\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n    return YES;\n} withStubResponse:^OHHTTPStubsResponse*(NSURLRequest *request) {\n    NSData* stubData = [@\"Hello World!\" dataUsingEncoding:NSUTF8StringEncoding];\n    OHHTTPStubsResponse stubResponse = [OHHTTPStubsResponse responseWithData:stubData statusCode:200 headers:nil];\n    sendResponseBlock = [stubResponse responseTrigger];\n    return stubResponse:\n}\n// some code that send a network request, that will be catched by OHHTTPStubs\n// then when you want to trigger the response:\nif (sendResponseBlock) sendResponseBlock();\nBut still that won't solve any problem, as:\n- At the time the if (sendResponseBlock) sendResponseBlock(); line is hit, the RunLoop won't have excuted and the request won't really have been sent, as NSURLConnection handles networks request using events watching installed on NSRunLoop (that's why there is a scheduleInRunLoop:modes: method on NSURLConnection)\n- Even so, network requests are typically asynchronous, so you would have to block your Unit Test code anyway to wait for the request to be at least sent (which is done asychronously by NSURLConnection or NSURLSession anyway)\nThe problem being that Cocoa's URL Loading System has a dedicated thread that manage network requests to send them and manage the response, and is the one responsive for calling -canInitRequest: then startLoading (asynchronously, on this dedicated thread) on the NSURLProtocol classes like the one OHHTTPStubsProtocol uses.\nSo I'm afraid we don't have much control over this, as all this process is asynchronous by nature.\nBut if you have any suggestion on how to implement it and how would the OHHTTPStubs API could look to make this work, please share as this would be quite an interesting feature!\n. Agreed, i'll keep it open and label it accordingly.\n. Closing this as it has been open for too long without any new propositions. Feel free to reopen if any idea to propose this comes to mind but I think this is conceptually impossible.\n. Given your code, that's entirely normal. You don't generate JSON anywhere in your code.\nYou are using NSKeyedArchiver, which creates archives (some binary representation of your data, in an obscure format only known to Apple). This does not AT ALL creates a JSON representation of your data.\nWith your code, the variable NSData* data contains some binary representation of your responseJSON dictionary. But you expect (and actually state in your response headers as well) that you are returning JSON (so some textual representation), which you are not.\nTo generate JSON from some NSDictionary, use the NSJSONSerialization class (and its class method +dataWithJSONObject:options:error:), but not NSKeyedArchiver which has noting to do with JSON.\nOr better yet, you could use my OHHTTPStubsResponse+JSON.h category, which provides commodity methods that do this JSON serialization for you and even add the \"application/json\" header if you don't provide it yourself.\nSee the README.md where this is explained; some code example about using responseWithJSONObject: is even provided in the README.\n. Thx!\n. As stated in the README, OHHTTPStubs can't work with -[NSURLSessionConfiguration backgroundSessionConfiguration]. See README for details.\n. Ok merci je regarde \u00e7a\nPar contre un malloc c'est bien mais il faut le balancer avec un free (contrairement \u00e0 une allocation statique qui se d\u00e9salloue toute seule quand on sort du scope) sinon tu as une \u00e9norme fuite m\u00e9moire !\n. Hi @jmburges \nI don't know KIF (never used it) so I just Googled it and found some info and tutorials about it (like this one).\nAs stated I never used KIF before, but from what is explained in the tutorial, isn't the - (void)beforeAll method of your KIFTestCase a more suitable place to setup your stubs for your KIF-testing environment?\n. Hi @jmburges \nSince I don't know KIF I probably won't be of any help here. I suggest you ask your question on StackOverflow to see if KIF users have some insight on where to put that initialisation code in KIF.\n. :+1: Hopefully will have time this weekend to merge all that!\n. As explained in the README you are disabling the stubs too late.\nThe way Apple's [NSURLSession sessionWithConfiguration:] work is that it creates a deep copy of the configuration to create the session, thus as explained in Apple's NSURLSession documentation itself, the sessionConfiguration can't be altered afterwards. Or more precisely, as it has been deep-copied by the NSURLSession, modifying your configuration object after it has been used to create the session won't affect the already-created session.\nAnd because this behavior from Apple's NSURLSession, the only solution is to change the sessionConfiguration object before creating the NSURLSession object with it. So to call [OHHTTPStubs setEnabled:NO forSessionConfiguration:sessionConfig] before creating the NSURLSession object with it. You can't use webServiceClient.session.configration because it means that the webServiceClient.session object has already been created, meaning it's too late already.\n.  Note that this was also explained in #38 (this comment).\n. Actually the paragraph in which I was explaining it seems to have been removed by a recent commit when I reduced a bit the size of the README by moving examples and help topics out of it to migrate them it the wiki.\nIt seems I've forgotten to add/migrate this paragraph as an entry in the Help Topics on the wiki, so I'm re-opening this issue just to be sure not to forget to add it when I'll have time for it next week.\nBut it is documented both in Apple's documentation and in my own method's doc, so\u2026\n. Strange. Are you sure you use the same instance of webServiceClient then in your tests and not for example your [WebServiceClient sharedClient] instead?\nIf not, could you provide a simple and uncluttered sample with only the related code and failing test case?\n. Cool so I will close the issue then.\n(I will maybe not even write the article in the wiki, as it is already explained in details both in Apple's NSURLSession documentation and in the \"Note\" paragraph of the [OHHTTPStubs setEnabled:forSessionConfiguration:] method own documentation\u2026 so if users don't RTFM they probably won't read the wiki either\u2026)\n. thx!\n. Hi @paristote \nThanks for your issue, sorry I didn't have time to help you with it.\nGlad you fixed it and thanks for the feedback!\nI'll wait for your confirmation then close it afterwards ;)\n. Hello,\nThis is probably a duplicate of #52. The HTTPBody of requests passed to NSURLProtocols are known to be inaccessible (probably already turned into HTTPBodyStream objects by Apple internally).\n\nSo I believe the issue you are experimenting is not related to OHHTTPStubs but to how Apple's NSURLProtocol and NSURLSession works. This leads to NSURLProtocol's +canInitWithRequest: method to be called with a request with an empty HTTPBody, because HTTPBody and HTTPBodyStream properties are handled internally and specifically by Apple for the HTTP protocol (for the specific internal NSURLProtocol originally managing the \"http://\" scheme by Apple). This seems to be supported by various StackOverflow answers like url=http://stackoverflow.com/questions/9301611/using-a-custom-nsurlprotocol-with-uiwebview-and-post-requests.\n. PS : As suggested by @lukabernardi in the other post, I encourage you fill a bugreport to Apple by duplicating the radar issue http://openradar.appspot.com/15993891\n. FYI, I just wrote a short wiki article to suggest a nice workaround \u2014 using [NSURLProtocol setProperty:forKey:inRequest:] and [NSURLProtocol propertyForKey:inRequest:] and how to implement it for use with AFNetworking 2.0.\n. Hi there\n\nThanks for reporting the issue.\nI didn't have the time to try OHHTTPStubs with Swift yet, but your code seems correct.\nI'm currently on vacation but I'll have to investigate and do some more tests when I'm back to check this out and will keep you posted.\n. Method swizzling is only used in OHHTTPStubs for NSURLSession. What did you guys use in your failng code, NSURLSessions or NSURLConnections?\n. @cvasilak Loool I just found that out myself and went there to post about it\u2026 but you beat me to it! Nice catch! :)\n\nThe reason this broke in iOS8 is that:\n- before iOS8, -[NSURLSessionConfiguration protocolClasses] was only containing custom protocol classes you wanted to add in addition to the system internal NSURLProtocols. So this array was empty (no custom NSURLProtocols) by default \u2014 and was not exposing any of the internal protocols \u2014 and my code added my custom OHHTTPStubsProtocol to this empty array, making it the only custom protocol. Probably then iOS7 would check the custom protocols listed in protocolClasses before checking its own, internal protocols.\n- But since iOS8 (beta1 thru beta4), the method now returns an array that also contains the internal Apple's NSURLProtocols (namely @[_NSURLHTTPProtocol, _NSURLDataProtocol, _NSURLFTPProtocol, _NSURLFileProtocol, NSAboutURLProtocol] to be precise). And I was adding my OHHTTPStubsProtocol in the last position instead of the first, making it be tested AFTER the _NSURLHTTPProtocol internal protocol (which was thus catching every requests before OHHTTPStubs had a chance to bypass them), contrary to the iOS7 behavior.\nI don't know if this is a feature in Apple's iOS8 version of the protocolClasses property (in that case, the documentation is not up-to-date), or if it is a bug introduced in iOS8 (and Apple will fix it so that the protocolClasses array will be back to an empty array by default).\nBut in any case, I will publish a patch to OHHTTPStubs very soon (and a feedback to Apple too about the documentation needing to be updated :wink:)\n\nI hope this is a feature btw: this would mean that we could _remove some internal protocols from the session if we want to, like removing FTP support and so on\u2026 this would open to more customization of our custom NSURLSessions for some specific cases/applications_ :+1: \n. Fix commited!\n\nI'll close the issue; please let me know if you guys managed to reproduce the issue after using the latest commit / HEAD. If you can still reproduce it, I'll reopen the issue of course.\nIf the issue is confirmed to be fixed, I'll release a new pod version very soon (probably right after converting all my tests to XCTest in my next commit\u2026 :wink:)\nThanks all for the feedback (and sorry for the delay for such an easy fix)!\n. Thx @cvasilak for the feedback! Great news :) Will release a version tonite.\n. Version 3.1.4 tagged and pod  3.1.4 released!\n. Hi @cvasilak I just saw @corinnekrych at dotSwift that told me you are using your own implementation of OHHTTPStubs, I'd be very interesting in getting in touch to see how we can team up for Swift support in OHHTTPStubs!\n. Let's move that discussion in a dedicated issue to avoid spamming this one ;)\n. Thx!\n. Thanks @samirGuerdah for taking time to answer for me :)\nThanks @rosiakr for the update.\nI'll close this issue then.\n. Done :)\n. Work started in branch XCTest.\nAlmost ready, just need some final checks:\n- [x] ensure that nothing is broken: try to use it in a project (using it as a pod that points to this branch)\n- [x] ensure it works the same way in Xcode5 and Xcode6 ; in particular when\n  - [x] an expectation is fulfilled twice\n  - [x] an expecation is fulfilled after its associated test has finished\n. Yeah I may add them as an optional subspec maybe, good suggestion.\n. Done ! :smiley: \nVersion 3.1.5 now includes a new subspec XCTestExpectation that imports this class too\n(class that is now in the OHHHTTPStubs/XCTestExpectation+Xcode5 folder and not in UnitTests anymore, FYI)\n\nSo now:\npod 'OHHTTPStubs'\ndoes NOT include the XCTestExpectation+OHRetroCompat.{hm} files, but only OHHTTPStubs itself (as with previous versions). This in fact import the Core subspec, which is the default subspec\nAnd:\npod 'OHHTTPStubs/XCTestExpectation'\ndoes include the XCTestExpectation+OHRetroCompat.{hm} files, but does NOT include OHHTTPStubs itself (so that you can use XCTestExpectation+OHRetroCompat without using OHHTTPStubs if you only need the XCTestExpectation support).\nSo if you want both, don't forget to add both lines in your Podfile:\npod 'OHHTTPStubs'\npod 'OHHTTPStubs/XCTestExpectation'\nThanks again for the good suggestion!\n. Hi @mamaral \nI have to admit that I'm not sure to understand your process and what exactly you are trying to achieve.\nCould you provide some more code/example (or maybe a simplified code sample)?\nAlso instead of removing the last stub (are you sure this is the one you expect?), you should better keep the returned id<OHHTTPStubsDesriptor> returned by your first [OHHTTPStubs stubRequestsPassingTest:withStubResponse:], and use removeStub: with it when you want to remove the given stub, instead of using removeLastStub and risking to remove a stub other than the one you expect.\nAnother solution would be to only register one stub for your request, and use some kind of flag in your withStubResponse: block to return either the first JSON or the second one depending on the flag.\n\nOne last piece of advice, avoid returning YES directly in stubRequestsPassingTest: because it would thus stub every request, including ones not related to your API/WebService. Imagine that in the future your code generate a request to TwitterConnect or to any other API in addition to your own server, as a side effect, then you would want to avoid stubbing all requests with the same JSON. I know that this is probably unlikely in your case but I believe it is a good practice in the general case anyway, at least to use some condition similar to return [request.absoluteString hasPrefix:kExpectedURLToStub]; or return [request.host isEqualToString:kYourwebServiceHost];.\n. Yes it does make sense. So to implement the two solutions I did suggest in my comment above, here is the pseudo-code:\nSolution 1 : Keeping a reference to the stub to remove\n``` objc\n-(void)test504then200\n{\n  NSDictionary json504 = \u2026; // JSON dictionary to return for the 504 response\n  static NSTimeInterval const kDelay504 = 2; // delay before the 504 response returns\n  NSDictionary json200 = \u2026; // JSON dictionary to return for the 200 response\n  static NSTimeInterval const kDelay200 = 2; // delay before the 200 OK response returns\n__weak __block id stub;\n  BOOL(^requestFilter)(NSURLRequest) = ^BOOL(NSURLRequest *request) {\n    return [request.URL.host isEqualToString:@\"mywebservice.com\"];\n  };\nstub = [OHHTTPStubs stubRequestsPassingTest:requestFilter\n                             withStubResponse:^OHHTTPStubsResponse(NSURLRequest request)\n  {\n    // Remove myself and install new stub for next time\n    [OHHTTPStubs removeStub:stub];\n    [OHHTTPStubs stubRequestsPassingTest:requestFilter\n                        withStubResponse:^OHHTTPStubsResponse(NSURLRequest request)\n    {\n      return [[OHHTTPStubsResponse responseWithJSONObject:json200 statusCode:200 headers:nil] responseTime:kDelay200];\n    }];\n// Return response for first stub\nreturn [[OHHTTPStubsResponse responseWithJSONObject:json504 statusCode:504 headers:nil] responseTime:kDelay504];\n\n}];\n// Your code that sends the request, will get a 504, will retry the same request and then get the 200.\n}\n```\nUsing a flag to return a different response (simpler code)\n``` objc\n-(void)test504then200\n{\n  NSDictionary json504 = \u2026; // JSON dictionary to return for the 504 response\n  static NSTimeInterval const kDelay504 = 2; // delay before the 504 response returns\n  NSDictionary json200 = \u2026; // JSON dictionary to return for the 200 response\n  static NSTimeInterval const kDelay200 = 2; // delay before the 200 OK response returns\n__block BOOL didSend504Response = NO;\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) {\n    return [request.URL.host isEqualToString:@\"mywebservice.com\"];\n  } withStubResponse:^OHHTTPStubsResponse(NSURLRequest request) {\n    OHHTTPStubsResponse response = nil;\n    if (!didSend504Response) {\n      response = [[OHHTTPStubsResponse responseWithJSONObject:json504 statusCode:504 headers:nil] responseTime:kDelay504];\n      didSend504Response = YES;\n    } else {\n      response = [[OHHTTPStubsResponse responseWithJSONObject:json200 statusCode:200 headers:nil] responseTime:kDelay200];\n    }\n    return response;\n  }];\n// Your code that sends the request, will get a 504, will retry the same request and then get the 200.\n}\n```\nI personally prefer the second solution, which is more simpler to read IMHO. But the first solution is to demonstrate that if you want to remove a stub, it is suggested to keep a reference to the stub to remove in an __weak id<OHHTTPStubsDescriptor> variable, and then use removeStub:, instead of using removeLastStub (which btw is a method that I may deprecate in a near future)\n. I would indeed first think that the issue you had was due to how you implemented your stubbing and removed stubs + restubbed. But given that you still have the problem even if you only run one Unit Test, it indeed seems still kinda odd that it would fail.\nSo even if my code solves your problem, further digging into the cause of the original issue in your code would still be interesting, just to make sure that this is not related to OHHTTPStubs itself and does not hide an underlying bug in my code.\n. Hmm seems like the first request either is never stubbed and hits the real world which talked more than 4 second to respond, or the request is stubbed but the response is never sent or does not have time to be sent to its end until the 4s timeout expires.\nIs the corresponding withStubResponse: block actually called during the test?\nMay you post the code of your unit test, both the code that install the stub and the one that send the request?\n. I definitely don't get it. Given your code this should work and not timeout.\nCan you add some logs in your test to check when the handlers of both the successfullyConnectWithCompletionHandler: and successfullyDisconnectWithCompletionHandler: gets called, in order to keep track which request may take time? (Maybe the first stub is returning its response immediately but the second one takes too much time, maybe it's the first one that already takes too much time, etc)\nAlso, adding a name to your stubs and calling [OHHTTPStubs onStubsActivation:\u2026] to log when the stubs get called would help us debug what is going on.\n. Stupid question: are you sure that your connectWithAPIKey: method is successful in your test case, and thus calls its successHandler: and not its errorHandler: or alertHandler: (which are nil thus do nothing)?\n[_manager connectWithAPIKey:_testAPIKey successHandler:^{\n    handler();\n} errorHandler:nil alertHandler:nil];\nCause if in your case, for some reason this method ends up calling its errorHandler: instead of its expected successHandler: (error in your code, connection error that was forecased in your unit test, \u2026) it would explain why your Unit test reaches the timeout (as the [self successfullyDisconnectWithCompletionHandler:\u2026] code would then never been called by your code).\nit's at least worth checking, by adding breakpoints and logs and all..\n. Don't hesitate to add a name and the onStubsActivation: code as pointed in my previous comment to better follow if the stubs gets called but takes too much time to respond or if it gets stuck.\nAlso don't hesitate to put breakpoints in the code of OHHTTPStubs itself, especially to check if the startLoading method of my internal OHHTTPStubsProtocol class gets called (and if so, if it does call the NSURLProtocol's client methods to tell that new data has been received and when the response is finished).\nIf you are not confortable with my own  OHHTTPStubs code and have trouble to understand which methods should normally get called and where to put breakpoint and what to check in my code, feel free to create a sample project (with the bare minimum inside) to demonstrate your issue, so that I could run it in my own Xcode and add breakpoints and investigate on my own.\n. As before, the console output only helps to see the actual result, but does not help much to debug and understand what is the reason of the issue, so I'll let you keep investigate in your project using breakpoints and all, that's the only way you could better understand what is actually going on (and I can't do it myself until I have a sample project to run into Xcode on my end) :wink:\nKeep me posted and good luck in your investigation!\n. Hi,\n1) Even after running the testConnect and testDisconnect unit tests you provided 15 times in a row, I wasn't able to reproduce the issue :cry: Will keep trying a bit, but it will be hard to debug if I can't reproduce :unamused: \n2) What is the purpose of the shouldFulfill boolean variable? I mean, my XCTestExpectation implementation already check if there is unfulfilled expectations in its tearDown implementation as well as once the timeout is hit (to ensure that those expectations are not fulfilled by the time the timeout is reached\u2026 even if they are fulfilled afterwards ) so I don't think this shouldFulfill boolean is necessary.\n. And additionally, I am not sure I understand your stubbing logic: In both successfullyConnectWithTestName:completionHandler: and successfullyDisconnectWithTestName:completionHandler: you stub with the exact same stub.\nSo in successfullyDisconnectWithTestName:completionHandler:, why bother removing the first stub (installed in successfullyConnectWithTestName:completionHandler:) to reinstall\u2026 the exact same one?\n. > 1) I ran those tests probably hundreds of times and as said it isn't very rare, but it is reproducible on two different machines running two different beta versions of Xcode intermittently.\nI continued running the tests using the code you provided, and still no luck :cry: Maybe my SSD MacBookPro is too fast for this test to fail?\n\n2) Regarding the shouldFulfill BOOL, in some cases when the request comes in after the test has completed and the completion handler is called and subsequently the expectation is fulfilled, an exception is thrown and the tests crash - \"'API violation - called -[XCTestExpectation fulfill] after the wait context has ended.'\", that was just a hack to prevent the crash, I'm thinking it might be a bug in the Xcode beta, but not sure yet.\n\nOk gotcha. And no that is not a bug in Xcode beta, that is documented behavior in the XCTestExpectation API IIRC. So your condition makes sense now.\n\n3) Those two example tests have the same response code, but different payloads, - which in this case will be the name of the test for debugging purposes, so they are technically not the same responses.\n\nOh yes sorry, as you called [self stubResponseWithStatusCode:200 dictionary:@{@\"test_name\": test} delay:0]; in both methods I read that too quickly and first thought it was the same dictionary, without seeing that there was a variable for the value of test_name key in there. My bad.\n\nAre you running all the tests at once, like using Command-U, or do you run them one at a time?\n\nI tested both, starting by running all of them ~10 times using Command+U, then testing only the testDisconnect \u2014 the only one that install 2 stubs and not one \u2014 unit test (by clicking on the diamond next to its code) a lot of times (didn't count them, probably ~50 times?)\n. Given the fact that it is highly unpredictable and highly random to reproduce, I'd say it's probably a threading race condition \u2014 the sneakiest and hardest bugs to catch as it is really hard to reproduce the exact timing conditions to have the issue, and adding logs or logging breakpoints would slow down (even by a very little amount) the execution of one thread, leading to change the threads scheduling regarding each other, and thus making the issue disappear.\n. Maybe because when you have the issue, due to threading race conditions, the request gets sent just before the stub gets installed, so in those rare cases when you have this kind of bad timing, the request is sent to the real network instead of being stubbed.\nAnd then maybe it takes more than 4 seconds for iOS to realize that the server in the real world does not respond (because you haven't implemented the code on the server side yet) \u2014 because the NSURLRequest has a timeout of 60 seconds by default, explaining why the test fails and hits its 4s timeout.\nThen when the next test is run, the same case arise, thus the stub you install for this one is registered very soon after the request is sent, so this 2nd request misses the 2nd stub, but the 1st stub being still installed (due to the race condition it will be removed just after, a little bit too late), is used for this 2nd request instead.\nThis would explain why the first request times out and the second request hits the first stub.\nIf that's what is happening, the only question remaining is why does this thread race condition occurs\u2026\n. As you only gave my 3 source files and not the whole project, it does not surprise me in fact that I haven't been able to reproduce it on my side.\nGiven your source files, I had to create the xcodeproj myself, create the Podfile and do the pod install, and configure it in my end. This means that I could end up in a quite different configuration from your own, like maybe I have different build settings (compiler optimizations settings, specific optimizations like code parallellizing, different build architectures, etc), and a quite different code context (e.g. you probably have a lot more classes in your own project, that means that more classes are registered in the runtime, that may mean very slight (but sufficient for a race condition to occur in one case and not the other?) different execution times of every message sent / method calls, and whatnot\u2026\nAs racing conditions are extremely hard to reproduce and depend on so many things, like compiler optimizations, code context, actual CPU the code is run on, etc\u2026 I'm unfortunately not surprised that given only your 3 files and no project settings and a different context from your own case, I was not able to reproduce it (I tested it on my MacBookPro/SSD from work but I just tested it on my own personal MBPr/SSD with no luck either :cry:)\n. I've tested with Xcode5 and Xcode6\u00df7 at work, and Xcode6\u00df4 at home.\nMy Podfile was using the more modern CocoaPods syntax:\n``` ruby\nxcodeproj 'OHHTTPStubsBug7/OHHTTPStubsBug7.xcodeproj'\nplatform :ios, '7.0'\ntarget :OHHTTPStubsBug7Tests do\n  pod 'OHHTTPStubs'\n  pod 'OHHTTPStubs/XCTextExpectation' # To use XCTestExpectation when using Xcode5\nend\n```\n\nPS: Please use 3 backticks in your GitHub comments to format your code and make it more readable \u2014 or ident it with 4 spaces so that GitHub render it as code\n. Closing due to lack of feedback and the subject/issue has drifted away from the original issue.\n. Thx!\n. @Goles so did the fix & updating your copy of OHHTTPStubs solve your issue?\n. @Goles In your sample project:\n- you first waitForExpectationsWithTimeout:handler:(which is a blocking call) and only THEN you [GETTask resume] to start the request \u2014 no wonder the stub never gets called, your request does not even get fired at all!\n- you forgot to fulfill your expectation too\n- You forgot to add -ObjC in your Build Settings, leading to OHHTTPStubs's NSURLSession support not being loaded when linking with the library\nI fixed your Unit Test to fix those two issues in your code and the test passes like a charm.\n``` objc\n- (void)testExample {\n    XCTestExpectation responseArrived = [self expectationWithDescription:@\"response of async request has arrived\"];\n    NSURL url = [NSURL URLWithString:@\"http://www.lalalalololo.com/\"];\n__block NSData *receivedData = nil;\nNSURLSessionDataTask *GETTask = [_session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n    NSLog(@\"Completed!!\");\n    receivedData = data;\n    [responseArrived fulfill]; // <--- [AliSoftware] Added this to fulfill the expectation once the request has completed\n}];\n\n[GETTask resume]; // <--- [AliSoftware] Moved this line BEFORE the waitForExpecatation\n\n[self waitForExpectationsWithTimeout:5.0 handler:^(NSError *error) {\n    XCTAssertNotEqual(receivedData.length, 0); // <--- [AliSoftware] Changed to make it actually fail when not stubbed / when the NSURLSessionDataTask failed\n}];\n\n}\n``\n. Also note two other errors in your sample project:\n1. **YourXCTAssertNotNilassertion is not enough** to test that your request succeeded.\n   - If theNSURLSessionDataTasksfails, its completion block will still be called, with an non-nilerrorand\u2026 **an emptyNSData** (i.e. **datawon't benil** in case of an error, but will be a zero-lengthNSDatainstead).\n   - So in this case, thisXCTAssertNotNilwill not fail asdatawon't be nil even in case of error\u2026 and your test will pass anyway!\n2. **You forgot to add the-ObjCLinker Flag to your Test project**.\n   - If you importOHHTTPStubs(or any static library for that matter), you should always add the-ObjCflag to the \"Other Linker Flags\" Build Settings (for **each** target linking with a static library), so that the linker also link with ObjC **categories** (like the one that does the swizzling forNSURLSessionin theOHHTTPStubs` lib).\n   - When you integrate any lib using CocoaPods (instead of doing it manually), CocoaPods does that for you automagically.\n. Thanks!\nWill merge as soon as I fixed the Travis failing build (which is a travis configuration matter and not related to your PR)\n. Version 3.1.7 is out and pushed on CocoaPods!\n. Thx! Strange that I use the right MIME type in the code here (OHHTTPStubsResponse+JSON) but did not use the good one in the README ^^\n. Hi @jcampbell05 \nYou you be a bit more specific? Could you provide some code and some steps to reproduce so I can investigate? What kind of NSURLSessionTask are you using? what code are you using to send the task? how do you stub the request?\nThx\n. Ping, can you give more intel about this? I can't reproduce nor fix it with more info.\nDid you check that you are not doing an upload / NSURLUploadTask ? (This use case is described in the README, and Apple's NSURLProtocol does not handle uploads)\n. up. (will have to close this one if I can't reproduce nor have a sample to look and ensure that's a real issue)\n. Hi @asymptotik \nThanks for your feedback.\nI never used AmazonSDK, can you point me what the code of the Amazon SDK is doing that may interfere with my +load method and swizzling? Any link to the aforementioned SDK source code so I can investigate what they mess up with (probably doing some swizzling on their own, but maybe not as transparently and \"other-existing-protocols-friendly\" as mine)?\nThe behavior of +load being called even when no header is included is intended. It is how +load works, and is the right place to do the swizzling, otherwise OHHTTPStubs won't work out of the box. But given what I do in that method, it will only then intercept methods for which you have installed stubs anyway, so it shouldn't interfere with any other network call if you haven't used OHHTTPStubs in your code but only added it.\nCould you also give more information as to how you integrate OHHTTPStubs in your project?\nDid you use CocoaPods as recommended, which will ensure that each separate 3rd party lib (like OHHTTPStubs and AmazonSDK) are built separately and use separate Build Settings that won't interfere with each other? If you included the OHTTPStubs files and the AmazonSDK files directly into your app project via drag&dropping the files alongside with your own code, conflicting build settings may be the reason.\n. Closing for lack of input. Please reopen if you got any news or sample code to reproduce.\n. Nope.\n1. ASIHTTPRequest is obsolete and deprecated since a while now (multiple years I believe) and is not maintained anymore. The official repo have even be removed from GitHub by its author. You should migrate to another library.\n2. ASIHTTPRequest did NOT use the standard Cocoa URL Loading System. Instead at the time they created the library, they reimplemented a whole HTTP standard themselves using sockets and low-level methods, instead of using the Cocoa networking layer like NSURLConnection & NSURLSession as well as AFNetworking and other libs do.\nIt has been years that people don't use ASIHTTPRequest anymore anyway and its support dropped by the community anyway.\n. That's a very good idea, thanks for the PR!\n. If I understand it correctly, this means that the NS_DESIGNATED_INITIALIZER macro that has been added by @samirGuerdah on PR #79 and merged on latest 3.1.9 version does not work with older SDKs, especially SDK 7.1 that you seem to use when compiling your project with Travis.\nI'll have to get a fix for that, thanks for notifying!\n. @nikolajpedersen can you confirm that when it passes locally when building with Xcode, you are actually building with the SDK 8.x (Xcode 6.x)?\nWhereas you probably didn't explicitly configure your Travis build to use on Xcode 6 and especially the latest SDK \u2014 so travis may use a VM with Xcode 5 when building your project \u2014\u2026 or your .travis.yml mention the SDK 7.0 explicitly in the script you make it run, explaining why the command you run contains -sdk iphonesimulator7.1?\n. Newly published version 3.1.10 should fix the issue.\n(@nikolajpedersen can you confirm this?)\n. I probably forgot to add the fix to another header. I won't have time to investigate this until mid-January once back home with my Mac (but don't hesitate to create a PR to add the fix on your end so I can merge it quickly in one click from my iPad if you cannot wait that long, the fix seems quite easy)\nBy the way, why do you guys still need to compile your code using a different SDK than the \"LatestSDK\"? I mean, why forcing to use the older, obsoleted SDK (SDK7), instead of using SDK8? The only reason why one may happen to still build using an old SDK is if one use an old version of Xcode, but even then, you should simply specify -sdk iphonesimulator and not sdk iphonesimulator7.1 and Xcode will automatically select the latest SDK. Then if you intend to test on the iPhone Simulator 7.1 for testing your app, you can use the -destination flag of xcodebuild for example to select the OS version of the simulator on which you want to test.\nThe version of the SDK to compile against is NOT the same as the version of the simulator you want to test onto, so don't use an old SDK to test on an old simulator, that's not how it is done, and that's not how Xcode does it when you test and run your code inside Xcode, event when you run your code on a 7.1 simulator, Xcode still uses the Latest SDK (8.1 for now).\n. Thanks!\n. I believe this is because NSURLSession adds the HTTPAdditionalHeaders at the very end just before sending the request to the network, so you are querying them too soon?\nWill try and investigate but I'm not sure it has anything to do with OHHTTPStubs code itself, but more to do with the way Cocoa URL Loading system handles this property and when it uses it to add the headers. Will keep you posted.\n. Unfortunately I just confirmed that it seems to be iOS's fault.\n(1) I created a NSURLSessionConfiguration and NSURLSession as in your code:\nobjc\nNSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];\nconfig.HTTPAdditionalHeaders = @{ @\"User-Agent\": @\"Test User Agent\" };\nNSURLSession *session = [NSURLSession sessionWithConfiguration:config];\n(2) Then sent a request with this session:\n``` objc\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"foo://unknownhost:666\"]];\n[request setHTTPMethod:@\"GET\"];\n[request setValue:@\"application/json\" forHTTPHeaderField:@\"Content-Type\"];\n[request setValue:@\"application/json\" forHTTPHeaderField:@\"Accept\"];\nNSURLSessionDataTask task =  [session dataTaskWithRequest:request\n                                         completionHandler:^(NSData data, NSURLResponse response, NSError error)\n{\n           NSLog(@\"Completed\");\n}\n```\n(3) I set a breakpoint in my NSURLProtocol subclass, right in the very beginning when it gets the request passed on, so in the implementation of - (id)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)response client:(id<NSURLProtocolClient>)client method, and dumped request.allHTTPHeaderFields there.\nAt that time, OHHTTPStubs has no control: it's iOS itself (the URL Loading System mechanism handled by iOS and the underlying stack inside Cocoa) that calls this NSURLProtocol's method and pass it the request before it is sent. And as I have just tested, at that time the request that iOS passed on to me does not contain the HTTPAdditionalHeaders  when dumping allHTTPHeaderFields.\nSo unfortunately this issue does not seem to be coming from my own code (where I could have had overridden the headers maybe, in that case I could have had that fixed) but from iOS itself :disappointed: \n\nPS: Probably this HTTPAdditionalHeaders property is only used privately by the private implementation of the HTTPURLProtocol that is in charge of usually processing HTTP requests to send them to the network, and custom NSURLProtocols don't have access to such properties (NSURLProtocol does not have access to the NSURLSession that handles the NSURLRequest thus I cannot even recreate/re-implment this and take that -[NSURLSession.configuration HTTPAdditionalHeaders] property into account :disappointed: \nIf you have any suggestion on how to hack into that, I'm interested.\n. Hi again,\nI've started working on a branch to workaround this issue.\nFeel free to test this branch in your code and tell me if it fixes your issue. If so I'll cleanup the code and ensure it's portable (even for those using older SDKs/versions or still using NSURLConnection etc) and include it in the next release.\n. I just discovered a very strange behavior:\n- when testing on iOS7, the additional headers specified in the session configuration are added.\n- they are missing only on iOS8!\n@rsaunders100 Do you observe the same behavior on your app?\nThis comforts me in the fact that this is an iOS bug. I encourage you to fill a radar / bug report to Apple.\n(I'll probably continue working on the branch with the trick that allows me to access the NSURLSessionConfiguration so that I can maybe provide a workaround, but this still seems to be an Apple issue that should be addressed by Apple itself)\n. Hi @rsaunders100 \nDo you still have the issue with iOS8.1, 8.2 and 8.3?\nOr has Apple fixed the issue since then?\n[EDIT] Ok nvm, I misread the tests I recently added; the issue is still present in iOS8.3, still trying to find a workaround for this Apple bug (but it's quite hard as we don't have access to the NSURLSessionConfiguration from the NSURLProtocol and the NSURLProtocol (NSURLSessionTaskAdditions) category, even if declared in NSURLProtocol.h, does not seem to be implemented at all by Apple\u2026)\n. Nice, thanks! :+1:\nI'll probably review this during the week-end.\nI think it would be best to rename existing targets (and thus generated products) to make it more clear/explicit now, right?\n- OHHTTPStubs iOS :arrow_right: OHHTTPStubs iOS StaticLib\n- OHHTTPStubs iOS Framework :white_check_mark: \n- OHHTTPStubs iOS Tests :white_check_mark: \n- OHHTTPStubs Mac :arrow_right: OHHTTPStubs Mac Framework\n- OHHTTPStubs Mac Tests :white_check_mark: \n. Cool, thanks a lot!\nWill merge this soon :)\n. According to Travis, it seems that the OHHTTPStubs iOS Framework is not configured for Testing.\nThat can make sense not to run tests for this scheme on Travis (since we already ran the iOS Tests using OHHTTPStubs iOS StaticLib scheme), but I think we should:\n- Configure the OHHTTPStubs iOS Framework for testing, and associate its test action to the OHHTTPStubs iOS Tests test target. That way if the scheme is selected in Xcode and the user hits Cmd+U then the tests for iOS are run\n- But configure .travis.yml to only run the build (or analyse) action (and not the test action) on this OHHTTPStubs iOS Framework scheme, as the iOS Unit Tests will already have been tested by Travis when the test action would be run on the OHHTTPStubs iOS StaticLib scheme.\n. In the meantime, I just opened a new issue #87 to push this further and add more travis destinations, especially because we should run  unit tests both for iOS7 and iOS8 to ensure there is no regression when there are changes in iOS8 internals like we have observed before.\n(Just to be clear: we should add the line described by @corinnekrych to .travis.yml for this PR to pass, and #87 will only be for after this has been merged)\n. Thanks @indragiek for the terrific work.\nAs I was inspecting the code, I see that you added the exported variables OHHTTPStubsFrameworkVersionNumber and OHHTTPStubsFrameworkVersionString.\nBut the \"Apple-Generic\" versioning system (activated in the Build Settings on the OHHTTPStubs iOS Framework target) generates OHHTTPStubsVersionNumber and OHHTTPStubsVersionString variables (without the Framework in between)\nWe could fix that in the lines you added in OHHTTPStubs.h to remove the Framework part. But using the Apple-Generic versioning system means that I have to fill that version number each time OHHTTPStubs increase its version manually (and it can only be a double, not a 3-digits version number). That's error-inducing as I'm sure I'll forget to change that build setting each time I bump the pod version anyway.\nAre you ok if I get rid of the Apple-Generic versioning system for the iOS Framework (as I did for the Mac Framework at that time) to be more consistant? Or did you have any specific reason to use it when you created the iOS framework target?\n. :+1:\n. Just thought that it could also be nice to update the \"basic example\" in README to add its Swift variant\n(and later on even update the Wiki \"Usage Examples\" page too, so that it also have the Swift versions for each?)\n. FYI, Carthage section just added here 02cc9fcc0cdfca79e1968df9e3e072c256e5e593\n. At the time I created OHHTTPStubs, target xxx do directive was not part of the CocoaPods DSL.\nNow that it is, I see no objection to migrating to target 'UnitTest' { pod 'AFNetworking' } instead of a submodule :+1:\nIf we do that, don't forget to fix the README (those lines) to remove the specific instructions\n. This future config has been introduced in the README here and we should get rid of the whole paragraph once this is done\n. Cool thx!\n. This has been fixed by #90 :+1:  Thx\n. For reference we may probably use the Travis build matrix feature to avoid repeating the same command again and again and just use the matrix to build multiple configurations.\n. Done. Travis now shows a nice build matrix to show the status of each configuration separately (so if one fails we can see which one and investigate in its build log only, without being lost in a too long, unique console log)\n\n. [Update] It appears that Travis recently dropped the iOS7 Runtime Simulator on their OS X VMs. Or maybe we got lucky when building the last time and were attributed a VM that had it installed, but it does not seem to be the case on every Travis OSX VMs.\nI emailed their support to ask them to add that iOS7 Runtime to all their OS X VMs, and disabled the compilation on iOS7.1 in the meantime. Wait & see.\nI'm reopening this issue to keep track of how things evolve with them and see if we can add it back in the future or if we will have to drop it.\n. One interesting stuff to demonstrate in the demo is the possibility to use trailing closures, something like this:\nOHHTTPStubs.stubRequest({$0.URL.scheme == \"stubs\"}) { req in\n    // .... Build and return the appropriate OHHTTPStubsResponse\n}\n. Mmmmh. Probably an xcodebuild bug indeed.\nSo as I understand it, you duplicated the iOS Unit Tests target to assign this copy to the iOS Framework target and change its Deployment Target, right?  \nMaybe it would be simpler just to remove the test target from the framework scheme altogether rather than having two duplicate targets to maintain.  \nAfter all, the Unit Tests target only contains functional tests (there is no integration test or whatnot in there), so as long as one can run those tests, it should be ok. The only important thing here is that the test can be run, making them run from the static lib or framework shouldn't change their behavior, so only having them associated with the StaticLib scheme should be sufficient, right?\n. Hey, just for my information, because I'm not that familiar with Cartage yet:\n\nCould not install OHHTTPStubs using Carthage if iOS 7 simulator is installed\n\nIsn't Carthage only supposed to use/be compatible with iOS dynamic Frameworks? And as frameworks are only supported since iOS8, how come you try to run it with iOS7 simulator then?\nIs that supposed to work at all? I mean iOS7 + frameworks are not compatible in the first place anyway, right?\n. Thanks.\nNote the original error still seems to make sense for me, regardless of the test target stuff:\nxcodebuild: error: Failed to build workspace OHHTTPStubsDemo with scheme OHHTTPStubs iOS Framework.\n    Reason: The run destination iPad 2 is not valid for Running the scheme 'OHHTTPStubs iOS Framework'.\nif your destination is using the iOS7 runtime, this error makes sense as iOS7 is not compatible with dynamic frameworks that was introduced with iOS8, so I'm not sure your error originates from the test target after all.\n. Maybe you should file an issue to Carthage then, right?\nI mean, given what you describe, that issue is with xcodebuild and Carthage, so OHHTTPStubs is by far not the only framework this issue will be happening with; it's gonna be problematic with every library out there on GitHub having the same kind of configuration\u2026\n. Damn. I don't like that our libraries (I mean not just mine but any other lib developer's too) have to do workarounds for a tool that don't want to fix issues on their end :cry:  Sad that Carthage does not want to fix that at the common place :unamused: \nThat means that if one wants Carthage support, we need to report this workaround on _every of our libraries instead of fixing it at only one place directly on the tool that have the problem. And they told us that \"there was nothing to do for lib developers to support Carthage out of the box\" ahah\u2026_\nI'll probably merge your PR anyway as it's ready to go, but integrating with CocoaPods or manual integration for example does not generate this issue when integrating iOS frameworks, so from my point of view it should still be up to Carthage to fix it\u2026\n. Travis Failed. Seems to be because you introduced the need for running pod install which means that it takes more time (network requests) to build. I would prefer to go with the policy of:\n- Pushing the pods in the repo, so that anyone can build the library and/or run the tests and/or run the demo even if they haven't CocoaPods installed (turnkey solution). This includes people using Carthage.\n- Using Development Pods for the library itself (like :path => ../) so that\n  - when we need to work the OHHTTPStubs's code itself to prepare new features and fix issues, we take advantage of this Development Pods mode/feature\n  - it avoids having to run pod install during development to test out the changes in the demo\n  - it avoids the risk to modify the code in the wrong place (typically modifying the source from the demo project \u2014 that would be erased on the next pod install \u2014 instead of in the lib project itself)\n  - and all those other stuffs that gave the \"Development Pods\" feature its name. It's made for this kind of use case so we should really do it (that's what I do on all my projects because that's so useful, so I plan to do it for OHHTTPStubs too anyway)\n. > To Pods/Podfile.lock or not to Pod/Podfile.lock, that is a question... of preferences I think. \n\nHaving fix version of Podfile is important though. Having only Podfile with fixed version, required cocoapods and specify a cocoapods version as pre-requisite, but leave you repo clean of generated folder/file. From a Java background(I confess) having to run mvn/pod install does not sound bad.\n\nTo commit the Pods/ folder or not is entirely debatable and a matter of preferences, I totally agree, as explained above already.\nBut regarding Podfile.lock, it MUST ALWAYS be pushed on the repo. There is no debate possible here: if you don't commit it, it will break the way pod install work. Not committing Podfile.lock will make pod install always do as it it was the first time you installed the pods, or as if you always did pod update (which bumps the versions of the pods used), which is not what pod install is intended to do.\nThe Podfile.lock file is at the heart of how CocoaPods works. It is what locks the versions of the pods to a specific version. Whether you choose to commit the Pods/ folder or not depending on your preferences does not change the fact that the Podfile.lock must always be commited no matter what. \nSpecifying explicit versions in the Podfile (like 3.1.10 here) is NOT sufficient to lock the versions of the pods used, because this does not lock the dependencies the pods rely on, for example, so this does not guarantee that the versions of the dependencies retrieved upon pod install will be the same when you pod install now or 3 month from now. Only Podfile.lock can guarantee that.\nPlease read the guides again that explain that in details: http://guides.cocoapods.org/using/using-cocoapods.html\n. > you modifly the Demo podfile, what shoul it be?\nJust modify the Podfile of the demo project to use :path => 'relative/path/to/folder/where/podspec/is' as explained here and run pod install once. And that's it.\nYou can then commit the Pods/ folder because it only contains symbolic links to the real sources, (that are store locally in the same repo, as the sources of OHHTTPStubs itself are next to its demo project), not copies of those files; so no need to run pod install again each time you change the pod sources (in contrast to the current solution you use that requires us to run pod install on the Demo project each time the library source code changes) because it directly links to the original files.\nThat is particularly useful for demo projects that live alongside the library's source, like we have here, because you can directly modify the source code of the lib from the demo project when you work on the lib and you don't have to pod install each time to test your lib locally.\nAnd it allows Travis to work without the need to contact other servers, and it allows pod try to work and download and launch the Demo project for your pod that will work out of the box. And so much more.\n. See also my detailed answer and explanation in this GitHub comment regarding the intended usage of pod install vs pod outdated vs pod update and the importance of Podfile.lock.\n. > My view is more: when using fixed version in your Podfile and given you dependencies use fixed versions, you end up with Pods with fixed version too.\nSorry to insist, but that's still not true.\nBelieve me, I worked on CocoaPods's resolver (called Molinillo, and which is now also integrated in bundler too) with the team and am part of CocoaPods CoreTeam where we discussed such matters regarding the resolver, and there are a lot of use cases where using a fixed version in the Podfile is not sufficient to ensure pods (especially dependencies) with fixed versions\u2026 and that's exactly why Podfile.lock exists. (see also our blog post about the CP resolver)\nAnyway, the Podfile.lock file is generated for that exact purpose and CocoaPods expects it to be pushed, that's quite even its raison d'\u00eatre and that's how CocoaPods work (and a lot of other dependency managers have lock files too and work the same way, including bundler, gem, etc). If this file is not present, the tool cannot guarantee that the version locking feature will work as expected.\nThat's not some personal choice or whatever, that's just a necessity for CP to work properly in all situation (even when using fixed versions in your Podfile) as explained in the guides; that's not me having personal preferences, that's just how the tool is expected to work at all.\n\nRegarding other aspects, I'm ok with bumping the minimum version.\nAnyway, thanks again for your PR; I'll look into the Travis failure for iOS7 as soon has I finish my other WIP in order to review and merge that PR ASAP.\n. Regarding Travis, we will have to test it but I bet that even if xcrun simctl lists simulators configured with 7.0 runtime, I bet that the Xcode installed on travis VM only have the 7.1 runtime (like my local Xcode 6 do, as usually the Downloads tab to get older simulators/runtimes only propose 7.1 and not 7.0)\nSo I my bet is right, changing the target to 7.1 instead of 7.0 in the .travis.yml should solve the problem.\n. Mmmhh. Really strange. Will look into that ASAP. Thanks for all your tests!\n. Bad news. Just ran xcrun simctl list on Travis and it appears that iOS 7 runtime is not installed at all on Travis :-/\nxcrun simctl list\n== Device Types ==\niPhone 4s (com.apple.CoreSimulator.SimDeviceType.iPhone-4s)\niPhone 5 (com.apple.CoreSimulator.SimDeviceType.iPhone-5)\niPhone 5s (com.apple.CoreSimulator.SimDeviceType.iPhone-5s)\niPhone 6 Plus (com.apple.CoreSimulator.SimDeviceType.iPhone-6-Plus)\niPhone 6 (com.apple.CoreSimulator.SimDeviceType.iPhone-6)\niPad 2 (com.apple.CoreSimulator.SimDeviceType.iPad-2)\niPad Retina (com.apple.CoreSimulator.SimDeviceType.iPad-Retina)\niPad Air (com.apple.CoreSimulator.SimDeviceType.iPad-Air)\nResizable iPhone (com.apple.CoreSimulator.SimDeviceType.Resizable-iPhone)\nResizable iPad (com.apple.CoreSimulator.SimDeviceType.Resizable-iPad)\n== Runtimes ==\niOS 7.0 (7.0 - Unknown) (com.apple.CoreSimulator.SimRuntime.iOS-7-0) (unavailable, runtime path not found)\niOS 7.1 (7.1 - Unknown) (com.apple.CoreSimulator.SimRuntime.iOS-7-1) (unavailable, runtime path not found)\niOS 8.1 (8.1 - 12B411) (com.apple.CoreSimulator.SimRuntime.iOS-8-1)\n== Devices ==\n-- iOS 7.0 --\n    iPhone 4s (16E214BA-9A36-489E-81C5-9CCB9604FF8B) (Shutdown) (unavailable)\n    iPhone 5 (B3581D0A-B151-4F5E-9884-FC5A78CDD908) (Shutdown) (unavailable)\n    iPhone 5s (CC4EE950-AC3A-40B9-A360-AD393B8D3D08) (Shutdown) (unavailable)\n    iPad 2 (FFDC0F02-6F2D-4261-A188-36C04B845F57) (Shutdown) (unavailable)\n    iPad Retina (62A308F2-3272-4EEA-9CD1-90C2335FD3E8) (Shutdown) (unavailable)\n    iPad Air (0A5D20B3-5D34-46F5-99B3-EB4AEA113421) (Shutdown) (unavailable)\n-- iOS 7.1 --\n    iPhone 4s (DF1BBEDE-90C5-41D9-A11B-8DA659322101) (Shutdown) (unavailable)\n    iPhone 5s (9262546F-329F-464B-9706-CD956CE4EC88) (Shutdown) (unavailable)\n    iPad 2 (27281F5C-9697-4009-9932-722486AFBBD4) (Shutdown) (unavailable)\n    iPad Retina (215C68E1-4BE6-4169-B30D-1847CF744474) (Shutdown) (unavailable)\n    iPad Air (88AAFE0A-8784-4CDF-997A-4387E38CF85A) (Shutdown) (unavailable)\n-- iOS 8.1 --\n    iPhone 4s (37BC3125-3F35-4B1B-9195-BC5105B115AF) (Shutdown)\n    iPhone 5 (2DDCAE77-D0F8-4FB1-B9E0-3AFBECA68164) (Shutdown)\n    iPhone 5s (604674C2-08C7-4F3E-9910-BB7731045B9A) (Shutdown)\n    iPhone 6 Plus (0569A245-BFFC-4F9D-96BD-BF4D5E28F738) (Shutdown)\n    iPhone 6 (28727EC6-4665-4FC2-B77C-C2C456206044) (Shutdown)\n    iPad 2 (32D0747C-DAF9-4EA6-BC66-28EAE7CA357A) (Shutdown)\n    iPad Retina (78CCB429-8012-4AB9-BB00-48C945BA1722) (Shutdown)\n    iPad Air (33309D21-9B76-41F2-B16E-8F9B4DB269AE) (Shutdown)\n    Resizable iPhone (90F9F633-C4A2-499C-82C0-0E2CD82A1829) (Shutdown)\n    Resizable iPad (115F4F5D-C861-4342-A274-D8438126F158) (Shutdown)\n. This is now fixed and merged.\nRegarding Travis-CI, I confirmed this is because Travis does not actually has the iOS7 Runtime installed. I emailed their support to ask for it, and disabled it in the meantime.\n. Good catch, thanks!\nCould you maybe make a PR with the fix? (I'll be quite busy the next few days and won't work on OHHTTPStubs for a while)\nThat's probably simply a < to change to <=, but the PR should also add a unit test that ensures it won't happen again ;)\nThx!\n. Perfect! Thanks a lot! :+1:\n. Hi @aleufms \nI don't think that's an issue related to OHHTTPStubs on itself.\nSee those related questions on StackOverflow: here and here (and probably others).\nFeel free to try those and give me feedback if it works for you or not.\n. Ok. Could you attach a sample test project here to help us reproduce the issue, to ensure it's unrelated to OHHTTPStubs itself? Thx\n. Closed due to lack of reproducibility and because it is most likely a bug in Xcode itself.\n. The workspace compiles locally on my machine and on travis CI so that is probably some modification you did on your Mac.\nYou must indeed open the workspace to build the example, not the project (the error you got when opening the project alone without the workspace is totally normal, as the dependency between the example and OHHTTPStubs is provided by the workspace so that's what the workspace is for !)\nGiven your description you probably modified the project used by the workspace \u2014 typically you probably removed the dependency to -lPods-OHHTTPStubs in the project somehow \u2014 which would explain why the workspace now fails to build.\nSimply rollback all your local changes (using GIT) \u2014 to make your local working copy go back to the same state as the github repo \u2014 and try again.\n. Any news?\n. I confirm that I just did test on a clean machine, by doing git clone https://github.com/AliSoftware/OHHTTPStubs.git then opening the Example/OHHTTPStubsDemo.xcworkspace workspace in Xcode 6.3, and Build & Run works like a charm.\nGiven what you describe about what you did, I'm pretty sure that's a bad manipulation on your local clone (especially as you described that you removed -l\"Pods-OHHTTPStubs\" from the project, which you shouldn't have done and would totally explain the error you got)\nI'm sure that if you remove your working copy and try cloning it again, it will work.\n(You can also use pod try OHHTTPStubs to let CocoaPods download/clone to repository for you in a temporary folder and opening the example workspace for you, so that ensures you got a clean copy)\n. Thx! Note that there was no need to close that PR and recreate one. You can add new commits to your branch / fork before the PR gets merged and they will be added to the PR automatically by GitHub\n. Thanks, this seems ace! :+1:\nDo you think you would be able to add a Unit Test for that (to ensure that every delegate method is indeed invoked on the expected thread)?\nAlso, don't forget to add an entry in the CHANGELOG.md to credit yourself :smiley: \n(Note: no need to create a new PR, new commits to your branch will be added here automatically)\n. I was planning to wait until I got time to add unit tests for that PR before merging it but maybe I'll merge it sooner and add tests later to avoid waiting too long. Will keep you guys posted\n. Hi guys,\nI can't find a way to create a failing Unit Test: I wrote a test that creates an NSURLConnection on a separate thread, and even before applying @NSProgrammer 's PR, the test still passes.\nHere is my unit test so far. Do any of you see anything wrong with that test? isn't it testing the right thing? Because it is passing, even before applying that fix so I'm wondering\u2026\nDo you guys have an actual example of when this fails for you, so I can get inspiration to write a proper test that would properly avoid regression once this fix is merged?\n. @cdzombak Mmmmh, good idea, but unfortunately I don't think we can access the NSURLProtocolClient from outside of the NSURLProtocol implementation itself, so it's probably hard to test this directly.\nOne way to properly test that directly could be to use mocks, e.g. using frameworks like OCMock to mock / add an \"expectation\" on calls to -[id<NSURLProtocolClient> URLProtocolDidFinishLoading] (and all other NSURLProtocolClient's methods), so that we can intercept those internal (= from OHHTTPStubs.m implementation) calls from outside (= from the Unit Test code). But I'm not sure I want to add a whole dependency framework like OCMock simply to test this case\u2026\nMaybe I'll try to swizzle the NSURLProtocolClient methods myself in the Unit Test code, to intercept those calls during testing (which is basically what OCMock does, but just for one test case it seems simpler to swizzle ourselves than to import the whole OCMock framework/dependency just to swizzle for one test case)\n. Yeah I agree, given that NSURLProtocolClient is actually a protocol, not a class, I'm not sure either we can actually do that (it's ages I haven't used OCMock personally, maybe I'm wrong).\nWill try and investigate swizzling the methods myself, but unfortunately I'm quite sure we can't swizzle methods on a protocol, because we swizzle implementations so we need to know the class that implement it, and in our case it's a internal class private to Apple, but I may try anyway.\n@NSProgrammer was talking about their tests using OCMock earlier, maybe he got some pointers on how they did it on their side?\n. Ah, I like that idea @NSProgrammer will try to implement it ASAP! Thanks for the pointers.\n. @NSProgrammer I finally mocked the NSURLProtocolClient to intercept all called made to it.\nAnd I was surprised that this revealed me\u2026 that your fix didn't actually \"call the NSURLProtocolClient method on the client's thread\". Well or more precisely, I'm not sure what Apple wanted to refer when talking about the \"client's thread\" here.\nIn fact, the -startLoading method is called on an Apple's private thread called com.apple.NSURLConnectionLoader, and not on the thread the NSURLConnection method itself was called on. Thus as you store the CFRunLoopGetCurrent() there, all your calls to NSURLProtocolClient's methods are done on that same runloop\u2026 which is associated to that com.apple.NSURLConnectionLoader thread, and not on the thread on which the user did call NSURLConnection in its own code.\nI don't know if your code is doing the wrong thing by calling those methods on the com.apple.NSURLConnectionLoader private thread, or if we misunderstood that not in the documentation / example's README that tells us to call those methods from the \"client's thread\" and that this is what we actually are expected to do (instead of what I initially understood in that sentence, which was calling those methods on the same thread the user did call the NSURLConnection/NSURLSession methods).\nAny insight on that?\nIf what you code do (calling the methods on the com.apple.NSURLConnectionLoader thread) is the right thing, I'll probably end up removing my test and stop trying to test that feature which has proved quite hard to test\u2026 and is even maybe not testable at all (I can't see a way to properly capture from my Unit Tests that actual thread/runloop the NSURLProtocol is using internally, and even if it's possible, this will probably need way too complex unit testing for that little feature and won't probably be worth it)\n. @NSProgrammer I just finally merged your fix into master and pushed version 4.0.1\u2026 without any Unit Testing.\nI still have my work on attempts of Unit Testing it on the threading-unit-test branch that I'll keep open and around if you have any idea about it.\nThe question that remains is:\n- Are we expected to call the NSURLProtocolClient methods on the com.apple.NSURLConnectionLoader thread on which all methods of the NSURLProtocol instance are called, which is what your fix does\n- Or are we expected to call the NSURLProtocolClient methods on the thread on which the NSURLConnection methods have been called by the user/caller, which is what my attempt of a unit test is trying to check (but in that case I don't see how we could achieve that in the code)\n. Thanks so much for those details and feedback :)\nI'll file a feedback on NSURLProtocol's documentation page to ask Apple to add some more details about that, but as you confirmed with Apple that they expect it to be called \"on the same thread that startLoading is called from\" then that's good enough for me.\n4.0.1 is out with your fix already. I'm not sure I'll be properly able to test this properly. I can surely be done somehow, by intercepting the call to startLoading then the calls to all NSURLProtocolClient's method, but it seems to me that it's not worth the effort of writing such complicated test code just for that one feature. \nThanks again\n. Interesting project! Will take a look, I didn't know about SPDY.\nAs you seem to have worked a lot with NSURLProtocol, and even talked to Apple engineers about it, maybe you have an idea on issue #82 (-[NSURLSessionConfiguration HTTPAdditionalHeader] not being added when the NSURLProtocol methods are called since iOS8, see related unit test on this branch)?\n. Thanks!\nYeah I started a branch with a workaround too, that creates a subclass of OHHTTPStubsProtocol dynamically using ObjC runtime and insert it (instead of the base OHHTTPStubsProtocol class) to the NSURLSession's protocolClasses so I can get that associated session back from the protocol. Seems hacky though.\nThere is a NSURLProtocol (NSURLSession) category that can be found at the end of NSURLProtocol.h (documented nowhere of course\u2026) but it doesn't even seem to work! (Despite what this category says, NSURLProtocol does not responds to the task selector so that @property declared here does not seem to be implemented at all\u2026 :sad: )\n. Thanks for reporting!\nI am beginning to think that I'll drop Carthage support. Too much work as a lib maintainer, that's the 4th issue I had to fix just to workaround Carthage bugs so far in a short amount of time; each time I fix a thing for Carthage another issue arise\u2026 I don't have time for this.\nI'll fix the README accordingly. Thanks!\n. Now that I moved Example projects down a level (as I added a Swift demo project alongside the already existing ObjC demo project), Carthage should not use the Example project(s) anymore.\nThis modification has been done on master so feel free to test it. I'll release 4.0.0 later in the week-end (once I finished removing some legacy code and updated the README & CHANGELOG).\n. Closing due to lack of feedback. Should theoretically be fixed anyway (I don't use Carthage so won't test myself)\n. Thanks for letting me know :wink: :+1: \n. This will probably break pod try support, so I'm not sure I want to merge this, if solving one thing will break another.\nI'd say better wait for Carthage/Carthage#213 to be fixed (my library is surely not the only one in that case anyway, so better fix the issue at its core by fixing Carthage than workaround it in the repos of every possible libs out there)\n. Be reassured, I won't drop it\u2026 but I won't corrupt/amend my project just to fix/workaround Carthage bugs either (and #97 \u2014 which this PR was a workaround for \u2014 is indeed a Carthage issue, not mine).\n. Good point. But given that those macros use self.class to know the context they are called from, do you have a suggestion on how we could achieve a similar behavior in Swift?\n. Hi, \nThis has just been fixed on master, by converting the macros to functions.\nI have added a Swift Demo Project (see #88) that makes use of those new OHPathHelper functions so you can see how to use them.\nNote: I still want to make some other (unrelated) modifications before pushing version 4.0.0 so there is no official tag/version yet, but there will be soon (probably tomorrow).\n. Good catch!\nDone \ud83d\ude03 Thx :+1:\n. I just did it for 4.0.2 and attached the OHHTTPStubs.framework.zip to the 4.0.2 release.\n@tibr Could you tell me if that works and if I did it correctly? (I'm not a Carthage user, more fan of CocoaPods, so I'm not sure how to ensure I did it properly)\n. Nice catch, thanks for the PR (and the additional unit test!) :+1:\n. 4.0.2 is out :)\n. Hi,\nHow did you integrate OHHTTPStubs in your project?\nIf you integrated using CocoaPods for example (or even Carthage), this should work out of the box.\nSee my Example project and also my own Unit Tests in the OHHTTPStubs workspace, some of them like this one are using AFNetworking and NSURLSession and work without any issue (all tests pass on Travis Continuous Integration, so this one works too).\n\nIf you integrated manually (which I strongly discourage, both because it is more painful to maintain and because it could lead to integration problems if you didn't do it right), you may have done it wrong. For example you may have forgot to add the -ObjC flag so that the categories of the library (especially the one that does the OHHTTPStubs injection in NSURLSession classes) is imported as well as its classes by Xcode when it links with the library.\nSe the dedicated page about manual integration in this repo's wiki for more info; but again I strongly discourage manually integrating OHHTTPStubs (as well as any third-party library) to your project (that's painful and error-prone), and better encourage well-recognized tools like to manage libs/dependencies, like CocoaPods. (See the README.md for recommended integration instructions).\n. Ok thx for the feedback \ud83d\ude09\nI'll close it then\n. Hi @gabro \nSorry for the delay, I haven't forgotten about your issue, but I've been busy lately and didn't have time to look at it yet.\nHopefully will have some time soon to check that use case and try to fix it (if you have a sample project that demonstrate the issue, I'm interested :wink: )\n. Hi @gabro \nI can't reproduce the issue with my demo project.\nFor example using the OHHTTPStubsDemo project you can find in that repo, where onStubActivation is setup in the viewDidLoad, even as the stub is setup with a responseTime != 0, onStubActivation is only called once per request.\nI'm guessing it has to do with how you setup you stubs in your own project.\nCould you provide a sample project so I can reproduce the issue? I won't be able to do much without being able to reproducing it.\n. Closing due to lack of response.\n. Fixed by 9fb400fd90d139ec1762fcbdf15b8693d7794381\n. Looks nice so far :+1: \nRegarding the Xcode project conflict, given that I haven't pushed any new commit that I know of between the start of your branch and your additional commits, that shouldn't be a conflict generated by any change on my part. I could take a look later, but I'm on my iPad rn so only see this from GitHub :wink: \nMaybe rebase to ensure it's based on master. Otherwise you may revert the xcodeproj and add the files manually again if merging the XML of the pbxproj seems too complicated to you.\n\nPS : if you're familiar with CocoaPods, it could be nice to add the necessary changes to the podspec as well, so that this addition becomes an optional subspec (move the current s.source_files into a \"Core\" subspec, make it the default, and make a \"Mocktail\" subspec that depends on Core + add the \"+Mocktail.h/m\" files to its ss.source_files)\n. If you have time yeah why not.\nI'm actually more waiting for me to have some time to pull it, run it, test it, merge it, podspec it, tag it, release it. Won't probably have some free time for that until next week.\n. Cool!\nSorry family time this weekend and won't be able to look at it until next week but seems promising!\n. Hi @JinlianWang \nI finally reviewed your code (sorry it took so long for me to start working to it!) and did some modifications to improve syntax, readability, add nullability annotations, fix potential crashes and code style, make it compatible with OS X, and more. You can see the changes here.\nProblem is, there are still some issues especially with the fact that your API is not working when OHHTTPStubs is used as a (Mac or iOS) framework (as opposed to a static lib). And frameworks are more and more used with iOS8, so that's problematic :wink:  \nThe source of the issue is because when OHHTTPStubs is built as a framework, the \"current NSBundle\" ([NSBundle bundleForClass:[self class]]) will be the framework itself (and not the app, or the Unit Test bundle). And so your methods stubRequestsUsingMocktailNamed:error: and stubRequestsUsingMocktailsAtPath:error: will both fail, searching the *.tail files in the framework itself instead of inside the app or test bundle calling those methods.\nI'll let you fix this by changing your API: typically you'll need to pass the bundle as an argument to your method (and you may avoid using OHPathHelpers methods in that case which are more meant to be used by the user, at call site). You can pick some inspiration from my OHHTTPStubsResponse+HTTPMessage.m file and its responseNamed:inBundle: method for example.\nI then invite you to test your code by running the Unit Tests from the \"OHHTTPStubs Mac Framework\" scheme (so that they run in a framework context) to ensure this issue is fixed.\n\nNote: I created a PR in your fork so you can retrieve my fixes on your code. You should of course merge that PR first, before starting to add other commits on your own to fix that framework issue.\n\n\nPS/Note for self: Once you've fixed your API so it can work with frameworks, I'm thinking of two more stuff I'd like to do (but are not related to Mocktail directly, so I could do them myself if you want):\n- [x] Move (or add?) the iOS Unit Tests from the \"iOS StaticLib\" scheme to the \"iOS Framework\" scheme, so that these iOS Unit Tests are executed when we build the iOS Framework and not simply the static lib, forcing us to run tests in a framework context in the future to avoid similar cases\n- [x] Further split OHHTTPStubs in subspecs. That new Mocktail subspec is great and made me think that I should maybe also extract the HTTPMessage category in its own subspec as well (and maybe the JSON category too, but this category should still be included in the default subspec as it's more common to be useful and used by many, as opposed to HTTPMessage and Mocktail)\n. Version 4.2.0 is out and includes your Mocktail support PR :smiley: \n. Never tried that before so not sure, but it seems like you are trying to\nread from request.HTTPBodyStream, and since it's the request, so the\ndata being sent, I bet it's an NSOutputStream, only intended for writing,\nnot an NSInputStream we can read from.\nSo it seems normal to me that you get that kind of error telling that the\nsteam is not open for reading (but only for writing).\n(The issue is probably not related to OHHTTPStubs btw)\n. :astonished: I'm not the one who wrote that in my wiki! Will check this out.\n. @jeremy-w As you're the one who added that in my Wiki, could you explain how you made it work (or if you tested it at all), given that it doesn't seem to work for the people commenting in this issue?\n. Thx for the feedback @jeremy-w :+1: \nKeep us posted (if you could test it again and e.g. confirm that it was working before on one of your project but broke since, etc) :wink:\n. > 2) The test fails with 404 errors in my logs because I believe that OHHTTPStub is either redirecting on the wrong URL or worse, it's injecting the JSON data on a URL that it should not be mocking (ie. facebook).\nThat will only happen if:\n- Either your test in the stubRequestsPassingTest: block is not correct (like if your returned YES for every request so that the stub would be triggered for all requests). But you seem to do proper tests like [request.URL.absoluteString isEqualToString:\u2026] so doesn't seem to be the case here\n- Or you forgot to remove your stubs from the previous Unit test before starting the next test, so the stub setup for test 1 will still be active when test 2 runs. see that article in my wiki\n\n\nWhat's the proper way to debug what OHHTTPStubs is mocking on? I want to make sure it's doing what we expect when we expect it.\n\n\nYou can use onStubActivation: to log every time a stub is activated. See here in the detailed usage examples in my wiki too\n\n\nCan I use it with request.URL.absoluteString as depicted below? I would think that it does not matter so long as the parameter evaluates to true.\n\n\nYes, that's actually the most common usage.\nDon't hesitate to consult my help articles in my wiki that could give you a lot of tips.\n. This feature been implemented in branch swift-2.0 (which will be merged into master and included in a release once Xcode 7 is out of beta)\n. Thanks @bruceflowers for the info.\nIt seems that Xcode 7b5 is a bit broken when working with Objective-C booleans. Typically, it sees the various blocks of my API as returning ObjCBool instead of a simple Bool, and it seems like those types are not converted to one another transparently anymore :disappointed: \nSo the solution for now is to wrap the value returned by your test block inside ObjCBool(\u2026) to convert it to ObjCBool type explicitly.\nOHHTTPStubs.stubRequestsPassingTest({ ObjCBool($0.URL!.host == \"mywebservice.com\") }) { _ in\n  // return a stub...\n}\nI hope this is only a bug in Xcode 7b5 and not intended behavior to force us to cast to ObjCBool manually. I'll take that into account when I got time to implement #111 that would expose helpers for an even better Swift API, and already updated the wiki.\nThx for your feedback :wink:\n. Xcode 7 beta 6 just went out and in the release notes it's explicitly stated this:\n\nC typedefs of block types are now imported as typealiases for Swift closures. The primary result of this is that typedefs for blocks with a parameter of type BOOL are now imported as closures with a parameter of type Bool (rather than ObjCBool as in the previous beta). This matches the behavior of block parameters to imported Objective-C methods. (22013912)\n\nSo it appears that this was a glitch in the previous beta and has been solved.\nI'm reopening the issue in order not to forget to check it when I got the time to download the latest beta and try it, and restore the previous examples without wrapping everything in ObjCBool(\u2026) if it's indeed solved.\n. Just confirmed that Xcode 7b6 fixed that ObjCBool strange stuff. no need for it anymore.\nReverted the changes in the Wiki to use plain Bool now, pffeeew :)\n. Simply return a responseWithData: with an empty (0-length) [NSData data].\n. LGTM, thx :+1: \n. No problem.\nActually, just realized I indeed missed to normalize the copyright info in the headers of your source files.\nAs OHHTTPStubs is under the MIT Licence, would you be ok to update the comments on top of your .h/.m files so that it matches this, simply replacing my name with yours and the year with 2015?\nThx\n. > I would have to check to see what we can do. Actually the other day some leadership asked why I am not showing as one of the contributors\nI actually can't keep your code in my repo if it's not under MIT as it would violate the license I release my code under, so please do.\nYou've been listed as a contributor / credited in the CHANGELOG already.\nI'd also be glad if you credit yourself at the bottom of the README in the \"License and Credits\" section.\n. I've merged everything to master, and added credits in README, so it should be good now \ud83d\ude03\n\nThe company is pushing effort over open source and sponsoring events like http://www.iosdevcampdc.com. Would you be interested coming in as a speaker to share your experience if similar event occurs?\n\nSure! Never went to DC (or even the US) yet, but could be interesting to be a speaker at one of those events :+1: \n. Thanks @keith for the feedback.\nThis seems very strange, as I fixed it in July by adding the designated init in this commit, then included in the 4.1.0 release.\nAre you sure you're using the latest version of OHHTTPStubs (or at least 4.1.0 or greater) in the project where you have that warning?\n. I think that's because I renamed targets at some point in the lifetime of OHHTTPStubs' project evolutions,  (like I renamed \"OHHTTPStubs iOS Tests\" renamed to \"OHHTTPStubs iOS Lib Tests\" when I introduced the dynamic framework version to make the name of the target more clear) and probably Xcode didn't update it everywhere it should have in the OHHTTPStubs.xcodeproj/*pbxproj files and kept the old name at some places in the pbxproj, which it updates only at compile time in some circumstances\u2026 (that's just a guess but I've see that behavior of Xcode before).\nCare to post a diff to list me all the modified files so I can see where Xcode missed them? Or provide a sample project to reproduce the issue so I can check the diffs myself?\nThx\n. Versions 4.2.1 and 4.3.0 have been pushed with the project fixed, so you shouldn't have the issue anymore!\n. https://github.com/AliSoftware/OHHTTPStubs/blob/master/README.md#known-limitations\n. That's strange because I indeed separated that method in a dedicated subspec now, but that subspec should be included by default unless specified otherwise.\nCan I see your Podfile and Podfile.lock files?\nPS : See also the CHANGELOG here which describes this change. (you can also see in the podspec that the default_subspec is the one named Default and this subspec indeed contains the JSON subspec by default as I knew it was used by a lot of people, so you should have it unless you specified another subspec explicitly by default)\n. So I don't get it\n1) your Podfile clearly shows that the OHHTTPStubs/JSON subspec has been retrieved by your pod install and is present, so you shouldn't have any problem\n2) You added a comment in your Podfile saying you resolved the issue? So is it solved now or not? I'm a bit confused.\n. Ok, so as I was saying, if you don't specify the version you can see in your Podfile.lock that CocoaPods uses the Default subspec which in turn brings OHHTTPStubs/Core, OHHTTPStubs/JSON, OHHTTPStubs/NSURLSession and OHHTTPStubs/OHPathHelper.\nSo your project correctly has the subspec and the code that include the JSON additions, the code for JSON is there as expected.\nSo if you still have the \u00ab No known class method for selector 'responseWithJSONObject:statusCode:headers:' \u00bb error, maybe you forgot to add #import <OHHTTPStubs/OHHTTPStubsResponse+JSON.h> in your source file?\nAgreed you should only need #import <OHHTTPStubs/OHHTTPStubs.h> (which is supposed to be the umbrella header and thus include that OHHTTPStubsResponse+JSON.h itself, but maybe the umbrella header stuff has been messed up by my recent split?)\nCould you try adding #import <OHHTTPStubs/OHHTTPStubsResponse+JSON.h> to the source file where you want to call responseWithJSONObject:statusCode:headers: and see if it solves your error? If you had the error when #import <OHHTTPStubs/OHHTTPStubs.h but the error disappears when you #import <OHHTTPStubs/OHHTTPStubsResponse+JSON.h, it would probably mean that the cause of the issue would be a broken umbrella header (and you would have a workaround in the meantime).\n. Yup, broken umbrella is probably the cause indeed. Will have to check it out sometime (but a little bit overwhelmed atm). Will keep this issue open to keep in mind that I have to investigate it.\n. I'm closing this as I opened a dedicated issue #127 to fix the umbrella header\n. Version 4.4.0 is out, fixing the umbrella header problem :wink: \n. If you want any pod containing Swift code (like the OHHTTPStubs/Swift subspec but it's the same for any other pod containing Swift) you have to activate use_frameworks! in your Podfile.\nSee the CocoaPods documentation, or CocoaPods' Blog post about this, or this raywenderlich tutorial, among others.\n. Yeah I thought about it and didn't add the Swift helper in OS X because it would force to bump the Deployment Target for the whole framework, so people still wanting to use the framework on OS X 10.8 even if they were not interested in the Swift Helper wouldn't be able to use it anymore.\nI'll probably gonna modify the Podfile so that the minimum deployment target for OS X will be set to 10.9 in the Swift subspec, but kept at 10.7 for the other subspecs, which would definitely solve the issue for people integrating with CocoaPods.\nBut I don't think there is a solution for Carthage, as Carthage is kinda strict and forces us to have everything configured once and for all in Xcode without any option for opt-in or opt-out of features like this Swift addition, it's just not flexible enough. And I don't want people still targeting 10.8 to not be able to use OHHTTPStubs anymore because of a feature they won't use anyway.\n. Hi all,\nXcode 7 UI Tests are executed by running the application bundle in the simulator then driving it using XCUI\u2026 commands. Thus the tests are Hosted Tests, as described in my wiki page here meaning that it's the app bundle that gets launched (then the UI tests bundle is injected into the app bundle).\nSo @dtrenz is right, given how UI tests work, the only way to stub your requests during UI testing is to install your OHHTTPStubs in your app bundle (which is the one being run), not in your test bundle.\nAs @dtrenz mentioned, I suggest you use XCUIApplication's launchArgument property to inject some special argument when running your stubs for UI testing, so you can differentiate it from a normal run, and install your OHHTTPStubs for UI tests only. See also this page for great suggestions.\n. Simple idea: maybe instead of passing the JSON when it's too big, you could instead pass the name (or path) of the fixture (JSON file) to use, and then use the file content to create your stub\n. Very nice idea! :+1: \nDo you have any idea about a simple implementation? The one from Overcoat is quite tightly coupled with Mantle.\nThe only thing I'm wondering if, is OHHTTPStubs the right place to implement that? I mean, it could work both for OHHTTPStubs and for any other various uses (like even in your app you could need such logic), and I prefer to have multiple small libraries that are focused on a feature than one big lib that keeps growing and become a huge machinery in the end.\nFor example, I already hesitated adding the matchers I wrote as part of the Swift subspec (but they are simple enough, so that's ok I guess), but someone already suggested me to make it possible for OHHTTPStubs to _record network traffic, and I feel that it's the responsibility for a dedicated pod instead of clobbering OHHTTPStubs_\nAnyway, that's still a nice idea and would be great to have a dedicated library for that. Won't have time for that anytime soon, but don't hesitate to start one on your own on which I'd be glad to contribute when I'm a little less busy ;)\n. Cool, keep me posted!\n. Hey @janglesdev any news on that front?\nStubbled upon https://github.com/kylef/URITemplate.swift the other day which might be an interesting starting point to implement this?\n. Note: upcoming version 6.0.0 (see #242) will add a pathMatches(\u2026) matcher function helper. It's not as powerful as a whole component matching mechanism like URITemplate but it could help in a lot of situations.\nLike pathMatches(\"^statuses/\") and pathMatches(\"^statuses/retweets/[0-9]+/extra$\") would both match the path statuses/retweets/12345/extra.. Did you read my dedicated troubleshooting page in my wiki? Especially this one explaining the difference between Hosted Tests (the app bundle is launched and the test bundle is injected into it ==> in that case you need to install the stubs in the app bundle) vs Standalone Tests (the test bundle is launched standalone, without the app bundle even needed to be build, and you install your stub in the tests bundle).\nIf you want the stubs to be able to intercept any network request, you need to install them in the same bundle that is launched during test, which is the app bundle for hosted test or the test bundle for non-hosted tests.\n. Yeah, hosted tests are now the default in Xcode, so maybe migrating to Xcode 7 force-changed that setup?\n. I'm not sure to follow.\n\nIt says not to use OHHTTPStubs in the app code (to mock TBD services)\n\nOn the contrary, you could use OHHTTPStubs in your app code when you need to mock TBD services\n\nbut in the sample code it's only in the test target\n\nWhat is? iirc, the sample code displays some UISwitches in the main view to toggle the stubs, and those stubs are installed in the application code, not in the tests. Actually the example projects don't contain any test at all, as the Unit Testing of the library is done in the dedicated project building the library/framework in Sources/, not in the sample projects in Examples/\n. I just opened your sample project and that confirms what I stated earlier.\nYou're using hosted tests apparently, so this means that Xcode will launch your app bundle (and call application(_:didFinishLaunchingWithOptions:)), then inject your test bundle. \nThis means that all network requests done by your app code, like the one in your AppDelegate, will use OHHTTPStubs registered in that app bundle, not the ones registered in the test bundle.\n. > Removing the Alamofire request in the app resolves this.\n\nAh, I didn't get that on my first look on your sample, indeed if just commenting the call to Alamofire.request in your AppDelegate changes the behavior, I see now how weird it feels!\n\nSo, I finally dug a bit deeper in your sample code, and this was indeed a tricky case, which I believe is linked with 3 factors:\n- the way Alamofire initialize its internal NSURLSession the first time Alamofire.request is called,\n- the fact that you're using Hosted Tests,\n- and the way OHHTTPStubs auto-loads itself.\nAll that explains why, when you're doing a request in your App code, the stubs are not properly setup in time.\nHere is what happens in practice:\n\nYou start running the tests.\nBecause they are Hosted Tests, the first thing Xcode does is to launch your application bundle. This means that your application(_:didFinishLaunchingWithOptions:) gets executed right away, before any test case start, even before the test bundle is loaded itself\nThere, your AppDelegate calls your Alamofire.request(\u2026) code, which is the first call to Alamofire so far\nAlamofire.request internally calls its static Manager.sharedInstance instance, which is a singleton (static let is how to do singletons in Swift) which creates and store an NSURLSessionConfiguration the first time that sharedInstance property is accessed\nThat request made by the app hits the real world, as we're still in the process of launching your App and the Tests bundle still hasn't been loaded by Xcode at that point, and neither does OHHTTPStubs (and no stub has even been setup yet)\nThen only once the app has finished launching, the test bundle is finally loaded and injected into the app\nThis is where OHHTTPStubs is loaded (because you've linked it to your unit tests target so it gets loaded only once your Unit Tests bundle is loaded and injected into the app by Xcode)\nThis is when OHHTTPStubs swizzles NSURLSessionConfiguration so it can inject itself into newly created instances and thus intercept every outgoing requests (see here in OHHTTPStubs' code)\nBut Alamofire has already created its internal NSURLSessionConfiguration at that point (see 4), on which stubs were not activated yet. So it's too late for him, it is already using an NSURLSession that got initialized with an NSURLSessionConfiguration without stubs installed.\n\nSome ideas to fix your edge case:\n\nSwitch to non-hosted tests, so that your App doesn't get launched before your test bundle is loaded\nKeep hosted tests, but add OHHTTPStubs to your app bundle instead of your test bundle, so that it's loaded as soon as the app is launched when running your tests\nHack your AppDelegate code somehow, so that when launched from the tests, it doesn't make any call to Alamofire.request, and that the first request made by Alamofire in the app or in the test (thus triggering its call to Manager.sharedInstance that creates its internal NSURLSessionConfiguration) is only done after the test bundle has been loaded and injected into your app bundle.\n\nThe fact that the App bundle is loaded and your app is started (and the AppDelegate methods executed) before the test bundle (and OHHTTPStubs) is even loaded and injected is the core of your problem. One of the 3 proposed solutions above would allow you to solve or workaround that.\n. @rcdilorenzo thanks for the feedback, glad it helped.\nIt could maybe be a nice addition to make a wiki page or article about that; I'd be glad to add a link to it in the README if it can help others.\n. @igorbelo If you integrated OHHTTPStubs using CocoaPods, simply move your pod 'OHHTTPStubs' line in your Podfile from the target 'YourAppTests' do \u2026 end block into target 'YourApp' do \u2026 end block.\nIf you integrated using Carthage, just change the OHHTTPStubs.framework target membership in the right panel one you have selected the framework in Xcode, to uncheck the \"YourAppTests\" checkbox and check \"YourApp\" checkbox instead.\n. Well looking at your code it seems that you properly integrated OHHTTPStubs to your app bundle and not your test bundle like it seems you wanted to do (which would make sense only if you use Hosted Tests, which you probably do as it's the default in Xcode now and otherwise you wouldn't be able to link to OHHTTPStubs in your test target anyway).\nSo now you'll have to ensure that Alamofire doesn't load itself and create its inner NSURLSession (which if does the first time you access Alamofire's shared Manager) before OHHTTPStubs had time to load into memory and install its stubbing protocol (breakpoints should help to check if that's the case or not)\n. @ivanruizscm I already explained the rationale in other issues and PRs as to why OHHTTPStubs/Swift doesn't automatically include OHHTTPStubs (aka OHHTTPStubs/Default. That's because otherwise people wouldn't be able to opt-out of other subspecs that the default one automatically provides but which might not be relevant to everybody.\nThis is very well documented both in multiple places in the README.md, the wiki, and all the docs anyway (it's even at the beginning of the README right in the Installation paragraph, so it's hard to miss).\n. Hi @AnandWalvekar\nAs explained the way the test harness used by Xcode for hosted tests (and thus UI tests) works is that Xcode launches the app itself then run the UI test code from the context of the app. So if you want to apply stubs in your app requests while UI testing your app, then sadly given how Xcode execute those tests there's no real magical solution other than writing your stubbing code in your app target. The general trick to do that is to test  in your code if an env var is set and only setup the stubs in that case. Then configure your Xcode scheme so that the test action defines that env var while the run action doesn't. Variants of that approach exists by basing the test wether to setup stubs or not on the command line arguments (instead of an env var), optionally leveraging the ArgumentDomain of UserDefaults (setting up your scheme to pass arguments like -uiTesting true only for the test action then reading the \"uiTesting\" user defaults to decide wether to stub or not). @billyto \n\nI tried setting \"Allow Non-modular includes in Framework Modules\" to YES\n\nYeah, even if that worked, that would be a workaround to cheat the compiler, wouldn't solve the core issue\n@keith Ah interesting. I was wondering if it would be necessary to create a custom umbrella header and a custom modulemap to use it, but if this fix of yours is enough I'd say let's do that instead!\n. I'm currently downloading Xcode 7.1 (I have seen this issue with Xcode 7, but it was not deterministic and sometimes worked, sometimes failed, so hopefully Xcode 7.1 will make it fail every time so I can be sure to know whether the patch fix it or not.\nWill then indeed need to try a lot of contexts / configurations then, especially how it affects people not using CocoaPods, or using some subspecs but not all, etc. Will have to double-check with that trick using #if __has_include which I'm not sure is working properly in every environment (CocoaPods vs. Carthage vs. Rome etc)\nWill keep you posted, but interested if you guys could then test this in multiple different configurations afterwards.\n. @keith did you only do these changes and nothing else?\ndiff\n-#import <OHHTTPStubs/Compatibility.h>\n-#import <OHHTTPStubs/OHHTTPStubsResponse.h>\n+#import \"Compatibility.h\"\n+#import \"OHHTTPStubsResponse.h\"\nBecause if I'm doing that, and then try to build the framework directly from Xcode in the OHHTTPStubs.xcworkspace, I then get the \"Include of non-modular header inside framework module\" error on lines 188/191/194/197 :unamused: \n. Mmmmh strange it doesn't work here then.\nCould you try with the fix I started in fix/umbrella-header branch? (Like make your Podfile point to that branch and tell if it fixes it)? Thx!\n. Ok made some more fixes in #131, @keith @billyto @jshier could you test by making your Podfiles point to that branch and confirm it works for y'all? If so, I'll merge and release a new version!\n. Cool! Will do a release probably in the week-end (too busy today). Thx for the feedback :tada:\n. Version 4.4.0 is out fixing all this. Thanks to you all for the feedback!\n. @madoke That's a known bug of CP 0.39 i believe.\n. Yeah just confirmed. Should be fixed in latest betas of CP though, so I encourage you to test the latest CocoaPods 1.0.0 beta.\n. Currently OHHTTPStubs.h is the umbrella header for the framework, so OHHTTPStubs.h is required by Xcode to import all the headers of the framework.\nThere is an issue about that (#127) and I need to find a way to solve it, probably by specifying a custom umbrella header in the Build Settings instead than the default one (which is the .h file having the same name as the framework, hence OHHTTPStubs.h here) and configure it right for all use cases:\n- When OHHTTPStubs is used as a static lib\n- When OHHTTPStubs is used as a a framework installed manually\n- When OHHTTPStubs is used as a a framework via Carthage\n- When OHHTTPStubs is used as a a framework via CocoaPods\n- When OHHTTPStubs is used as a a framework via CocoaPods and the user only choose to pick some of the pod's subspecs and not all\n. I'm closing this as this fix continue to break for other configurations, esp. frameworks integrated via Carthage vs. CocoaPods vs. Rome vs. manual etc.\nI started a branch fix/umbrella-header to try and fix it using a more generic approach.\nThx for the effort and the PR though!\n. Looks good to me :+1: Thx for the PR.\nI'd just suggest to maybe rename the methods withFileURL: instead of just withURL: so that people don't think they can use NSURLs pointing to network resources in there (which could get confusing especially in the context of OHHTTPStubs and network requests :smile: ) but only using fileURLs.\n. Also, once you've made the suggested changes, could you add an entry in the CHANGELOG to credit yourself? Thx!\n. Great work, thanks! :+1:\nI don't mind keeping multiple commits, no need to rebase into a single one. I usually like to create a merge commit anyway, so it'll be clear in the git graph that those commits go together.\nJust some last requests, it would be useful to:\n- transform your test_InvalidPathWithURL test so it uses a valid URL but pointing to an invalid path (file://foo/bar for example) \u2014 instead of it using a string that will return a nil NSURL and duplicate the previous test\n- add a test for an NSURL for which you couldn't get the file size, to cover the case of this part of your code (maybe using a network NSURL there?)\n- BTW, shouldn't we protect against the use of network URLs in these cases? Like throw an exception \u2014 or whatever would seem appropriate \u2014 in case the user use an NSURL that's not a fileURL?.\nSorry for the extra work and for not pointing to that previously :relaxed: \n. > An alternate implementation of this PR could be to implement the NSURL methods in terms of NSString based file paths, or vice versa.\nAh, good point. Maybe we should then change the implementation of the methods using NSString so they now create an  [NSURL URLWithFileAtPath:] and call your implementation instead, to avoid code duplication in those implementation? Would seem better for code quality and maintenance.\n. Additional idea, not sure it's really useful/needed, but do you think adding an OHPathHelper for returning NSURL for fixtures would also be handy for people using NSURLs in their tests?\n. Yeah I'm not sure they'd be needed, anyone can add them in their code anyway, that'd just be a one-liner, so let's not bother about that.\n. Awesome work man! :tada: \nCould you manage to add one last test that ensure you fail properly (we hit your NSAssert) if we give a non-file NSURL?\nI'm going to bed now, and will probably merge it tomorrow. (I'll probably need to fix #127 first before doing a new official release though)\n. Seems like tests are failing now :-/\nMaybe in the travis env, NS_BLOCK_ASSERTIONS is set, meaning that they are removed from code (#defined to empty)? In that case we better explicitly @throw an NSInconsistencyException instead of using NSAssert\n. Good question. I think keeping NSAssert makes more sense, as it's what this is for after all. But I guess this means that we need to make the Unit Tests test the Debug build \u2014 where assertions are enabled \u2014 not the Release one \u2014 where they are blocked which is probably a good thing too.\n. Yay! Champagne! :tada: \nI thing that's all good now, let's merge this at last!\nThanks so much for the great job and time spent on this @MaxGabriel :beers: \n. :ok_hand: \nTravis OS X VMs seems to all be frozen :disappointed:  But there's no reason this change won't compile once Travis team restart the jobs, so I'm merging anyway :wink:\n. What version of OHHTTPStubs did you pull in your Podfile? Is it using the latest 4.4.0 \u2014 which should have fixed #127 and thus fix this kind of issues?\n(Seems not, since here's what the 0.4.4 has on line 32 of OHHTTPStubs.h, which does not match what the error tells you, which is what was present before #131 got merged)\n. The race condition is not really in OHHTTPStubs, but with your code removing and adding stubs while there are requests (using them) still running (sent and not having replied yet).\nYou mustn't remove stubs while the corresponding request is still pending.\nInstead, to implement such a behavior, you should modify the stub response that you return in your stub depending on some condition. For example (in Swift):\nswift\nvar send404 = true\nstub( isHost(\"mywebservice.com\") && isPath(\"/foo/bar\") ) { request in\n  if send404 { // First time, return a 404\n    return fixture(fixturePathInBundleFor404, status: 404)\n    send404 = false\n  } else { // Next time, return a 200\n    return fixture(fixturePathInBundleFor200)\n  }\n}\n. Thanks for the PR !  :apple:  :tv:\nSadly I won't have much time those days to fully review it but I hope to look at it in detail this week-end.\nI'm not sure I understood why you had to bump the minimum deployment targets of the pod for iOS and OS X, since the pod doesn't have a dependency on AFNetworking, only the test targets do. \nSo theoretically you should only had to bump the Deployment Target build setting of the Unit Tests target, not the podspec which doesn't depend on AFN, right?\nRegarding the tests about the redirect block was to ensure the redirections were properly followed by OHHTTPStubs and especially that there weren't any regression on this part of the code logic. So I think we should still keep those tests, but they probably need to be adapted/rewritten to make a redirection using whatever new method AFNetworking 3 provides for that.\n. Great! Will take a look probably this weekend. Thanks a lot!\n. 4.5.0 is out, thanks a lot for this PR again!\n. Hi @kremizask.\nWhat's your current Podfile like?\nThe OHHTTPStubsSwift.swift file is part of the opt-in Swift subspec, so as explained here in the README, you need to explicitly list it in your Podfileif you want to have it:\nruby\nuse_frameworks!\n\u2026\ntarget '\u2026' do\n  pod 'OHHTTPStubs'\n  pod 'OHHTTPStubs/Swift'\nend\n\u2026\nThe default subspec only contains the Core of OHHTTPStubs + the NSURLSession, JSON and OHPathHelper subspecs. If you want other subspecs, especially OHHTTPStubs/Swift, you have to list them explicitly in your project's Podfile.\nThat's because using Swift with CocoaPods requires to use pods frameworks, which requires targeting iOS8+, and not everyone can afford to only target iOS8+ for their projects yet.\nThat's why it's still an opt-in feature. This way, people not using Swift can still keep a deployment target as low as iOS5+ on their project if they need to.\n. Well, in some pods, especially ones that don't explicitly specify a default subspec, indeed just writing pod 'ThePodName'generally brings all subspecs by default.\nOn other pods, like OHHTTPStubs, a default subspec is defined, and the other subspecs are opt-in and you need to explicitly specify them to fetch them.\nGlad it solved your problem ;)\n. Ah! Isn't it inherited from the parent specification?\nIf so we'll probably need to re-specify it for watchOS too then.\n. Could you add the watchOS platform to the Swift subspec too, and add a ## Master entry in the CHANGELOG for that change to credit yourself?\nThanks\n. Don't bother: I finally did it myself along with the CHANGELOG :wink:\n. 4.5.1 released to CocoaPods! Thx again for the PR\n. Good idea indeed. Could you please make a PR for that? Thx!\n. Nope\nAs described in the README, OHHTTPStubs uses Cocoa URL Loading System to intercept all network calls made via NSURLRequests and the like.\nI believe GCDAsyncSocket uses low-level, C API sockets so we have no way to intercept those low-level networking sockets with NSURLProtocol.\n. Sorry not to have responded earlier, I got tons of stuff to do and forgot this.\nThat could definitely be a property to add. Won't have much time to add it soon though, but don't hesitate to make a PR to add it, that shouldn't be too complicated to implement :wink:\n. Good poin, thanks!\n. Thanks for the PR !\nThe problem with this fix is that the framework will always be flagged as version \"1\" instead of the real version. When OHHTTPStubs increment its version (in the podspec and in the frameworks) the new version will not change the version in the framework. For people relying on the version of the framework on their code, and for proper dependency and version management, this is not good.\nThe proper fix is probably properly define the CURRENT_PROJECT_VERSION build setting (which is normally done by Xcode automatically so something probably went wrong elsewhere)\n. Fixed by commit 69c64dc6cf9d5df9914aaed027c6a37a49788d39\nThanks for pointing that out and sorry it took me so long to fix that.\nPlease test version 4.7.1 and ensure it indeed fixed your issue with versioning & iTunesConnect :wink:\n. :+1: \n. Yep, what Samir said.\nYou can also see my wiki page explaining how Xcode do unit tests and especially how the test bundle is dynamically loaded into the host target (usually the app) at runtime by Xcode, explaining what you got there. Not related to OHHTTPStubs per se but to how Xcode handle things and how target linking works, so doing what Samir said should fix your configuration.\n. Of course you would. That's how headers work :smiley:\nWhy would you just remove headers instead of following Samir's instructions and fix your Podfile?\n. Any news? Can we close this?\n. Haven't tried achieving that with Alamofire, but it's definitely possible.\nI just read the docs of Alamofire, and it seems that you can:\n- Either implement your own Alamofire.Manager and override the request method and alike to make the same stuff as described in my wiki for AFN (store the body using NSURLProtocol.setProperty(_, forKey:,inRequest:)\n- Or make an extension Alamofire.Request to add a method e.g. storeBody() which does that call, and use Alamofire.request(\u2026).storeBody().reponse { \u2026 } everywhere in your app instead of Alamofire.request(\u2026).response { \u2026 } (not as cool but should work and is opt-in at least)\n- Use a ParameterEncoding.Custom parameter encoding in your requests, which will call the ParameterEncoding.URL.encode() method to build the request, then call the NSURLProtocol to store the body\n- Swizzle NSURLRequest.setBody() in ObjC to call the original implementation then call NSURLProtocol.setProperty(\u2026)\n- Spam Apple with another dupe of the radar so they finally fix it :wink:\n. Nice catch!\nMaybe we should also add nullable to the attributes of the @property(\u2026) here in the class extension too? (even if the most important part is in the public API, but just to be consistent)\nOtherwise :+1: \n. :ok_hand: Thanks again for the PR!\n. Good idea indeed!\nCould you maybe make a Pull Request? (with the new method + some tests on the same model as the other for isGET etc + crediting yourself in the CHANGELOG)\nThx!\n. Where are your actual errors?\nDoes Xcode only complain on not knowing the methods stub() and/or isHost?\nOr does it also complain in not being able to import OHHTTPStubs?\nOr does it only complain in not finding OHPathForFile?\n. isMethodGet does not exist. The actual function name is isMethodGET\nAs for fixture(\u2026) what is the actual error? Maybe it's not that it can't find the function, but just because the parameters don't match what it expects so it can't find a function\u2026 with the matching parameter types?\n. It doesn't ignore stub or isHost so I don't think that's because the source of the Swift wrapper is not seen, but rather a type error in the code (with Xcode maybe printing a misleading error message?).\nThe Xcode error you reported is quite revealing actually. I wonder if Xcode converted the ObjC type OHHTTPStubsResponse into Swift as OHHTTPStubs.Response, namespacing the class automagically. What Xcode version are you using?\n. On what?\nLe mar. 12 janv. 2016 \u00e0 12:54, ogezue notifications@github.com a \u00e9crit :\n\nI'm using XCode 7.2.\nI changed the method to this:\n```\noverride func setUp() {\n    super.setUp()\nstub(isMethodGET(\"mywebservice.com/get\")) { _ in\n    let stubPath = OHPathForFile(\"Overview.json\", self.dynamicType)\n\n    return fixture(stubPath!, headers: [\"Content-Type\":\"application/json\"])\n}\n\n/*\nstub(isHost(\"mywebservice.com\")) { _ in\n    let stubPath = OHPathForFile(\"Overview.json\", self.dynamicType)\n    //isMethodGet(\"\")\n\n   return fixture(stubPath!, headers: [\"Content-Type\":\"application/json\"])\n}\n*/\n\n}\n```\nand now I'm getting\nCannot call value of non-function type 'OHHTTPStubsDescriptor?'\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/AliSoftware/OHHTTPStubs/issues/147#issuecomment-170888725\n.\n. And isMethodGET expects a request not a string, what are you doing with\nyour code ?!\nLe mar. 12 janv. 2016 \u00e0 12:55, Olivier Halligon olivier@halligon.net a\n\u00e9crit :\nOn what?\nLe mar. 12 janv. 2016 \u00e0 12:54, ogezue notifications@github.com a \u00e9crit :\n\nI'm using XCode 7.2.\nI changed the method to this:\n```\noverride func setUp() {\n    super.setUp()\nstub(isMethodGET(\"mywebservice.com/get\")) { _ in\n    let stubPath = OHPathForFile(\"Overview.json\", self.dynamicType)\n\n    return fixture(stubPath!, headers: [\"Content-Type\":\"application/json\"])\n}\n\n/*\nstub(isHost(\"mywebservice.com\")) { _ in\n    let stubPath = OHPathForFile(\"Overview.json\", self.dynamicType)\n    //isMethodGet(\"\")\n\n   return fixture(stubPath!, headers: [\"Content-Type\":\"application/json\"])\n}\n*/\n\n}\n```\nand now I'm getting\nCannot call value of non-function type 'OHHTTPStubsDescriptor?'\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/AliSoftware/OHHTTPStubs/issues/147#issuecomment-170888725\n.\n. Ok could you create a sample/minimalist project and post it there so I can\ntake a closer look?\nLe mar. 12 janv. 2016 \u00e0 13:05, ogezue notifications@github.com a \u00e9crit :\n\nOk - forget this example. I copied a slightly modified piece of your\nexample project into my test with the same error.\nTo be sure I added the modified code to your project where it compiles\nfine.\nvar mytextStub = stub(isExtension(\"txt\")) { _ in\n            let stubPath = OHPathForFile(\"stub.txt\", self.dynamicType)\n            return fixture(stubPath!, headers: [\"Content-Type\":\"text/plain\"])\n        }\nError : Cannot convert return expression of type 'OHHTTPStubsResponse' to\nreturn type 'Response' in line\nreturn fixture(stubPath!, headers: [\"Content-Type\":\"text/plain\"])\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/AliSoftware/OHHTTPStubs/issues/147#issuecomment-170892410\n.\n. The isPath function checks for the URL path, as the name implies. Not the the whole URL.\n\n\n. So instead you should:\n1) either pass your own matcher (closure testing the request), which is probably the most direct and simple approach in your case:\nswift\nstub( { request in request.URL.absoluteString == \"http://www.myserver.com/ressources/objects\" } ) { _ in\n  \u2026\n}\nYou could of course separate this testing code in a dedicated function if you find it more readable:\nswift\n// Reminder: the OHHTTPStubsTestBlock is a type alias for (NSURLRequest->Bool)\nfunc testURL(urlString: String) -> OHHTTPStubsTestBlock {\n  return { request in request.URL.absoluteString == urlString }\n}\nstub( testURL(\"http://www.myserver.com/ressources/objects\") ) { _ in\n  \u2026\n}\n2) Or you could instead create a matcher by combining the various matchers that are provided by OHHTTPStubs/Swift\nswift\nstub(isHost(\"www.myserver.com\") && isPath(\"/resources/objects\")) {\n  ...\n}\nWhich has the advantage of being more flexible than comparing the exact URL (as comparing the exact URL won't match if you send an URL which is canonically equivalent but not string-equivalent, like one containing empty path components or an empty fragment, like http://www.myserver.com/ressources///objects# for example, but which you might still want to stub regardless.\n. > But this doesn't work either?\nProbably because the path of the URL you're trying to stub is not exactly that one.\nFor example I noticed that you made a typo in your URL path, as the correct spelling for the word is resources not ressources, so maybe that's it\u2026\nIf you're not sure why it differs you can still put a breakpoint in isPath and check what values are being compared to see why they mismatch and thus where your typo is. Or you can provide your own OHHTTPStubsTestBlock instead of using the convenience function isPath and use it to log stuff here until you manage to debug what's mistyped or wrong in your code.\n. What exactly would you like to be improved?\nIf you receive a File Not Found error probably this is because the file is not found at the path you gave (so you probably gave a wrong path) isn't it?\n(But I can't help without seeing the code you used :wink:)\nNote that you can make a PR to improve the doc if you find something not clear enough.\n. Simply add it to your Test target. Like you would do for any other file you would want to bundle in your test target for it to access (i.e. that's not specific to OHHTTPStubs, that's classic Xcode step of adding a file to a target)\n. If you put a breakpoint in the closure of your stub(isHost(\"some.com\")) { _ in \u2026 } does it get called on every request? Are you sure the second request is really triggered?\n. Ok so that's not a case like the calls variable being const-captured by the closure and being always 1 in the context of the closure, returning the same stub every time, but more a case like the request is not caught the second time.\nIf the closure is not called it's either because the request is not sent or because the condition is the stub(\u2026) is not met. For example the second call does not use the host you think it does, because you made a typo in your code or sthg.\nTo debug it you could create a \"catching-all-stub\" and put a breakpoint in it to investigate your code further. For example:\n``` swift\n// A stub catching all requests\nstub(true) { request in\n  print(\"Request = (request)\")\n  print(\"Request host = (request.URL.host)\")\n}\n// Then your normal stub, which takes precedence if the isHost() condition is met\nvar calls = 0\nstub(isHost(\"some.com\")) { _ in\n    calls += 1\nswitch calls {\ncase 1:\n    return self.fixtures.root()\ncase 2:\n    return self.fixtures.child()\ndefault:\n     return self.fixtures.error()\n}\n\n}\n```\nThe first stub(true) will catch every request unless those previously caught by the stub(isHost(\"some.com\")). So if the second call is not caught by your stub, the stub(true) will capture it. You could then see what is printed in the console.\nIf the stub(true) closure is not called at all, that definitely means the second request is not even sent. If the stub(true) closure is called, you will be able to investigate what host it uses and use breakpoints to see what went wrong.\n. Use NSURLRequest's allHTTPHeaderFields property. See here in the documentation.\n. That's intended design in OHHTTPStubs to not make the NSData optional. That is to mimic the actual behavior and design of Apple's URL Loading System. And that's because it does not make sense to make a difference between \"nil = no data\" and \"empty NSData\".\nSo I'm not sure why Alamofire accept nil NSData in its design while an empty NSData conceptually means the same so the input domain is over-defined and two different input exist to represent the same case. If your server replies with a 204: No Content do you expect the NSData received to be nil or empty? Given both could match, keeping both possibilities (making it nullable) just makes cases confusing.\nIn fact that's also why Apple revised all their frameworks recently to annotate the Cocoa Framework and change some methods which previously returned nullable NSString, NSData or NSArray to now always return a non-nullable empty objects (empty NSString, empty NSArray, empty NSData, \u2026) instead. Because both could represent the same but having to test both cases instead of just one every time you use the API was a PITA.\n. Indeed.\nI wouldn't say it's a bug in Alamofire, rather a different design choice. I prefer to be aligned with Apple and to avoid having multiple values representing the exact same case, but maybe Alamofire has its rationale for making it optional? Or maybe they didn't think it through yet, and asking them might trigger a debate and reflection about why they allow a nil NSData while an empty one already represent the same thing.\n. Seems that you forgot to bump the version requirements in the Podspecs\nMight want to add an entry in the CHANGELOG too! :wink:\n. Merged, sorry it too so long ;-)\n. Sure, sorry I haven't got back to you earlier I've been busy.\nI'm gonna review #154 and merge it as soon as I've tested everything :wink:\n. If you're using NSURLSession that's expected.\n+setEnabled: only disable stubs on the NSURLConnection stack (and the sharedSession).\nBut NSURLSession instances use NSURLSessionConfiguration to configure supported NSURLProtocol so changing supported URL protocols (which includes turning on or off OHHTTPStubs on that NSURLSession) can only be done before creating the NSURLSession with an NSURLSessionConfiguration.\nThis behavior is documented in the library's documentation here\n. Probably not a good consistency solution because there would then be multiple levels of 'enable' meanings then, but might be worth considering. PR welcome if you think that would be worth it.\n. The problem is that NSURLProtocol doesn't allow s to know from which NSURLSession (thus NSURLSessionConfiguration) a network request comes from.\nSo I don't think that's even technically possible to make OHHTTPStubs.setEnabled(_:,forURLSessionConfiguration:) disable requests on a given configuration once the NSURLSession has been created. Because then the implementation of NSURLProtocol.canHandleRequest: would not know which session the request came from and which enable flag to check to know if the stub should be used or not depending on that enabled flag per session.\nFrom that, if we decide to make OHHTTPStubs.setEnabled(_:) affect every request so that even requests from any NSURLSession would be disabled, there would be a great misbalance between OHHTTPStubs.setEnabled and OHHTTPStubs.setEnabled(_:,forURLSessionConfiguration:) then, because one would only install NSURLProtocols for a given NSURLSession and the other would both install it NSURLConnection and NSURLSession.sharedSession requests and act as a flag for any requests both from NSURLConnection, NSURLSession.sharedSession and NSURLSession.sessionWithConfiguration:.\nIf we do that, I'd prefer that we adapt the API to make it less messy and with clearer intent, otherwise I already see the issues/questions coming from users not understanding why one method originally only affecting NSURLConnection and sharedSession requests\u00a0now also affect other requests created in a sandboxed session.\nSo maybe we could rename setEnabled: and setEnabled:forURLSessionConfiguration: to setInstalled: and setInstalled:forURLSessionConfiguration:, which only configure the NSURLProtocol installation and install OHHTTPStubs in the URL Loading System, while a new method setDisabled: would apply to every request and stub, whether their are from an arbitrary NSURLSession, the NSURLSession.sharedSession or from NSURLConnection. And remove the ambiguous setEnabled: and setEnabled:forSessionConfiguration then.\n. @janglesdev I'm closing this \"OHHTTPStubs isn't switching off\" issue as the original issue is solve (it was more of a misunderstanding of the API than a bug) and lack of solution about an API change that would solve what we discussed above.\nBut feel free to open a new PR to add that distinction between setDisabled vs. setInstalled: discussed above if you still feel it feasible and worth it. I'm still open to the idea if you find a proper solution \u2014 even if as I said earlier, I'm not sure it's technically possible with NSURLSession.\nAs we can't modify NSURLSessionConfigurations on existing NSURLSession and we can't know from which NSURLSession is coming the request when canHandleRequest: is called in NSURLProtocol to determine if we should stub or not, I don't see any proper way to support that but would be glad to if you find a way.\n. Mmh no that (null) seems strange indeed.\nMaybe you're experiencing this problem and your stubs get added to one of the OHHTTPStubs class instance while the tested code use another?\n. Ok so I guess your stubs are setup correctly, but the conditions probably don't match anymore.\nEspecially, request.URL!.absoluteString == URLs.sharedInstance.overviewItemsUrl() is probably never true. Which might be because you added query params, or a / is being aded at the end of the URL sent, or because you have # anchor in your URL etc.\nIt's generally not a good idea to compare absoluteURLs directly to stub. Because multiple URLs with slight differences might represent the same URI resource. Like http://host.org/path?foo=bar&baz=qux, http://host.org/path?baz=qux&foo=bar, http://host.org/path/?foo=bar&baz=qux and http://host.org:80/path?foo=bar&baz=qux&# all probably represent the same in your server (they are said to be \"canonical equivalent URLs\"), but comparing the absoluteString of each will fail.\nTo debug your issue, I suggest that you log all of the requests that might be captured by OHHTTPStubs and carefully check the differences between the compared URL!.absoluteString, as I bet there are some tiny subtle differences that would explain why the == test fail:\n``` swift\nself.httpStub = stub( { request in\n  print(\"Request to be sent: (request) \u2014 (request.URL!.absoluteString)\")\n  print(\"Will be compared to: (URLs.sharedInstance.overviewItemsUrl())\")\n  let compared = request.URL!.absoluteString == URLs.sharedInstance.overviewItemsUrl()\n  print(\"Comparison result: (compared)\")\n  return compared\n} ) { _ in\n            let stubPath = OHPathForFile(\"Overview.json\", self.dynamicType)\n        return fixture(stubPath!,status: 200 ,headers:\n            [\"Content-Type\":\"application/json\"])\n    }\n\n```\nOnce you've figured out what are de differences between the sent request URLs and the ones you compare them to, you can refine your comparison condition and avoid using absoluteString but instead compare requests by their relevant parts, like the URL host, path, query params, etc.\n. Then if even the comparison closures are never called that means that OHHTTPStubs is not loaded by the time you initialize your NSURLSession, maybe because you do your first call with Alamofire too early \u2014 especially if you use hosted tests and create your NSURLSession (via your first request using Alamofire maybe?) in the application:didFinishLaunchingWithOptions:, which is executed just before the Test bundle is loaded in memory by Xcode/XCTest?\nEspecially you should take a look at issue #126 as you might have a similar setup causing a similar behavior.\n. How did you integrate my library? CocoaPods ?\nWhat subspec did you integrate in your Podfile?\n. Especially, the OHPathHelper subspec is only included by default if you ask only for pod 'OHHTTPStubs' (or the pod 'OHHTTPStubs/Default' subspec, which is the same as this is the default subspec)\nSo if you only included pod 'OHHTTPStubs/Swift' then this subspec only brings the Swift wrapper (and theCore subspec it depends on) but not NSURLSession support, JSON helpers nor OHPathHelper which explains why it would not have been linked.\nSo typically you should specify both pod 'OHHTTPStubs/Swift and  pod 'OHHTTPStubs' (or pod 'OHHTTPStubs/Default') if you want both the Swift wrapper and the commonly used helpers.\n. Well of course using pod 'OHHTTPStubs/Default' instead of pod 'OHHTTPStubs' didn't change anything, as explained in my first answer they are the same :wink:\nYou must include both the root spec and the Swift addition:\nruby\npod 'OHHTTPStubs' # This will get you the Default subspec including Core, NSURLSession support, JSON helper and OHPathHelpers\npod 'OHHTTPStubs/Swift' # This will add the Swift API\nOnly doing one of those two will only get just what you ask not both.\n. For your second issue just check the condition you put in your stubs are correct. e.g maybe you added a stub for foo/bar but the request being sent by AFNetworking is in fact foo/bar/ for example with a training slash or something.\n. Yep, someone opened #126 because they were having a similar issue (creating the NSURLSession too early, whereas the OHHTTPStubs framework patches the NSURLSessionConfiguration to catch the requests, so it needs to be loaded before any NSURLSession is created otherwise NSURLSession created before OHHTTPStubs had time to load won't be patched)\nDid you fix all your issues, can we close this?\n. What's the CP issue/error message you're encountering?\n. Oh I see. Never had that issue before, it passed when running OHHTTPStubs tests on CI before which runs the checks for each platform, so will take a look later :+1:\n(PS: a bit busy this week so I might not be able to test this PR until this weekend)\n. :+1:\n. Yeah, OHHTTPStubs starts having history, that code was written a while back when @synchronized was the way to go. Nowadays if I were to re-do it, I'd probably use NSLock or OSSpinLock or something. But as this is not the purpose of this PR, I think it's better to keep @synhronized here for now. We can still decide to make the switch for NSLock or OSSpinLock in a separate and dedicated PR if we feel the need, but that's a separate issue :wink:\n. Awesome, thanks again for the PR :ok_hand: \n. Great thanks for the PR! :ok_hand:\nCould you add an entry (under some ## Master title) in the CHANGELOG.md to credit yourself? Thx!\n. The CHANGELOG have titles for each version, like ## 4.8.0 and ## 4.7.0 etc.\nSo tTo add a new entry, you'll simply need to add a section for \"Master\" (rather than, e.g. add a section named \"4.9.0\" or whatnot \u2014 since I don't know when I'll release a new version and what this next version will contain, so we can't know in advance what the next version number/name is gonna be).\n```\nMaster\n\n.\n@, #160\n```\n\nNote: in order for GitHub's markdown to go to the next line between your entry description and the line with your name and PR link, you'll have to end the description line with two spaces (see other entries in the CHANGELOG for inspiration)\n. :+1:\n. Thanks a lot for this PR! Looks quite good! :+1: \nI don't know why Travis didn't pick up that PR, it usually does (it did for the last PR 160, so why not this one?), so that's strange indeed.\nCould you also add an entry in the CHANGELOG.md to list your changes there and credit yourself? Thanks!\n. Hello,\nThanks for letting me know.\nProblem is, the artefact uploaded in the GitHub Releases is there for Carthage compatibility. And Carthage explicitly expects it to be named NameOfTheLibrary.framework.zip explicitly; so I don't see how I can make it work for Carthage for both Swift 2.1 and 2.2, as I will have to choose which one to name it so that Carthage should pick it, and that choice is impossible as it depends on what Swift version people are using.\nSo instead I think I'll have to release a new version\u2026 with no real new feature but just to allow Carthage users to pick one or the other :unamused: \nThat's one reason why I don't recommend using Carthage which rely on Swift ABI compatibility which we know will break, and encourage using other solutions like CocoaPods instead.\n. @AlexDenisov unfortunately given how Carthage works we can't both propose the zip for Carthage to download and propose the option for Carthage to build from source. Either the zip is there either it isn't but we can't have multiple zips for Carthage to use and if there is a zip Carthage won't build from source. I know, right?\n. I think the only reasonable option here is what @iamtomcat suggests: for the next release (expected in a few days after merging the last recent submitted PRs) I won't include any zip at all so that Carthage will be forced to rebuild from source in order to be sure it's compatible with both Swift 21 and 2.2 and avoid ABI incompatibility.\n. @kwandrews7 I believe your problems ar totally unrelated: if you've imported the OHHTTPStubs project manually, then you're building them from source; so in this case this is not related to build artefacts at all (you might need to \"clean\" before \"build\" though, but as for any other project, and this has nothing to do).\nThe future release \u2014 that I plan to do this ween-end \u2014 will not contain pre-build artifacts to avoid compatibility issues between Swift 2.1 and Swift 2.2, and so that Carthage build them back from source. Having a pre-build framework relying on a specific Swift runtime is not recommended by Apple anyway (at least not until the Swift ABI is stable)\n. Version 5.0.0 has been released to CocoaPods.\nThe GitHub release 5.0.0 has also been created, but this time I didn't include the prebuilt framework in order to avoid Swift Runtime ABI incompatibility risks for Carthage users during the transition from Swift 2.1 to Swift 2.2\n. Hey @sdduursma, thanks for the PR!\nCould you add a line in the CHANGELOG to credit yourself? Thx!\n. Perfect, thx!\n. This method already exists since version 4.7.0.\n. Probably because either you're asking it to, by constraining your version in your Podfile, or because it's constrained by your Podfile.lock and you're only doing a pod install rather than a pod update OHHTTPStubs\u2026 (Use pod outdated to check if a new version is available regardless of those, see the CP guides)\n. I don't see any CP issue here, this kind of configuration has always worked for me even in CP 1.0.0 betas . You probably forgot to use pod update or have another pod in your Podfile which has a stricter dependency (your Podfile.lock) will tell you which)\n. Thx!\n. Cool, looks interesting !\nDon't forget to add an entry in the CHANGELOG to credit yourself.\nI'm going on vacation for two weeks so I won't have time to check that PR until I return.\n. Finally had time to check that PR :tada: (sorry it took so long)\nPlease address the above comments, then rebase the branch on top of master \u2014 because as master has evolved since your PR, your branch is now in conflict (probably only because of the CHANGELOG entry, so not a complex conflict to fix :wink:)\nOtherwise I'm \ud83d\udc4d \n. > - [ ] Adjust the version number in the changelog as appropriate\nFYI, in general I use a special ## Master entry for that (instead of the 5.x you created), so that we can add more and more entries and only specify what the exact version number it should be (according to semver) when releasing a new version only :wink:\nSo when you'll be rebasing, you'll see that ## Master entry is now already existing on master (since I already merged other PRs that had it), so just put your changelog entry below the others of that section and I'll take care of changing ## Master to the proper version when I decide to do a release :wink:\n. Ping @felixLam ?\n- [x] Remove OHHTTPStubsMethodSwizzling.h from the public headers in the podspec\n- [x] Rebase\n. np, thx\n. Thx  :+1:\n(I don't know what's wrong with travis not reporting the test results on this PR suddenly\u2026 will investigate and merge once ok)\n. @felixLam Ah good point that was probably it. Tested locally and force-merged onto master, (let wait for travis to check master now just to be sure\u2026 :wink:)\n. @felixLam In an effort to try and follow Moya's Contributor Guidelines, and to thank your for your recent contribution to OHHTTPStubs, I just added you as contributor to OHHTTPStubs so that you can now merge PRs and manage issues!\n(Note: master is locked against direct commits, in order to force us to make PRs pass tests before we can merge any new code to master)\n. Right, added @shagedorn as a contributor as well just now :wink:\n. @felixLam @shagedorn while doing the 5.1.0 release, I just realized that maybe I merged that PR too quickly. I mean, it should work, but:\n- [ ] It's missing Unit Tests. We should add at least one unit test for this feature, ensuring that the code works and that there won't be any regression later\n- [ ] The file where you added the category is called NSMutableURLRequest+HTTPBodyTesting.h/m but is in fact an extension on NSURLRequest, not NSMutableURLRequest, so for consistency's sake we should probably rename it. Don't forget to update the name is the podspec as well.\nThat doesn't seem much work to do to make it right, so do you think you'd be able to throw a quick PR to add that soon, so I can include it properly in the upcoming 5.1.0 release?\nThx!\n. Cool Thx \ud83d\udc4d \n. ping @felixLam ?\n. > the OHHTTPStubs.h file only includes the bare minimum of imports, which I assume is intentional\nThat's sadly a legacy issue, because when I created OHHTTPStubs years ago, I didn't think it would grow that much, and I only had one public class, named OHHTTPStubs, which have the same name as the pod/framework itself.\nNow that OHHTTPStubs has grown a lot, OHHTTPStubs.h remains the header of only the OHHTTPStubs main class (like every other Foo class has its dedicated Foo.h header).\nI can't use OHHTTPStubs.h itself as the umbrella header as well (because of cross-import reasons \u2014 I can't import every .h in OHHTTPStubs.h because some of those headers needs the OHHTTPStubs class to be defined first \u2014 and for subspecs reasons \u2014 especially, the headers we need to import depend on the subspecs people opt-in in their Podfile). I tried in some branches to improve that and make OHHTTPStubs.h the umbrella header but sadly it always led to complex problems and incompatibility with modular imports and all.\nThat's because of all these reasons that the umbrella header being OHHTTPStubsUmbrella.h and not OHHTTPStubs.h\nBut anyway, using the modular import @import OHHTTPStubs; is indeed the way to import modules nowadays, which thanks to the .modulemap I wrote automatically import the right umbrella header for you.\n\nLooking fwd to your PR @shagedorn so that we can release the next version \ud83d\udc4d \n. np I know those situations \ud83d\ude09 \n. Seems Great and really interesting indeed!\nThis could also interest @lukabernardi who requested it in #53 a while back\nI'd make the sendResponseHandler property private instead of public (as it's set by the framework and it's supposed to be called by the respondNow public API already) but otherwise seems great.\nCould you maybe submit a PR for this to propose the code and its associated Unit Tests?\n. Strange behavior indeed.\nI'm not a Carthage user myself, so I don't really understand why it can't find the file in /Supporting Files and why it searches in Carthage/Checkouts, I'm not sure how all this thing with Carthage is supposed to work tbh. Maybe you should ask on the Carthage repo, or maybe someone more experienced with Carthage inner behavior could help?\n\nI didn't link the rebuild framework for version 5.0.0 because Carthage has another issue: due to how it works and make frameworks depend on the Swift Runtime libraries, using Carthage breaks when the Swift ABI changes, which is what happened with Xcode 7.3, which is embedding a new version of Swift and the Swift Runtime compared to Xcode 7.2.\nSo I couldn't ember a Carthage framework that would be both compatible with Xcode 7.2 (for people who didn't already upgrade yet, possibly due to the depreciation warning it generates) and Xcode 7.3 and the preferable solution was to not provide a pre-build framework so as to force Carthage to rebuild the library from source, hence matching the Xcode version \u2014 and more importantly the Swift version used \u2014 by the user's project.\n(To my understanding, that's a flaw in Carthage foundation itself, relying on / expecting the Swift ABI to be stable whereas Apple explicitly said that it wasn't \u2014 that's also why I prefer to rely on SPM or CocoaPods which build libs from source)\n. Any luck with asking on StackOverflow or on the Carthage repo to have more information about this kind of issue?\nAs I said, I'm not sure about what is wrong but as I'm not a Carthage user and don't really get how Carthage works and why it can't find the umbrella header, I'm not sure I can help, would love to see this issue resolved though.\n. Oh that's awesome thanks for the feedback! Sorry not to have been more helpful with that.\nDo you know where that ../** came from? Did you or one of your coworker add it to your project at some point manually? Or do you think it was added by some external tool behind the scenes?\nAnyway thanks for the feedback, I'm gonna close the issue as it was not related to my lib but to your project configuration after all!\n. Interesting! Does this properly only do that on tags, not on any other master commit, right?\n\nFYI, the last releases of OHHTTPStubs stopped attaching prebuilt framework archives to the GH release because it led to problem for Carthage users. Indeed, some people were still using Xcode 7.2 (thus Swift 2.0 or 2.1) while other already migrated to Xcode 7.3 (thus Swift 2.2), and using a prebuilt framework led to ABI incompatibility issues (see #162 for more details)\nThat's why I preferred to let people build the framework with the same Xcode version that they were building their app, instead of providing a prebuilt-framework\u2026 that wouldn't work for half of the users.\nMaybe I'm gonna restore the prebuilt-framework for the next release, considering that now people had time to migrate to Xcode 7.3, but I don't want to penalize people that are force for some reason to still use 7.2 and Swift 2.1\u2026\n. Merged via 99feb7fc12b14e03e83147684dd3c409b4a247a3 (at last!)\nThanks for the tip!\n. Just released 5.1.0 with this travis config enabled and it worked and indeed released the Carthage build automagically \ud83d\udc4d Thanks\n. Interesting. Maybe @JinlianWang, who is the one who implemented the Mocktail support in #108, has more information?\nBut indeed I'd agree on fixing that and support both formats by checking the presence of a : on line 4!\n(PR welcome, btw :wink: )\n\nAs for HTTPMessage that's the format generated by curl -is; so it's a little bit different than Mocktail, but very similar anyway, containing headers then body in a text format. Not sure if it's documented/used widely outside of curl though.\n. Are you using Hosted Tests (which launch the application target itself before starting the Unit Tests)? If so, be sure that you don't do any AFHTTPSessionManager can in your application:didFinishLaunchingWithOptions: method, because this would be executed before your Unit Tests and more importantly before OHHTTPStubs get loaded in memory by Xcode, and thus the NSURLSession created by AFHTTPSessionManager would be created before OHHTTPStubs could even install the stubbing protocol in it.\n. See also https://github.com/AliSoftware/OHHTTPStubs/issues/126#issuecomment-145149158 which might be similar to your problem, with detailed explanation on what might be happening in your project and how to solve it.\n. Very strange. Did you compare your project with the example projects provided in the OHHTTPStubs repo to see what you did different?\nIn your sample project without AFHTTPSessionManager, what did you use instead? If you used NSURLSession and one of its task\u2026 method, didn't you forget to call resume on the task be sure to start the request, i.e. does the request even actually fire to the network if you don't try to stub it?\nI even wonder if your initial issue (\"it works in main project but not in tests\") and the one in your simplified example (\"can't stub when I try without AFHTTPSessionManager\") might be different problems (e.g. one where your test project might be misconfigured and the other where you didn't even start the request, as I too often forget to call resume)\nDid you try to place some breakpoints in the OHHTTPStubs library code itself to see if it was even called, especially if it intercepted any request at all to test it against the isPath(\"/test\") and thus if what is wrong is the global setup of OHHTTPStubs or if it's just the test isPath(\"/test\") that is checked but returns false, or whatnot?\nI can't really see what's wrong without seeing your sample project anyway, because such code works in my example projects here. Maybe if you provide your sample project I could look at it and check.\n. I haven't looked at your sample project yet, but, if it works with NSURLConnection and  NSURLSession.sharedSession (which use NSURLProtocol installed globally) but doesn't work with any other NSURLSession (which are created from NSURLSessionConfiguration objects), that means that you created your NSURLSession before OHHTTPStubs had a chance to load into memory and inject itself in NSURLSessionConfiguration to swizzle its custom NSURLProtocol in there.\nWhich is exactly what issues like #126 are about.\nTry to make sure that OHHTTPStubs is loaded in memory before you even create your NSURLSession(configuration:\u2026) so it has a chance to inject itself and intercept future requests. As explained in the Apple doc, once an NSURLSession is created, its internal NSURLSessionConfiguration is frozen and can't be modified, and this also means that OHHTTPStubs can't inject itself there (which it does when the framework is loaded in memory, so usually as soon as the test target is loaded) which it's too late for any NSURLSession created before that (like ones created in applicationDidFinishLaunching, as explained in #126).\nI'll take a look at your sample project in a second to see if that is exactly the case you're encountering or not and get back to you to confirm.\n. Ohhhh wait, just opened your sample project now\u2026 The problem is wayyyy simpler than all that! (Sorry for the misdirection in the previous comment)\nYou just forgot to include the subspec to add support for NSURLSession in your Podfile, so no wonder it doesn't work with NSURLSession :wink:\nIn fact, the root spec pod 'OHHTTPStubs' contains already the most-often used subspecs, including OHHTTPStubs/Core, OHHTTPStubs/NSURLSession, OHHTTPStubs/JSON and OHHTTPStubs/OHPathHelpers. This means that if you put pod 'OHHTTPStubs' in your Podfile you will already have them all and will then only opt-in for pod 'OHHTTPStubs/Swift' for Swift support.\nBut if you specifically ask for subspecs only and not for the root pod \u2014 as you did in your Podfile as you listed pod 'OHHTTPStubs/Swift and pod 'OHHTTPStubs/OHPathHelpers' but not pod 'OHHTTPStubs' \u2014 then it only pick the specific subspecs you specify. So in that case you'll have to opt-in for the OHHTTPStubs/NSURLSession subspec explicitly too.\nThe solution is:\n- either to have pod 'OHHTTPStubs' (which will include the OHPathHelpers but also the NSURLSession support) and pod 'OHHTTPStubs/Swift' (to add Swift support \u2014 which is not included by default)\n- or to add pod 'OHHTTPStubs/NSURLSession' to your Podfile next to the existing two subspecs already declared there (you then won't have the JSON support and its ability to create JSON stubs from dictionaries easily, except if you opt-in to it too, but maybe you don't need it in your project and tests anyway, depends on your use cases)\n. Tested locally by adding pod 'OHHTTPStubs/NSURLSession' in your Podfile, running pod install then running the tests again, I can definitively confirm this was the reason for the issue.\nClosing the issue now (but feel free to add comments here if you have remarks or don't manage to make it work in your end)\n. :ok_hand:\nCould you add a line to credit yourself in the CHANGELOG?\n. Good call! Could you also add an entry in the CHANGELOG to credit yourself and link the PR? Thx!\n. Fixed by merging #175 \ud83d\udc4c \n. Thanks for the PR \ud83d\udc4d Looks ace! \ud83d\udc4c \nCould you please:\n- pull the new commits from master then rebase your branch on top of my master branch\n(so that your branch includes the latest commits from master, as I've merged other PRs on my master since yours)\n- then add an entry in the CHANGELOG.md to credit yourself \ud83c\udf89 \nThanks!\n. @adurdin In an effort to try and follow Moya's Contributor Guidelines, and to thank your for your recent contribution to OHHTTPStubs, I just added you as contributor to OHHTTPStubs so that you can now merge PRs and manage issues!\n(Note: master is locked against direct commits, in order to force us to make PRs pass tests before we can merge any new code to master)\n. @adurdin: Noted \ud83d\ude09 \nBut just to be clear, the push access doesn't come with any requirement nor expectation from your part \ud83d\ude09 \nIf you want to use it do it, if you don't no problem, if you don't have time, no problem either: there is no expectation on you contributing on a regular basis or whatnot, it's just for in case you want to, you now have more access, you can do whatever you want with it\u2026 including nothing \ud83d\ude1c \n. I just tested your sample code provided. The stubbing works perfectly.\nBut what makes you think that it doesn't work is that your test method always calls callback(\"dont work\") whatever the request(.GET, API.url).responseJSON returned. So even if you stub your request so that it returns stubbed data, your api.test { \u2026 } callback will always be called with a result having the \"dont work\" value as that's the hard-coded value that you return every time.\nBesides, you use Alamofire's .responseJSON which expects the data received from the network (or from your stub in your case) to be JSON \u2014 and would fail if it's invalid/un-parsable JSON \u2014 but if you stub with the string \"works\" this won't be parsable as JSON so Alamofire will fail. Which is another reason why you don't manage to stub\nFinally, I'm not a Quick/Nimble user myself, but are you sure that expect(finalResult).to(equal(\"works\")) does wait asynchronously for the result?\n. As a proof that OHHTTPStubs is stubbing as it should, I managed to make your code work by changing these in your code:\n1) I change your stub.txt file to contain { \"foo\": \"works\" } instead of just works, so that at least it is valid JSON, and would make sense for your stub (otherwise .responseJSON would fail to parse the stubbed response and would make your test fail anyway)\n2) Make api.test return something that actually depend on the response instead of a hard-coded value\nswift\nfunc test(callback:(String) -> Void) {\n        request(.GET, API.url)\n        .responseJSON { (response) in\n          let jsonDict = response.result.value as? [String:String]\n          callback(jsonDict?[\"foo\"] ?? \"\")\n        }\n    }\n3) Make your test asynchronous\nAs expect(finalResult).to(equal(\"works\")) doesn't wait for the request to be finished before testing, so it checks for equality in a synchronous manner \u2014 which doesn't make sense for network calls which are asynchronous by nature \u2014 which makes your test fail (as it compares finalResult too soon, before the request has returned).\nSo instead, change it to use toEventually instead of to:\nexpect(finalResult).toEventually(equal(\"works\"))\nSee https://github.com/Quick/Nimble#asynchronous-expectations for more info (that's where I found it as I never used Quick/Nimble before)\n. Thx for the issue report, will investigate soon!\n. Actually thinking about this after a good night's sleep, I don't think I'm gonna need to fix anything, as this works as expected and OHHTTPStubs already provides another mean to achieve what you want to do:\n- responseTime is indeed a simulation of the time it takes to send the request body. It's a way to limit the download speed of the body, so it indeed needs a non-empty body to make sense\n- But OHHTTPStubs also provides requestTime to simulate the time it would take for your request to be sent/uploaded to the server and processed by the server before the server starts delivering the (possibly empty) response.\nSo to achieve what you're trying to do, you can simply use requestTime instead!\nswift\nOHHTTPStubsResponse(data: NSData(), statusCode: statusCode, headers: nil).requestTime(10)\n. @felixLam I updated the wiki page just now, let me know if you find it clear enough (and if so, you might then close this very issue :wink:)\n. Tip: you can see the diff of the wiki page here for easier comparison/revision\n. @shagedorn I'd love if you could take 2 minutes to proof-read the changes in the wiki entry so we can close this one as well!\nThanks for your efforts on this feature btw \ud83d\udc4d \n. Ah, great point. I agreed providing a reset method is not worth it imho, but we could definitely mention it in the wiki.\n. Note added (under the workaround example). Closing now, thanks for the review!\n. Thanks for filing an issue and providing a sample test project to reproduce the issue! \ud83d\udc4c \nThat's a good question actually. I can already confirm that I reproduce the issue and can't stub the requests sent by the WKWebView \ud83d\ude22 \nI'll investigate a bit more, but at first glance my theory is that, since WKWebView is a bit special as it runs in a separate process different than the one from the application (e.g. you have less control over it for stuff like cookies, etc), that might be related. Will keep you posted.\n. Ok after a little digging, I can confirm that it is indeed a limitation of WKWebView.\nSee for example this answer in SO but also this radar as well as this one. As OHHTTPStubs uses an NSURLProtocol behind the scenes to catch the outgoing requests transparently and return the stubs before they hit the network, then WKWebView not supporting custom NSURLProtocol classes means we'll never be able to catch those requests from the application.\nThis is all because WKWebView uses an out-of-process engine to send requests, execute JS and render the page, and is totally isolated from the app process. So we have very little control over WKWebView for this sort of things (they have the same problem about cookies and similar features btw)\nI'm going to close this issue now, as this is actually an Apple Bug and I won't be able to do anything about it, but feel free to open a bug report to Apple (by duplicating the radars I mentioned above) to make this possible one day\u2026 hopefully!\n. As NSURLRequest+HTTPBodyTesting.h is already in OHHTTPStubsUmbrella.h it seems, I don't think there is any other place to add it. It's mentioned in the wiki page as well so we should be good!\n. 5.1.0 is out, including this change!\n. Which subspec did you list in your Podfile? Did you include pod 'OHHTTPStubs/JSON'?\n. It includes all but the Swift subspec so if you're only using it from ObjC you should be OK on that front.\nDid you import the header then (preferably with modular import)? What's your actual code?\n. You should use modular imports instead (@import OHHTTPStubs;) which imports the whole module that would have avoided you the trouble :wink:\n. Thanks for the Pull Request! \ud83d\udc4d \nI can't merge it on master though, as it's way too early to migrate the master branch of OHHTTPStubs to Swift 3 \u2014 while many people will continue using Xcode 7.3 until 8.0 is out of beta, and many people will continue using Swift 2.3 by then anyway.\nBut I'll of course consider creating a dedicated Swift3 branch to merge that PR into, so that people could point to it :+1:\n\nIn the meantime, it would be super-cool if you could wrap the changes you made in the source code in some #if swift(>=3.0) blocks, so that the source code would still be compatible with both Swift 2.x and Swift 3.0.\nThis would allow the pod to be installable and compilable on whatever Swift version people are using (at least if they use CocoaPods, as the podspec doesn't rely on the Xcode project but only on the source files) without the need to manage multiple branches (I could merge that to master :wink:)\n. I think we could do the migration in multiple steps:\n1. create a new (major) version of OHHTTPStubs that alter its API in order to follow the Swift 3 API Guidelines, but still be compatible/compiled with Swift 2. This means keep using Swift 2, but simply alter the method signatures of the pod's API to prepare it for the migration, and release a new major version so people prepare to this new API even in Swift 2\n2. from that version, alter the implementation where needs be (potentially using the #if tests if its possible not to have too much code duplication) so we can have a Swift 3 branch\nIn summary, address points 1 & 2 separately in order to help some progressive migration.\nDo you think that would be worth it and help people prepare for migration?\n. Thx @mxcl for the suggestion (wow THE Max Howell commenting on my repo :blush: ^^) this might indeed reduce code duplication during the migration phase :+1:\n(To be clear I don't intent on maintaining Swift 2 compatibility in the long run; that would only be for the transition phase, until ~ end of 2016 I guess)\n. @djbriane Would you be OK if I close your PR in favor of #192 which seems more advanced as it uses @mxcl 's suggestions and will be able to support both Swift 2.2, 2.3 and 3.0 in the same branch (if I understood #192 correctly)?\nThanks for the efforts anyway, and sorry it took me so much time to give some feedback of this Swift 3 support!\n. Thx and thanks again for your efforts on this PR!\n. Hi there,\nThere is no official way to do that the way NSURLProtocol works in Foundation.\nBut you might be able to trick it by using NSURLProtocol.propertyForKey(_:, inRequest:) and NSURLProtocol.setProperty(_:, forKey:, inRequest:) methods \u2014 see here in the wiki for an example usage\nMy idea for your use case, the idea would be to stub requests that have no value set for an arbitrary property ByPassStubs, and in the stubbing block, duplicate the NSURLRequest, associate to it a value to the ByPassStubs property, and re-send it. This time the secondary request won't be stubbed as you et the flag, and once the request is finished, you could build your real stub response from that.\nNote that the secondary request would probably need to be sent in an asynchronous way because you won't be able to wait for a completion block to be called to return from the stub method.\n. Here is a draft of what it might look like.\nQuickly typed directly in GitHub, so:\n- not tested at all\n- invokes synchronous network requests which is bad (maybe make it run on a dedicated thread + runloop instead?)\n- the function sync-sending the real request only returns the data, you might tweak this to return the statusCode and headers as well so you can adapt to your needs\nBut basically it's just to show you the idea.\n``` swift\nprivate let kFlagKey = \"ShouldBypassStubs\"\nlet hasBypassFlag: OHHTTPStubsTestBlock = {\n  NSURLProtocol.propertyForKey(kFlagKey, inRequest: $0) != nil\n}\nprivate func sendSynchronousRequest(request: NSURLRequest) -> NSData? {\n  // Don't do this at home, kids. It's bad.\n  var data: NSData? = nil\n  let semaphore: dispatch_semaphore_t = dispatch_semaphore_create(0)\n  let task = NSURLSession.sharedSession().dataTaskWithRequest(request) { taskData, _, error -> () in\n    data = taskData\n    if data == nil, let error = error {print(error)}\n    dispatch_semaphore_signal(semaphore);\n  }\n  task.resume()\n  dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)\n  return data\n}\nstub(isHost(\"mywebservice.com\") && !hasBypassFlag) { req in\n  let reqCopy = req.copy() as! NSURLRequest\n  NSURLSession.setProperty(true, forKey: kFlagKey, inRequest: reqCopy)\n  let data = sendSynchronousRequest(reqCopy)\n  return OHHTTPStubsResponse.responseWithData(data, statusCode: 200, headers: nil)\n}\n```\n. Thanks for the PR ! :+1:\nWondering if I should really merge the last commit of your PR 80860843e066450b95ab09bb01960e5f2949c11d (the one containing that patch described in Quick/Nimble#302) or better wait for the next Xcode beta to see if it's fixed. Keeping that patch in the long run in the repo would seem hacky to me (because let's be honest, if I merge this patch commit I'll forget about it in a few weeks/months and never remove it later :wink:)\n. Hey @ikesyo !\nIt seems like the workarounds (for linker & device codesigning) are no longer needed in Xcode 8 beta 2? https://github.com/Quick/Nimble/pull/316\nCould you thus please remove the workaround commits from this PR so we can move forward and merge a cleaner solution then? Thx!\n. Note that we might also want to tweak the .travis.yml file by adding a build matrix so the CI check the build both with Xcode 7.3 and Xcode 8 (it is currently only using the osx_image: xcode7.3.\nYou can find some inspiration on this .travis.yml file on my other library where I already did that kind of configuration.\n. Sadly that happens more and more on Travis lately, builds taking ages to start and builds randomly failing, while they pass perfectly locally.\nGiven that we now have 8 parallel builds for each PR now (because of the build matrix testing the 4 targets, each in Xcode 7 and 8) there are more chances that one of those 8 randomly fail because of that.\nNot sure if I can do anything about it. I could deactivate my timing tests for all but one build, that would probably help as those expect the response to be in a specific time window to ensure the given responseTime is respected\u2026 but if the Travis VM is too solicited and slow that doesn't help. But the most build fails I've seen lately are not because of them but more because of Travis failing to launch th Xcode test command, so I'm puzzled\u2026\nI just relaunched the Travis build that failed and hope it will pass this time, until I have more time to investigate that Travis bug.\n. Great!\nThx for the PR :+1:\nCould you please add an entry in the CHANGELOG to credit yourself? Thx!\n. Seems ok from what I read from the diff on GitHub, will merge soon \u2014 probably tonight \u2014 when I have access to my Mac to make a proper test and release.\n. Sorry I've been more busy than I thought in the last few days, and also had to release a new version of SwiftGen in parallel\u2026 but rest assured I didn't forget about OHHTTPStubs and this PR :wink:\n. Interesting issue! Sorry not to have given any feedback sooner.\nI'm wondering if the solution is as simple as just turn Embedded Content Contains Swift to NO and it will work in all 4 cases (both for people using OHHTTPStubs thru CocoaPods without the Swift subspec, thru CocoaPods and with the Swift subspec, as a framework and using Carthage) though?\n. Fixed by #217 / #220 sorry it took so long\n. When you build your OHHTTPStubsResponse to return in your stub, you should be able to build that response in multiple possible ways, as this type exposes various constructors, including:\n- responseWithData:statusCode:headers:, which builds an [NSInputStream inputStreamWithData:data?:[NSData data]] then calls the internal initWithInputStream:dataSize:statusCode:header: constructor\n- responseWithFileAtPath:statusCode:headers:, which builds an [NSURL fileURLWithPath:filePath] then call the method below\n- responseWithFileURL:statusCode:headers: which builds an [NSInputStream inputStreamWithURL:fileURL], compute the file size, then calls  the internal initWithInputStream:dataSize:statusCode:header: constructor\ninitWithInputStream:dataSize:statusCode:headers: is the designated initialized (that will be called in the end by any of the other convenience initializer) and which definitely takes an NSInputStream.\nSo yes, if that was your questions, you have everything to stream from a file, responseWithFileURL:statusCode:header: already uses NSInputStream and streams that content (instead of loading it all in memory at once and sending that NSData).\nThe only thing OHHTTPStubs does that your player might not like is that it adds the Content-Length header to the request automatically if it's not present/defined already, and if your player expects streaming content in the sense of \"non-fixed-length content that might never end\", maybe that additional Content-Length header bothers it?\n. Hi. I'm gonna close this issue now due to the fact that I think I've answered your question and due to lack of response. Consider reopening if you still have pending problems about that due to OHHTTPStubs itself.\n. Thanks for the PR! Would indeed love to stabilize those Travis builds!\nYeah I had that random problem with Travis even before Xcode 8, so not sure that's related to Xcode 8 :-/\n. Btw I just added you as collaborator to OHHTTPStubs, first to thank you for your latest contributions on it, and also to give you ability to create branches directly on my repo instead of having to have your own fork. Feel free to ask if you need anything like some additional Travis access or whatnot!\n. Cool! Wonder why though\u2026 but hey if that works \u00af_(\u30c4)_/\u00af\n. @Dershowitz011 I'm gonna close this issue now as you can use either @mxcl 's fork, or use #192.\nI'll try to find time soon to merge #192 and make it part of the official repo in master, sorry for the delay!\n. It's strange that you have NSMutableURLRequest+HTTPBodyTesting.h between 5.0.0 and 5.1.0.\nThis was introduced as part of #166 + #180 PRs which were both part of the 5.1.0 release\n- 5.0.0 did have neither NSMutableURLRequest+HTTPBodyTesting.h nor NSURLRequest+HTTPBodyTesting.h files\n- PR #166 added the NSMutableURLRequest+HTTPBodyTesting.h file\n- PR #180 renamed that NSMutableURLRequest+HTTPBodyTesting.h to NSURLRequest+HTTPBodyTesting.h\n- Then  released 5.1.0\nSo the intermediate NSMutableURLRequest+HTTPBodyTesting.h file shouldn't appear in the 5.1.0 release. If you look at the content of that folder in the repository locked at tag 5.1.0 you can see that in 5.1.0 the file is named NSURLRequest+HTTPBodyTesting.h, not NSMutableURLRequest+HTTPBodyTesting.h.\nSo I wonder where does Carthage gets that NSMutableURLRequest+HTTPBodyTesting.h from instead of using NSURLRequest+HTTPBodyTesting.h?\n. Oh, wait, it seems that I forgot to update the Sample projects. That file is in Examples/ObjC/ indeed. So the path spec problem isn't with the framework itself, it's with the sample project that I ship along in the repo to demonstrate usage. I wonder why Carthage would have to look into that and care about that?!\n. I'm closing this as the fix has been merged and 5.2.0 should resolve the problem. Feel free to re-open if the problem reappears.\n. :+1: thx for the feedback \n. Thanks a lot for this PR @Liquidsoul !\nSometimes the CI fails for no reason (well\u2026 for timeout reasons and for Xcode CLI tools weirdness randomly returning error code 65, see #188). I just asked Travis to restart the build, let's hope and see.\n[EDIT] Yay, that was it, tests now pass!\nAlso, could you please add an entry in the CHANGELOG crediting you and @mxcl for that change? Thanks!\n. Additionally @mxcl @Liquidsoul As an effort to adhere to the Moya contribution guidelines*, I've added you as collaborator to OHHTTPStubs to thank you for your contributions, and to also make it easier for you to contribute to the project in the future.\nYou'll now be able to create branches directly on the project (instead of having to have your fork) and have the ability to triage and label issues & PRs too. Use those new rights to your liking \u2014 or don't use them at all, it's up to you.\n* still haven't found the time to properly copy the Community.md files and adopt the guidelines fully properly, but that's the goal hopefully in a near future\n. @mxcl I honestly don't know. I mean, at work for client projects we're still on 2.3. Hell for some projects we're even still on 2.2. Because it would be really time-consuming to migrate your code to the new beta of each Swift 3 release every time a new beta is released, and because we didn't sell the time for that to the client and don't have time nor leisure to take the risk.\nOTOH, on personal projects where there's less strict deadlines and where we want to use Swift 3 as soon as each new beta is released to be always on top, we might prefer Swift 3 over 2.3.\nI think until Swift 3 / Xcode 8 is officially released we can keep 2.3 in the example project, and change that to 3 once Swift 3 is official (even if it should be quite soon now). Thoughts?\nPS: @Liquidsoul I'm not sure I understand your last comment, since when I look at the Changed Files tab, I see SWIFT_VERSION=2.3 lines in the xcodeproj\u2026 being removed, not restored?\n. Got it!\n. We should probably add something in the README.md (+ note/link in CHANGELOG.md) about how to change the Swift Version, like:\n\nUsing the right Swift Version of OHHTTPStubs for your project\nOHHTTPStubs support both Swift 2.2, 2.3 and Swift 3.0 \ud83c\udf89 \n- For CocoaPods users, if you use CocoaPods version 1.1.0.beta.1, then CocoaPods will compile OHHTTPStubs with the right Swift Version matching the one you use for your project automatically. For more info, see \n- For Carthage Users, the framework on master is built using Swift 2.3. If you want Carthage to build the framework with Swift 3, you can use the swift3 branch (whose only difference with master is that the project's Build Settings set SWIFT_VERSION=3.0 instead of 2.3)\n\nProblem is, if we do that, what about past September once Swift 3 is released, will we switch master to use SWIFT_VERSION=3.0 and remove branch swift3\u2026 and create a swift2.3 branch instead of legacy? Would probably be a pain for Carthage users to update all their URLs again in their Cartfile, right? While doing the opposite might work better for the long run?\nNote: I'm not a  Carthage user, so idk if there's a way to generate multiple pre-build framework for Carthage in GitHub Releases (one for 2.3 and one for 3.0) and let the users specify which pre-build version they want to download / depend on? Or will they be force to use --dont-use-binaries if they need Swift 3.0 so that Carthage rebuilds OHHTTPStubs from source instead of using the framework?\n. @Liquidsoul Swift 2.2 and Swift 2.3 are not ABI-compatible afaik. This means that even in your example use case, after upgrading from Xcode 7 (and using Swift 2.2) to Xcode 8 (+ SWIFT_VERSION=2.3 in their project), they'll still have to rebuild their Carthage dependencies anyway. So they'll need to do some carthage update or something and thus use a different version of OHHTTPStubs (2.3 instead of 2.2) anyway, right?\n. Fair enough. I'm convinced :wink:\nSo here's what I propose, does it match your idea of the ideal solution you suggested above?\n- First stage\n  - merge that PR into master which will use SWIFT_VERSION=2.3\n  - make a branch swift-3.0 with only diff with master will be SWIFT_VERSION=3.0\n  - If we ever do some new commits on master, we could even rebase swift-3.0 on top of master in order to always keep SWIFT_VERSION to be the only  difference between the two branches\n- Later, probably a couple of weeks after Xcode 8 GM is released or so\n  - merge branch swift-3.0 into master, making SWIFT_VERSION=3.0 the default\n  - Optionally, create branch swift-2.3 with only diff with master being SWIFT_VERSION=2.3, in order to still keep retro-compatibility  around for some time (and rebase regularly as needed)\n- In the long run, we will probably drop the swift-2.3 branch when everybody will be using Swift 3\nDoes that feel right to you? (And if so, do you feel like documenting this on a user's perspective in the README.md?)\n. Both are fine by me. Seems more logical to me to have everything related in the same PR but it's up to you.\n. \ud83c\udf89 time to merge this \ud83d\udc4d \n. 5.2.0 is live now! \ud83c\udf89\nTag 5.2.0 created; branch swift-3.0 + tag 5.2.0-swift3 created too.\nThanks again for the good work folks, nicely done! \ud83d\udc4d \ud83d\udc4c\n. Thx for your issue.\nYou can simply use carthage update --no-use-binaries to tell Carthage not to download the ZIP containing the pre-build binaries but build from source instead.\nThat's a Carthage-related issue more than an OHHTTPStubs issue btw, as Carthage recommend to create those zip frameworks for those interested, and you can opt-out of it if needed with --no-use-binaries anyway (see Carthage's README), while not having those zip files don't offer the alternative for those interested by it.\n. @ianks Thanks a lot for this PR. That's a very good idea to add this information.\nHowever, the added information is not totally true (that proves that adding that information is indeed needed \ud83d\ude09 ), because the OHHTTPStubs/Swift subspec only depends on OHHTTPStubs/Core (its done on purpose so that you can opt-in only for what you need), and thus does not automatically brings everything in the default OHHTTPStubs/Default subspec.\nSo in practice, if you only put pod 'OHHTTPStubs/Swift in your Podfile, you'll only have the Core + Swift features, but you won't have support for NSURLSession, JSON and OHPathHelper that is provided by the default subspec. That's intended, so that people only wanting to opt-in for some subspecs but not all can configure to their liking.\nSo I think the best suggestion to give in the README to cover most of what people uses is to list both the default and the Swift subspecs, that way you'll have everything you get by default (including NSURLSession & JSON support)\u2026 AND Swift support:\npod 'OHHTTPStubs'\npod 'OHHTTPStubs/Swift'\n. I've rearranged some stuff in the README, about Swift 2.2/2.3/3.0 and about subspecs.\nI've directly integrated your recommendations in that rework, explaining about the Swift subspec too. Feel free to review the last changes in the README on master to confirm it looks ok and more clear to you!\nI'm thus closing this PR now. Thanks a lot for that suggestion!\n. Thanks for reporting, will try to take a look when I have some more spare time :)\n\\cc @mxcl @Liquidsoul \n. @JackieQi wait, I was curious about which tests were failing so I still took the test of at least opening the project in Xcode 8b6 on the swift-3 branch and hit Cmd-U\u2026 and all the iOS Fmk tests are passing locally.\nWhat version of Xcode 8 are you using? Which tests are failing on your end?\n\n. For unit tests related to timing my time tolerance is a bit too short depending on the machine on which you run the tests.\nMaybe try running only the tests which failed one by one or increasing the time tolerance in the tests code to see if it solves it.\n. Thanks for the feedback. I'm closing this now; but if you feel like making a PR to increase the tolerance it might be helpful for others!\n. Yes sadly it's a drawback from how NSURLProtocol is used in the Cocoa URL Loading system, calling the protocol's canInitWithRequest: of the protocol twice sometimes (depending on iOS version) for some reasons.\nI have no control over it because that's a method called by the OS itself twice that triggers this double call so no real way to avoid this properly.\nThat's also a reason why I did a refactor the API some major versions ago \u2014 before the current API, the old one only took one block/closure and stubbed the request only if you returned non-nil response, but the fact that the methods was called many times by the OS made your potentially expensive code in that closure (maybe reading the content to sub from a file for example) run multiple times :-/ . That's another reason why those two closures (the one for testing and the one for building the response) are now separate.\nI've filed a bug report to Apple years ago about that behavior but no response so far.\n. See also the release notes from version 2.0.0 where I made that API change 3 years ago mainly because of that issue.\nhttps://github.com/AliSoftware/OHHTTPStubs/releases/tag/2.0.0\n. Thx! Will merge as soon as Travis finish building :)\n. I haven't tested OHHTTPStubs in a long time in Xcode 6.\nAre you using Swift in your project?\nHow are you integrating OHHTTPStubs in your project? CocoaPods? Carthage? Manually?\nI think Xcode 6 is containing a version of the compiler too old to know the Swift target compilation directives. If you're not using Swift, just don't integrate the Swift extension in your Podfile. If you need to use Swift, you'll need to use a version before those #if were added to the codebase to support Swift 3, because Xcode 6 is too old to know about those.\n. No, Carthage doesn't allow conditionally include only some parts of the library, that's a limitation of Carthage itself, so you can't opt-out of the Swift extension with Carthage.\nYou'll either have to use CocoaPods (with the CocoaPods-Rome plugin if you want CocoaPods to work the same as Carthage and only generate the .framework and let you integrate all manually) or if you still want to use Carthage, you'll have to use an older version of OHHTTPStubs.\nGiven the CHANGELOG, I think the latest version compatible with Xcode 6 is version 5.1.0, as the Swift 3 support with #if conditions for Swift 3.0 was added with 5.2.0.\n. Yes, just use the dedicated method [OHHTTPStubs setEnabled:YES forSessionConfiguration:config]; to activate the stubs on your custom configuration (and before creating the NSURLSession with it)\n. Or even better, don't set the protocolClasses property to a new value replacing the old one, but instead add your [CustomURLProocol] to the existing value.\n. :+1: thanks for the taking care of this fix \ud83d\udc4c\n. 5.2.1 is out, with this fix included \ud83c\udf89 \n- I cherry-picked this fix from swift3 in master, so that people using CocoaPods can still point to pod 'OHHTTPStubs, '~> 5.2' and get that change too if they're using Xcode 8 GM\n- I rebased the swift3 branch on top of master so that the only commit making swift3 differ from master is still SWIFT_VERSION=3.0 only, as this branch's only purpose is for Carthage users only\nFor Swift 2.2 / 2.3 users, this 5.2.1 doesn't have much change compared to 5.2.0 (except README & docs typos) but I prefer keeping all my versions in sync to avoid confusions.\n. Closing this as it's been addressed a while ago by #203 :wink:. Cool! Could you please also add an entry in the CHANGELOG for this?\n. Travis-CI builds are currently failing due to a bug in the latest version of xcpretty: https://github.com/supermarin/xcpretty/issues/241 so it's unrelated to OHHTTPStubs and the changes in that PR indeed.\n. I guess once xcpretty gets fixed (which the author promised to do by end of week)\n. Merged via 88cf9b2133ec086de5c51e736a2470aa4763bcfa\nThx and sorry for the delay!\n. Seems like an interesting idea! Would probably not have much time implementing that soon though, but would love a PR for that!\n. I'm not sure I understand what you want me to do with that?\n\nShould that be a new feature of OHHTTPStubs?\nShould it be an additional example project linked in the wiki page?\nShould it be a link we add in the wiki to your gist, using it as a blog-posty documentation?\nShould it be converted into a dedicated wiki page on my repo explaining how to read HAR files?\nOr does it needs us to add a new subspec in OHHTTPStubs to allow people to parse HAR files easily?\n\nI'm quite confused with what you expect me to do with your links there tbh ;). So\u2026 basically adding a dedicated page in OHHTTPStubs' wiki like \"Using HAR files with CharlesProxy to configure all stubs easier\", to explain how using Charles and a HAR file and you class could help people? And then link to that wiki page in the README?. \ud83d\udc4c Could you also add an entry in the CHANGELOG to credit yourself for this migration? Thx!\n. Travis-CI builds are currently failing due to a bug in the latest version of xcpretty: https://github.com/supermarin/xcpretty/issues/241 \u2014 Waiting for the fix.\n. Merged manually via ca8e9c295b859215b1ab8a9df8e0546a24e768e5\nThanks again!\n. I confirm what @Liquidsoul said.\nThat setup is totally intentional, so that people can opt-in only to what they need.\nIf we were doing the opposite (which is what you suggest), there wouldn't be a way to get the Swift wrapper subspec without the NSURLSession nor a way to opt-out other subspecs, which would lead to problems for other people.\nAll the details, subspecs list and dependencies and rationale for how this is split in the various subspecs are explained in the README under the collapsible sections.\nIf people don't read the documentation, they should not expect to file a bug and get a fix, especially if the solution and its rationale has already been explained in multiple places.\n. CocoaPods 1.1.0 is coming very soon. Just a couple of PRs to finish to be sure not handle every possible tricky Xcode8/Swift3 complex configurations out there.\nCP 1.1.0.rc.2 is super stable enough though, no reason to not use it. CP is not in beta anymore, and we use the RC at work without any problem.\nGonna close this issue now as it's silver by latest CP, and is not an OHHTTPStubs issue itself anyway.\n. +:100:\n. I think a mix of checkboxes (for a checklist of what people have to ensure before creating an issue) and a markdown template (with various sections to fill by the user) could be perfect\n. Implemented in #241 . Thanks for the PR!\nFYI, travis builds are failing due to a bug in the latest version of xcpretty: https://github.com/supermarin/xcpretty/issues/241\n. Hi\nI'm not sure what's your point with that issue?\nAre you suggesting to add that example to the other usage examples already in the dedicated wiki page to have a more concrete example?\n. Thx for the feedback!\nYou should be able to contribute to the wiki already (contributions, modifications and creating new pages in the wiki are open, no need for special rights or pull requests), so don't hesitate to enrich the existing Usage Examples page\u2026 or maybe even create a dedicated new wiki page for sharing such more complete code snippets like this!\n. I've shared all your suggestions in this wiki page now, thanks for the suggestions \ud83d\udc4d . Yeah, that's probably because of the #if.\nWhat's strange is that this #if is also used by the UnitTests test suite to only run the test on this property if the corresponding subspec has been included (otherwise when we run pod lib lint or try to publish the pod, which rightfully tests all the possible configurations of subspecs \u2014 including ones that don't include the NSURLSession subspec and this OHHTTPStubs_HTTPBody category \u2014 it fails at accessing this property when it doesn't exist.\nSo it is necessary to only declare that ohhttpStubs_httpBody extension in Swift only if the OHHTTPStubs_HTTPBody implementation exists (if the subspec has been imported), otherwise some configurations won't compile if they don't include the subspec.\nBut I'm not sure the trick I added with that #if does the job, especially since the macro is defined in ObjC but the #if is written in Swift and they don't share their macros.\n\nI'm open to any suggestion as to how to fix this while still making it work for every configuration.\nWe could consider separating your extension in a dedicated Swift file and only include it in the NSURLSession subspec\u2026 but then for people still using ObjC and not using Swift they'll then start to have a Swift file and have to load the whole Swift runtime just for a thing they'll never use\u2026\nI don't think there's a way to include a file conditionally only if both NSURLSession and Swift subspecs have been activated and not include it otherwise\u2026\nI might consider re-organizing the subspecs at some point (who doesn't need NSURLSession support nowadays that NSURLConnection is long deprecated?) which could be a solution, but that would potentially break subspecs for some of people, so it's not an easy decision\u2026\n. Yeah, and I know people would not understand all the complexity behind it (\"why do I have to add the SwiftNSURLSession subspec when I already had pod 'OHHTTPStubs/Swift' before and it worked but now it's broken?\") and this would require a lot of support time to answer those questions :wink:\nTh two options I find acceptable so far:\n- Revert your PR and remove that extension. After all, a cast is enough to reproduce the same behaviour (sure that's not as nice, but heh)\n- Make NSURLSession part of the Swift subspec, so that we're now sure it's always included.\nGiven that some other people complain that adding pod 'OHHTTPStubs/Swift' to your Podfile is not enough and you have to include pod 'OHHTTPStubs' to it too otherwise you don't have NSURLSession nor JSON support\u2026 maybe it's time I revise my organisation of the subspecs after all. But I just need to make sure it's possible for everyone to opt-out of NSURLSession and JSON for people not wanting it, and be sure I don't disrupt existing projects which have declared certain subspecs in their Podfile and will end up with a project not working if that new subspecs organisation remove stuff from what they previously had in their Pods\u2026\n. Yeah, that's probably the best choice for now indeed.\n. Reverted in 128f1b35ff3abae8ce56fdce2ece000e2ab1b109 until better solution :wink:\n. Closed by #220 \u2014 Sorry t took so long!\n. Why is that? The only difference I see in your correction is that:\n- You removed the return statement\n- You used the base name of the file (wsresponse.json) instead of its path (that my example constructs using the helper function OHPathForFile which basically simply does a NSBundle.pathForResource(\u2026) call to get the path of the file in the current bundle)\nGiving only the path isn't supposed to work (as in practice in 80% of cases you'll indeed place your JSON fixtures directly in your bundle, but nothing prevent you to place them elsewhere, like in a subdirectory, and you'll have to specify a matching different path in such cases instead) so I don't understand your fix.\n. Oh, well spotted \ud83d\udc4c  Fixed, thanks!\n. https://www.googleapis.com\" is not a host. That a full URL. The host of this URL (as returned by NSURL(string: \"https://www.googleapis.com\")!.host for example) is just www.googleapis.com.\n. Might be a duplicate of #217 right?\n(Which I still haven't had time to merge since I want to test if this modification doesn't break the CocoaPods installation)\n. \ud83d\udc4d \n. Yes it's a known issue without an easy solution that would work for every subspec configuration so not sure we're gonna fix that, given how complex it could be to make it work for people using the subspec\u2026 while still not make the compilation failed for people not using it.\nIn the meantime the fix is easy: just cast your request as NSURLRequest. Not as pretty but easy enough and did the job until we find a configuration working for everybody without breaking compilation for others.\n. @isimpson Release 6.0.0 (#242) will finally fix this by finally making the Swift subspec always include NSURLSession so we were able to add the hasBody() matcher to the Swift API too!. Even if they are very rare, I think there might exist URL paths not starting with /, like foo:bar (which is a valid URI iinm?), so not sure we should enforce this for everybody?\n. Thanks for the PR! Very good point and good explanation \ud83d\udc4d\n\nI'm wondering if, when I did write that code (potentially half asleep \ud83d\ude02) maybe my intent was to wait for the delay to call the redirect callback\u2026 then wait for the delay again after that callback fire the real response (as a 3xx redirect + the call to the redirected URL could be seen as two requests interest of one = wouldn't we be supposed to fake twice the request time?).\nSo maybe my intent was to send those one after the other and not in parallel (Obviously if I wanted to implement exactly that I should have nested the executeOnClientRunLoopAfterDelay\u2026 closures instead of calling them at the same level, might have been a sleepy day \ud83d\ude02)\nWhat do you think would be the best behavior users would expect?\n1. Wait for the delay, then call the redirect callback and the finished callback immediately after (your solution)\n2. Wait for the delay, call the redirect callback, wait for the delay again \u2014 because that's like a new request being sent \u2014 then call the finished callback (probably what I intended to implement in the first place)\n3. Wait for half the delay, call the redirect callback, wait for second half of the delay, call the finished callback \u2014 making the overall delay as long as what's passed/asked as initial parameter\n\nI personally think I prefer solution 2 but that would break the timing compared to current version, so people who already wrote code with some delays for their stubs with redirection will see that overall delay doubled. While your solution fix just the race condition while not changing the overall delay but it seems strange to me timing-wise to have the finish closure called immediately after the redirect, like the redirection took no time\u2026 so solution 3 seems like a good mitigation?\n. Indeed, makes sense; your implementation seems to be the one making more sense in that context then \ud83d\udc4d \n\nAbout the build failure, yes it's an issue I've introduced in a quite recent commit on master while trying to disable timing tests on CI, because timing tests depend highly on the speed and CPU of the machine running them \u2014 so they are non-deterministic \u2014 and typically VMs on Travis share a common CPU \u2014 meaning that timers to will be late. All of which made those timing tests (and Travis  builds) fail randomly depending on VM speed and execution conditions.\nBut since I disabled those tests I got this new error about module not found and can't understand the relationship between the changes I've done and this error\u2026 and haven't had time to investigate further yet.\n. I'm not sur I see a better way to test that, so I'm ok with NSDatefor this scenario.\nBTW, don't forget to add an entry in th CHANGELOG.md to mention both fixes (race condition + timing for zero-length responses) and credit yourself!\n. @morrowa yeah, just add a commit with the changes in the CHANGELOG, that way it'll be included automatically when we merge the PR \ud83d\ude03 \n. Now I'll probably have to take some time to understand what I did that makes the build fall on travis due to this \"cannot import module\" error, try and fix that on master so you can rebase on top on it, and hopefully this PR's build will pass at last and be mergeable at last!\n(I hope do have some time on Friday or the week-end to do that)\n. Travis failure fixed on master \ud83c\udf89 \n. The stubbing of an MP4 file is no different from the stubbing of any other request by any other type of file.\n- What did you try? (please give code samples as well as the remote full URL to be stubbed so we can check that your matcher is correct)\n- How did you install OHHTTPStubs into your project?\n- Are you using Objective-C or Swift?\n- What error do you have, if any?\n- Do you manage to stub any other request done by your application but have issue only with this one, or do you fail to stub any request?\n- Did you read the Wiki examples and troubleshooting pages?\n- \u2026\nWithout any code nor more information, it won't be possible to help.\n. If you put a breakpoint in the first block (return [request.URL.pathExtension isEqualToString:@\"mp4\"];) do the code goes in that block?\nI wonder if something has changed in iOS10 related to UIWebView not using NSURLConnection anymore (and if that's the case and it uses a custom NSURLSession since iOS10, then we're screwed except if iOS10 also allows us to provide custom protocols to UIWebView\u2026)\n. Ok, then I'm starting to wonder if something didn't change in the last versions of iOS, like maybe since iOS10 the UIWebView now use an internal NSURLSession to do their requests (instead of NSURLConnection that they used so far).\nWhich would mean that we would need a way to inject our custom NSURLProtocol (used by OHHTTPStubs to intercept the requests and stub them) in the UIWebView's NSURLSessionConfiguration before the UIWebView's internal NSURLSession is created with that configuration.\nNot sure that UIWebView exposes a way do provide a custom NSURLSessionConfiguration for it (and thus inject OHHTTPStubs's custom protocol into it) since they did that change (if that's indeed the reason it doesn't work anymore)\u2026\nCould you try on an iOS9 simulator and see if it works? If so, that would confirm that it's indeed due to a change in iOS10. (See also #227 which might suggest the same conclusion\u2026). I'd also be interested if you'd be able to test it, both in iOS9 and iOS10, with anything other than an mp4, like an image or an HTML webpage\u2026 as your StackOverflow link suggests that this is only related to video and multimedia content.\nSo maybe nothing changed between iOS9 and iOS10 like I though in my previous comment and the stubbing still works even in iOS10\u2026 but just not for multimedia content because of that iOS bug.\nIn any case (iOS10 changing UIWebView's implementation, or bug with multimedia content not going thru the NSURLProtocol chain), even if it would be an Apple bug in both cases, it would be worth updating the README section \"Known limitations\" with that info.. If you see a \"can't find module OHHTTPStubs\" error in Travis I'm afraid that's probably my fault, a recent commit on master to try and disable timing tests on the CI (because they are not deterministic and depend too much on the machine executing them) seen to have broken something. Haven't had time to investigate further yet \u2639\ufe0f\n. :+1:\n. The build has been fixed on master \ud83c\udf89  You'll now be able to rebase on top of master.\nHowever, I'm still surprised that the cast to NSString is necessary.\nIn the sample project we don't use it\n- Swift 2.3 version of the Sample project on master\n- Swift 3.0 version of the Sample project on the swift3 branch\nSo I think the only change necessary in the documentation should be the self.dynamicType -> type(of:self). Could you update your PR accordingly?\nThx\n. I plan to wait a bit more before merging Swift-3 branch in master.\nmaster is supposed to be compatible with 2.2, 2.3 and 3.0 (only emitting warnings for extraneous _ parameters in Swift 2.x), at least that's the intent until Swift 3 is merged to master when Swift 3 adoption is wider.\nSo the only difference in the pod between master and swift-3.0 branches are supposed to be the SWIFT_VERSION build setting (and the demo project being updated to Swift 3)\nIf that's not the case and there are more differences in the pod between those two branches, making master not Swift-3 compatible, then imho we should add an #if Swift(>=3.0) to make it so, as CocoaPods users are supposed to be able to use master even in Swift 3.\n. WKWebView uses a separate process (to use the accelerated Javascript engine of iOS in a secure and sandboxed environment) so we have little to no control over it.\nFor example, it's not possible (Apple doesn't open anything in the API) to hook a custom NSURLProtocol in WKWebView from your application to stub requests, due to how WKWebView works and how it's isolated in its own closed process. This means that there's technically no way to implement OHHTTPStubs hooking in WKWebView (except if in the future Apple opens the API in WKWebView to configure custom NSURLProtocols for it, but I highly doubt it)\nAs for UIWebView, they normally use NSURLConnection under the hood so OHHTTPStubs stubs should work out of the box.\n. Ah, interesting, thanks for the feedback \ud83d\udc4d \nWKWebView\nWill take a look at your pod, but as it seems to use a private API, so I won't probably integrate that in my own pod.\nBut we could totally point to your pod WKWebViewWithURLProtocol in the README \u2014 like in \"Known Limitations\" we could say that for WKWebView people could use your pod but would have to tweak it around to hope bypassing the validation on submission with selector hiding (and praying \ud83d\ude04)\nUIWebView\nDid you manage to make it work for UIWebView? I remember having making it work myself a while ago, but didn't re-test it recently, so maybe something changed in latest versions of iOS?\nI also discovered thanks to https://github.com/AliSoftware/OHHTTPStubs/issues/225#issuecomment-262476210 that there's a known Apple bug where requests from UIWebView to multimedia content (mp4, svg, \u2026) don't go through the usual URL Loading System (so they bypass any registered custom NSURLProtocol), so if when testing with your code for this current issue you were in fact trying to stub multimedia content, that might be the reason. Could you give some details about what you tried to load/stub when trying with UIWebView?\nThx. @Ashton-W Sadly, Some people want Carthage support. Which allows neither options. . tbh, I'm not a Carthage user and don't know much about the possibilities we would have here. That seems like a good idea. I'm starting more and more to consider including URLSession and JSON subspecs as part of the Swift subspec by default. If we do that, we could merge your idea in :wink:\n. Main con of merging is inability to opt out.\nWill try to make time for it this week. @Antondomashnev version 6.0.0 (#242) will finally (!) solve this and make hasBody part of the Swift API! \ud83c\udf89 . I have to admit I never tested that. Will have to investigate to know if it's an existing bug of OHHTTPStubs itself, of Alamofire, or if it's even possible at all to intercept that when using a custom NSURLProtocol (like this pod does to intercept requests)\u2026\n. Hey @CalvHobbes \nThanks for your feedback.\nIf you managed to make it work, I'd be very interested to see your solution.\nYou speak about using a custom NSURLProtocol and setting it in the protocolClasses property, but basically that's also what OHHTTPStubs does internally, so I'm intrigued.\nMaybe your workaround could be integrated as a fix in OHHTTPStubs itself (feel free to do a PR) so others can profit?. Cool that's reassuring then \ud83d\udc4d thanks!. \ud83e\udd14 Interesting, thanks for the report.\nNo guarantee I'll have much time to look at it soon, but will keep an eye on it and try to check it some time \ud83d\udc4d . Hey @nevil did you manage to investigate this issue further and understand what was causing it?. Hey @nevil !\nAny chance you'll have time to reopen the investigation anytime soon, or maybe at least re-test with a more recent iOS/SDK/Xcode to see if we can close this?. Thanks a lot @morrowa for all the investigative work, that's very interesting!. That's an issue on CocoaPods & Xcode, not on OHHTTPStubs itself.\nBasically, what CocoaPods does when you run pod install is that it uses the value of SWIFT_VERSION you have set on your own app project and set the same SWIFT_VERSION value for the Pods.xcodeproj targets.\nSo be sure to have set the right SWIFT_VERSION on your host project before running pod install (that's true for any Swift pod, not just OHHTTPStubs)\nIf the problem persists and you still have at least one target in the Pods.xcodeproj that doesn't have its SWIFT_VERSION build setting set, hence generating that Xcode prompt you're talking about:\n\nEnsure that you use the latest CocoaPods version\nTry to comment the line of the pod in your Podfile, run pod install (so it uninstalls the pod from your project), uncomment the pod line in your Podfile and run pod install again. This will force CocoaPods to regenerate the target for this pod in its Pods.xcodeproj. That's because if the SWIFT_VERSION wasn't set at the time of the first pod install or have changed since then, sometimes CocoaPods doesn't realize that the Pod target should change and leaves the pod target untouched.\n\nIf you still have an issue after all that, please file a bug on the CocoaPods repository, as it's an issue more related to CocoaPods not properly configuring the Pods project rather than specific to OHHTTPStubs itself.. It's aThis is confirmed with a lot of feedback from Twitter, Slack and the Dev forums, it's actually a regression also coming from Xcode 8.2, because Xcode 8.2 set back the SWIFT_VERSION to 3.0 but the \"Use Legacy Swift Version\" corresponding human readable settings in the Xcode GUI shows No for both values.\nThe solution is to force-change the \"Use Legacy Swift Version\" on your app project, for example by changing it to YES then back to NO again, to force Xcode to re-set it.\nSee also:\n\nhttps://twitter.com/arekholko/status/809120209491623936\nConfirmed here by an Apple engineer working on Xcode\n\nClosing this bug, as it has nothing to do with OHHTTPStubs.. Might be a good idea, but not sure that .swift-version would change anything. This file is used by CocoaPods to know which Swift version to lint & push your pod against, but doesn't affect the pod installation process.\nSee our Blog Post here:\n\nIn CocoaPods 1.1.0, setting the version of Swift when linting and pushing your pod is supported in following ways:\n[\u2026]\n* It uses the setting from your .swift-version file if present (inspired by swiftenv).\n\nThe pod install command always use the same SWIFT_VERSION that is set on your application target at the time it generates the Pods target; it doesn't use .swift-version at that time.\n.swift-version is only used during pod lib lint / pod spec lint and pod trunk push / pod repo push, but nowhere else (for reasons we explained in the same blog post). Thanks for the issue.\nIt has been tested\u2026 but separately, as you usually don't both stub and record what you stub, but rather record first and stub later.\nBut you're right in that it should be mentioned in the README that you should not use both at the same time but rather one after the other, so the README should be more clear about that.. I see.\nI think you should still be able to register OHHTTPStubs manually (I don't remember of SWHttpTrafficRecorder offers an API to register the NSURLProtocol manually but OHHTTPStubs has setEnabled: and setEnabled: forSession: methods that should allow you to add OHHTTPStubs' internal NSURLProtocol manually even after SWHttpTrafficRecorder did set itself up and added is own, making them both intercept the requests (I indeed haven't tested this use case of supporting them both at the same time but it's worth a try as it should theoretically work if you do it this way). No you can register as many as you want. Let me find a Mac in a minute so I can give you an example. Ok, so, basically my proposed solution is for you to call OHHTTPStubs.sharedInstance.setEnabled(true, forSessionConfiguration: sessionConfig) (assuming you use a custom NSURLSession build from an NSURLSessionConfiguration, and not NSURLConnection nor the shared NSURLSession) before creating your NSURLSession with it.\nYou can find this method's implementation here. As you can see, this method doesn't replace the supported NSURLProtocols of an NSURLSession, but instead just inserts OHHTTPStubs's own NSURLProtocol at the top of the sessionConfig.protocolClasses array.\nThis insertion is automatically done on the two NSURLSessionConfiguration's defaultSessionConfiguration and ephemeralSessionConfiguration presets (thanks to some swizzling).\nIf you use SWHttpTrafficRecorder, it also inserts its own NSURLProtocol in this array (see here). But for this to work you'll have to:\n\nEnsure you create your custom NSURLSessionConfiguration and set it up both for OHHTTPStubs AND for SWHttpTrafficRecorder before you create your NSURLSession(configuration: \u2026) initializer, because when you create your NSURLSession from a configuration, the configuration is copied, so any further changes on the NSURLSessionConfiguration you used after creating the NSURLSession won't affect that NSURLSession retroactively (this is explained in Apple's doc on NSURLSession)\nEnsure that both OHHTTPStubs an SWHttpTrafficRecorder did set up their NSURLProtocol in the right order and on the same NSURLSessionConfiguration\n\nSo, now that I've had time to re-read the implementation of both pods, I don't see why this wouldn't work:\n\nEnsure that you have the pod 'OHHTTPStubs' pod in your Podfile. If you only have pod 'OHHTTPStubs/Swift' for example, this subspec doesn't contain the NSURLSession-supporting subspec by default (this might change in the future, but for now the Swift subspec only contains the Swift helpers, not the other subspecs. See the dedicated section in the README about this\nUse this kind of code (I wrote it in Swift but should work the same in ObjC):\n\n```swift\nimport Foundation\n// Start with the default configuration\nlet config = URLSessionConfiguration.default\n// If you indeed have the OHHTTPStubs/NSURLSession subspec listed in your Podfile.lock\n// then OHHTTPStubs should have automatically  injected its own NSURLProtocol at this point\n// You can check this using some NSLog:\nNSLog(\"protocol classes after OHHTTPStubs: (config.protocolClasses)\") // this should contain OHHTTPStubsProtocol among others\ndo {\n  // not sure about the translation of SWHttpTrafficRecorder API in Swift here, I'll let you adapt\n  let started = try SWHttpTrafficRecorder.sharedRecorder().startRecording(path:nil, forSessionConfiguration:config)\n  // At this point, SWHttpTrafficRecord should itself have added its own NSURLProtocol to the\n  // protocolClasses array, intercepting the traffic first, BEFORE anybody else (including OHHTTPStubs)\n  NSLog(\"Started: (started)\")\n  NSLog(\"protocolClasses after SWHTR: (config.protocolClasses)\")\n} catch {\n  NSLog(\"Error while trying to start SWHttpTrafficRecorder\")\n}\n// At this point, SWHttpTrafficRecorder is listed first in the protocolClasses array\n// then OHHTTPStubs is next in line. This means that SWHTR will intercept requests first, then\n// OHHTTPStubs will be given the ability to stub them next, then if the request passed thru both\n// the request will finally hit the real world.\n// If you want to make OHHTTPStubs intercept the requests BEFORE SWHttpTrafficRecorder\n// Then you have to ask OHHTTPStubs to remove itself then re-insert itself at index 0\nOHHTTPStubs.setEnabled(false, forSessionConfiguration: config) // remove first\nOHHTTPStubs.setEnabled(true, forSessionConfiguration: config) // then reinsert, at index 0\n// And ONLY then, create your NSURLSession, because if you create it before\n// setting up the NSURLSessionConfiguration, changes in the configuration won't do anything\nlet session = URLSession(configuration: config)\nlet task = session.dataTask(with: yourURLHere)\ntask.resume()\n```. The difference is that one applies to global sessions/connections, the other to sessions built with a given session configuration.\n\n[NSURLProtocol registerClass:\u2026] only applies to requests sent via NSURLConnection or [NSURLSession sharedSession], and does not apply to requests sent via an NSURLSession built from an NSURLSessionConfiguration\n[NSURLSessionConfiguration setProtocolClasses:] is used by requests sent via an NSURLSession that has been created from that given NSURLSessionConfiguration, and doesn't affect the NSURLSession instances created by other NSURLSessionConfigurations nor requests sent via NSURLSession\n\nFor more info, see:\n\nhere in the README\nhere in OHHTTPStubs's API documentation of those two methods, which explain the difference as well.\n\nFor in-depth understanding, you can also find detailed information in Apple's API documentation on NSURLSession / NSURLSessionConfiguration and the URL Loading System Programming Guide. Yup that's it.\nAgain, it's explained explicitly here (\"Automatic Loading\" paragraph) in the README as pointed out before.. Ah right. Maybe we should put that NSHipster's link next to the \"swizzling\" mention in the README then.. Note that I think in a near future we will indeed make Swift3 the default (and keep Swift2.3 releases for people having legacy projects), as Swift3 is indeed now the default for most people and 2.3 is dropped with Xcode 8.3 anyway.\nI just won't do a release just for that, but will wait until there's something to release to do that for the next version.. That's a problem due to Carthage (and the fact that Carthage insists on using pre-built binaries if available, despite the Swift ABI still not being stable and changing on each Xcode release)\nThe official solution for that is to use the --no-use-binaries flag of Carthage.\nI can't rebuilt that binary (as you did) for everybody, because then people using Xcode beta with have a compatible binary but people not using the beta will then be the one having the problem. There's no solution supported by Carthage to support both people using swift 3.0 and 3.1 or multiple Xcode versions\u2026 apart from not using the pre built binary and rebuilding yourself each time (there's a bunch of issues about that opened on the Carthage repo btw)\nIn the future I may stop releasing pre built binaries for Carthage, enforcing people to rebuild on their end, as this Carthage limitation has bitten too many people at every new Swift or Xcode version already.\n. Hi \nOHHTTPStubs doesn't contain any URL templating logic. Only simple matchers like isScheme(\u2026), isHost(\u2026), isPath(\u2026) and similar are provided.\nInstead you can provide your own matcher quite easily, for example use:\nstub(condition: { req in \n  guard let path = req.url?.path else { return false }\n  return path.hasPrefix(\"/hello/\") && path.hasSuffix(\"/anotherMethod\")\n}, response: \u2026)\nFor advanced matching stuff like using a wildcard * or similar, you could use https://github.com/Kyle/URITemplate.swift for example.\nSee also #125.. I'll close this issue as a duplicate of #125, please continue any discussion there.. Could you try the same request without Alamofire to check if it's related to Alamofire or not? \nCould you put breakpoints in the Alamofire code when the URLSession is created and one when OHHTTPStubs does list and do the swizzling to check the order when they are called? \nOr just right before performing what you think is your first Alamofire request, check at that point the Alamofire's own URLSession's .configuration.protocolClasses If it contains the OHHTTPStubs protocol\nAlso could you check if OHHTTPStubs is just not installed or if it's installed but your condition to stub your requests is wrong? For example maybe you used a condition of isHost(\"http://example.com/\") (which is not a host string anyway) instead of isHost(\"example.com\").\nYou could for example replace your condition with a block always returning true, so it would stub all requests\u2026 and check with a breakpoint if the stub is called in that case. If that's the case that means the condition you use is incorrect.. Cool that you found the source, thanks for taking the time to reply and close! \ud83d\udc4d. Could you maybe submit a Pull Request? I'm a bit behind with all my open-source projects so any help is appreciated and would help make the migration happen faster :wink:. BTW, I'm not sure we'd have to change much between what's already in the swift-3.0 branch and what's needed to make that Swift 3.0 branch compile in Swift 3.1?\n(I plan to make that swift-3.0 branch the default (replacing master) one day, just still haven't had the time yet). I think by now it would be better to have the following branch setup:\n\nMake master always use the latest Swift version, even if it's early in adoption (so in our case today, Swift 3.1)\nMake dedicated branches for older versions, so swift-2.3 and swift-3.0\n\nBecause if today we make master use 3.0 and make a swift-2.3 and swift-3.1 branch we'll later again fall back in the similar issue we have today once 3.1 will be widely adopted.\nThoughts?. > \u2753One thing I am wondering is if the Travis CI configuration should not be updated in this PR to test both Xcode 8.3 and Xcode 8.2?\nYeah probably :+1:\n(Just to be clear, we won't need a build matrix to always build master on all Xcode's, just each branch \u2014 master, swift-2.3 and swift-3.0 will each have their travis.yml configured with the matching osx_image for the branch). I don't think there is any code change needed at all. \nThe only requested changes is for Carthage users, again\u2026 who will require us to do a branch on which the only difference compared to 3.0 would be the value of SWIFT_VERSION. Side note: we need to migrate OHHTTPStubs to Circle-CI some day\u2026 travis is still taking forever :'(. @Liquidsoul Now that this is merged:\n\nmaster is in Swift 3.1\nI've moved the swift-3.0 branch to be equal to master, so that people referencing that branch (especially people using Carthage) can still use it. We'll remove it as soon as we publish a new release/tag\nI've created a swift-2.3 branch (that is equal to where master was before the merge of that PR)\n\nNext steps is to:\n\nAdd a commit to that new swift-2.3 branch to add the shields.io badge in the README\nCreate a new release x.y.z (version to determine)\nTag the branch master with x.y.z but also the branch swift-2.3 with x.y.z-swift2.3\nRemove the swift-3.0 branch\nProfit!.  \ud83d\udc4c. Yep exactly that's what I plan indeed. Do you think we should do otherwise? Suggestions welcome. \n\nAlso wondering if I should bump the next release to 6.0.0 because the switch from 2.3 to 3.0 is source-breaking (I think, will have to compare our APIs for the two versions to check if the call site has to be changed or not \ud83e\udd14)\u2026. Perfect ! Ready to merge once Travis wakes up.. @Liquidsoul \ud83d\udc4c \nI've added one last commit to add more information for Carthage users. I think that:\n\ngiven most people have migrated to Swift 3.0 already\nand that people still using Swift 2.3 won't be in a hurry migrating to OHHTTPStubs 6.0.0 if they haven't migrated to Swift 3.0 yet and those people will still use 5.2.3\nit's time-consuming to maintain a specific \"swift-2.3\" branch just for those users (which are likely not many, as projects in Swift 2.3 and using Carthage and not migrated to Swift 3.0 yet is rare by now)\n\nThen I've decided to stop doing swift-2.3 specific branches just for so few people. Those people have alternatives anyway, and I don't want to lose time maintaining that old branch any longer for an obsoleted Swift version which is already not supported anymore in latest Xcode.\nMost of Carthage users likely have already migrated to Swift 3.0 anyway so they'll be OK, and those who haven't are likely to stick with old versions of their dependencies anyway, including OHHTTPStubs 5.2.3, so it's probably not worth losing our maintainers time for this. I'll try to take a look at that in a few weeks after all my conference talks are done \ud83d\ude09 But just wondering how that would work with the auto-installation feature of OHHTTPStubs (the swizzling of NSURLSessionConfiguration methods to auto-inject the OHHTTPStubs sharedInstance into them so that people have nothing to do \u2014 behaviour which we want to keep), does that mean that we need a way to remove the sharedInstance and replace it with a custom instance from an NSURLSessionConfiguration for people wanting to create them manually?\nHow is that gonna affect the usability of OHHTTPStubs?. I'm not sure there's any point on doing that ourselves while CocoaDocs already does that for us?\nhttp://cocoadocs.org/docsets/OHHTTPStubs/. Note that if you click on the  badge in the README it will send you straight to that API documentation on CocoaDocs already. That's pretty standard for README files of most pods :wink:. Thanks a lot for this PR! Well spotted!. Hi, thanks for taking the time to file an issue\nAre you saying that the print(\"true\") is executed and shows up in your console but the print (\"Stubbing\") doesn't? It's not just because the print might happen in a thread other than the main one and the text is not printed right away in the console? If you place a breakpoint does it stop?\nDid you try with anything other than localhost?\nI'm thinking maybe the iOS URL Loading System treats localhost as a special case and doesn't ask NSURLProtocol chain in those cases or bypass the system?. What's the Rx wrapper you are using?\nAt my company we use a custom-made Rx wrapper around Alamofire too (and not the RxAlamofire pod) and it works as expected\u2026\nMaybe you're creating your Alamofire.SessionManager too early, so before OHHTTPStubs has time to swizzle and inject the stubs protocol before the NSURLSession.configuration has time to be created?. Strange indeed.\nI'm not sure I'll have much time to look into it in details very soon, as I have quite some work and also talks to prepare. So what I can propose you is:\n\nCompare your code with our own wrapper we use: NetworkStack \u2014 maybe you'll find some differences and see what would make ours work but not yours and get some inspiration from that?\nHope someone will have time to take a look at your problem (@Liquidsoul ?) before I have more free time myself\nPing me in a week or two if you didn't have any progress on the issue, I might have some more time by then. @wassimseif we have a lot of work to do on it it to better document it, make a proper README and examples & demo projects indeed, haven't had that much time for that; but I know there's a pending pull request from one of my colleague adding a lot on that regard: check the \"documentation\" branch I think he even added sample projects in there. @wassimseif Any update on this, especially did you indeed ensure that you didn't forget the asynchronous wait in your test (e.g. using XCTestExpectation like explained here in the Wiki). @mrjimoy isHost compares the string you give with the request's url.host property.\n\nThe host part of an URL, as specified in the RFC and in NSURL documentation, is just api.some.com, without the \"https://\" part and without any /. While \"https\" is what is called the \"scheme\" part of an URL (which you can test via isScheme(\"https\") if you wish to)\nSo that's why your request doesn't gets stubbed. It's because, as @Liquidsoul suggested, the condition for matching your request is always false. Only pass the isHost(\"api.some.com\") for the host without the scheme (without the \"https://\" part nor the trailing slash) to fix it.. @Liquidsoul To avoid other people falling in this trap, I wonder if we should add a preconditionFailure(!host.contains(\"/\"), \"The host part of an URL never contains any slash. Only use strings like 'api.example.com' for this value, and not things like 'https://api.example.com/'\") in the isHost implementation? Or at least add - Note entries in the function's doc comments to hint about this?\nAnd probably same for some other test helpers (like isScheme isn't supposed to contain the \"://\" part either, etc). I just realized that this has been fixed by triggering an assertion when you misuse isHost (see #248)\u2026 but that I haven't done a release in a while so that fix is still in master but was never officially released!\nWill try to do a release soon. Don't hesitate to bump if I forget by next week.. Simply inspect the request parameter passe to the closure you give when you create your stub:\nswift\nstub(isHost(\"mywebservice.com\")) { request in\n  let params = request.url!.query // contains your parameters as string like \"a=1&b=2&c=3\n  // you can also use URL:\n  let comps: [URLQueryItems] = URLComponents(url: request.url!, resolvingAgainstBaseURL: true)!.queryItems!\n  // then iterate over the comps to check if you have the item.name and item.value you expect\n  // then build your response accordingly\n  return OHHTTPStubsResponse(\u2026)\n}\nNote that if your parameters are in the body you'll have to use the request.ohhttpStubs_httpBody property to get the NSData of the body instead and get back the parameters.\nOne last solution is to use NSURLProtocol.setProperty(parameters, forKey:NSURLRequestParametersMetadataKey, inRequest:req] \u2014 see this entry in our wiki for more info. @mikelupo Just push a new commit on your branch to fix that link. No need to create a different PR or whatnot, it's just a new commit to add on your fix_memoryLeaks branch \u2728 ). Oh wait\u2026 I totally got it the other way around, my bad, you're right!\nI actually am now used in all my project to remove all the indentation spaces from empty lines and remove them\u2026 like Gerrit suggests and like what you did!\nWhat I didn't realize when I wrote that comment here is that by the time I started writing OHHTTPStubs some years ago, I didn't use that setting/practice yet, and kept those spaces in empty lines at that time (instead of doing the same as you do\u2026 and as I do now on all my other projects too \ud83d\ude04). So I misread that diff and actually thought that there were no spaces and you added them\u2026 while in fact that was the total opposite \ud83d\ude1d \nMy concern is I want things to be consistent all across the codebase. So I'd agree that we should remove all the spaces from empty lines and since I never realised that it wasn't the case already in that (quite old now) codebase of OHHTTPStubs I never thought of re-auditing it for it \ud83d\ude09 \n\nIn light of that you have two choices, I'll let you decide which you like best:\n\nDon't remove the spaces in that PR, to focus on the memleak fix, and do a separate PR to fix all the spaces (not only on those files you changed, but everywhere in OHHTTPStubs's source code, demo project, Unit Tests, \u2026)\nMake those changes in the current PR, killing two birds in one stone (even if that doesn't split the tasks as clearly but would avoid you reverting the deletion of spaces just to remove them again a commit later). But then again if you keep the changes you did for spaces in that PR, then better apply the same rules and fix that\u2026 in the whole codebase then (even the ones you didn't edit to fix that memleak) :wink:\n\nI'll let you decide if you prefer to split that in 2 PRs (memleaks + remove spaces from empty lines) or all in that current one. I'd personally prefer two separate PRs, but would understand if it's too much work for you. In any case, just make sure that the spaces are consistent everywhere (and not in one way on some files and another in other files). \ud83c\udf89  Thx again @mikelupo for the fix and taking the time to follow our strict guidelines \ud83d\ude1c\nLooking forward to the next PR to remove extra whitespace from code \ud83d\ude09. Thx!\nQuestion: why only do it on test classes and not the whole codebase?. Haha sure, no rush! \ud83d\udc4d . Perfect \ud83d\udc4d. You have to create your first stub before creating your Alamofire.SessionManager.\nBecause Alamofire.SessionManager creates its internal URLSession from its own NSURLSessionConfiguration under the hood and if that session is created before OHHTTPStubs had any chance of injecting itself in the URLSessionConfiguration before the session is created using that configuration then it's too late to alter the session's configuration once it's created. OHHTTPStubs being lazily loaded of you don't call any method of OHHTTPStubs before creating the session it won't hack itself into the URLSessionConfigurations soon enough. \nYou can search closed issues in this repo, some people also had a similar setup as yours and made the mistake of creating the Alamofire.SessionManager or sending their first Alamofire request too soon before OHHTTPStubs got any chance to be loaded in memory by the system. But but but\u2026 when you write this: \nOHHTTPStubs.setEnabled(true, for: SessionManager.shared.sessionManager.session.configuration)\nYou're accessing the configuration of an already created session, right? \nSo you're actually trying to modify a configuration that is already part of an existing session so after that session has been instantiated, right? \ud83d\ude09. Btw maybe your issue has nothing to do with using Alamofire and that configuration stuff, I might have jumped at the wrong conclusion here. \nI just saw that you wrote isHost(self.baseURL) but what does this baseURL actually contains? Does it really ONLY contains a host name, without http scheme or any /?. So in the end it might just be a duplicate of https://github.com/AliSoftware/OHHTTPStubs/issues/247#issuecomment-300463378 \u2014 which will be prevented by the preconditions added by #248 but are still only in master and not been released yet (new release coming soon to avoid more people falling in that trap). Could you try using an always-true condition instead? (stub({ _ in true }) { \u2026 })\nAnd also adding some breakpoints to see if:\n your request is properly being sent (like you didn't forget to call .resume() on the dataTask / call response() or responseJSON() on the AF request / call subscribe() on your Observable triggering the request\n Your request is kept running and not being cancelled (like if your Observable's subscription isn't retained and ends too soon, being disposed quite immediately and the cancelling the request\n* The internal methods of OHHTTPStubs just even the ones checking if the protocol can handle the request, are called\n. Finally, even though it might not be the direct source of your issue here, note again that \u2014 as the URLSession documentation says \u2014 once a session is created from an URLSessionConfiguration, that session's configuration is copied at init time and thus read-only: any change to the configuration after it has been used to build the session will not affect the session after it has been instantiated. So you're generally not supposed to access shared.session.configuration to modify it (that won't have any impact on the session) but rather supposed to create a new configuration, set it's properties, then construct the session from it and don't modify the configuration afterwards. But skimming through your code (from my phone so maybe I missed some tricks?) it seems you try at multiple occasions to access shared.session.configuration to modify it, am I right?\nEven though idk if it's the source of your issue with stubs it feels to me that you should maybe start to fix that and make sure your test code works in the first place and you didn't overlook some survival case you have only because of that our because you're in tests (I've been bitten by that in the past so that's why I suggest that \ud83d\ude09) before adding stubs once the rest is guaranteed to work? I mean I'm sure you checked but better to rule everything out to be sure we're not trying to debug the wrong part ^^. If you use a custom condition closure you can already put a breakpoint here and check some stuff, like this: \nswift\nOHHTTPStubs.stub({ request in\n  print(req) // breakpoint here and check some values\n  print(req.url?.host)\n  return true // return req.url?.host == \"example.com\"\n}) { return OHHTTPStubsResponse (\u2026) }\nIf that's not sufficient to debug, you could check if this method is getting called, as well as the startLoading method a few lines below.. Then this means that OHHTTPStubsProtocol hasn't been injected in you URLSessionConfiguration before the session has been created. \nCould you check if OHHTTPStubsProtocol is present in the list of session.configuration.protocolClasses?\nIf not that means that the session has been created before OHHTTPStubs had time to auto-inject itself via swizzling into URLSessionConfiguration\u2026. Ok then that's the issue. \nYou might wanna put a breakpoint in this method which is responsible for doing the swizzling \u2014 and thus auto-installing the OHHTTPStubsProtocol inside the default URLSessionConfiguration constructors \u2014 especially check: \n That it's called only once and not twice (if it's called more that one that would strangely mean that the OHHTTPStubs library is linked & loaded twice in your target) \n That it's called before Alamofire is creating it's own URLSession (I'll let you find the right place in Alamofire's source code to put a breakpoint then check which is called first). Mmmh very strange indeed. And the swizzling is only called once?. Very strange. Did you check that you added OHHTTPStubs to the right target? Well you said you didn't use hosted tests so your test target should be a standalone one be I can't see what's going on here\u2026\nCould you maybe create a sample project to reproduce the issue in an isolated way and share it there?. Cool glad you managed to solve it. I'd love a PR to improve the README in that matter or even a dedicated wiki page maybe (the wiki is open so you should be able to contribute freely). Wow very strange indeed. Thanks for taking the time to file an issue. \nI don't see how calling stub could influence Quick/Nimble that way, especially since quick drives the tests then execute stub not the other way around so an potential bug influenced by stub on quick seems backwards\u2026 I have no idea what's happening there. \nJust to be sure: \n1) did you try without the stub to confirm that in that situation it only prints once?\n2) put breakpoints in the beforeEach, afterEach, and it?\nGiven that the print for \"describe before\" (which I don't see in your code btw) and \"context before\" are seen twice BUT the \"context after\" is only printed once, I'm wondering if it's not a glitch with print and the console (eg I've seen such behaviors in some projects when the print isn't executed on the main thread etc)?. Do you have a (simplified) sample project you could share reproducing the issue so we can investigate more?. Hey @geraldeersteling !\nAny news on that issue? Did you manage to understand what was going on, or maybe even solve it? Or otherwise come up with a sample project reproducing it?\nThanks!. You have multiple options there: \n\nthere's a matcher helper called containsQueryParams(\u2026) so you can combine isHost(\u2026) && isPath(\u2026) && containsQueryParams(\u2026) and so on \nremember that the matcher parameter (the first parameter of the stub method) is actually just a closure taking the request and returning a boolean. Helpers like isPath(\u2026) etc are just helper functions to construct closures for common use cases but if you need more control you can always provide a custom closure to fit advanced needs. \n\nIn your use case you could also either:\n- prefer install two different stubs with 2 different conditions (one with some containsQueryParams(xx) and another with containsQueryParams(yy)) \n- or stub all request, and return a different value in the trailing closure (using a simple if) depending on req.url?.query or similar \nSo really you have a lot of options to do that!. Hello @Jerem42 \nCarthage is based on the idea of downloading the pre-compiled binary framework of each library you put in your Cartfile if available. Which is not a good idea until Swift is ABI stable (and discouraged by Apple for this exact reason) because then every time the compiler changes the Swift version then every binary framework is incompatible. \nSo if you're in this situation (using Carthage to integrate OHHTTPStubs) then OHHTTPStubs will not be the only framework you'll have this issue with (every library providing a precompiled version will have the same issue). You'll have to use the --no-use-binaries flag of Carthage to solve this issue with all other libraries you use in your Cartfile. You can find more info in Carthage's own documentation & issues.. Just so we know if there's still work to do on that issue: has anybody had time to test OHHTTPStubs with Xcode 9 & Swift 4 and saw any compilation issue with it or code that would need modification for it to be adapted to Swift 4?. Cool, thanks @gonzalezreal for the feedback! \nI'm gonna close this one then.\nWe could still reopen it in case a later beta creates issues but I doubt it since the biggest risk was with the changes in the String API and the string manipulations we do in the matchers but we'd have seen errors by now if we were affected.. We decided to stop shipping precompiled binary releases due to the ABI stability not being there yet for Swift (otherwise we'd have to maintain one for each Swift version to make everyone happy and I don't have that maintenance bandwidth). Closing this as it's not an issue which requires any action by OHHTTPStubs itself, but by Carthage relying on the Swift ABI being stable while it's not. \nThis issue is thus common to any Swift library that you integrate with Carthage and provides a compiled binary, not just OHHTTPStubs. \nTo solve it just use the --no-use-binaries flag when invoking Carthage, or open an issue in the Carthage repo to all them to auto-fallback to that flag in case of binary ABI incompatibility detected (I thought they already implemented that fallback though so be sure to use the latest version of Carthage too). Hey @mplorentz, thanks for reporting the issue!\nI believe you're right, I might have closed #222 too soon.\nThe big change which made me close #222 was that now the subspec OHHTTPStubs/Swift always includes other subspecs necessary to make it work for all configuration. But in fact #222 only makes it now possible to implement that now, but I haven't indeed exposed it entirely yet.\nSo since #222, I've added the hasBody matcher, so that you can now stub(isHost(\"my-host.com\") && hasBody(myBodyData)) { req in \u2026 } \u2014 and this hasBody matcher is only possible thanks to #222 \u2014 but to access ohhttpStubs_HTTPBody() on URLRequest I indeed haven't exposed it to Swift in a nicer way than still forcing you to cast to NSURLRequest first.\nI'll try to do a fix soon (probably re-applying parts of #216 \u2014 but without the #if OHHTTPSTUBS_NSURLSESSION_HTTPBODY lines which were not working as expected anyway). Cool, looking forward to it! \n(Don't forget to credit yourself in the CHANGELOG too!). @mplorentz just gave you push access to the repo so you can create your branch directly on it instead of having to fork \ud83d\udc4d . Yeah don't worry, unfortunately that's a random failure we have on Travis sometimes due to some tests and simulator being extra slow or non responsive when Travis is under heavy load. I  planned to switch to Circle CI for a long time (that's what I use for all my other OSS projects) but haven't had time to migrate OHHTTPStubs on it yet. \nI'll restart the failing jobs usually the failure is only temporary.. \ud83c\udf89  Thanks again for your contribution @mplorentz !. Nicely spotted, thanks! \nJust fixed it \ud83d\udc4c. Oh, nice catch! Thx!\nI'll wait for your PR to do the release I was planning to do soon (it's been ages since I did a release and some fixes already in master are still waiting for release for a while). Let me know when you find time to do that PR so I can know if it's worth waiting for your for the release or not \ud83d\ude09. :+1:\nI think we have a \"WIP\" GitHub label don't hesitate to use it on the PR if there are some tasks still to do / tests still to add before merging. @mikelupo I've invited you as a collaborator so as soon as you accept the invitation you should have the rights to add labels now \ud83d\udc4d  (tbh I was surprised that I didn't invite you as an official collaborator on the repo before \ud83d\ude09 ). Oh yeah sure I think it will always be useful to have \ud83d\udc4d. Ok, I've investigated a little bit\n\nIt seems that NSURLSession does preserve method on 301/302 at first glance. Only tried with a HEAD request to http://google.com though (and seing that the redirect was also a HEAD), because I don't have any example server at hand doing a 301/302 on a POST to test. So maybe we should do the same here too and keep the method for 301/302 too (as the original RFC intended even if it's not what historical browsers do, but seems is what Safari does now?)\nWhen redirecting a POST request, shouldn't we also keep the body of the original request too?. @mikelupo This is a really good news, that means that everything should work magically, and I worried for nothing \ud83d\ude05 \n\nThe mreq = [request mutableCopy] should copy the stream, which is not open so has never been consumed, then newReq = [mreq copy] will do the same, and we'll return our new duplicated request with the same stream not yet consumed, and the iOS Loading System will be able to open and consume it only later when the request is finally really consumed.\nTbh I'm a bit (happily) surprisedly this result, as the request and all its body theoretically would have been sent to the real server at that stage, so that the server can return a 3xx redirect, so at that point, at least in real (not-stubbed) conditions, I guess the OS has already consumed the body (as it has sent the full request to the server). But in our case as we intercepted everything we never consumed it, so we should be totally good :-)\nIt's actually easy to confirm now that we know it's NotOpen and should work magically: implement as we said (just mutableCopy, change the url, then copy and call [client wasRedirected\u2026] etc) and let it run its course. If, after the redirection, the stub you set in your app ends up receiving the final response with the expected body (and not an empty one) then it's ok.\nBottom line: I probably worried for nothing, sorry for all the alarms and complex explanations for nothing ^^. Well we still need to make the mutableCopy + url = redirectLocationURL + copy dance, as for now the code still create a new request and set the method instead of doing a copy of the original request.. This would be nice to have unit tests for these redirect behaviors, especially to not forget cases like 303 and ensure we don't break those RFC implementations in the future.. I don't mind keeping the commit history.\nDon't hesitate if you need help implementing the unit tests \ud83d\ude09 . I think basically you can generalise the unit test for 301 to:\n\nTurn that test into a more generic function taking the httpMethod to use for the testing request, the optional body, and the status code to return.\nThen make some tests calling that function, respectively with { 301, 302, 307 and 308 } and with { GET, HEAD, POST, PATCH } (so 4x4 = 16 tests but which are simply all calling that generic function with different parameters). That way we'll not only test just 301+GET, but all other combinations\nImprove that function so it also add some assertions to check that the body of the returned redirect is the same as the original, and same for the method\u2026. @mikelupo ping :wink:\n\nAny chance you'll find some time to continue working on it soon?\nI'd love to make a new release at some point and would like to include your PR in it \ud83d\udc4d . \ud83d\udc4c . @mikelupo I took the liberty to rebase and give a try at those tests. It's indeed easy to get lost and lose track between all those multiple requests & responses in all redirects when trying to figure how to write that\u2026 \ud83d\ude13\nI hope I got it right. I'll let you review my commit when you have some time \ud83d\ude09 . Seems like Travis-CI randomly fail 50% of the time on:\n\n\u2717 test_NSURLSessionDefaultConfig_MethodAndDataRetentionOnRedirect, ((jsonError) == nil) failed: \"Error Domain=NSCocoaErrorDomain Code=3840 \"No value.\" UserInfo={NSDebugDescription=No value.}\" - Unexpected error deserializing JSON response\n\n\nAt first I thought it was just Travis being Travis (it has been quite unstable for some time) but even when restarting jobs, some pass and some continue failing with the same \"No value\" CocoaError, so maybe that's a real problem that we gonna have to investigate (likely a race condition between all the requests and redirects done simultaneously but the test only having one shared variable at some place in that test method?!). Thanks for the PR, I'll look into it this weekend.\nBut were you aware that when you setup multiple stubs, they are always tested in the reverse order they were added, which means that you can start all you tests by first adding a \"fallback stub\" which always succeeds (condition always true) and fatalErrors or XCTFails, preventing such risk of requests leaking to the real network?\nThis is described in the wiki here:\n\nThis may also be used for a fallback stub, as the first stub being installed will only be called if every other stub fails.\n\nBasically you just have to:\nswift\nfunc setUp() {\n  super.setUp()\n  // Being the very first stub to be installed, this will be the last condition to be checked\n  // So it will only be triggered if all other stubs added later failed to match their respective condition\n  // And no other stub matched.\n  stub(condition: { _ in return true }) { req in\n    fatalError(\"You forgot to stub request \\(req) and it almost hit the network. Please add a stub for it\")\n    // I used fatalError but maybe you prefer to just XCTFail, it's up to you\n  }\n  // And then install all your other stubs\n}\nIf that is sufficient for your changes, then maybe this onStubMissing addition is in fact not needed and you can use that trick instead. But even if it's the case I'd still then love a PR on the documentation, as I think a lot of people don't know this trick or realize they can use it, so maybe we could expose it better in the documentation.. I actually forgot that we had that many debugging blocks already (I remembered about onStubActivation but I now realize we also added onStubRedirectBlock and afterStubFinishBlock which I forgot about).\nSo even if this feature of catching un-stubbed requests is already achievable today (by make the very first stub be a fallback with condition true), adding an explicit onStubMissing block like you did probably still makes sense (if not only for better discoverability) \ud83d\udc4d . > This may not hold water, but I have a vague memory that this was fixed in iOS 8.4??\n\ud83e\udd14 Interesting, didn't remember they might have solved it. (Still worth testing again I guess?). @pimnijman No need to create a new PR \ud83d\ude03\nA pull request is a request to merge a branch into another branch, so if you push new commits to this branch like you just did, even after creating the initial PR, they'll be included in the PR as well, no need to create a new one \ud83d\ude03\nI'll merge as soon as the CI (Travis) is ready. Hello\nI've indeed had a strange issue recently with my repo where some very early commits were completely detached from the initial commit (my commit repo had 2 initial commits\u2026 very strange) and I removed the problematic lone commits that were never used by the rest of the git tree and not linked to the branches I regularly update.\nThat 922e9ec commit was apparently one of them.\nIndeed, 922e9ec points to such a previously-duplicate  commit that was matching version 1.1.0 (\ud83d\ude31 that's a 4-years-old commit!! we're now at 6.1.0), and was completely detached from the tree\nThis issue can only be solved from within the facebook-ios-sdk repo , so you should go open an issue or PR there indeed, and do one of the following:\n\nThe super-quick-fix solution is to point to 56e994e9c04162a8df9be893fdbfb65218f60358 instead, which is the same commit but which is properly attached to the main git tree (so the content is exactly the same as 922e9ec, but it's the proper non-isolated commit attached to the living tree)\nBut since these commits, corresponding to 1.1.0, are super-old (I'm not sure they even work with modern Xcode versions, 1.1.0 is a 4-years-old release after all), it would really be way better to take advantage of this occasion to make facebook-ios-sdk update to a more recent version of OHHTTPStubs anyway!!. Side note: btw that's also one reason I wouldn't favor including third party libraries using submodules but rather using a dependency manager (CocoaPods or Carthage typically), which solves transitive dependencies using semantic versioning and tags, so maybe that's also the occasion to make XMPPFramework be included e.g. via CocoaPods and let it all resolve the rest using tags?. Builds seem to be failing due to SWIFT_VERSION not being set appropriately?. Doesn't Xcode 9.1 require Swift 4.0.2 instead of 4.0?. Yeah but for people using Carthage, which builds the framework based on the settings in the Xcode project before linking it to the integrating product, they'll probably want the framework to be built with the latest Swift ABI & version, so 4.0.2 ?. :+1: \n(Full disclosure: I only checked from the github web interface as I was on my phone and not at a computer, sorry). Hi Mike \n\nI get the problem but I'm not sure I like using some magical NSNull value (feels more like a hack to me)\nWhat about adding an additional property like @property(assign) BOOL computeContentLength to OHHTTPStubsResponse, defaulting to YES (and thus defaulting to the current behavior), but which you could set to NO if needed before returning your OHHTTPStubsResponse?. Also I'm not sure that the Swift generated API would  explicitly allow Optional values so from Swift we couldn't replace that magical NSNull you suggest to be nil (except changing the headers signature to accept nil values but I don't think that would be the right call?).  while a dedicated property feels  more compatible with Swift API here too. Hi\nI don't really understand how the fact that the method you wanna call has a callback or not would change the use of OHHTTPStubs? Not sure I understand your question\u2026\nYou'd still call stub(isPath(\"/api/v1/foo/bar\")) { return OHHTTPStubs Response(\u2026) }  to create a stub the same way (see README and wiki for more info and examples, none involve the method making the request so whether the method making the request has a callback or not doesn't matter). I am sorry, but I still don't see how that kind of setup would affect the way you use OHHTTPStubs?\nOHHTTPStubs intercept the very low level network requests, at the OS level (using a custom NSURLProtocol interceptor). At the level where OHHTTPStubs works (the URL Loading system layer of iOS) it doesn't know nor care about who sent the request, it just intercept the request and return a stub response. Exactly like if you used a proxy server.\nWhen you use a proxy server instead of your real server the proxy didn't know anything about your app, its architecture and if it has a completion of not. Same is true for OHHTTPStubs.\nPlenty of people use OHHTTPStubs with real MVC and MVP and MVVM and that works as expected no matter the architecture you have.\nI think the fact that you don't have a completion has little to do with OHHTTPStubs itself. If your stubs are not working in your setup that would be for a different reason. Like:\n\nMaybe you didn't use the correct condition detecting your request to stub, and so the request you send is never subbed and you have to update your condition. For example maybe you subbed isPath(\"foo/bar\") instead of isPath(\"/foo/bar\") so when you send a request to http://server.com/foo/bar it doesn't match the condition isPath(\"foo/bar\") so the stub is not triggered\nAnd/Or maybe the layer you use to send your network request is implementation so that if you don't pass a completion, eg you use a nil completion block in your sendRequest(url, completion: nil) or similar, then it's implemented so that it doesn't send the request at all?\n\nBTW if you don't have a completion closure in your sendRequest method how do you expect your presenter layer to be updated in the first place (stub or not stub)? Since that's typically in the completion closure that you put your code to update the presentation layer initially\u2026\n  . I think that if you could provide an example project reduced to the minimum to reproduce your use case that would help us understand what you mean exactly and what's the origin of the issue. Ok, I see your mistake then. As expected, it's not related to OHHTTPStubs per-se, but to asynchronous testing in general.\nWhether you use OHHTTPStubs or not, when you write a unit test for some asynchronous call, you have to give time for the asynchronous call to execute before doing your assertion. You typically do that by using an XCTestExpectation\n\nSee this dedicated page in the wiki explaining that\n\nIf you don't wait for an expectation before your assertion, self.sut.fetchProjects() will trigger the asynchronous code, but then immediately return (letting the asynchronous code to run in the background), and XCTAssertTrue(\u2026) will run immediately, so without letting your asynchronous code enough time to execute, checking your condition too soon and fail. Whether that async code is a network request, a long-running operation in a background thread, or whatever, whether you use OHHTTPStubs, a proxy server, or dependency injection or whatnot, whether your code has a completion block or not\u2026the rule is the same for all those async test, and XCTestExpectation is the solution.\n\nNote that one main problem of your design and architecture is that it's stateful, but without a way to observe the changes of that state\u2026 which is not really MVP, as your model calling fetchProhects() does change the Presenter state directly \u2014 so those layers are not in isolation as MVP/MVC would expect. I suggest you make those layers more separate, either by introducing a completion block, or by using any reactive framework like RxSwift, or any other way, so that the brain/logic and the presentation/view are independent. You could also try to use TDD to force you to make those layers isolated from each other, so that you'll not be bitten later by a flawed architecture/design not respecting those isolation principles of all those MVC/MVP/MVVM architectures\n\nThat being said, if you still want to keep your code the way you wrote it (without any completion block and despite it mixing the layers of MVP), you can still make it work, again by using an XCTestExpectation to wait for the state to change before testing it is the correct value. And again, that technique isn't really specific to OHHTTPStubs, but to any unit test about asynchronous code in general, so you might be interested in reading more about asynchronous testing, for example in Apple's XCTestCase documentation here\nSo in your case, even if you decide to keep it without any completion block or any other way to be notified of the changes of state, you can still use an XCTestExpectation, you'll just not create it using expectation(description: ) and later call fulfill on it, but instead:\n\neither use KVO to observe the change of your state variable (provided it's not final and is dynamically dispatched, e.g. adding @objc so you can observe it using the KVO mechanism), by using self.keyValueObservingExpectation(for:,keyPath:, expectedValue: ) to create the expectation\nor (if you can't use KVO on this variable), you could also use expectation(for:, evaluatedWith: handler: ), which use an NSPredicate, then call self.waitForExpectations(timeout: \u2026) to wait for your state to change to the expected value and make your NSPredicate turn true.\n\n. By default the stub returns the fake response in the very next RunLoop, unless you specify a response time explicitly for the stub (see README and the wiki for details)\nSince it's all using iOS URL Loading system, it behaves exactly like any normal URLSession, which runs on RunLoop events too, just returning in the very next RunLoop. Like when you use DispatchQueue.asynxAfter(0) for example, so not immediately-immediately, but in the immediate next RunLoop. If it takes too long to execute it probably means that you're blocking the thread and allowing it to run its RunLoop. Hey\nThanks for the issue report\nThe problem you have is that you're using the shared URLSessionConfiguration, which is kind of special (see Apple docs) as it uses the global URLProtocolClasses.\nI think you're not even supposed to reuse the .configuration of the shared session in practice? (I'll have to check the Apple docs to confirm).\nThat's because the shared session has kind of a special status compared to any other custom session. E.g. it uses the same global URLProtocolClasses as the old NSURLConnection, which this intercept the outgoing requests differently, compared to any custom URLSession which has its own URLProtocolClasses and its own interception of stubs.\nSo instead what you're supposed to do is:\n1) either make a mutable copy of the URLSession.shared.configuration, then explicitly enable the stubs on that configuration (OHHTTPStubs.enable(true, for: yourMutableCopy), iirc) before using it to create the new URLSession with it\n2) or just simply use URLSessionConfiguration.default (Or a copy of it if you wanted to customize some parameters of that configuration first)\nThe problem here is more how Apple made the shared Configuration a special case. The shared config is read only so I can't insert the stubs magically into it anyway, but if you use any other configuration, or if you explicitly enable the stubs manually on a copy of that shared config you should be good to go. As said, even outside OHHTTPStubs, I'm not even sure it's recommended / meant to be to reuse the shared session config.. Hi\nYou've checked the \"have read the OHHTTPStubs wiki to see if there wasn't a detailed page talking about my issue\" checkbox in your issue description, does that mean that the wiki page that exists there for this exact problem already didn't solve your issue either?. Hello\nYes it is totally possible.\nEither by using a fallback stub, as explained in the wiki here\u2026\nOr better, since the last version (6.1.0) there's even a dedicated method for that now, called onStubMissing. You can call it in the setup of your tests to tell what to do if a network request which is not subbed is encountered, so you can for example log a message, make your test fail, or fatalError, or make the request return an HTTP error for those unstubbed requests, etc.. When installing any library with Carthage, OHHTTPStubs included, you'll have to use the --no-use-binary flag of Carthage in order to be able to have the same ABI / Swift Version as your project.\nThis is because Carthage otherwise doesn't consider the fact that Swift isn't ABI-stable yet, and it's impossible to make pre-build binaries of libraries (like OHHTTPStubs or any other) ABI-stable yet, so when Carthage tries to download a pre-build binary there's no guarantee to download the pre-build binary of the right Swift ABI version. Allowing to do that would require us to re-publish a new pre-build binary every time a new Swift version is out, including beta versions, while Carthage only allows to publish one pre-build binary for each version of each lib. Even if we had the bandwidth to do that and decide to publish the pre-build binary of the latest version every time, that would mean that other users potentially not ready to update to the latest Xcode for other reasons would have the same problem and we wouldn't be able to content everybody anyway.\nUsing the --no-use-binary flag of Carthage will force Carthage to not use the pre-build binary (which will almost never be the right Swift ABI version for everybody anyway) and instead re-build the library from source using your own current Swift version, ensuring it's ABI-compatible just for that current version. This tip is valid for any library integrated with Carthage, not just OHHTTPStubs.. See #277. Thanks a lot for the PR! I'll take a look at this very soon. \ud83d\ude22\nI think we'll have to go with solution 3 then. I think we could still keep the code handling the redirections, but just document properly that there are issues due to the Apple bug.. Thanks for the issue report.\nI'm a little confused because the demo projects in Examples/Swift/OHHTTPStubsDemo \u2014 which include OHHTTPStubs via CocoaPods too (even if they do so using :path => ../..) \u2014 are compiling fine in Xcode 10b1, and the library project compiles in 10b1 too\u2026 I'll have to investigate some more to reproduce the issue.. @richardtop Are we using the same versions and doing the same settings?\nI've created a brand new project with Xcode 10b1, added a Podfile with OHHTTPStubs in it, and built the workspace\u2026 and still haven't seen the error.\nAre you using OHTTPStubs with or without the Swift subspec? Are you using OHHTTPStubs from ObjC or Swift? Do you have a minimalistic workspace to share so I can reproduce the issue?\nThanks. Hi\nI'm sorry I've tried multiple setups but still can't reproduce the issue.\nSee below, I got a project that compiles without this cycling issue.\n\nI've attached the sample project I used in a ZIP here, which is a simple as it can get: I create a brand new project with Xcode 10b1, then ran pod init, added pod 'OHHTTPStubs/Swift to the Podfile, ran pod install, added import OHHTTPStubs and called stub(\u2026) in the Issue281Tests.swift file, built and ran the tests. So I have no idea how to make the issue you see appear.\nPlease provide a sample project (reduced to the minimum if possible) where you reproduce this in a ZIP file, as this issue of build cycles seems worrisome and I'd love to investigate further.. Thanks for the feedback.\ntbh, I don't have any free time lately to dig into that much, between work, summer leave & other project, so I can't guarantee you that I'll be able to investigate it very soon, I just wanted to let you know.\nMaybe @Liquidsoul have some bandwidth to investigate it more?\nOtherwise, don't hesitate to ping us back in while if we didn't give any news after a while. Hi\nI'd say that OHHTTPStubs is rather well tested, we have quite a lot of unit tests (and also a lot of projects using it in real world, if that counts).\nWe haven't automated the code coverage reports to show it as a badge in the README for example, but you can open the XcodeProj, check the \"Gather Coverage Data\" checkbox then run the tests to see the coverage manually.\nI just did exactly that, and it appears that we're at 75% of coverage overall.\nWhen I look at what's not covered, it's mainly the helper codes to access fixtures from file (e.g. helper methods that wrap calls to [NSBundle bundleForClass:self.class] URLForResource: withExtension:\u2026]; followed by [NSData dataWithContentsOfURL:responseURL]; then responseWithHTTPMessageData:, stuff like that \u2014 especially the parts using the Mocktail or HTTPMessage file formats for describing stubs, if you choose to use those subspecs (which are not enabled by default).\nAbout all the rest of the code dealing with actually stubbing, the code coverage report seems to confirm that our whole suite of unit tests covers all the main stubbing mechanisms \u2014 even if, of course, we're always welcoming PRs and contribution to always add more tests (we never have too much tests) :wink:. FYI\n\nHTH. good point.. Ping @linksmt about the #if defined(__IPHONE_7_0) remark above \ud83d\ude09 . There's actually a very recent PR to precisely add support for watchOS \ud83d\ude09\nhttps://github.com/AliSoftware/OHHTTPStubs/pull/286. Hi\nTo be honest I'm not the one who implemented the Mocktail subspec in OHHTTPStubs (that came with a PR) and I don't really know much about the Mocktail file format spec, so not sure which one is right or wrong.\nMaybe @JinlianWang (who implemented Mocktail support in the first place via #108) or @Ashton-W (who made some modifications about it in #172) might know better?. Also, what you describe seems quite similar to what @Ashton-W mentioned in #170 (which led to the PR he did in #172).\nIf I understand the comments correctly, Mocktail allows headers to either be specified using format \"Header: Value\" or just \"Value\" (which should then be interpreted as an implicit Content-Type header). \nMaybe we oversaw a case where some Mocktail files mix both of those formats, with some lines using just \"Value\" (\"application/zip;base64\") and \"Header: Value\" (\"Content-Type: application/zip\")?\nBut even if that's the case, it seems quite strange to me that SWHttpTrafficRecorder would generate files using a mix of the two header formats in the same file, especially if both lines are meant to both declare a Content-Type header (one implicitly, the other explicitly)\u2026 and the values for those don't match\u2026 so maybe that strange format mix is an issue on SWHttpTrafficRecorder's side after all?. I think the build failures might be related to the race condition bug we discovered in URLSession in https://github.com/AliSoftware/OHHTTPStubs/issues/230#issuecomment-380931933 (don't hesitate to duplicate the radar to help us make Apple fix it btw)\nSee also https://github.com/AliSoftware/OHHTTPStubs/issues/280. Sorry for the late reply.\nI honestly don't really know. I mean those redirect tests are probably always gonna fail until that Apple bug gets fixed or we find a workaround.\nSo maybe we should merge that anyway given that the failures are not our fault?\nOr a better solution might be to introduce a small delay in the redirection (like what we done in the other PR to confirm the bug was a race condition) as it seemed to at least reduce a lot the bug from happening; even if that means introducing a delay and slowing down stuff a little, that's probably better than failing 70% of the time\u2026?. I was talking about a new test case that @sberrevoets wrote in his initial commits, and that I remember about from when I reviewed the diff on that PR before the conflict resolution today. That new test case which was added in that PR was essentially creating a request, with all the headers of interest here + another header \u2014 named \"preserved\" iirc \u2014, and after using that dummy request and redirecting it, did XCTAssertNil() on all proper headers to check they were properly removed and an XCTAssertEqual() on the one named \"preserved\" to check it wasn't removed.\nThat test case seems not to be there anymore (or is my GitHub view of the PR diff on my phone making me missing something?). It probably was removed by the force-push done by @sberrevoets today I guess. While I think it would be worth to have that test case back (even if it ends up not being run on CI because we disabled them there, but they would still be able to be run locally in Xcode). Thanks @sberrevoets :tada:. Thanks for the report!\nI'll try to look into it as soon as I have some free time :wink:. Sorry for not being super responsive, haven't had a lot of time to work on my many OSS lately, and I don't have a Mac at home anymore (keyboard repair in progress) to test this PR unfortunately.\n@marcussc You could try to integrate the fork in a project (If you're integrating it using CocoaPods, just use pod 'OHHTTPStubs', :git => 'https://github.com/lightsprint09/OHHTTPStubs', :branch => 'extension-support' in your Podfile), do a clean build, and confirm it solves the problem. If so, I'll probably merge it right away.. Cool, thx \ud83d\udc4d \nI have a few other PRs left on which I've been late on reviewing and merging, will try to catch up on them all this week so I can release of a new version properly ASAP \ud83d\ude05 . Note that for some time now, Travis-CI hasn't been very reliable on OHHTTPStubs especially due to some timing tests randomly failing (depending on the CI CPU speed I think), but also sometimes travis failing to kick in and trigger the VM and tests\u2026 (I'm willing to migrate to CircleCI for a while but didn't yet). It's always fun to have to regularly restart the CI jobs when that happens, so don't be too surprised by that CI state, it might not be related to your PR specifically\u2026. I have to be honest I just started a new job, in a new country\u2026 so pretty swamped those days in it's not gonna get better until a few weeks I think.\nI happy to hand over and give push access to anyone willing to help, so if you're interested in becoming a co-maintainer and help with merging PRs and doing releases I'll be happy to make it happen so that someone can make those move forward while I'm busy \ud83d\ude05. @jeffctown Just added you as contributor with push access ;) I trust you'll review other pending PRs too (checking if some need to be merged first before this one? then rebase this one, etc) so everything is ready for release \ud83d\udc4d . Just dequeuing my notifications rn, I see you have decided to not merge this but just FYI if we were to fail to find a solution and decided to indeed disable the test for CI to be more reliable, I'd at least do it the same way I did for timing tests: wrap them in a big #if condition which would default to true, and make it false on CI by injecting the build setting during rake invocation on CI (see DISABLE_TIMING_TESTS or whatever I called that #if). Does that mean that when we do a PR from feature/x to master, the CI won't trigger until the PR is actually merged into master?\nDoesn't that defeat the purpose of the CI, if we only know after the fact (after merge) if it passes or not?\nOr does this config means the opposite, like only build PRs targeting master but not PRs targeting other branches nor commits on master?. Oh great, perfect explanation, makes total sense then \ud83d\udc4d thanks!\n(It has been years since I played with Travis, as I moved to circle CI for all my other OSS repos \ud83d\ude05). As commented in #298 maybe we should have kept that test enabled by default when run on Xcode and only disable it on CI (the same way I did with timing tests)?. In a dream world \ud83e\udd84 I'd say if you could let me the day after you opened a PR to have a chance to review it before merging, that could be interesting (at least for the first PRs you take responsibility for) so that I can validate the direction\u2026 \nBut given how busy I am with induction into my new job I can't guarantee that I'll be as fast to react or review all your other PRs (tonight was just a light evening, not expecting many ^^) \ud83d\ude13\nSo given how you seem to have good motivation and you're helping unlocking a situation that I did let stale for too long (And thanks again for that \ud83d\ude4f), sure if there's a PR that can wait a few hours or the day then maybe you could wait so I might take a look before you merge\u2026 but in any case if you see I'm not reacting after one day (while @liquidsoul approves the PR on his end), or a change is trivial, feel free to make things go forward without waiting for me \u2014 so that we don't continue having that stale situation on OHHTTPStubs that I kept postponing for too long for lack of  my own availability. (We could always revert a PR if needs be in case of emergency after all). Man it's so refreshing to see CI turn green on the PR without having to restart every CI job manually and pray until it passes \ud83d\ude04\ud83c\udf89. FYI: \nhttps://github.com/AliSoftware/OHHTTPStubs/wiki/%5BAdmin%5D-Release-Process. @jeffctown Feel free to tweet about the newly released 6.2.0 version on Twitter \ud83d\ude09 . @kcharwood Why *2.0 here?\n. Add an if (self.dataSize>0) condition\n. Maybe better add an inBundle: parameter (nil= mainBundle) to allow more flexibility\n. Maybe invert the parameters, to have dataSize: along with inputStream (and before statusCode) as it is related to the source.\n. Ok that's what I though, but what if you have multiple chained 302 redirections?\nIn fact, I see no reason to put this *2.0 here as it seems like a magic number here, and the user of the class won't understand why it observes a requestTime doubled from the one he/she specified. IMHO, it's up to him/her to specify a requestTime 2 or 3 times bigger when he/she builds the OHHTTPStubsResponse, if he/she thinks it is needed.\n. Why is slotTime = .0.25? What exactly means this value, that a chunk of data will be send each 1/4th of a second? In that case we can't simulate responses that returns in less than 250ms (which is a problem as a lot of users of my lib use very small requestTime values, sometimes even zero, for their Unit Tests to avoid latency while executing them)\n. Some more comments would be welcome here to explain this math magic\n. @kcharwood I added a case to handle the stubResponse.responseTime == 0 case as well as all values of stubResponse.responseTime that are smaller than slotTime, so that they will return all the data at once in those cases.\nWhat do you think?\nobjc\n        else if (stubResponse.responseTime < slotTime)\n        {\n            chunkSizePerSlot = stubResponse.dataSize;\n            slotTime = stubResponse.responseTime;\n        }\n. Just for information, for the sake of consistency you could also have used the commodity method responseWithJSONObject:statusCode:headers: here instead (defined in OHHTTPStubsResponse+JSON.h) which does the NSJSONSerialization and adds the Content-Type header for you:\nNSDictionary *expectedResponseDict = @{@\"Success\" : @\"Yes\"};\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n    return YES;\n} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {\n    return [[OHHTTPStubsResponse responseWithJSONObject:expectedResponseDict statusCode:200 headers:nil]\n            requestTime:kRequestTime responseTime:kResponseTime];\n}];\nIt doesn't change anything but is more readable IMHO. I don't know if you were aware of that commodity method ;)\n. :thought_balloon: :bulb: I'm thinking of doing some method swizzling on the defaultSessionConfiguration and ephemeralSessionConfiguration methods directly in [OHHTTPStubs setEnabled:] method, so that OHHTTPStubs will be automatically and transparently enabled for all NSURLSessionConfiguration created\u2026  (no additional code to add from the user :+1:)\nsetEnabled:forSessionConfiguration: would still be a good addition in cases users wanted to enable/disable stubs per session, but in the majority of cases letting OHHTTPStubs enable itself automatically and transparently seems to be a nice touch. What do you think?\n. I think we should use __IPHONE_OS_VERSION_MAX_REQUIRED >= 70000 (SDK version) here instead, to compile that code whatever the Deployment Target is (but only if the user is compiling with SDK 7 as NSURLSession is not defined in the SDK headers before that version of course)\nAnd then test for the availability of the NSURLSessionConfiguration class at runtime (using if ([NSURLSessionConfiguration class]) as described in Apple's \"SDK Compatibility Guide\") in the implementation, to only execute the code when the user's device is running on iOS6 or below.\nThis way OHHTTPStubs will still be usable with projects targeting iOS6 or below; and those projects could even (conditionally of course) use NSURLSession capability (in an if block testing for the class availability at runtime)\n. use __IPHONE_OS_VERSION_MAX_REQUIRED instead\n. Encapsulate this code between if ([NSURLSessionConfiguration class]) { \u2026 } or better, between if ([sessionConfig respondsToSelector:@selector(protocolClasses)]) { \u2026 }\n. I agree method swizzling is to be avoided when possible, but in that particular case I think it's worth it.\n. I should also modify my code to call setEnabled:YES maybe in +initialize instead of init. It seems a more logical place to register my NSURLProtocol subclass.\nThis way as soon as we use _any OHHTTPStubs method, even one not creating the sharedInstance like simply [OHHTTPStubs class], it will register the NSURLProtocol with the NSURLSessionConfiguration default condfigurations_\n\nSide note: I am wondering, does this protocolClasses property of NSURLSessionConfiguration means that +[NSURLProtocol registerClass] only has effects on requests sent via NSURLConnection? Too bad Apple didn't decide that [NSURLSessionConfiguration defaultConfiguration] does not include the additional registered NSURLProtocol classes by default, so that any NSURLProtocol subclass registered in existing code (for NSURLConnection) would have continued working seamlessly with the new NSURLSession\u2026\nWhat if some NSURLProtocol subclass is listed in -[NSURLSessionConfiguration protocolClasses] array but was not registered using [NSURLProtocol registerClass:]? Does it still get used by NSURLSession because listed in protocolClasses, even if not registered? I guess that's the case, but if not, we could only swizzle once (in +initialize) and make setEnabled: only register/unregister the NSURLProtocol\u2026\n. I can't understand why, do you have an explanation why this would works out of the box?\nDoes this sharedSession object implicitly use the protocols registered with [NSURLProtocol registerClass:], contrary to when you use [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]?\n. Ok That's what I did observe too. Thx.\nIt seems strange that there is nothing in the documentation explaining the fact that [NSURLSession sharedSession] uses the NSURLProtocol classes registered using [NSURLProtocol registerClass:] and not the classes set in its .configuration.protocolClasses as other NSURLSession does.\nI think I'll send a feedback to Apple about that missing info in the doc (and you may do the same)\n. For the record it seems to be the case \u2014 [NSURLSession sharedSession] using classes registered via [NSURLProtocol registerClass:] and not at all the classes present in its .configuration.protocolClasses.\nToo bad there is nothing at all about it in the Apple documentation :unamused: \n. Yep it totally make sense, just too bad it's not documented in the [NSURLSession sharedSession] documentation.\nSo in summary, you can change the behavior and NSURLProtocol classes between the various calls on [NSURLSession sharedSession] and the requests WILL be affected by those changes:\n[[NSURLSession sharedSession] dataTaskWithURL:\u2026 completionHandler:\u2026]; // 1\n[NSURLProtocol registerClass:\u2026]; // This NSURLProtocol class will be taken into account for the next dataTask below\n[[NSURLSession sharedSession] dataTaskWithURL:\u2026 completionHandler:\u2026]; // 2\n[NSURLProtocol unregisterClass:\u2026]; // The NSURLProtocol class will not be taken into account anomore for the next dataTask below\n[[NSURLSession sharedSession] dataTaskWithURL:\u2026 completionHandler:\u2026]; // 3 same as 1\nThat's handy and useful for sure, and an easy way to migrate fro NSURLConnection to NSURLSession, but should really be documented as this behavior for sharedSession is the opposite of the behavior described for other NSURLSession created using an NSURLSessionConfiguration whose behavior can't be changed once created!\n\nSo Apple should probably document this specific behavior of [NSURLSession sharedSession] better, for example like this instead [suggestion] :\n\nThe shared session is based on the default configuration but uses the currently set global NSURLCache, NSHTTPCookieStorage, and NSURLCredentialStorage objects and the currently registered NSURLProtocol classes. Contrary to NSURLSession based on a NSURLSessionConfiguration, requests sent using the sharedSession uses settings for the NSURLCache, NSHTTPCookieStorage, NSURLCredentialStorage and NSURLProtocol classes that are interpreted at the time the requests are made (and not at the time the session is created)\n. You must never gitignore Podfile.lock.\n\nPodfile.lock is the manifest that tell with versions of the pods have been installed the last time you pod install. Keeping it ensure that anyone making a pod install on their own machine will get the same version of pods that the ones you used the last time you checked your code.\nThis is important because if for some reason a third-party lib update (even a patch) breaks something, the code that works now will suddenly stops working later even if there were no new commit in OHHTTPStubs\u2026 just because one dependency did publish a breaking update, and as you didn't commit the Podfile.lock so you didn't lock your dependencies.\nThat's the way every dependency manager (CocoaPods, Carthage, etc) work and Podfile.lock files are meant to be committed onto GIT, otherwise there would be no guarantee that running pod install one day on one machine will install the same stuff that running pod install days later or on another machine. (If you want to update your dependencies later, that's what pod outdated and pod update XXX and pod update are for anyway)\n. Regarding the Pods folder there are two ways to go (commit it or not) and both solutions have pros and cons, but I personally prefer to commit them (I agree that that's a personal and debatable choice)\nNote that whatever your choice is regarding the Pods/ folder, that does not change anything about the fact that you still must always commit Podfile.lock whatever policy you choose.\n. Doesn't this change have other consequences, like raising the minimum iOS version for Carthage users (as Carthage use the settings in the Xcode project building the lib) \u2014 even if that's not big a deal as Carthage requires dynamic frameworks so every project using Carthage is probably iOS8+, but just wondering if it may have other side effects.\nNote that I won't mind raising the minimum requirement to 6.0 (everything under 5.0 is quite dead anyway those days), but in that case be sure not to forget to bump the pod version up to the next major version to be semver-compliant.\n. Why explicitly link on master?\nEither don't constrain it on a version at all to get the latest, or convert it as a Development Pod (as I usually do for all my libs generally) by linking to a :path, but linking it to the remote and on master is not justified (and introduce bad practice for users not familiar with CP, as master is usually unstable anyway compared to an official release)\n. I have a bit of OCD with tabs and consistence in indentation\u2026 \ud83d\ude04 please change to 4 spaces to keep same alignment as the rest of the block ;)\n. ditto\n. Requesting the user to run pod install (instead of pushing the Pods folder in the repo) maybe mean that this would stop being compatible with the pod try command?\n. This is only useful if one want to build and run the Unit tests.\nAnyone only wanting to build the library or dynamic framework shouldn't need to run pod install.\nNeeding to do so probably means that it will break the Carthage support that we just got some days ago anyway.\n. BTW using the Development Pods feature will allow us to skip this pod install step (as the Dev Pod will directly be linked internally without the need to run pod install to fetch it).\nThat's the beauty of Development Pods. And that will allow the pod try command to continue to work transparently even.\n. Just out of curiosity, why not use block directly as the 3rd parameter (as block is already a dispatch_block_t) instead of doing ^{ block() }?\n. You should use a more idiomatic name for this method, like stubRequestsUsingMocktailsAtPath:\n. You shouldn't ignore the potential error here, especially since this NSRegularExpression is not hardcoded as a string literal but comes from a file so is highly prone to errors.\n. ditto\n. You should use a constant string NSString* const MocktailErrorDomain = @\"Mocktail\" everywhere you need to create an Mocktail-related NSError (instead of using a string literal like here). You could also expose this constant in the header (extern NSString* const MocktailErrorDomain) so that consumers of the lib can compare/check the domain of the error appropriately.\n. I'm not sure I like that hack.\n1. bodyOffset is not really related to some \"timing info\" and the pace at which the data is sent periodically, so it's not logical to add it to this struct\n2. This modifies the library core just to be able to support Mocktail files\nIf I add support for Mocktail, given that it's not a feature used by many, I'll probably add it as a opt-in submodule in my podspec, so that people don't get useless extra code if they don't use it, and people needing it simply have to explicitly request OHHTTPStubs/Mocktail in their Podfile to get the extra feature. This modification does not allow us to do that given that it modifies the core of OHHTTPStubs.\n. Please use modern ObjC and the boxing expression syntax @(x) instead of [NSNumber numberWithUnsignedLongLong:x].\n. reutrn\n. Mmmh actually just realized that [NSURL URLWithString:@\"-invalid-url\"] will return nil and thus this test is kind of a duplicate of test_NilPathWithURL.\nProbably better use a valid URL (as of the RFC, so it doesn't return nil) but that resolves to an invalid resource (non-existing file) instead? E.g. sthg like file://foo/bar\n. Probably just say added methods for\u2026 (you actually added more than two :wink:)\n. Good point @samirGuerdah !\n. You don't even seem to check whether success is YES in this last implementation?\n[EDIT] Oh wait, you use it in your NSLog I see. But according to the documentation you should also check success in your if condition. So I'd use if (!success || !fileSize) there.\nThat NSLog is pretty verbose btw, maybe just %s: Countl't get tile size for URL %@. getResourceValue returned %d with error %@ is enough?\n. @MaxGabriel  Well, I'm not so sure I agree. I think for some bizarre reasons the method could also fail while setting a non-nil value to fileSize. I mean, sure that's very unlikely of course, and would be strange. But nothing from the doc prevent it from happening.\nSo if the method return a success boolean, you're always supposed to test it anyway. That's the official pattern for all those methods taking an NSError** pointer and returning a BOOL, you're supposed to test the returned BOOL, if it's NO then use the NSError to display the message, and if it's YES proceed with the data. In those methods, you're not supposed to test if NSError is nil or not to see if there is an error, but to test the returned BOOL. So I'd say that's the same for fileSize.\nAgreed that's probably just style because I don't think the method would even fill the fileSize pointer but still return NO, but that's how the method is defined and how the methods using NSError** and byref parameters are supposed to be used.\n. Feels odd to me that we'd @throw in one case (using a non-file URL) and just NSLog in the other (failing to get file size). I say we'd use one or the other for both. Probably @throw. What's your take?\n. I think a nil URL should still return empty [NSData data], because it makes sense and because it's already the behavior for what we have for the path and we don't want to change it.\nBut any misuse of the method like using a malformed URL, a non-file URL, a non-existing path(\u2020) or an URL for which we can't determine the resource size should @throw.\n(\u2020) if the existing code doesn't throw for an non-existing NSString path that's a mistake. But the fact that the existing code use [NSData data] when explicitly using nil is intended behavior, even if now that we have nullability annotations the parameter should be nonnull.\n. That is a new method, so according to http://semver.org that's gonna make us bump to version 4.7.0\n. global variables are not thread safe, so this is not an acceptable solution. You could instead add an atomic property on the shared instance for example.\n. Why not using a BOOL, as it will be initialized to YES at init time so you don't really need the YES/NO/nil tri-state anyway?\n. Why not directly return [urlProtocolClasses containsObject:protoCls];?\n. You should probably remove the NSLogs now that you've debugged its proper integration?\n. Note that although this is a perfectly valid code for swizzling, I already use a different technique in OHHTTPStubs+NSURLSessionConfiguration.m to perform a similar swizzling.\nMaybe it could be worth mutualizing the swizzling somehow (even if the one in OHHTTPStubs+NSURLSessionConfiguration.m is typed to return the specific signature of the NSURLSession methods I swizzle for now but you could change that and maybe move the swizzle helper code in a common file instead, idk)\nNot sure which of the two implementations is better; I like the fact in mine that we store the original implementation in a static with an explicit name so we explicitly call orig_defaultSessionConfiguration(\u2026) when we need to \u2014 instead of having to send the OHHTTPStubs_setHTTPBody: message to self inside the swizzled OHHTTPStubs_setHTTPBody implementation, which might be confusing even if you properly added a comment to explain it \u2014 but that's a matter of taste. But whatever solution we choose it would at least avoid code duplication.\n. If setting it to nil doesn't work, wouldn't it at least be an acceptable workaround to set it ton an empty NSData instead?\n. This header file should not be part of the public API. You might want to alter the podspec accordingly here to make it private (and thus make sure consumers of the pod won't be able to #import it from their app project)\n. Oh I see, right.\nDidn't understand your code comment at first (wrongly thought you meant \"setting it to nil doesn't work\"), but makes total sense now \ud83d\udc4d \n. Maybe I'm tired but I don't see the difference between the code for #if os(tvOS) and for #else?\n. Tip: please add two spaces after the full-stop, so that the markdown renders a line break and renders the next line as a separate line (otherwise it will join the lines) :wink:\n. full stop + 2 spaces\n. Just nitpicking here, but as a a code style preference, I'd have put the @discardableResult attribute on its own line (just before the function declaration line)\n. Could you add a full stop and 2 spaces at the end of that line so that the markdown formatting matches the other notes?\n. If I'm being pedantic, I think it would read more clearly with two separate entries/bullet points instead of one \ud83d\ude1d \n. Mmmh, good question \u2026\nnah I think it would be more logical to put the links on both, because if anyone is interested only in one of the entries they have to have the links to that PR always right next to it (and otherwise a reader would have no clue if the second entry just miss the links because we forgot them or if they're supposed to be the same as the previous entry\u2026)\nDamn I have to stop being perfectionist and pedantic, sorry \ud83d\ude02\n. \ud83d\udc4c \n. - [ ] I have read [the OHHTTPStubs wiki](https://github.com/AliSoftware/OHHTTPStubs/wiki) to see if there wasn't a detailed page talking about my issue. We should insert 3-backticks before and after that line to encourage people to put their output in them and have a nicely-formatted terminal output\nWe could even prepare a <details> block for them (so that if the terminal output they paste is long it doesn't make the issue description too unreadable), but I'm afraid doing that would be disturbing to people not knowing this tag. There's an HTML comment on top of the PULL_REQUEST_TEMPLATE.md down below, why not adding a similar one here too?\n<!-- Thanks for taking the time to report your issue with _OHHTTPStubs_! When submitting your issue, please make sure to check the following boxes by putting an x in the appropriate [ ] so we can fully understand the context of your problem and help you better -->. - [ ] I've added an entry in the CHANGELOG to credit myself. Please add an empty newline after markdown section titles (it's my OCD talking \ud83d\ude04). Ditto, empty line. Ditto, empty line. Why is this line still 2.3? (I'm reading that from the GitHub web page on mobile, so hard to easily get the context of that line in the whole xcodeproj to check if it's normal, but seems strange to me). Sorry I wasn't clear, given that 3-backticks blocks are supposed to contain multiple lines of code, I expected to have them in dedicated lines to let them wrap a block (and not be inline), so more like this:\n```\n[INSERT OUTPUT HERE]\n```\n\n. I just realised that HTML comments like those, not being markdown, won't be rendered, so that means that using underscores here isn't really useful. Maybe remove the underscores around OHHTTPStubs to make it read better when unformatted? (same for the issue template obviously). Now that I'm reading that again, the part \"putting an x in the appropriate [ ]\" feels like it's singular (\"in the appropriate box\") while we actually want to mean \"in the appropriate boxes\" \u2014 as the contributor should not limit their choices to only one box. Maybe changing the formulation to \"putting an x in each appropriate [ ]\" would help make that clearer?. None of the other checklist items end with a period (.), so why those two? \ud83e\udd14 \n(I'm OK for either style\u2026 as long as it's applied consistently \ud83d\ude04  ). Don't forget to address this one too \ud83d\ude09 \n```\n[INSERT OUTPUT HERE]\n```. Indeed!. Seems like `contains` was not available in Swift 2.3 \ud83d\ude44 Maybe add an `extension String` in the `#if !swift(>=3.0)` block at the top of this file to add support for it? https://github.com/AliSoftware/OHHTTPStubs/blob/5956336837ccb8d483119fede8cdee6590be8485/OHHTTPStubs/Sources/Swift/OHHTTPStubsSwift.swift#L30-L55. Please add two spaces after the `.` (like you can see for other entries).\n\n(This is a Markdown-specific stuff that makes the text on the next line actually be rendered in a new line in same paragraph instead of being joined on the same line). Could you fix the indentation here? (use spaces so that we're sure it matches the rest of the code which already uses spaces too). Yeah, I know, that old war again \ud83d\ude04 . Would it be possible to get rid of those changes? \ud83d\ude4f (by using the trick in the Xcode prefs I mentioned you in the last review or even manually of you don't want to change your prefs, that works too)\nBasically all empty lines should really be empty and not contain indentation and spaces. I know it's nitpicking and a matter of taste, I don't care for one style or another but I care about consistency throughout the code base \ud83d\ude09. And if course that applies to everywhere it changed here. Careful, we shouldn't modify the code of third-party pods \ud83d\ude09\nMaybe re-run pod install after your regex to overwrite the pods's code back to their original code for example. Don't forget the * to create a bullet point. Maybe use a more contrived example like with x=1&y=2#anchor query + anchor?. Parameter url:. Totally. We tried to name most if not all our matchers from the name of the method we call underneath to make the relationship clear, use common vocabulary and avoid confusion so let's try to continue that way \ud83d\ude09. Maybe add one or two more complex examples, I'm especially thinking about URLs with query parameters and anchors etc. The problem with isAbsoluteUrl is also that it doesn't follow the Swift naming convention, letting us believe that the expected parameter is an URL and not a String.\nOtoh just \"isAbsoluteString\" without context (as it's a free function, not a method on a tour) is also ambiguous\u2026 maybe isAbsoluteURLString? But might be too long. Tbh I honestly don't know what's best suited (especially at 0:30am \ud83d\ude05). yeah seems like a good compromise \ud83d\udc4d. Unrelated to this PR directly, but I see we have that pattern on multiple tests: maybe we should add a func request(from string: String) -> URLRequest helper function for our tests, responsible for handling Swift 2/3 compatibility, and use that in our test cases to avoid repeating those #if Swift(>=3.0) everywhere? (Might be a separate PR though). Please add 2 spaces after the period (so that the rendered markdown forces a newline-in-same-paragraph and makes the links go to a dedicated line). Maybe we could use some non-empty data here to have a more robust test? \nLike \"Hello World\".data(using: .utf8) or something?. Also I think GitHub's markdown parser prefers having empty lines after section titles like ## Master. Please add a period + 2 spaces (ending the line with 2 spaces allows the rendered markdown to insert a newline in the same paragraph to make the links be on their own line, see other entries). Please use spaces for indentation (not because I want to start the tabs vs spaces war \ud83d\ude04 but because all the rest of the code uses spaces so we should be consistent). Also little nitpicking while I'm at it :P Just for readability I think 307/308 is more understandable than 307/8. So, in light of the remarks I just did, maybe we should:\n\nKeep not only the httpMethod but also the body of the original request\nDo that for all 301, 302, 307 and 308 (but not 303)\n\nSo in practice:\n\nMaybe we should be less broad in the test >300 && < 400 above and only handle specific codes\nDo a mutableCopy of the original request and alter its url (instead of allocating a new NS[Mutable]URLRequest from scratch) so it keeps all the other original properties like method & body?\nIf we do that, be sure that making a copy of a request which was potentially already consumed didn't make the body empty, as the body data is quickly turned into the httpBodyStream: NSInputStream property and if that stream has started being consumed maybe a mutableCopy isn't enough to make it work & re-read from the beginning? So be sure to test that use case. I think you can override that per project (selecting the project in the left pane of Xcode then change the values of tab width + indent with on the right pane), maybe you should use that, so that whatever settings contributors like you have globally set in their Xcode, it will use spaces for that specific OHHTTPStubs project.. Just to be clear, when I said to make sure to copy the body, I didn't mean to make tempRedirectRequest.body = request.body explicitly, I rather meant that, by experience, once the request has been sent thru the iOS URL Loading System, as far as I understand, the content of the httpBody: NSData is converted into an NSInputStream which is then set to the httpBodyStream property of the request, and the httpBody property itself is then set back to nil\n\nThis is why we had to add the OHHTTPStubs_httpBody workaround-property for people wanting to do tests on their request body in their stubs, because at the time the stub is called the httpBody property was already turned into an inputStream then set to nil (so as a workaround we duplicate the httpBody: NSData when it's set so we can read it back later).\nI don't know how that's gonna work in our current context of redirection, maybe the [request mutableCopy] will have everything already working for the body to be re-used \u2014 even it's already transformed into an httpBodyStream, if that stream isn't consumed yet there shouldn't be any problem, the copy will have the copy of the httpBodyStream too and it will work as expected), but given this oddity in how httpBody is auto-transformed into an NSStream by the OS automatically, it's worth checking using some tests that it still works as expected in practice.. Whoops our comments were cross-posted :wink:\nTo answer your question above, I think:\n\nIt could be fine to return a mutable request, it will be exposed by the API as an NSURLRequest even if under the hood it's mutable, so the only side effect would be if the users were to cast it to mutable directly without making a mutableCopy first, which they are not supposed to do anyway (I mean if later they have a delegate method called, or their stub called, the type of the parameter will be NSURLRequest even if the object itself was in practice NSMutableURLRequest, but they are not supposed to do (NSMutableURLRequest*)request to force-cast anyway\nIf the httpBodyStream is not consumed and is properly copied from the request to the mutableCopy, I don't see any reason why it wouldn't also be properly copied from the mutableCopy back to the immutableCopy we return, so in practice we should still return an immutable copy anyway.\n\nSo to be clear:\n// We have the immutable \"NSURLRequest* request\" at that point // (1)\nNSMutableURLRequest* mreq = [request mutableCopy]; // (2)\nmreq.url = newLocation: // (3)\nNSURLRequest* newReq = [mreq copy]; // (4)\n\nAt point (1) we have the request, but I'm guessing the httpBody is already set to nil by the OS and has been turned into the httpBodyStream instead. The big question is, has that httpBodyStream already been consumed or not. Let's assume it hasn't (hyp A).\nSo at point (2), the httpBodyStream of the original request should, I guess (hyp B), be copied into the mutable request during the copy\nAt point (4), the httpBodyStream of the mutable copy is copied into the immutable request during copy (hyp B)\n\nAnd:\n I think the hypothesis B is very likely, after all when we ask for a (mutable)Copy there's no reason why it wouldn't make an exact copy of all fields, including the inputStream. But since it's a stream (like a file descriptor you have after some fopen and so on), and thus having multiple copies of the same stream open at once could lead to side effects, it's worth checking\n But the big question is hypothesis A, whether the stream has already been read by the filesystem or not, and if it has can it (and should it) be rewinded so that it's read from the start again for the new redirect request, etc\nI know it's a little complex, and maybe after having said all that maybe I'm imagining problems that don't even exist and everything will work automatically as expected without us having to worry about hypothesis A & B, but given that we had that issue that made us create the OHHTTPStubs_httpBody workaround, better be safe and double-check than sorry and break things :wink:. I think the simplest way to check that is to:\n1) Check if, as I guessed, by the time we are at that redirect stage, httpBody is already back to nil and turned into an httpBodyStream instead. If it's not yet turned into a stream, then all my worries go away as it's just copying the body's NSData, nothing special happens during the mutableCopy/copy then\n2) If it's indeed already turned into an httpBodyStream, look a at the httpBodyStream.streamStatus (see doc\n\nIf it's NotOpen for example, then it's ok even if it's already turned into a stream it has never been read yet\nIf it's NSStreamStatusAtEnd or Closed, then we might have a problem as that means it has already been consumed (and idk if it can be rewinded to the start so that our request copy that we return for the redirect is able to re-consume the data?). I really hope everything will work magically (and if that's the case, sorry for the false alarm and complex explanations, maybe I'm worrying for nothing).\n\nBut if it's indeed the latter:\n\n\nIt's a good question about how we've to handle that. It seems we can't rewind on an NSInputStream other than a file stream (so not one build from NSData), as far as I read in the docs. So we'll have to re-create it. But the httpBody is back to nil\u2026 So we'll have to rely on our OHHTTPStubs_httpBody workaround which kept a copy of the body around? Gross\u2026 but not sure we have many more options.\n\n\nAs for \"only apply for method=POST, I'm not sure what the RFC expects. In general, GET requests don't usually have any httpBody \u2014 only POST request do \u2014 but I have no idea if it's officially valid/accepted for GET request to have an httpBody according to the RFC, and if it is, if that body should also be conserved when redirecting. But I guess the logical thing to do would then be to do the copy of the body for all requests, whatever the method.\n\n\nLet's test first \u2014 if the body is already converted to a stream at that point and if the stream is already open or not \u2014 before relying on hypothesis and think of possible solutions (that we might not even have to use if the hypothesis isn't even true), we'll think about the solution depending on the result of the tests then :wink:. This isn't needed anymore as we do a mutableCopy on line 427 now so the HTTPMethod is already the same as the original. So in summary the behaviour we want to implement I think is:\n\n301, 302, 307, 307: do the mutableCopy + mReq.URL = redirectLocationURL + copy dance like you already do here\ndefault, especially for 303: redirectRequest = [NSURLRequest requestWithURL:redirectLocationURL]; \u2014 instead of the copy (as, according to the RFC, 303 exists to tells that \"the original request has been accepted and processed by the server and we now need to go to a new location to continue\", so we must forget the old request (and not copy anything from it) and create a brand new one . 303 shouldn't make a copy of the original request, as the intent according to RFC is to tell that the first request has been processed correctly and that we should now continue to a new request. Hey @c1ira could you add a period + 2 spaces at the end of this line? It's a little trick in markdown so that once rendered, it inserts a new line inside the same paragraph (see other entries)\n\nAlso don't hesitate to add a link to that PR too (under the link to your name) while you're at it. Did you check that this is only called once? I remember when I worked on canInitWithRequest a while ago that iOS called that method more than once to test a single request.\nI have no idea why it would call it multiple times while calling it only one should be enough for the system, but in practice, at least some iOS versions ago when I worked on this part of the code, putting a breakpoint there made it be triggered multiple times even for only one request, so better check in case it's still the case (especially with old iOS version, as maybe they've improved that since recent updates hopefully). This = nil; isn't needed as all path below will affect it a value anyway. (By not affecting it to nil, the compiler will warn us in case we later change the code and forget to affect a value in one of the code paths). Maybe here instead of returning an empty NSData, we could use a data for the redirect that is computed from the original httpBody (maybe not exactly the same data to be sure not to confuse them both, but maybe one derived from it) \u2014 And for those tests, don't use the json parameter then.\nSo make those stub be so that:\n\nfor the original request (the stub on that line 123), we send a redirect response (with httpStatusCode, being 301, 302, \u2026) with the body derived from the request: stubbedRedirectResponse.httpBody = f(originalRequest.httpBody).\nThen the second stub handling the redirect (below, line ~129), we make it so the stubbed final response has a body re-derived from the redirect body: finalResponse.httpBody = g(redirectResponse.httpBody) = g(f(originalRequest.httpBody))\n\nThat way, once in the completion block at the call site, we can look at the resulting body and do some assertions there.\nFor example f can be so it returns a simple JSON representation of a dictionary like { \"originalBody\": originalBodyHere, \"originalMethod\": originalMethodHere }. Then g can be so it returns a JSON wrapping that first JSON, like { \"redirectedBody\": { \"originalBody\": originalBodyHere, \"originalMethod\": originalMethodHere }, \"redirectedMethod\": redirectedMethodHere }.\nThat would make the assertions in the actual tests below easy to ensure we didn't lose anything in the way.. Don't forget to remove that NSLog once you've done with experimenting on that test before we merge :wink:. So for example here if we tweak our test_redirect_NSURLSession\u2026 method so that it returns a response body derived from the dataToPost, we can now check if the jsonResponse \u2014 which should be derived from that g(f(dataToPost)) that we initially sent \u2014 matches what is expected.\nIf our redirect lost the httpBody during that redirect, that means that we would lose the response derived from it and the assertion would fail.\n\nThat's just a random idea, I'm on the train rn with little data so haven't had the leisure of looking into it in details, I hope you'll see the idea.. Haha too late, I saw it in my email notifications \ud83d\ude02 \n(Thanks for telling me you deleted it though, as I would probably have gone crazy trying to find it on GitHub after receiving the email notification otherwise \ud83d\ude04). Indeed I think so too. We very recently fixed that need for the cast to NSURLRequest (see https://github.com/AliSoftware/OHHTTPStubs/pull/260) so as can be removed to simplify this expression :) . The problem with that approach is that dictionaries have no guaranteed order (and that's the whole point of your PR). So there's no guarantee that Swift won't make all those dictionaries exactly the same internally, and then making the JSON serialized version of all those exactly the same (e.g. one might even imagine that JSONSerialization.data(withJSONObject:) is implemented so that it iterates over the dictionaries' keys in alphabetical order\u2026 who knows\u2026)\nTo solve that, I think you'll instead need to use the already-converted-to-JSON String representations as a test set instead.\nWhich would have the additional benefit of proving that your matcher is also robust against different indentations of JSON bodies.\nOne way to do that is to use string literals of JSON representations to test\nlet jsonObjects = [\n  \"{ \\\"foo\\\": \\\"bar\\\", \\n\\\"baz\\\": 42,      \\\"qux\\\": true }\",\n\u2026\nBut for readability of the unit tests, maybe outsourcing those texts/JSON representation in fixture files would be nicer.. Same idea here of course. I was actually thinking about it the other day. The way we implemented it is that when there is a redirect, we do redirect with the same body as the original. That's the whole point of your PR. That's what you implemented. When there's a 301, we redirect to the new URL but with the original request's body. So that's our implementation after all.\nSo it's logical, from that implementation we did, that, whatever body we return in the redirection response, our implementation redirects to the new URL with the original body after all \ud83d\ude09 \nMore than that, I think in our reasoning for those tests we confused the request and the response. In the real world, when you post a request to the server with some http body B1, if the server returns a 301 response, that 301 response doesn't have any http body itself. It's the server's redirect response after all\nSo in our specific context:\n\nthe first stub should just return an OHHTTPStubsResponse with status code 301 (and no http body whatsoever, that body would be ignored anyway, and we respect the RFC on that)\nthen the second stub is supposed to be the final response that the server would return, when queried on the redirected URL with that original body. So there we could make our fake response to be some JSON wrapping the original body in that case (like if we had a real server whose only role was to echo what we send to it, just wrapped inside a JSON). Yup, exactly \ud83d\udc4d . Nitpicking, but just realized: why make that an array of tuples, instead of a Dictionary?\n\nWouldn't change a thing in your for loop below, but would be more common Swift and would make it order-independent.. Oh I didn't realize you used some test input strings multiple times, good point. I think all redirect responses are supposed to have an empty body. You can probably use our request.ohhttpstubs_HTTPBody extension there instead of reading the stream and then avoid this whole else block?. Curious why you used NSJSONSerialization for going from Data to JSON on line 143 but used NSKeyedArchived(and not NSJSONSerialization dataFromJSONObject) to go the other way around?\nAlso, you might just use the base64 of the body instead of deserializing it (in case that original body is not actual JSON for example it would still work). No problem. Just hope you saw I took a stab at it so it's implemented now\u2026 and so we've swapped roles then, as it'll be your turn to review \ud83d\ude01\nGood luck with work. pinging \ud83d\ude09 . Good point, fixed.. Please just use a new ## Master section for now instead of a future version number as we don't know when we'll release a new version and what its number will be yet.\n(besides, your PR adds a feature, while bumping the 3rd number of a version means fixing a bug, and new feature requires bumping the minor version number not the patch \u2014 read https://semver.org if you like to learn more). You can revert this change, my scripts will take care of updating the podspec with the future version number when we decide to release a new version and determine what that version number should be \ud83d\ude09. \ud83d\udc4d Good test set. Please rename that file appropriately for consistency :wink:. Maybe at this point we'd just state \"from 2.2 to 4.2\"\u2026 although I'm not sure that's really true. We might have dropped 2.x support at some point and forgot about updating that part of the README maybe? Would be good to check if we're still compatible with 2.x\u2026 or remove that from the sentence altogether as probably nobody uses 2.2 anymore\u2026. It would be nice to add a compatibility alias so that the code would still compile with older Xcode\nSomething like:\n```\nif !swift(>=4.2)\nextension UIApplication {\n  static let LaunchOptionKey = UIApplicationLaunchOptionKey\n}\nendif\n```. I wonder if that's still true?\niirc, that worked because Xcode 7 didn't know about (thus ignored) the SWIFT_VERSION=3.0 build setting and thus used 2.2, while Xcode 8 took it into account and used it.\nBut now that Xcode 8, 9 and 10 all know about SWIFT_VERSION and use it, I wonder what happens if we try to build a project with SWIFT_VERSION=4.2 using an earlier Xcode which doesn't know that version of Swift? Does it error? Does it fallback to the latest version of Swift it knows?\nAs a consequence, wouldn't that change risk that OHHTTPStubs wouldn't be compatible with earlier Xcode versions especially if integrated with Carthage, which uses the Xcode project to build the framework?\nAny Carthage user have an idea about that? @ikesyo maybe?. That means that the library itself is compatible with Swift 4.2 \ud83d\udc4d but as a result it could be worth updating the OHHTTPStubs.podspec to add that s.swift_version to the list \ud83d\ude09. Mmmh I see we actually never added that s.swift_version line to the podspec actually\u2026 might be the occasion to do so then\nhttp://blog.cocoapods.org/CocoaPods-1.4.0/#swift-version-dsl. I haven't tested, but I think this change would need a extension UIApplication { typealias LaunchOptionKey = UIApplicationLaunchOptionKey } inside some #if swift(>\u2026) to be able to still work with older Swift versions which did not have the new namespacing of that type before?. Not sure that really matters in practice in our case but shouldn't we used $(inherited) in that definition? (I think the default in Xcode is GCC_PREPROCESSOR_DEFINITIONS=DEBUG=1 in debug \u2014 while it's empty in release \u2014 so not using $(inherited) here means that debug builds don't have DEBUG=1 set anymore? Not that we currently use #if DEBUG in OHHTTPStubs as far as I know but just for configuration consistency\u2026. (Just because I like nitpicking: this feels a bit packed, so if you have the occasion of a new commit in this PR, adding an extra empty line to separate the endif and the next function while you're at it might help us breathe \ud83d\ude05). Strange that it magically inherit project settings indeed \ud83e\uddd0\nMoving DEBUG=1 in the xcconfig file makes sense, but would require two separate xcconfig files then (one for each config), just wondering if that's worth it \ud83e\udd14. Let's try $(inherited) at least for consistency, and validate it still works as expected (eg doesn't double-define DEBUG=1 in the resolved build settings after all). I'm happy surprised that the space character added in there doesn't break anything btw \ud83d\ude05 I guess I properly remembered in the CI config file to use quotes around \"$RAKETASK\" when incoming take, pfew \ud83d\ude04. This could maybe be a for header in @[@\"\u2026\",@\"\u2026\",\u2026] loop instead?. Just because if, say, we change the implementation one day and accidentally make the new implementation behave ( wrongly) as \"remove all headers but the last\" or \"only keep one header\" (instead of doing what it's supposed to do like today), I would try to put one or two more \"headers to be preserved\" in there and intertwine them in the middle of that list instead of all in the end \ud83d\ude09 #paranoiaModeOn. Oh good point!\nThough I suspect that dictionary literals, even though they don't guarantee order by contract as it's not a expected requirement for dicts, might end up always being iterated in the same deterministic order in practice (because of current implantation details of dictionary literals in ObjC)?. At that point maybe it's not worth it to list them all as it'll get pretty long \ud83d\ude05, maybe just 2.3 to 4.2 or 2.x & 3.x & 4.x?. Might be nice to also reference all the people who submitted a PR for updating to all those successive Xcode/Swift versions (even though we ended up not merging then because I was so late on my OSS time to merge them but since they made the effort\u2026). \ud83d\ude05 Good old times \ud83d\ude04. We should mention that minimum certain requirement bump in the CHANGELOG too, after all it's a breaking change. Would be interesting to mention that only 4.x+ is tested on CI so 2.3 compatibility for example isn't guaranteed by tests and might break at any time because we don't test it anymore.\n(Might actually be simpler to just drop the mention of 2.x altogether anyway and stop mentioning it tbh). Might also add well remove the paragraph about 2.3 too here and make that paragraph about 3.x just replace it (instead of being in addition of it).\nAlso I'm not sure we did Swift-3.x branches back in the day, branches was just used during the 2 to 3 transition. So might just as well start that paragraph directly with \"If you want\u2026\". I usually only declare the typealias for old versions so that by the time we drop those old version we'll only have to delete the typealias \ud83d\ude09\n```swift\nif !swift(>=4.0)\nextension UIApplication {\n  typealias LaunchOptionKey = UIApplicationLaunchOptionKey\n}\nendif\n```. ",
    "stanislaw": "\nThere is a possibility to remove all handlers using removeAllHandlers.\n\nI will try to use it. I am new to ios so I still don't know how fx GHUnit runs tests - it seems to do it synchronously - one by one, so removeAllHandlers should be ok, I hope.\nAnyway, an option to remove individual handlers seems to be nice to have too.\nThanks.\n. Great! Thanks!\n. +1 for this.\n. Thanks, indeed ;)\n. Great! Thanks!\n. Sorry about the large number of text and quotations following - this was one of the trickiest things I've learned since I've run into iOS development, so I think it deserves all that.\nBesides this issue with [NSURLConnection sendSynchronousRequest:returningResponse:error:], I think, there is more common issue related to any 'forced-synchronous' method (see below) containing the dispatches to the main queue.\nLet's consider the most interesting example: applying your OHHTTPStubs to the testing of net requests. Originally I've discovered this issue when I was using these three tools together: AFNetworking + GHUnit + OHHTTPStubs:\nTo test any net request (synchronous or asynchronous net requests or any probably asynchronous methods with non-strict, curly flow) the single unit test case must always implement the flow which could be called forced-synchronous - meaning \"straightening the flow of non-strict methods\" - we should run the request, we want to test, and block the flow of a test case while the net request is being processed and continue it only when the success (or failure) callback of net request is done, like that:\n``` objective-c\n- (void) test_somePossiblyAsynchronousOrCurlyFlowedMethod {\n    runSomethingPossiblyAsynchronousWithCompletionHandler:^{\n        // some test assertions\n        // ....\n        someCodeThatUnlocksCurrentThreadAndFinishesTests();\n    }\nsomeCodeThatBlocksCurrentThread();\n\n// some test assertions\n\n}\n```\nThe problem raises when a test of this kind is run on the main thread and at the same time the code inside its runSomethingPossiblyAsynchronousWithCompletionHandler block contains any dispatching to the main queue resulting in something like: we do lock something that is already locked.\nThe most important thing about dispatch_get_main_queue() is that it allows the behavior none of the any other kinds of queues allows: the flow is not really locked (call it soft-locked) if we continue running the main loop after we locked the flow waiting for the tasks scheduled to main queue are run. I will say it again loudly: this is impossible with any other queue other than main.\nThis specific behavior of main queue is summarized in http://stackoverflow.com/questions/7817605/pattern-for-unit-testing-async-queue-that-calls-main-queue-on-completion:\n\"\n In the COMPATIBILITY section of the dispatch_main man page, it says this:\nCocoa applications need not call dispatch_main(). Blocks submitted to the main queue will be executed as part of the \"common modes\" of the application's main NSRunLoop or CFRunLoop.\nIn other words, if you're in a Cocoa app, the dispatch queue is drained by the main thread's NSRunLoop. So all we need to do is keep the run loop running while we're waiting for the test to finish. It looks like this:\n``` objective-c\n- (void)testDoSomething {\n__block BOOL hasCalledBack = NO;\n\nvoid (^completionBlock)(void) = ^(void){        \n    NSLog(@\"Completion Block!\");\n    hasCalledBack = YES;\n};\n\n[MyObject doSomethingAsyncThenRunCompletionBlockOnMainQueue:completionBlock];\n\n// Repeatedly process events in the run loop until we see the callback run.\n\n// This code will wait for up to 10 seconds for something to come through\n// on the main queue before it times out. If your tests need longer than\n// that, bump up the time limit. Giving it a timeout like this means your\n// tests won't hang indefinitely.\n\n// -[NSRunLoop runMode:beforeDate:] always processes exactly one event or\n// returns after timing out.\n\nNSDate *loopUntil = [NSDate dateWithTimeIntervalSinceNow:10];\nwhile (hasCalledBack == NO && [loopUntil timeIntervalSinceNow] > 0) {\n    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode\n                             beforeDate:loopUntil];\n}\n\nif (!hasCalledBack)\n{\n    STFail(@\"I know this will fail, thanks\");\n}\n\n}\n```\n\"\nAnd now the working solutions code:\nI) https://github.com/AFNetworking/AFNetworking/issues/466#issuecomment-7917445\n``` objective-c\n@property (nonatomic, strong) dispatch_semaphore_t semaphore;\n// and these two methods\n\n\n(void)runTestWithBlock:(void (^)(void))block {\n    self.semaphore = dispatch_semaphore_create(0);\nblock();\nwhile (dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_NOW))\n    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode\n                             beforeDate:[NSDate dateWithTimeIntervalSinceNow:2]];\ndispatch_release(self.semaphore);\n}\n\n\n(void)blockTestCompletedWithBlock:(void (^)(void))block {\n    dispatch_semaphore_signal(self.semaphore);\nif (block) {\n    block();\n}\n}\n\n\nand the test is executed with\n[self runTestWithBlock:^{\n    [[APIClient sharedClient] getPath:@\"timezoneJSON\" parameters:nil success:^(AFHTTPRequestOperation operation, id JSON) {\n        [self blockTestCompletedWithBlock:^{\n            NSLog(@\"\\nSuccess\");\n        }];\n    } failure:^(AFHTTPRequestOperation operation, NSError *error) {\n        [self blockTestCompletedWithBlock:^{\n            NSLog(@\"\\nSuccess\");\n        }];\n    }];\n}];\n```\n\"\nII) The code GHUnit uses for async tests (too long to quote here - see - waitForStatus:timeout: there): https://github.com/gabriel/gh-unit/blob/master/Classes/GHAsyncTestCase.m\nIII) The code I use currently for my unit tests is a variation of I):\n``` objective-c\n@property (nonatomic, strong) dispatch_semaphore_t semaphore;\n// and these two methods\n\n\n(void)runTestWithBlock:(void (^)(void))block {\n    self.semaphore = dispatch_semaphore_create(0);\nblock();\nwhile (dispatch_semaphore_wait(_semaphore, DISPATCH_TIME_NOW))\n    CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0, YES);\ndispatch_release(self.semaphore);\n}\n\n\n(void)blockTestCompletedWithBlock:(void (^)(void))block {\n    dispatch_semaphore_signal(self.semaphore);\nif (block) {\n    block();\n}\n}\n```\n\n\nThis is the project I've extracted this logic to: https://github.com/stanislaw/SACompositeOperations/blob/master/SACompositeOperations/SASyncOperation.m\nAfter the all above is written I can say that the two things could be done by you:\n1) You could carefully inject the running of the main run loop, so it could drain the locking startLoading method and thus unfreeze the flow.\n2) Write a note on README pointing to this issue, because I find this information about the main queue behavior and using OHHTTPStubs in unit tests very important. I even think OHHTTPStubs deserves a separate blog article revealing all this stuff.\nThanks for your work on OHHTTPStubs. I hope I did not produce a noise but rather a useful tip to solve this issue.\n. I hope it is clear and obvious that I mean your dispatch_after(popTime, dispatch_get_main_queue(), ^(void) {...} block being exactly this forced-synchronous kind of operation I described above. \n. By the way, your nice OHHTTPStubs project could get a solid test coverage (SenTestingKit, GHUnit or whatever). \nIf the test code was already present, I'd suggest a pull request proving my thoughts - I just don't want to create \"one-issue project\" demonstrating the present behavior and needed behavior this issue addresses.\nWhy not setup a test infrastructure and write a test case reproducing this issue? I can work with you on this issue if you'd like.\n. OK, now I know for sure you are aware about the main queue/run loop issue ;). Would be interesting to see with what you will come up with.\n\nI am clearly interested in some test coverage for OHHTTPStubs !\n\nI am willing to assist but maybe you setup some basic infrastructure: choose test framework, setup test project to run the test suite against? I am not sure I could do this initial stuff for you.\n. Ah, thanks! I overlooked this -recordingForRequest part. Seems really simple now. I did switch from acceptance testing stuff for a while, I will look at this closer later. \nI am closing this issue for now. \nAnyway, let me know, if you will have any insights about using OHHTTPStubs together with VCR.\n. ",
    "rulien": "Thanks :-)\n. ",
    "netbe": "In my opinion, you should not have OHHTTPStubs code in you real app, only in the tests target, check where your headers are included.\n. ",
    "jcole": "Thanks -- I thought I did follow the instructions on the wiki for only adding it to the Test target, but it's certainly possible I screwed that up.\n. ",
    "aceysmith": "Is this still an issue? It appears that the mentioned initializer isn't used anymore. Is there any other private API use with this library? I'd like to switch to including OHHTTPStubs via cocoapods, but cocoapods doesn't have conditional linking based on build configurations quite yet.\n. ",
    "wolverian": "Thank you! That fixed my tests. Thanks for the great support.\n. ",
    "squarefrog": "Thanks for the detailed reply. Would it be possible to use the second method to capture the URL, and block the API call? Perhaps by returning nil for the stubResponse?\nFor these specific tests I am only concerned that the correct URL and method are being used in accordance with the API documentation. It is not a test of returned data handling.  Thanks again. \nI should also point out that my current implementation works, but it seems 0.2s per test is quite slow.\n. I used 0.1 initially changing from 1.0 just to check to see if it affected the timing of the tests, which it did not. I wondered if there was some latency being introduced by returning the fake object.\nI tried with [OHHTTPStubsResponse responseWithData:nil statusCode:200 responseTime:0 headers:nil] and it seems like 0.204s per test seems lowest we can get. Not to worry, it's still quicker than hammering the API. \nThanks for taking the time to answer my question. Keep up the good work.\n. These are automated Unit Tests run from within Xcode. \n. The time (0.2s) is the same for the new method too:\nobjective-c\n[OHHTTPStubs shouldStubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n    url = request.URL;\n    method = request.HTTPMethod;\n    return YES;\n} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {\n    return [OHHTTPStubsResponse responseWithData:nil statusCode:200 responseTime:0.0 headers:nil];\n}];\n. That's a great idea! Thank you for talking this through with me. Cheers!\n. ",
    "Dino4674": "I just added the .m files also and voila.\n. ",
    "hborders": "Going to update with a different commit that uses the timeout when redirecting.\n. Going to rebase this off of other dependent pull requests.\n. Sorry, screwed up the commit.\n. I tried to implement a stepwise responder object, but NSURLProtocolClient won't send the corresponding methods to NSURLConnectionDelegate immediately, so the whole idea can't work. This is the best we can do.\n. ",
    "toto": ":+1:\n. ",
    "jk": ":+1: \n. ",
    "stigi": "sweet. thanks @AliSoftware!\n. @343max :+1: :bow: \n. ",
    "kcharwood": "@AliSoftware Any thoughts on this?\n. Thanks. I expect there will probably be a little churn on this based on your preferences for the method names/parameters, but hopefully its just about all the way there. Let me know if you have any questions.\n:beers:\n. Awesome. Unfortunately I'm leaving the office right now to head out on vacation for five days, so I won't be able to give it thorough read through until next week.\n:beers:\n. Just gave a quick readthrough of your branch. It's looking good to me.\nFor responseTime==0, we should just send the whole stream back at once. You may want to add a note saying doing this with a large file forces the whole file to be loaded before it can be returned.\n. I put it there since a redirect should \"take longer\", but there is no other reason than that. I was a little unclear how you handle redirects, and we dont have them in our app, so just taking a stab in the dark.\n. ",
    "monishsyed": "@AliSoftware Thanks for your valuable feedback. Below are my responses:\n1 Fixed the build. Now checking for hosts count. If the host count > 0 and isHostRequest == NO, it should not stub the request.\n2 As a developer, i'd be more interested to set only whitelist hosts. Secondly, the app should not depend on any external factors that may break the build or tests in future.\n3 I don't want to use URL.host as their could be various services on the same host that the app may be consuming also if the URL doesn't conforms to rfc 1808, then this may not work. I think my point was to register baseURLs and not hosts. May be i need to change the name of the methods and properties such that it doesn't use \"host\". Suggestions ?\nThe sole purpose of adding this feature is that, while there is a way to conditionally configure the stubs, it may take a while for a new developer to understand the reason of not functioning of stubs when he tries to integrate a new third party library. Secondly, currently a developer needs to do this configuration everytime he/she defines a new request handler. Just a thought :)\nI'll add tests for this feature in a new PR. Let me know if you agree with the above points.\n. @AliSoftware Thanks for highlighting these issues. The first time i used OHHTTPStub, i was returning YES for all the request until i figured out that the boiler plate code i used to setup the project has some third party libraries already setup and due to that an exception was raised. It took a while for me to figure out the exact issue. Thats the reason i felt we should have a list of whiteListBaseURLS. Secondly, since most of the apps use some third party libraries which in turn makes a http request, i felt that having a whiteListBaseURL will help developers to not write the same code again and again when i could be done in the OHHTTPStub itself. But i do understand the problem with this approach and i'll probably think of something else. Closing the PR.\nThanks :)\n. ",
    "jkrall": "+1 for getting OHHTTPStubs working with  NSURLSessionDataTask and AFNetworking 2.0 ... unfortunately, we can't use this library on our project until that lands.\nHow can I help?\n. BTW... just found this fork:  https://github.com/ndonald2/OHHTTPStubs/commit/107faaab8442937f00e4c8deacb62fa056977413\nLooks like it works great.  (though it does require that you inject the sessionConfiguration into the creating of the AFHTTPSessionManager, or the underlying NSURLSession... see the test coverage on that fork's commit)\n. ",
    "ndonald2": "I will try to get a pull request in sometime today.\nAs @jkrall mentioned there are a few caveats. NSURLSession handles NSURLProtocol via its NSURLSessionConfiguration, which must be configured before initializing the session, regardless of whether using AFNetworking or vanilla NSURLSession - it won't work if you change the configuration later. \nAlso, the static library for OHHTTPStubs is targeting 5.0, so the new stuff I added won't even be compiled unless that is changed to 7.0 for a particular project (I wrapped it in an #ifdef for min required > 7.0). I debated whether to do that or not, but I figured that for the few months people may still be building against the 6.0 SDK. That's how AFNetworking handles the NSURLSession additions, too, so it seems to be standard practice.\n. @AliSoftware Thanks for taking a look, I will try to fix up these few things and push here.\n. Also I'm not sure why the Travis build check is failing - does it not support iOS7 yet?\n. @AliSoftware Made the changes you pointed out, ready for another review. Thanks!\n. I'm personally not a fan of method swizzling in all but rare cases. It breaks expectation and creates mystery behaviors to anyone unfamiliar with Obj-C's dynamic runtime.\nThat being said, it would be nice to be able to automatically enable stubs for the default sessions, so it may be worth the risk here if it's very well-documented.\n. That makes total sense. I copied and pasted the macro from AFNetworking, so I'm not sure why it wasn't done the way you describe here. I can change it.\n. @AliSoftware thanks for the tip. That method actually had a bug where the headers were not set correctly if you pass nil, but I fixed it in my pull request branch.\n. > I am wondering, does this protocolClasses property of NSURLSessionConfiguration means that +[NSURLProtocol registerClass] only has effects on requests sent via NSURLConnection\nThat seems to be the case, yes. As far as I understand it, NSURLSession is designed to be a session \"container\" of sorts for managing all network traffic sent through it, therefore it is designed such that no globally shared networking mechanisms affect a particular session instance (except the default session). I don't see this as a bad thing, though - it's really powerful for managing discrete networking sessions, say for a particular API or set of API routes out of several with which an app is communicating.\nHowever, registerClass: does work with [NSURLSession sharedSession], so it makes sense that the shared session is designed to stand-in for the previous global usage of NSURLConnection. I added a test for the shared session to my pull request branch. Because of this, I don't think it's necessary to do any swizzling - the stubbing will still work for people who just want to use the shared session. However, for AFNetworking, the shared session is never used, so the enabling per-configuration is still necessary.\n\nWhat if some NSURLProtocol subclass is listed in -[NSURLSessionConfiguration protocolClasses] array but was not registered using [NSURLProtocol registerClass:]? Does it still get used by NSURLSession because listed in protocolClasses, even if not registered?\n\nAs far as I can tell, yes - that is the new mechanism for registering a protocol. I commented out registerClass in OHHTTPStubs and it still works.\n. I think it's because [NSURLSession sharedSession] is the default session for the app, which is always created and initialized implicitly on application launch:\n\nThe shared session uses the currently set global NSURLCache, NSHTTPCookieStorage, and NSURLCredentialStorage objects and is based on the default configuration.\n\nTherefore any \"global\" Foundation networking methods, including [NSURLProtocol registerClass:], will affect the shared session.\nAlso since it is impossible to configure sharedSession with an instance of NSURLSessionConfiguration, there would otherwise be no way to register URLProtocol handler classes, since you cannot modify the configuration after the session is created:\n\nChanging mutable values within the configuration object has no effect on the current session, but you can create a new session with the modified configuration object.\n. \n",
    "nikolaykasyanov": "AFN2 can be used with 6.0+ deployment target, only NSURLSession-related part requires 7.0.\nBut this will require using CocoaPods instead of submodules.\n. ",
    "Goles": "I agree with you, closing :+1: \n. That's great to know @AliSoftware \n. @AliSoftware Thanks for the quick reply, \n@alvarezloaiciga I'm not using CocoaPods... I'm trying to integrate the library manually. I think the easiest thing is to provide you a link to the project. \nYou can go to HIAPIOperatorTests.m line 43 and run that test.\nYou can set a breakpoint in HIAPIRequests line 40 if you want to check the exact server response.\nHope this helps you out :)\n. Great! Let me know if I can help!\nSent from my iPhone\n\nOn Oct 11, 2013, at 2:14 PM, AliSoftware notifications@github.com wrote:\n@alvarezloaiciga Are you talking about an issue in CocoaPods, or an issue in OHHTTPStubs, for the case when it is on both targets?\n@Goles Thx I'll take a look!\n\u2014\nReply to this email directly or view it on GitHub.\n. Wow you guys are fast, will validate it asap.\n. @AliSoftware It's fixed, working fine now. :+1: \n. @AliSoftware Yeah, I just added the setEnabled:forSessionConfiguration because I was wondering if it was going to be helpful. I cleaned it up.\n\nOn a side-note, I was going to add the time-out thing too:\nobjective-c\n- (void)spinRunLoopWithTimeout:(NSTimeInterval)timeout predicate:(BOOL (^)())predicate\n{\n    NSDate *future = [NSDate dateWithTimeIntervalSinceNow:timeout];\n    while (predicate() == NO && [[NSDate date] earlierDate:future] != future) {\n        if ([future timeIntervalSinceNow] <= 0.0f) {\n            XCTFail(@\"Timeout...\");\n        }\n        CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0, YES);\n    }\n}\nI think this is better.\nThanks again for your help!\n. Lol, you're correct, pasted the wrong snippet ;)\n. @AliSoftware Hey there,\n``` objective-c\n    // Session property\n   @property (nonatomic, strong) NSURLSession *session;\n\n(void) setup {\n         NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];\n        _session = [NSURLSession sessionWithConfiguration:config];\n    }\n```\n\nThe uploadTasks are being stubbed, since I can actually see:\nRequest to https://website.com/image_upload has been stubbed with Image Upload OK\nAnd my stub looks like:\nobjective-c\n    /** Mock Image upload WS response */\n    [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n        return [request.URL.path isEqualToString:@\"/image_upload\"];\n    } withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {\n        return [[OHHTTPStubsResponse responseWithFileAtPath:OHPathForFileInBundle(@\"image_upload_ws_response.json\", nil)\n                                                 statusCode:201\n                                                    headers:@{@\"Content-Type\":@\"text/json\"}] responseTime:OHHTTPStubsDownloadSpeed3G];\n    }].name = @\"Image Upload OK\";\nI could even send you the project since it's still in early-stage, should the delegates be getting called?\n. @AliSoftware if you want to take a look to the code, you can check it out here.\nThe delegate methods are in HIAPIRequests.m , Line 104 and Line 116. You can set breakpoints there.\nYou could try to run the test case located in HIAPIOperatorTests.m Line 70, this test case will eventually try to upload images in the following method:\nobjective-c\n// HIAPIRequests.m line 37\n- (void)uploadImage:(UIImage *)image\n    completionBlock:(operationCompletionBlock)completionBlock\n      progressBlock:(operationProgressBlock)progressBlock\nThe delegate methods for NSURLSessionTaskDelegate are also located in HIAPIRequests.m\n``` objective-c\npragma mark - NSURLSessionTaskDelegate\n\n\n(void)URLSession:(NSURLSession )session\n              task:(NSURLSessionTask )task\n   didSendBodyData:(int64_t)bytesSent\n    totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend\n{\n    operationProgressBlock completionBlock = [_progressTable objectForKey:task];\nif (completionBlock) {\n    completionBlock(totalBytesSent/totalBytesExpectedToSend);\n}\n}\n\n\n(void)URLSession:(NSURLSession )session task:(NSURLSessionTask )task didCompleteWithError:(NSError *)error\n{\n    [_progressTable removeObjectForKey:task];\n}\n```\n. You're correct. Sorry for the hassle, \n\n\n_session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];\n. @AliSoftware \nI may be missing something here, but I added the above line in HIAPIRequests.m & Line 99\nobjective-c\n- (void)configureURLSession\n{\n    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];\n    _session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];\n}\nThe delegate methods are still not being called, is this expected behavior?\nPS: Another strange thing is that even though my upload speed is stated to be 3G, the 'image upload' seems to be instant.\n. Sure, will wrap it and submit a test project for you to review.\nCheers!\n. Ok, will do that!\n. Hey there!\nHaven't managed to debug my own code and write the test case yet! \nWill take a look at your test by Sunday and if I can write a non-passing test for OHHTTPStubs I'll do so!\nCheers and thanks for the heads-up!\nSent from my iPhone\n\nOn Oct 18, 2013, at 1:47 PM, AliSoftware notifications@github.com wrote:\nHi @Goles\nI don't know if you managed to debug your own code, but did some tests on my own and I also added a Unit Test to my own OHHTTPStubs project to test the use of NSURLSession delegates.\nAnd as you can see, the test is passing without any problem and the delegate methods are called as expected.\nThis should confirm that the issue you were having with your code was not related to OHHTTPStubs at all.\n\u2014\nReply to this email directly or view it on GitHub.\n. @AliSoftware \n\nHey there, wrote a small test case that shows that the progress delegate method is not getting called for an upload task, you can check it out here. Note that the test passes but the delegate method is not called.\nMaybe I'm missing something?\n. @AliSoftware Do you think it's still worthy to refactor and update my test? \nI could ask around, maybe there's another way we could do this.\nCheers!\n. This sounds like what @cvasilak experienced in issue #65 \n. @AliSoftware hey there. I'm experiencing the issue in the latest version of OHHTTPStubs. My test project is using the latest HEAD (as far as I know), I'm using the master branch.\nCooked the TestProject just to provide a proof of concept of the issue, hope it helps.\n. Thanks Ali, the main issue ended up being me forgetting to add the -ObjC flag... for some reason it got removed :+1: \nPS: Thanks for explaining me the new async testing API too ;)\n. I must +1 the petition of not dropping Carthage support :+1: \n. ",
    "alvarezloaiciga": "Yeah sorry, I am currently using 3.0.0. Just updated the issue up there. Seems like the issue is with the singleton, is it required to call setEnable:ForSessionConfiguration: before creating the sharedInstance?\n. According to what you have in the documentation:\na NSURLSession created using a NSURLSessionConfiguration and [NSURLSession sessionWithConfiguration:] (thanks\nto method swizzling that insert the private protocol used by OHHTTPStubs into the protocolClasses of \n[NSURLSessionConfiguration defaultSessionConfiguration] and [NSURLSessionConfiguration ephemeralSessionConfiguration] automagically)\nThe line in your test example:\nobjective-c\n[OHHTTPStubs setEnabled:YES forSessionConfiguration:sessionConfig];\nShouldn't be there if its enabled by default. Is there something special with NSURLSessionConfiguration?\n. Yep, that's correct. I am getting this array for the protocol classes:\nobjective-c\n(\n    OHHTTPStubsProtocol,\n    OHHTTPStubsProtocol\n)\nBut it is not doing the stub correctly, what should I print for you to know about the problem? Can we do hangout or something?\n. Everything correct but this line is returning nil so the condition is return false\nobjective-c\n[OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request]\nI think I found the issue, is in the singleton, when it adds the stub to the list it has this object as self\nobjective-c\n<OHHTTPStubs: 0xa0df3f0>\nBut when it is accesses sharedInstance in \nobjective-c\n[OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request]\nIts object id is:\nobjective-c\n<OHHTTPStubs: 0xa2bceb0>\n. Yes, just removed that the +setEnable and still the same. So this is what I got from the debugging:\n``` objective-c\n+(id)stubRequestsPassingTest:(OHHTTPStubsTestBlock)testBlock\n                                   withStubResponse:(OHHTTPStubsResponseBlock)responseBlock\n{\n    OHHTTPStubsDescriptor* stub = [OHHTTPStubsDescriptor stubDescriptorWithTestBlock:testBlock\n                                                                       responseBlock:responseBlock];\n    [OHHTTPStubs.sharedInstance addStub:stub];\n    NSLog(@\"%@\", OHHTTPStubs.sharedInstance) -> \n    return stub;\n}\n\n(BOOL)canInitWithRequest:(NSURLRequest *)request\n{\n    NSLog(@\"%@\", OHHTTPStubs.sharedInstance) -> \n    return ([OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request] != nil);\n}\n\n```\nSo its adding the stub to object A, but it is looking for that stub in object B.\n. Ok, got it. The problem is on concurrency.\nIt's actually getting a different sharedInstance when I am doing the waitForAsyncOperationWithTimeout. I took the parent class that has this method from your examples too.\nIs there a different way to make it wait for the block calls?\n. https://gist.github.com/alvarezloaiciga/6925055\nI gave it a good range of timeout but it should not affect.\n. Just to be able to reset the shareInstance on the tearDown\nAnd thanks so much for your help!\n. There is a way to reset it but I am not using it in this case. (I am actually reseting other singletons). You can move it to the method declaration to see if thats the issue.\n. can we have a quick hangout?\n. great, are you running the code in xcode 5? Cuz' you are using STAssert rather than XCT\n. It is working know, but I needed to remove the pod file and just added the xcode project to the workspace. So it might be related to the pod?\n. If you are using cocoapods there is an issue if you have the pod in both targets, so you should probably do:\nruby\ntarget :TargetTests, :exclusive => true do\n  pod 'OHHTTPStubs'\nend\n. ",
    "danpizz": "If for some reason you add the static OHHTTPStubs to both your project and your tests bundle, it will give you bad headaches because you'll end up with 2 bundles and 2 OHHTTPStubs singleton instances!\nThis explains the different instances address despite the dispatch_once call and the fact that the problem was resolved by removing the pod file.\nThis happens if you mess with pods, adding and removing XCode targets, because pod-generated static libs may get stuck and not removed by pod update or clean.\nI think it's better to add some documentation because it's a bad problem to trace down if you don't relize about multiple bundles.\n. ",
    "milosj": "You are creating a task with a completion handler, so the delegate will not be called.\n. ",
    "jspahrsummers": "Urgh, sorry. Opened this on the wrong repo. :worried: \n. ",
    "Abizern": "I'm using OHHTTPStubs 3.0.2\nI'm using AFNetworking2 with an AFHTTPSessionManager created with just a base URL - which use [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]\nI have three test files all using Specta and Expecta (the latest versions compatible with XCTest) Only one of the files uses OHHTTPStubs. In the very first before block I have:\n[OHHTTPStubs onStubActivation:^(NSURLRequest *request, id<OHHTTPStubsDescriptor> stub) {\n    NSLog(@\"\\n\\nStub activation for Request %@\\nstub %@\\nAll Stubs %@\\n\\n\", request, stub, [OHHTTPStubs allStubs]);\n}];\nI name all my stubs and when I run the test file as a standalone test (by clicking on the diamond in the gutter) it works properly, and the Logs are shown.\nFor each test context I have something like this:\n_successStub = [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n    return [request.URL.lastPathComponent isEqualToString:@\"venues\"];\n} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {\n    return [OHHTTPStubsResponse responseWithFileAtPath:OHPathForFileInBundle(@\"VenuesSuccess.json\", nil) statusCode:200 headers:httpHeaders];\n}];\n_successStub.name = @\"Success stub\";\nTo create and name the stubs. Again. This works when I run the file in isolation. I can but breakpoints on the two return lines and they are hit while running the tests.\nBut, if I run all the tests with cmd+u, which runs the two other test files, that do not use OHHTTPStubs, so are not enabling or disabling any stubs; then I am not seeing the logs from the onStubActivation``handler, nor are the breakpoints on the return lines being hit. Adding[OHHTTPStubs setEnabled:YES];` just above the stub test does not have any affect.\n. Okay - After creating a simple test example to try and reproduce the issue - I found the problem in my singleton initialiser.\nSorry, and thanks for this extremely helpful library.\n. ",
    "evanspa": "Thank you AliSoftware for the detailed response!  I will do that (use the comma-delimited syntax).  \nI would say though that a separate RFC speaks to cookies (RFC6265), and does indeed specify the wire format of having multiple \"Set-Cookie\" headers (also on Wikipedia).  I wonder if it's because the \"expires\" attribute value can contain a comma, making comma-delimeted cookies too cumbersome?  But I digress...  Thank you again for the detail answer.\n. I was also thrown because of my Java background - the HttpServletResponse interface treats cookies as 1st-class objects, with an API for explicitly being able to add multiple of them.  I guess I was expecting/hoping for iOS/OSX to do something similar.  Live and learn!\n. Ah yes - good point regarding the semicolon :smile:\n. ",
    "KyleLeneau": "I didn't really do anything with cocoa pods since I don't really use it.  However I did change the static iOS library and I added a mac framework library to the Xcode project file targets.  I also updated the iOS test target and added a mac text target to test the framework.  All in all the Xcode project files has 4 total targets: Mac framework, Mac test target that test framework, iOS static library, and iOS test target that tests the static library.\nI did not update or add an example Mac application or project and I did not test or update anything to do with the podfile.\n. ",
    "sibljon": "@AliSoftware Your suspicious were correct: the file patient_visit_review.json wasn't included in the test target. Thanks for your response, and sorry to waste your time... Hopefully someone in the future will find this thread helpful to make up for that!\nOh, and I almost forgot to thank you for such a wonderful library.\n. ",
    "bobbytables": "I'm experiencing the same issue with my project and have no idea why. I've NSLog'ed damn near everything and have not figured it out. So I'll contribute what I have since we're having the same issue.\niOS7\nAfnetworking 2.0.3\nOHHTTPStubs - 3.0.3\nI've subclassed like this:\n``` objc\n+ (instancetype)sharedClient {\n    static ROAAPIClient *_sharedClient = nil;\n    static dispatch_once_t onceToken;\ndispatch_once(&onceToken, ^{\n    NSURL *baseUrl = [NSURL URLWithString:API_BASEURL];\n    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];\n\n    _sharedClient = [[ROAAPIClient alloc] initWithBaseURL:baseUrl\n                                     sessionConfiguration:config];\n});\n\nreturn _sharedClient;\n\n}\n```\nI've setup my stub like this:\n``` objc\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) {\n        NSLog(@\"------- %@ %@\\n\\n\", request.URL.host, request.URL.path);\n        return [request.URL.path isEqualToString:@\"/oauth/token\"];\n    } withStubResponse:^OHHTTPStubsResponse(NSURLRequest *request) {\n        return [OHHTTPStubsResponse responseWithFileAtPath:OHPathForFileInBundle(@\"successfulClientCredentials.json\",nil)\n                                                statusCode:200 headers:@{@\"Content-Type\":@\"application/json\"}];\n    }];\n```\nI've logged OH hits like this:\nobjc\n[OHHTTPStubs onStubActivation:^(NSURLRequest *request, id<OHHTTPStubsDescriptor> stub) {\n        NSLog(@\"Hit stub for requested URL: %@\", [request.URL absoluteString]);\n    }];\nI've also included an NSLog in the method of my client class that fires off the HTTP request. It does happen, and the success blocks fire correctly as well.\n. I created this demonstration project to maybe help mitigate this efficiently https://github.com/bobbytables/ohhttpstubs_47_bug\nI'm logging out the response object, which when you run the tests, hits iTunes API (When it should be stubbed to return a json response file).\n. @brennon !!! Initialize your client after you setup the stub. Problem solved.\n. ",
    "brennon": "Added a TEST #define to my main app target so that in my creation of the AFHTTPSessionManager I now have this:\n```\n+ (instancetype)sharedClientWithBaseURL:(NSURL )url {\n    static SplashAPIClient sharedSplashAPIClient = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\nifdef SPLASH_TEST\n    [OHHTTPStubs setEnabled:YES];\n\nendif\n    sharedSplashAPIClient = [[self alloc] initWithBaseURL:url];\n});\nreturn sharedSplashAPIClient;\n\n}\n```\nI've confirmed that -[OHHTTPStubs setEnabled:] is being called with YES. However, now when the internals of AFNetworking now call +[NSURLSessionConfiguration defaultSessionConfiguration], this code in OHHTTPStubs+NSURLSessionConfiguration now acts up:\nstatic NSURLSessionConfiguration* OHHTTPStubs_defaultSessionConfiguration(id self, SEL _cmd)\n{\n    NSURLSessionConfiguration* config = orig_defaultSessionConfiguration(self,_cmd); // call original method\n    OHHTTPStubsAddProtocolClassToNSURLSessionConfiguration(config);\n    return config;\n}\nIn particular, the first line of the function body calls itself recursively, giving me a stack overflow... Am I missing something?\n. In fact, if the pod is compiled into the main target at all (irrespective of whether or not I actually make any calls to OHHTTPStubs), this happens.\n. Before I saw your message, I ripped out all the Pods and reinstalled them. Now, I can link against the library built from the Pod with no problem. However, now I am back to my original code. However, now this is the very first line of my app delegate's -application:didFinishLaunchingWithOptions::\n[OHHTTPStubs setEnabled:YES];\nStill, my stub (same as above) is not being called.\n. I wrote a pared down test to try to get a barebones failing scenario--now I'm back to the recursive swizzle...\nFrom app delegate:\n```\n- (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions\n{\nifdef SPLASH_TEST\n[OHHTTPStubs setEnabled:YES];\n\nendif\n// ...\n\n}\n```\nTest spec:\n```\nimport \"Specta.h\"\ndefine EXP_SHORTHAND\nimport \"Expecta.h\"\nimport \"OCMock.h\"\nimport \"SplashAPIClient.h\"\nimport \"OHHTTPStubs.h\"\nSpecBegin(SplashAPIClient)\nfdescribe(@\"SplashAPIClient\", ^{\ndescribe(@\"basic functionality\", ^{            \n    fit(@\"should pass a stupid test\", ^{\n        expect(YES).to.beTruthy();\n    });\n\n    fit(@\"should f---ing work\", ^{\n        AFHTTPSessionManager *localManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@\"http://www.github.com\"]];\n    });\n});\n\n});\nSpecEnd\n```\nStack trace for void _OHHTTPStubs_InstallNSURLSessionConfigurationMagicSupport() first call:\n```\nThread 1, Queue : com.apple.main-thread\n0  0x0007e96c in _OHHTTPStubs_InstallNSURLSessionConfigurationMagicSupport at /Users/brennon/Development/splash-ios/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubs+NSURLSessionConfiguration.m:69\n1  0x01c09275 in _class_initialize ()\n2  0x01c100f1 in lookUpImpOrForward ()\n3  0x01c1004e in _class_lookupMethodAndLoadCache3 ()\n```\nStack trace for static NSURLSessionConfiguration* OHHTTPStubs_defaultSessionConfiguration(id self, SEL _cmd) first call:\n```\nThread 1, Queue : com.apple.main-thread\n0  0x0007ea49 in OHHTTPStubs_defaultSessionConfiguration at /Users/brennon/Development/splash-ios/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubs+NSURLSessionConfiguration.m:55\n1  0x00075740 in -[AFURLSessionManager initWithSessionConfiguration:] at /Users/brennon/Development/splash-ios/Pods/AFNetworking/AFNetworking/AFURLSessionManager.m:294\n2  0x000608cb in -[AFHTTPSessionManager initWithBaseURL:sessionConfiguration:] at /Users/brennon/Development/splash-ios/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.m:70\n3  0x0006084a in -[AFHTTPSessionManager initWithBaseURL:] at /Users/brennon/Development/splash-ios/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.m:60\n4  0x000154e1 in -[SplashAPIClient initWithBaseURL:] at /Users/brennon/Development/splash-ios/splash/Source/Model/SplashAPIClient.m:33\n5  0x00015361 in __43+[SplashAPIClient sharedClientWithBaseURL:]_block_invoke at /Users/brennon/Development/splash-ios/splash/Source/Model/SplashAPIClient.m:27\n6  0x026f94b0 in _dispatch_client_callout ()\n7  0x026e8e17 in dispatch_once_f ()\n8  0x026e8d5c in dispatch_once ()\n9  0x00015242 in _dispatch_once [inlined] at /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.0.sdk/usr/include/dispatch/once.h:68\n10 0x000151e9 in +[SplashAPIClient sharedClientWithBaseURL:] at /Users/brennon/Development/splash-ios/splash/Source/Model/SplashAPIClient.m:26\n11 0x000150ef in +[SplashAPIClient sharedClient] at /Users/brennon/Development/splash-ios/splash/Source/Model/SplashAPIClient.m:20\n12 0x00034a22 in -[NearSplashesVC refreshSplashes] at /Users/brennon/Development/splash-ios/splash/Source/NearSplashesVC/NearSplashesVC.m:352\n13 0x00030a4f in -[NearSplashesVC mapView:regionDidChangeAnimated:] at /Users/brennon/Development/splash-ios/splash/Source/NearSplashesVC/NearSplashesVC.m:145\n14 0x00c39dc6 in -[MKMapView _didChangeRegionMidstream:] ()\n15 0x00c3bb11 in -[MKMapView _goToMapRegion:duration:animationType:resetHeading:] ()\n16 0x00c3c1e4 in -[MKMapView _setZoomScale:centerMapPoint:duration:animationType:resetHeading:] ()\n17 0x00c3b7c1 in -[MKMapView _setZoomScale:centerCoordinate:duration:animationType:resetHeading:] ()\n18 0x00c3e1e0 in -[MKMapView _goToCenterCoordinate:zoomLevel:animationType:cancelDefaultLocationTimer:] ()\n19 0x00c3d4f0 in -[MKMapView goToCenterCoordinate:zoomLevel:animationType:] ()\n20 0x00c41b3e in -[MKMapView goToRegion:animationType:] ()\n21 0x00c417a0 in -[MKMapView setRegion:animated:] ()\n22 0x0002f292 in -[NearSplashesVC viewDidLoad] at /Users/brennon/Development/splash-ios/splash/Source/NearSplashesVC/NearSplashesVC.m:56\n23 0x00eaf318 in -[UIViewController loadViewIfRequired] ()\n24 0x00eaf5b4 in -[UIViewController view] ()\n25 0x00ee63ae in -[UITabBarController transitionFromViewController:toViewController:transition:shouldSetSelected:] ()\n26 0x00ee5bd2 in -[UITabBarController transitionFromViewController:toViewController:] ()\n27 0x00ee1fbb in -[UITabBarController _setSelectedViewController:] ()\n28 0x00ee1de0 in -[UITabBarController setSelectedIndex:] ()\n29 0x00002955 in -[SplashController viewWillAppear:] at /Users/brennon/Development/splash-ios/splash/Source/SplashController.m:152\n30 0x00eb2bfa in -[UIViewController _setViewAppearState:isAnimating:] ()\n31 0x00eb3108 in -[UIViewController __viewWillAppear:] ()\n32 0x00eb40c7 in -[UIViewController viewWillMoveToWindow:] ()\n33 0x00df7384 in -[UIView(Hierarchy) _willMoveToWindow:withAncestorView:] ()\n34 0x00e02f60 in -[UIView(Internal) _addSubview:positioned:relativeTo:] ()\n35 0x00df69b1 in -[UIView(Hierarchy) addSubview:] ()\n36 0x00dd7bae in -[UIWindow addRootViewControllerViewIfPossible] ()\n37 0x00dd7d97 in -[UIWindow _setHidden:forced:] ()\n38 0x00dd802d in -[UIWindow _orderFrontWithoutMakingKey] ()\n39 0x0ffd1c66 in -[UIWindowAccessibility(SafeCategory) _orderFrontWithoutMakingKey] ()\n40 0x00de289a in -[UIWindow makeKeyAndVisible] ()\n41 0x00d95cd0 in -[UIApplication _callInitializationDelegatesForURL:payload:suspended:] ()\n42 0x00d9a3a8 in -[UIApplication _runWithURL:payload:launchOrientation:statusBarStyle:statusBarHidden:] ()\n43 0x00dae87c in -[UIApplication handleEvent:withNewEvent:] ()\n44 0x00daede9 in -[UIApplication sendEvent:] ()\n45 0x00d9c025 in _UIApplicationHandleEvent ()\n46 0x038ad2f6 in _PurpleEventCallback ()\n47 0x038ace01 in PurpleEventCallback ()\n48 0x01e00d65 in CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION ()\n49 0x01e00a9b in __CFRunLoopDoSource1 ()\n50 0x01e2b77c in __CFRunLoopRun ()\n51 0x01e2aac3 in CFRunLoopRunSpecific ()\n52 0x01e2a8db in CFRunLoopRunInMode ()\n53 0x00d99add in -[UIApplication _run] ()\n54 0x00d9bd3b in UIApplicationMain ()\n55 0x0003d2d5 in main at /Users/brennon/Development/splash-ios/splash/main.m:16\n```\nStack trace for void _OHHTTPStubs_InstallNSURLSessionConfigurationMagicSupport() second call:\n```\nThread 1, Queue : com.apple.main-thread\n0  0x0007e96c in _OHHTTPStubs_InstallNSURLSessionConfigurationMagicSupport at /Users/brennon/Development/splash-ios/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubs+NSURLSessionConfiguration.m:69\n1  0x01c09275 in _class_initialize ()\n2  0x01c100f1 in lookUpImpOrForward ()\n3  0x01c1004e in _class_lookupMethodAndLoadCache3 ()\n```\nStack trace for static NSURLSessionConfiguration* OHHTTPStubs_defaultSessionConfiguration(id self, SEL _cmd) second call:\n```\nThread 1, Queue : com.apple.main-thread\n0  0x0007ea49 in OHHTTPStubs_defaultSessionConfiguration at /Users/brennon/Development/splash-ios/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubs+NSURLSessionConfiguration.m:55\n1  0x09d30ed0 in -[AFURLSessionManager initWithSessionConfiguration:] at /Users/brennon/Development/splash-ios/Pods/AFNetworking/AFNetworking/AFURLSessionManager.m:294\n2  0x09d1c05b in -[AFHTTPSessionManager initWithBaseURL:sessionConfiguration:] at /Users/brennon/Development/splash-ios/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.m:70\n3  0x09d1bfda in -[AFHTTPSessionManager initWithBaseURL:] at /Users/brennon/Development/splash-ios/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager.m:60\n4  0x09d17bb1 in __37-[SplashAPIClientSpec spt_defineSpec]_block_invoke16 at /Users/brennon/Development/splash-ios/splashTests/SplashAPIClientSpec.m:70\n5  0x09d549c9 in runExampleBlock at /Users/brennon/Development/splash-ios/Pods/Specta/src/SPTExampleGroup.m:70\n6  0x09d55b4b in __48-[SPTExampleGroup compileExamplesWithNameStack:]_block_invoke at /Users/brennon/Development/splash-ios/Pods/Specta/src/SPTExampleGroup.m:308\n7  0x09d58c1a in -[SPTXCTestCase spt_runExampleAtIndex:] at /Users/brennon/Development/splash-ios/Pods/Specta/src/SPTXCTestCase.m:95\n8  0x01e79d1d in __invoking___ ()\n9  0x01e79c2a in -[NSInvocation invoke] ()\n10 0x201032bf in -[XCTestCase invokeTest] ()\n11 0x2010338d in -[XCTestCase performTest:] ()\n12 0x09d592d7 in -[SPTXCTestCase performTest:] at /Users/brennon/Development/splash-ios/Pods/Specta/src/SPTXCTestCase.m:147\n13 0x2010417c in -[XCTest run] ()\n14 0x20102a44 in -[XCTestSuite performTest:] ()\n15 0x2010417c in -[XCTest run] ()\n16 0x20102a44 in -[XCTestSuite performTest:] ()\n17 0x2010417c in -[XCTest run] ()\n18 0x20102a44 in -[XCTestSuite performTest:] ()\n19 0x2010417c in -[XCTest run] ()\n20 0x20105aa1 in +[XCTestProbe runTests:] ()\n21 0x0066912c in __NSFireDelayedPerform ()\n22 0x01e43bd6 in CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION ()\n23 0x01e435bd in __CFRunLoopDoTimer ()\n24 0x01e2b628 in __CFRunLoopRun ()\n25 0x01e2aac3 in CFRunLoopRunSpecific ()\n26 0x01e2a8db in CFRunLoopRunInMode ()\n27 0x038ab9e2 in GSEventRunModal ()\n28 0x038ab809 in GSEventRun ()\n29 0x00d9bd3b in UIApplicationMain ()\n30 0x0003d2d5 in main at /Users/brennon/Development/splash-ios/splash/main.m:16\n```\n. Good grief...\nSo, based on the above, it appears that OHHTTPStubs chokes when being asked to swizzle more than one (the one in my subclass of AFHTTPSession existed, as well.)\nSo, I stripped everything down again to this simple test (this is the only one being run in the entire suite:\n```\n    fit(@\"should f---ing work\", ^{\n        __block BOOL stubWasCalled = NO;\n    [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n        return YES;\n    } withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {\n        NSData *data = [@\"workgoddammit\" dataUsingEncoding:NSUTF8StringEncoding];\n        return [OHHTTPStubsResponse responseWithData:data statusCode:200 headers:@{}];\n    }].name = @\"simple stub\";\n\n    DebugLog(@\"All stubs: %@\", [OHHTTPStubs allStubs]);\n\n    [OHHTTPStubs onStubActivation:^(NSURLRequest *request, id<OHHTTPStubsDescriptor> stub) {\n        stubWasCalled = YES;\n    }];\n\n    [[SplashAPIClient sharedClient] GET:@\"findSplashes.php\" parameters:nil success:^(NSURLSessionDataTask *task, id responseObject) {\n        DebugLog(@\"success\");\n    } failure:^(NSURLSessionDataTask *task, NSError *error) {\n        DebugLog(@\"failure\");\n    }];\n\n    expect(stubWasCalled).to.beTruthy();\n});\n\n```\nDebugLog() is just a wrapped for NSLog(). If I break on that first DebugLog(), I can see that the stub is registered with [OHHTTPStubs allStubs]. I can also see this:\n(lldb) po [SplashAPIClient sharedClient].session.configuration.protocolClasses\n<__NSArrayI 0x9b9b2e0>(\nOHHTTPStubsProtocol\n)\nSo, the NSURLSessionConfiguration used for sharedClient only reports OHHTTPStubsProtocol. And no, the stub still isn't being called...\n. Interestingly, if I place this test inside my app delegate's -application:didFinishLaunchingWithOptions:, and run the app target (not the test target), the stub is called:\n```\n__block BOOL stubWasCalled = NO;\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) {\n    return [request.URL.host isEqualToString:@\"github.com\"];\n} withStubResponse:^OHHTTPStubsResponse (NSURLRequest request) {\n    NSData data = [@\"stub response string\" dataUsingEncoding:NSUTF8StringEncoding];\n    return [OHHTTPStubsResponse responseWithData:data statusCode:200 headers:@{@\"Content-type\":@\"text/html\"}];\n}].name = @\"simple stub\";\nDebugLog(@\"All stubs: %@\", [OHHTTPStubs allStubs]);\n[OHHTTPStubs onStubActivation:^(NSURLRequest *request, id stub) {\n    stubWasCalled = YES;\n}];\nAFHTTPSessionManager *localManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@\"https://github.com\"]];\n[localManager GET:@\"/\" parameters:nil success:^(NSURLSessionDataTask task, id responseObject) {\n    DebugLog(@\"success\");\n} failure:^(NSURLSessionDataTask task, NSError *error) {\n    DebugLog(@\"failure\");\n}];\n```\n. For what it's worth, this is all I have to do in a test to descend into recursion hell\n[OHHTTPStubs class];\n[NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];\nAlso, if I comment out all mention of OHHTTPStubs in my own code, as confirmed by a workspace-wide find, void _OHHTTPStubs_InstallNSURLSessionConfigurationMagicSupport() is still called with the following stack trace:\n```\nThread 1, Queue : com.apple.main-thread\n0  0x00097f62 in _OHHTTPStubs_InstallNSURLSessionConfigurationMagicSupport at /Users/brennon/Development/splash-ios/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubs+NSURLSessionConfiguration.m:69\n1  0x000989a2 in +[OHHTTPStubs initialize] at /Users/brennon/Development/splash-ios/Pods/OHHTTPStubs/OHHTTPStubs/Sources/OHHTTPStubs.m:111\n2  0x01c27275 in _class_initialize ()\n3  0x01c2e0f1 in lookUpImpOrForward ()\n4  0x01c2e04e in _class_lookupMethodAndLoadCache3 ()\n```\nAny clues?\n. I can confirm that the recursive loop only occurs when the pod is included for my main app target, as well. When it is only linked into the test target, I have no problems.\nSo, now I'm back to my original problem. I can confirm that the stub is called if I initialize my AFHTTPSessionManager subclass inside the test before stubbing a request. However, this requires that I initialize a separate client and cannot test the functionality of my singleton client, as the singleton is initialized on app launch. I can't fire up OHHTTPStubs inside my main app code (recursive loop...), nor should I have to do so. Either approach requires me to modify production code for only testing purposes--something I shouldn't have to do. How does one use OHHTTPStubs with a singleton client like this otherwise, though?\n. Here you go: https://github.com/brennon/ohhttpstubs-issue47/. The commented-out test will not run as long as the OHHTTPStub pod is specified for the main target.\n. Sorry about that--I didn't commit add the pod-related files to the repository--have done so now...\nI can confirm that your changes in your current commit do fix the issues in the test repo that I referenced. I don't know if (but I assume that) they do fix the issue in my 'real' project.\nThis, however, doesn't really address the other issue that I mentioned... Where someone is in the situation that they use a singleton class for NSURLSession-related functionality, and they're doing GUI-related testing in their tests (which I'm doing), is there any way to do so without modifying production code? As it stands now, I have to create a different scheme that allows me to create a different preprocessor #define, that allows me to ensure that OHHTTPStubs is initialized before any NSURLSession-related calls in my tests. I'd really prefer to leave all of my production code pristine and keep all code required for testing in my test target, but as of now I really don't see any way to do that...\n. Seems to work now--thanks!\n. I see now that if I remove the stub after all tests, instead of after each test (even though there is only one test!), I have no problems running this test.\n. ",
    "samirGuerdah": "@AliSoftware  : if a subclass does not implement +initialize but its superclass does, then that superclass\u2019s +initialize will be invoked once per non-implementing subclass and once for itself.\nYou can find the detail. http://www.friday.com/bbum/2009/09/06/iniailize-can-be-executed-multiple-times-load-not-so-much/ \n. :+1: \n. Hi,\nThis will help you to do your tests the right way. \nhttps://github.com/AliSoftware/OHHTTPStubs/wiki/OHHTTPStubs-and-asynchronous-tests\n. :+1: \n. They are in UnitTests folder group. \nhttps://github.com/AliSoftware/OHHTTPStubs/tree/master/OHHTTPStubs/UnitTests/Async%20Tests%20Helper\n. Hello,\nYou have this linking error because you are referencing the OHHTTPStubs library in your test class \"ApiReportsForHouseTest\". Remove any reference to the OHHTTPStubs or add the dependency to the test target. (Be sure that all the source files imported in the ApiReportsForHouseTest class don't reference(import) any class from OHHTTPStubs library.) \n. Hello,\nI have tested the same code you have posted and the OHHTTPStubsResponse instance created is not nil.  Can you show more code how you are doing it ? \n. Hello,\nlet data = NSData()\nXCTAssertEqual(data.lenth, 0)\nThe data object is not nil but it contains no data :). \nJust test if the length of the body is equal to 0, hope that i answered your question :). \n(In OHHTTPStubsResponse i think that you can test with the dataSize property if it's equal to 0 or no).\n. Hello,\nImport the corresponding source files :\n```\nimport \nimport \n```\n. I think that you should check the return value of the method getResourceValue and not the error and check also the availability of the property NSURLFileSizeKey if the method returns success. \nFrom the Apple Documentation:\n\"If this method returns YES and the value is populated with nil, it means that the resource property is not available for the specified resource, and that no errors occurred when determining that the resource property was unavailable.\"\nobjective-c\nBOOL success = [fileURL getResource...]\nif (success && fileSize) { }\nelse {} // Populate with [NSData data]\n. ",
    "JustinDSN": "@brennon @AliSoftware \nCan you update the article on how to integrate OHHTTPStubs into your Test target and also use it to stub requests from the app target.  I'd like to add UISwitches to development builds of my app to turn on the stubbing behaviors when the app is running in the simulator and on a device.  I couldn't figure out how to do it from this issue.\nI would like to do exactly what you're doing in the demo project.  But the wiki pages said to NOT link the OHHTTPStubs project to your application target.  So there's a gap in the instructions on how to accomplish what the demo project does using the pod file.\nThank you,\nJustin\n. ",
    "nicolasmiari-unext": "I already have the host application set to \"None\" (I'm testing a Framework). \nThe test block is called for requests other than my own (e.g. host: static.realm.io), but not for mine. Instead, I get NSURLErrorCancelled...\nI am using a background session, but I am also calling \nOHHTTPStubs.setEnabled(true, for: myBackgroundSessionConfiguration)\n\nbefore setting up any stubs and before initializing the session.\n\nUpdate: I tried changing my session configuration to default and now the blocks (passingTest and stubResponse) are executed.\nEither the stubs don't work with background sessions, or my  code invalidating the background session on each test isn't working as expected... . @AliSoftware Thank you, I missed that.\nI'll be using the default session configuration for my unit tests (Can't unit-test background downloads anyway).. ",
    "ghost": "Awesome. Thanks!!\n. ",
    "pbernery": "Wow, thank you @AliSoftware for this comprehensive answer! :)\nThat's what I had in mind but wanted to be sure before continuing. Unfortunately, my project cannot have his tests executed in \"Unit Tests\" mode. It uses a library (closed, I don't have the source) that asserts on some things that I guess come with the initialization of an app. I may find a workaround for this issue though.\nAnyway, thank you again. I guess I can close this issue.\n. ",
    "marcelofabri": "I'll try to do it in tearDown. However, if a test fails with an exception, for example, tearDown is not executed, making my other tests run on a \"dirty\" environment (please correct me if I'm wrong). I'll try to make a sample project later today.\nI'm using Expecta on my project too, to test async behavior.\n. I made a small test with XCTest (running tests inside Xcode) and that was the conclusion I figured out.\nI created a XCTestCase like this:\n```\n@interface ExceptionTests : XCTestCase\n@end\n@implementation ExceptionTests\n\n(void)setUp {\n    [super setUp];\n    // Put setup code here. This method is called before the invocation of each test method in the class.\n\n}\n\n\n(void)tearDown {\n    // Put teardown code here. This method is called after the invocation of each test method in the class.\n    [super tearDown];\n    NSLog(@\"TEAR DOWN is called!\");\n}\n\n\n(void)testThrowException {\n    @throw [NSException exceptionWithName:@\"TestException\" reason:@\"Test\" userInfo:nil];\n}\n\n\n@end\n```\nIf I comment @throw, my log is printed, but if I let it the log is never printed (and tearDown is not called - I put I breakpoint on it too).\nI'm new to XCTest (and unit tests in general), so maybe I'm missing something.\n. I'm using Expecta's will matcher, with a timeout of 5s.\n. I think you were right about your idea: I have tests where I don't use will operator, because I'm not interested in the response - just on whether the request was built successfully.\nHowever, I wasn't able to isolate it to a sample example. Even on my regular project it's hard to reproduce the issue (I'd say less than 1% of times running the full test suite).\nPS: I was also able to reproduce the issue when removing the stubs on tearDown instead of setUp.\n. I've updated to the latest version but it seems that something is wrong \ud83d\ude2c \nswift\nlet x = request.ohhttpStubs_httpBody\nValue of type 'URLRequest' has no member 'ohhttpStubs_httpBody'\nHere's how I'm importing on my Podfile:\nruby\npod 'OHHTTPStubs', :subspecs => ['Default', 'Swift']\nMaybe it's happening because of this #if https://github.com/AliSoftware/OHHTTPStubs/blob/master/OHHTTPStubs/Sources/Swift/OHHTTPStubsSwift.swift#L31 ?\n. This is probably overkill, but we could have a SwiftNSURLSession subspec that imported Swift and NSURLSession subspecs + this extension. However this seems a lot of trouble just to avoid one typecast \ud83d\ude2c \n. Maybe we should revert that extension for now and think on a bigger subspecs reorganization. We can always make it a new major (6.0.0) so it'd be expected to have some breaking changes.\n. Thanks! \ud83d\udcaf \n. ",
    "dreed1": "i just wanted to chime in that I'm having the same exact problem, although I'm not trying to remove any stubs anywhere but my test suite teardown methods.\nI don't have time right now to write a reproducible project, but I'll try to make some in the next few days.\nI think you're right, that there's a race condition somewhere.\nI've got 4 test suites that all create their own stubs in the setup block, and remove them in the teardown. The last one gives me this null stub error.\nSomething like\n```\n@interface someTestSuite : XCTestCase {\n  id httpStub;\n}\n\n(void)setUp\n{\n  [super setUp];\n\n[OHHTTPStubs setEnabled:YES];\n  httpStub = [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest request) {\n    return YES;\n  } withStubResponse:^OHHTTPStubsResponse(NSURLRequest request) {\n    NSString stubPath = PATH_TO_A_JSON_FIXTURE;\n    if (stubPath != nil) {\n      return [OHHTTPStubsResponse responseWithFileAtPath:stubPath\n                                              statusCode:200\n                                                 headers:@{@\"Content-Type\":@\"text/json\"}];\n    }\n    return [OHHTTPStubsResponse responseWithData:nil\n                                      statusCode:200\n                                         headers:@{}];\n  }];\n}\n\n(void)tearDown\n{\n  [OHHTTPStubs removeStub:httpStub];\n  [super tearDown];\n}\n```\n\nand the stub fails that same assert: 'Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'At the time startLoading is called, canInitRequest should have assured that stub is != nil beforehand''. My stacktrace is exactly the same as above, except line 5 is my code instead of his.\nHopefully this helps a little... I'll see if I can get you something reproducible within a few days. I'm out of sprint time for bug resolutions for the week so I probably can't get to it until the weekend starts. Thanks for all the hard work, this is a great little library.\n. ",
    "duanefields": "I see the same symptoms, but I see it maybe 25% of the time, which smells like a race condition, when running \"all tests\".\n. @AliSoftware that turned out to be exactly the problem - I tear down the stub after each test, but some of the tests weren't waiting for the response to complete (because I didn't care about the result) which caused the race condition\n. ",
    "gfontenot": "Just want to chime in here and say that I'm seeing the exact same behavior. Using Specta/Expecta, the will matcher, NSURLSession, and clearing all stubs on tearDown via Specta's afterEach block.\n. fwiw, I had 0 synchronous expectations in my suite. Everything was using will, nothing used to. I was getting these issues returning a super simple bit of JSON data with a (default) 1 second timeout.\n. You're exactly right about the expected behavior there. I couldn't figure out what the hell was going on either. Let me see if I can come up with a super simple reproduction when I get home, and I'll throw it up somewhere that you can get to.\n. @AliSoftware Here's a test project I zipped up showing the exception.\nIt happens really intermittently, you may have to run it 10 or more times. After pruning it down to the essentials, it hit the exception on the second run, but then I had to run it ~12 times to hit the next assertion.\n. Nope, the more recent versions seem to have solved this particular issue.\nThe issues I'm talking about on twitter seem to be completely unrelated to OHTTPStubs. Pretty much grasping at straws for those.\n. ",
    "jpalten": "Thanks for the swift reply.\nWhat I\u2019m trying to do is this: I have a connection class, and I try to make this connection class send something to a server. My test checks to see if the connection class actually sends the correct post body to the server.\nI see the log was not complete, sorry about that. I got a new log here:\n2014-02-06 16:08:33.293 xctest[73384:303] preparing response for /admin/_cmdstat.jsp\n2014-02-06 16:08:33.297 xctest[73384:303] Posting request 0xe1c2540 with body: \n2014-02-06 16:08:33.336 xctest[73384:1b03] find stub for request 0x2828e90\n2014-02-06 16:08:33.338 xctest[73384:1b03] Stubbing url /admin/_cmdstat.jsp\n2014-02-06 16:08:33.340 xctest[73384:1b03] checking body of request 0x2828e90\n2014-02-06 16:08:33.341 xctest[73384:1b03] Would sent body: \n/Volumes/InternalHD/Projecten/ZoneDirectorViewer/ZoneDirectorViewer/Connection/ServerConnectionTests.m:551: error: -[ServerConnectionTests testGetSystemInfo] : ((requestedBody) equal to (expectedBody)) failed: (\"\") is not equal to (\"\")\nHere is my test code:\n- (void) testGetSystemInfo\n  {\n  NSString* requestBody = @\"\";\nNSData* stubbedResponse = [self loadFixtureNamed:@\"getstat-system-sysinfo.xml\"];\n  [self stubHttpRequestTo:@\"/admin/_cmdstat.jsp\" requestBody:requestBody response:stubbedResponse];\n__weak ServerConnectionTests* weakSelf = self;\n  [self.connection getSystemInfo:^(SystemInfo* systemInfo){\n      XCTAssertNotNil(systemInfo);\n      weakSelf.responseReceived = YES;\n      XCTAssertEqualObjects(systemInfo.name, @\"ZD-1100-01\");\n      XCTAssertEqualObjects(systemInfo.versionNum,@\"9.5.1.0\");\n      XCTAssertEqualObjects(systemInfo.model,@\"ZD1106\" );\n      XCTAssertEqualObjects(systemInfo.serial,@\"981323000617\" );\n      XCTAssertEqual(systemInfo.maxAps,6);\n  } failure:^(NSURLSessionTask operation, NSError error) {\n      XCTAssertNil(error,@\"get sys info failed wrong\");\n  }];\n[self waitForResponse];\n  XCTAssertTrue(self.responseReceived);\n  }\n- (void)stubHttpRequestTo:(NSString )expectedUrlPath requestBody:(NSString)expectedBody response:(NSData *)responseData {\nNSLog(@\"preparing response for %@\",expectedUrlPath);\n  __block BOOL alreadyTested = NO;\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n      NSLog(@\"Stubbing url %@\",request.URL.path);\n```\n  XCTAssertEqualObjects(request.URL.path, expectedUrlPath);\nif (!alreadyTested) {\n      NSLog(@\"checking body of request %p\",request);\n      NSString* requestedBody = [[NSString alloc] initWithData:request.HTTPBody encoding:NSUTF8StringEncoding];\n      NSLog(@\"Would sent body: %@\",requestedBody);\n      XCTAssertEqualObjects(requestedBody, expectedBody);\n  alreadyTested = YES;\n\n}\nreturn [request.URL.path isEqualToString:expectedUrlPath];\n  ```\n} withStubResponse:^OHHTTPStubsResponse (NSURLRequest request) {\n      NSDictionary *headers = @{@\"Content-Type\" : @\"application/json\"};\n      return [OHHTTPStubsResponse responseWithData:responseData statusCode:200 headers:headers];\n  }];\n  }\nHere is the production code:\n- (void)getSystemInfo:(SuccessBlock)success failure:(FailureBlock)failure {\n  [self getStatComponent:@\"system\" elementXml:@\"\" success:^(SystemInfo * systemInfo) {\n      [self.delegate connection:self receivedSystemInformation:systemInfo];\n      success(systemInfo);\n  } failure:^(NSURLSessionTask * operation, NSError * error) {\n      failure(operation,error);\n  }];\n  }\n- (void)getStatComponent:(NSString_)component elementXml:(NSString_)elementXml success:(SuccessBlock)success failure:(FailureBlock)failure {\n  NSString* url = @\"admin/_cmdstat.jsp\";\n  NSString* bodyString = [NSString stringWithFormat:@\"%@\",component,elementXml];\n[self ajaxCall:url request:bodyString success:success failure:failure];\n  }\n- (void)ajaxCall:(NSString )url request:(NSString )bodyString success:(SuccessBlock)success failure:(FailureBlock)failure {\n  return [self ajaxCall:url request:bodyString parser:nil  success:success failure:failure];\n  }\n- (void)ajaxCall:(NSString_)url request:(NSString_)bodyString parser:(ListParser*)parser success:(SuccessBlock)success failure:(FailureBlock)failure {\nvoid (^luckyHandling)(NSURLSessionTask_, NSData_) = ^(NSURLSessionTask operation,NSData responseData) {\n      [self.delegate request:operation.currentRequest returnedData:responseData];\n      id responseObject = [XmlResponseParser parseXml:responseData usingParser:parser];\n      [self.delegate request:operation.currentRequest returnedObject:responseObject];\n      if (success) {\n          success(responseObject);\n      }\n  };\nNSData* bodyData = [bodyString dataUsingEncoding:NSUTF8StringEncoding];\nif  ([self handledLocally:url requestBody:bodyData usingSuccessHandling:luckyHandling]) {\n      return;\n  };\nself.httpSession.requestSerializer = [[XmlRequestSerializer alloc] init];\n  self.httpSession.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@\"application/xml\",@\"text/xml\",nil];\n  self.httpSession.responseSerializer = [[XmlResponseSerializer alloc] init];\n[self.httpSession POST:url body:bodyData constructingBodyWithBlock:^(NSMutableURLRequest request) {\n      NSString sendingBody = [[NSString alloc] initWithData:[request HTTPBody] encoding:NSUTF8StringEncoding];\n      DDLogVerbose(@\"Posting request %p with body: %@\", request, sendingBody);\n  }       success:^(NSURLSessionTask operation, NSString responseString) {\n      DDLogVerbose(@\"get xml ok:\\n%@\",responseString);\n      NSData* responseData = [responseString dataUsingEncoding:NSUTF8StringEncoding];\n      luckyHandling(operation,responseData);\n  }       failure:^(NSURLSessionTask operation, NSError error) {\n      DDLogWarn(@\"error! %@\", error);\n      [self.delegate request:operation.currentRequest failedWithError:error];\n      failure(operation, error);\n  }];\n  }\nOp 6 feb. 2014, om 14:46 heeft AliSoftware notifications@github.com het volgende geschreven:\n\nSome code or a sample project maybe? More code, more info, etc? Logs are far from enough to help me debug this!\nWhat version of OHHTTPStubs are you using, are you sure you use the latest which fixes issues with automatic support of NSURLSession (thus AFHTTPSessionManager)?\nIt seems strange anyway regarding your logs that the log says \"Posting request 0xe1efbc0 with body:\" letting us suspect an empty body, and that your assertion states that both the request body and the expected body are empty \"\" (and that assertion fails maybe only because of different typing?) I see nowhere in your logs where you sent the XML.\nAnd finally it seems strange that you Unit test your request body (which is what you send, on which OHHTTPStubs does not have any control) instead of your response body (which is what OHHTTPStubs returns when you stubbed the request)?\nAnyway, more info is needed for me to help you on this.\n\u2014\nReply to this email directly or view it on GitHub.\n. It could be, but I don\u2019t really want to simulate data upload, I want to check the data that would be posted/uploaded. Would you like me to create a minimum app with unit tests to show what is going on? \n. This should clear things up: https://bitbucket.org/jpalten/subbertesting\n. I actually had to wrap my tests with \u201ealreadySeen\u201d flags\u2026 I felt stupid doing it.\n\nOp 11 feb. 2014, om 22:02 heeft Luca Bernardi notifications@github.com het volgende geschreven:\n\nYeah, the 3 times call drive me crazy. I take a look at the stack trace to be understand if it was a mistake of mine but it's seems that is only Apple that likes to mess with us ;)\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks for all the research and feedback. I\u2019ll poke Apple about it.\n\nJelle\nOp 7 feb. 2014, om 17:46 heeft AliSoftware notifications@github.com het volgende geschreven:\n\nI just tested your project.\nI commented your XCTAssertEqualObjects(requestedBody, expectedBody) and put some breakpoints to see what was going on.\nWhen iOS calls NSURLProtocol's canInitWithRequest: method for the first set of times (as part of the URL Loding System mechanism managed by iOS and the runtime), the request passed as a parameter does not have any HTTPBody (= nil) when called thru an NSURLSession.\nI believe the issue you are experimenting is not related to OHHTTPStubs but to how Apple's NSURLProtocol and NSURLSession works. This leads to NSURLProtocol's +canInitWithRequest: method to be called with a request with an empty HTTPBody, because HTTPBody and HTTPBodyStream properties are handled internally and specifically by Apple for the HTTP protocol (for the specific internal NSURLProtocol originally managing the \"http://\" scheme by Apple). This seems to be supported by various StackOverflow answers like url=http://stackoverflow.com/questions/9301611/using-a-custom-nsurlprotocol-with-uiwebview-and-post-requests.\nIf you put some symbolic breakpoints on Apple's +[NSURLProtocol canInitRequest:] method you can see that this is true regardless of whether you use OHHTTPStubs or not; the request passed to the NSURLProtocol will always have a nil HTTPBody.\nI don't really understand why Apple does this, using the HTTPBody only for requests managed by Apple's internal NSURLProtocol to handle http:// scheme but not to custom protocols\u2026 maybe you should file a bugreport to Apple directly about it.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "lukabernardi": "I encountered the same issue and I confirm that is an Apple's issue. A radar has been filled (http://openradar.appspot.com/15993891) feel free to dupe it.\n. In my test this is not happening with NSURLConnection (check out this test project http://cl.ly/TqlD)\n. Yeah, the 3 times call drive me crazy. I take a look at the stack trace to be understand if it was a mistake of mine but it's seems that is only Apple that likes to mess with us ;)\n. Yep, probably it depends on the underlaying implementation. Do we want to speak about the fact that +NSURLSession dataTaskWithURL: are acting like a class cluster and is returning a private object that is not even a subclass o NSURLSessionTask et al.?\n. Spoiler: the returned objects are all subclass of __NSCFURLSessionTask\nCheers\n. Personally I'm using a terrible hacking and be aware that I'm definitely not endorsing this and I can do that only in a project where I'm in control of the code that is actually building the NSURLRequest (AKA network library):\nI'm basically putting the HTTP body inside a custom HTTP header (X-Debug-HTTPBody), in this way I'm able to extract the header in the stubRequestsPassingTest:.\n. @AliSoftware that's definitely more cleaner solution. Thanks!\n. I have to be honest I came up with a solutions similar to the second one you proposed and I stopped because of the problems you listed. I'm afraid that at the moment I do not have a good idea on how to implement that, an this is also the reason why I've been a little generic in my first comment: I was trying to start sort of brainstorming. \nAnyway I'll keep a background thread running in my brain to see if I can came up with a proper solution.\nI think that is worth to keep this issue open so that other peoples can eventually partecipate to the discussion.\n. ",
    "DenTelezhkin": "Just to add some clarification. This happens only with NSURLSession. This is probably why Apple provides us access to currentRequest and originalRequest on NSURLSessionTasks objects. Seems like HTTPBody of originalRequest gets turned onto HTTPBodyStream on currentRequest.\nMy solution to this was never checking on HTTPBody inside stubRequestsPassingTest:WithStubResponse: method, but instead provide a separate test, that specifically checks HTTPBody property on NSURLSessionTask originalRequest. \n. @lukabernardi @cwagdev Better approach would be never checking on HTTPBody in stubRequestsPassingTest: method, and provide a separate test, that creates NSURLSessionDataTask, and checks for originalRequest.HTTPBody.\n. ",
    "cwagdev": "I was previously using HTTPBody to determine what type of XML-RPC Payload was sent in order to provide different OHHTTPStubsResponse's\nHow would I go about doing this now that I can no longer inspect the XML-RPC payload in the stubRequestsPassingTest: block?\n. Interesting approach! I could probably just include the XML-RPC method as a header in a similar fashion as it is all that I am interested. Thanks for the idea!\n. @DenHeadless I think what happened is that I effectively wrote integration tests. I am using OHHTTPStubs to return different XML responses based on the method being invoked. So it is effectively testing my client, xml creation, and xml parsing all together. Probably need to reduce this to actual unit tests instead.\n. :+1:  Thanks @AliSoftware !\n. ",
    "samskiter": "Hi, not using OHHTTPStubs, but stumbled into this while hitting exactly this issue myself. Found your discussion very useful for diagnosing the problem. Boiled it down and produced a project demonstrating the problem at it's simplest (and the difference between NSURLSession and NSURLConnection) - https://github.com/samskiter/testnsurlprotocol\nThanks for the information everyone and thanks @AliSoftware for the workaround\n. ",
    "newmanw": "Wow, really good explanation!  Thanks so much for taking to time to write that up. Framework works great in mocking URLs, thanks!\n. ",
    "cdzombak": ":+1:\n. :+1:. We're being bitten by what I think is this same issue.\n. > This issue was being hit quite frequently in our unit tests and this fix completely eliminates it. It only would get triggered about 5% of the time, but when unit tests are run ~500 times per day, those 25 failures are blocking for dev.\n@NSProgrammer that sounds exactly like what we're seeing. (cc @twigz)\n. > I can't find a way to create a failing Unit Test: I wrote a test that creates an NSURLConnection on a separate thread, and even before applying @NSProgrammer 's PR, the test still passes.\n\nHere is my unit test so far. Do any of you see anything wrong with that test? isn't it testing the right thing? Because it is passing, even before applying that fix so I'm wondering\u2026\nDo you guys have an actual example of when this fails for you, so I can get inspiration to write a proper test that would properly avoid regression once this fix is merged?\n\nAt my job we're seeing this hang only one in 50 or so times. Assuming the hanging is a direct result of this particular threading bug, it'll be hard to write a consistently-failing unit test for it :disappointed: \nThat test looks promising. I wonder, though, if it's possible to more directly test this requirement somehow\u2026\n\nIn addition, an NSURLProtocol subclass is expected to call the various methods of the NSURLProtocolClient protocol from the client thread\n\nIs there any way for the test to get the NSURLProtocolClient that's being used and assert directly that this holds true, rather than simply checking that the NSURLConnectionDelegate methods are being called from the same thread?\nThat might be a silly question, but I am not sure exactly how the NSURLProtocolClient is coupled to the NSURLConnectionDelegate.\n. > unfortunately I don't think we can access the NSURLProtocolClient from outside of the NSURLProtocol implementation itself, so it's probably hard to test this directly.\nThat's what I was afraid of\u2026\n\nOne way to properly test that directly could be to use mocks, e.g. using frameworks like OCMock to mock / add an \"expectation\" on calls to -[id<NSURLProtocolClient> URLProtocolDidFinishLoading] (and all other NSURLProtocolClient's methods), so that we can intercept those internal (= from OHHTTPStubs.m implementation) calls from outside (= from the Unit Test code). But I'm not sure I want to add a whole dependency framework like OCMock simply to test this case\u2026\n\nThis is what I was thinking initially\u2026yes, it's heavy-handed, but OCMock does seem like a possible answer. But then I wondered, can OCMock actually mock a method from a protocol like that? That's not something I've done before.\n. > Yeah I agree, given that NSURLProtocolClient is actually a protocol, not a class, I'm not sure either we can actually do that (it's ages I haven't used OCMock personally, maybe I'm wrong).\nYeah, I am pretty confident that doing this isn't possible with OCMock (though I would be happy to be proven wrong).\n\nWill try and investigate swizzling the methods myself, but unfortunately I'm quite sure we can't swizzle methods on a protocol, because we swizzle implementations so we need to know the class that implement it, and in our case it's a internal class private to Apple, but I may try anyway.\n\nIf you're going to tie the test to whatever private class implements this protocol, it may still be worth considering OCMock. I know it's a lot to add to the project, but swizzling methods yourself can be tedious. Obviously, up to you, but it might be a tradeoff worth considering.\n. @AliSoftware thank you!\n. ",
    "mremond": "Actually, I solved this issue with the following workaround. I wrap background NSURLSession create in  a try-catch and create a foreground session when the error happen in my app code.\nThis make it run both in test and production mode.\n. ",
    "jmburges": "Hey @AliSoftware you would think the - (void)beforeAll would do it but it doesn't! it looks like the beforeAll block gets run earlier enough if you hit the internet on viewDidLoad. \n. ",
    "lukestringer90": "Thanks so much for you help. Your explanation of how the NSURLSession and NSURLSessionConfiguration objects are created sheds some light on what I need to do to accomplish my goal of being able to disable OHHTPStubs. \nI've amended the way that I construct my WebServiceClient instance so that it explicitly pass it a session configuration, which has been used to disable OHHTPStubs before the construction of the WebServiceClient instance. Like so:\n```\nbeforeAll(^{\n        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];\n        [OHHTTPStubs setEnabled:NO forSessionConfiguration:configuration];\n        webServiceClient = [[WebServiceClient alloc] initWithSessionConfiguration:configuration];\n    setAsyncSpecTimeout(0.5);\n});\n\n```\nAnd the constructor is the same as before:\n- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {\n    if (self = [super initWithBaseURL:[NSURL URLWithString:WebAPIBaseURLString] sessionConfiguration:configuration]) {\n        self.requestSerializer = [AFJSONRequestSerializer serializer];\n    };\n    return self;\n}\nI thought this would do the trick but OHHTPStubs is still intercepting my network calls. Any ideas? Thanks once again, OHHTPStubs is a really useful tool.\n. You were right; the loginUsername:password:success:failure: was still using the singleton sharedClient. Thanks for your help.\n. ",
    "hpique": "You're welcome. Nice library, BTW. :)\n. ",
    "paristote": "I've been able to fix my tests by using a real base URL instead of a fake one.\nWhat I think was happening is that RestKit does a reachability test before calling the rest services, and I guess (but not sure) that it happens before stubs are registered.\nI'm trying to find more details but it does not seem to be an issue with OHHTTPStubs anyways.\n. I tried to display the network requests with tcpdump, but nothing appeared. Either my filter was incorrect, or there's something else. I could try with my own server and reading the logs but I don't have so much time so I'll leave it for later.\nYou can close this issue, thanks.\n. ",
    "enrigalmig": "Thanks @AliSoftware \n. ",
    "elitalon": "I think this is related to iOS 8 in general, not specific to Swift. I am working on a project written in Objective-C using Xcode 6-beta 2. So far, the stubs are correctly created and matching the test, but the response blocks never seem to be triggered afterwards.\n. ",
    "GarethShapiro": "My suspicion is that method swizzling is different in Swift.\nG\nEliezer Tal\u00f3n wrote:\n\nI think this is related to iOS 8 in general, not specific to Swift. I\nam working on a project written in Objective-C using Xcode 6-beta 2.\nSo far, the stubs are correctly created and matching the test, but the\nresponse blocks never seem to be triggered afterwards.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/AliSoftware/OHHTTPStubs/issues/65#issuecomment-48891771.\n. Yup NSURLSessions.\n\nThanks for your response.\nG\n\nAliSoftware mailto:notifications@github.com\n21 July 2014 23:48\nMethod sizzling is only used on OHHTTPStubs for NSURLSession. What did \nyou guys use in your code, NSURLSessions or NSURLConnections?\n\u2014\nReply to this email directly or view it on GitHub \nhttps://github.com/AliSoftware/OHHTTPStubs/issues/65#issuecomment-49676783.\nChristos Vasilakis mailto:notifications@github.com\n8 July 2014 10:43\nHi all,\nI am trying to use OHHTTPStubs under Swift on iOS 8. Not sure what I \nam doing wrong but so far was unable to make it work. Here is exempt \nof the code that setup's the stub\n|OHHTTPStubs.stubRequestsPassingTest({ (request: NSURLRequest!) -> Bool in\nreturn true\n}, withStubResponse:( { (request: NSURLRequest!) -> OHHTTPStubsResponse in\nreturn OHHTTPStubsResponse(data:NSData.data(),\nstatusCode: 200, headers: [\"Content-Type\" : \"text/json\"])\n}))\n// initialize NSURLSession and make request\n|\nUnfortunately the stub is not called making the test fail with a 404. \nAm i doing sth wrong or the lib not yet supported on iOS 8 (presumably \nsth has changed there) ?\nRegards\n\u2014\nReply to this email directly or view it on GitHub \nhttps://github.com/AliSoftware/OHHTTPStubs/issues/65.\n. \n",
    "cvasilak": "@AliSoftware after changing the  line here to:\n[urlProtocolClasses insertObject:protoCls atIndex:0];\nseems that it fixed the issue and get back the correct stubbed response.  Not sure, probably in iOS 8 the order of evaluation when consulting the 'protocolClasses' has changed. But I am puzzled because it does work too in iOS 7 also, hmm..\n. @AliSoftware can confirm that the change fixed the issue.\nTested obj-c app on iOS 7 & iOS 8\nTested swift app on iOS 8\nBoth worked correctly :+1:  thanks!\n. awesome @AliSoftware !\nthank you!\n. Hi @AliSoftware thank you for getting in touch! \nMainly our aerogear-ios-httpstub project was started at the same time as our Swift httplib work where we needed a stub framework(preferably in Swift). Back then though, there wasn't any and because we were familiar with the awesome OHTTPStubs and experimenting/learning Swift, we thought to create one inspired by it.\nFrom my view and @corinnekrych, I think maybe continue development of our Swift httpstub framework, as we do now, and possible include a link in your repository Readme.md of sth 'If you are working with Swift, you may be interested at this Swift port of HTTPStub' or something you think more appropriate. Currently not all features of OHTTPStubs are supported but it will be just awesome to have your experience and contributions.\nWhat do you think?\nThanks again for getting in touch!\n. ",
    "rosiakr": "Thank you for the response - this is a good read when I start on my asynch http calls.\nThis one, however, is Synchronous call (NO A in front) - one thread only. I do remove my stubs after each test in tearDown (I use XCTest testing framework):\n- (void) tearDown\n  {\n  [super tearDown];\n[OHHTTPStubs removeAllStubs];\n  }\nThe NSLog statement in withStubResponse block does not even execute - I don't see it in my debug console in Xcode.\nAny ideas??\nThank you.\n. Update: After a closer look it turned out I was setting a different url host in stubRequestPassingTest block than what the method was using when I was running the test. Consequently the response in the stub was never set because the call to the anticipated url domain never happened. I corrected it and my test is green again!\n. ",
    "wka": "Great, thanks!\n. ",
    "mamaral": "I will also note that it seems to be intermittent - leading me to believe it could potentially be other tests not completing properly that is the cause, but I want to make sure that stubbing multiple responses in a single case is at least supported, otherwise I'll rethink my testing strategy.\nEDIT: Here's a screenshot from the logs from one of my tests doing what I was talking about (with sensitive info blacked out of course) and you can see me testing a request retry process by stubbing the first response with a 500, and once we get that response stubbing the next response with a 200 which the retry process should automatically receive and the completion handler should be called, but it hits the 4-second timeout before that:\n\n. To add another observation from another test run, it seems that the majority of stubbed requests have their responses received within about .002 seconds, but every now and then it takes ~2+ seconds for the stubbed response to be received.\n. I've been able to rule out some tests effecting the others by running only a single test case repeatedly, a test which includes the two stubs in the same test, and out of 10 runs it failed to catch the stubbed request 3 times.\nEDIT: Running the test an additional 10 times lead to none of them failing due to timing out.\n. I'll try and provide a simple use-case for why I might want to stub two requests in a single test case. Perhaps I have a primitive request retry process, whereby if a request fails I try it again in 2 seconds. In order to test this, I would want to stub the initial response with something like a 504 response, a timeout, for example, so the first request would fail and I would schedule a retry request to be sent 2 seconds later, so after the first failed/stubbed response is received I would want to get rid of the last 504 stubbed response and replace it with a 200 response with some JSON, so when the second request is sent I would then succeed and I would call some completion block that includes my test expectation being fulfilled. Does that make sense?\n. VERY interesting, thanks for the explanation! So are you thinking the original issue here has to do with the implementation of how I'm stubbing/removing studs/re-stubbing? I could see that could potentially be problematic, but it wouldn't explain running a single test case and having the stubbed response never come back... I'll have to dig more into it and see if I can reliably reproduce it.\n. I just got back into the office, so I will follow up ASAP with more results, thanks!\n. Was hoping this would go away after upgrading to Xcode 6 Beta 7, but looks like I was just able to reproduce what I was seeing before with the entire test suite.\nWhile I've yet to implement some of your recommendations, I will say that before I stub a response I always 'removeLastStub', and in the teardown between each test I 'removeAllStubs', but in the case of the tests that are failing now, it isn't so much an issue with stubs interfering with each other, the problem seems to be that the responses don't always come in immediately. In the case I showed below, the stubbed response took 4 seconds to be received, so the async timeout occurs, and then at some point during the next test the response is received.\nCheck out the log output here:\nhttps://gist.github.com/mamaral/ac1842e24c1b11b429bd\n. For the example shown above I called this method:\n[self stubResponseWithStatusCode:200 dictionary:@{@\"cookie\": @\"test_cookie\"} delay:0];\nWhich is implemented like this:\n```\n- (void)stubResponseWithStatusCode:(int)statusCode dictionary:(NSDictionary *)responseDictionary delay:(NSTimeInterval)delay {\n    NSLog(@\"Removing the last stub and stubbing the next response with status code: %@, dictionary: %@, delay: %@\", @(statusCode), responseDictionary, @(delay));\n    [OHHTTPStubs removeLastStub];\n[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n    return YES;\n} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {\n    return [[OHHTTPStubsResponse responseWithJSONObject:responseDictionary statusCode:statusCode headers:nil] responseTime:delay];\n}];\n\n}\n```\n. The first one definitely didn't hit the real world, as the endpoints I'm testing don't even exist yet. Here's the test case that had the stubbed response come late, along with the corresponding convenience methods:\nhttps://gist.github.com/mamaral/082f14b7cbe982ebf292\n. I will absolutely add some logs into my tests tomorrow morning when I'm back at work to see if I can grab some more info, thanks for your help thus far.\nSo given that test I showed above, the success handler is called only when I get a 200 response from the first request, which you can see in the first gist I linked to seems to be received ~4 seconds later when the next test is running. I am extremely confident that the error/alert handlers are not called, because in each case I have a bunch of NSLog statements with information that would show up. \nThe test that I showed that failed essentially does this:\n1) stub with 200 response (remove any stubs first)\n2) send connection request\n3) get 200 response\n4) call success handler\n5) stub with 200 response (remove last stub first)\n6) send disconnection request\n7) get 200 response\n8) call disconnection completion handler\n9 ) test assertions/fulfill expectation\nIn the failed test we're discussing, #3 is where the test seems to fail as the response is not received until much later after the timeout, but it does seem to be received. One more thing I'm going to do is instead of using the same \"test_cookie\" value for each test, I'll make them unique so I can see which response I'm getting.\n. Ok so step 1 this morning was to try to replicate the issue, but use unique values for the response so I see which test each response is associated with, and it took about 6 test runs to get one of my tests to fail.\nHere's a link to the console output.\nhttps://gist.github.com/mamaral/f152ae637aad373c0c57\n. Alrighty I have a very simple test project that's really only 3 files, the test .m file, and the .h/m files for the singleton that handles the requests. You should be able to grab these files and run the two tests that are there and hopefully you can reproduce it, I was able to on the 2nd try.\nhttps://www.dropbox.com/s/bihhjdqlu06bjn2/OHHTTPTestingTests.m?dl=0\nhttps://www.dropbox.com/s/0xa6brvz5kvvo0c/RequestManager.h?dl=0\nhttps://www.dropbox.com/s/ubf28gubt9duzzw/RequestManager.m?dl=0\nUPDATE: After having spent quite a bit digging down into the code and logging relevant details, the last 60 minutes of testing has been unable to replicate the problem unfortunately. Apparently more logging is the solution to the problem. ;)\nAnother update: Not sure if you've been able to replicate the issue on your end, but running the tests over and over for the last hour and I've been unable to replicate the issue. Hoping you encounter the same issue, otherwise perhaps its environmental?\nAnother update: About 2 minutes after posting the above update I started to run the same test project on another machine, and on about the 8th run through I was able to replicate the timeout, so it doesn't appear to be confined to my machine,.\n. 1) I ran those tests probably hundreds of times and as said it isn't very rare, but it is reproducible on two different machines running two different beta versions of Xcode intermittently.\n2) Regarding the shouldFulfill BOOL, in some cases when the request comes in after the test has completed and the completion handler is called and subsequently the expectation is fulfilled, an exception is thrown and the tests crash - \"'API violation - called -[XCTestExpectation fulfill] after the wait context has ended.'\", that was just a hack to prevent the crash, I'm thinking it might be a bug in the Xcode beta, but not sure yet.\n3) Those two example tests have the same response code, but different payloads, - which in this case will be the name of the test for debugging purposes, so they are technically not the same responses.\nAre you running all the tests at once, like using Command-U, or do you run them one at a time? \n. They all use the same key, \"test_name\", but the value for the payload, the NSString 'test', is a parameter passed in to that method, so they change for each test. You will see something like below, there you'll notice the payloads are different connection/disconnection.\n```\nNow stubbing the next response with status code: 200, dictionary: {\n    \"test_name\" = \"testDisconnect4 - connection request\";\n}, delay: 0\n..and then\nNow stubbing the next response with status code: 200, dictionary: {\n    \"test_name\" = \"testDisconnect4 - disconnection request\";\n}, delay: 0\n```\nAlso, I have a ~1 year old macbook pro SSD as well that I was able to replicate the issue on yesterday, although I've hit a dry spell and can't get the tests to timeout for the last few hours. Not really sure what to do, yesterday morning it was failing every third test, and now I can't get it to fail at all, and all I've done is add a few NSLogs into the code to see if I can dig through and learn the code.\n. That's what I was beginning to think, but it's so bizarre that so randomly the stubbed response would go from taking .002 seconds to 4-5 seconds, and those late responses from the prior test seemed to come in at almost if not the exact same time as the responses for the current test.\n. That does make sense, although I will note that in every case I've been able to reproduce it, the second request seems to kick off both the first and second stub, meaning both responses come back at the same exact time, or within .001 seconds of each other, as seen here:\nhttps://gist.github.com/mamaral/f152ae637aad373c0c57\nIt sucks you have been unable to replicate the issue, but given the code I provided you for demo purposes, do you think that could happen? I have been able to replicate the issue with that exact code multiple times on an older macbook pro from like 2011, as well as a top-of-the-line macbook pro SSD from 2013. I don't suppose there's a whole lot we can do, is there?\n. Yeah, I'm not sure if it's worth putting something up on GIT with the 'whole' project or not. I created an empty application, created only those 3 files I sent you, and my podfile looks like this:\n```\nxcodeproj 'OHHTTPTesting.xcodeproj'\nlink_with 'OHHTTPTestingTests'\ninhibit_all_warnings!\npod 'OHHTTPStubs'\n```\nPerhaps we have different Xcode settings, mine are very likely defaults. I've replicated the issue on Xcode 6 Beta 5 and Beta 7.\n. ",
    "jcampbell05": "Sure I'll produce an example for you give me a moment.\n. Sorry, sort of let this one slip, I'll get a example prepared\n. ",
    "asefnoor": "Thanks a bunch for prompt answer and double thanks for explanation regarding Cocoa URL System for ASIHTTP library because I was not sure about ASIHTTP either they are using Cocoa URL system or not.\nCheers.\n. ",
    "kmilitagaitan": "I removed -sdk iphonesimulator7.1 \\ from my  test script  and then it works.. thanks :)\n. :+1: it's correct I added -destination 'platform=iOS Simulator,name=iPhone 5s,OS=7.1' \\\n. ",
    "nikolajpedersen": "Thanks a lot. It works now.\nI also had to change Travis conf:\n\"osx_image: xcode61\" to \"osx_image: xcode611\"\nThanks for responding so fast - great job on this module!\n. ",
    "rsaunders100": "Awesome stuff. I'll do that. \nSent from my iPhone\n\nOn 27 Jan 2015, at 21:09, AliSoftware notifications@github.com wrote:\nI just discovered a very strange behavior: when testing on iOS7, the additional headers specified in the session configuration are added. They are missing only on iOS8! (Comforting me in the fact that this is an iOS bug)\nI encourage you to fill a radar / bug report to Apple.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "guidomb": "OK my bad, I realized that AFNetworking was using a JSON serializer for the request so the parameter were encoded as JSON in the HTTPBody. Sorry.\n. ",
    "indragiek": "@AliSoftware Done!\n. @AliSoftware I added in one more fix that is irrelevant to the iOS framework, but fixes the installation directory on the Mac framework such that targets linking it will look for it in the right place. Without this, my test bundles fail to run with the following error message:\n\"The bundle \u201cAlamofireRACExtensionsTests-Mac\u201d couldn\u2019t be loaded because it is damaged or missing necessary resources.\" (dlopen_preflight(/Users/Karunaratne/Library/Developer/Xcode/DerivedData/AlamofireRACExtensions-fwzqfpnjghfgdvgaqkdzjymwufxo/Build/Products/Debug/AlamofireRACExtensionsTests-Mac.xctest/Contents/MacOS/AlamofireRACExtensionsTests-Mac): Library not loaded: /Library/Frameworks/OHHTTPStubs.framework/Versions/A/OHHTTPStubs\n  Referenced from: /Users/Karunaratne/Library/Developer/Xcode/DerivedData/AlamofireRACExtensions-fwzqfpnjghfgdvgaqkdzjymwufxo/Build/Products/Debug/AlamofireRACExtensionsTests-Mac.xctest/Contents/MacOS/AlamofireRACExtensionsTests-Mac\n  Reason: image not found)\n. @AliSoftware Made those changes but it seems Travis is still failing because \"iPad 2 isn't a valid run destination\"? I'm not very familiar with Travis, any idea what's going on?\n. Looks like it worked. Thanks for the tip @corinnekrych!\n. @AliSoftware No particular reason, feel free to remove it! Thanks for merging.\n. ",
    "corinnekrych": "@indragiek running the command locally i get the ipad 2 pb too.\nAdding to xcodebuild command\n-destination 'platform=iOS Simulator,name=iPhone 6,OS=latest'\nfixed it\n. Great I'm working on a PR.\n. Hi @AliSoftware \nTo Pods/Podfile.lock or not to Pod/Podfile.lock, that is a question... \nof preferences I think. \nHaving fix version of Podfile is important though. Having only Podfile with fixed version, required cocoapods and specify a cocoapods version as pre-requisite, but leave you repo clean of generated folder/file. From a Java background(I confess) having to run mvn/pod install does not sound bad. \nBUT, I've added them as you wished. Question: should i also add OHHTTPStubs.xcworkspace if you don't want to have a pre-requisite on pod install ?\nYes we need to discuss the minimal deployment target.\nI changed it due to AFNetworking supporting only 6.0/10.8. Are you ok to move a level up? \nthen yes we should change: https://github.com/AliSoftware/OHHTTPStubs/blob/master/OHHTTPStubs.podspec#L39-L40\nI'll take a closer look to Travis build shortly.\n. @AliSoftware because i'm not familiar with, just reading http://www.cocoanetics.com/2014/07/development-pods/\nyou modifly the Demo podfile, what shoul it be?\n. @AliSoftware \n- I did the change for demo podfile\n- Podfile.lock checked in. Let's no start a flame war with bold and uppercase. My view is more: when using fixed version in your Podfile and given you dependencies use fixed versions, you end up with Pods with fixed version too.\nbut we still have to sort out:\n- a failing travis for iOS7, running out of idea for which simulator to pick... but the other subjobs succeed. (i'll do some more testing on a sep. branch)\n- supported platform, with this commit 892d8e4b3e01b0bae5c2b9e5f14e5d43bf72ad75 I've updated versions supported and move to 4.0.0. Are you ok with that?\nIf this is not the way you want to go forward, close my PR.\n. @AliSoftware Still the same with 7.1\nActually i did several trials:\n- remane iPhone 5S by iPhone5s \n- change to iPhone 5\n- 7.0\n  without luck so far....\n. ",
    "User2004": "https://webappcodes.com/category/ios\nhere, all iOS demo code available.. ",
    "ishkawa": "Yes, you are right. I will remove duplicated test target and remove test target from iOS framework scheme.\n. Carthage supports dynamic framework only, thus it supports iOS 8 or later and all of OS X. And I did not try to build OHHTTPStubs.framework for iOS 7 runtime (iOS 8 or later only). \nThe problem is we can not build framework by xcodebuild -scheme \"OHHTTPStubs iOS Framework\" -workspace OHHTTPStubsDemo.xcworkspace, and this means we can not install OHHTTPStubs using Carthage. This is caused by xcodebuild bug and that OHHTTPStubs iOS Framework scheme has test action with lower deployment target. Please try the command above on both of master and forked repository.\n. I noticed this also happened on Travis CI before. \nhttps://travis-ci.org/AliSoftware/OHHTTPStubs/builds/52363629\nThis error is avoided by adding -destination option of xcodebuild, but Carthage cannot do that.\n. Unfortunately, they decided that they will not add workaround for the similar issue.\nhttps://github.com/Carthage/Carthage/issues/259\nAnyway, their requirement is very simple, just making xcodebuild -scheme SCHEME -workspace WORKSPACE build succeeded. So I think this should be fixed by modifying library.\n. Thank you for merging. I hope this will be fixed in future version of Xcode.\n. ",
    "aleufms": "Hi,\nI tried the solutions on StackOverflow without success. I think it is a bug on XCode. I have to force use framework on my test target for it works.\n. ",
    "benhirashima": "The above happened when only opening the xcodeproject file. When I open the workspace, I get this error instead:\nUndefined symbols for architecture x86_64:\n  \"OBJC_CLASS$OHHTTPStubs\", referenced from:\n      objc-class-ref in MainViewController.o\n  \"_OBJC_CLASS$_OHHTTPStubsResponse\", referenced from:\n      objc-class-ref in MainViewController.o\n  \"_OHHTTPStubsDownloadSpeedWifi\", referenced from:\n      38-[MainViewController installTextStub:]block_invoke_2 in MainViewController.o\n      _39-[MainViewController installImageStub:]_block_invoke_2 in MainViewController.o\nld: symbol(s) not found for architecture x86_64\nBTW, I'm not using CocoaPods in case that wasn't already clear.\n. sorry, don't have time to look at this right now. i would just suggest you test it on a clean machine. it seems like the sample project is making some assumption about the environment that isn't true in my case.\n. ",
    "NSProgrammer": "There is a syntax bug, will resubmit\n. Totally understand wanting the unit test to go alongside.  I doubt I'll\nhave time though.  We use OCMock for testing this, but I don't want to\nintroduce a dependency and won't have bandwidth for an alternative.  I'm\nsorry for only going half way here.\nOn Thu, Apr 2, 2015 at 1:47 PM, AliSoftware notifications@github.com\nwrote:\n\nThanks, seems ace!\nDo you think you could be able to add a Unit Test for that (to ensure that\nevery delegate method is indeed invoked on the expected thread)?\nAlso, don't forget to add an entry in the CHANGELOG.md to credit yourself\n:)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/AliSoftware/OHHTTPStubs/pull/96#issuecomment-89040995\n.\n. This issue was being hit quite frequently in our unit tests and this fix completely eliminates it.  It only would get triggered about 5% of the time, but when unit tests are run ~500 times per day, those 25 failures are blocking for dev.\n. One option is to apply indirection.  You create a custom NSURLProtocolClient implementation that redirects all messages to the NSURLProtocol's client property and instead swizzle/mock the NSURLProtocol's client property.  You might even be able to get away with overriding the getter for the \"client\" property in your NSURLProtocol subclass and instead have the custom NSURLProtocolClient indirect to the super.client instead.\n. Yes, it is confusing commentary by Apple.  The \"client thread\" they are referring to is the thread that start loading is called from, which is com.apple.NSURLConnectionLoader.  I agree it is ambiguous with being potentially the thread the NSURLConnection or NSURLSession is called from, or even the NSRunLoop the NSURLConnection is registered with or the NSOperationQueue the NSURLSession has set as a delegate queue.  However, we have confirmed with Apple directly that it is the thread that startLoading is called from.  It is an implementation detail that the thread happens to be com.apple.NSURLConnectionLoader, but it makes sense that networking is synchronized via being on a dedicated thread.  Sorry for the delay in replying.\n. Sounds good, thanks!  And just for reference, most of our NSURLProtocol learnings came from building CocoaSPDY.\n\nhttps://github.com/twitter/CocoaSPDY\n. I haven't personally made these discoveries or any acquaintances at Apple; that's mostly comes from the core contributors to CocoaSPDY.  However, I know from working closely with them (and with NSURLProtocol over the past 10 years) that NSURLProtocol is not a priority for Apple and so things will often be forgotten for compatibility making it unstable and only the most common use cases are maintained (though I argue that's purely coincidence).\nFor example: \nhttp://openradar.appspot.com/radar?id=5792159408062464\nhttp://openradar.appspot.com/radar?id=5209760232112128\nI wouldn't be surprised if the place where HTTPAdditionalHeaders gets added to the canonical headers of the request moved from the NSURL loading system into the private NSURLProtocol implementations that Apple has and they just didn't care about the side effect.  What this really boils down to is the core flaw in NSURLProtocol; that the NSURLSessionConfiguration is not available to the protocol.  This particularly affects how cookies are handled which differs between NSURLConnection to NSURLSession, but ultimately no configuration properties are available to the protocol.\nYou can see in the latest addition to CocoaSPDY that I created a patch (submitted vicariously by a coworker) such that the NSURLSession (and therefore the configuration, delegate and delegate queue) can be provided to the SPDYURLProtocol (see the SPDYURLSession in NSURLRequest+SPDYURLRequest on the \"develop\" branch).  This might be an avenue to pursue, though it is admittedly a workaround.\nBest of luck, we appreciate your framework and your dedication to keeping it fresh!\n. Yup, it was unnecessary.  Fixed.\n. ",
    "YasKuraishi": "@AliSoftware - the fix was pretty trivial, just had to rename Example folder to Sample so Carthage could find the project file. PR waiting for your seal of approval... https://github.com/AliSoftware/OHHTTPStubs/pull/98\n. ",
    "michaelmcguire": "Sorry for the lack of feedback!  I just converted over to using Carthage from CocoaPods on the latest in master (4.0.1) and everything is working great.  Thanks!\n. ",
    "mrgrauel": "Please don't drop Carthage support. A lot of people use it instead of cocoapods\n. ",
    "rogernolan": ":+1: for that view. I think Carthage should add the flexibility to specify a target.\n. ",
    "danyalaytekin": "Great, that's the route I'd have recommended. :+1: \n. ",
    "tibr": "Works great, thanks a lot :+1: \n. Thanks a lot for the quick release :+1: \n. ",
    "Megatron1000": "Hi I was installing it via pods.\nDon't worry about this issue now. I've managed to figure out what was wrong. Basically I was overriding dataTaskWithRequest:completionHandler: in order to make another asynchronous request for an authorisation token. If I stop doing this it starts to working. The problem was probably because when I override the method I end up returning nil for the data task. I've managed get it to work by stubbing this method on my session manager and passing the method call onto its superclass. \n. ",
    "gabro": "As a temporary workaround, I'm doing something like this in order to log each stubbed request only once\n``` swift\n// ...\nstatic var loggedRequests = Set()\n// ...\nOHHTTPStubs.onStubActivation { (request: NSURLRequest!, stub: OHHTTPStubsDescriptor!) in\n  if !self.loggedRequests.contains(request) {\n    self.loggedRequests.insert(request)\n    // log the request\n  }\n}\n```\n. ",
    "JinlianWang": "Awesome comments. I was too excited to get this in and obviously let some hack slip in. Have it fixed so that Mocktail extension does not require any change in core library. Also make the error more descriptive. \n. Sorry Oliver. It seems like the project file has some conflict while I am trying to correct the target membership. I am not sure how to fix this. Anything you can do on your side to help? Thanks!\n. Somehow there is always conflict even if I back the project file all the way back and add them manually. Could you use the latest version of it and it shall work perfectly? \nAs for CocoaPods, my current project is not using it and need some time to refresh my memory. Maybe we treat this as a follow-up or it may take someone more familiar with it minutes to do it? Thanks!\n. Finally got it resolved without any conflicted. It appears that it had conflict because of the recent change on the upstream to the project file on July 28th. \n. @AliSoftware Are you waiting for a CocoaPods change from me before merging it? \n. @AliSoftware Just got some cycles today, refresh my memory and got the subspec in. I also added the capability so that it can handle base64 encoded body. It is helpful when it comes to simulate the response for image requests or any other kinds of binary download.\n. @AliSoftware Forgot to mention that I created a test project to test the base64 encoded body part@https://github.com/JinlianWang/TestHTTPStubs. I can make similar effort to the demo project if needed and the desirable change is given. \n. @AliSoftware Just expose NSBundle as one of the arguments for Framework environments. This is quite a learning process. Thanks!\n. Awesome. Thanks @AliSoftware for the great work on such a useful lib. Very thoughtful and powerful interface. We love it here.\n. BTW, I am finalizing up some code to recording traffic in Mocktail format files, so that the can be used for development and testing purpose. Will send your way to get your feedback once done.\n. I would love to update the file with MIT license. Capital One especially the department I am working for is pushing for open source culture and unfortunately the authorship is one of the main KPIs. I would have to check to see what we can do. Actually the other day some leadership asked why I am not showing as one of the contributors:-(\n. Just go ahead and update it. Going through the internal open source guidelines, it seems to be listed as one of acceptable samples. The company is pushing effort over open source and sponsoring events like http://www.iosdevcampdc.com. Would you be interested coming in as a speaker to share your experience if similar event occurs?\n. @AliSoftware Thanks a bunch for the flexibility!!! Will check with you when such events occur. \nBy the way, since this is merged to master, I will close this pull request. \n. @AliSoftware The recording tool is finally made public under CapitalOne. To help our users better, do you mind updating the README to include a link to the tool at https://github.com/capitalone/SWHttpTrafficRecorder? Thanks a lot in advance and please let me know if it needs to be rephrased or put it some other place instead. \n. Was not aware of the difference. I guess it is better to support both formats. \n.  @AliSoftware is right; the issue shall be on the SWHttpTrafficRecorder side. @ivan-ushakov sorry that I may not be able to handle any issue for that repo in the near future, in the process of archiving/retiring the project. Please find other tools that may work for similar purpose or feel free to find a solution and share with community if possible. . ",
    "newlix": "If the workaround in wiki is not working,  please remove it .\nThank you.\nhttps://github.com/AliSoftware/OHHTTPStubs/wiki/Testing-for-the-request-body-in-your-stubs#a-transparent-workaround\n``\nA Transparent Workaround\nOpen and then drain theHTTPBodyStream. You've just recovered theHTTPBody` as a big bag o' bytes!\nIf you're pulling in JSON, this gets even easier: open the stream, then call +[NSJSONSerialization JSONObjectWithStream:options:error:]. The deserializer will take care of draining the stream and spitting out JSON for you.\n```\n. ",
    "jeremy-w": "@AliSoftware I wrote it up only after I got it working in some project, so it's not an untested workaround. It's been a while though, so I'd have to do some digging to surface the code in question.\nWhat immediately leaps to mind on reading the original post is that NSStream is an async API, so after asking it to open, you might need to listen for the NSStreamEventOpenCompleted event before you can read from it in order to play by the rules of its state machine. (That said, CFStreamRead is documented as blocking till the open has finished.)\nIt's also possible that framework changes since I used the workaround have broken it.\n. ",
    "markst": "I seem to be able to check the body by serialzing the httpBodyStream\nswift\nOHHTTPStubs.stubRequests(passingTest: { (request) -> Bool in\n    guard let httpBodyStream = request.httpBodyStream else { return false }\n    do {\n        httpBodyStream.open()\n        let requestBody = try JSONSerialization.jsonObject(with: httpBodyStream, options: [])\n        print(\"requestBody\",requestBody)\n    } catch let error as NSError {\n        print(\"error: \\(error.localizedDescription)\")\n    }\n52\n. https://github.com/NimbusKit/sockit\n. ",
    "mikelupo": "Thanks for the clarifications. And especially the quick reply.\nI've been all over your wiki. It's helped me get thus far.\nTurns out that the problem is actually in our app software with the \"special\" target configuration that's specific to unit testing. \nWhen I resolved it the 404 went away. \nThanks again,\nMike\n-----Original Message-----\nFrom: AliSoftware notifications@github.com\nTo: AliSoftware/OHHTTPStubs OHHTTPStubs@noreply.github.com\nCc: mikelupo mikelupo@aol.com\nSent: Fri, Aug 14, 2015 10:37 am\nSubject: Re: [OHHTTPStubs] Questions about using HTTPStubs (#110)\n2) The test fails with 404 errors in my logs because I believe that OHHTTPStub is either redirecting on the wrong URL or worse, it's injecting the JSON data on a URL that it should not be mocking (ie. facebook).\nThat will only happen if:\nEither your test in the stubRequestsPassingTest: block is not correct (like if your returned YES for every request so that the stub would be triggered for all requests). But you seem to do proper tests like [request.URL.absoluteString isEqualToString:\u2026] so doesn't seem to be the case here\nOr you forgot to remove your stubs from the previous Unit test before starting the next test, so the stub setup for test 1 will still be active when test 2 runs. see that article in my wiki \nWhat's the proper way to debug what OHHTTPStubs is mocking on? I want to make sure it's doing what we expect when we expect it.\nYou can use onStubActivation: to log every time a stub is activated. See here in the detailed usage examples in my wiki too\nCan I use it with request.URL.absoluteString as depicted below? I would think that it does not matter so long as the parameter evaluates to true.\nYes, that's actually the most common usage.\nDon't hesitate to consult my help articles in my wiki that could give you a lot of tips.\n\u2014\nReply to this email directly or view it on GitHub.\n. It would be labor intensive I think to produce a project and work out reproducing instructions. \nWith that tidbit of history, I might be able to just do a find/replace in the project file and submit a PR.\nI'll have a look\nThanks!\n-----Original Message-----\nFrom: AliSoftware notifications@github.com\nTo: AliSoftware/OHHTTPStubs OHHTTPStubs@noreply.github.com\nCc: mikelupo mikelupo@aol.com\nSent: Fri, Sep 18, 2015 11:48 am\nSubject: Re: [OHHTTPStubs] my own apps; pbxproj file keeps getting updated with OHTTPStubs .xctest lines when building (#117)\nI think that's because I renamed targets at some point in the lifetime of OHHTTPStubs' project evolutions, (like I renamed \"OHHTTPStubs iOS Tests\" renamed to \"OHHTTPStubs iOS Lib Tests\" when I introduced the dynamic framework version to make the name of the target more clear) and probably Xcode didn't update it everywhere it should have in the OHHTTPStubs.xcodeproj/*pbxproj files and kept the old name at some places in the pbxproj, which it updates only at compile time in some circumstances\u2026 (that's just a guess but I've see that behavior of Xcode before).\nCare to post a diff to list me all the modified files so I can see where Xcode missed them? Or provide a sample project to reproduce the issue so I can check the diffs myself?\nThx\n\u2014\nReply to this email directly or view it on GitHub.\n. Before merging, please check to make sure that renaming did not affect the pods installations.\n. We had to add -ObjC to the other linker flags in the app which makes the call. Then the stubs started working for us. We don't integrate via cocoa pods tho.\n\nOn Jul 22, 2016, at 8:16 PM, Igor Belo notifications@github.com wrote:\n@AliSoftware even doing that I'm getting a hit in my API server...don't know if it's due an outdated version of CocoaPods (0.39.0) we are using\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Thank you.\nThat helps with the first issue.\n\nThe second issue, \nreturn [[OHHTTPStubsResponse responseWithFileAtPath:OHPathForFile\nis not solved.\n. I got it.  \n```\nimport \n```\nThanks again @samirGuerdah for your answer. \n. How should we #import the ability to utilize this new code? I can't seem to build it with just #include <OHHTTPStubs/OHHTTPStubs.h>\nNote, I'm not using cocoapods to install. I'm dragging the xcodeproj into a frameworks group in my own xcode project. that's how I've always used OHHTTPStubs.\nThanks in advance \n. Thanks for the quick reply. \nLooks like its my problem. It's mainly because of the way that I integrate. \nWhen I removed the existing OHHTTPStubs.xcodeproj from my workspace, it also removed references to it from my build phases where I was building/linking it into my bundle.  So of course it would not find it. \n:)\nNow that I've resolved that, it still won't build unless I import:\n#import <OHHTTPStubs/NSMutableURLRequest+HTTPBodyTesting.h>\nIn my test, I'm using the new method call like this:\nNSData *myData = [request OHHTTPStubs_HTTPBody];\nMike\n-----Original Message-----\nFrom: Felix Lamouroux notifications@github.com\nTo: AliSoftware/OHHTTPStubs OHHTTPStubs@noreply.github.com\nCc: mikelupo mikelupo@aol.com; Mention mention@noreply.github.com\nSent: Wed, Jun 1, 2016 1:53 pm\nSubject: Re: [AliSoftware/OHHTTPStubs] Adds support for HTTPBody during testing when using NSURLSession (#166)\n@mikelupo The should not require any changes in your end as far as I remember and should just magically work. \n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. What about \nimport \nSent from my iPhone\n\nOn Jun 13, 2016, at 11:34 PM, Hemster notifications@github.com wrote:\n@AliSoftware I tried '@import OHHTTPStubs;' , but it is not working properly. Xcode said module not found. QAQ\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Sorry I have not had a chance to revisit this. When I do and if I should have any further issue I will reopen. \nThank you for your careful and thought out reply!\n\nMike\nPs...we are using this library extensively and quite creatively I might add. We are thankful for it!\n\nOn Aug 17, 2016, at 5:46 PM, AliSoftware notifications@github.com wrote:\nHi. I'm gonna close this issue now due to the fact that I think I've answered your question and due to lack of response. Consider reopening if you still have pending problems about that due to OHHTTPStubs itself.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Update: Today I learned that the developers had implemented a clever workaround to prevent recursion between the Apple networking libs and our app. This had the unintended side-effect of hiding the request from OHHTTPStubs. As a test, I disabled that clever thing and viola! I can see the requests and respond with a proper mock. \n\nClosing ... \n. Maybe you need an asynchronous wait?\nSent from my iPhone\n\nOn May 5, 2017, at 8:00 AM, Wassim Seifeddine notifications@github.com wrote:\nYes that's exactly what happened. Now i changed it to\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {\n        // Override point for customization after application launch.\n    let condition : OHHTTPStubsTestBlock = { (request : URLRequest) in\n        if request.url!.host! == \"www.mocky.io\"{\n            print(\"true\")\n            return true\n        }\n        print(\"false\")\n        return false\n    }\n\n    stub(condition: condition ) { _ in\n        print(\"Stubbing\")\n        return OHHTTPStubsResponse()\n    }\n\n    return true\n\n}\n\nand still nothing changes. prints true all the time but never prints stubbing\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I know this isn't a question directed to me but I give +1 to the idea. \n\nSent from my iPhone\n\nOn May 11, 2017, at 5:26 AM, AliSoftware notifications@github.com wrote:\n@Liquidsoul I wonder if we should add a preconditionFailure(!host.contains(\"/\"), \"The host part of an URL never contains any slash. Only use strings like 'api.example.com' for this value, and not things like 'https://api.example.com/'\") in the isHost implementation? Or at least add - Note entries in the function's doc comments to hint about this?\nAnd probably same for some other test helpers (like isScheme isn't supposed to contain the \"://\" part either, etc)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I anticipated my CHANGELOG link to the PR incorrectly. I thought it would be 249, turns out it's 250. \nDo I need to change that? I can't imagine that all the other PR contributors had to anticipate that like I did. Please advise.... oh, I think I've been misunderstanding you. You want me to remove all the blank line fixes. Those blank lines had spaces where there should not have. And since I was in those files, I fixed those purposefully. Gerrit (our local code review tool) catches those and they show up as red space. We are diligent to remove \"red space\" as leaving it in in typically causes merge conflict headaches down the road.\nIn light of this comment, do you still want that removed?. You're very welcome! Glad to be able to contribute to a really great app. The strict guidelines are what keeps it stable and easy to maintain. \nI'll get that whitespace fix in perhaps even today... :)\n. Time. Leave this open and I'll get to it this week \ud83d\ude4f ??. ok, I got to it. \ud83e\uddc0 \ud83d\ude01  . Instead of adding a new commit, I amended the last one. I hope that is OK with the github workflow.. I've actually made the change, but I will need some help to add a test case for each of these redirects. I'll go ahead and post the PR so you can review the change just the same. . It seems like it would be rudimentary to add a label to a PR or Bug. I can see the categories on the right hand side of the web page, but it's immutable. I can't add any label. @AliSoftware can you please intervene?\n. @AliSoftware  It's mutable now. I can add a label, but we don't currently have a WIP label. Shall I create one?. @AliSoftware Oliver can you peruse this and let me know if any changes are needed? Thanks!. @AliSoftware This is what I observed in our own redirect tests. Does it amply answer your question? (Please note that this code a local test and isn't submitted here on Github at this time.)\n\n\n. @AliSoftware, no need to apologize. This is the exact purpose of this forum. To discuss (sometimes in detail) the change that is being presented. We learned some good things from this exercise.\nSo with that said, is this code ok as-is now? or do I need to make some more changes?\nPlease advise...\nThanks!\n. Good catch!\nSent from my iPhone\n\nOn Oct 16, 2017, at 2:29 PM, AliSoftware notifications@github.com wrote:\n@AliSoftware requested changes on this pull request.\nThis code means that 303 will not work anymore as the URL will not be replaced or changed in the case of 303\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I almost didn't do that. I'll change it and resubmit.\nA clever strategy...\n\nThanks,\nMike\n-----Original Message-----\nFrom: AliSoftware notifications@github.com\nTo: AliSoftware/OHHTTPStubs OHHTTPStubs@noreply.github.com\nCc: mikelupo mikelupo@aol.com; Mention mention@noreply.github.com\nSent: Mon, Oct 16, 2017 3:41 pm\nSubject: Re: [AliSoftware/OHHTTPStubs] Fix redirect handling to respect RFC and HTTP/1.1 RFC 7538 (#263)\n@AliSoftware commented on this pull request.\nIn OHHTTPStubs/Sources/OHHTTPStubs.m:\n\n@@ -424,7 +424,28 @@ - (void)startLoading\n                 // Notify if a redirection occurred\n                 if (((responseStub.statusCode > 300) && (responseStub.statusCode < 400)) && redirectLocationURL)\n                 {\n-                    NSURLRequest redirectRequest = [NSURLRequest requestWithURL:redirectLocationURL];\n+                    NSURLRequest redirectRequest = nil;\n+                    NSMutableURLRequest *mReq = nil;\n\nThis = nil; isn't needed as all path below will affect it a value anyway. (By not affecting it to nil, the compiler will warn us in case we later change the code and forget to affect a value in one of the code paths)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Once we settle on this, Shall I squash the commits down into a single thing and resubmit?\n-----Original Message-----\nFrom: AliSoftware notifications@github.com\nTo: AliSoftware/OHHTTPStubs OHHTTPStubs@noreply.github.com\nCc: mikelupo mikelupo@aol.com; Mention mention@noreply.github.com\nSent: Mon, Oct 16, 2017 3:41 pm\nSubject: Re: [AliSoftware/OHHTTPStubs] Fix redirect handling to respect RFC and HTTP/1.1 RFC 7538 (#263)\n@AliSoftware commented on this pull request.\nIn OHHTTPStubs/Sources/OHHTTPStubs.m:\n\n@@ -424,7 +424,28 @@ - (void)startLoading\n                 // Notify if a redirection occurred\n                 if (((responseStub.statusCode > 300) && (responseStub.statusCode < 400)) && redirectLocationURL)\n                 {\n-                    NSURLRequest redirectRequest = [NSURLRequest requestWithURL:redirectLocationURL];\n+                    NSURLRequest redirectRequest = nil;\n+                    NSMutableURLRequest *mReq = nil;\n\nThis = nil; isn't needed as all path below will affect it a value anyway. (By not affecting it to nil, the compiler will warn us in case we later change the code and forget to affect a value in one of the code paths)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I definitely need help writing the unit tests. Current unit tests seem to be only checking one status. A 301.. Thanks @AliSoftware. I am actively working on it between other tasks so my submission may be delayed.. @AliSoftware I have generalized the _test_redirect method and it's now accepting parameters. Where I'm lacking is the improvements that you mentioned, \n\n\"add some assertions to check that the body of the returned redirect is the same as the original, and same for the method\". \n\nCould use some help with that part.. Hi, I keep planning to work on it, but my daily job keeps getting in the way!\n;P\nI'll make a push to try and get this done before middle next week.\nFeel free to ping me any time to cattle-prod me.\nMike\n-----Original Message-----\nFrom: AliSoftware notifications@github.com\nTo: AliSoftware/OHHTTPStubs OHHTTPStubs@noreply.github.com\nCc: mikelupo mikelupo@aol.com; Mention mention@noreply.github.com\nSent: Thu, Oct 26, 2017 3:06 pm\nSubject: Re: [AliSoftware/OHHTTPStubs] Fix redirect handling to respect RFC and HTTP/1.1 RFC 7538 (#263)\n@mikelupo ping \ud83d\ude09\nAny change you'll find some time to continue working on it soon?\nI'd love to make a new release at some point and would like to include your PR in it \ud83d\udc4d\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @AliSoftware I posted Unit Tests for review. I hope that I have correct thinking as far as this part of the PR goes. \nThanks! \nEdit: I also see the conflict on CHANGELOG.md and will resolve it when we're ready to merge the commit.. @AliSoftware Thank you for taking this up in my absence! \ud83d\udc4d . This may not hold water, but I have a vague memory that this was fixed in iOS 8.4??\n-----Original Message-----\nFrom: AliSoftware notifications@github.com\nTo: AliSoftware/OHHTTPStubs OHHTTPStubs@noreply.github.com\nCc: Subscribed subscribed@noreply.github.com\nSent: Mon, Oct 16, 2017 3:34 pm\nSubject: Re: [AliSoftware/OHHTTPStubs] Add onStubMissing to report missing stubs; detects \"stale\" stubs which can lead to intermittent failures (#264)\n@AliSoftware requested changes on this pull request.\nChangelog nitpicking + double-check if canInitRequest isn't called too many times for same request by the system\nIn OHHTTPStubs/Sources/OHHTTPStubs.m:\n\n@@ -337,7 +343,11 @@ @implementation OHHTTPStubsProtocol\n\n\n(BOOL)canInitWithRequest:(NSURLRequest *)request\n {\nreturn ([OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request] != nil);\nBOOL found = ([OHHTTPStubs.sharedInstance firstStubPassingTestForRequest:request] != nil);\nif (!found && OHHTTPStubs.sharedInstance.onStubMissingBlock) {\nOHHTTPStubs.sharedInstance.onStubMissingBlock(request);\n\nDid you check that this is only called once? I remember when I worked on canInitWithRequest a while ago that iOS called that method more than once to test a single request.\nI have no idea why it would call it multiple times while calling it only one should be enough for the system, but in practice, at least some iOS versions ago when I worked on this part of the code, putting a breakpoint there made it be triggered multiple times even for only one request, so better check in case it's still the case (especially with old iOS version, as maybe they've improved that since recent updates hopefully)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I'll consider that in our own implementation here at Akamai first. \ud83d\udc4d . @AliSoftware, Sorry I missed that. It's fixed now. My Xcode is already up as you mentioned, but I just didn't CTRL-i to repair the indentation on that one file. It's in the new commit of this PR now.. That's what I get for trying to do this fast. \ud83d\udc4e . I kept the test for > 300 && < 400 but then applied special treatment for the special codes.\nInstead of creating a new NSMutableRequest, I can (and should have created a mutable copy instead) NSMutableURLRequest* tempRedirectRequest = [self.request mutableCopy];\nJust to be safe, I'll make sure to copy the body into the mutable copy as well.. Yes, I keep forgetting that you do that. And my Xcode has auto tabs, so when I save the file, it gets done automatically. I'll fix that.. Fixing this too :)\n. @AliSoftware As I'm re-reading your comments of making a mutable copy.\nNSURLRequest *redirectRequest = (NSURLRequest*)[tempRedirectRequest copy];\nHow can we know if the HTTPBody was consumed?\nquoting your comment, \"... as the body data is quickly turned into the httpBodyStream: NSInputStream property and if that stream has started being consumed maybe a mutableCopy isn't enough to make it work & re-read from the beginning? So be sure to test that use case\" \nNeed suggestions on how I test that use case?\nSeems we'll have to return the NSMutableURLRequest instead of copying it back to immutable. I wonder if there would be any unintended side-effect from that. Would we cause upgrading users to hit a snag because of the type change?. Ok, I can add the code to test that and try it out in my own client.\nBut if it's the latter, NSStreamStatusAtEnd or Closed, then we've got to decide how best to handle that. \nNow, I suppose all this only matters if the original request is of method=POST?\n. Got it. I'll make that change.  My code and your comment crossed on the wire.. It's already out in my code.  \ud83e\udd47 . I had a comment here, but it became a bit irrelevant after taking a break. I've been looking at this code for too long now. ;) So I deleted it. . So do we need to follow redirects in the context of these tests? I would think so.. ok, we have two \"withStubResponse\" methods here. One for the original redirect, one for the second response (from the redirected request) for the path, @\"/elsewhere\". In the first redirected response, I'm trying to hijack the data payload with my own JSON stuff to keep track of originating request stuff (I think this is what you were wanting me to do). Then put that hijacked data payload on the wire for the redirected request, and hence, when we finally get the 200 response, we should have our built up JSON. However, it seems that apple is ignoring my change in data. I'm getting the original data posted all the way through. This isn't bad behavior and it's preventing man-in-the-middle attacks. It seems I won't be able tweak the HTTPBody in the response. \nThoughts?. For the other response codes as well ...should we return nil for the body in the first stub or only in 301? Edit: We can't return nil for data as the stub won't allow returning a nil, . Thanks for taking a hard look at the code. I'll address your interesting comments soon.\nRecovering here from a bad storm and multi-day power outage.. Checking in. I've not forgotten. I'm just busy on some other tasks that are directly work related.. ",
    "bruceflowers": "Thanks for your quick response, this worked for me. I agree with you, it's ugly to have to do this and if this was intentional on Apple's part, I'd love to know their rationale.\n. ",
    "manuyavuz": "Ok, it worked because setting [NSData data] does not cause -connection:didReceiveData: delegate method to be called at all, which means we simply received an empty response.\nThanks for the quick response. \n. ",
    "keith": "Ah yep sorry, I was pinning to an older version. Thanks!\n. We're seeing this error as well.\n. I was able to fix this by manually changing the imports in OHHTTPStubs.h with:\n```\nimport \"Compatibility.h\"\nimport \"OHHTTPStubsResponse.h\"\n```\nBut this isn't really a long term solution\n. I'm not sure how that affects users not pulling this in via CocoaPods though.\n. Yep that's all I changed.\n. Yep, it built fine for me!\n. I think these test failures are related to your changes @sberrevoets ? It looks like master is mostly green (besides some flakes). ",
    "srosmd": "My Podfile:\n```\nsource 'https://github.com/CocoaPods/Specs.git'\nuse_frameworks!\npod 'AFNetworking', '~> 2.3'\ntarget 'MyAPI_Tests', :exclusive => true do\n  pod \"MyAPI\", :path => \"../\"\n  pod 'OHHTTPStubs' #, '~> 4.2.0' #I added this to fix the missing method\n  pod 'OCMock'\n  pod 'Expecta'\nend\n```\nMy 'Podfile.lock`:\n    PODS:\n    - AFNetworking (2.6.0):\n      - AFNetworking/NSURLConnection (= 2.6.0)\n      - AFNetworking/NSURLSession (= 2.6.0)\n      - AFNetworking/Reachability (= 2.6.0)\n      - AFNetworking/Security (= 2.6.0)\n      - AFNetworking/Serialization (= 2.6.0)\n      - AFNetworking/UIKit (= 2.6.0)\n    - AFNetworking/NSURLConnection (2.6.0):\n      - AFNetworking/Reachability\n      - AFNetworking/Security\n      - AFNetworking/Serialization\n    - AFNetworking/NSURLSession (2.6.0):\n      - AFNetworking/Reachability\n      - AFNetworking/Security\n      - AFNetworking/Serialization\n    - AFNetworking/Reachability (2.6.0)\n    - AFNetworking/Security (2.6.0)\n    - AFNetworking/Serialization (2.6.0)\n    - AFNetworking/UIKit (2.6.0):\n      - AFNetworking/NSURLConnection\n      - AFNetworking/NSURLSession\n    - Expecta (1.0.3)\n    - OCMock (3.1.5)\n    - OHHTTPStubs (4.3.0):\n      - OHHTTPStubs/Default (= 4.3.0)\n    - OHHTTPStubs/Core (4.3.0)\n    - OHHTTPStubs/Default (4.3.0):\n      - OHHTTPStubs/Core\n      - OHHTTPStubs/JSON\n      - OHHTTPStubs/NSURLSession\n      - OHHTTPStubs/OHPathHelpers\n    - OHHTTPStubs/JSON (4.3.0):\n      - OHHTTPStubs/Core\n    - OHHTTPStubs/NSURLSession (4.3.0):\n      - OHHTTPStubs/Core\n    - OHHTTPStubs/OHPathHelpers (4.3.0)\n    - SIODeviceAPI (0.2.0-RC1):\n      - AFNetworking (~> 2.3)\nDEPENDENCIES:\n    - AFNetworking (~> 2.3)\n    - Expecta\n    - OCMock\n    - OHHTTPStubs\n    - SIODeviceAPI (from ../)\nEXTERNAL SOURCES:\n    SIODeviceAPI:\n      :path: \"../\"\nSPEC CHECKSUMS:\n    AFNetworking: 79f7eb1a0fcfa7beb409332b2ca49afe9ce53b05\n    Expecta: 9d1bff6c8b0eeee73a166a2ee898892478927a15\n    OCMock: 4c2925291f80407c3738dd1db14d21d0cc278864\n    OHHTTPStubs: ea33adf65900e6bc8c31b80eb7d527e8874a559b\n    SIODeviceAPI: d2f2d89d6be2295bc830a5eb155acf810a270f29\nCOCOAPODS: 0.38.2\n. Hey Ali, \nSorry if I was unclear. I worked around this issue by rolling back the version of OHHTTPStubs I was using to 4.2.1. However, when I've used 4.3.0, I get this error.\n. Hey Ali, I'm happy to say your work around solved the issue. :) Thanks for your help. Seems like it might be a broken umbrella header then? \n. ",
    "billibala": "I use git submodule. Right now, modified my local copy to include the missing swift file\n. ",
    "ikesyo": "Thanks for your answer, I understand the situation and your support policy for older platforms. I'll give up to use it now.\n. Thanks for your thought! I'm OK to wait for the next Xcode beta to remove the workaround. In the meantime I'll using the branch personally.\n. Travis now supports Xcode 8 beta 2: https://twitter.com/travisci/status/752704816116293632. But the iOS tests are randomly failed as seen in the following:\n- https://travis-ci.org/AliSoftware/OHHTTPStubs/builds/144138180\n- https://travis-ci.org/AliSoftware/OHHTTPStubs/builds/144140405\n- https://travis-ci.org/AliSoftware/OHHTTPStubs/builds/144144290\n\n\u25b8 Signing /Users/travis/Library/Developer/Xcode/DerivedData/OHHTTPStubs-gozjzzlydcppgdbvdohewsnafzwl/Build/Products/Debug-iphonesimulator/OHHTTPStubs\\ iOS\\ Fmk\\ Tests.xctest\n* TEST FAILED *\nrake aborted!\nCommand failed with status (65): [set -o pipefail && xcodebuild -workspace O...]\n. Done \u2728 \n. Anything else?\n. Is the same issue happening on Xcode 7.3 now?\n- https://travis-ci.org/AliSoftware/OHHTTPStubs/jobs/144734002\n- https://travis-ci.org/AliSoftware/OHHTTPStubs/jobs/144734014\n. Thanks for the invitation, it's really great! \ud83d\ude04 \n. Looks like build test might be better than just test for Xcode 7.3.\n. > Maybe I'm missing some user-side settings that could make the lib works with Swift 2.x code without changing the SWIFT_VERSION here \ud83e\udd14\n\nCocoaPods users can work around this thanks for the PRs: https://github.com/CocoaPods/CocoaPods/pull/5540, https://github.com/CocoaPods/CocoaPods/pull/5760\nbut Carthage users can't.\n\nMy advice would be to set SWIFT_VERSION to 2.3 here and have a swift3.0 branch in the repository changing it to 3.0.\n\n\ud83d\udc4d from me.\n. Rebased\n. > What Swift versions are compatible with that annotation?\n@discardableResult is for Swift 3, not compatible with Swift 2.3 (that is almost same as Swift 2.2).\n. You should update to CocoaPods 1.1.0 (currently rc2) to be used with Xcode 8: gem update cocoapods --pre.\n. @kuyoonjo FYI you can close a issue by yourself.\n. I'm sorry, mistook :bow:. > You'll have to use the --no-use-binaries flag of Carthage to solve this issue with all other libraries you use in your Cartfile. You can find more info in Carthage's own documentation & issues.\nFYI Carthage now falls back to build checked out projects if prebuilt binaries was built with different Swift version from local Swift version, so normally you will not need to add --no-use-binaries option.. And also the message is just an info or warning, not an error. Carthage automatically falls back to build the framework locally.. @Liquidsoul\n\nAFAIK, the support of multiple Swift versions is not possible with Carthage, we've even opened an issue about this that was not resolved.\n\nXcode 9 and above support Swift 3.x and Swift 4 for each-target basis, so this should not be an issue nowadays.\n\nXcode 9.x has one Swift 4 compiler which supports both Swift 4 language mode and Swift 3 language mode, and the binaries are binary-compatible; consequently you can mix the binaries in one project\nXcode 8.x has two separate Swift 2.x compiler and Swift 3.x compiler, so the binary built with the former is not binary-compatible with the binary built with the latter; consequently you can not mix the binaries in one project. \n",
    "Munchery-KleinLieu": "Bump...I get this during unit tests too :/\n. ",
    "dtrenz": "As I continue to research the issue, it looks like this might not be possible. Unlike unit tests, it appears that UI test code executes in an completely separate module and therefore cannot directly access or modify the underlying app logic that is under test.\nI think the only way you could use OHHTTPStubs in UI tests would be to build them into the actual app \u2014 disabled by default \u2014 and then enable the stubs via some launch argument sent in when running UI tests.\nI'd love to hear other options.\n. Excellent response. Thanks, Ali!\n. Very nice. \nDid you create a class that manages this and call it in applicationDidFinishLaunching?\n. So, I tried this and got it working, but I'm backing off for now because I don't love having to include so much test code/fixtures in the app bundle. But I can attest that this does work. I would love to see how others find more elegant solutions to this.\n. ",
    "collinsrj": "After a suggestion from Ali, I have successfully setup stubs in my main application. I took the approach suggested using the launch options for the XCUIApplication.\nI wanted to have my test cases responsible for the definition of the stub. To make this happen I'm playing with passing stub definition in the XCUIApplication.launchEnvironment. E.g. in my test case define an environment variable named 'HTTP_STUB_SOME_TEST' with a value something like '{\"host\":\"example.com\",\"statusCode\":200, \"data\": ... }'\nIn my application code, inside a debug block I look at NSProcessInfo().environment and check for variables with names starting with \"HTTP_STUB_', parse the JSON definition and create the stubs the usual way.\n. @dtrenz yes, that's exactly what I did. It's a bit of a  hack. I haven't tried it with any substantial amount of data. I'm not sure how much can be passed through the environment. At the moment I'm still experimenting. Certainly for my small mocks at the moment it's working fine.\n. ",
    "tcamin": "We just released our library SBTUITestTunnel which kinda worksaround the issue. At the app's launch we instantiate a web server on the app that conveniently translates requests coming from UI Test code. The big advantage over launchArguments is that you can dynamically modify app's behavior during test execution.\nCurrently you can stub HTTP (of course using OHHTTPStubs \ud83d\ude00), download/upload files to app's sandbox, monitor HTTP requests (a sort of proxy) and access to NSUserDefaults. Give it a try, hope this helps!\n. ",
    "kumarSC": "Hey @collinsrj and @dtrenz , I have been trying to setup stubs for UI tests but couldn't get them to work correctly, could you please share some code which demonstrates how we can use launchArguments and  Stub setup in main app bundle using applicationDidFinishLaunching().\n. Hey @kleinlieu , thanks for the response.I followed the instructions here to setup OHHTTPStubs, https://github.com/AliSoftware/OHHTTPStubs/wiki/A-tricky-case-with-Application-Tests. I am using XCUIApplication.launchEnvironment to pass a JSON to app bundle to setup the stubs.Later in the main app bundle where we are using OHHTTPStubs for faking network data we are using applicationDidFinishLaunching to setup app for unit test.\nfinal class TestingAppDelegate: UIResponder, UIApplicationDelegate {\n    var window: UIWindow?\n    func applicationDidFinishLaunching(application: UIApplication) {\n        NetworkConnectionChecker.start()\n        window = UIWindow()\n        window?.rootViewController = UIViewController()\n        window?.makeKeyAndVisible()\nIn order to setup the stubs for UI tests, I need to figure out how I can initialize all the stubs and call them in applicationDidFinishLaunching for use in UI tests.Some code example might help me get going.\n. ",
    "kleinlieu": "@kumarSC what's your setup look like? Make sure your OHHTTPStubs pod is built with the application target and not the testing target. That was key for me.\n. ",
    "Janglinator": "Mark as a feature request!\n. I'd absolutely agree having a separate library.  When I get a chance, I'll do a little digging around to see if there is already a library for this, or at least something to start from.\n. That's an interesting approach.  I've actually been using an extremely simple URL matcher I wrote quickly based off the idea.  It just has one method, takes an NSUrl alongside the test string, and returns a boolean of whether it checks out.  I'm far from being a networking expert, but I really like his approach.  I'll give it a go one of these days, and check back\n. But the fact that I can manually remove those stubs, and re-add them proves there's a solution to be had for this issue.  While forcing the user to re-add the stubs after re-enabling OHHTTPStubs would be bad, wouldn't disabling the stubs tests when OHHTTPStubs is disabled be a valid solution?\n. I'll make a PR when I have a chance.\nI understand your case, but I'm not certain I agree.  It seems that OHHTTPStubs.enabled should reflect whether or not OHHTTPStubs has any influence.  So when a user disables OHHTTPStubs, the application should behave exactly as if OHTTPStubs was never installed/enabled in the first place.\n. ",
    "iwllyu": "Thanks for the response! I didn't think it was a test set-up error because the tests were working before we updated to Swift 2.0 but perhaps it was just coincidental with some other changes we were making\n. Perhaps. I do have a question after reading the wiki.\nIt says not to use OHHTTPStubs in the app code (to mock TBD services) - but in the sample code it's only in the test target. So if I understand correctly I do not need to \"...avoid linking OHHTTPStubs to the test target so that it is only loaded once\" since it's only loaded to the test target when the application loads?\n. > On the contrary, you could use OHHTTPStubs...\nSorry, I mean the wiki states don't use OHHTTPStubs in app and in unit tests when using hosted tests\nBy sample code I'm referring to my sample of the \"bug\" I'm experiencing https://github.com/iwllyu/test-ohhttpstubs\n. Thanks for taking a look.\nOkay here is where I am confused\nper the wiki\n\nIf you linked OHHTTPStubs with both the app and the test bundle, there will be two independent instances of OHHTTPStubs loaded at runtime.\n\nOHHTTPStubs is not linked in the app bundle, only the test bundle\n\nEvery code loaded by the Application Bundle (like code from your model classes) will use the instance of OHHTTPStubs loaded by the application\n\nIt is fine (for now, anyways) if the Alamofire request in the App calls makes an actual request\n\nEvery code loaded by the Test Bundle (like code in your test suite) will use the instance of OHHTTPStubs loaded by the test bundle\n\nThis is not happening, the test Alamofire request is calling the actual service even though there is an OHHTTPStub registered before the request. Removing the Alamofire request in the app resolves this.\nLet me know if I misunderstood something\n. I really appreciate the time you spent looking into this.\nI've made it so Alamofire requests aren't made during startup (there was a view controller being initialized that made the API call, I delayed the request until the viewWillAppear) - although we could also switch to non-hosted since we aren't doing any UI testing.\nThanks again for all the help\n. ",
    "rcdilorenzo": "@AliSoftware: Your last comment here was very helpful for me as well. Thanks!\n. ",
    "adamwaite": "God bless you @AliSoftware \n. ",
    "igorbelo": "hello @AliSoftware I'm swift/xcode beginner and have to write some tests for my company's app. I'm sorry if it's a too silly question (and it's not related to OHHTTPStubs directly) but how do I do the following?\n\n... add OHHTTPStubs to your app bundle instead of your test bundle, so that it's loaded as soon as the app is launched when running your tests \n. @AliSoftware even doing that I'm getting a hit in my API server...don't know if it's due an outdated version of CocoaPods (0.39.0) we are using. Digging a little bit more to see if worth to open an issue for that.\n\nUPDATE: even upgrading CocoaPods to last version and scoping the libs into targets I couldn't manage it to work.\nPodfile\n``` ruby\nsource 'https://github.com/CocoaPods/Specs.git'\nplatform :ios, '8.0'\nuse_frameworks!\ndef shared_pods\n    # Forced using Github as source. Specifying only the Pod Name was fetching an older version\n    pod 'Pluralize.swift', git: 'https://github.com/joshualat/Pluralize.swift.git'\n# Replacement for UIPageControl\npod 'SMPageControl'\n\n# SwiftyJson\npod 'SwiftyJSON', :git => 'https://github.com/SwiftyJSON/SwiftyJSON.git'\n\n# Alamofire https://github.com/Alamofire/Alamofire\npod 'Alamofire', '3.2.0'\n\n# SwiftValidator https://github.com/jpotts18/SwiftValidator\npod 'SwiftValidator', '~> 3.0.1'\n\n# https://github.com/honghaoz/AutoKeyboardScrollView\npod \"AutoKeyboardScrollView\", '~> 1.4'\n\n# HanekeSwift https://github.com/Haneke/HanekeSwift\npod 'HanekeSwift'\n\n# https://github.com/gilesvangruisen/Swift-YouTube-Player\npod 'YouTubePlayer'\n\n# https://github.com/scalessec/Toast-Swift\npod 'Toast-Swift', '~> 1.3.0'\n\n# https://github.com/oarrabi/OAStackView\npod 'OAStackView'\n\npod 'OHHTTPStubs/Swift'\n\nend\ntarget 'MyProject' do\n    shared_pods\n    pod 'OHHTTPStubs'\nend\ntarget 'MyProjectTests' do\n    shared_pods\nend\n```\nTest case\n``` swift\nimport XCTest\n@testable import MyProject\nimport OHHTTPStubs\nclass ApiClientTests: XCTestCase {\n    override func setUp() {\n        super.setUp()\n        stub(isPath(\"/api/notifications/\")) { _ in\n            let stubData = \"Hello World!\".dataUsingEncoding(NSUTF8StringEncoding)\n            return OHHTTPStubsResponse(data: stubData!, statusCode:200, headers:nil)\n        }\n    }\noverride func tearDown() {\n    super.tearDown()\n}\n\nfunc testNotificationsWhenLoggedIn() {\n    let api = ApiClient.sharedInstance()\n    let expectation = expectationWithDescription(\"Alamofire\")\n\n    api.notifications() { response in\n        XCTAssertTrue(response.success)\n        expectation.fulfill()\n    }\n\n    waitForExpectationsWithTimeout(5.0, handler: nil)\n}\n\n```\nI'm using Alamofire and my notifications() method just makes a GET request to the stubbed path /api/notifications/\nAny ideas?\n. ",
    "glyuck": "Ok, I've come across same issue yesterday, spent 4 hours debugging and... The problem was I've not included pod 'OHHTTPStubs' into my Podfile. I've had only pod 'OHHTTPStubs/Swift' there. Yes, it's stupid, yes it's documented in OHHTTPStubs' README. Hope it will help someone else. Once again, correct Podfile should look like this:\npod 'OHHTTPStubs'  # This one is required for Alamofire to work\npod 'OHHTTPStubs/Swift'\nProbably it's an issue for @igorbelo because his podfile omits OHHTTPStubs pod for Tests target.\n. ",
    "johndpope": "maybe relevant to some - (the podspec doesn't actually work - doesn't look a pull request has been opened to cocoapods) https://github.com/michaelhayman/OHHTTPStubsExtensions\n. I'm getting really good mileage using SWHttpTrafficRecorder \npod 'SWHttpTrafficRecorder'\nimport SWHttpTrafficRecorder/SWHttpTrafficRecorder.h\n```\n[SWHttpTrafficRecorder sharedRecorder].recordingFormat =  SWHTTPTrafficRecordingFormatBodyOnly;\nNSArray documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString docs = [documentPath objectAtIndex:0];\nNSString *path = [docs stringByAppendingPathComponent:@\"yourLoggingDir\"];\n[[SWHttpTrafficRecorder sharedRecorder] startRecordingAtPath:path error:nil];\n```\n. Ok - here we go.\nhttps://github.com/johndpope/HAR-Reader/blob/master/HarReader/AppDelegate.swift. I built a class that takes a HAR file - and will automatically stub entire payload via OHHTPStubs.\nAlbeit it's in swift. It will even mock the server response codes.\nHARStub.stubHarFile(fileName: \"openlab.har\")\nso given a charles capture - it will play back everything as if the internet existed without being online.\nI think the intention of ohhtpstubs was to do this and all - this is cleaner - provides a snapshot of api for stable developent - allows drag and drop traffic playback from charles captures.\nI think people will want to use this or I'm also building another plist to load json given a url. \nThis is a must have 1 liner. Please consider exposing feature in main project. \nIt doesn't need to be a subspec. \nI'm building out in my app to provide in flight switching of different environments using AppConfigSwift https://raw.githubusercontent.com/wwe-johndpope/AppConfigSwift/master/Images/AppConfigSwift.gif\nSource of frustration and drive to build this out was really to allow developers to mock entire api stack centrally from one place. The HAR file is one way - the other sample I sent through did it by code. I'm also slowly working on a  simple plist  approach. \nURL -> json file\nURL -> json file\nURL -> json file\nURL -> json file\nthen load this en masse. \nI will flesh out this example with AppConfigSwift when I have time. \n. that'd work - I don't suppose you can / or want to mix swift with cocoapod library. \nprobably really really bad idea. . spring cleaning my github issues - 56 to go. \nThanks for your efforts here @AliSoftware . it would nice to have afnetworking / alamofire samples.\nhttps://github.com/billyto/Apptester/tree/15d55e7c0f4aa87e3a3fb5bec08b66fb15c69d0f\n. closing this as part of spring cleaning exercise. . ",
    "ivanruizscm": "@glyuck same problem as you, i spend the whole day. I suggest adding auto dependency if pod 'OHHTTPStubs/Swift' just include pod 'OHHTTPStubs'.\n. thx you so much\n. ",
    "AnandWalvekar": "Hi @AliSoftware \nThank you very much for the article. I have added OHHTTPStubs to App bundle and written stubs in didFinishLaunchingWithOptions method. But I want to move all the stubs added in didFinishLaunchingWithOptions to UI testing bundle's testMethods(). I tried accessing app OHHTTPStubs from the UI testing bundle as below but could not succeed.\nlet appOHHTTPStubs = Bundle.main.classNamed(\"OHHTTPStubs\")\nappOHHTTPStubs?.stubRequests(...)\nIf we can't achieve what I am trying, is there a better way to move stubs code out of didFinishLaunchingWithOptions to improve the launch experiment while automating(we will off course not stub responses if app is not being launched from unit testing target). Did you say you need to remove \"A workaround if you really need it\" section from your article?. ",
    "jshier": "This may be related to what I'm seeing in Xcode 7.1. In OHHTTPStubs.h, line 32, I get an error: Include of non-modular header inside framework module OHHTTPStubs.OHHTTPStubs. This is using CocoaPods as such: \nruby\n  pod 'OHHTTPStubs/Core'\n  pod 'OHHTTPStubs/NSURLSession'\n  pod 'OHHTTPStubs/JSON'\n  pod 'OHHTTPStubs/OHPathHelpers'\n  pod 'OHHTTPStubs/Swift'\n. Fixed my build as well. \n. ",
    "billyto": "I tried settting \"Allow Non-modular includes in Framework Modules\" in Build Settings to YES, but no luck, anyone has another workaround?\n. Pointing at \n:branch => 'fix/umbrella-header'\nIt worked in my tests!\n\n. ",
    "incanus": "The fix branch is working great in my testing on several projects, too. \n. ",
    "madoke": "Can still reproduce this issue on XCode 7.2 / CocoaPods 0.39.0 when doing a fresh pod install (after removing the Pods folder) with the following Podfile configuration:\n```\ntarget 'AppCoreTests' do\n    use_frameworks!\npod 'OHHTTPStubs'\npod 'OHHTTPStubs/Swift'\n\nend\n```\nI can workaround it, however by commenting out the line pod 'OHHTTPStubs/Swift', doing a pod install, then uncommenting it and doing a pod install again.\n. ",
    "MaxGabriel": "@AliSoftware I've made the suggested changes; good idea to use fileURL for the method names. I can rebase them into a single commit if you'd like; just wanted to give you the chance to see the new commit first.\n. > Additional idea, not sure it's really useful/needed, but do you think adding an OHPathHelper for returning NSURL for fixtures would also be handy for people using NSURLs in their tests?\nI'm not sure. Right now I have two methods that all my test code uses to load files for HTTP stubbing (pasted below), so it's not a considerable typing saver for me. They'd be quick to write so I'll add them if you'd like.\n``` objc\n+ (NSMutableDictionary )jsonForResource:(NSString )resource\n{\n    NSURL url = [[NSBundle bundleForClass:[self class]] URLForResource:resource withExtension:@\"json\"];\n    NSData data = [NSData dataWithContentsOfURL:url];\nNSError *error;\nNSMutableDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers|NSJSONReadingMutableLeaves error:&error];\n\nNSAssert(error == nil, @\"Error should be nil\");\nNSAssert(json, @\"JSON shouldn't be nil\");\n\nreturn json;\n\n}\n```\n``` objc\n+ (id)stubRequestContainingString:(NSString )string withVideoFile:(NSString )videoFileName {\n    NSParameterAssert(string);\n    NSParameterAssert(videoFileName);\n    NSURL *url = [[NSBundle bundleForClass:[self class]] URLForResource:videoFileName withExtension:@\"mp4\"];\n    NSParameterAssert(url);\nreturn [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {\n    return [request.URL.absoluteString hzContainsString:string];\n} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {\n    return [[OHHTTPStubsResponse alloc] initWithURL:url statusCode:200 headers:@{@\"content-type\":@\"video/mp4\"}];\n}];\n\n}\n``\n. Awesome, thanks @AliSoftware. I think all comments are responded to. I wanted to note that these two points ended up both being covered bytest_InvalidPathWithURL`.\n\n\ntransform your test_InvalidPathWithURL test so it uses a valid URL but pointing to an invalid path (file://foo/bar for example) \u2014 instead of it using a string that will return a nil NSURL and duplicate the previous test\nadd a test for an NSURL for which you couldn't get the file size, to cover the case of this part of your code (maybe using a network NSURL there?)\n. Sure, good idea for that test. \n. @AliSoftware Any idea why these tests fail? It looks like [NSURL URLWithString:@\"http://www.iana.org/domains/example/\"]; is being considered as a file URL by the tests. The tests pass for me locally, but not on Travis.\n. Potentially related is that isFileURL is only available on iOS 8+, whereas OHHTPStubs supports back to iOS 5. Thoughts?\n\n\nEdit: I switched to this approach of detecting file URLs, which seems to pass the tests and should be compatible with iOS 5.\n. @AliSoftware Oh good call about the assertions. It looks like assertions are disabled in the release configuration of the libraries. Do you prefer using @throw or just setting ENABLE_NS_ASSERTIONS to YES? There are a couple of other NSAsserts in the codebase besides the ones I added.\n. Thanks for all your help @AliSoftware and @samirGuerdah! I think this came out great\n. Oh wow, actually this method is totally incorrect; in the case of an error the object is never initialized. \nDo you think something like this would work? I think I only need to check that the NSNumber is nil.\n``` objc\nNSError error;\nNSNumber fileSize;\nBOOL success = [fileURL getResourceValue:&fileSize forKey:NSURLFileSizeKey error:&error];\nif (!fileSize) {\n    fileSize = @0;\n    inputStream = [NSInputStream inputStreamWithData:[NSData data]];\n    NSLog(@\"%s: Couldn't get file size for URL; returning empty data instead. \\\nThe URL was: %@. \\\nThe operation to retrieve the file size was %@. \\\nThe error associated with that operation was: %@\",\n    PRETTY_FUNCTION, fileURL, success ? @\"successful\" : @\"unsuccessful\", error);\n}\nself = [self initWithInputStream:inputStream\n                        dataSize:[fileSize unsignedLongLongValue]\n                      statusCode:statusCode\n                         headers:httpHeaders];\n``\n. @AliSoftware From the documentation it sounds likesuccesscan beYES`, no error would be set, and the returned value would be nil:\n\nIf this method returns YES and value is populated with nil, it means the resource property is not available for the specified resource and no errors occurred when determining the resource property was not available.\n\nThis code really only cares about fileSize being non-nil\u2014I think the values of success and error are only useful for informing the user why the operation failed in this case.\n. Fair enough. Here's what I have then:\n``` objc\n-(instancetype)initWithFileURL:(NSURL )fileURL\n                    statusCode:(int)statusCode\n                       headers:(nullable NSDictionary )httpHeaders {\n    NSInputStream inputStream;\n    NSNumber fileSize;\n    if (fileURL)\n    {\n        // [NSURL -isFileURL] is only available on iOS 8+\n        if (![fileURL.scheme isEqualToString:NSURLFileScheme]) {\n            @throw [NSException exceptionWithName:NSInternalInconsistencyException\n                                           reason:[NSString stringWithFormat:@\"Only file URLs may be passed to %@\", NSStringFromSelector(_cmd)]\n                                         userInfo:nil];\n        }\n        inputStream = [NSInputStream inputStreamWithURL:fileURL];\n    NSError *error;\n    BOOL success = [fileURL getResourceValue:&fileSize forKey:NSURLFileSizeKey error:&error];\n\n    if (!success || !fileSize) {\n        fileSize = @0;\n        inputStream = [NSInputStream inputStreamWithData:[NSData data]];\n        NSLog(@\"%s: Couldn't get file size for URL; returning empty data instead. \\\n\nThe URL was: %@. \\\nThe operation to retrieve the file size was %@. \\\nThe error associated with that operation was: %@\",\n                  PRETTY_FUNCTION, fileURL, success ? @\"successful\" : @\"unsuccessful\", error);\n        }\n    }\n    else\n    {\n        NSLog(@\"%s: nil URL. Returning empty data\", PRETTY_FUNCTION);\n        fileSize = @0;\n        inputStream = [NSInputStream inputStreamWithData:[NSData data]];\n    }\nself = [self initWithInputStream:inputStream\n                        dataSize:[fileSize unsignedLongLongValue]\n                      statusCode:statusCode\n                         headers:httpHeaders];\n\nreturn self;\n\n}\n```\n. I like this version a better; there's some duplication in returning empty data but there's much less nesting:\n``` objc\n-(instancetype)initWithFileURL:(NSURL )fileURL\n                    statusCode:(int)statusCode\n                       headers:(nullable NSDictionary )httpHeaders {\n    if (!fileURL) {\n        NSLog(@\"%s: nil URL. Returning empty data\", PRETTY_FUNCTION);\n        return [self initWithInputStream:[NSInputStream inputStreamWithData:[NSData data]]\n                         dataSize:0\n                       statusCode:statusCode\n                          headers:httpHeaders];\n    }\n// [NSURL -isFileURL] is only available on iOS 8+\nif (![fileURL.scheme isEqualToString:NSURLFileScheme]) {\n    @throw [NSException exceptionWithName:NSInternalInconsistencyException\n                                   reason:[NSString stringWithFormat:@\"Only file URLs may be passed to %@\",NSStringFromSelector(_cmd)]\n                                 userInfo:nil];\n}\n\nNSNumber *fileSize;\nNSError *error;\nconst BOOL success = [fileURL getResourceValue:&fileSize forKey:NSURLFileSizeKey error:&error];\n\nif (!success || !fileSize) {\n    NSLog(@\"%s: Couldn't get file size for URL; returning empty data instead. \\\n\nThe URL was: %@. \\\nThe operation to retrieve the file size was %@. \\\nThe error associated with that operation was: %@\",\n              PRETTY_FUNCTION, fileURL, success ? @\"successful\" : @\"unsuccessful\", error);\n        return [self initWithInputStream:[NSInputStream inputStreamWithData:[NSData data]]\n                                dataSize:0\n                              statusCode:statusCode\n                                 headers:httpHeaders];\n    }\nreturn [self initWithInputStream:[NSInputStream inputStreamWithURL:fileURL]\n                        dataSize:[fileSize unsignedLongLongValue]\n                      statusCode:statusCode\n                         headers:httpHeaders];\n\n}\n```\n. > Feels odd to me that we'd @throw in one case (using a non-file URL) and just NSLog in the other (failing to get file size). I say we'd use one or the other for both. Probably @throw. What's your take?\n@AliSoftware I definitely agree it's strange; I prefer @throw for both, especially since this is a testing library. ~~The only thing I was worried about was that existing code could be counting on nil file paths returning empty data instead of throwing an exception.~~\nEdit: I misread your comment. I agree on @throw for both.\n. ",
    "tuzonghua": "Ah, my bad. Closing.\n. ",
    "alexkent": "Thanks a lot for your help!\n(and this great library!)\n. ",
    "tiagomartinho": "You were right, the deployment version should only be increased by the tests targets. I reverted the deployment target for the pod targets.\nRegarding the tests I found that AFNetworking has the method setTaskWillPerformHTTPRedirectionBlock in AFURLSessionManager. I will try using this one to adapt the failing tests.\n. I was able to fix the failing tests using the setTaskWillPerformHTTPRedirectionBlock method from AFNetworking.\n. Welcome! Thank you for merging.\nSent from my iPad\n\nOn 31 Oct 2015, at 22:16, AliSoftware notifications@github.com wrote:\n4.5.0 is out, thanks a lot for this PR again!\n\u2014\nReply to this email directly or view it on GitHub.\n. Glad to help!. \n",
    "kremizask": "Thank you very much! Adding the /Swift subspec indeed resolved the issue for me. I wasn't aware of how subspecs worked and I naively assumed they were supposed to be included automatically via pod install.\n. ",
    "pantuspavel": "Hi, thanks for merging. Will definitely add watchOS platform when have a minute.\n. That's fast! Thank you! Time to update my Podfile ;)\n. ",
    "stefreak": "Nice! You were too fast for me to create a PR :)\n. ",
    "jzucker2": "I saw this and decided to take a run at the idea. Let me know what you think https://github.com/AliSoftware/OHHTTPStubs/pull/159\n. Just in case you forgot, you can close this now :)\n. This is a thread about the issue. Supposedly fixed in the next beta. Definitely present in 0.39 https://github.com/CocoaPods/CocoaPods/issues/4478\n. No rush on this pull request. Just saw an opportunity to help and wanted to contribute.\n. There's not a ton of great documentation on @synchronized, seems it's slightly out of favor. I tried to follow your pattern in this implementation. Also open to using a NSLock or a mutex, if you'd prefer. Just figured I'd try out your original suggestion first.\n. Fixed!\n. Also, was CI disabled for this project?\n. CI ran this time!\n. Thank you! That's an easy fix\n. Thanks for the suggestion!\n. Using self instead of _enabledStateNumber because that might change and cause multiple locks to be enabled for this property\n. Same as above\n. Yes, that seems obvious now. I originally wrote it intending to do @synchronized(_enabledState) when I didn't fully understand the @synchronized() directive. Anyways, updated with another commit.\n. Good point!\n. ",
    "siemensikkema": "Sounds plausible. I don't know why this wasn't set correctly. I have other dependencies where this doesn't cause a problem. Could it be related to the renaming of OHHTTPStubs iOS-Info.plist to Info.plist? I don't see this in my other dependencies but this is just a wild guess.\nSome use ${CURRENT_PROJECT_VERSION} instead of $(CURRENT_PROJECT_VERSION) but either seems to work.\nYou might want to set the version for Mac to $(CURRENT_PROJECT_VERSION) as well because currently it reads 1.\n. Great! I can stop using my fork now :) I'll upload a test build soon and if I run into any problems I'll report back.\n. ",
    "Voley": "If I remove headers, I get 'Use of undeclared identifier: OHHTTPStubs'\n. Ok i will try and report back\nOn Thursday, 3 December 2015, AliSoftware notifications@github.com wrote:\n\nOf course you would. That's how headers work [image: :smiley:]\nWhy would you just remove headers instead of following Samir's\ninstructions and fix your Podfile?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/AliSoftware/OHHTTPStubs/issues/142#issuecomment-161435487\n.\n. \n",
    "DerLobi": "Added it to the property\n. ",
    "attheodo": "Sure, no problem. Thanks\nKind regards, \nAT.\nSent from iPhone\n\nOn 15 \u0394\u03b5\u03ba 2015, at 22:17, AliSoftware notifications@github.com wrote:\nGood idea indeed!\nCould you maybe make a Pull Request? (with the new method + some tests on the same model as the other for isGET etc + crediting yourself in the CHANGELOG)\nThx!\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "ogezue": "Wow - fastes response time ever in github ever! :+1: \nIt can resolve \n-import OHHTTPStubs\n-stub(isHost(\"mywebservice.com\"))\nBut not\n-fixture(stubPath!, headers: [\"Content-Type\":\"application/json\"])\n- or isMethodGet(\"\")\nThe swift files is existing in the pod directory in my project.\n. Yes, I meant isMethodGET sorry for writing it wrong here. But XCode even can not find it if I type it correctly. \nThe error is:\nOverviewModelTests.swift:26:20: Cannot convert return expression of type 'OHHTTPStubsResponse' to return type 'Response'\nBut the core of the problem is that it ignores the methods in your swift-wrapper.\n. I'm using XCode 7.2.\nI changed the method to this:\n```\n    override func setUp() {\n        super.setUp()\n    stub(isMethodGET(\"mywebservice.com/get\")) { _ in\n        let stubPath = OHPathForFile(\"Overview.json\", self.dynamicType)\n\n        return fixture(stubPath!, headers: [\"Content-Type\":\"application/json\"])\n    }\n\n    /*\n    stub(isHost(\"mywebservice.com\")) { _ in\n        let stubPath = OHPathForFile(\"Overview.json\", self.dynamicType)\n        //isMethodGet(\"\")\n\n       return fixture(stubPath!, headers: [\"Content-Type\":\"application/json\"])\n    }\n    */   \n}\n\n```\nand now I'm getting\n Cannot call value of non-function type 'OHHTTPStubsDescriptor?' on line stub(isMethodGET(\"mywebservice.com/get\")) { _ in\n. Ok - forget this example. I copied a slightly modified piece of your example project into my test with the same error.\nTo be sure I added the modified code to your project where it compiles fine.\nvar mytextStub = stub(isExtension(\"txt\")) { _ in\n            let stubPath = OHPathForFile(\"stub.txt\", self.dynamicType)\n            return fixture(stubPath!, headers: [\"Content-Type\":\"text/plain\"])\n        }\nError : Cannot convert return expression of type 'OHHTTPStubsResponse' to return type 'Response' in line \nreturn fixture(stubPath!, headers: [\"Content-Type\":\"text/plain\"])\n. Because my example project worked fine - I cleared my cocoapods cache and reloaded all pods again. Now this is working...\n. But this doesn't work either?\n```\nself.httpStubHeader = stub(isPath(\"/ressources/objects\")) { _ in\n            let stubPath = OHPathForFile(\"objetcs.json\", self.dynamicType)\n        return fixture(stubPath!,status: 200 ,headers:\n            [\"Content-Type\":\"application/json\"])\n\n```\n. Thank you! This here was exactly what I was looking for and should be mentioned in the examples:\nstub( { request in request.URL.absoluteString == \"http://www.myserver.com/ressources/objects\" } ) { _ in\n  \u2026\n}\n. Perhaps this info helps: If I print stubs at the end of the setup method \nlet stubs = OHHTTPStubs.allStubs()\n        print(stubs)\nI get this here:\nPrinting description of ((OHHTTPStubsDescriptor *)0x00007fb019ee9050):\n<OHHTTPStubsDescriptor 0x7fb019ee9050 : (null)>\nis (null) ok?\n. I think thats is not my problem. I haven't changed here something in my setup. I recognized that my build-system reports a much greater number of tests than really existing (41 existing / 471 reported). The tests that don't rely on OHHTTPStubs work fine.\nPerhaps you have some advice for debugging if you watch my setup method above?\nThe (null) was my fault because I'm in charge to set a name if I want. Added a name, the null is gone but the problem still exists.\n. Thank you very much for your support - that's really great.\nI replaced the inside of my setUp method with your code and recognized the following:\n- The body of the closure is never called\n- My test fetches data from the network and compares the server response.\nIs there some point in your framework where I can observe the comparison of the urls? Other ideas?\nHere is my podfile - perhaps an other lib causes the problem?\n```\nplatform :ios, '9.0'\nuse_frameworks!\npod 'Alamofire', '~> 3.2.0'\npod 'AlamofireObjectMapper', '~> 2.1.2'\npod 'RealmSwift', '~> 0.98.2'\npod 'KeychainAccess', '~> 2.3.3'\npod 'Mattress', '~> 1.0.3'\npod 'ReachabilitySwift', '~> 2.3.3'\npod 'SwiftyBeaver', '~> 0.3.3'\npod 'Chatto', '= 1.0.0'\npod 'ChattoAdditions', '= 1.0.0'\npod 'Attributed'\npod 'PermissionScope'\ntarget 'MyAppTests' do\n   pod 'OHHTTPStubs'\n   pod 'OHHTTPStubs/Swift'\nend\n```\n. That's it! The problem was that I had a automatic login with credentials from the keychain in my delegate... I think I have to redesign my test / application architecture.\nPerhaps it is something to add to your documentation?\nThank you ver much!\n. ",
    "johndpope-karhoo": "this sample code switching may help https://github.com/paulononaka/swift_restfull_sample/blob/a67e77f120583b3c76ad3da374c3672bf88e9e68/vivira_health_ios/Stubs/HTTPStub.swift\n. I love this project - thanks for the time you spent on.\nI am finding more uses for it each day. \nIt maybe worthwhile sending users to pre-canned search on github gist\nhttps://gist.github.com/search?utf8=%E2%9C%93&q=OHHTTPStubs\nThis serves a couple of purposes -\n1) other users sharing their OHHTTPStubs gists\n2) curating better scripts.\nI didn't find a single script to encapsulate my needs - but mocking server side errors has now become biggest use case that every app should have - and I want a canonical example that can handle every edge case. Happy to contribute once I have more time.\n. ",
    "vicmosin": "I use the snippet you used in docs:\nstub(isHost(\"mywebservice.com\")) { request in\n  return OHHTTPStubsResponse(fileAtPath:OHPathForFile(\"wsresponse.json\", self.dynamicType)!\n    statusCode:200 headers:[\"Content-Type\":@\"application/json\"])\n}\nbut don't know which actions should I do in xCode project itself in order to make the file \"visible\" to OHPathForFile method\n. That's a point that second request is not triggered, but definitely called \n. Oh, you are right, the second call contained www.* prefix. Thanks for pointing to it!\n. It's not about creating nullable OHHTTPStubsResponse object, I guess you misunderstood me. I was talking about nullable response body within OHHTTPStubsResponse object.\nThe case is the following: I use Alamofire to make requests, its logics puts the response into NSData? instance, but if I use the examples I posted in original post, the value of that NSData is not nil, but length = 0. I am not sure if it's their issue or OHHTTPStubs's...\nP.S.\nI can handle it by additional checking if response.length > 0 anyway\n. It wasn't my question...\nI'm just trying to understand: should I treat that behavior as a bug or not. Optional values were introduced exactly for these purposes and to me it looks like an issue - if data object contains no data it should be nil..\n. So I guess it's mostly Alamofire's issue/feature rather then OHHTTPStubs's...\n. Just checked Alamofire's default serialization sources. They use SerializationResult<NSData, ErrorType> for every single serializer, so that's why final result is not nil but has a length of 0. I guess we can close the issue since it can be handled by additional check at client-side.\n. ",
    "JeanAzzopardi": "I bumped the version requirements and added an entry in the Changelog. (Note that the link to 4.7.1 is inactive, I'm sort of assuming that it would be a 4.7.1. release)\nThanks!\n. Thanks!\n. ",
    "SpaceTrucker2196": "I'm importing with Cocoapods.\nI tried \npod 'OHHTTPStubs/Default' \nwhich didn't seem to make a difference over just\npod 'OHHTTPStubs'\nI was able to just load my service data by loading into an NSDATA object first with a regular file load.\nSince then I've ran into another problem. I'm using AFNetworking and doing my requests thru a AFURLSessionManager. My web service calls are then done with the dataTaskWithRequest:completionHandler method. \nI can see that my requests are hitting the stub using onStubActivation and naming my stub with the .name property.\nHowever the completionHandler block never executes.  The session manager looks right and my code executes outside of tests correctly.\nThanks for your quick response on the first issue!\n. I looked like I was having issues with where the Stub was set up. I saw some commentary on the web about making sure you set up the stubs at the right time in the url session lifecycle before any requests are issued. that seem to fix my issue.\n. closing. Thanks for your help!\n. ",
    "hq-mobile": "Awesome!\nSorry not sure I understand what you mean by some ## Master title.  Could you possibly give an example?\n. Great, thank you! Will do that now.\n. ",
    "iamtomcat": "You could also not include a prebuilt framework. While it makes it slower for people as they would have to wait for carthage to build it, but it would fix the incompatibility issue.\n. Just as a workaround atm. I've added\ngithub \"AliSoftware/OHHTTPStubs\" \"6d305e8a834cb78f7e07433b9a9ae13f8c172910\"\nwhich is just the 4.8.0 commit itself.\n. Cool, thank you.\n. ",
    "AlexDenisov": "@AliSoftware I can't say what is better for Carthage, but newly built framework in any form will work for us, since we use custom solution for managing dependencies.\n@iamtomcat I think it's still helpful to have both options.\n. @AliSoftware TIL :)\nThe way you choose will work us as well.\nThank you for working on the problem.\n. ",
    "skovatch": "For Carthage you could use carthage bootstrap --no-use-binaries and it will rebuild from the source code and ignore the included zip.\n. ",
    "kwandrews7": "We've imported this project manually not using pods or carthage. I may just be a newb here, but could you outline what \"build\" I would need to do or what files I need to update to get this working with Xcode 7.3? I've tried selecting the OHTTPS schemes and building them and that still does not resolve the errors.\n. ",
    "sdduursma": "@AliSoftware I've updated the CHANGELOG.\n. ",
    "krodak": "My bad, CP is fetching me 4.6.0...\n. Unfortunately, only defining explicit Pod location fixed issue for me:\npod 'OHHTTPStubs', :git => 'https://github.com/AliSoftware/OHHTTPStubs'\n  pod 'OHHTTPStubs/Swift', :git => 'https://github.com/AliSoftware/OHHTTPStubs'\nBut this is CP issue, so sorry to bother with whole issue.\n. ",
    "felixLam": "Thanks for getting back so quickly! Enjoy your vacation, we will improve this PR in the meantime.\n. @AliSoftware I made the requested changes and rebased on master\n. @AliSoftware there was a \"minor\" outage on GitHub today. \n. @AliSoftware Thank you very much. Credit where credit is due: @shagedorn did most of the heavy lifting here with the method swizzling.\n. @mikelupo This PR should not require any changes on your end as far as I remember and should just magically work. \n. Absolutely. Will look at this tomorrow. \n\nAm 02.06.2016 um 20:05 schrieb AliSoftware notifications@github.com:\n@felixLam @shagedorn while doing the 5.1.0 release, I just realized that maybe I merged that PR too soon. I mean, it should work, but:\nIt's missing Unit Tests. We should add at least one unit test for this feature, ensuring that the code works and that there won't be any regression later\n The file where you added the category is called NSMutableURLRequest+HTTPBodyTesting.h/m but is in fact an extension on NSURLRequest, not NSMutableURLRequest, so for consistency's sake we should probably rename it\nThat doesn't seem much work to do and make it right, do you think you'd be able to throw a quick PR to add that soon, so I can include it properly in the upcoming 5.1.0 release?\nThx!\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @AliSoftware Sorry for not following through with my promise on Friday. We had an unscheduled workload due to a rejection ;)\n. The reason we can't do that is that the session calls this method with nil which lead to the initial problem. If we touch the protocol property here we lose the benefit of this PR. The usual story is this:\n1. App sets up mutable request\n2. App sets body\n3. URL session for whatever reason resets it\n4. OHHTTP handles it\n\nIf we reset the property in step 3 again, we don't have access in step 4. \nI believe that in production code it rarely happens that you set the body and then later need to reset it (at least\u00a0missing support for this is the lesser bug, compared to not supporting the body IMHO). We can't really differentiate between the callers here unfortunately (to my runtime knowledge).\n. ",
    "shagedorn": "If merged, you'd probably want to...\n- [ ]  Adjust the Wiki entry\n- [x]  Post to issue #52\n- [ ]  Adjust the version number in the changelog as appropriate\n. Sorry about the delay, we had a busy week and @felixLam was on holidays. We'll tackle it next week!\n. @mikelupo the OHHTTPStubs.h file only includes the bare minimum of imports, which I assume is intentional ( @AliSoftware ?). To get everything, import OHHTTPStubsUmbrella.h, or use the modular import using @import OHHTTPStubs;, which will use the umbrella header.\nI'm working on the remaining issues (rename & tests) right now and will submit a PR later today.\n. \ud83d\udc4d \nShould we mention the (quite obvious) caveat that was mentioned in the original PR?\n\nOne known issue is that if you set the HTTPBody and later reset it to nil (for whatever reason), OHHTTPStubs_HTTPBody will still return the last non-nil value.\n\nWe could probably fix this by providing an additional reset method, but I don't think it would be of much use.\n. for testing and...?\n. The idea was to make sure this never ends up in any code unnoticed. However, swizzling is used in other parts of OHHTTPStubs, too, and the framework should generally only be used for testing and the likes, so I agree, this can probably be removed.\n. I agree that the static variable is easier to grasp than the commented message sending approach. I'll take a look how we can refactor this to reuse the swizzling code.\n. ",
    "ndbroadbent": "Here's what I hacked together: https://github.com/hdwr/OHHTTPStubs/commit/c394ba28312133691b9d6ff7ebbb82238ea28048\nSorry it's pretty ugly, but it works for us! This is how I'm using it in our app:\n``` Swift\n    lazy var pendingS3Uploads = OHHTTPStubsResponse\n    func setupS3UploadsStub() {\n        stub(isHost(\"s3-us-west-2.amazonaws.com\") && pathStartsWith(\"/uploads\")) { req in\n            let response = OHHTTPStubsResponse(data: NSData(), statusCode: 200, headers: nil)\n                           .shouldWait(true)\n            self.pendingS3Uploads.append(response)\n            return response\n        }\n    }\nclass func sendS3UploadResponses() {\n    for response in sharedInstance.pendingS3Uploads {\n        response.respondNow()\n    }\n    sharedInstance.pendingS3Uploads.removeAll()\n}\n\n```\nSo in the KIF test case I can call sendS3UploadResponses() when I'm ready to send the response.\n. ",
    "kanekin": "@AliSoftware Hi, thanks for the reply. I was on a vacation, and I haven't got around to post the questions yet. I think I can post the questions on Carthage repo tomorrow. I will keep you updated.\n. @AliSoftware I have solved the problem.\nI looked through the settings for my test target, and I found ../** in User Header Search Paths.\nThis was causing XCode to look everything under the parent directory of the test directory.\nI removed ../** from User Header Search Paths, and the test was built successfully.\nThanks for your help and excuse me for not checking my settings more carefully in the first place.\n. ",
    "Ashton-W": "I might just be misunderstanding Mocktail. This https://github.com/kif-framework/AMYServer framework has th content type on line 4 then header key values on the following lines...\n. Not sure why something is trying to get a diff of that file, have changes been made in your checkout? Are you using the submodules feature of Carthage?\nIs there some prior console output you can share?\n. Glad you worked it out anyway @mikelupo\n. What Seift versions are compatible with that annotation?\nA Pull Request would be great :)\n. What do you think about checkboxes in the issue template, like fastlane/fastlane\n. @AliSoftware cocoapods doesn't use library project files at all, so it will have no change there. \n. @AliSoftware what about providing WKWebView support through a pod subspec and/or preprocessor macro. If it is a must to support binaries built without any configuration options we could create an additional target that adds this feature. Carthage users could link this additional framework?. Changing sharedInstance is a source breaking change. It's a little needless IMO. CocoaDocs is shutting down at some point iirc. ",
    "jzau": "Thanks for your help.\nActually, I didn't use any AFHTTPSessionManager in main project. I just create a new project without unit test but using Objc, than add unit test target using swift. Do nothing about main project. The test case with above codes still can't stub request.\n. I find that it can't stub request even when using NSURLSession in test target. But it works with NSURLConnect. \nI tried to use breakpoints in OHHTTPStubs library code in OHHTTPStubsSwift.swift file.\nI separate isExtension for multiple lines so that it's easy to add breakpoint like this \npublic func isExtension(ext: String) -> OHHTTPStubsTestBlock {\nreturn {\n    req in\n    req.URL?.pathExtension == ext\n  }\n}\nbut it only stops in return line.\nHere is an example project. https://github.com/jackyzh/stubExample.\nAnd I find that it works with NSURLSession.sharedSession.\n. ",
    "rodericj": "Done.\n. ",
    "adurdin": "Rebased and changelog updated. I also squashed it all into one commit and rewrote the commit message to describe the issue better.\n. Thank you, but I\u2019ll decline. I\u2019m not using OHHTTPStubs at all regularly just now, so don\u2019t think I\u2019m in a position to usefully contribute for the moment.\n. Ok, thanks!\n. ",
    "namanhams": "Awesome ! Thanks @AliSoftware . I totally forgot about requestTime\n. ",
    "trilorez": "Ah, I was afraid of that. Thanks for the quick response and the great library!\n. ",
    "hemster": "@AliSoftware nope, just pod 'OHHTTPStubs'. I thought it include all\n. Ha! You are right, I forgot to import the header.\nI only imported\n``` objc\nimport \"OHHTTPStubs.h\"\n```\nbut not include\n``` objc\nimport \"OHHTTPStubsResponse+JSON.h\"\n``\n. Cool! You rock! \n. @AliSoftware  I tried '@import OHHTTPStubs;'  , but it is not working properly. Xcode said module not found. QAQ\n. @mikelupo not working, stillOHHTPStubs/OHHTTPStubs.h` file not found\n. ",
    "djbriane": "Agreed - the most logical approach for now would be to create a swift3 branch so any others who want to migrate their projects can point to that branch (Alamofire took this approach).\nIn regards to your suggestion to add conditionals, I spent some time working through those changes and came to the conclusion I don't think it is the best approach for the following reasons:\n1. Several of the method signatures need to be modified in order to conform to proposal #0046 regarding consistent label behavior for methods and functions. This results in the following block of code being replicated several times and obviously introduces a lot of code duplication:\nSwift\n   #if swift(>=3.0)\n       public func fixture(_ filePath: String, status: Int32 = 200, headers: [NSObject: AnyObject]?) -> OHHTTPStubsResponse {\n           return OHHTTPStubsResponse(fileAtPath: filePath, statusCode: status, headers: headers)\n       }\n   #else\n       public func fixture(filePath: String, status: Int32 = 200, headers: [NSObject: AnyObject]?) -> OHHTTPStubsResponse {\n           return OHHTTPStubsResponse(fileAtPath: filePath, statusCode: status, headers: headers)\n       }\n   #endif\n2. Swift 3 introduces new API Design Guidelines (proposal #0023) which resulted in numerous updates to the standard library (proposal #0006). There are many uses of these libraries in the project, which results in variations of the following code replicated throughout the file:\nSwift\n   public func isScheme(_ scheme: String) -> OHHTTPStubsTestBlock {\n       #if swift(>=3.0)\n           return { req in req.url?.scheme == scheme }\n       #else\n           return { req in req.URL?.scheme == scheme }\n       #endif\n   }\nRather than force this much code duplication into the project, it seems best for now to keep this in a branch until it can be merged back into master once Swift 3 gets mainstream adoption. Keep in mind I'm no expert with Swift so if anyone has a more elgant approach I'd love to learn about it.\nThoughts?\n. @AliSoftware Sure, not a problem. I'll go ahead and close it.\n. ",
    "mxcl": "As a suggestion for maintaining both 2.x and 3.x, at least as far as API renames, you could make a compatibility layer:\n``` swift\nif swift(>=3.0)\nelse\nextension NSURLRequest {\n   var url: NSURL { return URL }\n}\nendif\n```\nTo keep things neat this can be all kept in a separate file.\nNot that I think you need to maintain both, I don't intend to personally for my projects.\n. I\u2019m using the following in my fork so that OHHTTPSubs compiles against Swift 2.2, 2.3 & 3.0.\n``` swift\nif swift(>=3.0)\nelse\nif swift(>=2.2)\nextension OHHTTPStubs {\n    private class func stubRequests(passingTest passingTest: OHHTTPStubsTestBlock, withStubResponse: OHHTTPStubsResponseBlock) -> OHHTTPStubsDescriptor {\n        return stubRequestsPassingTest(passingTest, withStubResponse: withStubResponse)\n    }\n}\n\nextension NSURLRequest {\n    private var httpMethod: String? { return HTTPMethod }\n    private var url: NSURL? { return URL }\n}\n\nextension NSURLComponents {\n    private convenience init?(url: NSURL, resolvingAgainstBaseURL: Bool) {\n        self.init(URL: url, resolvingAgainstBaseURL: resolvingAgainstBaseURL)\n    }\n}\n\nprivate typealias URLRequest = NSURLRequest\n\nextension URLRequest {\n    private func value(forHTTPHeaderField key: String) -> String? {\n        return valueForHTTPHeaderField(key)\n    }\n}\n\nendif\nendif\n``\n. You can use my fork for now: https://github.com/mxcl/OHHTTPStubs/tree/swift-3.0\n. Sorry about thewip` commits. I didn't expect them to get used. Make sure to squash them if this PR is used!\n. IMO people are more likely to use Swift 3.0 than 2.3. Anyone using Swift is used to having to update and will want to be using the latest versions of everything.\n. > @mxcl I honestly don't know. I mean, at work for client projects we're still on 2.3. Hell for some projects we're even still on 2.2. Because it would be really time-consuming to migrate your code to the new beta of each Swift 3 release every time a new beta is released, and because we didn't sell the time for that to the client and don't have time nor leisure to take the risk.\nFair point.\nThe ticket I've opened against Carthage may make our setting moot anyway.\nIt's a pity Apple didn't anticipate this sort of scenario and make the setting inheritable. Perhaps they did and we just don't understand how to use it.\n. We want to keep the single #if block, this was a design decision in previous PRs, could you amend the patch conforming to the previous style? Thanks.\n. Many thanks. \n. Might be a bad merge. But this was there (with a difference I thought) because the legacy-swift setting for the tvOS target was YES (should be NO). I fixed this in my fork, so this #if os(tvOS) shouldn't be there and the legacy-swift setting should be checked.\n. ",
    "HHuckebein": "That is what I did. don't know how it works out with cocoapods. \nVon meinem iPhone gesendet\n\nAm 17.08.2016 um 23:45 schrieb AliSoftware notifications@github.com:\nInteresting issue! Sorry not to have given any feedback sooner.\nI'm wondering if the solution is as simple as just turn Embedded Content Contains Swift to NO and it will work in all 4 cases (both for people using OHHTTPStubs thru CocoaPods without the Swift subspec, thru CocoaPods and with the Swift subspec, as a framework and using Carthage) though?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "MattesGroeger": "Currently struggeling with the same issue. Trying to submit our app to the appstore crashes Xcode. The reason being that OHHTTPStubs includes not just the headers but also the standard library. \n. ",
    "iosdevben": "Hi Ashton,\nAnswers below.\nRegards,\nBen Thomas\n\nOn 2 Aug. 2016, at 15:37, Ashton Williams notifications@github.com wrote:\nNot sure why something is trying to get a diff of that file, have changes been made in your checkout?\nNo.\nAre you using the submodules feature of Carthage?\nNo.\nIs there some prior console output you can share?\nNo. I literally changed the version number from 4.7.0 to 5.1.0, ran carthage update --no-build then tried to stage the files and git complained.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I was able to update to version 5.0.0 without this issue occurring, but when going from 5.0.0 - 5.1.0 it occurs.\n. @Liquidsoul: Sorry I didn't get a chance to try your branch but thanks for your work fixing this!\n. \n",
    "Liquidsoul": "I think I saw that Carthage tries to build every shared schemes in a repository.\nA solution I used for some private libs was to remove all shared schemes not matching a framework (i.e. example projects schemes), but it may not be applicable in our case here.\n. I've fixed the example projects in #194 which should fix the issue.\n@iosdevben, it would be awesome if you could test your Carthage setup using the branch issue_190_carthage_and_examples_projects to see if this fixes your problem \ud83d\ude03 \n. @iosdevben: Changes have been merged into master \ud83d\ude09 \n. Not a problem, I can squash them if you want with a more meaningful message \ud83d\ude04\nIt is weird the CI did not pass though, everything worked fine on my repo branch \ud83e\udd14\n. Thanks @AliSoftware !\nI've updated the CHANGELOG.\nAbout this PR, I wonder if we should merge it as-is.\nHere, we enable Swift 3.0, but I suppose that most people use OHHTTPStubs with Swift 2.x code.\nSo, merging this can break their code if they use the next release.\nMaybe I'm missing some user-side settings that could make the lib works with Swift 2.x code without changing the SWIFT_VERSION here \ud83e\udd14\nMy advice would be to set SWIFT_VERSION to 2.3 here and have a swift3.0 branch in the repository changing it to 3.0.\nWhat's your thoughts about this?\n. I've updated the PR to set the SWIFT_VERSION back to 2.3.\nI let someone else review and merge this if everyone is ok with this \ud83d\ude0a\n. @AliSoftware The full diff can be misleading. This is because I've configured the Swift version at the project level and so removed the settings on the targets (see commit 9010c3a22636cbf8a7f904483001b76749d25f17).\nSo there is now only two lines that changes if we change the SWIFT_VERSION settings (see f83f1446e04e7b95fda3702cb4f37413ffb995f1).\n. I've fixed the conflicts, hope this will pass the CI on first try ! \ud83d\ude01 \n. > Problem is, if we do that, what about past September once Swift 3 is released, will we switch master to use SWIFT_VERSION=3.0 and remove branch swift3\u2026 and create a swift2.3 branch instead of legacy? Would probably be a pain for Carthage users to update all their URLs again in their Cartfile, right? While doing the opposite might work better for the long run?\nI do not think this is that bad for Carthage users. They would just have to update the dependency as for any version bump, but I may be wrong.\nMaybe we should consider the standard user case, not the beta users? The ones using Xcode 7.x, with Swift 2.2 and who will migrate automatically to Xcode 8 in september.\nThey are not impacted by this setting because their version of Xcode does not care about it yet \ud83d\ude01 However, once they decide to move to Xcode 8 we should not force them to Swift 3.0 as soon as they update their IDE. This would mean that an unrelated change (the IDE version) will break the OHHTTPStubs dependency without changing the library version.\nWe should let them choose to update like Apple is doing with the migration tool. Meaning, leaving them the option to enable Swift 3.0 using a branch until we decide to merge it to master and make it the default value in a later release.\n. They won't need to use a different version of OHHTTPStubs.\nThey need to do a carthage build in order to rebuild the frameworks. Something one needs to do for almost every Xcode update because of the ABI \ud83d\ude09\nThe rebuild will be using the current checkout version of the library. Meaning that, if we set SWIFT_VERSION=3.0, given a fully working Xcode 7/Swift 2.x project, the update to Xcode 8 will build OHHTTPStubs framework with swift 3.0 making it unusable for the now Xcode 8/Swift 2.x project.\n. Seems perfect \ud83d\udc4d \nI'll add the information about a swift-3.0 branch in the README.md.\n. I suggest that I create another pull-request for the README.md update. Or do you prefer to have the change here?\n. You're right, seems more logical to have it here.\nI've just pushed the change here.\n. I've added something in the Carthage section about Xcode 7 \ud83d\ude09 \n. Hi @AJ9UNiDAYS !\nThis should work, or maybe something broke with the Xcode 8 release \ud83d\ude05\nWhat depency manager do you use to integrate OHHTTPStubs?\n. Sorry for not getting back to you sooner.\nI think this is related to Cocoapods and Xcode 8.0. See this other issue #209 \nFeel free to comment / reopen if this is not the case.\n. Hi @Igor-Palaguta,\nMaybe I misunderstood your setup but it appears that you may have missed what is said in the cocoapods part of the README stating that your Podfile must reference both the main spec \u02cbOHHTTPStubsand the swift subspecOHHTTPStubs/Swift`.\nSo adding more than just the Swift subspec is the expected way to go \ud83d\ude09\n. Hi @cbauer10,\nThank you for your feedback !\nCould you give us some details on the errors you have? And how the library is integrated in your project?\nThanks !\n. Hi @gauravds !\nYou need to specify the swift-3.0 branch of OHHTTPStubs in your Cartfile if you use Swift 3.0.\nThe latest release is still set to compile in Swift 2.3.\nSee this section in the README.\n. Hi @gperdomor,\nI suppose that you are talking about the Carthage configuration?\nThe rationale behind the current setup can be found in the comments of #192\nMoving to swift 3 would require to keep a swift 2.3 compatibility anyway as the swift version is not enforced \"yet\". It should be soon when Xcode will drop the support for it.\nBecause of that, maybe it is better to keep things as-is for now and drop support of 2.3 altogether once Xcode stops supporting it.\nAre you having a specific issue with this current setup? \ud83d\ude0a. Hi @piercifani,\nWe made things so you should not need to fork the repository to use Carthage and Swift 3.0.\nAs stated in the carthage part of this section, all you need to do is specify the swift-3.0 branch in your Cartfile and you should be good to go \ud83d\ude03 \nAs Xcode 8.3 is coming soon, maybe it is a good time to work on the Swift 2.3 to Swift 3.0 migration of the project.. I forgot that you can also use dedicated releases for the library which have the -swift3 suffix like here for the latest one, and previous ones are available too!. I think we can finally close this \ud83c\udf7e\ud83c\udf89. Hi @cohilla,\nI think your issue is related to #233,\nIf you use Carthage, you must use -swift3 suffixed releases (in your case 5.2.2-swift3) until we make master use Swift 3.0.\nDo not despair, we are working on it #240 \ud83d\ude09  . Hi @cohilla,\nThank you for your contribution!\nI did not test the library on Xcode 8.3 yet but I am wondering if you've looked at the swift-3.0 branch?\nI suppose that it would be a better starting point than master if we want to make the switch from major 2.x/minor 3.x to major 3.x/minor 2.x\n. Hi @cohilla,\nI've just submitted #240 to set master to Swift 3.x.\nMaybe this will answer your issue? \ud83d\ude03 \nCheers!. Is there really a difference between Swift 3.1 and Swift 3.0?\nBecause it does not seem to be the case or maybe I am missing something \ud83e\udd14 . @AliSoftware I've just pushed the badge in branch swift2.3.. Oh right! I did not notice that! Thanks!. Ok so it will be a thing that we will need to address in the near future. I'll let this issue open to remind ourselves of this.. Hi @wassimseif \nThanks again for reporting your issue!\nYou are saying here that you are using Cocoapods to integrate OHHTTPStubs but your wrapper rxalamofiremapper does not seem to use Cocoapods but Carthage.\nDoes this mean that you are using both dependency managers in your project?\nI tried to use your wrapper but failed to do so in a test App because it lacks a shared scheme needed by Carthage to build the framework (I tried the latest version and the master branch).\nI am afraid I will not be able to reproduce your issue and help you out unless you give us a configured project exposing the problem \ud83d\ude1e\nBTW, your issue seems to be missing the version of Cocoapods you are using and the OHHTTPStubs one (6.0.0) is not in the correct spot. Could you edit your issue to confirm these informations please? \u263a\ufe0f. Cool! Did this solved your issue?\nIf so, would you mind closing the issue? \ud83d\ude0a . Hi @mrjimoy,\nIt seems you are missing an XCTestExpectation instance with its corresponding fulfill call to match your waitForExpectations call.\nIf you don't have any expectation your test will terminate before the asynchronous call. In fact, in your example, the timeout argument in waitForExpectations has no effect.\nHere is my suggestion (note that I wrote this without compiling it so this may need some fixes here and there):\n```swift\nfunc testGetHomeData_RequestsDefault_Return200() {\n        TestsHelper.stubNetwork(forConnector: HomeConnector.self,\n                                   endpoint: \"home\",\n                                   stubFileName: \"GET_Home_200\")\n        let successExpectation = self.expectation(description: \"success called\")\n    HomeConnector.sharedInstance.getHomeConfig(onSuccess: { (data, object) in\n        // --> Not even entering this part\n        successExpectation.fulfill()\n    }) { (data, error) in\n        XCTAssertFalse(true)\n    }\n\n    waitForExpectations(timeout: 10, handler: nil)\n}\n\n. This may mean that your condition is not met.swift\nisHost(HttpConnector.sharedFCHTTPClient().getKAPIBaseUrl()) && isPath(endpoint)\n```\nTry removing the condition and enabling the stub for all the requests to check if the stubbing works.. @AliSoftware yeah, I think that's a good idea. I will try to do submit a PR on this in the coming days.. Hi @Jerem42,\nI have to admit that I did not try to use OHHTTPStubs with Swift 4 yet.\nCan you give us some details on the issues you have when using OHHTTPStubs with Swift 4?\nThanks!. Can you provide some details about the integration tool you are using and follow the issue template and provide the informations it contains, please? \ud83d\ude0a \nI suspect that you are using Carthage here and I am afraid that we may not be able to support every swift version in this case \ud83d\ude1e . Hi @eman6576,\nFrom the error, it does not seem to be related to the OHHTTPStubs library but to its integration with cocoapods.\nYou are adding OHHTTPStubs as a dependency to targets with different Swift versions and it appears that cocoapods cannot handle this (or at least the version you use).\nCould you try using the same swift version in your targets? Or If not possible, just remove temporarily BaseAppV2IntegrationTests to see if it works with only Swift 4.0 integration?\nThanks!. I do not understand your need to have a fork here \ud83e\udd14 \nI tried to use the 6.0.0 version using cocoapods 1.3.1 on a project configured to use Swift 4.0 and everything seems to be working fine.\nCould you check that on your end?\nAnd in any case, if your problem is solved, please close the issue \ud83d\ude47. Hi @msalmanST,\nUnfortunately, I do not think you can achieve that, data upload is one of the known limitations of OHHTTPStubs.\nYou may be able to intercept the request using OHHTTPStubs but you would not be able to give the expected response to the SDK.\nEven if you manage to make this work, I would advise against this kind of configuration because you do not have the ownership of the AWS SDK code and any change in the library may break it.\nThe element you should mock is the SDK itself and have some kind of small abstraction layer over it. This would then be your mocking point for your tests.. Ok, after some investigations this seems related to https://github.com/AliSoftware/OHHTTPStubs/issues/230#issuecomment-378385218\nI have experienced the same issues (redirect data without response object) for the failures.\nSo this seems like a NSURLProtocol bug.\nSo now I see several options:\n- we find a workaround in the library to make this reliable (that seems unlikely to me)\n- we find a workaround for the tests, but this would mean that client code can fail, and this occurs a lot in the tests in my experience\n- we disable the tests and document that redirections are not correctly supported by OHHTTPStubs because of an Apple bug. I suppose that the question is answered. I'll close this then.. Hi @kamaki94 \nSorry for the late reply but did you try using a closure in condition to see if a request is at least captured by OHHTTPStubs?\nI cannot help you more as you do not provide the implementation of your manager.getData call and I did not try OHHTTPStubs with Siesta myself.\nIf you are still experiencing the issue, it would be great if you could give us a sample project reproducing it \ud83d\udc4c. I think 81017a6be3596ad16651bb5a522b7338fe63d984 fixes this but I forgot to remove this conditional \ud83d\ude0a\n. This is the project level settings which is overwritten by the target level settings. I'll change that and remove the target level one.. I'll remove the dots there then \ud83d\udc4d . Shouldn't the markdown badge [Language: Swift 3.1], even if not displayed, be updated to what the shield shows for consistency? (meaning Swift-2.3/3.0/3.1). Use XCTAssertTrue instead of XCTAssert.. Use XCTAssertFalse instead of XCTAssert.. Yup saw that, I'll look into it later as soon as I can \ud83d\ude09 . Small typo here \u270f\ufe0f . The number of this PR is 254 \ud83d\ude09 . I am wondering if this should not be called isAbsoluteString to match the URL member we call underneath, because there is a URL.absoluteURL\n\ud83e\udd14 . Typo here, missing closing parenthesis \u270f\ufe0f . Yes, I agree. But I think this should be in another PR.. Maybe it's me but, I find the message of this assert not clear. Something more like \"Expected the method to be unchanged\"?. Setting the SWIFT_VERSION in the project is required on each target (or at least at the project level).\nThis is why the CI fails.. The version should not change here, or at least be greater than the last released version 6.1.0.. Making this change on the deployment target and the one below for macOS, drops the support for previous OS.\nI am not sure that this is what we want because this is not what is exposed in the pod spec file (we support 7.0).\nMy point is that we could leave the Xcode 9 warning exposing the fact that it does not support iOS prior to 8.0 and macOS prior to 10.9 because, maybe, some people still use the previous versions.. Was this setting removed when supporting the Xcode recommended settings?. Is this necessary to change the code signing settings in the project? Was this done by the automatic process of Xcode?. Small typo here whicih.\nIn fact, I would rephrase that a bit\u00a0: \"Fixed a static analyser warning related to a property having the copy trait while using a mutable array, ...\". I think that we must not bump the swift version here because we are still supporting Swift 3.x and the CI still run tests using Xcode 8.3.. If you want to integrate a version bump of the library, you should do it at the Project level, not for each Target.\nIf you use the \"Levels\" view in the Build Settings you'll see that the Project's version is still set to 6.1.0.\nWe have the version at the Project level to share this information and change it only in one place.\nTo fix this, change the version in the OHHTTPStubs project and remove the override on each target.. I understand your problem but this is something we cannot do without considering the fact that we still support Swift 3 and that the CI needs to be able to check that for us.\nAFAIK, the support of multiple Swift versions is not possible with Carthage, we've even opened an issue about this that was not resolved.\nSee this section of the README for our proposed workarounds for Carthage.. ",
    "JackieQi": "I am using the latest. see the screenshot. Weird though.\n\n. @AliSoftware You are absolutely right. All the failed tests are about  kResponseTimeTolerence. So i tweaked them and all passed. Thanks very much for quick response. \n. ",
    "markedwards": ":-(\nThanks for the explanation!\n. ",
    "JanC": "I'm using Carthage for the tests dependencies and all my tests are in Objective C\n\nIf you're not using Swift, just don't integrate the Swift extension in your Podfile.\n\nIs that possible with Carthage? I can manually uncheck the target membership of the OHHTTPStubsSwift.swift then it compiles and runs \n. ok thanks, I'll give it a try. Maybe I can just keep the compiled .frameworks only for the CI xcode 6 tests. \ncheers!\n. ",
    "mrkite": "Looks like Travis failed on a running time test, not due to the PR itself.\n. ",
    "janiduw": "@AliSoftware when will this fix be available ?, Thanks\n. @AliSoftware Thanks for the quick response and for the great library \n. @AliSoftware seems that Travis CI is now working \n. ",
    "dhardiman": "Sure, updated. Hope the format is ok above the previous release? Let me know if not and I'll fix.\n. Updated\n. ",
    "AJ9UNiDAYS": "I was using Cocoapods, I suspect it may be an Xcode 8 glitch. I've had to rollback to using Swift 2.3 and Xcode 8 where this isn't an issue. May pop up again in anyone using a pure Swift 3.0 project?\n. ",
    "Igor-Palaguta": "Thanks @Liquidsoul for response. I've seen this, but nobody reads documentation - believe me) And better to add one more dependency to subspec to prevent this in future. \n```\n  s.subspec 'Swift' do |swift|\n    swift.ios.deployment_target = '8.0'\n    swift.osx.deployment_target = '10.9'\n    swift.watchos.deployment_target = '2.0'\n    swift.tvos.deployment_target = '9.0'\nswift.dependency 'OHHTTPStubs/Core'\n#additional dependency\nswift.dependency 'OHHTTPStubs/NSURLSession'\nswift.source_files = \"OHHTTPStubs/Sources/Swift/*.swift\"\n\nend\n```\n. ",
    "svachmic": "Same here. As noted below:\n\nMy setup is:\n- Xcode Version 8.0 (8A218a)\n- CocoaPods 1.0.1\nPodfile:\n\nplatform :ios, '9.0'\nuse_frameworks!\ntarget \"Gigsterous\" do\n\npod 'OHHTTPStubs'\npod 'OHHTTPStubs/Swift'\n\nend\n\nConsole output while pod install:\n\nInstalling OHHTTPStubs (5.2.1)\nGenerating Pods project\n\nHope it helps, looking forward to using it again! \ud83d\udc4d \n. @ikesyo  It did help indeed! Thanks a lot!\n. ",
    "cbauer10": "@ikesyo Glad to know that the fix is coming.  I just can't work with pre-release code at my company.  You don't have any insight as to when it will be released do you?\n. ",
    "kuyoonjo": "It works by\nOHHTTPStubs.stubRequests(passingTest: { request -> Bool in\n            let res = request as NSURLRequest\n            print(\"++++++++++\", JSON.init(data: res.ohhttpStubs_HTTPBody()))\n            print(\"++++++++++\", String(data: res.ohhttpStubs_HTTPBody(), encoding: .utf8))\n            return request.url?.absoluteString == API.securityCode.url\n            }, withStubResponse: { request -> OHHTTPStubsResponse in\n                let obj = [\"errorno\": 0, \"errorMsg\": \"\"] as [String : Any]\n                return OHHTTPStubsResponse(jsonObject: obj, statusCode:200, headers:nil)\n        })\nPlease mark this issue as resolved.\n. ",
    "wwe-johndpope": "I wanted to share this  swift 3 gist  - I looked at the sample wiki but not sure how to edit it - feel free to rip off the content and drop it in. Maybe you need a swift sample page entirely. \nThis has local swagger json compatibility \nhttps://gist.github.com/wwe-johndpope/60ac94a1af4537d755c71119d61f94f8. ",
    "zachlucas": "Sorry, I've updated my comment.  Notice the last line of the original, it includes an errant ];\n. Thank you, that was my issue.\n. ",
    "isimpson": "Ok, thanks for the quick response. May be nice to leave this issue to help others with the current workaround:\n(request as NSURLRequest).ohhttpStubs_HTTPBody()\n. ",
    "KingOfBrian": "Yea, looks like URIs with no host can do that, and since the predicate has no context you can't be sure. Oh well!\n. ",
    "morrowa": "I'm not sure I understand the build failure. Is it a known issue?\nI have not tested non-zero response times, and my understanding of NSURLProtocol is limited. (There's not very much documentation.) However, I believe that this implementation is correct for non-zero response times.\nThe response complete callback that gets called immediately after the redirect callback signals the completion of the 3xx response. startLoading is called a second time with a new request if the user chooses the follow the redirect. I was able to verify this with the debugger. It's also documented in the comments in the CustomHTTPProtocol Apple sample project.\nSince the redirect and the final request are separate invocations of startLoading, each will honor the request time configured on its respective stub. That means the behavior as implemented here will match both the API and the current behavior (ignoring the race condition).\nFor context, the issue was introduced as part of a bug fix for a related issue in May in PR https://github.com/AliSoftware/OHHTTPStubs/pull/175 . Before that fix was merged, startLoading would submit either the redirect notification block or the request completion block. That was incorrect - both callbacks must be made in the event of a 3xx response. After that code was merged, the code would correctly call both callbacks, but each was submitted in a separate block, which introduced the race condition solved in this patch.\nIt would be possible to write a unit test with a long response time for both the initial 3xx and the final response and verify that the response time is honored in each case with these changes. If you can wait a day or two, I'd be happy to write one.\n. OK! Meanwhile, I will find time to write a test verifying that the new behavior is correct for non-zero request times.\n. While working on unit tests for redirect response times, I found another bug which I addressed in commit a6f5453. The response time was not being honored for requests with zero-length data.\nI added some very rough timing to the NSURLSession tests to verify that the amount of time spent waiting for the requests to finish was greater than or equal to the configured request and response delays. Let me know if the tests look okay. I know that using NSDate for timing isn't ideal, but I thought it simplest in this scenario.\n. OK! Should I add that to this PR?\n. I've encountered the same issue. Here's a commit adding a unit test that semi-reliably reproduces the issue. I've been able to reproduce the issue in the iOS 11 simulator and directly in macOS. I'm using Xcode 9.3 on macOS 10.13.4. You might have to run the new unit tests several times to see a failure.\nWhen the failure happens, the 302 redirect is not followed. There's no response object, but there's also no error object. The body of the 302 response is returned.. I've been able to reproduce the issue without any OHHTTPStubs code at all. I suspect there's a race condition in Apple's implementation of NSURLProtocol, NSURLProtocolClient, and/or NSURLSession.\nIn the attached project (RedirectBugDemo.zip), StubbingProtocol is an extremely pared-down version of the concept of OHHTTPStubs. It intercepts certain HTTP requests and synchronously returns a response. (Although OHHTTPStubs is not synchronous, I've tested modifications to make it synchronous. The change doesn't fix this bug.)\nThe unit tests run a simple NSURLSession and expect it to follow the 302 redirect. In the first test, there is no NSURLSession delegate, so all redirects are followed immediately. In the second test, the NSURLSessionTaskDelegate calls usleep(500) before instructing the session to follow redirects.\nThe test without the delay fails on average once per 100,000 runs. The test with the delay has not failed in over 1,000,000 runs.\nI've submitted a Radar and cloned it to OpenRadar as well.. OK! Sounds good! Only one copy of the links though, right?\n. No, I appreciate this help! I haven't contributed to an open-source project in a long time and want to be sure that all of my changes fit the project perfectly.\n. ",
    "wantobe": "What did you try? (please give code samples as well as the remote full URL to be stubbed so we can check that your matcher is correct)\n[wantobe]: I've tried to stub a stream URL to play in webview. Used the responseWithFileURL:statusCode:header: to reponse it. \nTake an example, the user want to play a with \"http://www.ganttcn.com/ouhk/OUHK-IntroductionToTheOpenUniversityofHongKong.mp4\", I used the library to respond with a \"rvideo-1024x512.mp4\"(local).\nHow did you install OHHTTPStubs into your project?\n[wantobe]: I installed OHHTTPStubs(version 5.2.2) using Cocoapods\uff08podfile subspec: pod 'OHHTTPStubs'). I have not yet intergated it into my project, and i've just made a test running of your example.\nAre you using Objective-C or Swift?\n[wantobe]:Objective-C\nWhat error do you have, if any?\n[wantobe]: No error, but something unexpect. When i using the simulator to play the web video, the request would be stubbed, but the video never been played successfully,\nbut when i using the real device(iphone6 and 5s, ios10.1), i faild to stub the requests.\nDo you manage to stub any other request done by your application but have issue only with this one, or do you fail to stub any request?\n[wantobe]: only video request can't work well, other request(text, image...) is ok.\nDid you read the Wiki examples and troubleshooting pages?\n[wantobe]: I had read them. The issue like 'https://github.com/AliSoftware/OHHTTPStubs/issues/187', i can't make it still.\nBy the way, my Xcode version is 8.1.\nThe code as shown below:\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n[self installTextStub:self.installTextStubSwitch];\n[self installImageStub:self.installImageStubSwitch];\n[OHHTTPStubs onStubActivation:^(NSURLRequest * _Nonnull request, id<OHHTTPStubsDescriptor>  _Nonnull stub, OHHTTPStubsResponse * _Nonnull responseStub) {\n    NSLog(@\"[OHHTTPStubs] Request to %@ has been stubbed with %@\", request.URL, stub.name);\n}];\n\n\nstatic id<OHHTTPStubsDescriptor> stub = nil;\nstub = [OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest * _Nonnull request) {\n\n    return [request.URL.pathExtension isEqualToString:@\"mp4\"];\n\n} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {\n\n    NSString *str = OHPathForFile(@\"video-1024x512.mp4\", self.class);\n\n    //cheaking the local file path is correct or not \n    NSLog(@\"the local mp4 file size: %lu\", (unsigned long)[NSData dataWithContentsOfFile:str].length);\n\n    return [[OHHTTPStubsResponse responseWithFileURL:[NSURL fileURLWithPath:str]\n                                          statusCode:206\n                                             headers:@{@\"Content-Type\":@\"video/mpeg4\"}]\n            requestTime:0.f\n            responseTime:OHHTTPStubsDownloadSpeedWifi];\n\n}];\nstub.name = @\"video stub\";\n\n\n//webview has been appended in xib\n[self.webview loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://www.ganttcn.com/ssjy/ouhk\"]]];\n//geting the response\n//the real remote full url, one of the web page above video file url\nNSString* urlString = @\"http://www.ganttcn.com/ouhk/OUHK-IntroductionToTheOpenUniversityofHongKong.mp4\";\nNSURLRequest* req = [NSURLRequest requestWithURL:[NSURL URLWithString:urlString]];\n\n[NSURLConnection sendAsynchronousRequest:req\n                                   queue:[NSOperationQueue mainQueue]\n                       completionHandler:^(NSURLResponse* resp, NSData* data, NSError* error)\n {\n     NSLog(@\"=======================%@\",resp);   \n }];\n\n}\n``\n. Thanks for your answer. \nI found thatstartLoading` was not invoked, so, i'm sure it is an iOS bug.\nA similar issue from stackoverflow: Custom NSURLProtocol class for WebView doesn't work when loading video in HTML5 document. ",
    "manicaesar": "\nIf it really is, maybe we should use NS_REFINED_FOR_SWIFT or similar in the definition to avoid this at call site?\n\nYes, maybe that would be the best option. But I think it should not be done within this PR - rather within some separate one :)\nBTW: What's wrong with the travis?\n. Yes, that's the case, I think changes in README.md should typically not affect builds :) Ok, I will wait until the problem is solved (I don't have too much spare time right now either). Fingers crossed :)\n. Great news :) \nHowever, I haven't invented the problem - this keeps emerging (Xcode 8.1).\n\nI will check with your sample project. Maybe some compiler warning is disabled.\n. Ok, that was simpler than I expected. In my project I used OHHTTPStubs from master branch, where fixture is defined as follows:\npublic func fixture(filePath: String, status: Int32 = 200, headers: [NSObject: AnyObject]?) -> OHHTTPStubsResponse\nwhile on swift-3.0 branch it is defined that way:\npublic func fixture(filePath: String, status: Int32 = 200, headers: [AnyHashable: Any]?) -> OHHTTPStubsResponse\nwhich does not cause any problem.\nThere is no signal in README.md that I should use swift-3.0 branch when using the pod in application that uses Swift 3.0. Maybe we should add one? Or maybe you are about to merge branch swift-3.0 to master soon? :)\n. Sorry for the delay. Ok, I finally squashed and rebased my PR to contain only required changes. Please check. Thank you for cooperation!. ",
    "wilddylan": "I use it WKWebViewWithURLProtocol for custom URLProtocol hook request from WKWebView.\n. @AliSoftware Some times, i want to cache HTML sources in my documents folder, i want to load this as a website with stub.. ",
    "Antondomashnev": "@AliSoftware do you have any estimation to decide whether to merge subspecs or not? Could you please point the cons of merging? \ud83d\ude04 . @AliSoftware wow, that's an amazing news \ud83c\udf89 \ud83d\ude80 . ",
    "CalvHobbes": "I used a custom UrlProtocol to get around this issue. I set this in the .protocolClasses property of my sessionconfiguration. The custom protocol basically uses an internal session to forward the request  (which incidentally is to my  OHHTTPStubs stub ).. Hello, I took another look at this. Turns out, the framework is fine. I was using .responseTime instead of .requestTime to delay the return of the response from the stub, which is why it was returning the response earlier than expected (and my request was therefore not timing out) :) Think we're ok wiht the current code. FYI though, for the custom UrlProtocol, I just used the standard code from one of Alamofire test UrlProtocol classes.. ",
    "nevil": "@AliSoftware \nSorry. I didn't have the time yet to find the real cause.\nI have temporarily changed the requestTime to 0.2 and responseTime to 0.5 (arbitrarily selected) and it prevents the issue from happening for me.\nThis does slow down my unit test execution a bit (though not more than 10 seconds :-) ) so I hope to have time to continue investigating soon.\n. I don't have a full investigation for this issue but It seemed to me like the timing of the call of the completionHandler from \nURLSession:task:willPerformHTTPRedirection:completionHandler: matters.\nFor example, if I take your test, add a delegate,  and implement it like below then the redirect test never fails.\nIf I shorten or remove the usleep() then testRedirection1000Times fails almost every time.\nobjc\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler {\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        usleep(1000);\n        completionHandler(request);\n    });\n}\n. ",
    "esetnik": "Hi @AliSoftware thanks for the feedback. I noticed the same thing but forgot to follow up here. I think it can also help to have the .swift-version file which might prevent this situation if Apple decides to cause this problem again.\nSee:\nhttps://github.com/Alamofire/Alamofire/blob/master/.swift-version. ",
    "Amindv1": "So the reason I have a two in one is that I try to automate everything. I attempt to record, if the file name for the request doesn't exist then I do record the request, otherwise if it does exist I stub the request based off of the file. This requires me to register both.. I thought that only one NSURLProtocol can be registered at a time? I don't think I understand your proposed solution. Can you show me what you mean? This would save me a lot of heartache, I was considering merging the two pods into one so I can merge their protocols and use them at the same time. . What's the difference between adding the protocol like so:\n[NSURLProtocol registerClass:OHHTTPStubsProtocol.class];\nand like so:\nNSMutableArray * urlProtocolClasses = [NSMutableArray arrayWithArray:sessionConfig.protocolClasses];\n        Class protoCls = OHHTTPStubsProtocol.class;\n        if (enable && ![urlProtocolClasses containsObject:protoCls])\n        {\n            [urlProtocolClasses insertObject:protoCls atIndex:0];\n        }\n        else if (!enable && [urlProtocolClasses containsObject:protoCls])\n        {\n            [urlProtocolClasses removeObject:protoCls];\n        }\n        sessionConfig.protocolClasses = urlProtocolClasses;?\nIf I register the class for NSURLProtocol does it register it for the default protocol, so any call to URLSessionConfiguration.default after adding a protocol will include the new protocol?. Alright maybe I'm confused here but something doesn't seem right. I was assuming that the setEnabled method is what was registering the class under the default session configuration, which is what AFNetworking was using. But after some testing I don't know if this is the case, how are you making it so that you stub AFNetworking requests? The reason I don't think it's the registerClass function is because SWHttpTrafficRecorder uses that to register its own protocol class but when I do:\nprint(\"before: \", URLSessionConfiguration.default.protocolClasses)\nprint(\"did register AFRecordingProtocol.self: \", URLProtocol.registerClass(AFRecordingProtocol.self))    // This is my custom recording protocol looks exactly like SW's    \nprint(\"after: \", URLSessionConfiguration.default.protocolClasses)\n\nthe before and after are the same:\nbefore:  Optional([OHHTTPStubsProtocol, _NSURLHTTPProtocol, _NSURLDataProtocol, _NSURLFTPProtocol, _NSURLFileProtocol, NSAboutURLProtocol])\ndid register AFRecordingProtocol.self:  true\nafter: Optional([OHHTTPStubsProtocol, _NSURLHTTPProtocol, _NSURLDataProtocol, _NSURLFTPProtocol, _NSURLFileProtocol, NSAboutURLProtocol])\nAs you can see, OHHTTPStubsProtocol is being registered but my custom protocol isn't listed. How is OHHTTPStubs making it so that the class is being registered with AFNetworking? You mentioned method swizzling but can you point me to where to start looking to see how this is happening? The session manager I'm using is an AFHTTPSessionManager and I pass it the default configuration:\n[NSURLSessionConfiguration defaultConfiguration];\nI make sure to setup the session configuration after I've added the protocol classes, so that isn't the issue either. \nI'm using swift and objc interchangeably because my project has both and the code snippets come from different files.. Alright so I took a look at OHHTTPStubs+NSURLSessionConfiguration and see where the method swizzling is happening. Now I understand my error. I was thinking that the URLProtocol RegisterClass was what was adding OHHTTPStubs to the session configuration but this isn't the case, it's being 'swizzled' in. Thanks for pointing that out in your comment, it took me a couple of reads through to understand exactly what you meant and I also had to read through the implementation and on method swizzling. Here's the post I read if anyone else that stumbles upon this is as confused as I was:\nhttp://nshipster.com/method-swizzling/. Yea I read through that a bunch of times actually but since I'm a bit of a noob I didn't understand exactly what you meant by swizzling. I thought that the registerclass was what was swizzling the method because I didn't understand the concept of swizzling. I think all the new terminology threw me off too so I was confused when reading through the readme. \nAgain I really appreciate the help!. Maybe that and mentioning where you're swizzling the sessions, what really did it for me is actually seeing where you guys swizzled the config.. ",
    "piercifani": "Hello @Liquidsoul,\nYes, there is an issue here when you integrate this library using Carthage, since Carthage will use the project's xcodeproj to create a framework, and currently the project is set to compile with Swift 2.3 check it here.\nIn order to get this working with Carthage you'd have to fork it and change this value to 3.0which is less than ideal.\nSince Swift 2.3 is closer and closer to deprecation (Xcode 8.3 release could be less than a month away) I think it's safe to set Swift 3 as the default for this project.\nThanks!. oops... sorry, I didn't catch that! Thanks a lot!. ",
    "ianbytchek": "Today is the day! \ud83e\udd41\ud83c\udf89. ",
    "raktec": "Thanks ,\nNow its working\nOn Wed, Feb 1, 2017 at 2:18 AM, AliSoftware notifications@github.com\nwrote:\n\nThat's a problem due to Carthage (and the fact that Carthage insists on\nusing pre-built binaries if available, despite the Swift ABI still not\nbeing stable and changing on each Xcode release)\nThe official solution for that is to use the --no-use-binaries flag of\nCarthage.\nI can't rebuilt that binary (as you did) for everybody, because then\npeople using Xcode beta with have a compatible binary but people not using\nthe beta will then be the one having the problem. There's no solution\nsupported by Carthage to support both people using swift 3.0 and 3.1 or\nmultiple Xcode versions\u2026 apart from not using the pre built binary and\nrebuilding yourself each time (there's a bunch of issues about that opened\non the Carthage repo btw)\nIn the future I may stop releasing pre built binaries for Carthage,\nenforcing people to rebuild on their end, as this Carthage limitation has\nbitten too many people at every new Swift or Xcode version already.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/AliSoftware/OHHTTPStubs/issues/234#issuecomment-276487273,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAu-zSBCu4LLlAhz_Q4ljNJJ5ycShOi8ks5rX54bgaJpZM4LzHV4\n.\n\n\n-- \nThanks & Regards,\nRakesh Kumar Sharma\nSkype :raktec\nGmail  : raktec@gmail.com\nMobile: +91- 886-013-8161\n. ",
    "ugenlik": "I feel so dumb, you were right, Alamofire is fired before OHHTTPStubs, I missed a piece of code that runs to get app configs from the server before the login... My bad....\nThanks for the quick reply . ",
    "cohilla": "I'm able to build using Carthage and the Xcode-8.3 branch \ud83d\udc4d \nI will close this since another issue is open to update the master branch.. Closing this since another request has been opened.. ",
    "krunk4ever": "I noticed that the releases are versioned as:\n\n5.2.2\n5.2.2-swift3\n5.2.3\n5.2.3-swift3\n\nMoving forward, will this be switched to?\n\n5.2.4\n5.2.4-swift23. I agree you should make 5.2.3 not compatible with the next version since they are not compatible, so \ud83d\udc4d  on 6.0.0. \n",
    "nickolas-pohilets": "I don't see it being used in public interface anywhere. But I agree, this does not make a big difference, I'll revert it.. ",
    "loudmouth": "CocoaDocs is indeed sunsetting as Ashton-W mentioned. It should be shut down by the end of the month. See the maintainers blog post here.. ",
    "wassimseif": "Yes that's exactly what happened. Now i changed it to \n```\n func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {\n        // Override point for customization after application launch.\n    let condition : OHHTTPStubsTestBlock = { (request : URLRequest) in\n        if request.url!.host! == \"www.mocky.io\"{\n            print(\"true\")\n            return true\n        }\n        print(\"false\")\n        return false\n    }\n\n    stub(condition: condition ) { _ in\n        print(\"Stubbing\")\n        return OHHTTPStubsResponse()\n    }\n\n    return true\n\n}\n\nand still nothing changes. prints true all the time but never prints stubbing . I'm using `Alamofire` . Okay i think i knew what wrong. When using a `RxSwift` wrapper around `Alamofire` it doesn't work. i think due to asynchronous calls? when sending the request like this\n  Alamofire.request(\"http://www.mocky.io/v2/590c43ed270000d70ab2a7ca\").responseJSON { response in\n    }\n\nit works! \nis thiss doable using an `RxSwift` wrapper around `Alamofire`. It's a really simple wrapper that doesn't affect the manager. Here is it\nextension DataRequest{\npublic func processMap<N>(mapObject:@escaping (AnyObject)->N?) -> Observable<N>{\n\n    return Observable.create{ (observer) -> Disposable in\n        self.responseJSON(completionHandler: { (response : DataResponse<Any>) in\n            switch response.result {\n            case .success :\n                guard let o = mapObject(response.result.value! as AnyObject) else{\n                    observer.on(Event.error(ObjectMapError.MapError(response.result.value as? JSON)))\n                    return\n                }\n                observer.on(Event.next(o))\n\n            case .failure :\n                observer.on(Event.error(ObjectMapError.APIResponseError(response.result.value as? JSON)))\n            }\n        })\n        return Disposables.create {\n            self.cancel()\n        }\n    }\n}\n\npublic func rx_responseArray<T:Mappable>(type:T.Type) -> Observable<[T]>{\n    return self.processMap(mapObject: { (json) in\n        Mapper<T>().mapArray(JSONArray: json as! [JSON])\n\n    })\n}\n\npublic func rx_responseObject<T:Mappable>(type:T.Type) -> Observable<T>{\n    return self.processMap(mapObject: { (json) in\n        Mapper<T>().map(JSON: json as! [String : Any] )\n\n    })\n}\n\n}\n```\nIf you want you can test it. Here's link for the wrapper https://github.com/wassimseif/rxalamofiremapper. Hello @Liquidsoul \nThank you for your time to lookup the issue. I have updated the issue. I'm using Cocoapods 1.2.0 to install OHHTTPStubs version 6.0.0. For the wrapper, I'm not using any dependency manager to install it, just by copying the files to my project. Since the wrapper requires RxSwift \n and Alamofire. I'm also using Cocoapods to install them. Hears the output of my Podfile.lock \n```\nPODS:\n  - Alamofire (4.4.0)\n  - Nimble (6.0.1)\n  - ObjectMapper (2.2.6)\n  - OHHTTPStubs/Core (6.0.0)\n  - OHHTTPStubs/Default (6.0.0):\n    - OHHTTPStubs/Core\n    - OHHTTPStubs/JSON\n    - OHHTTPStubs/NSURLSession\n    - OHHTTPStubs/OHPathHelpers\n  - OHHTTPStubs/JSON (6.0.0):\n    - OHHTTPStubs/Core\n  - OHHTTPStubs/NSURLSession (6.0.0):\n    - OHHTTPStubs/Core\n  - OHHTTPStubs/OHPathHelpers (6.0.0)\n  - OHHTTPStubs/Swift (6.0.0):\n    - OHHTTPStubs/Default\n  - Quick (1.1.0)\n  - Realm (2.6.2):\n    - Realm/Headers (= 2.6.2)\n  - Realm/Headers (2.6.2)\n  - RealmSwift (2.6.2):\n    - Realm (= 2.6.2)\n  - RxBlocking (3.4.0):\n    - RxSwift (~> 3.4)\n  - RxCocoa (3.4.0):\n    - RxSwift (~> 3.4)\n  - RxSwift (3.4.0)\n  - RxTest (3.4.0):\n    - RxSwift (~> 3.4)\n  - SWHttpTrafficRecorder (1.0.2)\n  - SwiftEventBus (2.2.0)\n  - Swinject (2.1.0)\nDEPENDENCIES:\n  - Alamofire (~> 4.4)\n  - Nimble\n  - ObjectMapper (~> 2.2)\n  - OHHTTPStubs/Swift\n  - Quick\n  - RealmSwift\n  - RxBlocking (~> 3.0)\n  - RxCocoa (~> 3.0)\n  - RxSwift (~> 3.0)\n  - RxTest (~> 3.0)\n  - SWHttpTrafficRecorder\n  - SwiftEventBus (from https://github.com/cesarferreira/SwiftEventBus.git, tag 2.2.0)\n  - Swinject (~> 2.1.0)\nEXTERNAL SOURCES:\n  SwiftEventBus:\n    :git: https://github.com/cesarferreira/SwiftEventBus.git\n    :tag: 2.2.0\nCHECKOUT OPTIONS:\n  SwiftEventBus:\n    :git: https://github.com/cesarferreira/SwiftEventBus.git\n    :tag: 2.2.0\nSPEC CHECKSUMS:\n  Alamofire: dc44b1600b800eb63da6a19039a0083d62a6a62d\n  Nimble: 1527fd1bd2b4cf0636251a36bc8ab37e81da8347\n  ObjectMapper: '042708195cc46c20871cbcbec0453826398273fd'\n  OHHTTPStubs: 752f9b11fd810a15162d50f11c06ff94f8e012eb\n  Quick: dafc587e21eed9f4cab3249b9f9015b0b7a7f71d\n  Realm: 29222766425b9f831228f81b63f0e38a97a4d700\n  RealmSwift: d161a80f96cb91ae88391a7d5a9cf08024a7bc8e\n  RxBlocking: 1797b8c1a3ad7b08965145e6e2294c2e101515aa\n  RxCocoa: d14ef6b6029e1ddc6e966508c09289090de68ff9\n  RxSwift: 3789a1af753002a14edecdb698a2424624296a9c\n  RxTest: beb6beb882cf1dcac5fc9fdbd4760a5254e7f3a6\n  SWHttpTrafficRecorder: 6c0804d3f8edf9c7f3a1e0eec9f6bf5e4b241b9f\n  SwiftEventBus: 39cde57d1881f9d6e8afb1f9e41f973e331bf847\n  Swinject: 85e468ac75c5c2d234076f98c591d57d56bc64bc\nPODFILE CHECKSUM: 0caf8a7da8bfb24ce2beb4e76bb04bb2f69177d5\nCOCOAPODS: 1.2.0\n```. @AliSoftware i checked NetworkStack and it's really interesting. do you have any sample app to demo it?. @AliSoftware I migrated to the network stack you provided the link for. it's much more mature than the one i wrote. . @Liquidsoul Yess. Thank you very much for your help. Awesome people!. ",
    "mrjimoy": "Hi @Liquidsoul, thank you so much for your reply. I have tried that, now it's entering the closure of getHomeConfig, but the still not entering stub in stubNetwork. I debug on getHomeConfig,  I got a response directly from the API, not the json file I provide (\"GET_Home_200\"). Anything I missed out?. But that is something like: \nHttpConnector.sharedFCHTTPClient().getKAPIBaseUrl() = https://api.some.com/\nendpoint = home\nI tried to change it as:\nisHost(HttpConnector.sharedFCHTTPClient().getKAPIBaseUrl().appending(endpoint))\nbut still the same. What should I put there then?. Hi @AliSoftware, thanks, it works now. Everything will be smooth from now on :). Wow okay, will try that! Thanks for the suggestion @AliSoftware :). ",
    "MrNeekReevers": "I fell into this same trap with isHost() today. This question solved my issues. . ",
    "VincentDengSZ": "Got it . thanks . ",
    "minuscorp": "So... I follows your instructions with some code rearrange:\nNow, the stub is created at the spec initialization:\nswift\nlet userDetailStub: OHHTTPStubsDescriptor = {\n        return stub(condition: isHost(UserOperationSpecs.baseURL)) {\n            _ in\n            let stubData = UserOperationSpecs.loadUserStub()\n            return OHHTTPStubsResponse(data: stubData, statusCode: 200, headers: nil)\n        }\n    }()\nand later on, on the test case:\nswift\n// [...]\nit(\"Should retrieve an user\") {\n    SessionManager.shared.configuration = SessionManagerConfiguration(withInvalidAuthenticationNotificationName: Notification.Name(rawValue: \"testInvalidAuthenticationName\"), invalidAuthenticationCode: 1500, userDefaultsTokenKey: \"testTokenKey\", baseURL: UserOperationSpecs.baseURL) \n    // <- Debugging checked that no Alamofire.Session is instantiated anywhere before this point\n     OHHTTPStubs.setEnabled(true, for: SessionManager.shared.sessionManager.session.configuration)\n// [...]\nAnd the result is the same, the call is not being stubbed.. The session is being instantiated in the line you mention, far after the stub is being created.. It's actually var baseURL = http://www.example.com I changed to isHost(\"example.com\") without any success. Can you give me a clue of what internal methods should I breakpoint to debug if the request is at least being checked by the library? After that I check your next comment to try to solve what you're telling me, step by step... \ud83d\ude05 \nEDIT: I've checked all the other points in your first comment. Neither of the methods are being called \ud83d\ude1f . (lldb) po SessionManager.shared.sessionManager.session.configuration.protocolClasses\n\u25bf Optional<Array<AnyObject.Type>>\n  \u25bf some : 5 elements\n    - 0 : _NSURLHTTPProtocol\n    - 1 : _NSURLDataProtocol\n    - 2 : _NSURLFTPProtocol\n    - 3 : _NSURLFileProtocol\n    - 4 : NSAboutURLProtocol\nTomorrow I'll dig into this.... The method you mention of OHHTTPStubs is getting called before this, this or this, which are, as far as I know, all the points where an Alamofire.SessionManager is getting created (and thus, the URLSession?)\nEDIT: Also, I can ensure that your library method is being called firstly in the _XCTestMain even before any test in the suite.. Just called once. Checked.. Tomorrow I create a project where you can reproduce the issue and I put the link here.\nP.D. it's 10 pm in Spain \ud83d\ude05. After some tweaking here and there... I carefully read your comment talking about URLSession and how it handles its URLSessionConfiguration, so I modified my custom manager creation like this:\n```swift\npublic var configuration: SessionManagerConfiguration = SessionManagerConfiguration.default {\n        didSet(newValue) {\n            let configuration = URLSessionConfiguration.default\n            if let token = UserDefaults.standard.string(forKey: newValue.userDefaultsTokenKey) {\n                configuration.httpAdditionalHeaders = [\"token\": token]\n            }\n            self._sessionManager = Alamofire.SessionManager(configuration: configuration)\n        self.initializeObservables()\n    }\n}\n\n``\nSo now I'm simply using copies ofURLSessionConfiguration.defaultwhich, as you said, should be being swizzled at test suite start. Now is correctly running all the tests independently of the order or the time of the stub addition, (at least those whose are added **before** theAlamofire.SessionManager` is instantiated for the first time.\nThank you very much, I would love to see this more explicitly explained for beginner users and visible in the README.md as feedback.. ",
    "geraldeersteling": "Oh I'm sorry. I pasted in a snippet and added the print's after, not updating the snippet; let me correct that.\nYeah, I'm not sure what to believe anymore. I made two new test classes and in one of them it works like it's supposed to, in the other class I get the same problem again however.\nI did noticed though that it might have something to do with how I stub.\nThere is a lot of repeating code in tests so I made a helper class for stubbing. See the snippet below:\n```swift\n/// A convenience helper to stub certain targets\nstruct StubsHelper {\n/// Convenience function to stub the network requests\n/// - Remark: For an explanation of some params check: https://github.com/AliSoftware/OHHTTPStubs\nstatic func stubHost(_ host: String,\n                     statusCode: Int32 = 200,\n                     headers: [AnyHashable: Any]? = nil,\n                     timeBeforeSendingRequest: Double = 0,\n                     stretchResponseOverTime: Double = 0,\n                     simulateNetwork: SimulatedNetwork? = nil,\n                     verbose: StubVerboseLevel = .none,\n                     willStub: (() -> Void)? = nil) {\n\n    print(\"stubbin once!\")\n\n    let condition = isHost(host)\n\n    stub(condition: condition) { _ in\n        willStub?()\n\n        if verbose > .none {\n            var msg = \"stubbing \\(host)\"\n            msg += \" | statusCode: \\(statusCode)\"\n\n            if verbose > .short {\n                if let aSimulatedNetwork = simulateNetwork {\n                    msg += \" | simulatedNetwork: \\(aSimulatedNetwork.networkType)\"\n                }\n                if timeBeforeSendingRequest > 0 {\n                    msg += \" | delayed by: \\(timeBeforeSendingRequest) second(s)\"\n                }\n                if stretchResponseOverTime > 0 {\n                    msg += \" | stretched over: \\(stretchResponseOverTime) second(s)\"\n                }\n            }\n            if verbose > .long {\n                if let someHeaders = headers {\n                    msg += \" | with headers: \\(someHeaders)\"\n                }\n            }\n            tLog.verbose(msg)\n        }\n\n        var response: OHHTTPStubsResponse\n\n        do {\n            let json = try JSONSerialization.jsonObject(with: Data(),\n                                                        options: []) as? [AnyHashable: Any]\n            var responseHeaders: [AnyHashable: Any] = [\"Content-Type\": \"application/json\"]\n            if let someHeaders = headers {\n                for header in someHeaders {\n                    responseHeaders[header.key] = header.value\n                }\n            }\n            response = OHHTTPStubsResponse(jsonObject: json ?? [\"StubError\": \"No sampledata\"],\n                                           statusCode: statusCode,\n                                           headers: responseHeaders)\n\n        } catch {\n            response = OHHTTPStubsResponse(data: Data(),\n                                           statusCode: statusCode,\n                                           headers: headers)\n        }\n\n        if (simulateNetwork != nil) {\n            guard simulateNetwork != .noNetwork else {\n                let notConnected = NSError(domain: NSURLErrorDomain,\n                                           code: Int(CFNetworkErrors.cfurlErrorNotConnectedToInternet.rawValue),\n                                           userInfo: nil)\n                return OHHTTPStubsResponse(error: notConnected)\n            }\n            response.responseTime(simulateNetwork!.rawValue)\n        } else {\n            response.requestTime(timeBeforeSendingRequest,\n                                 responseTime: stretchResponseOverTime)\n        }\n\n        return response\n    }\n}\n\n}\n```\nNow whenever I try to use StubsHelper.stubHost(...) in the beforeEach and removing the stubs again in the afterEach (with OHHTTPStubs.removeAllStubs) I get the same problem.\nSadly I don't see how this is somehow wrong.... I'll try, but the project is littered with corporate sensitive data.\nGoing to check if I can manage to create one.. Hi @AliSoftware,\nSadly no news yet \ud83d\ude1e. To be honest, I haven't been able to look into it further as the project is currently on hold (and I'm on an other project right now).\nIt will probably take a few months before the project continues, I'll set a reminder for myself to come back to this issue at that point.\nThanks for coming back at me though, much appreciated!. ",
    "victorg1991": "Done!\n. done!. I think that isAbsoluteUrl has more meaning than the other option, but its up to you.\nDo I have to change to isAbsoluteString? I could also do something like URL.absoluteURL.absoluteString \u00af_(\u30c4)_/\u00af  haha\nWhat do you think?\n. I prefer isAbsoluteURLString over isAbsoluteString, it doesn't sound too bad :). So I rename to isAbsoluteURLString? @AliSoftware . Dish! I'll fix tha in a minute : D. Done \ud83d\udc4d . ",
    "Jerem42": "Sure, here's the error when I try to import OHHTTPStubs:\nModule compiled with Swift 3.1 cannot be imported in Swift 4.0\nThe same happen if the Swift language version in the Settings is 3.2.. ",
    "gonzalezreal": "I am using OHHTTPStubs in a Swift 4 project (installed via Carthage) and I haven't experienced any issues using Xcode beta 4. I didn't install the latest beta yet.. ",
    "SwiftyGuerrero": "@Liquidsoul ,\nI was able to compile by making all targets use Swift 4.0. I also forked OHHTTPStubs, migrated to Swift 4.0 and changed its targets to Swift 4.0. . Need to test on my fork first. ",
    "dimazen": "Hello, @Liquidsoul. Any chances to update OHHTTPStubs archive for the Carthage download (the one attached to the release)? It is compiled with Swift 2.2 which is quite old for today :). ",
    "mplorentz": "I can take a shot at it. #216 looks easy enough to reimplement. I will try to submit a PR tomorrow.. @AliSoftware one of the Travis CI builds failed, but it appears to be unrelated to my code changes. Have you had problems with NSURLSessionTests.test_SharedNSURLSession failing in the past?. ",
    "c1ira": "Thanks, I'll try that.. Oh, okay, great.. I haven't noticed canInitRequest called repeatedly, and like I wrote, we've been using this for months. Also I worry it might do more harm than good to try to suppress that.. ",
    "pimnijman": "@AliSoftware, should I create a new pull request or is there a way to resubmit this one? I'm new to this. :). Your suggestion makes sense, but just to be clear; what you're suggesting is the following:\n```\n    let jsonStrings = [\n      (\"{ \\\"foo\\\": \\\"bar\\\", \\\"baz\\\": 42, \\\"qux\\\": true }\",\n       [\"foo\": \"bar\", \"baz\": 42, \"qux\": true])\n      // Etc...\n    ]\nfor (jsonString, expectedJsonObject) in jsonStrings {\n  var req = URLRequest(url: URL(string: \"foo://bar\")!)\n  req.httpBody = jsonString.data(using: .utf8)\n  let matchesJsonBody = hasJsonBody(expectedJsonObject)(req)\n\n  XCTAssertTrue(matchesJsonBody)\n}\n\n```. I'm not sure I agree. Of course I could convert this array to a dictionary but this would mean I can use each JSON sting only once. Unless I've misinterpreted your comment.\nlet dict = [ \"{ \\\"foo\\\": \\\"bar\\\" }\", [\"foo\": \"bar\" ] ]. ",
    "dorsegal": "Thanks!. ",
    "NikSativa": "did update both projects and all targets/framworks to the latest version of xcode 9.1 and swift version 4.0. all warnings and errors are fixed. no, 4.x required\n4.0.2 is the minor update. xcode contains only 1 integrated version inside\nthats why xcode 9.0 will contain 4.0, but xcode 9.1 - 4.0.2\nand inside project/target setting the version will be the same 4.0\nsee screenshot:\n. few lines below:\nMACOSX_DEPLOYMENT_TARGET = 10.9;\n. all of this changes was done automatically by \"update xcode project to recommended settings\"\n\"project level\" is more preferred instead of framework/target settings, because project can be changed by every developer instead of only code owner\nexample, i don't want to see any warnings in my project and than i can setup any MY project settings which will inherited by YOURs target. proposal: ios/macos version must be removed and xcode will use \"default\" version based on the parent project\nand as proposal you must review your demo/project/target/framework settings, because as you see many of them are old legacy from the previous versions. ",
    "jeffctown": "@NikSativa - Hey there!  We just released version 7 of OHHTTPStubs which is compatible with Xcode 10 and Swift 4.x, so I am closing this PR out, but I wanted to say thank you for submitting it! We really appreciate the community support!\nWe actually thanked you directly in the release notes.. @rckoenes - Hey there!  We just released version 7 of OHHTTPStubs which is compatible with Xcode 10 and Swift 4.x, so I am closing this PR out, but I wanted to say thank you for submitting it! We really appreciate the community support!\nWe actually thanked you directly in the release notes.. @robertoferraz - Hey there!  We just released version 7 of OHHTTPStubs which is compatible with Xcode 10 and Swift 4.x, so I am closing this PR out, but I wanted to say thank you for submitting it! We really appreciate the community support!\nWe actually thanked you directly in the release notes.. @sberrevoets - we're reviewing all outstanding PRs before making a release, and then updating the version of Swift being used.  the hope is to do all of this before Xcode 10.2 comes out, so our timeline is a bit tight.  \nIf you are still interested in getting this in, please resolve the conflicts. If you are not interested, having that feedback would be helpful too.  . @sberrevoets - if you mean the failing tests - those were disabled in CI (#301 & #302), so you don't need to worry about that part.  We only need the conflicts resolved.  If you want to give me permission to commit to your fork's master branch I don't mind resolving them myself.  the tests should pass once the conflicts are resolved.. @AliSoftware I updated this branch with a for loop, and I still see the conditional tests.. Oh! My bad man. I thought you meant the buggy test. \nSent with GitHawk. @hellensoloviy - Hey there!  We just released version 7 of OHHTTPStubs which is compatible with Xcode 10 and Swift 4.x, so I am closing this PR out, but I wanted to say thank you for submitting it! We really appreciate the community support!\nWe actually thanked you directly in the release notes.. I have a carthage archive of this branch if the CI passes and the PR is approved.. @AliSoftware let me know if you have any issues with this or if there's anything I can do to get travis running.. This totally makes sense @AliSoftware .  Let me know if I can help with any of this.  \nFYI - I read the Xcode 10.2 beta release notes today, and Swift 3 won't be supported.\nSwift 3 mode has been removed. Supported values for the -swift-version flag are 4, 4.2, and 5. (43101816)\nfrom: https://developer.apple.com/documentation/xcode_release_notes/xcode_10_2_beta_release_notes/swift_5_release_notes_for_xcode_10_2_beta\n. \ud83d\udc4b  @sunshinejr .  I'm happy to help out, but I'm waiting on next steps from @AliSoftware.  \nSince the existing code compiles fine in Swift 4.2, once I updated my test target to Swift 4.2 and ran pod install this dependency is compiling and working fine in Swift 4.2.  I'm not sure if this would work with your app / setup, but it unblocked my Swift 4.2 migration.. >Note that for some time now, Travis-CI hasn't been very reliable on OHHTTPStubs especially due to some timing tests randomly failing (depending on the CI CPU speed I think), but also sometimes travis failing to kick in and trigger the VM and tests\u2026 (I'm willing to migrate to CircleCI for a while but didn't yet). It's always fun to have to regularly restart the CI jobs when that happens, so don't be too surprised by that CI state, it might not be related to your PR specifically\u2026\n@AliSoftware\n\nI have to be honest I just started a new job, in a new country\u2026 so pretty swamped those days in it's not gonna get better until a few weeks I think. ...\n\n@AliSoftware totally understandable. I\u2019d be happy to help merge and release. \nSent with GitHawk. @AliSoftware sorry for not being more clear with the initial comment.\nBefore this change, Travis was building every pull request and any commits added to an existing pull request twice.  One build for the pr and one for the push.  This was my original pull request for swift 4.2, but I saw the same behavior for every new pull request and every commit pushed to an existing pull request:\n\nWhen you click those links you see the same exact build is run twice.\nThis change will not prevent pull requests from being built before a merge, it simply means they will only be built once instead of twice.   We should still expect Travis to kick off a build for any new pull requests, any commits pushed to an existing pull request, and for any merges into master (for releases and to update the build status badge).  \nThis is a screenshot of the checks for this pull request, which you can see only builds once instead of twice:\n\nNotice how the push build is gone.  The reason a second build with the push label doesn't spin up is because of this change. \nIf the duplicate builds were there for a reason, or if you don't like this change - I'm happy to revert it.  I just thought getting these next releases out would go a little quicker if we didn't have them.. @AliSoftware I think this is a great idea.  I can make put up a pull request with that change soon, and it makes way more sense than just disabling it globally.  \nWould you prefer for me to wait for your approval on any of these pull requests before merging?  You're bringing up totally valid concerns on them..  @AliSoftware - Sounds reasonable to me.  \ud83d\udc4d I can continue in this fashion. . @AliSoftware oh nice, I hadn't seen that yet.  . I'm honestly not sure how, but the config file looks like it's value resolves to have DEBUG=1, even though it's in the project build settings and not in the file.\n\nI thought build settings always inherited from right to left in Xcode's levels view (^^ that view).. so I wouldn't expect the config file to inherit a setting from the project, but it does. \ud83e\udd37\u200d\u2642\ufe0f \nNow that I think more about it - I normally don't mix project build settings and also have an xcconfig with them.  My opinion is normally that if you have an xcconfig you should put the entire value of that setting into the xcconfig instead of the project's build settings. \n@AliSoftware - What do you think of moving DEBUG=1 to the xcconfig instead, so there is no project build setting for this one?\n. Yes, probably overkill.  So do you think we should add $(inherit) or leave it as is?. There were actually a few places where we had DEBUG=1 twice, so I removed the target level preprocessor macros where needed.\nHere are the resulting resolved preprocessor macros now:\n\n. Addressed in https://github.com/AliSoftware/OHHTTPStubs/pull/302/commits/6bb739713c01a0c4f618bb60def33b1359506fa0 .. These were added at the target level, and caused DEBUG=1 to end up in the resolved macros twice.. These were added at the target level, and caused DEBUG=1 to end up in the resolved macros twice.. These were added at the target level, and caused DEBUG=1 to end up in the resolved macros twice.. These were added at the target level, and caused DEBUG=1 to end up in the resolved macros twice.. These were added at the target level, and caused DEBUG=1 to end up in the resolved macros twice.. I pushed a commit to put this into it's own method since where it is now is already a bit large.. Updated in c9b28c9.. Updated in c9b28c9.. Love this idea.  Updated in c9b28c9.. Updated in c9b28c9.. Updated in c9b28c9.  I went with the path of removing 2.x mentions.. Updated in c9b28c9.. Good point.  Updated.. ",
    "joaopedrok": "Imagine that you are using some architectures like real MVC or MVP. Inside your presenter or controller you will have something like FooService. Also you gonna have a method like fetchFooList that will call a method from FooService.\nBesides having all of this, i also want to unit test my presenter or my controller then i need to mock my requests. Those methods doesnt have any call back for ViewController. So i need to stub these requets for unit testing the behavior of my class for a success of failures.\nAnd when i do that, it doesnt update my state. What i mean,  that my completion is called before the stub.. Ok. I will provide one. . My unit test is like that\n```\nfunc testIfTheStateIsSuccessWithSuccessRequestWhenFetchProjectsIsCalled() {\n        stub(condition: isPath(\"/api/v1/projects\")) { request in\n            let stubPath = OHPathForFile(\"ProjectsResponse.json\", type(of: self))\n            return fixture(filePath: stubPath!, status: 200, headers: [\"Content-Type\":\"application/json\"])\n        }\n    self.sut.fetchProjects()\n\n    XCTAssertTrue(sut.state == .success(_))        \n}\n\n```\nAnd my code in my presenter\nfunc fetchProjects() {\n        self.state = .loading\n        self.requestProjects(page: 1)\n}\n```\nprivate func requestProjects(page: Int) {\n        ProjectsService.fetchProjects(page: page) { (projects, responseError) in\n            self.myProjectsViewController?.finishInfinityScroll()\n        if let error = responseError {\n            self.state = .error(error)\n        } else {\n            self.state = .success(projects)\n        }\n    }\n}\n\n```\nSo when I run my unit test, I can see that stub is correctly but my state is never success in Unit Test, so my unit test always but the code is right. \nCan you see my doubt now?\n  . I see your point related to my architecture and I know that is not a presenter. Is more like a controller from the real MVC that handle all the business rule. For that reason, I don't see any problem if my controller handle the state of my ViewController. But thanks for the tip.\nAbout XCTestExpectation I have had some problem using it because there is a timeout for it. So, as the unit test increase the size, the tests start to fail because I need more time for execution.\nCan you tell me why the stub response is not fast? It looks like to me that it spends almost the same time that the real network connection. Is there any response time for stub or something like that?\n. ",
    "crsantos": "allowMoreParams as a default param looks way better!\nI\u2019ll update. \nActually PR is closed but I\u2019ll reopen soon when I finish all updates. \nThanks for reviewing. Thanks, will update. \ud83d\udc4c. ",
    "msalmanST": "@Liquidsoul Thanks for your quick response, I will look into it \ud83d\udc4d . ",
    "janckoch": "Same for the HTTPBody.... ",
    "markalbert": "Hi, It sounds like I am having the same / similar issue as the OP is having, but I wanted to clarify that it is. \nI have read the issue in the OHHTTPStubs wiki, but it's in reference to the httpBody. I just wanted some clarity that it is the same thing which is happening with request headers? \n\nTest Steps\n\nLogin request is made to get an authentication cookie from the server\nCookie is automatically stored in the shared cookie store\nSuccessful logout test (session delete) is then ran\n\nExpected result:\nCookie is automatically added to the headers, and matcher hasHeaderNamed(\"Cookie\") is successful \nActual result:\nCookie is not automatically added to the headers, is not present on the request and the matcher hasHeaderNamed(\"Cookie\") fails and my stub is not used. \n\nI was confused as to why it wasn't working, but wanted to make sure it wasn't Alamofire, or something I had done incorrectly, so I created my own node.js server to fire my log in and logout requests into and pointed the \"successful logout\" test to my node server and ran it again - the test passed and sure enough my server logs showed that the cookie was included with the request, so it wasn't something I was doing wrong with the actual request.  \nSee here my stub for the \"successful logout\" test: \nswift\nfunc stubApiToRespond() {        \n        stub(condition: isAbsoluteURLString(AuthenticationWebApiDeleteSessionTests.sessionsUrl.absoluteString) &&\n            isMethodDELETE() && hasHeaderNamed(\"Cookie\"), response: { (request) -> OHHTTPStubsResponse in\n                var response: OHHTTPStubsResponse? = nil\n                do {\n                    let json = try JSONSerialization.data(withJSONObject: [:], options: .prettyPrinted)\n                    response = OHHTTPStubsResponse(data: json, statusCode: 204, headers: nil)\n                } catch {\n                    XCTFail(\"Error converting credentials to JSON \\(error)\")\n                }\n                return response!\n        })\n    } \nInitialiser:\n```swift\nlet configuration = URLSessionConfiguration.default\nafManager = Alamofire.SessionManager(configuration: configuration)\n```\nCode for logout (delete session):\n```swift\npublic func deleteSession(withSuccessHandler aSuccess: @escaping DeleteSessionSuccessHandler,\n                              andErrorHandler aError: @escaping DeleteSessionErrorHandler) throws {\n    afManager.request(self.sessionsUrl, method: .delete, parameters: nil, encoding: JSONEncoding.default)\n        .responseJSON { (response: DataResponse<Any>) in\n            if (response.response === nil) {\n                aError(DeleteSessionApiError.Network)\n            } else if response.response?.statusCode == 204 {\n                aSuccess(response.result.value as? JSONObject ?? [:])\n            } else if response.response?.statusCode == 401 {\n                aError(DeleteSessionApiError.Unauthorized)\n            } else {\n                aError(DeleteSessionApiError.HTTP(statusCode: response.response!.statusCode))\n            }\n    }\n}\n\n```\nAgain, I have read the issue in the OHHTTPStubs wiki, but it's in reference to the httpBody. I just wanted some clarity that it is the same thing which is happening with request headers, and that I'm not going mad?. ",
    "richardtop": "I'm adding the library to the project with CocoaPods:\npod 'OHHTTPStubs/Swift'\nThe issue is not always reproducible and making a clean build usually resolves it.\nMy Xcode version is 10.0 beta (10L176w), I'll try using the newest beta.\nActually, it seems, I'm already using the latest beta. . I understand, the issue is pretty hard to reproduce in my project. Cleaning the build folder always leads to build success, so I speculate, the issue has to deal with the derived data.\nMost likely, the issue isn't a library issue at all, but a byproduct of \u00df-Xcode instability, or has to deal with my project settings.\nI'll try to investigate it deeper when it occurs again and post the results here.. I've encountered a problem once again, using Swift 4.1, btw.\nHere is the output:\n```\nShowing All Messages\n:-1: Cycle in dependencies between targets 'AppName' and 'OHHTTPStubs'; building could produce unreliable results.\nCycle path:  \u2192 Pods-AppName \u2192 OHHTTPStubs \u2192 AppName\nCycle details:\n\u2192 Target 'AppName' has compile command for Swift source files\n\u2192 Target 'Pods-AppName' has target dependency on Target 'OHHTTPStubs'\n\u2192 Target 'OHHTTPStubs' has copy command from '/Users/user/Documents/Code/AppName-ios/Pods/Target Support Files/OHHTTPStubs/OHHTTPStubs-umbrella.h' to '/Users/user/Library/Developer/Xcode/DerivedData/AppName-dccqjpeftvorbzfhjfzvjwlkqkxo/Build/Products/Debug-iphonesimulator/OHHTTPStubs/OHHTTPStubs.framework/Headers/OHHTTPStubs-umbrella.h'\n\u25cb Target 'OHHTTPStubs' has link command with output '/Users/user/Library/Developer/Xcode/DerivedData/AppName-dccqjpeftvorbzfhjfzvjwlkqkxo/Build/Products/Debug-iphonesimulator/OHHTTPStubs/OHHTTPStubs.framework/OHHTTPStubs'\n\u25cb Target 'OHHTTPStubs' has link command with output '/Users/user/Library/Developer/Xcode/DerivedData/AppName-dccqjpeftvorbzfhjfzvjwlkqkxo/Build/Products/Debug-iphonesimulator/OHHTTPStubs/OHHTTPStubs.framework/OHHTTPStubs'\n``. A bit more insight: usually this issue happens when adding a new.swift` file. Cleaning and building the project usually resolves it.. ",
    "tfonfara": "I'm a bit concerned if those changes are enough, as there is on several places code like #if defined(__IPHONE_7_0), that should be extended with __WATCHOS_2_0. I tried to come up with a solution by myself, but things are petty weird. I've added all necessary precompiler defines, but OHHTTPStubsProtocol isn't working properly.\ncanInitWithRequest is being called and also returns true, but neither initWithRequest nor startLoading gets called. I also tried with a simple approach in a fresh project to implement NSURLProtocol but found same behaviour.. Oh didn't see that, I only checked issues \ud83d\ude48 I thought as it's listed in podfile it is already supporting watchos^^. ",
    "ivan-ushakov": "@AliSoftware I created the same issue for SWHttpTrafficRecorder but I still don't have any response.. ",
    "sberrevoets": "I was able to reproduce this once (via rake, I never saw them fail in Xcode 9.4.1), but now even rake is succeeding locally.\n@AliSoftware any idea what might be going on?. Ah thanks for the heads up, I've duped the radar. What would you like to see here in the meantime?. Friendly ping @AliSoftware :). Yeah that's a very good question. For me it'd probably depend on how much it fails. If it really is 70% of the time right now then adding a delay seems worth it. If it's every now and then, it might be possible to (somehow) auto-retry the affected tests, or take a simpler approach of adding a comment explaining the problem.\nI'm also open to alternatives, framework bugs like these are a huge PITA \ud83d\ude15. Happy to resolve conflicts (though can't promise I'll have time for that before the 10.2 release), but how depends on what approach is preferable. Based on the conversation above I'm not sure if there's a clear path forward.. Ah I missed that, that makes resolving conflicts a bit easier. Pushed an update but also gave edit access just in case.. I did remove that test case because it was one of the conflicts. Working on adding that back now.. Added that back and ran it locally - it still passed.. Thanks for the reviews and suggestions!. But since it's a dictionary order isn't guaranteed anyway? Is that different under the NSURLSession hood?. Yeah it doesn't hurt to add - done. (In a separate commit for reviewing purposes, happy to rebase at the end if you'd like.). ",
    "hellensoloviy": "Hello! \nThanks for the answer on my PR :)\nI have made some changes based on your comments, so u can look at it if u wanna) \nHave a nice evening! \n\nOn Oct 27, 2018, at 5:34 PM, AliSoftware notifications@github.com wrote:\nMaybe at this point we'd just state \"from 2.2 to 4.2\"\u2026 although I'm not sure that's really true. We might have dropped 2.x support at some point and forgot about updating that part of the README maybe? Would be good to check if we're still compatible with 2.x\u2026 or remove that from the sentence altogether as probably nobody uses 2.2 anymore\u2026\n\n. Yes, it's better to add it! Thanks for noticing. I've added it)\n\nOn Oct 27, 2018, at 6:33 PM, AliSoftware notifications@github.com wrote:\n@AliSoftware commented on this pull request.\nIn OHHTTPStubs/OHHTTPStubs.xcodeproj/project.pbxproj https://github.com/AliSoftware/OHHTTPStubs/pull/292#discussion_r228716848:\n\n@@ -1735,6 +1746,7 @@\n              SDKROOT = appletvos;\n              SKIP_INSTALL = YES;\n              SWIFT_OPTIMIZATION_LEVEL = \"-Owholemodule\";\n+             SWIFT_VERSION = 4.2;\nMmmh I see we actually never added that s.swift_version line to the podspec actually\u2026 might be the occasion to do so then\n\nhttp://blog.cocoapods.org/CocoaPods-1.4.0/#swift-version-dsl http://blog.cocoapods.org/CocoaPods-1.4.0/#swift-version-dsl\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/AliSoftware/OHHTTPStubs/pull/292#discussion_r228716848, or mute the thread https://github.com/notifications/unsubscribe-auth/ARU4Dam10SGJleCPnLrwr1hsb3d3gy0Mks5upHy_gaJpZM4X9cep.\n\n\n. Hi, @jeffctown \nThanks for your explanation & mention.\nI'm glad my PR was of help :) . ",
    "lightsprint09": "Thanks for the quick reply. \nAdded a changlog and waiting for your comments now.. ",
    "marcussc": "@lightsprint09 @AliSoftware is there anything I can help with to get this merged? . @AliSoftware Just integrated the Fork in inside my Project via Carthage. After a clean build the warning is gone. Looks good for me \ud83d\udc4d . @AliSoftware Maybe I can help on this one too? Xcode 10.2 is coming closer very fast would be a shame to have to stick to 10.1 because of our beloved OHHTTPStubs :). Here is something i wonder about. Why/How many Swift Versions should be kept? IMHO: Its not worth to keep so many Versions around. If someone needs an older Swift Version they can get an older Version of OHHTTPStubs?. ",
    "Simon-Kaz": "Thanks! Appreciate the quick turnaround on this \ud83c\udf89 I ran the tests locally multiple times and they were fine, Travis can be a bit weird sometimes. hey @AliSoftware are you planning to release new version of OHHTTPStubs anytime soon? I need this PR merged for the project I'm working on :). ",
    "sunshinejr": "Hey @AliSoftware @jeffctown, what's left here to get this one merged in? . ",
    "rckoenes": "The hole problem is that I can not use the Swift 3 version in carthage because Xcode fails if I include a framework build with Swift 3. I'm fully aware that support Swift 3 is support by Xcode and would make this project work on the most version of Xcode. \nWe just have an automated build system that required some modules in Swift 4 and it did not want to build with a Swift 3 module in place.\n. "
}