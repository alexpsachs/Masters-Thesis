{
    "acdlite": "Could you give me more details? Quoting from README:\n\nOther values of status are valid, but only success and error are treated with any special meaning.\n. Ah, do you mean that this requirement should be lifted?\nIf status is defined but not one of success or error, the consumer MUST NOT respond to the action.\n\nThinking about it more that's probably a good idea. The consumer should be allowed to choose whether or not to respond to it.\n. @trabianmatt What would the special meaning be? How should the consumer interpret it?\n. Both of those feel like separate action types to me.\nThink of an action as being a part of a stream of actions with the same type. If you think about other kinds of streams \u2014 let's use RxJS as an example \u2014 a subscriber to a stream (in this analogy, that's our store or reducer function) has onNext() and onError() functions.\n- onNext() corresponds to a status of success\n- onError() corresponds to a status of error\nThere's also onComplete() that is called when the stream terminates, but a stream of Flux actions never truly ends. It continues throughout the lifecycle of the application. So it's not relevant in this case.\nSo a status of pending doesn't fit into this metaphor. I can see how a pending flag would be useful for optimistic updates, but I don't think it belongs in the status field.\nMaybe we should rename status so that it's more clear? Can't think of a better alternative.\n. Yes, that's actually what Flummox does, but having a single status field felt more explicit and easier to work with.\n. Now that I see how status could be confusing, I'm inclined to agree with you, but let's take some time to think about it.\n. I agree this is a common pattern, just not sure if belongs in the spec... Maybe as an extension, but not part of the core. Let's keep thinking about it.\n. @trabianmatt In that example, what does the action payload look like in begin()? Usually you want to send along some kind of ID. Flummox addresses this by just passing along the arguments passed to the action creator, but this has always felt like a hacky solution to me.\nAnother problem with that API is mixes up separate concerns: begin is about time, but success and error are about whether or not an error occurred.\nIn redux-actions v0.6, the handlers were renamed to next() and throw() to make this a bit clearer, and to emulate the ES6 generator interface.\nWhat about something like this?\njs\nhandleAsyncAction('FETCH_THING', {\n  begin(state, action) {...}, \n  end: {\n    success(state, action) {...},\n    error(state, action) {...}\n  }\n});\n. Closing this since the original issue was about status, which is superseded by error in v0.6. https://github.com/acdlite/flux-standard-action/issues/6\n. Please continue any further discussion over here #7\n. payload on that page refers to the action itself. But I'm cool with renaming with payload. It's clearer that way.\n. @taion Every dispatched Flux action is part of a asynchronous sequence. Think of every other kind of asynchronous sequence \u2014 observables, streams, promises, etc. *All * of them have the concept of being in a \"error\" state.\n- Observables have onNext() and onError()\n- Promises can be in either a \"resolved\" state or a \"rejected\" state.\n- Streams have on('error')\n- Even Node-style callbacks have (err, x) => {...}\nstatus is the solution I came up with for this initial version of the standard. Its sole purpose is to indicate if action represents an error, without requiring knowledge of different, specific action types.\nYes, you're right that current Flux libraries often use separate types to implement error handling \u2014 they can continue doing that while still conforming to FSA, simply by omitting status entirely. status is a totally optional part of the spec, though also very useful one that increases interop between tools.\nHere's an exercise: look at the source of redux-promise and tell me how you would implement it with multiple action types. https://github.com/acdlite/redux-promise/blob/master/src/index.js#L15-L20\nIf the word \"success\" is too confusing, we can rename it to \"next\" using the Observable parlance. Perhaps that would be clearer.\nA metadata field (@goatslacker suggested the same thing) is worth considering, but I'm not sure if it's worth it... It seems just as good to put metadata in the top-level state object. But we can open a separate issue for that.\n. @clearjs There's no reason why a spec that works for Redux shouldn't also work for all Flux implementations. Even middleware isn't Redux-specific. All middleware does is wrap a dispatch() method, so they work with every Flux library that has one of those. Hint: all of them :)\n. > outside of e.g. Flummox and Redux, it's not something special or with semantic meaning\nNot currently, but it should! Good standards encourage good ideas. Making failed actions (actions that represents errors) a first-class concept is important, for the reasons described in my comment above. Suggestions for alternatives are totally welcome, but omitting it completely is not an option.\nI'm thinking we should replace status with a boolean error property (as I believe @clearjs suggested) to make it clearer what its purpose is. Also cleaner, since there are only two valid values anyway.\n. > Usually you start with the ideas, not with the standards\nThis isn't some idea I pulled out of my ass yesterday. Flummox has been using it successfully for months, and it's worked really well. If you give me a specific reason why treating errors as a first class concept is a bad idea besides \"other libraries don't do this\" I will take that into consideration.\n. @taion starting and done are very different from failed. The first two are about time and the second is about errors. starting and done should be metadata.\n. > But in any case it's not a \"minimal, common standard\" if you have a carve-out for something that only Flummox does, regardless of the inherent merit of the feature.\n@taion I simply disagree. If something's a good idea, we shouldn't leave it out of the spec just because it's not yet popular.\n. Can you please explain why you don't like error instead of repeating that you don't like it over and over? I've yet to hear a reason from you other than \"it's not necessary,\" which is... not helpful.\nOn Sun, Jul 5, 2015 at 5:23 PM, Jimmy Jia notifications@github.com\nwrote:\n\n@clearjs / @acdlite \nI remain in disagreement over error, which is essentially the same thing as status by a different name. My intent for bringing up the meta field was that this could be where you define all the specific bits for middleware-based routing. You don't need a top-level error-field to enable this, and I think this would be a better standard if it were less opinionated in that regard, and more minimal if it didn't have the unnecessary feature whose benefits could be accomplished all the same under meta.\nBut I've said my piece about this repeatedly. There's no definition of \"minimal\" with which I am familiar that includes:\n\nIf something's a good idea, we shouldn't leave it out of the spec just because it's not yet popular.\nGoodness-of-idea is an orthogonal concept to minimalism. My understanding of the term calls for preferring to not including things that are not strictly necessary, regardless of merit as a good idea or not.\n@goatslacker \nI like the idea of having specific pre-defined keys under meta to allow mutual comprehensibility when necessary. How would you word those field definitions - with SHOULD or with MUST (if present)?\nReply to this email directly or view it on GitHub:\nhttps://github.com/acdlite/flux-standard-action/issues/4#issuecomment-118682343\n. I see where you're coming from. My problem with putting it in meta is that I think that should be reserved for things that are totally not defined in the spec at all. I think there should be an \"in between\" area where things aren't required or part of the core spec, but are optional extensions that can be used if desired, and those things should go on the top level. I'm thinking of error but also of displayType or perhaps a field for optimistic updates if we ever think of a good solution. If we put everything except type and payload inside meta then it kinda defeats the purpose of having a spec, in my opinion. It also cuts against another goal of FSA, which is it should be easy to construct and consume actions by hand.\n\n\nSo how do you like that approach \u2014 the core spec is just { type, payload, meta } but we can define optional extensions to the spec for different problem areas, like error handling.\nOn Sun, Jul 5, 2015 at 5:34 PM, Jimmy Jia notifications@github.com\nwrote:\n\n@acdlite \nI think its not being necessary is a big part of why it should not be included. Like with id and displayType, it fits quite naturally into the proposed meta field, where its placement would allow all the things relating to routing with your middleware per https://github.com/acdlite/redux-promise/blob/master/src/index.js#L15-L20 as discussed.\nMaybe this gets to the heart of the disagreement? In your own words, this is supposed to be \"a minimal, common standard\" - if meta.error is sufficient, why have error? Or alternatively why not bring things like id and displayType up to the top level? To me it's the same kind of optional field - potentially relevant and very useful in certain contexts, but not in all of them.\nI'm not arguing that error is necessarily a bad idea - in the same sense that I think things like id and displayType can often be good ideas. What I'm saying is that there's no compelling reason for it to be a top-level error field rather than a meta.error field; the only thing you accomplish by doing so is by injecting a portion of opinionatedness into a standard that would be better served by not being unnecessarily opinionated.\nReply to this email directly or view it on GitHub:\nhttps://github.com/acdlite/flux-standard-action/issues/4#issuecomment-118682751\n. I see both arguments here, but I'm leaning toward having a separate field because it clearly distinguishes between standard and non-standard properties.\n. Added in v0.6.0\n. @clearjs Any false-y value should be interpreted as success, including null, undefined, etc. Only action.error === true indicates failure.\n. I would keep the error object in the payload. That way you don't get into a situation where an action has both a payload and an error object.\n. An action with error === true  is analogous to a rejected Promise. By convention, the payload should be an error object, but nothing's technically stopping you from breaking that convention. However, if you need to dispatch extra stuff, I would suggest catching the original error and dispatching a different action.\n. @clearjs No problem, same goes for me! :)\n. Changed in v0.6.0\n. Please continue any discussion over here: https://github.com/acdlite/flux-standard-action/issues/7\n. Haha thanks!\n. I like the sequence idea. Here's how I'd implement it:\n\njs\n{\n  type,\n  payload,\n  meta,\n  sequence: {\n    type: 'start', // or 'next', or 'return'\n    id: 123 // same for every action in the sequence\n  }\n}\nI'm going to try this out in redux-promise and redux-actions to see how well it works.\n. Couldn't you merge action and meta into a single field?\n. How are you distinguishing between the dispatch and the action? To me they're synonymous (or rather, each action represents a distinct dispatch). I get your \"class vs. instance\" analogy from our Slack conversation, but I don't really think it fits. To me the only field here that kinda feels like a \"class\" property is type. And type is only meant for introspection. Isn't everything else specific to the dispatch or \"instance\"?\n. Okay, so if everything else is dispatch info, action and meta can be merged together, right?\n. Could actions in Alt look like this instead?\n``` js\n{\n  // any: Symbol, string, number, object, function. A unique way to identify the action dispatched\n  type: ActionTypes.ADD_TODO,\n// any: whatever is being dispatched\n  payload: { text: 'Create FSA Proposal' },\n// information about the action itself\n\nmeta: {\n    // string | number: a unique identifier for the dispatch\n    id: 'abcdef123',\n// string representation of the particular action type\n// since Symbols are not strings and action type can be anything, having a way to identify an\n// action as a string is useful for serializing, debugging, and logging.\ndisplayType: 'ActionTypes.ADD_TODO'\n\n}\n}\n```\n. Yes, I think that's a sensible requirement. However, we should distinguish between \"in-flight\" actions and \"processed\" actions that are ready for consumption by a Flux store, reducer, whatever. We should come up with a good term for those, as well.\nThat way this is still a legal \"in-flight\" FSA action:\njs\n{\n  type: 'FETCH_DATA'\n  payload: somePromise\n}\nthat will be turned into proper \"processed\" FSA actions by middleware or some other library code (trying to stay framework agnostic, remember :smile:):\njs\n{\n  type: 'FETCH_DATA'\n  payload: { id, data, ..stuff }\n}\n. Oh, I forgot that right now the spec says the payload of a failed action should be an error object, which isn't serializable. Not a problem, we can specify that the payload of a failed action should (by convention) be\njs\n{\n  type: 'FETCH_DATA',\n  error: true,\n  payload: {\n    message: \"Something's gone wrong\",\n    fileName: 'index.js',\n    lineNumber: 123\n  }\n}\nThis is a \"SHOULD,\" though, not a \"MUST.\" The only \"MUST\" is that it is serializable.\n. Thanks!\n. Thanks!\n. Thanks! Released in 0.6.1\n. @JaKXz Sorry I haven't responded to this yet! Been pretty busy lately. This all looks great.\n. Btw I just sent you an email\n. ",
    "clearjs": "Yep. Lifted or somehow amended.\n. One complication is that such status might need to be treated like success in some cases. No specific examples yet, but I can come up with one if needed. Possible solution is to introduce another special status for pending.\n. Consumer (reducer) might apply an optimistic update. Also, UI could display some visual indication (a loader or a notification). The former has been discussed elsewhere, and the latter might be a separate action.\nThe more I think about it, the less I like an idea of the \"pending\" status. Still, would be interesting to compare how this may work with and without a special status.\n. Rx has great abstractions, I always enjoy using them. Agree with your reasoning here.\n\nMaybe we should rename status so that it's more clear? Can't think of a better alternative.\n\nDid you consider having a falsy (or missing) error property for success and truthy for error actions?\n. Let's see what others think, but now I like the error property much more as it does what is says and only that.\n. @tappleby each of those actions may be considered to have status \"success\" if we define the latter as \"no error\".\nDepending on needs and priorities of a specific project, at least a few alternative solutions are possible:\n- Use a (single) dedicated action type (e.g., 'UPDATE_PROGRESS') for tracking progress for all actions that need this. Add fields for the \"main\" action type (e.g., 'LOAD_MEDIA'), progress, and an ID to correlate a specific series of actions. These may either be meta fields (added to the action object), or be part of payload.\nPossibly use helpers to fire these progress updates from any async action creator that needs them. A single reducer may handle all progress updates. Using multiple reducers (e.g., one per main action type) is also easy, just need to check the main action type field in them.\n-  Same as above, but each main action type has a separate corresponding action type for tracking progress (e.g., 'LOAD_MEDIA_PROGRESS'). In this case there is no need to keep another field for the main action type.\n- Treat progress as part of state. No need for introducing additional action types. This may make reducer logic more complicated, but still simple enough for some use cases.\nOne of these, or some more specific/generic approach might become part of some spec extension, after at least 1-2 implementations are available and battle-tested in production projects. Alternatively, they may be described as recipes and simply go to the documentation.\nNOTE: there are many more cross-cutting concerns like this. E.g., ability to cancel a series of actions, retry failed operations, etc.\n. Or limit scope to Redux, so that it doesn't get too generic. Probably most middleware wouldn't work with other frameworks anyway.\n. @taion What value would such generic standard provide? Which kinds of tools could be built on it?\n. Metadata can be defined as every field except payload, no need to nest it IMO.\n. @acdlite A boolean is one option. An error object (e.g., exception) is another. In the latter case, payload could contain user-friendly error message.\n. > Isn't success/error status literally metadata here?\n@taion I think it is, in the same way as action type may be considered metadata.\n@acdlite I wouldn't define what the error field contains in the spec, except stating that any falsy value would correspond to success, and truthy to error.\n. @taion Yes, it is special. Since it is necessary, it is a required metadata field, not optional.\n. Unique identifier for a dispatch seems to be very useful, thus moving it out of meta might make sense. Or it really belongs to a spec extension?\nAllowing the type property to be of any type seems controversial. What are the use cases where it would be necessary or what are the advantages?\nAs for the displayType, why not require type.toString() to represent it instead? It should be possible to create define toString on the type instance or prototype (e.g., for functions). In most cases, this should be unnecessary. This approach might be a good compromise if type is allowed to be anything.\nAlso, meta shouldn't contain any fields that are required. If and only if a field is defined by the FSA spec core, it must be a top-level field. This way, standard extensions go to meta, and the standard itself may be easily extended in the future (because any non-standard fields at the top level are disallowed and all standard fields are at the top level).\nstatus was really controversial, it's great that it has been dropped. As for error (or isError / hasError?), while not yet commonly accepted practice, it seems to bring a lot of value. For example, it makes it easy to define actions using middleware like https://github.com/acdlite/redux-promise/blob/master/src/index.js#L15-L20\n. Spec versioning (actually, extensibility) was the only compelling reason for me to make meta field part of the spec. Otherwise, it wouldn't satisfy the heuristic criteria of spec being minimal - the same goals would be possible to achieve without it in a simpler way.\nError handling seems to belong to the core of spec, since probably every real-world use of actions assumes error handling. Without it, the only spec value is to allow extensions, I guess. Or am I missing something?\nAlso, without it each user would need to define their own way to handle errors (or select among popular ones), thus diminishing possibility to reuse any middleware that depends on error handling.\nWhen we're talking about action interoperability, I believe this actually means ability to reuse various kinds of code for processing actions: creating them with minimal boilerplate, creating them in a way that solves certain commonly occurring problems, transforming them (e.g., filtering, mapping, reducing).\nEven if the only thing this spec enables is to create such reusable libraries, then it is worth the effort. Arguments over merits of particular spec aspects should appeal to specific examples of code that wouldn't work or would work worse than with alternative approaches.\nSpec should probably focus more on explaining the goals and value of itself, with examples or references to working code. A series of libraries that @acdlite is creating along with this spec shows its usability (such libraries wouldn't be applicable in projects that follow different action schemas).\n. Metadata can be defined as every field except payload, no need to nest it IMO. At least, I don't see any advantages, while making actions harder to comprehend.\n. http://www.enterpriseintegrationpatterns.com/EnvelopeWrapper.html\nAn action can be considered an envelope for user-defined payload.\n. OK, so that's mostly about preferences? A standard might simply work with both options: since both 'metadata' and 'type' are top-level fields, they both would be considered metadata under the definition that I proposed.\nSo, both of the following would be FSA-compliant:\njavascript\n{\n  type: 'DO_SMTH',\n  payload: {},\n  metadata: {\n    field1: null\n  }\n}\nand\njavascript\n{\n  type: 'DO_SMTH',\n  payload: {},\n  field1: null\n}\nWithout loss of any functionality already discussed. (Spec extensions which specify additional metadata fields wouldn't, though.)\n. Please describe what value would a restriction to a boolean provide over being any truthy/falsy value?\n. Disadvantages:\n- not clear how to treat an absent field\n- need an additional field for an error object\n- makes it more difficult to be compliant\n. Good. Then why not go one step further, and allow any truthy value as well? For example, an error object.\n. @acdlite I think I've addressed that here: https://github.com/acdlite/flux-standard-action/issues/4#issuecomment-118398813\nAlso, your situation would work just fine with what I propose: error === true would still be truthy, so it would be FSA-compliant. But other usages (like an error in the error field) would be allowed as well without loss of functionality. The end user would decide whichever middleware and action schema fits their needs and preferences.\n. By the way, sorry if my tone looks harsh or like I have hard feeling with respect to the outcome, both here and elsewhere. That isn't the intention at all. I'm being a bit pedantic trying to clarify the motivation and making sure that most aspects have been considered.\n. @acdlite looks like your last comment was intended for some other issue. \n. @acdlite It might be useful to have some sequentially increasing number for sequence ordering information. E.g., if progress of 67% arrives after 70%, it would be possible to ignore it.\nEDIT: that would be more relevant for Rx, or wherever we need sequence.type === 'next', not for optimistic updates.\n. @tappleby It depends. Perhaps, after more use cases are addressed this will be clear.\nGenerally speaking, the concept of sequence implies ordering. My point was to bring this into discussion, not to suggest any specifics.\nIf I had to make a decision, I'd introduce ordering information and make it a field of sequence.\n. @acdlite Defining a point where an action must comply with certain criteria is important. It might vary depending on criteria.\n. ",
    "trabianmatt": "Would it be worth considering pending as a status with special meaning?\n. A better name might be begin (for my purposes, at least). What I'd like to be able to do is:\n``` javascript\n// Action\ncreateAction('FETCH_THING', async id => {\n  const res = await api.fetchThing(id);\n  return res.body;\n});\n// Reducer\nhandleAction('FETCH_THING', {\n  begin(state, action) {\n    return { ...state, pending: true };\n  },\n  success(state, action) {...},\n  error(state, action) {...}\n});\n```\n. ",
    "tappleby": "I think part of the issue is we need a way to identify when an action has \"started\".\n@acdlite you mentioned how a flux stream never completes, which is true, but within that stream there are sequences of actions that do begin and complete.\nPerhaps there is a way we could identify a sequence, which would consist of a start, complete and N intermediate actions. The complete action must also indicate if it is a success|error.\nIn the case of the Promise it would just be a sequence of 2 actions. For a more complex example we could take something that needs to report progress such as loading a file or processing data:\njs\n[\n    { type: 'LOAD_MEDIA', mediaId: 42, sequence: 0 },\n    { type: 'LOAD_MEDIA', mediaId: 42, sequence: 1, payload: { progress: 10 } },\n    { type: 'LOAD_MEDIA', mediaId: 42, sequence: 2, payload: { progress: 67 } },\n    { type: 'LOAD_MEDIA', mediaId: 42, sequence: 3, payload: { progress: 84 } },\n    { type: 'LOAD_MEDIA', mediaId: 42, sequence: 4, status: 'success', payload: { id: 42, path: '...' } },\n]\nThe above example is a bit contrived since a progress action could be handled with a different type.\n. I agree an optional unique identifier would be useful, especially for something like #7. I can see some value in it being a top level field (less typing, avoids needing to check if meta exists), that being said the id is likely generated by the framework/middleware which fits the description framework-level information regarding action.\ntype being any value does complicate things, in order to cover all the use cases I think requiring strict equivalence (===) is as restrictive as we can be. Being able to serialize actions does allow for some powerful techniques such as: Time Travel, Flux over the wire, Sharing state (this is more about state, but I could see an implementation that allows the same workflow with actions). Perhaps a spec extension could exist that places restrictions on actions that can be serialized?\n. I dont see much value in having both action.error and action.payload.error. \nIf we relaxed the error requirement to just contain a truthy value I think that be enough:\njs\ndispatch({\n    ...prevAction\n    error: {\n        message: \"Error saving user\"\n    }\n});\n. I realized after posting that there was previous discussion about making error truthy, @acdlite gave some reasons for why error should be in payload but I think its worth revisiting.\n. I dont think the spec should specifically address optimistic updates but being able to express a sequence of actions would allow for someone to implement optimistic updates.\nActions:\njs\n[\n  { type: 'SAVE_FOO', payload: { fooId: 42, name: 'Foo' }, meta: { id: 'abc1', sequence: 'begin' } },\n  { type: 'SAVE_FOO', payload: { fooId: 42, name: 'Foo' }, meta: { id: 'abc1', sequence: 'complete' } },\n]\nStore or Reducer:\njs\nif (action.type == 'SAVE_FOO') {\n  switch (action.meta.sequence) {\n    case 'begin':\n      // Store pending value using action.payload.fooId\n      // Possibly keep track of request using action.meta.id\n      break;\n    case 'complete':\n      if (isError(action)) {\n        // Remove pending value, store error letting user know what occurred.\n      } else {\n        // Remove and merge pending value.\n      }\n      break;\n  }\n}\nA user may want a sequence of more then 2 actions, if we borrow slightly from Observable terminology I could see the following values for sequence: begin|next|complete. An optional sequenceOrder could be useful as well.\nNot sure if this causes any issues but for an action creator that performs some client side validation it might be possible for a complete sequence to be fired without having a matching begin.\n. @acdlite I like the top level sequence as an object, not a huge fan of return, would prefer end or complete.\n@clearjs the sequence order would be useful, I could see it living in meta or sequence. Do you think this is something the spec needs to define?\n. Matching the Iterators spec is an interesting idea. Part of me does like the idea of being able to identify the start of a sequence without having to track previous sequence ids; this isnt possible using just done alone. Perhaps this isnt a common use case?\n. @acdlite how do you feel about the following:\njs\n{\n  type,\n  payload,\n  meta,\n  sequence: {\n    type: 'start', // or 'next', or 'done'\n    id: 123, // same for every action in the sequence\n    value: { progress: 0 } // Optional value \n  }\n}\nI feel using done  instead of return better describes whats happening and is less likely to be confused with the return keyword.\nI am still not sure if value is necessary, optional data like this could be stored in meta.\n. I actually have a pending PR for the sequence branch based on discussions in this issue - https://github.com/acdlite/redux-actions/pull/22\n. I think the warn middleware would be handy (in its own repo). Would also be useful to expose a utility method like isSerializable\n. ",
    "jprichardson": "As pointed out by raydeo on #redux, payload is found all over this page: https://facebook.github.io/flux/docs/dispatcher.html\n. ",
    "taion": "I don't think status improves interop because it specifically highlights an optional semantic field without really signposting that, outside of e.g. Flummox and Redux, it's not something special or with semantic meaning.\nIn my view, the benefit of putting status inside something like a broader metadata is that it explicitly signposts that you have something where the semantics are not universal. If you use that middleware and then pass the action to a store handler that (by design) just looks at the payload, what do you get? Nothing good/correct. You end up needing another piece of middleware-like behavior on the handler end to resolve how to handle the action from something other than the type and the payload. In other words, you end up with a framework-specific piece of metadata, that might as well be captured under a broader notion, rather than as as a unique and special status field.\nHence what I have outlined - type and payload are the bare minimum for dispatching and handling actions, and a minimal standard should aim to be agnostic toward anything else. Implementation-wise, success/failure status seems like a special case of \"metadata meaningful to ~~framework~~ framework or specific piece of middleware used\", which seems like a generic, useful, universal construct that most Flux frameworks make some use of.\nEDIT: Fixed phrasing above\n. Also, while I can parse this on a technical level, in plain English this makes no sense if I'm dispatching a GET_USER_FAILED action:\n\nstatus MAY be undefined, in which case the consumer MUST treat the action as if its status were success.\n\nBut mostly my point is that I look at status as being a sub-case of metadata, and that a standard should include the more general thing when it's useful, which metadata would be.\n. @clearjs\nIt gives you a way to dispatch actions from one framework that another framework can use.\nAnd standardizing all information other than the type and payload under a meta field gives a reasonable place where potentially interoperable middlewares can stash their relevant keys/data.\n. Usually you start with the ideas, not with the standards...\nIf meta.error is used everywhere to convey error status, why is that worse than having error be a top-level optional boolean field?\nIsn't success/error status literally metadata here?\n. One thing I might very well want to do is have a meta.status field with enum values for starting, done, and failed. This maps much more closely to what I generally want to do with async actions than just success or error. At some level a special top-level standard-defined status or error field precludes or makes it much more awkward to do this, which seems like an anti-feature.\n. @clearjs \nI think type is special because it's the minimum for meaningfully dispatching an action.\n@acdlite \nBut they'd be used in a very similar way, e.g. with something like a promise-based middleware that dispatched starting at the beginning and then either done or failed at the resolution or rejection of the promise, and then hooks to handle this from stores (e.g. when building higher-level abstractions around fetching data).\nI think the sheer fact that we can't agree over how a status field ought to be used is prima facie evidence that it's not an obvious fit for the standard. I just think it's better to go from the perspective of adoption driving a standard than the standard attempting to drive adoption - otherwise if people find something better, you're just left with cruft in the standard you have to deprecate.\nBut in any case it's not a \"minimal, common standard\" if you have a carve-out for something that only Flummox does, regardless of the inherent merit of the feature.\n. @clearjs / @acdlite \nI remain in disagreement over error, which is essentially the same thing as status by a different name. My intent for bringing up the meta field was that this could be where you define all the specific bits for middleware-based routing. You don't need a top-level error-field to enable this, and I think this would be a better standard if it were less opinionated in that regard, and more minimal if it didn't have the unnecessary feature whose benefits could be accomplished all the same under meta.\nBut I've said my piece about this repeatedly. There's no definition of \"minimal\" with which I am familiar that includes:\n\nIf something's a good idea, we shouldn't leave it out of the spec just because it's not yet popular.\n\nGoodness-of-idea is an orthogonal concept to minimalism. My understanding of the term calls for preferring to not including things that are not strictly necessary, regardless of merit as a good idea or not.\n@goatslacker \nI like the idea of having specific pre-defined keys under meta to allow mutual comprehensibility when necessary. How would you word those field definitions - with SHOULD or with MUST (if present)?\n. @acdlite \nI think its not being necessary is a big part of why it should not be included. Like with id and displayType, it fits quite naturally into the proposed meta field, where its placement would allow all the things relating to routing with your middleware per https://github.com/acdlite/redux-promise/blob/master/src/index.js#L15-L20 as discussed.\nMaybe this gets to the heart of the disagreement? In your own words, this is supposed to be \"a minimal, common standard\" - if meta.error is sufficient, why have error? Or alternatively why not bring things like id and displayType up to the top level? To me it's the same kind of optional field - potentially relevant and very useful in certain contexts, but not in all of them.\nI'm not arguing that error is necessarily a bad idea - in the same sense that I think things like id and displayType can often be good ideas. What I'm saying is that there's no compelling reason for it to be a top-level error field rather than a meta.error field; the only thing you accomplish by doing the former is to inject a portion of opinionatedness into a standard that would be better served by not being unnecessarily opinionated.\n. I like that a lot. And I like the idea of formal extensions putting things outside of meta to make life easier - shall we open a new issue to discuss how we handle extensions and what we want those extensions to be?\n. @clearjs\nLike I said, I don't care too much about whether well-defined extensions go into meta. I feel like it's a bit neater to have users put their extra information that's not so well-defined under meta rather than leave it all over the place and have potential key conflicts.\nEven without error handling, just by defining exactly what type and payload are already gives us a minimum standard of interop, in that different frameworks will be able to consume actions generated by other frameworks, if they all understand the standard.\nOf course a lot of great things can be done with extensions, but I think that's exactly why extensibility is so important. Time travel, optimistic updates, &c. - these are all super cool things that we want the ability to do in a consistent way so that we don't end up needlessly reinventing them over and over again.\n. Well, I'm not using Flux any more, and really the concerns here are probably not that relevant any more. Redux is Redux, Alt is hanging around because Alt is cool, and Reflux remains vaguely undead. I don't think there's anything further productive to accomplish here.\n. As I mentioned in #4, I think there should be a meta field, and that status (and everything else used by middlewares or frameworks to attach specific behavior to actions) should sit underneath that meta field.\n. I think it's clearer to specifically signpost \"metadata\" as such, though - I agree that it gives you a little more to look at, but it makes it more clear on inspection what is what, and I think it's a bit neater to have a specific keyed place for everything, rather than saying \"put whatever else you want at top level\".\nThis is how JSON API does it: http://jsonapi.org/format/#document-top-level, and I like it in that context.\n. ",
    "goatslacker": "Bringing over the latest comments from #8 \n``` js\n{\n  // any: Symbol, string, number, object, function. A unique way to identify the action dispatched\n  type: ActionTypes.ADD_TODO,\n// any: whatever is being dispatched\n  payload: { text: 'Create FSA Proposal' },\n// information about the action itself\n\nmeta: {\n    // string | number: a unique identifier for the dispatch\n    id: 'abcdef123',\n// string representation of the particular action type\n// since Symbols are not strings and action type can be anything, having a way to identify an\n// action as a string is useful for serializing, debugging, and logging.\ndisplayType: 'ActionTypes.ADD_TODO'\n\n}\n}\n```\nI don't like the name displayType, other than that I think this is the most minimal interoperable action we can standardize on.\nRegarding the debate on here about status or error being first-class I don't really have any strong opinion. You both make good arguments. If I were to lean one way it would be to omit it from the spec because it's not minimal, it's a bit opinionated, and we can't seem to agree on it. But I'm not adamant about it.\n. Can we close this out with a resolution? I'd like to implement FSA for next alt release.\nMy current thoughts:\nid unique dispatch id.\ntype string. uniqued for each action.\npayload any.\nmeta object.\nerror boolean.\n. Yes you can, I just think action is a better name because meta may refer to meta information about the dispatch. Whereas action is explicit, it refers to data about the action.\n. We need more information than just the type. Since the type can be anything. \nIn alt I include a string representation of the type, the name of the action, and the namespace.\nEverything else is dispatch info. \n. yeah that looks good enough. Not sure about the displayType name but we can work on it\n. Closing this in favor of #4 which looks like a better issue.\n. ",
    "emmenko": "Just a minor note: if we're going with a boolean flag, woudn't be better isError or hasError?\n. ",
    "idolize": "I know this is an old issue, and it seems like the dust has already settled a bit, but I have a concern about errors in the FSA spec:\nIn the case of an error, the entire action payload is supposed to consist of a single Error object. Unfortunately, this restriction means that there is no way to add any additional payload information to the action. This can be problematic if there is other information required to handle the error, which I believe is a very likely scenario.\nFor example, if I am a developer and I have an UPDATE_USER action which requires a userId in the payload, my hypothetical Flux store (or reducer) probably needs that userId to update it's mapping of userId -> user data.\nLikewise, if the UPDATE_USER action fails, and I dispatch an action with error: true, then I only get a single Error as my payload... how does the store know which user failed to update?\nThe only solutions currently allowed by the spec (that I can see) are adding the userId information to the Error (which I may not have control over) or adding it to meta, which seems wrong to me because this information is not really metadata at all, but rather a core piece of the action payload.\n\nMy proposed solution is to change the spec from:\n\nAn action whose error is true is analogous to a rejected Promise. By convention, the payload SHOULD be an error object.\n\nto something like the following:\n\nAn action whose error is true is analogous to a rejected Promise. By convention, the payload SHOULD contain an error object inside an error field.\n\nThis is obviously a breaking change for code using the current spec; it would require error handling middleware to mirror the payload object with an additional error field:\nEx: dispatch({ ...prevAction, error: true, payload: { ...prevAction.payload, error: errorObj } })).\nAnd in addition, the handler of the action would have to access the error object via action.payload.error instead of action.payload.\nHowever, the result would be much friendlier to Flux developers in my opinion.\n. @tappleby\nPerfect. That idea also came to me before bed last night -- seems much simpler than requiring both, and it allows us to use the payload for other things :)\n. ",
    "cesarandreu": "This sounds like a great idea.\nWith respect to ordering information, I think picking something and sticking with it would keep people from falling into the bikeshedding trap, so I think it'd be good to include in the sequence field.\nNow for a little bikeshedding, why not use done to signal that it finished? Then it would match Iterators. Taking it one step further, why not try to match iterators more closely?\n{\n  type: 'FOO',\n  payload: { foo: true }\n  sequence: {\n    id: 123,\n    done: false,\n    value: 'start'\n  }\n}\n. Probably legacy reasons. Facebook's flux examples use actionType.\n. I think the reasoning might be so that you can serialize the action (which requires converting the Error object into a plain object) but still be able to convert the serialized action into its original state.\n. ",
    "valscion": "I like the idea of matching the spec with Iterators :+1: This would also allow you to specify the sequence.value in any way you choose to. In some cases, the value could be an object with a progress key if the user so chooses, or it could just be a plain scalar value if custom objects seem overkill.\nIt might be too much to try to fit the form of sequence.value to cover all the possible use cases. That could be left for the application domain to handle so that FSA would only be concerned about the sequence.id and sequence.done values. What do you think?\nEDIT: P.S. This issue being open is currently the only thing stopping us from using FSA in our application. Some way of resolving this would help us tremendously so that we wouldn't have to invent our own ways of doing optimistic updates.\n. > I am still not sure if value is necessary, optional data like this could be stored in meta.\nThat would actually be reasonable. If at some point FSA wants to change to add a more thought-out sequence.value, it would not conflict with ones before.\n. > I think the proposed sequence solution\nThere has been many proposed solutions in this issue @rgrwkmn. Which one do you mean?\n. Yeah so @rgrwkmn for your use case, the only thing that the sequence value MUST contain is type and id. The rest can be inside payload or meta, right?\nSo the spec would look like this:\njs\n{\n  type,\n  payload,\n  meta,\n  sequence: {\n    type: 'start', // or 'next', or 'done'\n    id: 123, // same for every action in the sequence\n  }\n}\nWhich in turn looks very similar to @acdlite comment, only the last value of type would be done instead of return. I have no strong feelings about that, though.\nSo @acdlite, have you tried your initial spec further? I think we're revolving back around to it, so it seems like a good way to go forward. The spec could always later be amended to include more values, should that be necessary, but at least we could go forward with what you've said.\n. @acdlite, would you accept a PR implementing the spec I described? Or the spec you have described? What needs to be done would be adding the sequence key and it's valid keys check to the isFSA function + amend the README to note optimistic updates, too.\n. ",
    "johanneslumpe": "I agree with @tappleby that return feels weird in this context. done  seems more appropriate here. :+1: \n. ",
    "chibicode": "I like @tappleby's comment: https://github.com/acdlite/flux-standard-action/issues/7#issuecomment-130933371\nAlso, for someone like me who didn't know about the iterator protocol, here's the link:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol\n. ",
    "gabrielgiussi": "Could someone explain a little more how will be used the iterator approach? What would be the benefits?\nThe actions would need to have an [Symbol.iterator], don't they?\n. ",
    "hiddentao": "+1 for @tappleby's suggestion.\n. ",
    "dlmanning": "Hey, random bystander here. Is there consensus about this yet? I'd like to incorporate it into an app we're about to start and basing off FSA's :)\nAnything that needs doing, experimenting with, or whatever? Happy to help. \n. ",
    "epeli": "BTW redux-optimist is an interesting approach https://github.com/ForbesLindesay/redux-optimist/\n. ",
    "timdorr": "@epeli That's actually very close to what Andrew is doing in redux-promise's sequence branch\n. ",
    "eldh": "fwiw I made a small todo app using the sequence branch while trying to learn redux and I find it to be pretty nice. https://github.com/eldh/todo\n. ",
    "gsklee": "Have no time to look closely yet but this might be of interest:\nhttps://github.com/pburtchaell/redux-promise-middleware\n. ",
    "gpbl": "I could test the redux-promise \"sequence\" branch and it worked very well for optimistic updates. I'd love to see this idea implemented into FSA.\n. ",
    "rgrwkmn": "I think the proposed sequence solution makes actions less readable. Actions that are part of the same sequence (and not part of start or done sequence type) seem more like a stream of progress information, with the most import information hidden away in the sequence key and the payload being unimportant. \n. I'm referring to @tappleby's comment.\nAs I worked through my own use case example and did some more reading, I've concluded that my criticisms are moot,  but since I haven't seen them specifically addressed I'll list them here. Hope this helps:\nActions having sub-actions hidden in the sequence type is less readable. It seems that none of the proposals preclude using different action types, though, so this is a moot point.\nThe discussion may be missing a distinction between optimistic updates (a standard that could be defined) and other multi-action processes (which could be anything). Semantically, sequence suggests it can cover any multistep process. A use case relevant to my industry would be deploying a virtual machine. I've described a potential list of rough actions in this gist. This point is also moot because I can see how using sequence with type and id can cover this use case, while I can still use different action types and have the relevant data in the action's payload.\n. @valscion :thumbsup:\n. ",
    "lukewestby": "@acdlite should updating the spec here precede finalizing https://github.com/acdlite/redux-actions/tree/sequence ?\n. @tappleby awesome! IMO it looks good to go. Let me rephrase my question more clearly: since redux-actions and many other libraries are intended to be FSA compliant, should we make an effort to see the sequence standard all-the-way through into the spec before implementing it in compliant libraries, or take more of a \"draft\" approach and implement what we have here to see if it works well before adding it into the standard?\n. ",
    "DawidLoubser": "My opinion is that FSA should remain a standard for the data structure for the action only. I think that optimistic updates are best handled at the higher level. \nMicrocosm has a particularly elegant implementation, where action creators can return ES6 generator functions, which the middleware will continually pull from - facilitating optimistic, or multiple, dispatch from one action.\nAnyway, I think that precisely because multiple ways exist to solve the optimistic update problem, it's better not to bake on view onto this into the FSA data structure 'standard'.\n. ",
    "iest": "What's happening with this? Would love to know if I should wait for this stuff to land, or if I should do a custom implementation...\n. ",
    "kpaxqin": "@DawidLoubser\n+1\nI think we should just keep FSA the simplest standard and move the async stuffs (include optimistic update) to the actionCreators .\nAnd in my opinion, the only things reducer should care about are payload and type, add other attribute on action will making things complex.\nHere is my example, a todo list with optimistic update : https://github.com/kpaxqin/redux_example/tree/todomvc\nThe redux-promise-thunk use thunk to dispatch action in each phase of async promise, and in TodoActions we can use createPromiseThunk directly or compose with another thunk\nThis is just a demo, but I think it can show the possibility of composing logics in action creator, instead of putting extra things in action object and handle them in reducer. \n@acdlite @lukewestby \n. ",
    "rdsubhas": ":-1: for sub-actions inside actions. Having a sequence object with a status inside it would lead to nested switch/case in reducers. The beauty of FSA is its easy to use it with or without redux-actions, and that ease should be maintained. I really believe sub-actions should have different action types altogether.\n:-1: for mixing Async/Promises with Sequence/Generator/Iterator. Those two are different problems. NodeJS made a hacky example of using generators to solve async, but that need not be taken as a standard. We should be looking at async/promise and sequencing as separate issues. Async should be handled separately like how ES7 introduced async/await.\n:+1: for keeping FSA simple. As with any standardization process, having this issue in FSA is delaying a trivial but most-hit-upon problem. Request to move the Async/Promise discussion to redux-promise to let things continue forward, and maybe discuss only sequences in the context of FSA.\nRequest to unstandardize this discussion, and move downstream. Atleast for the Async/Promise handling part.\n@acdlite @lukewestby @DawidLoubser @kpaxqin\n. ",
    "nhunzaker": "I'm bumping into this writing debug tools as well. Sending actions over postMessage is easy enough, but I keep wondering if I should add an assertion for objects that don't conform to:\nhttps://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm\nThe browser will gripe at you if you try to window.postMessage an object that doesn't follow this format, but it can be a little alien to get the message out of context.\n. ",
    "gaearon": "How about a dev-only middleware that you'd put at the very end, and that warns you when your actions aren't FSA-compliant (or serializable for that matter)?\n. ",
    "ariddell": "Just hit this.\nIt seems like serializing the Error object is the tricky part. The convention proposed be @acdlite makes sense to me, e.g.:\n{\n  type: 'FETCH_DATA',\n  error: true,\n  payload: {\n    message: \"Something's gone wrong\",\n    fileName: 'index.js',\n    lineNumber: 123\n  }\n}\nsince this mimics the Error object structure: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nMentioning this convention in the docs would be welcome.\n. ",
    "rstuven": "I implemented an FSA serialization library: https://github.com/rstuven/flux-standard-action-json\nI tried to be strict where the FSA spec is (throwing an error when the action to be serialized/deserialized is not compliant, ie.!isFSA()), but flexible enough to support Symbol (requiring a key though) and Error serialization (thanks to errio).\nI'll include a validation for something like isSerializable if FSA settles it down (opt-in or opt-out, depending on how the spec goes).\nHope you find it useful. :)\n. ",
    "maxmechanic": "Weirdly I just saw this issue, and have just published something like what @gaearon suggests for linting actions: https://github.com/maxmechanic/redux-fsa-linter\n. ",
    "jayphelps": "Are error objects suppose to be only for clientside errors? Cause given your example:\njs\n{\n  type: 'FETCH_DATA',\n  error: true,\n  payload: {\n    message: \"Something's gone wrong\",\n    fileName: 'index.js',\n    lineNumber: 123\n  }\n}\nIf the error was produced by the server, I'm not sure you have any meaningful fileName and lineNumber. e.g. if FETCH_DATA, the server responds with Unauthorized\nAlso--Error objects are not serializable as-is by JSON.stringify btw..not sure if tooling uses that or just walks the object manually.\n. bump @acdlite\n. ",
    "JaKXz": "Closing as stale, sorry this was never addressed. Feel free to open a PR for anything and it will be discussed :). Hopefully your question was answered. I think S/O is a better platform for these :). @bkonkle thanks for the contribution - I think in the time that this PR was made and now the lodash file sizes have improved, and I just tested v1.1.0 and found it to be < 10k [uncompressed and not uglified] including index.js and all dependencies. Let me know if you see anything wildly different from this.\nImprovements like this are welcome though, so if you find something else, feel free to crack open another PR! :). Hey @tomchentw I think that's a reasonable suggestion, want to make a PR? :)\nI have a broader, naive question though, probably for @jdalton:\nWould it be possible to have lodash itself depend on all the lodash.* modules and just export them under the one var _? There's probably a maintenance issue I'm not thinking of, but perhaps lerna can help with that?. @jdalton thanks for the reply :) \nI believe we were at ^4.0.0: https://github.com/acdlite/flux-standard-action/blob/01e8fc3cb9fa80fe49b816a9d65d1ad9c85c3180/package.json#L56\nbut yeah that's a good idea, I'll take a look at redux.. Thanks!\n. Thank you for the issue, I think this was addressed in #23.. Thanks!\n. Sorry @unional for the delay - I'm still on the fence about the index.d.ts file being in the src directory and then having to be copied over in the babel script. I'd rather it be in the root of the project and just published alongside the lib folder unless that's against the TS standard?\n. @unional thanks so much for your patience! I've had some offline conversations about this and it LGTM - I'll update the README and publish v1.1.0 soon.\n. I believe this is taken care of by using redux-actions. Closing as stale.. CI ~~is~~ was failing only because npm@2 doesn't like unresolved peer dependencies and eslint-plugin-airbnb-base hasn't updated its peerDependencies, yet: https://github.com/airbnb/javascript/pull/1101\n. @acdlite no worries! life first \ud83d\udc4d \nI'll reset my last commit.\n. <details>\n<summary>Title</summary>\nlots of stuff\n</details>\n\n\n\nTitle\n\n\nlots of stuff\n\n@yangmillstheory :)\n. @yangmillstheory my thoughts here: https://github.com/acdlite/redux-actions/issues/126#issuecomment-256832993 but I don't have a strong opinion either way so I'm fine with whatever the community decides :)\n. perhaps https://github.com/nzakas/eslint-plugin-typescript would help?. @unional thank you for your thoughts, hard work, and patience on this. I'm excited to get it merged after one last issue and release v1.1.0 :). @aight8 thanks for the issue, want to take a crack at a PR? :). @tomchentw oh ok, cool. Would destructuring those methods out of lodash also produce that result?. Yes, please :). Thanks @tomchentw! I'm going to bed now but I will release this by the end of the week when I have OSS cycles again :)\nIn the meanwhile please feel free to install flux-standard-action#master and give it a whirl.. + flux-standard-action@1.2.0 finally published! sorry for the delay!. Thanks for the patch! For some reason, I'm not seeing good errors on travis, but I tried the test command locally and it printed:\ntest/typings-test.ts(50,21): error TS2532: Object is possibly 'undefined'.\ntest/typings-test.ts(53,9): error TS2322: Type 'string | undefined' is not assignable to type 'string'.\n  Type 'undefined' is not assignable to type 'string'.\ntest/typings-test.ts(71,21): error TS2532: Object is possibly 'undefined'.\ntest/typings-test.ts(74,9): error TS2322: Type 'string | undefined' is not assignable to type 'string'.\n  Type 'undefined' is not assignable to type 'string'.\ncc @unional . @wub @unional thanks for the discussion, it's been informative to me too. Unless I'm misunderstanding something it seems like this is blocked by those Typescript issues? Specifically though, this point makes the most sense to me:\n\nIf you define a meta, do you expect that it can be optional?\n\nI would motion to close this PR in the meanwhile, possibly in favour of another one that \"loosens\" up the typings... though I'm not sure about what that looks like. TBPH I'm pretty happy with the way things are for now, but if others feel strongly that this needs to change somehow then I'm open to changes. :). Thank you for the PR, but please see the discussion in #53.. @smithad15 thanks for the response, and sorry for my slow response. Please feel free to submit that documentation change that is relevant until TS 2.3, but for now I'm going to close this PR in favour of #53. \ncc @wub, @unional . Please see the discussion in #53. Thanks!. @gCardinal I'm going to close this for now, hopefully your question is answered. If not, feel free to continue the conversation in #53 to keep the context there.. Hi @CharlieHess sorry for the slow reply, but as you can see #53 was not merged. Please see the discussion there. I'd be open to restarting that discussion if things have changed in the TS community, but it seems to me like the community is ok with the typings the way they are. Let me know if you have any further concerns but I'm going to close this issue to centralize the discussion in #53.. Hi @gurre thanks for the question. I apologize for the slow reply, but I think the best place would be inside the meta key so that your action is FSA compliant.\nIf you wanted to be extra-organized, you could nest it in a meta.geo key or something to that effect so that you can have other properties in your meta as well, that isn't related to GeoJSON.. @linguamachina thank you for the PR. What do you think of the discussion in #53? To me it seems this question has a lot of back and forth... I'm not a daily TS user so I'm not sure what the best course going forward is.. Closing in favour of #94. . Hi @robgraeber thanks for the suggestion! I think https://github.com/reduxactions/redux-actions is what you're thinking/looking for. :). From your usage example, the constructor takes the action type and the payload, and I assume returns the action object that you would dispatch.\nYou can achieve this with redux-actions:\n```js\n// in setUsername.js\nimport { createAction } from 'redux-actions'\nexport default createAction('SET_USERNAME', username => username)\n```\nYou can see more examples here - I think your suggestion is very valid, but I don't think that creating duplication here is necessary.\nThis repo is really meant to serve as documentation for what FSAs are. redux-actions promises to be FSA compliant IIRC.. I'm going to mark this as closed/out of scope for now. redux-actions is a great standard, but one size might not fit all. . This is something that should be reflected in the exported methods as well. . I believe this would also resolve #9, if there's general support for it. . the isError method is already exported, you can use it like so:\n```js\nimport { isError as isErrorAction } from 'flux-standard-action';\n// or without ES modules\nconst isErrorAction = require('flux-standard-action').isError;\nconst isNotErrorAction = (action) => !isErrorAction(action);\n``. Okay so unless anyone is opposed I'm going to merge this and release it as a patch today :).+ flux-standard-action@2.0.1` has been published! sorry for the delay, it completely slipped my mind before.\nIn related news, #100 would be a prime candidate for another patch like this one.... Thank you for the issue! I just merged #94 and perhaps we need something similar for payload.. I'm going to close this as fixed in the latest published version, but please feel free to re-open if you are still experiencing issues!. Sorry for the delay in getting this merged! I will have a patch released with teh fix for payload as well today.. + flux-standard-action@2.0.3 published! Thank you for your patience everyone.. @timche I think this is ready to go.. @timche that's pretty cool :) I think one for the typescript config would be expedient too.. @sstarrAtmeta are you still experiencing this pain? Would you like to take a stab at a PR? :). @ryanmitts thank you for the PR. I apologize for not getting back to you sooner, and now that #114 is also suggested, I would love to have a discussion there about what would be best. I do like the testing strategy that @couven92 came up with, do you think something similar would be possible here?. @ryanmitts great, thanks!. @couven92 can this be closed in favour of #114? I'm seeing a lot of similarities but I'll let you hit the button :). Doesn't the index.d.ts need to be in the published files? I would rather you move this to the root so that this array can just be: \njson\n[\n  \"lib\",\n  \"index.d.ts\"\n]\n. I'm not sure if this last statement is [strictly] true, since the tests have a line where the error object is an instanceof Error. see: https://github.com/acdlite/flux-standard-action/blob/master/test/isFSA-test.js#L31\n. Good point - it should be updated.\n. Though which one is defined as correct is still debatable imho [b/c we have a test enforcing one way and documentation mentioning another]. Thoughts @acdlite?\n. cc @yangmillstheory for your thoughts?\n. Please use the posttest lifecycle hook for tsc.\n. I would prefer to see semi-colons to be consistent with index.d.ts and the JS files.\n. I think all typescript dependencies should be in devDeps.. missed this one as well. There is an import that needs to be removed as well. . You need an error here . Sure, I'll make that change :). Nope, will remove.. I think we should keep coverageThreshold so that we don't dip below 100 at any time.\nI'll add the collectCoverage: true option.. I didn't add this so that we'd have less config to write. You have the con :). Good catch, thanks.. Done. Done. I think the plugin just adds linting rules for typescript specifically... I assume that it would be useful, and also helps the parser by not using all the potentially incompatible plugins that are meant for JS.\nI could be misunderstanding something important, though.. Done. I think this could be simplified:\nsuggestion\nexpect(fsaStrict.type).not.toBe(ACTION_TYPE_1). I'm curious what the benefit of creating Type and using the extends keyword is, as opposed to just saying it must be a string. I'm not up to speed on the latest TS trends \ud83d\ude05 . This is great. I think updating jest itself would be appropriate.. ",
    "xonev": "+1 This is confusing.\n. ",
    "cappslock": "Yeah, I had the exact same thought.\n. ",
    "tshinnic": "+1 definitely confusing as it says the action (object) MUST be identical\n. ",
    "gajus": "Have a look at https://github.com/gajus/canonical-reducer-composition. It is a broader standard I have been working on. It encompasses actions and reducer definition.\n\nOn Aug 10, 2015, at 21:29, Cesar Andreu notifications@github.com wrote:\nProbably legacy reasons. Facebook's flux examples use actionType.\n\u2014\nReply to this email directly or view it on GitHub.\n. Ah, OK. It is not a problem then. I was working on the Canonical Composition Action spec. If you do not require that object is an instance of Error and instead specify certain traits (e.g. it must have message property), then object can be serialised and unserialised as needed.\n\nBy the way, I am happy if FSA copy from CCA everything. I am only trying to improve the standard. I have little hope for replacing the standard. \n. Which is a good thing.\n\nOn Oct 15, 2015, at 10:42, Malte Legenhausen notifications@github.com wrote:\nForcing the assignment of error to the payload property seems to force you to use custom error objects, that contain all necessary information to describe the error context.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "luqmaan": ":pencil2: \n. ",
    "lizell": ":+1: \n. ",
    "tomatau": "+1 for error property being any object with a message property.\nYou can serialise an Error object:\njs\nJSON.stringify(new Error(\"my message\"), ['message'])\n// \"{\"message\":\"my message\"}\"\nYou can even serialise the stack if you so wish...\nHaving an error boolean flag to me seems like a duplication of action information.\nIt's good to have a place for a standardised error format that can hold general information.\nStoring state specific IDs for failure in the meta data also seems like the wrong place.\nFor example, an action sequence that performs a batch update with optimism.\njs\n{ type: BATCH_ITEM_UPDATE_PENDING, payload: {items[]}, meta: {actionId} }\n{ type: BATCH_ITEM_UPDATE_SUCCESS, payload: {successful_item_ids[]}, meta: {actionId} }\n{ type: BATCH_ITEM_UPDATE_FAIL, payload: {failed_items[]}, meta: {actionId} }\nThe meta property contains an id specific to the action sequence -- not the state changes.\nThe payload contains multiple ids (and more), for any items that failed and needs reverting from the optimistic update (or whatever else -- maybe error messages in the app?).\n. I agree that It's good to enforce standards and common structures but I don't think the payload is the best place for that when handling an error action.\nRight now we already force the error field to be a boolean, which is clearly limited in the information it can communicate -- so seems like a better place to enforce custom error objects. Then the payload doesn't need to conform to a structure when in an error action and can be free to contain more data about the error-action.\n. @mlegenhausen -- you can have a falsy value in your payload if you conform to the error value should always have a message property -- like an Error object, then everything else that doesn't have a message property can be ignored.\nNo-one here is suggesting that passing an empty string (or any other ambiguous falsy value) should be used as an error value.\n. The parameters causing an error can be put into an Error object -- along with many other things.\nI would assume it's more common for server responses to be placed in payload, not the meta object -- which makes the payload inconsistent already.\n. I prefer to see actions more closely represent business logic, and so often have some definition of how to handle errors. Logic around errors, validity and defensive defaults etc, can be different on a use-case by use-case basis even within the same app -- so I prefer to have this described at the action level.\nAlso, when handling any side effects, such as transactions, these definitely do not belong in a reducer and so the error handling must happen in the action layer for these situations.\n. How could actions introduce race conditions unless you fire off multiple actionCreators at the same time? Which is a pattern that is discouraged.\n. I'm in the habit of using flags in my reducers such as isPending so that the sequence of dispatched actions can be handled appropriately by the components responding to the said state changes. Action creators dispatching error actions can facilitate this process in sophisticated applications.\nYou're suggesting that components should initiate transactions, pass these results to the dispatch through an action creator and then the reducers all individually handle the response/error?\n. If the reducers are not handling the transaction fail event, what is?\n. That didn't answer my question.\nFor example.. when you make an AJAX request... where do you put your onError or try/catch for this transaction?\n. OK so you still put the transaction in your actionCreator.\nSo when setting error messages based on say a connection error or invalid response from the server, you would still send an action that resembles a successful transaction -- The error information would still need to be dispatched in an action.\n. Ahh! Yes you're not the only one! I'm not happy with that either and have been protesting for an API change around the error flag too :)\nI think you should check existing issues before opening a new one https://github.com/acdlite/flux-standard-action/issues/17\n. ",
    "pbomb": "I'm struggling a bit with this design as well. Our application has the typical pattern of fetches dispatching REQUEST, SUCCESS and FAILURE actions. For all of these actions, the payload always contains the contextual information required to identify which part of the state tree its for. If the FAILURE action is supposed to have the error property set to true and the payload property set to the error object, then the contextual properties don't have a home.\nThis is unless contextual information is always supposed to go into the meta field. My questions is related to the question in issue #18 asking what is supposed to go into the meta field. If contextual info should go there, then the REQUEST action would not have a payload, but only have meta. Can someone explain how this typical fetch pattern works with Flux Standard Actions? \n. ",
    "mlegenhausen": "Forcing the assignment of error to the payload property seems to force you to use custom error objects, that contain all necessary information to describe the error context.\n. Using an error flag is more explicit in term of what is possible with javascript. If you want to use a falsy value as your \"error object\"/payload you are unable to determine if your action is an error or not. \nExample:\n```\n// works\n{\n   error: {\n      status: 404\n   }\n}\n{\n  error: 'Error message'\n}\n// does not work\n{\n  error: ''\n}\n// works again\n{\n  error: true\n  payload: { status: 404 }\n}\n{\n   error: true\n   payload: ''\n}\n```\n. ",
    "bryanlarsen": "The error design of Flux Standard Actions is completely unworkable for us; we've decided to not use Flux Standard Actions for that reason.\n1.  As mentioned, the 'error' boolean is redundant.   For us, an error is any action that has a type that ends with 'ERROR'.\n2.  We almost always require the original payload when handling error actions.   For example, when we have an error updating a model, we update our state to contain the list of field that have not been successfully updated.   It's certainly possible to put the original payload into meta.payload or payload.payload or something like that, but that's just silly.   In our \"FSA\", the payload property of an error action is always the original payload.\n3. Given that most error objects are the result of HTTP actions, we have a standard field that contains the HTTP status code.   Not all errors have to have this field, but when they do, it's in a standard place.\n4. We make the Error object required rather than optional, and put it in the error property of the action.\n. ",
    "mattkrick": "I agree with where this is going. If there's an error, it's in my action type & that action creator can handle the error. What I don't like is having the error itself in the payload instead of the action that caused the error (or the multiple failed items if it's a batch job). I say let error be an Error object & for those edge cases where the action type doesn't have an ERROR/FAIL suffix, they can action.error instanceof Error (after a rehydrate, if serialized). \n. ",
    "m-sanders": "I agree with the general sentiment of this issue. \nI personally am using something akin to Error Handling in Nodejs guidelines, where only ever one property of data or error is set, error is always an instance of Error with an appropriate computer friendly name and a human friendly message. Any additional context objects can be attached to Error and should consistently exist for all instances of Error with the same name. On success data is a free for all but I try to document all relevant data on the action. I am using data over payload - both are equally vague but data is less keystrokes!\nAnyway, I am sure there is an XKCD mentioning something about competing standards....\n. ",
    "MarkMurphy": ":+1: I concur also. Ditch the boolean on the error attribute and store the error there.\n. ",
    "thedumbtechguy": "I came from SO for this same issue. \nWhen an error occurs, it IS an action. It is not an action with an error. \nI forsee conditional logic sprinkled all over your action handling code checking for an error property when you could simply be handling an error action. \nIf you are using something like redux, you can have a dedicated reducer handling errors. \nA better design would have been to standardize the error payload so handling is streamlined. \nAnother thing is properties that 'MAY' exist. How is that even standard then? More conditional logic for me. \nAn action should have ONLY two properties. A TYPE and a PAYLOAD. Everything else, error messages, meta data etc should be in the PAYLOAD. That is a standard.\n. @migueloller\nExactly my point.\nWhat you should be doing is standardizing the payload for a given action your application. \nThat way, your app knows how to react when ever it sees that action type. \nWhat happens when you decide that for a certain error, you want to do something different for example? \nYou \n. ",
    "jchook": "Consider this ideal use case where an AJAX request has 3 prongs:\n1. initial dispatch({ type, payload })\n2. success dispatch({ type, payload, meta: { serverResponse }})\n3. error dispatch({ type, payload, error, meta: { serverResponse }})\nWouldn't it make the most sense to have the payload consistent across all three in order to tell what parameters led to error / success? Unless I keep the original action in the action-creator scope, then put it in meta (yo dawg I heard you like actions), I cannot see what the payload of the initial action was.\n. ",
    "sagiavinash": "we can have a hasError flag in meta object and payload be the error object.\n. ",
    "migueloller": "I think the original intent of adding error as a boolean property can be deduced from the example in the readme.\n``` js\n{\n  type: 'ADD_TODO',\n  payload: {\n    text: 'Do something.'\n  }\n}\n{\n  type: 'ADD_TODO',\n  payload: new Error(),\n  error: true\n}\n```\nThere are no redundancies in this example.\nDue to the way people use Redux, though, it starts to get redundant.\n``` js\n{\n  type: 'ADD_TODO_REQUEST',\n  payload: {\n    text: 'Do something.'\n  }\n}\n{\n  type: 'ADD_TODO_SUCCESS',\n  payload: {\n    text: 'Do something.'\n  }\n}\n{\n  type: 'ADD_TODO_FAILURE',\n  payload: new Error(),\n  error: true\n}\n```\nPerhaps the correct approach would be to separate app concerns from asynchronous concerns and instead of doing request -> success | failure, it's better to do request -> success (triggers action<foo>) | failure (triggers error<foo>), where action<foo> is equivalent to { type: 'foo' } and error<foo> is equivalent to { type: 'foo', error: true } with their respective payloads.\nThe only issue this brings are optimistic updates. This could be solved, though, by triggering actions that queue the change when the request is made and then committing when it succeeds or reverting if it fails.\n. ",
    "queckezz": "From my perspective, I think payload is used for data that is necessary to update a given state to a new state whereas meta can be used for literally anything, commonly middleware. It's extra Information.\nA good example of using meta is redux-effects, where it's used to define future step()s for an effect. This is not necessary for updating the current state but for the middleware:\njs\n{\n  type: 'FETCH',\n  payload: {url: '/some/thing', method: 'GET'},\n  meta: {\n    steps: [\n      [success, failure]\n    ]\n  }\n}\nand it's used in: redux-effects#L16\n. ",
    "dariocravero": "Hopefully I got you right :). If you need state data you can always return a thunk that dispatches a promise in the payload, e.g.:\n``` js\nimport * as users from './api';\nexport const LOAD = 'my-app/LOAD';\nexport function load() {\n  return function loadThunk(dispatch, getState) {\n    dispatch({\n      type: LOAD,\n      payload: users.load(getState().credentials)\n    });\n  }\n}\n```\n. ",
    "GantMan": "Checking for errors at actions + async can allow for race conditions if you have sophisticated application.  Business logic belongs in a controller-like component, and reducers are model-like.\nI'll just have to disagree.  Actions seem like a bad place to enforce protection of state in my opinion.\n. I'm using redux-thunk to handle async actions inside my actionCreators.   I could then attemptLogin which will have the actions REQUEST_LOGIN and RECEIVE_LOGIN respectively.   Between the two, you could have the user press CANCEL_LOGIN.\nDon't focus on the example, but async introduces variance of order, simply by definition.\n. close.  The reducers set the state to error.  They don't handle them.   Basically, reducers are in charge of transforming state (as they should).  Ultimately, I guess that's where we differ.  We both agree that the problem needs to be handled (via flags/error or whichever we choose).  The crux is where and when.  And that depends on definition.\nFor me actions are signals that should not be stopped or stunted.  If a button is pressed, let the associated action happen, because perhaps later or in some other aspect of your application you'll want to do something, like log user behavior or show a friendly message.\nReducers can receive error messages from actions, but ultimately they transform data.  They should hold the rules of what error state should be.  I hate to use the hackneyed DRY concept, but actions can possibly come from a multitude of places, and what qualifies state changes really only matters in one spot, the reducer.\n. The \"Dumb\" components respond to the state change.  Error state can cause some components to become non-editable, while others turn red, and even others display messages.  When the props are mapped to state with connect, the components can then react accordingly to their own properties, powered by redux state.\n. Sorry I missed what you meant  and thank you for having this philosophical conversation with me :)\nA response that is an error (not a 200) is passed on through the action as to a reducer.   The action only cares a result has been returned (usually aptly named something like RECEIVED_X).\nThe reducer can then set state based on the payload.  Now the reducer translates error state, like 401 can set state to \"unauthorized\".  Which then prompts the correct behavior to deal with that state.\n. Yes.  I apologize for the confusion.  My gripe is the error flag in FSA.\n. O good!  I'm glad :+1: \nand thank you again for your time in discussing redux with me :) It really helps me grok the concepts more deeply.  I hope this thread helps others!\n. ",
    "dmytro-shchurov": "It's very sad it is closed, because it's a pain to use redux-promise -> flux-standard-actions with SystemJS. Because when I agreed to configure lodash.isplainobject, it required yet more 4 modules: _basefor, isarguments, isarray, keysin. My config.js is getting bigger and bigger, and soon exceeds a size of lodash. ",
    "tomchentw": "@JaKXz instead of replacing lodash modular dependencies, would you consider switching dependencies to lodash main module and import from its entries? For example,\nBefore\njs\nimport isPlainObject from 'lodash.isplainobject';\nimport isString from 'lodash.isstring';\nimport isSymbol from 'lodash.issymbol';\nAfter\njs\nimport isPlainObject from 'lodash/isPlainObject';\nimport isString from 'lodash/isString';\nimport isSymbol from 'lodash/isSymbol';\nThus, for those users who's also using lodash in their user space, the bundler (rollup/webpack) could resolve these modules and create a smaller output. What do you think?\n. One benefit of this approach is user can combine with babel-plugin-lodash and thus preventing importing the whole lodash into their bundle.. I've created the PR #51 to address it.. @JaKXz that's how it looks like when running yarn run build:\n\n. @JaKXz I think so! Would you like switching to destructing format?\n\n. @JaKXz updated!. Awesome!. ",
    "jdalton": "Hi @JaKXz!\nThe lodash.* packages are self-contained, zero dependency, packages. This means there'd likely be duplication. The preferred route would be to use something like babel-plugin-lodash. In v5 we're dropping the monolithic file altogether opting for folks to use the babel plugin if they want the monolithic-like syntax.\nIn the case of this PR though simply upgrading lodash.isplainobject to ^4.0.0 would get you reduced deps as it now has no deps. You can look to others like redux which cherry-pick Lodash's lodash/isPlainObject as well into their package build.. If you go the redux route you can combo with lodash-webpack-plugin for an even smaller bundle.. ",
    "brianneisler": "Seeing the same issue. Running on react-native 0.17\n. ",
    "alvaromb": "Same here.\n. ",
    "marcelklehr": "Same here, please add .babelrc to .npmignore or else fix it.\n. Thank you!\n. ",
    "tantou": "Same here !\n. ",
    "0x80": "Me too\n. ",
    "chrisdziewa": "Same here and it does work when I apply that fix @anderson916. Thanks!\n. ",
    "hero78119": "I run into the same issue when use react-native 0.17 + redux-actions + redux-promise with error prompt when bundle js \nbash\nTransformError: MyProject/node_modules/flux-standard-action/lib/index.js: [BABEL] MyProject/node_modules/flux-standard-action/lib/index.js: Unknown option: MyProject/node_modules/flux-standard-action/.babelrc.stage\n. ",
    "AbrahamAlcaina": "or include \n{\n  \"presets\": [\"stage-0\"]\n}\n. ",
    "smrq": "Thanks for the quick merge! :tada:\n. ",
    "axe312ger": "Oops sorry. All fine.\n. ",
    "sergej-s": "Also should action with error=true have different type or can have the same type as result action.\n. ",
    "coveralls": "\nCoverage remained the same at 100.0% when pulling cd45da8b9f74f0a85a4806247645a9d03368b435 on unional:master into 08fdb1b85ed301bd4512af7713e992479cfb637d on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 26a7bf3ac115a9f5a1196d194c56c9d736fae807 on unional:master into 08fdb1b85ed301bd4512af7713e992479cfb637d on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 26a7bf3ac115a9f5a1196d194c56c9d736fae807 on unional:master into 08fdb1b85ed301bd4512af7713e992479cfb637d on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 26a7bf3ac115a9f5a1196d194c56c9d736fae807 on unional:master into 08fdb1b85ed301bd4512af7713e992479cfb637d on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 8cc32e519a84f68b0f833872541d5fc6acd68434 on unional:master into 08fdb1b85ed301bd4512af7713e992479cfb637d on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 9f4d84fcb3ad91e1fb758781e74244ee873f27b6 on greenkeeper/eslint-config-airbnb-base-10.0.0 into 1c8f1f8ce784604a505d459d398d1ceb32e547f9 on master.\n. \nCoverage remained the same at 100.0% when pulling c3a4acad4029f2d3ff9ab695122b12319b342f80 on chore/update-all-dependencies into f6ad6d0e80b32a26da648165c0acd8ed1adcf64a on master.\n. \nCoverage remained the same at 100.0% when pulling 421cac2d7bf424ac463bcdcb58ee1aea48e33199 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 133fbdf7e1a4b35ca5597e5413743b4e1bcce801 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 133fbdf7e1a4b35ca5597e5413743b4e1bcce801 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 5633fff1a647dcdb0cb2ba5fa43261dbcb50f956 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 5633fff1a647dcdb0cb2ba5fa43261dbcb50f956 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 5633fff1a647dcdb0cb2ba5fa43261dbcb50f956 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling f542e795a5b74f90fb4d5df455cf6bc4b65561fe on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling f542e795a5b74f90fb4d5df455cf6bc4b65561fe on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 31f0e767af255cdd7681c8f2fc26b0da23173fe8 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 31f0e767af255cdd7681c8f2fc26b0da23173fe8 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \nCoverage remained the same at 100.0% when pulling 22229d3acd01a58ae80dcbaf1ceb11863588579b on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 78a9065914b2ca4848dfba8fc0b47c54e2d0e319 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 78a9065914b2ca4848dfba8fc0b47c54e2d0e319 on unional:master into d9b70df39fc57e0b7780bc6aed6486f607824632 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling c9fa6879ad2a8a419474fbda67771ee04c6dd8c2 on unional:master into 0c3752a91b4a0c111daa382ce95debbd13f90121 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 5216925601bf6b85a5b2d78c6e3ef869e578f5ac on unional:master into 0c3752a91b4a0c111daa382ce95debbd13f90121 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling b9d81be50367515496388e2ff8c9ea4420707fcc on unional:master into 00c2b9b9a4228cd6926e83c2e3dba32a5741ab80 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling b9d81be50367515496388e2ff8c9ea4420707fcc on unional:master into 00c2b9b9a4228cd6926e83c2e3dba32a5741ab80 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling b9d81be50367515496388e2ff8c9ea4420707fcc on unional:master into 00c2b9b9a4228cd6926e83c2e3dba32a5741ab80 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 73529c4205b4d3aff8147ca9d4f7946dbfafa6c4 on unional:master into 00c2b9b9a4228cd6926e83c2e3dba32a5741ab80 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 73529c4205b4d3aff8147ca9d4f7946dbfafa6c4 on unional:master into 00c2b9b9a4228cd6926e83c2e3dba32a5741ab80 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 73529c4205b4d3aff8147ca9d4f7946dbfafa6c4 on unional:master into 00c2b9b9a4228cd6926e83c2e3dba32a5741ab80 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 4157c98561df3cb723c57ef889121a3cd98446c8 on unional:master into 00c2b9b9a4228cd6926e83c2e3dba32a5741ab80 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 4157c98561df3cb723c57ef889121a3cd98446c8 on unional:master into 00c2b9b9a4228cd6926e83c2e3dba32a5741ab80 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 4157c98561df3cb723c57ef889121a3cd98446c8 on unional:master into 00c2b9b9a4228cd6926e83c2e3dba32a5741ab80 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 2e62303aa6be14db0f0049557a0d59bc2dea4b2a on greenkeeper/nyc-10.0.0 into d9b70df39fc57e0b7780bc6aed6486f607824632 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 75b2bb41b3982988de85d10f606f477e1d271044 on greenkeeper/nyc-10.0.0 into d9b70df39fc57e0b7780bc6aed6486f607824632 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 75b2bb41b3982988de85d10f606f477e1d271044 on greenkeeper/nyc-10.0.0 into d9b70df39fc57e0b7780bc6aed6486f607824632 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 75b2bb41b3982988de85d10f606f477e1d271044 on greenkeeper/nyc-10.0.0 into d9b70df39fc57e0b7780bc6aed6486f607824632 on master.\n. \n\nCoverage remained the same at 100.0% when pulling c18447d779a72098b17c1af168525eef39339726 on greenkeeper/eslint-config-airbnb-base-11.0.1 into 239349ce065da3433a055cbc91a4110a62963de2 on master.\n. \n\nCoverage remained the same at 100.0% when pulling c18447d779a72098b17c1af168525eef39339726 on greenkeeper/eslint-config-airbnb-base-11.0.1 into 239349ce065da3433a055cbc91a4110a62963de2 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 93824e885aed5a99311812830423f8b7216b6545 on tomchentw:refactor/depends-on-lodash into f787b9d03d2992f17c61871a1bf4eddb79d74f3b on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling a299fdeb54a4ceb42b2e0cc6067dcee1dac2d677 on tomchentw:refactor/depends-on-lodash into 01e8fc3cb9fa80fe49b816a9d65d1ad9c85c3180 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling a299fdeb54a4ceb42b2e0cc6067dcee1dac2d677 on tomchentw:refactor/depends-on-lodash into 01e8fc3cb9fa80fe49b816a9d65d1ad9c85c3180 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 237725ec270e378b4751b816d0e60825b4fc96c1 on greenkeeper/babel-plugin-istanbul-4.0.0 into f787b9d03d2992f17c61871a1bf4eddb79d74f3b on master.\n. \n\nCoverage remained the same at 100.0% when pulling 237725ec270e378b4751b816d0e60825b4fc96c1 on greenkeeper/babel-plugin-istanbul-4.0.0 into f787b9d03d2992f17c61871a1bf4eddb79d74f3b on master.\n. \n\nCoverage remained the same at 100.0% when pulling 7d79dfe9a8ce89ec79d71d8b158d9d33dc30cf01 on greenkeeper/babel-plugin-istanbul-4.0.0 into f787b9d03d2992f17c61871a1bf4eddb79d74f3b on master.\n. \n\nCoverage remained the same at 100.0% when pulling 7d79dfe9a8ce89ec79d71d8b158d9d33dc30cf01 on greenkeeper/babel-plugin-istanbul-4.0.0 into f787b9d03d2992f17c61871a1bf4eddb79d74f3b on master.\n. \n\nCoverage remained the same at 100.0% when pulling 7d79dfe9a8ce89ec79d71d8b158d9d33dc30cf01 on greenkeeper/babel-plugin-istanbul-4.0.0 into f787b9d03d2992f17c61871a1bf4eddb79d74f3b on master.\n. \n\nCoverage remained the same at 100.0% when pulling 58840bc962d480f3037a0416b543b7bfb4e62379 on wub:master into 5eb76c5a59b426111a84adae9ac9e95dc4cd424e on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 06299a9dc0e6eead1208d3ca56d3fb344ce49fda on greenkeeper/typescript-eslint-parser-2.0.0 into 5eb76c5a59b426111a84adae9ac9e95dc4cd424e on master.\n. \n\nCoverage remained the same at 100.0% when pulling 06299a9dc0e6eead1208d3ca56d3fb344ce49fda on greenkeeper/typescript-eslint-parser-2.0.0 into 5eb76c5a59b426111a84adae9ac9e95dc4cd424e on master.\n. \n\nCoverage remained the same at 100.0% when pulling 5d86379f33b33e797cb876d88e042dc2153e9276 on greenkeeper/typescript-eslint-parser-2.0.0 into 5eb76c5a59b426111a84adae9ac9e95dc4cd424e on master.\n. \n\nCoverage remained the same at 100.0% when pulling 25c75d9348eedb4604c7037512b09419942c6da8 on greenkeeper/cross-env-4.0.0 into 74f54c87d4829da47bdc19299e787c7359ae8d15 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 25c75d9348eedb4604c7037512b09419942c6da8 on greenkeeper/cross-env-4.0.0 into 74f54c87d4829da47bdc19299e787c7359ae8d15 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 786b7a6a41bb733a4aa25a7a3c9f873c2cf961ec on greenkeeper/cross-env-4.0.0 into 74f54c87d4829da47bdc19299e787c7359ae8d15 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 786b7a6a41bb733a4aa25a7a3c9f873c2cf961ec on greenkeeper/cross-env-4.0.0 into 74f54c87d4829da47bdc19299e787c7359ae8d15 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 6ea25b72a4a0d1eb8792fb8238bfc3dfd853a4fe on smithad15:patch-1 into e55a7364b1caa694b4a6bc9a0b66d7815e5761aa on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 4a3483751b1ba5107ee945d7f39c60f673515369 on greenkeeper/cross-env-5.0.0 into e55a7364b1caa694b4a6bc9a0b66d7815e5761aa on master.\n. \n\nCoverage remained the same at 100.0% when pulling 4a3483751b1ba5107ee945d7f39c60f673515369 on greenkeeper/cross-env-5.0.0 into e55a7364b1caa694b4a6bc9a0b66d7815e5761aa on master.\n. \n\nCoverage remained the same at 100.0% when pulling f8505aef859c9d7d280f5f9d518d99e9f5556c43 on greenkeeper/cross-env-5.0.0 into e55a7364b1caa694b4a6bc9a0b66d7815e5761aa on master.\n. \n\nCoverage remained the same at 100.0% when pulling 1cabad8217622d9e72e288514c4d859e66b36601 on greenkeeper/nyc-11.0.0 into 9973c1c8ffcb7830e5954ab3d94de64282721793 on master.\n. \n\nCoverage remained the same at 100.0% when pulling b16ecb8cc2d93b359255583d3a241db544aba7a9 on greenkeeper/nyc-11.0.2 into 9973c1c8ffcb7830e5954ab3d94de64282721793 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 4ed5b0705cce7620b3d2c3ad521dad44bc650d45 on greenkeeper/chai-4.0.2 into 9973c1c8ffcb7830e5954ab3d94de64282721793 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 04e5037170473425d978cebb69ae871219877418 on greenkeeper/chai-4.0.2 into 9973c1c8ffcb7830e5954ab3d94de64282721793 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 407b0f95e80e51b71044c82a8cfdc1a53dd45e23 on greenkeeper/typescript-eslint-parser-4.0.0 into bd571a795c6a39c7fae3a25ea11912f4fea5eb4f on master.\n. \n\nCoverage remained the same at 100.0% when pulling 20c81eec1302487a6e94837aa2b1566a89c32fbb on greenkeeper/eslint-plugin-typescript-0.3.0 into bd571a795c6a39c7fae3a25ea11912f4fea5eb4f on master.\n. \n\nCoverage remained the same at 100.0% when pulling 2121baaf6a39cd7482e0e7cd0caed34cc28f726a on greenkeeper/eslint-plugin-typescript-0.6.0 into 4924a8b2f195ecf030432ef6f5510c8f4aae7988 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 2121baaf6a39cd7482e0e7cd0caed34cc28f726a on greenkeeper/eslint-plugin-typescript-0.6.0 into 4924a8b2f195ecf030432ef6f5510c8f4aae7988 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 06ca4daf8e20618e704bd179024a0b6f963c1b7c on greenkeeper/typescript-eslint-parser-7.0.0 into 4924a8b2f195ecf030432ef6f5510c8f4aae7988 on master.\n. \n\nCoverage remained the same at 100.0% when pulling c50b13c30edbc2bf2af6e92664d2ed04962b3797 on greenkeeper/jest-21.0.0 into 4924a8b2f195ecf030432ef6f5510c8f4aae7988 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 4c053925b155aa73dede1d082ad8799f5552ba11 on greenkeeper/typescript-eslint-parser-8.0.0 into 4924a8b2f195ecf030432ef6f5510c8f4aae7988 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 4c053925b155aa73dede1d082ad8799f5552ba11 on greenkeeper/typescript-eslint-parser-8.0.0 into 4924a8b2f195ecf030432ef6f5510c8f4aae7988 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 14c77422f7a3685b03f734722744d365c5a64e62 on greenkeeper/babel-eslint-8.0.0 into 4924a8b2f195ecf030432ef6f5510c8f4aae7988 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 87dcaa390905c969ac5f5830ebb9f5569df96b53 on greenkeeper/babel-eslint-8.0.0 into f509286dc672785efd4437994bb14e0ab9d3a084 on master.\n. \n\nCoverage remained the same at 100.0% when pulling e9eb8e6b2a5ec37615b997cbeda6a1fd535362ee on greenkeeper/jest-21.1.0 into 4924a8b2f195ecf030432ef6f5510c8f4aae7988 on master.\n. \n\nCoverage remained the same at 100.0% when pulling a1cda1d38f4e16b2eaea3bcf89248c14f466ef1d on greenkeeper/jest-21.1.0 into 4924a8b2f195ecf030432ef6f5510c8f4aae7988 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 0f139a8393327bfb1e4e295ab49a7e0c23d32bb1 on greenkeeper/coveralls-3.0.0 into f509286dc672785efd4437994bb14e0ab9d3a084 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 0f139a8393327bfb1e4e295ab49a7e0c23d32bb1 on greenkeeper/coveralls-3.0.0 into f509286dc672785efd4437994bb14e0ab9d3a084 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 2b8a6c53e2e8f43277d44fb3c0b566d74c735d08 on greenkeeper/coveralls-3.0.0 into f509286dc672785efd4437994bb14e0ab9d3a084 on master.\n. \n\nCoverage remained the same at 100.0% when pulling bee9959fa93d82d3f77c9b815635dbde088305e3 on greenkeeper/eslint-plugin-typescript-0.8.0 into f509286dc672785efd4437994bb14e0ab9d3a084 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 6a56bfa9022020c7665ec6777ba2e4628cd62fcc on unional:patch-3 into f509286dc672785efd4437994bb14e0ab9d3a084 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 9a5ffeb07a4304b8cb7d5c0a4a996e974337a548 on unional:patch-3 into f509286dc672785efd4437994bb14e0ab9d3a084 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling e8795a3c6790f4d688e4b2d17d8fd52b690ae6f5 on greenkeeper/babel-eslint-8.0.1 into cc178cff783546aa5c45f9d758b0ee039d12794b on master.\n. \n\nCoverage remained the same at 100.0% when pulling be35d05e5b1fb0e4b24b7c3cd3a2b9a6f44bd0c5 on greenkeeper/conventional-github-releaser-2.0.0 into cc178cff783546aa5c45f9d758b0ee039d12794b on master.\n. \n\nCoverage remained the same at 100.0% when pulling 80bb55adb55ac2ced33f72f7d63d097f434fa655 on greenkeeper/babel-eslint-8.0.2 into 1e957bd005783f940bd7c6dba3772ed05f6a498e on master.\n. \n\nCoverage remained the same at 100.0% when pulling 8f6d057f406e33bfedfc765d18775e6265243ab0 on greenkeeper/typescript-eslint-parser-9.0.0 into 1e957bd005783f940bd7c6dba3772ed05f6a498e on master.\n. \n\nCoverage remained the same at 100.0% when pulling ebf82ee2f981ce3a5bd63fd0b87dfaa735e99851 on greenkeeper/typescript-eslint-parser-9.0.0 into 1e957bd005783f940bd7c6dba3772ed05f6a498e on master.\n. \n\nCoverage remained the same at 100.0% when pulling dd2ea7a61a46719c51ff0d19bf7b208fdd949d5a on greenkeeper/eslint-plugin-typescript-0.8.1 into 272f2d5500f41645c6f59bb1b7228cf924ae0cc7 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 309bd7fa6e46b99b176f5e00143ec2bf35db8491 on 3af:patch-2 into 272f2d5500f41645c6f59bb1b7228cf924ae0cc7 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 309bd7fa6e46b99b176f5e00143ec2bf35db8491 on 3af:patch-2 into 272f2d5500f41645c6f59bb1b7228cf924ae0cc7 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 5edfa80281ab89804f31d2eb68bce5863a4199c7 on 3af:patch-2 into 272f2d5500f41645c6f59bb1b7228cf924ae0cc7 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 5edfa80281ab89804f31d2eb68bce5863a4199c7 on 3af:patch-2 into 272f2d5500f41645c6f59bb1b7228cf924ae0cc7 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 786f2c3e77bbaffdbdefbb16da9c2effefe1efbd on wub:patch-1 into 388ca8f9d982d4d2ef23f998145b891543e98c27 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling 4eb16e4ec34117e40ecd43e2fc9f86fc889f2bb5 on greenkeeper/typescript-eslint-parser-10.0.0 into 388ca8f9d982d4d2ef23f998145b891543e98c27 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 4eb16e4ec34117e40ecd43e2fc9f86fc889f2bb5 on greenkeeper/typescript-eslint-parser-10.0.0 into 388ca8f9d982d4d2ef23f998145b891543e98c27 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 4eb16e4ec34117e40ecd43e2fc9f86fc889f2bb5 on greenkeeper/typescript-eslint-parser-10.0.0 into 388ca8f9d982d4d2ef23f998145b891543e98c27 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 975d1eff9925b43582413a7fbbcf910557105a1d on greenkeeper/jest-22.0.0 into 388ca8f9d982d4d2ef23f998145b891543e98c27 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 57f6d2fdf369a0103011e9953cc78ad3df417927 on greenkeeper/jest-22.0.4 into 388ca8f9d982d4d2ef23f998145b891543e98c27 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 14a958018ea9a9cfa8bfc2fc5e84098af58a9148 on greenkeeper/babel-eslint-8.1.0 into 388ca8f9d982d4d2ef23f998145b891543e98c27 on master.\n. \n\nCoverage remained the same at 100.0% when pulling 9efea41b821cf68265e4654f971aec6892888617 on pwnn:patch-1 into 388ca8f9d982d4d2ef23f998145b891543e98c27 on acdlite:master.\n. \n\nCoverage remained the same at 100.0% when pulling bd0d46b18cebb383a94717ddd5beecab7941cbdd on greenkeeper/jest-22.1.3 into 5afacaac3f958525d54d6f2a98d4b5381851291e on master.\n. \n\nCoverage remained the same at 100.0% when pulling bd0d46b18cebb383a94717ddd5beecab7941cbdd on greenkeeper/jest-22.1.3 into 5afacaac3f958525d54d6f2a98d4b5381851291e on master.\n. \n\nCoverage remained the same at 100.0% when pulling bd0d46b18cebb383a94717ddd5beecab7941cbdd on greenkeeper/jest-22.1.3 into 5afacaac3f958525d54d6f2a98d4b5381851291e on master.\n. \n\nCoverage remained the same at 100.0% when pulling 6f3842ab2e6432dd93caa9be759a58a84234e34a on greenkeeper/typescript-eslint-parser-13.0.0 into 5afacaac3f958525d54d6f2a98d4b5381851291e on master.\n. \n\nCoverage remained the same at 100.0% when pulling e3c6102d9b2030d915206b623d87f280ab74e44f on greenkeeper/babel-eslint-8.2.2 into 334ad3220c95fc29ce8c532fd515786c34cd695b on master.\n. \n\nCoverage remained the same at 100.0% when pulling ca2e14bfb6b6434a3d77021a9a7cbe89531c2ba4 on greenkeeper/typescript-eslint-parser-14.0.0 into 5afacaac3f958525d54d6f2a98d4b5381851291e on master.\n. \n\nCoverage remained the same at 100.0% when pulling dcb3a0f3bb6bda185ce19d0ba93e2578af39d9f7 on greenkeeper/eslint-plugin-typescript-0.9.0 into def5afd3fdf3958d57648a66e14a37558a67718e on master.\n. ",
    "unional": "I have updated it.\nThey typings file is basically the same. I just further clean up the comments as now VSC supports tilde in the intelliSense.\n. @JaKXz I update package.json to instruct babel to copy the file over to lib, so the editor can recognize the typings and it is still distributed under lib.\nerror is simplified to error?: boolean as discussed.\n. No problem. It is a convention that the .d.ts file lives along the .js file.\nThat's what tsc will produce if you wrote the library in TypeScript (that it transpiles the files to lib/dist).\nI can move it to root if you still want that.\n. I have some update to the typings that can make it more useful.\nWill submit another PR. Can you wait for that? Should be ready in an hour or so.\n. Thanks for bringing this up. I would vote for removing Symbol support for simplicity. Keep action serializable. \ud83c\udf37 . The reducer being a Pure function, it should not really make changes to the action either. I agree with @aCandidMind middleware should not change action.\n\nThe object isn't a a string or a number, so unless we're using the Immutable library, can totally be mutating.\n\nThe user is not necessary using an immutable library for state either, but the reducer should not change the state anyway.\nUPDATE: It's not really possible to do. e.g. thunk is dispatching a function to begin with. So middleware can change action, as long as the final action sending to reducer is serializable.. Updated based on feedback. \ud83c\udf37 \n. The last change I made worth debating. On one side it helps on the type guard usage, on the other side it makes action creation harder:\nhttps://github.com/Microsoft/TypeScript/issues/12400\nWhat do you think?. I think it is the right change. When payload and meta is defined by a custom action, the action author would expect the payload and meta to be non-optional.\nWould that be any case that this is not true?. cc/ @tkqubo who add typings to DT.. @JaKXz do you have anything for me to change before we can merge this? \ud83c\udf37 . @JaKXz good to hear from you!\n\nhere are some more nitpicks I could make in typings-test.ts about code style [e.g. missing semicolons \ud83d\ude31 ] - can that file [and other .ts files in the repo] be linted somehow?\n\nIt still have? Seems like I'm getting very comfortable with my own linting standard \ud83d\ude1b .\nI can use tslint (which I do for my projects), but the key is getting the same linting config as your are comfortable with.\nLet me know what do you want to fix (other than the semicolons), and I will fix them.\n\nthe posttest action that runs tsc will return an exit code of 1 if there is a problem with the typings, correct?\n\nYes, but since it is posttest, I don't think it will stop the build.\n\nplease run yarn to update yarn.lock\n\nI personally do not recommend checking in yarn.lock for module library. It makes breakage detection harder for the maintainer. I can do it if you still want to.\n\nwhat is the status on the typescript issue\n\nThey are working on it, likely will still take a few months to land. We can update the typing when that is released and get mainstreamed.\n. Found the comment I made about yarn.lock: https://github.com/greenkeeperio/greenkeeper/issues/314#issuecomment-270993958\n. > it would be ideal if the tsc command exited with a non-zero code\nIt does exist with non-zero. I was just concerning that posttest non-zero exit will be ignored. Seems like it will not be the case.\n\nI think the purpose of the yarn.lock file is to give some reassurance about what versions of dependencies and sub-dependencies are resolved & installed\n\nyes, that's true for applications. For modules/packages, IMO it will hide the problem until a user reports it. E.g. if your module depends on moduleA@1.2.3 and unfortunately moduleA@1.2.4 breaks your code, you won't know it until some users use your module and discover it is broken.\nThis is because during consumption, the yarn.lock file of your module is not used to lock sub-dependency.\nThe article (https://yarnpkg.com/blog/2016/11/24/lockfiles-for-all) about devDeps vs deps is correct thou.\nAll in all, maybe this topic is still in flux and it will clear out as more module authors adopt one way or the other. This is just a friendly discussion. \ud83c\udf37 \nMaybe using yarn.lock with greenkeeper would work out just fine?\nI have updated the yarn.lock file anyway, as you requested. \ud83c\udf37 \n. I'm not sure if this is the right change. \nIf you define a meta, do you expect that it can be optional?\nIf it is optional, then may be one option is to specify it as YourMeta | undefined\n. That will be possible when generic default lands. \nIn the mean time, I don't think overloading would work, but can give it a try. You are welcome.\nIt is a touchy point in TypeScript.\nIn the typings in DT, it uses FSA<Payload> & Meta<Meta> to get around this problem.\nHowever, IMO it does not do it justice as it is really a hack because when you define a FSA with meta, you are thinking of it as one type instead of an interaction of types. But it is IMO and discussion is always welcome.\nThe current typing is more strict and the good thing about it is that when generic default and undefined as optional is accepted and landed, there won't be any breaking change to the consumer of this library.\nWe can just loosen up the typings.\nHere are references to the issues if you are interested:\nhttps://github.com/Microsoft/TypeScript/issues/2175\nhttps://github.com/Microsoft/TypeScript/issues/12400\n. FYI generic default is available in ts@next. XD \n. > will this be resolved?\nDo you mean fixing the readme?. As discusses above, keeping meta as require field provides a more accurate type when you use meta.\nCurrently, there is a limitation on TypeScript side that you need to explicitly define undefined in the generic, but hopefully when it is fixed on TS land, this limitation can be removed and you can just use it as FSA<YourPayload> instead of FSA<YourPayload, undefined>. You can extend Error to add more information to it.\nIMO, as with rejecting promise, the rejecting parameter should be an Error.\nIn fact, I believe rejecting promise MUST reject with an Error.\nThat's how it works in async/await situation:\n```ts\nfunction foo() {\n  return Promise.reject(new Error('something'))\n}\nasync function boo() {\n  try {\n    await foo()\n  }\n  catch (err) {\n    // err should always be of type Error\n  }\n}\n```\nhttps://stackoverflow.com/questions/42453683/how-to-reject-in-async-await-syntax/42453798#42453798\n. @everdimension after using FSA for a while, yes I do agree with you that dispatched action is different.\nFor one thing, Error is not that serializable (JSON.stringify(new Error('abc')) gets an empty object string {}).\nBut on the other hand, putting Error (in a serializable format) in meta is not a good idea because meta can be used by middlewares and you run the risk of overwriting that information.\nIMO, { payload: <serializable error>, error: true } vs { error: <serializable error> } is about the same. You have to check for if (action.error) {...} anyway.\n\nAs for your first suggestion \u2014\u00a0extending the javascript Error object \u2014 I have to think about it, but I'm not sure it's such a good idea.\nMy understanding is that you should extend an Error instance with custom information only for debugging purposes, not to pass it around as data.\n\nI do see the value of carrying custom information by extending Error is very valuable.\nThe are three consumers of an Error: some Engineer, some logging mechanism, and the JavaScript engine.\nThe JavaScript engine doesn't care, it just spilled out the error.\nThe logging mechanism does care. Theerror.message often lacks the context for the logging to produce any meaningful message.\nThe engineer does care. It is never a good idea to try handling the error by parsing the error message. That is fragile, unreliable, and slow.. You can create one pretty easily.\nFor example: https://github.com/unional/fsa-emitter/blob/master/src/createActionCreator.ts\n. I'm ok with it.\nOne issue remain is this: https://github.com/Microsoft/TypeScript/issues/12400#issuecomment-296360175\nThat's why I didn't add the default generics yet.\nYou can see the behavior here:\nhttp://www.typescriptlang.org/play/index.html#src=interface%20FSA%3CP%2C%20M%20%3D%20undefined%3E%20%7B%0D%0A%20%20%20%20payload%3A%20P%0D%0A%20%20%20%20meta%3A%20M%0D%0A%7D%0D%0A%0D%0Alet%20x%3A%20FSA%3Cnumber%3E%20%3D%20%7B%20payload%3A%201%20%7D%0D%0A%0D%0Ax%20%3D%20%7B%20payload%3A%201%2C%20meta%3A%20undefined%20%7D%0D%0A%0D%0Alet%20y%20%3D%20%7B%20payload%3A%201%20%7D%20as%20FSA%3Cnumber%3E%0D%0A\nYou can see type declaration (x) is not working. Type casting (y) is working thou.. We can do that. Putting the file directly next to the source allows editor (VS Code) to pick it up automatically.\n. This is directly from the README. Do you want to update that?\n. I would like to keep it as simpleboolean. But by README, I assume you allow it to be other values.\n. When user enables strictNullCheck, it is excluded from ?.\n. Ok.\n. Nice, never use posttest before. :)\n. Yes, of course. \ud83d\ude1b . Thanks. I was editing on github directly. Missed the import. \ud83d\ude1b . Nope. That's the whole point. It should not be optional. See #53 and related discussion.. We discussed that here: https://github.com/acdlite/flux-standard-action/pull/53#issuecomment-279258673\nIt is debatable on which is a better solution.\nI would say when https://github.com/Microsoft/TypeScript/issues/12400#issuecomment-296360175 is resolved, we will be just fine.. ",
    "yangmillstheory": "Some of the keys above are optional in an FSA - payload, error, and meta, for example.\nYour action creator will always have these keys, however.\n``` js\nconst [ foo, bar ] = [ 1, undefined ]\nconsole.log({ foo, bar }) // { foo: 1, bar: undefined }\n```\nSo it's not a valid assumption (if by \"signature\" you mean \"same key-value return shape\"), as there exist action creators which output actions without some of the keys mentioned above.\n. Those markdown drop-downs are neat. Anyone know the markup for that?\n. Nice! Thanks \ud83d\udc4d  \ud83d\udc4c  \u270c\ufe0f \n. I think more people have probably read the README than studied the test - at least that's my personal experience with this. I would vote for aligning the test with the documentation, but the ultimate goal would be to pick one of those sources of truth and stick with it.\nAlso, it's been a while since I've done TypeScript, but shouldn't this be boolean, since no other value is meaningful?\n. It's \"allowed\", but not meaningful. In TypeScript we should have this be\njs\ntype?: boolean\nso that users know at compile-time that the only meaningful values are true, false, undefined, or null.\nI'm not sure how to exclude null, since ? seems to allow it:\njs\ninterface Foo { foo?: boolean }\nconst foo: Foo = { foo: null } // no compiler errors\n. Is there a way to disambiguate between null and undefined in code? I think 2.0 has Null and Undefined.\n. ",
    "everking": "Thanks for the response @yangmillstheory.\nWhat I meant was the parameter names that it will always have either none, or restricted to the following parameter names payload, error or meta.\nfunction someAction()\nfunction someAction(payload)\nfunction someAction(payload, error)\nfunction someAction(payload, error, meta)\nSo the following would be invalid/non-compliant:\nthis.props.someAction(myOwnParam, anotherParam);\n...\nfunction someAction(myOwnParam, anotherParam) {\n    return {\n        type: SOME_ACTION,\n        myOwnParam,\n        anotherParam\n    }\n}\nInstead should be...\nthis.props.someAction({myOwnParam, anotherParam});\n...\nfunction someAction(payload) {\n    return {\n        type: SOME_ACTION,\n        payload\n    }\n}\n. @yangmillstheory @acdlite - any thoughts?\n. ",
    "cornedor": "You could store the name in meta.\n. ",
    "mstruensee": "check out redux-higher-order-reducers and see that works for your use case(s).  If not add comments \ud83d\udc4d . ",
    "BerkeleyTrue": "I'd also vote for removing Symbols since they are not serializable. ",
    "aCandidMind": "You could easily namespace inside the meta object. Putting your namespace top-level only saves you from some code blatantly clearing meta. Don't know why someone would do that. Which brings me to the question of why actions aren't immutable? To me they should include all information when they are created. It's not like they go through middleware chain or is that me being to inexperienced with Redux?\n. ",
    "faceyspacey": "they do go through the middleware chain. Each middleware can modify the object. The object isn't a a string or a number, so unless we're using the Immutable library, can totally be mutating. But that doesn't really matter because each middleware can return an entirely different object as well, but after having done whatever they want to \"it,\" including assigning to the key and perhaps overwriting what you assigned to it. In fact, that's what some middleware do--tack on meta data to your actions object and probably many other things. So my concern is someone doing that incorrectly (by simply assigning to action.meta rather than incorporating its current values) and erasing my meta data. \n. ",
    "peterjacobson": "Lack of other action props is preventing me integrating this awesome module with redux-optimist, which seems to expect optimist and response properties in the action object. I could be wrong here, still trying to fully understand what's going on \nWould you consider allow other action prop types if only to interface with other excellent modules?. ",
    "greenkeeper[bot]": "Version 11.0.1 just got published.\nUpdate to this version instead \ud83d\ude80 \n. ## Version 11.1.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n. ## Version 11.1.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n. ## Version 11.1.3 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n. ## Version 3.2.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv3.2.1\n<a name\"3.2.1\">\n3.2.1 (2017-03-04)\nBug Fixes\n\nbin location (aae44dff)\n\n\n\nCommits\nThe new version differs by 1 commits .\n\naae44df fix: bin location\n\nSee the full diff.\n\n. ## Version 3.2.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv3.2.2\n<a name\"3.2.2\">\n3.2.2 (2017-03-04)\nBug Fixes\n\nbin require (b303b9f5)\n\n\n\nCommits\nThe new version differs by 2 commits .\n\nb303b9f fix: bin require\n85b8e8a docs: contributor member (#66)\n\nSee the full diff.\n\n. ## Version 3.2.3 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv3.2.3\n<a name\"3.2.3\">\n3.2.3 (2017-03-04)\nBug Fixes\n\nbin: babelify bin (#75) (967f4728)\n\n\n\nCommits\nThe new version differs by 2 commits .\n\n967f472 fix(bin): babelify bin (#75)\ndba0b39 docs: update path to release page (#71)\n\nSee the full diff.\n\n. ## Version 1.1.9 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\n1.1.9\n\n1.1.9 (7427b9b)\nchore(travis-ci): only call coveralls on success (e26c9a7)\n\n\n\nCommits\nThe new version differs by 2 commits.\n\n7427b9b 1.1.9\ne26c9a7 chore(travis-ci): only call coveralls on success\n\nSee the full diff\n\n. ## Version 1.1.11 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n9a18c37 1.1.11\n822e6ed chore(travis-ci): test Node 8 and npm 5\n488844a docs(README): add Node support policy\n741cf34 chore(package): relax Node and npm version requirements\n01481d7 1.1.10\n1b6a68c fix(transform): don't remove 'v' from tag\n\nSee the full diff\n\n. ## Version 11.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 5.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.0.0\n\n271b4f1 New: Support TypeScript 2.4 (fixes #321) (#322) (#326) (James Henry)\nea6c3bb Breaking: Use TSTypeReference for TypeParameters (#340) (James Henry)\na9ca775 Fix: Use name 'this' in JSXMemberExpression (fixes #337) (#338) (Reyad Attiyat)\nef2687b Fix: Handle assignment within property destructuring (fixes #332) (#336) (James Henry)\n\n\n\nCommits\nThe new version differs by 6 commits.\n\n34aaa71 5.0.0\n2650bdb Build: changelog update for 5.0.0\n271b4f1 New: Support TypeScript 2.4 (fixes #321) (#322) (#326)\nea6c3bb Breaking: Use TSTypeReference for TypeParameters (#340)\na9ca775 Fix: Use name 'this' in JSXMemberExpression (fixes #337) (#338)\nef2687b Fix: Handle assignment within property destructuring (fixes #332) (#336)\n\nSee the full diff\n\n. ## Version 5.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.0.1\n\n81e20c0 Fix: Only warn about an unsupported TypeScript version once (#347) (Jed Fox)\n5e22fac Chore: AST alignment testing against Babylon (#342) (James Henry)\n\n\n\nCommits\nThe new version differs by 4 commits.\n\n046727a 5.0.1\n5e00320 Build: changelog update for 5.0.1\n81e20c0 Fix: Only warn about an unsupported TypeScript version once (#347)\n5e22fac Chore: AST alignment testing against Babylon (#342)\n\nSee the full diff\n\n. ## Version 6.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv6.0.0\n\n32c0cc8 Breaking: Explicitly handle TSEnumDeclaration (fixes #345) (#364) (James Henry)\n5f741a9 Fix: Allow other orderings of implements/extends clauses (fixes #361) (#363) (Jed Fox)\nf5bd145 Chore: Breakout and label TS-specific AST comparison tests (#360) (James Henry)\nf6e56b3 Chore: Build out AST comparison tests and categorize issues (#358) (James Henry)\nab4e05e Breaking: Only add .implements/.accessibility/.decorators if truthy (#354) (James Henry)\n275897b Fix: Location data for methods and constructors (#357) (James Henry)\n5fce5e7 Fix: Exp. operator assignment is AssignmentExpression (fixes #355) (#356) (James Henry)\n67971de Fix: Include newlines at the end of source in AST (fixes #352) (#353) (James Henry)\n8406209 Fix: Remove start and end values from JSX tokens (fixes #341) (#351) (James Henry)\n\n\n\nCommits\nThe new version differs by 11 commits.\n\n9909aa1 6.0.0\n2237dc9 Build: changelog update for 6.0.0\n32c0cc8 Breaking: Explicitly handle TSEnumDeclaration (fixes #345) (#364)\n5f741a9 Fix: Allow other orderings of implements/extends clauses (fixes #361) (#363)\nf5bd145 Chore: Breakout and label TS-specific AST comparison tests (#360)\nf6e56b3 Chore: Build out AST comparison tests and categorize issues (#358)\nab4e05e Breaking: Only add .implements/.accessibility/.decorators if truthy (#354)\n275897b Fix: Location data for methods and constructors (#357)\n5fce5e7 Fix: Exp. operator assignment is AssignmentExpression (fixes #355) (#356)\n67971de Fix: Include newlines at the end of source in AST (fixes #352) (#353)\n8406209 Fix: Remove start and end values from JSX tokens (fixes #341) (#351)\n\nSee the full diff\n\n. ## Version 6.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv6.0.1\n\n7bcc0d6 Fix: Ensure modifiers are applied to enums (fixes #365) (#366) (James Henry)\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n65b019b 6.0.1\n43eed9f Build: changelog update for 6.0.1\n7bcc0d6 Fix: Ensure modifiers are applied to enums (fixes #365) (#366)\n\nSee the full diff\n\n. ## Version 0.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n0a781e9 Fix: type-annotation-spacing rule doesn't work for class properties (fixes #24) (#36)\nea18968 Fix: no-explicit-any Rule does not check generic type (fix #26) (#35)\ncdd4073 New: no-use-before-define (#34)\n76860d6 New: Add rule member-ordering (#23)\nd7b7936 New: Add rule no-type-literal (#15)\n\nSee the full diff\n\n. ## Version 0.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\nbae09be Chore: Publish version 0.5.0 to npm\ne1eda2d New: Add adjacent-overload-signatures (#37)\ncc4a362 Add typescript/no-unused-vars rule to documentation (#32)\nc350de7 Chore: Publish version 0.4.0 to npm\n\nSee the full diff\n\n. ## Version 0.7.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\ncd935e9 Fix: fixes incorrectly marked function call as misplaced (fixes #63) (#64)\n5fe06f9 Fix: fixes missing test cases in no-unused-vars (fixes #65) (#66)\n205925b Fix: type-annotations are marked as used (fixes #61) (#62)\n3edbe7d Update: Migrate to typescript-eslint-parser 7.0.0 (#60)\n\nSee the full diff\n\n. ## Version 21.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 21.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 21.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 8.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv8.0.1\n\n0401ffc Fix: Calculate typeArguments loc data correctly if empty (fixes #395) (#396) (James Henry)\na214f71 Chore: Add a way to test TSX specific issues (fixes #376) (#398) (James Henry)\n9c71a62 Fix: add missing TSSymbolKeyword type (#385) (Ika)\ne10aab8 Chore: Refactor alignment tests, now on by default (#387) (James Henry)\n9e17d0b Chore: Minor cleanup, fix jQuery foundation copyright (#383) (James Henry)\n\n\n\nCommits\nThe new version differs by 7 commits.\n\n5e9e7fa 8.0.1\n5a96293 Build: changelog update for 8.0.1\n0401ffc Fix: Calculate typeArguments loc data correctly if empty (fixes #395) (#396)\na214f71 Chore: Add a way to test TSX specific issues (fixes #376) (#398)\n9c71a62 Fix: add missing TSSymbolKeyword type (#385)\ne10aab8 Chore: Refactor alignment tests, now on by default (#387)\n9e17d0b Chore: Minor cleanup, fix jQuery foundation copyright (#383)\n\nSee the full diff\n\n. ## Version 8.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv8.0.1\nv8.0.1\nHandle optionalCatchBinding: #521\n\n\nCommits\nThe new version differs by 2 commits.\n\n6c7e3d0 8.0.1\n5742b71 Adding optionalCatchBinding to plugins. (#521)\n\nSee the full diff\n\n. ## Version 12.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 12.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 8.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n1f220c2 8.0.3\ncf5ab03 Fix mocha command path.\n0609da8 Lock down dependency versions.\n\nSee the full diff\n\n. ## Version 11.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv11.0.0\n\n6698042 Breaking: No prefix on FnDec within namespace (fixes #127) (#413) (James Henry)\naec31cb Breaking: Implement parseForESLint() function (#412) (James Henry)\n\n\n\nCommits\nThe new version differs by 4 commits.\n\nf70a8e4 11.0.0\n0f99c37 Build: changelog update for 11.0.0\n6698042 Breaking: No prefix on FnDec within namespace (fixes #127) (#413)\naec31cb Breaking: Implement parseForESLint() function (#412)\n\nSee the full diff\n\n. ## Version 12.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv12.0.0\n\n6ce4cd8 Breaking: Properly categorize constructors with no body (#427) (Jed Fox)\ne94ede3 Docs: Sets default code block language in issue template to \"ts\" (#421) (Marius Schulz)\n\n\n\nCommits\nThe new version differs by 4 commits.\n\nc30e534 12.0.0\n6935dd3 Build: changelog update for 12.0.0\n6ce4cd8 Breaking: Properly categorize constructors with no body (#427)\ne94ede3 Docs: Sets default code block language in issue template to \"ts\" (#421)\n\nSee the full diff\n\n. ## Version 22.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 22.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 22.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 22.0.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 22.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 22.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 22.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 22.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 8.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nd84b236 8.1.1\ne4bed5a Fix: Prevent parseForESLint() behavior from changing after parse() is called (fixes #558)(#559)\n\nSee the full diff\n\n. ## Version 8.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n36bf8b4 8.1.2\n5aaf0e1 Fix: add Literal type to visitorKeys (#562)\nbf9092a Fix: ignore eval (fixes #560) (#561)\n\nSee the full diff\n\n. ## Version 8.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\nef27670 8.2.0\neba5920 Add other parser plugins, update yarn.lock (#569)\ne201fb4 Make 2018 the default ecmaVersion for rules relying on parserOptions (#556)\n1dedd1b update babel packages (#565)\n\nSee the full diff\n\n. ## Version 8.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nbf27f60 8.2.1\nd96ce55 fix export change (#571)\n\nSee the full diff\n\n. ## Version 22.1.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 14.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n45c0a88 14.0.0\n2078a59 Build: changelog update for 14.0.0\n439ea24 New: Support Definite Assignment (fixes #424) (#432)\nadc0b1b Breaking: Remove all tokens inside comments from tokens array (fixes #422) (#423)\n\nSee the full diff\n\n. ",
    "wub": "Oh whoops, that's laziness on my part, I'll fix that!. Good point! I find that I don't really use meta at all.\nIf I could do x: FSA<foo> instead of x: FSA<foo, any | undefined> everywhere it would look a bit tidier, but I don't know how complex that would make the typings.\nAlso, I could just make my own type X = FSA<foo, any | undefined>, couldn't I.. Great, thanks for the feedback @unional. Up to you guys!. @JaKXz Cheers! See you on the other side of ts@next ;). Yeah, sorry, @zowers (and anyone else), my PR is incorrect and will cause issues! I'll edit the parent.. @leesiongchan The first conversation happened before TypeScript 2.3, which introduced defaults for generics (like your example). But yes, we can do that now! I'll submit a request.. See #94. Sorry, not an expert in versioning - what should this be bumped to?. ",
    "ghost": "In the JSDocs, and README, it's still listed as optional (so is Payload).\njs\n /**\n   * The optional `meta` property MAY be any type of value.\n   * It is intended for any extra information that is not part of the payload.\n   */\n  meta: Meta;\nShouldn't it be the same as error? (meta?: Meta;). Aha. This is missing in the docs: FluxStandardAction, or import { FluxStandardAction as Action } from 'flux-standard-action';. ",
    "zowers": "will this be resolved?. I mean when the PR will be actually merged or there will be done anything to mark meta as optional. Oh, cool! Thanks for the explanation, it was not clear from the above comments that FSA<YourPayload, undefined> is compatible with { type, payload } (without explicit meta: undefined). ",
    "leesiongchan": "I thought we can set something like this?\nexport interface FluxStandardAction<Payload = undefined, Meta = undefined> {\n  ...\n}. Isn't this supposed to be optional?. ",
    "everdimension": "@unional \n\nIn fact, I believe rejecting promise MUST reject with an Error.\nThat's how it works in async/await situation\n\nI see your point, but I'd say that the dispatched action is of different nature compared to a promise chain.\nWhen using async or promises, you can easily keep the initial request object in scope and access it in the catch block.\nOn the other hand, the idea of flux actions is that they can come into your app independently. When you're receiving an action, you usually do not have another action (which might've been an \"initiator\" in some sense) in scope or in a closure.\nDispatched action should be sufficient in a way that a reducer can describe the state update accordingly. Making payload a faceless error strips this crucial information from the action.\n\nAs for your first suggestion \u2014\u00a0extending the javascript Error object \u2014 I have to think about it, but I'm not sure it's such a good idea.\nMy understanding is that you should extend an Error instance with custom information only for debugging purposes, not to pass it around as data.. ",
    "smithad15": "Understood, however, this does cause some confusion between the documentation and the type enforcement. If you are hesitant to change the type declarations while waiting for TS2.3, might I suggest changing the documentation to reflect the current limitations instead? Having a property described as optional, and then enforcing its inclusion only for TypeScript users is a little counterintuitive. Personally, I've had to implement my own type description in my projects in order to work around this. In the end, it's up to you. Thanks for the library!. ",
    "gurre": "Thanks!. ",
    "linguamachina": "Ah, sorry, I now see that this has been addressed before. I'll respectfully leave the PR open, because I think the interface definition for an \"optional\" property (as spec'ed in the docs) should allow the total omission of the property, if the user so desires. Forcing the presence of a property whose value is undefined or null is over-opinionated, in my book. YMMV.. ",
    "robgraeber": "@JaKXz Afaik redux-actions is different, it creates action creators and reducers. Versus I'm proposing an Action class/factory function to go along with the typescript interface definition.. @JaKXz My 2 cents: I gave it a try and I thought redux-actions ended up clunkier for what's conceptually a very simple task and didn't autocomplete as well for VSCode at least.\ne.g.\n```js\nexport function sendUsernameUpdate(newUsername, currentUsername) {\n  return new Action(SEND_USERNAME_UPDATE, {newUsername, currentUsername});\n}\nvs\nexport const sendUsernameUpdate = ReduxActions.createAction(\n  SEND_USERNAME_UPDATE,\n  (newUsername, currentUsername) => ({newUsername, currentUsername})\n);\n```. ",
    "timche": "Looks good \ud83d\udc4d . Looks very good now!. Is this still required?. Do we need still need to support 6? I think in general it's enough to use Node LTS which can be set as lts/*.. Is coverageThreshold configuration still needed? Do we want to set collectCoverage: true so coverage is collected by default and we don't need to pass --coverage?. Do we want to stick with camelCase for filenames like before and in our other libs? \n\"rules\": {\n      \"unicorn/filename-case\": [\n        \"error\",\n        {\n          \"case\": \"camelCase\"\n        }\n      ]\n    },. I think everything after xo can be omitted. See below regarding .ts files.. Is the plugins definition correct? I couldn't find anything where this is required:\n\nhttps://github.com/eslint/typescript-eslint-parser\nhttps://github.com/xojs/xo/issues/315#issue-316611471. Add extensions: ['.ts'] to support .ts files to change the line above.. prepublish can be changed to prepublishOnly: https://docs.npmjs.com/misc/scripts#prepublish-and-prepare. I also think that we don't need to test here when publishing from master as it should always be stable.. One last wish: Can this come after Build Status?. \n",
    "3af": "I see it now, I feel stupid. Thanks and sorry!. Fixed, thanks. ",
    "dsanders1234": "The problem is that this \"standard action\" format does not lend itself to typescript very well.  In reality, one should have an interface for each type of action:\ntypescript\nActionWithPayload<P> extends Action\nActionWithMeta<M> extends Action\nActionWithPayloadAndMeta<P,M> extends ActionWithPayload<P>\netc.\n. ",
    "sstarrAtmeta": "I believe this issue should now be closed, since the following commit will have made payload optional.\nhttps://github.com/redux-utilities/flux-standard-action/commit/62deb4ac6c83094c2cb3c41495febce3ac62a7d5. ",
    "jack-guy": "I think this should get merged! Clearly with the number of times this has come up, TypeScript users are generally confused that the type definitions do not match the documentation. If a property is truly optional, like meta, it should be defined with a question mark meta?: so we aren't littering our actions with\nts\n{\n  type: 'foo',\n  meta: null,\n}\nIncidentally, DefinitelyTyped has always had this right.\nBy the way, we should technically be doing the same for payload as well.... ",
    "npoirey": "I agree, we should merge this and do the same for payload. ",
    "codecov[bot]": "Codecov Report\n\n:exclamation: No coverage uploaded for pull request base (master@7e0007b). Click here to learn what that means.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff           @@\nmaster   #107   +/-\n=======================================\n  Coverage          ?   100%         \n=======================================\n  Files             ?      1         \n  Lines             ?      3         \n  Branches          ?      1         \n=======================================\n  Hits              ?      3         \n  Misses            ?      0         \n  Partials          ?      0\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/index.js | 100% <100%> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7e0007b...e771739. Read the comment docs.\n. # Codecov Report\nMerging #110 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@          Coverage Diff          @@\nmaster   #110   +/-\n=====================================\n  Coverage     100%   100%         \n=====================================\n  Files           1      1         \n  Lines           3      3         \n  Branches        1      1         \n=====================================\n  Hits            3      3\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8675633...6f82d82. Read the comment docs.\n. # Codecov Report\nMerging #112 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@          Coverage Diff          @@\nmaster   #112   +/-\n=====================================\n  Coverage     100%   100%         \n=====================================\n  Files           1      1         \n  Lines           3      3         \n  Branches        1      1         \n=====================================\n  Hits            3      3\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 98de5fe...dbabc94. Read the comment docs.\n. \n",
    "couven92": "We now have two variants solving this issue: #112 and #114.. @JaKXz yes, we can :)\n. Okay, first off, from what I can tell both my suggestion and #112 would work. I am going to argue for my suggestion (i.e. #114).\n\nBy redeclaring the payload and meta properties (in the FSAWithPayload and FSAWithMeta types) gives us the oppurtunity to add specific documentation comments on these properties, explictly stating that they are required.\nInferred requirements. The FSAAuto type automatically detects the usage of undefined arguments for Payload or Meta. In cases where you actually specify a type, you probably want the property to be required.\nObviously a very subjective view, but I'd argue that the conditional alias of the existing types is fairly easy to understand.\n\nDisadvantages:\n The condition statement is quite convoluted due to the fact that undefined for either and both Payload and Meta have to be checked. It will be difficult to extend the FSA with new additional optional/required properties. The Pick-method of #112 will be better suited to cope with future extensions.\n Using FSAAuto<string | undefined> still requires the payload property to be specified as shown in the test added in bdf8205.. And if we go for my option, can we please agree on a name for the automatically inferred requiements type? I do not really like FSAAuto as a name. Is FSAInfer better? Any other suggestions?. In TypeScript you can restrict a type to a constant value.\nFor a Counter application example this makes it possible to change the following code:\n``` ts\nimport { FSA } from 'flux-standard-action';\nconst INCREMENT_COUNTER = 'INCREMENT_COUNTER';\ntype INCREMENT_COUNTER = typeof INCREMENT_COUNTER;\ninterface IncrementCounterAction extends FSA {\n  type: INCREMENT_COUNTER;\n}\n```\nto this:\n``` ts\nimport { FSA } from 'flux-standard-action';\nconst INCREMENT_COUNTER = 'INCREMENT_COUNTER';\ntype IncrementCounterAction = FSA;\n```\nremoving the need to re-declare the type property. An object using a string, but different to 'INCREMENT_COUNTER' would thus not implement the IncrementCounterAction type.. ",
    "ryanmitts": "@JaKXz I would just use the other PR to solve this problem -- I didn't know you could override the optional properties like that.. ",
    "rhys-vdw": "Hey, sorry to butt in here. Just hit this issue and am a bit confused... Currently I have this issue:\nts\nconst x: FSA<string, undefined> = { type: \"foo\", payload: \"hello\" }\nType '{ type: string; payload: string; }' is not assignable to type 'FluxStandardAction<string, undefined>'.\n  Property 'meta' is missing in type '{ type: string; payload: string; }'.\nSo setting the type to undefined does not make the attribute optional.\nI think the DefinitelyTyped defs handle this in a more appropriate way.. Ah yeah, makes sense. It's just annoying having to add extra code to satisfy types, but a small price to pay I suppose. :). "
}