{
    "michaelficarra": "Sorry Gerald, I already updated it. Looks like Adam responded before I noticed this patch. Closing.\n. I've already fixed this locally, so it'll actually be easier for me to just close this. Thanks anyway.\n. > Michael would probably make classes automatically add this property in the future because displayName is going to be standardized.\nThat was exactly my thinking. Closing.\n. related: https://github.com/jashkenas/coffee-script/compare/2a56f0c...5d7a834.diff\n. @franc: because the grammar isn't a JS file, it's a PEG.js grammar, which has embedded JS snippets. I want those to be CS.\n. @Dignifiedquire: Definitely!\n. @Dignifiedquire: Always use interpolation for string concatentaiton. The + operator in CoffeeScript should only be used for summation.\n@renekooi: Matches on other rules produce the value returned in that rule's action. That could be a number.\n. The space is in the variable. I was using ws to stand for \"whitespace (characters)\".\n. No, it shouldn't be. I don't think we're taking advantage of any of the features that have any compatibility issues between the two compilers within the parser. The main ones are super, splicing, and indentation strictness. See this wiki page for more info.\n. This seems to have worked itself out at some point. Whew. Closing.\n. Resolved. Turns out you need to explicitly tell PEG.js to generate a memoising parser.\n. Actually, I got rid of that task this morning. Hold on, I'll push it.\n. Remember to quote them to account for files with spaces in the name.\n. Merged, thanks.\n. Same reason the official compiler commits its compiled source. This will soon be self-hosted, and the built files will be required to do any development on the compiler.\n. How do you feel about making this a git checkout lib? That's probably a more appropriate \"clean\", no?\n. You may want to check out the implementation of the optimiser (don't worry, it is very readable). Skip to the bottom. It can be supplied with additional, user-defined rules at compile time. The same will be possible with the compiler (CS AST to JS AST transformation).\n. Is there any reason why %s is quoted?\n. > The aim here was not to port all of command\nThat's far from what I did. This is a completely new CLI for a CoffeeScript compiler.\n\nRunning bin/coffee just sits\n\nIt's waiting for input on stdin by default.\n\nCan you pass it a file to work against?\n\nYes. Use -i to pass it a filename. bin/coffee -pi inputFileName\n. @josher19: I don't believe I'll be able to make use of that in either the preprocessor or the parser since they both need to work in the browser environment. I'll have to do a bunch of /\\r?\\n/ in the preprocessor and \"\\r\"? \"\\n\" in the parser.\n. @josher19: But line terminators are not insignificant whitespace.\n. Ah, that's a good idea.\n. Yes, @josher19's idea should work. I will try implementing it today.\n. Not yet, sorry. I will get to it soon. It is toward the top of my TODO list.\n. @brian428: c01df938f9897920d8f2a9b3b697dd3e578d0f62 should add support for windows line endings. Give that a try and let me know if it works for you. Sorry it took so long.\n. Fixed by cf0ac2583a9496db104162991bee363fc934daed and a few other, related commits.\n. Thanks for the tests. There's currently a bug with the preprocessor distinguishing between division and regexps. I'll look into it tomorrow and pull this when it's fixed.\n. @mattparlane: After the last few commits, your tests should pass. Do you mind adding a few more that test nested interpolations before I pull this?\n. Merged. Thanks for the beautiful tests.\n. I'm going to side with the decision in jashkenas/coffee-script#1820 for now, but I'm willing to revisit it later.\n. I'm sure you see the problem here, though. Since -h isn't a valid flag, the program is treating it as a filename because there is no ambiguity. Still, people will usually specify filenames that begin with - after the -- parameter so they know they won't ever conflict. It's tough. I think I'll do as you suggest and error on these parameters.\n. Sorry about the unexpected \"%uEFEF\". The test harness doesn't yet know how to properly format and display errors regarding indentation. I figured it was really low priority.\n. I'm going to have to defer to the numerous jashkenas/coffee-script issues on this, most recently jashkenas/coffee-script#1165. Features not already included in jashkenas/coffee-script will not be supported by this compiler. This compiler is meant to be a compiler for the language that the collaborators on that project have designed.\nI am interested in extending the CoffeeScript language in my project \"coffee-of-my-dreams\", but I am not a fan of getters/setters for many of the reasons listed in jashkenas/coffee-script#1165, so I don't believe I'll be adding them to the coffee-of-my-dreams language, either.\n. d8d1d210f93f284a6dced17275dcafdb983dfbdb\n. Representing comments in the AST is not a priority, but it is still a feature that would be nice to have. I may implement this at some point in the future, but it is much more likely to get in if someone else implements it and sends a pull request.\n. A strategy I would start with: change the TERM rule to allow an optional single-line comment before the terminator, then have that rule side-effect, adding the comment to a global list of comments. On every node creation, call some function like addComments that adds comment markers to the nodes if the global list contains any comments, then clears the list and returns the node.\nedit: Also, I'm currently omitting comments in the preprocessed code. You'll have to just change that to emit them instead.\n. Feel free.\n. > Trouble is, however, that the next node created after the comment is found != the correct node.\nOh, of course. I forgot about that. Sorry about the bad recommendation.\n\nI am now thinking of other approaches; maybe changing the grammar to support block comments as separate entities\n\nThat's always been a possibility, but the unfortunate consequence is that we'd have an optional comment in front of EVERY rule. Still, it could be the cleanest approach if we can't find anything better.\nRight now, I don't have any better ideas. I'll continue to think about it. Thanks for taking a look at this.\n. I'll be starting to preserve them through the optimisation and compilation transformations this week. So, soon but not quite yet. Try again in a week or two.\n. @TobiaszCudnik: Source map support is completed. See constellation/escodegen#50.\n. @mark-hahn: Just use the --source-map option to generate the source map that's associated with the JS generated by the --js option.\nbin/coffee --js -i sourceFile.coffee > outFile.js\nbin/coffee --source-map -i sourceFile.coffee > outFile.js.map\nThen, depending on the tool you're using, you may need to add a comment to the bottom of the JS file:\n(echo; echo '//@ sourceMappingURL=outFile.js.map') >> outfile.js\n. @Nami-Doc: Nope. One step at a time.\n. This seems like a failing of the escodegen project. It is attempting to require the source-map module, but it is not in its dependencies, since it's an optional dependency. Maybe it should try/catch the require and notify the user of this.\nPing @Constellation.\n@rpflorence: For now, you can just npm install source-map in this project's directory.\n. Looking through the npm documentation, the best option I've found is optionalDependencies in the package.json. It's not ideal, since it will unconditionally install the dependency, but at least it's marked as optional.\n. Also related: isaacs/npm@3bf7d2f7b34a1fdc15e4e7c58360c56157da5f70 . So I would change the installation instructions to recommend the --no-optional flag.\n. I have no plans. If you'd like to come up with a proposal, I'd be glad to take a look at it, but I have no incentive to create anything like that right now.\n. @delaaxe: Yep, I've done something similar in the current source-mapping pach I'm working on. Feel safe making use of those line numbers, since they'll be official soon enough.\n. > /Users/rpflo/Code/github/clones/CoffeeScriptRedux/node_modules/mocha/\nLooks like mocha isn't installing the required modules. For now, cd node_modules/mocha; npm install. If that doesn't fix it, cd node_modules/mocha; npm install commander.\nmake deps should have worked. Are you using the latest commit?\n. @rpflorence: I just set up the project on a clean machine, and the only problem I had was with today's recent update of pegjs. I've pushed ab4dec298b3a072b4245fab4d3424edae691bb56 to fix that. I'm going to close this since I can't reproduce your problem.\n. @StanAngeloff: Thanks for playing with it and reporting this bug.\n@Constellation: That's exactly right. Fix coming soon.\n. @StanAngeloff: I noticed that you're passing --optimise explicitly. Just so you know, that defaults to on. The option is there mainly so you can turn it off with --no-optimise (especially since it's not perfect yet).\n. It doesn't lock up, it's waiting for input on stdin. I tried to keep the same interface as the old compiler, but it simply wasn't sufficiently flexible. So I had to change it. You're probably looking to do coffee --js < ~/somefile.coffee.\nLike instructed in the README, use coffee --help to fully understand the interface.\n. Oh, I guess it's called StringScanner. Thanks for the heads up. Fix coming.\n. cscodegen isn't published yet, either. That's okay, I don't recommend using npm install. For now, people should be using make deps, as listed in the README. Come release time, all the packages should be available, and I will make use of npm install.\n. Fixed by 333f2a642951b4b3126fa763e344adb4ecc53700\n. > You're quick!\nRemember, this is my job right now. If I wasn't paying attention to my users, how could I justify accepting their money?\n. related, untested commit: dfe5782d3b3808b54d6176533e28ef7fd0e4e4ba\n. Browserify is working pretty well for me. I only have two issues: I can't get it to automatically export CoffeeScript (probably an option I'm missing), and I can't get it to automatically ignore /lib/coffee-script/run.js, which is needed to ignore the unsupported native module module. Currently, building the browser version requires manually deleting the require('./run') line in /lib/coffee-script/module.js and manually adding var CoffeeScript = ... to the output. I'm working on fixing these minor issues.\n. These issues are both known. The first issue is that I simply haven't yet added support for block comments, since they provide no functionality, and are an extremely low priority for me right now. Just replace them with single-line comments, which are ignored. I'll get to them when other real problems have been taken care of.\nThe second issue is one I'm currently debating over how to solve, so I'm glad you've brought it up publicly. Really, you shouldn't be allowed to perform an assignment within a higher-precedence operation like a do expression. I've been running examples through that contain expressions like a and b or c = d, and though it is currently accepted by the current overly-permissive compiler, I think it should produce an error because it just doesn't make sense. With the correct operator precedence, that expression would be disambiguated as ((a and b) or c) = d. Doesn't look so good any more now. Likewise, the example you provided is (in my mind, correctly) being parsed as (do doOneDir) =  -> ..., which is invalid. @jashkenas: what do you think about this?\n. @mark-hahn:\n\nI was really hoping redux would be backwards compatible\n\nThat's the goal, but the compatibility is with the CoffeeScript features as we intended them to be implemented. For instance, I didn't duplicate any of the bugs in the current compiler, so it's no backwards compatible in that way. But that was always the goal. I'm just not sure if we ever intended to allow people to throw unqualified assignment operations into just about everything.\n@epidemian:\n\nAlso, i sometimes find things like a and b = c to be useful. For example, when i want to cache the result of c, which should only be computed if a is truthly, for later usage.\n\nRemember: this wouldn't be disallowed, you would just need to raise the precedence of the assignment by putting it in parentheses.\n. @GlitchMr: yes\n. See issue #19. This is an open issue. Once you get your indentation inconsistencies sorted out, debugging should be quite nice. Make sure you're not alternating between tabs/spaces and if you're using spaces make sure the same number of spaces are used for indentation everywhere.\n. After looking into this syntax, I've come to the conclusion that this was not an intentional feature. At the end of a function call, an implicit object may be given on the next line, specifying that it is to be used as the last argument. You shouldn't then be able to chain to that result without using parentheses to explicitly specify the target.\nInstead, use\ncoffee\n(($ '<a/>').css\n  color: 'blue'\n  'text-decoration': 'underline'\n).appendTo 'body'\nor\ncoffee\n$('<a/>').css({\n  color: 'blue'\n  'text-decoration': 'underline'\n}).appendTo 'body'\nor \ncoffee\n(($ '<a/>').css color: 'blue', 'text-decoration': 'underline').appendTo 'body'\n. @connec: You've got it. I would run screaming from code written like that.\n. @mark-hahn: That is also a concern of mine. I really do not want this compiler to change the CoffeeScript language or break our users' production CoffeeScript code. But there has to be a line we draw between intentional features and quirks. I am not duplicating quirks. The original compiler was very, very permissive, allowing unintentional and inconsistent syntax.\n. I'll be fixing this issue as soon as #112 is finished.\nMessage to self: #79 is outdated, but it has some nice tests for this.\n. @dbrans: see the roadmap, my comment above, and the indented-member-access branch.\n. @meryn: This is already pretty much fixed. I just need to finish up the WIP commit on the indented-member-access branch. I've just been working on more fulfilling OSS projects recently.\n. > Do you think this (CSR dev) is an \"unthankful\" job, or does it not excite you technically anymore?\nNo, not thankless. It's just that the remaining things to do (super, splicing, this issue, a few obscure bugs) just don't ever affect me. Also, they're not particularly challenging. I'm using the compiler without any problems, so it's hard to get motivated.\nWith commonjs-everywhere, I truly feel I've created the best bundler available for modules that conform to the CommonJS spec. Thanks for the suggestion, I will write up a comparison between commonjs-everywhere and similar bundlers. I'm extremely proud of it :smile:.\n. > And yes, if CoffeeScript 1.6 currently supports this, I'd consider this an undesirable thing. It does enforce consistent indentation in other places.\n@meryn: I agree, but it seems a lot of others don't. The CoffeeScript language isn't exactly consistent. It is not designed to be a good language or to be liked by PLT enthusiasts, but instead to be accepted by the masses, who often don't know what's best for them. That's why I started coffee-of-my-dreams.\n. @meryn: Just call him here. Oh @jashkenas, @jashkenas, wherefore art thou, @jashkenas?\n. @meryn: That looks pretty serious. Can you open an issue for that?\n. Working on this one today. Since changing the compilation of statements-used-as-expressions so dramatically will be very difficult, I'm just going to rewrite the gross auto-declaration code, changing it from operating on the generated JS to operating on the CoffeeScript nodes. Not sure how well that's going to work with gensyms, but I'll find out.\n. Yes, that would be an easy way to do it. If this fails, I can do that instead.\n. I did this, but because someone might want to override the CS.Function, CS.BoundFunction, or CS.Class compilation without destroying declaration, I'm going to revert back to auto-declaration and use @Nami-Doc's strategy of skipping IIFEs that are marked as generated. This will allow custom rules to mark their IIFEs as generated when they don't want them to affect scope.\n. Definitely not. See the various issues related to this point in the original repo. Basically, it's either CoffeeScript or it's not CoffeeScript. The compiler won't be supporting different flavours of the language based on compiler flags. If you want to enforce those things, it should be easy to build a tool that utilises the parser and its \"raw\" values.\n. @mark-hahn: There are times when being more explicit can help the reader avoid manually disambiguating things, but that's really only when the programmer thinks it's cool to mix a bunch of implicit syntax. In most cases, it's trivial to disambiguate our implicit syntax, and the additional characters would be, as you say, noise.\n. @epidemian: I prefer that grouping style (and have promoted it many times, in many issues) to the style that appends a parentheses-enclosed argument list to functions. If you look at the source of this compiler, it's used everywhere.\n. Since this discussion is getting way off-topic, I'm going to ask everyone to move this conversation over to IRC or the google group. If you have fully-realised proposals, open an issue on jashkenas/coffee-script.\n. Yep, moving away from make deps (which pretty much just initialises the submodules) has been a goal since it was added. And you've got it exactly right: I haven't been able to do that because I haven't been able to properly reference my patched PEGjs in the package.json. Pull requests would be very welcome here.\nEdit: See #6 for the goal of using CoffeeScript in the PEGjs rules.\n. Because it's the best choice. It most accurately represents our intent. We want to evaluate the given expression and produce no result. The expression is the IIFE.\n. Ah, so that's how you do it. Thank you, @cgarvis.\n. Ugh, I get this error:\nnpm ERR! Error: invalid version: @VERSION\nnpm ERR!     at validVersion (/usr/local/lib/node_modules/npm/node_modules/read-package-json/read-json.js:529:40)\nnpm ERR!     at final (/usr/local/lib/node_modules/npm/node_modules/read-package-json/read-json.js:289:23)\nnpm ERR!     at /usr/local/lib/node_modules/npm/node_modules/read-package-json/read-json.js:119:33\nnpm ERR!     at cb (/usr/local/lib/node_modules/npm/node_modules/slide/lib/async-map.js:48:11)\nnpm ERR!     at /usr/local/lib/node_modules/npm/node_modules/read-package-json/read-json.js:241:40\nnpm ERR!     at fs.readFile (fs.js:176:14)\nnpm ERR!     at fs.close (/usr/local/lib/node_modules/npm/node_modules/graceful-fs/graceful-fs.js:92:5)\nnpm ERR!     at Object.oncomplete (fs.js:297:15)\nnpm ERR! If you need help, you may report this log at:\nnpm ERR!     <http://github.com/isaacs/npm/issues>\nnpm ERR! or email it to:\nnpm ERR!     <npm-@googlegroups.com>\nBecause @dmajda has a custom build process that uses a preprocessor to write the version number into the package.json file. I wish he would just fucking pull dmajda/pegjs#95 already...\n. Depends on #52.\n. Fixed by #107.\n. Related issues: Constellation/esmangle#40 and Constellation/esmangle#41\n. It should be easy, actually. You pretty much just need to update the file pointed to above to use my compiler's flags instead of the original's. And remove coffeelint. Then just open a pull request and let it sit until this hits 2.0.\n. coffeelint uses the old compiler, which fails on many perfectly valid constructs. Nested interpolations, for instance.\n. Testing --version sounds like an excellent idea.\n. Make sure it doesn't misidentify 1.2.0.\n. Sorry, I must have recently broken that. Fix and blame coming ASAP.\n. This was broken by a bug in the compiler (fix coming) when we started self-hosting, and went unnoticed until now.\n. @weyert: This should be fixed as of db8b64b3b1f545efa865ec20c96ef2ac0b136c72. Let me know if that doesn't work for you for some reason.\n. That's odd, I can't reproduce this issue.\n. Try running make clean; git checkout lib; make -j test.\n. Whew, good.\n. cscodegen is incomplete. Just ignore that optional dependency for now and don't use the --cscodegen option. If you really want to use its limited capabilities, clone it into node_modules/cscodegen. I will put it in the NPM repo when it's more complete.\n. Yeah, sorry about that. I need to loosen up the whitespace allowances regarding argument lists and member accesses.\n. @euskode: This will be fixed before 2.0, but I'm not working on it just yet. For now, just pull out the function and name it or flip _.delay.\n. @zoz: What is the \"value\" of a throw statement? This is another open question. The current compiler optimises this kind of construct, as well.\nedit: The value is undefined. The optimisation is valid. Fix coming soon.\n. This is intentional. See jashkenas/coffee-script#1275\n. Very interesting. This compiles on its own:\ncoffee\nclass Player extends Mob\n    constructor: (@world, x, y, z, @name) ->\n        @model = 'player'\nCan you post a reproducible test case?\n. Ah, super. See https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Progress. super is one of two features not yet supported.\n. Just forgot to allow the terminator that separates the finally from the catch body. Fix coming soon.\n. That looks good to me. What did you expect?\n. @gregwebs: That failure of the current compiler is a bug, since there's obviously a perfectly valid parse: the one my compiler has identified and used.\nThe eval generation is because we need to represent the inline JS as a node in our output JS AST. We add the requirement that the inline JS must also be a valid JS program. This shouldn't be a concern to anyone that wasn't abusing JS literals in a way that could possibly generate invalid output, such as leaving unmatched braces. I may further restrict it to valid ExpressionStatements. That way, {} will produce an object literal instead of an undefined value, and function a(){} will produce a named function expression rather than an undefined value with an environment mutation. We could do this by producing eval('0,X') or eval('(X)').\n. > using var gives no output\nSorry about that, a JS node was being assumed to have no side effects. The assumption should be the other way around. I will fix this. edit: For now, you can use --no-optimise.\n\nit is convenient for your implementation to wrap the javascript in an eval\n\nYes, but it's also the only way to define proper semantics for the JS literal. If it was allowed to contain arbitrary character data, its semantics would rely on implementation details that could change in the future. The completion value of a javascript program is well-defined, and that will be the value of a JS literal.\n\nI still don't understand how the generated javascript in the second example is supposed to be ok.\n\nMaybe it would help if you looked at the parse tree. I've cut out the source information for clarity.\n$ echo 'f = (`a`) -> a + 5' |  bin/coffee --parse\n{ type: 'Program',\n  body: \n   { type: 'AssignOp',\n     assignee: \n      { type: 'Identifier',\n        data: 'f' },\n     expression: \n      { type: 'FunctionApplication',\n        function: \n         { type: 'JavaScript',\n           data: 'a' },\n        arguments: \n         [ { type: 'Function',\n             parameters: [],\n             body: \n              { type: 'PlusOp',\n                left: \n                 { type: 'Identifier',\n                   data: 'a' },\n                right: \n                 { type: 'Int',\n                   data: 5 } } } ] } } }\n\nwe need to have a JS parser that can take apart the JS\n\nThat was an option that we considered, but it would require us to depend upon a JS parser for a feature that is highly discouraged and completely unnecessary. The tradeoff is not worth it when eval does at runtime what the parser would be doing at compile time.\n\nThis is yet one more CS feature being thrown out in 2.0.\n\nNot thrown out, fixed. It was broken. It allowed the user to provide a program that would cause the compiler to output invalid programs. It didn't have a properly-defined semantics, or any defined semantics at all. That is unacceptable. This has standardised it.\n. @mark-hahn: Preserving the semantics of CoffeeScript was the most important factor influencing development. It is not my intention to change CoffeeScript; I have my own fork for that. I personally disagree with some of the language features I implemented, but I faithfully implemented them. JS literals were always a hack. If they weren't being abused to do something crazy like try to change CoffeeScript semantics (such as with your scoping hack), my implementation should cause no problems. Allowing unparenthesised assignments on the RHS of boolean operators, as in your other issue, was a bug that people were (some intentionally, some unintentionally) abusing. These cases are extraordinary, and not indicative of the support for code you will see in well-written CoffeeScript programs.\n. @gregwebs: would this be more clear?\ncoffee\n(eval 'a') (-> a + 5)\nThis is what you're writing.\n. @epidemian: We have to distinguish parameter lists from functions being passed to parenthesised expressions, we can't disallow it. It's certainly useful, and I would be surprised if it failed:\ncoffee\n(generateAFunction withThisInitialisationValue) ->\n  thenPassThis\n  multilineFunction\n  withNoParameters\n. Cross-referencing: Constellation/escodegen#73\n. See #43. I will likely have to add a special syntax case for the do followed by an assignmentExpression (but nothing of lower precedence, ugh). I'm not sure where the error in the optimiser is originating, but I will likely find it when I go to fix this myself. For now, you can use --no-optimise to disable the optimisation pass entirely.\n. @bpartridge: Awesome. I'm excited to get more eyes on this code. You may find it useful to look through the slides from this presentation I gave: https://speakerdeck.com/u/michaelficarra/p/redesigning-the-coffeescript-compiler\nThis is also a good read (just make sure you read the comments!): http://codebrief.com/2012/08/hacking-the-coffeescript-compiler/\n. Very nice. I was just about to start looking into this. I figured it would be a minor change. Merging.\n. Beautiful. Thanks for following the grammar's style perfectly. We may want to DRY that RHS expression, but this is good for now. Merging.\n. This is expected behaviour. CoffeeScript has a long history of ignoring the existence of getters.\n. Thanks, merging.\n. This doesn't take into account the preservation of the raw value.\n. The extra spacing within the parentheses is not in line with the rest of the grammar's styling.\n1. make that change\n2. git rebase -i\n3. squash everything\n4. git push -f\nThanks for these pulls, they're much appreciated!\n. Hah, sorry, I don't mean to sound like your sergeant. I guess I just have an eye for detail. I will try to get on #coffeescript later today.\n. As you can see, it's merely a JavaScript file with a *nix-specific shebang. I'm not sure how people are expected to use the compiler on Windows; I have little experience with the platform. Try executing it as node bin/coffee --help and see what you get. I wouldn't be able to provide any assistance past there. If that doesn't work, try asking around on the CoffeeScript IRC.\n. Sorry, I must have missed this. The test suite hasn't been 100% ported yet. For now, use a?(b) (with explicit parentheses). Fix coming soon.\n. @nickretallack: fixed by 59a5b667d330da074af19db412418567dd4261cc\n. Fixed by https://github.com/michaelficarra/CoffeeScriptRedux/commit/eb22110d52add5683e68b41cb50e1e835320fed8\n. I hadn't been coercing the operands of ExistsOps to expressions. Fix coming soon.\nedit: grammar\n. @kevinmehall: 19b030300430ec61913b85a9cf01135aba73a749 should fix this. Thanks for the great bug report.\n. Merged. Thanks.\n. Sorry, that feature has been planned for removal and discouraged for over a year now. See jashkenas/coffee-script#1601.\n. Whoops. Looks like I forgot to mark the extends operator as having side effects. It's getting removed by the optimiser. I'll fix this as soon as I get back to my computer. It's a trivial fix.\n. Fixed by 6d6d77111f7dd6fa7836207b6df51a0f7af22525. Sorry for the delay.\n. Thanks for giving me the motivation to knock this one out. I've taken a similar but slightly cleaner approach with my solution in ecd067b2e9b175b9181d2ef235639abf92d354e2.\n. Works for me:\n```\n$ bin/coffee --js\nT =\n    a:1\nb:2\n\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var T;\n  T = {\n    a: 1,\n    b: 2\n  };\n}.call(this);\n$ bin/coffee --js\nclass Animal\n    constructor: (@name) ->\nmove: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var Animal;\n  Animal = function () {\n    function Animal(param$) {\n      this.name = param$;\n    }\n    Animal.prototype.move = function (meters) {\n      return alert(this.name + (' moved ' + meters + 'm.'));\n    };\n    return Animal;\n  }();\n}.call(this);\n$ \n```\n. Yeah, win32 line ending support is lacking. See #18 for that. I'm going to make a commit to make that character more readable. Hang on.\n. @sleytr: I've pushed 0535bc278385df793ed4b31c95cdd12a10d07bf2. Try that and show me your error.\nedit: Looks like your error might be originating in the preprocessor. I'll work on those errors.\n. @evrenesat: You can simply write your example like this:\ncoffee\nT =     \n  foo: ->\n    a = z(4, {\n      'q': 1\n      'w': 2\n    })\n  x: 1\n... or, taking advantage of implicit syntax, like this:\ncoffee\nT =     \n  foo: ->\n    a = z 4,\n      'q': 1\n      'w': 2\n  x: 1\n. This was a decision that had to be made very early on in the project. I could use a PEG to generate a parser with some very desirable properties or use parser combinators to define a parser with other desirable properties (namely, the runtime extensibility you mention). I went with the PEG and its linear-time parsing guarantee when memoised. Compiler/optimiser extensibility were important, so those have very versatile hooks built in. But, unfortunately, if you want to extend the syntax, you're going to need to fork it and modify the grammar.\n. See jashkenas/coffee-script#1952. The decision to change that behaviour must be made there before this compiler could implement it.\n. Yes, I know what the problem is here. You have invalid (inconsistent) indentation somewhere in your file. I'm working on improving the output for this kind of error. It's on the top of my list, but it may not be ready for a few days.\n. Proposals like this should go to jashkenas/coffee-script for the time being. This project is trying to implement only the features of the language as defined in jashkenas/coffee-script. What is the intended behaviour here, anyway? {id: id ? 0, track: track ? 0}?\n. It's not at all that complex. That wouldn't be very extensible. This repo will be out on npm as soon as it hits 2.0.0 stable. Right now, the kinks are still being worked out. I have a few bugs that are showstoppers for a stable release, and more will likely be found in the next few months. That said, you can see some examples of the extensibility of the compiler in this presentation (specifically slides 29-30): https://speakerdeck.com/michaelficarra/redesigning-the-coffeescript-compiler. You can make instances of both the compiler and the optimiser, add rules, and use those instances rather than using the static compile and optimise methods (which just defer to the instance methods of unmodified compiler/optimiser instances).\n. https://github.com/michaelficarra/CoffeeScriptRedux/blob/05026cdc0361124a031e5ac797a334cd98e610ca/src/command.coffee#L366\n. This should be an easy 5 minute fix for anyone looking for a way to contribute.\n. @jrozner: Definitely 5 minutes. See jashkenas/coffee-script#2496.\n. The former. It's a 5 minute fix.\n. Nope, this was fixed by #103.\n. Merged, thanks.\n. Committed b5dc7c7139fb499934baf10e77aa8f6fd30ee361. Thanks.\n. Crap, just realised you didn't include tests. Can you open another pull request with tests?\n. I'd like to see a test where -> debugger compiles successfully to function(){ debugger; }. I believe that's currently an issue. -> return if a then debugger should also compile. Anything else we should add?\n. LGTM. Squash and I'll merge.\n. @ghempton: Thanks, you've reminded me that I forgot to send out the last backer update. Currently, I'm at YOW! in Brisbane, QLD. I think the slides from my talk will give you everything I would have put in the update and then some. The Current Status and Future Work sections will probably be of most interest.\nI'm glad to see everyone still so excited about this project. I am working to get through the open issues and do what I've mentioned in the Future Work section in my free time. Unfortunately, my 4 month full-time funding period is over and I can no longer contribute as much time as I would like. The project can certainly still be considered actively maintained, though, and it is very nearly feature complete.\nI believe comment preservation, super, and array splicing are the only features that remain incomplete. I'd encourage anyone with a comprehensive test suite to start using the compiler now, but don't start a new project using this compiler just yet. I don't want anyone to have a bad experience with a subtle bug, and with a project this young it would be naive to assume that we know about all of them. To make sure I touch upon each of your points, I will answer them more directly below:\n\nJust curious as to what is the state of CSR?\n\nActively maintained, fairly stable, very nearly feature complete.\n\nAre you still planning on actively working on it?\n\nDefinitely. I love this project and have many more things planned for it.\n\nI see that the code is still largely undocumented and sprinkled with TODOs and the roadmap hasn't been updated recently.\n\nYes, that is an unfortunate reality. It is on my TODO list to clean up and document everything.\n\nHow far away from being a true coffee script replacement is the project?\n\nThat's a tough question because it depends on what you're looking for. It works, it supports nearly every feature of the language, and it's a tiny bit stricter regarding whitespace (which could still use tweaking). If that is good for you, you should be good to switch. For very large projects or teams, you should let it harden first like any other integral tool.\n\nDo the issues actively reflect what is left?\n\nTogether with the Future Work section, yes, I believe so.\n\nThe reason I ask is that I am very excited about the project and would like to help in whatever way I can. Thanks!\n\nI will be happy to ping you next time I see something that could be easily contributed. The first thing that comes to mind is porting the REPL over, but we're currently trying to rethink the REPL implementation in jashkenas/coffee-script, so that might not be a good idea. The next thing I could think of would be switching out uglifyjs for esmangle. That should be pretty easy for just about anyone.\n. @surjikal: I'm surprised super is a blocker for you. I didn't think too many people were using it. Maybe you're just one of those that are.\nsuper support is tough mainly because it's hard to define simple, consistent semantics for it. So not only do I have to try to emulate the behaviour that was codified in the original compiler, but also take into account any pending issues with approved changes/enhancements to super. Additionally, I have to consider how super may be changed in the future so that it doesn't require a fundamental redesign later. This involves looking into the changes that have been made to super in forks like LiveScript and Coco.\nSo, in short, it may take a little while. If I were you, I would make the uses of super more explicit anyway by desugaring them. Feel free to help with any part of that development process. I would love for someone to open up an issue and write some nice logic rules surrounding that feature that take into account everything I've mentioned here.\n. @kevinmehall: This branch has fallen behind while I was working on the parser rewrite. Can you rebase off master so I can properly review and merge this?\n. Thank you. I will review this today.\n. Alright, other than those issues, LGTM.\n. @mark-hahn: string interpolation expresses your intent more clearly. You intend to join strings, not do addition. The compilation also makes sure you don't accidentally do addition. JS using the same operator for two different operations was a mistake. Related: DavidBruant/ECMAScript-regrets#22\n. @epidemian: If I wanted it to do array concatenation and vector addition, I would actually define those types as monoid type class instances and use an operation that has type-specific behaviour (Haskell's mappend). Completely agree about the case where + is given a heterogenous set of operands being the root of the issue.\n. Merged, thanks!\n. Fixed by a1033f9951edbcbf22cf7cc8dcfbd573a5769ae2. Related: 2782c9bc25b3a98a2ce85e317f4f8306bd2bbe4e.\n. Duplicate of #20.\n. The semicolon should not be used to terminate an expression, but instead to separate two expressions. The semicolon is the sequence operator in imperative languages. I've considered allowing this special case, but it is so highly discouraged that it's best to just keep the syntax consistent. If you really want to explicitly terminate statements, use ;0 on the final one.\n. This works for me. It appears you've run into #18. For now, try setting your text editor to use \\n as a line terminator or, preferably, change to a UNIX-based operating system.\n. I'm making good progress on this. See the GH-112 branch. I just have to switch out all the binary expression rules with one rule that parses a list of arbitrary binary expressions and then fold them using the precedence table.\n. Hah, I've actually been working on something similar here: https://github.com/michaelficarra/CoffeeScriptRedux/compare/master...update-pegjs\n. Yeah, it's so much cleaner now. I'm also going to add an option that disables raw value preservation (now that that behaviour has been defined in a single place) so the typical user doesn't have to pay a performance cost.\n. See a1033f9951edbcbf22cf7cc8dcfbd573a5769ae2 and 2782c9bc25b3a98a2ce85e317f4f8306bd2bbe4e.\n. @Constellation: I'm having trouble using ibrik. I get errors that appear to originate in my compiler. I would love to start using ibrik's coverage reports to improve the test suite (and finally finish pulling in the original compiler''s tests). Do you mind taking a look at it?\n. Crap, you're right. I didn't run the tests after the recent changes to the parser. Though I don't know how that could expose a place where I forgot to run expr on some expression in the compiler. I'll try to track this down tomorrow. It should be pretty easy: just run each test file separately and then binary search for the problematic source with comments.\n. @jldailey: It was broken for about a day a day ago, but other than that it should build fine and tests should pass. It looks like you don't have /lib at all. /lib, the compiled compiler, is required to compile itself. The compiler is self-hosting. Try git checkout master && git pull origin master && git checkout HEAD lib && make -j build && make test\n. Closing until someone else verifies that they also have this problem.\n. Ah, yes. Now that I have PEGjs storing those properties and not my own code, I no longer filter those out. Thanks for spotting this.\n. I'm going to work on this next. I believe it may be the cause for #200.\n. @Arelius: Why is it desirable to have something like that parse? I would write it like this:\ncofffee\nidentity = ->\n  matrix = [\n    1, 0, 0, 0\n    0, 1, 0, 0\n    0, 0, 1, 0\n    0, 0, 0, 1\n  ]\nAnd that compiles just fine.\n. Sorry for the delayed response, everyone.\n@Arelius:\n\nI was going to continue to work on this, but it seems that you may be strongly against merging this in even if I do finish it. Can you comment on if this is indeed the case?\n\nI'm not strongly against it, but it's nowhere near the top of my priority list. It'd be interesting to see a good implementatoin.\n@alexgorbatchev:\n\nIf i'm not mistaken, in #45 it was decided to not support existing CoffeeScript markup... am I right?\n\nNot at all. It is still a top priority.\n@mlogan:\n\nplease clarify whether backwards compatibility with existing CoffeeScript code is a goal of CoffeeScriptRedux\n\nIt is the most important goal. Unfortunately, defining the language itself is a little bit tricky. There's a grey area where abused bugs meet obscure, discouraged features. I've just been ignoring that area for now while I polish up everything else so that 99% of users are better off. The other 1% that write code like this can wait a little longer until we figure out some consistent, understandable rules that allow these kinds of constructs.\n<rant>It would also help if there was more contribution and less moaning. A lot of people are complaining about these minor inconsistencies but don't contribute an exhaustive list of supported/unsupported cases or derive a consistent set of rules that would allow for the construct they desire. When I shoot down the issues as bugs with the old compiler, all I get in response is a \"but it works with the original compiler!\", not \"it's intentional and here's the rules for determining when you see this case\".\nIn this issue, for example, what's the rule? It would have to be some sort of special case, since the leftmost indentation is inconsistent, something identified as a bug in the original compiler. Also, whitespace within array literals is significant to support arrays that contain functions or implicit objects. This is not Python. But I'm willing to see a more well-defined proposal, even though I'm almost positive this should be categorised as a bug. It's just not proper CoffeeScript code.</rant>\nClosing until someone posts an actual proposal.\n. @mark-hahn: You've got it exactly right.\n. @Arelius: Feel free. But please try to be as detailed as possible, describing the properties of the missing feature or the parsing/identification rules for it. As @alexgorbatchev suggested, plenty of examples in all possible contexts would be a good start.\n. Closing in favour of jashkenas/coffee-script#2598.\n. Note that the extensibility of this compiler stops at parsing. You can change how a particular structure compiles and change its semantics, but you cannot add new syntax. I did not want to encourage people to make hundreds of \"CoffeeScript with small syntactic difference X\" languages.\n. Good catch, I will work on this right now.\n. This is proving more difficult than I thought it would. Analysing the grammar, it appears that this should already parse properly. I will need to investigate in more depth where exactly the parse is failing.\n. Ah, that helps a lot! Thanks.\n. Yeah, that is exceptionally difficult. I've been thinking about it, and the only clean solution I see is something akin to all the NoIn rules in @tolmasky's JavaScript PEG.\n. I'd really rather not have that cluttering up the grammar (and probably ~doubling its size), but it's likely the right thing to do.\n. Yeah, it would be nice to get this set up. I will look into it soon.\n. Merged. Now let's see if I can get it set up over at the Travis CI website.\n. Alright, I believe it's set up now. We'll see how it goes. Thanks for the nudge and the help!\n. Yep, that's a bug in the optimiser. It has no concept of directives, so it just throws them out as dead code. For now, as @delaaxe says, use the --no-optimise flag.\n. @Zearin: Glad you're excited about the project. Right now, I'd say this project is in an early beta. In fact, I'll be tagging it as such and releasing it on npm shortly.\nThe advice I have been giving people is to try it out with already-stable projects that have good test coverage. If your tests are still passing, the compiler is obviously working for you. It's currently a little too strict with its whitespace requirements (so you might need to tidy up a bit), a few minor features haven't been implemented, and I have a few open bugs I'd like to fix before tagging a 2.0 and looking to merge with jashkenas/coffee-script. For brand new projects, stick with the much more time-tested compiler for now unless you absolutely need one of the features only available in my compiler.\nSee the related issue #106 and another related discussion on the Google Group.\nI'll leave this issue open to remind me to add a little note to the README. I need to update documentation anyhow. Thanks for asking!\n. @Ciantic: As I said above, I need to update the README and the wiki. If you need it in short order, please open a pull request.\nedit: @Nami-Doc beat me to it.\n. Of course.\n. Regarding the difficulties surrounding super, see my comments here: https://github.com/michaelficarra/CoffeeScriptRedux/issues/106#issuecomment-11102238\nThat's why it's been delayed for so long. super semantics are effing complicated.\n. @paulmillr:\n\nDevelopment of Redux slowed down much as compared to jun-sep \n\nAn unfortunate side effect from switching from full-time to free-time. I'm still working on it when I can! It's now just split among my contributions to all the other OSS projects I love.\n\ndo you think the project will be ready in the next few months?\n\nDepends on what you mean by ready. For some people and some use cases, it's ready today.\n. @mehcode: Correct. And that will still be a while. It needs a lot of users and time to shake out the bugs. It is still fairly new code, and only time will make us confident that it is \"stable\".\n. @mehcode: That new, fancy REPL is being merged in sometime this week and immediately ported over to here. That's why I've been working on it. I wanted a REPL, but not the somewhat hacky one that's currently there when newer, better hooks exist.\n. @archaeron: A few more things. I want to clear up cross-platform support. No matter how much we want to deny it, some people do actually use windows line endings. There's also a few bugs (all listed here in the issues) I'd like to clean up, and some whitespace issue discussions I'd like to try to get worked out. Also, ideally, I want to get the binary operator parsing rewritten. There's a much more efficient way it can be done. And we'll actually have a precedence table, so it will be much easier for forks to modify it. So still a couple months off from being merge-able. It's a slow process. But nothing's stopping you guys from using the compiler as it is right now. Unless you depend on super or splicing or comment preservation.\n. @nkohari: Yes, it will take many months, if not years, to finish the last 3 features, even though the first 97 and the infrastructure around them took just 4 months. Thank you for putting that into perspective for the rest of us. We'll be lucky if our children ever see a world with CoffeeScript 2.0.\n. Hey, everyone. I've updated the roadmap to include all the things I want to get done before I consider my compiler ready to replace the original. Check it out. Currently, there's 9 things on the list, some larger than others, and it has me reaching 2.0 sometime mid-late March. If any of you would like to work on any of those issues before I get to them, feel free to contribute in whatever way you like. It would be much appreciated.\nPS Thanks for the kind words and inspiration, @Zearin.\nPPS @nkohari: Sorry I was a little hard on you earlier. You did, indeed, touch a nerve. It's been difficult receiving criticisms where people were expressing a lack of confidence in the project being completed, while at the same time the first major release feels so close to me. I hope the roadmap alleviates some of your concerns. super is probably the only thing people would consider a \"major\" feature on that list.\nClosing this issue, as I think it has served its purpose.\n. I'll be making the compiler available on npm tomorrow, tagged as a beta release. It's 98% feature complete and fairly stable. And apparently npm orders 2.0.0-beta-0 before 2.0.0, so I don't have to worry about what I'll call it.\n. Link: https://npmjs.org/package/coffee-script-redux\n. See jashkenas/coffee-script#1494 and jashkenas/coffee-script#1820. I was at first unsure about the conclusions of those issues, but I now believe we made the right choice. If you'd like to change our mind, post your thoughts in one of those issues.\n@epidemian: I believe you were referring to jashkenas/coffee-script when mentioning --join. This compiler will have no such feature. That should be left to build tools.\n. @dmitkataev: just configure your editor to use \\n as the line terminator.\n. Merged as 1bef91eb4a2709f3721a4e46873e55c69002d363. Thanks.\n. Thanks, fixed in the above commit.\n. @Nami-Doc: only the non-standard name property, about which I don't care. @satyr actually recommended something like this for CS back in the day, I believe.\n. @mark-hahn: The related issues are all linked in the linked FAQ. I'm pretty confident I understand the IE bug. It has been around and well known for quite a while.\njs\nvar f = function g(){};\nbehaves like this in IE6:\njs\nfunction g(){}\nvar f = g;\nSo the name g is exposed to the containing scope in IE6, not just the function body's scope.\nedit: Also, f !== g, so memory use will be higher in IE6. But nothing will break because of the change.\n. @epidemian: I think you've stumbled upon an esmangle bug. I've reported it and it is linked above.\n. I'm going to close this because of general FUD and because I don't want this change affecting the merge into jashkenas/coffee-script.\n. You are awesome! This looks perfect. Thanks, merging.\n. Fixed by #318.\n. @ghempton: I just don't see any merit in trying to preserve the old interface, especially when I've abandoned it on the CLI. This compiler is composed of distinct components, and that's how the CLI exposes it. Each component is individually useful. If you'd like to add a convenience method that composes a few of these (and behaves like jashkenas/coffee-script's compile), I'd be fine with that. But I'd like the browser interface to match the node interface, which already matches the CLI.\n. With those changes, this patch should be good.\n. LGTM. Merging. We'll have to add browser tests at some point. Thanks for the contribution, @ghempton!\n. See also jashkenas/coffee-script#2051\n. See #92. Not allowing the language to be dynamically extended was a conscious decision. This way CoffeeScript programs will be syntactically consistent. Sorry for not closing this earlier.\n. Huh. Looks like ) should sometimes close an indent. For the record, I would write it like this:\ncoffee\n(->\n  foo\n)()\nbut we have do, so this is preferred:\ncoffee\ndo ->\n  foo\nAnother inconsistency in the language accepted by the current compiler...\n. @phadej: I just pushed a commit to fix this. Please try it out, as I plan to do a release in the next day or two.\n. Re-opening. I, too, thought this was the same as #119 at first. This is different, and I see no reason this syntax should not be supported. Thanks for the better description, @mehcode. We'll have to keep an indentation style stack in the preprocessor.\n. Fixed by #145. Thanks again, @Arelius.\n. Wow, I wasn't even aware of this bug in the original compiler. @Nami-Doc: can you point me to an open issue?\nWe won't be supporting bugs. Closing.\n. Thanks for the great test ideas, @epidemian.\n. @Arelius: Merged, thanks.\n@epidemian: Agreed, we can use more negative tests, both here and in jashkenas/coffee-script. But for now, the test suite is sufficient (it's unlikely similar constructs would behave differently), and I've merged these changes. I also agree that allowing the ugly code that follows a set of consistent rules is a step forward.\n. > Nothing happens. The program hangs.\nIt doesn't hang, it waits for input on stdin. That's what this line from --help means:\n\nUnless instructed otherwise (--{input,watch,cli}), coffee will operate on stdin/stdout.\n\nAlso, what OS/node are you using? The help should read coffee where you have node.\n```\n$ bin/coffee --help\nUsage:\n  coffee FILE ARG* [-- ARG*]\n  coffee OPT* [--repl] OPT*\n  coffee OPT* -{-parse,p,-compile,c,-js,j,-cscodegen} OPT*\n  coffee {OPT,ARG}* -{-eval,e} {OPT,ARG}* -- ARG*\n\n... etc.\n```\nI definitely see how those usage patterns could use some clarification, I just don't quite know how. Maybe with examples? Common usage?\n. Awesome. For future issue readers' reference, here's an example usage:\ncoffee --js --source-map-file file.js.map -i file.coffee -o file.js\n. @JamesMaroney: I'm not liking this change. By default, I would like the compiler to operate on stdin/stdout. And the only case where more than one output is desirable is the --js and --source-map options. We should just add an interface for that. See #148. Also, is the --output option still not working for you after 9b3b9e299aa365b8bc6535bd50f2c25cb459e143?\n. > I did maintain the stdin/stdout behavior for default.\nI don't believe so. This currently generates JS from stdin and outputs to stdout: coffee --js. How do you do that?\n\nThe biggest win is in the ability to link the js and source maps since the tool is writing them both in one pass.\n\nI agree that this is a useful flow. It's also a more efficient one, since they can both be generated from the same JS CST. I'm thinking I should just change the --source-map flag to a parameter that takes a filename or some way to specify stdio streams.\n. Looks like this is related to the general need for better error handling in the preprocessor. When you get the indentation wrong, you're going to get these terrible error messages. I will look into it. Thanks for the reports.\n. This was fixed by #157.\n. They work fine for me. Make sure you're using them as the binary seq operator that they are.\n. I can't reproduce this issue.\n. @Arelius: Mind rebasing? I would like to try to get this merged.\n. LGTM. Merged. Thanks, @Arelius!\n. Thanks, merged.\n. Why are you running npm as root?\n. No. It seems to be working for others. You could try posting the more verbose report. Your initial report looks like it couldn't find the StringScanner dependency, but it's definitely available. Are you on a machine that's not connected to the internet?\n. This was completed when michaelficarra/jedediah was released. See #221 for the planned switch to isaacs/nopt.\n. In a way. The CLI and API are incompatible because of the fundamental differences in the designs of the compilers. But the input language it accepts should be the same (sans implementation bugs). You can learn a good deal more by reading the previous issues that discussed this.\n. I know it's going to be unpopular, but this looks like yet another duplicate of jashkenas/coffee-script#1736. In python, indentation inside parentheses or brackets is ignored. CoffeeScript isn't python. Indentation is significant everywhere.\n. @jldailey: It's known. See #57.\n. It's a bug. They're both bugs, since throw is a statement in JS. Also, @epidemian: you forgot break and continue.\n. @kevinmehall: Yep, I believe I was the one that added that support.\nedit: Never mind, it was Jeremy.\n. Running make browser will generate the file you're looking for. You can also find this file already built at https://github.com/michaelficarra/CoffeeScriptRedux/blob/gh-pages/CoffeeScriptRedux.js\n. @Nami-Doc: That will probably work because of this: https://github.com/michaelficarra/CoffeeScriptRedux/blob/60916462e816cffdcb8b330ecc5d4fc611d71203/src/compiler.coffee#L95-L96\nFor the record, I highly discourage writing code like this. Gross. But we should support it.\n. @epidemian: You're exactly right, on both points. Comprehensions are not inferred to be such when they contain pure statements (or at least return). We could make it an error if we explicitly denoted that we wanted a comprehension. And that's why I think using a pure statement in what would otherwise be an implicit comprehension is such a gross style. But the original compiler intentionally supports that exact case, so we will have to as well.\n. Wow, when did that happen? git bisecting now...\n. I can't reproduce this. Please provide a test case.\n. Wow, this is an insane bug. I must have accidental state somewhere in the declaration-emitting code. Re-opening.\n. @epidemian: It's very useful, especially when you can easily write a script that fails when it detects the bug.\n. Huh, I still can't reproduce this on current master.\n$ bin/coffee --js --cli 'a extends b'\n// Generated by CoffeeScript 2.0.0-beta3\nextends$(a, b);\nfunction isOwn$(o, p) {\n  return {}.hasOwnProperty.call(o, p);\n}\nfunction extends$(child, parent) {\n  var key;\n  for (key in parent)\n    if (isOwn$(parent, key))\n      child[key] = parent[key];\n  function ctor() {\n    this.constructor = child;\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor;\n  child.__super__ = parent.prototype;\n  return child;\n}\nCan anyone give me a reproducible case?\n. Yeah, I just forgot to coerce it to an expression. Happy CoffeeScripting! :smile:\n. Thanks, @Constellation.\n. Yep, feature requests belong in jashkenas/coffee-script. And just use executable class bodies.\n. Looks fine to me. The semicolon is CoffeeScript's , operator. You wouldn't expect this JavaScript program to work, would you?\njs\na = 1\nrequire('./main2'),\nedit: @mehcode just beat me to it.\n. In this case, I'd say it depends who you ask. I have no qualms about not supporting trailing semicolons, though. If that's how you were writing your CoffeeScript code before, you were doing it wrong.\n. Ah, I see how that could happen. My editor actually points out trailing semicolons in bright red. Well, good luck with commonjs-everywhere!\n. @epidemian: Actually, I think that quote makes my point perfectly. But really, I don't care either way. I could add a special exception that allows trailing semicolons for blocks, and I could change the ; operator to read one or more semicolons. It's not going to be high priority, though. Code like that really disgusts me.\n. @mehcode: I couldn't have put it better myself.\n. This should help a bit, but obviously isn't a contributors' guide: https://speakerdeck.com/michaelficarra/an-analysis-of-the-redesign-of-the-coffeescript-compiler\nI'll try to write something up. Maybe a wiki page with pretty pictures and everything.\n. RE static type checker: see this tweet: https://twitter.com/puffnfresh/status/303961963661254656\nI think it's better to create a tool that performs the analysis on the spidermonkey AST and then just map the types back to the CoffeeScript constructs. Then you'll be able to determine static types for any compile-to-JS language.\nedit: here's some good resources or starting points:\n- https://github.com/espadrine/aulx\n- https://github.com/scripted-editor/scripted/wiki/Architecture#wiki-Inferencing\n- https://github.com/scripted-editor/scripted/blob/master/client/scripts/plugins/esprima/esprimaJsContentAssist.js\n- https://github.com/marijnh/tern/blob/master/infer.js\n- http://rfrn.org/~shu/drafts/ti.pdf\n- http://research.microsoft.com/apps/pubs/default.aspx?id=168635\n. Not with fall-through cases. We'd have to double up the body. Unless you mean we should or the conditions.\n. coffee\nswitch a\n  when b, c\n    do d\n  else\n    do e\n. Yeah, I think that's fine. Only for headless switches, though. We don't want to be repeating the switch condition all over the place.\n. Although, when it's used as a value, which is uglier: an IIFE wrapper around the switch or a conditional expression? I guess it depends on how many cases there are. But in the spirit of CoffeeScript, I guess we should compile to something as similar to the source as possible. Let's only transform headless switches.\n. Not quite as dramatic as that, but yes, there is a significant performance difference: http://jsperf.com/iife-switch-vs-ternary/2\nI'm torn here.\n. @jashkenas: I'm curious what you think is appropriate here. Do we sacrifice a little readability for some serious performance gains? According to the FAQ, we consider performance more important.\n. Closing this as wontfix. It was a bad idea, since we also need to make sure none of the cases have a break in them.\n. @epidemian: My feelings exactly. I'm not sure if there was an actual decision to support break in switch, they just  always compiled to breaks so worked as they would in JS. Personally, I would never write code that breaks early within a switch case.\n. It should be a pretty easy fix, just like it was with jashkenas/coffee-script. I'll look into it.\n. @fuson: I've implemented a similar fix. It's available now on master, and will be released in beta 8. Let me know how it works for you.\n. By the way, only node 0.10.0+ is supported with cluster, since that's when the execPath option was added to child_process.fork. Related: 432edaae31264451685fcc35532a4cad7a8fd369\n. @sokra: the additional offset is due to indent/dedent control characters and already known: #117\n. Huh, works for me. Are you building it yourself? Have you tried running npm update?\n. @ghempton: I just upgraded commonjs-everywhere (the build tool) to 0.5.x and successfully rebuilt the browser build (barring Constellation/esmangle#64). If you comment out this line, everything should work fine. Let me know how things work out for you.\n. Duplicate of #169.\n. Yes. It is just a very minor issue. Since it is literally a 1 line change to reduce the size of arrays that are cached, I will prioritise this for you.\n. I'm going to take this opportunity to just optimise loops over static, integral ranges.\n. You're running node 0.8. I accidentally broke it a few days ago. Upgrade node until I can issue a fix.\n. When you use the --source-map-file option, we add it for you, but in your use case, we have no idea whether you have a map or where it is. So yes, you should add the comment yourself.\n. Thanks for the analysis, but this is already known. See #43. We're still unsure about this syntax.\n. Confirmed, marking as bug.\n. Looks like an escodegen bug:\n``` js\n\nrequire('escodegen').generate({ type: 'Literal', value: new RegExp('///') });\n'/////'\n```\n\nPing @Constellation.\n. Wow, looks like a v8 bug. The note in ES5 \u00a715.10.6.4 states\n\nNOTE The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp object with the same behaviour as this object.\n\nBut that's not the case:\n``` js\n\n/\\/\\/\\//.toString()\n'/\\/\\/\\//'\nnew RegExp('///').toString()\n'/////'\n```\n\nedit: found the bug: https://code.google.com/p/v8/issues/detail?id=956\n. @Constellation: You are the best!\n. It's a bug.\n. I use it for all of my projects, and if you're using commonjs-everywhere, you are already using it. For docs, see bin/coffee --help. The CLI had to change because it exposes each IR and emphasises use of stdin/stdout for I/O. For an example Makefile for a project that uses this compiler, see the michaelficarra/coffeescript-project Makefile.\n. @marchaefner: that is a relic from browserify days. With commonjs-everywhere, I can just alias src/run.coffee to /dev/null.\n@epidemian: believe it or not, windows is a POSIX compliant OS. edit: Apparently, not since NT 4. That shows how long it's been since I've looked at Windows...\n. @Nami-Doc: maybe this would work better? https://github.com/int3/closure-interpreter/blob/48ce8e7284b57fb376150073d4c36585511ec354/Makefile#L3-L4\n. Fixed by #218.\n. Sorry about the failing travis build by the way. The REPL tests are failing in node 0.8 and I can't figure out why.\n. Yeah, there's still a bunch of commented ones that probably don't need to be commented anymore.\n@Avenger7x: Can you squash and force-push?\n. I rebuilt and rebased for you. Committed as 8e753e3e897e827804c990cee8c3258167aef373. Thanks for the bug report and pull request.\n. Merged as 37a7cefc74438114022242c067a7f883919208e5. Thanks.\n. @marchaefner: I can't seem to create a failing test case. My tests along with http://es5.github.io/#x12.14 indicate that the existence of a finally pretty much implies an empty catch.\nNever mind, I was wrong.\n. @marchaefner: Thanks for the persistence. I think I've fixed it with 8ec74fd4e684d3404527694d7ef30d299134ac0f. Can you try that out for me?\n. @marchaefner: A dangling finally doesn't have any observable effects. It's dead code and should be eliminated.\n. @marchaefner: try does imply an empty catch unless it is explicitly specified (and in CS 1.x, unless a finally is given, which is an inconsistency that must be a bug). So only the empty finally body needed to be eliminated, which it was.\n. Alright, that's plausible, though I would say unlikely. I'd like to hear the opinion/wisdom of @jashkenas, @Nami-Doc, or @satyr on this.\n. @Nami-Doc: We all agree on that. The question is whether a try-finally implies an empty catch (as it does without a finally) or whether it specifies that the catch is omitted. I personally think it's a bug that adding a finally would cause the catch in the output to be removed.\n. Okay, re-closing until someone else makes noise about this. I think we've fixed what was a bug in jashkenas/coffee-script. I'll document it along with the other intentional deviations from jashkenas/coffee-script on the wiki.\n. @jashkenas: Were we wrong here to change this behaviour? I try to never write code like the above (mutation and complex control flow, blech), but it seems some people would find use in catch-less try-finally constructs. I think that we might want to err on the side of caution and revert the behaviour back to how it was.\n. Okay, after looking into this deeper, I see where the mistake was made. When @jphaas resurrected this thread, he had missed the fact that a catch is only implied for empty finally blocks. And since it was 6 months since we had last discussed this issue, I had missed it, too. I've changed the wording of the wiki page to make it clear that this is only a very specific, rare case. Closing #274, as this is definitely a bug fix.\n. I've locked mozilla/source-map at v0.1.11 for now to fix this. Something in this diff broke the source position lookup: https://github.com/mozilla/source-map/compare/00d5b8f4...5cdb2633\n. See https://github.com/mozilla/source-map/pull/71\n. Yep, @Nami-Doc is right.\n. To truly match CS 1.x behaviour, we would need to return the result of calling the super constructor, but that would result in the very unexpected\ncoffee\nnew Subclass not instanceof Subclass\nI thought we had that behaviour a while ago and removed it. I'll do some research.\n. See jashkenas/coffee-script#1970 where we make sure that the return value of external constructors is returned from generated constructors. The fix for that happened to satisfy the request in jashkenas/coffee-script#2111, but I don't think we ever actually decided to have that functionality. It definitely seems like an error to me, even though I would expect new Subclass not instanceof Subclass to to be true in some cases, like the external constructor from jashkenas/coffee-script#1970 and of course constructors that explicitly return other objects. Leaving things as they are for now.\nedit: https://github.com/jashkenas/coffee-script/issues/2596#issuecomment-9780945 is a much better resource. Take a look at that. This is definitely a bugfix.\n. Thanks for the report. I will look into fixing this tomorrow. Here's my test cases:\n``` diff\ndiff --git i/test/classes.coffee w/test/classes.coffee\nindex 56fd2543..545c0ae1 100644\n--- i/test/classes.coffee\n+++ w/test/classes.coffee\n@@ -670,3 +670,12 @@ suite 'Classes', ->\n           b: nonceB\n       eq nonceA, A.prop.a\n       eq nonceB, A.prop.b\n+\n+    test '#205: implicit objects should not consume following prototype assignments', ->\n+      class A\n+        a: b: 0\n+        c: 1\n+      ok 'a' of A.prototype\n+      ok 'b' of A::a\n+      ok 'b' not of A.prototype\n+      ok 'c' of A.prototype\ndiff --git i/test/function-invocation.coffee w/test/function-invocation.coffee\nindex 587a450c..2c966e35 100644\n--- i/test/function-invocation.coffee\n+++ w/test/function-invocation.coffee\n@@ -479,3 +479,11 @@ suite 'Function Invocation', ->\n       a: 0\n     eq nonce, f? 0,\n       a: 1\n+\n+  test '#205: implicit objects on the same line should not consume following key-value pairs', ->\n+    fn = (o) ->\n+      ok 'a' of o\n+      ok 'b' not of o\n+    fn a: 0\n+    b: 1\n+    0\n``\n. Agreed. See https://github.com/michaelficarra/commonjs-everywhere/issues/68.\n. The line continuations with` is a duplicate of #20.\nThe semicolon is being treated as a sequence operator internally in CSR, as it should have been in the original compiler. The only difference should be trailing semicolons in files. Semicolons were never meant to be stuck on the end of every line. Are you suggesting we shouldn't allow newlines to follow semicolons? I would be for that, but it may make some people unhappy. Though I guess it'd only affect those stick-a-semicolon-at-the-end-of-every-line-for-no-semantic-reason people.\n. @epidemian:\n\nIs this by design or is it a bug?\n\nI doubt the original compiler's precedence was by design. A lot of the precedence rules seem to have occurred simply by accident, and only the most egregious mistakes were later corrected. Try searching for \"precedence\" in the issues.\nImplementing the same precedence rules in CSR was entirely by design. I wish we could change them now. Function application needs to be above infix operators.\n. @epidemian: Sorry, I wasn't trying to derail the issue, just lamenting. The CSR compilation of your examples is the same as jashkenas/coffee-script. Are you saying postfix and prefix if should have the same precedence relative to ;? I don't see why that would be expected.\n. > CSR is not really going to be CoffeeScript at all, but rather just another opinionated fork like all the other CS variants\nNot even close. Only the most underspecified and edge-case features have been changed/corrected (depending on your opinion of the change). I'll try to get together an exhaustive list of differences on the wiki soon.\nRegarding the trailing semicolons: you've read the previous issues and are familiar with my stance on the issue. Let me remind you that the vim-coffee-script syntax file highlights trailing/unnecessary semicolons as errors. It did not do this without reason. Unnecessary semicolons have always been highly discouraged, to the point of being considered errors.\n. > At one point I also saw a difference of interpretation of whitespace removal in multi-line strings between CS and CS\nYeah, sorry about that. That bug re-appeared a couple of times due to insufficient tests. Single- and double-quoted strings, single- and double-quoted heredocs, and strings with interpolations all have distinct parse rules, so the bug kept getting half-fixed. It should be all good now.\n. @pjeby: See https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script. It's obviously not yet exhaustive, but it's a start.\n. Ha, whoops. Thanks. Fix coming right up.\n. I guess we can do a feature test for require.extensions support. I'll fix this right now.\n. There is one: https://github.com/evanw/node-source-map-support. I'll make the change you requested.\n. Ah, yes, I forgot to implement this. Probably related: #178. Pull requests are welcome. I can probably get to this and #178 within the next couple of weeks. It shouldn't be very hard.\n. This may be a duplicate, but I don't see one right now. Pretty sure this is something we should correct.\n. Nice. Thanks, @jiyinyiyong. Closing in favour of #83.\n. If we can do it the way I'm thinking, this should be pretty easy. Unfortunately, it'll probably be at least 2 weeks before I'll have the chance to try it out.\n. @Nami-Doc: it it just the globbing in the Makefile that fails on Windows? Send over a pull request if it's simple. Let's continue this in #194.\n. Merged. Thanks :-)\n. This is not something that can be fixed. That error is meaningful. There's no tokenisation step. jashkenas/coffee-script's parser operates on a token stream. When it sees an unexpected token, it marks that token with an error. My PEG operates on the character stream. So the first character that is unacceptable in that position will be marked as erroneous. I think you just have to change how you interpret the messages. They're just as descriptive.\n. Thanks for the awesome bug report. Marking as bug.\n. Thanks for the report, @goffrie. I've fixed the issue you mentioned. Regarding the member accesses being stripped: it has been a long-standing CoffeeScript policy to ignore the existence of getters/setters. The compilers (both of them) will often generate code that may break or behave unexpectedly if getters/setters are used. There's nothing we can do to statically determine if they're being used, so we always assume that you are not using such mis-features.\n. Ugh, yeah, this was a pain in the ass when we fixed it in jashkenas/coffee-script. I'll look for the issue.\n. Just use the SHA.\n. Unnecessarily indented member accesses are not yet supported. This is a duplicate of some issue, but I can't find it right now.\n. Sure. I can start you off. It's going to require some fancy trickery here: https://github.com/michaelficarra/CoffeeScriptRedux/blob/a7448ea26e6887000d828af595e9c3b693fec4ef/src/grammar.pegjs#L594-L625\n. Duplicate of #63.\n. Unfortunately, we're redeclaring gensym-ed params. It doesn't break anything, but it's still a bug. I'm looking into it.\n. @Nami-Doc: That's basically what I was proposing. What don't you like about it?\n. @erisdiscord: Yep, just press ctrl-v.\nDoes anyone else have an opinion on this? I can drop it if it's unfavourable.\n. Alright, done.\n. And interestingly\n$ bin/coffee --js --no-optimise < test.coffee\n// Generated by CoffeeScript 2.0.0-beta7-dev\nanObject.someProp;\n. @erisdiscord: thanks for answering this.\nClosing as wontfix.\n. Re-opening. I'd like to add a parser rule at the end of blocks to look for a semicolon first. If it sees one, it should immediately throw an error. Thanks for that recommendation, @ulikoehler, and sorry for taking so long to get back to you.\n. Wow, I wasn't even aware of this. I need this all the time and usually just use this hack. This is great, I will add it.\n. Maybe it should be split up this way:\ngit clone git://github.com/michaelficarra/CoffeeScriptRedux.git && cd CoffeeScriptRedux && npm install\nmake clean && git checkout -- lib && make -j build && make test\nThat breaks it into a setup step and an iterative development step.\n. Merged as https://github.com/michaelficarra/CoffeeScriptRedux/commit/b886c15f80f1e6985a13daea7bcad63119e78686\n. That's a good question. These tests were pretty much ripped straight from jashkenas/coffee-script, so any errors in these probably also apply there. I will look into it soon. Feel free to send a PR if you think you fully understand it.\n. The CLI has changed. Read https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script and bin/coffee --help.\n. Fixed by #318.\n. Wow, this is interesting. I can reproduce your result (though only with data[3]/ 4 spacing, none of the others), but this test passes.\n``` coffee\ntest '#242: variously spaced divisions should all work', ->\n  nonce = 242\n  p = 1\n  o = {1: nonce}\neq nonce, (o[1]/1)\n  eq nonce, (o[p]/1)\n  eq nonce, (o[1]/p)\n  eq nonce, (o[p]/p)\neq nonce, (o[1] /1)\n  eq nonce, (o[p] /1)\n  eq nonce, (o[1] /p)\n  eq nonce, (o[p] /p)\neq nonce, (o[1]/ 1)\n  eq nonce, (o[p]/ 1)\n  eq nonce, (o[1]/ p)\n  eq nonce, (o[p]/ p)\neq nonce, (o[1] / 1)\n  eq nonce, (o[p] / 1)\n  eq nonce, (o[1] / p)\n  eq nonce, (o[p] / p)\n```\nStill investigating...\n. Why would you need this information at run time?\n. It would not fail to compile using jashkenas/coffee-script, just cause a ReferenceError at runtime. You should be compiling your CS to JS for production. And the JS should have no idea what compiler version was used. I am not convinced.\n. Okay, I've come around. But this implementation is not acceptable. I'll fix this with an alternative implementation.\n. @xixixao: There are some issues with jashkenas/coffee-script that will be incredibly hard to fix because of the compiler's design. The remaining issues here will just take a bit of time to implement. super will probably take me 10-15 hours. Stepped loops can be done in under 4. There's only one issue (splices on LHS of assignment) that has exposed a design flaw in this compiler.\nThis project is just not as interesting for me right now as some of the other projects I'm working on. I have a lot of really cool stuff coming out soon. I use this compiler pretty much every day and fix bugs immediately as I come upon them. I don't know why many other people aren't motivated to contribute to OSS projects.\n. @antonkulaga: I recently negotiated 10% time to work on outstanding OSS issues for Groupon. I'll be prioritising work on CSR, especially these two issues, starting 2014.\n. Fine, it doesn't hurt anything.\n. http://michaelficarra.github.io/CoffeeScriptRedux/#try:new%20this\n. https://github.com/michaelficarra/CoffeeScriptRedux/commit/31ad76fb372de484fe7fee46381b43558a7a79eb\n. Two bugs in one! Thanks. Can you file the failure to compile billingRecords[0]?.default = true as a separate issue?\n. Sure, we can do this.\n. Don't use comments, just omit them. The comments are pretty, and I once suggested the same thing for jashkenas/coffee-script, but it's just not consistent with what we do elsewhere.\n. From bin/coffee --help:\n--raw                   preserve source position and raw parse information\n. Aww, you beat me to it. I was looking forward to tackling this one. Unfortunately, I'll have to see some tests before I can merge this.\n. Also, please commit the generated parser.\n. LGTM. Squash and I'll merge.\n. Merging. Thanks for the contribution.\n. This is actually mentioned already.\n\nAnother change to note comes from fixing #1601, which proposed removing postfix :: and standalone @.\n\nWhat you have written is (a::)::b. The LHS of that :: uses a production that is no longer allowed.\n. Glad to hear.\n. Looks like JavaScriptCore can't even parse regexps right:\n\nIt doesn't allow unescaped / within character classes. If we wanted to fix this, we'd have to change Constellation/escodegen to work around this bug. I'll open an issue over there and see what Yusuke wants to do about it.\n. See https://github.com/Constellation/esmangle/issues/95.\n. See https://github.com/michaelficarra/CoffeeScriptRedux/commit/31ad76fb372de484fe7fee46381b43558a7a79eb, #247, https://github.com/michaelficarra/CoffeeScriptRedux/commit/b7b1a0d43649b8b95a013ab4bcc2e30b545494fa, and finally https://github.com/michaelficarra/CoffeeScriptRedux/commit/31ad76fb372de484fe7fee46381b43558a7a79eb#commitcomment-4176759. The next release will have standalone @ again, but do not use standalone @.\n. @mark-hahn: Stop trolling. It was removed for a short while, but added back solely for compatibility with legacy code. It is still officially discouraged, but not an incompatibility. If you're going to participate, please read the full conversation first.\n. I will update the wiki.\n. Nice catch. This is going to be an interesting one...\n. Yep, I was thinking the same thing. The parameter needs to be deleted in order to have the expected function length. Shouldn't be awful.\n. This is one of the intentional CLI deviations that is referred to in the wiki. Quoting:\n\nIntentional interface changes will not be listed here, as the command line and module interfaces have been drastically changed. It was never a goal of this project to have compatible interfaces suitable for drop-in replacement.\n\nWhat you want to do is pass arguments to the script after --, similar to git-checkout and many, many other command line tools. Try coffee myfile.coffee -- -v. Let me know if you have any problems with that.\nedit: Actually, I've just noticed a bug related to this. Fix coming soon.\n. @Alaneor: It's to allow this: coffee yourProgram.coffee --bare -- --bare. You need to be explicit about which flags are intended for the compiler and which are intended for your program.\n. @Alaneor: Ah, yes. I also wanted the flexibility to specify arguments in any order.\n. @alsotang: I don't really think this is a good idea. You're inevitably going to be stale. I don't think many people would think the benefit of writing fewer characters is worth falling behind. I won't officially endorse this, but feel free to continue keeping it up to date.\n. Ask the npm authors to add package aliases then.\n. We should probably just be setting the sourceRoot value.\n. The dedented comma style that is typically discouraged is not yet supported. See related issue #232. Also, it's interesting that the leading whitespace in the error message seems to have disappeared.\n. I would give the object a name.\n. We'll reserve import/export once they're reserved in a final version of the ECMA-262 spec.\n. CSR doesn't currently support stepped loops of any kind.\n. Looks great :-)\n. Wow, thanks.\n. Looks like the build failed. Can you either pend those failing REPL tests or disable them for node <= 0.8?\n. See https://github.com/jashkenas/coffee-script/pull/2824 for an example. I say we just pend them, though.\n. Can you unpend the tests that failed due to #288? After that, I will merge.\n. edit Stupid mobile website...\nThanks. Merging.\n. Fixed by #295.\n. Merged as b07f8184ae386e8eea094e5a29f22faabf44591b with some modifications in af87ba5ecbd3eb4be2c7fe1eeeb113bb92d81a4c and 72f1521a0ba767971d9cf88d74b08fc0156a44b2.\n. Hmm, I just removed this a few days ago: https://github.com/michaelficarra/CoffeeScriptRedux/commit/2b9160704a2a471766a01b1b137c46a8426e3a64\nIt worked for me. What commonjs-everywhere version do you have installed?\n. > fatal: unable to connect to github.com\nIt's on your side.\n. Since this example is better isolated, I'm going to close the earlier issue as a duplicate of this one.\n. I believe I saw a pegjs thread on returning partial trees on failure (though it could be done manually in each parse rule without support from pegjs), but I can't find it right now. This would be a lot of work, whichever strategy was chosen, but I'd be open to a PR if someone wants to take it on.\n. Github was probably down. Try again. Either way, it's not anything I can fix for you. Closing.\n. Yes, it must be supported for compatibility. I just haven't prioritised fixing it because I recommend against using this style.\n. It will, @slang800.\n. This is fixed on master.\njs\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvoid function () {\n  Foo = function () {\n    function Foo() {\n      this.args = [];\n    }\n    Foo.prototype.act = function () {\n      this.args = arguments.length > 0 ? [].slice.call(arguments, 0) : [];\n    };\n    return Foo;\n  }();\n}.call(this);\n. No, this is not intentional. It appears named destructuring does not allow newlines to be used as separators, unlike object literals. This should be an easy fix.\n. Backticks weren't removed, they just aren't able to introduce invalid syntax, such as {. And your conclusion was correct: we don't acknowledge side-effecting getters. It is a deplorable design.\n. Side-effecting getters.\n. Thanks for the PR, but there's a lot of work still needed here and, more importantly, I am still not sure of the future of super in CoffeeScript to begin with. Many, including myself, have been petitioning the other maintainers for adoption of ES6 semantics.\n. Sure. I'd merge a PR that achieves that. We need all those tests I mentioned in place first, though.\n. Duplicate of #63. The workaround I'd recommend is naming your function.\n. Yes. Except meaningful names would be better. \n. Wow, this is great! I've been struggling with this one for a while. Merging as soon as the travis build finishes.\n. Thanks, this is great progress.\n\nLooks like the the Travis build fails on Node 0.11\u2014sigh\u2014do you understand why?\n\nDon't worry about it. It's currently broken due to https://github.com/michaelficarra/CoffeeScriptRedux/issues/319\n\ncommon bug that bit me was [...]\n\njashkenas/coffeescript interface takes an options object as its second parameter, which may have a locals member (called inScope in CSR because we don't strive for interface parity) that lists names that should be considered already in scope. Ask the plugin maintainer to start using that.\n. I don't think so. helpers is something that needs to be mutated (or threaded through return values monadically), right? inScope and ancestry are entirely informational. They are built up in the traversal. Rules do not mutate them or pass out new values for them.\n. Yeah, it's a shitty one. You can keep the state in the Compiler instance and mutate it there instead of threading it through the compilation rules. It's cleaner. Unfortunately, JavaScript/CoffeeScript do not allow for very powerful abstraction.\n. Fixed by https://github.com/michaelficarra/CoffeeScriptRedux/commit/5272d3c9c3f17f62c23663a5c7c92bf2c87e9c02.\n. Ah I see, the test is not changed for negative step loops. Okay, I understand now.\n. cs2js does not take the same options as compile.\n. Nope. This compiler does not extend the CoffeeScript language.\n. It's very strange that we get the raw value correct but the range incorrect. Especially since we're just using PEG.js's line, column, and offset functions. Unfortunately, this is in one of the hairier parts of the code (read: there's a nasty hack to skip counting of context-free-CoffeeScript control characters).\n. Ah yes, now I remember. We fixed that issue in #117 (https://github.com/michaelficarra/CoffeeScriptRedux/commit/1f314eb80ff2393bc9508dd1f66205ad33ba6c3d) (though, using an extremely hacky approach). I would not be surprised if it broke when upgrading PEGjs, if not for the fact that we do have tests for it. I still can't think of a better way to solve this problem than the hack from #117.\n. Oh you're right, I didn't notice it only fixed line/column but not offset.\nYour commit looks awesome! Would we be able to also get rid of that nasty hack in the parser?\nedit: In case it wasn't clear, I mean integrating that lookup table in the CSR parser and getting rid of the overridden PEGjs function hack.\n. Not from any official sources, that's where. Anyone is free to work on this project. I stopped working on it after a disagreement between myself and the other CoffeeScript maintainers (long after this project's sponsored time period was over). I don't see a future for the CoffeeScript language without adoption of ES6 features. Unfortunately, I was the only one that believed we should adopt the semantics of any equivalent features in ES6: classes, default parameters, destructuring, comprehensions (while they were still ES6 track), etc. So because I no longer use the language for my own projects, I am not motivated to work on it. But there's nothing stopping anyone from opening issues and sending PRs. The vast majority of users are just unwilling to contribute.\n. :heart: @lydell. Thanks for all you've been doing with these projects lately.\n. @dynamix: I've been using ES6 for work JS (compiled to ES5 through 6to5) and PureScript for fun.\n. Thanks.\n. @devinrhode2: \"passing through\" breaks the abstraction, and is not how this compiler works. It is a structural transformation, not a text-based one. Sure, we could easily add support for import/export declarations, but the implementation would probably not look like what you're thinking.\n. @rattrayalex Check out PureScript. It is awesome and meets your requirements.\n. I'm aware: https://github.com/michaelficarra/CoffeeScriptRedux/issues/319\n. I don't understand why the line number was incorrect before. Is there not a simpler way we can fix this? Obviously there's a bug somewhere if it's reporting an error on line 1 for that program.\n. We have to remember that we're doing quite a few hacky things to try to get context sensitivity. It could have something to do with either our preprocessor-inserted context markers or the pegcoffee plugin/variant of pegjs we're using.\n. I like this PR a lot. I am willing to merge it in. @ef4: Can you rebase?\n. We should fix the accidentally missing raw field.\n. :heart:\n. Please rebase.\n. Thanks!\n. Wow, thanks.\n. See #336.\n. Nice! Thank you.\n. Yeah, unfortunately this hack is the most fragile part of the compiler (see the comment above). Thanks for fixing it. I wish we had a better way.\n. Is this just in recent versions of node? Have you tested whether 0.12 is affected? Do other stack traces work properly? Have you caught the error and inspected the stack yourself instead of allowing node to print it?\n. Done.\n. What is the -r flag supposed to do? I don't think that's a flag in our CLI.\n. This project's CLI is not compatible with that one's.\n. No, it compiles the same language. The CLI, REPL, etc. are separate.\n. Duplicate of #336.\n. Sorry Gerald, I already updated it. Looks like Adam responded before I noticed this patch. Closing.\n. I've already fixed this locally, so it'll actually be easier for me to just close this. Thanks anyway.\n. > Michael would probably make classes automatically add this property in the future because displayName is going to be standardized.\nThat was exactly my thinking. Closing.\n. related: https://github.com/jashkenas/coffee-script/compare/2a56f0c...5d7a834.diff\n. @franc: because the grammar isn't a JS file, it's a PEG.js grammar, which has embedded JS snippets. I want those to be CS.\n. @Dignifiedquire: Definitely!\n. @Dignifiedquire: Always use interpolation for string concatentaiton. The + operator in CoffeeScript should only be used for summation.\n@renekooi: Matches on other rules produce the value returned in that rule's action. That could be a number.\n. The space is in the variable. I was using ws to stand for \"whitespace (characters)\".\n. No, it shouldn't be. I don't think we're taking advantage of any of the features that have any compatibility issues between the two compilers within the parser. The main ones are super, splicing, and indentation strictness. See this wiki page for more info.\n. This seems to have worked itself out at some point. Whew. Closing.\n. Resolved. Turns out you need to explicitly tell PEG.js to generate a memoising parser.\n. Actually, I got rid of that task this morning. Hold on, I'll push it.\n. Remember to quote them to account for files with spaces in the name.\n. Merged, thanks.\n. Same reason the official compiler commits its compiled source. This will soon be self-hosted, and the built files will be required to do any development on the compiler.\n. How do you feel about making this a git checkout lib? That's probably a more appropriate \"clean\", no?\n. You may want to check out the implementation of the optimiser (don't worry, it is very readable). Skip to the bottom. It can be supplied with additional, user-defined rules at compile time. The same will be possible with the compiler (CS AST to JS AST transformation).\n. Is there any reason why %s is quoted?\n. > The aim here was not to port all of command\nThat's far from what I did. This is a completely new CLI for a CoffeeScript compiler.\n\nRunning bin/coffee just sits\n\nIt's waiting for input on stdin by default.\n\nCan you pass it a file to work against?\n\nYes. Use -i to pass it a filename. bin/coffee -pi inputFileName\n. @josher19: I don't believe I'll be able to make use of that in either the preprocessor or the parser since they both need to work in the browser environment. I'll have to do a bunch of /\\r?\\n/ in the preprocessor and \"\\r\"? \"\\n\" in the parser.\n. @josher19: But line terminators are not insignificant whitespace.\n. Ah, that's a good idea.\n. Yes, @josher19's idea should work. I will try implementing it today.\n. Not yet, sorry. I will get to it soon. It is toward the top of my TODO list.\n. @brian428: c01df938f9897920d8f2a9b3b697dd3e578d0f62 should add support for windows line endings. Give that a try and let me know if it works for you. Sorry it took so long.\n. Fixed by cf0ac2583a9496db104162991bee363fc934daed and a few other, related commits.\n. Thanks for the tests. There's currently a bug with the preprocessor distinguishing between division and regexps. I'll look into it tomorrow and pull this when it's fixed.\n. @mattparlane: After the last few commits, your tests should pass. Do you mind adding a few more that test nested interpolations before I pull this?\n. Merged. Thanks for the beautiful tests.\n. I'm going to side with the decision in jashkenas/coffee-script#1820 for now, but I'm willing to revisit it later.\n. I'm sure you see the problem here, though. Since -h isn't a valid flag, the program is treating it as a filename because there is no ambiguity. Still, people will usually specify filenames that begin with - after the -- parameter so they know they won't ever conflict. It's tough. I think I'll do as you suggest and error on these parameters.\n. Sorry about the unexpected \"%uEFEF\". The test harness doesn't yet know how to properly format and display errors regarding indentation. I figured it was really low priority.\n. I'm going to have to defer to the numerous jashkenas/coffee-script issues on this, most recently jashkenas/coffee-script#1165. Features not already included in jashkenas/coffee-script will not be supported by this compiler. This compiler is meant to be a compiler for the language that the collaborators on that project have designed.\nI am interested in extending the CoffeeScript language in my project \"coffee-of-my-dreams\", but I am not a fan of getters/setters for many of the reasons listed in jashkenas/coffee-script#1165, so I don't believe I'll be adding them to the coffee-of-my-dreams language, either.\n. d8d1d210f93f284a6dced17275dcafdb983dfbdb\n. Representing comments in the AST is not a priority, but it is still a feature that would be nice to have. I may implement this at some point in the future, but it is much more likely to get in if someone else implements it and sends a pull request.\n. A strategy I would start with: change the TERM rule to allow an optional single-line comment before the terminator, then have that rule side-effect, adding the comment to a global list of comments. On every node creation, call some function like addComments that adds comment markers to the nodes if the global list contains any comments, then clears the list and returns the node.\nedit: Also, I'm currently omitting comments in the preprocessed code. You'll have to just change that to emit them instead.\n. Feel free.\n. > Trouble is, however, that the next node created after the comment is found != the correct node.\nOh, of course. I forgot about that. Sorry about the bad recommendation.\n\nI am now thinking of other approaches; maybe changing the grammar to support block comments as separate entities\n\nThat's always been a possibility, but the unfortunate consequence is that we'd have an optional comment in front of EVERY rule. Still, it could be the cleanest approach if we can't find anything better.\nRight now, I don't have any better ideas. I'll continue to think about it. Thanks for taking a look at this.\n. I'll be starting to preserve them through the optimisation and compilation transformations this week. So, soon but not quite yet. Try again in a week or two.\n. @TobiaszCudnik: Source map support is completed. See constellation/escodegen#50.\n. @mark-hahn: Just use the --source-map option to generate the source map that's associated with the JS generated by the --js option.\nbin/coffee --js -i sourceFile.coffee > outFile.js\nbin/coffee --source-map -i sourceFile.coffee > outFile.js.map\nThen, depending on the tool you're using, you may need to add a comment to the bottom of the JS file:\n(echo; echo '//@ sourceMappingURL=outFile.js.map') >> outfile.js\n. @Nami-Doc: Nope. One step at a time.\n. This seems like a failing of the escodegen project. It is attempting to require the source-map module, but it is not in its dependencies, since it's an optional dependency. Maybe it should try/catch the require and notify the user of this.\nPing @Constellation.\n@rpflorence: For now, you can just npm install source-map in this project's directory.\n. Looking through the npm documentation, the best option I've found is optionalDependencies in the package.json. It's not ideal, since it will unconditionally install the dependency, but at least it's marked as optional.\n. Also related: isaacs/npm@3bf7d2f7b34a1fdc15e4e7c58360c56157da5f70 . So I would change the installation instructions to recommend the --no-optional flag.\n. I have no plans. If you'd like to come up with a proposal, I'd be glad to take a look at it, but I have no incentive to create anything like that right now.\n. @delaaxe: Yep, I've done something similar in the current source-mapping pach I'm working on. Feel safe making use of those line numbers, since they'll be official soon enough.\n. > /Users/rpflo/Code/github/clones/CoffeeScriptRedux/node_modules/mocha/\nLooks like mocha isn't installing the required modules. For now, cd node_modules/mocha; npm install. If that doesn't fix it, cd node_modules/mocha; npm install commander.\nmake deps should have worked. Are you using the latest commit?\n. @rpflorence: I just set up the project on a clean machine, and the only problem I had was with today's recent update of pegjs. I've pushed ab4dec298b3a072b4245fab4d3424edae691bb56 to fix that. I'm going to close this since I can't reproduce your problem.\n. @StanAngeloff: Thanks for playing with it and reporting this bug.\n@Constellation: That's exactly right. Fix coming soon.\n. @StanAngeloff: I noticed that you're passing --optimise explicitly. Just so you know, that defaults to on. The option is there mainly so you can turn it off with --no-optimise (especially since it's not perfect yet).\n. It doesn't lock up, it's waiting for input on stdin. I tried to keep the same interface as the old compiler, but it simply wasn't sufficiently flexible. So I had to change it. You're probably looking to do coffee --js < ~/somefile.coffee.\nLike instructed in the README, use coffee --help to fully understand the interface.\n. Oh, I guess it's called StringScanner. Thanks for the heads up. Fix coming.\n. cscodegen isn't published yet, either. That's okay, I don't recommend using npm install. For now, people should be using make deps, as listed in the README. Come release time, all the packages should be available, and I will make use of npm install.\n. Fixed by 333f2a642951b4b3126fa763e344adb4ecc53700\n. > You're quick!\nRemember, this is my job right now. If I wasn't paying attention to my users, how could I justify accepting their money?\n. related, untested commit: dfe5782d3b3808b54d6176533e28ef7fd0e4e4ba\n. Browserify is working pretty well for me. I only have two issues: I can't get it to automatically export CoffeeScript (probably an option I'm missing), and I can't get it to automatically ignore /lib/coffee-script/run.js, which is needed to ignore the unsupported native module module. Currently, building the browser version requires manually deleting the require('./run') line in /lib/coffee-script/module.js and manually adding var CoffeeScript = ... to the output. I'm working on fixing these minor issues.\n. These issues are both known. The first issue is that I simply haven't yet added support for block comments, since they provide no functionality, and are an extremely low priority for me right now. Just replace them with single-line comments, which are ignored. I'll get to them when other real problems have been taken care of.\nThe second issue is one I'm currently debating over how to solve, so I'm glad you've brought it up publicly. Really, you shouldn't be allowed to perform an assignment within a higher-precedence operation like a do expression. I've been running examples through that contain expressions like a and b or c = d, and though it is currently accepted by the current overly-permissive compiler, I think it should produce an error because it just doesn't make sense. With the correct operator precedence, that expression would be disambiguated as ((a and b) or c) = d. Doesn't look so good any more now. Likewise, the example you provided is (in my mind, correctly) being parsed as (do doOneDir) =  -> ..., which is invalid. @jashkenas: what do you think about this?\n. @mark-hahn:\n\nI was really hoping redux would be backwards compatible\n\nThat's the goal, but the compatibility is with the CoffeeScript features as we intended them to be implemented. For instance, I didn't duplicate any of the bugs in the current compiler, so it's no backwards compatible in that way. But that was always the goal. I'm just not sure if we ever intended to allow people to throw unqualified assignment operations into just about everything.\n@epidemian:\n\nAlso, i sometimes find things like a and b = c to be useful. For example, when i want to cache the result of c, which should only be computed if a is truthly, for later usage.\n\nRemember: this wouldn't be disallowed, you would just need to raise the precedence of the assignment by putting it in parentheses.\n. @GlitchMr: yes\n. See issue #19. This is an open issue. Once you get your indentation inconsistencies sorted out, debugging should be quite nice. Make sure you're not alternating between tabs/spaces and if you're using spaces make sure the same number of spaces are used for indentation everywhere.\n. After looking into this syntax, I've come to the conclusion that this was not an intentional feature. At the end of a function call, an implicit object may be given on the next line, specifying that it is to be used as the last argument. You shouldn't then be able to chain to that result without using parentheses to explicitly specify the target.\nInstead, use\ncoffee\n(($ '<a/>').css\n  color: 'blue'\n  'text-decoration': 'underline'\n).appendTo 'body'\nor\ncoffee\n$('<a/>').css({\n  color: 'blue'\n  'text-decoration': 'underline'\n}).appendTo 'body'\nor \ncoffee\n(($ '<a/>').css color: 'blue', 'text-decoration': 'underline').appendTo 'body'\n. @connec: You've got it. I would run screaming from code written like that.\n. @mark-hahn: That is also a concern of mine. I really do not want this compiler to change the CoffeeScript language or break our users' production CoffeeScript code. But there has to be a line we draw between intentional features and quirks. I am not duplicating quirks. The original compiler was very, very permissive, allowing unintentional and inconsistent syntax.\n. I'll be fixing this issue as soon as #112 is finished.\nMessage to self: #79 is outdated, but it has some nice tests for this.\n. @dbrans: see the roadmap, my comment above, and the indented-member-access branch.\n. @meryn: This is already pretty much fixed. I just need to finish up the WIP commit on the indented-member-access branch. I've just been working on more fulfilling OSS projects recently.\n. > Do you think this (CSR dev) is an \"unthankful\" job, or does it not excite you technically anymore?\nNo, not thankless. It's just that the remaining things to do (super, splicing, this issue, a few obscure bugs) just don't ever affect me. Also, they're not particularly challenging. I'm using the compiler without any problems, so it's hard to get motivated.\nWith commonjs-everywhere, I truly feel I've created the best bundler available for modules that conform to the CommonJS spec. Thanks for the suggestion, I will write up a comparison between commonjs-everywhere and similar bundlers. I'm extremely proud of it :smile:.\n. > And yes, if CoffeeScript 1.6 currently supports this, I'd consider this an undesirable thing. It does enforce consistent indentation in other places.\n@meryn: I agree, but it seems a lot of others don't. The CoffeeScript language isn't exactly consistent. It is not designed to be a good language or to be liked by PLT enthusiasts, but instead to be accepted by the masses, who often don't know what's best for them. That's why I started coffee-of-my-dreams.\n. @meryn: Just call him here. Oh @jashkenas, @jashkenas, wherefore art thou, @jashkenas?\n. @meryn: That looks pretty serious. Can you open an issue for that?\n. Working on this one today. Since changing the compilation of statements-used-as-expressions so dramatically will be very difficult, I'm just going to rewrite the gross auto-declaration code, changing it from operating on the generated JS to operating on the CoffeeScript nodes. Not sure how well that's going to work with gensyms, but I'll find out.\n. Yes, that would be an easy way to do it. If this fails, I can do that instead.\n. I did this, but because someone might want to override the CS.Function, CS.BoundFunction, or CS.Class compilation without destroying declaration, I'm going to revert back to auto-declaration and use @Nami-Doc's strategy of skipping IIFEs that are marked as generated. This will allow custom rules to mark their IIFEs as generated when they don't want them to affect scope.\n. Definitely not. See the various issues related to this point in the original repo. Basically, it's either CoffeeScript or it's not CoffeeScript. The compiler won't be supporting different flavours of the language based on compiler flags. If you want to enforce those things, it should be easy to build a tool that utilises the parser and its \"raw\" values.\n. @mark-hahn: There are times when being more explicit can help the reader avoid manually disambiguating things, but that's really only when the programmer thinks it's cool to mix a bunch of implicit syntax. In most cases, it's trivial to disambiguate our implicit syntax, and the additional characters would be, as you say, noise.\n. @epidemian: I prefer that grouping style (and have promoted it many times, in many issues) to the style that appends a parentheses-enclosed argument list to functions. If you look at the source of this compiler, it's used everywhere.\n. Since this discussion is getting way off-topic, I'm going to ask everyone to move this conversation over to IRC or the google group. If you have fully-realised proposals, open an issue on jashkenas/coffee-script.\n. Yep, moving away from make deps (which pretty much just initialises the submodules) has been a goal since it was added. And you've got it exactly right: I haven't been able to do that because I haven't been able to properly reference my patched PEGjs in the package.json. Pull requests would be very welcome here.\nEdit: See #6 for the goal of using CoffeeScript in the PEGjs rules.\n. Because it's the best choice. It most accurately represents our intent. We want to evaluate the given expression and produce no result. The expression is the IIFE.\n. Ah, so that's how you do it. Thank you, @cgarvis.\n. Ugh, I get this error:\nnpm ERR! Error: invalid version: @VERSION\nnpm ERR!     at validVersion (/usr/local/lib/node_modules/npm/node_modules/read-package-json/read-json.js:529:40)\nnpm ERR!     at final (/usr/local/lib/node_modules/npm/node_modules/read-package-json/read-json.js:289:23)\nnpm ERR!     at /usr/local/lib/node_modules/npm/node_modules/read-package-json/read-json.js:119:33\nnpm ERR!     at cb (/usr/local/lib/node_modules/npm/node_modules/slide/lib/async-map.js:48:11)\nnpm ERR!     at /usr/local/lib/node_modules/npm/node_modules/read-package-json/read-json.js:241:40\nnpm ERR!     at fs.readFile (fs.js:176:14)\nnpm ERR!     at fs.close (/usr/local/lib/node_modules/npm/node_modules/graceful-fs/graceful-fs.js:92:5)\nnpm ERR!     at Object.oncomplete (fs.js:297:15)\nnpm ERR! If you need help, you may report this log at:\nnpm ERR!     <http://github.com/isaacs/npm/issues>\nnpm ERR! or email it to:\nnpm ERR!     <npm-@googlegroups.com>\nBecause @dmajda has a custom build process that uses a preprocessor to write the version number into the package.json file. I wish he would just fucking pull dmajda/pegjs#95 already...\n. Depends on #52.\n. Fixed by #107.\n. Related issues: Constellation/esmangle#40 and Constellation/esmangle#41\n. It should be easy, actually. You pretty much just need to update the file pointed to above to use my compiler's flags instead of the original's. And remove coffeelint. Then just open a pull request and let it sit until this hits 2.0.\n. coffeelint uses the old compiler, which fails on many perfectly valid constructs. Nested interpolations, for instance.\n. Testing --version sounds like an excellent idea.\n. Make sure it doesn't misidentify 1.2.0.\n. Sorry, I must have recently broken that. Fix and blame coming ASAP.\n. This was broken by a bug in the compiler (fix coming) when we started self-hosting, and went unnoticed until now.\n. @weyert: This should be fixed as of db8b64b3b1f545efa865ec20c96ef2ac0b136c72. Let me know if that doesn't work for you for some reason.\n. That's odd, I can't reproduce this issue.\n. Try running make clean; git checkout lib; make -j test.\n. Whew, good.\n. cscodegen is incomplete. Just ignore that optional dependency for now and don't use the --cscodegen option. If you really want to use its limited capabilities, clone it into node_modules/cscodegen. I will put it in the NPM repo when it's more complete.\n. Yeah, sorry about that. I need to loosen up the whitespace allowances regarding argument lists and member accesses.\n. @euskode: This will be fixed before 2.0, but I'm not working on it just yet. For now, just pull out the function and name it or flip _.delay.\n. @zoz: What is the \"value\" of a throw statement? This is another open question. The current compiler optimises this kind of construct, as well.\nedit: The value is undefined. The optimisation is valid. Fix coming soon.\n. This is intentional. See jashkenas/coffee-script#1275\n. Very interesting. This compiles on its own:\ncoffee\nclass Player extends Mob\n    constructor: (@world, x, y, z, @name) ->\n        @model = 'player'\nCan you post a reproducible test case?\n. Ah, super. See https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Progress. super is one of two features not yet supported.\n. Just forgot to allow the terminator that separates the finally from the catch body. Fix coming soon.\n. That looks good to me. What did you expect?\n. @gregwebs: That failure of the current compiler is a bug, since there's obviously a perfectly valid parse: the one my compiler has identified and used.\nThe eval generation is because we need to represent the inline JS as a node in our output JS AST. We add the requirement that the inline JS must also be a valid JS program. This shouldn't be a concern to anyone that wasn't abusing JS literals in a way that could possibly generate invalid output, such as leaving unmatched braces. I may further restrict it to valid ExpressionStatements. That way, {} will produce an object literal instead of an undefined value, and function a(){} will produce a named function expression rather than an undefined value with an environment mutation. We could do this by producing eval('0,X') or eval('(X)').\n. > using var gives no output\nSorry about that, a JS node was being assumed to have no side effects. The assumption should be the other way around. I will fix this. edit: For now, you can use --no-optimise.\n\nit is convenient for your implementation to wrap the javascript in an eval\n\nYes, but it's also the only way to define proper semantics for the JS literal. If it was allowed to contain arbitrary character data, its semantics would rely on implementation details that could change in the future. The completion value of a javascript program is well-defined, and that will be the value of a JS literal.\n\nI still don't understand how the generated javascript in the second example is supposed to be ok.\n\nMaybe it would help if you looked at the parse tree. I've cut out the source information for clarity.\n$ echo 'f = (`a`) -> a + 5' |  bin/coffee --parse\n{ type: 'Program',\n  body: \n   { type: 'AssignOp',\n     assignee: \n      { type: 'Identifier',\n        data: 'f' },\n     expression: \n      { type: 'FunctionApplication',\n        function: \n         { type: 'JavaScript',\n           data: 'a' },\n        arguments: \n         [ { type: 'Function',\n             parameters: [],\n             body: \n              { type: 'PlusOp',\n                left: \n                 { type: 'Identifier',\n                   data: 'a' },\n                right: \n                 { type: 'Int',\n                   data: 5 } } } ] } } }\n\nwe need to have a JS parser that can take apart the JS\n\nThat was an option that we considered, but it would require us to depend upon a JS parser for a feature that is highly discouraged and completely unnecessary. The tradeoff is not worth it when eval does at runtime what the parser would be doing at compile time.\n\nThis is yet one more CS feature being thrown out in 2.0.\n\nNot thrown out, fixed. It was broken. It allowed the user to provide a program that would cause the compiler to output invalid programs. It didn't have a properly-defined semantics, or any defined semantics at all. That is unacceptable. This has standardised it.\n. @mark-hahn: Preserving the semantics of CoffeeScript was the most important factor influencing development. It is not my intention to change CoffeeScript; I have my own fork for that. I personally disagree with some of the language features I implemented, but I faithfully implemented them. JS literals were always a hack. If they weren't being abused to do something crazy like try to change CoffeeScript semantics (such as with your scoping hack), my implementation should cause no problems. Allowing unparenthesised assignments on the RHS of boolean operators, as in your other issue, was a bug that people were (some intentionally, some unintentionally) abusing. These cases are extraordinary, and not indicative of the support for code you will see in well-written CoffeeScript programs.\n. @gregwebs: would this be more clear?\ncoffee\n(eval 'a') (-> a + 5)\nThis is what you're writing.\n. @epidemian: We have to distinguish parameter lists from functions being passed to parenthesised expressions, we can't disallow it. It's certainly useful, and I would be surprised if it failed:\ncoffee\n(generateAFunction withThisInitialisationValue) ->\n  thenPassThis\n  multilineFunction\n  withNoParameters\n. Cross-referencing: Constellation/escodegen#73\n. See #43. I will likely have to add a special syntax case for the do followed by an assignmentExpression (but nothing of lower precedence, ugh). I'm not sure where the error in the optimiser is originating, but I will likely find it when I go to fix this myself. For now, you can use --no-optimise to disable the optimisation pass entirely.\n. @bpartridge: Awesome. I'm excited to get more eyes on this code. You may find it useful to look through the slides from this presentation I gave: https://speakerdeck.com/u/michaelficarra/p/redesigning-the-coffeescript-compiler\nThis is also a good read (just make sure you read the comments!): http://codebrief.com/2012/08/hacking-the-coffeescript-compiler/\n. Very nice. I was just about to start looking into this. I figured it would be a minor change. Merging.\n. Beautiful. Thanks for following the grammar's style perfectly. We may want to DRY that RHS expression, but this is good for now. Merging.\n. This is expected behaviour. CoffeeScript has a long history of ignoring the existence of getters.\n. Thanks, merging.\n. This doesn't take into account the preservation of the raw value.\n. The extra spacing within the parentheses is not in line with the rest of the grammar's styling.\n1. make that change\n2. git rebase -i\n3. squash everything\n4. git push -f\nThanks for these pulls, they're much appreciated!\n. Hah, sorry, I don't mean to sound like your sergeant. I guess I just have an eye for detail. I will try to get on #coffeescript later today.\n. As you can see, it's merely a JavaScript file with a *nix-specific shebang. I'm not sure how people are expected to use the compiler on Windows; I have little experience with the platform. Try executing it as node bin/coffee --help and see what you get. I wouldn't be able to provide any assistance past there. If that doesn't work, try asking around on the CoffeeScript IRC.\n. Sorry, I must have missed this. The test suite hasn't been 100% ported yet. For now, use a?(b) (with explicit parentheses). Fix coming soon.\n. @nickretallack: fixed by 59a5b667d330da074af19db412418567dd4261cc\n. Fixed by https://github.com/michaelficarra/CoffeeScriptRedux/commit/eb22110d52add5683e68b41cb50e1e835320fed8\n. I hadn't been coercing the operands of ExistsOps to expressions. Fix coming soon.\nedit: grammar\n. @kevinmehall: 19b030300430ec61913b85a9cf01135aba73a749 should fix this. Thanks for the great bug report.\n. Merged. Thanks.\n. Sorry, that feature has been planned for removal and discouraged for over a year now. See jashkenas/coffee-script#1601.\n. Whoops. Looks like I forgot to mark the extends operator as having side effects. It's getting removed by the optimiser. I'll fix this as soon as I get back to my computer. It's a trivial fix.\n. Fixed by 6d6d77111f7dd6fa7836207b6df51a0f7af22525. Sorry for the delay.\n. Thanks for giving me the motivation to knock this one out. I've taken a similar but slightly cleaner approach with my solution in ecd067b2e9b175b9181d2ef235639abf92d354e2.\n. Works for me:\n```\n$ bin/coffee --js\nT =\n    a:1\nb:2\n\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var T;\n  T = {\n    a: 1,\n    b: 2\n  };\n}.call(this);\n$ bin/coffee --js\nclass Animal\n    constructor: (@name) ->\nmove: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var Animal;\n  Animal = function () {\n    function Animal(param$) {\n      this.name = param$;\n    }\n    Animal.prototype.move = function (meters) {\n      return alert(this.name + (' moved ' + meters + 'm.'));\n    };\n    return Animal;\n  }();\n}.call(this);\n$ \n```\n. Yeah, win32 line ending support is lacking. See #18 for that. I'm going to make a commit to make that character more readable. Hang on.\n. @sleytr: I've pushed 0535bc278385df793ed4b31c95cdd12a10d07bf2. Try that and show me your error.\nedit: Looks like your error might be originating in the preprocessor. I'll work on those errors.\n. @evrenesat: You can simply write your example like this:\ncoffee\nT =     \n  foo: ->\n    a = z(4, {\n      'q': 1\n      'w': 2\n    })\n  x: 1\n... or, taking advantage of implicit syntax, like this:\ncoffee\nT =     \n  foo: ->\n    a = z 4,\n      'q': 1\n      'w': 2\n  x: 1\n. This was a decision that had to be made very early on in the project. I could use a PEG to generate a parser with some very desirable properties or use parser combinators to define a parser with other desirable properties (namely, the runtime extensibility you mention). I went with the PEG and its linear-time parsing guarantee when memoised. Compiler/optimiser extensibility were important, so those have very versatile hooks built in. But, unfortunately, if you want to extend the syntax, you're going to need to fork it and modify the grammar.\n. See jashkenas/coffee-script#1952. The decision to change that behaviour must be made there before this compiler could implement it.\n. Yes, I know what the problem is here. You have invalid (inconsistent) indentation somewhere in your file. I'm working on improving the output for this kind of error. It's on the top of my list, but it may not be ready for a few days.\n. Proposals like this should go to jashkenas/coffee-script for the time being. This project is trying to implement only the features of the language as defined in jashkenas/coffee-script. What is the intended behaviour here, anyway? {id: id ? 0, track: track ? 0}?\n. It's not at all that complex. That wouldn't be very extensible. This repo will be out on npm as soon as it hits 2.0.0 stable. Right now, the kinks are still being worked out. I have a few bugs that are showstoppers for a stable release, and more will likely be found in the next few months. That said, you can see some examples of the extensibility of the compiler in this presentation (specifically slides 29-30): https://speakerdeck.com/michaelficarra/redesigning-the-coffeescript-compiler. You can make instances of both the compiler and the optimiser, add rules, and use those instances rather than using the static compile and optimise methods (which just defer to the instance methods of unmodified compiler/optimiser instances).\n. https://github.com/michaelficarra/CoffeeScriptRedux/blob/05026cdc0361124a031e5ac797a334cd98e610ca/src/command.coffee#L366\n. This should be an easy 5 minute fix for anyone looking for a way to contribute.\n. @jrozner: Definitely 5 minutes. See jashkenas/coffee-script#2496.\n. The former. It's a 5 minute fix.\n. Nope, this was fixed by #103.\n. Merged, thanks.\n. Committed b5dc7c7139fb499934baf10e77aa8f6fd30ee361. Thanks.\n. Crap, just realised you didn't include tests. Can you open another pull request with tests?\n. I'd like to see a test where -> debugger compiles successfully to function(){ debugger; }. I believe that's currently an issue. -> return if a then debugger should also compile. Anything else we should add?\n. LGTM. Squash and I'll merge.\n. @ghempton: Thanks, you've reminded me that I forgot to send out the last backer update. Currently, I'm at YOW! in Brisbane, QLD. I think the slides from my talk will give you everything I would have put in the update and then some. The Current Status and Future Work sections will probably be of most interest.\nI'm glad to see everyone still so excited about this project. I am working to get through the open issues and do what I've mentioned in the Future Work section in my free time. Unfortunately, my 4 month full-time funding period is over and I can no longer contribute as much time as I would like. The project can certainly still be considered actively maintained, though, and it is very nearly feature complete.\nI believe comment preservation, super, and array splicing are the only features that remain incomplete. I'd encourage anyone with a comprehensive test suite to start using the compiler now, but don't start a new project using this compiler just yet. I don't want anyone to have a bad experience with a subtle bug, and with a project this young it would be naive to assume that we know about all of them. To make sure I touch upon each of your points, I will answer them more directly below:\n\nJust curious as to what is the state of CSR?\n\nActively maintained, fairly stable, very nearly feature complete.\n\nAre you still planning on actively working on it?\n\nDefinitely. I love this project and have many more things planned for it.\n\nI see that the code is still largely undocumented and sprinkled with TODOs and the roadmap hasn't been updated recently.\n\nYes, that is an unfortunate reality. It is on my TODO list to clean up and document everything.\n\nHow far away from being a true coffee script replacement is the project?\n\nThat's a tough question because it depends on what you're looking for. It works, it supports nearly every feature of the language, and it's a tiny bit stricter regarding whitespace (which could still use tweaking). If that is good for you, you should be good to switch. For very large projects or teams, you should let it harden first like any other integral tool.\n\nDo the issues actively reflect what is left?\n\nTogether with the Future Work section, yes, I believe so.\n\nThe reason I ask is that I am very excited about the project and would like to help in whatever way I can. Thanks!\n\nI will be happy to ping you next time I see something that could be easily contributed. The first thing that comes to mind is porting the REPL over, but we're currently trying to rethink the REPL implementation in jashkenas/coffee-script, so that might not be a good idea. The next thing I could think of would be switching out uglifyjs for esmangle. That should be pretty easy for just about anyone.\n. @surjikal: I'm surprised super is a blocker for you. I didn't think too many people were using it. Maybe you're just one of those that are.\nsuper support is tough mainly because it's hard to define simple, consistent semantics for it. So not only do I have to try to emulate the behaviour that was codified in the original compiler, but also take into account any pending issues with approved changes/enhancements to super. Additionally, I have to consider how super may be changed in the future so that it doesn't require a fundamental redesign later. This involves looking into the changes that have been made to super in forks like LiveScript and Coco.\nSo, in short, it may take a little while. If I were you, I would make the uses of super more explicit anyway by desugaring them. Feel free to help with any part of that development process. I would love for someone to open up an issue and write some nice logic rules surrounding that feature that take into account everything I've mentioned here.\n. @kevinmehall: This branch has fallen behind while I was working on the parser rewrite. Can you rebase off master so I can properly review and merge this?\n. Thank you. I will review this today.\n. Alright, other than those issues, LGTM.\n. @mark-hahn: string interpolation expresses your intent more clearly. You intend to join strings, not do addition. The compilation also makes sure you don't accidentally do addition. JS using the same operator for two different operations was a mistake. Related: DavidBruant/ECMAScript-regrets#22\n. @epidemian: If I wanted it to do array concatenation and vector addition, I would actually define those types as monoid type class instances and use an operation that has type-specific behaviour (Haskell's mappend). Completely agree about the case where + is given a heterogenous set of operands being the root of the issue.\n. Merged, thanks!\n. Fixed by a1033f9951edbcbf22cf7cc8dcfbd573a5769ae2. Related: 2782c9bc25b3a98a2ce85e317f4f8306bd2bbe4e.\n. Duplicate of #20.\n. The semicolon should not be used to terminate an expression, but instead to separate two expressions. The semicolon is the sequence operator in imperative languages. I've considered allowing this special case, but it is so highly discouraged that it's best to just keep the syntax consistent. If you really want to explicitly terminate statements, use ;0 on the final one.\n. This works for me. It appears you've run into #18. For now, try setting your text editor to use \\n as a line terminator or, preferably, change to a UNIX-based operating system.\n. I'm making good progress on this. See the GH-112 branch. I just have to switch out all the binary expression rules with one rule that parses a list of arbitrary binary expressions and then fold them using the precedence table.\n. Hah, I've actually been working on something similar here: https://github.com/michaelficarra/CoffeeScriptRedux/compare/master...update-pegjs\n. Yeah, it's so much cleaner now. I'm also going to add an option that disables raw value preservation (now that that behaviour has been defined in a single place) so the typical user doesn't have to pay a performance cost.\n. See a1033f9951edbcbf22cf7cc8dcfbd573a5769ae2 and 2782c9bc25b3a98a2ce85e317f4f8306bd2bbe4e.\n. @Constellation: I'm having trouble using ibrik. I get errors that appear to originate in my compiler. I would love to start using ibrik's coverage reports to improve the test suite (and finally finish pulling in the original compiler''s tests). Do you mind taking a look at it?\n. Crap, you're right. I didn't run the tests after the recent changes to the parser. Though I don't know how that could expose a place where I forgot to run expr on some expression in the compiler. I'll try to track this down tomorrow. It should be pretty easy: just run each test file separately and then binary search for the problematic source with comments.\n. @jldailey: It was broken for about a day a day ago, but other than that it should build fine and tests should pass. It looks like you don't have /lib at all. /lib, the compiled compiler, is required to compile itself. The compiler is self-hosting. Try git checkout master && git pull origin master && git checkout HEAD lib && make -j build && make test\n. Closing until someone else verifies that they also have this problem.\n. Ah, yes. Now that I have PEGjs storing those properties and not my own code, I no longer filter those out. Thanks for spotting this.\n. I'm going to work on this next. I believe it may be the cause for #200.\n. @Arelius: Why is it desirable to have something like that parse? I would write it like this:\ncofffee\nidentity = ->\n  matrix = [\n    1, 0, 0, 0\n    0, 1, 0, 0\n    0, 0, 1, 0\n    0, 0, 0, 1\n  ]\nAnd that compiles just fine.\n. Sorry for the delayed response, everyone.\n@Arelius:\n\nI was going to continue to work on this, but it seems that you may be strongly against merging this in even if I do finish it. Can you comment on if this is indeed the case?\n\nI'm not strongly against it, but it's nowhere near the top of my priority list. It'd be interesting to see a good implementatoin.\n@alexgorbatchev:\n\nIf i'm not mistaken, in #45 it was decided to not support existing CoffeeScript markup... am I right?\n\nNot at all. It is still a top priority.\n@mlogan:\n\nplease clarify whether backwards compatibility with existing CoffeeScript code is a goal of CoffeeScriptRedux\n\nIt is the most important goal. Unfortunately, defining the language itself is a little bit tricky. There's a grey area where abused bugs meet obscure, discouraged features. I've just been ignoring that area for now while I polish up everything else so that 99% of users are better off. The other 1% that write code like this can wait a little longer until we figure out some consistent, understandable rules that allow these kinds of constructs.\n<rant>It would also help if there was more contribution and less moaning. A lot of people are complaining about these minor inconsistencies but don't contribute an exhaustive list of supported/unsupported cases or derive a consistent set of rules that would allow for the construct they desire. When I shoot down the issues as bugs with the old compiler, all I get in response is a \"but it works with the original compiler!\", not \"it's intentional and here's the rules for determining when you see this case\".\nIn this issue, for example, what's the rule? It would have to be some sort of special case, since the leftmost indentation is inconsistent, something identified as a bug in the original compiler. Also, whitespace within array literals is significant to support arrays that contain functions or implicit objects. This is not Python. But I'm willing to see a more well-defined proposal, even though I'm almost positive this should be categorised as a bug. It's just not proper CoffeeScript code.</rant>\nClosing until someone posts an actual proposal.\n. @mark-hahn: You've got it exactly right.\n. @Arelius: Feel free. But please try to be as detailed as possible, describing the properties of the missing feature or the parsing/identification rules for it. As @alexgorbatchev suggested, plenty of examples in all possible contexts would be a good start.\n. Closing in favour of jashkenas/coffee-script#2598.\n. Note that the extensibility of this compiler stops at parsing. You can change how a particular structure compiles and change its semantics, but you cannot add new syntax. I did not want to encourage people to make hundreds of \"CoffeeScript with small syntactic difference X\" languages.\n. Good catch, I will work on this right now.\n. This is proving more difficult than I thought it would. Analysing the grammar, it appears that this should already parse properly. I will need to investigate in more depth where exactly the parse is failing.\n. Ah, that helps a lot! Thanks.\n. Yeah, that is exceptionally difficult. I've been thinking about it, and the only clean solution I see is something akin to all the NoIn rules in @tolmasky's JavaScript PEG.\n. I'd really rather not have that cluttering up the grammar (and probably ~doubling its size), but it's likely the right thing to do.\n. Yeah, it would be nice to get this set up. I will look into it soon.\n. Merged. Now let's see if I can get it set up over at the Travis CI website.\n. Alright, I believe it's set up now. We'll see how it goes. Thanks for the nudge and the help!\n. Yep, that's a bug in the optimiser. It has no concept of directives, so it just throws them out as dead code. For now, as @delaaxe says, use the --no-optimise flag.\n. @Zearin: Glad you're excited about the project. Right now, I'd say this project is in an early beta. In fact, I'll be tagging it as such and releasing it on npm shortly.\nThe advice I have been giving people is to try it out with already-stable projects that have good test coverage. If your tests are still passing, the compiler is obviously working for you. It's currently a little too strict with its whitespace requirements (so you might need to tidy up a bit), a few minor features haven't been implemented, and I have a few open bugs I'd like to fix before tagging a 2.0 and looking to merge with jashkenas/coffee-script. For brand new projects, stick with the much more time-tested compiler for now unless you absolutely need one of the features only available in my compiler.\nSee the related issue #106 and another related discussion on the Google Group.\nI'll leave this issue open to remind me to add a little note to the README. I need to update documentation anyhow. Thanks for asking!\n. @Ciantic: As I said above, I need to update the README and the wiki. If you need it in short order, please open a pull request.\nedit: @Nami-Doc beat me to it.\n. Of course.\n. Regarding the difficulties surrounding super, see my comments here: https://github.com/michaelficarra/CoffeeScriptRedux/issues/106#issuecomment-11102238\nThat's why it's been delayed for so long. super semantics are effing complicated.\n. @paulmillr:\n\nDevelopment of Redux slowed down much as compared to jun-sep \n\nAn unfortunate side effect from switching from full-time to free-time. I'm still working on it when I can! It's now just split among my contributions to all the other OSS projects I love.\n\ndo you think the project will be ready in the next few months?\n\nDepends on what you mean by ready. For some people and some use cases, it's ready today.\n. @mehcode: Correct. And that will still be a while. It needs a lot of users and time to shake out the bugs. It is still fairly new code, and only time will make us confident that it is \"stable\".\n. @mehcode: That new, fancy REPL is being merged in sometime this week and immediately ported over to here. That's why I've been working on it. I wanted a REPL, but not the somewhat hacky one that's currently there when newer, better hooks exist.\n. @archaeron: A few more things. I want to clear up cross-platform support. No matter how much we want to deny it, some people do actually use windows line endings. There's also a few bugs (all listed here in the issues) I'd like to clean up, and some whitespace issue discussions I'd like to try to get worked out. Also, ideally, I want to get the binary operator parsing rewritten. There's a much more efficient way it can be done. And we'll actually have a precedence table, so it will be much easier for forks to modify it. So still a couple months off from being merge-able. It's a slow process. But nothing's stopping you guys from using the compiler as it is right now. Unless you depend on super or splicing or comment preservation.\n. @nkohari: Yes, it will take many months, if not years, to finish the last 3 features, even though the first 97 and the infrastructure around them took just 4 months. Thank you for putting that into perspective for the rest of us. We'll be lucky if our children ever see a world with CoffeeScript 2.0.\n. Hey, everyone. I've updated the roadmap to include all the things I want to get done before I consider my compiler ready to replace the original. Check it out. Currently, there's 9 things on the list, some larger than others, and it has me reaching 2.0 sometime mid-late March. If any of you would like to work on any of those issues before I get to them, feel free to contribute in whatever way you like. It would be much appreciated.\nPS Thanks for the kind words and inspiration, @Zearin.\nPPS @nkohari: Sorry I was a little hard on you earlier. You did, indeed, touch a nerve. It's been difficult receiving criticisms where people were expressing a lack of confidence in the project being completed, while at the same time the first major release feels so close to me. I hope the roadmap alleviates some of your concerns. super is probably the only thing people would consider a \"major\" feature on that list.\nClosing this issue, as I think it has served its purpose.\n. I'll be making the compiler available on npm tomorrow, tagged as a beta release. It's 98% feature complete and fairly stable. And apparently npm orders 2.0.0-beta-0 before 2.0.0, so I don't have to worry about what I'll call it.\n. Link: https://npmjs.org/package/coffee-script-redux\n. See jashkenas/coffee-script#1494 and jashkenas/coffee-script#1820. I was at first unsure about the conclusions of those issues, but I now believe we made the right choice. If you'd like to change our mind, post your thoughts in one of those issues.\n@epidemian: I believe you were referring to jashkenas/coffee-script when mentioning --join. This compiler will have no such feature. That should be left to build tools.\n. @dmitkataev: just configure your editor to use \\n as the line terminator.\n. Merged as 1bef91eb4a2709f3721a4e46873e55c69002d363. Thanks.\n. Thanks, fixed in the above commit.\n. @Nami-Doc: only the non-standard name property, about which I don't care. @satyr actually recommended something like this for CS back in the day, I believe.\n. @mark-hahn: The related issues are all linked in the linked FAQ. I'm pretty confident I understand the IE bug. It has been around and well known for quite a while.\njs\nvar f = function g(){};\nbehaves like this in IE6:\njs\nfunction g(){}\nvar f = g;\nSo the name g is exposed to the containing scope in IE6, not just the function body's scope.\nedit: Also, f !== g, so memory use will be higher in IE6. But nothing will break because of the change.\n. @epidemian: I think you've stumbled upon an esmangle bug. I've reported it and it is linked above.\n. I'm going to close this because of general FUD and because I don't want this change affecting the merge into jashkenas/coffee-script.\n. You are awesome! This looks perfect. Thanks, merging.\n. Fixed by #318.\n. @ghempton: I just don't see any merit in trying to preserve the old interface, especially when I've abandoned it on the CLI. This compiler is composed of distinct components, and that's how the CLI exposes it. Each component is individually useful. If you'd like to add a convenience method that composes a few of these (and behaves like jashkenas/coffee-script's compile), I'd be fine with that. But I'd like the browser interface to match the node interface, which already matches the CLI.\n. With those changes, this patch should be good.\n. LGTM. Merging. We'll have to add browser tests at some point. Thanks for the contribution, @ghempton!\n. See also jashkenas/coffee-script#2051\n. See #92. Not allowing the language to be dynamically extended was a conscious decision. This way CoffeeScript programs will be syntactically consistent. Sorry for not closing this earlier.\n. Huh. Looks like ) should sometimes close an indent. For the record, I would write it like this:\ncoffee\n(->\n  foo\n)()\nbut we have do, so this is preferred:\ncoffee\ndo ->\n  foo\nAnother inconsistency in the language accepted by the current compiler...\n. @phadej: I just pushed a commit to fix this. Please try it out, as I plan to do a release in the next day or two.\n. Re-opening. I, too, thought this was the same as #119 at first. This is different, and I see no reason this syntax should not be supported. Thanks for the better description, @mehcode. We'll have to keep an indentation style stack in the preprocessor.\n. Fixed by #145. Thanks again, @Arelius.\n. Wow, I wasn't even aware of this bug in the original compiler. @Nami-Doc: can you point me to an open issue?\nWe won't be supporting bugs. Closing.\n. Thanks for the great test ideas, @epidemian.\n. @Arelius: Merged, thanks.\n@epidemian: Agreed, we can use more negative tests, both here and in jashkenas/coffee-script. But for now, the test suite is sufficient (it's unlikely similar constructs would behave differently), and I've merged these changes. I also agree that allowing the ugly code that follows a set of consistent rules is a step forward.\n. > Nothing happens. The program hangs.\nIt doesn't hang, it waits for input on stdin. That's what this line from --help means:\n\nUnless instructed otherwise (--{input,watch,cli}), coffee will operate on stdin/stdout.\n\nAlso, what OS/node are you using? The help should read coffee where you have node.\n```\n$ bin/coffee --help\nUsage:\n  coffee FILE ARG* [-- ARG*]\n  coffee OPT* [--repl] OPT*\n  coffee OPT* -{-parse,p,-compile,c,-js,j,-cscodegen} OPT*\n  coffee {OPT,ARG}* -{-eval,e} {OPT,ARG}* -- ARG*\n\n... etc.\n```\nI definitely see how those usage patterns could use some clarification, I just don't quite know how. Maybe with examples? Common usage?\n. Awesome. For future issue readers' reference, here's an example usage:\ncoffee --js --source-map-file file.js.map -i file.coffee -o file.js\n. @JamesMaroney: I'm not liking this change. By default, I would like the compiler to operate on stdin/stdout. And the only case where more than one output is desirable is the --js and --source-map options. We should just add an interface for that. See #148. Also, is the --output option still not working for you after 9b3b9e299aa365b8bc6535bd50f2c25cb459e143?\n. > I did maintain the stdin/stdout behavior for default.\nI don't believe so. This currently generates JS from stdin and outputs to stdout: coffee --js. How do you do that?\n\nThe biggest win is in the ability to link the js and source maps since the tool is writing them both in one pass.\n\nI agree that this is a useful flow. It's also a more efficient one, since they can both be generated from the same JS CST. I'm thinking I should just change the --source-map flag to a parameter that takes a filename or some way to specify stdio streams.\n. Looks like this is related to the general need for better error handling in the preprocessor. When you get the indentation wrong, you're going to get these terrible error messages. I will look into it. Thanks for the reports.\n. This was fixed by #157.\n. They work fine for me. Make sure you're using them as the binary seq operator that they are.\n. I can't reproduce this issue.\n. @Arelius: Mind rebasing? I would like to try to get this merged.\n. LGTM. Merged. Thanks, @Arelius!\n. Thanks, merged.\n. Why are you running npm as root?\n. No. It seems to be working for others. You could try posting the more verbose report. Your initial report looks like it couldn't find the StringScanner dependency, but it's definitely available. Are you on a machine that's not connected to the internet?\n. This was completed when michaelficarra/jedediah was released. See #221 for the planned switch to isaacs/nopt.\n. In a way. The CLI and API are incompatible because of the fundamental differences in the designs of the compilers. But the input language it accepts should be the same (sans implementation bugs). You can learn a good deal more by reading the previous issues that discussed this.\n. I know it's going to be unpopular, but this looks like yet another duplicate of jashkenas/coffee-script#1736. In python, indentation inside parentheses or brackets is ignored. CoffeeScript isn't python. Indentation is significant everywhere.\n. @jldailey: It's known. See #57.\n. It's a bug. They're both bugs, since throw is a statement in JS. Also, @epidemian: you forgot break and continue.\n. @kevinmehall: Yep, I believe I was the one that added that support.\nedit: Never mind, it was Jeremy.\n. Running make browser will generate the file you're looking for. You can also find this file already built at https://github.com/michaelficarra/CoffeeScriptRedux/blob/gh-pages/CoffeeScriptRedux.js\n. @Nami-Doc: That will probably work because of this: https://github.com/michaelficarra/CoffeeScriptRedux/blob/60916462e816cffdcb8b330ecc5d4fc611d71203/src/compiler.coffee#L95-L96\nFor the record, I highly discourage writing code like this. Gross. But we should support it.\n. @epidemian: You're exactly right, on both points. Comprehensions are not inferred to be such when they contain pure statements (or at least return). We could make it an error if we explicitly denoted that we wanted a comprehension. And that's why I think using a pure statement in what would otherwise be an implicit comprehension is such a gross style. But the original compiler intentionally supports that exact case, so we will have to as well.\n. Wow, when did that happen? git bisecting now...\n. I can't reproduce this. Please provide a test case.\n. Wow, this is an insane bug. I must have accidental state somewhere in the declaration-emitting code. Re-opening.\n. @epidemian: It's very useful, especially when you can easily write a script that fails when it detects the bug.\n. Huh, I still can't reproduce this on current master.\n$ bin/coffee --js --cli 'a extends b'\n// Generated by CoffeeScript 2.0.0-beta3\nextends$(a, b);\nfunction isOwn$(o, p) {\n  return {}.hasOwnProperty.call(o, p);\n}\nfunction extends$(child, parent) {\n  var key;\n  for (key in parent)\n    if (isOwn$(parent, key))\n      child[key] = parent[key];\n  function ctor() {\n    this.constructor = child;\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor;\n  child.__super__ = parent.prototype;\n  return child;\n}\nCan anyone give me a reproducible case?\n. Yeah, I just forgot to coerce it to an expression. Happy CoffeeScripting! :smile:\n. Thanks, @Constellation.\n. Yep, feature requests belong in jashkenas/coffee-script. And just use executable class bodies.\n. Looks fine to me. The semicolon is CoffeeScript's , operator. You wouldn't expect this JavaScript program to work, would you?\njs\na = 1\nrequire('./main2'),\nedit: @mehcode just beat me to it.\n. In this case, I'd say it depends who you ask. I have no qualms about not supporting trailing semicolons, though. If that's how you were writing your CoffeeScript code before, you were doing it wrong.\n. Ah, I see how that could happen. My editor actually points out trailing semicolons in bright red. Well, good luck with commonjs-everywhere!\n. @epidemian: Actually, I think that quote makes my point perfectly. But really, I don't care either way. I could add a special exception that allows trailing semicolons for blocks, and I could change the ; operator to read one or more semicolons. It's not going to be high priority, though. Code like that really disgusts me.\n. @mehcode: I couldn't have put it better myself.\n. This should help a bit, but obviously isn't a contributors' guide: https://speakerdeck.com/michaelficarra/an-analysis-of-the-redesign-of-the-coffeescript-compiler\nI'll try to write something up. Maybe a wiki page with pretty pictures and everything.\n. RE static type checker: see this tweet: https://twitter.com/puffnfresh/status/303961963661254656\nI think it's better to create a tool that performs the analysis on the spidermonkey AST and then just map the types back to the CoffeeScript constructs. Then you'll be able to determine static types for any compile-to-JS language.\nedit: here's some good resources or starting points:\n- https://github.com/espadrine/aulx\n- https://github.com/scripted-editor/scripted/wiki/Architecture#wiki-Inferencing\n- https://github.com/scripted-editor/scripted/blob/master/client/scripts/plugins/esprima/esprimaJsContentAssist.js\n- https://github.com/marijnh/tern/blob/master/infer.js\n- http://rfrn.org/~shu/drafts/ti.pdf\n- http://research.microsoft.com/apps/pubs/default.aspx?id=168635\n. Not with fall-through cases. We'd have to double up the body. Unless you mean we should or the conditions.\n. coffee\nswitch a\n  when b, c\n    do d\n  else\n    do e\n. Yeah, I think that's fine. Only for headless switches, though. We don't want to be repeating the switch condition all over the place.\n. Although, when it's used as a value, which is uglier: an IIFE wrapper around the switch or a conditional expression? I guess it depends on how many cases there are. But in the spirit of CoffeeScript, I guess we should compile to something as similar to the source as possible. Let's only transform headless switches.\n. Not quite as dramatic as that, but yes, there is a significant performance difference: http://jsperf.com/iife-switch-vs-ternary/2\nI'm torn here.\n. @jashkenas: I'm curious what you think is appropriate here. Do we sacrifice a little readability for some serious performance gains? According to the FAQ, we consider performance more important.\n. Closing this as wontfix. It was a bad idea, since we also need to make sure none of the cases have a break in them.\n. @epidemian: My feelings exactly. I'm not sure if there was an actual decision to support break in switch, they just  always compiled to breaks so worked as they would in JS. Personally, I would never write code that breaks early within a switch case.\n. It should be a pretty easy fix, just like it was with jashkenas/coffee-script. I'll look into it.\n. @fuson: I've implemented a similar fix. It's available now on master, and will be released in beta 8. Let me know how it works for you.\n. By the way, only node 0.10.0+ is supported with cluster, since that's when the execPath option was added to child_process.fork. Related: 432edaae31264451685fcc35532a4cad7a8fd369\n. @sokra: the additional offset is due to indent/dedent control characters and already known: #117\n. Huh, works for me. Are you building it yourself? Have you tried running npm update?\n. @ghempton: I just upgraded commonjs-everywhere (the build tool) to 0.5.x and successfully rebuilt the browser build (barring Constellation/esmangle#64). If you comment out this line, everything should work fine. Let me know how things work out for you.\n. Duplicate of #169.\n. Yes. It is just a very minor issue. Since it is literally a 1 line change to reduce the size of arrays that are cached, I will prioritise this for you.\n. I'm going to take this opportunity to just optimise loops over static, integral ranges.\n. You're running node 0.8. I accidentally broke it a few days ago. Upgrade node until I can issue a fix.\n. When you use the --source-map-file option, we add it for you, but in your use case, we have no idea whether you have a map or where it is. So yes, you should add the comment yourself.\n. Thanks for the analysis, but this is already known. See #43. We're still unsure about this syntax.\n. Confirmed, marking as bug.\n. Looks like an escodegen bug:\n``` js\n\nrequire('escodegen').generate({ type: 'Literal', value: new RegExp('///') });\n'/////'\n```\n\nPing @Constellation.\n. Wow, looks like a v8 bug. The note in ES5 \u00a715.10.6.4 states\n\nNOTE The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp object with the same behaviour as this object.\n\nBut that's not the case:\n``` js\n\n/\\/\\/\\//.toString()\n'/\\/\\/\\//'\nnew RegExp('///').toString()\n'/////'\n```\n\nedit: found the bug: https://code.google.com/p/v8/issues/detail?id=956\n. @Constellation: You are the best!\n. It's a bug.\n. I use it for all of my projects, and if you're using commonjs-everywhere, you are already using it. For docs, see bin/coffee --help. The CLI had to change because it exposes each IR and emphasises use of stdin/stdout for I/O. For an example Makefile for a project that uses this compiler, see the michaelficarra/coffeescript-project Makefile.\n. @marchaefner: that is a relic from browserify days. With commonjs-everywhere, I can just alias src/run.coffee to /dev/null.\n@epidemian: believe it or not, windows is a POSIX compliant OS. edit: Apparently, not since NT 4. That shows how long it's been since I've looked at Windows...\n. @Nami-Doc: maybe this would work better? https://github.com/int3/closure-interpreter/blob/48ce8e7284b57fb376150073d4c36585511ec354/Makefile#L3-L4\n. Fixed by #218.\n. Sorry about the failing travis build by the way. The REPL tests are failing in node 0.8 and I can't figure out why.\n. Yeah, there's still a bunch of commented ones that probably don't need to be commented anymore.\n@Avenger7x: Can you squash and force-push?\n. I rebuilt and rebased for you. Committed as 8e753e3e897e827804c990cee8c3258167aef373. Thanks for the bug report and pull request.\n. Merged as 37a7cefc74438114022242c067a7f883919208e5. Thanks.\n. @marchaefner: I can't seem to create a failing test case. My tests along with http://es5.github.io/#x12.14 indicate that the existence of a finally pretty much implies an empty catch.\nNever mind, I was wrong.\n. @marchaefner: Thanks for the persistence. I think I've fixed it with 8ec74fd4e684d3404527694d7ef30d299134ac0f. Can you try that out for me?\n. @marchaefner: A dangling finally doesn't have any observable effects. It's dead code and should be eliminated.\n. @marchaefner: try does imply an empty catch unless it is explicitly specified (and in CS 1.x, unless a finally is given, which is an inconsistency that must be a bug). So only the empty finally body needed to be eliminated, which it was.\n. Alright, that's plausible, though I would say unlikely. I'd like to hear the opinion/wisdom of @jashkenas, @Nami-Doc, or @satyr on this.\n. @Nami-Doc: We all agree on that. The question is whether a try-finally implies an empty catch (as it does without a finally) or whether it specifies that the catch is omitted. I personally think it's a bug that adding a finally would cause the catch in the output to be removed.\n. Okay, re-closing until someone else makes noise about this. I think we've fixed what was a bug in jashkenas/coffee-script. I'll document it along with the other intentional deviations from jashkenas/coffee-script on the wiki.\n. @jashkenas: Were we wrong here to change this behaviour? I try to never write code like the above (mutation and complex control flow, blech), but it seems some people would find use in catch-less try-finally constructs. I think that we might want to err on the side of caution and revert the behaviour back to how it was.\n. Okay, after looking into this deeper, I see where the mistake was made. When @jphaas resurrected this thread, he had missed the fact that a catch is only implied for empty finally blocks. And since it was 6 months since we had last discussed this issue, I had missed it, too. I've changed the wording of the wiki page to make it clear that this is only a very specific, rare case. Closing #274, as this is definitely a bug fix.\n. I've locked mozilla/source-map at v0.1.11 for now to fix this. Something in this diff broke the source position lookup: https://github.com/mozilla/source-map/compare/00d5b8f4...5cdb2633\n. See https://github.com/mozilla/source-map/pull/71\n. Yep, @Nami-Doc is right.\n. To truly match CS 1.x behaviour, we would need to return the result of calling the super constructor, but that would result in the very unexpected\ncoffee\nnew Subclass not instanceof Subclass\nI thought we had that behaviour a while ago and removed it. I'll do some research.\n. See jashkenas/coffee-script#1970 where we make sure that the return value of external constructors is returned from generated constructors. The fix for that happened to satisfy the request in jashkenas/coffee-script#2111, but I don't think we ever actually decided to have that functionality. It definitely seems like an error to me, even though I would expect new Subclass not instanceof Subclass to to be true in some cases, like the external constructor from jashkenas/coffee-script#1970 and of course constructors that explicitly return other objects. Leaving things as they are for now.\nedit: https://github.com/jashkenas/coffee-script/issues/2596#issuecomment-9780945 is a much better resource. Take a look at that. This is definitely a bugfix.\n. Thanks for the report. I will look into fixing this tomorrow. Here's my test cases:\n``` diff\ndiff --git i/test/classes.coffee w/test/classes.coffee\nindex 56fd2543..545c0ae1 100644\n--- i/test/classes.coffee\n+++ w/test/classes.coffee\n@@ -670,3 +670,12 @@ suite 'Classes', ->\n           b: nonceB\n       eq nonceA, A.prop.a\n       eq nonceB, A.prop.b\n+\n+    test '#205: implicit objects should not consume following prototype assignments', ->\n+      class A\n+        a: b: 0\n+        c: 1\n+      ok 'a' of A.prototype\n+      ok 'b' of A::a\n+      ok 'b' not of A.prototype\n+      ok 'c' of A.prototype\ndiff --git i/test/function-invocation.coffee w/test/function-invocation.coffee\nindex 587a450c..2c966e35 100644\n--- i/test/function-invocation.coffee\n+++ w/test/function-invocation.coffee\n@@ -479,3 +479,11 @@ suite 'Function Invocation', ->\n       a: 0\n     eq nonce, f? 0,\n       a: 1\n+\n+  test '#205: implicit objects on the same line should not consume following key-value pairs', ->\n+    fn = (o) ->\n+      ok 'a' of o\n+      ok 'b' not of o\n+    fn a: 0\n+    b: 1\n+    0\n``\n. Agreed. See https://github.com/michaelficarra/commonjs-everywhere/issues/68.\n. The line continuations with` is a duplicate of #20.\nThe semicolon is being treated as a sequence operator internally in CSR, as it should have been in the original compiler. The only difference should be trailing semicolons in files. Semicolons were never meant to be stuck on the end of every line. Are you suggesting we shouldn't allow newlines to follow semicolons? I would be for that, but it may make some people unhappy. Though I guess it'd only affect those stick-a-semicolon-at-the-end-of-every-line-for-no-semantic-reason people.\n. @epidemian:\n\nIs this by design or is it a bug?\n\nI doubt the original compiler's precedence was by design. A lot of the precedence rules seem to have occurred simply by accident, and only the most egregious mistakes were later corrected. Try searching for \"precedence\" in the issues.\nImplementing the same precedence rules in CSR was entirely by design. I wish we could change them now. Function application needs to be above infix operators.\n. @epidemian: Sorry, I wasn't trying to derail the issue, just lamenting. The CSR compilation of your examples is the same as jashkenas/coffee-script. Are you saying postfix and prefix if should have the same precedence relative to ;? I don't see why that would be expected.\n. > CSR is not really going to be CoffeeScript at all, but rather just another opinionated fork like all the other CS variants\nNot even close. Only the most underspecified and edge-case features have been changed/corrected (depending on your opinion of the change). I'll try to get together an exhaustive list of differences on the wiki soon.\nRegarding the trailing semicolons: you've read the previous issues and are familiar with my stance on the issue. Let me remind you that the vim-coffee-script syntax file highlights trailing/unnecessary semicolons as errors. It did not do this without reason. Unnecessary semicolons have always been highly discouraged, to the point of being considered errors.\n. > At one point I also saw a difference of interpretation of whitespace removal in multi-line strings between CS and CS\nYeah, sorry about that. That bug re-appeared a couple of times due to insufficient tests. Single- and double-quoted strings, single- and double-quoted heredocs, and strings with interpolations all have distinct parse rules, so the bug kept getting half-fixed. It should be all good now.\n. @pjeby: See https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script. It's obviously not yet exhaustive, but it's a start.\n. Ha, whoops. Thanks. Fix coming right up.\n. I guess we can do a feature test for require.extensions support. I'll fix this right now.\n. There is one: https://github.com/evanw/node-source-map-support. I'll make the change you requested.\n. Ah, yes, I forgot to implement this. Probably related: #178. Pull requests are welcome. I can probably get to this and #178 within the next couple of weeks. It shouldn't be very hard.\n. This may be a duplicate, but I don't see one right now. Pretty sure this is something we should correct.\n. Nice. Thanks, @jiyinyiyong. Closing in favour of #83.\n. If we can do it the way I'm thinking, this should be pretty easy. Unfortunately, it'll probably be at least 2 weeks before I'll have the chance to try it out.\n. @Nami-Doc: it it just the globbing in the Makefile that fails on Windows? Send over a pull request if it's simple. Let's continue this in #194.\n. Merged. Thanks :-)\n. This is not something that can be fixed. That error is meaningful. There's no tokenisation step. jashkenas/coffee-script's parser operates on a token stream. When it sees an unexpected token, it marks that token with an error. My PEG operates on the character stream. So the first character that is unacceptable in that position will be marked as erroneous. I think you just have to change how you interpret the messages. They're just as descriptive.\n. Thanks for the awesome bug report. Marking as bug.\n. Thanks for the report, @goffrie. I've fixed the issue you mentioned. Regarding the member accesses being stripped: it has been a long-standing CoffeeScript policy to ignore the existence of getters/setters. The compilers (both of them) will often generate code that may break or behave unexpectedly if getters/setters are used. There's nothing we can do to statically determine if they're being used, so we always assume that you are not using such mis-features.\n. Ugh, yeah, this was a pain in the ass when we fixed it in jashkenas/coffee-script. I'll look for the issue.\n. Just use the SHA.\n. Unnecessarily indented member accesses are not yet supported. This is a duplicate of some issue, but I can't find it right now.\n. Sure. I can start you off. It's going to require some fancy trickery here: https://github.com/michaelficarra/CoffeeScriptRedux/blob/a7448ea26e6887000d828af595e9c3b693fec4ef/src/grammar.pegjs#L594-L625\n. Duplicate of #63.\n. Unfortunately, we're redeclaring gensym-ed params. It doesn't break anything, but it's still a bug. I'm looking into it.\n. @Nami-Doc: That's basically what I was proposing. What don't you like about it?\n. @erisdiscord: Yep, just press ctrl-v.\nDoes anyone else have an opinion on this? I can drop it if it's unfavourable.\n. Alright, done.\n. And interestingly\n$ bin/coffee --js --no-optimise < test.coffee\n// Generated by CoffeeScript 2.0.0-beta7-dev\nanObject.someProp;\n. @erisdiscord: thanks for answering this.\nClosing as wontfix.\n. Re-opening. I'd like to add a parser rule at the end of blocks to look for a semicolon first. If it sees one, it should immediately throw an error. Thanks for that recommendation, @ulikoehler, and sorry for taking so long to get back to you.\n. Wow, I wasn't even aware of this. I need this all the time and usually just use this hack. This is great, I will add it.\n. Maybe it should be split up this way:\ngit clone git://github.com/michaelficarra/CoffeeScriptRedux.git && cd CoffeeScriptRedux && npm install\nmake clean && git checkout -- lib && make -j build && make test\nThat breaks it into a setup step and an iterative development step.\n. Merged as https://github.com/michaelficarra/CoffeeScriptRedux/commit/b886c15f80f1e6985a13daea7bcad63119e78686\n. That's a good question. These tests were pretty much ripped straight from jashkenas/coffee-script, so any errors in these probably also apply there. I will look into it soon. Feel free to send a PR if you think you fully understand it.\n. The CLI has changed. Read https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script and bin/coffee --help.\n. Fixed by #318.\n. Wow, this is interesting. I can reproduce your result (though only with data[3]/ 4 spacing, none of the others), but this test passes.\n``` coffee\ntest '#242: variously spaced divisions should all work', ->\n  nonce = 242\n  p = 1\n  o = {1: nonce}\neq nonce, (o[1]/1)\n  eq nonce, (o[p]/1)\n  eq nonce, (o[1]/p)\n  eq nonce, (o[p]/p)\neq nonce, (o[1] /1)\n  eq nonce, (o[p] /1)\n  eq nonce, (o[1] /p)\n  eq nonce, (o[p] /p)\neq nonce, (o[1]/ 1)\n  eq nonce, (o[p]/ 1)\n  eq nonce, (o[1]/ p)\n  eq nonce, (o[p]/ p)\neq nonce, (o[1] / 1)\n  eq nonce, (o[p] / 1)\n  eq nonce, (o[1] / p)\n  eq nonce, (o[p] / p)\n```\nStill investigating...\n. Why would you need this information at run time?\n. It would not fail to compile using jashkenas/coffee-script, just cause a ReferenceError at runtime. You should be compiling your CS to JS for production. And the JS should have no idea what compiler version was used. I am not convinced.\n. Okay, I've come around. But this implementation is not acceptable. I'll fix this with an alternative implementation.\n. @xixixao: There are some issues with jashkenas/coffee-script that will be incredibly hard to fix because of the compiler's design. The remaining issues here will just take a bit of time to implement. super will probably take me 10-15 hours. Stepped loops can be done in under 4. There's only one issue (splices on LHS of assignment) that has exposed a design flaw in this compiler.\nThis project is just not as interesting for me right now as some of the other projects I'm working on. I have a lot of really cool stuff coming out soon. I use this compiler pretty much every day and fix bugs immediately as I come upon them. I don't know why many other people aren't motivated to contribute to OSS projects.\n. @antonkulaga: I recently negotiated 10% time to work on outstanding OSS issues for Groupon. I'll be prioritising work on CSR, especially these two issues, starting 2014.\n. Fine, it doesn't hurt anything.\n. http://michaelficarra.github.io/CoffeeScriptRedux/#try:new%20this\n. https://github.com/michaelficarra/CoffeeScriptRedux/commit/31ad76fb372de484fe7fee46381b43558a7a79eb\n. Two bugs in one! Thanks. Can you file the failure to compile billingRecords[0]?.default = true as a separate issue?\n. Sure, we can do this.\n. Don't use comments, just omit them. The comments are pretty, and I once suggested the same thing for jashkenas/coffee-script, but it's just not consistent with what we do elsewhere.\n. From bin/coffee --help:\n--raw                   preserve source position and raw parse information\n. Aww, you beat me to it. I was looking forward to tackling this one. Unfortunately, I'll have to see some tests before I can merge this.\n. Also, please commit the generated parser.\n. LGTM. Squash and I'll merge.\n. Merging. Thanks for the contribution.\n. This is actually mentioned already.\n\nAnother change to note comes from fixing #1601, which proposed removing postfix :: and standalone @.\n\nWhat you have written is (a::)::b. The LHS of that :: uses a production that is no longer allowed.\n. Glad to hear.\n. Looks like JavaScriptCore can't even parse regexps right:\n\nIt doesn't allow unescaped / within character classes. If we wanted to fix this, we'd have to change Constellation/escodegen to work around this bug. I'll open an issue over there and see what Yusuke wants to do about it.\n. See https://github.com/Constellation/esmangle/issues/95.\n. See https://github.com/michaelficarra/CoffeeScriptRedux/commit/31ad76fb372de484fe7fee46381b43558a7a79eb, #247, https://github.com/michaelficarra/CoffeeScriptRedux/commit/b7b1a0d43649b8b95a013ab4bcc2e30b545494fa, and finally https://github.com/michaelficarra/CoffeeScriptRedux/commit/31ad76fb372de484fe7fee46381b43558a7a79eb#commitcomment-4176759. The next release will have standalone @ again, but do not use standalone @.\n. @mark-hahn: Stop trolling. It was removed for a short while, but added back solely for compatibility with legacy code. It is still officially discouraged, but not an incompatibility. If you're going to participate, please read the full conversation first.\n. I will update the wiki.\n. Nice catch. This is going to be an interesting one...\n. Yep, I was thinking the same thing. The parameter needs to be deleted in order to have the expected function length. Shouldn't be awful.\n. This is one of the intentional CLI deviations that is referred to in the wiki. Quoting:\n\nIntentional interface changes will not be listed here, as the command line and module interfaces have been drastically changed. It was never a goal of this project to have compatible interfaces suitable for drop-in replacement.\n\nWhat you want to do is pass arguments to the script after --, similar to git-checkout and many, many other command line tools. Try coffee myfile.coffee -- -v. Let me know if you have any problems with that.\nedit: Actually, I've just noticed a bug related to this. Fix coming soon.\n. @Alaneor: It's to allow this: coffee yourProgram.coffee --bare -- --bare. You need to be explicit about which flags are intended for the compiler and which are intended for your program.\n. @Alaneor: Ah, yes. I also wanted the flexibility to specify arguments in any order.\n. @alsotang: I don't really think this is a good idea. You're inevitably going to be stale. I don't think many people would think the benefit of writing fewer characters is worth falling behind. I won't officially endorse this, but feel free to continue keeping it up to date.\n. Ask the npm authors to add package aliases then.\n. We should probably just be setting the sourceRoot value.\n. The dedented comma style that is typically discouraged is not yet supported. See related issue #232. Also, it's interesting that the leading whitespace in the error message seems to have disappeared.\n. I would give the object a name.\n. We'll reserve import/export once they're reserved in a final version of the ECMA-262 spec.\n. CSR doesn't currently support stepped loops of any kind.\n. Looks great :-)\n. Wow, thanks.\n. Looks like the build failed. Can you either pend those failing REPL tests or disable them for node <= 0.8?\n. See https://github.com/jashkenas/coffee-script/pull/2824 for an example. I say we just pend them, though.\n. Can you unpend the tests that failed due to #288? After that, I will merge.\n. edit Stupid mobile website...\nThanks. Merging.\n. Fixed by #295.\n. Merged as b07f8184ae386e8eea094e5a29f22faabf44591b with some modifications in af87ba5ecbd3eb4be2c7fe1eeeb113bb92d81a4c and 72f1521a0ba767971d9cf88d74b08fc0156a44b2.\n. Hmm, I just removed this a few days ago: https://github.com/michaelficarra/CoffeeScriptRedux/commit/2b9160704a2a471766a01b1b137c46a8426e3a64\nIt worked for me. What commonjs-everywhere version do you have installed?\n. > fatal: unable to connect to github.com\nIt's on your side.\n. Since this example is better isolated, I'm going to close the earlier issue as a duplicate of this one.\n. I believe I saw a pegjs thread on returning partial trees on failure (though it could be done manually in each parse rule without support from pegjs), but I can't find it right now. This would be a lot of work, whichever strategy was chosen, but I'd be open to a PR if someone wants to take it on.\n. Github was probably down. Try again. Either way, it's not anything I can fix for you. Closing.\n. Yes, it must be supported for compatibility. I just haven't prioritised fixing it because I recommend against using this style.\n. It will, @slang800.\n. This is fixed on master.\njs\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvoid function () {\n  Foo = function () {\n    function Foo() {\n      this.args = [];\n    }\n    Foo.prototype.act = function () {\n      this.args = arguments.length > 0 ? [].slice.call(arguments, 0) : [];\n    };\n    return Foo;\n  }();\n}.call(this);\n. No, this is not intentional. It appears named destructuring does not allow newlines to be used as separators, unlike object literals. This should be an easy fix.\n. Backticks weren't removed, they just aren't able to introduce invalid syntax, such as {. And your conclusion was correct: we don't acknowledge side-effecting getters. It is a deplorable design.\n. Side-effecting getters.\n. Thanks for the PR, but there's a lot of work still needed here and, more importantly, I am still not sure of the future of super in CoffeeScript to begin with. Many, including myself, have been petitioning the other maintainers for adoption of ES6 semantics.\n. Sure. I'd merge a PR that achieves that. We need all those tests I mentioned in place first, though.\n. Duplicate of #63. The workaround I'd recommend is naming your function.\n. Yes. Except meaningful names would be better. \n. Wow, this is great! I've been struggling with this one for a while. Merging as soon as the travis build finishes.\n. Thanks, this is great progress.\n\nLooks like the the Travis build fails on Node 0.11\u2014sigh\u2014do you understand why?\n\nDon't worry about it. It's currently broken due to https://github.com/michaelficarra/CoffeeScriptRedux/issues/319\n\ncommon bug that bit me was [...]\n\njashkenas/coffeescript interface takes an options object as its second parameter, which may have a locals member (called inScope in CSR because we don't strive for interface parity) that lists names that should be considered already in scope. Ask the plugin maintainer to start using that.\n. I don't think so. helpers is something that needs to be mutated (or threaded through return values monadically), right? inScope and ancestry are entirely informational. They are built up in the traversal. Rules do not mutate them or pass out new values for them.\n. Yeah, it's a shitty one. You can keep the state in the Compiler instance and mutate it there instead of threading it through the compilation rules. It's cleaner. Unfortunately, JavaScript/CoffeeScript do not allow for very powerful abstraction.\n. Fixed by https://github.com/michaelficarra/CoffeeScriptRedux/commit/5272d3c9c3f17f62c23663a5c7c92bf2c87e9c02.\n. Ah I see, the test is not changed for negative step loops. Okay, I understand now.\n. cs2js does not take the same options as compile.\n. Nope. This compiler does not extend the CoffeeScript language.\n. It's very strange that we get the raw value correct but the range incorrect. Especially since we're just using PEG.js's line, column, and offset functions. Unfortunately, this is in one of the hairier parts of the code (read: there's a nasty hack to skip counting of context-free-CoffeeScript control characters).\n. Ah yes, now I remember. We fixed that issue in #117 (https://github.com/michaelficarra/CoffeeScriptRedux/commit/1f314eb80ff2393bc9508dd1f66205ad33ba6c3d) (though, using an extremely hacky approach). I would not be surprised if it broke when upgrading PEGjs, if not for the fact that we do have tests for it. I still can't think of a better way to solve this problem than the hack from #117.\n. Oh you're right, I didn't notice it only fixed line/column but not offset.\nYour commit looks awesome! Would we be able to also get rid of that nasty hack in the parser?\nedit: In case it wasn't clear, I mean integrating that lookup table in the CSR parser and getting rid of the overridden PEGjs function hack.\n. Not from any official sources, that's where. Anyone is free to work on this project. I stopped working on it after a disagreement between myself and the other CoffeeScript maintainers (long after this project's sponsored time period was over). I don't see a future for the CoffeeScript language without adoption of ES6 features. Unfortunately, I was the only one that believed we should adopt the semantics of any equivalent features in ES6: classes, default parameters, destructuring, comprehensions (while they were still ES6 track), etc. So because I no longer use the language for my own projects, I am not motivated to work on it. But there's nothing stopping anyone from opening issues and sending PRs. The vast majority of users are just unwilling to contribute.\n. :heart: @lydell. Thanks for all you've been doing with these projects lately.\n. @dynamix: I've been using ES6 for work JS (compiled to ES5 through 6to5) and PureScript for fun.\n. Thanks.\n. @devinrhode2: \"passing through\" breaks the abstraction, and is not how this compiler works. It is a structural transformation, not a text-based one. Sure, we could easily add support for import/export declarations, but the implementation would probably not look like what you're thinking.\n. @rattrayalex Check out PureScript. It is awesome and meets your requirements.\n. I'm aware: https://github.com/michaelficarra/CoffeeScriptRedux/issues/319\n. I don't understand why the line number was incorrect before. Is there not a simpler way we can fix this? Obviously there's a bug somewhere if it's reporting an error on line 1 for that program.\n. We have to remember that we're doing quite a few hacky things to try to get context sensitivity. It could have something to do with either our preprocessor-inserted context markers or the pegcoffee plugin/variant of pegjs we're using.\n. I like this PR a lot. I am willing to merge it in. @ef4: Can you rebase?\n. We should fix the accidentally missing raw field.\n. :heart:\n. Please rebase.\n. Thanks!\n. Wow, thanks.\n. See #336.\n. Nice! Thank you.\n. Yeah, unfortunately this hack is the most fragile part of the compiler (see the comment above). Thanks for fixing it. I wish we had a better way.\n. Is this just in recent versions of node? Have you tested whether 0.12 is affected? Do other stack traces work properly? Have you caught the error and inspected the stack yourself instead of allowing node to print it?\n. Done.\n. What is the -r flag supposed to do? I don't think that's a flag in our CLI.\n. This project's CLI is not compatible with that one's.\n. No, it compiles the same language. The CLI, REPL, etc. are separate.\n. Duplicate of #336.\n. ",
    "isakb": "Ah, no problem :) Sorry for the trouble.\n. Ah, no problem :) Sorry for the trouble.\n. ",
    "paulmillr": "it won't work on minified source. Michael would probably make classes automatically add this property in the future because displayName is going to be standardized.\n. This was discussed before and I agree it will be a useful util to output all helpers, but it will need to have low-level (js) API that returns string for usefulness.\n. Correction 2: jQuery won\u2019t drop it when worldwide IE6 share will be 0.x% because it\u2019s 6% currently and I think when 2.0 will be released in 2013 it will be around 3.5-4%. Still a lot China users use it.\n. the problem is: folks usually have different opinions on code readability.\nThis is the work coffeescript linter should do. I will create one with release of redux because I despise non-idiomatic code. It's really easy to do with the new compiler.\n. +1\n. yep, working\n. It is inconvenient at all to use backticks and there is no need to use them.\nI'm +100 on adding the perf / readability penalty. \u201cAdding types support\u201d should be done by proper compiler improvement.\n. node seem to automatically create proper binary if you install stuff via npm install. so just npm install the package.\n. @michaelficarra yep; ok\n. @michaelficarra super is used almost always in backbone-based web applications, it should be pretty popular to many people. I\u2019d open an issue.\n. https://github.com/jashkenas/coffee-script/issues/2638\n. Development of Redux slowed down much as compared to jun-sep :crying_cat_face: \n@michaelficarra do you think the project will be ready in the next few months?\n. it won't work on minified source. Michael would probably make classes automatically add this property in the future because displayName is going to be standardized.\n. This was discussed before and I agree it will be a useful util to output all helpers, but it will need to have low-level (js) API that returns string for usefulness.\n. Correction 2: jQuery won\u2019t drop it when worldwide IE6 share will be 0.x% because it\u2019s 6% currently and I think when 2.0 will be released in 2013 it will be around 3.5-4%. Still a lot China users use it.\n. the problem is: folks usually have different opinions on code readability.\nThis is the work coffeescript linter should do. I will create one with release of redux because I despise non-idiomatic code. It's really easy to do with the new compiler.\n. +1\n. yep, working\n. It is inconvenient at all to use backticks and there is no need to use them.\nI'm +100 on adding the perf / readability penalty. \u201cAdding types support\u201d should be done by proper compiler improvement.\n. node seem to automatically create proper binary if you install stuff via npm install. so just npm install the package.\n. @michaelficarra yep; ok\n. @michaelficarra super is used almost always in backbone-based web applications, it should be pretty popular to many people. I\u2019d open an issue.\n. https://github.com/jashkenas/coffee-script/issues/2638\n. Development of Redux slowed down much as compared to jun-sep :crying_cat_face: \n@michaelficarra do you think the project will be ready in the next few months?\n. ",
    "nhemsley": "nod\n. nod\n. ",
    "franc": "ignorant question: Why not write the parser code in CS, then compile to js and feed that to PEG.js?\n. makes sense thanks.\n. ignorant question: Why not write the parser code in CS, then compile to js and feed that to PEG.js?\n. makes sense thanks.\n. ",
    "dignifiedquire": "Are you interested in a pull request that converts the grammar to use my plugin? \n. I've started \"translating\" and found quite a few points where there is a construct like '?::[' + ws0 + e + ws1 + ']'\nI'm unsure about converting this to \"?::[#{ws0}#{e}#{ws1}]\". I think the first one is actually much more readable then latter. Any suggestions?\n. @renekooi That could go wrong if they aren't already strings. Suppose \"?[#{1+1}]\" would be converted to \"?[2]\"\n. @michaelficarra Ok. Just one more question I encountered something like \"for\" + ws and was wondering should there be a space between like \"for #{ws}\"  or is the space already contained in the variable that gets concatenated?\n. @ttilley You can find the work I've done on this here. I was at about 40% I think. The pegjs-coffee-plugin was finished and ready to use. But I haven't updated it to use the new plugin architecture in PEG.js. \nI'm afraid though right now I don't have the time to finish this translation. But if you have any questions I'll gladly help. \n. @ttilley Yes that seems to be pure luck :D I haven't looked at the changes before and no one filed a issue so I thought everything is allright. Yes in the old version the right phase was allocateRegister but that was removed some time ago. \nIf you have some more time on your hand I'd be happy to accept a PR with fixes for this lucky behavior as I don't have the time right now to read through all the changes in peg.js since then. \n. @michaelficarra You need to build PEGjs and upload the node distribution on itself to github as a repo, then you could reference it.\n. Are you interested in a pull request that converts the grammar to use my plugin? \n. I've started \"translating\" and found quite a few points where there is a construct like '?::[' + ws0 + e + ws1 + ']'\nI'm unsure about converting this to \"?::[#{ws0}#{e}#{ws1}]\". I think the first one is actually much more readable then latter. Any suggestions?\n. @renekooi That could go wrong if they aren't already strings. Suppose \"?[#{1+1}]\" would be converted to \"?[2]\"\n. @michaelficarra Ok. Just one more question I encountered something like \"for\" + ws and was wondering should there be a space between like \"for #{ws}\"  or is the space already contained in the variable that gets concatenated?\n. @ttilley You can find the work I've done on this here. I was at about 40% I think. The pegjs-coffee-plugin was finished and ready to use. But I haven't updated it to use the new plugin architecture in PEG.js. \nI'm afraid though right now I don't have the time to finish this translation. But if you have any questions I'll gladly help. \n. @ttilley Yes that seems to be pure luck :D I haven't looked at the changes before and no one filed a issue so I thought everything is allright. Yes in the old version the right phase was allocateRegister but that was removed some time ago. \nIf you have some more time on your hand I'd be happy to accept a PR with fixes for this lucky behavior as I don't have the time right now to read through all the changes in peg.js since then. \n. @michaelficarra You need to build PEGjs and upload the node distribution on itself to github as a repo, then you could reference it.\n. ",
    "goto-bus-stop": "\"?::[#{ ws0 + e + ws1 }]\", perhaps\n. Same with '?::[' + ws0 + e + ws1 + ']'\nAren't those always strings or a certain data type at the very least? Or does PEG.js pass number-only matches as Numbers instead of Strings? That'd be odd behavior...\n. Should be a compile-time error then?\n. In this snippet, this refers to the global object:\ncoffee\nb = a: this\nWhat the double arrow => does is make sure that the context, this, remains the same within the function, so that\n`` coffee\nb =\n  a: this\n  b: => this # This is the samethis`!\nc: -> this # This is another this!\nb.a is b.b()\nand\nb is b.c()\n```\nWhich is all expected. If you want this to refer to the object, use a single arrow ->.\n. \"?::[#{ ws0 + e + ws1 }]\", perhaps\n. Same with '?::[' + ws0 + e + ws1 + ']'\nAren't those always strings or a certain data type at the very least? Or does PEG.js pass number-only matches as Numbers instead of Strings? That'd be odd behavior...\n. Should be a compile-time error then?\n. In this snippet, this refers to the global object:\ncoffee\nb = a: this\nWhat the double arrow => does is make sure that the context, this, remains the same within the function, so that\n`` coffee\nb =\n  a: this\n  b: => this # This is the samethis`!\nc: -> this # This is another this!\nb.a is b.b()\nand\nb is b.c()\n```\nWhich is all expected. If you want this to refer to the object, use a single arrow ->.\n. ",
    "ttilley": "@Dignifiedquire - ping just to see if this was abandoned. I'm about to start a new project largely inspired by @michaelficarra using PEG.js for CoffeeScriptRedux and would absolutely :heart: the advanced practical example of pegcoffee usage, even if incomplete, for self-educational purposes.\nBesides the practical goal of the project, having a more solid understanding of PEG and thus a better understanding of CoffeeScriptRedux and how I might contribute would also be nice. But hey, I like to cheat and coffee-script feels so much like cheating to me. ;)\n. @Dignifiedquire - I got bored and started poking at the new plugin API now that it doesn't look like it'll be radically changed before the next release (famous last words). I have a debugging plugin example that dumps out the AST after each stage written just to make sure I understand the AST and plugin-specific portion of the API: https://github.com/ttilley/pegjs/blob/be775ff60d3c5551bc9acba970107d4166617256/examples/plugins/plugin-debug.js#L27\n@Dignifiedquire - I do have a question though... your plugin seems to insert itself in the right place (transform stage) entirely by accident. You're looking for the index of a string that I assume used to be the name of a phase (allocateRegister) so that you can insert the coffee plugin before/after it. However, it doesn't exist at least in pegjs 0.7 as a phase, so the indexOf returns -1, which you subtract 1 from, and splice and it's entirely by luck that (-2, 0, fn) puts the coffee phase after the \"remove proxy rules\" phase, but before code generation. 0.o\n. my peg.js plugin is against the 0.8 api (though i haven't touched it in about a year) - https://github.com/ttilley/pegcoffee/blob/master/src/pegcoffee.coffee\nI never bothered adding a license, so consider it public domain. :+1: \n. Holy crap people! This is the kind of feedback loop that makes a developer less motivated rather than more so to continue working on a project that they'd otherwise be passionate about (or at least inspire them to completely ignore the issue tracker). CoffeeScriptRedux is more than just a little bit badass, and it'll get there when it can be implemented to the standard of quality the primary development resources feel comfortable with and proud of. Seriously, it's that simple.\nDo you have any idea how long it took Rubinius to be able to run 95% of the standard MRI code you might throw at it, and that JRuby has even given up entirely on providing a native C extension interface despite having an implementation at one point that was essentially 60% of the way there and just ended up being more effort than it was worth to get at that last 40%? The resulting efforts, RubySpec and FFI, are essentially game changing developments and would not have been created in the first place if both projects didn't come together and decide \"this shit is hard and we should probably do something about that\".\nResponding to @michaelficarra essentially saying that \"this shit is hard\", including linking to further constructive conversation in issue #106, by claiming the project is unfinished/unusable without offering any further assistance or creative input is... Well, to be as gentle and polite as I possibly can be, I can only say that it's uninspiring.\nPlease note that I'm not talking about the simple \"me toos\" that go about it without edging towards insulting, as those do tend to be genuinely helpful for prioritizing one's task list and future development efforts. I might also be semi-projecting some recent bitterness and the complaints haven't bothered @michaelficarra at all. :neutral_face:\n. @mehcode - That's a good point, a perfectly valid concern, and stated with exactly the right kind of perspective. If only half of the issue comments on my own projects were so clear. ;)\n@michaelficarra @jashkenas - What are your thoughts, generally speaking, regarding the above ?\n@mehcode - If I can offer encouragement in the form of beer or what have you, please let me know. ;)\nPersonally, at least in terms of ruby, i've made small contributions to multiple implementations over the years. It's something I can see myself dedicating time to purely out of moment-of-zen-amidst-the-chaos purposes (don't ask... I haven't had a lot of free time lately either...).\nPerhaps it's time to learn PEG.js...\n. Yeah... complete rewrites tend to do that. The commit comment mentions a fair number of incompatibilities. Without having looked in-depth myself, it does seem that this line might at least be relevant: \"all internal identifiers visible to user code in the initializer, actions and predicates are prefixed by |peg$|.\" Then again, it might also be bugs resulting from an incomplete implementation of pegjs's new <meme>ALL THE BYTECODE</meme> approach.\nIs this worth looking at in the near future if I have the time to while teaching myself pegjs, or of low enough priority that even code review for such a change would be worth deferring until after your updated schedule?\n. also for completeness sake, a quick scripted run against the documentation examples via:\nshell\nfor doc_coffee in $(find ../coffee-script/documentation -type f -name '*.coffee')\ndo\n  echo \"${doc_coffee}\"\n  ./bin/coffee --compile --input \"${doc_coffee}\" > /dev/null\ndone\nresults in the following (non-super-related) errors:\n../coffee-script/documentation/coffee/existence.coffee\nSyntax error on line 13, column 2: unexpected end of input\n../coffee-script/documentation/coffee/objects_reserved.coffee\nSyntax error on line 1, column 25: unexpected ':' (\\u003A)\n1 : $('.account').attr class: 'active'\n^ :~~~~~~~~~~~~~~~~~~~~~~~~~^\n2 : \n3 : log object.class\n4 :\n../coffee-script/documentation/coffee/parallel_assignment.coffee\nSyntax error on line 9, column 2: unexpected end of input\n../coffee-script/documentation/coffee/splices.coffee\nSyntax error on line 7, column 2: unexpected end of input\n...and obviously the one super-related error (again, just for completeness):\n../coffee-script/documentation/coffee/classes.coffee\nSyntax error on line 10, column 11: unexpected '5' (\\u0035)\n07 : class Snake extends Animal\n08 :   move: ->\n09 :     alert \"Slithering...\"\n10 :     super 5\n^^ :~~~~~~~~~~~^\n11 : \n12 : class Horse extends Animal\n13 :   move: ->\n. speaking of super, it may be worthwhile to include it within the PEG syntax as an exception case with a more descriptive error message. Perhaps super is currently unimplemented or some such, at least so the debugging makes sense to someone used to vanilla coffee-script.\n. EDIT: when I mentioned syntax error reporting, I was thinking of language.js and not PEG.js. Still, it might be nice to have specific handling for the short-term and a more descriptive error message as a result.\n@mehcode - I wasn't kidding earlier about offer of beer, pizza, or... Well, I don't know your life situation. Hiring a babysitter? Heh. :wink:\n. @Dignifiedquire - ping just to see if this was abandoned. I'm about to start a new project largely inspired by @michaelficarra using PEG.js for CoffeeScriptRedux and would absolutely :heart: the advanced practical example of pegcoffee usage, even if incomplete, for self-educational purposes.\nBesides the practical goal of the project, having a more solid understanding of PEG and thus a better understanding of CoffeeScriptRedux and how I might contribute would also be nice. But hey, I like to cheat and coffee-script feels so much like cheating to me. ;)\n. @Dignifiedquire - I got bored and started poking at the new plugin API now that it doesn't look like it'll be radically changed before the next release (famous last words). I have a debugging plugin example that dumps out the AST after each stage written just to make sure I understand the AST and plugin-specific portion of the API: https://github.com/ttilley/pegjs/blob/be775ff60d3c5551bc9acba970107d4166617256/examples/plugins/plugin-debug.js#L27\n@Dignifiedquire - I do have a question though... your plugin seems to insert itself in the right place (transform stage) entirely by accident. You're looking for the index of a string that I assume used to be the name of a phase (allocateRegister) so that you can insert the coffee plugin before/after it. However, it doesn't exist at least in pegjs 0.7 as a phase, so the indexOf returns -1, which you subtract 1 from, and splice and it's entirely by luck that (-2, 0, fn) puts the coffee phase after the \"remove proxy rules\" phase, but before code generation. 0.o\n. my peg.js plugin is against the 0.8 api (though i haven't touched it in about a year) - https://github.com/ttilley/pegcoffee/blob/master/src/pegcoffee.coffee\nI never bothered adding a license, so consider it public domain. :+1: \n. Holy crap people! This is the kind of feedback loop that makes a developer less motivated rather than more so to continue working on a project that they'd otherwise be passionate about (or at least inspire them to completely ignore the issue tracker). CoffeeScriptRedux is more than just a little bit badass, and it'll get there when it can be implemented to the standard of quality the primary development resources feel comfortable with and proud of. Seriously, it's that simple.\nDo you have any idea how long it took Rubinius to be able to run 95% of the standard MRI code you might throw at it, and that JRuby has even given up entirely on providing a native C extension interface despite having an implementation at one point that was essentially 60% of the way there and just ended up being more effort than it was worth to get at that last 40%? The resulting efforts, RubySpec and FFI, are essentially game changing developments and would not have been created in the first place if both projects didn't come together and decide \"this shit is hard and we should probably do something about that\".\nResponding to @michaelficarra essentially saying that \"this shit is hard\", including linking to further constructive conversation in issue #106, by claiming the project is unfinished/unusable without offering any further assistance or creative input is... Well, to be as gentle and polite as I possibly can be, I can only say that it's uninspiring.\nPlease note that I'm not talking about the simple \"me toos\" that go about it without edging towards insulting, as those do tend to be genuinely helpful for prioritizing one's task list and future development efforts. I might also be semi-projecting some recent bitterness and the complaints haven't bothered @michaelficarra at all. :neutral_face:\n. @mehcode - That's a good point, a perfectly valid concern, and stated with exactly the right kind of perspective. If only half of the issue comments on my own projects were so clear. ;)\n@michaelficarra @jashkenas - What are your thoughts, generally speaking, regarding the above ?\n@mehcode - If I can offer encouragement in the form of beer or what have you, please let me know. ;)\nPersonally, at least in terms of ruby, i've made small contributions to multiple implementations over the years. It's something I can see myself dedicating time to purely out of moment-of-zen-amidst-the-chaos purposes (don't ask... I haven't had a lot of free time lately either...).\nPerhaps it's time to learn PEG.js...\n. Yeah... complete rewrites tend to do that. The commit comment mentions a fair number of incompatibilities. Without having looked in-depth myself, it does seem that this line might at least be relevant: \"all internal identifiers visible to user code in the initializer, actions and predicates are prefixed by |peg$|.\" Then again, it might also be bugs resulting from an incomplete implementation of pegjs's new <meme>ALL THE BYTECODE</meme> approach.\nIs this worth looking at in the near future if I have the time to while teaching myself pegjs, or of low enough priority that even code review for such a change would be worth deferring until after your updated schedule?\n. also for completeness sake, a quick scripted run against the documentation examples via:\nshell\nfor doc_coffee in $(find ../coffee-script/documentation -type f -name '*.coffee')\ndo\n  echo \"${doc_coffee}\"\n  ./bin/coffee --compile --input \"${doc_coffee}\" > /dev/null\ndone\nresults in the following (non-super-related) errors:\n../coffee-script/documentation/coffee/existence.coffee\nSyntax error on line 13, column 2: unexpected end of input\n../coffee-script/documentation/coffee/objects_reserved.coffee\nSyntax error on line 1, column 25: unexpected ':' (\\u003A)\n1 : $('.account').attr class: 'active'\n^ :~~~~~~~~~~~~~~~~~~~~~~~~~^\n2 : \n3 : log object.class\n4 :\n../coffee-script/documentation/coffee/parallel_assignment.coffee\nSyntax error on line 9, column 2: unexpected end of input\n../coffee-script/documentation/coffee/splices.coffee\nSyntax error on line 7, column 2: unexpected end of input\n...and obviously the one super-related error (again, just for completeness):\n../coffee-script/documentation/coffee/classes.coffee\nSyntax error on line 10, column 11: unexpected '5' (\\u0035)\n07 : class Snake extends Animal\n08 :   move: ->\n09 :     alert \"Slithering...\"\n10 :     super 5\n^^ :~~~~~~~~~~~^\n11 : \n12 : class Horse extends Animal\n13 :   move: ->\n. speaking of super, it may be worthwhile to include it within the PEG syntax as an exception case with a more descriptive error message. Perhaps super is currently unimplemented or some such, at least so the debugging makes sense to someone used to vanilla coffee-script.\n. EDIT: when I mentioned syntax error reporting, I was thinking of language.js and not PEG.js. Still, it might be nice to have specific handling for the short-term and a more descriptive error message as a result.\n@mehcode - I wasn't kidding earlier about offer of beer, pizza, or... Well, I don't know your life situation. Hiring a babysitter? Heh. :wink:\n. ",
    "lydell": "When #318 is merged I\u2019d like to work on this. Just wondering, @Dignifiedquire\u2019s plugin uses jashkenas/coffee-script\u2014is that a problem? (Considering that CoffeeScriptRedux is self-hosted.)\n. I didn\u2019t expect such problems either. I was more of thinking on a more \u201cidealistic\u201d perspective or whatever you should call it. Just wanted to make sure that I didn\u2019t work in vain because you absolutely could not stand having another coffee-script compiler as a(n) (indirect) devDependency :)\n. Fixed by #321.\n. Looking at the compiled code and the source code, I now realize that there are only two cases:\n- When the splat is last\n- When the splat isn't last\nThe latter outputs the correct number of arguments, by splicing out the splat parameter. The former does not include such a splice. It looks pretty easy to fix that. I'll have a look at it tomorrow, hopefully. I just wonder, how do I generate comments?\n. Alright, no comments.\nI tried giving this a shot today, but I'm currently on Windows and installing make there seems next to impossible. I tried and failed to test my code without make. I'm slowly moving to linux, but that's gonna take a while.\nAnyways, here is the diff in case I don't get any time to work on this soon and somebody else would like a head start:\n``` diff\ndiff --git a/src/compiler.coffee b/src/compiler.coffee\nindex 1872958..f5894a3 100644\n--- a/src/compiler.coffee\n+++ b/src/compiler.coffee\n@@ -612,10 +612,10 @@ class exports.Compiler\n     if parameters.length > 0\n       if parameters[-1..][0].rest\n\n\nparamName = parameters.pop().expression\n             numParams = parameters.length\nparamName = parameters[numParams - 1] = parameters[numParams - 1].expression\ntest = new JS.BinaryExpression '<=', (new JS.Literal numParams), memberAccess (new JS.Identifier 'arguments'), 'length'\nconsequent = helpers.slice (new JS.Identifier 'arguments'), new JS.Literal (numParams - 1)\ntest = new JS.BinaryExpression '>', memberAccess (new JS.Identifier 'arguments'), 'length', (new JS.Literal numParams)\nconsequent = helpers.slice (new JS.Identifier 'arguments'), new JS.Literal numParams\n             alternate = new JS.ArrayExpression []\n             block.body.unshift stmt new JS.AssignmentExpression '=', paramName, new JS.ConditionalExpression test, consequent, alternate\n           else if any parameters, (p) -> p.rest\ndiff --git a/test/functions.coffee b/test/functions.coffee\nindex 78cbd20..3d7f76d 100644\n--- a/test/functions.coffee\n+++ b/test/functions.coffee\n@@ -81,11 +81,17 @@ suite 'Function Literals', ->\n\nsuite 'Parameter List Features', ->\n\n\ntest \"splats\", ->\n\n\narrayEq [0, 1, 2], (((splat...) -> splat) 0, 1, 2)\n\n\narrayEq [2, 3], (((_, _1, splat...) -> splat) 0, 1, 2, 3)\n\n\narrayEq [0, 1], (((splat..., _, _1) -> splat) 0, 1, 2, 3)\n\n\narrayEq [2], (((_, _1, splat..., _2) -> splat) 0, 1, 2, 3)\n\ntest \"splats\", ->\narrayEq [0, 1, 2], (((splat...) -> splat) 0, 1, 2)\narrayEq [2, 3], (((_, _1, splat...) -> splat) 0, 1, 2, 3)\narrayEq [0, 1], (((splat..., _, _1) -> splat) 0, 1, 2, 3)\narrayEq [2], (((_, _1, splat..., _2) -> splat) 0, 1, 2, 3)\n+\ntest \"function length with splats\", ->\neq 0, ((splat...) ->).length\neq 2, ((_, _1, splat...) ->).length\neq 2, ((splat..., _, _1) ->).length\n\neq 3, ((_, _1, splat..., _2) ->).length\n#test \"destructured splatted parameters\", ->\n #  arr = [0,1,2]\n```\n. Thanks for explaining! That was a real \"aha!\" moment to me; I actually learned something from it.\n. Duplicate of #165.\n. I only tested on node 0.10.\n\n\nHow do I disable tests just for node <= 0.8? Or should we just simply pend them?\n. Yay, now the tests pass!\n. Done.\n. No, this is not expected behavior. I also ran into this problem recently, and opened #323, which is a duplicate of this issue I realize now. Even though this issue was reported first, I\u2019m closing this one in favor of #323, since that one is more straight to the point.\n. The feature is intentional and nowadays it is documented as well.\n. I think this is a good start, but there are some things I don\u2019t really like:\n- I\u2019m not totally sold on that you have to use @var for \u201cglobal\u201d variables. Might be better to just do it like in plain JavaScript.\n- I common bug that bit me was this: a:Foo? { a ?= []; @rp a}. coffee-script then complains \u201cError on line 1: the variable \"a\" can't be assigned with ?= because it has not been declared before\u201d. Rewriting it to a:Foo? { a = [] unless a?; @rp a} doesn\u2019t work either, because that adds var a; at the top of the function, shadowing the \u201ca\u201d label. In such cases I used b:Foo? { a = if b? then b else []; @rp a}. This could be solved by adding all labels as parameters in the added wrapper function, but I\u2019m not sure that is easy to retrieve for plugins.\n- When there are errors in your coffee-script code, the error messages suck. You only get to see all of the cs code that contains the error, and what the error is. No line numbers. This is partly the plugin\u2019s fault (it should use coffee-script 1.7 and expose more), and partly pegjs\u2019s fault (it should add line and column positions to its ast nodes so plugins can base their error locations on them).\nStill, this is a step in the right direction. I just don\u2019t feel like forking both the plugin and pegjs to improve them too right now\u2014to tired from this conversion and tricky debugging ....\n. Looks like the the Travis build fails on Node 0.11\u2014sigh\u2014do you understand why?\n. @michaelficarra could you please have a look at the latest commit. It is a big improvement.\n. @michaelficarra Can we try to get this merged? Any change to the grammar is either blocked by this, or requires this PR to be updated.\n. I think this happen because enableHelpers is a module-global variable. It should be created on each invocation.\n. Are there any API tests? In case I end up making a PR\u2026\n. Does it make sense to pass helpers to each rule, just like inScope, ancestry etc.?\n. Then I don't know how to fix this issue :(\n. I thought about keeping the state on the Compiler instance as well, but the rules don't seem to have access to it?\n. Just found https://github.com/michaelficarra/CoffeeScriptRedux/commit/efaa09b7183f0d8e43a63c5ae4a9548f42582f08:\n\nnext up, remove {h,enabledH}elpers statefulness \n. Nope.\n\n~/CoffeeScriptRedux [master|\u2714] \n17:44 $ git checkout  5272d3c -q\n~/CoffeeScriptRedux [:5272d3c|\u2714] \n17:44 $ echo \"for a in b by -1 then c\" | bin/coffee --js --no-optimise\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvoid function () {\n  var a;\n  for (var i$ = 0, length$ = b.length; i$ < length$; i$ += -1) {\n    a = b[i$];\n    c;\n  }\n}.call(this);\nWhich is exactly the same output as in my original post.\nThis example might be clearer:\n```\n~/CoffeeScriptRedux [master|\u2714] \n17:53 $ bin/coffee -e --cli \"for i in [1,2,3] by -1 then console.log i.toString 2\"\n1\n(cli):10\n    console.log(i.toString(2));\n                  ^\nTypeError: Cannot call method 'toString' of undefined\n  at Object. ((cli):1:43, :10:19)\n  at Object. ((cli) :12:3)\n  at Module._compile (module.js:456:26)\n  at runModule (/home/lydell/CoffeeScriptRedux/lib/run.js:100:17)\n  at runMain (/home/lydell/CoffeeScriptRedux/lib/run.js:93:10)\n  at processInput (/home/lydell/CoffeeScriptRedux/lib/cli.js:276:7)\n  at Object. (/home/lydell/CoffeeScriptRedux/lib/cli.js:297:5)\n  at Module._compile (module.js:456:26)\n  at Object.Module._extensions..js (module.js:474:10)\n  at Module.load (module.js:356:32)\n~/CoffeeScriptRedux [master|\u2714] \n17:53 $ coffee -e \"for i in [1,2,3] by -1 then console.log i.toString 2\"\n11\n10\n1\n``\n. The online demo might not be up-to-date. Always try things out by pulling the latest master and runningbin/coffee`.\n~/CoffeeScriptRedux [master|\u2714] \n18:30 $ bin/coffee -bj --cli 'its (@really, @bad...) =>'\n// Generated by CoffeeScript 2.0.0-beta9-dev\nits(function (this$) {\n  return function (param$) {\n    this$.bad = arguments.length > 1 ? [].slice.call(arguments, 1) : [];\n    this$.really = param$;\n  };\n}(this));\n~/CoffeeScriptRedux [master|\u2714] \n18:32 $ bin/coffee -bj --cli 'a = (@b...) =>'\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvar a;\na = function (this$) {\n  return function () {\n    this$.b = arguments.length > 0 ? [].slice.call(arguments, 0) : [];\n  };\n}(this);\n~/CoffeeScriptRedux [master|\u2714] \n18:33 $ bin/coffee -bj --cli 'a = (@b...) ->'\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvar a;\na = function () {\n  this.b = arguments.length > 0 ? [].slice.call(arguments, 0) : [];\n};\nSeems to work.\n. > The vast majority of users are just unwilling to contribute.\nThat's the important point here. There are too few users and contributors. I've contributed a bit to the project and it's very nicely designed so it's not that hard! If you're interestes in the project, then by all means go ahead and work on it!\nIMO, the project is mostly done. What needs to be done is:\n- super (there's a PR for it)\n- CoffeeScript 1.7+ features\n- Polishing\n- Work on the \"jashkenas/coffeescript is too permissive, redux is too strict\" issues\nI hope that both projects could live alongside each other, without one replacing the other.\n. Just for the fun of it, I wrote up a bit about my \u201cdream compile-to-JS\u201d language: https://github.com/lydell/frappe. If you also like fantasizing about syntax it might be worth a read ;)\n. @lolmaus Yeah, I'd like to discuss things, but it's very likely I'll forget logging in on gitter, because I don't hang out there very much.\n(Side note: Frappe has no implementation yet, so there are no implementation details to discuss. But I get what you mean.)\n. It might be a bug in pegjs. As far as I know the offset and line/column are supposed to point to the same place.\n. When #318 is merged I\u2019d like to work on this. Just wondering, @Dignifiedquire\u2019s plugin uses jashkenas/coffee-script\u2014is that a problem? (Considering that CoffeeScriptRedux is self-hosted.)\n. I didn\u2019t expect such problems either. I was more of thinking on a more \u201cidealistic\u201d perspective or whatever you should call it. Just wanted to make sure that I didn\u2019t work in vain because you absolutely could not stand having another coffee-script compiler as a(n) (indirect) devDependency :)\n. Fixed by #321.\n. Looking at the compiled code and the source code, I now realize that there are only two cases:\n- When the splat is last\n- When the splat isn't last\nThe latter outputs the correct number of arguments, by splicing out the splat parameter. The former does not include such a splice. It looks pretty easy to fix that. I'll have a look at it tomorrow, hopefully. I just wonder, how do I generate comments?\n. Alright, no comments.\nI tried giving this a shot today, but I'm currently on Windows and installing make there seems next to impossible. I tried and failed to test my code without make. I'm slowly moving to linux, but that's gonna take a while.\nAnyways, here is the diff in case I don't get any time to work on this soon and somebody else would like a head start:\n``` diff\ndiff --git a/src/compiler.coffee b/src/compiler.coffee\nindex 1872958..f5894a3 100644\n--- a/src/compiler.coffee\n+++ b/src/compiler.coffee\n@@ -612,10 +612,10 @@ class exports.Compiler\n     if parameters.length > 0\n       if parameters[-1..][0].rest\n\n\nparamName = parameters.pop().expression\n             numParams = parameters.length\nparamName = parameters[numParams - 1] = parameters[numParams - 1].expression\ntest = new JS.BinaryExpression '<=', (new JS.Literal numParams), memberAccess (new JS.Identifier 'arguments'), 'length'\nconsequent = helpers.slice (new JS.Identifier 'arguments'), new JS.Literal (numParams - 1)\ntest = new JS.BinaryExpression '>', memberAccess (new JS.Identifier 'arguments'), 'length', (new JS.Literal numParams)\nconsequent = helpers.slice (new JS.Identifier 'arguments'), new JS.Literal numParams\n             alternate = new JS.ArrayExpression []\n             block.body.unshift stmt new JS.AssignmentExpression '=', paramName, new JS.ConditionalExpression test, consequent, alternate\n           else if any parameters, (p) -> p.rest\ndiff --git a/test/functions.coffee b/test/functions.coffee\nindex 78cbd20..3d7f76d 100644\n--- a/test/functions.coffee\n+++ b/test/functions.coffee\n@@ -81,11 +81,17 @@ suite 'Function Literals', ->\n\nsuite 'Parameter List Features', ->\n\n\ntest \"splats\", ->\n\n\narrayEq [0, 1, 2], (((splat...) -> splat) 0, 1, 2)\n\n\narrayEq [2, 3], (((_, _1, splat...) -> splat) 0, 1, 2, 3)\n\n\narrayEq [0, 1], (((splat..., _, _1) -> splat) 0, 1, 2, 3)\n\n\narrayEq [2], (((_, _1, splat..., _2) -> splat) 0, 1, 2, 3)\n\ntest \"splats\", ->\narrayEq [0, 1, 2], (((splat...) -> splat) 0, 1, 2)\narrayEq [2, 3], (((_, _1, splat...) -> splat) 0, 1, 2, 3)\narrayEq [0, 1], (((splat..., _, _1) -> splat) 0, 1, 2, 3)\narrayEq [2], (((_, _1, splat..., _2) -> splat) 0, 1, 2, 3)\n+\ntest \"function length with splats\", ->\neq 0, ((splat...) ->).length\neq 2, ((_, _1, splat...) ->).length\neq 2, ((splat..., _, _1) ->).length\n\neq 3, ((_, _1, splat..., _2) ->).length\n#test \"destructured splatted parameters\", ->\n #  arr = [0,1,2]\n```\n. Thanks for explaining! That was a real \"aha!\" moment to me; I actually learned something from it.\n. Duplicate of #165.\n. I only tested on node 0.10.\n\n\nHow do I disable tests just for node <= 0.8? Or should we just simply pend them?\n. Yay, now the tests pass!\n. Done.\n. No, this is not expected behavior. I also ran into this problem recently, and opened #323, which is a duplicate of this issue I realize now. Even though this issue was reported first, I\u2019m closing this one in favor of #323, since that one is more straight to the point.\n. The feature is intentional and nowadays it is documented as well.\n. I think this is a good start, but there are some things I don\u2019t really like:\n- I\u2019m not totally sold on that you have to use @var for \u201cglobal\u201d variables. Might be better to just do it like in plain JavaScript.\n- I common bug that bit me was this: a:Foo? { a ?= []; @rp a}. coffee-script then complains \u201cError on line 1: the variable \"a\" can't be assigned with ?= because it has not been declared before\u201d. Rewriting it to a:Foo? { a = [] unless a?; @rp a} doesn\u2019t work either, because that adds var a; at the top of the function, shadowing the \u201ca\u201d label. In such cases I used b:Foo? { a = if b? then b else []; @rp a}. This could be solved by adding all labels as parameters in the added wrapper function, but I\u2019m not sure that is easy to retrieve for plugins.\n- When there are errors in your coffee-script code, the error messages suck. You only get to see all of the cs code that contains the error, and what the error is. No line numbers. This is partly the plugin\u2019s fault (it should use coffee-script 1.7 and expose more), and partly pegjs\u2019s fault (it should add line and column positions to its ast nodes so plugins can base their error locations on them).\nStill, this is a step in the right direction. I just don\u2019t feel like forking both the plugin and pegjs to improve them too right now\u2014to tired from this conversion and tricky debugging ....\n. Looks like the the Travis build fails on Node 0.11\u2014sigh\u2014do you understand why?\n. @michaelficarra could you please have a look at the latest commit. It is a big improvement.\n. @michaelficarra Can we try to get this merged? Any change to the grammar is either blocked by this, or requires this PR to be updated.\n. I think this happen because enableHelpers is a module-global variable. It should be created on each invocation.\n. Are there any API tests? In case I end up making a PR\u2026\n. Does it make sense to pass helpers to each rule, just like inScope, ancestry etc.?\n. Then I don't know how to fix this issue :(\n. I thought about keeping the state on the Compiler instance as well, but the rules don't seem to have access to it?\n. Just found https://github.com/michaelficarra/CoffeeScriptRedux/commit/efaa09b7183f0d8e43a63c5ae4a9548f42582f08:\n\nnext up, remove {h,enabledH}elpers statefulness \n. Nope.\n\n~/CoffeeScriptRedux [master|\u2714] \n17:44 $ git checkout  5272d3c -q\n~/CoffeeScriptRedux [:5272d3c|\u2714] \n17:44 $ echo \"for a in b by -1 then c\" | bin/coffee --js --no-optimise\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvoid function () {\n  var a;\n  for (var i$ = 0, length$ = b.length; i$ < length$; i$ += -1) {\n    a = b[i$];\n    c;\n  }\n}.call(this);\nWhich is exactly the same output as in my original post.\nThis example might be clearer:\n```\n~/CoffeeScriptRedux [master|\u2714] \n17:53 $ bin/coffee -e --cli \"for i in [1,2,3] by -1 then console.log i.toString 2\"\n1\n(cli):10\n    console.log(i.toString(2));\n                  ^\nTypeError: Cannot call method 'toString' of undefined\n  at Object. ((cli):1:43, :10:19)\n  at Object. ((cli) :12:3)\n  at Module._compile (module.js:456:26)\n  at runModule (/home/lydell/CoffeeScriptRedux/lib/run.js:100:17)\n  at runMain (/home/lydell/CoffeeScriptRedux/lib/run.js:93:10)\n  at processInput (/home/lydell/CoffeeScriptRedux/lib/cli.js:276:7)\n  at Object. (/home/lydell/CoffeeScriptRedux/lib/cli.js:297:5)\n  at Module._compile (module.js:456:26)\n  at Object.Module._extensions..js (module.js:474:10)\n  at Module.load (module.js:356:32)\n~/CoffeeScriptRedux [master|\u2714] \n17:53 $ coffee -e \"for i in [1,2,3] by -1 then console.log i.toString 2\"\n11\n10\n1\n``\n. The online demo might not be up-to-date. Always try things out by pulling the latest master and runningbin/coffee`.\n~/CoffeeScriptRedux [master|\u2714] \n18:30 $ bin/coffee -bj --cli 'its (@really, @bad...) =>'\n// Generated by CoffeeScript 2.0.0-beta9-dev\nits(function (this$) {\n  return function (param$) {\n    this$.bad = arguments.length > 1 ? [].slice.call(arguments, 1) : [];\n    this$.really = param$;\n  };\n}(this));\n~/CoffeeScriptRedux [master|\u2714] \n18:32 $ bin/coffee -bj --cli 'a = (@b...) =>'\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvar a;\na = function (this$) {\n  return function () {\n    this$.b = arguments.length > 0 ? [].slice.call(arguments, 0) : [];\n  };\n}(this);\n~/CoffeeScriptRedux [master|\u2714] \n18:33 $ bin/coffee -bj --cli 'a = (@b...) ->'\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvar a;\na = function () {\n  this.b = arguments.length > 0 ? [].slice.call(arguments, 0) : [];\n};\nSeems to work.\n. > The vast majority of users are just unwilling to contribute.\nThat's the important point here. There are too few users and contributors. I've contributed a bit to the project and it's very nicely designed so it's not that hard! If you're interestes in the project, then by all means go ahead and work on it!\nIMO, the project is mostly done. What needs to be done is:\n- super (there's a PR for it)\n- CoffeeScript 1.7+ features\n- Polishing\n- Work on the \"jashkenas/coffeescript is too permissive, redux is too strict\" issues\nI hope that both projects could live alongside each other, without one replacing the other.\n. Just for the fun of it, I wrote up a bit about my \u201cdream compile-to-JS\u201d language: https://github.com/lydell/frappe. If you also like fantasizing about syntax it might be worth a read ;)\n. @lolmaus Yeah, I'd like to discuss things, but it's very likely I'll forget logging in on gitter, because I don't hang out there very much.\n(Side note: Frappe has no implementation yet, so there are no implementation details to discuss. But I get what you mean.)\n. It might be a bug in pegjs. As far as I know the offset and line/column are supposed to point to the same place.\n. ",
    "quackingduck": "Or just never put spaces in your source files. Like pretty much all source files ever :)\n. Ah right, the bootstrap. Makes sense\n. I guess. It is nice to do make clean && make and know that the full build process will run, not a huge deal though\n. Or just never put spaces in your source files. Like pretty much all source files ever :)\n. Ah right, the bootstrap. Makes sense\n. I guess. It is nice to do make clean && make and know that the full build process will run, not a huge deal though\n. ",
    "abedra": "Just a formality. The quotes aren't necessary. I will update the pull request.\n. I thought this would be a good way to start a conversation. This is certainly not meant to be the actual bin/coffee, but it serves the purpose of adding your parserTest.js file to the actual project. The only real modification I made from that is to take filenames directly as arguments rather than piping from stdin. \n. How do things work now? Can you pass it a file to work against? Running bin/coffee  just sits, and running bin/coffee <  just spits out the contents of the file. The aim here was not to port all of command, but to take what was currently working and pull it into the repo so others could work more effectively.\n. Just a formality. The quotes aren't necessary. I will update the pull request.\n. I thought this would be a good way to start a conversation. This is certainly not meant to be the actual bin/coffee, but it serves the purpose of adding your parserTest.js file to the actual project. The only real modification I made from that is to take filenames directly as arguments rather than piping from stdin. \n. How do things work now? Can you pass it a file to work against? Running bin/coffee  just sits, and running bin/coffee <  just spits out the contents of the file. The aim here was not to port all of command, but to take what was currently working and pull it into the repo so others could work more effectively.\n. ",
    "josher19": "Hi Michael,\nYou can make it more cross-platform by doing:\ncoffee\n{EOL} = require 'os'\nor \njavascript\nEOL = require('os').EOL\nor even (adapted from node's os.js):\ncoffee\nEOL = if process.platform is 'win32' then '\\r\\n' else '\\n'\nThen replace '\\n' with\n- variable EOL or\n- \"#{EOL}\" in Strings or \n- /\\r?\\n/ in Regex\nCheers,\n->> Josh <<-\n. @michaelficarra : Can you just treat it as whitespace in the preprocessor.coffee?\ncoffee\nws = '\\\\r\\\\t\\\\x0B\\\\f \\\\xA0\\\\u1680\\\\u180E\\\\u2000-\\\\u200A\\\\u202F\\\\u205F\\\\u3000\\\\uFEFF'\n. \"\\n\" is significant, but \"\\r\" generally is not (except on old Macs).\n\"\\r\\n\" converted to SPACE + NEWLINE should be okay in most cases, right?\nOn Thu, Dec 6, 2012 at 12:22 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@josher19 https://github.com/josher19: But line terminators are not\ninsignificant whitespace.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/18#issuecomment-11072773.\n. Hi Michael,\n\nYou can make it more cross-platform by doing:\ncoffee\n{EOL} = require 'os'\nor \njavascript\nEOL = require('os').EOL\nor even (adapted from node's os.js):\ncoffee\nEOL = if process.platform is 'win32' then '\\r\\n' else '\\n'\nThen replace '\\n' with\n- variable EOL or\n- \"#{EOL}\" in Strings or \n- /\\r?\\n/ in Regex\nCheers,\n->> Josh <<-\n. @michaelficarra : Can you just treat it as whitespace in the preprocessor.coffee?\ncoffee\nws = '\\\\r\\\\t\\\\x0B\\\\f \\\\xA0\\\\u1680\\\\u180E\\\\u2000-\\\\u200A\\\\u202F\\\\u205F\\\\u3000\\\\uFEFF'\n. \"\\n\" is significant, but \"\\r\" generally is not (except on old Macs).\n\"\\r\\n\" converted to SPACE + NEWLINE should be okay in most cases, right?\nOn Thu, Dec 6, 2012 at 12:22 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@josher19 https://github.com/josher19: But line terminators are not\ninsignificant whitespace.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/18#issuecomment-11072773.\n. \n",
    "brian428": "I know most folks probably aren't on Windows, but the issues with line endings and (if I recall from my testing) lines between object keys seems to be the only deal-breaker that is preventing a full switch from CS to CS-R. Any idea when this might be addressed? Thanks.\n. Michael, your last comment sounded like you might have a solution for this one. Just wondering if you had a chance to try it and see if it resolved the line terminator issue?\n. Hey Michael, sorry to pester but I've watched the recent flurry of activity and was just wondering if you were able to give this a shot? Thanks.\n. Thanks, Michael! Initial tests are promising! Next I hope to try it on a more complex project involving a lot of files.\n. Looks like it works if you run it within Git Bash. Might be worth adding to the docs/readme. Thanks.\n. https://npmjs.org/package/coffee-script-redux\n. I'm one of those Windows line ending folks, because work mandates that we use a specific gold-load of Win 7 for everything we do. In the corporate world this is not uncommon. So as much as it is a pain, there's probably more people affected by the line ending issues than one might expect. :-)\n. I know most folks probably aren't on Windows, but the issues with line endings and (if I recall from my testing) lines between object keys seems to be the only deal-breaker that is preventing a full switch from CS to CS-R. Any idea when this might be addressed? Thanks.\n. Michael, your last comment sounded like you might have a solution for this one. Just wondering if you had a chance to try it and see if it resolved the line terminator issue?\n. Hey Michael, sorry to pester but I've watched the recent flurry of activity and was just wondering if you were able to give this a shot? Thanks.\n. Thanks, Michael! Initial tests are promising! Next I hope to try it on a more complex project involving a lot of files.\n. Looks like it works if you run it within Git Bash. Might be worth adding to the docs/readme. Thanks.\n. https://npmjs.org/package/coffee-script-redux\n. I'm one of those Windows line ending folks, because work mandates that we use a specific gold-load of Win 7 for everything we do. In the corporate world this is not uncommon. So as much as it is a pain, there's probably more people affected by the line ending issues than one might expect. :-)\n. ",
    "mattparlane": "Done. I couldn't think of any more than the two I added. It's hard writing tests for code that works...  :)\nI also added one for multi-line interpolation.\n. Done. I couldn't think of any more than the two I added. It's hard writing tests for code that works...  :)\nI also added one for multi-line interpolation.\n. ",
    "webskin": "I have the same problem. For now I use a simple tool that merges all my coffee files before to launch the compilation. I don't know if it is simple to solve ?\n. +1\n. I have the same problem. For now I use a simple tool that merges all my coffee files before to launch the compilation. I don't know if it is simple to solve ?\n. +1\n. ",
    "delaaxe": "@webskin \nBut that would defeat the purpose of having a dependency manager right?\nI'd be happy if the compiler could print all possible helpers once, and then never show them anymore.\nedit: I see this was discussed to death already (https://github.com/jashkenas/coffee-script/pull/1820). Feel free to close.\n. Thanks. I've played a little with the parser and it's pretty awesome so far. Although I'm confused as to what happens when converting the AST to JSON.\nFor example :\n```\nCoffeeScript = require 'CoffeeScriptRedux'\nast = CoffeeScript.parse 'foo = ->', optimise: false\nconsole.log ast\nconsole.log ast.toJSON()\n```\ngives me this output :\n{ body: { statements: [ [Object] ], line: 1, column: 1 },\n  line: 1,\n  column: 1 }\n{ body: { statements: [ [Object] ], type: 'Block' },\n  type: 'Program' }\nIn other words, is there a way to get both line/column and type information without having to traverse both trees in parallel?\n. Found a way to have line numbers appear in the toJSON() output.\nIn nodes.coffee :\n@@ -196,6 +196,8 @@ Nodes::toJSON = ->\n       json[child] = (p.toJSON() for p in @[child])\n     else\n       json[child] = @[child]?.toJSON()\n+    json.line = @[child]?.line if @[child]?.line?\n+    json.column = @[child]?.column if @[child]?.column?\n   json\nMight not be the ideal solution though\n. -1 I find those constructs completely unreadable for anyone not expert in CoffeeScript (like other employees, which I'm trying to convince to use CoffeeScript). Less parens are counter productive IMO\n. would appreciate too +1\n. That'll probably have to do with the fact that the\n    \"use strict\";\nstatement has no side effect, so the optimiser cleans it out. Try compiling with the \"--no-optimise\" flag.\nThis should be treated as a special case though\n. @webskin \nBut that would defeat the purpose of having a dependency manager right?\nI'd be happy if the compiler could print all possible helpers once, and then never show them anymore.\nedit: I see this was discussed to death already (https://github.com/jashkenas/coffee-script/pull/1820). Feel free to close.\n. Thanks. I've played a little with the parser and it's pretty awesome so far. Although I'm confused as to what happens when converting the AST to JSON.\nFor example :\n```\nCoffeeScript = require 'CoffeeScriptRedux'\nast = CoffeeScript.parse 'foo = ->', optimise: false\nconsole.log ast\nconsole.log ast.toJSON()\n```\ngives me this output :\n{ body: { statements: [ [Object] ], line: 1, column: 1 },\n  line: 1,\n  column: 1 }\n{ body: { statements: [ [Object] ], type: 'Block' },\n  type: 'Program' }\nIn other words, is there a way to get both line/column and type information without having to traverse both trees in parallel?\n. Found a way to have line numbers appear in the toJSON() output.\nIn nodes.coffee :\n@@ -196,6 +196,8 @@ Nodes::toJSON = ->\n       json[child] = (p.toJSON() for p in @[child])\n     else\n       json[child] = @[child]?.toJSON()\n+    json.line = @[child]?.line if @[child]?.line?\n+    json.column = @[child]?.column if @[child]?.column?\n   json\nMight not be the ideal solution though\n. -1 I find those constructs completely unreadable for anyone not expert in CoffeeScript (like other employees, which I'm trying to convince to use CoffeeScript). Less parens are counter productive IMO\n. would appreciate too +1\n. That'll probably have to do with the fact that the\n    \"use strict\";\nstatement has no side effect, so the optimiser cleans it out. Try compiling with the \"--no-optimise\" flag.\nThis should be treated as a special case though\n. ",
    "jldailey": "Closing this because it isn't a real pull request, converting it to an open issue.\nBoth of the included tests still fail:\nshouldParse \"a or\\n b\"\nshouldParse \"a or\\n\\tb\"\n. Yes, this is correct.  Checking out the /lib folder let it build again.\n. Allowed, but terrible:\nMath.min [\n    a,\n    b\n]...\nNot allowed, but obvious and natural:\nMath.min(\n    a,\n    b\n)\n???\n. Correction: the only issue is the lack of caching, the lack of assignment is a result of the contrived example.\n-> return cache[func()] ?= cache[func()] ?= []\nThis does do all the right comparisons and assignments, it just calls func() 4 times instead of 2.\n. Closing this because it isn't a real pull request, converting it to an open issue.\nBoth of the included tests still fail:\nshouldParse \"a or\\n b\"\nshouldParse \"a or\\n\\tb\"\n. Yes, this is correct.  Checking out the /lib folder let it build again.\n. Allowed, but terrible:\nMath.min [\n    a,\n    b\n]...\nNot allowed, but obvious and natural:\nMath.min(\n    a,\n    b\n)\n???\n. Correction: the only issue is the lack of caching, the lack of assignment is a result of the contrived example.\n-> return cache[func()] ?= cache[func()] ?= []\nThis does do all the right comparisons and assignments, it just calls func() 4 times instead of 2.\n. ",
    "Evgenus": "Two lines needed. You can do it by yourself\nhttp://stackoverflow.com/questions/11587231/coffeescript-getter-setter-in-object-initializers\n. Two lines needed. You can do it by yourself\nhttp://stackoverflow.com/questions/11587231/coffeescript-getter-setter-in-object-initializers\n. ",
    "netzpirat": "Perfect. I try to get this done and will open a pull request when it's finished or I need help.\n. Thanks for the hints, that will help me for getting started.\n. Perfect. I try to get this done and will open a pull request when it's finished or I need help.\n. Thanks for the hints, that will help me for getting started.\n. ",
    "lexaux": "Hello @michaelficarra, what about the block comments like\n``` coffee\n\nA code comment\n\n```\nAs I can see, with the current master they are totally omitted from the generated js output AND from the AST. Is it desired behavior yet? Otherwise I could try picking this issue. \nThanks! \nPS that's what I am exactly talking about: \n```\n[lexaux@archbang test]$ coffee --version\nCoffeeScript version 2.0.0-beta5\n[lexaux@archbang test]$ cat comments.coffee \n*\n*A comment here?\n\n[lexaux@archbang test]$ coffee --parse -i comments.coffee \n{ type: 'Program', body: undefined }\n[lexaux@archbang test]$ coffee --js -i comments.coffee \n[lexaux@archbang test]$ \n``\n. Cool, tried the approach from https://github.com/michaelficarra/CoffeeScriptRedux/issues/33#issuecomment-8008806 comment, though I augmentedTERMINATOR, not theTERM` rule, as I need to support rather multliners. \nThe approach itself works, but is troublesome. So, what we do: \n1. In the TERMINATOR rule, collect comment text. Push it to an array stored in initializer. \n2. I added to id function, so that it a) gets called even if raw/position is enabled, and it also tries to pop from the comment storage and append comment to a node. \nWell, that's it. \nTrouble is, however, that the next node created after the comment is found != the correct node. As the traversal goes in deep, it would trigger comment to the very first return (e.g. when we found something). To explain a little:\nThe sample program\n``` coffee\nfunc: (a, b) -> \n        console.log a+b \n\nKOMMENT\n\nfunc1: (c) ->\n        ###\n        also comment\n        ###\n        if c > 0 then console.log c \n        console.log c\n```\nAST produced using the approach from above: \njavascript\n{ body: \n   { statements: \n      [ { members: \n           [ { key: { data: 'func' },\n               expression: \n                { parameters: [ { data: 'a' }, { data: 'b' } ],\n                  body: \n                   { statements: \n                      [ { function: \n                           { expression: { data: 'console' },\n                             memberName: 'log',\n                             raw: NaN },\n                          arguments: \n                           [ { left: { data: 'a' },\n                               right: { data: 'b' } } ] } ] } } },\n             { key: { data: 'func1', comment: 'KOMMENT\\n' },\n               expression: \n                { parameters: [ { data: 'c' } ],\n                  body: \n                   { statements: \n                      [ { condition: \n                           { left: { data: 'c', comment: '\\talso comment\\n\\t' },\n                             right: { data: 0 } },\n                          consequent: \n                           { function: \n                              { expression: { data: 'console' },\n                                memberName: 'log',\n                                raw: NaN },\n                             arguments: [ { data: 'c' } ] },\n                          alternate: null },\n                        { function: \n                           { expression: { data: 'console' },\n                             memberName: 'log',\n                             raw: NaN },\n                          arguments: [ { data: 'c' } ] } ] } } } ] } ] } }\n'comment' field is added not to the IF but to the first concrete finding by parser - to the identifier c.  Normally, comment should be attached to condition I think. \nI am now thinking of other approaches; maybe changing the grammar to support block comments as separate entities (not part of the separator) and then writing them down during the AST materialization (this way it may be suppressed later, but requires tree traversal at compile-time). \nWhat do you think? \nPS sorry if missing something really obvious, haven't written parsers since the school. \n. Thanks Michael, I'll think about that too.\nFor now we have the TERMINATOR (which may obviously contain comments) after the rule, not before. If we change this (prepend TERMINATOR), we could then output comment text from the TERMINATOR match and somehow apply that to the node being created (another function wrapping new node?) \n. Hello @michaelficarra, what about the block comments like\n``` coffee\n\nA code comment\n\n```\nAs I can see, with the current master they are totally omitted from the generated js output AND from the AST. Is it desired behavior yet? Otherwise I could try picking this issue. \nThanks! \nPS that's what I am exactly talking about: \n```\n[lexaux@archbang test]$ coffee --version\nCoffeeScript version 2.0.0-beta5\n[lexaux@archbang test]$ cat comments.coffee \n*\n*A comment here?\n\n[lexaux@archbang test]$ coffee --parse -i comments.coffee \n{ type: 'Program', body: undefined }\n[lexaux@archbang test]$ coffee --js -i comments.coffee \n[lexaux@archbang test]$ \n``\n. Cool, tried the approach from https://github.com/michaelficarra/CoffeeScriptRedux/issues/33#issuecomment-8008806 comment, though I augmentedTERMINATOR, not theTERM` rule, as I need to support rather multliners. \nThe approach itself works, but is troublesome. So, what we do: \n1. In the TERMINATOR rule, collect comment text. Push it to an array stored in initializer. \n2. I added to id function, so that it a) gets called even if raw/position is enabled, and it also tries to pop from the comment storage and append comment to a node. \nWell, that's it. \nTrouble is, however, that the next node created after the comment is found != the correct node. As the traversal goes in deep, it would trigger comment to the very first return (e.g. when we found something). To explain a little:\nThe sample program\n``` coffee\nfunc: (a, b) -> \n        console.log a+b \n\nKOMMENT\n\nfunc1: (c) ->\n        ###\n        also comment\n        ###\n        if c > 0 then console.log c \n        console.log c\n```\nAST produced using the approach from above: \njavascript\n{ body: \n   { statements: \n      [ { members: \n           [ { key: { data: 'func' },\n               expression: \n                { parameters: [ { data: 'a' }, { data: 'b' } ],\n                  body: \n                   { statements: \n                      [ { function: \n                           { expression: { data: 'console' },\n                             memberName: 'log',\n                             raw: NaN },\n                          arguments: \n                           [ { left: { data: 'a' },\n                               right: { data: 'b' } } ] } ] } } },\n             { key: { data: 'func1', comment: 'KOMMENT\\n' },\n               expression: \n                { parameters: [ { data: 'c' } ],\n                  body: \n                   { statements: \n                      [ { condition: \n                           { left: { data: 'c', comment: '\\talso comment\\n\\t' },\n                             right: { data: 0 } },\n                          consequent: \n                           { function: \n                              { expression: { data: 'console' },\n                                memberName: 'log',\n                                raw: NaN },\n                             arguments: [ { data: 'c' } ] },\n                          alternate: null },\n                        { function: \n                           { expression: { data: 'console' },\n                             memberName: 'log',\n                             raw: NaN },\n                          arguments: [ { data: 'c' } ] } ] } } } ] } ] } }\n'comment' field is added not to the IF but to the first concrete finding by parser - to the identifier c.  Normally, comment should be attached to condition I think. \nI am now thinking of other approaches; maybe changing the grammar to support block comments as separate entities (not part of the separator) and then writing them down during the AST materialization (this way it may be suppressed later, but requires tree traversal at compile-time). \nWhat do you think? \nPS sorry if missing something really obvious, haven't written parsers since the school. \n. Thanks Michael, I'll think about that too.\nFor now we have the TERMINATOR (which may obviously contain comments) after the rule, not before. If we change this (prepend TERMINATOR), we could then output comment text from the TERMINATOR match and somehow apply that to the node being created (another function wrapping new node?) \n. ",
    "vendethiel": "Correction : JQuery will do it when IE6 will be around 0%.\nCoffeeScriptRedux is - til @michaelficarra starts his \"coffee of my dreams\" project - \"only\" a rewrite of the current CoffeeScript compiler.\n. Is this working with directories compilation ? Using \"sections\" feature for source map (I don't even know if this is more than a draft)\n. AJaX updates of github for the issues.\n. jQuery code, for example ? ;)\n. satyr/coco#64\n. @meryn Yes, they work, because OUTDENT DOT is a specialcase.\n. I agree this should work :). Actually, we have a PR for that : #79.(not sure what \"chiming in\" means)\n. Yes, I think it should. I think jashkenas said it was \"taking indentation to the next level\" - can't find the issue right now, I must be tired.\ncoffee\n    eq nonce, o\n      .a()\n        .b\n      .c\nThis is the only discutable case, imho.\n(Sorry 'bout the english bit, I'm french kiddie, so my english is rather poor :p.)\n. Ah, I found it back. I couldn't find it because, well, it's from HN, not coffee issues. (as Coffee's Thunder-rolling-janitor, I still claim I can find any issue :p).\n. It should not mean the same as your second example ... In a perfect world. In a world where we need backcompat, we need that too. If we use that to allow for prog1s (or anything else) later, we first need to remove that from the official compiler. And that's not going to happen. So I think this is usually bad style, but should still be supported\n. Considering jashkenas likes this syntax (see my HN link), I doubt you're going to get it removed from the official compiler. (and also because it's completly fucked-up concerning whitespace :p)\n. I'd love to see that as a cascade (prog1) :). Probably with a slightly different op, tho\n. IIRC, CoffeeScriptRedux is a try-and-fail compiler. The compiler tries every rule, starting from its preferres rule, and failing with an explanative error message if none matched\n. Would it be possible/easier to mark IIFEs as generated and extract VariableDeclarations to the upper level ?\n. No.\n. I believe that's one of the thing @michaelficarra decided to leave behind, see #45\n. I think you know that super is a reference in itself in coco. ie super is superclass.method, super ... is superclass::method.apply this, ... and super:: is superclass::\n. Still discussed.\n. I was just searching the issue. I'm not as fast to find duplicates as on jashkenas coffee-script\nSee #63 \n. I find @michaelficarra 's answer still applies, no ?\n. True he said that, but he also said he'd think again about it afterwards.\nSee #79 too\n. Isn't that written in the wiki that super doesn't work ?\n. I suppose you can open a PR to add this link to the readme then !\n. It is already on npm, as coffee-script-redux\n. Redux's sloc : 3797.\nOriginal compiler : 4042.\nAnd I think @michaelficarra wants to shrink the grammar.\n. > Is there any chance this project could be merged now to a redux branch? \nI'm not sure I second this. Confusing more users and having to migrate issues etc is probably not the best choice right now.\n. Not available as long as it's not feature-complete, IIRC.\n. I mean feature-complete. In the coffee sense\n. --helpers= 0: normal behavior. -1: no helpers. 1: all helpers\nYour thoughts?\n. I believe you've run into #18\n. So I guess it doesn't harm on IE ? Could be possible to change arguments.callee inside the function body? \n. He veoted function foo(){}\n. @mark-hahn actually, it's fairly easy :p \n. I Still think runScripts is broken. Why is the next script loading triggered only if the current doesn't have an src ? (do execute is in the else clause)\n. Redux is just a rewrite, feature requests must go into jashkenas/coffee-script\n. Feature set : CoffeeScript.\n. That's not related to redux's feature set, I'm afraid you'll have to wait for it to be be in iced\n. #119\n. just closed as a dup.\n. oops -- and #119 should be resolved\n. This was never considered a valid syntax, it was merely allowed because how the compiler treated implicit objects but I remember reading comments from jashkenas etc saying this style shoudn't be used\n. Nope, I was unable to find it. I remember it wasn't in an related issue so it makes it a bit harder for me. Will look again when I get back home.\n. Which is kinda expected since it's not done. look at the progress\n. Having wikis as git is definitely neat :).\n. Maybe the first one should for consistency with the second, but implicit objects.\n. Bracket and parens rules are already really complex and break a lot in coffee\nIe : \ncoffee\nfoo\n  {a: 1}\n  {b: 2}\n  {c: 3}\nWon't parse because addImplicitParentheses will not trigger implicit call if you have INDENT {.\nAs for the compile result that's what I'd expect.\n. This is an edge case of implicit objects, not implicit call. Merely everything I know concerning comes from @satyr. I could certainly find issues tho (after my cinema tho :p).\nWhich makes things like that fail : \ncoffee\n{a: b,\n  c: d}\nWhich is basically the same case as yours but with a comma.\n. Would need to be added here, I suppose.\n. (Btw, the bracketed array comprehension is no more harmony's which decided to go [for (a in b) a] style).\nNot sure why CSR produces a closure here, seems unefficient no? I don't see the use case it fixes\n. Oh. Definitely a bug in the original compiler. Would need to check how makeReturn works in coffee\n. I'd add that redux is not (now) the place for feature requests ;).\n. You could actually compile everything to if-else chains, and use the ternary syntax if it's used as an expression (+ js comma op, of course)\n. how do we fallthrough in coffee?\n. then yes, I don't see what's wrong with or-ing\n. Could obviously use a simple caching\nswitch a.b()\n  when b, c\n    do d\n  else\n    do e\njs\nvar __ref;\nif ((__ref = a.b()) === b || __ref == c)\n  d();\nelse\n  e();\nbut that's a serious readibility loss so I agree\n. While I do agree with you, the perf hit is insane - a factor of 10. http://jsperf.com/iife-switch-vs-ternary\n. > In this case, the code does absolutely nothing, so a good compiler could optimize one entire test case, or part of it, to a no-op\nThat's what it was doing with my version. I originally tried to avoid that but getting the same metrics I removed it ... look at @michaelficarra 's link to see that it's still up to 4 times faster.\n. I'd vote +1 for that. Maybe a header ? ref assign on another line?\njs\n/* switch 5 */\nif ((_ref = 5) == 3 || _ref == 5) {\n. Interesting enough, I just learnt coffee used to compile switch statements to if/else (for compat with JS 1.3) :+1: \n0.9.3 \u2013 SEP 16, 2010\nCoffeeScript switch statements now compile into JS switch statements \u2014 they previously compiled into if/else chains for JavaScript 1.3 compatibility. Soaking a function invocation is now supported. Users of the RubyMine editor should now be able to use --watch mode.\n. I admit I actually forgot that org existed; 'Tis too late for coffee-script to move but I'd +1 for 2.0 :).\n. Whatever, cmake or cake or anything doesn't matter to me.\n. Cygwin is so bad and so horribly done it's never an ok requirement. I'd not use it even if that was the only way I had to build a project.\n. > I remember, however, that the MinGW project provided a set of command-line tools that emulated the *nix commands, including bash, make, and the very useful things like ls, rm, grep, etc, without requiring a full POSIX system ala Cygwin. I think i had some sort of success building C++ projects on both Windows and Linux with the same Makefile using those tools; but that was long time ago, i don't know what's their current state.\nI use that already. Does not do anything for the problems I mentioned here :(.\n. the only problems (when building) so far seems to be to be the globbing \nSRC = $(shell find src -name \"*.coffee\" -type f | sort)\nLIB = $(SRC:src/%.coffee=lib/%.js) lib/parser.js\nin $(LIB) but I have no idea whatsoever how to fix it. Googling didn't help a single bit.\n. Seems to work with SRC = $(wildcard src/*.coffee | sort)!\n. Maybe typo unless/typo:).\n. I think you can uncomment some until somewhere\n. you mean to tell me we don't have an until test? erm :^p\n. aah, we do\n(but seriously, I think we need some more tests, seeing how it could've gone wrong with that implicit call/brackets removal, if it weren't for satyr (you learn early that satyr can test any kind of code just seeing it and deduce any kind of situation where it might go wrong)).\n\n(sorry, it's been a long day xD)\n\nI quite like it, for my part. I don't plan to be strictly formal any soon :p.\n. unless I missed one testing postfix version, this PRs gives CSR more \"test coverage\", except for commented tests\n. Not sure I have much wisdom to bring, but I think that a try implies an empty catch in every case. I admit I never saw finally actually in JS. Or maybe in a keyword list ...\n. Even github searching only brings keyword lists and a lot of tests.\n. I think you missed my edit (since github doesn't \"refresh\" posts)\n\nbut I think that a try implies an empty catch in every case.\n. I think this i because super isn't implemented\n. Seems like the object never closes\n. I edited my comment already\n. This is not possible, why would you even want to do that ?\n. > compromise is to use coffeescript which produce typescript\n\nRedux produces JS, which I suppose is valid Typescript. Generating invalid JS for the purpose of using ANOTHER precompiler makes no sense\n. it's not even possible because it conflicts with the syntax\n. Blah, blah, whitespace significant isn't so tolerant in redux, and what have been said in all the other issues :p \n. great :).\n. I'm afraid I can't compile on windows anyway\n. Not something like node's repl, please.\n. The exact fact that it doesn't stop on parse error itself. That's just a time loss, and it never is how I expect it to be. \"Fail early\", don't try to capture my input for 20 lines when people are trying to get out of it.\nAlso insanely confusing as a beginner or when you don't know how that works. You think you just broke it.\n. make scratch ?\n. super's not implemented yet, so yeah.\n. Progress is here.\nRoadmap is here.\nAlso, you should be thanking @michaelficarra, not me (which also means I can't answer your last question).\n(and note that the original compiler now includes source maps)\n. https://github.com/jashkenas/coffee-script/issues/2342\nThis is the biggest issue. Other than that, the rewriter is an entangled mess imho.\n. \"this should be in your global gitignore\"\n. Well, that's the answer usually given.\n. Yes, it's a correct CoffeeScript expression. Basically everything in coffee is an expression. The tutorial doesn't talk about lvalue or rvalue because there's no point in making simple stuff complex.\n. It's just optimized away because it doesn't have any effect. a = b in [1,2,3] works fine.\n. That's what I'd want to see, yes.\n. Bare-@ were removed. (they're back now)\n. I think that should be documented here : https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script\nSee https://github.com/jashkenas/coffee-script/issues/1007#issuecomment-1637361\n. That's an interesting point. I agree it can feel impractical and not very user-friendly, but I like the parity with usual cli tools.\n. I like having cs2 for redux tho\n. See https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script\n. Just add the brackets\n. visionmedia/express#1976\n. I wondered what \"enable\" meant, too ...\n. No, this is a non-writable property\n. Add a propertyName\n. If the parser can't parse the code, how can it gives you what it parsed ?\n. My main issue with that is : it usually doesn't help (although you're maybe not trying to do something like acorn_loosejs). Compilers that don't skip on the first error and try to get as many as possible are usually really bad at that -- You get tons of error and you usually get to the first one anyway (that's what I do when I use gcc, for example) ...\nIf that's not your use-case, it might be fine, tho.\n. Duplicate of #76.\n. You can with a.b, I guess.\n. oh :).\n. @lydell and congrats on that collaborator badge :-).\n. Lol :D. But I think this is a duplicate of some other one\n. > So because I no longer use the language for my own projects, I am not motivated to work on it.\nThat's the same for me (not that I've been a huge contributer to either compilers, though) : I havn't used coffee in well over 2 years (and LiveScript in the past year), so my interest in either projects have dwindled down (and really, I don't have much interest in web anymore). \nBut yeah, :+1: to @lydell for his awesome contributions :).\nEDIT: \n\nUnfortunately, I was the only one that believed we should adopt the semantics of any equivalent features in ES6: classes, default parameters, destructuring, comprehensions\n\nI agree with all these. The only one I'd discuss would be \"let\", but the keyword is do in coffee, so it doesn't matter.\n. > Is there any guideline as to where to start in the light of making the current CS syntax output (node-supported) ES6 code? What parts would I have to look at/change?\nYou'd need to first make sure Escodegen supports ES6. Thankfully, it does.\nThen you need to teach CSR's js-nodes about it. Then you need to have the compiler's Class compilation logic generate a JS Class node instead of what it currently does.\nNote that you'd drop executable class bodies, which are a really big feature of CoffeeScript imho. Or do as I said here, and only compile to ES6 classes if there's no executable code in the body...\n. What? Why would coffee never see es6 modules going through? Did jeremy say that?\n. \"Which volunteers\"?\n. The js-nodes are here: https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/js-nodes.coffee\nIf you manage to replace the code generating javascript (that's escodegen, afaik) with something that takes the same AST format (well, that's gonna be a JS ast, you'll definitely need to change things up), I don't think too much of the compiler internals are tied to JS (you'll need to translate helpers and all, of course)\n. Correction : JQuery will do it when IE6 will be around 0%.\nCoffeeScriptRedux is - til @michaelficarra starts his \"coffee of my dreams\" project - \"only\" a rewrite of the current CoffeeScript compiler.\n. Is this working with directories compilation ? Using \"sections\" feature for source map (I don't even know if this is more than a draft)\n. AJaX updates of github for the issues.\n. jQuery code, for example ? ;)\n. satyr/coco#64\n. @meryn Yes, they work, because OUTDENT DOT is a specialcase.\n. I agree this should work :). Actually, we have a PR for that : #79.(not sure what \"chiming in\" means)\n. Yes, I think it should. I think jashkenas said it was \"taking indentation to the next level\" - can't find the issue right now, I must be tired.\ncoffee\n    eq nonce, o\n      .a()\n        .b\n      .c\nThis is the only discutable case, imho.\n(Sorry 'bout the english bit, I'm french kiddie, so my english is rather poor :p.)\n. Ah, I found it back. I couldn't find it because, well, it's from HN, not coffee issues. (as Coffee's Thunder-rolling-janitor, I still claim I can find any issue :p).\n. It should not mean the same as your second example ... In a perfect world. In a world where we need backcompat, we need that too. If we use that to allow for prog1s (or anything else) later, we first need to remove that from the official compiler. And that's not going to happen. So I think this is usually bad style, but should still be supported\n. Considering jashkenas likes this syntax (see my HN link), I doubt you're going to get it removed from the official compiler. (and also because it's completly fucked-up concerning whitespace :p)\n. I'd love to see that as a cascade (prog1) :). Probably with a slightly different op, tho\n. IIRC, CoffeeScriptRedux is a try-and-fail compiler. The compiler tries every rule, starting from its preferres rule, and failing with an explanative error message if none matched\n. Would it be possible/easier to mark IIFEs as generated and extract VariableDeclarations to the upper level ?\n. No.\n. I believe that's one of the thing @michaelficarra decided to leave behind, see #45\n. I think you know that super is a reference in itself in coco. ie super is superclass.method, super ... is superclass::method.apply this, ... and super:: is superclass::\n. Still discussed.\n. I was just searching the issue. I'm not as fast to find duplicates as on jashkenas coffee-script\nSee #63 \n. I find @michaelficarra 's answer still applies, no ?\n. True he said that, but he also said he'd think again about it afterwards.\nSee #79 too\n. Isn't that written in the wiki that super doesn't work ?\n. I suppose you can open a PR to add this link to the readme then !\n. It is already on npm, as coffee-script-redux\n. Redux's sloc : 3797.\nOriginal compiler : 4042.\nAnd I think @michaelficarra wants to shrink the grammar.\n. > Is there any chance this project could be merged now to a redux branch? \nI'm not sure I second this. Confusing more users and having to migrate issues etc is probably not the best choice right now.\n. Not available as long as it's not feature-complete, IIRC.\n. I mean feature-complete. In the coffee sense\n. --helpers= 0: normal behavior. -1: no helpers. 1: all helpers\nYour thoughts?\n. I believe you've run into #18\n. So I guess it doesn't harm on IE ? Could be possible to change arguments.callee inside the function body? \n. He veoted function foo(){}\n. @mark-hahn actually, it's fairly easy :p \n. I Still think runScripts is broken. Why is the next script loading triggered only if the current doesn't have an src ? (do execute is in the else clause)\n. Redux is just a rewrite, feature requests must go into jashkenas/coffee-script\n. Feature set : CoffeeScript.\n. That's not related to redux's feature set, I'm afraid you'll have to wait for it to be be in iced\n. #119\n. just closed as a dup.\n. oops -- and #119 should be resolved\n. This was never considered a valid syntax, it was merely allowed because how the compiler treated implicit objects but I remember reading comments from jashkenas etc saying this style shoudn't be used\n. Nope, I was unable to find it. I remember it wasn't in an related issue so it makes it a bit harder for me. Will look again when I get back home.\n. Which is kinda expected since it's not done. look at the progress\n. Having wikis as git is definitely neat :).\n. Maybe the first one should for consistency with the second, but implicit objects.\n. Bracket and parens rules are already really complex and break a lot in coffee\nIe : \ncoffee\nfoo\n  {a: 1}\n  {b: 2}\n  {c: 3}\nWon't parse because addImplicitParentheses will not trigger implicit call if you have INDENT {.\nAs for the compile result that's what I'd expect.\n. This is an edge case of implicit objects, not implicit call. Merely everything I know concerning comes from @satyr. I could certainly find issues tho (after my cinema tho :p).\nWhich makes things like that fail : \ncoffee\n{a: b,\n  c: d}\nWhich is basically the same case as yours but with a comma.\n. Would need to be added here, I suppose.\n. (Btw, the bracketed array comprehension is no more harmony's which decided to go [for (a in b) a] style).\nNot sure why CSR produces a closure here, seems unefficient no? I don't see the use case it fixes\n. Oh. Definitely a bug in the original compiler. Would need to check how makeReturn works in coffee\n. I'd add that redux is not (now) the place for feature requests ;).\n. You could actually compile everything to if-else chains, and use the ternary syntax if it's used as an expression (+ js comma op, of course)\n. how do we fallthrough in coffee?\n. then yes, I don't see what's wrong with or-ing\n. Could obviously use a simple caching\nswitch a.b()\n  when b, c\n    do d\n  else\n    do e\njs\nvar __ref;\nif ((__ref = a.b()) === b || __ref == c)\n  d();\nelse\n  e();\nbut that's a serious readibility loss so I agree\n. While I do agree with you, the perf hit is insane - a factor of 10. http://jsperf.com/iife-switch-vs-ternary\n. > In this case, the code does absolutely nothing, so a good compiler could optimize one entire test case, or part of it, to a no-op\nThat's what it was doing with my version. I originally tried to avoid that but getting the same metrics I removed it ... look at @michaelficarra 's link to see that it's still up to 4 times faster.\n. I'd vote +1 for that. Maybe a header ? ref assign on another line?\njs\n/* switch 5 */\nif ((_ref = 5) == 3 || _ref == 5) {\n. Interesting enough, I just learnt coffee used to compile switch statements to if/else (for compat with JS 1.3) :+1: \n0.9.3 \u2013 SEP 16, 2010\nCoffeeScript switch statements now compile into JS switch statements \u2014 they previously compiled into if/else chains for JavaScript 1.3 compatibility. Soaking a function invocation is now supported. Users of the RubyMine editor should now be able to use --watch mode.\n. I admit I actually forgot that org existed; 'Tis too late for coffee-script to move but I'd +1 for 2.0 :).\n. Whatever, cmake or cake or anything doesn't matter to me.\n. Cygwin is so bad and so horribly done it's never an ok requirement. I'd not use it even if that was the only way I had to build a project.\n. > I remember, however, that the MinGW project provided a set of command-line tools that emulated the *nix commands, including bash, make, and the very useful things like ls, rm, grep, etc, without requiring a full POSIX system ala Cygwin. I think i had some sort of success building C++ projects on both Windows and Linux with the same Makefile using those tools; but that was long time ago, i don't know what's their current state.\nI use that already. Does not do anything for the problems I mentioned here :(.\n. the only problems (when building) so far seems to be to be the globbing \nSRC = $(shell find src -name \"*.coffee\" -type f | sort)\nLIB = $(SRC:src/%.coffee=lib/%.js) lib/parser.js\nin $(LIB) but I have no idea whatsoever how to fix it. Googling didn't help a single bit.\n. Seems to work with SRC = $(wildcard src/*.coffee | sort)!\n. Maybe typo unless/typo:).\n. I think you can uncomment some until somewhere\n. you mean to tell me we don't have an until test? erm :^p\n. aah, we do\n(but seriously, I think we need some more tests, seeing how it could've gone wrong with that implicit call/brackets removal, if it weren't for satyr (you learn early that satyr can test any kind of code just seeing it and deduce any kind of situation where it might go wrong)).\n\n(sorry, it's been a long day xD)\n\nI quite like it, for my part. I don't plan to be strictly formal any soon :p.\n. unless I missed one testing postfix version, this PRs gives CSR more \"test coverage\", except for commented tests\n. Not sure I have much wisdom to bring, but I think that a try implies an empty catch in every case. I admit I never saw finally actually in JS. Or maybe in a keyword list ...\n. Even github searching only brings keyword lists and a lot of tests.\n. I think you missed my edit (since github doesn't \"refresh\" posts)\n\nbut I think that a try implies an empty catch in every case.\n. I think this i because super isn't implemented\n. Seems like the object never closes\n. I edited my comment already\n. This is not possible, why would you even want to do that ?\n. > compromise is to use coffeescript which produce typescript\n\nRedux produces JS, which I suppose is valid Typescript. Generating invalid JS for the purpose of using ANOTHER precompiler makes no sense\n. it's not even possible because it conflicts with the syntax\n. Blah, blah, whitespace significant isn't so tolerant in redux, and what have been said in all the other issues :p \n. great :).\n. I'm afraid I can't compile on windows anyway\n. Not something like node's repl, please.\n. The exact fact that it doesn't stop on parse error itself. That's just a time loss, and it never is how I expect it to be. \"Fail early\", don't try to capture my input for 20 lines when people are trying to get out of it.\nAlso insanely confusing as a beginner or when you don't know how that works. You think you just broke it.\n. make scratch ?\n. super's not implemented yet, so yeah.\n. Progress is here.\nRoadmap is here.\nAlso, you should be thanking @michaelficarra, not me (which also means I can't answer your last question).\n(and note that the original compiler now includes source maps)\n. https://github.com/jashkenas/coffee-script/issues/2342\nThis is the biggest issue. Other than that, the rewriter is an entangled mess imho.\n. \"this should be in your global gitignore\"\n. Well, that's the answer usually given.\n. Yes, it's a correct CoffeeScript expression. Basically everything in coffee is an expression. The tutorial doesn't talk about lvalue or rvalue because there's no point in making simple stuff complex.\n. It's just optimized away because it doesn't have any effect. a = b in [1,2,3] works fine.\n. That's what I'd want to see, yes.\n. Bare-@ were removed. (they're back now)\n. I think that should be documented here : https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script\nSee https://github.com/jashkenas/coffee-script/issues/1007#issuecomment-1637361\n. That's an interesting point. I agree it can feel impractical and not very user-friendly, but I like the parity with usual cli tools.\n. I like having cs2 for redux tho\n. See https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script\n. Just add the brackets\n. visionmedia/express#1976\n. I wondered what \"enable\" meant, too ...\n. No, this is a non-writable property\n. Add a propertyName\n. If the parser can't parse the code, how can it gives you what it parsed ?\n. My main issue with that is : it usually doesn't help (although you're maybe not trying to do something like acorn_loosejs). Compilers that don't skip on the first error and try to get as many as possible are usually really bad at that -- You get tons of error and you usually get to the first one anyway (that's what I do when I use gcc, for example) ...\nIf that's not your use-case, it might be fine, tho.\n. Duplicate of #76.\n. You can with a.b, I guess.\n. oh :).\n. @lydell and congrats on that collaborator badge :-).\n. Lol :D. But I think this is a duplicate of some other one\n. > So because I no longer use the language for my own projects, I am not motivated to work on it.\nThat's the same for me (not that I've been a huge contributer to either compilers, though) : I havn't used coffee in well over 2 years (and LiveScript in the past year), so my interest in either projects have dwindled down (and really, I don't have much interest in web anymore). \nBut yeah, :+1: to @lydell for his awesome contributions :).\nEDIT: \n\nUnfortunately, I was the only one that believed we should adopt the semantics of any equivalent features in ES6: classes, default parameters, destructuring, comprehensions\n\nI agree with all these. The only one I'd discuss would be \"let\", but the keyword is do in coffee, so it doesn't matter.\n. > Is there any guideline as to where to start in the light of making the current CS syntax output (node-supported) ES6 code? What parts would I have to look at/change?\nYou'd need to first make sure Escodegen supports ES6. Thankfully, it does.\nThen you need to teach CSR's js-nodes about it. Then you need to have the compiler's Class compilation logic generate a JS Class node instead of what it currently does.\nNote that you'd drop executable class bodies, which are a really big feature of CoffeeScript imho. Or do as I said here, and only compile to ES6 classes if there's no executable code in the body...\n. What? Why would coffee never see es6 modules going through? Did jeremy say that?\n. \"Which volunteers\"?\n. The js-nodes are here: https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/js-nodes.coffee\nIf you manage to replace the code generating javascript (that's escodegen, afaik) with something that takes the same AST format (well, that's gonna be a JS ast, you'll definitely need to change things up), I don't think too much of the compiler internals are tied to JS (you'll need to translate helpers and all, of course)\n. ",
    "aeosynth": "jQuery's splitting into two pieces - 1.9.x, which will support oldIE; and 2.x, which will not. CoffeeScript could have a similar setup.\nI guess the goal of \"pass[ing] the current CS compiler\u2019s entire test suite\" rules out any breaking changes.\n. jQuery's splitting into two pieces - 1.9.x, which will support oldIE; and 2.x, which will not. CoffeeScript could have a similar setup.\nI guess the goal of \"pass[ing] the current CS compiler\u2019s entire test suite\" rules out any breaking changes.\n. ",
    "TobiaszCudnik": "Sounds great! For me it's the hottest feature, looking forward to it.\n. Extending the syntax and cross-compiling via TypeScript would be AWESOME. Thats exactly what i've been looking for - neat grammar and powerful control.\n. Nope, tabs everywhere. Besides, if indentation would be the issue, moving these bits after the constructor would also produce some error. Double checked.\n. Forgot to add that there are other methods in this class. Ive removed any whitespace after the last method. Still reproducible.\n. Ok i found out whats wrong here - this shortened object declarations aren't supported as class attrs (at least in this format) and constructor is simply nested there. The point is that official CS compiler does support such format.\nI've aligned the ticket description.\n. Sounds great! For me it's the hottest feature, looking forward to it.\n. Extending the syntax and cross-compiling via TypeScript would be AWESOME. Thats exactly what i've been looking for - neat grammar and powerful control.\n. Nope, tabs everywhere. Besides, if indentation would be the issue, moving these bits after the constructor would also produce some error. Double checked.\n. Forgot to add that there are other methods in this class. Ive removed any whitespace after the last method. Still reproducible.\n. Ok i found out whats wrong here - this shortened object declarations aren't supported as class attrs (at least in this format) and constructor is simply nested there. The point is that official CS compiler does support such format.\nI've aligned the ticket description.\n. ",
    "mark-hahn": "Awesome.  How does one use this?  Are we supposed to run escodegen with\nsome output of the CS compiler?\nOn Wed, Sep 5, 2012 at 12:25 PM, Michael Ficarra notifications@github.com\nwrote:\n\n@TobiaszCudnik: Source map support is completed. See\nconstellation/escodegen#50.\n\u2014\nReply to this email directly or view it on GitHub.\n. What is GitHub live update?  That is impossible to google.\n\nOn Thu, Sep 6, 2012 at 6:46 AM, Stan Angeloff notifications@github.comwrote:\n\n@michaelficarra https://github.com/michaelficarra: Too bad I can't do\nmuch more at the moment, e.g., send pull's, but hope bug reports are\nequally as good at this stage in the project.\nEDIT: wow, GitHub live update just closed this issue, neat!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/39#issuecomment-8332570.\n. > you shouldn't be allowed to perform an assignment within a higher-precedence operation like a do expression.\n\nI guess it could be do (func = ->) but then I'd have to put a paren at the end of the func definition which would be a pain in the butt.  This is a very common use case.  I've used it hundreds of times.\nI was really hoping redux would be backwards compatible.  I've got around 40,000 lines of coffescript and it would be nice if I didn't have to support 1.x and 2.x at the same time for different projects.  But that is my selfishness.  Do what is right for the community.\n. Now that I think about it, if I had to use do (func = ->) I wouldn't use do any more.  It would be cleaner to do \nfunc = ->\nfunc()\nwhich is less expressive than the old way.  Couldn't you just make do low-precedence?  Your and or example has a clear precedence but why does do have to be high-precedence?\n. >  it might be for auto-invoking recursive functions that need a reference to themselves inside the definition;\nExactly.  Here is the code that gave the error, minus a bunch of snipping.  Note the nesting and how messy it would be if = were forced to low precedence ...\n```\ndo doOneDir = ->\n    if not (dir = dirsPending.shift()) \n        dirsPending = ['/ri', '/rip']\n        doOneDir()\n        return\nfs.readdir dir, (err, files) ->\n    do doOneFile = ->\n        if not (file = files.shift()) then doOneDir(); return\n\n        filePath = path.join dir, file\n        process filePath, doOneFile\n\n```\n@michaelficarra  Please don't take this away from me.  I really like @epidemian's idea of changing the precedence of = when the left side isn't legal.\nCoffescript is very pragmatic.  Making it less useful for the sake of syntactic \"purity\" would be a big loss to the language.\n. >  So an \"invalid indentation\" can be also an unsupported block comment.\nI've always thought that if you indent to the right more than one tab it\nshould be automatic line continuation.\nOn Mon, Sep 10, 2012 at 11:36 AM, Jan Philipp notifications@github.comwrote:\n\nFor the records: I got it. I found in the issues / wiki that the block\ncomment won't work. Indeed, after some regex magic it works.\nSo an \"invalid indentation\" can be also an unsupported block comment.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/44#issuecomment-8433313.\n. I think you need to show a better example.  Not only would that example give a run-time error but I can't think of why anyone would code something so wrong.\n. Putting a comma in the front of a line is the standard way to ensure it\nis treated as a new argument.  You can't pull that.\n\nFWIW, I'm a bit concerned that redux is pulling a lot of useful features\nwhen it was supposed to be compatible.\nOn Tue, Sep 18, 2012 at 3:50 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@connec https://github.com/connec: You've got it. I would run screaming\nfrom code written like that.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/45#issuecomment-8673599.\n. >  I am not duplicating quirks.\n\nOne man's meat is another man's poison.  And it isn't just quirks.\n Requiring parens where they weren't needed before is taking the language\nbackwards, not matter how quirky it is.  If you do that you are not going\nto be very popular.  Sorry if this comes across as harsh.\nBTW, some of these issues fall under the category of line continuations.\n Line continuations are and always have been really screwed up in CS.  I\ncan find a blog for you that lists many of the problems.  I have had to\nresort to just using \\ at the end of the line for almost every continuation.\nI'm not suggesting a continuation fix, just stating the problem.\nOn Tue, Sep 18, 2012 at 4:11 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@mark-hahn https://github.com/mark-hahn: That is also a concern of\nmine. I really do not want this compiler to change the CoffeeScript\nlanguage or break our users' production CoffeeScript code. But there has to\nbe a line we draw between intentional features and quirks. I am not\nduplicating quirks. The original compiler was very, very permissive,\nallowing unintentional and inconsistent syntax.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/45#issuecomment-8674046.\n. +1  It would be a step backwards to lose this construct.\n\nOn Sun, Dec 16, 2012 at 2:46 AM, Arelius notifications@github.com wrote:\n\n$('').css 'color': 'blue' 'text-decoration': 'underline' .appendTo\n'body'\n. >  this arguably \"bad\" syntax constructs.\n\nIt may be arguable but I'd take the side of the argument saying it is a\nvery \"good\" construct.  I find it very readable and noise-free.\nOn Wed, Dec 19, 2012 at 8:23 AM, Demian notifications@github.com wrote:\n\nitems\n  .map (item) ->\n    item.price * item.quantity\n  .reduce (x, y) ->\n    x + y\n. I can't image thinking that adding more noise makes it more readable.\n\nOn Mon, Sep 17, 2012 at 12:55 PM, Christopher Pappas \nnotifications@github.com wrote:\n\nTotally understood.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/47#issuecomment-8628541.\n. Backticks have to pass everything through unchanged.  That is their purpose\nin life.\n\nI use var x; constantly to fix the scope problem.  They are also needed\nto use tamejs.\nOn Sat, Oct 13, 2012 at 7:52 PM, Greg Weber notifications@github.comwrote:\n\nI don't understand the second example code, do you think that is correct?\nThe current coffeescript compiler bails on some of these things.\necho 'f = (a) -> a + 5' | coffee -b -sError: Parse error on line 1: Unexpected 'JS'\nBut I have never seen the current coffee compiler generate eval: I am not\nsure what the point of that is. Backticks in the existing implementation\nare just supposed to pass through: that is what I expected.\nThis is an easy way to improve upon the existing coffee compiler: have\nbackticks to be parseable in all circumstances and do a simple pass\nthrough. I use backticks on occasion, mostly for multi-line JSON literals\nright now. What I am trying to do now is add support for types via\ntypescript:\nhttp://stackoverflow.com/questions/12874942/adding-typescript-to-coffeescript\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9415391.\n. This is yet one more CS feature being thrown out in 2.0.  My production\ncode will not be able to use 2.0 and I'm reluctant to use 2.0 in future\nprojects.\n\nOn Sun, Oct 14, 2012 at 10:49 AM, Greg Weber notifications@github.comwrote:\n\nlooking at the source, it seems we need either a new JS node type that\nrepresent opaque JS, or we need to have a JS parser that can take apart the\nJS.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9423599.\n. > Yes, but it's also the only way to define proper semantics for the JS\nliteral.\n\nThe backtick is not supposed to define semantics.  It is a kludge to allow\none to pass through unmodified text.  Nothing more, nothing less.\n\nIt is inconvenient at all to use backticks and there is no need to use\nthem.\n\nIf you read the entire thread you would see two valid uses.  I'll repeat\nthem here ...\n\"I use `var x;` to fix the scope problem.  They are also needed to use\ntamejs\".\nI have also used them as a kludge for debugging.\nOn Sun, Oct 14, 2012 at 12:21 PM, Michael Ficarra\nnotifications@github.comwrote:\n\nusing var gives no output\nSorry about that, a JS node was being assumed to have no side effects. The\nassumption should be the other way around. I will fix this.\nit is convenient for your implementation to wrap the javascript in an eval\nYes, but it's also the only way to define proper semantics for the JS\nliteral. If it was allowed to contain arbitrary character data, its\nsemantics would rely on implementation details that could change in the\nfuture. The completion value of a javascript program is well-defined, and\nthat will be the value of a JS literal.\nI still don't understand how the generated javascript in the second\nexample is supposed to be ok.\nMaybe it would help if you looked at the parse tree. I've cut out the\nsource information for clarity.\n$ echo 'f = (a) -> a + 5' |  bin/coffee --parse\n{ type: 'Program',\n  body:\n   { type: 'AssignOp',\n     assignee:\n      { type: 'Identifier',\n        data: 'f' },\n     expression:\n      { type: 'FunctionApplication',\n        function:\n         { type: 'JavaScript',\n           data: 'a' },\n        arguments:\n         [ { type: 'Function',\n             parameters: [],\n             body:\n              { type: 'PlusOp',\n                left:\n                 { type: 'Identifier',\n                   data: 'a' },\n                right:\n                 { type: 'Int',\n                   data: 5 } } } ] } } }\nwe need to have a JS parser that can take apart the JS\nThat was an option that we considered, but it would require us to depend\nupon a JS parser for a feature that is highly discouraged and completely\nunnecessary. The tradeoff is not worth it when eval does at runtime what\nthe parser would be doing at compile time.\nThis is yet one more CS feature being thrown out in 2.0.\nNot thrown out, fixed. It was broken. It allowed the user to provide a\nprogram that would cause the compiler to output invalid programs. It didn't\nhave a properly-defined semantics, or any defined semantics at all. That is\nunacceptable. This has standardised it.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9424676.\n. @Michael\n\nYou are claiming to be backwards compatible with CS but you are making\ndecisions to change CS without the approval of the community.  This is a\nrecipe for disaster.\nYou keep talking about 'fixing\" things that aren't broken.  How do you get\nto be the arbiter of what's broken?\nNormally I would not bitch about disagreements with an author of a project.\n But I fear this will replace the old CS and everyone will be stuck with\nyour unilateral decisions.\nOn Sun, Oct 14, 2012 at 12:40 PM, Mark Hahn mark@hahnca.com wrote:\n\n\nYes, but it's also the only way to define proper semantics for the JS\nliteral.\n\nThe backtick is not supposed to define semantics.  It is a kludge to allow\none to pass through unmodified text.  Nothing more, nothing less.\n\nIt is inconvenient at all to use backticks and there is no need to use\nthem.\n\nIf you read the entire thread you would see two valid uses.  I'll repeat\nthem here ...\n\"I use `var x;` to fix the scope problem.  They are also needed to\nuse tamejs\".\nI have also used them as a kludge for debugging.\nOn Sun, Oct 14, 2012 at 12:21 PM, Michael Ficarra \nnotifications@github.com wrote:\n\nusing var gives no output\nSorry about that, a JS node was being assumed to have no side effects.\nThe assumption should be the other way around. I will fix this.\nit is convenient for your implementation to wrap the javascript in an eval\nYes, but it's also the only way to define proper semantics for the JS\nliteral. If it was allowed to contain arbitrary character data, its\nsemantics would rely on implementation details that could change in the\nfuture. The completion value of a javascript program is well-defined, and\nthat will be the value of a JS literal.\nI still don't understand how the generated javascript in the second\nexample is supposed to be ok.\nMaybe it would help if you looked at the parse tree. I've cut out the\nsource information for clarity.\n$ echo 'f = (a) -> a + 5' |  bin/coffee --parse\n{ type: 'Program',\n  body:\n   { type: 'AssignOp',\n     assignee:\n      { type: 'Identifier',\n        data: 'f' },\n     expression:\n      { type: 'FunctionApplication',\n        function:\n         { type: 'JavaScript',\n           data: 'a' },\n        arguments:\n         [ { type: 'Function',\n             parameters: [],\n             body:\n              { type: 'PlusOp',\n                left:\n                 { type: 'Identifier',\n                   data: 'a' },\n                right:\n                 { type: 'Int',\n                   data: 5 } } } ] } } }\nwe need to have a JS parser that can take apart the JS\nThat was an option that we considered, but it would require us to depend\nupon a JS parser for a feature that is highly discouraged and completely\nunnecessary. The tradeoff is not worth it when eval does at runtime what\nthe parser would be doing at compile time.\nThis is yet one more CS feature being thrown out in 2.0.\nNot thrown out, fixed. It was broken. It allowed the user to provide a\nprogram that would cause the compiler to output invalid programs. It didn't\nhave a properly-defined semantics, or any defined semantics at all. That is\nunacceptable. This has standardised it.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9424676.\n. I appreciate your attention.\n\nJS literals were always a hack\n\nMaybe, but a necessary one.  TameJS won't work without them.\n\nyour scoping hack\n\nIt is interesting that you want to fix all the \"broken\" parts of javascript\nbut you call fixing the biggest problem in CS a hack.  Many people,\nincluding several on the front page of HN, feel this way about the scoping.\n The current lack of local scoping is constantly being defended, for\nreasons I don't understand.\n\nThese cases are extraordinary\n\nI would really like to know how many users would agree with you.  At what\npoint will the community get a say in this?  I saw that the BDFL agreed\nthat non parenthesized assignments on the RHS of boolean operators was not\nbug, but you continue to call it that.\nOn Sun, Oct 14, 2012 at 1:37 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@mark-hahn https://github.com/mark-hahn: Preserving the semantics of\nCoffeeScript was the most important factor influencing development. It is\nnot my intention to change CoffeeScript; I have my own fork for that. I\npersonally disagree with some of the language features I implemented, but I\nfaithfully implemented them. JS literals were always a hack. If they\nweren't being abused to do something crazy like try to change CoffeeScript\nsemantics (such as with your scoping hack), my implementation should cause\nno problems. Allowing unparenthesised assignments on the RHS of boolean\noperators, as in your other issue, was a bug that people were (some\nintentionally, some unintentionally) abusing. These cases are\nextraordinary, and not indicative of the support for code you will see in\nwell-written CoffeeScript programs.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9426638.\n. > I don't like the tone this ticket has taken\n\nI apologize for hijacking this discussion.  I was just shocked to see the\nremoval of back-tick functionality.\nOn Sun, Oct 14, 2012 at 3:07 PM, Greg Weber notifications@github.comwrote:\n\nI don't like the tone this ticket has taken. I disagree with the decision\nto use eval, but I understand it avoids a more complex implementation.\nHowever, I opened this ticket giving an example of bizarrely generated\ncode. The parse tree doesn't make sense just as the generated javascript\ndoesn't make sense and generates invalid javascript by hoisting an\nexpression out of its current location as a function argument and treating\nit as a function.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9428407.\n. > This is kinda off-topic, but...\n\nScoping has been discussed at great length before and will be in the\nfuture.  There is no need to discuss it here.\nOn Sun, Oct 14, 2012 at 4:09 PM, Demian notifications@github.com wrote:\n\nQuite an interesting discussion. Not so much for the usefulness of the\ntopic being discussed, but for how an undefined behaviour of the language\ncan cause so much trouble.\nI do agree that letting JS literals anywhere would be very broken (and\nprobably impossible/extremely difficult from the CS parser perspective).\nRestricting the backticks to be used only as expressions seems like a\nreasonable requirement to me.\nThe case of a = (<some JS>) -> b is quite an unfortunate one. It took\nme quite a while to understand that Redux was interpreting is as (lispy\nAST:) (assignment 'a' (application '' (function () 'b'))). That\nwas quite an unexpected behaviour to me. Once i figured out that Redux was\nadmitting things like a = (b + c) -> d (which interprets as a = (b +\nc)(-> d)) it became more evident what was happening, but i still think\nthat's not a very happy behaviour and i'd prefer it to be an error, like in\nthe original compiler.\nAbout the need for eval, i'm not sure i fully understand it. Is it\nbecause escodegen expects a nice AST and therefore you give it something\nlike (application 'eval' '')? If that's the case then\nyes, it's unfortunate. It would be nice for escodegen to admit a raw input\nleaf node as \"just trust that what comes here is a valid expression\" or\nsome other way including raw input. A very hacky way of bypassing\nescodegen would be to give it an AST like (application 'inlineMe'\n'' 'end'), which would generate the valid JS code: inlineMe('', 'end'), and then do a replacement of /inlineMe('(.*)',\n'end')/g with the first capturing group. Yes, a horrendous hack, but\nprobably better than including a JS parser just for the sake of backticks.\nWhat do you think? :)\nThis is kinda off-topic, but...\nIt is interesting that you want to fix all the \"broken\" parts of\njavascript but you call fixing the biggest problem in CS a hack. Many\npeople, including several on the front page of HN, feel this way about the\nscoping. The current lack of local scoping is constantly being defended,\nfor reasons I don't understand.\nI think you're referring to lexical scoping, which CS does have. I'm\npositive @jashkenas https://github.com/jashkenas clarified that in a HN\nthread. An example of how CS would behave if it had dynamic scopinghttp://en.wikipedia.org/wiki/Lexical_scoping#Lexical_scoping_and_dynamic_scoping\n:\nfoo = ->\n  alert a\nbar = ->\n  a = 5\n  foo() # With dinamic scoping this would work, and would alert 5.\n        # With lexical scoping this causes en error, as 'a' is not defined in the scope of foo.\n\nThese cases are extraordinary\nI would really like to know how many users would agree with you. At what\npoint will the community get a say in this?\nI'd say that the need for backticks at all it quite extraordinary. I\npersonally wouldn't miss them if they are completely removed at some point.\nBut that's just me, i'd also like to know what others think about this =D\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9429030.\n. +100 for anything like this that makes line-continuations easier to use,\nsimpler, and sane.  The CS line-continuation rules are a mish-mash at the\nmoment and not very friendly and not documented.  I've given up and mostly\nuse backslashes at the end of lines (so ugly!).\n\nOn Sat, Mar 9, 2013 at 11:15 PM, Peter Wong notifications@github.comwrote:\n\nThis is preventing me from moving any of my projects to Redux as I rely on\na HAML-ish DSL that works perfectly fine in regular coffeescript...\nSample:\nMyView = View.extend\n  render: (_)->\n    _ '.aDiv',\n      _ '.aNestedDiv', 'some text'\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/83#issuecomment-14677572\n.\n. Thanks -- I could have sworn I looked at help first.\n. > The + operator should never be used for string concatenation in\nCoffeeScript.\n\nI'm curious as to why?\nOn Wed, Dec 12, 2012 at 6:47 AM, Michael Ficarra\nnotifications@github.comwrote:\n\nAlright, other than those issues, LGTM.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/107#issuecomment-11291397.\n. Thanks.\n\nOn Wed, Dec 12, 2012 at 10:56 AM, Michael Ficarra\nnotifications@github.comwrote:\n\n@mark-hahn https://github.com/mark-hahn: string interpolation expresses\nyour intent more clearly. You intend to join strings, not do addition. It\nalso makes sure you don't accidentally do addition. JS using the same\noperator for two different operations was a mistake.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/107#issuecomment-11302773.\n. > The problem with languages without specs, and a single implementation is\nthat \"bugs\" are spec.\n\nThat's not true.  If the coffeescript (not redux) issues page has listed a\nbug as a bug, then it is a bug, not a spec.  Everything else is a desired\nspec'd feature.  Doing any other way makes redux a new fork, which is not\nanything anybody wants.\nAny time someone gets the idea that a feature in coffeescript should not be\nin redux, then a bug should be posted in the coffeescript issues forum to\ngive the community a chance to comment, especially Jeremy.\nOn Thu, Jan 3, 2013 at 12:59 PM, Arelius notifications@github.com wrote:\n\nI see that writing spec to duplicate existing \"bugs\" is a pretty weird\naffair to begin with.\nThe problem with languages without specs, and a single implementation is\nthat \"bugs\" are spec. And fixing bugs isn't just fixing bugs, but it's\nrather changing spec.\nNot that changing spec is inherently net-bad but it's definitely bad by\ndefault.\nit simply is a matter of \"does it compile in coffee\"... it does? then it\nmust compile in redux.\nI don't think we need to go quite to that extreme, I think for instance\nif it's a bug that manifests in poorly defined circumstances, that are\nunlikely to be used purposefully in existing code, it may warrant getting\nfixed. Weird dedent behavior described in this bughttps://github.com/jashkenas/coffee-script/issues/1275is a likely candidate for instance, unless you can argue that some sane\npeople rely on that behavior.\nPerhaps assembling a list of test cases for what's currently not compiling\nwould be a good start. This list could be in itself a spec.\nThat would work as a start for me, I'll begin with:\nidentity = ->\n    matrix = [1, 0, 0, 0,\n              0, 1, 0, 0,\n              0, 0, 1, 0,\n              0, 0, 0, 1]\nWhich compiles in Coffee, but not Redux. And I'd argue that that's both\nsane and well-specified code, and even if not the preferred style of\n@michaelficarra https://github.com/michaelficarra should still be\nsupported in Redux.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/119#issuecomment-11860508.\n. super will be supported by 2.0, right?\n\nOn Thu, Jan 3, 2013 at 12:39 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@Ciantic https://github.com/Ciantic: As I said above, I need to update\nthe README and the wiki. If you need it in short order, please open a pull\nrequest.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/125#issuecomment-11859819.\n. Sorry, I'm just paranoid.\n\nI must be one of the fud promoters that are such a thorn in your side.\n Sorry about that.  I just have a lot invested in coffeescript, as a user.\n I know that doesn't count for much compared to people that have invested\neffort into CS itself, but I'm a selfish person.\nOn Thu, Jan 3, 2013 at 1:38 PM, Michael Ficarra notifications@github.comwrote:\n\nOf course.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/125#issuecomment-11862016.\n. I started a thread about the relative position of CS and CS-Redux here ...\n\nhttps://groups.google.com/d/msg/coffeescript/N9HS6yN2iDc/5BYmXCiyQ8EJ\n@michaelficarra https://github.com/michaelficarra and\n@jashkenashttps://github.com/jashkenas\n participated.\nOn Sat, Jan 26, 2013 at 7:40 PM, Travis Tilley notifications@github.comwrote:\n\n@mehcode https://github.com/mehcode - That's a good point, a perfectly\nvalid concern, and stated with exactly the right kind of perspective. If\nonly half of the issue comments on my own projects were so clear. ;)\n@michaelficarra https://github.com/michaelficarra @jashkenashttps://github.com/jashkenas- What\nare your thoughts, generally speaking, regarding the abovehttps://github.com/michaelficarra/CoffeeScriptRedux/issues/125#12745032?\n@mehcode https://github.com/mehcode - If I can offer encouragement in\nthe form of beer or what have you, please let me know. ;)\nPersonally, at least in terms of ruby, i've made small contributions to\nmultiple implementations over the years. It's something I can see myself\ndedicating time to purely out of moment-of-zen-amidst-the-chaos purposes\n(don't ask... I haven't had a lot of free time lately either...).\nPerhaps it's time to learn PEG.js...\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/125#issuecomment-12747117.\n. > foo = function foo$() {\n\nI thought jeremy vetoed this because it didn't work in IE.\n. I hope I don't have to try to find something in coffeescript issues,\nbecause that is impossible.  But I distinctly remember foo = function\nfoo$() { being vetoed. I know for a fact it doesn't work in old IE.\nOn Sun, Dec 30, 2012 at 4:30 PM, Nami-Doc notifications@github.com wrote:\n\nHe veoted function foo(){}\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/131#issuecomment-11770659.\n. Sorry.  I somehow missed the beginning of this thread.\n. I think it is impossible to use a return value after the return has\nhappened.  There is no more code running.  That example would return 1 and\ndo nothing else.\n\nOr is this a valentine's day joke?\nOn Thu, Feb 14, 2013 at 4:09 AM, Jinzhu notifications@github.com wrote:\n\nCan't compile below sample file. will throw \"expr: Cannot use a\nReturnStatement as a value\"\nConfirmed with latest git and beta 2.\na = ->\n  return i for i in [1..3]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/168.\n. You message subject is misleading.  You don't want it to return a value,\nyou just want to be able to use the return.  I was scratching my head as to\nwhat you meant, especially with the 1..3 example.\n\nI understand your use case which I have used before.  I would never use\nthat one-liner though.  It looks like an entry in an obfuscation contest.\nOn Thu, Feb 14, 2013 at 10:17 AM, Demian notifications@github.com wrote:\n\n@mark-hahn https://github.com/mark-hahn It's not a valentine's day\njoke, i fear. The code should is equivalent to:\na = ->\n  for i in [1..3]\n    return i\nWhich looks more like a reasonable usage and (fortunately, i think) raises\nthe same compilation error in Redux.\nA valid usage could be finding an element in an array:\nfindBy = (array, fn) ->\n  for x in array\n    return x if fn x\nWhich, written as a one-liner should be:\nfindBy = (array, fn) -> return x for x in array when fn x\nAnd before anyone says \"but you shouldn't write that as a one liner\", i\nagree, but it currently works on CoffeeScript 1.4 and apparently people\nrely on those for one-liners with early returns [image: :anguished:]http://stackoverflow.com/questions/14831462/can-this-statement-be-written-in-one-line\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/168#issuecomment-13569982.\n. >  you were doing it wrong.\n\nIn your opinion.  The way it is now it will break code for no reason.  I\npersonally believe carrying this over from CS is harmless.\nOn Mon, Mar 4, 2013 at 1:29 PM, Michael Ficarra notifications@github.comwrote:\n\nAh, I see how that could happen. My editor actually points out trailing\nsemicolons in bright red. Well, good luck with commonjs-everywhere!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/174#issuecomment-14406776\n.\n. > not very sure if jsPerf results are that reliable.\n\nWhy?  It simply runs the code in the browser which is just V8.\nOn Sat, Mar 9, 2013 at 11:11 AM, Demian Ferreiro\nnotifications@github.comwrote:\n\nWell, i thought that adding more cases would start favouring the switchcase (maybe browsers would use some hash table optimization for big\nswitches). It does close the gap a fair bit in Firefox though:\nhttp://jsperf.com/iife-switch-vs-ternary/3. I am, however, not very sure\nif jsPerf results are that reliable.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/177#issuecomment-14668660\n.\n. OK.  I thought you meant the site, not the code used for the test.\n\nOn Sat, Mar 9, 2013 at 11:25 AM, Demian Ferreiro\nnotifications@github.comwrote:\n\n(off-topic, let's keep this side-discussion short, @mark-hahnhttps://github.com/mark-hahn\n)\nWhy? It simply runs the code in the browser which is just V8.\nBecause the sample code is very artificial. In this case, the code does\nabsolutely nothing, so a good compiler could optimize one entire test case,\nor part of it, to a no-op, thus making that test case much \"faster\" than\nthe other one, but not telling anything at all about which approach would\nrun better for real code.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/177#issuecomment-14668886\n.\n. > I personally don't find it very fitting for switches that don't have\ndefault fall-through.\n\nYou are in a minority.  No modern languages allow this.  You can, and\nshould, break the common functionality into a separate function.\nOn Sun, Mar 17, 2013 at 8:45 PM, Demian Ferreiro\nnotifications@github.comwrote:\n\nDammit, break! May i ask: was the decision to support breaks inside switchstatements deliberate? I personally don't find it very fitting for switches\nthat don't have default fall-through.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/177#issuecomment-15037950\n.\n. > Bare-@ were removed.\n\nYet one more incompatibility with CS.  It's gonna be hard to get people to\nswitch if it's not the same language.\nOn Sat, Dec 14, 2013 at 8:36 AM, Hendrik Helwich\nnotifications@github.comwrote:\n\nThank you for the quick answer and the infos! I will switch to thisinstead of standalone\n@\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/265#issuecomment-30579919\n.\n. My mistake.  I interpreted this thread as saying that \"Bare-@ were removed.\"\n\nI apologize.\nOn Sat, Dec 14, 2013 at 10:15 AM, Michael Ficarra\nnotifications@github.comwrote:\n\n@mark-hahn https://github.com/mark-hahn: Stop trolling. It was removed\nfor a short while, but added back solely for compatibility with legacy\ncode. It is still officially discouraged, but not an incompatibility. If\nyou're going to participate, please read the full conversation first.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/265#issuecomment-30582408\n.\n. Awesome.  How does one use this?  Are we supposed to run escodegen with\nsome output of the CS compiler?\n\nOn Wed, Sep 5, 2012 at 12:25 PM, Michael Ficarra notifications@github.com\nwrote:\n\n@TobiaszCudnik: Source map support is completed. See\nconstellation/escodegen#50.\n\u2014\nReply to this email directly or view it on GitHub.\n. What is GitHub live update?  That is impossible to google.\n\nOn Thu, Sep 6, 2012 at 6:46 AM, Stan Angeloff notifications@github.comwrote:\n\n@michaelficarra https://github.com/michaelficarra: Too bad I can't do\nmuch more at the moment, e.g., send pull's, but hope bug reports are\nequally as good at this stage in the project.\nEDIT: wow, GitHub live update just closed this issue, neat!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/39#issuecomment-8332570.\n. > you shouldn't be allowed to perform an assignment within a higher-precedence operation like a do expression.\n\nI guess it could be do (func = ->) but then I'd have to put a paren at the end of the func definition which would be a pain in the butt.  This is a very common use case.  I've used it hundreds of times.\nI was really hoping redux would be backwards compatible.  I've got around 40,000 lines of coffescript and it would be nice if I didn't have to support 1.x and 2.x at the same time for different projects.  But that is my selfishness.  Do what is right for the community.\n. Now that I think about it, if I had to use do (func = ->) I wouldn't use do any more.  It would be cleaner to do \nfunc = ->\nfunc()\nwhich is less expressive than the old way.  Couldn't you just make do low-precedence?  Your and or example has a clear precedence but why does do have to be high-precedence?\n. >  it might be for auto-invoking recursive functions that need a reference to themselves inside the definition;\nExactly.  Here is the code that gave the error, minus a bunch of snipping.  Note the nesting and how messy it would be if = were forced to low precedence ...\n```\ndo doOneDir = ->\n    if not (dir = dirsPending.shift()) \n        dirsPending = ['/ri', '/rip']\n        doOneDir()\n        return\nfs.readdir dir, (err, files) ->\n    do doOneFile = ->\n        if not (file = files.shift()) then doOneDir(); return\n\n        filePath = path.join dir, file\n        process filePath, doOneFile\n\n```\n@michaelficarra  Please don't take this away from me.  I really like @epidemian's idea of changing the precedence of = when the left side isn't legal.\nCoffescript is very pragmatic.  Making it less useful for the sake of syntactic \"purity\" would be a big loss to the language.\n. >  So an \"invalid indentation\" can be also an unsupported block comment.\nI've always thought that if you indent to the right more than one tab it\nshould be automatic line continuation.\nOn Mon, Sep 10, 2012 at 11:36 AM, Jan Philipp notifications@github.comwrote:\n\nFor the records: I got it. I found in the issues / wiki that the block\ncomment won't work. Indeed, after some regex magic it works.\nSo an \"invalid indentation\" can be also an unsupported block comment.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/44#issuecomment-8433313.\n. I think you need to show a better example.  Not only would that example give a run-time error but I can't think of why anyone would code something so wrong.\n. Putting a comma in the front of a line is the standard way to ensure it\nis treated as a new argument.  You can't pull that.\n\nFWIW, I'm a bit concerned that redux is pulling a lot of useful features\nwhen it was supposed to be compatible.\nOn Tue, Sep 18, 2012 at 3:50 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@connec https://github.com/connec: You've got it. I would run screaming\nfrom code written like that.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/45#issuecomment-8673599.\n. >  I am not duplicating quirks.\n\nOne man's meat is another man's poison.  And it isn't just quirks.\n Requiring parens where they weren't needed before is taking the language\nbackwards, not matter how quirky it is.  If you do that you are not going\nto be very popular.  Sorry if this comes across as harsh.\nBTW, some of these issues fall under the category of line continuations.\n Line continuations are and always have been really screwed up in CS.  I\ncan find a blog for you that lists many of the problems.  I have had to\nresort to just using \\ at the end of the line for almost every continuation.\nI'm not suggesting a continuation fix, just stating the problem.\nOn Tue, Sep 18, 2012 at 4:11 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@mark-hahn https://github.com/mark-hahn: That is also a concern of\nmine. I really do not want this compiler to change the CoffeeScript\nlanguage or break our users' production CoffeeScript code. But there has to\nbe a line we draw between intentional features and quirks. I am not\nduplicating quirks. The original compiler was very, very permissive,\nallowing unintentional and inconsistent syntax.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/45#issuecomment-8674046.\n. +1  It would be a step backwards to lose this construct.\n\nOn Sun, Dec 16, 2012 at 2:46 AM, Arelius notifications@github.com wrote:\n\n$('').css 'color': 'blue' 'text-decoration': 'underline' .appendTo\n'body'\n. >  this arguably \"bad\" syntax constructs.\n\nIt may be arguable but I'd take the side of the argument saying it is a\nvery \"good\" construct.  I find it very readable and noise-free.\nOn Wed, Dec 19, 2012 at 8:23 AM, Demian notifications@github.com wrote:\n\nitems\n  .map (item) ->\n    item.price * item.quantity\n  .reduce (x, y) ->\n    x + y\n. I can't image thinking that adding more noise makes it more readable.\n\nOn Mon, Sep 17, 2012 at 12:55 PM, Christopher Pappas \nnotifications@github.com wrote:\n\nTotally understood.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/47#issuecomment-8628541.\n. Backticks have to pass everything through unchanged.  That is their purpose\nin life.\n\nI use var x; constantly to fix the scope problem.  They are also needed\nto use tamejs.\nOn Sat, Oct 13, 2012 at 7:52 PM, Greg Weber notifications@github.comwrote:\n\nI don't understand the second example code, do you think that is correct?\nThe current coffeescript compiler bails on some of these things.\necho 'f = (a) -> a + 5' | coffee -b -sError: Parse error on line 1: Unexpected 'JS'\nBut I have never seen the current coffee compiler generate eval: I am not\nsure what the point of that is. Backticks in the existing implementation\nare just supposed to pass through: that is what I expected.\nThis is an easy way to improve upon the existing coffee compiler: have\nbackticks to be parseable in all circumstances and do a simple pass\nthrough. I use backticks on occasion, mostly for multi-line JSON literals\nright now. What I am trying to do now is add support for types via\ntypescript:\nhttp://stackoverflow.com/questions/12874942/adding-typescript-to-coffeescript\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9415391.\n. This is yet one more CS feature being thrown out in 2.0.  My production\ncode will not be able to use 2.0 and I'm reluctant to use 2.0 in future\nprojects.\n\nOn Sun, Oct 14, 2012 at 10:49 AM, Greg Weber notifications@github.comwrote:\n\nlooking at the source, it seems we need either a new JS node type that\nrepresent opaque JS, or we need to have a JS parser that can take apart the\nJS.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9423599.\n. > Yes, but it's also the only way to define proper semantics for the JS\nliteral.\n\nThe backtick is not supposed to define semantics.  It is a kludge to allow\none to pass through unmodified text.  Nothing more, nothing less.\n\nIt is inconvenient at all to use backticks and there is no need to use\nthem.\n\nIf you read the entire thread you would see two valid uses.  I'll repeat\nthem here ...\n\"I use `var x;` to fix the scope problem.  They are also needed to use\ntamejs\".\nI have also used them as a kludge for debugging.\nOn Sun, Oct 14, 2012 at 12:21 PM, Michael Ficarra\nnotifications@github.comwrote:\n\nusing var gives no output\nSorry about that, a JS node was being assumed to have no side effects. The\nassumption should be the other way around. I will fix this.\nit is convenient for your implementation to wrap the javascript in an eval\nYes, but it's also the only way to define proper semantics for the JS\nliteral. If it was allowed to contain arbitrary character data, its\nsemantics would rely on implementation details that could change in the\nfuture. The completion value of a javascript program is well-defined, and\nthat will be the value of a JS literal.\nI still don't understand how the generated javascript in the second\nexample is supposed to be ok.\nMaybe it would help if you looked at the parse tree. I've cut out the\nsource information for clarity.\n$ echo 'f = (a) -> a + 5' |  bin/coffee --parse\n{ type: 'Program',\n  body:\n   { type: 'AssignOp',\n     assignee:\n      { type: 'Identifier',\n        data: 'f' },\n     expression:\n      { type: 'FunctionApplication',\n        function:\n         { type: 'JavaScript',\n           data: 'a' },\n        arguments:\n         [ { type: 'Function',\n             parameters: [],\n             body:\n              { type: 'PlusOp',\n                left:\n                 { type: 'Identifier',\n                   data: 'a' },\n                right:\n                 { type: 'Int',\n                   data: 5 } } } ] } } }\nwe need to have a JS parser that can take apart the JS\nThat was an option that we considered, but it would require us to depend\nupon a JS parser for a feature that is highly discouraged and completely\nunnecessary. The tradeoff is not worth it when eval does at runtime what\nthe parser would be doing at compile time.\nThis is yet one more CS feature being thrown out in 2.0.\nNot thrown out, fixed. It was broken. It allowed the user to provide a\nprogram that would cause the compiler to output invalid programs. It didn't\nhave a properly-defined semantics, or any defined semantics at all. That is\nunacceptable. This has standardised it.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9424676.\n. @Michael\n\nYou are claiming to be backwards compatible with CS but you are making\ndecisions to change CS without the approval of the community.  This is a\nrecipe for disaster.\nYou keep talking about 'fixing\" things that aren't broken.  How do you get\nto be the arbiter of what's broken?\nNormally I would not bitch about disagreements with an author of a project.\n But I fear this will replace the old CS and everyone will be stuck with\nyour unilateral decisions.\nOn Sun, Oct 14, 2012 at 12:40 PM, Mark Hahn mark@hahnca.com wrote:\n\n\nYes, but it's also the only way to define proper semantics for the JS\nliteral.\n\nThe backtick is not supposed to define semantics.  It is a kludge to allow\none to pass through unmodified text.  Nothing more, nothing less.\n\nIt is inconvenient at all to use backticks and there is no need to use\nthem.\n\nIf you read the entire thread you would see two valid uses.  I'll repeat\nthem here ...\n\"I use `var x;` to fix the scope problem.  They are also needed to\nuse tamejs\".\nI have also used them as a kludge for debugging.\nOn Sun, Oct 14, 2012 at 12:21 PM, Michael Ficarra \nnotifications@github.com wrote:\n\nusing var gives no output\nSorry about that, a JS node was being assumed to have no side effects.\nThe assumption should be the other way around. I will fix this.\nit is convenient for your implementation to wrap the javascript in an eval\nYes, but it's also the only way to define proper semantics for the JS\nliteral. If it was allowed to contain arbitrary character data, its\nsemantics would rely on implementation details that could change in the\nfuture. The completion value of a javascript program is well-defined, and\nthat will be the value of a JS literal.\nI still don't understand how the generated javascript in the second\nexample is supposed to be ok.\nMaybe it would help if you looked at the parse tree. I've cut out the\nsource information for clarity.\n$ echo 'f = (a) -> a + 5' |  bin/coffee --parse\n{ type: 'Program',\n  body:\n   { type: 'AssignOp',\n     assignee:\n      { type: 'Identifier',\n        data: 'f' },\n     expression:\n      { type: 'FunctionApplication',\n        function:\n         { type: 'JavaScript',\n           data: 'a' },\n        arguments:\n         [ { type: 'Function',\n             parameters: [],\n             body:\n              { type: 'PlusOp',\n                left:\n                 { type: 'Identifier',\n                   data: 'a' },\n                right:\n                 { type: 'Int',\n                   data: 5 } } } ] } } }\nwe need to have a JS parser that can take apart the JS\nThat was an option that we considered, but it would require us to depend\nupon a JS parser for a feature that is highly discouraged and completely\nunnecessary. The tradeoff is not worth it when eval does at runtime what\nthe parser would be doing at compile time.\nThis is yet one more CS feature being thrown out in 2.0.\nNot thrown out, fixed. It was broken. It allowed the user to provide a\nprogram that would cause the compiler to output invalid programs. It didn't\nhave a properly-defined semantics, or any defined semantics at all. That is\nunacceptable. This has standardised it.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9424676.\n. I appreciate your attention.\n\nJS literals were always a hack\n\nMaybe, but a necessary one.  TameJS won't work without them.\n\nyour scoping hack\n\nIt is interesting that you want to fix all the \"broken\" parts of javascript\nbut you call fixing the biggest problem in CS a hack.  Many people,\nincluding several on the front page of HN, feel this way about the scoping.\n The current lack of local scoping is constantly being defended, for\nreasons I don't understand.\n\nThese cases are extraordinary\n\nI would really like to know how many users would agree with you.  At what\npoint will the community get a say in this?  I saw that the BDFL agreed\nthat non parenthesized assignments on the RHS of boolean operators was not\nbug, but you continue to call it that.\nOn Sun, Oct 14, 2012 at 1:37 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@mark-hahn https://github.com/mark-hahn: Preserving the semantics of\nCoffeeScript was the most important factor influencing development. It is\nnot my intention to change CoffeeScript; I have my own fork for that. I\npersonally disagree with some of the language features I implemented, but I\nfaithfully implemented them. JS literals were always a hack. If they\nweren't being abused to do something crazy like try to change CoffeeScript\nsemantics (such as with your scoping hack), my implementation should cause\nno problems. Allowing unparenthesised assignments on the RHS of boolean\noperators, as in your other issue, was a bug that people were (some\nintentionally, some unintentionally) abusing. These cases are\nextraordinary, and not indicative of the support for code you will see in\nwell-written CoffeeScript programs.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9426638.\n. > I don't like the tone this ticket has taken\n\nI apologize for hijacking this discussion.  I was just shocked to see the\nremoval of back-tick functionality.\nOn Sun, Oct 14, 2012 at 3:07 PM, Greg Weber notifications@github.comwrote:\n\nI don't like the tone this ticket has taken. I disagree with the decision\nto use eval, but I understand it avoids a more complex implementation.\nHowever, I opened this ticket giving an example of bizarrely generated\ncode. The parse tree doesn't make sense just as the generated javascript\ndoesn't make sense and generates invalid javascript by hoisting an\nexpression out of its current location as a function argument and treating\nit as a function.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9428407.\n. > This is kinda off-topic, but...\n\nScoping has been discussed at great length before and will be in the\nfuture.  There is no need to discuss it here.\nOn Sun, Oct 14, 2012 at 4:09 PM, Demian notifications@github.com wrote:\n\nQuite an interesting discussion. Not so much for the usefulness of the\ntopic being discussed, but for how an undefined behaviour of the language\ncan cause so much trouble.\nI do agree that letting JS literals anywhere would be very broken (and\nprobably impossible/extremely difficult from the CS parser perspective).\nRestricting the backticks to be used only as expressions seems like a\nreasonable requirement to me.\nThe case of a = (<some JS>) -> b is quite an unfortunate one. It took\nme quite a while to understand that Redux was interpreting is as (lispy\nAST:) (assignment 'a' (application '' (function () 'b'))). That\nwas quite an unexpected behaviour to me. Once i figured out that Redux was\nadmitting things like a = (b + c) -> d (which interprets as a = (b +\nc)(-> d)) it became more evident what was happening, but i still think\nthat's not a very happy behaviour and i'd prefer it to be an error, like in\nthe original compiler.\nAbout the need for eval, i'm not sure i fully understand it. Is it\nbecause escodegen expects a nice AST and therefore you give it something\nlike (application 'eval' '')? If that's the case then\nyes, it's unfortunate. It would be nice for escodegen to admit a raw input\nleaf node as \"just trust that what comes here is a valid expression\" or\nsome other way including raw input. A very hacky way of bypassing\nescodegen would be to give it an AST like (application 'inlineMe'\n'' 'end'), which would generate the valid JS code: inlineMe('', 'end'), and then do a replacement of /inlineMe('(.*)',\n'end')/g with the first capturing group. Yes, a horrendous hack, but\nprobably better than including a JS parser just for the sake of backticks.\nWhat do you think? :)\nThis is kinda off-topic, but...\nIt is interesting that you want to fix all the \"broken\" parts of\njavascript but you call fixing the biggest problem in CS a hack. Many\npeople, including several on the front page of HN, feel this way about the\nscoping. The current lack of local scoping is constantly being defended,\nfor reasons I don't understand.\nI think you're referring to lexical scoping, which CS does have. I'm\npositive @jashkenas https://github.com/jashkenas clarified that in a HN\nthread. An example of how CS would behave if it had dynamic scopinghttp://en.wikipedia.org/wiki/Lexical_scoping#Lexical_scoping_and_dynamic_scoping\n:\nfoo = ->\n  alert a\nbar = ->\n  a = 5\n  foo() # With dinamic scoping this would work, and would alert 5.\n        # With lexical scoping this causes en error, as 'a' is not defined in the scope of foo.\n\nThese cases are extraordinary\nI would really like to know how many users would agree with you. At what\npoint will the community get a say in this?\nI'd say that the need for backticks at all it quite extraordinary. I\npersonally wouldn't miss them if they are completely removed at some point.\nBut that's just me, i'd also like to know what others think about this =D\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/71#issuecomment-9429030.\n. +100 for anything like this that makes line-continuations easier to use,\nsimpler, and sane.  The CS line-continuation rules are a mish-mash at the\nmoment and not very friendly and not documented.  I've given up and mostly\nuse backslashes at the end of lines (so ugly!).\n\nOn Sat, Mar 9, 2013 at 11:15 PM, Peter Wong notifications@github.comwrote:\n\nThis is preventing me from moving any of my projects to Redux as I rely on\na HAML-ish DSL that works perfectly fine in regular coffeescript...\nSample:\nMyView = View.extend\n  render: (_)->\n    _ '.aDiv',\n      _ '.aNestedDiv', 'some text'\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/83#issuecomment-14677572\n.\n. Thanks -- I could have sworn I looked at help first.\n. > The + operator should never be used for string concatenation in\nCoffeeScript.\n\nI'm curious as to why?\nOn Wed, Dec 12, 2012 at 6:47 AM, Michael Ficarra\nnotifications@github.comwrote:\n\nAlright, other than those issues, LGTM.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/107#issuecomment-11291397.\n. Thanks.\n\nOn Wed, Dec 12, 2012 at 10:56 AM, Michael Ficarra\nnotifications@github.comwrote:\n\n@mark-hahn https://github.com/mark-hahn: string interpolation expresses\nyour intent more clearly. You intend to join strings, not do addition. It\nalso makes sure you don't accidentally do addition. JS using the same\noperator for two different operations was a mistake.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/107#issuecomment-11302773.\n. > The problem with languages without specs, and a single implementation is\nthat \"bugs\" are spec.\n\nThat's not true.  If the coffeescript (not redux) issues page has listed a\nbug as a bug, then it is a bug, not a spec.  Everything else is a desired\nspec'd feature.  Doing any other way makes redux a new fork, which is not\nanything anybody wants.\nAny time someone gets the idea that a feature in coffeescript should not be\nin redux, then a bug should be posted in the coffeescript issues forum to\ngive the community a chance to comment, especially Jeremy.\nOn Thu, Jan 3, 2013 at 12:59 PM, Arelius notifications@github.com wrote:\n\nI see that writing spec to duplicate existing \"bugs\" is a pretty weird\naffair to begin with.\nThe problem with languages without specs, and a single implementation is\nthat \"bugs\" are spec. And fixing bugs isn't just fixing bugs, but it's\nrather changing spec.\nNot that changing spec is inherently net-bad but it's definitely bad by\ndefault.\nit simply is a matter of \"does it compile in coffee\"... it does? then it\nmust compile in redux.\nI don't think we need to go quite to that extreme, I think for instance\nif it's a bug that manifests in poorly defined circumstances, that are\nunlikely to be used purposefully in existing code, it may warrant getting\nfixed. Weird dedent behavior described in this bughttps://github.com/jashkenas/coffee-script/issues/1275is a likely candidate for instance, unless you can argue that some sane\npeople rely on that behavior.\nPerhaps assembling a list of test cases for what's currently not compiling\nwould be a good start. This list could be in itself a spec.\nThat would work as a start for me, I'll begin with:\nidentity = ->\n    matrix = [1, 0, 0, 0,\n              0, 1, 0, 0,\n              0, 0, 1, 0,\n              0, 0, 0, 1]\nWhich compiles in Coffee, but not Redux. And I'd argue that that's both\nsane and well-specified code, and even if not the preferred style of\n@michaelficarra https://github.com/michaelficarra should still be\nsupported in Redux.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/119#issuecomment-11860508.\n. super will be supported by 2.0, right?\n\nOn Thu, Jan 3, 2013 at 12:39 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@Ciantic https://github.com/Ciantic: As I said above, I need to update\nthe README and the wiki. If you need it in short order, please open a pull\nrequest.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/125#issuecomment-11859819.\n. Sorry, I'm just paranoid.\n\nI must be one of the fud promoters that are such a thorn in your side.\n Sorry about that.  I just have a lot invested in coffeescript, as a user.\n I know that doesn't count for much compared to people that have invested\neffort into CS itself, but I'm a selfish person.\nOn Thu, Jan 3, 2013 at 1:38 PM, Michael Ficarra notifications@github.comwrote:\n\nOf course.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/125#issuecomment-11862016.\n. I started a thread about the relative position of CS and CS-Redux here ...\n\nhttps://groups.google.com/d/msg/coffeescript/N9HS6yN2iDc/5BYmXCiyQ8EJ\n@michaelficarra https://github.com/michaelficarra and\n@jashkenashttps://github.com/jashkenas\n participated.\nOn Sat, Jan 26, 2013 at 7:40 PM, Travis Tilley notifications@github.comwrote:\n\n@mehcode https://github.com/mehcode - That's a good point, a perfectly\nvalid concern, and stated with exactly the right kind of perspective. If\nonly half of the issue comments on my own projects were so clear. ;)\n@michaelficarra https://github.com/michaelficarra @jashkenashttps://github.com/jashkenas- What\nare your thoughts, generally speaking, regarding the abovehttps://github.com/michaelficarra/CoffeeScriptRedux/issues/125#12745032?\n@mehcode https://github.com/mehcode - If I can offer encouragement in\nthe form of beer or what have you, please let me know. ;)\nPersonally, at least in terms of ruby, i've made small contributions to\nmultiple implementations over the years. It's something I can see myself\ndedicating time to purely out of moment-of-zen-amidst-the-chaos purposes\n(don't ask... I haven't had a lot of free time lately either...).\nPerhaps it's time to learn PEG.js...\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/125#issuecomment-12747117.\n. > foo = function foo$() {\n\nI thought jeremy vetoed this because it didn't work in IE.\n. I hope I don't have to try to find something in coffeescript issues,\nbecause that is impossible.  But I distinctly remember foo = function\nfoo$() { being vetoed. I know for a fact it doesn't work in old IE.\nOn Sun, Dec 30, 2012 at 4:30 PM, Nami-Doc notifications@github.com wrote:\n\nHe veoted function foo(){}\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/131#issuecomment-11770659.\n. Sorry.  I somehow missed the beginning of this thread.\n. I think it is impossible to use a return value after the return has\nhappened.  There is no more code running.  That example would return 1 and\ndo nothing else.\n\nOr is this a valentine's day joke?\nOn Thu, Feb 14, 2013 at 4:09 AM, Jinzhu notifications@github.com wrote:\n\nCan't compile below sample file. will throw \"expr: Cannot use a\nReturnStatement as a value\"\nConfirmed with latest git and beta 2.\na = ->\n  return i for i in [1..3]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/168.\n. You message subject is misleading.  You don't want it to return a value,\nyou just want to be able to use the return.  I was scratching my head as to\nwhat you meant, especially with the 1..3 example.\n\nI understand your use case which I have used before.  I would never use\nthat one-liner though.  It looks like an entry in an obfuscation contest.\nOn Thu, Feb 14, 2013 at 10:17 AM, Demian notifications@github.com wrote:\n\n@mark-hahn https://github.com/mark-hahn It's not a valentine's day\njoke, i fear. The code should is equivalent to:\na = ->\n  for i in [1..3]\n    return i\nWhich looks more like a reasonable usage and (fortunately, i think) raises\nthe same compilation error in Redux.\nA valid usage could be finding an element in an array:\nfindBy = (array, fn) ->\n  for x in array\n    return x if fn x\nWhich, written as a one-liner should be:\nfindBy = (array, fn) -> return x for x in array when fn x\nAnd before anyone says \"but you shouldn't write that as a one liner\", i\nagree, but it currently works on CoffeeScript 1.4 and apparently people\nrely on those for one-liners with early returns [image: :anguished:]http://stackoverflow.com/questions/14831462/can-this-statement-be-written-in-one-line\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/168#issuecomment-13569982.\n. >  you were doing it wrong.\n\nIn your opinion.  The way it is now it will break code for no reason.  I\npersonally believe carrying this over from CS is harmless.\nOn Mon, Mar 4, 2013 at 1:29 PM, Michael Ficarra notifications@github.comwrote:\n\nAh, I see how that could happen. My editor actually points out trailing\nsemicolons in bright red. Well, good luck with commonjs-everywhere!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/174#issuecomment-14406776\n.\n. > not very sure if jsPerf results are that reliable.\n\nWhy?  It simply runs the code in the browser which is just V8.\nOn Sat, Mar 9, 2013 at 11:11 AM, Demian Ferreiro\nnotifications@github.comwrote:\n\nWell, i thought that adding more cases would start favouring the switchcase (maybe browsers would use some hash table optimization for big\nswitches). It does close the gap a fair bit in Firefox though:\nhttp://jsperf.com/iife-switch-vs-ternary/3. I am, however, not very sure\nif jsPerf results are that reliable.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/177#issuecomment-14668660\n.\n. OK.  I thought you meant the site, not the code used for the test.\n\nOn Sat, Mar 9, 2013 at 11:25 AM, Demian Ferreiro\nnotifications@github.comwrote:\n\n(off-topic, let's keep this side-discussion short, @mark-hahnhttps://github.com/mark-hahn\n)\nWhy? It simply runs the code in the browser which is just V8.\nBecause the sample code is very artificial. In this case, the code does\nabsolutely nothing, so a good compiler could optimize one entire test case,\nor part of it, to a no-op, thus making that test case much \"faster\" than\nthe other one, but not telling anything at all about which approach would\nrun better for real code.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/177#issuecomment-14668886\n.\n. > I personally don't find it very fitting for switches that don't have\ndefault fall-through.\n\nYou are in a minority.  No modern languages allow this.  You can, and\nshould, break the common functionality into a separate function.\nOn Sun, Mar 17, 2013 at 8:45 PM, Demian Ferreiro\nnotifications@github.comwrote:\n\nDammit, break! May i ask: was the decision to support breaks inside switchstatements deliberate? I personally don't find it very fitting for switches\nthat don't have default fall-through.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/177#issuecomment-15037950\n.\n. > Bare-@ were removed.\n\nYet one more incompatibility with CS.  It's gonna be hard to get people to\nswitch if it's not the same language.\nOn Sat, Dec 14, 2013 at 8:36 AM, Hendrik Helwich\nnotifications@github.comwrote:\n\nThank you for the quick answer and the infos! I will switch to thisinstead of standalone\n@\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/265#issuecomment-30579919\n.\n. My mistake.  I interpreted this thread as saying that \"Bare-@ were removed.\"\n\nI apologize.\nOn Sat, Dec 14, 2013 at 10:15 AM, Michael Ficarra\nnotifications@github.comwrote:\n\n@mark-hahn https://github.com/mark-hahn: Stop trolling. It was removed\nfor a short while, but added back solely for compatibility with legacy\ncode. It is still officially discouraged, but not an incompatibility. If\nyou're going to participate, please read the full conversation first.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/265#issuecomment-30582408\n.\n. \n",
    "ryanflorence": "Using your example above, I get this:\n$ ./bin/coffee --source-map -i test.coffee > test.js.map\nError: Cannot find module 'source-map'\n    at Function._resolveFilename (module.js:334:11)\n    at Function._load (module.js:279:25)\n    at Module.require (module.js:357:17)\n    at require (module.js:368:17)\n    at Object.generate (./CoffeeScriptRedux/node_modules/escodegen/escodegen.js:1637:30)\n    at Object.sourceMap (./CoffeeScriptRedux/lib/coffee-script/module.js:111:22)\n    at [object Object].<anonymous> (./CoffeeScriptRedux/lib/coffee-script/command.js:363:31)\n    at [object Object].emit (events.js:64:17)\n    at afterRead (fs.js:1111:12)\n    at Object.wrapper [as oncomplete] (fs.js:254:17)\n. I was on node v0.6.8, updated to v0.6.9, everything worked.  Thanks for looking into it.\n. Thanks.  A couple examples will go a long way in the readme :)\n. Using your example above, I get this:\n$ ./bin/coffee --source-map -i test.coffee > test.js.map\nError: Cannot find module 'source-map'\n    at Function._resolveFilename (module.js:334:11)\n    at Function._load (module.js:279:25)\n    at Module.require (module.js:357:17)\n    at require (module.js:368:17)\n    at Object.generate (./CoffeeScriptRedux/node_modules/escodegen/escodegen.js:1637:30)\n    at Object.sourceMap (./CoffeeScriptRedux/lib/coffee-script/module.js:111:22)\n    at [object Object].<anonymous> (./CoffeeScriptRedux/lib/coffee-script/command.js:363:31)\n    at [object Object].emit (events.js:64:17)\n    at afterRead (fs.js:1111:12)\n    at Object.wrapper [as oncomplete] (fs.js:254:17)\n. I was on node v0.6.8, updated to v0.6.9, everything worked.  Thanks for looking into it.\n. Thanks.  A couple examples will go a long way in the readme :)\n. ",
    "Constellation": "Because escodegen doesn't always require source-map, so I didn't insert source-map to dependencies in escodegen.\nIs it better adding source-map to package.json of escodegen?\n. @michaelficarra:\nLGTM. I've added this to escodegen package.json.\n. I think a guard that checks string is valid as Identifier is needed to\nhttps://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L163\n. I suggest using node-browserify to generate single file.\nIn esmangle project, we generate it by using browserify.\n. >  I can't get it to automatically export CoffeeScript (probably an option I'm missing)\nIn Esmangle, creating entry point JavaScript file tools/entry.js and doing browserify tools/entry.js.\nhttps://github.com/Constellation/esmangle/blob/master/tools/entry.js\nAnd because node-detective uses esprima and static analysis, we can remove dependency to some file by writing\ncoffee\nrunModule = './run'\nrequire runModule\n. If you're interested in getting stractural type tree, doctrine can parse closure-compiler style type annotation.\n. Nice!\n. > Do you mind taking a look at it?\nNo, not at all. Of course I'll take a look at it :) \n. Great!\n. I've investigated it and found that,\ncoffee\ni = if testing\n  test: test\nis tried to parse as,\njs\ni = (testing({\n  test: test\n}) ? <INVALID>\n. Probably, we can fix above simple case with using extendee definition.\nBut, I think this raises problem,\ncoffee\ni = if a is b\n  test: test\nbecomes\njs\ni = a === b({\n  test: test\n}) ? <INVALID>\n. Agreed with your thoughts.\n. OK, I'll see this.\n. JSC works fine with this issue because I fixed it 1.5 years ago :)\nhttps://bugs.webkit.org/show_bug.cgi?id=71572\nAnd patch is prepared for V8.\nhttps://code.google.com/p/v8/issues/detail?id=1813\nSo if you have regexp.source, we can generate valid RegularExperssionLiteral by using this process.\nI'll implement this process on Escodegen.\n. Escodegen version 0.0.21 has released.\nNow Escodegen has own RegExp stringifier.\n. https://bugzilla.mozilla.org/show_bug.cgi?id=866367\nI've created the patch for SpiderMonkey and the review is ongoing.\n. ok stderr.indexOf(\"cli-eval-errors-files/1.coffee:4:6, <js>:6:9)\") > 0 is failed in test/cli-eval-errors.coffee\nAnd stderr is following,\n/Users/yusuke/dev/CoffeeScriptRedux/test/cli-eval-errors-files/0.coffee:4\n  throw new Error('Test Error');\n        ^\nError: Test Error\n  at Object.exports.error (/Users/yusuke/dev/CoffeeScriptRedux/test/cli-eval-errors-files/0.coffee:3:26, <js>:4:9)\n  at Object.<anonymous> (/Users/yusuke/dev/CoffeeScriptRedux/test/cli-eval-errors-files/1.coffee:null:1, <js>:6:9)\n  at Object.<anonymous> (/Users/yusuke/dev/CoffeeScriptRedux/test/cli-eval-errors-files/1.coffee:null:1, <js>:7:3)\n  at Module._compile (module.js:456:26)\n  at runModule (/Users/yusuke/dev/CoffeeScriptRedux/lib/run.js:101:17)\n  at runMain (/Users/yusuke/dev/CoffeeScriptRedux/lib/run.js:94:10)\n  at processInput (/Users/yusuke/dev/CoffeeScriptRedux/lib/command.js:250:7)\n  at /Users/yusuke/dev/CoffeeScriptRedux/lib/command.js:264:16\n  at fs.js:266:14\n  at Object.oncomplete (fs.js:107:15)\n. Yeah! I've fixed it on esmangle 1.0.0.\nI'll submit PR\n. Thank you!\n. Because escodegen doesn't always require source-map, so I didn't insert source-map to dependencies in escodegen.\nIs it better adding source-map to package.json of escodegen?\n. @michaelficarra:\nLGTM. I've added this to escodegen package.json.\n. I think a guard that checks string is valid as Identifier is needed to\nhttps://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L163\n. I suggest using node-browserify to generate single file.\nIn esmangle project, we generate it by using browserify.\n. >  I can't get it to automatically export CoffeeScript (probably an option I'm missing)\nIn Esmangle, creating entry point JavaScript file tools/entry.js and doing browserify tools/entry.js.\nhttps://github.com/Constellation/esmangle/blob/master/tools/entry.js\nAnd because node-detective uses esprima and static analysis, we can remove dependency to some file by writing\ncoffee\nrunModule = './run'\nrequire runModule\n. If you're interested in getting stractural type tree, doctrine can parse closure-compiler style type annotation.\n. Nice!\n. > Do you mind taking a look at it?\nNo, not at all. Of course I'll take a look at it :) \n. Great!\n. I've investigated it and found that,\ncoffee\ni = if testing\n  test: test\nis tried to parse as,\njs\ni = (testing({\n  test: test\n}) ? <INVALID>\n. Probably, we can fix above simple case with using extendee definition.\nBut, I think this raises problem,\ncoffee\ni = if a is b\n  test: test\nbecomes\njs\ni = a === b({\n  test: test\n}) ? <INVALID>\n. Agreed with your thoughts.\n. OK, I'll see this.\n. JSC works fine with this issue because I fixed it 1.5 years ago :)\nhttps://bugs.webkit.org/show_bug.cgi?id=71572\nAnd patch is prepared for V8.\nhttps://code.google.com/p/v8/issues/detail?id=1813\nSo if you have regexp.source, we can generate valid RegularExperssionLiteral by using this process.\nI'll implement this process on Escodegen.\n. Escodegen version 0.0.21 has released.\nNow Escodegen has own RegExp stringifier.\n. https://bugzilla.mozilla.org/show_bug.cgi?id=866367\nI've created the patch for SpiderMonkey and the review is ongoing.\n. ok stderr.indexOf(\"cli-eval-errors-files/1.coffee:4:6, <js>:6:9)\") > 0 is failed in test/cli-eval-errors.coffee\nAnd stderr is following,\n/Users/yusuke/dev/CoffeeScriptRedux/test/cli-eval-errors-files/0.coffee:4\n  throw new Error('Test Error');\n        ^\nError: Test Error\n  at Object.exports.error (/Users/yusuke/dev/CoffeeScriptRedux/test/cli-eval-errors-files/0.coffee:3:26, <js>:4:9)\n  at Object.<anonymous> (/Users/yusuke/dev/CoffeeScriptRedux/test/cli-eval-errors-files/1.coffee:null:1, <js>:6:9)\n  at Object.<anonymous> (/Users/yusuke/dev/CoffeeScriptRedux/test/cli-eval-errors-files/1.coffee:null:1, <js>:7:3)\n  at Module._compile (module.js:456:26)\n  at runModule (/Users/yusuke/dev/CoffeeScriptRedux/lib/run.js:101:17)\n  at runMain (/Users/yusuke/dev/CoffeeScriptRedux/lib/run.js:94:10)\n  at processInput (/Users/yusuke/dev/CoffeeScriptRedux/lib/command.js:250:7)\n  at /Users/yusuke/dev/CoffeeScriptRedux/lib/command.js:264:16\n  at fs.js:266:14\n  at Object.oncomplete (fs.js:107:15)\n. Yeah! I've fixed it on esmangle 1.0.0.\nI'll submit PR\n. Thank you!\n. ",
    "StanAngeloff": "@michaelficarra: Too bad I can't do much more at the moment, i.e., send pull's, but hope bug reports are equally as good at this stage in the project.\nEDIT: wow, GitHub live update just closed this issue, neat!\n. @michaelficarra: Too bad I can't do much more at the moment, i.e., send pull's, but hope bug reports are equally as good at this stage in the project.\nEDIT: wow, GitHub live update just closed this issue, neat!\n. ",
    "mcculloughsean": "You're quick! Thanks Michael! \n. :cake: \n. Can this be implemented without implementing super? \nThe output of the above coffeescript is \njavascript\n// Generated by CoffeeScript 2.0.0-beta7-dev\nvoid function () {\n  var Bar, Foo;\n  Foo = function () {\n    function Foo() {\n    }\n    ;\n    return Foo;\n  }();\n  Bar = function (super$) {\n    extends$(Bar, super$);\n    function Bar() {\n    }\n    ;\n    return Bar;\n  }(Foo);\n  function isOwn$(o, p) {\n    return {}.hasOwnProperty.call(o, p);\n  }\n  function extends$(child, parent) {\n    for (var key in parent)\n      if (isOwn$(parent, key))\n        child[key] = parent[key];\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor;\n    child.__super__ = parent.prototype;\n    return child;\n  }\n}.call(this);\nI think it's simple enough to implement a feature where if the constructor of a subclass isn't defined, apply the super constructor. E.g:\n// -- snip -- \n  Bar = function (super$) {\n    extends$(Bar, super$);\n    function Bar() {\n      // -- FIX if the constructor isn't explicitly defined\n      super$.apply(this, arguments); \n    }\n    ;\n    return Bar;\n  }(Foo);\n// -- snip --\n. Sure thing.\n. You're quick! Thanks Michael! \n. :cake: \n. Can this be implemented without implementing super? \nThe output of the above coffeescript is \njavascript\n// Generated by CoffeeScript 2.0.0-beta7-dev\nvoid function () {\n  var Bar, Foo;\n  Foo = function () {\n    function Foo() {\n    }\n    ;\n    return Foo;\n  }();\n  Bar = function (super$) {\n    extends$(Bar, super$);\n    function Bar() {\n    }\n    ;\n    return Bar;\n  }(Foo);\n  function isOwn$(o, p) {\n    return {}.hasOwnProperty.call(o, p);\n  }\n  function extends$(child, parent) {\n    for (var key in parent)\n      if (isOwn$(parent, key))\n        child[key] = parent[key];\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor;\n    child.__super__ = parent.prototype;\n    return child;\n  }\n}.call(this);\nI think it's simple enough to implement a feature where if the constructor of a subclass isn't defined, apply the super constructor. E.g:\n// -- snip -- \n  Bar = function (super$) {\n    extends$(Bar, super$);\n    function Bar() {\n      // -- FIX if the constructor isn't explicitly defined\n      super$.apply(this, arguments); \n    }\n    ;\n    return Bar;\n  }(Foo);\n// -- snip --\n. Sure thing.\n. ",
    "osuushi": "I've also been wondering about this and looking through the code for answers. Even though the docs say that \"it's not recommended for serious use\", the <script type=\"text/coffeescript\"> feature of the original compiler is a lifesaver during development, especially when using a web host with no server side JS capabilities.\n. I've also been wondering about this and looking through the code for answers. Even though the docs say that \"it's not recommended for serious use\", the <script type=\"text/coffeescript\"> feature of the original compiler is a lifesaver during development, especially when using a web host with no server side JS capabilities.\n. ",
    "gkz": "I'm also wondering about this (I'd like to get a browser version of coffee2ls running) - but as well, this seems necessary if replacing CS 1.x is desired.\n. I'm getting the same error - looks like something to do with super, as changing super(arguments...) to xsuper(arguments...) leads it to compile without issue. \n. @mark-hahn, if you are are using \n`var x`\nconstantly, you might want to check out LiveScript:\n```\nx = 10\ndo ->\n  x = 5\nx #=> 10\ndo ->\n  x := 2\nx #=> 2\n``\n. @epidemian regarding scoping, he is referring to the fact that you can't shadow variables.\n. The other work to the parser I've done so far is parsesuper` - but I don't know if you want me to send a pull request with that, as only parsing is implemented (all I'm interested in), and not actual JS compilation. \nIf you want to take a look at what things need to be completed before the parser is good to go, grep REDUX in coffee2ls/test\n. try with --no-optimise\n. Ah yes, will update\n. I can hear my sergeant yelling \"Attention to detail! Attention to detail!\"\nThere are 2 main things blocking me currently:\n- whitespace in the middle of chains\n- implicit object literals as arguments\nI'm on #livescript and #coffeescript if you can talk at any point. \n. I said it in a joking way :-p\n. If you see the diffs you'll see this change makes several tests pass\n. The CLI is not the same as CSv1\nUse -i to specify the file.\nUse -j to compile to JavaScript. \nSee\nbin/coffee --help\n. LiveScript and Coco can't be sublangauges as they significantly change semantics in some areas (eg. variable shadowing), and thus need to be separate languages.\n. I'm also wondering about this (I'd like to get a browser version of coffee2ls running) - but as well, this seems necessary if replacing CS 1.x is desired.\n. I'm getting the same error - looks like something to do with super, as changing super(arguments...) to xsuper(arguments...) leads it to compile without issue. \n. @mark-hahn, if you are are using \n`var x`\nconstantly, you might want to check out LiveScript:\n```\nx = 10\ndo ->\n  x = 5\nx #=> 10\ndo ->\n  x := 2\nx #=> 2\n``\n. @epidemian regarding scoping, he is referring to the fact that you can't shadow variables.\n. The other work to the parser I've done so far is parsesuper` - but I don't know if you want me to send a pull request with that, as only parsing is implemented (all I'm interested in), and not actual JS compilation. \nIf you want to take a look at what things need to be completed before the parser is good to go, grep REDUX in coffee2ls/test\n. try with --no-optimise\n. Ah yes, will update\n. I can hear my sergeant yelling \"Attention to detail! Attention to detail!\"\nThere are 2 main things blocking me currently:\n- whitespace in the middle of chains\n- implicit object literals as arguments\nI'm on #livescript and #coffeescript if you can talk at any point. \n. I said it in a joking way :-p\n. If you see the diffs you'll see this change makes several tests pass\n. The CLI is not the same as CSv1\nUse -i to specify the file.\nUse -j to compile to JavaScript. \nSee\nbin/coffee --help\n. LiveScript and Coco can't be sublangauges as they significantly change semantics in some areas (eg. variable shadowing), and thus need to be separate languages.\n. ",
    "samwgoldman": "I managed to use browserify to create a single file. I had to manually edit the original coffeescript in a few places and I had to rip out amdrequire stuff, which I think comes in from source-map.\nAnyway, here it is: https://gist.github.com/4005706\nI managed to get a simple script (\"four = 2 + 2\") to parse, compile, and output as javascript and source map. I didn't check that the source map was valid.\nI'm not a javascript person, so I felt like a dog at the keyboard for most of this process. Hopefully this is helpful.\n. I managed to use browserify to create a single file. I had to manually edit the original coffeescript in a few places and I had to rip out amdrequire stuff, which I think comes in from source-map.\nAnyway, here it is: https://gist.github.com/4005706\nI managed to get a simple script (\"four = 2 + 2\") to parse, compile, and output as javascript and source map. I didn't check that the source map was valid.\nI'm not a javascript person, so I felt like a dog at the keyboard for most of this process. Hopefully this is helpful.\n. ",
    "epidemian": "Nice discussion. I would tend towards allowing things like do foo = -> bar (equivalent to do (foo = -> bar)) or a and b = c (equivalent to a and (b = c)).\nIn the case of do foo = -> though, i'm curious about where are you using that, @mark-hahn. If it is for auto-invoking a function that also needs to be used later on, then i think separating the function definition and it's first usage as you suggested in the last message would be clearer. But i could also imagine that it might be for auto-invoking recursive functions that need a reference to themselves inside the definition; something like:\ncoffeescript\ndo drawTree = (tree = root, depth = 0) ->\n  return unless tree\n  drawValue tree.value, depth\n  drawTree tree.left, depth + 1 \n  drawTree tree.right, depth + 1\nAbout the mixed and/or and = operators, i think that = is quite special compared to other operators in that the left-hand side should only be an identifier, and not an expression of any kind. Therefore, it shouldn't obey the same precedence rules as the other operators (which allow the LHS and RHS to be arbitrary expressions). a and b = c should only mean a and (b = c) and not (a and b) = c, as only the former has a = LHS that makes sense.\nAlso, i sometimes find things like a and b = c to be useful. For example, when i want to cache the result of c, which should only be computed if a is truthly, for later usage.\nFinally, notice that the argument about how = is special and may not follow normal operator precedence rules can also be applied to allow assignments inside do's :)\n. @mark-hahn Cool. Yeah, though i've never used them, i think recursive functions are a valid use of do func = ->. Thanks for the examples :+1:\n\nRemember: this wouldn't be disallowed, you would just need to raise the precedence of the assignment by putting it in parentheses.\n\nYeah, but is it necessary? Does a and b = c have some kind of ambiguity? \nIn my previous comment i said that the only requirement was that the LHS of = needed to be an identifier. That was incorrect. The LHS needs to be an lvalue, which should be something like lvalue ::= identifier | lvalue \".\" identifier | lvalue \"[\" expression \"]\" if i'm not forgetting some other(s) valid lvalue(s).\nMy point is that = is not like the other operators that accept an arbitrary expression in both sides, so i don't see why a case like a and b = c would need to be disambiguated with parentheses around the assignment. \nI don't know if it's a good example but, in Ruby a && b = c is a valid expression. In Python though, as assignments are statements and not expressions, that's not valid syntax (nor using a simple assignment in an if condition).\nAnyway, that's just my opinion, i'm also interested in knowing what @jashkenas thinks.\n. Hmm... i feel this is yet another case for a nice chaining syntax. For example, this is valid in LiveScript:\ncoffeescript\n$ '<a/>'\n  .css color: 'blue', 'text-decoration': 'underline'\n  .appendTo 'body'\nHowever, it seems this is not supported:\ncoffeescript\n$ '<a/>'\n  .css \n    color: 'blue'\n    'text-decoration': 'underline'\n  .appendTo 'body'\nA proper chaining syntax does not belong to this issue, and it has been discussed many times before, but i just wanted to comment that this might be another case for it :)\n. While i agree with the general sentiment in that it would be cool to have a more clear way to express chaining (i.e. chaining special syntax), i also agree with @mark-hahn in this one, forbidding these constructs altogether will break lots of today-legal code. \nThis a sample snippet from a Stack Overflow answer i saw today:\ncoffeescript\nitems\n  .map (item) ->\n    item.price * item.quantity\n  .reduce (x, y) ->\n    x + y\nThese constructs are valid in today's CS and lots of people are very used to using them. It's hard to imagine someone fixing their codebase all over the place just to support a new compiler. That's why i think it would be cool if Redux supported this arguably \"bad\" syntax constructs.\n. While i'm not in favour not against the proposed feature, i think the mentioned blog post brings some interesting points about code style.\nFor example, i agree with the author on that this snippet from the original CS compiler is not very readable:\ncoffeescript\naction = (token, i) ->\n  @tokens.splice i, 0, @generate 'CALL_END', ')', token[2]\nThe author suggests using explicit function-call parentheses for the second function, like:\ncoffeescript\naction = (token, i) ->\n  @tokens.splice i, 0, @generate('CALL_END', ')', token[2])\nBut i think it's more readable and consistent to add a pair of parentheses for explicit grouping, but not for function-call:\ncoffeescript\naction = (token, i) ->\n  @tokens.splice i, 0, (@generate 'CALL_END', ')', token[2])\nMore readable because i think it's easier to identify that there are three arguments for the @tokens function (this is usually more evident when you group more than one parameter, like move enemy, (min vx, maxVel), (min vy, maxVel), 0 -> obviously four parameters for move); and more consistent because it does not incur in using function-call parentheses sometimes and sometimes not.\nReading this CS style guide i realized that this style is known as \"function grouping style\" (i called it \"lispy style\" for i think it bares a resemblance to S-expressions =D).\nBut well, i'd like to know what others think about this parenthesizing style. The linked style guide mentions that it's not recommended, any idea why? I might open a discussion regarding this topic in the future if i find some time to experiment with it more deeply (for instance, one of the problems with this style is chaining methods, like (($ 'li').css 'margin-color', 'blue').show()... but well, chaining syntax is a problem on its own too =D).\n. Quite an interesting discussion. Not so much for the usefulness of the topic being discussed, but for how an undefined behaviour of the language can cause so much trouble.\nI do agree that letting JS literals anywhere would be very broken (and probably impossible/extremely difficult from the CS parser perspective). Restricting the backticks to be used only as expressions seems like a reasonable requirement to me. \nThe case of a = () -> b is quite an unfortunate one. It took me quite a while to understand that Redux was interpreting is as (lispy AST:) (assignment 'a' (application '<some JS>' (function () 'b'))). That was quite an unexpected behaviour to me. Once i figured out that Redux was admitting things like a = (b + c) -> d (which interprets as a = (b + c)(-> d)) it became more evident what was happening, but i still think that's not a very happy behaviour and i'd prefer it to be an error, like in the original compiler.\nAbout the need for eval, i'm not sure i fully understand it. Is it because escodegen expects a nice AST and therefore you give it something like (application 'eval' '<the backticked JS>')? If that's the case then yes, it's unfortunate. It would be nice for escodegen to admit a raw input leaf node as \"just trust that what comes here is a valid expression\" or some other way including raw input. A very hacky way of bypassing escodegen would be to give it an AST like (application '__inlineMe__' '<the backticked JS>' '__end__'), which would generate the valid JS code: __inlineMe__('<the backticked JS>', '__end__'), and then do a replacement of /__inlineMe__\\('(.*)', '__end__'\\)/g with the first capturing group. Yes, a horrendous hack, but probably better than including a JS parser just for the sake of backticks. What do you think? :)\n\nThis is kinda off-topic, but...\n\nIt is interesting that you want to fix all the \"broken\" parts of javascript but you call fixing the biggest problem in CS a hack. Many people, including several on the front page of HN, feel this way about the scoping. The current lack of local scoping is constantly being defended, for reasons I don't understand.\n\nI think you're referring to lexical scoping, which CS does have. I'm positive @jashkenas clarified that in a HN thread. An example of how CS would behave if it had dynamic scoping:\n``` coffeescript\nfoo = ->\n  alert a\nbar = ->\n  a = 5\n  foo() # With dinamic scoping this would work, and would alert 5.\n        # With lexical scoping this causes en error, as 'a' is not defined in the scope of foo.\n```\n\n\n\nThese cases are extraordinary\n\nI would really like to know how many users would agree with you. At what point will the community get a say in this?\n\nI'd say that the need for backticks at all it quite extraordinary. I personally wouldn't miss them if they are completely removed at some point. But that's just me, i'd also like to know what others think about this =D\n. @michaelficarra Ouch, nice counter-example. I guess there's no ambiguity (although in the simple case of '(' identifier ')' '->' expression it's kind of tricky, as an identifier alone is a valid expression but in that case it has to be treated as a parameter and the whole expression is a function definition instead of an application), but it surely is confusing (e.g. the GitHub highlighter got confused there and highlighted the expression before -> as function-definition parameters =P).\nBut yeah, i guess there's nothing to do with this. It's an unfortunate consequence of the function definition and function application syntax.\nRegarding the use of eval, do you think it would be possible/convenient to get rid of it after it's been processed by escodegen?\n@gregwebs Yes, that's would work the same. I used a special construct just to be (kind of) safe that it would not conflict with other code (e.g. CS code that, for some reason, uses eval). The __inlineMe__ that i mentioned would not be visible to the user, it'd be just an intermediate representation between the JS AST passed to escodegen and the final JS source code.\n. As @gkz said:\nbash\n$ echo \"alert hello 'world'\" | bin/coffee --js\n// Generated by CoffeeScript 2.0.0-dev\nalert(hello('world'));\nIf you want to read from a file, you can also use the shell redirect operators:\nbash\n$ bin/coffee --js <test.coffee >test.js\n. > JS using the same operator for two different operations was a mistake.\nMmm... i would probably have used the readability argument. In the line you commented i agree that interpolation results in more readable code. If you just want to concatenate a couple variables, something + somethingElse is probably more readable than \"#{something}#{somethingElse}\".\nAbout using the same operator for different operations being a mistake; i don't know. Both integer addition and string concatenation behave like a monoid, so i'm not that sure that using the same symbol to \"add\" those elements together is a mistake. Wouldn't it be cool that + also worked to concatenate arrays? or to \"add\" user-defined types, like maybe a 3D vector? =D\nWhat i think was a mistake is that + works on heterogeneous types; 5 + \"a\" or \"b\" + [] should raise an error IMO. For that reason, i think it's very cool to have string interpolation in Coffee.\n. :+1:  I think this feature would be also really cool for libraries like Sprockets, so they avoid duplication these functions all the time in the concatenated output.\nAn alternative to this would be fixing the --join option of the compiler. I say fixing because as it is right now, --joining the files can change their runtime behaviour. For instance, if i have two files:\n``` coffeescript\na.coffee\naux = -> 'aux a'\nexporta.a = -> aux()\n```\nand\n``` coffeescript\nb.coffee\naux = -> 'aux b'\nexporta.b = -> aux()\n```\nWhen compiled with --join, the auto-invoked functions that normally wrap each JS file get merged and thus the topmost scope of each file gets merged. In this case, it causes a.coffee's aux variable to be overridden by the inclusion of b.coffee:\n``` javascript\n// Generated by CoffeeScript 1.4.0\n(function() {\n  var aux;\naux = function() {\n    return 'aux b';\n  };\nexporta.b = function() {\n    return aux();\n  };\naux = function() {\n    return 'aux a';\n  };\nexporta.a = function() {\n    return aux();\n  };\n}).call(this);\n```\nI think a better behaviour for --join would be to keep each file's scope separate (with different auto-invoked functions in the compiled JS) but put the \"internal\" CS functions like isOwn$ in an all-enclosing scope.\n. > @epidemian: I believe you were referring to jashkenas/coffee-script when mentioning --join. This compiler will have no such feature. That should be left to build tools.\nYeah, i was referring to that; sorry for mixing things up :sweat: \nI'm not sure if this is a problem easily solvable by build tools. It's not just about doing cat *.js. I've used Sprockets in production, and even though it does lots of nice things like compiling the .coffee files on demand and serving a nice concatenated and minified JS, it still included all the repeated definitions of __indexOf, __extend, etc for each .coffee file included in the concatenated JS.\nFor a tool like Sprockets to solve this problem, it would require them to look at the generated JS code and remove repeated definitions of built-in CS functions. Not something ideal IMO; and not something that the build tool should be doing. I think having a compiler option for turning helper functions off and another one to generate all helper functions into a single file would be much more reasonable and would make the job for build tools much easier. Or, as an alternative, having a --join option that doesn't change the meaning of file top-level variables (which should be private to the file itself).\n. Looks good to me. It will probably help a lot with debugging; making stack traces more readable :)\nIt's also good to know that a minifier like UglifyJS can get rid of the unnecessary function name for production code:\n```\n$ echo 'foo = -> 99' | bin/coffee --js\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var foo;\n  foo = function foo$() {\n    return 99;\n  };\n}.call(this);\n$ echo 'foo = -> 99' | bin/coffee --js | uglifyjs --compress --mangle\nvoid function(){var n;n=function(){return 99}}.call(this);\n```\nThe built-in Redux minifier leaves it as a named function expression though (maybe a missing option to esmangle?):\n$ echo 'foo = -> 99' | bin/coffee --js --minify\nvoid function(){foo=function a(){return 99}}.call(this)\nNow that i look at it, the minified output also omits the var declaration inside the auto-invoked function, making foo leak into the global scope. Is that an intended behavior or a bug?\n. Well, the test/parser.coffee has a couple of handy shouldParse and shouldNotParse functions. Though, i'm not sure if using the shouldParse for the positive case would be enough, maybe adding an assertion to test if the generated code structure is OK:\n``` coffeescript\ntest '#142 inconsistently indented object literal', ->\n  inconsistentyly =\n    indented:\n             object:\n              literal: yes\n  ok inconsistently.indented.object.literal\ntest 'inconsistently indented if statement', ->\n  f = (b) ->\n    if b\n      'if'\n    else\n         'else'\n  eq 'if', f yes\n  eq 'else', f no\n```\nAnd to test that inconsistent dedents/invalid indentations throw parser errors, maybe something like (although this is seems to already be implemented, so i don't know if it's already tested somewhere):\n``` coffeescript\ntest 'inconsistent object literal dedent', ->\n  shouldNotParse '''\n    obj =\n         foo: 5\n      bar: 6\n  '''\ntest 'inconsistent if statement dedent', ->\n  shouldNotParse '''\n    f = ->\n        if something\n          'yup'\n      else\n        'nope'\n  '''\n```\n(sorry for not implementing these myself, but i don't have a functional development environment on the PC i'm at right now, so i wouldn't be able to test if the tests work hehe)\n. No need to thank, @michaelficarra, i'm glad i can help with something :)\nAnd thanks @Arelius for including the test cases verbatim. You know, it feels kinda weird to write tests that check if some ugly code compiles. But it makes sense. It makes the language feel more well-defined/specified. And i think it's cool for compilers to be a bit lenient about style, as long as that style can be defined with some reasonable grammar rules. Let it be the job of some other tool(s) to check the style/format code/apply coding conventions/etc.\nSpeaking about the language being well-defined though, i'm not sure if the negative test cases are exhaustive (in fact, i'm pretty sure they aren't). Are there more cases (different from a grammar point of view) in which bad indentation should cause a compile error? I thought about adding more control structures aside from the if, but maybe those are not fundamentally different from the if. Maybe object literals aren't treated differently from an if either from a indentation point of view. I think it would be cool for the tests to be as exhaustive as possible (without being redundant of course).\n. Interesting. I didn't know throw could be used as an expression (i assumed throw and return were the only not valid expressions). I'd always prefer doing:\ncoffeescript\nthrow \"bar\" unless foo\nBuuuut, it seems like a bug on Redux, as this does compile:\ncoffeescript\nfoo or (throw \"bar\")\n. @mark-hahn It's not a valentine's day joke, i fear. The code should is equivalent to: \ncoffeescript\na = ->                     \n  for i in [1..3] \n    return i\nWhich looks more like a reasonable usage and (fortunately, i think) raises the same compilation error in Redux.\nA valid usage could be finding an element in an array:\ncoffeescript\nfindBy = (array, fn) ->\n  for x in array\n    return x if fn x\nWhich, written as a one-liner should be:\ncoffeescript\nfindBy = (array, fn) -> return x for x in array when fn x\nAnd before anyone says \"but you shouldn't write that as a one liner\", i agree, but it currently works on CoffeeScript 1.4 and apparently people rely on those for one-liners with early returns :anguished: \n. The compilation error seems to be triggered only when the for loop is treated as a comprehension. If another statement is added after the loop it compiles:\n``` coffeescript\nThis compiles:\nfindBy = (array, fn) -> \n  for x in array when fn x\n    return x\n  undefined # Remove this line and it stops compiling.\n```\nNow, the funny thing is that the original CS compiles this:\ncoffeescript\nfindBy = (array, fn) -> \n  for x in array when fn x\n    return x\nInto:\n``` javascript\nvar findBy;\nfindBy = function(array, fn) {\n  var x, _i, _len;\n  for (_i = 0, _len = array.length; _i < _len; _i++) {\n    x = array[_i];\n    if (fn(x)) {\n      return x;\n    }\n  }\n};\n```\nWhich means that the compiler is detecting that the for loop contains a return statement and therefore does not generate an array as the return value. But, what if the return inside the for is not executed? Shouldn't the function then return an array, as the last expression is an array comprehension? Or are for loops not considered array comprehensions when they include a return statement?\n@michaelficarra, i think i now understand why you consider that the array comprehension syntax should include some [] around it and be different to normal for loops =P\n. @michaelficarra I guess it's a trickier problem than i though. \nIn order to maintain consistency with the original compiler not only would it be necessary to add support for these for loops with return statements as the last expression in a block, but also change how things like this get compiled:\ncoffeescript\nfoo = ->\n  for x in arr \n    if someCondition\n      return []\n    x\n``` javascript\n// Generated by CoffeeScript 1.4.0\n(function() {\n  var foo;\nfoo = function() {\n    var x, _i, _len;\n    for (_i = 0, _len = arr.length; _i < _len; _i++) {\n      x = arr[_i];\n      if (someCondition) {\n        return [];\n      }\n      x;\n}\n\n};\n}).call(this);\n```\njavascript\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var foo;\n  foo = function () {\n    return function (accum$) {\n      var x;\n      for (var i$ = 0, length$ = arr.length; i$ < length$; ++i$) {\n        x = arr[i$];\n        if (someCondition)\n          return [];\n        accum$.push(x);\n      }\n      return accum$;\n    }.call(this, []);\n  };\n}.call(this);\nThen again, this probably could be considered a bug in the original compiler =P\n. > Not sure why CSR produces a closure here, seems unefficient no? I don't see the use case it fixes\nMe neither. But but i was trying to point out is that the behaviour of the generated code differs. Redux returns an array (as, i think, would be expected) from the function (in case the return inside the loop is never executed) while the original compiler doesn't.\n. Hehehe. It's funny. It happens to me too in the on line demo. But only if i'm typing the code. If i type class Foo extends Bar it starts adding var key; lines on the compiled output for each new character i type after the \"B\" of Bar. If i refresh the page the code is shown without extra var key; lines.\nReproduced in both Firefox and Chrome in Ubuntu.\n. Yeah, it's quite a fun bug :smile_cat:. Good luck git bisecting it (BTW, thanks for mentioning that command; i didn't know about it!).\n. That's why i said good luck git bissecting it hehe. The bug looks to be easily triggered in the on line demo, but not so much in the command line compiler.\nHere's a script that reproduces this (intended to run at the root of Redux project):\n``` coffeescript\n! /usr/bin/env coffee\nCS = require './lib/coffee-script/module'\ncompileFail = ->\n  CS.cs2js 'class Foo extends Bar'\nCall a couple of times...\ncompileFail()\ncompileFail()\nAnd voila!\nconsole.log compileFail()\n```\nOutput:\njavascript\n// Generated by CoffeeScript 2.0.0-beta3\nvoid function () {\n  var Foo;\n  Foo = function (super$) {\n    extends$(Foo, super$);\n    function Foo() {\n    }\n    void 0;\n    return Foo;\n  }(Bar);\n  function isOwn$(o, p) {\n    return {}.hasOwnProperty.call(o, p);\n  }\n  function extends$(child, parent) {\n    var key;\n    var key;\n    var key;\n    for (key in parent)\n      if (isOwn$(parent, key))\n        child[key] = parent[key];\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor;\n    child.__super__ = parent.prototype;\n    return child;\n  }\n}.call(this);\nThe amount of var key; declarations in the output is directly proportional to the times compileFail is called xD\n. A simpler script to test it:\n$ coffee --eval \"console.log ((require './lib/coffee-script/module').cs2js 'a extends b' for i in [1..10])[9]\"\n// Generated by CoffeeScript 2.0.0-beta3\nextends$(a, b);\nfunction isOwn$(o, p) {\n  return {}.hasOwnProperty.call(o, p);\n}\nfunction extends$(child, parent) {\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  for (key in parent)\n    if (isOwn$(parent, key))\n      child[key] = parent[key];\n  function ctor() {\n    this.constructor = child;\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor;\n  child.__super__ = parent.prototype;\n  return child;\n}\nOne funny (or not so funny...) thing about this script is that the CS code needs to be compiled with the old CS compiler, as Redux will raise an error. I'm gonna open an issue for that now, but i wanted to leave this code here just as an evidence of this not being a very esoteric use-case.\n. BTW, the compiled output for:\ncoffeescript\nn ** 2 for n in [1..10]\nis pretty bonkers:\njavascript\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var n;\n  for (var i$ = 0, length$ = [\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10\n      ].length; i$ < length$; ++i$) {\n    n = [\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10\n    ][i$];\n    Math.pow(n, 2);\n  }\n  function in$(member, list) {\n    for (var i = 0, length = list.length; i < length; ++i)\n      if (i in list && list[i] === member)\n        return true;\n    return false;\n  }\n}.call(this);\nThis is on the live demo. Compiling it in the command line produces nothing, as it seems to optimise the loop to a no-op. However, doing something with possible side effects like console.log n for n in [1..10] results in a similar compilation.\n. Awesome to see such a succinct fix! :smile_cat: \n. Why not the CoffeeScript class syntax?\ncoffeescript\nclass MyClass\n  privateMethod = -> 'private'\n  publicMethod: -> privateMethod() + ' call'\nOr, if you prefer the JS Style of constructor functions, maybe using a do statement:\ncoffeescript\nMyClass = ->\nmyClass.prototype = do ->\n  privateMethod = -> 'private'\n  publicMethod: -> privateMethod() + ' call'\nIn both cases you prevent the privateMethod function from being at the top level of the file; instead being on a separate scope that only the functions related to MyClass can see.\n. Ho, i totally missed that this was Redux xD\n. I'm with @mark-hahn on this one. The CoffeeScript documentation mentions semicolons pretty early (so this is something many people will have read and assimilated):\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don't need to use semicolons ; to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line).\n\nSo, my interpretation from that is that semicolons are optional statement delimiters, that can be used instead of newlines. I see no reason to take them as operators. And i think their rules regarding semicolons on the original CS compiler are pretty consistent:\n``` coffeescript\nJust like you can use newlines to separate statements in a block...\nif foo\n  bar()\n  baz()\n... you can also use semicolons.\nif foo\n  bar(); baz()\nAnd just like you can have more than one newline between statements\nand the code will mean the same...\nif foo\n  bar()\nbaz()\n... you can have more than one semicolon.\nif foo\n  bar();; baz();;;;\n```\nSo i see no reason to prohibit semicolons at the end of the last statement of a block.\n. What @renekooi said, and also: it's the same behaviour as in the original CS compiler :smiley: \n. Well, i thought that adding more cases would start favouring the switch case (maybe browsers would use some hash table optimization for big switches). It does close the gap a fair bit in Firefox though: http://jsperf.com/iife-switch-vs-ternary/3. I am, however, not very sure if jsPerf results are that reliable.\n. (off-topic, let's keep this side-discussion short, @mark-hahn)\n\nWhy? It simply runs the code in the browser which is just V8.\n\nBecause the sample code is very artificial. In this case, the code does absolutely nothing, so a good compiler could optimize one entire test case, or part of it, to a no-op, thus making that test case much \"faster\" than the other one, but not telling anything at all about which approach would run better for real code.\n. Dammit, break! May i ask: was the decision to support breaks inside switch statements deliberate? I personally don't find it very fitting for switches that don't have default fall-through.\n. Add me to the interested list alongside @Avenger7x. Remember that not every user will open an issue for something that they find wrong in the project :wink: \n. > Cygwin is so bad and so horribly done it's never an ok requirement. I'd not use it even if that was the only way I had to build a project.\nSad to hear that shell compatibility between *nix-like operating systems and Windows is still so crappy.\nI remember, however, that the MinGW project provided a set of command-line tools that emulated the *nix commands, including bash, make, and the very useful things like ls, rm, grep, etc, without requiring a full POSIX system ala Cygwin. I think i had some sort of success building C++ projects on both Windows and Linux with the same Makefile using those tools; but that was long time ago, i don't know what's their current state.\n. Good. I was writing a comment on your\n\nCan I do pull request for this issue?\n\nquestion. Glad you beat me to it :smiley_cat: \nTo make this PR more complete, i think you should add a test case that failed before this fix (bonus points for a test case that enters an infinite loop in case it doesn't pass :stuck_out_tongue_closed_eyes:)\n. \n(sorry, it's been a long day xD)\n. > aah, we do\nBut that tests the prefix until form, not the postfix one, which is the one Redux had problems.\nDoes this PR make Redux have more test coverage than CS 1.x!??\n. @pjeby, if you're interested, the change regarding the semicolon as an operator instead of a statement delimiter was discussed in #174. As it can be inferred from that discussion, i'm not in favour of that change either.\nThat being said, i think the first code snippet in this issue is quite a obscure hack. I wouldn't use that unless it's the last resort, and it would need to have an explanatory comment so readers of the code can understand what the hell is going on there (which would be so painful that i'd rather consider using other module system, like CommonJS, or adding a pre-processing step to the compilation :stuck_out_tongue_closed_eyes:). So yeah, i don't think that example makes a good point for retaining that particular behaviour of the original compiler.\nNow, the bit about the:\ncoffeescript\nif x then y();\nspim()\nis very confusing IMO. I personally would expect that in order to have more than one statement in an in-line if one would need to use parentheses (i.e. if x then (y(); z()). But it kinda follows the same reasoning about the meaning of the semicolon. \nThere's however, an inconsistency with post-if form it seems. The normal if will eat all the semicolon-separated statements after it:\n``` coffeescript\nif isFriday() then haveCerelal(); catchBus()\nCompiles to:\nif (isFriday()) { haveCerelal(); catchBus(); }\n```\nBut the post-if does not eat all semicolon-separated statements before it:\n``` coffeescript\nhaveCerelal(); catchBus() if isFriday()\nCompiles to:\nhaveCerelal(); if (isFriday()) catchBus();\nAnd i don't have enough money to have cereal every day...\n```\nIs this by design or is it a bug?\n. @michaelficarra, the discussion about precedence of infix operators vs function application is outside the scope of this issue i think.\nHowever, i was asking about the behaviour in Redux. The difference i mentioned between normal if and post-if seems pretty unintuitive to me. In the original compiler the semicolon behaves as a statement delimiter, semantically equivalent to a newline, so the behaviour if a then b; c and a; b if c is pretty consistent IMO (the semicolon can be replaced by a newline and the meaning is preserved).\n. > The CSR compilation of your examples is the same as jashkenas/coffee-script.\nHo, snap. That was a total brain fart from my part. I was under the impression that if a then b(); c() compiled to if (a) b(); c(); in the original compiler :sweat: \nWell, i'll leave my comment there just to avoid rewriting the past, but it was totally wrong hehe.\n. TBH, i always thought that Node's REPL was screwing things up when SyntaxErrors were raised. I never realized that it was entering multi-line mode :sweat_smile:\nIf others also think this a particularly ugly \"feature\" of Node's REPL, i would also prefer to leave it out.\n. Nice discussion. I would tend towards allowing things like do foo = -> bar (equivalent to do (foo = -> bar)) or a and b = c (equivalent to a and (b = c)).\nIn the case of do foo = -> though, i'm curious about where are you using that, @mark-hahn. If it is for auto-invoking a function that also needs to be used later on, then i think separating the function definition and it's first usage as you suggested in the last message would be clearer. But i could also imagine that it might be for auto-invoking recursive functions that need a reference to themselves inside the definition; something like:\ncoffeescript\ndo drawTree = (tree = root, depth = 0) ->\n  return unless tree\n  drawValue tree.value, depth\n  drawTree tree.left, depth + 1 \n  drawTree tree.right, depth + 1\nAbout the mixed and/or and = operators, i think that = is quite special compared to other operators in that the left-hand side should only be an identifier, and not an expression of any kind. Therefore, it shouldn't obey the same precedence rules as the other operators (which allow the LHS and RHS to be arbitrary expressions). a and b = c should only mean a and (b = c) and not (a and b) = c, as only the former has a = LHS that makes sense.\nAlso, i sometimes find things like a and b = c to be useful. For example, when i want to cache the result of c, which should only be computed if a is truthly, for later usage.\nFinally, notice that the argument about how = is special and may not follow normal operator precedence rules can also be applied to allow assignments inside do's :)\n. @mark-hahn Cool. Yeah, though i've never used them, i think recursive functions are a valid use of do func = ->. Thanks for the examples :+1:\n\nRemember: this wouldn't be disallowed, you would just need to raise the precedence of the assignment by putting it in parentheses.\n\nYeah, but is it necessary? Does a and b = c have some kind of ambiguity? \nIn my previous comment i said that the only requirement was that the LHS of = needed to be an identifier. That was incorrect. The LHS needs to be an lvalue, which should be something like lvalue ::= identifier | lvalue \".\" identifier | lvalue \"[\" expression \"]\" if i'm not forgetting some other(s) valid lvalue(s).\nMy point is that = is not like the other operators that accept an arbitrary expression in both sides, so i don't see why a case like a and b = c would need to be disambiguated with parentheses around the assignment. \nI don't know if it's a good example but, in Ruby a && b = c is a valid expression. In Python though, as assignments are statements and not expressions, that's not valid syntax (nor using a simple assignment in an if condition).\nAnyway, that's just my opinion, i'm also interested in knowing what @jashkenas thinks.\n. Hmm... i feel this is yet another case for a nice chaining syntax. For example, this is valid in LiveScript:\ncoffeescript\n$ '<a/>'\n  .css color: 'blue', 'text-decoration': 'underline'\n  .appendTo 'body'\nHowever, it seems this is not supported:\ncoffeescript\n$ '<a/>'\n  .css \n    color: 'blue'\n    'text-decoration': 'underline'\n  .appendTo 'body'\nA proper chaining syntax does not belong to this issue, and it has been discussed many times before, but i just wanted to comment that this might be another case for it :)\n. While i agree with the general sentiment in that it would be cool to have a more clear way to express chaining (i.e. chaining special syntax), i also agree with @mark-hahn in this one, forbidding these constructs altogether will break lots of today-legal code. \nThis a sample snippet from a Stack Overflow answer i saw today:\ncoffeescript\nitems\n  .map (item) ->\n    item.price * item.quantity\n  .reduce (x, y) ->\n    x + y\nThese constructs are valid in today's CS and lots of people are very used to using them. It's hard to imagine someone fixing their codebase all over the place just to support a new compiler. That's why i think it would be cool if Redux supported this arguably \"bad\" syntax constructs.\n. While i'm not in favour not against the proposed feature, i think the mentioned blog post brings some interesting points about code style.\nFor example, i agree with the author on that this snippet from the original CS compiler is not very readable:\ncoffeescript\naction = (token, i) ->\n  @tokens.splice i, 0, @generate 'CALL_END', ')', token[2]\nThe author suggests using explicit function-call parentheses for the second function, like:\ncoffeescript\naction = (token, i) ->\n  @tokens.splice i, 0, @generate('CALL_END', ')', token[2])\nBut i think it's more readable and consistent to add a pair of parentheses for explicit grouping, but not for function-call:\ncoffeescript\naction = (token, i) ->\n  @tokens.splice i, 0, (@generate 'CALL_END', ')', token[2])\nMore readable because i think it's easier to identify that there are three arguments for the @tokens function (this is usually more evident when you group more than one parameter, like move enemy, (min vx, maxVel), (min vy, maxVel), 0 -> obviously four parameters for move); and more consistent because it does not incur in using function-call parentheses sometimes and sometimes not.\nReading this CS style guide i realized that this style is known as \"function grouping style\" (i called it \"lispy style\" for i think it bares a resemblance to S-expressions =D).\nBut well, i'd like to know what others think about this parenthesizing style. The linked style guide mentions that it's not recommended, any idea why? I might open a discussion regarding this topic in the future if i find some time to experiment with it more deeply (for instance, one of the problems with this style is chaining methods, like (($ 'li').css 'margin-color', 'blue').show()... but well, chaining syntax is a problem on its own too =D).\n. Quite an interesting discussion. Not so much for the usefulness of the topic being discussed, but for how an undefined behaviour of the language can cause so much trouble.\nI do agree that letting JS literals anywhere would be very broken (and probably impossible/extremely difficult from the CS parser perspective). Restricting the backticks to be used only as expressions seems like a reasonable requirement to me. \nThe case of a = () -> b is quite an unfortunate one. It took me quite a while to understand that Redux was interpreting is as (lispy AST:) (assignment 'a' (application '<some JS>' (function () 'b'))). That was quite an unexpected behaviour to me. Once i figured out that Redux was admitting things like a = (b + c) -> d (which interprets as a = (b + c)(-> d)) it became more evident what was happening, but i still think that's not a very happy behaviour and i'd prefer it to be an error, like in the original compiler.\nAbout the need for eval, i'm not sure i fully understand it. Is it because escodegen expects a nice AST and therefore you give it something like (application 'eval' '<the backticked JS>')? If that's the case then yes, it's unfortunate. It would be nice for escodegen to admit a raw input leaf node as \"just trust that what comes here is a valid expression\" or some other way including raw input. A very hacky way of bypassing escodegen would be to give it an AST like (application '__inlineMe__' '<the backticked JS>' '__end__'), which would generate the valid JS code: __inlineMe__('<the backticked JS>', '__end__'), and then do a replacement of /__inlineMe__\\('(.*)', '__end__'\\)/g with the first capturing group. Yes, a horrendous hack, but probably better than including a JS parser just for the sake of backticks. What do you think? :)\n\nThis is kinda off-topic, but...\n\nIt is interesting that you want to fix all the \"broken\" parts of javascript but you call fixing the biggest problem in CS a hack. Many people, including several on the front page of HN, feel this way about the scoping. The current lack of local scoping is constantly being defended, for reasons I don't understand.\n\nI think you're referring to lexical scoping, which CS does have. I'm positive @jashkenas clarified that in a HN thread. An example of how CS would behave if it had dynamic scoping:\n``` coffeescript\nfoo = ->\n  alert a\nbar = ->\n  a = 5\n  foo() # With dinamic scoping this would work, and would alert 5.\n        # With lexical scoping this causes en error, as 'a' is not defined in the scope of foo.\n```\n\n\n\nThese cases are extraordinary\n\nI would really like to know how many users would agree with you. At what point will the community get a say in this?\n\nI'd say that the need for backticks at all it quite extraordinary. I personally wouldn't miss them if they are completely removed at some point. But that's just me, i'd also like to know what others think about this =D\n. @michaelficarra Ouch, nice counter-example. I guess there's no ambiguity (although in the simple case of '(' identifier ')' '->' expression it's kind of tricky, as an identifier alone is a valid expression but in that case it has to be treated as a parameter and the whole expression is a function definition instead of an application), but it surely is confusing (e.g. the GitHub highlighter got confused there and highlighted the expression before -> as function-definition parameters =P).\nBut yeah, i guess there's nothing to do with this. It's an unfortunate consequence of the function definition and function application syntax.\nRegarding the use of eval, do you think it would be possible/convenient to get rid of it after it's been processed by escodegen?\n@gregwebs Yes, that's would work the same. I used a special construct just to be (kind of) safe that it would not conflict with other code (e.g. CS code that, for some reason, uses eval). The __inlineMe__ that i mentioned would not be visible to the user, it'd be just an intermediate representation between the JS AST passed to escodegen and the final JS source code.\n. As @gkz said:\nbash\n$ echo \"alert hello 'world'\" | bin/coffee --js\n// Generated by CoffeeScript 2.0.0-dev\nalert(hello('world'));\nIf you want to read from a file, you can also use the shell redirect operators:\nbash\n$ bin/coffee --js <test.coffee >test.js\n. > JS using the same operator for two different operations was a mistake.\nMmm... i would probably have used the readability argument. In the line you commented i agree that interpolation results in more readable code. If you just want to concatenate a couple variables, something + somethingElse is probably more readable than \"#{something}#{somethingElse}\".\nAbout using the same operator for different operations being a mistake; i don't know. Both integer addition and string concatenation behave like a monoid, so i'm not that sure that using the same symbol to \"add\" those elements together is a mistake. Wouldn't it be cool that + also worked to concatenate arrays? or to \"add\" user-defined types, like maybe a 3D vector? =D\nWhat i think was a mistake is that + works on heterogeneous types; 5 + \"a\" or \"b\" + [] should raise an error IMO. For that reason, i think it's very cool to have string interpolation in Coffee.\n. :+1:  I think this feature would be also really cool for libraries like Sprockets, so they avoid duplication these functions all the time in the concatenated output.\nAn alternative to this would be fixing the --join option of the compiler. I say fixing because as it is right now, --joining the files can change their runtime behaviour. For instance, if i have two files:\n``` coffeescript\na.coffee\naux = -> 'aux a'\nexporta.a = -> aux()\n```\nand\n``` coffeescript\nb.coffee\naux = -> 'aux b'\nexporta.b = -> aux()\n```\nWhen compiled with --join, the auto-invoked functions that normally wrap each JS file get merged and thus the topmost scope of each file gets merged. In this case, it causes a.coffee's aux variable to be overridden by the inclusion of b.coffee:\n``` javascript\n// Generated by CoffeeScript 1.4.0\n(function() {\n  var aux;\naux = function() {\n    return 'aux b';\n  };\nexporta.b = function() {\n    return aux();\n  };\naux = function() {\n    return 'aux a';\n  };\nexporta.a = function() {\n    return aux();\n  };\n}).call(this);\n```\nI think a better behaviour for --join would be to keep each file's scope separate (with different auto-invoked functions in the compiled JS) but put the \"internal\" CS functions like isOwn$ in an all-enclosing scope.\n. > @epidemian: I believe you were referring to jashkenas/coffee-script when mentioning --join. This compiler will have no such feature. That should be left to build tools.\nYeah, i was referring to that; sorry for mixing things up :sweat: \nI'm not sure if this is a problem easily solvable by build tools. It's not just about doing cat *.js. I've used Sprockets in production, and even though it does lots of nice things like compiling the .coffee files on demand and serving a nice concatenated and minified JS, it still included all the repeated definitions of __indexOf, __extend, etc for each .coffee file included in the concatenated JS.\nFor a tool like Sprockets to solve this problem, it would require them to look at the generated JS code and remove repeated definitions of built-in CS functions. Not something ideal IMO; and not something that the build tool should be doing. I think having a compiler option for turning helper functions off and another one to generate all helper functions into a single file would be much more reasonable and would make the job for build tools much easier. Or, as an alternative, having a --join option that doesn't change the meaning of file top-level variables (which should be private to the file itself).\n. Looks good to me. It will probably help a lot with debugging; making stack traces more readable :)\nIt's also good to know that a minifier like UglifyJS can get rid of the unnecessary function name for production code:\n```\n$ echo 'foo = -> 99' | bin/coffee --js\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var foo;\n  foo = function foo$() {\n    return 99;\n  };\n}.call(this);\n$ echo 'foo = -> 99' | bin/coffee --js | uglifyjs --compress --mangle\nvoid function(){var n;n=function(){return 99}}.call(this);\n```\nThe built-in Redux minifier leaves it as a named function expression though (maybe a missing option to esmangle?):\n$ echo 'foo = -> 99' | bin/coffee --js --minify\nvoid function(){foo=function a(){return 99}}.call(this)\nNow that i look at it, the minified output also omits the var declaration inside the auto-invoked function, making foo leak into the global scope. Is that an intended behavior or a bug?\n. Well, the test/parser.coffee has a couple of handy shouldParse and shouldNotParse functions. Though, i'm not sure if using the shouldParse for the positive case would be enough, maybe adding an assertion to test if the generated code structure is OK:\n``` coffeescript\ntest '#142 inconsistently indented object literal', ->\n  inconsistentyly =\n    indented:\n             object:\n              literal: yes\n  ok inconsistently.indented.object.literal\ntest 'inconsistently indented if statement', ->\n  f = (b) ->\n    if b\n      'if'\n    else\n         'else'\n  eq 'if', f yes\n  eq 'else', f no\n```\nAnd to test that inconsistent dedents/invalid indentations throw parser errors, maybe something like (although this is seems to already be implemented, so i don't know if it's already tested somewhere):\n``` coffeescript\ntest 'inconsistent object literal dedent', ->\n  shouldNotParse '''\n    obj =\n         foo: 5\n      bar: 6\n  '''\ntest 'inconsistent if statement dedent', ->\n  shouldNotParse '''\n    f = ->\n        if something\n          'yup'\n      else\n        'nope'\n  '''\n```\n(sorry for not implementing these myself, but i don't have a functional development environment on the PC i'm at right now, so i wouldn't be able to test if the tests work hehe)\n. No need to thank, @michaelficarra, i'm glad i can help with something :)\nAnd thanks @Arelius for including the test cases verbatim. You know, it feels kinda weird to write tests that check if some ugly code compiles. But it makes sense. It makes the language feel more well-defined/specified. And i think it's cool for compilers to be a bit lenient about style, as long as that style can be defined with some reasonable grammar rules. Let it be the job of some other tool(s) to check the style/format code/apply coding conventions/etc.\nSpeaking about the language being well-defined though, i'm not sure if the negative test cases are exhaustive (in fact, i'm pretty sure they aren't). Are there more cases (different from a grammar point of view) in which bad indentation should cause a compile error? I thought about adding more control structures aside from the if, but maybe those are not fundamentally different from the if. Maybe object literals aren't treated differently from an if either from a indentation point of view. I think it would be cool for the tests to be as exhaustive as possible (without being redundant of course).\n. Interesting. I didn't know throw could be used as an expression (i assumed throw and return were the only not valid expressions). I'd always prefer doing:\ncoffeescript\nthrow \"bar\" unless foo\nBuuuut, it seems like a bug on Redux, as this does compile:\ncoffeescript\nfoo or (throw \"bar\")\n. @mark-hahn It's not a valentine's day joke, i fear. The code should is equivalent to: \ncoffeescript\na = ->                     \n  for i in [1..3] \n    return i\nWhich looks more like a reasonable usage and (fortunately, i think) raises the same compilation error in Redux.\nA valid usage could be finding an element in an array:\ncoffeescript\nfindBy = (array, fn) ->\n  for x in array\n    return x if fn x\nWhich, written as a one-liner should be:\ncoffeescript\nfindBy = (array, fn) -> return x for x in array when fn x\nAnd before anyone says \"but you shouldn't write that as a one liner\", i agree, but it currently works on CoffeeScript 1.4 and apparently people rely on those for one-liners with early returns :anguished: \n. The compilation error seems to be triggered only when the for loop is treated as a comprehension. If another statement is added after the loop it compiles:\n``` coffeescript\nThis compiles:\nfindBy = (array, fn) -> \n  for x in array when fn x\n    return x\n  undefined # Remove this line and it stops compiling.\n```\nNow, the funny thing is that the original CS compiles this:\ncoffeescript\nfindBy = (array, fn) -> \n  for x in array when fn x\n    return x\nInto:\n``` javascript\nvar findBy;\nfindBy = function(array, fn) {\n  var x, _i, _len;\n  for (_i = 0, _len = array.length; _i < _len; _i++) {\n    x = array[_i];\n    if (fn(x)) {\n      return x;\n    }\n  }\n};\n```\nWhich means that the compiler is detecting that the for loop contains a return statement and therefore does not generate an array as the return value. But, what if the return inside the for is not executed? Shouldn't the function then return an array, as the last expression is an array comprehension? Or are for loops not considered array comprehensions when they include a return statement?\n@michaelficarra, i think i now understand why you consider that the array comprehension syntax should include some [] around it and be different to normal for loops =P\n. @michaelficarra I guess it's a trickier problem than i though. \nIn order to maintain consistency with the original compiler not only would it be necessary to add support for these for loops with return statements as the last expression in a block, but also change how things like this get compiled:\ncoffeescript\nfoo = ->\n  for x in arr \n    if someCondition\n      return []\n    x\n``` javascript\n// Generated by CoffeeScript 1.4.0\n(function() {\n  var foo;\nfoo = function() {\n    var x, _i, _len;\n    for (_i = 0, _len = arr.length; _i < _len; _i++) {\n      x = arr[_i];\n      if (someCondition) {\n        return [];\n      }\n      x;\n}\n\n};\n}).call(this);\n```\njavascript\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var foo;\n  foo = function () {\n    return function (accum$) {\n      var x;\n      for (var i$ = 0, length$ = arr.length; i$ < length$; ++i$) {\n        x = arr[i$];\n        if (someCondition)\n          return [];\n        accum$.push(x);\n      }\n      return accum$;\n    }.call(this, []);\n  };\n}.call(this);\nThen again, this probably could be considered a bug in the original compiler =P\n. > Not sure why CSR produces a closure here, seems unefficient no? I don't see the use case it fixes\nMe neither. But but i was trying to point out is that the behaviour of the generated code differs. Redux returns an array (as, i think, would be expected) from the function (in case the return inside the loop is never executed) while the original compiler doesn't.\n. Hehehe. It's funny. It happens to me too in the on line demo. But only if i'm typing the code. If i type class Foo extends Bar it starts adding var key; lines on the compiled output for each new character i type after the \"B\" of Bar. If i refresh the page the code is shown without extra var key; lines.\nReproduced in both Firefox and Chrome in Ubuntu.\n. Yeah, it's quite a fun bug :smile_cat:. Good luck git bisecting it (BTW, thanks for mentioning that command; i didn't know about it!).\n. That's why i said good luck git bissecting it hehe. The bug looks to be easily triggered in the on line demo, but not so much in the command line compiler.\nHere's a script that reproduces this (intended to run at the root of Redux project):\n``` coffeescript\n! /usr/bin/env coffee\nCS = require './lib/coffee-script/module'\ncompileFail = ->\n  CS.cs2js 'class Foo extends Bar'\nCall a couple of times...\ncompileFail()\ncompileFail()\nAnd voila!\nconsole.log compileFail()\n```\nOutput:\njavascript\n// Generated by CoffeeScript 2.0.0-beta3\nvoid function () {\n  var Foo;\n  Foo = function (super$) {\n    extends$(Foo, super$);\n    function Foo() {\n    }\n    void 0;\n    return Foo;\n  }(Bar);\n  function isOwn$(o, p) {\n    return {}.hasOwnProperty.call(o, p);\n  }\n  function extends$(child, parent) {\n    var key;\n    var key;\n    var key;\n    for (key in parent)\n      if (isOwn$(parent, key))\n        child[key] = parent[key];\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor;\n    child.__super__ = parent.prototype;\n    return child;\n  }\n}.call(this);\nThe amount of var key; declarations in the output is directly proportional to the times compileFail is called xD\n. A simpler script to test it:\n$ coffee --eval \"console.log ((require './lib/coffee-script/module').cs2js 'a extends b' for i in [1..10])[9]\"\n// Generated by CoffeeScript 2.0.0-beta3\nextends$(a, b);\nfunction isOwn$(o, p) {\n  return {}.hasOwnProperty.call(o, p);\n}\nfunction extends$(child, parent) {\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  var key;\n  for (key in parent)\n    if (isOwn$(parent, key))\n      child[key] = parent[key];\n  function ctor() {\n    this.constructor = child;\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor;\n  child.__super__ = parent.prototype;\n  return child;\n}\nOne funny (or not so funny...) thing about this script is that the CS code needs to be compiled with the old CS compiler, as Redux will raise an error. I'm gonna open an issue for that now, but i wanted to leave this code here just as an evidence of this not being a very esoteric use-case.\n. BTW, the compiled output for:\ncoffeescript\nn ** 2 for n in [1..10]\nis pretty bonkers:\njavascript\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var n;\n  for (var i$ = 0, length$ = [\n        1,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10\n      ].length; i$ < length$; ++i$) {\n    n = [\n      1,\n      2,\n      3,\n      4,\n      5,\n      6,\n      7,\n      8,\n      9,\n      10\n    ][i$];\n    Math.pow(n, 2);\n  }\n  function in$(member, list) {\n    for (var i = 0, length = list.length; i < length; ++i)\n      if (i in list && list[i] === member)\n        return true;\n    return false;\n  }\n}.call(this);\nThis is on the live demo. Compiling it in the command line produces nothing, as it seems to optimise the loop to a no-op. However, doing something with possible side effects like console.log n for n in [1..10] results in a similar compilation.\n. Awesome to see such a succinct fix! :smile_cat: \n. Why not the CoffeeScript class syntax?\ncoffeescript\nclass MyClass\n  privateMethod = -> 'private'\n  publicMethod: -> privateMethod() + ' call'\nOr, if you prefer the JS Style of constructor functions, maybe using a do statement:\ncoffeescript\nMyClass = ->\nmyClass.prototype = do ->\n  privateMethod = -> 'private'\n  publicMethod: -> privateMethod() + ' call'\nIn both cases you prevent the privateMethod function from being at the top level of the file; instead being on a separate scope that only the functions related to MyClass can see.\n. Ho, i totally missed that this was Redux xD\n. I'm with @mark-hahn on this one. The CoffeeScript documentation mentions semicolons pretty early (so this is something many people will have read and assimilated):\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don't need to use semicolons ; to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line).\n\nSo, my interpretation from that is that semicolons are optional statement delimiters, that can be used instead of newlines. I see no reason to take them as operators. And i think their rules regarding semicolons on the original CS compiler are pretty consistent:\n``` coffeescript\nJust like you can use newlines to separate statements in a block...\nif foo\n  bar()\n  baz()\n... you can also use semicolons.\nif foo\n  bar(); baz()\nAnd just like you can have more than one newline between statements\nand the code will mean the same...\nif foo\n  bar()\nbaz()\n... you can have more than one semicolon.\nif foo\n  bar();; baz();;;;\n```\nSo i see no reason to prohibit semicolons at the end of the last statement of a block.\n. What @renekooi said, and also: it's the same behaviour as in the original CS compiler :smiley: \n. Well, i thought that adding more cases would start favouring the switch case (maybe browsers would use some hash table optimization for big switches). It does close the gap a fair bit in Firefox though: http://jsperf.com/iife-switch-vs-ternary/3. I am, however, not very sure if jsPerf results are that reliable.\n. (off-topic, let's keep this side-discussion short, @mark-hahn)\n\nWhy? It simply runs the code in the browser which is just V8.\n\nBecause the sample code is very artificial. In this case, the code does absolutely nothing, so a good compiler could optimize one entire test case, or part of it, to a no-op, thus making that test case much \"faster\" than the other one, but not telling anything at all about which approach would run better for real code.\n. Dammit, break! May i ask: was the decision to support breaks inside switch statements deliberate? I personally don't find it very fitting for switches that don't have default fall-through.\n. Add me to the interested list alongside @Avenger7x. Remember that not every user will open an issue for something that they find wrong in the project :wink: \n. > Cygwin is so bad and so horribly done it's never an ok requirement. I'd not use it even if that was the only way I had to build a project.\nSad to hear that shell compatibility between *nix-like operating systems and Windows is still so crappy.\nI remember, however, that the MinGW project provided a set of command-line tools that emulated the *nix commands, including bash, make, and the very useful things like ls, rm, grep, etc, without requiring a full POSIX system ala Cygwin. I think i had some sort of success building C++ projects on both Windows and Linux with the same Makefile using those tools; but that was long time ago, i don't know what's their current state.\n. Good. I was writing a comment on your\n\nCan I do pull request for this issue?\n\nquestion. Glad you beat me to it :smiley_cat: \nTo make this PR more complete, i think you should add a test case that failed before this fix (bonus points for a test case that enters an infinite loop in case it doesn't pass :stuck_out_tongue_closed_eyes:)\n. \n(sorry, it's been a long day xD)\n. > aah, we do\nBut that tests the prefix until form, not the postfix one, which is the one Redux had problems.\nDoes this PR make Redux have more test coverage than CS 1.x!??\n. @pjeby, if you're interested, the change regarding the semicolon as an operator instead of a statement delimiter was discussed in #174. As it can be inferred from that discussion, i'm not in favour of that change either.\nThat being said, i think the first code snippet in this issue is quite a obscure hack. I wouldn't use that unless it's the last resort, and it would need to have an explanatory comment so readers of the code can understand what the hell is going on there (which would be so painful that i'd rather consider using other module system, like CommonJS, or adding a pre-processing step to the compilation :stuck_out_tongue_closed_eyes:). So yeah, i don't think that example makes a good point for retaining that particular behaviour of the original compiler.\nNow, the bit about the:\ncoffeescript\nif x then y();\nspim()\nis very confusing IMO. I personally would expect that in order to have more than one statement in an in-line if one would need to use parentheses (i.e. if x then (y(); z()). But it kinda follows the same reasoning about the meaning of the semicolon. \nThere's however, an inconsistency with post-if form it seems. The normal if will eat all the semicolon-separated statements after it:\n``` coffeescript\nif isFriday() then haveCerelal(); catchBus()\nCompiles to:\nif (isFriday()) { haveCerelal(); catchBus(); }\n```\nBut the post-if does not eat all semicolon-separated statements before it:\n``` coffeescript\nhaveCerelal(); catchBus() if isFriday()\nCompiles to:\nhaveCerelal(); if (isFriday()) catchBus();\nAnd i don't have enough money to have cereal every day...\n```\nIs this by design or is it a bug?\n. @michaelficarra, the discussion about precedence of infix operators vs function application is outside the scope of this issue i think.\nHowever, i was asking about the behaviour in Redux. The difference i mentioned between normal if and post-if seems pretty unintuitive to me. In the original compiler the semicolon behaves as a statement delimiter, semantically equivalent to a newline, so the behaviour if a then b; c and a; b if c is pretty consistent IMO (the semicolon can be replaced by a newline and the meaning is preserved).\n. > The CSR compilation of your examples is the same as jashkenas/coffee-script.\nHo, snap. That was a total brain fart from my part. I was under the impression that if a then b(); c() compiled to if (a) b(); c(); in the original compiler :sweat: \nWell, i'll leave my comment there just to avoid rewriting the past, but it was totally wrong hehe.\n. TBH, i always thought that Node's REPL was screwing things up when SyntaxErrors were raised. I never realized that it was entering multi-line mode :sweat_smile:\nIf others also think this a particularly ugly \"feature\" of Node's REPL, i would also prefer to leave it out.\n. ",
    "jashkenas": "Hrm. I don't know about the \"correct operator precedence\"-ness of it all, but I think it's highly desirable to have:\ndefaults and defaults = options\noptions or options = defaults\n... work like this:\ndefaults and (defaults = options)\noptions or (options = defaults)\n... even though they're just longhand versions of and= and or=. They don't involve any special confusion when trying to be read. That said, they're not valid in vanilla JavaScript, so I can see the case for \"correcting\" them. Would it be too difficult to add a special case? Or is there any undesirable behavior that including the special case would allow?\n. Forsooth, doth yonder issue beckon?\n1. My ideal indenting style for regular chaining looks like this:\nobject\n     .method(arg)\n     .method2()\n     .method3()\n2. I don't think we should use indentation to support accessing members on different \"levels\" of a nested object. It would be too fiddly, syntactically.\n3. I've got very few qualms about breaking current code in the pursuit of the ideal style, so no worries about that -- we just have to agree on what the ideal style is first.\n4. I do want member accesses to be a place where indentation doesn't matter. That's why they try to be implemented the way they are. If the following line makes clear that the preceding line was left unfinished, then it should be treated as an effective continuation of the previous line, and not a new one, where indentation rules would apply. Lines that begin with a .access are continuations of the line above.\nFinally, to answer Michael's question way, way upthread, the current implicit-object-implicit-call-chaining \"support\" is actually intentional:\nfunc \n  a: b\n  c: d\n.chain(call)\n... as you can start with a filled-in version of it, and then arrive at that point by removing parens and braces. I remember having a conversation about allowing it a while back. But that said, it's extremely poor style. I'd be pretty happy to get rid of it, if that's the consensus.\n. Pinged, so here's my thinking:\nFirst of all, don't stress too much about \"official\" statuses. Because of the nature of CoffeeScript, CS and CS-Redux will always be interoperable and compatible, between each other and different versions, because we're all targeting lowest-common-denominator JavaScript here. There's much less of a chance of incompatible code than say, between Ruby 1.8 and 1.9.\nSecondly, I'd love to merge Redux in as the official compiler, once it gets to the point where it's ready to be ... and if it still has the readable-hackable nature of a nice CoffeeScript program. If it ended up as a 100,000-line Java monstrosity, for example, I'd be less keen on merging.\nSo really, no worries. At this point, both compilers work fine for the vast majority of CoffeeScript code you'd want to write, and there are other working alternatives if you want to go further afield. If there's something that's actually blocking you apart from general uncertainty -- I'd love to hear more about it.\n. > Is there any chance this project could be merged now to a redux branch?\nI don't think quite yet. There isn't a common codebase, so comparing it in a branch wouldn't be helpful .. and the Git history would get more confusing for all of us. Let's wait until it's deemed ready to go.\nTalk about having a jashkenas/coffee-script/redux branch, and BDFL concerns make me worried that you haven't gotten the gist of my post. Namely, if you'd like, you should be using Redux today. Do the weekend hacking sessions, use it for your day-to-day work. As far as I'm aware, it's in great shape.\n. If you're actually doing anything in any of those branches, then the performance difference demonstrated here won't be worth a damn... But that said, the ternary probably isn't too terrible. Maybe we should have a nice pretty-printer for our ternaries, in general?\n. > I think we've fixed what was a bug in jashkenas/coffee-script. \nI'd agree. We should fix it there as well.\n. >  some people would find use in catch-less try-finally constructs. I think that we might want to err on the side of caution and revert the behaviour back to how it was\nAgreed.\n. Hrm. I don't know about the \"correct operator precedence\"-ness of it all, but I think it's highly desirable to have:\ndefaults and defaults = options\noptions or options = defaults\n... work like this:\ndefaults and (defaults = options)\noptions or (options = defaults)\n... even though they're just longhand versions of and= and or=. They don't involve any special confusion when trying to be read. That said, they're not valid in vanilla JavaScript, so I can see the case for \"correcting\" them. Would it be too difficult to add a special case? Or is there any undesirable behavior that including the special case would allow?\n. Forsooth, doth yonder issue beckon?\n1. My ideal indenting style for regular chaining looks like this:\nobject\n     .method(arg)\n     .method2()\n     .method3()\n2. I don't think we should use indentation to support accessing members on different \"levels\" of a nested object. It would be too fiddly, syntactically.\n3. I've got very few qualms about breaking current code in the pursuit of the ideal style, so no worries about that -- we just have to agree on what the ideal style is first.\n4. I do want member accesses to be a place where indentation doesn't matter. That's why they try to be implemented the way they are. If the following line makes clear that the preceding line was left unfinished, then it should be treated as an effective continuation of the previous line, and not a new one, where indentation rules would apply. Lines that begin with a .access are continuations of the line above.\nFinally, to answer Michael's question way, way upthread, the current implicit-object-implicit-call-chaining \"support\" is actually intentional:\nfunc \n  a: b\n  c: d\n.chain(call)\n... as you can start with a filled-in version of it, and then arrive at that point by removing parens and braces. I remember having a conversation about allowing it a while back. But that said, it's extremely poor style. I'd be pretty happy to get rid of it, if that's the consensus.\n. Pinged, so here's my thinking:\nFirst of all, don't stress too much about \"official\" statuses. Because of the nature of CoffeeScript, CS and CS-Redux will always be interoperable and compatible, between each other and different versions, because we're all targeting lowest-common-denominator JavaScript here. There's much less of a chance of incompatible code than say, between Ruby 1.8 and 1.9.\nSecondly, I'd love to merge Redux in as the official compiler, once it gets to the point where it's ready to be ... and if it still has the readable-hackable nature of a nice CoffeeScript program. If it ended up as a 100,000-line Java monstrosity, for example, I'd be less keen on merging.\nSo really, no worries. At this point, both compilers work fine for the vast majority of CoffeeScript code you'd want to write, and there are other working alternatives if you want to go further afield. If there's something that's actually blocking you apart from general uncertainty -- I'd love to hear more about it.\n. > Is there any chance this project could be merged now to a redux branch?\nI don't think quite yet. There isn't a common codebase, so comparing it in a branch wouldn't be helpful .. and the Git history would get more confusing for all of us. Let's wait until it's deemed ready to go.\nTalk about having a jashkenas/coffee-script/redux branch, and BDFL concerns make me worried that you haven't gotten the gist of my post. Namely, if you'd like, you should be using Redux today. Do the weekend hacking sessions, use it for your day-to-day work. As far as I'm aware, it's in great shape.\n. If you're actually doing anything in any of those branches, then the performance difference demonstrated here won't be worth a damn... But that said, the ternary probably isn't too terrible. Maybe we should have a nice pretty-printer for our ternaries, in general?\n. > I think we've fixed what was a bug in jashkenas/coffee-script. \nI'd agree. We should fix it there as well.\n. >  some people would find use in catch-less try-finally constructs. I think that we might want to err on the side of caution and revert the behaviour back to how it was\nAgreed.\n. ",
    "rlidwka": "I use auto-invoking functions with do smth = -> a lot, so I'd appreciate if it'll be supported here.\n. > The typed coffeescript package links here\nIt's a mistake. It should be linked here: https://github.com/mizchi/TypedCoffeeScript\n. I use auto-invoking functions with do smth = -> a lot, so I'd appreciate if it'll be supported here.\n. > The typed coffeescript package links here\nIt's a mistake. It should be linked here: https://github.com/mizchi/TypedCoffeeScript\n. ",
    "xfix": "Just wondering, isn't\ncoffeescript\ndo (reuse = ->\n  scope = 'I have new scope'\n)\nand:\ncoffeescript\n(reuse = ->\n  scope = 'I have new scope'\n)()\nequivalent to:\ncoffeescript\nreuse = ->\n  scope = 'I have new scope'\nreuse()\n. Just wondering, isn't\ncoffeescript\ndo (reuse = ->\n  scope = 'I have new scope'\n)\nand:\ncoffeescript\n(reuse = ->\n  scope = 'I have new scope'\n)()\nequivalent to:\ncoffeescript\nreuse = ->\n  scope = 'I have new scope'\nreuse()\n. ",
    "heartsentwined": "The use case of @jashkenas is different from that of @epidemian. For \"default value assignment\" that @jashkenas mentioned, I would favor the shorthand &&=, for arguably better readability.\nHowever, @epidemian mentioned a valid use case, in that one intends to work with various different variables. For example:\ncoffeescript\nif foo && bar = funcThatReturnsSomething()\n  # do something with bar\nThis is, almost certainly, an upgrade from\ncoffeescript\nbar = funcThatReturnsSomething()\nif foo && bar\n  # do something with bar\nI think that, if coffeescript aims to be a wrapper script that provides convenience and irons out inconveniences of javascript, then I think this being a useful shorthand should already be a valid argument.\nSymmetry (hence predictability) would also be a concern. On one hand, we have the already implemented do foo = -> syntax, itself being a justified as a shorthand for recursive function use cases as I understand.\nOn the other hand, if (foo = 'foo') && (bar = 'bar') would now become, kind of, asymmetric, in that the second pair of parens are now optional, but not the first. Although I would still argue that in this case, keeping both is significantly more readable than if (foo = 'foo') && bar = 'bar', even if the programmer is allowed the choice.\n. Thanks for the pointer, I'll join discussions over there.\n. Current workaround is to pass just about any \"dummy\" statement in the catch block:\ncoffeescript\ntry\n  foo\ncatch e\n  '' # do nothing\nbaz\ncoffeescript\ntry\n  foo\ncatch e\n  true # do nothing\nbaz\n. @michaelficarra same happens to other structures too, e.g. \ncoffeescript\nif condition\n  # TODO - to be implemented\nelse \n  return false\nwould throw an error at the # TODO line\n. The use case of @jashkenas is different from that of @epidemian. For \"default value assignment\" that @jashkenas mentioned, I would favor the shorthand &&=, for arguably better readability.\nHowever, @epidemian mentioned a valid use case, in that one intends to work with various different variables. For example:\ncoffeescript\nif foo && bar = funcThatReturnsSomething()\n  # do something with bar\nThis is, almost certainly, an upgrade from\ncoffeescript\nbar = funcThatReturnsSomething()\nif foo && bar\n  # do something with bar\nI think that, if coffeescript aims to be a wrapper script that provides convenience and irons out inconveniences of javascript, then I think this being a useful shorthand should already be a valid argument.\nSymmetry (hence predictability) would also be a concern. On one hand, we have the already implemented do foo = -> syntax, itself being a justified as a shorthand for recursive function use cases as I understand.\nOn the other hand, if (foo = 'foo') && (bar = 'bar') would now become, kind of, asymmetric, in that the second pair of parens are now optional, but not the first. Although I would still argue that in this case, keeping both is significantly more readable than if (foo = 'foo') && bar = 'bar', even if the programmer is allowed the choice.\n. Thanks for the pointer, I'll join discussions over there.\n. Current workaround is to pass just about any \"dummy\" statement in the catch block:\ncoffeescript\ntry\n  foo\ncatch e\n  '' # do nothing\nbaz\ncoffeescript\ntry\n  foo\ncatch e\n  true # do nothing\nbaz\n. @michaelficarra same happens to other structures too, e.g. \ncoffeescript\nif condition\n  # TODO - to be implemented\nelse \n  return false\nwould throw an error at the # TODO line\n. ",
    "knalli": "For the records: I got it. I found in the issues / wiki that the block comment won't work. Indeed, after some regex magic  it works.\nSo an \"invalid indentation\" can be also an unsupported block comment.\n. For the records: I got it. I found in the issues / wiki that the block comment won't work. Indeed, after some regex magic  it works.\nSo an \"invalid indentation\" can be also an unsupported block comment.\n. ",
    "connec": "That kind of syntax was fantastic with jQuery:\ncoffee\n$('<a/>').css\n  'color':           'blue'\n  'text-decoration': 'underline'\n.appendTo 'body'\n==\njavascript\n$('<a/>').css({\n  'color': 'blue',\n  'text-decoration': 'underline'\n}).appendTo('body');\n. I'd be very disappointed if this didn't make it into Redux, clean chaining syntax like this is a pretty big deal for myself, and I expect others, who regularly use jQuery and other similar APIs and wish to fully utilise CoffeeScript's clean, low-parenthesis syntax.\nAlso, from what you've said (\"specifying that it is to be used as the last argument\"), would the following also not be intentional:\ncoffee\nsome_func\n  object: 'argument'\n, another_param\n. @michaelficarra: OK how about (I can't run the Redux compiler on this system, sorry):\nsetTimeout ->\n  console.log 'Look ma! No brackets!'\n, 10\nNot supporting these syntaxes could break a significant amount of production code...\n. Edit: I misunderstood the problem :(  Basically you want ? soaking to capture the full assignment expression, not just the access.\n~~The problem is records[0]?.default evaluates to the equivalent of records[0] != null ? records[0].default : undefined - so what you are trying to write is something like (records[0] != null ? records[0].default : undefined) = true, which doesn't make sense (certainly not in the alternative branch).~~\n~~You probably could give conditional expressions assignable semantics, but it doesn't feel like that is something coffeescript should do, since it's not clear what records[0] should be such that default can be set on it (e.g. when you write records[0]?.default = true, should records[0] become a vanilla object?  Why not a string or number or function or prototyped object?).~~\n. That kind of syntax was fantastic with jQuery:\ncoffee\n$('<a/>').css\n  'color':           'blue'\n  'text-decoration': 'underline'\n.appendTo 'body'\n==\njavascript\n$('<a/>').css({\n  'color': 'blue',\n  'text-decoration': 'underline'\n}).appendTo('body');\n. I'd be very disappointed if this didn't make it into Redux, clean chaining syntax like this is a pretty big deal for myself, and I expect others, who regularly use jQuery and other similar APIs and wish to fully utilise CoffeeScript's clean, low-parenthesis syntax.\nAlso, from what you've said (\"specifying that it is to be used as the last argument\"), would the following also not be intentional:\ncoffee\nsome_func\n  object: 'argument'\n, another_param\n. @michaelficarra: OK how about (I can't run the Redux compiler on this system, sorry):\nsetTimeout ->\n  console.log 'Look ma! No brackets!'\n, 10\nNot supporting these syntaxes could break a significant amount of production code...\n. Edit: I misunderstood the problem :(  Basically you want ? soaking to capture the full assignment expression, not just the access.\n~~The problem is records[0]?.default evaluates to the equivalent of records[0] != null ? records[0].default : undefined - so what you are trying to write is something like (records[0] != null ? records[0].default : undefined) = true, which doesn't make sense (certainly not in the alternative branch).~~\n~~You probably could give conditional expressions assignable semantics, but it doesn't feel like that is something coffeescript should do, since it's not clear what records[0] should be such that default can be set on it (e.g. when you write records[0]?.default = true, should records[0] become a vanilla object?  Why not a string or number or function or prototyped object?).~~\n. ",
    "ghost": "Thanks connec - that's more accurate to the way I'm actually doing it, I was just trying to provide a really simple example :)\nThere's a few modules/libraries (jQuery, fs.createWriteStream pipe, underscore) that use \"chaining\" (is that the right word?) like that, and the habit of being able to put a period at the start of the line for those chains, separating them onto separate lines makes them easy for me personally to read/undertsand. I'm sure it's wrong as mark-hahn said, so I was really hoping to ask more generally if coffeescriptredux intends to support those wrong things that folks like me are doing :)\n. Thanks connec - that's more accurate to the way I'm actually doing it, I was just trying to provide a really simple example :)\nThere's a few modules/libraries (jQuery, fs.createWriteStream pipe, underscore) that use \"chaining\" (is that the right word?) like that, and the habit of being able to put a period at the start of the line for those chains, separating them onto separate lines makes them easy for me personally to read/undertsand. I'm sure it's wrong as mark-hahn said, so I was really hoping to ask more generally if coffeescriptredux intends to support those wrong things that folks like me are doing :)\n. ",
    "ScatteredRay": "So, I'm not sure what the decided action is on this sort of thing, however it seems to me that:\n$('<a/>').css\n  'color':           'blue'\n  'text-decoration': 'underline'\n.appendTo 'body'\nis entirely non-ambiguous and likely used all over production code. IMO, I think the initial release of CoffeeScriptRedux is probably not the place to be making choices that significantly change the semantics of the languages for items that seem to be already well specified, even if a bit clunky, or cumbersome.\nNow, I only stand behind the argument so long as this sort of thing is both unambiguous and well specified, but it does seem so to me.\n. @delaaxe I'd tend to agree, in fact I feel any instance of implicit parens are error-prone and counter-productive.\nBut this is about the fact that this is a compiler for an existing, and reasonably well used existing language. With what's quite possibly hundreds of thousands of existing lines of code, many of which use these more poorly specified quirks of the language. And it's awfully naive to assume that the community is going to manually rewrite thousands of lines of code for dubious gains.\nFrankly disallowing this sort of code is the place of a strict-mode, or perhaps even something much more like coffeelint. Or perhaps this could be a valid approach, if someone wrote a source rewriting tool to perform these modifications automatically, however the problem with that, is first a parser needs to exist that can fully understand legacy CoffeeScript, and also do source location tracking. Yet since one of the major goals behind the Redux rewrite was to implement that behavior, that legacy parser is clearly not to come from the mainline codebase.\n. I'm sorry? Not sure I follow.\n. As best as I can tell, this is an error preprocessor.coffee not actually managing @context properly with multi-line []'s and the like, wheras issue #63 seems to be releated to later steps in the compiler.\n. Yeah, I think it may.\n. Because a large amount of existing code is written like that and compiles and parses just fine. Additionally, be they right or wrong, people have different stylistic opinions on how their CoffeeScript should be written, and not supporting existing methods isn't a very good way to win over existing CoffeeScript users.\n. @michaelficarra I was going to continue to work on this, but it seems that you may be strongly against merging this in even if I do finish it. Can you comment on if this is indeed the case?\n. @alexgorbatchev That seems to be where michaelficarra left it.\n. > It would also help if there was more contribution and less moaning.\nIt's a bit insulting for you to post this as a reply to my PR. While It's clearly incomplete, I am here, not \"moaning\" as you say, but attempting to contribute.\nKnowing that I would not be able to fix this in isolation, I presented some changes, and opened a PR, so that I could get comments on how this should be fixed, presenting some of my initial modifications to help guide the discussion. And then instead of starting a discussion on how this best be done. This was left at\n\nWhy is it desirable to have something like that parse? I would write it like this:\n\nSo, if you want contribution you need to make a decent attempt at communicating with potential contributors.\nNow I'm perfectly willing to start over and discuss how this could get solved properly.\nNow looking at the bug in the original compiler, My change seems to handle this well, Since it tracks the indent sizes it can then verify that the matching dedent has a matching length. Which is preferable to enforcing that all indentation in a single file has to be the same. This is behavior much more similar to the Python compiler.\nSo, can we work through the actual issues here rather than just claiming that this is not an \"actual proposal\" and closing it?\n. > I see that writing spec to duplicate existing \"bugs\" is a pretty weird affair to begin with. \nThe problem with languages without specs, and a single implementation is that \"bugs\" are spec. And fixing bugs isn't just fixing bugs, but it's rather changing spec.\nNot that changing spec is inherently net-bad but it's definitely bad by default.\n\nit simply is a matter of \"does it compile in coffee\"... it does? then it must compile in redux. \n\nI don't think we need to go quite to that extreme, I think for instance if it's a bug that manifests in poorly defined circumstances, that are unlikely to be used purposefully in existing code, it may warrant getting fixed. Weird dedent behavior described in this bug is a likely candidate for instance, unless you can argue that some sane people rely on that behavior.\n\nPerhaps assembling a list of test cases for what's currently not compiling would be a good start. This list could be in itself a spec.\n\nThat would work as a start for me, I'll begin with:\nidentity = ->\n    matrix = [1, 0, 0, 0,\n              0, 1, 0, 0,\n              0, 0, 1, 0,\n              0, 0, 0, 1]\nWhich compiles in Coffee, but not Redux. And I'd argue that that's both sane and well-specified code, and even if not the preferred style of @michaelficarra should still be supported in Redux.\n. @mark-hahn :\nThat sounds like a reasonable way to view it.\n. @michaelficarra: Then can we finally discuss the problems with this particular issue?\n. Can I get a hand writing a test for this? I'm having a hard time figuring out how I should test for this sort of thing. In particular I have no idea how I'm supposed to assert that certain types of indent-dedent pairs are supposed to trigger an error.\n. @michaelficarra Fixed.\n. I think these are similar to some of the problems I'm having... but could you perhaps try to simplify the error cases if at all possible?\n. The initial commit is easier to view with whitespace diffs turned off: https://github.com/Arelius/CoffeeScriptRedux/commit/80df46dcb7cb86732679c06d96246fe7de7e8e99?w=1\n. Fixes #152 \n. @michaelficarra, Sorry it took so long. Rebased.\n. I don't think this is the the same issue... While it is indeed correct that \nx = {1: 2,\n     3: 4}\ndoes not compile in coffee, this does:\nx = [1, 2,\n     3, 4]\nI agree that CoffeeScript isn't nor should be Python, But I think it's important to match existing CoffeeScript behavior if can be done so reasonably. I think this is a case where it can be done so reasonably.\n. @Nami-Doc Perhaps, but I'm not sure it's nearly as unambigious with nested objects and all.\n. This case seems to be ambigious enough:\n```\nf = (v) ->\n  v\nx = a: f\n      b: 2\n```\n. Interestingly enough, the original compiler compiles: \n```\nf = (v) ->\n  v\nx = [a, f\n     b, 2]\n```\nas \n```\nvar f, x;\nf = function(v) {\n  return v;\n};\nx = [a, f, b, 2];\n```\nAnd I don't know if that's good or bad.\n. I agree they they are terribly convoluted, Perhaps you know of a few more coffee-script bugs that are caused by this so we can write test cases, so if we do choose to fix this we can do it properly?\nregarding the compile result, I could agree, but compare it to how coffee compiles the comparitive object:\n```\nf = (v) ->\n  v\nx = [a, f\n     b, 2]\ny = {a: f\n     b: 2}\n```\nas\n```\nvar f, x, y;\nf = function(v) {\n  return v;\n};\nx = [a, f, b, 2];\ny = {\n  a: f({\n    b: 2\n  })\n};\n```\nMy point to was to bring up that it's not nearly so clear-cut. In response to supporting the prior like the later.\n. I think that'd be valuable, Because I think there may be a reasonable solution to this problem that doesn't cause problems elsewhere, but better tests will make that much easier.\n. So, I'm not sure what the decided action is on this sort of thing, however it seems to me that:\n$('<a/>').css\n  'color':           'blue'\n  'text-decoration': 'underline'\n.appendTo 'body'\nis entirely non-ambiguous and likely used all over production code. IMO, I think the initial release of CoffeeScriptRedux is probably not the place to be making choices that significantly change the semantics of the languages for items that seem to be already well specified, even if a bit clunky, or cumbersome.\nNow, I only stand behind the argument so long as this sort of thing is both unambiguous and well specified, but it does seem so to me.\n. @delaaxe I'd tend to agree, in fact I feel any instance of implicit parens are error-prone and counter-productive.\nBut this is about the fact that this is a compiler for an existing, and reasonably well used existing language. With what's quite possibly hundreds of thousands of existing lines of code, many of which use these more poorly specified quirks of the language. And it's awfully naive to assume that the community is going to manually rewrite thousands of lines of code for dubious gains.\nFrankly disallowing this sort of code is the place of a strict-mode, or perhaps even something much more like coffeelint. Or perhaps this could be a valid approach, if someone wrote a source rewriting tool to perform these modifications automatically, however the problem with that, is first a parser needs to exist that can fully understand legacy CoffeeScript, and also do source location tracking. Yet since one of the major goals behind the Redux rewrite was to implement that behavior, that legacy parser is clearly not to come from the mainline codebase.\n. I'm sorry? Not sure I follow.\n. As best as I can tell, this is an error preprocessor.coffee not actually managing @context properly with multi-line []'s and the like, wheras issue #63 seems to be releated to later steps in the compiler.\n. Yeah, I think it may.\n. Because a large amount of existing code is written like that and compiles and parses just fine. Additionally, be they right or wrong, people have different stylistic opinions on how their CoffeeScript should be written, and not supporting existing methods isn't a very good way to win over existing CoffeeScript users.\n. @michaelficarra I was going to continue to work on this, but it seems that you may be strongly against merging this in even if I do finish it. Can you comment on if this is indeed the case?\n. @alexgorbatchev That seems to be where michaelficarra left it.\n. > It would also help if there was more contribution and less moaning.\nIt's a bit insulting for you to post this as a reply to my PR. While It's clearly incomplete, I am here, not \"moaning\" as you say, but attempting to contribute.\nKnowing that I would not be able to fix this in isolation, I presented some changes, and opened a PR, so that I could get comments on how this should be fixed, presenting some of my initial modifications to help guide the discussion. And then instead of starting a discussion on how this best be done. This was left at\n\nWhy is it desirable to have something like that parse? I would write it like this:\n\nSo, if you want contribution you need to make a decent attempt at communicating with potential contributors.\nNow I'm perfectly willing to start over and discuss how this could get solved properly.\nNow looking at the bug in the original compiler, My change seems to handle this well, Since it tracks the indent sizes it can then verify that the matching dedent has a matching length. Which is preferable to enforcing that all indentation in a single file has to be the same. This is behavior much more similar to the Python compiler.\nSo, can we work through the actual issues here rather than just claiming that this is not an \"actual proposal\" and closing it?\n. > I see that writing spec to duplicate existing \"bugs\" is a pretty weird affair to begin with. \nThe problem with languages without specs, and a single implementation is that \"bugs\" are spec. And fixing bugs isn't just fixing bugs, but it's rather changing spec.\nNot that changing spec is inherently net-bad but it's definitely bad by default.\n\nit simply is a matter of \"does it compile in coffee\"... it does? then it must compile in redux. \n\nI don't think we need to go quite to that extreme, I think for instance if it's a bug that manifests in poorly defined circumstances, that are unlikely to be used purposefully in existing code, it may warrant getting fixed. Weird dedent behavior described in this bug is a likely candidate for instance, unless you can argue that some sane people rely on that behavior.\n\nPerhaps assembling a list of test cases for what's currently not compiling would be a good start. This list could be in itself a spec.\n\nThat would work as a start for me, I'll begin with:\nidentity = ->\n    matrix = [1, 0, 0, 0,\n              0, 1, 0, 0,\n              0, 0, 1, 0,\n              0, 0, 0, 1]\nWhich compiles in Coffee, but not Redux. And I'd argue that that's both sane and well-specified code, and even if not the preferred style of @michaelficarra should still be supported in Redux.\n. @mark-hahn :\nThat sounds like a reasonable way to view it.\n. @michaelficarra: Then can we finally discuss the problems with this particular issue?\n. Can I get a hand writing a test for this? I'm having a hard time figuring out how I should test for this sort of thing. In particular I have no idea how I'm supposed to assert that certain types of indent-dedent pairs are supposed to trigger an error.\n. @michaelficarra Fixed.\n. I think these are similar to some of the problems I'm having... but could you perhaps try to simplify the error cases if at all possible?\n. The initial commit is easier to view with whitespace diffs turned off: https://github.com/Arelius/CoffeeScriptRedux/commit/80df46dcb7cb86732679c06d96246fe7de7e8e99?w=1\n. Fixes #152 \n. @michaelficarra, Sorry it took so long. Rebased.\n. I don't think this is the the same issue... While it is indeed correct that \nx = {1: 2,\n     3: 4}\ndoes not compile in coffee, this does:\nx = [1, 2,\n     3, 4]\nI agree that CoffeeScript isn't nor should be Python, But I think it's important to match existing CoffeeScript behavior if can be done so reasonably. I think this is a case where it can be done so reasonably.\n. @Nami-Doc Perhaps, but I'm not sure it's nearly as unambigious with nested objects and all.\n. This case seems to be ambigious enough:\n```\nf = (v) ->\n  v\nx = a: f\n      b: 2\n```\n. Interestingly enough, the original compiler compiles: \n```\nf = (v) ->\n  v\nx = [a, f\n     b, 2]\n```\nas \n```\nvar f, x;\nf = function(v) {\n  return v;\n};\nx = [a, f, b, 2];\n```\nAnd I don't know if that's good or bad.\n. I agree they they are terribly convoluted, Perhaps you know of a few more coffee-script bugs that are caused by this so we can write test cases, so if we do choose to fix this we can do it properly?\nregarding the compile result, I could agree, but compare it to how coffee compiles the comparitive object:\n```\nf = (v) ->\n  v\nx = [a, f\n     b, 2]\ny = {a: f\n     b: 2}\n```\nas\n```\nvar f, x, y;\nf = function(v) {\n  return v;\n};\nx = [a, f, b, 2];\ny = {\n  a: f({\n    b: 2\n  })\n};\n```\nMy point to was to bring up that it's not nearly so clear-cut. In response to supporting the prior like the later.\n. I think that'd be valuable, Because I think there may be a reasonable solution to this problem that doesn't cause problems elsewhere, but better tests will make that much easier.\n. ",
    "asalant": "+1 We use this style of chaining extensively. Chaining is encouraged by libraries like jQuery and underscorejs so I expect many coffeescript users are using chaining sugar like this.\n. +1 We use this style of chaining extensively. Chaining is encouraged by libraries like jQuery and underscorejs so I expect many coffeescript users are using chaining sugar like this.\n. ",
    "neersighted": ":+1:\n. :+1:\n. :+1:\n. :+1:\n. ",
    "hden": "The current Redux allows multi-lined chaining\ncoffee-script\nchart = d3.select('#graph')\n.append('svg')\n.attr('width', width)\n.attr('height', height)\nThere are lots of codes such as this one below, and I would say that there is no confusion what the programmer's intensions are. Like @epidemian said, lots of people have to adjust their styles if Redux drop this.\ncoffee-script\nchart = d3.select('#graph')\n          .append('svg')\n          .attr('width', width)\n          .attr('height', height)\nSometimes unintended creations works as well, no?\n. The current Redux allows multi-lined chaining\ncoffee-script\nchart = d3.select('#graph')\n.append('svg')\n.attr('width', width)\n.attr('height', height)\nThere are lots of codes such as this one below, and I would say that there is no confusion what the programmer's intensions are. Like @epidemian said, lots of people have to adjust their styles if Redux drop this.\ncoffee-script\nchart = d3.select('#graph')\n          .append('svg')\n          .attr('width', width)\n          .attr('height', height)\nSometimes unintended creations works as well, no?\n. ",
    "devongovett": "Yep, just tried to compile a pretty big CoffeeScript app with Redux and ran into this.  CoffeeScript mainline has always been a bit fiddly with chaining, but this always worked:\ncoffeescript\na.b()\n .c()\nThat now throws an error in Redux but not the original compiler.  Redux does allow you to chain without the spaces in front of the c() call, but that doesn't look as nice as when the dots all line up nicely.  Chaining is very common in JavaScript and CoffeeScript code so I think it's important that Redux keeps production code working properly.\n. Yep, just tried to compile a pretty big CoffeeScript app with Redux and ran into this.  CoffeeScript mainline has always been a bit fiddly with chaining, but this always worked:\ncoffeescript\na.b()\n .c()\nThat now throws an error in Redux but not the original compiler.  Redux does allow you to chain without the spaces in front of the c() call, but that doesn't look as nice as when the dots all line up nicely.  Chaining is very common in JavaScript and CoffeeScript code so I think it's important that Redux keeps production code working properly.\n. ",
    "kisPocok": "Vote up for task :+1: thanks your work michaelficarra!\n. Thanks, it works very well.\n. I would use different location too, so :+1: for the task!\n. I'm just tried each way. Have you got any other idea?\nD.\n. Ok, I got it! My Nodejs was too old (0.5.x-pre). I ugpraded it with \"n\" and looks work fine.\n. Vote up for task :+1: thanks your work michaelficarra!\n. Thanks, it works very well.\n. I would use different location too, so :+1: for the task!\n. I'm just tried each way. Have you got any other idea?\nD.\n. Ok, I got it! My Nodejs was too old (0.5.x-pre). I ugpraded it with \"n\" and looks work fine.\n. ",
    "dbrans": "Any update on this?\n. Awesome, thanks.\n. Any update on this?\n. Awesome, thanks.\n. ",
    "mzedeler": "+1 to this issue. Very happy that it has been left open and keep up the good work.\n. +1 to this issue. Very happy that it has been left open and keep up the good work.\n. ",
    "myrne": "I stumbled upon this compatibility issue a few days ago, while exploring good ways to deal with promises in CoffeeScript.\nCurrently, CoffeeScript allows me to do the following:\ncoffee\ngetSomePromise(arg)\n.then (result) ->\n  console.log result\n.then null, (error) ->\n  console.error error\nor\ngetSomePromise(arg)\n  .then (result) ->\n    console.log result\n  .then null, (error) ->\n    console.error error\nBoth compile to the same JavaScript. Indentation doesn't matter, as long as the \"dot-calls\" are indented the same. If one would indent the second .then to the right, then the .then would be applied to the result expression.\nI think syntax in both cases is clear, and the results not surprising or quirky. I can't judge other implications of the parsing logic currently enabling this. If this an accident, it's a good accident, and must be kept.\nI could live with rules becoming stricter, in the sense that indentation used would matter. Either first or second example could be a parse error for all I care, potentially reserved for a different meaning later, or just for enforcing consistent indentation in source code.\nNote that I use a second .then as a trick to prevent need for parentheses. Extended exposure to CoffeeScript has made me develop an allergy to parentheses. (I do realize that using a second .then is not equivalent to just a single then, but because how errors propagate forward, it's equivalent in practice if code in first .then callback does not throw an error.)\nAlso, note that if one would do getSomePromise arg, then CoffeeScript would apply the first .then to the arg expression, (regardless of indentation of .then). For my purposes, I'd prefer if the first line would be taken as a \"finished\" expression, with .then applied to it afterwards. But I can certainly live with current state. Others might not like the implications of my preference.\n. Great to hear!\n\nI've just been working on more fulfilling OSS projects recently.\n\nWhat's fulfilling for you? Do you think this (CSR dev) is an \"unthankful\" job, or does it not excite you technically anymore?\nCommonjs-everywhere is certainly cool. Do you think you could explain somewhere how it compares to browserify? I have relied on simple concatenation of plain compiled scripts up to now, and certainly would appreciate the low-down on these matters. Also because I'm looking to open source more of my work, and therefore need to decouple stuff more. CommonJS modules are a very alluring target. Although I may in the end prefer something with asynchronous requires (e.g. AMD/RequireJS) so not all code has to be loaded at once. \n. > It's just that the remaining things to do (super, splicing, this issue, a few obscure bugs) just don't ever affect me. Also, they're not particularly challenging.\nI'd contribute if I'd understand. I really don't grok the whole thing. I wish I would. I don't know where to start really.\nWhat I'm thinking of now, is that perhaps it would be educative for me to see a full blown example different components used in a very minimal example.\nCould you for example, explain in words to me what you have done, and what still needs to be done for this particular feature? Perhaps I could help then. For me it's a learning opportunity, for you it's having something a whole lot smarter than a computer at your disposal, although I'm not as good in crunching numbers.\nIf you do, please keep in mind that I know next to nothing about compilers.\n. So if stack trace line numbers work correctly, the failing test is\ncoffee\n    eq nonce, o\n      .a()\n        .b\n          .c\nI approach this quite naively. Is it even asked for that it passes? Who asks for that this indentation style is supported? \n. coffee\n    eq nonce, o\n    .a()\n    .b\n    .c\napparently passes, as does\ncoffee\n    eq nonce, o\n      .a()\n      .b\n      .c\nWell if I'm not mistaken, that were the two things I asked for.\nIf I see these other types of indentation, I wouldn't even want that to be valid coffeescript. I even have doubts on supporting these two styles above.\n. In particular this:\ncoffee\n    eq nonce, o\n      .a()\n        .b\n      .c\nAs I see coffeescript, indentation has meaning. Here, because it's supposed to be equivalent to a consistently indented piece of code, it seems as though the indentation has become meaningless. Is that desirable?\nTo me, it seems as though this member access thing would be one of the few cases (the only case?) where I could arbitrarily indent my code. And yes, if CoffeeScript 1.6 currently supports this, I'd consider this an undesirable thing. It does enforce consistent indentation in other places.\n. All examples I see in this thread use consistent indentation. Some indeed want to indent the lines, to match up with an earlier dot for example.\n. Thanks for chiming in Nami Doc. How do you feel about that being the case?\n. My way to make a consistent rule about this would be this:\nConsider every \"expression\" on a line an \"invitation\" to start a new \"block\" (just like if expression is such an invitation). Any block that follows an invitation for a block must be indented relative to the previous block.\nPerhaps some (many) people out there currently don't indent their \"member accesses\" blocks. Or let's call them \"dot-blocks\". Complain loudly in the next release. Deprecated. Next release after that: kill it.\n. Nami: \" to break into a conversation or discussion especially to express an opinion\" (never thought I'd be teaching anyone English, lol).\n. Nami: You think this inconsistent indenting should be allowed?\n. I'm talking about this specific syntax:\ncoffee\n    eq nonce, o\n      .a()\n        .b\n      .c\nnot this\ncoffeee\neq nonce, o\n      .a()\n      .b\n      .c\nthe last example is a consistently indented \"dot-block\".\n. Examples here https://github.com/michaelficarra/CoffeeScriptRedux/issues/121 also have consistently indented dot-blocks.\n. Nami: Wait, what exactly are you arguing for? You don't like the back-and-forth indenting, it seems. Well me neither, but I don't like the \"run-away\" indenting either. Normally, indenting means something. It means a change in something. Here, it changes nothing. Or at least, that's what I'm discussing now. :)\nMaybe \ncoffee\n    eq nonce, o\n      .a()\n        .b\n          .c\nshould mean something, but I don't want it to mean the same as\ncoffee\neq nonce, o\n      .a()\n      .b\n      .c\nDo you get what I mean by \"dot-blocks\". Blocks are things that have the same indenting, and therefore belong to each other. You do \"if something\", change indenting, do a few things, go back (outdent), and then you're in the original indenting. Back in original \"context\".\ndot-blocks are special blocks that all start with a dot, and are intended for multi-line member-access. The point is that you can't arbitrarily change indenting: You'd leave the block.\nThat's a nice model I think.\n. >  instead [designed to be] accepted by the masses\nI doubt jashkenas would state that as his goal specifically.\nI think he just wanted to make a \"nicer Javascript\".\nThe inconsistency, the true inconsistency is mostly an accident I think. Not something that would help appeal with the masses or so. :)\n. Michael, I know your coffee dreams. That's what the original title for the kickstarter was I think. That has won you my sympathy.\n. >  In a world where we need backcompat, we need that too. \nI agree about non breaking things in a whim, but that what's deprecation is for. No-one says that the very next release of CS has to be Redux-based, no? The next release of CoffeeScript 1.x could introduce warnings about such syntax. It could even be two releases, or three, for all I care.\nI must admit: I don't know the exact roadmap for \"2.0\", if there is any. If indeed CSR will be the next major release of CoffeeScript then yes, it better has backwards compatibility with every quirk. But if there's still time, then the old CS code could be made to pave the way (by issuing warnings) for a new compiler, which does not have to do quirks. (I'm speaking in broad terms now).\n. Nami: Thanks, I had not seen these code examples before. Looking at them, I can kind of understand why people would like the \"run-away\" indenting. I personally never had a need for heavy method chaining (I generally dislike the idea) before I started to explore promises seriously, so I don't have much feel for how people \"see\" the chains they made. How they see them, is how they want to express them in code. And give them then chance (as CoffeeScript has), they will.\nI think jashkenas comment is a bit weird though. Technically, I think it's \"wrong\". What I mean by that is that \"significant whitespace\" in context of CoffeeScript, Python etc has meant that whitespace actually has meaning to the parser. The examples given are really examples of insignificant whitespace. Languages like Javascript and C allow this kind of stuff everywhere, as long as you remember to always \"match your braces\" (or else, hell and fury upon you).\nHis comment is otherwise a bit funny. I mean there is a kind of \"significance\" of this whitespace. Sure. To the user. But that was not what the term \"significant whitespace\" was coined for. This term belongs to the world of parsers, not to the world of user perception.\nCoffeeScript also don't allow you to  embed your programs in kind of ASCII art, as some guys who want to be funny in C and Javascript do. That's all user perception. And yes, I can appreciate \"99 bottles of beer\" seeing written in the shape of a beer bottle. Now and then. Not too often, please. :)\n. I think raganwald's comment is much more sensible. He actually proposes two different meanings for same-indent and increasing-indent, wrt to lines starting with a dot. It actually goes counter to what would be ideal for how promises work (at least, how they are specced now) because they were designed to use with chaining to prevent run-away indenting. But at least, it assigns significance for white space.\nHe mentions array and pop in his example.\nHis idea is that \".pop()\"'s on different lines but with same indent would keep referring to the array object.\nPromises may be able to be adapted (with more OO abstraction) so that a call to \"then\" modifies an underlying object. All these then (with same indent) calls would then all be applied to a kind of \"scheduler\" object.\nThe scheduler would call the next queued scheduled callback as the previous pending promise has resolved. Something like that.\nI'd whip up a prototype, but right now it cannot result in pretty coffeescript syntax. I would have keep saying\ncoffee\nscheduler.schedule -> new Promise(a)\nscheduler.schedule -> new Promise(b)\nscheduler.schedule -> new Promise(c)\nNo way to keep referring to the same object, I think.\nActually I'm wrong. It could be reasonably pretty, with a hack\nOne woud need to set the function context to the scheduler. Then syntax would be just\ncoffee\n@schedule -> apromise\n@schedule -> bpromise\n@schedule -> cpromise\nor\ncoffee\n@then -> apromise\n@then -> bpromise\n@then -> cpromise\nThe fact that this is quite terse (@ is exactly the same length as a \".\") might actually be an argument to not use these dot-blocks for this purpose. They're too precious for that.\nScheduler could be called \"promise chain\" too. Instead of a regular promise chain, represented with syntax, the chain would be represented by an object.\nHis example of multiple pops could probably work if he'd do\n``` coffee\narr =[1,2,3,4,5]\nfunc = ->\n  @pop()\n  @pop()\n  @pop()\nfunc.apply arr\narr should now be [1,2]\n```\nNot the prettiest, I must admit.\n. Craziness: raganwald, the guy arguing for different meaning of same-indenting and increasing-indenting actually is the same guy telling us about his personal style where he uses whitespace just for his own understanding of the code.\n. A hypothetical SweetArray instance could have a applyToSelf method:\n``` coffee\narr = new SweetArray([1,2,3,4,5]).applyToSelf ->\n   @pop()\n   @pop()\n   @pop()\narr.getRealArray() is [1,2]\n```\nThis is basically an alternative way for a library like jQuery to allow chaining-like syntax. It could also be implemented by my aforementioned PromiseChain. The interesting thing is that the object's individual methods (in this case pop) can return a different, otherwise meaningful value (in this case, the value that was popped).\nIMO, that reduces the question down to: How many times do you want to apply chaining to builtins like Array, String and Number? How many times of those is it that hard to wrap the native object inside a decorator (like SweetArray). Or just extend the Array prototype...\n. In fact, the value of arr is the return value of applyToSelf\n``` coffee\narr = quickWrap([1,2,3,4,5]).applyToSelf ->\n @pop()\n @pop()\n @pop()\narr is [1,2]\n```\nThe wrapper object is immediately discarded. It was only there to allow for the chaining \"syntax\". \nCase closed.\n``` coffee\narr = [1,2,3,4,5]\n$(arr).do ->\n @pop()\n @pop()\n @pop()\narr is [1,2]\n```\n. @Nami-Doc \nSo, I have delved somewhat deeper into the original thread on Hacker News:\nhttps://news.ycombinator.com/item?id=3174821\nThe point is here that jashkenas is asking raganwald how he would design syntax for a language. And indeed, raganwald answers that he'd like whitespace to be actually significant in his ideal language so that \"run-away\" indenting means something different than same-level indenting. Jeremy applauds that. So that means he actually likes (or at least - liked) the idea that \ncoffee\no\n.a()\n  .b\n    .c\nwould indeed mean something different than\ncoffee\no\n  .a()\n  .b\n  .c\nThat's the whole point of \"significant whitespace\". Hence his comment. He sees even more expressive power in whitespace than before.\n. @Nami-Doc Maybe you could ask Jeremy to give a quick comment on his current state of thinking on this?\nI wonder\n1. What his ideal indenting style for regular chaining (jQuery, promises) would be.\n2. If he wants to support an indenting style for accessing different members of the same object in succession (or same member, multiple times, of course).\n3. If he can live with (at some point) breaking current code using something that diverts from the ideal style.\n4. Or else if he want this to be the one place in CoffeeScript where indenting just doesn't matter. We have been able to live with it so far, after all. This would confirm the necessity for the weird test cases mentioned above to pass.\n. > If the following line makes clear that the preceding line was left unfinished, then it should be treated as an effective continuation of the previous line, and not a new one, where indentation rules would apply. \nI think at least wrt to current parser behavior it should be added: \"it should be treated as an effective continuation of the previous line if indent stays same or increases\", because:\ngetSomePromise(arg)\n.then (result) ->\n  console.log result\n.then null, (error) ->\n  console.error error\ndoes not equal\ngetSomePromise(arg)\n.then (result) ->\n  console.log result\n  .then null, (error) ->\n  console.error error\nand I'm thankful for that.\nOn second thought, this is probably more of an instance where some other rules (leaving function definition because of outdent) take precedence, at least in current parser. Because current parser indeed supports back-and-forth indenting of regular .access lines.\n. > I do want member accesses to be a place where indentation doesn't matter. \nSo to get this clear: You favor \ncoffee\no\n.a()\n  .b\n    .c\nand\ncoffee\no\n  .a()\n     .b\n.c\nto mean the same as\ncoffee\no\n.a()\n.b\n.c\n?\nI'd rather have it stricter, and demand starting-dots to be aligned, effectively forming a dot-block. They could be arbitrarily indented though, to allow visual aligning the \"dot-block\" with the dot on the previous line. You can also indent regular a block (say something following an if-line) as much as you want (although indent must increase by at least one).\n. Maybe I'm gonna write a new kind of parser, in the form of \nwhile(situation = nextSituation())\n  outcomes.push applyRules(situation, sortedRules)\nand just see how far I come. :) If it works, we'd have a nice list of rules, ordered by precedence.\nWith situation I mean: \"Hey WTH does this random indent or outdent, dot or colon mean?\" and situation would include entire source code, so rules can look ahead infinitely to look for clues after the current token (or so).\nBTW I don't know how current parser works.\nI do think anything I write won't be very performant, because I always tend to search for the nicest abstractions, not something that could ever be reduced to some other kind of code. But it may be a fun exercise.\n. I shouldn't have said \"new kind\", because I don't know current parsers.\nI need to study Redux and current compiler seriously, I think.\nBut there may be difference to my idea and redux, at least if I can trust the program's error message: Redux says \"unexpected [token]\", my output would say \"ambiguous blurp beyond current position\". It would do it best to look at everything beyond the current \"cursor\" position (i.e. from the point in the code where it was still unambiguous what was going on). Which could make it very slow, but that's not a concern.\n. To explain further: Most notably, there wouldn't be a \"grammar\", or at least not in the traditional sense. Just a bunch of \"rule\" functions or classes, each documented in prose, implemented however seems best to me.\nI'd want to be able to turn this:\n\nIf the following line makes clear that the preceding line was left unfinished, then it should be treated as an effective continuation of the previous line, and not a new one, where indentation rules would apply. Lines that begin with a .access are continuations of the line above.\n\ninto a self-standing piece of code (a class, or a function), that could be left in or out without any repercussion. Leave it out, and there's no indented member access. Put it in, and you have it.\n. What's the status with this?\nI just tried \ncoffee\nobject\n  .method(arg)\n  .method2()\n  .method3()\nand noticed it worked. That's pretty cool!\nThis, however, does not:\ncoffee\nstartChain()\n  .then ->\n    doSomething()\n  .then (result) ->\n    console.log result\nSyntax error on line 2, column 9: unexpected '-' (\\u002D)\n1 : startChain()\n2 :   .then ->\n^ :~~~~~~~~^\n3 :     doSomething()\n4 :   .then (result) ->\n5 :     console.log result\nThat's unfortunate, because I use this type of syntax a lot throughout my code.\n. Also, \ncoffee\nanObject\n  .someProp\n  .someOtherProp\nand node_modules/.bin/coffee --js < test.coffee gives\n/Users/meryn/Work/redux-test/node_modules/coffee-script-redux/lib/nodes.js:0\n(function (exports, require, module, __filename, __dirname) { // Generated by\n^\nRangeError: Maximum call stack size exceeded\n. @michealficarra: done\nOn Thu, Aug 22, 2013 at 10:43 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@meryn https://github.com/meryn: That looks pretty serious. Can you\nopen an issue for that?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/45#issuecomment-23124202\n.\n. I stumbled upon this compatibility issue a few days ago, while exploring good ways to deal with promises in CoffeeScript.\n\nCurrently, CoffeeScript allows me to do the following:\ncoffee\ngetSomePromise(arg)\n.then (result) ->\n  console.log result\n.then null, (error) ->\n  console.error error\nor\ngetSomePromise(arg)\n  .then (result) ->\n    console.log result\n  .then null, (error) ->\n    console.error error\nBoth compile to the same JavaScript. Indentation doesn't matter, as long as the \"dot-calls\" are indented the same. If one would indent the second .then to the right, then the .then would be applied to the result expression.\nI think syntax in both cases is clear, and the results not surprising or quirky. I can't judge other implications of the parsing logic currently enabling this. If this an accident, it's a good accident, and must be kept.\nI could live with rules becoming stricter, in the sense that indentation used would matter. Either first or second example could be a parse error for all I care, potentially reserved for a different meaning later, or just for enforcing consistent indentation in source code.\nNote that I use a second .then as a trick to prevent need for parentheses. Extended exposure to CoffeeScript has made me develop an allergy to parentheses. (I do realize that using a second .then is not equivalent to just a single then, but because how errors propagate forward, it's equivalent in practice if code in first .then callback does not throw an error.)\nAlso, note that if one would do getSomePromise arg, then CoffeeScript would apply the first .then to the arg expression, (regardless of indentation of .then). For my purposes, I'd prefer if the first line would be taken as a \"finished\" expression, with .then applied to it afterwards. But I can certainly live with current state. Others might not like the implications of my preference.\n. Great to hear!\n\nI've just been working on more fulfilling OSS projects recently.\n\nWhat's fulfilling for you? Do you think this (CSR dev) is an \"unthankful\" job, or does it not excite you technically anymore?\nCommonjs-everywhere is certainly cool. Do you think you could explain somewhere how it compares to browserify? I have relied on simple concatenation of plain compiled scripts up to now, and certainly would appreciate the low-down on these matters. Also because I'm looking to open source more of my work, and therefore need to decouple stuff more. CommonJS modules are a very alluring target. Although I may in the end prefer something with asynchronous requires (e.g. AMD/RequireJS) so not all code has to be loaded at once. \n. > It's just that the remaining things to do (super, splicing, this issue, a few obscure bugs) just don't ever affect me. Also, they're not particularly challenging.\nI'd contribute if I'd understand. I really don't grok the whole thing. I wish I would. I don't know where to start really.\nWhat I'm thinking of now, is that perhaps it would be educative for me to see a full blown example different components used in a very minimal example.\nCould you for example, explain in words to me what you have done, and what still needs to be done for this particular feature? Perhaps I could help then. For me it's a learning opportunity, for you it's having something a whole lot smarter than a computer at your disposal, although I'm not as good in crunching numbers.\nIf you do, please keep in mind that I know next to nothing about compilers.\n. So if stack trace line numbers work correctly, the failing test is\ncoffee\n    eq nonce, o\n      .a()\n        .b\n          .c\nI approach this quite naively. Is it even asked for that it passes? Who asks for that this indentation style is supported? \n. coffee\n    eq nonce, o\n    .a()\n    .b\n    .c\napparently passes, as does\ncoffee\n    eq nonce, o\n      .a()\n      .b\n      .c\nWell if I'm not mistaken, that were the two things I asked for.\nIf I see these other types of indentation, I wouldn't even want that to be valid coffeescript. I even have doubts on supporting these two styles above.\n. In particular this:\ncoffee\n    eq nonce, o\n      .a()\n        .b\n      .c\nAs I see coffeescript, indentation has meaning. Here, because it's supposed to be equivalent to a consistently indented piece of code, it seems as though the indentation has become meaningless. Is that desirable?\nTo me, it seems as though this member access thing would be one of the few cases (the only case?) where I could arbitrarily indent my code. And yes, if CoffeeScript 1.6 currently supports this, I'd consider this an undesirable thing. It does enforce consistent indentation in other places.\n. All examples I see in this thread use consistent indentation. Some indeed want to indent the lines, to match up with an earlier dot for example.\n. Thanks for chiming in Nami Doc. How do you feel about that being the case?\n. My way to make a consistent rule about this would be this:\nConsider every \"expression\" on a line an \"invitation\" to start a new \"block\" (just like if expression is such an invitation). Any block that follows an invitation for a block must be indented relative to the previous block.\nPerhaps some (many) people out there currently don't indent their \"member accesses\" blocks. Or let's call them \"dot-blocks\". Complain loudly in the next release. Deprecated. Next release after that: kill it.\n. Nami: \" to break into a conversation or discussion especially to express an opinion\" (never thought I'd be teaching anyone English, lol).\n. Nami: You think this inconsistent indenting should be allowed?\n. I'm talking about this specific syntax:\ncoffee\n    eq nonce, o\n      .a()\n        .b\n      .c\nnot this\ncoffeee\neq nonce, o\n      .a()\n      .b\n      .c\nthe last example is a consistently indented \"dot-block\".\n. Examples here https://github.com/michaelficarra/CoffeeScriptRedux/issues/121 also have consistently indented dot-blocks.\n. Nami: Wait, what exactly are you arguing for? You don't like the back-and-forth indenting, it seems. Well me neither, but I don't like the \"run-away\" indenting either. Normally, indenting means something. It means a change in something. Here, it changes nothing. Or at least, that's what I'm discussing now. :)\nMaybe \ncoffee\n    eq nonce, o\n      .a()\n        .b\n          .c\nshould mean something, but I don't want it to mean the same as\ncoffee\neq nonce, o\n      .a()\n      .b\n      .c\nDo you get what I mean by \"dot-blocks\". Blocks are things that have the same indenting, and therefore belong to each other. You do \"if something\", change indenting, do a few things, go back (outdent), and then you're in the original indenting. Back in original \"context\".\ndot-blocks are special blocks that all start with a dot, and are intended for multi-line member-access. The point is that you can't arbitrarily change indenting: You'd leave the block.\nThat's a nice model I think.\n. >  instead [designed to be] accepted by the masses\nI doubt jashkenas would state that as his goal specifically.\nI think he just wanted to make a \"nicer Javascript\".\nThe inconsistency, the true inconsistency is mostly an accident I think. Not something that would help appeal with the masses or so. :)\n. Michael, I know your coffee dreams. That's what the original title for the kickstarter was I think. That has won you my sympathy.\n. >  In a world where we need backcompat, we need that too. \nI agree about non breaking things in a whim, but that what's deprecation is for. No-one says that the very next release of CS has to be Redux-based, no? The next release of CoffeeScript 1.x could introduce warnings about such syntax. It could even be two releases, or three, for all I care.\nI must admit: I don't know the exact roadmap for \"2.0\", if there is any. If indeed CSR will be the next major release of CoffeeScript then yes, it better has backwards compatibility with every quirk. But if there's still time, then the old CS code could be made to pave the way (by issuing warnings) for a new compiler, which does not have to do quirks. (I'm speaking in broad terms now).\n. Nami: Thanks, I had not seen these code examples before. Looking at them, I can kind of understand why people would like the \"run-away\" indenting. I personally never had a need for heavy method chaining (I generally dislike the idea) before I started to explore promises seriously, so I don't have much feel for how people \"see\" the chains they made. How they see them, is how they want to express them in code. And give them then chance (as CoffeeScript has), they will.\nI think jashkenas comment is a bit weird though. Technically, I think it's \"wrong\". What I mean by that is that \"significant whitespace\" in context of CoffeeScript, Python etc has meant that whitespace actually has meaning to the parser. The examples given are really examples of insignificant whitespace. Languages like Javascript and C allow this kind of stuff everywhere, as long as you remember to always \"match your braces\" (or else, hell and fury upon you).\nHis comment is otherwise a bit funny. I mean there is a kind of \"significance\" of this whitespace. Sure. To the user. But that was not what the term \"significant whitespace\" was coined for. This term belongs to the world of parsers, not to the world of user perception.\nCoffeeScript also don't allow you to  embed your programs in kind of ASCII art, as some guys who want to be funny in C and Javascript do. That's all user perception. And yes, I can appreciate \"99 bottles of beer\" seeing written in the shape of a beer bottle. Now and then. Not too often, please. :)\n. I think raganwald's comment is much more sensible. He actually proposes two different meanings for same-indent and increasing-indent, wrt to lines starting with a dot. It actually goes counter to what would be ideal for how promises work (at least, how they are specced now) because they were designed to use with chaining to prevent run-away indenting. But at least, it assigns significance for white space.\nHe mentions array and pop in his example.\nHis idea is that \".pop()\"'s on different lines but with same indent would keep referring to the array object.\nPromises may be able to be adapted (with more OO abstraction) so that a call to \"then\" modifies an underlying object. All these then (with same indent) calls would then all be applied to a kind of \"scheduler\" object.\nThe scheduler would call the next queued scheduled callback as the previous pending promise has resolved. Something like that.\nI'd whip up a prototype, but right now it cannot result in pretty coffeescript syntax. I would have keep saying\ncoffee\nscheduler.schedule -> new Promise(a)\nscheduler.schedule -> new Promise(b)\nscheduler.schedule -> new Promise(c)\nNo way to keep referring to the same object, I think.\nActually I'm wrong. It could be reasonably pretty, with a hack\nOne woud need to set the function context to the scheduler. Then syntax would be just\ncoffee\n@schedule -> apromise\n@schedule -> bpromise\n@schedule -> cpromise\nor\ncoffee\n@then -> apromise\n@then -> bpromise\n@then -> cpromise\nThe fact that this is quite terse (@ is exactly the same length as a \".\") might actually be an argument to not use these dot-blocks for this purpose. They're too precious for that.\nScheduler could be called \"promise chain\" too. Instead of a regular promise chain, represented with syntax, the chain would be represented by an object.\nHis example of multiple pops could probably work if he'd do\n``` coffee\narr =[1,2,3,4,5]\nfunc = ->\n  @pop()\n  @pop()\n  @pop()\nfunc.apply arr\narr should now be [1,2]\n```\nNot the prettiest, I must admit.\n. Craziness: raganwald, the guy arguing for different meaning of same-indenting and increasing-indenting actually is the same guy telling us about his personal style where he uses whitespace just for his own understanding of the code.\n. A hypothetical SweetArray instance could have a applyToSelf method:\n``` coffee\narr = new SweetArray([1,2,3,4,5]).applyToSelf ->\n   @pop()\n   @pop()\n   @pop()\narr.getRealArray() is [1,2]\n```\nThis is basically an alternative way for a library like jQuery to allow chaining-like syntax. It could also be implemented by my aforementioned PromiseChain. The interesting thing is that the object's individual methods (in this case pop) can return a different, otherwise meaningful value (in this case, the value that was popped).\nIMO, that reduces the question down to: How many times do you want to apply chaining to builtins like Array, String and Number? How many times of those is it that hard to wrap the native object inside a decorator (like SweetArray). Or just extend the Array prototype...\n. In fact, the value of arr is the return value of applyToSelf\n``` coffee\narr = quickWrap([1,2,3,4,5]).applyToSelf ->\n @pop()\n @pop()\n @pop()\narr is [1,2]\n```\nThe wrapper object is immediately discarded. It was only there to allow for the chaining \"syntax\". \nCase closed.\n``` coffee\narr = [1,2,3,4,5]\n$(arr).do ->\n @pop()\n @pop()\n @pop()\narr is [1,2]\n```\n. @Nami-Doc \nSo, I have delved somewhat deeper into the original thread on Hacker News:\nhttps://news.ycombinator.com/item?id=3174821\nThe point is here that jashkenas is asking raganwald how he would design syntax for a language. And indeed, raganwald answers that he'd like whitespace to be actually significant in his ideal language so that \"run-away\" indenting means something different than same-level indenting. Jeremy applauds that. So that means he actually likes (or at least - liked) the idea that \ncoffee\no\n.a()\n  .b\n    .c\nwould indeed mean something different than\ncoffee\no\n  .a()\n  .b\n  .c\nThat's the whole point of \"significant whitespace\". Hence his comment. He sees even more expressive power in whitespace than before.\n. @Nami-Doc Maybe you could ask Jeremy to give a quick comment on his current state of thinking on this?\nI wonder\n1. What his ideal indenting style for regular chaining (jQuery, promises) would be.\n2. If he wants to support an indenting style for accessing different members of the same object in succession (or same member, multiple times, of course).\n3. If he can live with (at some point) breaking current code using something that diverts from the ideal style.\n4. Or else if he want this to be the one place in CoffeeScript where indenting just doesn't matter. We have been able to live with it so far, after all. This would confirm the necessity for the weird test cases mentioned above to pass.\n. > If the following line makes clear that the preceding line was left unfinished, then it should be treated as an effective continuation of the previous line, and not a new one, where indentation rules would apply. \nI think at least wrt to current parser behavior it should be added: \"it should be treated as an effective continuation of the previous line if indent stays same or increases\", because:\ngetSomePromise(arg)\n.then (result) ->\n  console.log result\n.then null, (error) ->\n  console.error error\ndoes not equal\ngetSomePromise(arg)\n.then (result) ->\n  console.log result\n  .then null, (error) ->\n  console.error error\nand I'm thankful for that.\nOn second thought, this is probably more of an instance where some other rules (leaving function definition because of outdent) take precedence, at least in current parser. Because current parser indeed supports back-and-forth indenting of regular .access lines.\n. > I do want member accesses to be a place where indentation doesn't matter. \nSo to get this clear: You favor \ncoffee\no\n.a()\n  .b\n    .c\nand\ncoffee\no\n  .a()\n     .b\n.c\nto mean the same as\ncoffee\no\n.a()\n.b\n.c\n?\nI'd rather have it stricter, and demand starting-dots to be aligned, effectively forming a dot-block. They could be arbitrarily indented though, to allow visual aligning the \"dot-block\" with the dot on the previous line. You can also indent regular a block (say something following an if-line) as much as you want (although indent must increase by at least one).\n. Maybe I'm gonna write a new kind of parser, in the form of \nwhile(situation = nextSituation())\n  outcomes.push applyRules(situation, sortedRules)\nand just see how far I come. :) If it works, we'd have a nice list of rules, ordered by precedence.\nWith situation I mean: \"Hey WTH does this random indent or outdent, dot or colon mean?\" and situation would include entire source code, so rules can look ahead infinitely to look for clues after the current token (or so).\nBTW I don't know how current parser works.\nI do think anything I write won't be very performant, because I always tend to search for the nicest abstractions, not something that could ever be reduced to some other kind of code. But it may be a fun exercise.\n. I shouldn't have said \"new kind\", because I don't know current parsers.\nI need to study Redux and current compiler seriously, I think.\nBut there may be difference to my idea and redux, at least if I can trust the program's error message: Redux says \"unexpected [token]\", my output would say \"ambiguous blurp beyond current position\". It would do it best to look at everything beyond the current \"cursor\" position (i.e. from the point in the code where it was still unambiguous what was going on). Which could make it very slow, but that's not a concern.\n. To explain further: Most notably, there wouldn't be a \"grammar\", or at least not in the traditional sense. Just a bunch of \"rule\" functions or classes, each documented in prose, implemented however seems best to me.\nI'd want to be able to turn this:\n\nIf the following line makes clear that the preceding line was left unfinished, then it should be treated as an effective continuation of the previous line, and not a new one, where indentation rules would apply. Lines that begin with a .access are continuations of the line above.\n\ninto a self-standing piece of code (a class, or a function), that could be left in or out without any repercussion. Leave it out, and there's no indented member access. Put it in, and you have it.\n. What's the status with this?\nI just tried \ncoffee\nobject\n  .method(arg)\n  .method2()\n  .method3()\nand noticed it worked. That's pretty cool!\nThis, however, does not:\ncoffee\nstartChain()\n  .then ->\n    doSomething()\n  .then (result) ->\n    console.log result\nSyntax error on line 2, column 9: unexpected '-' (\\u002D)\n1 : startChain()\n2 :   .then ->\n^ :~~~~~~~~^\n3 :     doSomething()\n4 :   .then (result) ->\n5 :     console.log result\nThat's unfortunate, because I use this type of syntax a lot throughout my code.\n. Also, \ncoffee\nanObject\n  .someProp\n  .someOtherProp\nand node_modules/.bin/coffee --js < test.coffee gives\n/Users/meryn/Work/redux-test/node_modules/coffee-script-redux/lib/nodes.js:0\n(function (exports, require, module, __filename, __dirname) { // Generated by\n^\nRangeError: Maximum call stack size exceeded\n. @michealficarra: done\nOn Thu, Aug 22, 2013 at 10:43 PM, Michael Ficarra\nnotifications@github.comwrote:\n\n@meryn https://github.com/meryn: That looks pretty serious. Can you\nopen an issue for that?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/45#issuecomment-23124202\n.\n. \n",
    "tomByrer": "\nMy ideal indenting style for regular chaining looks like this:\n\n+1  I like CS over JS due to it being more \"readable\" & a bit more \"standardized\".  Too much zig-zag makes code harder to scan.  It also makes it slightly more confusing to figure out what indentation is significant or not.  So dot-lining would be great.\n. > My ideal indenting style for regular chaining looks like this:\n+1  I like CS over JS due to it being more \"readable\" & a bit more \"standardized\".  Too much zig-zag makes code harder to scan.  It also makes it slightly more confusing to figure out what indentation is significant or not.  So dot-lining would be great.\n. ",
    "tgriesser": "Just tried out coffee-redux, and also ran into the issue with the .then -> chaining syntax @meryn pointed out above:\ncoffee\nSomePromise()\n  .then ->\n    'do something here'\n  .otherwise ->\n    'fail'\ndoes this look like something that'll eventually make it into this version (since the ticket is still labeled as question)?\n. Just tried out coffee-redux, and also ran into the issue with the .then -> chaining syntax @meryn pointed out above:\ncoffee\nSomePromise()\n  .then ->\n    'do something here'\n  .otherwise ->\n    'fail'\ndoes this look like something that'll eventually make it into this version (since the ticket is still labeled as question)?\n. ",
    "mdlavin": "Is the plan still to fix this?  I ran into the same issue as @tgriesser above using the latest version of redux.\n. Is the plan still to fix this?  I ran into the same issue as @tgriesser above using the latest version of redux.\n. ",
    "kossnocorp": ":+1:\n. :+1:\n. ",
    "damassi": "Totally understood.\n. Totally understood.\n. ",
    "zbowling": "How about a compiler flag that adds warnings instead? \n. How about a compiler flag that adds warnings instead? \n. ",
    "hildjj": "See https://github.com/ipython/ipython for some ideas of how to do an even better REPL that coffeescript currently has.\n. See https://github.com/ipython/ipython for some ideas of how to do an even better REPL that coffeescript currently has.\n. ",
    "goodwink": "What about UglifyJS 2 https://github.com/mishoo/UglifyJS2 would that be an easier conversion?  It will also allow us to get source maps to the minified output when using the --in-source-map option.\n. What about UglifyJS 2 https://github.com/mishoo/UglifyJS2 would that be an easier conversion?  It will also allow us to get source maps to the minified output when using the --in-source-map option.\n. ",
    "brendanjerwin": "Hey, I did some work on the syntax checker to get coffee lint support a while back. What needs to change for redux? Maybe I can get it done?\n. Why does coffeelint need to be removed?\n. Ok, as of now, the coffeelint and coffeescript compiler checkers are split apart.\nDo you think it'll be reasonable/possible to make the coffeescript compiler one automatically sniff out if redux is present?\nMaybe a --version test or something?\nI'd like to make it \"just work\" without needing to keep a long-running pull-request up to date.\n. Ok, I'll test for 2.0 in the version output and change the call accordingly.\n. Hey, I did some work on the syntax checker to get coffee lint support a while back. What needs to change for redux? Maybe I can get it done?\n. Why does coffeelint need to be removed?\n. Ok, as of now, the coffeelint and coffeescript compiler checkers are split apart.\nDo you think it'll be reasonable/possible to make the coffeescript compiler one automatically sniff out if redux is present?\nMaybe a --version test or something?\nI'd like to make it \"just work\" without needing to keep a long-running pull-request up to date.\n. Ok, I'll test for 2.0 in the version output and change the call accordingly.\n. ",
    "weyert": "Thanks. I will give it a shot in a few hours. I am supposed to wake up in one hour :+\n. Yep its working for me now! Thanks for the quick fix!!!\n. Thanks. I will give it a shot in a few hours. I am supposed to wake up in one hour :+\n. Yep its working for me now! Thanks for the quick fix!!!\n. ",
    "dalssoft": "it works! Tks. \n. it works! Tks. \n. ",
    "danielflower": "Any update on getting cscodegen into NPM? Some projects can't use non-NPM modules, and with coffee-script-redux used by ibrik, which is used by karma-coverage, code coverage is not available currently. Will cscodegen be published when coffee-script-redux comes out of beta?\nThis is related to https://github.com/karma-runner/karma-coverage/issues/60\n. Any update on getting cscodegen into NPM? Some projects can't use non-NPM modules, and with coffee-script-redux used by ibrik, which is used by karma-coverage, code coverage is not available currently. Will cscodegen be published when coffee-script-redux comes out of beta?\nThis is related to https://github.com/karma-runner/karma-coverage/issues/60\n. ",
    "sheerun": "Maybe you could extend syntax to compile to TypeScript and Source Maps to get type information. It's long shot I guess.\n. Maybe you could extend syntax to compile to TypeScript and Source Maps to get type information. It's long shot I guess.\n. ",
    "pspeter3": "The typed coffeescript package links here so does that mean that the compiler can handle optional typing?\n. Sad. Optional typing for CoffeeScript would be amazing\n. The typed coffeescript package links here so does that mean that the compiler can handle optional typing?\n. Sad. Optional typing for CoffeeScript would be amazing\n. ",
    "jtackaberry": "Same thing happens when lines start with . which is often the case when using chaining:\npython\n$.ajax('/api/foo')\n    .done(result) ->\n        alert 'done'\n    .fail ->\n        alert 'failed'\nThis compiles with CoffeeScript 1.3.3, but with CoffeScriptRedux:\nSyntax error on line 2, column 5: unexpected '.'\n1 : $.ajax('/api/foo')\n2 :     .done(result) ->\n^ :~~~~~^\n3 :         alert 'done'\n4 :     .fail ->\n5 :         alert 'failed'\n. Same thing happens when lines start with . which is often the case when using chaining:\npython\n$.ajax('/api/foo')\n    .done(result) ->\n        alert 'done'\n    .fail ->\n        alert 'failed'\nThis compiles with CoffeeScript 1.3.3, but with CoffeScriptRedux:\nSyntax error on line 2, column 5: unexpected '.'\n1 : $.ajax('/api/foo')\n2 :     .done(result) ->\n^ :~~~~~^\n3 :         alert 'done'\n4 :     .fail ->\n5 :         alert 'failed'\n. ",
    "euskode": "Is there a temporary solution to this that does not involve much refactoring? I am having the same issues myself everywhere we use .delay. This may well be the only issue preventing us from using CoffeeScriptRedux with WebStorm 6's source map support!\n. Is there a temporary solution to this that does not involve much refactoring? I am having the same issues myself everywhere we use .delay. This may well be the only issue preventing us from using CoffeeScriptRedux with WebStorm 6's source map support!\n. ",
    "jnordberg": "+1\n. +1\n. ",
    "xixixao": "I know you have a list of differences from CS, but having a tag on issues like changed/different might be useful.\n. (for future reference) I've already presented my implementation there.\n. Got here through half a year old question on super in Redux, and after 6 months... :).\nI absolutely understand that this project is now left with whatever time anyone willing to help have spare. But could someone explain to me what is the point of a half finished compiler while we have a working compiler? The roadmap now has no due dates. Wouldn't it be better to abandon this project and make sure people like @olegam don't get confused by articles which suggest using redux? Anytime I see \"Fixed in redux\" tag on the main repo, something moves inside of me. With all due respect to the contributors here...\n. @michaelficarra Is there any way to run the CS test suite with Redux (I attempted this, but the internal API is different)? If not, would nice to enable that as well.\n. I know you have a list of differences from CS, but having a tag on issues like changed/different might be useful.\n. (for future reference) I've already presented my implementation there.\n. Got here through half a year old question on super in Redux, and after 6 months... :).\nI absolutely understand that this project is now left with whatever time anyone willing to help have spare. But could someone explain to me what is the point of a half finished compiler while we have a working compiler? The roadmap now has no due dates. Wouldn't it be better to abandon this project and make sure people like @olegam don't get confused by articles which suggest using redux? Anytime I see \"Fixed in redux\" tag on the main repo, something moves inside of me. With all due respect to the contributors here...\n. @michaelficarra Is there any way to run the CS test suite with Redux (I attempted this, but the internal API is different)? If not, would nice to enable that as well.\n. ",
    "oal": "Hey, thanks for the reply. If you also include the super line etc, it fails. I added a dummy Mob class as well, which seems to compile, because it still crashes right after \"@model = 'player'\".\n``` coffeescript\nclass Mob\n    constructor: (@world, x, y, z, @name) ->\n        @mesh =\n            material:\n                transparent: no\nclass Player extends Mob\n    constructor: (@world, x, y, z, @name) ->\n        @model = 'player'\n        super(arguments...)\n        @mesh.material.transparent = yes\n```\nI'm using the latest master.\n. @gkz Interesting. In my own code it still fails after removing the super line, and it only compiles after also removing \"extends Mob\".\n. Hey, thanks for the reply. If you also include the super line etc, it fails. I added a dummy Mob class as well, which seems to compile, because it still crashes right after \"@model = 'player'\".\n``` coffeescript\nclass Mob\n    constructor: (@world, x, y, z, @name) ->\n        @mesh =\n            material:\n                transparent: no\nclass Player extends Mob\n    constructor: (@world, x, y, z, @name) ->\n        @model = 'player'\n        super(arguments...)\n        @mesh.material.transparent = yes\n```\nI'm using the latest master.\n. @gkz Interesting. In my own code it still fails after removing the super line, and it only compiles after also removing \"extends Mob\".\n. ",
    "helmutgranda": "I am going to take a wild guess and this still needs implementation, hence the \"TODO\" note.\n. I am going to take a wild guess and this still needs implementation, hence the \"TODO\" note.\n. ",
    "gregwebs": "I don't understand the second example code, do you think that is correct? The current coffeescript compiler bails on some of these things.\njs\necho 'f = (`a`) -> a + 5' | coffee -b -s\nError: Parse error on line 1: Unexpected 'JS'\nBut I have never seen the current coffee compiler generate eval: I am not sure what the point of that is. Backticks in the existing implementation are just supposed to pass through: that is what I expected.\nThis is an easy way to improve upon the existing coffee compiler: have backticks to be parseable in all circumstances and do a simple pass through. I use backticks on occasion, mostly for multi-line JSON literals right now. What I am trying to do now is add support for types via typescript: http://stackoverflow.com/questions/12874942/adding-typescript-to-coffeescript\n. I just tried Mark's example.\nHere is a normal coffee variable:\necho 'x = 3' | bin/coffee -b -j \n// Generated by CoffeeScript 2.0.0-dev\nvar x;\nx = 3;\nusing var gives no output\n``\necho 'var x = 3`' | bin/coffee -b -j\n```\n. @michaelficarra so if I understand correctly, it is convenient for your implementation to wrap the javascript in an eval. This is inconvenient for the end user since it comes with perfomance overhead and makes the generated code harder to understand. Please accept this issue as a regression vs. the original coffee compiler.\n. I still don't understand how the generated javascript in the second example is supposed to be ok. This is what I would expect the output to be:\necho '(function (a){return a + 5})(2)' | node -p\n7\nBut this is the result (note that it is failing on the outer a, not the inner)\n``\necho '((a`) -> a + 5)(2)' |  bin/coffee -b -j | node\nundefined:1\n^\nReferenceError: a is not defined\n```\n. looking at the source, it seems we need either a new JS node type that represent opaque JS, or we need to have a JS parser that can take apart the JS.\n. I tried to hack in a JS.Ignore to be used in place of the eval statement, but that gets sent to escodegen and I don't know how to make the 2 play nice together. \n. I don't like the tone this ticket has taken. I disagree with the decision to use eval, but I understand it avoids a more complex implementation. However, I opened this ticket giving an example of bizarrely generated code. The parse tree doesn't make sense just as the generated javascript doesn't make sense and generates invalid javascript by hoisting an expression out of its current location as a function argument and treating it as a function.\n. @michaelficarra that is certainly not what I wrote! I understand what it is currently being translated to. However, I don't think you are putting yourself in the shoes of the users. I doubt we could find anyone that is not hacking on the compiler that thinks the translation makes sense. If I wanted to write the current output I would write it like this:\n`a`(-> a + 5)\nDisallowing backticks in the position of function arguments (as the current compiler does) would be much more desirable than the current behavior.\n. @epidemian rather than creating a special inline construct, can't we just have a transformation that turns eval('JS') into JS? If that is too risky we could leave a marker in a comment in the eval string:\necho 'eval(\"1 + 2 // inline JS\")' | node -p \n3\n. If you want to stick with the current translation, there should be a semi-colon in the generated output rather than it being interpreted as function application. If I wanted function application I would write it that way!\na;function () {return a + 5;};\n. I don't understand the second example code, do you think that is correct? The current coffeescript compiler bails on some of these things.\njs\necho 'f = (`a`) -> a + 5' | coffee -b -s\nError: Parse error on line 1: Unexpected 'JS'\nBut I have never seen the current coffee compiler generate eval: I am not sure what the point of that is. Backticks in the existing implementation are just supposed to pass through: that is what I expected.\nThis is an easy way to improve upon the existing coffee compiler: have backticks to be parseable in all circumstances and do a simple pass through. I use backticks on occasion, mostly for multi-line JSON literals right now. What I am trying to do now is add support for types via typescript: http://stackoverflow.com/questions/12874942/adding-typescript-to-coffeescript\n. I just tried Mark's example.\nHere is a normal coffee variable:\necho 'x = 3' | bin/coffee -b -j \n// Generated by CoffeeScript 2.0.0-dev\nvar x;\nx = 3;\nusing var gives no output\n``\necho 'var x = 3`' | bin/coffee -b -j\n```\n. @michaelficarra so if I understand correctly, it is convenient for your implementation to wrap the javascript in an eval. This is inconvenient for the end user since it comes with perfomance overhead and makes the generated code harder to understand. Please accept this issue as a regression vs. the original coffee compiler.\n. I still don't understand how the generated javascript in the second example is supposed to be ok. This is what I would expect the output to be:\necho '(function (a){return a + 5})(2)' | node -p\n7\nBut this is the result (note that it is failing on the outer a, not the inner)\n``\necho '((a`) -> a + 5)(2)' |  bin/coffee -b -j | node\nundefined:1\n^\nReferenceError: a is not defined\n```\n. looking at the source, it seems we need either a new JS node type that represent opaque JS, or we need to have a JS parser that can take apart the JS.\n. I tried to hack in a JS.Ignore to be used in place of the eval statement, but that gets sent to escodegen and I don't know how to make the 2 play nice together. \n. I don't like the tone this ticket has taken. I disagree with the decision to use eval, but I understand it avoids a more complex implementation. However, I opened this ticket giving an example of bizarrely generated code. The parse tree doesn't make sense just as the generated javascript doesn't make sense and generates invalid javascript by hoisting an expression out of its current location as a function argument and treating it as a function.\n. @michaelficarra that is certainly not what I wrote! I understand what it is currently being translated to. However, I don't think you are putting yourself in the shoes of the users. I doubt we could find anyone that is not hacking on the compiler that thinks the translation makes sense. If I wanted to write the current output I would write it like this:\n`a`(-> a + 5)\nDisallowing backticks in the position of function arguments (as the current compiler does) would be much more desirable than the current behavior.\n. @epidemian rather than creating a special inline construct, can't we just have a transformation that turns eval('JS') into JS? If that is too risky we could leave a marker in a comment in the eval string:\necho 'eval(\"1 + 2 // inline JS\")' | node -p \n3\n. If you want to stick with the current translation, there should be a semi-colon in the generated output rather than it being interpreted as function application. If I wanted function application I would write it that way!\na;function () {return a + 5;};\n. ",
    "bpartridge": "Thanks! For the record, I'm working on an experimental extension of CoffeeScript as a fork of this, so I'll probably be finding (or refinding) bugs and contributing over the next few weeks.\n. Thanks! For the record, I'm working on an experimental extension of CoffeeScript as a fork of this, so I'll probably be finding (or refinding) bugs and contributing over the next few weeks.\n. ",
    "thlorenz": "Use browserify with the  coffeeify transform.\nThis will allow you to bundle all your files with sourcemaps preserved and allows debugging the original coffee script.\nWorking Demo.\nThis is compiled with the main coffee script compiler (redux failed to compile all coffee scripts in that project).\nIn order to use the redux compiler, you can use the coffeeify-redux transform with browserify instead.\n. Use browserify with the  coffeeify transform.\nThis will allow you to bundle all your files with sourcemaps preserved and allows debugging the original coffee script.\nWorking Demo.\nThis is compiled with the main coffee script compiler (redux failed to compile all coffee scripts in that project).\nIn order to use the redux compiler, you can use the coffeeify-redux transform with browserify instead.\n. ",
    "peterwmwong": "This is preventing me from moving any of my projects to Redux as I rely on a HAML-ish DSL that works perfectly fine in regular coffeescript...\nSample:\ncoffeescript\nMyView = View.extend\n  render: (_)->\n    _ '.aDiv',\n      _ '.aNestedDiv', 'some text'\n. This is preventing me from moving any of my projects to Redux as I rely on a HAML-ish DSL that works perfectly fine in regular coffeescript...\nSample:\ncoffeescript\nMyView = View.extend\n  render: (_)->\n    _ '.aDiv',\n      _ '.aNestedDiv', 'some text'\n. ",
    "jiyinyiyong": "Mine too when I try running my code:\n``` coffee\n{html, css} = require \"lilyturf\"\npage = html ->\n  @div class: \"new\",\n    @span id: \"none\", \"x\"\nstyle = css ->\n  \"html\":\n    \"css\": \"red\"\n    head:\n      fontSize: 10\n      color: @hsl 10, 20, 30\n```\n. This one? https://github.com/michaelficarra/CoffeeScriptRedux/issues/215\n\nThis coffeescript should be valid.\na b,\n  c\n  d\n. @rstacruz Yeah, I thought it would generate a link.. But I didn't saw it.\n\n\nSorry. Here's the right link:\nhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/83?source=c\n. https://github.com/michaelficarra/CoffeeScriptRedux/issues/83 again. fails when using indentation among arguments.\n. Mine too when I try running my code:\n``` coffee\n{html, css} = require \"lilyturf\"\npage = html ->\n  @div class: \"new\",\n    @span id: \"none\", \"x\"\nstyle = css ->\n  \"html\":\n    \"css\": \"red\"\n    head:\n      fontSize: 10\n      color: @hsl 10, 20, 30\n```\n. This one? https://github.com/michaelficarra/CoffeeScriptRedux/issues/215\n\nThis coffeescript should be valid.\na b,\n  c\n  d\n. @rstacruz Yeah, I thought it would generate a link.. But I didn't saw it.\n\n\nSorry. Here's the right link:\nhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/83?source=c\n. https://github.com/michaelficarra/CoffeeScriptRedux/issues/83 again. fails when using indentation among arguments.\n. ",
    "johan": "I want this pretty sorely too; there just isn't a way that's tidy to break up arguments across multiple lines in cs-redux. The only ones I have found that are legal are somewhat hideous:\n```\nsomeFunc 'some really long string, object, invocation or similar',\n'some other pretty long, hard-to-break-into-lines anything'\nsomeFunc(\n  'some really long string, object, invocation or similar'\n  'some other pretty long, hard-to-break-into-lines anything'\n)\n``\n. @michaelficarra would you consider merging and publishing this in a new release?\n. My node server has an endpoint that publishes debugging details about the running server, consumed both by people maintaining the project and not.\n. This feature request was prompted by past problems where npm dependencies were using (non-redux) coffeescript which in turn silently replaced the compile handler for.coffee` files, which in turn made parts of our server supposedly running cs-redux, getting compiled by a non-redux coffeescript.\nHaving and using this construct would have both been helpful for debugging that, and made whichever file using this provision fail to even compile when that problem showed up.\n. Sorry, I was grasping for straws there, and should have said\u00a0\"fail to even run\". It is the information I want to expose, though, and there's no existing way of surfacing it.\nrequire('child_process').spawn('coffee',['-v']).stdout.on('data', (data) -> console.log data.toString()) produces a non-representable clean-room environment unrelated to the actual current compilation env, require('./node_modules/coffee-script-redux/package.json').version is what you want to be true, not what is true.\nIf cs-redux is never supposed to be run, except as a pre-processor step, I think it would be generous to say so in its docs. It is hard to reason with \"don't do that\".\nI don't know why __DATE__, __TIME__ or __DATETIMEMS__ have more merit than something which can be used to find problems with live code \u2013 all these constants are useful for different things.\n. Sweet \u2013 thanks! Looking forward to next release.\n. I want this pretty sorely too; there just isn't a way that's tidy to break up arguments across multiple lines in cs-redux. The only ones I have found that are legal are somewhat hideous:\n```\nsomeFunc 'some really long string, object, invocation or similar',\n'some other pretty long, hard-to-break-into-lines anything'\nsomeFunc(\n  'some really long string, object, invocation or similar'\n  'some other pretty long, hard-to-break-into-lines anything'\n)\n``\n. @michaelficarra would you consider merging and publishing this in a new release?\n. My node server has an endpoint that publishes debugging details about the running server, consumed both by people maintaining the project and not.\n. This feature request was prompted by past problems where npm dependencies were using (non-redux) coffeescript which in turn silently replaced the compile handler for.coffee` files, which in turn made parts of our server supposedly running cs-redux, getting compiled by a non-redux coffeescript.\nHaving and using this construct would have both been helpful for debugging that, and made whichever file using this provision fail to even compile when that problem showed up.\n. Sorry, I was grasping for straws there, and should have said\u00a0\"fail to even run\". It is the information I want to expose, though, and there's no existing way of surfacing it.\nrequire('child_process').spawn('coffee',['-v']).stdout.on('data', (data) -> console.log data.toString()) produces a non-representable clean-room environment unrelated to the actual current compilation env, require('./node_modules/coffee-script-redux/package.json').version is what you want to be true, not what is true.\nIf cs-redux is never supposed to be run, except as a pre-processor step, I think it would be generous to say so in its docs. It is hard to reason with \"don't do that\".\nI don't know why __DATE__, __TIME__ or __DATETIMEMS__ have more merit than something which can be used to find problems with live code \u2013 all these constants are useful for different things.\n. Sweet \u2013 thanks! Looking forward to next release.\n. ",
    "sebastianhoitz": "+1\nThink about a use-case with async:\n``` coffeescript\ndata = [0,1,2,3]\nasync.eachSeries data,\n  (elm, cb) ->\n    # do someting...\n    cb()\n  (err) ->\n    console.log \"Done\"\n```\nI have this type of code all over my projects. With the current implementation, I would have to write this code like this:\n``` coffeescript\ndata = [0,1,2,3]\niterator = (elm, cb) ->\n  # do someting...\n  cb()\nasync.eachSeries data, iterator, (err) ->\n  console.log \"Done\"\n```\nwhich becomes quite hard to maintain once iterator gets longer etc.\n. +1\nThink about a use-case with async:\n``` coffeescript\ndata = [0,1,2,3]\nasync.eachSeries data,\n  (elm, cb) ->\n    # do someting...\n    cb()\n  (err) ->\n    console.log \"Done\"\n```\nI have this type of code all over my projects. With the current implementation, I would have to write this code like this:\n``` coffeescript\ndata = [0,1,2,3]\niterator = (elm, cb) ->\n  # do someting...\n  cb()\nasync.eachSeries data, iterator, (err) ->\n  console.log \"Done\"\n```\nwhich becomes quite hard to maintain once iterator gets longer etc.\n. ",
    "provegard": "+1\nJust tried to migrate a project from the original compiler to redux. I think I'm encountering this issue for code like this:\nangular.module(\"foobar\", [\"dep1\",\n    \"dep2\"])\nI get:\nSyntax error on line 2, column 4: unexpected '(INDENT)' (\\uEFEF)\n1 : angular.module(\"foobar\", [\"dep1\",\n2 :     \"dep2\"])\n^ :~~~~^\n3 :\n4 :\nAs @johan wrote, the only way around it is to skip the indentation altogether on the continuation line, but that lowers readability drastically...\n. Correction: My case can be fixed with a backslash to explicitly indicate a continuation line, except on Windows where the CR isn't properly handled by the preprocessor. I'll open a separate issue.\n. +1\nI have a lot of code exactly like this. AFAIK this is the only way to specify arguments after a function argument, unless you define the function separately and then put all arguments on one line...\n. +1\nJust tried to migrate a project from the original compiler to redux. I think I'm encountering this issue for code like this:\nangular.module(\"foobar\", [\"dep1\",\n    \"dep2\"])\nI get:\nSyntax error on line 2, column 4: unexpected '(INDENT)' (\\uEFEF)\n1 : angular.module(\"foobar\", [\"dep1\",\n2 :     \"dep2\"])\n^ :~~~~^\n3 :\n4 :\nAs @johan wrote, the only way around it is to skip the indentation altogether on the continuation line, but that lowers readability drastically...\n. Correction: My case can be fixed with a backslash to explicitly indicate a continuation line, except on Windows where the CR isn't properly handled by the preprocessor. I'll open a separate issue.\n. +1\nI have a lot of code exactly like this. AFAIK this is the only way to specify arguments after a function argument, unless you define the function separately and then put all arguments on one line...\n. ",
    "erisdev": "Looks like this still happens for the reverse case, where ?. is on the left. Also affects ?().\nValhallites% coffee --version\nCoffeeScript version 2.0.0-beta7\nValhallites% coffee -j --cli 'a?.b() ? c'\nError: Unknown expression type: IfStatement\n    at generateExpression (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:1482:19)\n    at generateExpression (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:913:21)\n    at generateStatement (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:1587:23)\n    at generateStatement (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:1876:21)\n    at Object.generate (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:2041:22)\n    at Object.CoffeeScript.jsWithSourceMap (./node_modules/coffee-script-redux/lib/module.js:80:22)\n    at processInput (./node_modules/coffee-script-redux/lib/cli.js:252:30)\n    at Object.<anonymous> (./node_modules/coffee-script-redux/lib/cli.js:293:5)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\nShould I create a new issue or can you reopen this one?\n. my hand slipped. granted, this needs a heckload of work. and comments. call it more of a proof of concept/weekend project/waste of time.\nmostly ported over from blackcoffee. I've changed some (most) of the helper function names to shorter, snappier things.\none of the specs is failing because the way I've handled the this context is wrong.\n. Related: #120, jashkenas/coffee-script#2598, numerous others. Macros have definitely been suggested before, and that's probably the best way to implement something like this.\n. @app that cases is a simple matter of the compiler optimizing out an expression that has no effect. you aren't doing anything with the function, just dropping it on the floor, so the compiler is dropping the whole expression.\n. I think I actually agree with @Nami-Doc, but then is there a way to explicitly enter multiline mode in the REPL? because that would be useful.\n. From the wiki:\n\n\nsemicolon operator: Semicolons are semantic. See the discussion in #208. They will still work at the end of most lines, but you should only use them as you would JavaScript's sequence (comma) operator. Using semicolons as line terminators has always been highly discouraged.\n\n\nI believe the parser is interpreting this as an incomplete sequence and continuing it on the next line.\n. It doesn't look like this was ever fixed.\n. Not terribly efficient I guess but would this be an acceptable workaround? Last I checked CSR didn't support back ticks, so...\ncoffeescript\nuse = ->\nuse a.b\n. It'd be kind of difficult to eliminate that call since the compiler can't be sure that the value of use itself hasn't changed. Anyways, looks like I was mistaken about the status of the backtick in redux\u2014pretty sure it used to be a syntax error, but it works now\u2014so if you prefer that solution, it's there.\n. @nami-doc ugh I wouldn't be surprised. It was a surprisingly difficult issue to actually search for.\n. @rstacruz what exactly is your command and output for that? I can't duplicate it unless there is at least one parameter before the splat. obsoive:\n% node_modules/.bin/coffee -bj --cli 'a = (@b...)->'\n// Generated by CoffeeScript 2.0.0-beta8\nvar a;\na = function () {\n  this.b = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];\n};\n. @rstacruz what in the hell\n. @fourq Really?? Where'd you hear that?\n. @alexgorbatchev forking CSR or the original? I've poked around with both codebases and this one seems to be a lot easier to navigate. Either way, do drop a comment here if you decide to go through with it.\n. - CoffeeScriptRedux maintainers pull their heads out of the sand and fix the language so that it matches ES6 semantics, breaking backwards compatibility\u2014it is CoffeeScript's \"2.0\" after all, and breaking changes have already been made. CoffeeScript in the mean time remains compatible with legacy code. The CoffeeScriptRedux compiler is renamed coffee2 or some such shit in order to coexist alongside the already mutually incompatible coffee.\nThough frankly I'm considering just making a fork with a new name and fixing this myself.\n. Maybe when ES6 ditches the curlies for indentation. :stuck_out_tongue_closed_eyes: \n. Looks like this still happens for the reverse case, where ?. is on the left. Also affects ?().\nValhallites% coffee --version\nCoffeeScript version 2.0.0-beta7\nValhallites% coffee -j --cli 'a?.b() ? c'\nError: Unknown expression type: IfStatement\n    at generateExpression (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:1482:19)\n    at generateExpression (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:913:21)\n    at generateStatement (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:1587:23)\n    at generateStatement (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:1876:21)\n    at Object.generate (./node_modules/coffee-script-redux/node_modules/escodegen/escodegen.js:2041:22)\n    at Object.CoffeeScript.jsWithSourceMap (./node_modules/coffee-script-redux/lib/module.js:80:22)\n    at processInput (./node_modules/coffee-script-redux/lib/cli.js:252:30)\n    at Object.<anonymous> (./node_modules/coffee-script-redux/lib/cli.js:293:5)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\nShould I create a new issue or can you reopen this one?\n. my hand slipped. granted, this needs a heckload of work. and comments. call it more of a proof of concept/weekend project/waste of time.\nmostly ported over from blackcoffee. I've changed some (most) of the helper function names to shorter, snappier things.\none of the specs is failing because the way I've handled the this context is wrong.\n. Related: #120, jashkenas/coffee-script#2598, numerous others. Macros have definitely been suggested before, and that's probably the best way to implement something like this.\n. @app that cases is a simple matter of the compiler optimizing out an expression that has no effect. you aren't doing anything with the function, just dropping it on the floor, so the compiler is dropping the whole expression.\n. I think I actually agree with @Nami-Doc, but then is there a way to explicitly enter multiline mode in the REPL? because that would be useful.\n. From the wiki:\n\n\nsemicolon operator: Semicolons are semantic. See the discussion in #208. They will still work at the end of most lines, but you should only use them as you would JavaScript's sequence (comma) operator. Using semicolons as line terminators has always been highly discouraged.\n\n\nI believe the parser is interpreting this as an incomplete sequence and continuing it on the next line.\n. It doesn't look like this was ever fixed.\n. Not terribly efficient I guess but would this be an acceptable workaround? Last I checked CSR didn't support back ticks, so...\ncoffeescript\nuse = ->\nuse a.b\n. It'd be kind of difficult to eliminate that call since the compiler can't be sure that the value of use itself hasn't changed. Anyways, looks like I was mistaken about the status of the backtick in redux\u2014pretty sure it used to be a syntax error, but it works now\u2014so if you prefer that solution, it's there.\n. @nami-doc ugh I wouldn't be surprised. It was a surprisingly difficult issue to actually search for.\n. @rstacruz what exactly is your command and output for that? I can't duplicate it unless there is at least one parameter before the splat. obsoive:\n% node_modules/.bin/coffee -bj --cli 'a = (@b...)->'\n// Generated by CoffeeScript 2.0.0-beta8\nvar a;\na = function () {\n  this.b = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];\n};\n. @rstacruz what in the hell\n. @fourq Really?? Where'd you hear that?\n. @alexgorbatchev forking CSR or the original? I've poked around with both codebases and this one seems to be a lot easier to navigate. Either way, do drop a comment here if you decide to go through with it.\n. - CoffeeScriptRedux maintainers pull their heads out of the sand and fix the language so that it matches ES6 semantics, breaking backwards compatibility\u2014it is CoffeeScript's \"2.0\" after all, and breaking changes have already been made. CoffeeScript in the mean time remains compatible with legacy code. The CoffeeScriptRedux compiler is renamed coffee2 or some such shit in order to coexist alongside the already mutually incompatible coffee.\nThough frankly I'm considering just making a fork with a new name and fixing this myself.\n. Maybe when ES6 ditches the curlies for indentation. :stuck_out_tongue_closed_eyes: \n. ",
    "audreyt": "Aha. Thanks for the reference -- I'll refrain from using that in the future (and perhaps js2coffee can be made to not emit it).\n. Aha. Thanks for the reference -- I'll refrain from using that in the future (and perhaps js2coffee can be made to not emit it).\n. ",
    "humanchimp": "@michaelficarra wow, thanks for the quick response.  cheers!\n. the delay didn't affect me.  i look forward to the wrath of khan. :)\n. @michaelficarra  this technique uses super as a closure variable.  I'm not sure if an approach like that would help to simplify the semantics at all.  In any case it's worth looking at\u2014I find this guy to be a rather extraordinary hacker:\nhttp://bbenvie.com/articles/2012-07-25/JavaScript-Classes-with-private-protected-and-super\n. @michaelficarra wow, thanks for the quick response.  cheers!\n. the delay didn't affect me.  i look forward to the wrath of khan. :)\n. @michaelficarra  this technique uses super as a closure variable.  I'm not sure if an approach like that would help to simplify the semantics at all.  In any case it's worth looking at\u2014I find this guy to be a rather extraordinary hacker:\nhttp://bbenvie.com/articles/2012-07-25/JavaScript-Classes-with-private-protected-and-super\n. ",
    "evrenesat": "Ok this is really weird. If I enter the commands via stdin like you, everything is ok. Even my real codes are compiling without an error. But it throws that error when I feed it like this:\ncoffee --js -i /path/to/file.coffee \n. Apperantly it was not weird that much; msdos style line endings are cause of the problem. (PyCharm's \"system-dependend\" option somehow defaults to msdos style on Linux).\nAfter passing this and fixing a few more CS1.4 allowed looseness I hit this error and stuck:\nUnexpected '[]'\nI've placed square brackets by hand but actually error message contains a rectangle symbol (look like this []) between the quotes which was disappeared while pasting here.\n. Still giving the same error with latest revision but I've caught the error by clipping my code block by block.\n```\nT =\n    foo: ->\n        a = z(4, {\n            'q': 1, \n            'w': 2,\n            })\nx: 1\n\nbin/coffee --js -i test.coffee\nUnexpected '\ueffe'\n```\nlooks like it gives a bit more understandable error if there isn't anything after erroneous block.\n```\nT =\n    foo: ->\n        a = z(4, {\n            'q': 1, \n            'w': 2,\n            })\n#x: 1\n\nbin/coffee --js -i test.coffee\nUnclosed '{' at EOF\n```\nit gives proper error message if I come closer to solution by dedenting the dict definition:\n```\nT =\n    foo: ->\n        a = z(4, {\n        'q': 1,\n        'w': 2,\n        })\nx: 1\n\nbin/coffee --js -i test.coffee\nSyntax error on line 4, column 9: unexpected '\\'' (\\u0027)\n1 : T =\n2 :     foo: ->\n3 :         a = z(4, {\n4 :         'q': 1,\n^ :~~~~~~~~~^\n5 :         'w': 2,\n6 :         })\n7 : \n```\nand taking the first line of dict next to curly bracket finally fix the problem. hurray!\n```\nT =\n    foo: ->\n        a = z(4, {'q': 1,\n        'w': 2,\n        })\nx: 1\n\nbin/coffee --js -i test.coffee\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var T;\n  T = {\n    foo: function () {\n      var a;\n      return a = z(4, {\n        'q': 1,\n        'w': 2\n      });\n    },\n    x: 1\n  };\n}.call(this);\n``\n. Ok this is really weird. If I enter the commands via stdin like you, everything is ok. Even my real codes are compiling without an error. But it throws that error when I feed it like this:coffee --js -i /path/to/file.coffee` \n. Apperantly it was not weird that much; msdos style line endings are cause of the problem. (PyCharm's \"system-dependend\" option somehow defaults to msdos style on Linux).\nAfter passing this and fixing a few more CS1.4 allowed looseness I hit this error and stuck:\nUnexpected '[]'\nI've placed square brackets by hand but actually error message contains a rectangle symbol (look like this []) between the quotes which was disappeared while pasting here.\n. Still giving the same error with latest revision but I've caught the error by clipping my code block by block.\n```\nT =\n    foo: ->\n        a = z(4, {\n            'q': 1, \n            'w': 2,\n            })\nx: 1\n\nbin/coffee --js -i test.coffee\nUnexpected '\ueffe'\n```\nlooks like it gives a bit more understandable error if there isn't anything after erroneous block.\n```\nT =\n    foo: ->\n        a = z(4, {\n            'q': 1, \n            'w': 2,\n            })\n#x: 1\n\nbin/coffee --js -i test.coffee\nUnclosed '{' at EOF\n```\nit gives proper error message if I come closer to solution by dedenting the dict definition:\n```\nT =\n    foo: ->\n        a = z(4, {\n        'q': 1,\n        'w': 2,\n        })\nx: 1\n\nbin/coffee --js -i test.coffee\nSyntax error on line 4, column 9: unexpected '\\'' (\\u0027)\n1 : T =\n2 :     foo: ->\n3 :         a = z(4, {\n4 :         'q': 1,\n^ :~~~~~~~~~^\n5 :         'w': 2,\n6 :         })\n7 : \n```\nand taking the first line of dict next to curly bracket finally fix the problem. hurray!\n```\nT =\n    foo: ->\n        a = z(4, {'q': 1,\n        'w': 2,\n        })\nx: 1\n\nbin/coffee --js -i test.coffee\n// Generated by CoffeeScript 2.0.0-dev\nvoid function () {\n  var T;\n  T = {\n    foo: function () {\n      var a;\n      return a = z(4, {\n        'q': 1,\n        'w': 2\n      });\n    },\n    x: 1\n  };\n}.call(this);\n```\n. ",
    "texastoland": "I looked into doing this with Redux last night. I expect just additions to grammar, compiler, and nodes files. These kinds of modifications could be abstracted if it's a common use case? I expect you have a vision for plugins though.\n. I looked into doing this with Redux last night. I expect just additions to grammar, compiler, and nodes files. These kinds of modifications could be abstracted if it's a common use case? I expect you have a vision for plugins though.\n. ",
    "dokuboyejo": "I just had a similar issue, the following helped me resolve it:\ngit config --global url.\"https://github.com/\".insteadOf git@github.com:\ngit config --global url.\"https://\".insteadOf git://\n. I just had a similar issue, the following helped me resolve it:\ngit config --global url.\"https://github.com/\".insteadOf git@github.com:\ngit config --global url.\"https://\".insteadOf git://\n. ",
    "jrozner": "Definitely not a 5 minute fix unless you mean to exit if the input is a directory. I've added support for directory structures to be walked for compilation but the processInput was not written to support multiple input files and the output functionality does not seem to actually be implemented yet though is a requirement for input to be a directory. I've written a method to walk the directory tree but still need to refactor processInput and implement the output method in order to have this working. Depending on time I may be able to finish this by the end of the week.\n. Sorry, I think I misunderstood what the function of --input was supposed to be doing. Is it simply just used for execution of a specific file/directory where the directory would look for index.coffee or is it used to provide a directory of files that should be compiled and outputed to a new directory retaining the original directory structure. If adding support for simply running the index.coffee if a directory is the intended functionality then it is indeed just a 5 minute fix if not less.\n. Is there anything else that still needs to be changed?\n. Definitely not a 5 minute fix unless you mean to exit if the input is a directory. I've added support for directory structures to be walked for compilation but the processInput was not written to support multiple input files and the output functionality does not seem to actually be implemented yet though is a requirement for input to be a directory. I've written a method to walk the directory tree but still need to refactor processInput and implement the output method in order to have this working. Depending on time I may be able to finish this by the end of the week.\n. Sorry, I think I misunderstood what the function of --input was supposed to be doing. Is it simply just used for execution of a specific file/directory where the directory would look for index.coffee or is it used to provide a directory of files that should be compiled and outputed to a new directory retaining the original directory structure. If adding support for simply running the index.coffee if a directory is the intended functionality then it is indeed just a 5 minute fix if not less.\n. Is there anything else that still needs to be changed?\n. ",
    "ghempton": "@michaelficarra will do\n. Yeah you are right about the -> debugger case being an issue right now. Will add these tests and look into getting them to pass.\n. @michaelficarra done.\n. @michaelficarra amended the last commit per your suggestion. /r comments: agreed :)\n. done\n. @michaelficarra Thanks for the update! I am very excited for the future of this project and it becoming the de facto coffee script compiler.\nI am also casually working on EmberScript and hope to be contributing back upstream to CSR.\n. :thumbsup: \n. Cool, looking forward to that being merged in.\n. nice work! the parser feels way cleaner\n. Fyi, its super easy. Once this is merged, just log into travis ci with github and toggle this repo.\n. @michaelficarra done\n. @michaelficarra just changed it to something you might find more palatable\n. @michaelficarra how about this one?\n. @michaelficarra done\n. Yeah looks like it is. It must be broken on the original CS too.\nOn Thu, Jan 10, 2013 at 3:18 PM, Nami-Doc notifications@github.com wrote:\n\nI Still think runScripts is broken. Why is the next script loading\ntriggered only if the current doesn't have an src ? (do execute is in the\nelse clause)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/134#issuecomment-12124133.\n\n\nGordon L. Hempton\nhttp://codebrief.com\n360.460.8098\n. NM, no its not broken, it passes execute as the callback to load\nOn Thu, Jan 10, 2013 at 3:22 PM, Gordon Leland Hempton\nghempton@gmail.comwrote:\n\nYeah looks like it is. It must be broken on the original CS too.\nOn Thu, Jan 10, 2013 at 3:18 PM, Nami-Doc notifications@github.comwrote:\n\nI Still think runScripts is broken. Why is the next script loading\ntriggered only if the current doesn't have an src ? (do execute is in\nthe else clause)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/134#issuecomment-12124133.\n\n\nGordon L. Hempton\nhttp://codebrief.com\n360.460.8098\n\n\nGordon L. Hempton\nhttp://codebrief.com\n360.460.8098\n. @michaelficarra I am building it myself. It builds fine, the error is when it is included into the browser. I have also ran npm update.\n. Sorry to be a nuisance, but now I am getting a new error (looks to be from the same spot, however):\nUncaught TypeError: Cannot read property 'EventEmitter' of null all.js:39517\nrequire.define.StringScanner.str all.js:39517\nrequire all.js:9513\nrequire.define.module.exports.name all.js:9607\nrequire all.js:9513\nrequire.define.formatParserError all.js:9527\nrequire all.js:9513\n(anonymous function) all.js:40034\n(anonymous function)\nAny thoughts on what a fix might be? I haven't spent much time looking at these new build tools.\n. Was able to fix this by using the above PR. :beers: \n. I'm not sure what is going on exactly, but I think there might be some listener leaks.\n. I am in this existential crisis as well. I prefer the conciseness of CS, but ES6 is obviously the way forward. I've always thought that a small language that is a close relative to ES6 and CS would be a great alternative. Specifically it would be ES6 with the following minimal set additional CS-related features:\n1. Indentation-based (maybe optional curlies a la Stylus)\n2. Statements are always expressions when possible (e.g. if/else, functions return their last value etc.)\n3. Support for @\n4. Some additional (but not conflicting) operators (e.g. the elvis operator)\nAll other features, classes, destructuring, for of loops, arrow functions, etc. would just rely on ES6. This minimal language (minscript?) would seems like it wouldn't be incredibly difficult to build as it would just output ES6 and then rely on an intermediate transpiler.\n. :heart: \n. @michaelficarra will do\n. Yeah you are right about the -> debugger case being an issue right now. Will add these tests and look into getting them to pass.\n. @michaelficarra done.\n. @michaelficarra amended the last commit per your suggestion. /r comments: agreed :)\n. done\n. @michaelficarra Thanks for the update! I am very excited for the future of this project and it becoming the de facto coffee script compiler.\nI am also casually working on EmberScript and hope to be contributing back upstream to CSR.\n. :thumbsup: \n. Cool, looking forward to that being merged in.\n. nice work! the parser feels way cleaner\n. Fyi, its super easy. Once this is merged, just log into travis ci with github and toggle this repo.\n. @michaelficarra done\n. @michaelficarra just changed it to something you might find more palatable\n. @michaelficarra how about this one?\n. @michaelficarra done\n. Yeah looks like it is. It must be broken on the original CS too.\nOn Thu, Jan 10, 2013 at 3:18 PM, Nami-Doc notifications@github.com wrote:\n\nI Still think runScripts is broken. Why is the next script loading\ntriggered only if the current doesn't have an src ? (do execute is in the\nelse clause)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/134#issuecomment-12124133.\n\n\nGordon L. Hempton\nhttp://codebrief.com\n360.460.8098\n. NM, no its not broken, it passes execute as the callback to load\nOn Thu, Jan 10, 2013 at 3:22 PM, Gordon Leland Hempton\nghempton@gmail.comwrote:\n\nYeah looks like it is. It must be broken on the original CS too.\nOn Thu, Jan 10, 2013 at 3:18 PM, Nami-Doc notifications@github.comwrote:\n\nI Still think runScripts is broken. Why is the next script loading\ntriggered only if the current doesn't have an src ? (do execute is in\nthe else clause)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/134#issuecomment-12124133.\n\n\nGordon L. Hempton\nhttp://codebrief.com\n360.460.8098\n\n\nGordon L. Hempton\nhttp://codebrief.com\n360.460.8098\n. @michaelficarra I am building it myself. It builds fine, the error is when it is included into the browser. I have also ran npm update.\n. Sorry to be a nuisance, but now I am getting a new error (looks to be from the same spot, however):\nUncaught TypeError: Cannot read property 'EventEmitter' of null all.js:39517\nrequire.define.StringScanner.str all.js:39517\nrequire all.js:9513\nrequire.define.module.exports.name all.js:9607\nrequire all.js:9513\nrequire.define.formatParserError all.js:9527\nrequire all.js:9513\n(anonymous function) all.js:40034\n(anonymous function)\nAny thoughts on what a fix might be? I haven't spent much time looking at these new build tools.\n. Was able to fix this by using the above PR. :beers: \n. I'm not sure what is going on exactly, but I think there might be some listener leaks.\n. I am in this existential crisis as well. I prefer the conciseness of CS, but ES6 is obviously the way forward. I've always thought that a small language that is a close relative to ES6 and CS would be a great alternative. Specifically it would be ES6 with the following minimal set additional CS-related features:\n1. Indentation-based (maybe optional curlies a la Stylus)\n2. Statements are always expressions when possible (e.g. if/else, functions return their last value etc.)\n3. Support for @\n4. Some additional (but not conflicting) operators (e.g. the elvis operator)\nAll other features, classes, destructuring, for of loops, arrow functions, etc. would just rely on ES6. This minimal language (minscript?) would seems like it wouldn't be incredibly difficult to build as it would just output ES6 and then rely on an intermediate transpiler.\n. :heart: \n. ",
    "srdjan": "this would be very good to know... +1\n. +1\nOn Sat, Mar 16, 2013 at 1:19 PM, backspaces notifications@github.comwrote:\n\nIs it possible for CSR to target asm.js? This would absolute switch me in\na heartbeat! I realize some work by the programmer would be required but if\na list of CSR styles (num|0, +num, indication of static objects, typed\narray usage etc) were available, it would be appreciated.\nIt may simply not be a good match. But if so, lots of us would be\ninterested.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/106#issuecomment-15008472\n.\n. +1\n. this would be very good to know... +1\n. +1\n\nOn Sat, Mar 16, 2013 at 1:19 PM, backspaces notifications@github.comwrote:\n\nIs it possible for CSR to target asm.js? This would absolute switch me in\na heartbeat! I realize some work by the programmer would be required but if\na list of CSR styles (num|0, +num, indication of static objects, typed\narray usage etc) were available, it would be appreciated.\nIt may simply not be a good match. But if so, lots of us would be\ninterested.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/106#issuecomment-15008472\n.\n. +1\n. \n",
    "alexkirsz": "+1\n. +1\n. ",
    "surjikal": "@michaelficarra Thanks for the update! Do you have an ETA for the super feature? It's the only thing holding me back from using your compiler. \n. @michaelficarra I'm using super for a backbone-based web app. Exactly what @paulmillr said :)\n. Sorry about that :-1: \n. @michaelficarra Thanks for the update! Do you have an ETA for the super feature? It's the only thing holding me back from using your compiler. \n. @michaelficarra I'm using super for a backbone-based web app. Exactly what @paulmillr said :)\n. Sorry about that :-1: \n. ",
    "rosenfeld": "Just to let you know, one of the main reasons I chose CS was because it has built-in sugar for OO programming and I use classes all the time and \"super\" is just an integral part of OO programming. I use it a lot and I don't use backbone in my applications.\n. Just to let you know, one of the main reasons I chose CS was because it has built-in sugar for OO programming and I use classes all the time and \"super\" is just an integral part of OO programming. I use it a lot and I don't use backbone in my applications.\n. ",
    "tonqa": "Could you please update us on this issue? \nwe are waiting for this a lot.\n. Please support the super keyword, which is really essential for this language. I know so many projects, which are waiting for this issue to be fixed, it really hinders the adoption of this project. 'To be ready' means at least supporting the main syntax of Coffeescript, so you should at least add this to the project before finishing.\n. Could you please update us on this issue? \nwe are waiting for this a lot.\n. Please support the super keyword, which is really essential for this language. I know so many projects, which are waiting for this issue to be fixed, it really hinders the adoption of this project. 'To be ready' means at least supporting the main syntax of Coffeescript, so you should at least add this to the project before finishing.\n. ",
    "smeevil": "Just an other shout out for the support of \"super\" :)\n. Just an other shout out for the support of \"super\" :)\n. ",
    "backspaces": "Is it possible for CSR to target asm.js?  This would absolute switch me in a heartbeat!  I realize some work by the programmer would be required but if a list of CSR styles (num|0, +num, indication of static objects, typed array usage etc) were available, it would be appreciated.\nIt may simply not be a good match.  But if so, lots of us would be interested.\n. Actually, rather than asm.js .. which I think Bruno addressed nicely\nhttps://groups.google.com/forum/#!msg/coffeescript/0LlXx2vFUrQ/LjIcmY9HSBQJ\n.. the more important question is: will CSR have a greater chance to target new versions of JS?\nIt hadn't occurred to me when I started using CS that the JS engines are a moving target.  On the other hand, CSR should be able to target newer JS versions, right?\n. Isn't the real question \"How will CoffeeScript with ES6\"?  I.e. the point of CSR is to have a more flexible, more formal compiler .. so given that we know ES6 is soon upon us, shouldn't we consider how CS2.0 should evolve?\nOr maybe simply: so much of ES6 was inspired by CS, are we even sure we need CSnext?  I think we do, because JavaScript is simply too dangerous for Most Of Us.\nBut any conversation about CSR w/o ES6 is flawed.\n. Is it possible for CSR to target asm.js?  This would absolute switch me in a heartbeat!  I realize some work by the programmer would be required but if a list of CSR styles (num|0, +num, indication of static objects, typed array usage etc) were available, it would be appreciated.\nIt may simply not be a good match.  But if so, lots of us would be interested.\n. Actually, rather than asm.js .. which I think Bruno addressed nicely\nhttps://groups.google.com/forum/#!msg/coffeescript/0LlXx2vFUrQ/LjIcmY9HSBQJ\n.. the more important question is: will CSR have a greater chance to target new versions of JS?\nIt hadn't occurred to me when I started using CS that the JS engines are a moving target.  On the other hand, CSR should be able to target newer JS versions, right?\n. Isn't the real question \"How will CoffeeScript with ES6\"?  I.e. the point of CSR is to have a more flexible, more formal compiler .. so given that we know ES6 is soon upon us, shouldn't we consider how CS2.0 should evolve?\nOr maybe simply: so much of ES6 was inspired by CS, are we even sure we need CSnext?  I think we do, because JavaScript is simply too dangerous for Most Of Us.\nBut any conversation about CSR w/o ES6 is flawed.\n. ",
    "waynehoover": "Is this project still aiming to replace the official coffeescript compiler? Any new updates on its current state?\n. Is this project still aiming to replace the official coffeescript compiler? Any new updates on its current state?\n. ",
    "alexgorbatchev": "+1\n. :+1: existing code must compile\n. If i'm not mistaken, in #45 it was decided to not support existing CoffeeScript markup... am I right?\n. :+1: \n. Lets everyone look at this positively. I don't think anyone is trying to hurt anyone. I undersand @michaelficarra desire for the more concrete spec. At the same time I see that writing spec to duplicate existing \"bugs\" is a pretty weird affair to begin with. The problem here is that this projects aims to be a better compiler for currently existing and pretty popular language. This unfortunately dictates that all existing code must parse (or we have ourselves a fork). It's not a matter of stylistic preferences or how one thinks it is better for format code, it simply is a matter of \"does it compile in coffee\"... it does? then it must compile in redux. \nPerhaps assembling a list of test cases for what's currently not compiling would be a good start. This list could be in itself a spec.\nThought?\n. better example\n```\napp\n  .module()\nconsole.log 'foo'\n```\nerror\nSyntax error on line 2, column 3: unexpected '.' (\\u002E)\n1 : app\n2 : .module()\n^ :~~^\n3 : \n4 : console.log 'foo'\n. Found that decision was made not to be compatible with CoffeeScript... shame #45\n. :+1: \n. I'm currently considering forking coffeescript to do proper implementation of ES6 stuff... I'm baffled by lack of progress on that side.\n. havent looked into which specific repo to use as base yet\n. +1\n. :+1: existing code must compile\n. If i'm not mistaken, in #45 it was decided to not support existing CoffeeScript markup... am I right?\n. :+1: \n. Lets everyone look at this positively. I don't think anyone is trying to hurt anyone. I undersand @michaelficarra desire for the more concrete spec. At the same time I see that writing spec to duplicate existing \"bugs\" is a pretty weird affair to begin with. The problem here is that this projects aims to be a better compiler for currently existing and pretty popular language. This unfortunately dictates that all existing code must parse (or we have ourselves a fork). It's not a matter of stylistic preferences or how one thinks it is better for format code, it simply is a matter of \"does it compile in coffee\"... it does? then it must compile in redux. \nPerhaps assembling a list of test cases for what's currently not compiling would be a good start. This list could be in itself a spec.\nThought?\n. better example\n```\napp\n  .module()\nconsole.log 'foo'\n```\nerror\nSyntax error on line 2, column 3: unexpected '.' (\\u002E)\n1 : app\n2 : .module()\n^ :~~^\n3 : \n4 : console.log 'foo'\n. Found that decision was made not to be compatible with CoffeeScript... shame #45\n. :+1: \n. I'm currently considering forking coffeescript to do proper implementation of ES6 stuff... I'm baffled by lack of progress on that side.\n. havent looked into which specific repo to use as base yet\n. ",
    "thedjpetersen": "+1\n. +1\n. ",
    "kevinmehall": "I think this is ready for review.\nThe one thing that remains missing is that the line of error context above the stack trace is shown in JavaScript.\nThere's no robust way to get that line of JavaScript source code (to replicate what Node normally does if the error is originally thrown in JS code). Node itself does it in C++, and there's no chance to determine whether that top stack frame is CS or JS before overriding the default behavior.\nMy opinion is to leave that out until maybe v8 or Node get a better stack trace API. We have the CoffeeScript lineno on the next line, and that's the important part.\n. Fixed or commented on those notes.\nWhile testing formatSourcePosition, I also found that the stack trace formatter in a more recent v8 does a better job associating a name with anonymous functions (important for CoffeeScript where all functions are declared anonymously), so I based the sourceMap-modified formatter on that version instead.\n. This is actually already possible and easy with pegjs:\nmain = expr\nexpr = \"(\" fn:[abcd] subexpr:((\" \" e:expr){return e})? \")\"\n  { return {start:offset, end:pos,\n            raw:input.substring(offset, pos),\n            fn:fn, subexpr:subexpr};\n  }\nWhich parses (a (b (c))):\n{ start: 0,\n  end: 11,\n  raw: '(a (b (c)))',\n  fn: 'a',\n  subexpr: \n   { start: 3,\n     end: 10,\n     raw: '(b (c))',\n     fn: 'b',\n     subexpr: \n      { start: 6,\n        end: 9,\n        raw: '(c)',\n        fn: 'c',\n        subexpr: '' } } }\nThat pos variable is in lexical scope in parser actions, but it's undocumented. I've added an issue dmajda/pegjs#131 on pegjs to officially expose this in the API.\n. jashkenas/coffee-script explicitly claims support for throw as an expression, both in the changelog for 1.2.0 (\"The throw statement can now be used as part of an expression.\") and in the tests.\n. I think this is ready for review.\nThe one thing that remains missing is that the line of error context above the stack trace is shown in JavaScript.\nThere's no robust way to get that line of JavaScript source code (to replicate what Node normally does if the error is originally thrown in JS code). Node itself does it in C++, and there's no chance to determine whether that top stack frame is CS or JS before overriding the default behavior.\nMy opinion is to leave that out until maybe v8 or Node get a better stack trace API. We have the CoffeeScript lineno on the next line, and that's the important part.\n. Fixed or commented on those notes.\nWhile testing formatSourcePosition, I also found that the stack trace formatter in a more recent v8 does a better job associating a name with anonymous functions (important for CoffeeScript where all functions are declared anonymously), so I based the sourceMap-modified formatter on that version instead.\n. This is actually already possible and easy with pegjs:\nmain = expr\nexpr = \"(\" fn:[abcd] subexpr:((\" \" e:expr){return e})? \")\"\n  { return {start:offset, end:pos,\n            raw:input.substring(offset, pos),\n            fn:fn, subexpr:subexpr};\n  }\nWhich parses (a (b (c))):\n{ start: 0,\n  end: 11,\n  raw: '(a (b (c)))',\n  fn: 'a',\n  subexpr: \n   { start: 3,\n     end: 10,\n     raw: '(b (c))',\n     fn: 'b',\n     subexpr: \n      { start: 6,\n        end: 9,\n        raw: '(c)',\n        fn: 'c',\n        subexpr: '' } } }\nThat pos variable is in lexical scope in parser actions, but it's undocumented. I've added an issue dmajda/pegjs#131 on pegjs to officially expose this in the API.\n. jashkenas/coffee-script explicitly claims support for throw as an expression, both in the changelog for 1.2.0 (\"The throw statement can now be used as part of an expression.\") and in the tests.\n. ",
    "kevinrobinson": "Ahh, thanks Michael!\n. Ahh, thanks Michael!\n. ",
    "mlogan": "Michael,\nRegardless of the outcome of this particular PR, would you please clarify whether backwards compatibility with existing CoffeeScript code is a goal of CoffeeScriptRedux? Your silence on this PR casts doubt on that question.\nThanks,\nMark\n. Michael,\nRegardless of the outcome of this particular PR, would you please clarify whether backwards compatibility with existing CoffeeScript code is a goal of CoffeeScriptRedux? Your silence on this PR casts doubt on that question.\nThanks,\nMark\n. ",
    "swayf": "what about https://github.com/jashkenas/coffee-script/pull/3171 ? \nlike https://github.com/paiq/blackcoffee\n. what about https://github.com/jashkenas/coffee-script/pull/3171 ? \nlike https://github.com/paiq/blackcoffee\n. ",
    "devinus": "I would really love to see at least one CS inspired compile-to-JS language that takes huge risks like this.\n. I would really love to see at least one CS inspired compile-to-JS language that takes huge risks like this.\n. ",
    "JamesMaroney": "+1 We use this syntax quite a lot in a very large codebase. I would absolutely love to have source maps, but moving from that syntax just wouldn't work for us. :(\n. @michaelficarra Any thoughts on this? I am still working on wrapping this up. I'd like to know if I'm working in a direction you find acceptable though.\n. I did maintain the stdin/stdout behavior for default. The file overrides\nshould just provide additional features.\nThe biggest win is in the ability to link the js and source maps since the\ntool is writing them both in one pass.\n. Yes, I just verified, but this still works: echo \"i=0\" | coffee --js and\nwrites out to stdout\nThe way I did that is basically the output options go through 3 possible\nstates: unset, stdout, or specified file\nso, no --js doesn't set the option, --js sets the option, with empty\nstring as it's argument (which is understood as stdout) and --js\n/some/file.js sets the output filename\n. Another similar, but not identical, instance of this issue. Moving the closing paren to a new line seems to allow for proper messaging\n. This deviation from the original CS compiler is one of the main issues in updating my codebase to work with coffee-script-redux. I have had to update literally 100+ files just for this issue alone. I do think that fixing this would help the uptake of Redux.\n. I merged this into my local clone and it is really helping me tweak my coffeescript to compile with Redux. \nThanks! No problems so far.\n. +1 We use this syntax quite a lot in a very large codebase. I would absolutely love to have source maps, but moving from that syntax just wouldn't work for us. :(\n. @michaelficarra Any thoughts on this? I am still working on wrapping this up. I'd like to know if I'm working in a direction you find acceptable though.\n. I did maintain the stdin/stdout behavior for default. The file overrides\nshould just provide additional features.\nThe biggest win is in the ability to link the js and source maps since the\ntool is writing them both in one pass.\n. Yes, I just verified, but this still works: echo \"i=0\" | coffee --js and\nwrites out to stdout\nThe way I did that is basically the output options go through 3 possible\nstates: unset, stdout, or specified file\nso, no --js doesn't set the option, --js sets the option, with empty\nstring as it's argument (which is understood as stdout) and --js\n/some/file.js sets the output filename\n. Another similar, but not identical, instance of this issue. Moving the closing paren to a new line seems to allow for proper messaging\n. This deviation from the original CS compiler is one of the main issues in updating my codebase to work with coffee-script-redux. I have had to update literally 100+ files just for this issue alone. I do think that fixing this would help the uptake of Redux.\n. I merged this into my local clone and it is really helping me tweak my coffeescript to compile with Redux. \nThanks! No problems so far.\n. ",
    "mehcode": "The following works now:\ncoffee\n_(list)\n.chain()\n.pluck('email')\n.sortBy('length')\n.value()\nWhat I'm planning to do with expressions in https://github.com/michaelficarra/CoffeeScriptRedux/issues/143#issuecomment-12749271 should allow the following (in theory and if @michaelficarra agrees):\ncoffee\n_(list)\n  .chain()\n  .pluck('email')\n  .sortBy('length')\n  .value()\n. > Depends on what you mean by ready. For some people and some use cases, it's ready today.\nReady means that when I do npm install coffee-script@2.x it installs this project.\n. If you're responding to me @brian428, that doesn't count. This project is supposed to supersede coffee-script properly, right?\n. Personally, I'd be satisfied with this being merged into coffee-script and versioned at 2.0.0-alpha or something. That would hopefully stop people from working on new features (such as that new, fancy REPL) in coffee-script itself.\n. @michaelficarra So... not to sound like a broken record. When can we expect to have this merged in and versioned at 2.0.0-alpha ?\n. > So still a couple months off from being merge-able.\nI'd still recommend merging now. Just publish it as an alpha build. Having this be actually in the coffee-script repository would (in my opinion) spur more interest in the project as well as development support. Personally, I've been holding off on getting involved in actually contributing (as I'm still unsure if this project is legitimately decided to be the next coffee-script).\n. > Responding to @michaelficarra essentially saying that \"this shit is hard\", including linking to further constructive conversation in issue #106, by claiming the project is unfinished/unusable without offering any further assistance or creative input is... Well, to be as gentle and polite as I possibly can be, I can only say that it's uninspiring.\nI don't know about anyone else. I would be glad to help and can actually help (with an understanding of this kind of programming having written several compilers, transpilers, dynamic recompilers, etc.); however, I also don't have a lot of free time and I don't want to designate time on this project without knowing that it is going to be accepted / go somewhere. I'm concerned about @jashkenas et all even allowing this to be the next coffee-script. This may sound weird but It also sounds weird to write the next version of something in a separate repository.\n. >  Because of the nature of CoffeeScript, CS and CS-Redux will always be interoperable and compatible [...]\nInteroperable, yes; compatible, no. Once they've compiled their respective code to javascript the resultant code will be interoperable. However, they cannot be compatible at a source level simply due to the significant number of bugs that have been fixed in redux (not that this is a bad thing).\n\nSecondly, I'd love to merge Redux in as the official compiler, once it gets to the point where it's ready to be ... and if it still has the readable-hackable nature of a nice CoffeeScript program. If it ended up as a 100,000-line Java monstrosity, for example, I'd be less keen on merging.\n\nIs there any chance this project could be merged now to a redux branch? Thanks to the excellent work from @michaelficarra et all this project only really needs a couple of weekend hacking sessions and it will be feature-complete. This would also assuage any concerns people may have over any decisions on the compiler direction, etc.\n\nThank you for your post. There is nothing really blocking me, just general concerns, as you said. I was a bit concerned over your post on the google group discussion (you mentioned that you'd rather not merge redux in to coffee-script because of BDFL, etc.) because if that were the case this project would never be more than a fork (and that would be a shame as there is a lot of great work here).\n. See https://github.com/jashkenas/coffee-script/issues/2670\n. This looks like valid syntax and is not directly related to #119. From what I can gather if the dedent matches the indent it should be considered a valid expression. \n. > just closed as a dup.\nI know. I'm stating this is not a duplicate. Sorry if I was unclear. This is not a duplicate and seems to follow what @michaelficarra asked @Arelius to do at the end of #119 (break out things that make #119 not parse and give consistent rules, etc.).\nThis is the code in question:\ncoffee\nidentity = ->\n    matrix = [\n              1, 0, 0, 0,\n              0, 1, 0, 0,\n              0, 0, 1, 0,\n              0, 0, 0, 1\n    ]\n119 was this:\ncoffee\nidentity = ->\n    matrix = [1, 0, 0, 0,\n              0, 1, 0, 0,\n              0, 0, 1, 0,\n              0, 0, 0, 1]\nThere is a very important difference. From the the issue @michaelficarra linked describing #119 as a bug (https://github.com/jashkenas/coffee-script/issues/1275), it is stated by the resident BDFL that the proper behavior should be that the indent and dedent counts should match. I don't see an issue stating that these counts must be the same throughout the entire program for every indent and dedent.\n. ###### https://github.com/jashkenas/coffee-script/blob/master/documentation/coffee/existence.coffee\nThe error here occurs in the following conditions:\n- The file has at least one line with valid syntax\n- The file doesn't end with a new line\n- The last line in the file has at least one blank\n\nhttps://github.com/jashkenas/coffee-script/blob/master/documentation/coffee/objects_reserved.coffee\nThe error here seems to occur only when class is used as the key. Quick testing:\ncoffee\n$('.account').attr do: 'active'  # works (sort-of, do is not quoted)\n$('.account').attr function: 'active'  # works (sort-of, function is not quoted)\n$('.account').attr key: 'active'  # works\n$('.account').attr class: 'active'  # error\n\nhttps://github.com/jashkenas/coffee-script/blob/master/documentation/coffee/parallel_assignment.coffee\nSame error as existance.coffee\n\nhttps://github.com/jashkenas/coffee-script/blob/master/documentation/coffee/splices.coffee\nSame error as existance.coffee\n. ###### https://github.com/jashkenas/coffee-script/blob/master/examples/underscore.coffee\n``` coffee\nWorks\ndo ->\n  return a.source is b.source and \n  a.global is b.global\nWorks\ndo ->\n  a.source is b.source and \n  a.global is b.global\nDoesn't work\ndo ->\n  a.source is b.source and \n    a.global is b.global\nDoesn't work\ndo ->\n  return a.source is b.source and \n    a.global is b.global\nSome more examples of the same problem\nWorks\nx = a + \n3 + \n5\nDoesn't work\nx = a + \n  3 + \n    5\n```\nIt looks like this problem is caused because of a few reasons. One is that returns are implicit. This causes the return keyword to not introduce any sort of block or statement that would allow for indentation on a successive line. Line statements are strict in that continuations must start on the same indentation. Original coffee-script has allowed for any sort of indentation on successive lines (as long as the operator is the last symbol on the previous line).\nHonestly I feel we should extend this to allow for easier continuations. For expressions take the initial indentation and continue the expression until the initial indentation is reached (unless the last symbol on a previous line was an operator then we allow the expression to continue on the same indentation level). Here are some example expressions that would compile with these rules:\n``` coffee\nForm that works in original coffee-script but not in redux\nx = a +\n    4 +\n    42\nForm that doesn't work in either but I feel it should\nx = a \n  + 4\n  + 42\nOnly form that works right now\nx = a +\n4 +\n42\n```\nThoughts on the changes, etc. ?\n\nhttps://github.com/jashkenas/coffee-script/blob/master/examples/potion.coffee\ncoffee\nloop then print \"a\"  # Works\nloop\n  print \"a\"    # Works\nloop print \"a\"  # Doesn't work\nFrom some quick testing it looks like loop needs to have an implied then when then is not present. From my 15-minute review of PEG.js this looks like a simple fix for anyone interested. I'll be spending some dedicated time next weekend (or perhaps the one after, we'll see how my time goes) to work on some of this stuff. I'd like to get super up  honestly.\n\n\n@mehcode - I wasn't kidding earlier about offer of beer, pizza, or... Well, I don't know your life situation. Hiring a babysitter? Heh. \n\n@ttilley Heh. I just have a lot of work going on. I'll take a rain check on the beer though. :beers: \n. Correct. This was definitely an inconsistency in the original compiler that should be fixed:\n``` coffee\nIn the original compiler\nfoo = ({my: name}) -> # works\ntest = {my: \"hello\"}  # works\n{my: name} = test  # works\nmy: name = test  # doesn't work (for destructuring)\nfoo = (my: name) -> # works (for some interesting reason)\n```\n. Agreed. The following makes no sense.\n``` coffee\nIn redux compiler\npattern = (my: name) ->\n```\nThat should not compile to ...\njavascript\npattern = { my: name }(function () {\n... It should be a syntax error.\n. ; is a binary operator in coffee-script. I don't believe @michaelficarra wants it to be able to be used as a null statement but I could be wrong.\n. My perfect code must compile.\ncoffee\nbar = (x) ->\n  x+=32;;;;;;;;;;;;;;;;;;;;;;;\n  ;;;;;;;;;;x+3;;;;;;;;x-=4;;;\n  ;;;;;;;;;;;;;;;;;;x==3;;;;;;\n  ;;;;;;;;x-51;;;;;;;;;;;;;;;;\nIn all seriousness I suppose it does make sense to allow the semicolon operator to read one or more semicolons as people are just used to doing that (though I'm not a fan I must say). \n\n\nalthough semicolons can still be used to fit multiple expressions onto a single line\n\nJust to be clear, redux is doing this. Note that the quote doesn't state the semicolon can be used as the null statement or that empty statements are valid (nor does the document state the latter anywhere).\n. It's an enormous amount of work to make a makefile that runs in both GNU make and windows NMake for more than just simple tasks. I'd recommend using something cross-platform: cmake, waf, etc.\n. The following works now:\ncoffee\n_(list)\n.chain()\n.pluck('email')\n.sortBy('length')\n.value()\nWhat I'm planning to do with expressions in https://github.com/michaelficarra/CoffeeScriptRedux/issues/143#issuecomment-12749271 should allow the following (in theory and if @michaelficarra agrees):\ncoffee\n_(list)\n  .chain()\n  .pluck('email')\n  .sortBy('length')\n  .value()\n. > Depends on what you mean by ready. For some people and some use cases, it's ready today.\nReady means that when I do npm install coffee-script@2.x it installs this project.\n. If you're responding to me @brian428, that doesn't count. This project is supposed to supersede coffee-script properly, right?\n. Personally, I'd be satisfied with this being merged into coffee-script and versioned at 2.0.0-alpha or something. That would hopefully stop people from working on new features (such as that new, fancy REPL) in coffee-script itself.\n. @michaelficarra So... not to sound like a broken record. When can we expect to have this merged in and versioned at 2.0.0-alpha ?\n. > So still a couple months off from being merge-able.\nI'd still recommend merging now. Just publish it as an alpha build. Having this be actually in the coffee-script repository would (in my opinion) spur more interest in the project as well as development support. Personally, I've been holding off on getting involved in actually contributing (as I'm still unsure if this project is legitimately decided to be the next coffee-script).\n. > Responding to @michaelficarra essentially saying that \"this shit is hard\", including linking to further constructive conversation in issue #106, by claiming the project is unfinished/unusable without offering any further assistance or creative input is... Well, to be as gentle and polite as I possibly can be, I can only say that it's uninspiring.\nI don't know about anyone else. I would be glad to help and can actually help (with an understanding of this kind of programming having written several compilers, transpilers, dynamic recompilers, etc.); however, I also don't have a lot of free time and I don't want to designate time on this project without knowing that it is going to be accepted / go somewhere. I'm concerned about @jashkenas et all even allowing this to be the next coffee-script. This may sound weird but It also sounds weird to write the next version of something in a separate repository.\n. >  Because of the nature of CoffeeScript, CS and CS-Redux will always be interoperable and compatible [...]\nInteroperable, yes; compatible, no. Once they've compiled their respective code to javascript the resultant code will be interoperable. However, they cannot be compatible at a source level simply due to the significant number of bugs that have been fixed in redux (not that this is a bad thing).\n\nSecondly, I'd love to merge Redux in as the official compiler, once it gets to the point where it's ready to be ... and if it still has the readable-hackable nature of a nice CoffeeScript program. If it ended up as a 100,000-line Java monstrosity, for example, I'd be less keen on merging.\n\nIs there any chance this project could be merged now to a redux branch? Thanks to the excellent work from @michaelficarra et all this project only really needs a couple of weekend hacking sessions and it will be feature-complete. This would also assuage any concerns people may have over any decisions on the compiler direction, etc.\n\nThank you for your post. There is nothing really blocking me, just general concerns, as you said. I was a bit concerned over your post on the google group discussion (you mentioned that you'd rather not merge redux in to coffee-script because of BDFL, etc.) because if that were the case this project would never be more than a fork (and that would be a shame as there is a lot of great work here).\n. See https://github.com/jashkenas/coffee-script/issues/2670\n. This looks like valid syntax and is not directly related to #119. From what I can gather if the dedent matches the indent it should be considered a valid expression. \n. > just closed as a dup.\nI know. I'm stating this is not a duplicate. Sorry if I was unclear. This is not a duplicate and seems to follow what @michaelficarra asked @Arelius to do at the end of #119 (break out things that make #119 not parse and give consistent rules, etc.).\nThis is the code in question:\ncoffee\nidentity = ->\n    matrix = [\n              1, 0, 0, 0,\n              0, 1, 0, 0,\n              0, 0, 1, 0,\n              0, 0, 0, 1\n    ]\n119 was this:\ncoffee\nidentity = ->\n    matrix = [1, 0, 0, 0,\n              0, 1, 0, 0,\n              0, 0, 1, 0,\n              0, 0, 0, 1]\nThere is a very important difference. From the the issue @michaelficarra linked describing #119 as a bug (https://github.com/jashkenas/coffee-script/issues/1275), it is stated by the resident BDFL that the proper behavior should be that the indent and dedent counts should match. I don't see an issue stating that these counts must be the same throughout the entire program for every indent and dedent.\n. ###### https://github.com/jashkenas/coffee-script/blob/master/documentation/coffee/existence.coffee\nThe error here occurs in the following conditions:\n- The file has at least one line with valid syntax\n- The file doesn't end with a new line\n- The last line in the file has at least one blank\n\nhttps://github.com/jashkenas/coffee-script/blob/master/documentation/coffee/objects_reserved.coffee\nThe error here seems to occur only when class is used as the key. Quick testing:\ncoffee\n$('.account').attr do: 'active'  # works (sort-of, do is not quoted)\n$('.account').attr function: 'active'  # works (sort-of, function is not quoted)\n$('.account').attr key: 'active'  # works\n$('.account').attr class: 'active'  # error\n\nhttps://github.com/jashkenas/coffee-script/blob/master/documentation/coffee/parallel_assignment.coffee\nSame error as existance.coffee\n\nhttps://github.com/jashkenas/coffee-script/blob/master/documentation/coffee/splices.coffee\nSame error as existance.coffee\n. ###### https://github.com/jashkenas/coffee-script/blob/master/examples/underscore.coffee\n``` coffee\nWorks\ndo ->\n  return a.source is b.source and \n  a.global is b.global\nWorks\ndo ->\n  a.source is b.source and \n  a.global is b.global\nDoesn't work\ndo ->\n  a.source is b.source and \n    a.global is b.global\nDoesn't work\ndo ->\n  return a.source is b.source and \n    a.global is b.global\nSome more examples of the same problem\nWorks\nx = a + \n3 + \n5\nDoesn't work\nx = a + \n  3 + \n    5\n```\nIt looks like this problem is caused because of a few reasons. One is that returns are implicit. This causes the return keyword to not introduce any sort of block or statement that would allow for indentation on a successive line. Line statements are strict in that continuations must start on the same indentation. Original coffee-script has allowed for any sort of indentation on successive lines (as long as the operator is the last symbol on the previous line).\nHonestly I feel we should extend this to allow for easier continuations. For expressions take the initial indentation and continue the expression until the initial indentation is reached (unless the last symbol on a previous line was an operator then we allow the expression to continue on the same indentation level). Here are some example expressions that would compile with these rules:\n``` coffee\nForm that works in original coffee-script but not in redux\nx = a +\n    4 +\n    42\nForm that doesn't work in either but I feel it should\nx = a \n  + 4\n  + 42\nOnly form that works right now\nx = a +\n4 +\n42\n```\nThoughts on the changes, etc. ?\n\nhttps://github.com/jashkenas/coffee-script/blob/master/examples/potion.coffee\ncoffee\nloop then print \"a\"  # Works\nloop\n  print \"a\"    # Works\nloop print \"a\"  # Doesn't work\nFrom some quick testing it looks like loop needs to have an implied then when then is not present. From my 15-minute review of PEG.js this looks like a simple fix for anyone interested. I'll be spending some dedicated time next weekend (or perhaps the one after, we'll see how my time goes) to work on some of this stuff. I'd like to get super up  honestly.\n\n\n@mehcode - I wasn't kidding earlier about offer of beer, pizza, or... Well, I don't know your life situation. Hiring a babysitter? Heh. \n\n@ttilley Heh. I just have a lot of work going on. I'll take a rain check on the beer though. :beers: \n. Correct. This was definitely an inconsistency in the original compiler that should be fixed:\n``` coffee\nIn the original compiler\nfoo = ({my: name}) -> # works\ntest = {my: \"hello\"}  # works\n{my: name} = test  # works\nmy: name = test  # doesn't work (for destructuring)\nfoo = (my: name) -> # works (for some interesting reason)\n```\n. Agreed. The following makes no sense.\n``` coffee\nIn redux compiler\npattern = (my: name) ->\n```\nThat should not compile to ...\njavascript\npattern = { my: name }(function () {\n... It should be a syntax error.\n. ; is a binary operator in coffee-script. I don't believe @michaelficarra wants it to be able to be used as a null statement but I could be wrong.\n. My perfect code must compile.\ncoffee\nbar = (x) ->\n  x+=32;;;;;;;;;;;;;;;;;;;;;;;\n  ;;;;;;;;;;x+3;;;;;;;;x-=4;;;\n  ;;;;;;;;;;;;;;;;;;x==3;;;;;;\n  ;;;;;;;;x-51;;;;;;;;;;;;;;;;\nIn all seriousness I suppose it does make sense to allow the semicolon operator to read one or more semicolons as people are just used to doing that (though I'm not a fan I must say). \n\n\nalthough semicolons can still be used to fit multiple expressions onto a single line\n\nJust to be clear, redux is doing this. Note that the quote doesn't state the semicolon can be used as the null statement or that empty statements are valid (nor does the document state the latter anywhere).\n. It's an enormous amount of work to make a makefile that runs in both GNU make and windows NMake for more than just simple tasks. I'd recommend using something cross-platform: cmake, waf, etc.\n. ",
    "adamkuipers": "As of CoffeeScript 1.3.1, CoffeeScript enforces strict mode at compile time. Does your compiler do this as well/does it have plans to implement this feature? \n. As of CoffeeScript 1.3.1, CoffeeScript enforces strict mode at compile time. Does your compiler do this as well/does it have plans to implement this feature? \n. ",
    "jpleclerc": "Maybe this page can help you: https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Progress\n. Maybe this page can help you: https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Progress\n. ",
    "Zearin": "Thanks for the update, @michaelficarra!  \nQuick thoughts:\n- Happy to hear it is on its way to beta-release level on NPM!  :)\n- I\u2019ll try and stick to your guidelines for safe use.\n- Have you spoken with jashkenas about this project yet?\n  - Reason: When CoffeeScriptRedux becomes mature enough\u2014do you think jashkenas might adopt it as the official CoffeeScript compiler?  (Newcomers and veterans alike are probably going to get their compiler from the official source.  And it would be oh-so-awesome if the improved compiler\u2019s benefits would have the official channel to reach as many people as possible. \u263a)\n. Everyone: Let\u2019s all take a deep breath! :relaxed: We\u2019re all on the same side here.  Remember, we all want the best, most badass CS compiler possible.  \n\nI'm not saying redux sucks. On the contrary, I can't wait until it's done\n- @nkohari : I share your need for super.  I also want to appreciate your respectful self-defense when your first comment was interpreted the wrong way.\n- @ttilley : Thank you for reminding everyone that in threads like this, we have to consider our impact on the developer\u2019s motivation, not just the technical issues.  @michaelficarra is human like the rest of us. It\u2019s beyond my skill to directly help with writing a compiler, but I hope I can still be of some small help by showing enthusiasm for the project, and offering (what I hope is) constructive input where I can.\n- @jashkenas : Thanks for participating in this dialogue! It means a lot to me that you\u2019re aware of this project.  It means even more to me to hear that\u2014one day, when CS-redux is mature enough\u2014you\u2019ll be open to making CS-redux the official compiler.  It may be a while, but I look forward to that day.\n- @michaelficarra : Writing a compiler is so far beyond me that I am not even worthy to post in this thread! :tongue: But seriously\u2026I bow to your skill, ambition, vision, and discipline\u2014in creating what is already a fantastic piece of software.  I really wish I knew how to be more helpful.  Please don\u2019t get discouraged by the less-healthy aspects of support threads. I think it\u2019s safe to say that pretty much everyone in this thread is here because we love your work!\n. Ah, okay.  Didn\u2019t realize it was still considered unstable.  \n\n\u2026Kinda surprised to hear that, though!  I haven\u2019t taken a close look yet\u2014only just found about about this project about 20m ago\u2014but, this looks amazing so far.  The wiki page \u201cProgress\u201d is particularly impressive.  \nIs the project close to \u201cstable\u201d status yet?\n. Ah.  Got it.  \nI\u2019ll keep an eye on the Progress page, then.  Thanks!\n. Thanks for the update, @michaelficarra!  \nQuick thoughts:\n- Happy to hear it is on its way to beta-release level on NPM!  :)\n- I\u2019ll try and stick to your guidelines for safe use.\n- Have you spoken with jashkenas about this project yet?\n  - Reason: When CoffeeScriptRedux becomes mature enough\u2014do you think jashkenas might adopt it as the official CoffeeScript compiler?  (Newcomers and veterans alike are probably going to get their compiler from the official source.  And it would be oh-so-awesome if the improved compiler\u2019s benefits would have the official channel to reach as many people as possible. \u263a)\n. Everyone: Let\u2019s all take a deep breath! :relaxed: We\u2019re all on the same side here.  Remember, we all want the best, most badass CS compiler possible.  \n\nI'm not saying redux sucks. On the contrary, I can't wait until it's done\n- @nkohari : I share your need for super.  I also want to appreciate your respectful self-defense when your first comment was interpreted the wrong way.\n- @ttilley : Thank you for reminding everyone that in threads like this, we have to consider our impact on the developer\u2019s motivation, not just the technical issues.  @michaelficarra is human like the rest of us. It\u2019s beyond my skill to directly help with writing a compiler, but I hope I can still be of some small help by showing enthusiasm for the project, and offering (what I hope is) constructive input where I can.\n- @jashkenas : Thanks for participating in this dialogue! It means a lot to me that you\u2019re aware of this project.  It means even more to me to hear that\u2014one day, when CS-redux is mature enough\u2014you\u2019ll be open to making CS-redux the official compiler.  It may be a while, but I look forward to that day.\n- @michaelficarra : Writing a compiler is so far beyond me that I am not even worthy to post in this thread! :tongue: But seriously\u2026I bow to your skill, ambition, vision, and discipline\u2014in creating what is already a fantastic piece of software.  I really wish I knew how to be more helpful.  Please don\u2019t get discouraged by the less-healthy aspects of support threads. I think it\u2019s safe to say that pretty much everyone in this thread is here because we love your work!\n. Ah, okay.  Didn\u2019t realize it was still considered unstable.  \n\n\u2026Kinda surprised to hear that, though!  I haven\u2019t taken a close look yet\u2014only just found about about this project about 20m ago\u2014but, this looks amazing so far.  The wiki page \u201cProgress\u201d is particularly impressive.  \nIs the project close to \u201cstable\u201d status yet?\n. Ah.  Got it.  \nI\u2019ll keep an eye on the Progress page, then.  Thanks!\n. ",
    "Ciantic": "Please write to the README that this is in alpha, and that it is not working yet. I, for one, wasted time looking around is this working or not.\nE.g. I tried to copy paste Classes & Inheritance example code from original CoffeeScript page to your tester page only to find out this implementation does not implement all features yet.\n. My only point is that the README itself doesn't tell anything of the progress, I did try to go Wiki first but it gave mostly empty page... I see now that they are tucked away.\n. Please write to the README that this is in alpha, and that it is not working yet. I, for one, wasted time looking around is this working or not.\nE.g. I tried to copy paste Classes & Inheritance example code from original CoffeeScript page to your tester page only to find out this implementation does not implement all features yet.\n. My only point is that the README itself doesn't tell anything of the progress, I did try to go Wiki first but it gave mostly empty page... I see now that they are tucked away.\n. ",
    "martinheidegger": "I think \"ready\" means \"ready to be used instead of https://github.com/jashkenas/coffee-script in daily problems without new problems\"\n. @ulikoehler  +1 long post but I agree all the way.\n. I think \"ready\" means \"ready to be used instead of https://github.com/jashkenas/coffee-script in daily problems without new problems\"\n. @ulikoehler  +1 long post but I agree all the way.\n. ",
    "archaeron": "would it be ready to put on npm?\n. you're right, I'm sorry :)\nCoffeeScript and CoffeeScriptRedux don't seem to like each other though\n. @michaelficarra so after that the only thing missing that could stop us from using it is the super? :)\n. @michaelficarra is there something we can do without knowledge about how a compiler works? (that class has still to come ;) ) event if it's donating so that you can work more on this project?\nI'd really love having the sourcemap function :)\n. would it be ready to put on npm?\n. you're right, I'm sorry :)\nCoffeeScript and CoffeeScriptRedux don't seem to like each other though\n. @michaelficarra so after that the only thing missing that could stop us from using it is the super? :)\n. @michaelficarra is there something we can do without knowledge about how a compiler works? (that class has still to come ;) ) event if it's donating so that you can work more on this project?\nI'd really love having the sourcemap function :)\n. ",
    "nkohari": "There are still some substantial features missing in redux that would block many from switching. In particular, support for super is a must-have before I can even consider using redux for anything real-world. The work that @michaelficarra et al. has done here is fantastic, but to say it's \"a couple weekend hacking sessions\" away from complete is just not accurate.\n. @michaelficarra Yikes, I guess a hit a nerve. You don't need to jump up my ass. I'm not here to talk shit or troll you... see the part where I said your work was fantastic?\nAfter the comments from @mehcode and @jashkenas, I'm just tempering expectations for others that come to this thread. After reading what they wrote, I tried swapping out the CS 1.4 compiler for redux to see how well it worked in my current project, and everything melted. After spending a bit trying to fix some of the minor issues, I realized that there were several large pieces still yet to be implemented, super being one of them.\nI'm not saying redux sucks. On the contrary, I can't wait until it's done, and I've spent the day looking at the code to see if there's any pull requests I can submit. I just want to make sure people don't assume the project is ready to go, and then get a sour taste from it not being ready.\n. > I think it\u2019s safe to say that pretty much everyone in this thread is here because we love your work!\nThis. :)\n. There are still some substantial features missing in redux that would block many from switching. In particular, support for super is a must-have before I can even consider using redux for anything real-world. The work that @michaelficarra et al. has done here is fantastic, but to say it's \"a couple weekend hacking sessions\" away from complete is just not accurate.\n. @michaelficarra Yikes, I guess a hit a nerve. You don't need to jump up my ass. I'm not here to talk shit or troll you... see the part where I said your work was fantastic?\nAfter the comments from @mehcode and @jashkenas, I'm just tempering expectations for others that come to this thread. After reading what they wrote, I tried swapping out the CS 1.4 compiler for redux to see how well it worked in my current project, and everything melted. After spending a bit trying to fix some of the minor issues, I realized that there were several large pieces still yet to be implemented, super being one of them.\nI'm not saying redux sucks. On the contrary, I can't wait until it's done, and I've spent the day looking at the code to see if there's any pull requests I can submit. I just want to make sure people don't assume the project is ready to go, and then get a sour taste from it not being ready.\n. > I think it\u2019s safe to say that pretty much everyone in this thread is here because we love your work!\nThis. :)\n. ",
    "dmitkataev": "Thanks for the reference. So, as i understand, there is no way to use it on Windows system for now. But maybe some hack?\n. Hello Michael.I did as you said and it doesn't help.\u00a0I use Sublime text 2.\u00a0 In View menu of this editor I set Line Endings to Unix (and I also tried to set it to Mac OS9)After saving I checked that now line ending is 0D (not 0A0D). But I still have the same errorcode:class C1 extends C\u00a0 constructor: -> \u00a0\u00a0\u00a0 supererror:\u00a0 Syntax error on line 3, column 4: unexpected '(INDENT)' (\\uEFEF)if to change super to super1 - it worksThis code works tooclass C1 extends C\u00a0 f1:->\u00a0\u00a0\u00a0 i = 0\u00a0\u00a0I also tried to compile it online in CoffeeScriptRedux site and had the same error.\u00a027.12.2012, 19:05, \"Michael Ficarra\" notifications@github.com:@dmitkataev: just configure your editor to use \\n as the line terminator.\u2014 Reply to this email directly or view it on GitHub.\n. Thanks for the reference. So, as i understand, there is no way to use it on Windows system for now. But maybe some hack?\n. Hello Michael.I did as you said and it doesn't help.\u00a0I use Sublime text 2.\u00a0 In View menu of this editor I set Line Endings to Unix (and I also tried to set it to Mac OS9)After saving I checked that now line ending is 0D (not 0A0D). But I still have the same errorcode:class C1 extends C\u00a0 constructor: -> \u00a0\u00a0\u00a0 supererror:\u00a0 Syntax error on line 3, column 4: unexpected '(INDENT)' (\\uEFEF)if to change super to super1 - it worksThis code works tooclass C1 extends C\u00a0 f1:->\u00a0\u00a0\u00a0 i = 0\u00a0\u00a0I also tried to compile it online in CoffeeScriptRedux site and had the same error.\u00a027.12.2012, 19:05, \"Michael Ficarra\" notifications@github.com:@dmitkataev: just configure your editor to use \\n as the line terminator.\u2014 Reply to this email directly or view it on GitHub.\n. ",
    "machty": "@michaelficarra just submitted the suggested changes\n. @michaelficarra just submitted the suggested changes\n. ",
    "akre54": "Awesome. Thanks for the fast fix!\n. > There are some issues with jashkenas/coffee-script that will be incredibly hard to fix because of the compiler's design.\nNot trolling but I've seen you mention this a number of times. Is there an up-to-date list of things that are possible in CSR that aren't possible (or are hard) to fix in jashkenas/coffee-script? The wiki page lists four and the open issues page lists 37, none of which are particularly compelling. What reason would I have to use CSR over CS these days?\n. http://michaelficarra.github.io/CoffeeScriptRedux/#try:Bosh%20%3D%201%0ABosh%20%3D%20if%20Bosh%20then%20Bosh%20else%20%7B%7D\n?\n. Try this one http://michaelficarra.github.io/CoffeeScriptRedux/\n. As a workaround, you can simply assign the result to a variable (no need to pass it to an identity function). But I generally agree that getters are dumb and anti-js.\n. Excellent!\n. There are still a few pending tests that could get squashed by this. The static super ref needs to reference __super__.constructor (CS), and some of the scope lookup stuff may need some streamlining. But awesome to get the main case out of the way on this! \n. Shouldn't CSR at least try to match CS super as it stands now, and then fix if CS changes? There hasn't been any progress on super in years and it's preventing many people (myself included) from switching to CSR.\n. Awesome. Thanks for the fast fix!\n. > There are some issues with jashkenas/coffee-script that will be incredibly hard to fix because of the compiler's design.\nNot trolling but I've seen you mention this a number of times. Is there an up-to-date list of things that are possible in CSR that aren't possible (or are hard) to fix in jashkenas/coffee-script? The wiki page lists four and the open issues page lists 37, none of which are particularly compelling. What reason would I have to use CSR over CS these days?\n. http://michaelficarra.github.io/CoffeeScriptRedux/#try:Bosh%20%3D%201%0ABosh%20%3D%20if%20Bosh%20then%20Bosh%20else%20%7B%7D\n?\n. Try this one http://michaelficarra.github.io/CoffeeScriptRedux/\n. As a workaround, you can simply assign the result to a variable (no need to pass it to an identity function). But I generally agree that getters are dumb and anti-js.\n. Excellent!\n. There are still a few pending tests that could get squashed by this. The static super ref needs to reference __super__.constructor (CS), and some of the scope lookup stuff may need some streamlining. But awesome to get the main case out of the way on this! \n. Shouldn't CSR at least try to match CS super as it stands now, and then fix if CS changes? There hasn't been any progress on super in years and it's preventing many people (myself included) from switching to CSR.\n. ",
    "devinrhode2": "Hey Micheal, FWIW I thought of a cleaner way to name object methods:\njavascript\nModule.method = function Module_method() {};\nThe Module_ prefix is important so you never mistake one function for another\n. I think we should focus on creating IDE and editor plugins that automatically and flawlessly insert es cruft for you, color it so it's hard to see (because you don't need to), let tc39 innovate the language, and libraries focus on making nice API's for one js.\nIn the meantime, recognizing import, export, and default as valid tokens and passing them through into the output would be a real painkiller for coffeescript-ember devs right now. This would allow @alexspeller to deprecate his coffees6 hack, and the ember community could use happily use coffeescript with the standard ember-cli-coffeescirpt plugin without the ugly escaped imports and exports.\n@michaelficarra Any pointers as to how we could let the import, export, and default keywords pass through into the output?\n. And here's my two more cents\n\nI think we should focus on creating IDE and editor plugins that automatically and flawlessly insert es cruft for you, color it so it's hard to see (because you don't need to)\n\nghetto coffeescript for sublime is where the idea of hiding js syntactical cruft came from.\nBy making es6 more aesthetically pleasing to work with, the coffeescript project could instead focus on innovating the language, instead of playing catch up. My feeling is that es has caught up to and surpassed coffeescript. Coffeescript has done a great job influencing this new standard; and there's no reason the coffeescript community can't focus on continuing to innovate the language, perhaps with an \"automatic cruft insertion\" or \"use whitespace\" directive implemented in an es.next transpiler like Babel.\nTranspilers will continue to innovate the language, and I wish the coffeescript project would separate out syntactical sugar with language innovations.\n. Hey Micheal, FWIW I thought of a cleaner way to name object methods:\njavascript\nModule.method = function Module_method() {};\nThe Module_ prefix is important so you never mistake one function for another\n. I think we should focus on creating IDE and editor plugins that automatically and flawlessly insert es cruft for you, color it so it's hard to see (because you don't need to), let tc39 innovate the language, and libraries focus on making nice API's for one js.\nIn the meantime, recognizing import, export, and default as valid tokens and passing them through into the output would be a real painkiller for coffeescript-ember devs right now. This would allow @alexspeller to deprecate his coffees6 hack, and the ember community could use happily use coffeescript with the standard ember-cli-coffeescirpt plugin without the ugly escaped imports and exports.\n@michaelficarra Any pointers as to how we could let the import, export, and default keywords pass through into the output?\n. And here's my two more cents\n\nI think we should focus on creating IDE and editor plugins that automatically and flawlessly insert es cruft for you, color it so it's hard to see (because you don't need to)\n\nghetto coffeescript for sublime is where the idea of hiding js syntactical cruft came from.\nBy making es6 more aesthetically pleasing to work with, the coffeescript project could instead focus on innovating the language, instead of playing catch up. My feeling is that es has caught up to and surpassed coffeescript. Coffeescript has done a great job influencing this new standard; and there's no reason the coffeescript community can't focus on continuing to innovate the language, perhaps with an \"automatic cruft insertion\" or \"use whitespace\" directive implemented in an es.next transpiler like Babel.\nTranspilers will continue to innovate the language, and I wish the coffeescript project would separate out syntactical sugar with language innovations.\n. ",
    "PhilAndrew": "You could take this further and have a language plugin registry, like NodeJS's NPM where you can search for sub-languages and select a sub-language and write your code in that language within that language in a block. Then its easy to write code in the sub-language within Coffeescript.\nlanguage \"mathml\"\n  then some mathml code markup here\nJust a vague suggestion.\n. I feel rejected.\n. You could take this further and have a language plugin registry, like NodeJS's NPM where you can search for sub-languages and select a sub-language and write your code in that language within that language in a block. Then its easy to write code in the sub-language within Coffeescript.\nlanguage \"mathml\"\n  then some mathml code markup here\nJust a vague suggestion.\n. I feel rejected.\n. ",
    "phadej": "Another example triggering this bug:\ncoffee\nconsole.log(\n   \"quite long expression\".toUpperCase().replace(\" \", \"-\")\n   \"another long expression\"\n   \"and a third one\")\nIs there workaround to this (other than naming the arguments)?\n. Few other contrived examples:\ncoffee\nconsole.log(\n  1, (x) -> x,\n  2, (y) -> y)\ncoffee\nconsole.log x,\n  (x) -> x\ncoffee\nconsole.log(\n  (x) -> x,\n  (y) -> y)\ncoffee\nconsole.log 1,\n  -> x\n. Another example triggering this bug:\ncoffee\nconsole.log(\n   \"quite long expression\".toUpperCase().replace(\" \", \"-\")\n   \"another long expression\"\n   \"and a third one\")\nIs there workaround to this (other than naming the arguments)?\n. Few other contrived examples:\ncoffee\nconsole.log(\n  1, (x) -> x,\n  2, (y) -> y)\ncoffee\nconsole.log x,\n  (x) -> x\ncoffee\nconsole.log(\n  (x) -> x,\n  (y) -> y)\ncoffee\nconsole.log 1,\n  -> x\n. ",
    "chertov": "simple log preprocessor for IcedCoffeeScript...\nwatch coffee_path, copy to source_path, replace 'LINE', 'FILE', 'FL'\n'FL' replace with {file: 'filepath', line: 'linenum''}\n``` coffeescript\n    fs = require 'fs-extra'\n    Path = require 'path'\n    Walker = require 'walker'\n    watchTree = require './watchtree'\nlazy = require 'lazy'\n\ncoffee_path = Path.join __dirname, './coffee'\nsource_path = Path.join __dirname, './src'\n\nblock = false\n\nfile_count = 0\npreprocessor_file = (filepath)->\n    FILENAME = '.' + filepath.replace source_path, ''\n    lines = fs.readFileSync(filepath).toString().split '\\n'\n    for line, i in lines\n        LINENUM = i+1\n        line = line.replace /__LINE__/g, LINENUM.toString()\n        line = line.replace /__FILE__/g, FILENAME.toString()\n        line = line.replace /__FL__/g, '{file: \\'' + FILENAME.toString() + '\\', line: ' + LINENUM.toString() + '}'\n        lines[i] = line\n    file_str = lines.join '\\n'\n    fd = fs.openSync filepath, 'w+'\n    fs.writeSync fd, file_str\n    fs.closeSync fd\n\n    file_count--\n    if file_count==0\n        block = false\n\nupdate_files = ()->\n    block = true\n    console.log 'preprocessing...'\n    fs.removeSync source_path\n    fs.mkdirSync source_path\n\n    fs.copy coffee_path, source_path, (err)->\n        if err?\n            console.log err\n            return\n\n        Walker(source_path)\n        .on 'file', (file, stat)->\n            if file.substring(file.length - 7) == '.coffee'\n                file_count++\n                preprocessor_file file\n        .on 'end', ()->\n            if file_count==0\n                block = false\n                console.log 'updated!'\n\nupdate_files()\nwt = watchTree coffee_path\nwt.on 'all', (event, file)->\n    if !block\n        update_files()\n\n```\n. simple log preprocessor for IcedCoffeeScript...\nwatch coffee_path, copy to source_path, replace 'LINE', 'FILE', 'FL'\n'FL' replace with {file: 'filepath', line: 'linenum''}\n``` coffeescript\n    fs = require 'fs-extra'\n    Path = require 'path'\n    Walker = require 'walker'\n    watchTree = require './watchtree'\nlazy = require 'lazy'\n\ncoffee_path = Path.join __dirname, './coffee'\nsource_path = Path.join __dirname, './src'\n\nblock = false\n\nfile_count = 0\npreprocessor_file = (filepath)->\n    FILENAME = '.' + filepath.replace source_path, ''\n    lines = fs.readFileSync(filepath).toString().split '\\n'\n    for line, i in lines\n        LINENUM = i+1\n        line = line.replace /__LINE__/g, LINENUM.toString()\n        line = line.replace /__FILE__/g, FILENAME.toString()\n        line = line.replace /__FL__/g, '{file: \\'' + FILENAME.toString() + '\\', line: ' + LINENUM.toString() + '}'\n        lines[i] = line\n    file_str = lines.join '\\n'\n    fd = fs.openSync filepath, 'w+'\n    fs.writeSync fd, file_str\n    fs.closeSync fd\n\n    file_count--\n    if file_count==0\n        block = false\n\nupdate_files = ()->\n    block = true\n    console.log 'preprocessing...'\n    fs.removeSync source_path\n    fs.mkdirSync source_path\n\n    fs.copy coffee_path, source_path, (err)->\n        if err?\n            console.log err\n            return\n\n        Walker(source_path)\n        .on 'file', (file, stat)->\n            if file.substring(file.length - 7) == '.coffee'\n                file_count++\n                preprocessor_file file\n        .on 'end', ()->\n            if file_count==0\n                block = false\n                console.log 'updated!'\n\nupdate_files()\nwt = watchTree coffee_path\nwt.on 'all', (event, file)->\n    if !block\n        update_files()\n\n```\n. ",
    "mcollina": "@michaelficarra  I believe is a better approach to return a proper compile error.\nPeople use that (or at least I did). It's way better to not generate anything than generating Javascritp that does not run, right? Otherwise people will keep saying 'could you fix this bug' all over again.\n. @michaelficarra  I believe is a better approach to return a proper compile error.\nPeople use that (or at least I did). It's way better to not generate anything than generating Javascritp that does not run, right? Otherwise people will keep saying 'could you fix this bug' all over again.\n. ",
    "gjtorikian": "\nAlso, what OS/node are you using?\n\nOS X 10.8.2, node 0.8.8.\n\nI definitely see how those usage patterns could use some clarification, I just don't quite know how. Maybe with examples? Common usage?\n\nWell, for example-does * mean \"zero or more,\" or something else? If that's the case, I still don't quite grasp what coffee FILE tells me--it implies to me that providing a filename gets you out of std input. So right off the bat, coffee -i FILE ARG* makes sense. The reason I'm not sure if * means zero or more is the [-- ARG*]--one or more optional args? So why have ARG* [-- ARG*] when ARG* will do?\nAnother idea is to group the help results in, perhaps, \"commonalities.\" Meaning, instead of:\n```\nnode OPT [--repl] OPT\nnode OPT -{-parse,p,-compile,c,-js,j,-cscodegen} OPT\nnode {OPT,ARG} -{-eval,e} {OPT,ARG} -- ARG*\n...\n -c, --compile       output a JSON-serialised AST representation of the output\n -e, --eval          evaluate compiled JavaScript\n -f, --cscodegen     output cscodegen-generated CoffeeScript code\n -j, --js            generate JavaScript output\n -p, --parse         output a JSON-serialised AST representation of the input\n --repl              run an interactive CoffeeScript REPL\n```\nInto something like:\n```\nnode OPT [--repl] OPT\n--repl              run an interactive CoffeeScript REPL\nnode OPT -{-p,-c,-js} OPT\n-p, --parse         output a JSON-serialised AST representation of the input\n -c, --compile       output a JSON-serialised AST representation of the output\n -j, --js            generate JavaScript output\nnode {OPT,ARG} -{-eval,e} {OPT,ARG} -- ARG*\n-e, --eval          evaluate compiled JavaScript\n```\nI'm probably extremely wrong here, since I guess there is a difference between OPT and ARG, which I'm not clear about. But, anyway, perhaps even providing a link--\"For more information, see \"--or creating a man page with ronn-js--could help dummies like me out.\n. > Also, what OS/node are you using?\nOS X 10.8.2, node 0.8.8.\n\nI definitely see how those usage patterns could use some clarification, I just don't quite know how. Maybe with examples? Common usage?\n\nWell, for example-does * mean \"zero or more,\" or something else? If that's the case, I still don't quite grasp what coffee FILE tells me--it implies to me that providing a filename gets you out of std input. So right off the bat, coffee -i FILE ARG* makes sense. The reason I'm not sure if * means zero or more is the [-- ARG*]--one or more optional args? So why have ARG* [-- ARG*] when ARG* will do?\nAnother idea is to group the help results in, perhaps, \"commonalities.\" Meaning, instead of:\n```\nnode OPT [--repl] OPT\nnode OPT -{-parse,p,-compile,c,-js,j,-cscodegen} OPT\nnode {OPT,ARG} -{-eval,e} {OPT,ARG} -- ARG*\n...\n -c, --compile       output a JSON-serialised AST representation of the output\n -e, --eval          evaluate compiled JavaScript\n -f, --cscodegen     output cscodegen-generated CoffeeScript code\n -j, --js            generate JavaScript output\n -p, --parse         output a JSON-serialised AST representation of the input\n --repl              run an interactive CoffeeScript REPL\n```\nInto something like:\n```\nnode OPT [--repl] OPT\n--repl              run an interactive CoffeeScript REPL\nnode OPT -{-p,-c,-js} OPT\n-p, --parse         output a JSON-serialised AST representation of the input\n -c, --compile       output a JSON-serialised AST representation of the output\n -j, --js            generate JavaScript output\nnode {OPT,ARG} -{-eval,e} {OPT,ARG} -- ARG*\n-e, --eval          evaluate compiled JavaScript\n```\nI'm probably extremely wrong here, since I guess there is a difference between OPT and ARG, which I'm not clear about. But, anyway, perhaps even providing a link--\"For more information, see \"--or creating a man page with ronn-js--could help dummies like me out.\n. ",
    "KennethSundqvist": "I found that this is available as the --source-map-file argument and is used as described above.\n. I found that this is available as the --source-map-file argument and is used as described above.\n. ",
    "MartinodF": "+1 This is a really common pattern when using chaining apis.\nThis is another workaround and works as expected:\ncoffeescript\nangular\n.module(\"test.factories\", [])\n.factory(\"Page\", () -> new Page())\nBe sure to use parentheses around the arguments. This does not work:\ncoffeescript\nangular\n.module \"test.factories\", []\n.factory \"Page\", () -> new Page()\nbecause .factory is called on []:\njavascript\nangular.module('test.factories', [].factory('Page', function () {\n  return new Page;\n}));\n. +1 This is a really common pattern when using chaining apis.\nThis is another workaround and works as expected:\ncoffeescript\nangular\n.module(\"test.factories\", [])\n.factory(\"Page\", () -> new Page())\nBe sure to use parentheses around the arguments. This does not work:\ncoffeescript\nangular\n.module \"test.factories\", []\n.factory \"Page\", () -> new Page()\nbecause .factory is called on []:\njavascript\nangular.module('test.factories', [].factory('Page', function () {\n  return new Page;\n}));\n. ",
    "imcotton": "I think here is another scenario fails:\ncoffeescript\n$.get('url')\n  .done ->\n    alert 'success'\n. I think here is another scenario fails:\ncoffeescript\n$.get('url')\n  .done ->\n    alert 'success'\n. ",
    "joliss": "Right now CoffeeScriptRedux is a good bit slower than the original CoffeeScript. E.g. compiling src/compiler.coffee takes 3.6 sec for redux, but 1.4 sec for the original compiler. FYI, the original compiler has some unfortunate quadratic behavior when you catenate files, which redux doesn't seem to suffer from.\n. Right now CoffeeScriptRedux is a good bit slower than the original CoffeeScript. E.g. compiling src/compiler.coffee takes 3.6 sec for redux, but 1.4 sec for the original compiler. FYI, the original compiler has some unfortunate quadratic behavior when you catenate files, which redux doesn't seem to suffer from.\n. ",
    "utkarshkukreti": "Ok, so I found the code which CoffeeScript uses for this - https://github.com/jashkenas/coffee-script/blob/master/Cakefile#L88\nThey seem to be doing something like what browserify does.\nI'll see if I can do something.\n. @Nami-Doc, hmm, I haven't seen a single project which doesn't have this in the local .gitignore file.\n. Ok, so I found the code which CoffeeScript uses for this - https://github.com/jashkenas/coffee-script/blob/master/Cakefile#L88\nThey seem to be doing something like what browserify does.\nI'll see if I can do something.\n. @Nami-Doc, hmm, I haven't seen a single project which doesn't have this in the local .gitignore file.\n. ",
    "krisnye": "This snippet also won't compile.  I think it's related.\nfn = ->\n    while true\n        if true\n            1\n        else\n            return 2\n. @D1plo1d I didn't close this bug, I only closed the related bug filed against commonjs-everywhere.\n. This snippet also won't compile.  I think it's related.\nfn = ->\n    while true\n        if true\n            1\n        else\n            return 2\n. @D1plo1d I didn't close this bug, I only closed the related bug filed against commonjs-everywhere.\n. ",
    "D1plo1d": "@krisnye You didn't mention a solution and then you closed the bug. If you have fixed this bug then please post your solution. If the bug is not fixed then please reopen it again so that it stands a chance of getting fixed (at the very least I could really use this being fixed!).\n. @michaelficarra I suspect this bug was closed by mistake. I am seeing this same issue in 2.0.0-beta 6. Can you reopen it please?\n. @krisnye Ahh, my mistake. Sorry about that!\n. @krisnye You didn't mention a solution and then you closed the bug. If you have fixed this bug then please post your solution. If the bug is not fixed then please reopen it again so that it stands a chance of getting fixed (at the very least I could really use this being fixed!).\n. @michaelficarra I suspect this bug was closed by mistake. I am seeing this same issue in 2.0.0-beta 6. Can you reopen it please?\n. @krisnye Ahh, my mistake. Sorry about that!\n. ",
    "joshuacc": "Confirmed that this is currently happening in the online demo with the steps @epidemian noted.\n. Confirmed that this is currently happening in the online demo with the steps @epidemian noted.\n. ",
    "ciddan": "This happened when I was compiling my code using require('coffee-script-redux') and going the more manual route (in a grunt task). The CLI does not generate that extra noise. I couldn't really see what the CLI was doing that I wasn't, but...\n. This happened when I was compiling my code using require('coffee-script-redux') and going the more manual route (in a grunt task). The CLI does not generate that extra noise. I couldn't really see what the CLI was doing that I wasn't, but...\n. ",
    "guybedford": "Ok sure will post there in future, I was just under the impression this was becoming the main branch of CoffeeScript. Executable class bodies look great. Hadn't seen this feature before - thanks for pointing it out.\n. Ok sure will post there in future, I was just under the impression this was becoming the main branch of CoffeeScript. Executable class bodies look great. Hadn't seen this feature before - thanks for pointing it out.\n. ",
    "jtmalinowski": "ok, my bad. Is original coffee compiler wrong then?\n. nope its just that I was re writing some js and forgot to remove the semicolon. browserify was fine with it but commonjs-everywhere not, coffee pushed it but redux not, that confused me. thanks for help\n. ok, my bad. Is original coffee compiler wrong then?\n. nope its just that I was re writing some js and forgot to remove the semicolon. browserify was fine with it but commonjs-everywhere not, coffee pushed it but redux not, that confused me. thanks for help\n. ",
    "alexeyraspopov": "@renekooi thanks for your answer.\n@epidemian yeah, I tested this example in the original compiler and it has confused me too\n. Is there anyone here?\n. Yes it is :)\nCan I do pull request for this issue?\n. @renekooi thanks for your answer.\n@epidemian yeah, I tested this example in the original compiler and it has confused me too\n. Is there anyone here?\n. Yes it is :)\nCan I do pull request for this issue?\n. ",
    "j1wilmot": "+1 that would be cool\n. +1 that would be cool\n. ",
    "fuson": "We tried to migrate onto redux, but cluster module don't support and it was our showstopper :( Have you any plans to fix it before 2.0 release?  Maybe anyone have a workaround?\n. Thank you for your response, we will try to migrate our solution on monday and i'll report you our results.\n. We use the lastest stable 0.10 release in production and the same on dev/test sandboxes, thats why our feed will be relevant (i hope). \n. Here is out minimal representative example:\n---- master.coffee:\ncluster = require 'cluster'\ncluster.setupMaster\n                 exec: 'drone.coffee'\ncluster.on 'online', (drone) -> \n                    console.log drone.process.pid, 'online'\n                    drone.send 'test message for ' + drone.id\ncluster.on 'disconnect', (drone) -> console.log drone.process.pid, 'disconnect'\ncluster.on 'exit', (drone) -> console.log drone.process.pid, 'exit'\nfor i in [0..3]\n    cluster.fork()\n---- drone.coffee:\nconsole.log 'drone', process.pid\nping = () -> console.log process.pid\nsetInterval ping, 2000\nprocess.on 'message', (message) -> console.log process.pid, message\nresult output:\n$ ./node_modules/coffee-script-redux/bin/coffee master.coffee \nexecvp(): No such file or directory\nexecvp(): No such file or directory\nexecvp(): No such file or directory\nexecvp(): No such file or directory\nevents.js:72\n        throw er; // Unhandled 'error' event\n              ^\nError: spawn ENOENT\n  at errnoException (child_process.js:980:11)\n  at Process.ChildProcess._handle.onexit (child_process.js:771:34)\n. We tried to migrate onto redux, but cluster module don't support and it was our showstopper :( Have you any plans to fix it before 2.0 release?  Maybe anyone have a workaround?\n. Thank you for your response, we will try to migrate our solution on monday and i'll report you our results.\n. We use the lastest stable 0.10 release in production and the same on dev/test sandboxes, thats why our feed will be relevant (i hope). \n. Here is out minimal representative example:\n---- master.coffee:\ncluster = require 'cluster'\ncluster.setupMaster\n                 exec: 'drone.coffee'\ncluster.on 'online', (drone) -> \n                    console.log drone.process.pid, 'online'\n                    drone.send 'test message for ' + drone.id\ncluster.on 'disconnect', (drone) -> console.log drone.process.pid, 'disconnect'\ncluster.on 'exit', (drone) -> console.log drone.process.pid, 'exit'\nfor i in [0..3]\n    cluster.fork()\n---- drone.coffee:\nconsole.log 'drone', process.pid\nping = () -> console.log process.pid\nsetInterval ping, 2000\nprocess.on 'message', (message) -> console.log process.pid, message\nresult output:\n$ ./node_modules/coffee-script-redux/bin/coffee master.coffee \nexecvp(): No such file or directory\nexecvp(): No such file or directory\nexecvp(): No such file or directory\nexecvp(): No such file or directory\nevents.js:72\n        throw er; // Unhandled 'error' event\n              ^\nError: spawn ENOENT\n  at errnoException (child_process.js:980:11)\n  at Process.ChildProcess._handle.onexit (child_process.js:771:34)\n. ",
    "wonk": "ditto\n. ditto\n. ",
    "sokra": "http://sokra.github.com/source-map-visualization/ and click on \"coffee-redux\"\n. It think the error is something different than just a wrong base. Sometimes there is a bigger offset...\n\n. http://sokra.github.com/source-map-visualization/ and click on \"coffee-redux\"\n. It think the error is something different than just a wrong base. Sometimes there is a bigger offset...\n\n. ",
    "fabnoe": "\u2714 270 tests complete (2.38 seconds)\nThanks!\n.   \u2714 270 tests complete (2.38 seconds)\nThanks!\n. ",
    "marchaefner": "Cygwin is the (obvious) solution and an acceptable requirement IMO.\nThe third point however might be a bug, caused by these 3 lines. process.title is not necessarily \"node\" in node.js (for me it's the current path). In a browser it  just does not exist and causes a ReferenceError. (@ghempton: Did i miss something?)\nBrowser vs node.js detection is notoriously hard / unreliable, but something like this would probably be a better solution.\n. I missed something (sorry for the noise): commonjs-everywhere sets process.title to \"browser\".\nA better detection would then be something like\nunless process.title is 'browser'\n  require './run'\n. Regarding the clean-up:\nSomething like @hasCatch/@hasFinally is necessary, since the body of  catch and finally clauses may be empty (i.e. non-existent). But the absence of a body does not always coincide with the absence of the keyword.\nExample (with the clean-up):\ntry\n    do stuff\nfinally\n    # XXX commented out by an irresponsible person\n    # handle.release()\ncompiles to:\ntry {\n  stuff();\n} catch (e$) {\n}\nThe last test does not work as i (naively) assumed and fails silently. Compare:\n$ bin/coffee -j --cli 'try throw {} catch finally ok yes'\n// Generated by CoffeeScript 2.0.0-beta4\ntry {\n  throw {};\n} finally {\n  ok(true);\n}\nWhile the @has... flags are indeed quite ugly, the compiler needs those 2 bits. (And i just can't come up with a prettier solution.)\n. Great. A much better solution.\nThere only remains the issue with a dangling finally as in the first example. (Which is easily fixed by doing the same thing in finallyClause.)\n. > A dangling finally doesn't have any observable effects.\nYes, but:\ntry x() finally\ncurrently compiles to\ntry {\n  x();\n} catch (e$) {\n}\nIt should either:\n1. compile, as in CS1, to:\ntry {\n       x();\n   } finally {\n   }\n2. or even better to:\nx();\n3. or not compile at all (i.e. don't allow an empty body in finallyClause).\n\nIt's dead code and should be eliminated.\n\nAye (see 2nd compilation suggestion). But i guess this should be done by the optimiser.\n. > try does imply an empty catch\nI would rather say that only a lone try (which would otherwise be an illegal construct) implies an empty catch. And from this point of view CS1s behavior is consistent, while the above compilations are quite unexpected.\n. Cygwin is the (obvious) solution and an acceptable requirement IMO.\nThe third point however might be a bug, caused by these 3 lines. process.title is not necessarily \"node\" in node.js (for me it's the current path). In a browser it  just does not exist and causes a ReferenceError. (@ghempton: Did i miss something?)\nBrowser vs node.js detection is notoriously hard / unreliable, but something like this would probably be a better solution.\n. I missed something (sorry for the noise): commonjs-everywhere sets process.title to \"browser\".\nA better detection would then be something like\nunless process.title is 'browser'\n  require './run'\n. Regarding the clean-up:\nSomething like @hasCatch/@hasFinally is necessary, since the body of  catch and finally clauses may be empty (i.e. non-existent). But the absence of a body does not always coincide with the absence of the keyword.\nExample (with the clean-up):\ntry\n    do stuff\nfinally\n    # XXX commented out by an irresponsible person\n    # handle.release()\ncompiles to:\ntry {\n  stuff();\n} catch (e$) {\n}\nThe last test does not work as i (naively) assumed and fails silently. Compare:\n$ bin/coffee -j --cli 'try throw {} catch finally ok yes'\n// Generated by CoffeeScript 2.0.0-beta4\ntry {\n  throw {};\n} finally {\n  ok(true);\n}\nWhile the @has... flags are indeed quite ugly, the compiler needs those 2 bits. (And i just can't come up with a prettier solution.)\n. Great. A much better solution.\nThere only remains the issue with a dangling finally as in the first example. (Which is easily fixed by doing the same thing in finallyClause.)\n. > A dangling finally doesn't have any observable effects.\nYes, but:\ntry x() finally\ncurrently compiles to\ntry {\n  x();\n} catch (e$) {\n}\nIt should either:\n1. compile, as in CS1, to:\ntry {\n       x();\n   } finally {\n   }\n2. or even better to:\nx();\n3. or not compile at all (i.e. don't allow an empty body in finallyClause).\n\nIt's dead code and should be eliminated.\n\nAye (see 2nd compilation suggestion). But i guess this should be done by the optimiser.\n. > try does imply an empty catch\nI would rather say that only a lone try (which would otherwise be an illegal construct) implies an empty catch. And from this point of view CS1s behavior is consistent, while the above compilations are quite unexpected.\n. ",
    "jphaas": "This change will break any code that's using a try { use a resource } finally { clean up the resource } pattern by silently absorbing any errors instead of throwing them.   Given that in javascript and in historical coffeescript, try...finally without a catch does not absorb errors, my guess is that this would be very surprising behavior. (I'd have to revisit all my code that uses finally statements since about half the time I deliberately omit the catch statement).\nImplicitly creating catch statements seems like a dangerous default, especially since it's rarely the correct behavior to discard thrown errors without any handling at all.  This seems like something javascript got right... Rather than implicitly creating catch, I'd rather a try without a catch or finally be a syntax error.\n. This change will break any code that's using a try { use a resource } finally { clean up the resource } pattern by silently absorbing any errors instead of throwing them.   Given that in javascript and in historical coffeescript, try...finally without a catch does not absorb errors, my guess is that this would be very surprising behavior. (I'd have to revisit all my code that uses finally statements since about half the time I deliberately omit the catch statement).\nImplicitly creating catch statements seems like a dangerous default, especially since it's rarely the correct behavior to discard thrown errors without any handling at all.  This seems like something javascript got right... Rather than implicitly creating catch, I'd rather a try without a catch or finally be a syntax error.\n. ",
    "skozin": "I totally agree with @jphaas. Try..finally without a catch block is a perfectly valid construction. It is not so frequently used, but it can be very convenient when there is a need to cleanup some internal state while handling exception up the scope. That's why catch block is optional in almost any language that supports exceptions: JS, Java, C#, Ruby, Python, to name a few.\nSlightly contrived example:\n``` CoffeeScript\ninitializeAudioPlayback: ->\n  try\n    # any of these functions can throw an exception\n    @checkBrowserCapabilities()\n    @decodeAudioData()\n    @schedulePlayback()\n  catch e\n    console.log('cannot initialize playback: ' + e);\n    trigger 'error', e.message\ncheckBrowserCapabilities: ->\n  try\n    # try creating and manipulating DOM objects\n  finally\n    # remove any created objects from the DOM\netc.\n```\nGenerating implicit catch block will break any code that uses similar technique.\n. @michaelficarra, I don't think that the above example is a good code, but it is a valid use case, however. Thank you for reverting this behavior!\n. I totally agree with @jphaas. Try..finally without a catch block is a perfectly valid construction. It is not so frequently used, but it can be very convenient when there is a need to cleanup some internal state while handling exception up the scope. That's why catch block is optional in almost any language that supports exceptions: JS, Java, C#, Ruby, Python, to name a few.\nSlightly contrived example:\n``` CoffeeScript\ninitializeAudioPlayback: ->\n  try\n    # any of these functions can throw an exception\n    @checkBrowserCapabilities()\n    @decodeAudioData()\n    @schedulePlayback()\n  catch e\n    console.log('cannot initialize playback: ' + e);\n    trigger 'error', e.message\ncheckBrowserCapabilities: ->\n  try\n    # try creating and manipulating DOM objects\n  finally\n    # remove any created objects from the DOM\netc.\n```\nGenerating implicit catch block will break any code that uses similar technique.\n. @michaelficarra, I don't think that the above example is a good code, but it is a valid use case, however. Thank you for reverting this behavior!\n. ",
    "ulikoehler": "I can reproduce this with precompiled node v0.11.0 binaries on Ubuntu 13.04 x86_64.\nSteps to reproduce:\n- Fresh clone https://github.com/michaelficarra/CoffeeScriptRedux.git\n- cd into clone and npm install\n- npm test should succeed\n- Download precompiled NodeJS v0.11.0\n- export PATH=(path to node v0.11.0 bin directory):$PATH\n- check node -v (should be 0.11.0)\n- npm test, should fail with the error described above.\n. Thanks for the quick fix!\n. Yes, when converting my code to work with CS redux I had a lot of errors related to the intentional deviation cited by you, but IMO the behaviour is still inconsistent and error-prone.\n. @michaelficarra\nThanks for looking into this, but to be honest I think even if it is discouraged to use semicolons at the end of lines, CS Redux shouldn't yield unexpectable results if there's a single character that is not considered an error.\nI have to admit I'm seeing a tendency in CS redux to not fix issues like this and leaving hurdles for new Coffeescript users that are hard to debug and even harder to explain. If you think this behaviour is consistent, please explain to me - at the moment I can't understand.\nIn the long term I'd like to see CS redux as a replacement for the original CoffeeScript. IMO the current redux compiler produces slightly better code even if it's quite slow.\nHaving worked with both compilers for some time, I don't like the tendency of redux dropping a lot of features and therefore requiring people to change their code in order to use redux. But hey, at least the language gets a little cleaner from that (hopefully).\nBut what I really can't understand at all is why inconsistencies like this (IMO it's only a matter of time until someone stumbles over this bug and wastes hours debugging it) won't be fixed.\nI think to resolve this (and some related issues), CS redux should either\n- Completely disallow semicolons (at least at the end of indented blocks, like functions) or\n- Ignore semicolons at the end of indented blocks (keeping maximum compatibility with CS 1.x)\nThis would also fix a common case of incompatibility with CS 1.x:\ncoffeescript\nclass Foo\n    baz: () -> \"foo\";\nI think it's obvious what the programmer meant to do. CS 1.x compiles that code. CS redux does not. baz is an indented code block (not sure what's the actual term for that is, I consider it an indented code block even if it's inlike like here). If there would be either an error message or the semicolon would be ignored silently, the behaviour would be fine.\nI'm not familiar with the internal structure of CS redux and I don't know how difficult this would be to fix - I'm not saying this is in any way urgent or must be fixed immediately - still, I think you should just leave it open. But please, don't introduce additional hurdles for new CS users in any case, that would (at least in my opionion) defeat one of the main purposes of CoffeeScript! \n@michaelficarra : Some time ago someone asked if this is a drop-in-replacement (see #162 ). Your answer was (basically) yes. I think it is not a drop-in replacement at all if this won't be fixed.\nThanks and sorry for the way-oversized post.\n. Thanks @michaelficarra and @martinheidegger !\n@michaelficarra No problem, a month isn't really long, considering some people from other repositories haven't answered after more than a year ;-)\n. I can reproduce this in 2.0.0-beta7 using the single line\ncoffee\ndata[0]/2\n. Note: This error does not occur when adding spaces before and after the division (adding it not at all, or on one side only, yields the error described above):\n``` coffee\nThis works\ndata = [1,2,3,4]\nval = (data[3] / 4)\nThese do not\nval = (data[3]/ 4)\nval = (data[3] /4)\nval = (data[3]/4)\n```\n. :+1: \n@Nami-Doc I don't think you should require users/developers to setup language/environment-specific stuff globally.\nAdditionally, this has no negative side-effects at all, if I'm not missing something.\nAlso I agree to @utkarshkukreti . \n. @Nami-Doc\nIMO there is no objective reason behind not adding it to the local gitignore.\nI also don't agree with usually, because at least for me Github is pretty usual, and their official gitignore template (not the global gitignore) lists node_modules.\nSee https://github.com/github/gitignore/blob/master/Node.gitignore\nBesides, it's not more than a single click to merge this (thanks to @utkarshkukreti 's work), so I think that not adding it might be an an answer in other projects, should not matter, especially when considering the hundreds of projects, including Github itself, which add it to .gitignore.\n. Is\ncoffeescript\nrecords[0]?.default = true\na correct CoffeeScript expression?\nI can't find any lvalue-?. expression on http://coffeescript.org/ \n... which IMO matches the error message which basically says Hey, that expr you used as lvalue is an rvalue only\n. Thanks for fixing @michaelficarra !\n. I can reproduce this with precompiled node v0.11.0 binaries on Ubuntu 13.04 x86_64.\nSteps to reproduce:\n- Fresh clone https://github.com/michaelficarra/CoffeeScriptRedux.git\n- cd into clone and npm install\n- npm test should succeed\n- Download precompiled NodeJS v0.11.0\n- export PATH=(path to node v0.11.0 bin directory):$PATH\n- check node -v (should be 0.11.0)\n- npm test, should fail with the error described above.\n. Thanks for the quick fix!\n. Yes, when converting my code to work with CS redux I had a lot of errors related to the intentional deviation cited by you, but IMO the behaviour is still inconsistent and error-prone.\n. @michaelficarra\nThanks for looking into this, but to be honest I think even if it is discouraged to use semicolons at the end of lines, CS Redux shouldn't yield unexpectable results if there's a single character that is not considered an error.\nI have to admit I'm seeing a tendency in CS redux to not fix issues like this and leaving hurdles for new Coffeescript users that are hard to debug and even harder to explain. If you think this behaviour is consistent, please explain to me - at the moment I can't understand.\nIn the long term I'd like to see CS redux as a replacement for the original CoffeeScript. IMO the current redux compiler produces slightly better code even if it's quite slow.\nHaving worked with both compilers for some time, I don't like the tendency of redux dropping a lot of features and therefore requiring people to change their code in order to use redux. But hey, at least the language gets a little cleaner from that (hopefully).\nBut what I really can't understand at all is why inconsistencies like this (IMO it's only a matter of time until someone stumbles over this bug and wastes hours debugging it) won't be fixed.\nI think to resolve this (and some related issues), CS redux should either\n- Completely disallow semicolons (at least at the end of indented blocks, like functions) or\n- Ignore semicolons at the end of indented blocks (keeping maximum compatibility with CS 1.x)\nThis would also fix a common case of incompatibility with CS 1.x:\ncoffeescript\nclass Foo\n    baz: () -> \"foo\";\nI think it's obvious what the programmer meant to do. CS 1.x compiles that code. CS redux does not. baz is an indented code block (not sure what's the actual term for that is, I consider it an indented code block even if it's inlike like here). If there would be either an error message or the semicolon would be ignored silently, the behaviour would be fine.\nI'm not familiar with the internal structure of CS redux and I don't know how difficult this would be to fix - I'm not saying this is in any way urgent or must be fixed immediately - still, I think you should just leave it open. But please, don't introduce additional hurdles for new CS users in any case, that would (at least in my opionion) defeat one of the main purposes of CoffeeScript! \n@michaelficarra : Some time ago someone asked if this is a drop-in-replacement (see #162 ). Your answer was (basically) yes. I think it is not a drop-in replacement at all if this won't be fixed.\nThanks and sorry for the way-oversized post.\n. Thanks @michaelficarra and @martinheidegger !\n@michaelficarra No problem, a month isn't really long, considering some people from other repositories haven't answered after more than a year ;-)\n. I can reproduce this in 2.0.0-beta7 using the single line\ncoffee\ndata[0]/2\n. Note: This error does not occur when adding spaces before and after the division (adding it not at all, or on one side only, yields the error described above):\n``` coffee\nThis works\ndata = [1,2,3,4]\nval = (data[3] / 4)\nThese do not\nval = (data[3]/ 4)\nval = (data[3] /4)\nval = (data[3]/4)\n```\n. :+1: \n@Nami-Doc I don't think you should require users/developers to setup language/environment-specific stuff globally.\nAdditionally, this has no negative side-effects at all, if I'm not missing something.\nAlso I agree to @utkarshkukreti . \n. @Nami-Doc\nIMO there is no objective reason behind not adding it to the local gitignore.\nI also don't agree with usually, because at least for me Github is pretty usual, and their official gitignore template (not the global gitignore) lists node_modules.\nSee https://github.com/github/gitignore/blob/master/Node.gitignore\nBesides, it's not more than a single click to merge this (thanks to @utkarshkukreti 's work), so I think that not adding it might be an an answer in other projects, should not matter, especially when considering the hundreds of projects, including Github itself, which add it to .gitignore.\n. Is\ncoffeescript\nrecords[0]?.default = true\na correct CoffeeScript expression?\nI can't find any lvalue-?. expression on http://coffeescript.org/ \n... which IMO matches the error message which basically says Hey, that expr you used as lvalue is an rvalue only\n. Thanks for fixing @michaelficarra !\n. ",
    "askucher": "Because typescript can use strict types and validate it during compilation.\nTypescript has interfaces for that\nhttp://blogs.msdn.com/b/typescript/archive/2013/01/24/interfaces-walkthrough.aspx\nI like coffeescript but typescript's interfaces force me to use typescript\ninstead of coffeescript.\nAnd moreover typescript has some benefits:\nI can use already written declarations of all famous libs https://github.com/borisyankov/DefinitelyTyped\nI can see members in autocomplete https://github.com/raph-amiard/sublime-typescript during development. It works in browser as well\nhttp://www.typescriptlang.org/Playground/\nSo conclusion. I like typescript and coffeescript and want to use both.\nThe compromise is to use coffeescript which produce typescript. This is\nkind of combination of syntax sugar and serious approach according to\ntypes.\nOn Wed, May 22, 2013 at 10:19 AM, Nami-Doc notifications@github.com wrote:\n\nWhy would you even do that ?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/206#issuecomment-18261341\n.\n. Typescript is extension of javascript. If redux support typescript it automatically will support javscript\n. Is it possible to add possibility to write such statement:\n\n1.\nclass Someclass\n_method: (arg:ITYPE):IRESUTLTYPE\n_prop: ITYPE: 1\n2.\nvariable:ITYPE = 1\nI cannot write so now.\nThat's enougth.\n. Sorry for closed-reopened, closed-reopened.\n. Because typescript can use strict types and validate it during compilation.\nTypescript has interfaces for that\nhttp://blogs.msdn.com/b/typescript/archive/2013/01/24/interfaces-walkthrough.aspx\nI like coffeescript but typescript's interfaces force me to use typescript\ninstead of coffeescript.\nAnd moreover typescript has some benefits:\nI can use already written declarations of all famous libs https://github.com/borisyankov/DefinitelyTyped\nI can see members in autocomplete https://github.com/raph-amiard/sublime-typescript during development. It works in browser as well\nhttp://www.typescriptlang.org/Playground/\nSo conclusion. I like typescript and coffeescript and want to use both.\nThe compromise is to use coffeescript which produce typescript. This is\nkind of combination of syntax sugar and serious approach according to\ntypes.\nOn Wed, May 22, 2013 at 10:19 AM, Nami-Doc notifications@github.com wrote:\n\nWhy would you even do that ?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/206#issuecomment-18261341\n.\n. Typescript is extension of javascript. If redux support typescript it automatically will support javscript\n. Is it possible to add possibility to write such statement:\n\n1.\nclass Someclass\n_method: (arg:ITYPE):IRESUTLTYPE\n_prop: ITYPE: 1\n2.\nvariable:ITYPE = 1\nI cannot write so now.\nThat's enougth.\n. Sorry for closed-reopened, closed-reopened.\n. ",
    "forivall": "This should wait until browsers support it, or at least add a switch to provide backward compatibility. I just ran into this issue with uglify-js, and it was annoying.\n. The alternative (and I do this, even though I'm only targetting coffee1), is to surround the function with parens:\nsetInterval (->\n  console.log new Date()\n), 1000\n. @rattrayalex @nmccready  I'm currently working on https://github.com/forivall/tacoscript - for typing, I'll basically support flow annotations, but right now it's just the core es6 syntax. I'm not using PEG since my goal is to do CST transformations to preserve whitespace (which is what I want to get \"done\" before I want to get people to try it out. I'm currently just doing AST transformations and discarding the CST data).\n. w.r.t adopting ES6 features, I'll be announcing something in a month or few.\n. This should wait until browsers support it, or at least add a switch to provide backward compatibility. I just ran into this issue with uglify-js, and it was annoying.\n. The alternative (and I do this, even though I'm only targetting coffee1), is to surround the function with parens:\nsetInterval (->\n  console.log new Date()\n), 1000\n. @rattrayalex @nmccready  I'm currently working on https://github.com/forivall/tacoscript - for typing, I'll basically support flow annotations, but right now it's just the core es6 syntax. I'm not using PEG since my goal is to do CST transformations to preserve whitespace (which is what I want to get \"done\" before I want to get people to try it out. I'm currently just doing AST transformations and discarding the CST data).\n. w.r.t adopting ES6 features, I'll be announcing something in a month or few.\n. ",
    "pjeby": "\nThe semicolon is being treated as a sequence operator internally in CSR, as it should have been in the original compiler. \n\nReally?  The CS docs say it's an optional statement terminator, not a sequence operator.\n\nAre you suggesting we shouldn't allow newlines to follow semicolons?\n\nPersonally, I don't care about the semicolons part at all; that was just an attempt to see if there was a workaround for the semicolon-free syntax of my first example, that avoids having to have an entire module definition (i.e. an entire file) indented an extra level.  (This is an pain in .litcoffee especially, since there's already an extra indent level.)\nI also can't use a define( ... ) wrapper, because CSR evals JS literals instead of placing them inline...  which seems like a nasty misfeature to me.  If I didn't want to inject raw javascript, what good is `` syntax?  (For example, I don't think eval'ing a yield statement is going to do much good.)\nOf course, if CS and CSR ever implement <- syntax, that would be the obvious correct way to do what I'm trying to do, i.e.\n```\n(dep1, dep2) <- define ['dep1', 'dep2']\nrest of file goes here\n```\nBut lacking that, I'm wondering if there is any other way of doing this available.  Will CSR have any sort of non-indent block syntax?\nAlso, is there any document anywhere that summarizes all (or even some) of the backwards incompatible changes, such as backquote->eval, semicolon as sequence operator, etc.?  Thanks!\n. > I was under the impression that if a then b(); c() compiled to if (a) b(); c(); in the original compiler \nNo, but:\nif a then b();\nc();\ndoes, unlike in CSR.  CSR actually fails on this input, complaining about an unexpected end-of-input unless you either add more code or get rid of the semicolon.\nCSR is treating  ';' like a binary operator rather than an optional statement terminator.  This strikes me as just plain wrong, if one goes by the CS docs, or an intuitive \"CS is just JavaScript\" reading of one's code.\nBut I see this has been raised already in the other issue.  What worries me about the process there is that ISTM CSR is not really going to be CoffeeScript at all, but rather just another opinionated fork like all the other CS variants, with its own set of unique parsing quirks, rather than a CS with fewer parsing quirks.\nAlas, maybe this is unavoidable due to CS's grammar being underspecified.\n. > I'll try to get together an exhaustive list of differences on the wiki soon.\nThank you.  That will help a lot with reducing my vague worries that CSR will quietly change semantics of existing code or barf on stuff that looks valid to the inexperienced and non-vim-using eye.  ;-)  (At one point I also saw a difference of interpretation of whitespace removal in multi-line strings between CS and CSR, so it'd be good to know how those are changing, too.)\nIt also occurred to me later that I might be worrying too much about upgrading anyway; I can always pin my projects to older versions of CS until there's a reason to upgrade them.  I probably didn't think of that sooner, due to being still too accustomed to my toolsets for other languages...  where tools are installed globally by default and upgraded whether you like the changes or not.  ;-)\n. > The semicolon is being treated as a sequence operator internally in CSR, as it should have been in the original compiler. \nReally?  The CS docs say it's an optional statement terminator, not a sequence operator.\n\nAre you suggesting we shouldn't allow newlines to follow semicolons?\n\nPersonally, I don't care about the semicolons part at all; that was just an attempt to see if there was a workaround for the semicolon-free syntax of my first example, that avoids having to have an entire module definition (i.e. an entire file) indented an extra level.  (This is an pain in .litcoffee especially, since there's already an extra indent level.)\nI also can't use a define( ... ) wrapper, because CSR evals JS literals instead of placing them inline...  which seems like a nasty misfeature to me.  If I didn't want to inject raw javascript, what good is `` syntax?  (For example, I don't think eval'ing a yield statement is going to do much good.)\nOf course, if CS and CSR ever implement <- syntax, that would be the obvious correct way to do what I'm trying to do, i.e.\n```\n(dep1, dep2) <- define ['dep1', 'dep2']\nrest of file goes here\n```\nBut lacking that, I'm wondering if there is any other way of doing this available.  Will CSR have any sort of non-indent block syntax?\nAlso, is there any document anywhere that summarizes all (or even some) of the backwards incompatible changes, such as backquote->eval, semicolon as sequence operator, etc.?  Thanks!\n. > I was under the impression that if a then b(); c() compiled to if (a) b(); c(); in the original compiler \nNo, but:\nif a then b();\nc();\ndoes, unlike in CSR.  CSR actually fails on this input, complaining about an unexpected end-of-input unless you either add more code or get rid of the semicolon.\nCSR is treating  ';' like a binary operator rather than an optional statement terminator.  This strikes me as just plain wrong, if one goes by the CS docs, or an intuitive \"CS is just JavaScript\" reading of one's code.\nBut I see this has been raised already in the other issue.  What worries me about the process there is that ISTM CSR is not really going to be CoffeeScript at all, but rather just another opinionated fork like all the other CS variants, with its own set of unique parsing quirks, rather than a CS with fewer parsing quirks.\nAlas, maybe this is unavoidable due to CS's grammar being underspecified.\n. > I'll try to get together an exhaustive list of differences on the wiki soon.\nThank you.  That will help a lot with reducing my vague worries that CSR will quietly change semantics of existing code or barf on stuff that looks valid to the inexperienced and non-vim-using eye.  ;-)  (At one point I also saw a difference of interpretation of whitespace removal in multi-line strings between CS and CSR, so it'd be good to know how those are changing, too.)\nIt also occurred to me later that I might be worrying too much about upgrading anyway; I can always pin my projects to older versions of CS until there's a reason to upgrade them.  I probably didn't think of that sooner, due to being still too accustomed to my toolsets for other languages...  where tools are installed globally by default and upgraded whether you like the changes or not.  ;-)\n. ",
    "app": "My example\na = null\nb = 2\n-> return a ?= b\nRedux output\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvoid function () {\n  var a, b;\n  a = null;\n  b = 2;\n}.call(this);\nExpected 'a' assignment similar this\n// Generated by CoffeeScript 1.8.0\nvar a, b;\na = null;\nb = 2;\n(function() {\n  return a != null ? a : a = b;\n});\n. My example\na = null\nb = 2\n-> return a ?= b\nRedux output\n// Generated by CoffeeScript 2.0.0-beta9-dev\nvoid function () {\n  var a, b;\n  a = null;\n  b = 2;\n}.call(this);\nExpected 'a' assignment similar this\n// Generated by CoffeeScript 1.8.0\nvar a, b;\na = null;\nb = 2;\n(function() {\n  return a != null ? a : a = b;\n});\n. ",
    "ckknight": "Actually, it probably would be better to make a common library that any compile-to-JS language could employ.\n. Actually, it probably would be better to make a common library that any compile-to-JS language could employ.\n. ",
    "jkrems": "@xcambar: Shameless plug - I try to keep bugger[1] roughly up-to-date with the latest redux version. Also the new fork of node-inspector by strangeloop supports source mapped coffee-script, though they are using CS1.x for it.\n[1] https://github.com/jkrems/bugger\n[2] https://github.com/strongloop/node-inspector\n. @xcambar: Shameless plug - I try to keep bugger[1] roughly up-to-date with the latest redux version. Also the new fork of node-inspector by strangeloop supports source mapped coffee-script, though they are using CS1.x for it.\n[1] https://github.com/jkrems/bugger\n[2] https://github.com/strongloop/node-inspector\n. ",
    "xcambar": "Sounds pretty nice, I'll give it a try.\nThe guys at strongloop do an amazing job to keep node-inspector alive. Their fork is by far the most advanced right now.\nThanks for pointing me to bugger!\n. Sounds pretty nice, I'll give it a try.\nThe guys at strongloop do an amazing job to keep node-inspector alive. Their fork is by far the most advanced right now.\nThanks for pointing me to bugger!\n. ",
    "rstacruz": "Tried to look around for something similar issue but I haven't found any.\nAwesome job with Redux, by the way!\n. Well, yes, #215 is indeed this one ;) Did you mean to link to another issue?\n. It fails in coffeescriptredux 2.0.0-beta8.\nhttp://michaelficarra.github.io/CoffeeScriptRedux/#try:switch%20%28if%20a%20then%20b%20else%20c%29%0A%20%20when%20d%0A%20%20%20%20e%28%29\n. Reducing it further, a = (@b...) => is enough to replicate the behavior. It produces an invalid parameter name, function (this$.b) { ... }.\nIn contrast, CoffeeScript 1.8 doesn't even add arguments (function () { }) for any function that has splats.\n. Found something similar: #288 \u2014 it actually refers to a different syntax oddity though (var ;)\n. I just tried it in the online site: http://michaelficarra.github.io/CoffeeScriptRedux/#try:a%20%3D%20%28%40b...%29%20-%3E\ncoffee\na = (@b...) ->\njs\n// Generated by CoffeeScript 2.0.0-beta8\nvoid function () {\n  var a;\n  a = function (this.b) {\n    this.b = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];\n  };\n}.call(this);\n. Tried to look around for something similar issue but I haven't found any.\nAwesome job with Redux, by the way!\n. Well, yes, #215 is indeed this one ;) Did you mean to link to another issue?\n. It fails in coffeescriptredux 2.0.0-beta8.\nhttp://michaelficarra.github.io/CoffeeScriptRedux/#try:switch%20%28if%20a%20then%20b%20else%20c%29%0A%20%20when%20d%0A%20%20%20%20e%28%29\n. Reducing it further, a = (@b...) => is enough to replicate the behavior. It produces an invalid parameter name, function (this$.b) { ... }.\nIn contrast, CoffeeScript 1.8 doesn't even add arguments (function () { }) for any function that has splats.\n. Found something similar: #288 \u2014 it actually refers to a different syntax oddity though (var ;)\n. I just tried it in the online site: http://michaelficarra.github.io/CoffeeScriptRedux/#try:a%20%3D%20%28%40b...%29%20-%3E\ncoffee\na = (@b...) ->\njs\n// Generated by CoffeeScript 2.0.0-beta8\nvoid function () {\n  var a;\n  a = function (this.b) {\n    this.b = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];\n  };\n}.call(this);\n. ",
    "jamesonquinn": "Yay!\nI had offerred to do this as a spur to jashkenas. But honestly it would probably take me a solid week, including getting my head around the compiler. And then there's the issue of separately implementing it in CS and CSR. So I think it's probably more efficient for me to let the experts handle it.\nOn the other hand, I am chomping at the bit to implement iced-cs as a library.\n. Yay!\nI had offerred to do this as a spur to jashkenas. But honestly it would probably take me a solid week, including getting my head around the compiler. And then there's the issue of separately implementing it in CS and CSR. So I think it's probably more efficient for me to let the experts handle it.\nOn the other hand, I am chomping at the bit to implement iced-cs as a library.\n. ",
    "EndangeredMassa": "Thanks for the quick fix! I'll workaround this until there's another release.\n. Please add this to the local .gitignore.\n. Thanks for the quick fix! I'll workaround this until there's another release.\n. Please add this to the local .gitignore.\n. ",
    "twoolie": "Here's what i'm using to test.\n% node_modules/coffee-script-redux/bin/coffee --compile << EOF\nangular.module \"MyApp\"  \n  .config ($routeProvider) ->     \n    $locationProvider.html5Mode true     \nEOF\nIt's a minimal exemplar from a larger codebase.\n. @michaelficarra would a PR that enables this functionality be welcome?\n. Here's what i'm using to test.\n% node_modules/coffee-script-redux/bin/coffee --compile << EOF\nangular.module \"MyApp\"  \n  .config ($routeProvider) ->     \n    $locationProvider.html5Mode true     \nEOF\nIt's a minimal exemplar from a larger codebase.\n. @michaelficarra would a PR that enables this functionality be welcome?\n. ",
    "eranimo": "Does CoffeeScriptRedux still not support this?\n. Does CoffeeScriptRedux still not support this?\n. ",
    "lordnox": "I have a similar problem:\n```\nsome_service \n.def \"test\", -> \n  123\nsome_service # should not be needed\n.def \"test2\", -> 123\n```\nTest with my command line inside my project and https://michaelficarra.github.io/CoffeeScriptRedux\nError: Syntax error on line 27, column 0: unexpected '.' (\\u002E)\n. I do have this problem as well (see: https://github.com/michaelficarra/CoffeeScriptRedux/issues/22)\nI did make sure to just have 2-spaces for indentation\n. I have a similar problem:\n```\nsome_service \n.def \"test\", -> \n  123\nsome_service # should not be needed\n.def \"test2\", -> 123\n```\nTest with my command line inside my project and https://michaelficarra.github.io/CoffeeScriptRedux\nError: Syntax error on line 27, column 0: unexpected '.' (\\u002E)\n. I do have this problem as well (see: https://github.com/michaelficarra/CoffeeScriptRedux/issues/22)\nI did make sure to just have 2-spaces for indentation\n. ",
    "vjeux": "Feel free to take over this pull request with the best way to explain it. I just wanted to give a working command line for other people :)\n. Feel free to take over this pull request with the best way to explain it. I just wanted to give a working command line for other people :)\n. ",
    "olegam": "Makes sense. Thanks for the great work you are doing. I got started using this based on the recommendation from this blogpost about getting coffee-script to work best with Jetbrains WebStorm: http://blog.jetbrains.com/webide/2013/03/coffeescript-debugging-with-sourcemaps-in-webstorm-6-phpstorm-6/\nIs there a schedule for when you will implement features like this?\n. Makes sense. Thanks for the great work you are doing. I got started using this based on the recommendation from this blogpost about getting coffee-script to work best with Jetbrains WebStorm: http://blog.jetbrains.com/webide/2013/03/coffeescript-debugging-with-sourcemaps-in-webstorm-6-phpstorm-6/\nIs there a schedule for when you will implement features like this?\n. ",
    "antonkulaga": "\nsuper will probably take me 10-15 hours. Stepped loops can be done in under 4.\n\nHow soon are you going to fix it? These two problems are the only things that prevent me (and I suspect a huge number of people like me) from switching to CoffeeScript redux\n. > super will probably take me 10-15 hours. Stepped loops can be done in under 4.\nHow soon are you going to fix it? These two problems are the only things that prevent me (and I suspect a huge number of people like me) from switching to CoffeeScript redux\n. ",
    "slang800": "duplicate of issue #147\n. there's a PR for this over here: https://github.com/michaelficarra/CoffeeScriptRedux/pull/313 ... not sure what's left to do on it\n. Yeah, you don't update copyrights - only the start year is listed. And, since you're in the US, you don't even need that. Every work is implicitly copyrighted from the time of its creation till 70 years after the death of the author.\n. @gkz - have you seen nodeca/argparse? You might like it... It has a lot of the same goals as gkz/optionator but already has a small communitty built around it, and a design copied from the very popular Python argparse module.\n. +1 for making it work the same as it does in the original CoffeeScript\n. +1 thanks @mizchi, this is a hugely important for me being able to move to CS-redux\n. duplicate of issue #147\n. there's a PR for this over here: https://github.com/michaelficarra/CoffeeScriptRedux/pull/313 ... not sure what's left to do on it\n. Yeah, you don't update copyrights - only the start year is listed. And, since you're in the US, you don't even need that. Every work is implicitly copyrighted from the time of its creation till 70 years after the death of the author.\n. @gkz - have you seen nodeca/argparse? You might like it... It has a lot of the same goals as gkz/optionator but already has a small communitty built around it, and a design copied from the very popular Python argparse module.\n. +1 for making it work the same as it does in the original CoffeeScript\n. +1 thanks @mizchi, this is a hugely important for me being able to move to CS-redux\n. ",
    "davidbonnet": "Still no support of super?\n. \u2026or this, which is faster: Foo::bla.call @, message.\nPerhaps, the reason why it is called CoffeeScript Redux is that it is missing some of the features\u2026 :) Yet omitting super makes the whole class aspect less useful.\n. Still no support of super?\n. \u2026or this, which is faster: Foo::bla.call @, message.\nPerhaps, the reason why it is called CoffeeScript Redux is that it is missing some of the features\u2026 :) Yet omitting super makes the whole class aspect less useful.\n. ",
    "matthiasg": "stumbled over this too .. a suggested workaround should at least be presented or documented shouldnt it ?\n. Since this specific item seems rather easy to fix.. Are the any other obvious omissions from this compiler ? \n-----Original Message-----\nFrom: \"David Bonnet\" notifications@github.com\nSent: \u200e10.\u200e10.\u200e2014 10:40\nTo: \"michaelficarra/CoffeeScriptRedux\" CoffeeScriptRedux@noreply.github.com\nCc: \"matthiasg\" mgt576@gmail.com\nSubject: Re: [CoffeeScriptRedux] Fails to compile when subclass constructorcalls super (#244)\n\u2026or this, which is faster: Foo::bla.call @, message.\nPerhaps, the reason why it is called CoffeeScript Redux is that it is missing some of the features\u2026 :) Yet omitting super makes the whole class aspect less useful.\n\u2014\nReply to this email directly or view it on GitHub.=\n. stumbled over this too .. a suggested workaround should at least be presented or documented shouldnt it ?\n. Since this specific item seems rather easy to fix.. Are the any other obvious omissions from this compiler ? \n-----Original Message-----\nFrom: \"David Bonnet\" notifications@github.com\nSent: \u200e10.\u200e10.\u200e2014 10:40\nTo: \"michaelficarra/CoffeeScriptRedux\" CoffeeScriptRedux@noreply.github.com\nCc: \"matthiasg\" mgt576@gmail.com\nSubject: Re: [CoffeeScriptRedux] Fails to compile when subclass constructorcalls super (#244)\n\u2026or this, which is faster: Foo::bla.call @, message.\nPerhaps, the reason why it is called CoffeeScript Redux is that it is missing some of the features\u2026 :) Yet omitting super makes the whole class aspect less useful.\n\u2014\nReply to this email directly or view it on GitHub.=\n. ",
    "jordansexton": "This issue hasn't been addressed and the project seems to be abandonware. There is no real substitute for super, so the suggested workaround I went with was \"don't use CoffeeScriptRedux\". Hard to establish any practical use for it when it's not feature complete.\n. Only a substitute for super in the simplest case.\nDoesn't work with non-constructor methods.\n. You can also do this:\ncoffeescript\n    Foo::bla.apply this, [message]\nBut that isn't the point. This issue isn't that workarounds to not supporting super don't exist, it's that super doesn't work in CSRedux and it works in CoffeeScript proper, which means CSRedux is not a substitute for the CoffeeScript compiler without changing your code.\n. This issue hasn't been addressed and the project seems to be abandonware. There is no real substitute for super, so the suggested workaround I went with was \"don't use CoffeeScriptRedux\". Hard to establish any practical use for it when it's not feature complete.\n. Only a substitute for super in the simplest case.\nDoesn't work with non-constructor methods.\n. You can also do this:\ncoffeescript\n    Foo::bla.apply this, [message]\nBut that isn't the point. This issue isn't that workarounds to not supporting super don't exist, it's that super doesn't work in CSRedux and it works in CoffeeScript proper, which means CSRedux is not a substitute for the CoffeeScript compiler without changing your code.\n. ",
    "tangzero": "try:\n``` coffeescript\nclass Foo\nconstructor: (@name) ->\nclass Bar extends Foo\nconstructor: () ->\n    Foo.apply this, [\"Peter\"]\n```\n. Really?\n``` coffeescript\nclass Foo\nconstructor: (@name) ->\nbla: (message) ->\n    console.log \"#{message} by #{@name}\"\nclass Bar extends Foo\nconstructor: () ->\n    Foo.apply this, [\"Peter\"]\nbla: (message) ->\n    Foo.prototype.bla.apply this, [message]\nnew Bar().bla \"No super\" # No super by Peter \n```\nI don't like the fact that I need to do this way, but works...\n. I agree.\n. try:\n``` coffeescript\nclass Foo\nconstructor: (@name) ->\nclass Bar extends Foo\nconstructor: () ->\n    Foo.apply this, [\"Peter\"]\n```\n. Really?\n``` coffeescript\nclass Foo\nconstructor: (@name) ->\nbla: (message) ->\n    console.log \"#{message} by #{@name}\"\nclass Bar extends Foo\nconstructor: () ->\n    Foo.apply this, [\"Peter\"]\nbla: (message) ->\n    Foo.prototype.bla.apply this, [message]\nnew Bar().bla \"No super\" # No super by Peter \n```\nI don't like the fact that I need to do this way, but works...\n. I agree.\n. ",
    "boccob": "But why new @ is invalid syntax?\n. But why new @ is invalid syntax?\n. ",
    "vivinjoy": "+1 for this issue.\n. +1 for this issue.\n. ",
    "philbooth": "Oh dear, how embarrassing. Apologies for failing to read! :-/\n. Oh dear, how embarrassing. Apologies for failing to read! :-/\n. ",
    "logicmason": "I have to admit my eyes lit up as soon as I saw pegjs :)\n. done!\n. I have to admit my eyes lit up as soon as I saw pegjs :)\n. done!\n. ",
    "jnicklas": "@Nami-Doc but I'm not trying to use the JS in operator. jashkenas/coffee-script supports using in as an operator, which compiles a in b to b.indexOf(a) essentially, with some optimizations for literal arrays and ranges, and polyfills it for IE <= 8.\nI'm aware how the in operator works in JavaScript and that its equivalent is of in CoffeeScript. However, jashkenas/coffee-script also supports in as an operator, but with different semantics to the JS version. The strange thing is that redux doesn't even throw a compile error when you try to use it though, I could understand not supporting this feature, as it's honestly a bit frivolous, but it just prints nothing, which doesn't seem like the right thing to me at all. And also, it does work when evaluating the code, as in my REPL example pasted above, it just doesn't print the correct compiled code.\n. Okay, makes sense, thanks!\n. @Nami-Doc but I'm not trying to use the JS in operator. jashkenas/coffee-script supports using in as an operator, which compiles a in b to b.indexOf(a) essentially, with some optimizations for literal arrays and ranges, and polyfills it for IE <= 8.\nI'm aware how the in operator works in JavaScript and that its equivalent is of in CoffeeScript. However, jashkenas/coffee-script also supports in as an operator, but with different semantics to the JS version. The strange thing is that redux doesn't even throw a compile error when you try to use it though, I could understand not supporting this feature, as it's honestly a bit frivolous, but it just prints nothing, which doesn't seem like the right thing to me at all. And also, it does work when evaluating the code, as in my REPL example pasted above, it just doesn't print the correct compiled code.\n. Okay, makes sense, thanks!\n. ",
    "nfour": "+1 for coco's implementation. I felt like CS 1's chaining was a long overdue victory for the language; but this would be even better.\n. +1 for coco's implementation. I felt like CS 1's chaining was a long overdue victory for the language; but this would be even better.\n. ",
    "hhelwich": "Thank you for the quick answer and the infos! I understand the problem but standalone @ looks better in my code, so i will stick to it ;-)\n. Thank you for the quick answer and the infos! I understand the problem but standalone @ looks better in my code, so i will stick to it ;-)\n. ",
    "hmaurer": "I feel that optimisation is, in general, a good thing, and there is an option to disable it. Constructing your own compilation pipeline is not accessible to every user who would benefit from optimisation. \n. I guess we should add some code to shadow the outer variable (if there is one) over there:\nhttps://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L627\nAny advice on how to do that? I just started looking at the redux source code.\nAnother option could be not to delete the parameter:\nhttps://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L627\nIt will require some changes to the generated code L630-635 though, and some special handling for MemberAccessOp  or we'll run into the same trouble as in https://github.com/michaelficarra/CoffeeScriptRedux/issues/84\n. Ok, as far as I see, we've got a few options here:\n(1) Re-declare the variable, i.e.\ncoffee\n(a..., b) ->\njs\nfunction (b) {\n  var a;\n  ...\n}\nProblem: I have got no clue how to do that since redux seems to be dealing with variable decls around https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L1054. I couldn't find a way to force it to shadow an outer variable. Any insights here?\n(2) Not removing the parameter\ncoffee\n(a..., b) ->\njs\nfunction (a, b) {\n  ....\n}\nWould require some modifications around https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L630.\n(3) Push the parameter at the end of the parameter list\ncoffee\n(a..., b) ->\njs\nfunction (b, a) {\n  ....\n}\nAfaik that's a one-liner fix:\ncoffee\nparameters.push paramName\nthere https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L635\nAny preference?\n. Related to https://github.com/michaelficarra/CoffeeScriptRedux/issues/250\n. https://github.com/michaelficarra/CoffeeScriptRedux/issues/248\n. I feel that optimisation is, in general, a good thing, and there is an option to disable it. Constructing your own compilation pipeline is not accessible to every user who would benefit from optimisation. \n. I guess we should add some code to shadow the outer variable (if there is one) over there:\nhttps://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L627\nAny advice on how to do that? I just started looking at the redux source code.\nAnother option could be not to delete the parameter:\nhttps://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L627\nIt will require some changes to the generated code L630-635 though, and some special handling for MemberAccessOp  or we'll run into the same trouble as in https://github.com/michaelficarra/CoffeeScriptRedux/issues/84\n. Ok, as far as I see, we've got a few options here:\n(1) Re-declare the variable, i.e.\ncoffee\n(a..., b) ->\njs\nfunction (b) {\n  var a;\n  ...\n}\nProblem: I have got no clue how to do that since redux seems to be dealing with variable decls around https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L1054. I couldn't find a way to force it to shadow an outer variable. Any insights here?\n(2) Not removing the parameter\ncoffee\n(a..., b) ->\njs\nfunction (a, b) {\n  ....\n}\nWould require some modifications around https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L630.\n(3) Push the parameter at the end of the parameter list\ncoffee\n(a..., b) ->\njs\nfunction (b, a) {\n  ....\n}\nAfaik that's a one-liner fix:\ncoffee\nparameters.push paramName\nthere https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/compiler.coffee#L635\nAny preference?\n. Related to https://github.com/michaelficarra/CoffeeScriptRedux/issues/250\n. https://github.com/michaelficarra/CoffeeScriptRedux/issues/248\n. ",
    "robertrossmann": "Thanks for the explanation.\nI wonder why was the CLI designed this way? If I develop a CLI application that is supposed to closely resemble native executables on Unix-based systems with CS, the requirement to write -- in front of any argument list seems extremely impractical and not very user-friendly.\nIs there possibly any other way around this design decision if its redesign is not desirable?\nThanks for help!\n. @michaelficarra Perhaps a solution might be to treat arguments before the script file as arguments for compiler and arguments after the script file as arguments for the script?\nbash\ncoffee --somethingForCoffee myScript.coffee --somethingForMyScript\nYour requirement is satisfied and I can call it with -v without those -- in front.\nIn my opinion, it does not really matter in the end if the arguments are separated by an executable name or by special character sequence.\n. @michaelficarra But still the only benefit I see now is that the script file path is more or less flexible. You specify executable path, optionally some compiler args, then you pass -- and afterwards you can specify args for the executable. Is it really that more flexible? Perhaps I am just not seeing something. Maybe this is used by many other tools but I have seriously not bumped across this yet; if that's the case then I guess I'll drop this case.:)\nPS.\nI think I found a viable solution for my requirement, but I would like to continue this discussion as long as there is a chance to improve CS by it.\n1. The main executable is a standard JS file, i.e. main.js, which will load coffee-script-redux as dependency:\n   var cs = require('coffee-script-redux');\n2. Coffee compiler will be registered with the cs.register() method\n3. Another file, main.coffee, which contains the main application's logic, is loaded:\n   require('./main.coffee');\nThis way, I can use node main.js -v and the argument will be handled by my application instead of interpreted by CS. I am unsure how would I fare if suddenly I discovered I also need to pass some arguments to the compiler.:)\n. Thanks for the explanation.\nI wonder why was the CLI designed this way? If I develop a CLI application that is supposed to closely resemble native executables on Unix-based systems with CS, the requirement to write -- in front of any argument list seems extremely impractical and not very user-friendly.\nIs there possibly any other way around this design decision if its redesign is not desirable?\nThanks for help!\n. @michaelficarra Perhaps a solution might be to treat arguments before the script file as arguments for compiler and arguments after the script file as arguments for the script?\nbash\ncoffee --somethingForCoffee myScript.coffee --somethingForMyScript\nYour requirement is satisfied and I can call it with -v without those -- in front.\nIn my opinion, it does not really matter in the end if the arguments are separated by an executable name or by special character sequence.\n. @michaelficarra But still the only benefit I see now is that the script file path is more or less flexible. You specify executable path, optionally some compiler args, then you pass -- and afterwards you can specify args for the executable. Is it really that more flexible? Perhaps I am just not seeing something. Maybe this is used by many other tools but I have seriously not bumped across this yet; if that's the case then I guess I'll drop this case.:)\nPS.\nI think I found a viable solution for my requirement, but I would like to continue this discussion as long as there is a chance to improve CS by it.\n1. The main executable is a standard JS file, i.e. main.js, which will load coffee-script-redux as dependency:\n   var cs = require('coffee-script-redux');\n2. Coffee compiler will be registered with the cs.register() method\n3. Another file, main.coffee, which contains the main application's logic, is loaded:\n   require('./main.coffee');\nThis way, I can use node main.js -v and the argument will be handled by my application instead of interpreted by CS. I am unsure how would I fare if suddenly I discovered I also need to pass some arguments to the compiler.:)\n. ",
    "aurium": "IMHO the coffee bin from cs2 must not to be on system path, or you will conflict with jashkenas/coffee-script -- the official coffeescript version.\nMay be more polite to ask @michaelficarra about this. I believe you must change the command name (with a symlink or directly filename change) to coffee2 or coffee-alpha or cs2, allowing to have both versions in the same system.\n. +1 @drarmstr \n. Well...\nIf it was possible to plug parser extensions, and plug external AST to JS code generator, on CS compiler, initiatives like IcedCoffee, ember-script, and ES6 support could survive integrated to the CS ecosystem. And if the ES6 prove it is a good idea (i believe so), may be easier to push it to the CS core, on the future.\n. IMHO the coffee bin from cs2 must not to be on system path, or you will conflict with jashkenas/coffee-script -- the official coffeescript version.\nMay be more polite to ask @michaelficarra about this. I believe you must change the command name (with a symlink or directly filename change) to coffee2 or coffee-alpha or cs2, allowing to have both versions in the same system.\n. +1 @drarmstr \n. Well...\nIf it was possible to plug parser extensions, and plug external AST to JS code generator, on CS compiler, initiatives like IcedCoffee, ember-script, and ES6 support could survive integrated to the CS ecosystem. And if the ES6 prove it is a good idea (i believe so), may be easier to push it to the CS core, on the future.\n. ",
    "michaelowens": "Any updates on this? Is there any progress?\n. Any updates on this? Is there any progress?\n. ",
    "pYr0x": "i looked at it before and didnt find an answer\n. ok.. but is there a workaround?\n. i looked at it before and didnt find an answer\n. ok.. but is there a workaround?\n. ",
    "RobLoach": ":+1: \n. :+1: \n. ",
    "sylvain-hamel": "I see. It's a firewall issue here. You've declared the dependency using the git: protocol which requires a specific port to be open.\n\"cscodegen\": \"git://github.com/michaelficarra/cscodegen.git...\ncould you please change it to git+https:\n\"cscodegen\": \"git+https://github.com/michaelficarra/cscodegen.git...\nto prevent using the git port.\n. Thanks a lot!\n. @michaelficarra, can you please update the package on the npm registry? Thanks.\n. I see. It's a firewall issue here. You've declared the dependency using the git: protocol which requires a specific port to be open.\n\"cscodegen\": \"git://github.com/michaelficarra/cscodegen.git...\ncould you please change it to git+https:\n\"cscodegen\": \"git+https://github.com/michaelficarra/cscodegen.git...\nto prevent using the git port.\n. Thanks a lot!\n. @michaelficarra, can you please update the package on the npm registry? Thanks.\n. ",
    "RLovelett": "This would be great to see updated in npm.\n. This would be great to see updated in npm.\n. ",
    "etylsarin": "@michaelficarra, could you please update the npm registry?\n. @michaelficarra, could you please update the npm registry?\n. ",
    "Marsup": "@michaelficarra Same as the others, can you publish it please ?\n. @michaelficarra Same as the others, can you publish it please ?\n. ",
    "tony-kerz": "ok, how about any way to retrieve the class name of an instance?\n. thx @akre54, haha, right in front of my face, perfect :+1: \n. ok, how about any way to retrieve the class name of an instance?\n. thx @akre54, haha, right in front of my face, perfect :+1: \n. ",
    "drarmstr": "Adding __name__ to the constructor, just like __super__, would be great for building class hierarchies.  Currently, these issue all say to just create our own property in the instance or prototype.  Yes, that works, but it becomes tedious and isn't DRY, and so more prone to errors.\n. Adding __name__ to the constructor, just like __super__, would be great for building class hierarchies.  Currently, these issue all say to just create our own property in the instance or prototype.  Yes, that works, but it becomes tedious and isn't DRY, and so more prone to errors.\n. ",
    "dkundel": "Agree with that part :) I was just hoping there might be a way I can achieve something such as the acorn_loose parser and it's parse_dammit function :) https://github.com/marijnh/acorn#acorn_loosejs\n. Agree with that part :) I was just hoping there might be a way I can achieve something such as the acorn_loose parser and it's parse_dammit function :) https://github.com/marijnh/acorn#acorn_loosejs\n. ",
    "cybertk": "Is there any plan to support this format?\n. Is there any plan to support this format?\n. ",
    "DavidSouther": "NB if the answer is, \"Don't use this syntax, use splice as it's intended\", that's totes cool, but a mention of that in the know breaking changes would be :+1: \n. When, @michaelficarra? The pulse for redux is looking mighty sparse.\n. Oh, awesome! When will beta9 get released to NPM?\n. Apologies, this seems to fall under... a ticket I thought I saw but can't now find. Adding commas works. Is this an intentional deviation?\nhttp://michaelficarra.github.io/CoffeeScriptRedux/#try:%20%20%20%20_newPageHandler%20%3D%20(%7B%0A%20%20%20%20%20%20%20%20path%2C%0A%20%20%20%20%20%20%20%20order%2C%0A%20%20%20%20%20%20%20%20definition%2C%0A%20%20%20%20%20%20%20%20redirect%2C%0A%20%20%20%20%20%20%20%20noUid%2C%0A%20%20%20%20%20%20%20%20permissioned%0A%20%20%20%20%7D)-%3E%0A%20%20%20%20%20%20%20%20order%20or%3D%20100%0A%20%20%20%20%20%20%20%20noUid%20or%3D%20false%0A%20%20%20%20%20%20%20%20permissioned%20or%3D%20(-%3E%20true)%0A\n. NB if the answer is, \"Don't use this syntax, use splice as it's intended\", that's totes cool, but a mention of that in the know breaking changes would be :+1: \n. When, @michaelficarra? The pulse for redux is looking mighty sparse.\n. Oh, awesome! When will beta9 get released to NPM?\n. Apologies, this seems to fall under... a ticket I thought I saw but can't now find. Adding commas works. Is this an intentional deviation?\nhttp://michaelficarra.github.io/CoffeeScriptRedux/#try:%20%20%20%20_newPageHandler%20%3D%20(%7B%0A%20%20%20%20%20%20%20%20path%2C%0A%20%20%20%20%20%20%20%20order%2C%0A%20%20%20%20%20%20%20%20definition%2C%0A%20%20%20%20%20%20%20%20redirect%2C%0A%20%20%20%20%20%20%20%20noUid%2C%0A%20%20%20%20%20%20%20%20permissioned%0A%20%20%20%20%7D)-%3E%0A%20%20%20%20%20%20%20%20order%20or%3D%20100%0A%20%20%20%20%20%20%20%20noUid%20or%3D%20false%0A%20%20%20%20%20%20%20%20permissioned%20or%3D%20(-%3E%20true)%0A\n. ",
    "es128": "+1\n. +1\n. +1\n. +1\n. ",
    "pygy": "\nThis is expected behaviour. CoffeeScript has a long history of ignoring the existence of getters.\n\nThe trouble is it means that you can't interact cleanly with JS code that relies on that feature.\n. That's what I meant by \"not cleanly\".\nFurthermore, a future, smarter compiler may also eliminate use calls, which are no ops, not matter what.\n. > It'd be kind of difficult to eliminate that call since the compiler can't be sure that the value of use itself hasn't changed.\nSince CoffeeScript is lexically scoped, the compiler has all the information needed to determine if a variable is rebound later on. In that case, if the evaluation of the arguments dont have any effect, removing the call is a valid optimization. Relying on the lack of a correct optimization to prevent an invalid one is probably not a good idea...\nThat being said, I agree that relying on the side effects of property access is a bad programming \npractice, I just wanted to be sure it wasn't an oversight.\nWell, it could have its use in a well documented DSL, but it's a corner case.\nThe backticks allow it if needed, so it isn't that problematic if the language doesn't support it anyway. \nAs far as I knew, backticks had been removed from CS 2.0. \nI'm glad that they're back in. In this case it makes it explicit that the property access does something special, so if someone encounters foo.bar, it means that something special is occuring.\n. > This is expected behaviour. CoffeeScript has a long history of ignoring the existence of getters.\nThe trouble is it means that you can't interact cleanly with JS code that relies on that feature.\n. That's what I meant by \"not cleanly\".\nFurthermore, a future, smarter compiler may also eliminate use calls, which are no ops, not matter what.\n. > It'd be kind of difficult to eliminate that call since the compiler can't be sure that the value of use itself hasn't changed.\nSince CoffeeScript is lexically scoped, the compiler has all the information needed to determine if a variable is rebound later on. In that case, if the evaluation of the arguments dont have any effect, removing the call is a valid optimization. Relying on the lack of a correct optimization to prevent an invalid one is probably not a good idea...\nThat being said, I agree that relying on the side effects of property access is a bad programming \npractice, I just wanted to be sure it wasn't an oversight.\nWell, it could have its use in a well documented DSL, but it's a corner case.\nThe backticks allow it if needed, so it isn't that problematic if the language doesn't support it anyway. \nAs far as I knew, backticks had been removed from CS 2.0. \nI'm glad that they're back in. In this case it makes it explicit that the property access does something special, so if someone encounters foo.bar, it means that something special is occuring.\n. ",
    "mizchi": "Fix by myself :) but I have no confidence it is correct way... in especially assignee detection.\n@michaelficarra please give me advice, or merge if you don't care.\n. I will implement static super too. After that I want to reply other peoples fix.\n. My private goal is that I want to make CSR which has compatibility to CS. (And for my hobby project TypedCoffeeScript that aimed to super set of CS, but you, execept me,  don't have to take care about it:)\nAnyway, I will fix some point you mentioned first. Thx!\n. Now it works about super and static method super in class as CS specs.\n. Oops, I passed only syntax and broke execution. I'll fix...\n. Fix by myself :) but I have no confidence it is correct way... in especially assignee detection.\n@michaelficarra please give me advice, or merge if you don't care.\n. I will implement static super too. After that I want to reply other peoples fix.\n. My private goal is that I want to make CSR which has compatibility to CS. (And for my hobby project TypedCoffeeScript that aimed to super set of CS, but you, execept me,  don't have to take care about it:)\nAnyway, I will fix some point you mentioned first. Thx!\n. Now it works about super and static method super in class as CS specs.\n. Oops, I passed only syntax and broke execution. I'll fix...\n. ",
    "ef4": "I incorporated this PR into my ES6 branch, so I can piggyback off the super keyword. It's working pretty well. Demo:\n$ cat sample.coffee\ncoffee\nclass Foo extends Bar\n  someValue: 1\n  constructor: (a) ->\n    super(a)\n  doIt: ->\n    super(\"yay\")\n$ ./bin/coffee --bare --js --input ./sample.coffee --target-es6\njs\n// Generated by CoffeeScript 2.0.0-beta9-dev-es6\nclass Foo extends Bar {\n  constructor(a) {\n    super(a);\n  }\n  doIt() {\n    return super.doIt('yay');\n  }\n}\nFoo.prototype.someValue = 1;\n. Apologies, I did an issue search but \"node\" was the wrong term, as it's rather overloaded here. :stuck_out_tongue: \n. I was interpreting the error as \"while disambiguating a structure that starts at line 1, col 1, I hit an error offset bytes ahead of that point.\nI haven't looked into the grammar to know if that's really how it's working, but it seems a reasonable guess. \n. Yeah, if that's the intent of offset, line, and column then we probably do have a bug in pegjs. Skimming their repo just now it does look like it's supposed to work that way.\n. @srb- default params are working now, for both ArrowExpressions and FunctionExpresion:\n$ cat sample.coffee\n``` coffee\nclass Foo extends Bar\n  doIt: (a=1, b=2, c...)->\n    super(\"yay\", a, b, c)\ndemo = (a, b=2, c...) => a + b + c.length\n```\n$ ./bin/coffee --bare --js --input ./sample.coffee --target-es6\njs\n// Generated by CoffeeScript 2.0.0-beta9-dev-es6\nvar demo;\nclass Foo extends Bar {\n  doIt(a = 1, b = 2, ...c) {\n    return super.doIt('yay', a, b, c);\n  }\n}\ndemo = (a, b = 2, ...c) => a + b + c.length;\n. I haven't yet, but I'm planning to use it to help me port a significant production codebase from coffeescript to ES6. This is admittedly a lower bar than getting it working as an ongoing production compiler -- I can supervise the process more closely.\nOverall I have been happy with the parser -- it is more conservative than the one in original coffeescript, and it forced me to disambiguate a bunch of dubious code. And some of the roughest features (like super, which exists only in a PR) are things that I've already replaced with much simpler ES6 versions.\nSo for my use case it works, but I can understand the hesitation. You definitely have to be willing to debug the compiler to use it at this point.\n. Sure, happy to rebase in anticipation of merge, as soon as I have the test suite stabilized. \n. I have a separate tool for safely porting the comments across, using source\nmapping as a guide. I should get around to publishing it.\nThis PR is still definitely a work in progress. It's usable to if you're\ndoing one file at a time and supervising it, but it definitely has holes.\nOn Aug 26, 2015 8:13 PM, \"Brian Donovan\" notifications@github.com wrote:\n\nWow, I wish I'd seen this sooner. I've been working on decaffeinate\nhttps://github.com/eventualbuddha/decaffeinate which has a pretty\nsimilar goal. Did I understand you correctly, @ef4\nhttps://github.com/ef4, that you're trying to move a codebase from\nCoffeeScript to ES6? If so, we might want to see if there's any work we can\ndo together as that's my goal.\nThe main reason I didn't go with the approach in this PR is that I'd lose\ncomments and formatting.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/344#issuecomment-135214201\n.\n. I had to shift focus to other things, anyone is welcome to take it and run with it.\n\nThe status is the same as my last comment: it's already useful as an assistant if you're hand-porting code from coffeescript to ES2015. I wouldn't trust it to transpile a whole codebase.\n. Sure.\n. https://github.com/michaelficarra/CoffeeScriptRedux/issues/299 looks like the same bug, although this example is broader -- no destructuring is needed to trigger the bug.\n. Rebased and recompiled lib.\n. This is all part of my grand scheme to make this into a coffeescript-to-es6 compiler. :smile: \n. I incorporated this PR into my ES6 branch, so I can piggyback off the super keyword. It's working pretty well. Demo:\n$ cat sample.coffee\ncoffee\nclass Foo extends Bar\n  someValue: 1\n  constructor: (a) ->\n    super(a)\n  doIt: ->\n    super(\"yay\")\n$ ./bin/coffee --bare --js --input ./sample.coffee --target-es6\njs\n// Generated by CoffeeScript 2.0.0-beta9-dev-es6\nclass Foo extends Bar {\n  constructor(a) {\n    super(a);\n  }\n  doIt() {\n    return super.doIt('yay');\n  }\n}\nFoo.prototype.someValue = 1;\n. Apologies, I did an issue search but \"node\" was the wrong term, as it's rather overloaded here. :stuck_out_tongue: \n. I was interpreting the error as \"while disambiguating a structure that starts at line 1, col 1, I hit an error offset bytes ahead of that point.\nI haven't looked into the grammar to know if that's really how it's working, but it seems a reasonable guess. \n. Yeah, if that's the intent of offset, line, and column then we probably do have a bug in pegjs. Skimming their repo just now it does look like it's supposed to work that way.\n. @srb- default params are working now, for both ArrowExpressions and FunctionExpresion:\n$ cat sample.coffee\n``` coffee\nclass Foo extends Bar\n  doIt: (a=1, b=2, c...)->\n    super(\"yay\", a, b, c)\ndemo = (a, b=2, c...) => a + b + c.length\n```\n$ ./bin/coffee --bare --js --input ./sample.coffee --target-es6\njs\n// Generated by CoffeeScript 2.0.0-beta9-dev-es6\nvar demo;\nclass Foo extends Bar {\n  doIt(a = 1, b = 2, ...c) {\n    return super.doIt('yay', a, b, c);\n  }\n}\ndemo = (a, b = 2, ...c) => a + b + c.length;\n. I haven't yet, but I'm planning to use it to help me port a significant production codebase from coffeescript to ES6. This is admittedly a lower bar than getting it working as an ongoing production compiler -- I can supervise the process more closely.\nOverall I have been happy with the parser -- it is more conservative than the one in original coffeescript, and it forced me to disambiguate a bunch of dubious code. And some of the roughest features (like super, which exists only in a PR) are things that I've already replaced with much simpler ES6 versions.\nSo for my use case it works, but I can understand the hesitation. You definitely have to be willing to debug the compiler to use it at this point.\n. Sure, happy to rebase in anticipation of merge, as soon as I have the test suite stabilized. \n. I have a separate tool for safely porting the comments across, using source\nmapping as a guide. I should get around to publishing it.\nThis PR is still definitely a work in progress. It's usable to if you're\ndoing one file at a time and supervising it, but it definitely has holes.\nOn Aug 26, 2015 8:13 PM, \"Brian Donovan\" notifications@github.com wrote:\n\nWow, I wish I'd seen this sooner. I've been working on decaffeinate\nhttps://github.com/eventualbuddha/decaffeinate which has a pretty\nsimilar goal. Did I understand you correctly, @ef4\nhttps://github.com/ef4, that you're trying to move a codebase from\nCoffeeScript to ES6? If so, we might want to see if there's any work we can\ndo together as that's my goal.\nThe main reason I didn't go with the approach in this PR is that I'd lose\ncomments and formatting.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/michaelficarra/CoffeeScriptRedux/pull/344#issuecomment-135214201\n.\n. I had to shift focus to other things, anyone is welcome to take it and run with it.\n\nThe status is the same as my last comment: it's already useful as an assistant if you're hand-porting code from coffeescript to ES2015. I wouldn't trust it to transpile a whole codebase.\n. Sure.\n. https://github.com/michaelficarra/CoffeeScriptRedux/issues/299 looks like the same bug, although this example is broader -- no destructuring is needed to trigger the bug.\n. Rebased and recompiled lib.\n. This is all part of my grand scheme to make this into a coffeescript-to-es6 compiler. :smile: \n. ",
    "RReverser": "@michaelficarra Could you please have a look at this? Seems to be trivial thing to add, but I can't compile CoffeeScriptRedux on Windows machine :(\n. @michaelficarra Could you please have a look at this? Seems to be trivial thing to add, but I can't compile CoffeeScriptRedux on Windows machine :(\n. ",
    "rachkoud": "There is a workaround, if we add parenthesis like this, it works : \n```\n  processOffer: (msg) ->\n    @log \"Processing offer\", msg\n@pc.setRemoteDescription new adapter.RTCSessionDescription(msg)\n@pc.createAnswer ((sdp) =>\n  @pc.setLocalDescription sdp\n  @sendSignal sdp), ((err) =>\n  @log \"Error creating answer\", err), @sdpConstraints\n\n```\n. @michaelficarra When you talk about naming your function, it's just like that (this solution compiles)?\n```\n    processOffer: (msg) ->\n      @log \"Processing offer\", msg\n  @pc.setRemoteDescription new adapter.RTCSessionDescription(msg)\n  f1 = (sdp) =>\n    @pc.setLocalDescription sdp\n    @sendSignal sdp\n  f2 = (err) =>\n    @log \"Error creating answer\", err\n  @pc.createAnswer f1, f2 , @sdpConstraints\n\n```\n. Yes of course. Thanks!\n. There is a workaround, if we add parenthesis like this, it works : \n```\n  processOffer: (msg) ->\n    @log \"Processing offer\", msg\n@pc.setRemoteDescription new adapter.RTCSessionDescription(msg)\n@pc.createAnswer ((sdp) =>\n  @pc.setLocalDescription sdp\n  @sendSignal sdp), ((err) =>\n  @log \"Error creating answer\", err), @sdpConstraints\n\n```\n. @michaelficarra When you talk about naming your function, it's just like that (this solution compiles)?\n```\n    processOffer: (msg) ->\n      @log \"Processing offer\", msg\n  @pc.setRemoteDescription new adapter.RTCSessionDescription(msg)\n  f1 = (sdp) =>\n    @pc.setLocalDescription sdp\n    @sendSignal sdp\n  f2 = (err) =>\n    @log \"Error creating answer\", err\n  @pc.createAnswer f1, f2 , @sdpConstraints\n\n```\n. Yes of course. Thanks!\n. ",
    "loveencounterflow": "That it is legal doesn't mean it's intentional, very useful or clear. The c part of the expression gets evaluated the appropriate number of times and the value of the expression is a list with the same number of undefined values: \ncoffee\ncoffee> for [ 0 .. 3 ] then console.log 'x'\nx\nx\nx\nx\n[ undefined,\n  undefined,\n  undefined,\n  undefined ]\ncoffee>\nIt gets worse if you happen to place this as the last line into a function, because then implicit return insertion kicks in and will make that list the return value of the function, which is very probably not what you intended. Do you have any real use case?\n. Is it? The closest i seem to be able to find is, under \"Operators and Aliases\" on the CoffeeScript homepage, the remark that \"Instead of a newline or semicolon, then can be used to separate conditions from expressions, in while, if/else, and switch/when statements.\" for is not mentioned here, though.\n. That it is legal doesn't mean it's intentional, very useful or clear. The c part of the expression gets evaluated the appropriate number of times and the value of the expression is a list with the same number of undefined values: \ncoffee\ncoffee> for [ 0 .. 3 ] then console.log 'x'\nx\nx\nx\nx\n[ undefined,\n  undefined,\n  undefined,\n  undefined ]\ncoffee>\nIt gets worse if you happen to place this as the last line into a function, because then implicit return insertion kicks in and will make that list the return value of the function, which is very probably not what you intended. Do you have any real use case?\n. Is it? The closest i seem to be able to find is, under \"Operators and Aliases\" on the CoffeeScript homepage, the remark that \"Instead of a newline or semicolon, then can be used to separate conditions from expressions, in while, if/else, and switch/when statements.\" for is not mentioned here, though.\n. ",
    "eddiemonge": "that just looks so weird and odd. the lonesome comma looks only slightly less weird though\n. I get this as well\n. that just looks so weird and odd. the lonesome comma looks only slightly less weird though\n. I get this as well\n. ",
    "andreineculau": "A short digression.\nI'm not sure what the ultimate goal is with this conversion, but one could also just strip the grammar of actions, and with the help of https://github.com/andreineculau/pegjs-override-action consolidate the actions in a standalone module.\n. A short digression.\nI'm not sure what the ultimate goal is with this conversion, but one could also just strip the grammar of actions, and with the help of https://github.com/andreineculau/pegjs-override-action consolidate the actions in a standalone module.\n. ",
    "schueler1987": "+1\nThis issue came up for us when using karma-coverage (which relies on ibrik which then uses coffee-script-redux).\n. +1\nThis issue came up for us when using karma-coverage (which relies on ibrik which then uses coffee-script-redux).\n. ",
    "yumitsu": "Your code looks bad for me too. Anyway, if I modify your code just for a bit:\n``` coffee\nangular.module('App').controller('AppController', [\n  '$location', '$scope', (\n    $location,   $scope) ->\n@link = (field) ->\n  (\"http://example.com\" +\n  \"/\" + field)\n@\n\n])\n```\nCoffeeScriptRedux compiles it as expected:\njs\n// Generated by CoffeeScript 2.0.0-beta8\nangular.module('App').controller('AppController', [\n  '$location',\n  '$scope',\n  function ($location, $scope) {\n    this.link = function (field) {\n      return 'http://example.com' + '/' + field;\n    };\n    return this;\n  }\n]);\n. @arkarkark Honestly, I can't understand why vanilla coffee-script acts so \"forgiving\".\n. @erisdiscord It's quite strange\n. Your code looks bad for me too. Anyway, if I modify your code just for a bit:\n``` coffee\nangular.module('App').controller('AppController', [\n  '$location', '$scope', (\n    $location,   $scope) ->\n@link = (field) ->\n  (\"http://example.com\" +\n  \"/\" + field)\n@\n\n])\n```\nCoffeeScriptRedux compiles it as expected:\njs\n// Generated by CoffeeScript 2.0.0-beta8\nangular.module('App').controller('AppController', [\n  '$location',\n  '$scope',\n  function ($location, $scope) {\n    this.link = function (field) {\n      return 'http://example.com' + '/' + field;\n    };\n    return this;\n  }\n]);\n. @arkarkark Honestly, I can't understand why vanilla coffee-script acts so \"forgiving\".\n. @erisdiscord It's quite strange\n. ",
    "arkarkark": "indeed, but if it's valid for the original coffee compiler, shouldn't your compiler like it too?\n. :-D \n. indeed, but if it's valid for the original coffee compiler, shouldn't your compiler like it too?\n. :-D \n. ",
    "flying-sheep": "OK, so why is this invalid?\n``` coffee\na(b,\n  c)\n\u2192 Syntax error on line 1, column 5: unexpected '\\n' (\\u000A)\n```\nisn\u2019t the grouping given via parens?\nit\u2019s especially of interest for me because coffee-react-transform creates such code:\ncoffee\nCar = React.createClass\n  render: ->\n    React.createElement(Vehicle, {\"doors\": (4), \"locked\": (isLocked()), \"data-colour\": \"red\", \"on\": true},\n      React.createElement(Parts.FrontSeat, null),\n      React.createElement(Parts.BackSeat, null),\n      React.createElement(\"p\", {\"className\": \"seat\"}, \"Which seat can I take? \", (@props?.seat or 'none'))\n    )\n. thanks but:\n1. i didn\u2019t create the code, coffee-react-transform did, so i have no control over it.\n2. there\u2019s absolutely no ambiguity so there\u2019s no reason why it shouldn\u2019t be accepted\n3. the grammar says nothing about whitespace in argument lists\n. OK, so why is this invalid?\n``` coffee\na(b,\n  c)\n\u2192 Syntax error on line 1, column 5: unexpected '\\n' (\\u000A)\n```\nisn\u2019t the grouping given via parens?\nit\u2019s especially of interest for me because coffee-react-transform creates such code:\ncoffee\nCar = React.createClass\n  render: ->\n    React.createElement(Vehicle, {\"doors\": (4), \"locked\": (isLocked()), \"data-colour\": \"red\", \"on\": true},\n      React.createElement(Parts.FrontSeat, null),\n      React.createElement(Parts.BackSeat, null),\n      React.createElement(\"p\", {\"className\": \"seat\"}, \"Which seat can I take? \", (@props?.seat or 'none'))\n    )\n. thanks but:\n1. i didn\u2019t create the code, coffee-react-transform did, so i have no control over it.\n2. there\u2019s absolutely no ambiguity so there\u2019s no reason why it shouldn\u2019t be accepted\n3. the grammar says nothing about whitespace in argument lists\n. ",
    "SuperPaintman": "@flying-sheep \n``` coffee\na(b\n   ,c)\nor\na \\\n      b\n    , c\n```\n. @flying-sheep \n``` coffee\na(b\n   ,c)\nor\na \\\n      b\n    , c\n```\n. ",
    "KenanSulayman": "Redux doesn't allow variable indentation anymore. Check if you're using space & tabs combined by accident.\n. Redux doesn't allow variable indentation anymore. Check if you're using space & tabs combined by accident.\n. ",
    "xyrius": "Just tried on 1.8.0, it generates the ternary as expected, runs fine (after\ninitialization of course) no errors.\nOn Mon, Sep 1, 2014 at 7:40 AM, Rico Sta. Cruz notifications@github.com\nwrote:\n\nThis:\nswitch (if a then b else c)\n  when d\n    e()\nis expected to become:\nswitch (a ? b : c) {\n  case d:\n    e();\n    break;}\nbut instead gives you:\n- Unknown expression type: IfStatement\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/329.\n. Just tried on 1.8.0, it generates the ternary as expected, runs fine (after\ninitialization of course) no errors.\n\nOn Mon, Sep 1, 2014 at 7:40 AM, Rico Sta. Cruz notifications@github.com\nwrote:\n\nThis:\nswitch (if a then b else c)\n  when d\n    e()\nis expected to become:\nswitch (a ? b : c) {\n  case d:\n    e();\n    break;}\nbut instead gives you:\n- Unknown expression type: IfStatement\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/michaelficarra/CoffeeScriptRedux/issues/329.\n. \n",
    "CodisRedding": "I found the function cs2js here https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/module.coffee#L68 but it doesn't work exactly like the old compile func coffeescript 1.* even though the comment is \"# Equivalent to original CS compile\". \nWhen I run cs2js and pass in the option to create the source map (just like I used to in the .compile func I get an error:\n```\nWarning: Cannot read property 'length' of undefined Use --force to continue.\nAborted due to warnings.\n```\n. Great comment and insight on options. Best closed before any chat of new options. :+1: \n. from what I heard, it's dead. #RIP\n. @erisdiscord a few different irc channels. =/\n. R.I.P\n. I found the function cs2js here https://github.com/michaelficarra/CoffeeScriptRedux/blob/master/src/module.coffee#L68 but it doesn't work exactly like the old compile func coffeescript 1.* even though the comment is \"# Equivalent to original CS compile\". \nWhen I run cs2js and pass in the option to create the source map (just like I used to in the .compile func I get an error:\n```\nWarning: Cannot read property 'length' of undefined Use --force to continue.\nAborted due to warnings.\n```\n. Great comment and insight on options. Best closed before any chat of new options. :+1: \n. from what I heard, it's dead. #RIP\n. @erisdiscord a few different irc channels. =/\n. R.I.P\n. ",
    "m1sta": "Distinct from named function expressions obviously, which I know are a no-go.\n. @eventualbuddha I like your idea of using decaffinate and babel because it seems to more naturally fit the idea of extensibility and supporting different target environments.\n. Distinct from named function expressions obviously, which I know are a no-go.\n. @eventualbuddha I like your idea of using decaffinate and babel because it seems to more naturally fit the idea of extensibility and supporting different target environments.\n. ",
    "eventualbuddha": "Just in case it's helpful to you or anyone else who runs into this, here's what I'm using to fix the ranges. It's probably pretty inefficient but so far it's been sufficient for my needs:\n`` js\n// Visit every node to fix its range, assumes each node has a\n//_parentproperty that refers to its parent node. This is intended\n// to operate on the result oftoBasicObject()` on the parsed AST.\ntraverse(ast, function(node) {\n  if (!node.range) { return; }\nif (node._parent) {\n    node.range[0] += node._parent._offset;\n    node.range[1] += node._parent._offset;\n  }\nif (node.raw !== source.slice(node.range[0], node.range[1])) {\n    node._offset = fixRange(node, source);\n  } else {\n    node._offset = 0;\n  }\n});\nfunction fixRange(node, source) {\n  var index = -1;\n  var expectedStart = node.range[0];\n  var minimumOffsetIndex = -1;\n  var minimumOffset = Infinity;\nwhile ((index = source.indexOf(node.raw, index + 1)) >= 0) {\n    if (minimumOffsetIndex < 0) {\n      minimumOffsetIndex = index;\n      minimumOffset = Math.abs(expectedStart - minimumOffsetIndex);\n    } else {\n      var thisOffset = Math.abs(expectedStart - index);\n      if (thisOffset < minimumOffset) {\n        minimumOffset = thisOffset;\n        minimumOffsetIndex = index;\n      }\n    }\n  }\nif (minimumOffsetIndex < 0) {\n    throw new Error('unable to find location for node: ' + JSON.stringify(node.raw));\n  }\nnode.range[0] = minimumOffsetIndex;\n  node.range[1] = minimumOffsetIndex + node.raw.length;\nreturn minimumOffsetIndex - expectedStart;\n}\n``\n. Actually, it looks like it's even worse. Some nodes that ought to haverangeandrawdo not have either, such as when parsing\"a#{b}\"`:\n``` js\n\nparse('\"a#{b}\"', { raw: true }).toBasicObject().body.statements[0]\n{ type: 'ConcatOp',\n  line: 1,\n  column: 1,\n  raw: '\"a#{b}\"',\n  range: [ 0, 7 ],\n  left:\n   { type: 'String',\n     line: 1,\n     column: 2,\n     data: 'a' },\n  right:\n   { type: 'Identifier',\n     line: 1,\n     column: 5,\n     raw: 'b',\n     range: [ 4, 5 ],\n     data: 'b' } }\n```\n. Okay, I think I've figured out why this is happening. I'm pretty sure it's due to the \"context-free-CoffeeScript control characters\" you mentioned. When an input string is pre-processed a number of characters are added, so this:\n\njs\n->\n  a.b\nBecomes this:\njs\n->\n  \uefefa.b\ueffe\uefff\nThose extra characters are what is causing the range property to be incorrect, as it's reporting the range inside the preprocessed input, not the original input. I can think of a few ways to work around this, but I'm not sure how to fix it. Thoughts, @michaelficarra?\n. I don't believe the problem is exactly the same. That commit does in fact fix line and column numbers, but doesn't fix offsets. I have a workaround from a commit that links to this issue that basically recomputes the range info based on the line and column numbers.\nAm I missing something?\n. Or you can just jump on the ES6 bandwagon, and help me build a tool to convert CoffeeScript to ES6 :wink: I'm using CoffeeScriptRedux to make the necessary modifications to the source code.\n. Never going to happen :wink:\n. I think if you want to add support for import and export statements you should either for CSR and add support to the parser, or continue using a hack to fix it.\nThe \"right\" solution, in my opinion, is to move to ES6 using decaffeinate to translate from CoffeeScript to ES6, and babel to transpile from ES6 to ES5.\n(I am a contributor to babel and the maintainer of decaffeinate, fwiw.)\n. @alexspeller I think your coffees6 project does just that. Since CoffeeScript itself does not have, and will likely never have, support for ES6-style modules it necessarily means using a fork or a hack to make it work. I guess I'm not seeing what's wrong with the status quo for those who choose to use CoffeeScript.\n. Huh, looks like I was a little hasty. I can't tell if this means \"not until ES6 is final\" or \"not until major browsers implement it natively\":\n\nit's probably still better to wait until real JS modules are finished and fully described\n\nIf the former, that's pretty soon so maybe CoffeeScript would support ES6 modules sometime this year. If the latter, I'd put it next year at the earliest.\n. Wow, I wish I'd seen this sooner. I've been working on decaffeinate which has a pretty similar goal. Did I understand you correctly, @ef4, that you're trying to move a codebase from CoffeeScript to ES6? If so, we might want to see if there's any work we can do together as that's my goal.\nThe main reason I didn't go with the approach in this PR is that I'd lose comments and formatting.\n. Just in case it's helpful to you or anyone else who runs into this, here's what I'm using to fix the ranges. It's probably pretty inefficient but so far it's been sufficient for my needs:\n`` js\n// Visit every node to fix its range, assumes each node has a\n//_parentproperty that refers to its parent node. This is intended\n// to operate on the result oftoBasicObject()` on the parsed AST.\ntraverse(ast, function(node) {\n  if (!node.range) { return; }\nif (node._parent) {\n    node.range[0] += node._parent._offset;\n    node.range[1] += node._parent._offset;\n  }\nif (node.raw !== source.slice(node.range[0], node.range[1])) {\n    node._offset = fixRange(node, source);\n  } else {\n    node._offset = 0;\n  }\n});\nfunction fixRange(node, source) {\n  var index = -1;\n  var expectedStart = node.range[0];\n  var minimumOffsetIndex = -1;\n  var minimumOffset = Infinity;\nwhile ((index = source.indexOf(node.raw, index + 1)) >= 0) {\n    if (minimumOffsetIndex < 0) {\n      minimumOffsetIndex = index;\n      minimumOffset = Math.abs(expectedStart - minimumOffsetIndex);\n    } else {\n      var thisOffset = Math.abs(expectedStart - index);\n      if (thisOffset < minimumOffset) {\n        minimumOffset = thisOffset;\n        minimumOffsetIndex = index;\n      }\n    }\n  }\nif (minimumOffsetIndex < 0) {\n    throw new Error('unable to find location for node: ' + JSON.stringify(node.raw));\n  }\nnode.range[0] = minimumOffsetIndex;\n  node.range[1] = minimumOffsetIndex + node.raw.length;\nreturn minimumOffsetIndex - expectedStart;\n}\n``\n. Actually, it looks like it's even worse. Some nodes that ought to haverangeandrawdo not have either, such as when parsing\"a#{b}\"`:\n``` js\n\nparse('\"a#{b}\"', { raw: true }).toBasicObject().body.statements[0]\n{ type: 'ConcatOp',\n  line: 1,\n  column: 1,\n  raw: '\"a#{b}\"',\n  range: [ 0, 7 ],\n  left:\n   { type: 'String',\n     line: 1,\n     column: 2,\n     data: 'a' },\n  right:\n   { type: 'Identifier',\n     line: 1,\n     column: 5,\n     raw: 'b',\n     range: [ 4, 5 ],\n     data: 'b' } }\n```\n. Okay, I think I've figured out why this is happening. I'm pretty sure it's due to the \"context-free-CoffeeScript control characters\" you mentioned. When an input string is pre-processed a number of characters are added, so this:\n\njs\n->\n  a.b\nBecomes this:\njs\n->\n  \uefefa.b\ueffe\uefff\nThose extra characters are what is causing the range property to be incorrect, as it's reporting the range inside the preprocessed input, not the original input. I can think of a few ways to work around this, but I'm not sure how to fix it. Thoughts, @michaelficarra?\n. I don't believe the problem is exactly the same. That commit does in fact fix line and column numbers, but doesn't fix offsets. I have a workaround from a commit that links to this issue that basically recomputes the range info based on the line and column numbers.\nAm I missing something?\n. Or you can just jump on the ES6 bandwagon, and help me build a tool to convert CoffeeScript to ES6 :wink: I'm using CoffeeScriptRedux to make the necessary modifications to the source code.\n. Never going to happen :wink:\n. I think if you want to add support for import and export statements you should either for CSR and add support to the parser, or continue using a hack to fix it.\nThe \"right\" solution, in my opinion, is to move to ES6 using decaffeinate to translate from CoffeeScript to ES6, and babel to transpile from ES6 to ES5.\n(I am a contributor to babel and the maintainer of decaffeinate, fwiw.)\n. @alexspeller I think your coffees6 project does just that. Since CoffeeScript itself does not have, and will likely never have, support for ES6-style modules it necessarily means using a fork or a hack to make it work. I guess I'm not seeing what's wrong with the status quo for those who choose to use CoffeeScript.\n. Huh, looks like I was a little hasty. I can't tell if this means \"not until ES6 is final\" or \"not until major browsers implement it natively\":\n\nit's probably still better to wait until real JS modules are finished and fully described\n\nIf the former, that's pretty soon so maybe CoffeeScript would support ES6 modules sometime this year. If the latter, I'd put it next year at the earliest.\n. Wow, I wish I'd seen this sooner. I've been working on decaffeinate which has a pretty similar goal. Did I understand you correctly, @ef4, that you're trying to move a codebase from CoffeeScript to ES6? If so, we might want to see if there's any work we can do together as that's my goal.\nThe main reason I didn't go with the approach in this PR is that I'd lose comments and formatting.\n. ",
    "dynamix": "@lydell @michaelficarra - thanks for the clarification. (OT : did you just switch back to plain JS (>=ES6)?) \n. @lydell @michaelficarra - thanks for the clarification. (OT : did you just switch back to plain JS (>=ES6)?) \n. ",
    "erichonkanen": "has anyone continued to work on this? the web is full of people proclaiming es6 > coffeescript but imo it's quite the opposite.. I hope development and support continues despite the hipster es6 fad\n. coffeescript for life! not drinking the babel/es6/7 coolaid yet!\n. has anyone continued to work on this? the web is full of people proclaiming es6 > coffeescript but imo it's quite the opposite.. I hope development and support continues despite the hipster es6 fad\n. coffeescript for life! not drinking the babel/es6/7 coolaid yet!\n. ",
    "igl": "After also doing the switch from coffee to babel in our company, i am not too excited about ES6 anymore. Precompilers still have a future. The features they have to tackle are going to be harder but with TC39 focused on imperative features, transforming javascript yet again more into java, there is plenty of stuff that needs fixing by the community.\nAnnoying: function (foo, ...rest, callback) === Error rest argument must be the last one. (callback = rest.pop()ugh! :cry:)\nSilly: const foo = 1; foo = 2; === No Error. Assignment expr. returns 2.\nHalf assed: @annotation are only planned for class and their proto functions. No functions, no vars no imports, more java.\nConsistency: import { a as b } from 'foo',const { a : b } = foo\nMore Wat: ((a, ...b) => a).length === 1\nSad: Instead of channels or proper tasks we get: Promises. Shoot me now!\n~~Arrow Functions~~Obfuscators: ({a}) => ({a})\nAnd boy did i NOT miss these tails:\n})\n    ], callback)\n}\nHaving said that: Always bet on JS creating the need for precompilers.\n. After also doing the switch from coffee to babel in our company, i am not too excited about ES6 anymore. Precompilers still have a future. The features they have to tackle are going to be harder but with TC39 focused on imperative features, transforming javascript yet again more into java, there is plenty of stuff that needs fixing by the community.\nAnnoying: function (foo, ...rest, callback) === Error rest argument must be the last one. (callback = rest.pop()ugh! :cry:)\nSilly: const foo = 1; foo = 2; === No Error. Assignment expr. returns 2.\nHalf assed: @annotation are only planned for class and their proto functions. No functions, no vars no imports, more java.\nConsistency: import { a as b } from 'foo',const { a : b } = foo\nMore Wat: ((a, ...b) => a).length === 1\nSad: Instead of channels or proper tasks we get: Promises. Shoot me now!\n~~Arrow Functions~~Obfuscators: ({a}) => ({a})\nAnd boy did i NOT miss these tails:\n})\n    ], callback)\n}\nHaving said that: Always bet on JS creating the need for precompilers.\n. ",
    "nmccready": "\nHaving said that: Always bet on JS creating the need for precompilers.\n\n@igl amen\n. > Having said that: Always bet on JS creating the need for precompilers.\n@igl amen\n. ",
    "JimPanic": "bump\nHas anyone got plans/ideas/anything regarding this dilemma? I'm currently looking into starting with ES6, but I'd rather have a coffee6 for the reasons everyone else here stated as well. :)\n. I didn't have time yet to dive in deep into the codebase, but I also have no idea where to start.\nIs there any guideline as to where to start in the light of making the current CS syntax output (node-supported) ES6 code? What parts would I have to look at/change?\nI'd really like to keep CS in my toolbox, vanilla JS is so tedious to write. :-1: \n. @danielbayley I'd much rather continue to use coffee (redux?) instead of just converting my code. So I was basically asking how to contribute.\nI'd also like to see new features in coffee at some point. But I really am a bit lost in getting to know the codebase.\n. I haven't even looked at classes in ES6 so far tbh, I'm usually not using them. But keeping semantics in CS is probably a good idea and it might be a step in the future to remove this in favour of something else maybe.\nI'll try to decipher the codebase of coffeescriptredux and see where to go from there.\n@danielbayley are those projects able to run code like coffee does now (cli interface, load coffee modules on the fly)? From the README it seems they're mostly used as transit projects to migrate coffeescript codebases to ES6. (Which is not my goal!)\n. @danielbayley as far as I can see decaf is a superset of coffee. It uses a different library to generate JS code apparently. And with this, it generates ES.next (ES2017 right now, I guess?) code. I'd like to target ES6 - or ultimately and ideally be able to drop in different generators.\nLets see. :)\n. Thank you for putting this up, @rattrayalex !\n. bump\nHas anyone got plans/ideas/anything regarding this dilemma? I'm currently looking into starting with ES6, but I'd rather have a coffee6 for the reasons everyone else here stated as well. :)\n. I didn't have time yet to dive in deep into the codebase, but I also have no idea where to start.\nIs there any guideline as to where to start in the light of making the current CS syntax output (node-supported) ES6 code? What parts would I have to look at/change?\nI'd really like to keep CS in my toolbox, vanilla JS is so tedious to write. :-1: \n. @danielbayley I'd much rather continue to use coffee (redux?) instead of just converting my code. So I was basically asking how to contribute.\nI'd also like to see new features in coffee at some point. But I really am a bit lost in getting to know the codebase.\n. I haven't even looked at classes in ES6 so far tbh, I'm usually not using them. But keeping semantics in CS is probably a good idea and it might be a step in the future to remove this in favour of something else maybe.\nI'll try to decipher the codebase of coffeescriptredux and see where to go from there.\n@danielbayley are those projects able to run code like coffee does now (cli interface, load coffee modules on the fly)? From the README it seems they're mostly used as transit projects to migrate coffeescript codebases to ES6. (Which is not my goal!)\n. @danielbayley as far as I can see decaf is a superset of coffee. It uses a different library to generate JS code apparently. And with this, it generates ES.next (ES2017 right now, I guess?) code. I'd like to target ES6 - or ultimately and ideally be able to drop in different generators.\nLets see. :)\n. Thank you for putting this up, @rattrayalex !\n. ",
    "danielbayley": "@JimPanic \nThere are already a couple of projects on that:\nhttps://github.com/rainforestapp/decaf\nhttps://github.com/decaffeinate/decaffeinate\n. > I'd much rather continue to use coffee\nSame! I hate vanilla JS. But those are 2 projects (there might be more) already converting CS to ES6 so why duplicate effort? I believe the decaf repo is being moved into a new @CoffeeScript organisation, and talk of putting it behind a command line flag or something, but nothing has happened yet. There's plenty of discussion on this [CS > ES6] over on the original CS repo.\nI really wish everyone in the CS camp would just come together and kill this meme that CS is dead and we all have to be coerced into writing ES6.\n. @JimPanic I'm not sure to be honest, I would at least speak to @juliankrispel about decaf though.\n. @michaelficarra From the coffee help;\n-r, --require [MODULE*] require the given module before eval or REPL\n. > This project's CLI is not compatible with that one's.\nI get that, but is this project not aiming for feature parity?\n. @JimPanic \nThere are already a couple of projects on that:\nhttps://github.com/rainforestapp/decaf\nhttps://github.com/decaffeinate/decaffeinate\n. > I'd much rather continue to use coffee\nSame! I hate vanilla JS. But those are 2 projects (there might be more) already converting CS to ES6 so why duplicate effort? I believe the decaf repo is being moved into a new @CoffeeScript organisation, and talk of putting it behind a command line flag or something, but nothing has happened yet. There's plenty of discussion on this [CS > ES6] over on the original CS repo.\nI really wish everyone in the CS camp would just come together and kill this meme that CS is dead and we all have to be coerced into writing ES6.\n. @JimPanic I'm not sure to be honest, I would at least speak to @juliankrispel about decaf though.\n. @michaelficarra From the coffee help;\n-r, --require [MODULE*] require the given module before eval or REPL\n. > This project's CLI is not compatible with that one's.\nI get that, but is this project not aiming for feature parity?\n. ",
    "remoteportal": "Hey folks,\n(My favorite language is CS\u2014I\u2019ve been using it for my \u201cday job\u201d for two years and have chosen CoffeeScript Redux for a project I\u2019m moonlighting with at home.)\nIn addition to that I\u2019m envisioning an entirely new domain-specific language based on CS Redux for my home project.  \nIt\u2019s NOT writing CoffeeScript Redux, per se, but compiler work; I\u2019m looking for someone who is good at PEG.js to fork the Redux project and customize to my needs.\nDoes anyone reading this have a desire to work remotely on a project for (guessing?) perhaps 40 hours?  I\u2019m just one guy (not a company) but can obviously compensate per hour for your work.\nANY help would be appreciated; even a few hours of your paid coding could get me on the right path if you\u2019re not interested in working the entire small project. \nI figure you folks can crank this out MUCH quicker than I can.\nPete Alvin\nit@onlyup.com mailto:it@onlyup.com\n@remoteportal\nhttps://github.com/remoteportal https://github.com/remoteportal\nmobile 704.804.4786\n. (I hope CoffeeScript doesn\u2019t die\u2014it\u2019s by far my favorite language right now.)\nPeter Alvin\n\nOn Apr 19, 2016, at 04:15, Nikita Litvin notifications@github.com wrote:\nSee #336 https://github.com/michaelficarra/CoffeeScriptRedux/issues/336.\nAnyone is free to work on this project. I stopped working on it after a disagreement between myself and the other CoffeeScript maintainers [...]. I don't see a future for the CoffeeScript language without adoption of ES6 features. Unfortunately, I was the only one that believed we should adopt the semantics of any equivalent features in ES6 [...]. So because I no longer use the language for my own projects, I am not motivated to work on it. But there's nothing stopping anyone from opening issues and sending PRs.\nTL;DR: It's dead.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub https://github.com/michaelficarra/CoffeeScriptRedux/issues/361#issuecomment-211787145\n. Hey folks,\n\n(My favorite language is CS\u2014I\u2019ve been using it for my \u201cday job\u201d for two years and have chosen CoffeeScript Redux for a project I\u2019m moonlighting with at home.)\nIn addition to that I\u2019m envisioning an entirely new domain-specific language based on CS Redux for my home project.  \nIt\u2019s NOT writing CoffeeScript Redux, per se, but compiler work; I\u2019m looking for someone who is good at PEG.js to fork the Redux project and customize to my needs.\nDoes anyone reading this have a desire to work remotely on a project for (guessing?) perhaps 40 hours?  I\u2019m just one guy (not a company) but can obviously compensate per hour for your work.\nANY help would be appreciated; even a few hours of your paid coding could get me on the right path if you\u2019re not interested in working the entire small project. \nI figure you folks can crank this out MUCH quicker than I can.\nPete Alvin\nit@onlyup.com mailto:it@onlyup.com\n@remoteportal\nhttps://github.com/remoteportal https://github.com/remoteportal\nmobile 704.804.4786\n. (I hope CoffeeScript doesn\u2019t die\u2014it\u2019s by far my favorite language right now.)\nPeter Alvin\n\nOn Apr 19, 2016, at 04:15, Nikita Litvin notifications@github.com wrote:\nSee #336 https://github.com/michaelficarra/CoffeeScriptRedux/issues/336.\nAnyone is free to work on this project. I stopped working on it after a disagreement between myself and the other CoffeeScript maintainers [...]. I don't see a future for the CoffeeScript language without adoption of ES6 features. Unfortunately, I was the only one that believed we should adopt the semantics of any equivalent features in ES6 [...]. So because I no longer use the language for my own projects, I am not motivated to work on it. But there's nothing stopping anyone from opening issues and sending PRs.\nTL;DR: It's dead.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub https://github.com/michaelficarra/CoffeeScriptRedux/issues/361#issuecomment-211787145\n. \n",
    "rattrayalex": "Like @remoteportal I am interested in building a new language, and this repo seems like the best starting point. \nUnlike @remoteportal I don't think I could pay for the help \ud83d\ude04 \nPersonally I'm interested in a statically-typed, whitespace-sensitive, light-syntax language \u2013\u00a0think \"coffeescript for typescript/flow\". \n@michaelficarra do you have any interest in creating a coffeescript-like derivative? From the ES6-related issues on the main coffee repo, it seems much of the community was on your side. I'm sure I'm not the only one who likes ES6 features and CS syntax; anything you were to produce would probably attract a following. \nEDIT: I ask not to lure you into working on mine, but because I'd be much more interested in using one you were to come up with than one I would \ud83d\ude04 \n. You know what, @DomVinyard ? That's a good point \ud83d\ude09 \nI've gone ahead and created https://github.com/coffeescript6/discuss to do just that. \nCoffeeScript really is a fantastic language and while it could use some upgrades, I think you're right that we don't necessarily need to start from scratch here. \nLet's start getting some ideas on paper! \n. I'll throw my hat in the ring of people excited about a new whitespace-based lang. \nPersonally, I think it should target es7 out of the box (it won't be done till that's out anyway) and support optional static typing, \u00e0 la TypeScript. But I'm not sure how many people would be interested in such a thing. \n. @eldh curlyfy actually looks awesome, almost exactly what I had in mind (would be great to see optional commas, etc). \n@michaelficarra PureScript definitely looks awesome! However, I'm looking for something closer to the spirit of \"unfancy javascript\" - I want to be writing Type/JavaScript without the cruft, not writing another language in the browser. \n. @ef4 what's the status of this project?\nEDIT: And are you looking for help to get it over the finish line?\n. Awesome, thanks @ef4 !\nDo you think you'd be willing to provide advice from time to time if someone were to pick it up?\n. Like @remoteportal I am interested in building a new language, and this repo seems like the best starting point. \nUnlike @remoteportal I don't think I could pay for the help \ud83d\ude04 \nPersonally I'm interested in a statically-typed, whitespace-sensitive, light-syntax language \u2013\u00a0think \"coffeescript for typescript/flow\". \n@michaelficarra do you have any interest in creating a coffeescript-like derivative? From the ES6-related issues on the main coffee repo, it seems much of the community was on your side. I'm sure I'm not the only one who likes ES6 features and CS syntax; anything you were to produce would probably attract a following. \nEDIT: I ask not to lure you into working on mine, but because I'd be much more interested in using one you were to come up with than one I would \ud83d\ude04 \n. You know what, @DomVinyard ? That's a good point \ud83d\ude09 \nI've gone ahead and created https://github.com/coffeescript6/discuss to do just that. \nCoffeeScript really is a fantastic language and while it could use some upgrades, I think you're right that we don't necessarily need to start from scratch here. \nLet's start getting some ideas on paper! \n. I'll throw my hat in the ring of people excited about a new whitespace-based lang. \nPersonally, I think it should target es7 out of the box (it won't be done till that's out anyway) and support optional static typing, \u00e0 la TypeScript. But I'm not sure how many people would be interested in such a thing. \n. @eldh curlyfy actually looks awesome, almost exactly what I had in mind (would be great to see optional commas, etc). \n@michaelficarra PureScript definitely looks awesome! However, I'm looking for something closer to the spirit of \"unfancy javascript\" - I want to be writing Type/JavaScript without the cruft, not writing another language in the browser. \n. @ef4 what's the status of this project?\nEDIT: And are you looking for help to get it over the finish line?\n. Awesome, thanks @ef4 !\nDo you think you'd be willing to provide advice from time to time if someone were to pick it up?\n. ",
    "DomVinyard": "I think it would be helpful if this conversation came back around to reinvigorating coffeescript rather than inventing new technologies.\n. I think it would be helpful if this conversation came back around to reinvigorating coffeescript rather than inventing new technologies.\n. ",
    "juliankrispel": "I'm still working on an integration between coffeescript and decaf btw. Just have been super busy lately, ETA: 2 months\n. I'm still working on an integration between coffeescript and decaf btw. Just have been super busy lately, ETA: 2 months\n. ",
    "lolmaus": "The problem with ES6 support in CoffeeScript is that ES6 overlaps with CoffeeScript syntax. Some of core CS features conflict with ES6, namely backticks and fat arrows, others become redundant (splats, comprehensions, classes, etc). I think that the JS preprocessor of the future should not have its syntax elements mean things different from the modern JS.\nI can think of three directions:\n- CoffeeScriptRedux maintainers refuse to support ES6. CoffeeScriptRedux dies out together with CoffeeScript and some other ES6-capable preprocessor takes its place.\n- CoffeeScriptRedux extends CoffeeScript syntax to support ES6. Nothing is deprecated, but identical syntax elements mean different things than those of the contemporary JavaScript. This makes CoffeeScript an even more hated language.\n- CoffeeScriptRedux team decides to start a new preprocessor project, giving precedence to ES6 syntax features. The new preprocessor is as easy to learn for a ES6 user an CoffeeScript was for a ES5 user. Can't be used to compile CoffeeScript, but who needs ES6 support in old projects anyway.\nWhat do you say?\n. That's why we need a new language, taking up the place of CoffeeScript, offering indentation-based semantics and at the same time reusing modern ES syntax constructs. It could produce modern ES code and rely on Babel for compatibility with runtimes.\n. @alexspeller, exactly!\nRewriting CoffeeScript from scratch is a barely feasible task, but we could start with small steps. E. g. collaboratively write an RFC for the new language, agree on nuances, attract more people.\nOMG, i'm so happy this conversation has finally started! I almost lost hope.\nAs for syntactic sugar vs language innovation, there's no distinct line between them. Also, some extremely useful CoffeeScript innovations are still missing in ESNext. For example, ? (the existential operator), i just can't live without it.\n. @lydell, I've also had the idea of making such a proposal for quite a while now. I like your effort, but I strongly dislike certain implementation details.\nI wrote you on Gitter, please respond if you would like to discus the matter.\n. The problem with ES6 support in CoffeeScript is that ES6 overlaps with CoffeeScript syntax. Some of core CS features conflict with ES6, namely backticks and fat arrows, others become redundant (splats, comprehensions, classes, etc). I think that the JS preprocessor of the future should not have its syntax elements mean things different from the modern JS.\nI can think of three directions:\n- CoffeeScriptRedux maintainers refuse to support ES6. CoffeeScriptRedux dies out together with CoffeeScript and some other ES6-capable preprocessor takes its place.\n- CoffeeScriptRedux extends CoffeeScript syntax to support ES6. Nothing is deprecated, but identical syntax elements mean different things than those of the contemporary JavaScript. This makes CoffeeScript an even more hated language.\n- CoffeeScriptRedux team decides to start a new preprocessor project, giving precedence to ES6 syntax features. The new preprocessor is as easy to learn for a ES6 user an CoffeeScript was for a ES5 user. Can't be used to compile CoffeeScript, but who needs ES6 support in old projects anyway.\nWhat do you say?\n. That's why we need a new language, taking up the place of CoffeeScript, offering indentation-based semantics and at the same time reusing modern ES syntax constructs. It could produce modern ES code and rely on Babel for compatibility with runtimes.\n. @alexspeller, exactly!\nRewriting CoffeeScript from scratch is a barely feasible task, but we could start with small steps. E. g. collaboratively write an RFC for the new language, agree on nuances, attract more people.\nOMG, i'm so happy this conversation has finally started! I almost lost hope.\nAs for syntactic sugar vs language innovation, there's no distinct line between them. Also, some extremely useful CoffeeScript innovations are still missing in ESNext. For example, ? (the existential operator), i just can't live without it.\n. @lydell, I've also had the idea of making such a proposal for quite a while now. I like your effort, but I strongly dislike certain implementation details.\nI wrote you on Gitter, please respond if you would like to discus the matter.\n. ",
    "sleepyfox": "I would consider that since active development stopped on this project almost 11 months ago (according to the commit log) that any major requests for change are going to fall on deaf ears.\n. I would consider that since active development stopped on this project almost 11 months ago (according to the commit log) that any major requests for change are going to fall on deaf ears.\n. ",
    "alexspeller": "\nThe \"right\" solution, in my opinion, is to move to ES6 using decaffeinate to translate from CoffeeScript to ES6, and babel to transpile from ES6 to ES5.\n\nES6 is certainly is an improvement, but still nowhere near as nice to code in as coffeescript. It would still make a lot of sense, for people who like coffeescript, to have a way to make use of ES6 modules in coffeescript\n. @eventualbuddha it seems like coffeescript is very likely to have ES6 modules eventually, just not immediately\nA fork has obvious issues of keeping up to date with the latest version. A hack has issues of being a hack (regex substitution has a lot of caveats compared to real parsing). But it probably is the best compromise for now.\n. @lolmaus that would be ideal, and if magically we could have that I'd be super happy. It seems like a big undertaking though - I wonder how much interest and momentum such a project could generate?\nMy main worry would be that CS has fallen out of fashion so it would be hard to find contributors, however if it targetted ESNext (i.e. babel) maybe more people would be interested.\n. So I created an org and repo to explore this - anyone who's interested feel free to comment here https://github.com/babelscript/rfcs/pull/1/files?short_path=4e5e753#diff-4e5e75370db49a9550d4bbe7f0f6f57e\n. > The \"right\" solution, in my opinion, is to move to ES6 using decaffeinate to translate from CoffeeScript to ES6, and babel to transpile from ES6 to ES5.\nES6 is certainly is an improvement, but still nowhere near as nice to code in as coffeescript. It would still make a lot of sense, for people who like coffeescript, to have a way to make use of ES6 modules in coffeescript\n. @eventualbuddha it seems like coffeescript is very likely to have ES6 modules eventually, just not immediately\nA fork has obvious issues of keeping up to date with the latest version. A hack has issues of being a hack (regex substitution has a lot of caveats compared to real parsing). But it probably is the best compromise for now.\n. @lolmaus that would be ideal, and if magically we could have that I'd be super happy. It seems like a big undertaking though - I wonder how much interest and momentum such a project could generate?\nMy main worry would be that CS has fallen out of fashion so it would be hard to find contributors, however if it targetted ESNext (i.e. babel) maybe more people would be interested.\n. So I created an org and repo to explore this - anyone who's interested feel free to comment here https://github.com/babelscript/rfcs/pull/1/files?short_path=4e5e753#diff-4e5e75370db49a9550d4bbe7f0f6f57e\n. ",
    "volkanunsal": "I spent several months switching a large CS codebase to ES6 because we can't see any glimmer of hope for supporting major features like type inference and up and coming ES6 features. My bet is many of those features will never get into CoffeeScript because it will mean major changes to the language itself.\n. I spent several months switching a large CS codebase to ES6 because we can't see any glimmer of hope for supporting major features like type inference and up and coming ES6 features. My bet is many of those features will never get into CoffeeScript because it will mean major changes to the language itself.\n. ",
    "eldh": "I like this!\n. One approach is this: https://github.com/rstuven/curlyfy-loader\nThis is a webpack loader that you run before babel, but it could surely be implemented as a babel plugin. This is, I think, the easy part. The tricky thing is getting all the surrounding tooling in place (linting, etc) and getting wide usage.\n. I like this!\n. One approach is this: https://github.com/rstuven/curlyfy-loader\nThis is a webpack loader that you run before babel, but it could surely be implemented as a babel plugin. This is, I think, the easy part. The tricky thing is getting all the surrounding tooling in place (linting, etc) and getting wide usage.\n. ",
    "balupton": "I've setup a repo here as well with a comparison between CoffeeScript and ES6:\nhttps://github.com/balupton/coffeescript-to-es6/blob/master/README.md\n. > From what I understand, both CoffeeScriptRedux and Babel generate code from a SpiderMonkey AST.\nBabel uses Acorn instead of Esprima which is why it's esnext support is way higher.\n. I've setup a repo here as well with a comparison between CoffeeScript and ES6:\nhttps://github.com/balupton/coffeescript-to-es6/blob/master/README.md\n. > From what I understand, both CoffeeScriptRedux and Babel generate code from a SpiderMonkey AST.\nBabel uses Acorn instead of Esprima which is why it's esnext support is way higher.\n. ",
    "keithjgrant": "@alexspeller - Nice! I hope this gets some traction. I love the significant whitespace and lack of keyword noise (prototype, return, this, function) in CS, and really want to see that carried over to something next-gen.\n. For those who haven't seen it, there's a newish white-space significant JS language called Earl Grey, with a significant amount of ES6 support: http://breuleux.github.io/earl-grey/\n. @alexspeller - Nice! I hope this gets some traction. I love the significant whitespace and lack of keyword noise (prototype, return, this, function) in CS, and really want to see that carried over to something next-gen.\n. For those who haven't seen it, there's a newish white-space significant JS language called Earl Grey, with a significant amount of ES6 support: http://breuleux.github.io/earl-grey/\n. ",
    "mbrowne": "From what I understand, both CoffeeScriptRedux and Babel generate code from a SpiderMonkey AST. Currently CoffeeScriptRedux is using escodegen to generate the final Javascript, but what if it used Babel for the final generation step instead? It looks like Babel is significantly ahead of escodegen in ES6/7 support, so using Babel would mean that CoffeeScriptRedux would only need to implement parsing support for ES6 features; the ES5-compatible Javascript generation part would be taken care of by Babel.\nI have a bit of an additional agenda here, which is that I want to add support for DCI [1] programming to Javascript and eventually CoffeeScript as well, and proper support for it involves the introduction of at least one new keyword ('role') as well as source code rewriting. First I'm planning to implement it in Babel...if CoffeeScript used Babel for Javascript generation as well, then in order to support CoffeeScript I'd only need to modify the parser, rather than both the parser and the generator. So I think this could be useful for those like myself who are interested in adding custom extensions to JS and CoffeeScript, but obviously the more important point is what I said in the preceding paragraph.\n[1] For more info on DCI (Data-Context-Interaction), see these links:\nhttp://fulloo.info/doku.php?id=what_is_dci\nhttp://folk.uio.no/trygver/2015/CommSense-1.14.1.pdf\nDesired Javascript code (currently implemented with a fork of TypeScript): https://github.com/mbrowne/typescript-dci/blob/master/samples/dci/js/TransferMoney-simplified/TransferMoney.ts\n. Yes, I saw that it uses acorn...I thought the esnext support was higher because they forked acorn (https://github.com/babel/acorn-babel - \"Acorn fork used by babel - not supported outside of babel usage\"), but I'm guessing acorn has better esnext support out of the box too.\n. Earl Grey looks quite good. And I noticed that it uses Babel, which seems to indicate that using Babel might be viable for CoffeeScript too (see my earlier suggestion).\n. From what I understand, both CoffeeScriptRedux and Babel generate code from a SpiderMonkey AST. Currently CoffeeScriptRedux is using escodegen to generate the final Javascript, but what if it used Babel for the final generation step instead? It looks like Babel is significantly ahead of escodegen in ES6/7 support, so using Babel would mean that CoffeeScriptRedux would only need to implement parsing support for ES6 features; the ES5-compatible Javascript generation part would be taken care of by Babel.\nI have a bit of an additional agenda here, which is that I want to add support for DCI [1] programming to Javascript and eventually CoffeeScript as well, and proper support for it involves the introduction of at least one new keyword ('role') as well as source code rewriting. First I'm planning to implement it in Babel...if CoffeeScript used Babel for Javascript generation as well, then in order to support CoffeeScript I'd only need to modify the parser, rather than both the parser and the generator. So I think this could be useful for those like myself who are interested in adding custom extensions to JS and CoffeeScript, but obviously the more important point is what I said in the preceding paragraph.\n[1] For more info on DCI (Data-Context-Interaction), see these links:\nhttp://fulloo.info/doku.php?id=what_is_dci\nhttp://folk.uio.no/trygver/2015/CommSense-1.14.1.pdf\nDesired Javascript code (currently implemented with a fork of TypeScript): https://github.com/mbrowne/typescript-dci/blob/master/samples/dci/js/TransferMoney-simplified/TransferMoney.ts\n. Yes, I saw that it uses acorn...I thought the esnext support was higher because they forked acorn (https://github.com/babel/acorn-babel - \"Acorn fork used by babel - not supported outside of babel usage\"), but I'm guessing acorn has better esnext support out of the box too.\n. Earl Grey looks quite good. And I noticed that it uses Babel, which seems to indicate that using Babel might be viable for CoffeeScript too (see my earlier suggestion).\n. ",
    "catamphetamine": "So, is it not gonna happen?\nMaybe another kickstarter campaign?\nI'm starting a hobby project and I'm thinking about what language to code it in.\nIf CSR won't support ES6-7 in future then I'll drop it in favour of the latter.\nOk, I see that I'll likely have to resort to ES6\n. @keithjgrant Thanks, looks cool. Not a fan of python myself but have a friend who will surely like it.\n@keithjgrant omg, AWAITs, finally someone got it! no more bulky promise chains? that would be something.\n. So, is it not gonna happen?\nMaybe another kickstarter campaign?\nI'm starting a hobby project and I'm thinking about what language to code it in.\nIf CSR won't support ES6-7 in future then I'll drop it in favour of the latter.\nOk, I see that I'll likely have to resort to ES6\n. @keithjgrant Thanks, looks cool. Not a fan of python myself but have a friend who will surely like it.\n@keithjgrant omg, AWAITs, finally someone got it! no more bulky promise chains? that would be something.\n. ",
    "Penagwin": "I love Coffeescript's syntax over Earl Grey's syntax. I also think that Coffeescript is supposed to compile to javascript, and ES6 is the most recent version of javascript. By not compiling into the closest things(Coffeescript classes become ES6 classes) I think that Coffeescript is falling behind. \nNow that many libraries like Angular 2.0 are using ES6 modules, and classes, I believe that coffeescript  should be updated too.\n(Note: When I say coffeescript I mean this project.)\n. I love Coffeescript's syntax over Earl Grey's syntax. I also think that Coffeescript is supposed to compile to javascript, and ES6 is the most recent version of javascript. By not compiling into the closest things(Coffeescript classes become ES6 classes) I think that Coffeescript is falling behind. \nNow that many libraries like Angular 2.0 are using ES6 modules, and classes, I believe that coffeescript  should be updated too.\n(Note: When I say coffeescript I mean this project.)\n. ",
    "auvipy": "how do you think of using babel?\n. since http://coffeescript.org/v2/ is targeting es6 can we contribute some works from here to there? or already contributed?. great works. but\nThis branch has conflicts that must be resolved\n. @michaelficarra why not transfer this project to @coffeescript6 ? or add more volunterers to this project? \n. interested volunteers :) \n. how do you think of using babel?\n. since http://coffeescript.org/v2/ is targeting es6 can we contribute some works from here to there? or already contributed?. great works. but\nThis branch has conflicts that must be resolved\n. @michaelficarra why not transfer this project to @coffeescript6 ? or add more volunterers to this project? \n. interested volunteers :) \n. ",
    "srb-": "Fantastic! I'm especially interested in the default parameters. \n. Very cool! Question: do you actually use this compiler in production? I was under the impression it's in a semi-abandoned state so I've been afraid to use it for real projects.\n. Fantastic! I'm especially interested in the default parameters. \n. Very cool! Question: do you actually use this compiler in production? I was under the impression it's in a semi-abandoned state so I've been afraid to use it for real projects.\n. ",
    "flosse": "\nYou might add a small note to the Readme, so people don't have to\nsearch the docs to find out.\n\n+1\n. > You might add a small note to the Readme, so people don't have to\n\nsearch the docs to find out.\n\n+1\n. ",
    "madis": "Thank you for the answer. I wish there was a way to incorporate the many improvements you've made in this project to the original coffeescript codebase. \n. Thank you for the answer. I wish there was a way to incorporate the many improvements you've made in this project to the original coffeescript codebase. \n. ",
    "pyros2097": "+1 Keeping the dream alive\n. +1 Keeping the dream alive\n. ",
    "mathiasbynens": "May I suggest updating this URL to use HTTPS?\n\n. May I suggest updating this URL to use HTTPS?\n\n. ",
    "falafflepotatoe": "@vendelthiel thanks that helps a lot.\n. @vendelthiel thanks that helps a lot.\n. ",
    "jameswilddev": "Wait, I'm sorry, I got confused and posted this here rather than in the main CoffeeScript repository.\n. Wait, I'm sorry, I got confused and posted this here rather than in the main CoffeeScript repository.\n. ",
    "deltaidea": "See #336.\n\nAnyone is free to work on this project. I stopped working on it after a disagreement between myself and the other CoffeeScript maintainers [...]. I don't see a future for the CoffeeScript language without adoption of ES6 features. Unfortunately, I was the only one that believed we should adopt the semantics of any equivalent features in ES6 [...]. So because I no longer use the language for my own projects, I am not motivated to work on it. But there's nothing stopping anyone from opening issues and sending PRs.\n\nTL;DR: It's dead.\n. See #336.\n\nAnyone is free to work on this project. I stopped working on it after a disagreement between myself and the other CoffeeScript maintainers [...]. I don't see a future for the CoffeeScript language without adoption of ES6 features. Unfortunately, I was the only one that believed we should adopt the semantics of any equivalent features in ES6 [...]. So because I no longer use the language for my own projects, I am not motivated to work on it. But there's nothing stopping anyone from opening issues and sending PRs.\n\nTL;DR: It's dead.\n. ",
    "basicer": "@michaelficarra Updated \ud83d\ude04 . @michaelficarra Updated \ud83d\ude04 . "
}