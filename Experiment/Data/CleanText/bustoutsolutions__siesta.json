{
    "pcantrell": "Nice: filed same day Apple releases Xcode 7 beta 4 with a fix.\nBut bug still persists in extension names:\n@interface Resource (SWIFT_EXTENSION(Siesta))\n@end\n\u2026should be:\n@interface Resource (SWIFT_EXTENSION(Siesta))\n@end\n\u2026so workaround must remain for now.\n. Confirmed. Removing all references to Alamofire.framework from the example project\u2019s xcodeproj should work just fine, since Alamofire is an optional dependency and the example project uses the default Siesta\u2019s NSURLSession network. The project does indeed build and launch in this form, but crashes in strange ways that suggest memory clobbering.\nThis outstrips my understanding of frameworks. I\u2019ll probably just move Networking-Alamofire.swift to another target (but will that confuse poor Carthage?) or another project, but would love it if anyone with a better understanding of frameworks can figure this out.\n. As of Siesta 1.0b8 + Xcode 7.3.1, the simple subclass workaround above no longer works.\nIt is possible to create a project-local subclass in Objective-C that works. However, Siesta should just drop the BOS prefix for the Obj-C version of ResourceStatusOverlay, which will prevent Siesta from exposing this Apple bug in the first place. Targeting 1.0b9 for this.\n. Thanks. Good catches!\n(Ignore Travis. It\u2019s just broken.)\n. There\u2019s no built-in extension for any particular reactive framework, though certainly Siesta\u2019s architecture would fit quite naturally into a reactive project. Siesta\u2019s built-in observer logic is sort of \u201creactive lite,\u201d and gives some of the code-simplifying benefits of reactive programming without having to go fully Rx.\nI\u2019d love to add extensions for ReactiveCocoa and RxSwift to Siesta, either as examples in the docs or as optional plugins. Send a PR or a gist!\n. I\u2019m not actively working on it \u2014 my priority is stabilizing the API so we can cut a 1.0 release \u2014 but this is \u201chelp wanted\u201d\u00a0issue so I\u2019d welcome a PR!\nIf anybody gets a plugin working and wants to submit it:\n- Put the plugin code in Extensions/ReactiveCocoa.\n- Add your code to the iOS & macOS  test targets in Xcode (but not the core project targets).\n- Add ReactiveCocoa to Cartfile.private, then run carthage update --platform ios,osx to download & build it.\n- Write some specs.\n- Add a new subspec to Siesta.podspec. (You can use the Alamofire one as an example.)\n. Here are some quick initial thoughts, which are probably have wrong so take them with a grain of salt:\n- Resources and requests should both be signal producers. They handle two different cases: one for when you want the latest data wherever it came from, and the other for observing a specific request.\n- Resource signals use addObserver. Request signals use onCompletion.\n- Resources only get released if nobody is using them. (Siesta never evicts resources from its cache; it changes its resource reference to weak reference, but keeps using the same instance until it\u2019s deallocated.) An active signal should thus retain a resource as long as it has subscribers \u2026 however that works in ReactiveCocoa.\n. Thanks for this, @VDKA! Is it similarly easy to make an extension for Resource? I feel like that's where the real reactive payoff would be \u2014\u00a0but I don\u2019t know enough about the lifecycle of an Observable to know whether it would cause a Resource to be retained longer than it ought to be.\n. @akaralar: I\u2019d happily welcome a PR for this, and would be very happy to guide you through any Siesta-related points of uncertainty! Once you have some code worth sharing, even if it\u2019s incomplete, put your work on a reactivecocoa branch in your own fork of the project and go ahead and open a pull request off that branch.\nThe solution to the error problem is clear. (Or at least I think it\u2019s clear, which means I probably don\u2019t understand it. Beware the obvious!)\nA resource-centric signal would take a snapshot of the several Resource properties that change over time, and publish that snapshot as a single unit. Here\u2019s a sketch:\n```\npublic struct ResourceState  // Crucial that it is a struct!\n    {\n    public var data: Entity?\n    public var error: Error?\n    public var isLoading, isRequesting: Bool\n    }\npublic extension Resource\n    {\n    var state: ResourceState\n        {\n        return ResourceState(\n            data: latestData,\n            error: latestError,\n            isLoading: isLoading,\n            isRequesting: isRequesting)\n        }\n    }\n```\nA signal attached to a resource would expose only that ResourceState struct \u2014 not the resource itself. (The struct is immutable & threadsafe, or at least as threadsafe as the entity\u2019s content. A Resource is neither immutable nor threadsafe.)\nThis essentially says that \u201cResource with error\u201d is a valid state, and a resource might transition in and out of that state.\nIt\u2019s probably smart to attach the content convenience accessors to that, so that you have typedContent():\nextension ResourceState: TypedContentAccessors\n    {\n    public var entityForTypedContentAccessors: Entity?\n        { return data }\n    }\nOr better yet \u2014 and here I\u2019m going out on a limb \u2014\u00a0the standalone ResourceState struct avoids the limitations of Swift that prevented Siesta from having a fully generic Resource<T>, so you could probably make this work:\n```\npublic struct ResourceState\n    {\n    public var content: T?\n    public var error: Error?\n    public var isLoading, isRequesting: Bool\n    }\npublic extension Resource\n    {\n    func stateSnapshot() -> ResourceState\n        {\n        let data: T? = latestData?.typedContent()\n        let contentTypeError: Error? =\n            (latestData != nil && data == nil)\n                ? Siesta.Error(\n                    userMessage: \"The server return an unexpected response type\",\n                    cause: Error.Cause.WrongContentType())\n                : nil\n    return ResourceState(\n        content: data,\n        error: latestError ?? contentTypeError,\n        isLoading: isLoading,\n        isRequesting: isRequesting)\n    }\n}\n\nextension Siesta.Error.Cause\n    {\n    public struct WrongContentType: ErrorType { }\n    }\n```\nThis would make the signal expect a specific content type, and would turn \u201csuccessful request, unexpected type\u201d into an error.\nToo much of a brain dump? Let me know if that makes sense.\n. Closing this thanks to @akaralar\u2019s contribution \u2014\u00a0but I\u2019d gladly welcome an RxSwift extension as well.\n. Thanks for noticing this, and for the fix. Your fix would mean bumping the required version to 8.1, but I'm fine with that.\nI like to get rid of ! whenever practical. Any idea why stringByAddingPercentEncodingWithAllowedCharacters returns an optional? If the encoding can fail, I want to report it as an error instead of crashing the app, but it's not clear what that error would be. Docs say it can return nil \u201cif the transformation is not possible,\u201d but I can\u2019t see the circumstances in which that would happen.\nI'm surprised that the as! is necessary, but looking over the docs, it seems to be \u2014\u00a0no copying initializer. Just filed a radar about that.\n. No need to reject. It\u2019s a good PR! I just always like to audit the use of ! very carefully. It\u2019s rarely the right choice, IMO \u2014\u00a0but this appears to be one of those rare cases.\nJust one reformatting request before I merge, which I\u2019ve noted in the code.\nI\u2019m share your surprise about the NSCharacterSet API. I filed a second radar about the String? return type.\n. Sweet! Thanks. \n. Huh, OK! I was just going by the docs. I guess I\u2019ll leave it at 8.0 and see if anybody complains. Thanks! And thanks again for the fix.\n. @paddlefish I filed a bug report w/Apple, and heard back \u2014\u00a0with a very helpful response, no less! Thought you\u2019d want to know, since this was such a head-scratcher:\nTurns out (much to my surprise) that it\u2019s possible to successfully create Swift strings that contain invalid Unicode in the form of unpaired UTF-16 surrogate chars. Such a string can cause UTF-8 encoding to fail. Here\u2019s some code that illustrates this behavior:\n``` swift\n// Succeeds (wat?!):\nlet str = String(\n    bytes: [0xD8, 0x00] as [UInt8],\n    encoding: NSUTF16BigEndianStringEncoding)!\n// Returns nil:\nstr.stringByAddingPercentEncodingWithAllowedCharacters(\n    NSCharacterSet.alphanumericCharacterSet())\n```\nNow that we know what can cause the nil, I\u2019ve updated the code to report it with a graceful error.\n. That's a good heads up about tagging requiring reputation on Stack Overflow. Hand\u2019t even occurred to me! Perhaps I'll rethink that recommendation about getting help in the README.\nThe Service.resource(url:) method \u2014 the one with the parameter labeled url:\u00a0\u2014 expects a complete URL. It looks like you want Service.resource(_:), which takes a path relative to the Service\u2019s base URL.\nTry:\napi.resource(\"users/login\")\n. Sure thing!\n\nOn Oct 15, 2015, at 9:50 AM, Rhuantavan notifications@github.com wrote:\nYes, the resource(url:) was the problem. Thanks.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/bustoutsolutions/siesta/issues/8#issuecomment-148409513.\n. If you expect the response content to already have been transformed into a String by the earlier transformers in the pipeline, then do this:\n\nservice().configureTransformer(\"/foo\") { $0.content as String }       // example 0\nThis doesn\u2019t transform the content, but it does cause Siesta to report it as an error if the content comes out as anything other than a string.\nIf you are getting something else from the transformers, an Int for example, and you want to convert it into a string, do this:\nservice().configureTransformer(\"/foo\") { String($0.content as Int) }  // example 1\nOr if you prefer a very explicit approach:\nservice().configureTransformer(\"/foo\") {                              // example 2\n    (content: Int, entity: Entity) -> String in\n    String(content)\n}\nExample 2 is what the Swift compiler infers from example 1, all spelled out. Those two are equivalent.\nThe underlying principle to all of this is that configureTransformer(...) uses Swift\u2019s type inference to determine your transformer\u2019s input and output type. That means that your closure needs to make it clear to the compiler exactly what types it expects, resulting in two common confusions:\n1. If you just use a bare $0 in your transformer closure, Swift doesn\u2019t know whether you mean the content argument, or the entire (content,entity) tuple. Usually Swift can infer which one you mean, but because configureTransformer(...)\u2019s first argument is a generic type, there\u2019s not enough information in this case. Saying $0.content removes that ambiguity.\n2. You need to make sure that $0.content can only have one possible type in the context where you use it, or the compiler can\u2019t infer its type. There are many String(_:) initializers, so you need to pick one using the as clause. Similarly, you need to make sure your closure has an unambiguous return type.\n. Glad it helped!\nPlease keep the issues coming. It\u2019s really helpful to know how people are using Siesta, and where the stumbling blocks are.\n. Yes, this is something I\u2019d wondered about, but I wanted to make sure somebody was actually using ResourceStatusOverlay before addressing it. (That question is now answered!)\nI don\u2019t think there\u2019s one behavior that\u2019s right for everyone. Certainly for a view that polls in the background, what you want makes sense. If a load is user-initiated, prioritizing the error might make sense. Depending on the UI, it might be better not to even show the loading indicator if data is present.\nAll that is complicated by the fact that you can use your own layout with the class \u2014\u00a0and if, for example, the error view is a little unobtrusive thing at the top, then it might make sense to show it even when polling in the background. Twitter & Slack both do something along those lines, IIRC.\nI\u2019d like to solve this with something very simple, general, and flexible. My vague thought was that there are three things the view can show, namely data, error, and loading, and you should be able to prioritize them in a list. Something like this:\n```\noverlayView.displayPriority = [.Loading, .Error, .Data]  // What it does now\noverlayView.displayPriority = [.Data, .Loading, .Error]  // What I think you want?\noverlayView.displayPriority = [.Data, .Error, .Loading]  // No spinner except on first request\noverlayView.displayPriority = [.Data, .Error]  // Maybe you never want a spinner\n```\nI\u2019m fuzzy on the details. I\u2019ve sketched it out like it\u2019s an enum, but maybe those are little strategy structs instead, where the first one in the list to say \u201cI\u2019m it\u201d wins, and you can provide your own.\nThoughts on that \u2014\u00a0as a user, as someone looking at the code?\n. Good point about pull to refresh. Hmmm.\nI think if you wanted one request to be specially privileged over others, you\u2019d use request hooks instead of the observer mechanism to manage the UI for just that request. Something like this:\n```\nvar resource: Resource\nvar overlay: ResourceStatusOverlay\nvar manualRefresh: Request?\nvar manualRefreshView: UIWhateverView\nfunc doSetupSortsOfThings()\n    {\n    ...\n    resource.addObserver(self)\n            .addObserver(overlay)\n    ...\n    }\nfunc triggerManualRefresh()\n    {\n    guard manualRefresh == nil else\n        { return }\nmanualRefreshView.hidden = false\nmanualRefresh = resource.load()\n    .completion\n        {\n        _ in\n        manualRefresh = nil\n        manualRefreshView.hidden = true\n        }\n}\n\n```\nNote that triggerManualRefresh() doesn\u2019t have to worry about actually doing anything with the response data \u2014\u00a0we\u2019re already observing it. It just ties a special\u00a0\u201crequest\u00a0in progress\u201d indicator to one specific request.\nAnother related question is how you might show a small, unobtrusive error if a background refresh failed and cached data is unavailable, but the standard full-size overlay if there is no data. In that case, I think you\u2019d have two separate observer views: one that\u2019s the standard overlay with [.Data, .Loading, .Error], and a second custom view that shows the error only if data is also present.\nIn general, I imagine ResourceStatusOverlay being layered with other things in one UI \u2014\u00a0not managing the whole screen at once. That eases the burden somewhat.\nTalking through this makes me think that the enum probably is sufficient, and little customizable strategy structs is overkill. Other use cases to consider?\n. I took a first crack at this, pretty much following this discussion. It\u2019s on master. For your case, I think you want:\nstatusOverlay.displayPriority = [.Retrying, .AnyData, .Error, .Loading]\nThe .Retrying condition refers specifically to a manual refresh initiated by the user tapping the retry button in the status overlay\u2019s error view, whereas .Loading means any load request initiated by anyone.\nThe \u201cany\u201d in .AnyData means \u201cany of the possibly multiple resources this overlay is observing.\u201d There\u2019s also an .AllData.\nGive it a try when you get a chance, and let me know how it works and what it needs.\n. Thanks for trying it out, Annica!\nI\u2019m puzzled about the behavior you saw with [.Retrying, .AnyData, .Error, .Loading]. With that setting, it certainly shouldn\u2019t show an error if there is data. I tried this myself \u2014 refresh timer, app gets data, network that goes offline, refresh hits again \u2014\u00a0and wasn\u2019t able to reproduce what you saw.\nWould you mind double checking that you\u2019re getting that behavior even when .AnyData comes before .Error in the list? If so, could you post some of your log output with the categories set to LogCategory.common? That would help narrow it down.\n. No apologies necessary. \u201cMeasure twice, cut once\u201d is just what it takes to make good software. Glad it works!\nI got halfway into the Realm-Siesta question before coming down with a really nasty cold. Now catching back up. I\u2019ll be in touch!\n. This should be fixed in the next beta release.\nIf you\u2019re brave and foolhardy, try master and see if it\u2019s fixed for you already.\n. Wait, apologies, I mistook this for another bug. I should have looked at your log more carefully before answering.\nIt looks like your server is sending Content-Type: application/json even though the response is empty. That\u2019s causing Siesta to attempt to parse the response as JSON, which gives the \u201cno value\u201d error you\u2019re seeing.\nA 204 should not give a content-type header, since there is no content. Is that something you have control over?\n. If they're unable to change it, feel free to reopen this issue, and we'll either decide to make Siesta handle it as a special case or get you a configuration workaround.\n. Seeing that you\u2019ve only got a workaround from the Restler side, I\u2019ll give you a Siesta-side workaround to choose from as well.\nYou can make a response transformer that assigns a made-up content-type to empty responses to suppress further processing:\n```\nstruct ChangeEmptyResponseContentType: ResponseTransformer\n    {\n    func process(response: Siesta.Response) -> Siesta.Response\n        {\n        switch(response)\n            {\n            case .Success(var entity):\n                if let data = entity.content as? NSData where data.length == 0\n                    { entity = Entity(content: NSData(), contentType: \"unknown/empty\") }\n                return .Success(entity)\n        case .Failure:\n            return response\n        }\n    }\n}\n\n```\n\u2026and then, when configuring your service, make it the first transformer in the pipeline:\nconfigure\n    {\n    $0.config.responseTransformers.add(\n        ChangeEmptyResponseContentType(),\n        first: true)\n    }\nThat\u2019s just a hack, but it does give you another option if the Restler patch doesn\u2019t suit.\n. It\u2019s supposed to work without Alamofire, but I\u2019m getting reports of the same error as you with the latest beta.\nI\u2019ve had trouble pinning it down, but my current best guess is that Apple\u2019s optional framework dependencies simply don\u2019t allow third-party frameworks to be optional in practice, and it\u2019s only working for some people because Alamofire is present in their Xcode temp directory.\nKeep using your current workaround, and I hope to have a new beta out soon to resolve this.\n. Could give master a try and see if it fixes your problem?\n(Probably best to scrub your Carthage and xcode temp dirs just to be sure.)\n. Fix confirmed by Jon via email. Will be released in next beta.\n. There isn't a whole lot of public example code yet. You\u2019ll find some hints in the configuration chapter of the user guide and in the API docs for invalidateConfiguration.\nAlthough there isn\u2019t currently time available for it, my hope to write up a cookbook of examples for the 1.0 release.\nIf you can pose a more specific question, I can help point you in the right direction.\n. I\u2019d first select a third-party lib such as p2/OAuth2 or dongri/OAuthSwift to handle the whole dance of acquiring an OAuth token. That's well outside the scope of Siesta.\nOnce you have a token, you\u2019d do something like this:\n```\nclass MyApi: Service\n    {\n    init()\n        {\n        ...\n    configure { $0.config.headers[\"Authorization\"] = authHeader }\n    }\n\nvar authHeader: String?\n    {\n    didSet\n        {\n        // Clear any cached data now that auth has changed\n        wipeResources()\n\n        // Force resources to recompute headers next time they\u2019re fetched\n        invalidateConfiguration()\n        }\n    }\n}\n\n```\n\u2026and then when authentication succeeds:\nmyAPI.authToken = authTokenFromOAuthLib\n\u2026and for logout:\nmyAPI.authToken = nil\nYou could integrate OAuth more tightly with Siesta.\u00a0For example, you could add special error handling hooks in your Siesta config to trigger a token refresh when you detect an OAuth error. However, I\u2019d start with something as simple as the code above and see what other needs you have.\n. I added some of this info to the Siesta docs: http://bustoutsolutions.github.io/siesta/guide/security/\nClosing this issue, but feel free to post more on Stack Overflow (with the siesta-swift tag) or here if you need more info.\n. That file with the \u201cimport Siesta\u201d\u00a0is a problem child. It\u2019s optional, only necessary if you want to use Alamofire; you can just exclude it. It\u00a0was part of the main framework until it became clear that optional dependencies really aren\u2019t. Before the next beta, I\u2019m going to either (most likely) move it into a different source folder, or even a different project. In face, I think I\u2019ll just do that for you right now\u2026.\n. Moved it. Should now build cleanly from source if you only include Source/.\n. I assumed the issue with import Siesta was the module not being able to import itself, but it sounds like what\u2019s happening is that you\u2019re not building Siesta as a module at all.\nI don't recommend doing that. The project has a number of types that make sense when namespaced to a module, but that you probably don\u2019t want just dropped into your global namespace (e.g. it\u2019s one thing having Siesta.Error, but it\u2019s another having something just called Error).\nEven if you\u2019re including the source as a git submodule, I\u2019d strongly recommend still building Siesta as its own Swift module. Whether the right way to do that is as a separate target in the same xcproj or as an xcworkspace with the Siesta project nested in it, I can\u2019t say.\n. You bet.\nThe moment for your first PR will come yet, I have no doubt!\n. Thanks for the review, Ray.\nYou raise a good question about resourceWithURL(_:). My thinking is as follows:\nThere\u2019s value in having a flavor of the method that accepts a string instead of an NSURL, because it can fold \u201cnil string\u201d and \u201cinvalid URL\u201d into a single method call. The logic for that is mildly tangled if there\u2019s only an NSURL flavor of the method, and is likely to be repeated a lot. So you want one version of the method that takes a string that's a URL.\nHowever, there also needs to be a method that takes a string that\u2019s a baseURL-relative path. At that point, there are two different Service.resource(String) methods. The \u201cCompensate For Weak Type Information\u201d section of the guidelines recommends adding clarifying words to method & param names in this situation:\nresourceWithPath(String)\nresourceWithURL(String?)\nresourceWithURL(NSURL?)\nThat\u2019s not bad, but I feel like resourceWithPath(_:) is kind of the default and should be just resource(_:). It\u2019s super common, and I like how it reads in code:\nfunc currentUser() -> Resource { return resource(\"/user\") }\nservice.resource(\"/widgets\").child(widgetID).addObserver(\u2026)\nBut maybe I\u2019m wrong about that, and the added clarity of  resourceWithPath(_:) is preferable?\nfunc currentUser() -> Resource { return resourceWithPath(\"/user\") }\nservice.resourceWithPath(\"/widgets\").child(widgetID).addObserver(\u2026)\n. > One thing I was wondering about was resources always seem to with a forward slash. Is the shorter resource(\"user\") frowned upon?\nNah, I left it open to both styles on purpose. It doesn't matter, since that method always creates something underneath the base URL (which is meant to prevent security holes caused by, say, an accidental hostname switch). I tend to prefer resource(\"/user\") just because API docs usually include the leading slash.\n. Looking back over this list, I\u2019m wondering about adding a prefix to the request hooks, maybe this:\nswift\nresource.load()\n    .onSuccess { data in print(\"Wow! Data!\") }\n    .onFailure { error in print(\"Oh, bummer.\") }\n\u2026instead of this:\nswift\nresource.load()\n    .success { data in print(\"Wow! Data!\") }\n    .failure { error in print(\"Oh, bummer.\") }\n@rayfix, any others \u2026\u00a0gut reactions to that?\n. Good point about the autocomplete. Hadn\u2019t even crossed my mind.\nI\u2019ve updated the gist to reflect \u201con\u201d prefixes as well.\n. Thanks for this in-depth review, Radek!\n\nThe rationale being, ifNone doesn't really describe the method \u2026 it describes the parameter. Most of the time, the job of the method makes the first parameter obvious (hence the guideline), but here, it doesn't. So the parameter makes sense.\n\nI like this as a counterpoint to the Apple guidelines. I\u2019m still tentative about how I feel about that particular rule.\n\nHaving said that, I think it would be worth rethinking this particular API either way, because it's really not obvious that the ifNone not only supplies the default value but also determines the type of the cast return value.\n\nThe cast becomes the narrower type of the ifNone: arg and what the return value\u2019s context allows. For example, here the return type gets the last word, [String] instead of [Any]:\nlet stringContent: [String] = resource().contentAsType(ifNone: [])\n(It\u2019s one of my favorite weird-awesome features of Swift that the inferred return type changes the runtime behavior of contentAsType()!)\nIn fact, if there were to be a no-default version of this method \u2014 there isn\u2019t, at least now, because it\u2019s no more useful than as? \u2014 but if there were, it would work like this:\nlet stringContent: [String]? = resource().contentAsType()\nThat line of thinking lead me to the current name.\n\nCorrect me if I'm wrong, but AFAICT the difference between resourceWithURL and resource is that the former takes an absolute URL, and the latter is relative to the service's base URL \u2014 right?\n\nYou understand resourceWithURL() correctly, but resource(_:) is a bit more subtle. It isn\u2019t relative, in that it doesn\u2019t resolve ./, ../, //, etc; it just appends everything to the base URL\u2019s path. That\u2019s meant to prevent security holes. Suppose you let this dangerous code slip in:\nlet userProfile = service.resource(username)\nIf somebody tries to make your app leak sensitive information by making setting their username to //malicious.host, Siesta will just append that to the path: https://api.myapp.com///malicious.host, whereas relative URL resolution would switch hosts.\nThe only place Siesta does relative resolution is in Resource.relative(_:), which is meant to be a little harder to use by accident.\n\nI feel like this semantic difference isn't well conveyed in the naming, and the fact that \"URL\" doesn't just mean \"NSURL\", as there's an override that takes an equivalent URL string, confuses matters even more.\nWhat about resource(absoluteURL:) perhaps? Or maybe even resource(absolute:), since at call site the type is clear. The former is a bit more verbose than just (url:), but clearer about the intention, I think.\n\nI like your line of thought. Yeah, these methods have been a point of confusion for multiple users, and better naming might help. Since the distinction between the two methods is not absolute / relative, but rather URL / path, maybe this naming I shied away from is the right one after all:\nresourceWithPath(_:)\nresourceWithURL(_:)\nOr:\nresource(path:)\nresource(url:)\n@rayfix, any thoughts on this?\nThanks for the sanity check on onCompletion() and friends. You have a good point about ResourceObserver.onResourceChange(...), thought it\u2019s a bit different because it doesn\u2019t accept a closure, so I\u2019m not convinced it should follow the same convention. The Cocoa way would be resourceDidChange(\u2026).\n\nThis is one of those cases where repeating type information might be preferable after all. And the reason why is that \"URL\" isn't just type information here, it also actually describes the thing the property is. And \"base\" works to describe \"URL\", not as a standalone noun.\nAt first glance \"Service.base\" seems to suggest that there's a class called Base, or perhaps ServiceBase, or that there's some fundamental concept of a \"base\". And there isn't. There's just a base URL.\n\nHmmm, you\u2019re making me lean back to baseURL after all. Just base does open the door to many a misunderstanding.\n. Hmm, perhaps \u201cpath\u201d is indeed the problem. How about \u201cendpoint\u201d as the other term?\nresource(endpoint: \"/users\")\nresource(url: \"https://other.server/dingbats\")\nThat\u2019s not perfectly correct, though, because of course external URLs can also be endpoints. Plus it loses the concision of the common case:\nresource(\"/users\")\nWhat about this?\nresource(\"/users\")\nresource(absoluteURL: \"https://other.server/dingbats\")\n\nOn the typed content question, it's best to evaluate the method name in context, I think. One common case is defining an extension to provide a new convenience accessor \u2014\u00a0here, for example, one that lets you do resource.image:\n```\nlet placeholderImage = UIImage(named: \"placeholder.png\")\nextension TypedContentAccessors {\n    var image: UIImage {\n        return contentAsType(ifNone: placeholderImage)\n    }\n}\n```\nSo there\u2019s the problem: \u201cas what type?\u201d Like Radek said, it sounds like there\u2019s a parameter missing \u2014\u00a0and that\u2019s correct, in a way, because there is an implicit type parameter.\nWith some of the alternatives:\nextension TypedContentAccessors {\n    var image: UIImage {\n        return typedContent(ifNone: placeholderImage)\n    }\n}\nThis isn\u2019t bad, but it's not perfect. It makes it sound like a resource can either have \u201ctyped content\u201d or not, but all content is typed; it just may be of the wrong type. With the word \u201cas\u201d gone, it doesn\u2019t convey in the same way the connection to Swift\u2019s as?.\nRay\u2019s suggestion:\nextension TypedContentAccessors {\n    var image: UIImage {\n        return content(or: placeholderImage)\n    }\n}\nI don\u2019t think this conveys the type conversion nature of the operation enough. It\u2019s a nice convention if we\u2019re only defaulting for nil, but we\u2019re defaulting for nil or wrong type.\nDoes a preposition change or more verbosity fix it? I don\u2019t think so, but throwing it out here:\n```\nextension TypedContentAccessors {\n    var image: UIImage {\n        return contentOfType(ifNone: placeholderImage)\n    }\n}\nextension TypedContentAccessors {\n    var image: UIImage {\n        return contentAsMatchingType(ifNone: placeholderImage)\n    }\n}\n```\nHere\u2019s another set of \u201cin the wild\u201d comparisons, for the common case of extracting a specific model type, and using Radek\u2019s idea of the bare inferred type converter with no default value:\nif let user: User = resource.contentAsType() {\n  ...\n}\nif let user: User = resource.typedContent() {\n  ...\n}\nif let user: User = resource.content() {\n  ...\n}\nif let user: User = resource.contentOfType() {\n  ...\n}\nif let user: User = resource.contentAsMatchingType() {\n  ...\n}\nThat touch off any opinions, or new ideas?\n. >  I'd also be willing to consider dropping the \"absolute\" word, and just have resource(\"/path\") and resource(url: \"http://...\"). I have a sense the distinction is still perfectly clear, but I could be wrong.\nHa! That is exactly my original design! Full circle.\nI also thought it was clear, but it was a point of confusion for at least a couple of different people. I\u2019d tentatively lean toward this, then, since we both like it:\nresource(\"/users\")\nresource(absoluteURL: \"https://other.server/dingbats\")\nRay, others, gut check on that?\n\n\nI still like typedContent best.\n\nFunny thing: that was my original name for it. I switched to contentAsType because of the helpful presence of the word \u201cas.\u201d\nI still like these two best, and definitely agree with Radek\u2019s analysis of the others:\nif let user: User = resource.contentAsType() {\nif let user: User = resource.typedContent() {\nI could be talked back into typedContent if others agree it\u2019s better.\n. I\u2019ve locally gone back to baseURL and made the migration to onSuccess() etc. Both changes look good as I actually use them in code.\nI\u2019ve also experimented with going back to typedContent(ifNone:), and I think you two have a point. Also, you make me see the value of the no-args typedContent() that works just like as? but uses type inference. Even this simple case:\nif let user: User = userResource.typedContent() { \u2026 }\n\u2026is more pleasant than:\nif let user = userResource.latestData.content as? User { \u2026 }\nSo \u2026\u00a0yeah, I think you\u2019ve won me over. If I still like it by the end of the weekend, it shall be so.\n\nOn reflection, I\u2019m liking the new use of \u201cabsolute\u201d in the method name, but am on the fence about this:\nresource(absoluteURL: \"https://other.server/dingbats\")\n\u2026versus this:\nresourceWithAbsoluteURL(\"https://other.server/dingbats\")\nLike you all, I find the first one appealing, but it does clearly violate Apple\u2019s guidelines as well as common practice. @erica, any chance I can nudge you into a gut reaction on this one? Seems like the kind of call you\u2019re good at making.\n. > I'm not so sure about this use case (I tend to avoid explicit type declarations inside methods like that), but one that I find compelling is when the type can be inferred from a method you're passing typedContent() to.\nSure, you could also do this nice refactoring:\nshowUser(userResource.typedContent())\nYou\u2019d then have to make showUser()\u2019s arg optional:\nfunc showUser(user: User?) { \u2026\u00a0}\n\u2026but that\u2019s probably the right thing anyway, since \u201cshow that there is no user\u201d is also a valid & important operation.\nAnd I still do like typedContent just fine after sleeping on it and don\u2019t have a strong opinion either way, so I\u2019ll defer to the judgement of R* on this.\n\nOK, Radek, I think you\u2019ve convinced me on resource(absoluteURL:). I like it better that way as a matter of personal taste, and I agree completely with all of your reasoning.\nI say \u201cclearly violates\u201d because after that \u201cusually\u201d you mention, the Apple guidelines then say, \u201cThere are only a few exceptions,\u201d and this is not among those they list. However \u2026 I don\u2019t see any examples in the guidelines that clearly promote a first arg label to be part of the method name. The closest they come is this:\n\nfunc addObserver(_ observer: NSObject, forKeyPath path: String)\n\n\u2026but in this case, addObserver seems like an operation that\u2019s distinct from other kinds of adding, and it makes sense for \u201cobserver\u201d to be in the base name. Is that line of thought inconsistent with the guidelines? Well, they do say this:\n\nMethods can share a base name when they share the same basic meaning but operate on different types\n\nThat\u2019s \u201ccan\u201d and not \u201cshould,\u201d but it does suggest we\u2019re not out of line thinking that method base names are about the method\u2019s role, and not its first argument.\n. Thanks, Erica. I didn\u2019t think you were ignoring us! Certainly nobody\u2019s obliged to respond to a random Github mention, especially on the weekend, so I\u2019m delighted to have you jump in at all.\n\nTo give some background, because I know this is a long thread to jump into: there are several different resource(...) variants going on. They all are essentially the same operation underneath and return the same thing, but take different parameters.\nOne variant takes a subpath of a service\u2019s base URL; the other takes a fully independent URL, and that latter one comes in two flavors that accept String and NSURL. So there\u2019s both a \u201cpath vs. URL\u201d distinction and an \u201cunder the base URL vs. absolutely nothing to do with base URL\u201d distinction.\nI lean (as I think do Ray & Radek) toward making the more common \u201csubpath of base URL\u201d variant be unlabeled, because with the strings you\u2019d actually be passing to that, it really is pretty clear at the call site:\nmyAPI.resource(\"/dingbats\")\n\u2026whereas more explicit labels like this get ugly, especially given that they\u2019re such a common case:\nmyAPI.resource(subpathOfBaseURL: \"/dingbats\")\n(end of background)\n\nI totally agree that this is not good:\nabsoluteResource(\"http://other.server/dingbats\")\n\u2026because, among other reasons, there\u2019s no such thing as an \u201cabsolute resource.\u201d Every resource has a fully resolved URL; the only difference between all these resource(...) methods is how that URL is derived. The word \u201cabsolute\u201d modifies the parameter, not the result.\nWhen you say that \u201cthis would be way better:\u201d\nresource(absoluteURL: \"https://other.server/dingbats\")\n\u2026you are in agreement with everyone else in this thread. It passes my own gut check, and three other developers whose opinions I respect a lot say it looks good to them. That\u2019s enough for me to go against the Apple guidelines.\nIf we do get a chance to comment on the API guidelines on swift-evolution, then we can make our stand there! Get your torches and pitchforks ready, I guess?\n. If I you set up the repo, I\u2019ll definitely drop in my $0.02!\nFWIW, I really like the new guidelines in a great many respects. They\u2019re just too prescriptive given the narrow range of cases they actually consider \u2014\u00a0particularly around part-of-speech questions and parameter naming.\n. Glad you fixed it! Let us know how Siesta goes for you once you\u2019ve had a chance to experiment.\n. Great! Be sure to tweet @siestaframework about the app when it's live!\n. Good catch. Thanks!\n. By default, Siesta uses NSURLSession and not NSURLConnection, so look up instructions on how to do certificate pinning with an NSURLSessionDelegate instead of an NSURLConnectionDelegate.\nConfigure an NSURLSession with your custom NSURLSessionDelegate just as you would without Siesta. Then pass the NSURLSession as your networking provider when you create the Siesta service.\nlet certificatePinningSession = NSURLSession(\n    configuration: NSURLSessionConfiguration.ephemeralSessionConfiguration(),\n    delegate: MyCustomSessionPinningDelegate(),\n    delegateQueue: nil)\nlet myService = Service(baseURL: \"http://what.ever\", networking: certificatePinningSession)\nYou might also take a look at the SSL conveniences provided by Alamofire (which you can also use with Siesta).\nFinally \u2014 or I should say first! \u2014 consider using TrustKit instead of configuring it manually.\n. Thanks for this, Alessandro!\nTwo things before I merge:\n- This is too specific for the REAME. Let's move it to the user guide. Create a new \u201cSecurity\u201d page for it, because we may want to add other sections as well (e.g. authentication, pitfalls, etc.).\n- I'm noting a few minor copy edits in the text.\n. My apologies \u2014\u00a0I should have explained that the gh-pages branch is generated from master; all you need to do is add the file to the Docs directory on master. (You don't need to add the jekyll header or the next page link. Those are also generated.)\nI hate to make you keep jumping through hoops, so I can take care of that. I\u2019ll just merge this PR and move it to the user guide myself.  Thanks again for writing this up!\n. I think we\u2019re in the clear here. As far as I can trace through, in a low memory event, the cleanup touches every weak reference that might have been zombified.\nWe can reopen the inquiry if we observe unexplained memory leakage in the wild.\n. I assume that response.json is the typed content accessor from the example project that returns SwiftyJSON, right?\nWhat's going on here is that at this point:\nvar res = response.json\n//example manipulation\nres[\"cbs\"][0][\"input\"][0][\"value\"].string = \"00000\"\n\u2026res is a SwiftyJSON.JSON object, but NSJSONConvertible wants a dictionary or array. You have two options:\n1. Convert the JSON back to an NSDictionary to pass it to Siesta:\napi.login.request(.POST, json: res.dictionary)\n2. If you're doing that in many places, add a Siesta request flavor that accepts JSON objects:\npublic func request(method: RequestMethod, jsonDict: JSON) -> Request\n       { return request(method, json: json.dictionary) }\n(Warning: untested code there!)\n. Ah, indeed. Here is some code that I\u2019ve verified actually compiles:\nextension Resource\n    {\n    public func request(method: RequestMethod, jsonDict: JSON) -> Request\n        { return request(method, json: json.object as! NSJSONConvertible) }\n    }\nSee if that does the trick.\n(Hmm. I should expose FailedRequest in the public API so you can replace that as! with an as?.)\n. > the parameter is called jsonDict, not json\nAh, right.\nI mean to write up a cookbook for 1.0, but am trying to get API details sorted out first.\nI may also add a standard SwiftyJSON extension, now that there's an Extensions folder for such things.\n. Thanks, Jon! Nicely written. See the one minor note in the code, and then it\u2019s next stop mergeville.\n. Done. Thanks!\n. Thanks for the heads up. Not sure how this crept into an info plist! Are you building with Cocoapods, Carthage, or manual code inclusion (e.g. git submodule)?\nWould you mind giving me a dump of everywhere the string appears in your codebase? That might reveal something:\nfind . -name .git -prune -o -type f -exec grep -l 1.0-beta {} \\;\n(Also, note that beta 5 just came out!)\n. Ah \u2014\u00a0so Cocoapods is generating a plist and stuffing it in. One of my Siesta apps uses Cocoapods too. Wonder why this issue didn\u2019t trip that one up? Curious. Would you mind attaching your Podfile (if it's not full of secret stuff)?\n. Yes, confirmed locally, and it is indeed an issue in Cocoapods, the one that you linked to in your first comment: https://github.com/CocoaPods/CocoaPods/issues/4421\nFrom what segeddins said on that thread, it looks like there\u2019s already a fix in the pipelines, and it may be released as soon as Cocoapods 0.39.1. In the meantime, you could try the post_install hacks on that thread \u2014\u00a0but it may be easier to just manually fix the version number until the updated Cocoapods is released.\n\nOne of my Siesta apps uses Cocoapods too. Wonder why this issue didn\u2019t trip that one up?\n\nBecause the only release of that particular app that I did after the Siesta beta numbering started used a hot patch from master, and thus wasn\u2019t stamped with a beta version number. So that explains it.\nWhat\u2019s your app, if you don\u2019t mind my asking? Would love to see it!\n. If two things are the same resource, then they must have the same data. Thus you definitely want /resource and /resource?filterByDate=2015-12-18 to be different resources: \u201call the things\u201d and \u201cthings from Dec 18\u201d are different pieces of information. It\u2019s best to think of them as entirely separate resources.\n\nIn this way I need to add an observer (the view, self), to a new Resource, every time the user select a different filter for the list.\n\nYes, that\u2019s exactly right.\nIn fact, it\u2019s best not just to add the observers to the new resource, but to remove the old one as well. Think of your table view as always showing some particular resource, and when you change filters, you change which resource it\u2019s showing: \u201cNow show all the things!\u201d \u201cNow show things from Dec 18!\u201d\nThe idiom that keeps this clean is to create a \u201ccurrently displayed resource\u201d\u00a0property with a setter that un-observers the old resources and starts observing the new one. Take a look at this code from the example project, which shows how to integrate this behavior with a table view:\nhttps://github.com/bustoutsolutions/siesta/blob/master/Examples/GithubBrowser/Source/UI/RepositoryListViewController.swift#L14-L22\n. Please see the answer on Stack Overflow, and let me know on that end if you need more info!\n. Sounds great. Send the PR once you feel like it\u2019s basically working, even if it\u2019s not perfect, and I\u2019ll review it.\nThe UIKit stuff should be limited to the two UI classes (ResourceStatusOverlay and RemoteImageView) \u2026 right? You should be able to just remove those files from the OS X build target.\n. Ah, no, looking it over, I see that there\u2019s also a mention of UIImage in the response transformers, and a mention of UIApplicationDidReceiveMemoryWarningNotification in the weak cache. That second one is problematic, since Siesta relies on the low memory warning to keep the cache from growing without bound. I\u2019ll have to implement the LRU cache eviction I\u2019ve been avoiding to make that work\u2026.\n. Depends on #31 \n. Fixed in #56 \n. > Actually WatchKit includes way of getting data through the iOS app so it's ok if it's dismissed for now.\nThat was my understanding, but\u2026\n\nIt would be very beneficial if it could work on watchOs as well.\n\nI\u2019m all for it if anyone finds a need for it.\n\ntvOS would be amazing to get tho\n\nI\u2019d welcome a pull request.\n\nCan we split Siesta and SiestaUI ?\n\nAlready done. Isolating UIKit code was done by @onekiloparsec for the macOS target, and I already split SiestaUI for SwiftPM support. Siesta & SiestaUI are now two separate subdirectories under Source, separate targets in the Xcode project, separate modules if you build with SwiftPM or Carthage, and separate subspecs if you\u2019re using Cocoapods.\nI\u2019m only aware of two spots in the core Siesta module that require platform-specific attention: the type of parsed images, and the name of the low memory notification. Both should be easy to resolve. Search Source/Siesta/ for the two occurrences of #if.\n. Looks like maybe @TriTT was working on tvOS support?. #187 added a tvOS target. Specs don\u2019t run on tvOS because of Nocilla, but that seems solvable.\nI'd like to hear from users about any success / troubles in actual apps before declaring this supported. (See checklist at the top of the issue.). Siesta should support HTTP/2 just fine as long as the underlying networking provider supports it. The default provider is URLSession (formerly NSURLSession), which supports HTTP/2 as of iOS 9.\n@tracicot: If you find a case where URLSession supports a request when used directly but fails when used through Siesta, please open an issue.\n. @JoiMeseery That\u2019s an error coming from the underlying networking layer. Same question as above: what happens when you send the same request with URLSession? If there\u2019s a request that works with raw URLSession but not when sent through Siesta, then reopen this issue.. Use the Resource.request() variant that passes you an NSMutableURLRequest, and populate that exactly as you would if you were using NSURLSession without Siesta.\nSee the API docs for an example.\n. I decided not to implement WeakCache using NSCache because of the complexity of the latter. As Matt Thompson put it, it\u2019s \u201ckind of a hot mess.\u201d In particular, I was concerned about making Siesta\u2019s strong \u2192 weak transition work in terms of NSDiscardableContent. The trick is that WeakCache needs to be able to to make refs go weak when the cache wants to discard them, but not actually remove them from the cache until the weak ref goes nil. I investigated a while, and it looked like it might conceivably be possible to make NSCache do this, but it would have to rely on dubious assumptions about the exact sequence of calls and internal behavior. Thus no NSCache.\n. Thanks for giving it a look, Annica. Since writing this up, I also started wondering if I shouldn\u2019t just make all EntityCache implementations work at the beginning of the pipeline, i.e. NSData only. Your scenario answers that: yes, there is potential value to exposing models to caches too.\nIn that case, would the change I\u2019m proposing here help you? Maybe. You could do something like this:\n\n\u2026where the Siesta \u2192 Realm flow is unidirectional: the Realm cache\u2019s writeEntity updates Realm every time new data arrives, but its readEntity never returns anything. That means you don\u2019t have to stuff URLs in the database. (There\u2019s still the main thread problem, but that\u2019s easily solved.)\nIn this scheme, Realm is only there for queries and rollups; the app doesn\u2019t rely on Realm to make network requests work offline. When you make a request, Siesta first asks the Realm cache, but that one always says \u201cNot it!\u201d It then checks with the JSON cache, which might actually return something.\nDoes this make any sense? It seems like it would work if Realm is just a cache too, but it would fall apart if you\u2019re trying to update Realm locally and then push those changes back to the server.\n\nThere\u2019s a deeper problem here I\u2019ve been trying to avoid: I don\u2019t want to make Siesta try to handle bidirectional sync. That pushes too deep into API-specific behavior.\nRight now, Siesta is strictly a cache, and the server remains the ultimate source of truth. It\u2019s up to the app to manage updates: what they look like, when they happen, what to do with client-side state if they fail. That seems like the right line to draw. However, I think a lot of Siesta client projects (including yours) are going to push up against it, and I don\u2019t have a clear answer. Thus my interest in your case.\n. I think the need for encrypted caching is widespread. Right now, of course, Siesta doesn\u2019t even provide an implementation of EntityCache for you, so \u2026\u00a0you can write one that\u2019s encrypted or not. Eventually (1.1?) I do think Siesta should provide default implementation(s) supporting both NSData and JSON input, and storing files both encrypted and unencrypted. For 1.0, though, I just want to stabilize the API.\nTo that end:\n1. I\u2019m thinking to go ahead with the API changes necessary to support what described above, and\n2. I should also let caches specify their preferred GCD queue, which would solve your Realm problem.\n. And an addendum to that: even though you\u2019re not relying on Siesta to handle the sync problem (yay!), I\u2019m very interested to know about any roadblocks you hit in the course of doing that that do fall squarely on Siesta\u2019s side of the line.\n. @jyounus Well, I don\u2019t have a paying client for Siesta improvements at the moment, so it\u2019s (alas) a spare time project, taking a backseat to the teaching and other urgent things. But this feature is definitely high on my list! I will post to this issue when I have something testable.\n. After some head-scratching and light prototyping, I have a design proposal for this.\nBackground\nThe challenge here is that the transformer pipeline currently is just an unstructured (and uninspectable) array, and depends on users writing configuration so that transformers get added in the order they should run, with no opportunity to insert or replace specific ones. This design was already stretched a little thin, but this issue clearly breaks it: clients need to be able to say \u201cadd cache X at point Y in the pipeline\u201d where Y is not necessarily the end.\nWe therefore need some way to say \u201cpoint Y in the pipeline.\u201d Because transformers are usually structs, using instance equality is not an option. Because they are often closures wrapped in a single ResponseContentTransformer type, using dynamic type information is not an option. There\u2019s no natural way to say \u201cthe JSON transformer that\u2019s in the pipeline.\u201d\nI originally considered letting clients specify an optional ID when adding a transformer. However, this turns out to be fairly awkward at the point of use, and is also brittle.\nProposal\nConcept\nThe big API change is that the pipeline would have a sequence of identifiable named stages:\n\nClients can customize the set of stages and their order.\nEach stage has zero or more transformers:\n\n\u2026and a cache:\n\nDuring response processing, each cache receives an entity for writing after all the stage\u2019s transformers have run.\nWhen reinflating a new resource, Siesta checks each cache in turn starting with the end of the pipeline. If there is a cache hit, Siesta takes whatever the cache returned and runs it through the pipeline\u2019s subsequent stages.\nAPI\nThe opaque resourceTransformers property would go away.  Instead, you would configure transformers by attaching them to a pipeline stage:\nswift\nservice.configure {\n    $0.config.pipeline[.parsing].add(SwiftyJSONTransformer, contentTypes: [\"*/json\"])\n    $0.config.pipeline[.cleanup].add(GithubErrorMessageExtractor())\n}\nThe ability to identify transformers by stage creates the new ability to remove or replace specific transformers in the pipeline. This is frequently request feature for model transformers. To this end, Service.configureTransformer(\u2026) will no longer always append the transformer; instead, it will by default replace the transformer at the model stage:\n``` swift\nservice.configureTransformer(\"/users/*\") {\n  User(json: $0.content)\n}\n// ...is shorthand for:\nservice.configureTransformer(\"/users/*\", atStage: .model, replaceExisting: true) {\n  User(json: $0.content)\n}\n// ...which is shorthand for:\nservice.configure(\"/users/*\") {\n    $0.config.pipeline[.model].removeTransformers()\n    $0.config.pipeline[.model].add(\n        ResponseContentTransformer(\n            User(json: $0.content)))\n}\n```\n@MPiccinato, I think this would nicely solve #47?\nswift\nservice.configureTransformer(\"/products/*\") { Product(...) }\nservice.configureTransformer(\"/products/filters\") { Filter(...) }  // overrides line above\nEach stage has an optional cache:\nswift\nservice.configure {\n    $0.config.pipeline[.rawData].cache = encryptedFileCache\n    $0.config.pipeline[.model].cache = realmCache\n}\nClients can create custom stages with an arbitrary order:\nswift\nservice.configure {\n    $0.config.pipeline.order = [.munging, .twiddling, .blending, .baking]\n}\nMy tentative list of default stages:\n- rawData: unprocessed data (to attach cache; wouldn\u2019t typically have transformers at this stage)\n- decoding: bytes \u2192 bytes: decryption, decompression, etc.\n- parsing: bytes \u2192 ADT / general type: JSON, UIImage, etc.\n- model: general object \u2192\u00a0model\n- cleanup: catch-all for stuff at the end (Maybe \u201cpostprocessing\u201d instead?)\nThanks everyone for your patience on this. I have a precious window of time right now to move fast on implementing this, if we can get to a satisfactory design quickly. Please send your reactions and nitpicks!\n. I\u2019ve pushed a draft implementation of this to the structured-pipeline branch. It\u2019s a work in progress, but I think it\u2019s testable if you want to experiment with it.\n. Thanks for this, Ray, Are you using Cocoapods? If so, it\u2019s probably a dup of #24, which is really https://github.com/CocoaPods/CocoaPods/issues/4421.\n. It looks like Cocoapods 1.0b2 fixes this:\ngem uninstall cocoapods\ngem install cocoapods --pre\n(I had to uninstall the existing versions to get the pod command to start picking up the beta.)\nCould you give that a try and let me know if that fixes it for you? Assuming that you\u2019re using Cocoapods, that is\u2026.\n. Great! Close the issue if it works, and keep sending the diagnostics if it doesn\u2019t!\n. Ah, two things: first, there\u2019s a mistake in the README. That\u2019s what I get for editing in place without testing! It should read like this:\nAPI.resource(\"/profile/\").addObserver(self) {\n        [weak self] resource, _ in\n        self?.refreshText(resource.typedContent())\n    }\nI think the problem here is that Swift doesn\u2019t know whether $0 means just the first arg, resource, or the whole (resource,event) tuple. Which is dumb, and I wish they\u2019d fix it. Hmm. Something for the swift-evolution list\u2026. Anyway, code above should fix it, and I'll fix the README when I get a chance.\nSecond thing is that refreshText needs to accept an optional arg, because there\u2019s no guarantee that you actually got a MiniUser:\nfunc refreshText(user: MiniUser?){\n     self.txtView.text = user?.fullName\n  }\nAlternatively, you could test this in the closure (warning: more untested code here!):\n```\n    API.resource(\"/profile/\").addObserver(self) {\n        [weak self] resource, _ in\n        if let user: MiniUser = resource.typedContent() {\n            self?.refreshText(user)\n        }\n    }\nfunc refreshText(user: MiniUser){\n     self.txtView.text = user.fullName\n  }\n```\n\u2026although you\u2019ll probably want to update the UI for a \u201cno user\u201d\u00a0state as well, so usually it makes more sense for refreshText to accept the optional and either update or clear the UI.\nLet me know if that does the trick!\n. Fixed the README. Thanks for the heads up!\nOne of these days, I\u2019ll get around to writing a script to copy all those code snippets in the docs out of a project that makes sure they actually compile. Hard to keep them up to date as the API stabilizes for 1.0.\n. ObjectMapper seems like such a natural partner for Siesta, I\u2019ve heard people talk about it \u2014\u00a0but I haven\u2019t used it myself, and don\u2019t know of any example code.\nCould your problem be as simple as missing parens?\nconfigureTransformer(\"/profile/\") {\n    Mapper<User>().map($0.content as JSON)\n}\nAlso, it\u2019s not clear to me that ObjectMapper works with SwiftyJSON \u2014 but you should be able to pass it a raw dict as parsed by Siesta:\nconfigureTransformer(\"/profile/\") {\n    Mapper<User>().map($0.jsonDict)\n}\n. Ah, yes, welcome to the wonderful world of Swift\u2019s type inference: 80% awesome, 20% wat?! Anyway, glad you figured it out.\nI\u2019m puzzled that this didn\u2019t compile:\nif let user: User = resource.typedContent() {\nIt works for me when I try to construct a parallel case. I\u2019m wondering \u2026 does this compile for you?\nif let user = resource.typedContent() as User? {\nWhat about this one (even though it obviously always returns nil)?\nif let text: String = resource.typedContent() {\n. Hmm, looking a little closer at the ObjectMapper API, I think Siesta is giving you content of type User??. Yuck.\nWould you mind running this check to verify the theory?\nprint(\"--------->\", resource.latestData?.content.dynamicType)\nIf you see Optional(Swift.Optional<MyProject.User>), then bingo.\n(Minor aside: it\u2019s both legal and idiomatic Swift to say if let user = user. The non-optional one shadows the optional one within the if\u2019s body, so you don\u2019t have to define a separate optionalUser.)\n. OK, thanks! I think that\u2019s something I can address in Siesta. I\u2019ll send you a fix on a branch to test when I\u2019ve had a chance to sit down with it.\n. I think I\u2019ve fixed this on master. Give it a whirl if you get a chance, and let me know if you\u2019re still getting the double optional!\n. No worries. Thanks for verifying!\n. It will be in the next beta for sure, though Siesta work is on hold for a couple of weeks for the start of the semester.\n. @o15a3d4l11s2 No, you\u2019ll have to use master for now.\n. This was merged and released over a year ago. If you\u2019re having trouble with double optionals, please file a new issue with a reproducible test case.. The problem is that Swift has no notion of closure identity or comparison: there\u2019s no way for Siesta to know that you\u2019re adding \u201cthe same\u201d\u00a0closure twice, because there\u2019s no such thing as \u201cthe same\u201d closure.\nIf you add an observer that\u2019s an object, then Siesta will prevent dups. But otherwise, it\u2019s up to you to make sure you don\u2019t add redundant observers \u2014\u00a0by adding them in viewDidLoad instead of viewWillAppear, for example.\n. Prompted by this, I added some information about duplicate observers to the API docs. Thanks for the good question!\nAlso, an aside on the code you posted: in Swift, when the last arg is a closure, you can place it as a block after the method call. So instead of this:\nMyAPI.resource('/home').addObserver(owner: self, closure: {\n    [weak self] resource, event in\n    print(event)\n})\n\u2026you can do this:\nMyAPI.resource('/home').addObserver(owner: self) {\n    [weak self] resource, event in\n    print(event)\n}\nYou may already know that, but I though I\u2019d mention it just in case.\n. The owners are about lifecycle, not uniqueness. When the owner goes away, the observer stops observing. When you want to remove observers, you do it by owner. There\u2019s a detailed explanation in the docs.\n\nIs there a use case to adding multiple 'self' owners to a specific resource?\n\nObservers have owners, not resources, so I\u2019m not quite sure what you mean by that. I\u2019m guessing you mean, \u201cIs there a use case for having multiple observers with the same owner?\u201d If so, then sure; in fact, it\u2019s quite common. For example, a view controller might might do this:\nfoo.addObserver(self)\nbar.addObserver(self)\nbar.addObserver(owner: self) {\n    [weak barDisplayerWidget] in\n    barDisplayerWidget?.refresh()\n}\nHere, the VC depends on two resources, so it observes both of them (as a self-owned observer). It also owns a barDisplayerWidget that wants to observe the second resource. All three observers are owned by self, so when the VC is deallocated, Siesta automatically stops sending events to all of them.\nThis also has the advantage that you can remove multiple observers at once:\nfor resource in [foo, bar] {\n    resource.removeObservers(ownedBy: self)\n}\n\u2026which is a common idiom when one VC wants to change which resource it\u2019s observing. There\u2019s an example of this in the sample project.\n. The error you\u2019re getting is because InvalidJSONObject doesn\u2019t have a public initializer. (It\u2019s only meant for client code to detect, not to create.) To do it using the approach you were using, you can make up your own error type:\nenum MyAppErrors: ErrorType {\n    case ResponsesMustBeJSON\n}\n\u2026and then:\nservice.configure {\n    $0.config.responseTransformers.add(\n        ResponseContentTransformer() {\n            (content: Any, entity: Entity) throws -> Any in\n            guard content is NSJSONConvertible else {\n                throw Siesta.Error(\n                    userMessage: \"Cannot parse response.\",\n                    cause: MyAppErrors.ResponsesMustBeJSON)\n            }\n            return content\n        }\n    )\n}\nBut wait! Siesta already has that type checking built in. Siesta infers a content transformer\u2019s expected input type from the parameter\u00a0type of the closure you give, and flags it as an error if the incoming type in the pipeline is wrong. So believe it or not, all you have to do is pass a closure that declares a specific type for the content, but just passes it through unmodified:\nservice.configure {\n    $0.config.responseTransformers.add(\n        ResponseContentTransformer() {\n            (content: NSJSONConvertible, entity: Entity) in   // Note: NSJSONConvertible instead of Any\n            content\n        }\n    )\n}\nAnd because adding a custom ResponseContentTransformer is so common, Siesta provides a shortcut:\nservice.configureTransformer(\"/**\") {\n    (content: NSJSONConvertible, entity: Entity) in\n    content\n}\n\u2026or if you\u2019re willing to lean hard on some Swift type inference magic:\nservice.configureTransformer(\"/**\") {\n    $0.content as NSJSONConvertible\n}\nThat\u2019s all you need!\n\nNote that all the code above lets the default content-type-based transformers do their thing, then errors if something other than a JSON-like array or dict came out the other end.\nIf instead you want to attempt to parse everything as JSON, regardless of content type:\nconfigure {\n    $0.config.responseTransformers.add(JSONResponseTransformer())\n}\nBy default, Siesta applies JSON parsing only to responses with a content type of */json or */*+json. This additional config makes Siesta apply JSON parsing to everything.\nYou want might want to parse even plain text responses as JSON. To do that, pass useDefaultTransformers: false to your Service initializer. (Why? Any transformers you add get appended to ones that are already there. Siesta includes transformers for text, images, and JSON by default. With those default ones in there, the server could return valid JSON with a content type of text/plain, the default text transformer would catch that and turn that into a string, and then the JSON transformer would say, \u201cHey! I\u2019m supposed to get NSData\u201d and give you an error.)\n. Mathew \u2014\u00a0I\u2019m closing this one, but please feel free to keep following up (or reopen if it\u2019s not resolve for you).\n. The Error.Cause structs are not publicly constructable because synthesized struct initializers aren't public (I think).\nThe causes themselves are public (even though their initializers aren't) so that you can do error-specifc recovery. There\u2019s an example of that in the docs.\n. Cookie-based auth in an API (as opposed to a web site) is unusual and somewhat unorthodox, so I wouldn\u2019t want to build special handling for it directly into Siesta itself.\nIf you do need cookie handling, that\u2019s a responsibility that\u2019s best left to the underlying networking library plus your app-specific rules for allowing & storing cookies. You\u2019d add your own beforeStartingRequest hook to add cookie headers before sending the request, then receive cookie headers on receiving the response. That could even make a nice little lib.\nFor examples of the code you\u2019d need to put in the beforeStartingRequest hook, see:\nhttps://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/CookiesandCustomProtocols/CookiesandCustomProtocols.html\nhttp://stackoverflow.com/questions/29596206/how-to-get-cookie-from-a-nsurlsession-with-swift\n. Yes, we often have to make things work well with the APIs we\u2019re given.\nI\u2019ll close this for now, but please do ask if you hit a snag with your Siesta configuration. The basic structure will be something like this:\n``` swift\nservice.configure {\n  addStoredCookiesTo($0.config.headers)\n$0.config.beforeStartingRequest {\n    _, req in\n    req.onSuccess {\n      entity in\n      storeCookiesFrom(entity.headers)\n    }\n  }\n}\n```\n``` swift\nfunc addStoredCookiesTo(inout headers: [String:String]) {\n  // for each stored cookie\n    header[cookieKey] = formattedCookieValue\n}\nfunc storeCookiesFrom(headers: [String:String]) {\n  // parse any cookie headers\n  if newCookieDetected {\n    // store cookie\n    service.invalidateConfiguration() // crucial!\n  }\n}\n```\n. Ah, thanks!\n. Thanks again! Will merge as soon as I figure out why Travis is being wonky\u2026.\n. Hi Tomasz! Nice work on Codebeat! While I\u2019m pleased to get an \u201cA,\u201d I have concerns about drawing attention to a machine-generated quality metric. I had a long email conversation with Marcin Wyszy\u0144ski about this. Here\u2019s what I wrote, edited a bit:\nIt\u2019s nice to have problems flagged \u2014 and Codebeat chooses good ones to flag. I always like things that help me see code in a fresh way, and help me give attention to things I might have missed. However, when a linter / style checker / analysis tool is part of my normal dev flow, it keeps on nagging me with feedback long after that feedback has ceased to be useful.\nFor example, Codebeat flagged NetworkRequest.interpretResponse() and ResourceStatusOverlay.updateDisplay(). I think it was right to flag them. There\u2019s complexity there that deserves attention. However, when I look at those two methods, IMHO they strike the right tradeoff. There are alternatives that would make those methods score better on Codebeat's complexity metric, but they\u2019d be harder to read. Best as is. Flagged, reviewed, approved.\nBut there sits Codebeat\u2019s grade, chastising me, perhaps even making managers or potential users nervous. And thus I suspend my own good judgement and bend the code to the tool. The tool ends up prioritizing the mindless over the mindful, the machine reader over the human reader \u2014 and thus makes me expend effort to make the code worse!\nI\u2019m happy to have issues flagged once for consideration. I\u2019m not happy to have them flagged forever until I bend the code to the style checker\u2019s will. This is a problem even when things are folded into a numeric quality metric\u00a0\u2014 even if that metric currently scores high and makes the project look good! Metrics always draw attention to the things they know how to measure, and thus away from the things they don\u2019t.\nMy wish is for a code analysis tool which flags newly introduced issues for review. Possible ways to do this:\n- A Github hook that flags each PR with new potential quality issues it introduces.\n- A hook that translates new Codebeat flags into Github issues for the developers to review and consider.\n- A Codebeat-managed review queue.\nAny of those things would be quite helpful to me as a developer, and I\u2019d happily integrate them into Siesta! They\u2019re not pressuring me to suspend my good judgement, but still helping see things I might not have considered.\n. I will be eager to beta test it when it\u2019s ready!\n. I'm closing this for now, but please do let me know when you have a \u201cnew quality flags introduced by pull request\u201d feature ready to try.\n. Isn't it always?\n. @korzonek I\u2019m excited to try it! But I don\u2019t see any of the pull request functionality. There\u2019s no \u201cpull requests\u201d tab for Siesta on Codebeat, and nothing about it in the project settings.\n\n. Well, it\u2019s Siesta I\u2019d be interested in using Codebeat for, so please do let me know if and when it\u2019s available for open source projects!\n. Thanks again.\nOK, I concede. I am actually going to run the docs through a spell checker.\n. The short answer is no there isn't \u2014 though there clearly should be, and I'm wondering why I haven't hit this already. I think the answer is that in the APIs I've used Siesta with, all non-GET requests have returned either full entities or subsets thereof.\nSiesta should do this, and it should be in the 1.0 release. Putting it on the list. \n. Your diagnosis is exactly correct, and yes, you should be able to add your own request(\u2026) flavors in exactly the manner of Siesta\u2019s own. The reason I\u2019ve hesitated to expose FailedRequest is simply that I don\u2019t want to make a public promise about that type existing, i.e. I don\u2019t want code relying on being able to do if request is FailedRequest { \u2026 }.\nMy thought was to leave FailedRequest an internal type, but instead expose some sort of public factory method \u2014 probably a static method on Request \u2014\u00a0to create them. I\u2019d happily accept a PR for that if you want to take a crack at it!\n. Right, no static members on protocols in Swift.\nHmm. I\u2019d say make it an instance method on Resource then. Although there\u2019s no backreference from the request to the resource, it does seem kind of right to ask a resource for an associated request in all cases. Maybe.\nLet\u2019s try that and how it smells.\n. Glad you like Siesta!\nAt a very quick glance, I\u2019m guessing the problem is that S3 isn\u2019t sending a content type for the image:\n$ curl -I https://d3lpseitn39rtz.cloudfront.net/uploads/images/admin/ZdqrV5RKwKugOKu3HpeH7w.jpg\nHTTP/1.1 200 OK\nContent-Length: 231103\nConnection: keep-alive\nDate: Sun, 03 Apr 2016 19:32:02 GMT\nLast-Modified: Wed, 23 Mar 2016 09:36:37 GMT\nETag: \"a7247e54aa9aadbcd94ef8dfcdee311e\"\nAccept-Ranges: bytes\nServer: AmazonS3\nAge: 72\nX-Cache: Hit from cloudfront\nVia: 1.1 f8375738cc4acf5f5ea814a0efd10a17.cloudfront.net (CloudFront)\nX-Amz-Cf-Id: gEPwvVZf_Uhu0o16kHL-aTfqLX8gSryLfkerjS0HJ2uTh-vXCN8F-Q==\nBy default, Siesta does not parse the data as an image unless the server says it\u2019s an image. You need to either:\n- configure your server to send a content type, which on S3 I think maybe you have to do when uploading the file (?), or\n- give RemoteImageView a Service that\u2019s configured to always apply image parsing no matter what the content type is.\nLet me know if that isn\u2019t the problem, and we can dig in a little deeper.\n. I\u2019ll close it once we've tracked down the problem and verified that it's not a Siesta issue. So let me know!\n. Thanks for the follow up!\nNext round of Siesta work, I may add a little logging on the content type matching that will help the next person to encounter a problem like this more easily track the problem down.\n. A transformer can do arbitrary processing (as long as it follows Siesta\u2019s thread safety conventions), and it can return any sort of data structure you like.\nThis is therefore really more of a Swift question than a Siesta question.\nHere\u2019s a quick and dirty sketch to get you started:\n```\nservice.configureTransformer(\"/cars\") {\n    (content: JSON, _) in\nlet users = content[\"users\"].arrayValue\nfunc findUser(id: String) {\n    users.filter { $0[\"id\"].string == id }.first\n}\n\nreturn content[\"cars\"].arrayValue.map {\n    Car($0, findUser($0[\"user_id\"].string))\n}\n\n}\n```\nThat\u2019s a naive implementation that I just typed out, totally untested. You\u2019d have to get it working, determine whether the O(n\u00b2) user lookup is a performance problem, figure out how you want to handle missing users (e.g. throw an error), etc.\n. Yes, this is a bit of a headache with the current configuration approach.\nFor right now, you can use the configuration flavor that takes an arbitrary predicate to make more fine-grained matches. For example (just a sketch, untested):\nswift\napi.configureTransformer({ $0.path?.rangeOfString(\"/products/\\\\d+$\", options: .RegularExpressionSearch) != nil }) { \u2026 }\napi.configureTransformer(\"/products/filters\") { \u2026 }\napi.configureTransformer(\"/products/*/market\") { \u2026 }\n(Ugh, that Foundation regex API. Hmm, Siesta could \u2014 should \u2014 make NSRegularExpression implement ConfigurationPatternConvertible.)\n\nThe most obvious better solution is a \u201cfirst match wins\u201d policy in the manner of a routing engine, but that doesn\u2019t work because configuration blocks aren\u2019t mutually exclusive: you may want to have several independent config passes match the same resource.\nThe \u201cno more transforming, we\u2019re done\u201d approach would solve this immediate problem, but feels like it won\u2019t generalize well, and will lead to more special cases.\nA slightly more generic version of it I\u2019ve considered would allow you to give configuration blocks a key, where a new config block replaces one with the same key if it exists:\nswift\napi.configureTransformer(\"/products/*\", inSlot: .ModelTransform) { \u2026 }\napi.configureTransformer(\"/products/filters\", inSlot: .ModelTransform) { \u2026 }  // replaces first one\napi.configureTransformer(\"/products/**\", inSlot: .FastTimeout) { \u2026 }  // does not override first one\nThis would help #32 play out right. The implementation details get messy, though, and I\u2019m not sure it\u2019s all that easy to understand.\nAnother approach would be to create configuration groups, within which the first match wins:\nswift\napi.configurationGroup { group in\n  group.configureTransformer(\"/products/filters\") { \u2026 }\n  group.configureTransformer(\"/products/*\") { \u2026 }\n}\nAgain, though, messy details and maybe hard to follow.\n. This should now work if you pull the bleeding edge from master:\nswift\napi.configureTransformer(\"/products/*\") { returns Product }\napi.configureTransformer(\"/products/filters\") { returns Filter }  // overrides previous; order matters!\napi.configureTransformer(\"/products/*/market\") { returns Market }  // not matched by either of previous 2 rules\n. Making this circuit work as you describe, where it retries automatically and you never see the auth failure, isn't really workable with the Siesta API as it stands.\nYou can do something close to what you want, if:\n1. you\u2019re willing to see the auth error first and then see the refreshed data, and\n2. you only want to retry load requests (not POST etc).\nHere\u2019s a sketch:\nswift\nconfigure {\n  $0.config.beforeStartingRequest { resource, request in\n    request.onFailure { error in\n      if isAuthError(error) {\n        doAuthorization() {\n          resource.loadIfNeeded()\n        }\n      }\n    }\n  }\n}\nThat would clearly need cleaning up and building out. Hopefully it helps.\n. (And I should clarify: isAuthError() and doAuthorization() are hypotherical methods that you would write, and doAuthorization() calls the given closure on success.)\n. Auto-reuath and auto-refresh would certainly have widespread appeal. @VDKA, I could imagine something along those lines. Instead of request.pause(), I\u2019d first investigate some framework-provided mechanism for letting beforeStartingRequest replace the request wholesale.\n. I think #98 resolved this. If it didn\u2019t, feel free to reopen.\n. If you want a SwiftJSON JSON object instead of a dictionary, you need to configure that. See the example project: \nhttps://github.com/bustoutsolutions/siesta/blob/master/Examples/GithubBrowser/Source/API/GithubAPI.swift#L23\nhttps://github.com/bustoutsolutions/siesta/blob/master/Examples/GithubBrowser/Source/API/GithubAPI.swift#L86-L88\n. Thanks for this. Can you give a little background on the problem it\u2019s solving?\nI\u2019d thought is should be an instance method in order to leave the door open to future API support for asking which resource a response came from, which this change rules out. However, the use cases for that are fuzzy and might be achieved through other means as well. So let me know if making this static solves a concrete problem for you.\n. Right \u2014\u00a0in the first example, the very reason the request fails is that there is no resource on which you could call a failedRequest() instance method. That seems decisive.\n. Hmm, guessing the bug is here:\nhttps://github.com/bustoutsolutions/siesta/blob/db78e2c90d6c1c4dbfee9efe998a42d05013d4b7/Source/Support/DebugFormatting.swift#L91\nSiesta tries to log the response as pretty-printed JSON, then falls back to default string conversion. It\u2019s possible that try? doesn\u2019t catch the Obj-C exception that dataWithJSONObject throws.\nCould you try commenting out that whole JSON formatting section in lines 89\u201394 and see if that fixes it?\n. Holding off on Swift 3 changes until Swift 3 itself has stabilized a bit \u2014\u00a0especially for when all the API renamings are done and dust has settled on the new named parameter defaults.\nAt that point, we\u2019ll do a complete pass for Swift 3 deprecations and breakages. The deep changes will probably necessitate separate Swift 2/3 branches, but waiting to see where all the details of the release land before deciding that.\n. Also, @nissaba: once Swift 3 has stabilized a bit and we\u2019re ready to cut a Swift 3 branch of Siesta, I would gladly welcome pull requests to fix these sorts of issues!\n. @majorgilles: It took me ages to get to this, so certainly no apologies needed about not testing after only 3 days!\n. @majorgilles Likely you\u2019ll have a chance to take a look? Would love a sanity check before merging.\n. Thanks, @majorgilles. I\u2019ll take that as a sufficient smoke test to merge the PR. Let me know if you hit any hitches with the new functionality after your server is back on its feet.\n. I\u2019m going ahead and merging this \u2014\u00a0but @enricode, I\u2019d still appreciate your feedback on whether this solves the problem you mentioned here.\n. Wow, thanks for taking on this huge task! This is fantastic. I\u2019d been wanting to do this for a long time, but had been hoping somebody who knows more about OS X development than me would take it on. Thank you!\nI have a new Siesta release coming soon, hopefully next week. My release strategy with this PR would be to get 1.0 beta 7 out the door first, then merge this and add OS X support in beta 8.\nMain thoughts below; I\u2019m also adding some minor notes in the code.\n\nUIApplicationDidReceiveMemoryWarningNotification is the showstopper. Low memory events are the only thing that ever clears Siesta\u2019s cache. That\u2019s mostly fine given how Siesta runs in real apps in practice, but even on iOS I\u2019d like to add the ability to limit the cache size \u2014\u00a0and with it disabled on OS X, the cache will just grow without bound. I filed #31 to fix this, but before this PR came in, it\u2019s been low priority. Once I have 1.0 beta 7 out, I\u2019ll get to work on implementing it.\nLong story short: I\u2019ll make sure that this PR and fix for #31 go in the same release.\n\nI\u2019m surprised that the typealias approach works as well as it does. I assumed that ResourceStatusOverlay would have to be totally iOS-specific. Have you sanity checked that your code does in fact work property on OS X? If so, fantastic and wow.\nI\u2019m on the fence about how the typealiases should be named. The Swift API guidelines encourage us to move away from the prefixes like BOS in favor of module namespacing. So\u2026\n- Maybe drop the prefix altogether? An alias named Image is effectively named Siesta.Image for other modules. That\u2019s not so bad.\n- Maybe an underscore to emphasize that it\u2019s internal: _Image? But then people will be nervous about using an internal class.\n- Maybe UINSImage? NSUIImage? Clearer. But yuck.\nWhatever name we choose will show up in docs and autocomplete, and I don\u2019t want users to get confused by what they see.\nIs there a common practice you\u2019ve seen in other Swift frameworks that target both OS X and iOS?\n\nRe Nocilla: I\u2019ve been thinking about dropping it. It\u2019s buggy and full of race conditions, and the maintainer still hasn\u2019t accepted that ancient PR. If you have other HTTP mocking suggestions that work on both platforms, I\u2019m all for it! That shouldn\u2019t hold up this PR, but let me know if you have a preference.\nIn the meantime, if you submit a PR against my Nocilla PR for the OS X support, I can merge it.\n. The BOS prefix only shows up on the Obj-C side of Siesta. Or should, anyway.\n\nUIKit classes continue to hold their prefix for instance\n\nThere\u2019s a swift-evolution proposal to remove the NS prefix from many of the Foundation classes, and I suspect others frameworks may go that direction.\n\nI realise there is quite a bit of work left.\n\nYes, but you\u2019ve done a tremendous amount, and things are already looking pretty good here.\n. Tests now pass on OS X.\n@onekiloparsec, hopefully this is enough to get you off and running with trying Siesta out in your OS X. It\u2019s essential, I think, to have a least some basic validation that things work on an actual project before publishing this.\nOther things left to do:\n- [ ] Decide on fate of BOS prefix & fix it\n- [ ] Fix #31\n- [x] Merge C\u00e9dric\u2019s Nocilla changes into Paul\u2019s fork\n- [x] Add OS X to Travis (will be a pain)\n- [ ] Get beta 7 out the door first\nAm I forgetting anything?\n. Think I have CI working, but Travis doesn\u2019t see this PR. Sometimes closing & reopening a PR fixes that. Trying that, so don\u2019t freak out\u2026. [Addendum: it was just the merge conflict blocking it.]\n. Yes, I suspected it might be hard to get that code working on both platforms at once. Thanks for giving it a try.\nI had loose plans to separate the UIKit stuff into a separate module \u2014\u00a0either within this repo or as a separate library altogether. In addition to the cross-platform reasons, it will also make things better for SwiftPM. I already have some sketches of splitting the purely logical state transition stuff in ResourceStatusOverlay apart from the UIKit stuff, so there could eventually be separate iOS and OS X UI helpers that share some core logic.\nHowever, all of that is a big, messy change, and I don\u2019t want this PR to snowball. How about this revised plan?\n- For this PR, just bracket all of ResourceStatusOverlay with #if os(iOS). No UI helpers on OS X for the time being.\n- This should remove the need for all of the cross-platform typealiases and extensions except for MemoryWarningNotification. Move the MemoryWarningNotification typealias into WeakCache.swift and delete the rest of Platforms.swift. (It will still be there in the history if we want to resurrect it in the future.)\n- At that point, this PR would be ready to merge.\nFollow-ups would be:\n1. Fix #31 \n2. Reorganize project/directory structure to platform-specific UI code from core\n3. Split state transition logic out of ResourceStatusOverlay\n4. Write OS X resource status UI helper\nOf those, I think 1 and 2 should be done before releasing a beta with OS X support, but 3 and 4 could be done at leisure.\n. > I made the changes, which means basically getting rid of all the OSX work I did at first. But that's life. :-)\nHopefully some of that investigation you did does pay off in the future, though, when building OS X UI helpers.\n\nI deleted the OSX tests target as well, as it doesn't make real sense to keep all typealiases just to run the tests (I must say I haven't read much the details of the tests, just that UIViews are used).\n\nNo, we should keep the OS X tests! I definitely don\u2019t want to have an untested target in the project. \nThe only usages of UIView in the specs were as dummy objects (something that can\u2019t be transformed by JSON, for example). You should be able to replace all of those with some arbitrary class from Foundation that wouldn\u2019t normally show up in a response entity.\nFeel free to revert 0ccfb2f & force push to fix that.\n\nI also had to keep the typealias for (NS/UI)Image, because it is used in the ImageResponseTransformer.\n\nRight, of course.\n. OK. I didn\u2019t want to remove that commit from here because I don\u2019t want to mess up your local git history \u2014 but once 0ccfb2f is gone, I can fix up the usages of UIView in the specs if you want.\nWe\u2019re close!\n. I think we\u2019re there! Given that feedback on the pipeline API has been slow and this has moved fast, I\u2019m going to cut a release with this instead and move the pipeline stuff back to a subsequent beta.\n\nYour scheme renaming was a good idea. I checked some other multi-platform projects, and they do the same. I renamed the targets too, and got the travis file updated. (Don\u2019t look in there. It\u2019s horrid.)\n\nFound a race condition in one of the specs. Don\u2019t know if it\u2019s a timing difference on OS X, or if it allows more simultaneous connections per host by default and that's what caused it. Regardless, one spec was failing about 3% of the time on OS X. Now fixed.\nI\u2019m still seeing sporadic build failures from Travis \u2026\u00a0but I blame Travis itself. Its Xcode environment has all kinds of weird timeout issues. Failed builds almost always pass if I rerun them. It\u2019s possible this might be an issue with Siesta and not Travis, but I never have these problems locally.\n. And we\u2019re there! Merci bien @onekiloparsec for getting this through!\n. Siesta provides an interface but not an implementation for this.\nThis is exactly what EntityCache is for, and it does basically what you describe but one better: the model layer immediately gets the cached data (if any), and then gets a \u201cnew data\u201d notification if a network call succeeds. In the offline state, you\u2019ll see both the cached and the \u201cno connection\u201d error on the Siesta resource. Your UI can decide for itself what to do with that \u2014 for example, it could show the \u201cno internet connection\u201d error in a little banner at the top, then show the cached data underneath.\nAlas, EntityCache is only a protocol for now. I plan on providing a public EntityCache implementation baked into Siesta, but I want to get the API changes in #32 vetted and released first, because the protocol will likely change when it\u2019s done.\nHope this helps!\n. Thanks, @alecgorge! If you have a chance to try these API changes this week, please let me know if things do or don\u2019t work well for you. I\u2019d love to gather feedback on these changes before putting them in an official release.\nI made the diagrams in OmniGraffle. It\u2019s great for all things boxes & arrows.\n. Ha! Good catch. It\u2019s such a delicious mistake, I\u2019m half tempted to leave it as is! But better that it actually make sense. Thanks for the fix.\nOut of curiosity, where did you find out about Siesta? There\u2019s been a sudden influx of interest in the last few days, and I have no idea where it came from.\n. Oops: PersistentCache.swift shouldn\u2019t be there at all. Looks like it got accidentally re-added during the big OS X PR merge, but the project still compiles locally & with Carthage because PersistentCache.swift isn\u2019t in the Xcode project. Fixing.\n. This isn\u2019t much information to go on. The as! NSDictionary is curious; you shouldn\u2019t need that. Otherwise, there\u2019s nothing obviously wrong with what you\u2019re doing.\nThe way to diagnose this problem is to ask Siesta to tell you exactly what request it\u2019s sending, and make sure it\u2019s the request you mean to be sending:\nSiesta.enabledLogCategories = [.Network, .NetworkDetails, .ResponseProcessing]\n\u2026or for the full firehose:\nSiesta.enabledLogCategories = LogCategory.all\nI\u2019m marking this closed since it\u2019s not (yet) an issue with Siesta, but please feel free to keep commenting on this issue for help. And please do file an issue if you do find something that\u2019s a specific bug, shortcoming, or feature request!\n. Mystery to me. I've never encountered this.\nOne shot in the dark: try removing Info-*.plist from the Siesta Xcode project \u2014\u00a0not the files themselves, just the references in the project file. They\u2019re included in Source/Support.\n. You might want to report this to the Cocoapods and Jenkins teams. It sure sounds like the problem is on one of their ends.\n. Aha! Looks like you might be hitting this: https://github.com/CocoaPods/CocoaPods/issues/3638\n\u2026and if so, looks like a fix is in the Cocoapods pipeline.\n. Merging this PR, but project watchers, please feel free to provide feedback even after it\u2019s closed. (That\u2019s the point of making it a PR!)\n. Hi, akaralar! Thanks for working on this!\nIt doesn't feel right that this change needs to be so intrusive, and it definitely shouldn\u2019t require duplicating all that code from the core project. In principle, it should be able to wrap entirely around the API that\u2019s already there.\nIt seems like all of that traces back to an effort to create the SignalProducer before starting the request. What\u2019s the rationale behind that? Could you do something like this instead?\n``` swift\nextension Request\n    {\n    public func rac_signal()\n        -> SignalProducer\n        {\n        return SignalProducer\n            {\n            [weak self] observer, disposable in\n        self?\n            .onSuccess\n                {\n                entity in\n                observer.sendNext(entity)\n                observer.sendCompleted()\n                }\n            .onFailure\n                {\n                error in\n                observer.sendFailed(error)\n                }\n\n        disposable.addDisposable\n            { req.cancel() }\n        }\n    }\n}\n\n```\n. > I couldn't be sure what happens if you initiate a request(and start it implicitly), and you subscribe to it later somewhere after the request is finished\nSiesta goes through some internal gymnastics to ensure that Request exposes no external difference in hook behavior that depends on whether the underlying network call is newly created, in progress, or already completed. From the docs:\n\u201cThere is no race condition between a callback being added and a response arriving. If you add a callback after the response has already arrived, the callback is still called as usual.\n\u201cRequest guarantees that it will call any given callback at most one time.\u201d\nThat means you are perfectly safe letting the request start first, then adding callbacks later in rac_signal. I think this clears up the problem?\n. (Where by \u201cclears up the problem,\u201d I mean that Signal is all that\u2019s strictly necessary for either requests or resources, and not SignalProducer?)\n. Let\u2019s validate the design first, then worry about the tests. (And thank you for even thinking of them; people so often forget to!)\n. This is looking good! Nice work. The reactive extensions seem like just the right amount of effort, and they make sense as I read through them. I\u2019m excited for people to be able to try them.\nThe way you\u2019ve done the memory handling for ReactiveObserver looks good to me. That\u2019s a thing I was concerned about, but your solution makes sense: keep the Siesta memory model, and let the user decide who the owner is.\nThe travis stuff you should revert to the way it was. Alas. You\u2019ll notice that the travis builds take just a ridiculous amount of time (over an hour!) if we have the CI server do the full Carthage build, so downloading the manually prebuilt libraries is an unfortunate but necessary workaround. Before merging this, I\u2019ll upload a Carthage prebuild with the reactive stuff in it. (I am all for CI replacement suggestions, BTW. Travis regularly times out and has to be rerun.)\nI noted a few other very minor things in the code.\nWe\u2019ll eventually want to add specs, but I think we could publish this with an \u201cexperimental\u201d label first, after I get this next beta out.\n. Things are looking good! Merging.\n\nRedundant builds for tvOS and watchOS of all dependencies were slowing down the process.\n\nEven without them, it\u2019s still pretty slow. Regardless, I\u2019d like to keep any more fiddling with Travis out of this PR. CI improvements shouldn\u2019t hold up this good work here. I\u2019ve uploaded prebuilt binaries that include the reactive libs, and it\u2019s now passing.\n\nThere is something that causes me discomfort with this implementation. Right now the type has to be supplied when calling rac_signal on the resource. Is there a way to get that type from the response transformer or anywhere else so that if the response transformer is changed, we automatically get the correct type?\n\nUnfortunately not until Swift\u2019s type system is up to the task, which will be post-Swift 3. Alas. See this question in the FAQ for more info.\n. Good point, this would be a nice convenience.\n. Thanks for the heads up! Able to reproduce, and looks like making the podspec explicitly ignore the Info*.plist fixes the problem.\n. Just released 1.0-beta.8a, which should fix this. Let me know if it doesn\u2019t.\n. Hi Andrew! I can\u2019t merge these changes yet, because absoluteString becoming optional in 2.3 is a breaking change, and the lib thus won\u2019t work under 2.2 when we make that leap.\nAs per the plans for 2\u21923 migration, I\u2019m going to cut a 3.0 (and maybe 2.3) branch only after finalizing API changes in 2.2. I\u2019ll hold this PR open for reference until then.\n. @andrewloyola I think the moment has come. Care to rebase / redo the Swift 2.3 migration off the current master? If you send the PR, I\u2019ll cut a swift2.3 branch from it.\n. @andrewloyola Thanks!\n. Yeah, this is a well-noted limitation of Siesta as it stands \u2014\u00a0it really does assume your API is RESTful, at least in GET requests having that special status. If you\u2019re using, say, a SOAP API, then you\u2019re out of luck.\nNot all the machinery is there for this problem to be solved, but it\u2019s close. The solution will be to apply service-wide configuration that modifies the NSURLRequests for all resources before they go out. You\u2019d then specify resources with virtual URLs like /foo/bar, and they\u2019d get transformed into, say, POST with <stupidEnvelope><resource>foo.bar</resource></stupidEnvelope>.\nThis machinery for request warping & wrapping is up soon on my dev list, but not there yet.\n. Mulling this over a little more, I think the right way to handle this is with a custom NetworkProvider implementation that rewrites and then forwards the URLRequest. To Siesta, your API looks restful; it\u2019s only in the network layer that you rewrite GET /widget as POST /nastySoapEndpointOrWhatever. This is more or less the Siesta version of what @onekiloparsec mentioned.\nThat should be quite robust, and is supported with Siesta\u2019s API today.\nI\u2019ll leave this issue open as a reminder to write an example of this \u2014\u00a0or as a request for someone else to!\n. @xtravar That sounds a lot like the abstraction Moya provides over Alamofire? I considered that, but it seemed like solving too many problems at once.\nEven without that, it\u2019s pretty easy with the Siesta API as it stands to make your own URL-free wrapper for a specific service. The GithubBrowser example project does a light version of this: you get resources with calls like GithubAPI.repository(ownedBy: \"bustoutsolutions\", named: \"siesta\"), no knowledge of URL structure needed in app code.. > Quick perusal of Moya's readme seems that it's not cache-observer based\nRight, right, sorry \u2014\u00a0I meant that what you were describing sounded to Siesta as Moya is to Alamofire, not that Moya is what you are looking for.\nPerhaps, though, you're thinking of something more general? Building Siesta, I originally considered making it two separate projects: an abstract observable cache with a graph structure, and a REST data provider that would one possible implementation of a data provider protocol. The data provider would allow arbitrary mapping between cache entries and requests, and the cache would have no knowledge of underlying request structure (HTTP or otherwise). This would open all sorts of interesting applications. It would also provide the oft-requested ability to make an index request update cache entries for both the whole collection.\nLovely as that sounds, it\u2019s a much deeper problem, and I decided it was better to bite off a tractable piece that served my concrete needs, and perhaps generalize from that later. One thing I love about Siesta is that it\u2019s small \u2014 and even so it still untangles enough tricky problems that I\u2019m glad it doesn\u2019t take on more.\nI'd love to compare notes on the grander vision, although my semester starts in a couple of weeks and I'm wrapping up some project work before then, so I probably won\u2019t be a very good correspondent!. This sounds suspiciously like #78. Have you tried the 1.0-beta.8a patch, just released?\n. Hmm, I should really update the README, shouldn\u2019t I?\n. Setting expirationTime to infinity will prevent loadIfNeeded() from ever fetching new data if it already has data available. Feel free to reopen this issue if that doesn\u2019t work for you.\n. Service.baseURL has one and only one purpose: it is the starting point for Service.resource(_:) (with the unlabeled arg).\nYes, you can cross host boundaries with Resource.relative(), exactly as you suggest. You can also open arbitrary URLs with Service.resource(absoluteURL:). In fact, you can create a Service with no baseURL, and always use resource(absoluteURL:). The Service spec will answer a lot of questions about the details.\n. gh-pages is all generated; fixed in README.md in master\n. Thanks!\n. Curious \u2014 this sounds exactly like #82, which beta 8a should have fixed.\nPerhaps it\u2019s somehow a problem with the Alamofire subspec. Would you mind checking whether you still get this error with just the core Siesta pod?\npod 'Siesta', '>=1.0-beta.8a'\n. Looks like this is a bug in CocoaPods: https://github.com/CocoaPods/CocoaPods/issues/5718\nRemove the >= and it should work:\npod 'Siesta/Alamofire', '1.0-beta.8a'\n(Note: you may have to clean your project in Xcode after updating.)\nLet me know if that fixes it for you, and I\u2019ll update the README.\n. The reason the cache keys are opaque is that I want to leave room for Siesta to include more than just the URL in the cache key in the future. For example, you might want to make it a digest of (URL + secure auth token) so that you can securely cache data for multiple users on one device.\n\nSo, when that request comes in, the url would be for a single article, not the issue that the article was originally requested in.\n\nThis is a sticky situation. The one-to-one relationship between URLs and resources is baked pretty deeply into the cache, so storing something with one key and retrieving it with another certainly does break the mold.\nI pondered making each EntityCache responsible for generating its own keys. Doing that gets complicated, but you make a compelling case for it:\n\nI would want to be able to transform the EntityCacheKey into an array of keys just before we write to the cache (the issue url and all the article urls). It might be handy at that point to convert from urls to a key type I can specify, so my cache isn't in the business of parsing urls.\n\nI suspect many users would like to use a structured database as a cache store instead of the \u201craw bytes on disk\u201d approach that the current API assumes. I\u2019ll poke at this when I find some time, and when I do, I\u2019ll call on you to try whatever I come up with and see if it makes sense.\n. Yes, it seems we\u2019re thinking along very similar lines! I\u2019d imagined the protocol looking like this:\n``` swift\npublic protocol EntityCache\n    {\n    associatedtype Key\n// Called on main thread.\n// Returns optional so cache can opt out.\nfunc key(for resource: Resource) -> Key?\n\nfunc readEntity(forKey key: Key) -> Entity?\nfunc writeEntity(entity: Entity, forKey key: Key)\n// etc\n}\n\n```\nThis is what makes sense from the outside: a cache should know what kind of key it expects, and be responsible for creating it. Is this something like what you\u2019re picturing?\nThe problem is all in the implementation, and it\u2019s due to Swift\u2019s limitations: once EntityCache has an associated type, it becomes very difficult to work with it. (For example, Swift disallows the type [EntityCache].) I ventured a couple of steps down this path, but the Pipeline code got messy fast, so I went into \u201cduck and cover\u201d mode until somebody made me think it\u2019s a good idea.\nYou\u2019re making me think that now.\n\n\nIs there support for staleness in the EntityCache?\n\nYes. Entity has a timestamp property. If your cache restores it properly, Siesta will respect it exactly as if it has always been in memory from the beginning.\n\nBut what happens when a known resource is cleared from the in memory cache? Is the EntityCache informed?\n\nWhen an unused resource is evicted due to memory pressure, the cache doesn\u2019t hear about it \u2014 and I don\u2019t think there\u2019s any reason it should.\nWhen you explicitly clear resource content with Resource.wipe() \u2026 this is tricky, and I\u2019m not completely confident it works the way it should. I\u2019d appreciate your thoughts on it.\nThe usual situation for calling wipe() is that you\u2019ve just changed some configuration that will give different content next time the resource is loaded, e.g. changing authentication. Here\u2019s what a Resource.wipe() does now:\n- It cancels any outstanding requests.\n- It clears latestData and latestError.\n- It notifies observers of this change with a .NewData(.Wipe) event.\n- It loads whatever is cached, which may trigger a .NewData(.Cache) event if there is a cache hit.\nThe assumption behind that last one is that if you\u2019ve changed your auth (or other configuration) so that requests give different results, you\u2019ve also changed the cache so it gives different results. For example, if you\u2019re wiping due to auth changes, then the cache implementation takes an auth token \u2014 and when you reconfigure the auth header, you always reconfigure the cache alongside it.\nThat\u2019s how it works in my one project in the wild that uses EntityCache. However, this feels confusing \u2014 and maybe even dangerous, if you don\u2019t think to make sure your cache implementation takes auth into account, or don't think to keep auth headers and cache params in sync. Thoughts?\n. Got inspired, and put up an implementation of this and #90 on the structured-cache-keys branch. @jordanpwood, if you have a chance, give it a whirl!\n. Thanks for kicking the tires! Having passed your sanity check, I\u2019ll promote it to a PR to encourage further review.\nThe thing where you see cache misses for each child() and withParam() step bugs me too, and is on my list. The problem is that right now, resources try to load their content from the cache as soon as they\u2019re instantiated. I think instead that they should do it on the first read of latestData and/or the first call to addObserver(). Not sure whether first, second, or both would be least confusing. Hmm.\nOn wipe(), my thinking is starting to clarify a bit. For forcing a new request on the next resource load, there\u2019s already invalidate(). The purpose of wipe() is not just to say \u201cplease remove the cache entry,\u201d but rather to say \u201cconfig or context has changed in a way that changes the meaning of the load request\u201d \u2014\u00a0with change of auth being the primary example. To that end, wipe() not only does not remove the entity from the EntityCache, but initiates a new cache load after the resource is wiped. I think that\u2019s right. It\u2019s up to you to make sure that your cache takes into account the same things that would change what the server returns, and if you\u2019re not doing that properly, you\u2019d be clued into the problem when you see the same data immediately pop back out of the cache after a wipe. This is all clear in my head, but I\u2019m not sure it\u2019s making sense as I type it out.\n\n\nFor my API, I can't really use an auth token as part of the persistent store, since they expire if they aren't used frequently enough.\n\nYeah. If you want to support caching on a single device, and you want to protect one user from being able to view another\u2019s cached content, then the options I see are:\n- include some secure digest of the login as part of the cache key (e.g. bcrypt(login+password)), or\n- have the server provide a randomly generated encryption key, perhaps tied to the specific device, that remains the same over longer periods of time.\nI used the latter approach on a project once, and it worked nicely. On that project, though, offline access was not a requirement; if you want offline, only the first approach works (I think?). You lose your cache when your password changes, but oh well \u2014\u00a0it\u2019s just a cache.\n. Hmm, the calls to dispatch_sync are what I\u2019d imagined people would do in your situation. (It\u2019s only three calls, one for each of the three required methods of EntityCache \u2014\u00a0or four, if you want to write a custom updateEntityTimestamp.) I\u2019d hesitated to muddy the waters with this, and in theory, the overhead of dispatch_sync should be negligible. In theory.\nIn practice, since you\u2019re the second person to ask for this, seems like it\u2019s a reasonable thing to add.\n. You can create a service without a baseURL. See this comment for more info.\nI\u2019d recommend doing that, then providing a convience method for each microservice:\n``` swift\nfinal func coolResource(path: String) -> Resource {\n    return resource(absoluteURL: coolBaseURL).child(path)\n}\nfinal func userResource(path: String) -> Resource {\n    return resource(absoluteURL: userBaseURL).child(path)\n}\n```\nThen you can set up coolBaseURL and userBaseURL however you like.\nYou\u2019ll lose the nice thing Siesta does to prevent redundant leading slashes; that is, you\u2019ll need to decide either to put a trailing slash on coolBaseURL or a leading slash on path, but not both. Otherwise, this will work exactly like baseURL.\nHmm, you know, it would be nice for Siesta to provide Service.resource(baseURL:path:) as a convenience. I\u2019ll keep this issue open as a reminder to add that.\n\nI dont want to have a separate instance of the web service object for every service.\n\nIf the microservices link to each other, then yes, you want just one service to guarantee resource uniqueness. (That is, if you use Resource.relative() to traverse from https://cool.com/cool-service/xyz to https://cool.com/user-service/users/1, then you\u2019d need a single service instance to ensure that you have a single resource for /users/1.)\nOtherwise, there\u2019s no problem with having multiple ones. Service doesn\u2019t have a particularly large per-instance overhead.\n. Jazzy bug!\n. Filed Jazzy bug here: https://github.com/realm/jazzy/issues/635\n. Ah, Swift type inference. It\u2019s awesome \u2026\u00a0until it can\u2019t figure something out.\nI\u2019m not familiar with Argo, but I\u2019m guessing the problem is that its global decode(_:) method takes a type that is too broad for Swift to infer the input type of your transformer closure.\nIn these situations, my usual approach is to add explicit types until it works (or I get a more meaningful compile error), then trying removing them one by one to see which the compiler can infer. So maybe try something like this:\nswift\nself.configureTransformer(\"/\\(self.APIVersion)/objects/*\") {\n    decode($0.content as NSJSONConvertible) as AstronomicalObject\n}\n\u2026or even the fully explicit version:\nswift\nself.configureTransformer(\"/\\(self.APIVersion)/objects/*\") {\n    (content: NSJSONConvertible, entity: Entity) -> AstronomicalObject\n    return decode($0.content)\n}\n(Or should the content be JSON already? Not sure what Argo expects.)\nThis still may not work, but hopefully you\u2019ll at least get a more helpful compiler error.\n. @onekiloparsec Did you ever get this working? If you did, let me know and we can find a place to drop an Argo example in the docs and/or Extensions/.\n. Down a Swift type rabbit hole!\nI\u2019ll have a chance to dig into this later this week. It certainly deserves attention \u2014 you won't be the last to hit it. If in the meantime you have time to prepare a minimal example project to reproduce the problem, that would be quite helpful.\n. OK, digging into this\u2026\nThis doesn\u2019t work because the trailing closure doesn\u2019t use any inputs and doesn\u2019t return anything, so Swift can neither infer the input nor the output type of your transformer:\nconfigureTransformer(\"/\\(APIVersion)/objects/*\") {\n  //\n}\nBack to your original Argo example, there was clearly some problem going on where both Siesta and Argo\u2019s use of generic left Swift unable to figure out what set of types would make the whole closure compile. I therefore tried isolating just the Argo call, like this:\nlet content = NSData()\nlet x: AstronomicalObject = decode(content)\n\u2026which gave a much more helpful compile error: decode(\u2026) returns an optional. Aha! Armed with that knowledge, I tried this, which compiles:\nconfigureTransformer(\"/\\(APIVersion)/objects/*\") {\n    decode($0.content as NSData) as AstronomicalObject?\n}\nThis version, which is more verbose but perhaps clearer about the structure of things, also compiles:\nconfigureTransformer(\"/\\(APIVersion)/objects/*\") {\n    (content: NSData, _) -> AstronomicalObject? in\n    decode(content)\n}\nI only verified compilation here, not correct behavior. Let me know if this unties the type knot for you!\n. > the resource observer closure isn't called either\nThis is a sign of something more than just contentTransformer trouble. Turn on the detailed logging and work through that line by line. It\u2019s a little hard to wade through, but it will tell you exactly what\u2019s going wrong.\nself.hd5980!.addObserver(owner: self) { (resource, event) in\n    print(\"resource \\(resource.typedContent())\")\n}\nObviously the editor shouldn\u2019t crash (!), but typedContent() will only work when its return type is constrained by its context. It means \u201cconditional downcast to the type I expect.\u201d That\u2019s sort of the opposite of what you want; you\u2019re looking for \u201cjust show me whatever type you have.\u201d Try latestData?.content instead of typedContent().\n. Glad you worked it out! It sounds like the network issue is outside of Siesta, but \u2026\u00a0at the very least, once the Swift 3 adventure is over, I'm keen to improve the readability of Siesta\u2019s logging to help make these sorts of problems easier to diagnose.\n\nThe only additional change was to set the type of content in the closure to NSDictionary rather than NSData\n\nSounds like Siesta\u2019s default JSON parsing is still in the pipeline. No harm in that, although depending on what Argo does under the covers, it might parse a snerch faster if you let it do the parsing to. (Or maybe Argo uses NSJSONSerialization too and it\u2019s all the same!)\n. Thanks to @annicaburns for nudging me into thinking about the Realm question way back when, and to @jordanpwood for the push to actually deal with this and not hide under the rock of opaque keys!\n. Agreed, this is a bug.\nIt should also arguably convert spaces to +, although %20, while inefficient, is at least harmless.\n. Just spent some time poking around myself, and I agree that this is the best way. I\u2019m surprised that NSURLComponents doesn\u2019t take care of this automatically.\nOn further thought, it\u2019s best to do exactly as you did and leave spaces encoded as %20.\n. Please take a look at #98. It may be what you\u2019re looking for. That pull request is open for user experimentation and feedback, so let me know what you think!\n. Awesome! Thanks, @jwardle. I was waiting for second party confirmation that #98 isn\u2019t broken before merging it. If you\u2019ve tried it and yellow smoke didn\u2019t come pouring out the vents, then I\u2019ll go ahead and merge it.\n. Merged #98. Closing this, but it\u2019s new functionality in need of more eyes \u2014 so please send questions, bugs, and enhancement ideas early and often!\n. It seems like there are several separate problems entangled here:\nWhat to do when latestData is nil?\nThere are many circumstances in which you\u2019ll get a resourceChanged() notification with nil latestData:\n- when you are added as a new observer of a not-yet-loaded resource (ObserverAdded), or\n- when you are observing a not-yet-loaded resource and a new load request starts (Requested), or\n- when that first load request is cancelled (RequestCancelled) or fails (Error), or\n- when the resource is wiped (NewData(Wipe)).\nTherefore you should not be using NewData(Wipe) to detect when latestData is nil. Instead, it\u2019s best to just ignore the event parameter and write your code to handle nil data whenever you see it.\nIn other words, get rid of the ! in this code (in most circumstances, you should avoid using ! in Swift):\ngEventCategories = resource.latestData!.typedContent(ifNone: [])\n\u2026and instead do this:\ngEventCategories = resource.latestData?.typedContent(ifNone: [])\n\u2026or better yet, use Siesta\u2019s shortcut:\ngEventCategories = resource.typedContent(ifNone: [])\n\u2026so that you always get [] even if latestData is nil. Then your observer can look more like this:\n```\neventCategoriesResource.addObserver(owner: self)\n    {\n    [weak self] (resource, _) in\n// Always called. Write the code so that it handles\n// gEventCategories being empty or having data.\n\ngEventCategories = resource.typedContent(ifNone: [])\n\n// Always called. Write showErrorMessage so that it\n// clears the error if message is nil.\n\nshowErrorMessage(resource.latestError?.userMessage)\n}\n\n```\nNote the lack of conditionals.\nBut who triggers the load?\nThe most common approach is to call resource.loadIfNeeded() either in viewWillAppear or immediately upon observing a new resource.\nIn your case, though, it looks like you also want to trigger a refresh immediately on wipe. You could do this:\n```\neventCategoriesResource.addObserver(owner: self)\n    {\n    resource, _ in\nif resource.latestData == nil\n    { resource.loadIfNeeded() }   // Note loadIfNeeded() instead of load() to prevent redundant requests\n}\n\n```\n\u2026or, if you\u2019d also like to automatically refresh the data when it gets stale, you could even do this:\neventCategoriesResource.addObserver(owner: self)\n    {\n    resource, _ in\n    resource.loadIfNeeded()\n    }\nYou could even reuse that closure and attach it to lots of resources.\nOK, so what is the event parameter for, then?\nIt\u2019s primarily for optimization when UI updates are expensive \u2014\u00a0but they rarely are, so in most circumstances, the right approach is to first get your code working without examining event, then optimize only when you\u2019re proved you have a performance problem.\nThe events section in the user guide explains this in more depth. And as that section says, a lot of branching on event is a code smell in Siesta apps.\nLet me know if this answers your question.\n. Swift 3 is officially released. Switching new work to master!\n. It depends on whether you are using CocoaPods, Carthage, or a manual build. Please see the instructions under \u201cBreaking Changes\u201d in the release notes for beta 10:\nhttps://github.com/bustoutsolutions/siesta/releases\nPrompted by this question, I\u2019ve updated the README to include these instructions as well:\nhttps://github.com/bustoutsolutions/siesta#installation\nTry that and let me know how it works for you.\n. CocoaPods does t show prerelease/beta in its search results, even if there is not a 1.0 release yet. An unfortunate shortcoming. But there is a Siesta page on the site: http://cocoapods.org/pods/Siesta\nDo let me know if you get it working so that we can close this issue. \n. Glad it\u2019s working!\nThe simplest quick and dirty way to get a status overlay into your view hierarchy is the way the example project does it: leave it out of your storyboard altogether, instantiate it directly in code, and then use embedIn and positionToCoverParent to add it to your view hierarchy.\nThe reason to do this:\n@IBOutlet weak var statusOverlay: ResourceStatusOverlay!\n\u2026is if you want to customize the overlay with your own look & feel instead of the default baked-in one. To make that work, add a generic UIView in your storyboard and then give it a custom class of ResourceStatusOverlay:\n\nNote that the module name would be SiestaUI if you\u2019re building with Carthage.\n. 1.0-beta.10 is a Swift 2 release.\nThere is no Swift 3 release yet, because the example code in the docs has to be updated & I need to write up some migration instructions. Use master until there\u2019s an official release.\n. Also, I\u2019d like to hear some smoke test success from users before I declare a Swift 3 release, so please let me know about how it works for you \u2014 and if there are migration difficulties I should include in the docs.\n. There has been a swift3 branch for some weeks, but it merged to master when Swift 3 went GM per the release plan.\nI\u2019m leaving this issue open, so hopefully others will find it if they\u2019re confused!\n. > What should I have in my podfile?\n\npod 'Siesta', '>=1.0-rc.0'\nor \npod 'Siesta' , :git => 'https://github.com/bustoutsolutions/siesta.git', :branch => 'master'\n\nBoth should work. As Jordan pointed out in another thread, rc.0 incorrectly says that Siesta requires iOS 9, but that\u2019s the only issue I know of at the moment.\nYour compile error is because you aren\u2019t giving Swift enough information to infer the input type of your transformer. What is .dictionaryObject and what type is it supposed to come from? How would Swift know that from context? (The error message about \u201cExpressibleByStringLiteral\u201d is completely misleading. It\u2019s a terrible message.)\nThe way to debug a type inference problem like this is to switch from $0 to an explicitly declared entity input:\nservice.configureTransformer(\"/highlight-feed/simple/\") {\n    (entity: Entity<WhateverInputTypeDictionaryObjectIsSupposedToComeFrom>) -> HighlightFeed? in\n    if let dic = entity.content.dictionaryObject,\n       let ret: HighlightFeed = try? Unbox(dic) {\n        return ret\n    }\n    return nil\n}\nIn any case, I don\u2019t think it\u2019s a Swift 3 compatibility issue \u2014\u00a0but please open a new issue if you determine that it is.\n. The official Swift 3 release is out and it looks like it\u2019s working for people, so I\u2019m closing this.\n. I was getting weird runtime errors about missing symbols from the platform libs when tried to run on iOS 8, and wanted to get something working quickly for the majority of users out there.\nI\u2019d love some assistance getting it to run on iOS 8. Would you be willing to poke at it a bit and see what happens if you change Siesta to target it?\n. As I look back at that error message, one extra bit of info that might be super helpful: the errors I saw were when I tried to run tests on an 8.x simulator, and it looks like they happened when it tried to load the Alamofire framework \u2014 which just dropped 8.x support.\nThe tests test the optional Alamofire integration, but of course Siesta doesn\u2019t require AF. It\u2019s quite possible that Siesta itself will support 8.x just fine, and it\u2019s only the tests that bomb.\nLet me know what you find!\n. @jordanpwood Wanting to get an official Swift 3 release out the door, so I put this together. It resolves #111. No Travis on iOS 8 for now, but when I manually comment out the AF stuff, the specs do pass on 8. So you should be GTG.\n. You bet. \u2615\ufe0f is my vice if you\u2019re looking to raise a glass to Siesta. Your work is not done, though: this release needs lots of sanity checking after the big Swift 3 migration! So LMK how it goes.\n. Ah, indeed. Good catch! Fixed now on master.\n. The rc.0 podspec erroneously requires 9.0 even though Siesta itself works with 8.0 (see #112). This is fixed on master:\npod 'Siesta', git: 'https://github.com/bustoutsolutions/siesta.git', branch: 'master'\n\u2026and the fix will go out in the next official release.\n. Curious. Your code certainly looks good. This may be a bug introduced by the performance tuning in rc.1.\nWhat output do you get with LogCategory.enabled = [.stateChanges, .observers]?\nAny chance you can create a self-contained example class/project that reproduces the issue? I realize that\u2019s a tall order since you won\u2019t want to expose your API, but if you can, I\u2019ll point the debugger at it and see what\u2019s happening.\n. From the logs, it certainly looks as though nothing except Siesta retains overlay, and since it\u2019s registered with Siesta as being self-owned, it gets deallocated.\nThanks for sharing the code! I got your project to build (your Cartfile seems to be missing Gloss, BTW?), and got the app running. Cool undertaking.\nI\u2019m afraid I wasn\u2019t able to reproduce your issue, though: it seems to work perfectly even after I upgraded Siesta to rc.1: I can log in, see gists, and view individual ones, with the loading indicator working just fine the whole time. I tried both in the simulator and on a device, building with both debug and production configurations. Double checked that I was running Siesta 1.0-rc.1. Couldn\u2019t get it to fail.\nI wonder if I have your latest code? I investigated where a ResourceStatusOverlay might ever be deallocated, and found this:\nclass DirectedViewController : UIViewController {\n  ...\n  let overlay: ResourceStatusOverlay = {\n    let o = ResourceStatusOverlay()\n    o.displayPriority = [.ManualLoading, .Loading, .Error, .AnyData]\n    return o\n  }()\n\u2026which pretty clearly ties the lifecycle of the overlay to its enclosing VC. Perhaps a recent change made observer a computed property or otherwise no longer a let, weak, more locally allocated\u2026?\n. Well, congratulations, you found a bug in Swift! It\u2019s a nice sticky one, too.\nPlease upvote that bug to let Apple & the community know we care!\nIn the meantime, #121 should work around the bug. @kl, I verified it with your project, but would you be willing to double check yourself that the fix works as you expect? Point your Cartfile at the issue-120 branch, and let me know. I\u2019ll wait to hear from you before I merge.\n. Merged to master. Thanks, @kl!\n. Siesta\u2019s only real smarts here are knowing which URL and URLComponents methods to use \u2014 it\u2019s not always obvious \u2014 and wrapping them in a less clunky API. The actual escaping is all in Foundation.\nThe relative path logic you\u2019re talking about all comes from URL(string: relativeURL, relativeTo: parentURL), and that you can certainly call from any thread. All of the other path resolving code is here, here, and here. (The params are the messiest to deal with.) Hope that helps!\n\nIf you find yourself wanting to resolve URLs throughout your code, then beside the threading issue, there\u2019s the problem of having many bits of code tightly coupled to your API\u2019s URL layout. I don\u2019t know if this is relevant to your situation, Jordan, but I\u2019ll mention an approach that can work nicely in case it\u2019s useful to either you or to others:\n1. Make a domain-specific struct that allows navigation within the logical structure of your problem domain, and doesn\u2019t know anything about URLs.\n2. Let your Siesta API wrapper map from that struct to Resources, hiding all URL structure from the rest of the app.\nFor example:\n```\nenum Foot: String {\n    case left\n    case right\nvar other: Foot {\n    switch(self) {\n        case left:  return right\n        case right: return left\n    }\n}\n\n}\nstruct ShoeDescriptor {\n    var model: String\n    var foot: Foot\n// Here we're effectively navigating from one resource to another,\n// but doing no URL operations \u2014\u00a0and nothing that touches\n// Resource, so it can run on any thread. Note that we could\n// do this with resource.relative(\u2026), but this way crisply\n// distinguishes changing foot from changing shoe model.\n\nvar counterpart: Shoe {\n    return Shoe(model: model, foot: foot.other)\n}\n\n}\n```\n\u2026and then:\n```\nclass MyAPI {\n    ...\n    func shoe(for descriptor: ShoeDescriptor) -> Resource {\n    // Actual URL structure fully encapsulted in MyAPI\n\n    return service\n        .resource(\"/shoes\")\n        .child(descriptor.model)\n        .child(descriptor.rawValue)\n}\n...\n\n}\n```\nThe GithubBrowser example uses Repository this way.\n. Fair enough, and no apologies needed! I always overexplain for these sorts of best practice questions in the hopes that it will be useful in the future to others who are searching for answers. (Speaking of which, you might have useful contributions to this discussion of mocking with Siesta.)\nOK to close this?\n. The README has a comparison with other frameworks, including Moya.\nSiesta does not contain special support for JWT, but has a robust configuration mechanism that lets you provide transparent authentication for a wide variety of approaches. See this section of the User Guide.\nIt\u2019s straightforward to wire a Resource or a Request up to RX. The included ReactiveCocoa extension is a good starting point; similar principles apply. There\u2019s no RX extension included with Siesta, because nobody has submitted a pull request for one yet!\n. Siesta already make this reasonably easy to build yourself. First write a little helper to track multiple simultaneous requests, because iOS\u2019s activity indicator won\u2019t do that for you:\n``` swift\nprivate var requestsInProgress = 0 {\n  didSet {\n    UIApplication.shared.isNetworkActivityIndicatorVisible =\n        requestsInProgress > 0\n  }\n}\nprivate func requestStarted() {\n    requestsInProgress += 1\n}\nprivate func requestCompleted() {\n    requestsInProgress -= 1\n}\n```\nThen you can make an entire Service (or multiple ones!) update the activity indicator automatically for all requests:\n``` swift\nextension Service {\n    func showRequestsWithNetworkActivityIndicator() {\n        configure {\n            $0.decorateRequests {\n                res, req in\n            requestStarted()\n            req.onCompletion { _ in requestCompleted() }\n\n            return req\n        }\n    }\n}\n\n}\n```\nswift\nservice.showRequestsWithNetworkActivityIndicator()\nI think that should do the trick for you? Feel free to reopen this issue if it doesn\u2019t and there\u2019s a missing feature here!\n. @Reedyuk: Thanks for the PR! A good addition. I\u2019ll post some comments over there.\n@Alex293 wrote:\n\nThe problem is that sometimes you have multiple service that you don't own like in RemoteImageView that create it's own service\n\nNo problem:\nswift\nRemoteImageView.defaultImageService.showRequestsWithNetworkActivityIndicator()\n\u2026or for a particular one, if it doesn\u2019t use the default:\nswift\nmyRemoteImageView.imageService.showRequestsWithNetworkActivityIndicator()\n. This is a good point: it does seem like a RequestChain should repeat the underlying request.\nI\u2019d like to drive this out with a use case or two if possible. Can you provide a sketch of what you\u2019re doing?\n. OK, thanks for the use case! That is helpful. Rethinking my thinking on this, you\u2019re spot on: the current behavior is incorrect. I\u2019ll get a fix together, and ping you for a sanity check when it\u2019s ready.\n\nA side note on implementing \u201ctap to retry\u201d\u00a0behavior, which you likely already know, but just in case it\u2019s useful to you or any others reading: req.repeated() does not call req\u2019s callback hooks a second time. In other words:\nswift\nlet request = resource.request(.post)\nrequest.onCompletion { _ in print(\"hello\") }\nrequest.repeated().start()  // will _not_ say \"hello\" a second time\nThis is by design: the contract of Request is that it is a thing that happens exactly once, and has a single outcome that never changes once the request is done. Hooks can and should rely on the fact they they can be called at most once. (Look at #132, for example: repeating already-called hooks would cause requestCount to go negative.)\nBe careful! This:\nswift\nlet req0 = resource.load()\nlet req1 = resource.load()\n\u2026is not the same as this:\nswift\nlet req0 = resource.load()  // request has hooks that update resource state\nlet req1 = req0.repeated()  // repeated request has no hooks\nreq1.start()\nThe latter example will not update the resource state. For that reason, you\u2019ll usually want to implement \u201ctap to retry\u201d by calling resource.load() again, as ResourceStatusOverlay does. If you\u2019re implementing tap to retry for mutating request (POST etc.), then you\u2019ll probably want to pass around some kind of \u201cmake request and handle results\u201d closure that you call twice instead of using repeated().\n(The primary purpose of repeated() is to exist inside a request chain, for doing retries before any hooks get called. Note that inside a chain, the problem above doesn\u2019t exist because hooks attached to the whole chain don\u2019t get called until the chain declares itself done. In other words, the whole chain appears to be a single request. The different with \u201ctap to retry\u201d is that you can see a request fail, and you want to then see a different second outcome. Second outcome implies\u00a0second request implies attaching hooks again.)\n. @jwardle: If you have a minute, would you mind testing #134 and see if it gives the behavior you expect?\n. You could configure withRenderingMode(\u2026) as a transformer at the service level, but I tend to agree that this would be a good thing to be able to include independently on each image view.\nThere are other UIImage methods it seems like people might also want to apply to the downloaded image, such as resizableImage(withCapInsets:) and imageFlippedForRightToLeftLayoutDirection(). Instead of duplicating portions of the UIImage API for each one, RemoteImageView could provide a custom transform-on-set closure:\nswift\npublic var imageTransform: (UIImage?) -> UIImage? = { $0 }\nswift\nimage = imageTransform(imageResource?.typedContent(ifNone: placeholderImage))\n\u2026and then you\u2019d do:\nswift\nsomeImageView.imageTransform = { $0?.withRenderingMode(.alwaysTemplate) }\nHow would you feel about that?\n. Good, let\u2019s do it. I\u2019m keeping new functionality frozen until the imminent 1.0 release is out the door. (Very soon!) Once it\u2019s done, this easy fix can go in the first follow-up release.\n. 1.0 is out. Feel free to submit a PR for this.. This a good and sensible addition. Thanks for sending it!\nReflecting on this more as library code and not just a quick example, there\u2019s one substantial change I\u2019d like to make: it should be an extension to Configuration, not Service.\nInstead of this:\nswift\nservice.showRequestsWithNetworkActivityIndicator()\n\u2026one would do this:\nswift\nservice.configure {\n    $0.showRequestsWithNetworkActivityIndicator()\n}\nThis lets clients draw on the full range of configuration options \u2014\u00a0only showing the activity indicator for certain resources, for example:\nswift\nservice.configure(\"/huge-downloads/**\") {\n    $0.showRequestsWithNetworkActivityIndicator()\n}\nThere are also a few minor questions/fixes. I\u2019ll mark those inline in the code.\n. @Reedyuk: I moved the extension to Configuration. See if it makes sense to you.\nI\u2019m not totally in love with the name showRequestsWithNetworkActivityIndicator. It\u2019s OK, but I am open to suggestions if anybody has a better name. Reactions to either of these?\n```\nautoUpdateNetworkActivityIndicator()  // abbreviation contra Swift guidelines, feels jargony\nuseNetworkActivityIndicator()         // too vague?\n```\n. > to be honest, i think useNetworkActivityIndicator() is good enough\nI\u2019m ambivalent about all the names, so I\u2019ll go with your instinct on this. useNetworkActivityIndicator() it is! Care to make the change yourself, so your name is on the commit?\n\nAlso, i think i was on the right route with decorateRequests, but for some reason my compiler was not working correctly as it was coming up with an error\n\nIt\u2019s the trouble of Swift\u2019s error messages that you can miss by a millimeter and feeling like you\u2019re off by a mile. A downside of rich, strict static type systems.\n. Looks good. Thanks @Reedyuk for bearing with the process and getting this ready for prime time! This will be a nice little bonus in the 1.0 release.\n. There\u2019s a loadingView property which you can point at a loading indicator.\nYou\u2019ll typically want to add the contextually appropriate loading indicator to your layout and bind it when setting up your view hierarchy. (Because loadingView is an IBOutlet, you can do this in a storyboard with no additional code.)\nYou could also subclass RemoteImageView to create the indicator you desire and set the property on view creation.\n. @Alex293: Did this answer your quest? I\u2019m closing this issue, but feel free to reopen it if you find a bug or feature request that\u2019s stopping you from getting it working.\n. You can\u2019t do response[\"access_token\"] because response is an Entity. It is response.content that contains the transformed content \u2014 and that is what will be JSON if you configure your pipeline to make it so. See the API docs for content for more info.\nTo use the JSON, you\u2019ll need to do one of the following:\n(1) Downcast it manually:\nswift\n(response.content as? JSON)?[\"access_token\"].string\n(2) Use Siesta\u2019s typedContent() helper:\nswift\nlet json: JSON? = response.typedContent()  // if you want nil for no content\nlet json: JSON = response.typedContent(ifNone: JSON([:]))  // if you want empty JSON for no content\n(3) Add your own convenience accessor so you don\u2019t have to do that cast all over the place:\nswift\nextension TypedContentAccessors {\n    public var json: JSON {\n        return typedContent(ifNone: JSON([:]))\n    }\n}\n\u2026which then lets you do:\nswift\nresponse.json  // tries to cast response to JSON\nOption 3 is exactly how the built-in jsonDict, text, etc. all work.\n\nresponse.jsonDict is empty\n\nThat happens because jsonDict is looking for a dictionary, but the content is now JSON and not a dict.\n\nHi, first of all great work :) this is amazing.\n\nThanks! Please help spread the word.\n. It is already set to iOS 8 in both the embedded xcodeproj (used by Carthage) and the podspec. The forthcoming 1.0.0 uses AF 4.1 for its own internal testing, and Siesta does not impose any Alamofire version requirements downstream anyway.\nIn other words, this should already work. Can you please describe the problem you're seeing? What Siesta version are you using?\n. > [!] Unable to satisfy the following requirements:\nYou probably just beat the 1.0.0 release propagating to CocoaPods. Give it 15 minutes and try again.\n\nI can install only 1.0-rc.3 version that requires iOS 9+\n\n1.0-rc.3 also supports iOS 8.\n. I believe that\u2019s a limitation of Alamofire, not Siesta. I\u2019m not sure there even is a release of Alamofire that supports both Swift 3 and iOS 8.\n. Ah, IIRC at one point AF 4 did require iOS 9, and I had to update the subspec to match. Either they fixed that or I misremembered. I\u2019ll fix it in 1.0.1.\n. This is an unfortunate but intentional design compromise for Siesta\u2019s JSONResponseTransformer. It may deserve some rethinking.\nFor now, try adding this to your app to signal that you accept NSNull as JSON content:\nswift\nextension NSNull: JSONConvertible { }\n. See \u201cWhy doesn\u2019t Siesta provide a typesafe Resource?\u201d in the FAQ.\nIn the meantime:\nswift\napi.myMethod().onSuccess { entity in\n    let user: MyUserModel? = entity.typedContent()\n}\n(Note also that to get the full benefit of Siesta, you don\u2019t want to be attaching onSuccess() to individual requests, but rather observing the resource.). > What the difference between Request and Resource?\nRead the User Guide, especially the first 4 pages (Resources, Resource State, Observers, and Requests). This will answer a lot of your questions.\nSee also the API docs for Request for info on how it differs from Resource.\n\nI do not like this case, because it could be used lots across the program and will lead to potential duplication and requires changes in many places\n\nIt doesn\u2019t play out so badly in practice, especially if you let Swift\u2019s type inference guide typedContent() for you. See the code in the example project.. > Just running resource.load()when I got the token \ud83d\udc4d\n\nSo basically just letting the request fail then reload stuff when I have the new token.\n\nYes, that\u2019s the way to do it if you want resource observers to first see \u201cno auth\u201d failure, then success:\n\nload() \u2192 observers see loading\nload fails \u2192 observers see \u201cno auth\u201d error\nauth succeeds; load() again \u2192 observers see loading\nload succeeds \u2192\u00a0observers see new data\n\nThe request decorator is what you do if you want the whole auth reattempt to look like a single request from the outside, so that observers / requesters to just wait until the auth attempt succeeds or fails:\n\nload() \u2192 observers see loading\nload fails, but observers still waiting\nauth succeeds, so reattempt request; observers still waiting\nload succeeds \u2192\u00a0observers see new data\n\nIn your example code, where do fetchNewToken(\u2026) and .then come from? Is that another library?. Yup, then there is an issue to resolve here. Siesta uses RequestChainAction instead of more open-ended promises to ensure at compile time that chained requests honor the general Request contract of having exactly one result.\nThat\u2019s lovely if you\u2019re staying entirely inside the world of Siesta requests, but it gives you no simple way to wait on something else (such as a PromiseKit promise) mid-chain. It\u2019s possible to do it by writing your own Request implementation that wraps a promise, but Siesta ought to provide that escape hatch for you. I\u2019ll leave this issue open for that.. You can find mostly working implementation in progress on the simpler-custom-requests branch. I\u2019d love for you to poke at it a little and share your thoughts!\nThere\u2019s no documentation yet, not even API docs, so it may be a bumpy ride. Here are some quick tips to get started:\n\nThe new additions to the public API are here.\nCreate an implementation of RequestDelegate to wrap a promise, OAuth lib, etc.\nThe crucial method to implement is startUnderlyingOperation(completionHandler:).\nEnsure that your implementation eventually calls completionHandler.broadcastResponse(\u2026).\nNote that this does not touch the response pipeline: no transformers, no cache. Whatever you pass to broadcastResponse goes straight to the request\u2019s callbacks, so it\u2019s up to your delegate to put the response in whatever form the rest of your app expects. The assumption here is that whatever external library you\u2019re using does its own processing, and does not just return raw Data, so normal pipeline operations should not apply.\n\n\nUse resource.request(using: myCustomDelegate) to initiate a Siesta request using your delegate. It returns a Request that you can use in request chains, pass to resource.load(\u2026), etc.\n\nIf you get a chance to give it a try, please let me know! I would love to get feedback before publishing the new API.. > I can't get the RequestCompletionHandler.willIgnore to not return true.\nThis means that the Request thinks it has already either received a response or been cancelled. It\u2019s hard to say why this is happening, but it would start with examining whether you\u2019ve already made a call to broadcastResponse before calling willIgnore.\nSynchronously calling completionHandler within startUnderlyingOperation shouldn't be a problem. I verified that this works as I\u2019d expect it to:\n```swift\nResource.prepareRequest(using: DummyRequestDelegate()).start()\nclass DummyRequestDelegate: RequestDelegate\n    {\n    func startUnderlyingOperation(passingResponseTo completionHandler: RequestCompletionHandler)\n        {\n        let dummyResponse =\n            ResponseInfo(\n                response: .success(Entity(\n                    content: \"custom\",\n                    contentType: \"text/whatever\")))\n    print(completionHandler.willIgnore(dummyResponse))  // prints false\n    completionHandler.broadcastResponse(dummyResponse)\n    print(completionHandler.willIgnore(dummyResponse))  // prints true\n    }\n\nfunc cancelUnderlyingOperation()\n    { }\n\nfunc repeated() -> RequestDelegate\n    { fatalError(\"unsupported\") }\n\nlet requestDescription = \"DummyRequestDelegate\"\n}\n\n```\n\nAlso, my real implementation that uses this feature will open a web view and get the user to login so I can get the credentials I need for Siesta's headers. I assume that this non NSURL based request will work in a request chain?\n\nYes, that should work fine, and is a good use of the feature. A more standard approach would be to accept the error and prompt a retry \u2014\u00a0but if you want parts of the UI to just sit there waiting until the user logs in, then what you describe is exactly the way to do it.. > Is there supposed to be a race between the request and the cache hit\nYes, in a word. The .newData(.wipe) is synchronous, but the cache read is asynchronous \u2014 as is the network request, of course. That\u2019s why, after receiving a cache hit, Siesta checks whether the resource already has data and if so ignores the cached data.\nThis means that you can see two different sequences of events depending on whether the network or the cache wins the race:\nCache wins\n1. .newData(.wipe)\n2. .newData(.cache)\n3. .newData(.network)\nNetwork wins\n\n.newData(.wipe)\n.newData(.network)\n(cache hit ignored)\n\nIn real apps, the cache is very likely to beat the network, but I can imagine a mocked network winning. The solution to your problem is to pause the mocked network response until you see the cache hit. That\u2019s something the Siesta specs have to do a lot of \u2014 and unfortunately I had to fork Nocilla to do!. Hmm, on second thought, you could also fix your problem by waiting for .newData(.cache) instead of just .newData(.wipe). Would that ruin the point of your test?. > I didn't realize that I'd get a cached response after a wipe.\nYeah, that\u2019s not obvious, and it took some serious thought to get there. The short of it is that wipe()\u2019s contract is to restore the resource to the state it would be in if it has just been instantiated for the first time \u2014 and resources check the cache on creation.. There are many compelling reasons for this feature or something like it: automatic retry after reestablishing a lost connection, for example, or automatically polling resources while they\u2019re in use.\nIt\u2019s more complicated than just extending the domain of addObserver(\u2026), however. Under Siesta\u2019s memory rules, resources are retained as long as they\u2019re observed \u2014 and if a resource is always observed, then it can never be deallocated.\nWe need a beast that\u2019s slightly different from a ResourceObserver that can:\n\nchoose whether it wants to watch a resource as long as it\u2019s in memory or only as long as it has observers, and\niterate over all resources it\u2019s watching without actually retaining them.\n\nThat\u2019s a big chunk of API design to bite off, so I\u2019ve been deferring it. I\u2019d prioritize it just after having a standard drop-in EntityCache implementation. In the meantime, your decorator approach is a good workaround.. > I've been looking at ways to cache some images in a way so that volatile views (observers) are likely, but not required, to find the image locally. This happens in the reuse (q.v.) of CollectionCells as the user scrolls back and forth; a cell scrolls out of view, gets reused, and the original request is dropped on the floor only to be re-requested when the users reverses the scrolling.\nThis is exactly what Siesta is designed for as it stands, and the GithubBrowser example project contains code that demonstrates exactly what you describe (with table views, even).\nThis issue is about making an observer that can keep watching a resource as long as it is in use by others, but without causing it to be retained forever. For example, such an observer could say, \u201cAs long as anyone is using a \u2018current temperature\u2019 resource, keep refreshing it.\u201d. I\u2019d welcome a PR for this. I\u2019m not sure whether it\u2019s preferable to use base internationalization and have strings files for the storyboard, or just set a localized button title in code.\nOpinions on that?. I\u2019d be fine with exposing a retryButton property for the button itself, much like the current errorHeadline. Would that suit your needs?. Go ahead and submit a pull request for this. I\u2019d be happy to accept it!. Siesta intentionally does not track any relationships between resources. A future major revision might use a more GraphQL-like internal structure for the cache, but that\u2019s a massive undertaking next to Siesta\u2019s simple resource-based approach, so not on the table for now.\nAs Siesta exists, it\u2019s up to you to establish relationships between resources. One strategy would be for anything that observers a child to also observe its parent and trigger a refresh if new data comes in, e.g.:\nswift\nchildResource.addObserver(self)\nparentResource.addObserver(owner: self) {\n  if case .newData = $1 {\n    childResource.invalidate()\n    // Delayed refresh prevents redundant load if multiple\n    // children trigger a refresh on the same parent\n    DispatchQueue.main.async {\n      childResource.loadIfNeeded()\n    }\n  }\n}. Yup, Siesta has that.\n(Feel free to reopen this if that\u2019s not what you\u2019re looking for.). Looks good. Sorry for the slow follow-up \u2014\u00a0and congratulations! This is commit number 1000!\nFixes #131. Fixes #155.. Siesta lets you configure a whole pipeline for each resource and request method. Each chunk of configuration can add, insert, and replace previously configured transformers in the pipeline.\nI added some example to the pipeline chapter of the user guide that demonstrate this. Look for \u201cNote that this method replaces the transformer(s) at the stage you specify\u201d for the relevant text.. @Alex293 is right. The resource(_:), resource(baseURL:path:), child(\u2026), and withParam(\u2026) methods are all specifically designed never to let path parameters bleed into query strings or vice versa, and never to let parameters escape outside of the service\u2019s baseURL. This is a security feature, so that you can do things like resource(\"/items\").child(itemID) where itemID is potentially malicious user input.\nRelative URL handling does not have this protection. It resolves relative URLs much like a browser does, and lets you freely modify the path, query string, and host, or even provide a new absolute URL altogether. This is meant for data that you\u2019ve generated and sanitized yourself, or that was sent from the server.\nFor your example, you could do:\nswift\nlet root = service.resource(\"/\")\nroot.relative(\"./1234567/do-stuff?timeframe=5\")  // note the leading dot\nIf you are using relative and absolute URLs with Siesta, consider using one of the approaches described in the Host Whitelisting section of the user guide.. Keeping doc-wide Obj-C examples up to date is a bit more than this project can take on. Also, many \u2014 perhaps most \u2014 of the examples are for sticky things that require examples are configuration-related, and thus Swift-only.\nThere are a few example snippets on the Obj-C page of the user guide.\nIf there are other specific things you\u2019d like examples of, file issues for them and one of the contributors can add them to that page.. This looks good. Thanks!\nI can imagine someone conceivably wanting to use ResourceStatusOverlay or some derivate in an app extension, but we can solve that problem when we come to it.. Yes, please put together an example project that minimally reproduces the problem.\nDoes the same problem occur with Siesta\u2019s NetworkActivityIndicator?. Thanks for tracking that down, @piv199. I\u2019d say that firing Alamofire.DidResume for a request that\u2019s already started sounds like a bug in Alamofire. Someone should file that with AF.\nStill, it\u2019s reasonable to work around the issue. Does AF provide a way to test whether a request is already in progress before we call resume()?. It looks like we shouldn\u2019t call resume() unless it\u2019s suspended. Would you be interested in taking on the fix, @piv199? You\u2019re in a good position to test it, since you can see the bug happening.. It sounds like you may not be copying / emitting all the frameworks your tests need.\nThis SO question may be relevant:\nhttp://stackoverflow.com/questions/40986082/dyld-library-not-loaded-rpath-libswiftswiftononesupport-dylib. OK. Please do reopen if it seems to be a bug in Siesta.. Olexii, I think you\u2019ll find it awkward to do what you describe. It sounds like an overconstrained problem. You may be better off keeping two separate libs.\nThat said, Siesta can wrap anything that conforms to NetworkingProvider. You basically need to be able to start arbitrary requests given a URLRequest, and call Siesta back when they complete. If you can make your lib conform to that, then you can wrap your lib with Siesta.. Siesta does minimal localization due diligence: it uses NSLocalizedString for its own error messages, and asks HTTPURLResponse for localized messages. However, the localization is not exhaustively tested, and Siesta does not include any localized string files itself. Pull requests welcome!. Awesome! Thank you for taking this on.\nI\u2019ll add a couple of minor project style consistency things in the review notes.\nIt would be great to get regression tests for this. It\u2019s subtle enough \u2014 and easy enough to mess up \u2014 that it\u2019s worth covering.\nI take it that if alamofireRequest.task, then resume() is the correct action to take? If I\u2019m following that correctly, your ?? solution is a nice bit of concise ingenuity. When does nil task even happen, and how is it different from suspended? This question has a bearing on how the specs would be structured.. > I haven't found siesta+alamofire tests at all...\nThe existing tests rerun a large subset of the tests serval times on CI using four different networking provider/setting combinations, making sure that all the different underlying providers result in the same Siesta behavior.\nWe could add a fifth provider to that suite with startRequestsImmediately = false, and maybe that would be a good sanity check, but that doesn\u2019t actually catch the original problem your PR fixes! The reason is that the existing strategy only tests Siesta behavior via the provider, but the bug you found affects underlying Alamofire behavior not exposed through Siesta. So this bug calls for a new regression test in a new file.\n\nI' not familiar with tests you have\n\nIf you give me push access to your pull request, I can drop the test in the right place.\n. I dug into this a bit, and decided that the substantial amount of code it would take to test the fix simply isn\u2019t justified. Sorry for the long delay on accepting this, @piv199, and thanks again so much for chasing the issue down!\nDid you file an issue with Alamofire about the redundant notification? It really does seem like that\u2019s a bug.. The key info in that error message is here:\nexpectedType: Swift.Dictionary<Swift.String, Any>\nactualType: __NSSingleObjectArrayI\nYour transformer expects a dictionary, but it\u2019s getting an Array.\nWhy does it expect a dictionary? Because the first arg to unbox(dictionary:\u2026) is a dictionary, so unbox(dictionary: $0.content, \u2026) means the transformer\u2019s input has to be a dictionary.\nWhy is it getting an array? Presumably because the API returned one, i.e. the JSON the server sent was [\u2026] instead of {\u2026}.. This might be a Swift or Xcode bug, and it might be a configuration problem in your project. Just to be clear:\n\nThe seemingly unnecessary import Siesta in your app makes the problem go away?\nYour API module uses Siesta directly?\nYour app does not use Siesta directly, just API?\n\nHow are you including Siesta: CocoaPods? Carthage? submodule/subproject?\nWhat are your project settings for Build Phases \u2192 Link Binary with Libraries and Copy Bundle Resources?. @BilalReffas: If you are using that refreshTokenOnAuthFailure with decorateRequest(\u2026), as it is in the doc example it comes from, then you are doing it right.\nReusing that single token update request for all the clients is exactly the sort of thing that the Request API is supposed to support: any number of callbacks, added at any time, can safely attach themselves to a request and share the answer. So your approach looks solid to me.\nI\u2019m closing this out, but please do reopen it if you find a bug or design shortcoming.. Thanks for this! It\u2019s the first week of classes for me, so it will be a while before I have time to give it a thorough look. Some quick thoughts:\nI'm not an expert in Rx either, but I strongly suspect it's better to publish a struct snapshot of a resource's state as the ReactiveCocoa extension does instead of making each property its own separate sequence. You\u2019ll often want to write logic that deals with multiple properties strictly in sync with each other, e.g. \u201cif no data and loading\u2026.\u201d\n\nShould subscription on Request implicitly call start() on it\n\nNo. Requests are always started when Siesta returns them. You defer them using request decorators.\nI don\u2019t know about the Driver question. Somebody who knows Rx well should answer that.. These are the things that operate across a service as a whole, but do not cross service boundaries:\n\nthe resource cache\nglobal configure() (i.e. called without a pattern or predicate)\nwipeResources()\ninvalidateConfiguration()\ncachedResourceCountLimit and the eviction of unused resources\n\nIf you want to keep any of those things strictly separate, then multiple services might make sense. It\u2019s not common, but I could imagine situations where it\u2019s the right thing.\nThe first is the really big one. If you want to simultaneously cache two different versions of the same URL to be used in two contexts, then that means two services \u2014 at least separate instances if not separate classes.\nOTOH, if you want to avoid having multiple cached versions of the same resource running around, then keep yourself to a single service. For example suppose your LoginService returns the URL of the user\u2019s profile on successful authentication, so you do this:\nlet profile0 = relativeResource(loginResult.profilePath)\n\nThen suppose you have a UserService and you do this:\nlet profile1 = userService.resource(\"/profile/me\")\n\nNow profile0 and profile1 belong to different services, are separate objects, and thus can potentially get out of sync. If that\u2019s not what you want, then keep it to a single service and configure the special header scheme for auth using path wildcards.. Siesta requires Swift 3. You'll need to change your whole project to use Swift 3 in order to use the latest Siesta. (It's currently not possible to mix Swift versions in a project.)\nThere are old swift-2.2 and swift-2.3 branches if you cannot make the Swift 3 migration now.. Yes, but those compiler errors indicate that your project is not set to use it. Search for information on setting the Swift language version in a Cocoapods project.. Siesta follows the UIKit convention that any time you are looking at shared state \u2014 like a Resource \u2014 you should do it only from the main thread. All observers and callbacks are therefore called on the main thread, and this is not configurable. See the Threading chapter of the user guide.\nIf your resourceChanged is consuming significant CPU time for big responses, that\u2019s a bad code smell. Two possible resolutions:\n\nIf you\u2019re doing intensive processing of a response that all subscribers to that resource will want (e.g. parsing), put that in Siesta\u2019s transformer pipeline, which does run off the main thread.\nOtherwise, use resourceChanged to grab a snapshot of the relevant resource state (your resources do use immutable content, right?), and then spawn a concurrent task using GCD (takes one extra line!) or whatever concurrency approach makes sense for your app.. P.S. Feel free to reopen this if you have a specific, concrete problem that Siesta\u2019s thread model prevents you from solving.. If you just want offline access, then what you are looking for is EntityCache. Note its workQueue property, which is there specifically to support Realm models. Also note that recent Realm versions let you pass models across threads, IIRC.\n\nAs @Alex293 points out, there are some concerns about mixing Realm and Siesta. The fundamental problem is that both can act as an observable cache, and so you end up with two versions of your data competing for canonicity, one in the shape of an API (Siesta) and one in the shape of a database (Realm). Some of the implications:\n\nIf your app observes Realm models instead of Siesta resources, you lose all the benefits of resource state metadata like isLoading and latestError and the associated transition events.\nIf your app observes Siesta resources, then you lose the benefits of using Realm queries \u2014 or at least of knowing when their results change.\nIf your app modifies Realm data locally but observes Siesta resources, you'll have to back-map those modifications to Siesta\u2019s in-memory cache.\n\nAs you describe your project\u2019s problem, it sounds like you could use Realm only as a backing store for EntityCache, and have the rest of your app take a Siesta-shaped view of the world. But there\u2019s really not a one size fits all answer here... You can remove default parsing and apply Siesta\u2019s string transformer if you want to parse all responses for a resource as strings. (See the Pipeline section of the user guide.)\nIn your case, however, where a JSON service is returning a bare JSON literal instead of a dictionary or array, there's a non-obvious but simple solution described in #150.\nIn your case, you want to tell Siesta to consider bare booleans to be valid JSON values:\nextension Bool: Siesta.JSONConvertible { }\n\n(The Siesta. is just for clarity about whose notion of JSON convertibility you\u2019re extending; it\u2019s optional.)\nThis should fix your problem. Feel free to reopen this issue if it doesn\u2019t.. I'm delighted to hear it's working well for you in general!\nI'd certainly need more detail about the problem you're encountering to diagnose it. A project that reproduces the problem is the best, of course. Logs would also be helpful. With sufficient detail, Siesta's logging should say what state those zombie resources think they're in.. @jordanpwood: I lost track of this issue; my apologies. Did you manage to determine if this bug was really a bug or not?. This question is answered here: http://stackoverflow.com/questions/41832911/configure-request-method-for-a-siesta-resource. This is the perpetual problem with memory cleanup events \u2014\u00a0and with NotificationCenter in general, I suppose. There\u2019s not an obvious good answer.\nSiesta does internally listen for a MemoryWarningNotification notification which you could cheat and publish yourself. It is just UIApplicationDidReceiveMemoryWarning on iOS, however, which might send you into thrash mode.\nI\u2019d consider exposing a Service.flushUnusedResource() or similar, if that sounds like the best solution to your problem. Any further insights since you asked the question?. > Having access to something like a Service.flushUnusedResource() would still be my preferred solution.\nIt\u2019s a reasonable request, and easy enough to implement. We\u2019ll need to give a little thought to what it should be called, whether it should be global or per service, and whether it exposes anything it shouldn\u2019t.. In its current form, Siesta thinks that there\u2019s a one-to-one correspondence between URLs and logical resources. You can manually propagate changes as described in https://github.com/bustoutsolutions/siesta/issues/156.\n\u2026or perhaps what you really want is to radically remap a non-RESTful API into a logical structure, as this other person asked? https://github.com/bustoutsolutions/siesta/issues/81\nThe best way to do that is currently to build your own NetworkingProvider that translates logical URLs of your own choosing into the messy requests your real API expects.. I\u2019m closing this assuming that the response above answered your question, but @ishaanSejwal feel free to ask for clarification or reopen if there\u2019s a feature request the links above don\u2019t cover.. Thanks!. @alecgorge: Did you get this worked out? If the approach @dazzz1er describes (or variations on it) did\u2019t get you what you need, and you did in fact find yourself adding a new StateRule, let me know. I\u2019ve toyed a bit with designs that would make StateRule a protocol instead of an enum so as to let people define custom ones, but didn\u2019t have a compelling use case.. Glad to hear it worked out for you! I can imagine ways to generalize it, but I have yet to find a case where generalizing is necessary. Let me know if you do!. Thanks for this! One question above, and then I think we can merge it.. No rebase needed, I think! Just the one code question above.. Thanks, @victorcotap! I\u2019ll merge this once it\u2019s passed CI. Alas, looks like we can\u2019t run the tests on tvOS (because Nocilla doesn't support it) or watchOS (because it doesn\u2019t support tests at all?!) \u2014\u00a0but I'm willing to live with that.\nThanks for seeing this through.. @xuaninbox Please see the checklist at the top of #28. This is essentially waiting for community members who are actually using Siesta with tvOS to report back on whether it\u2019s working, and to send PRs. Please comment on that issue, let us know what is working and what is not, and if you had to tweak anything, please send a PR!. I'd love to hear about your project! I'm rarely actually in the Bust Out offices (mostly remote), but drop me a note and we can set up a meeting at Corner Coffee. My first name @ bustoutsolutions.com.. Since this thread has turned into a discussion of multipart encoding, which is an HTTP feature and not Siesta-specific, I\u2019m closing this issue. Please not, however, that I would happily accept a pull request for a multipart encoding helper in the spirit of the JSON and form encoding helpers in this file.\n@Alex293, thanks for helping walk Toxa through this.. @juarezjaramillo If you're inspired to do a little extra work for the community, I\u2019d encourage you to submit a PR as described above! Don't hesitate to open a PR for rough work in progress, or even just your code slapped in there with lots of dangling questions; I'd be happy to work with you to generalize it and make it Siesta-ready.. Siesta doesn't deal with certificate validation at all. This is something that the underlying network layer handles. That mean you\u2019ll need to debug the problem at that level: either URLSession (aka NSURLSession, the Siesta default) or Alamofire if you\u2019re configuring Siesta to use it instead. This Stack Overflow question might be helpful, for example.\nOnce you have a URLSessionConfiguration that properly ignores the self-signed certificates, you can pass it as the networking: parameter when you create your Siesta Service.\nP.S. You might gently suggest to your test team that they use Let\u2019s Encrypt instead of a self-signed cert. Less danger of \u201cinsecure by accident\u201d that way!. That's very nice! You're right, I doubt that Let's Encrypt handles local domains \u2014 but limiting the server trust to specific hosts as you're doing reduces the risk of it causing a vulnerability. Thanks for sharing your nice code. . The configuration docs in the user guide answer this question:\nhttp://bustoutsolutions.github.io/siesta/guide/configuration/#configuration-that-changes. Thanks Jordan!. To understand why your AuthSessionController() gets deallocated as soon as viewDidLoad() finishes, take a look at the memory management section of the Siesta user guide.\n(And thanks @jordanpwood! \ud83d\udc4f). Good to hear that it\u2019s working on tvOS! Thanks for letting me know. I\u2019ll check that box off on #28. Are you using Carthage, Cocoapods, or neither to include Siesta?. This is an unfortunate but necessary effect of how Cocoapods handles submodules. While SiestaUI is a separate Swift module with Carthage and SwiftPM, with Cocoapods Siesta and SiestaUI all get compiled into one big Swift module.\nThe warning is harmless, but AFAIK there's no way to work around it.. I was wrong above! As it turns out, there is a simple workaround. This is now fixed in Siesta 1.2.0.. @erenkabakci, I\u2019d say your solution is a good one if the problem is that your service API surface is getting too large. You\u2019ve managed to keep only a single Service instance per API, but (1) split initialization code into multiple files and (2) not expose all those methods at once. Clever!\nI\u2019m not sure the typealias is buying you anything. If you define an extension on a typealias, it also applies to the original type:\n```swift\nclass Foo { }\nprotocol Bar {\n  func bar()\n}\ntypealias FooBar = Foo\nextension FooBar: Bar {  // extending FooBar, not Foo\n  func bar() { }\n}\nlet f = Foo()  // f is a Foo and not a FooBar, but...\nf.bar()        // ...this still compiles\n```\nI may well be missing something about your approach, but I think you could remove one layer of indirection by keeping your underlying Service subclass internal to an API module\u2026\n```swift\ninternal class MyApiClient: Service {\n  // Notice that static let is the Swift-preferred way to create singletons.\n  // (Unlike Java, this does guarantee unique initialization, even across threads.)\n  static let instance = MyApiClient()\noverride init() {\n    super.init()\n    generalConfiguration()\n    userServiceConfiguration()\n    paymentConfiguration()\n    //.....\n  }\n}\n```\n\u2026then adding conformance to a public protocol:\n```swift\npublic protocol UserServiceClient {\n  func userData() -> Resource\n}\nextension MyApiClient: UserServiceClient {\n  func userServiceConfiguration() { \u2026 }\n  func userData () -> Resource { \u2026 }\n}\n```\n\u2026and publicly exposing the same singleton via different public protocols:\nswift\n// Protocols don\u2019t (yet) allow static members, alas,\n// so this needs to be a free global function\npublic func userServiceClient() -> UserServiceClient {\n  return MyApiClient.instance\n}\n(Or just keep things simple and make it a variable instead of a function:)\nswift\npublic let userServiceClient: UserServiceClient = MyApiClient.instance\n(Closing this for bookkeeping purposes, but feel free to continue the conversation.). Summer, probably June. Right now the end-of-semester dust is just starting to clear. (The students sure did great projects!). Hi @jrmsklar, and thanks for suggesting this! I have several concerns about attaching the full HTTPURLResponse to RequestError. Here they are, in order of decreasing importance:\n\n\nDuplicated, possibly inconsistent information\nRequestError already has an entity property that exposes most of the same data (though not the URL). The app\u2019s transformer pipeline can and should transform errors, including the metadata in the entity. Siesta\u2019s Entity itself normalizes headers to make them case-insensitive.\nThis means that with the addition of the raw HTTPURLResponse, RequestError would contain two separate and possibly conflicting versions of the response headers, mime type, etc. I can imagine somebody getting very confused about whether to use error.entity.header(forKey: foo) or error.httpResponse.allHeaderFields[foo] \u2014\u00a0and even more confused about the fact that they can contain different data and exhibit different behavior even with the same data.\nAll of this smells of leaky abstraction.\nA partial solution would be to make everything exposed by RequestError and Entity be a computed property that delegates to an underlying RequestError \u2014 just as you\u2019ve done with the status code. However, this would make response transformers much more difficult to write, and exacerbate the problems below\u2026.\n\n\nMutability\nRequestError is a struct (as is Entity). This is crucial to Siesta\u2019s API design:\n\nBoth the transformer pipeline and EntityCache need to be able to pass them safely across threads.\nResource exposes them as read-only properties, and thus since they\u2019re structs they can\u2019t be mutated in place. This helps Siesta guarantee that observers are notified about any changes to resource state.\n\nHTTPURLResponse is an open class with mutable fields. It thus breaks all of the above.\n(Aside: these concerns are why Siesta urges you to use only immutable or struct data in for Entity content.)\n\n\nMemory weight\nThis is minor compared to the above, but I\u2019m slightly concerned about HTTPURLResponse\u2019s memory weight, mostly that [AnyHashable : Any]. (At least it doesn\u2019t hold the full response body \u2026\u00a0I think?)\nThe memory weight is fine when it\u2019s an ephemeral object that disappears after a single response, but Siesta can potentially hold large numbers of errors over a long period of time. That\u2019s not what HTTPURLResponse was designed for. I\u2019d want to double check memory usage before using it this way.\n\n\nI did originally consider designing the API this way. These concerns are why I decided against it.\nSorry to pour cold water on this idea! It seems to me that RequestError holding only the URL would have none of these problems.\nI\u2019m curious: how would you use the URL? Your need for it suggests there may be some underlying unmet need in Siesta\u2019s API.. > I'd like the to have access to the URL in order to log it when handling API response errors.\nThat does make perfect sense.\nAdding a url property sounds fine to me, and I see little harm in it. And like the other RequestError properties, I see no harm in making it var: because it\u2019s a struct, you can\u2019t still mangle a Resource\u2019s error in place, and there\u2019s no interrelationship with other properties that the struct needs to manage.\nIt\u2019s not obvious at first, but url must be optional. Some apps use RequestError to signal that it was not possible to form a valid URL / resolve something to a valid resource, so there may not always be a URL to associate with the error. (This is the same reason that Resource.failedRequest(\u2026) is static. See #50.). @jrmsklar and @jeffaburt: Hello, and sorry for the very slow turnaround on this! I see you've been maintaining your own fork; I hope my delay hasn't caused your project distress.\nThis innocent-looking property opened a little a can of worms for me. It occurred to me that it\u2019s not sufficient to set url only when we receive an actual HTTP response; the property should be set for any RequestError associated with a resource. (For example, pre-request errors such as unencodable strings or malformed JSON objects do not have an associated server response but did come from an identifiable URL.)\nIt then occurred to me that the property should be set not only when request hooks and resource observers receive the response, but throughout the response pipeline. Why should RequestError have a different shape during pipeline processing than after? And it shouldn\u2019t be the responsibility of a transformer to set it, so shouldn\u2019t the pipeline itself set the URL property after every transformer, just in case the next transformer needs it?\nAt this point, the reasoning seemed to be getting out of hand, and the implementation got mildly messy:\nhttps://github.com/bustoutsolutions/siesta/compare/error-url-property\nThat's not terrible, but it smells funny to me. I\u2019m passing the resource URL around all over the pipeline code, only to have transformers ignore it 99% of the time. And if we follow this reasoning, shouldn\u2019t successes also have a URL property? That means it\u2019s a property of Entity. But that undermines the whole idea that Entity represents the state of a resource decoupled from how it arrived. Separations of concerns are crumbling left and right \u2014 all in the name of logging\u00a0URLs.\nThis is where I decided to put the brakes on.\n\nThe way Siesta is designed, it would make more sense for transformers, observers, and hooks alike to all get the URL either by capturing it from context or by receiving it as an input than for it to be passed in the response.\nIt would be helpful to know a little more about the problem you\u2019re trying to solve. So, questions for you:\nYou said this was for logging errors? Are you logging them via an onFailure hook? A resource observer? What does that code look like?. Hmm, that is a compelling and clarifying example. Thanks for taking the time to share it!\nAlthough you\u2019re logging only errors, I can imagine scenarios where one would also want the URL for successes (e.g. logging all requests made). In this context, it would make less sense for url to be a property of Entity or RequestError than for it to be a parameter to process(\u2026).\nI\u2019m not thrilled with making the url a centerpiece of the pipeline API, however. That runs against best practices, and I have a gut feeling (which I haven't fully worked out) that it fundamentally breaks the pipeline\u2019s separation of concerns.\nOn reflection, this is probably yet another compelling reason for implementing what @Reedyuk suggested in #154. The basic idea is that you could configure observers that receive events only as long as a resource is still in memory, while not causing that resource to be retained indefinitely. That hypothetical non-retaining observer API would certainly send observers the resource in question, which I think would solve your problem.. The good reason is \u2026\u00a0none at all.\nI\u2019d welcome a pull request! Some design questions:\n\n\nWhat kind of entity should it return? Entity<Data> with zero-length data? Or Entity<Void> to help code not accidentally parse an empty response?\n\n\nHow does this interact with the transformer pipeline? Should Siesta take special measures to prevent transformers from operating on HEAD responses?\n\n\nRequest currently guarantees that any request that calls onSuccess will also call exactly one of onNewData or onNotModified. I\u2019d like to preserve that guarantee. Since a HEAD doesn\u2019t actually return any data, onNewData seems like a bit of a misnomer \u2014\u00a0but I tend to think that we should interpret it as meaning \u201cthere would be new data if you made a GET request,\u201d and thus interpret HTTP response codes exactly as we do for the other methods. Thoughts on that?. Good question. This had never even occurred to me! I'd always imagined Siesta operating within apps.\n\n\nThe real constraint is not that all operations happen on the main thread specifically, but rather that all operations for a given service and all of its resources happen on the same thread. I know very little about XPC. Can it guarantee that your code is consistently called on the same thread / GCD queue? (Or if not, can you use GCD to single-queue operations yourself?)\nFor the more common case of people writing apps, I don\u2019t want to lose that main thread precondition.\nOne approach would be to give every Service instance an immutable \u201ccorrect thread\u201d\u00a0property that records the thread the Service was created on, but (1) I'm not sure there\u2019s a well-defined way of checking thread equality and (2) passing the preferred thread everywhere Siesta needs to check it could have nasty ripple effects.\nAny thoughts?. Of course. Resource.relative(_:) and optionalRelative(_:) are there for exactly this purpose.\nIf you run into trouble working HATEOASly, Stack Overflow with a siesta-swift tag is a good place to ask \u201chow to\u201d questions \u2014\u00a0and of course feel free to file a Github issue if you find a bug or a gap in functionality.. One possibility: You are calling self.invalidateConfiguration() in the onSuccess callback for the token refresh, and there might be a race condition between that callback and the request chain in refreshTokenOnAuthFailure continuing. \nIf that isn't it, try turning on all the Siesta logging and make sure that your token refresh is succeeded, that you're getting a new token from it, that the configuration gets invalidated before the request is repeated, etc.. Siesta configures a JSON parser in the transformer pipeline by default. Turn that off (per the instructions in that link) if you want raw data for JSON responses.. You should be able to configure Swift 4 coders in your transformer pipeline just as you would any other kind of model-specific mapping. It's not clear to me that any special support from the framework is necessary to support them.\nIf you try it and run into a specific roadblock, please file an issue! It is certainly Siesta\u2019s goal to support Swift 4 when it is officially released.. Indeed, this is something of a gap in Siesta. Good point.\nYou can currently achieve this with the requestMutation: param of Resource.request(_:) and friends, but not via configuration. As you discovered, decorateRequests is for adding behavior before and after an already-constructed request, not for modifying it. Configuration should also have a place for attaching RequestMutations to be applied before the Request is constructed.. @reversepanda I\u2019m batching up a few little things for a 1.2 release before Swift 4 hits. In the meantime, this is now on master if you want it!. Right now, Siesta leaves all redirect handling to the network provider. Any custom redirect handling would belong in a URLSession with a custom delegate, a custom taskWillPerformHTTPRedirection handler with Alamofire, etc.\nI didn't surface redirect handling in Siesta because it wasn't clear to me what the use cases are, i.e. what problem Siesta should solve that a network provider shouldn\u2019t. In particular, it's not clear to me that there's a good general policy that handles the security implications of following or not following redirects from an API, to the same host or not, with or without the same headers sent. Thus this note to self.\nIf you can lay out your particular problem in a little more detail, we might be able to spot some good abstraction for Siesta to provide. Hearing about real-world use cases is always very helpful.. @reversepand Ping on this issue: would you be willing to describe your use case a little? What kind of redirects does your API send, and what is your desired policy for handling them?\nThe network provider may well be the right solution, but I'd like to understand your need to make sure that Siesta is doing what it ought to be doing.. @Alex293, did Ahmet answer your question? What he said is exactly right. The key sentence is here:\n\nThe pattern ignores the resource\u2019s query string.\n\nSo api/resource/?offset=40 and api/resource/ are identical as far as the configuration pattern matching is concerned \u2014 but api/resource/ and api/resource are not. For the ID, you want to require at least one character after the trailing slash:\napi/resource/?*. >  I noticed that the ** configuration was being applied to all the requests except the token deletion request. Then I noticed that there was a colon : in the token, and I suspected it might be the cause. I stripped the : in the token string and the configuration was being applied to the request correctly.\nThis is almost certainly a bug in Siesta. I\u2019ll investigate \u2014\u00a0or you\u2019d be welcome to yourself, if you want to submit a pull request! If you want to work on it, look for the describe(\"using wilcards\") section of ServiceSpec.swift, try adding a test case, and go from there. The actual work happens in ConfigurationPatternConvertible.swift.. Huh, well, I just dug into this and \u2026\u00a0I seem to have explicitly treated colons as path separators in the original version of the pattern matching. That\u2019s not right; HTTP path segments can contain colons. What was I thinking? Probably a half-formed thought abouthost:port` matching.\nI\u2019ve submitted a fix as #221 (against the swift-4 branch, which is where the action is happening right now). @akaralar, would you mind taking a look?. I thought I\u2019d fixed it. Are you getting this on the current swift-4 branch?. Awesome. Thanks for checking!. It is possible I did something that messed up the Alamofire extension for Cocoapods with the 1.2.0 release. Would you try Siesta version 1.1.1 and see if it works for you?. @KRUBERLICK, I\u2019m afraid I can\u2019t reproduce your problem. I was able to use Alamofire for the networking provider in Siesta\u2019s GithubBrowser example project without any problem.\nThis error:\n\nI am getting error 'use of unresolved identifier 'Alamofire'\n\n\u2026would mean that you forgot import Alamofire.\nThis error:\n\nCould not cast value of type 'Alamofire.SessionManager.Type' (0x608000242388) to 'Siesta.NetworkingProvider' (0x6080002605d8).\n\n\u2026would mean that Siesta\u2019s AlamofireProvider code somehow isn\u2019t being built in your project. Make sure that Cocoapods has included Networking-Alamofire.swift somewhere in your xcworkspace.\n@LavanayaV is correct: you should never need as! NetworkingProviderConvertible. It\u2019s not under any circumstances going to help if the compiler says the types don't match.. A fine use of a pull request. Good catches! Thanks.. Makes sense to me. Is there any downside to this? If not, send a pull request!. Travis is freaking out on this PR, I think because I changed the base branch from swift-4 to master so the fix for this could make it into 1.2.1, but it\u2019s still building with Xcode 9. Anyway, I'm going to merge into master and see what disaster ensues. Yay!. Ah, that's a bug. Mysterious!\n(The correct result should be /api?x&y, not /api?x=&y=. Siesta drops the = for empty string param values.). As you apparently discovered (I see that you closed the issue shortly after opening it), there is a swift-4 branch.\nThere will be an official Swift 4 release in the next few days.. I confess that I've never tested Siesta with Swift 3.2; I just recklessly went straight to Swift 4. \ud83d\ude44\nThis looks exactly like a problem I had to fix for Swift 4, and I\u2019m guessing you might be able to fix the problem by cherry picking (or manually applying) this change on the swift-3 branch:\nhttps://github.com/bustoutsolutions/siesta/commit/22943eabfe3e8338ebc9bd2ba67b7a883466cc31\nYou may also have to apply this one:\nhttps://github.com/bustoutsolutions/siesta/commit/33ed1b70edf3975f7d081e77a732895716a84488\nIf anybody wants to do that, test it on Swift 3.2, and submit a PR against swift-3, I\u2019d happily accept it!. @reversepanda: Can you confirm that 1.2.2 fixed this for you, and if so close this issue? Thanks!. That line that\u2019s failing is the one that controls the net activity indicator in the status bar. Questions to resolve this issue:\n\nIs it even possible to control the network activity indicator from an app extension?\nDoes the same build error happen when building a standalone framework with Carthage and using it from an app extension?\nIf not, is there a build-time test we can use to disable this code? (Does if #available do the trick?)\nAre there any other app-extension-unfriendly bits in SiestaUI?\n\nNot having developed an app extension myself, I\u2019d certainly welcome pull requests on this one!. Looks go to me! Thanks for doing this housekeeping.\nNo need to bump the version \u2014\u00a0I do that as part of the release process \u2014\u00a0but thanks for the head start! Yes, I'll get a new release out with this as soon as I have a chance.. Yeah. I haven\u2019t figured out how to suppress that; last I checked, @discardableResult just doesn\u2019t translate to Obj-C. If you know how, I\u2019d welcome a pull request!\nIn the meantime, you can suppress the warning like this:\nObjective-C\n_ = [resource loadIfNeeded];. You are quite right! I believe that a previous version of that code configured the mock responses before passing them to the Service init. Thanks for catching this!. Thank you for catching this! It looks like this arrived with Xcode 9.1? I confess I hadn\u2019t actually tested Siesta with 9.1 yet.. Thanks!\n(Fixes #232). Thanks, Lucas, though I think they\u2019re asking about params and not headers.\n@boardmain, I answered your post on Stack Overflow: https://stackoverflow.com/questions/47477280/how-to-decorate-a-request-with-parameters/47612722#47612722. P.S. I'm still rearranging that branch a lot as I work, and occasionally force-pushing it, so beware of that if you fork it. If you want to suggest a patch to it, LMK and I\u2019ll stabilize it so you can make a PR.. My grades go in tomorrow, then teaching is done for the semester! New Siesta release next week, most likely.\n\nthe standard transformer for JSON decoding isn't being applied by default\n\nCurious. That\u2019s on the file-cache branch?. Hi, @Narsail, this is great!\nSince this fix means that useNetworkActivityIndicator effectively does nothing in the absence of UIApplication, I wonder whether the entire file should be wrapped in the #if instead of just the didSet? Then people won\u2019t use useNetworkActivityIndicator and be confused when it does nothing; instead, a compile error will alert people that it\u2019s not available.\nWhat do you think? Does that make sense?\n(I can imagine a future version of this code letting clients register their own hooks to be notified that requests are / are not now in progress, but I\u2019m all in favor of this much simpler fix until that magical future time.). Looks good to me! Thanks!. Narsail: I\u2019ve discovered that this PR does not in fact test for a Swift symbol named UIApplication, but rather tests for a compiler flag named UIApplication. That means that the #if always excludes this code. Oops!\nI\u2019ve reverted the commit on master for now, so that this doesn\u2019t break existing projects. That means you\u2019ll have to either locally reinstate your patch or point back at the previous commit that had it.\nIt looks like availability conditions to test for application extensions are coming in Swift 4.1, but are not available yet. If anybody knows a way to detect this in 4.0, let me know!. Huh, it looks like even with the new conditions available in Swift 4.1, it\u2019s still not possible to conditionally compile code only if it\u2019s not used in an app extension. Perhaps some hero out there will answer my Stack Overflow question.\nI was able to get it working both in apps and in extensions by using this monstrous hack:\nextension UIApplication\n    {\n    static var sharedIfAvailable: UIApplication?\n        {\n        let sharedApplicationSelector = Selector(\"shared\" + \"Application\")\n        guard UIApplication.responds(to: sharedApplicationSelector) else\n            { return nil }\n        return UIApplication.perform(sharedApplicationSelector)?.takeUnretainedValue() as? UIApplication\n        }\n    }\n\n\u2026but this bafflingly returns a UIApplication instance even in an app extension (!), and it\u2019s a nasty enough hack that I\u2019m not comfortable releasing it \u2014 at least not without further research.. One thought: it looks like your SDKAPI class subclasses Service. Instead of subclassing, try holding an internal Service reference inside SDKAPI and making it a facade for Siesta\u2019s Service API, much as the GithubBrowser example does. Based on what you commented out, that might solve your issue.\nI'm afraid I have no other useful feedback: I have not investigated Objective-C++ support for Siesta, have no knowledge of Obj-C++ / Swift interop, and know nothing about this issue in particular. You are pretty much on your own figuring it out! But I would happily accept a pull request if you do find a solution.. Thanks for flagging this! The fix should go out in the next release.. Couldn\u2019t do it all without the help of people like you!\nI\u2019m going to leave this open for now just so I don\u2019t forget to actually roll out the fix. Because I know my own brain, and that will totally happen.. Yes, I tend to agree. The caching stuff I'd hoped to get in the next release still has some large issues I haven't had a chance to untangle. I'll get this out in a smaller release.. @NermeenNery: You shouldn\u2019t need to modify any podfiles; this fix is already released, and is included in Siesta version 1.4.0 and larger.\nIf you are getting an error that sounds like this issue, you should make sure that you are using the latest version of Siesta. Take some time to understand how Podfiles specify versions, how you can use Podfile.lock to see what version of each pod you have installed, and how to update a pod version if necessary.\nIf you see that you are using the latest version of Siesta but still getting this error, then create an issue that includes enough information for others to reproduce the problem. The Mozilla guide to bug reports I linked to in your earlier issue is  good resource.. My usual approach with Swift language updates has been to fold them into the next minor version, and require a higher Swift version for that release while back-porting any critical fixes to a new patch release on the previous minor version. In other words, Siesta 1.4 will require Swift 4.1, and 1.3.x will maintain 4.0 support.\nSo no need for conditional compilation or 4.0 backward compatibility; I'll just keep this PR handy until I'm ready to start putting together Siesta 1.4.. If we were going to simultaneously support Swift 4.0 and 4.1, I\u2019d prefer to do it with a conditional extension, which can live in its own separate file and doesn\u2019t clutter up usage sites:\n```swift\nif !swift(>=4.1)\nextension Sequence\n    {\n    func compactMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]\n        { return try flatMap(transform) }\n    }\n\nendif\n```\nHowever, as I said above, I don\u2019t see any particular reason not to just require 4.1 in the next Siesta release. If somebody does find a compelling reason to keep 4.0 support, we could add the above.\nFor now, if you want to get this PR passing CI, try updating the .travis.yml to require the newer Xcode.. Also P.S. I expect to be pulling together Siesta 1.4 in early May. There are some awesome new caching and custom request building features in the works, mostly complete; just have to survive the end of the semester first! If anybody wants a sneak preview, all that work is on the file-cache branch.. The \u201cCannot parse server response\u201d error means that something in the transformer pipeline returned an error. If you look in the logs, there should be an accompanying underlying error. (You may need to enable more Siesta log categories to get the full info.)\nTwo likely causes:\n\nIf your server sets a Content-Type response header, this can trigger an attempt to parse the response body as e.g. JSON.\nIf you have configured a model transformer for this resource, it may be the thing that is failing.\n\nIn either case, one blanket solution is to disable the entire response transformer pipeline for all DELETE requests:\nswift\nservice.configure(\"**\", requestMethods: [.delete]) {\n  $0.removeAllTransformers()\n}\nMake sure to do that after configuring your own specific transformers. Siesta applies configuration in the order you specify it.\n(You might want to only disable process for specific pipeline stages if you have some transformers that do useful things with headers, errors, etc.)\nIf it is one of your model transformers that is failing, another less ham-handed approach is to configure your model transformer only for specific request methods:\nswift\nservice.configureTransformer(\"/users/*\", requestMethods: [.get, .put, .post]) {\n    try jsonDecoder.decode(User.self, from: $0.content)\n}\n. You need to look up above that in the log, where the transformer pipeline is being applied to the response. If you enable logging for configuration, network, and pipeline (the detailed preset includes all three), Siesta will show you what transformers are configured, what response the server sends back, and which transformers it applies to the response in what order. Look in the logs for entries matching those categories.\nThe question here is why it\u2019s trying to apply a transformer that expects JSON. Is it because the server sent a content type that triggered default JSON parsing? Is it because you configured a model transformer that's kicking in?. Sorry for the lack of response; I've been focusing on my limited Siesta time on getting the cache improvements out the door.\nOut of curiosity, does changing underlyingRequest.addValue to underlyingRequest.setValue in RequestCreation.swift fix the issue for you?. Hmm, you are right to ask these questions. I don't think multiple content-type headers are ever correct \u2014 but if a request(_:method:contentType:) argument and configuration both specify a content type, which should win? I tend to think the argument should, since it is more local, more specific to the individual request.. Thanks, Massimo! I'm just getting to merging this now; thanks for your patience. I spent some time scratching my chin, and decided that yes, the discussion above is correct:\n\nThe request methods that set Content-Type should override the header value, not add it.\nThe override order (first one wins) is:\nconfigured request mutation\nad hoc request mutation\ndefault content type for request helper method\nheader set in configuration\n\nI added some tests to the PR to reflect this.\n\n\nAs a side note, unrelated with this issue, I'm wondering if the contentType parameter in [various request helpers] can go away and be hard coded? The reasoning for that is that I think is more error prone letting the user the freedom to specify an application/xml even if for example is sending json.\n\nNo, because many APIs require specialized content types for familiar data type. In fact, the original application that Siesta came from works with an API that wants Content-Type: application/hal+json.. Fixed in #247.. Calling addObserver should send observerAdded regardless of whether you call loadIfNeeded, or whether it actually triggers a load.\nIs this with the very latest Siesta release? Could you point at master and see if the behavior still occurs?\nIt would be helpful if you could either (1) include a minimal test project that exhibits the issue, or (2) include detailed log output tracking all the observers and events. With the new logging API improvements on master, you can do the latter with:\nSiestaLog.Category.enabled = .detailed. Siesta internally normalizes all invalid URLs to `\":\"`, a syntactically valid but never functional URL, in order to funnel URL formatting errors through the same error event mechanism as other resource errors.\n\nThis is leaking out through RemoteImageView, and I agree that it shouldn\u2019t!. This is now fixed on master.. Caching in the current release is a bit half-baked. The behaviors you're looking at also have a subtle bug (#237).\nA revamp of caching is coming, including a working default cache implementation. You can get a preview on the file-cache branch. (Note that the API on that branch is still in flux! It does work, though.) That branch will land with better docs.. Well, it\u2019s a very reasonable request, so I hardly blame you for making it twice!. Thanks for this PR, dondi, and sorry for letting it languish! I love the idea. I\u2019ll give it a design review for the next minor release of Siesta.. Yes, .withParam(\"key=val1&key=val2\", \"\") should definitely not work, because part of that method\u2019s contract is that it escapes as necessary to make sure the key is the key and the value is the value. If that did work to create a multi-valued key, it would be a bug.\nThe best current workaround is to construct the query string yourself. You can use Resource.relative(\u2026) to provide your own entire query string while still relying on Siesta to construct the rest of the URL:\nswift\nresource.relative(\"?key=val1&key=val2\")\nNote that:\n- this replaces the entire query string, overriding any previous withParam calls, and\n- you are responsible for doing the escaping yourself.\nMy sense is that APIs that use multi-valued keys are rare enough these days that deeper support isn\u2019t necessary, but I\u2019d certainly change my mind about that in the face of evidence to the contrary.. Sounds good. Feel free to reopen (sapieneptus or others) if this is a widespread probelm.\n\nmonkey patching to make Request#url writeable\n\nDefinitely don\u2019t do that. Making Request mutable would break all kinds of critical assumptions.\n\nswizzling #withParam()\n\nOr better yet, you could write an extension Resource { func addParam(\u2026) } that appends a param to the query string without replacing existing ones. That might suit your needs in a tidy way.. Just because I had thoughts doesn\u2019t mean they\u2019re right! I can see a case to be made that the configuration should have precedence, or perhaps that using the default (e.g. request(.post, json: foo)) should read the config which an explicitly specific one takes precedence, or\u2026.\nI'm looking for something that:\n\nis easy to understand & reason about, and\nsuits the common use cases.. I\u2019m glad to hear you figured this out.\n\nA clarification: you mention the server checking if the \u201csession is valid.\u201d Is your server using cookie-based sessions? Was URLSession caching your credentials somehow? Or was the problem something else?\n(I\u2019m wondering whether there\u2019s anything here that needs to be documented better.). Without knowing your particular Jetty configuration, we can\u2019t know for sure how you\u2019re told it to track your httpSession \u2014 but it\u2019s probably cookie-based, in which case it\u2019s up to you to configure your URLSession to store or not store the cookie as you want it to. (Alternatively, you can disable URLSession cookie handling entirely and then manually manage the Cookie header yourself.)\nI\u2019ll add a note in the documentation about cookies being managed by the underlying network provider.. Have you considered adding retroactive conformance yourself?\n```swift\nimport Siesta\nextension RequestError: LocalizedError {\n    public var errorDescription: String? {\n        return userMessage\n    }\n}\n```\nYou can do that within your project, without any changes to Siesta.\nIf that doesn\u2019t suit your needs, would you elaborate a bit on your use case? What is the situation in which you have a RequestError but are not working with any other Siesta API?\nI\u2019ve been reluctant to make RequestError a Swift Error because it doesn\u2019t exactly have the shape of one. (It isn\u2019t ever thrown, for starters.) It\u2019s perhaps better to think of it as an event payload that wraps a Swift error.\nThat may be a distinction without a difference, and I\u2019m open to adding LocalizedError conformance. However, I suspect that may cause more confusion than not: Siesta.RequestError has one guaranteed message; LocalizedError has four optional ones.. Belated reply: yes, I like this idea, and have thought along similar lines in the past but never did anything about it.\nOne could split out just the logic pieces \u2014 i.e. no UIKit dependencies, but just observedResources, displayPriority and friends \u2014\u00a0and then have a protocol with showLoading etc. that ResourceStatusOverlay (and custom resource state indicator views) would implement. Is that more or less what you're thinking?\nI haven't thought much beyond what I typed above. If you want to investigate and take a crack at it, go for it!. Hi, @olcayertas, and thanks for this! The image URL does work in the compiled user guide, which is where it\u2019s meant to be viewed.\nWhile an absolute URL would work in both places at first, the problem is that the link would always point to master, and thus immediately pick up changes, but the compiled user guide is supposed to be pinned to the latest stable release.. Thanks for flagging this. 1.4.0 had some progress-related refactoring, which seems a likely culprit. I'll poke at it tomorrow or Wed unless somebody else gets to it first.. I found a likely culprit. Could you check if the memory-leak branch fixes the problem for you?. Excellent! Thanks. I'll cut a release just for this fix as soon as I can find an hour.\nI\u2019d love to figure out how to regression test this by checking for total deallocation of all Siesta classes after the test suite runs, but without stuffing instance-counting code into Siesta itself. Anyone know of any Apple toolchain trickery that might help?. No, because the problem was that code in chained is not guaranteed to be called (if for example the first request in the chain is cancelled), so cleanup code always belongs in onCompletion \u2014 a detail I overlooked despite the fact that my own docs make a point of it! \ud83d\ude44 . Right. The chained request (\u201ctry cache first, then network\u201d) that method creates was sticking around in loadRequest forever if it was cancelled before it reached the \u201ctry the network\u201d part.. > Do see some other leaks than include Siesta stuff in the stack trace, but for now I'm assuming those are related to something else.\nIt is quite possible Siesta has more leaks lurking. I can see from this issue that I need a full audit and an ongoing testing strategy for them.\nHowever, Siesta\u2019s \u201ckeep resources in case they\u2019re needed\u201d algorithm does make it easy to get false positives on leaks. Service and Resource form an intentional retain cycle until one of three things triggers an unused resource cleanup:\n\na low memory event on iOS,\nthe resource cache exceeds cachedResourceCountLimit, or\nyou manually call flushUnusedResources().\n\n(When these happen, the service\u2192resource ref becomes weak, and resources not currently in use thus disappear.)\nSo \u2026\u00a0unless one of those things happens right before you inspect for leaks, you\u2019ll see things that look like leaks but would vanish under memory pressure.. > I notice you use a rather remarkable curly brace style that I've never seen before. Is this simply your preference, or wasn't it supposed to look like this?\nIt\u2019s my personally preferred style, which reduces the non-information-bearing visual noise created by the ragged block boundaries of other styles. I came to it on my own back when I first learned C, but later found out it has a name (\u201cWhitesmiths\u201d). Apparently some study or other found it easier to read. Who knows? I like it. I don\u2019t generally inflict on teams I work with, but like to use in my own code.. Thanks so much for this, @Hugal31! I\u2019m not using Siesta SwiftPM support, so it\u2019s great that it\u2019s getting some love.\nIf you or anyone else who knows SwiftPM cares to take a look, I would love to make swift test work properly with Siesta. My impression is that\u2019s impossible as long as Siesta\u2019s specs depend on Nocilla, but it deserves investigation.. > I'm planning to release a new version of my app this week, and I had included 1.4.0 in it. Would you recommend using memory_leak, or do you plan on getting a new version of Siesta released shortly (Travis issues?)? Is there anything I can do to help?\nI expect that the memory_leak branch should be safe, but I\u2019d love to see it pass CI before I say that with confidence. I\u2019d happily welcome any additional detective work on this!\nThis PR\u2019s new leak check in the tests is flagging leaks with the Alamofire provider. The problem is puzzling, and I haven't yet figured out whether it\u2019s real or whether Alamofire just delays cleanup of its requests in a way that trips the test but is actually harmless.\nIf you want to take a look and puzzle over it, run the tests with the env var Siesta_TestMultipleNetworkProviders set to something nonempty. (I do this locally by manually changing the value to 1 in Edit Scheme \u2192\u00a0Test \u2192\u00a0Arguments.) You\u2019ll know the flag is working if you see >1000 tests run instead of the usual 300-something.\nYou can see the AF issue in the Siesta macOS target, which runs much faster than the others because it doesn\u2019t require a simulator.\nThe check that\u2019s failing just keeps a weak ref to each test case\u2019s Service, then checks that it\u2019s nil at the end of the test. (This also catches Resource and Request leaks, since both of those ultimately retain their associated Service.) The interesting detail: it looks like each test case\u2019s service gets cleaned up during the next test case. My suspicion is that AF does an additional something or other with each request that Siesta just isn\u2019t waiting for.\n\nI'm trying to setup Siesta so I can build and run the tests on my local machine, but I'm unable to get Carthage to compile Nocilla, I'm getting the following error: \u2026 If I'm reading that right, it wants a tvOS simulator which is version 11.4, but since I'm not yet on Xcode 10, I only have access to devices up to 11.3. Any suggestions on how to fix?\n\nCould you open a separate issue for this? Then we can tag in the kind person who contributed the tvOS support.. Update: my current working theory is that AF is relying on autorelease for cleanup, and the autorelease pool doesn\u2019t get drained until after my afterEach block that checks for leaks.. Yes, confirmed: at least some of the tests pass with Alamofire if each spec is wrapped in autoreleasepool { \u2026 }.\nThe problem now is that AFAICT, Quick doesn\u2019t provide any sort of aroundEach facility that we could use to automatically wrap each test in an autoreleasepool { \u2026 }, and ARC doesn\u2019t allow us to manually create and drain an autorelease pool in a way that Quick\u2019s beforeEach and afterEach would support.\nI have to dash off, and will be on other tasks most of the rest of the day. @jordanpwood, if you have some time today, you could help by investigating whether it\u2019s possible to control autorelease pools with Quick. We need some way to make sure that each spec created during this call gets wrapped in its own pool, and that the pool is drained before the leak-checking block runs. The solution I\u2019d want, but don\u2019t know if Quick supports, would look like this:\n```swift\naroundEach\n    {\n    spec in\n    autoreleasepool\n        { spec() } // (1)\n    }\nafterEach\n    {\n    // (2) \u2026check for leaks here\u2026\n    }\n```\n\u2026so that the order of execution is:\n// (1) pool created\n// spec runs\n// (1) pool drained\n// (2) leak check runs\n// (1) pool created\n// spec runs\n// (1) pool drained\n// (2) leak check runs\netc.. Trying a Quick fix (pun intended) for the Alamofire tests. If it passes CI, we\u2019ll see if Quick wants to accept the new feature\u2026.. Phew, passed!\nIt was test artifacts, it seems \u2014 though establishing that and working around them took some finagling. The general flavor of all these leak-checking issues is that between Siesta, URLSession, and Alamofire, there\u2019s a lot of deferred cleanup, and some of it is timing-sensitive. I hacked around it by adding a very forgive progressive delay-and-retry loop before we confirm the leak.\nThe good news is that the wait-and-rety appears to also take care of the nasty Travis issues that the unpleasant DelayAfterEachSpec flag was working around. Appears to. Without that delay, the specs run a bit faster on CI.. @victorcotap You got the tvOS support in the project. Did you manage to get the tests running on your machine?. Siesta builds and runs just fine with XC10 / Swift 4.2. Is there a specific issue you\u2019re seeing?. It looks like whatever you're compiling it with isn\u2019t respecting the SWIFT_VERSION flag, which should still be set to 4.0 (though it compiles with 4.2).\nHmm, are you getting this error in an app that includes Siesta via CocoaPods, perhaps?\n(With all these error reports, don't forget to include at least minimal details about the specific error, context and configuration, etc. It reduces the back-and-forth.). Indeed, it looks like CocoaPods can't mix Swift versions per pod, even though Xcode itself can, and ignored the Swift version setting of pod dependencies:\nhttps://github.com/CocoaPods/CocoaPods/issues/7099\nhttps://github.com/CocoaPods/CocoaPods/issues/6791. This is fixed on master (see #273, #274). I didn't cut a release yet because I realized Siesta should really support both 4.1 and 4.2 using compilation conditionals.. Duplicate of #275.. Ha, I\u2019ll be darned! Thanks for catching this.\nI\u2019d be tempted to say that this is too small a thing to test, except \u2026\u00a0I screwed it up, so obviously it isn\u2019t! I worry a little about writing timing-dependent tests like this: Travis is so slow and timings are so inconsistent, timing-dependent things like this can make CI sporadically fail. (Siesta\u2019s already in that boat with waiting for Nocilla cleanup, and it's not great.) But I think your testing approach is good, so I\u2019ll merge it and if it breaks CI we can add slop to the tests later.\nThanks!. The ~> 1.0 should be shorthand for >= 1.0, < 2.0 (see here). Are you sure it installed an old version? Even when there was no existing Podfile.lock?. I just verified that a new, empty project with pod 'Siesta', '~> 1.0' installs Siesta 1.4.2.. This isn\u2019t nearly enough information to diagnose or reproduce the issue. Mozilla\u2019s guidelines are a pretty good reference on writing useful bug reports: https://developer.mozilla.org/en-US/docs/Mozilla/QA/Bug_writing_guidelines\nI\u2019m closing this assuming it\u2019s duplicate of https://github.com/bustoutsolutions/siesta/issues/242.. \"(it\u2019s for NSURLConnection\" should be a new sentence.\n. No need for both quotes and italics, plus tightening up the text a little:\nIt provides certificate pinning without modifying the App's source code.\n. Maybe add something here so people don't carelessly copy & paste and put it in the root dir of the project? Because git submodules are notoriously hard to move once created.\ncd Libraries/  # or wherever you want to put it in your project\n\u2026or just:\ngit submodule add https://github.com/bustoutsolutions/siesta.git Libraries/Siesta\n. Did you just delete the \u201cTest-only\u201d subgroup? That\u2019s fine, I suppose, now that Alamofire is optional.\n. Sanity check: does this work even if one of these directories is not present? We should make sure people can build with carthage --platform ios\n. It\u2019s a mystery to me why the extension doesn\u2019t compile on OS X. Seems like it shouldn\u2019t matter at all, since it\u2019s a Swift language thing. Putting them in the extension is just for style reasons, so I suppose it\u2019s OK to merge. But \u2026\u00a0huh.\n. Could you make these follow Siesta\u2019s brace conventions? I know the style is weird, but it\u2019s how this project rolls. The rule is that a pair of matching braces:\n- are always in either the same row or the same column, and\n- are always indented the same as the code they surround.\nswift\nextension NSControl\n    {\n    public var text: String\n        {\n        get { return self.stringValue }\n        set { self.stringValue = newValue }\n        }\n    }\n. Why TARGET_OS_IOS in some places, #if os(\u2026) in others?\nIf it works, I\u2019d prefer #if os(\u2026) everywhere, in anticipation of SwiftPM building the project in the absence of the Xcode project config.\n. Funky indentation\n. I think that\u2019s just fine. It was a minor style point; if it caused any trouble at all, it\u2019s just not worth it.\n. Of course. Always good to validate and gather feedback before perfecting.\n. I have a fix for this that also cleans up some other code. Can you give me push permission for your Siesta fork?\n. Thanks! Just realized I posted my comment on the wrong line note. The fix is for the Error.Cause extension. Now pushed.\n. This keeps the Obj-C specific InvalidRequestMethod from showing up in the Swift API, which is a good thing.\nAs a side bonus, it also happens to fix the OS X specific Error.Cause problem \u2026 which is a still a mystery to me, and possibly a Swift bug, but now we can ignore it!\n. The no-args form is part of the public API. If the sender arg is necessary for the @IBAction on OS X, then the form with a sender can delegate to the no-args form.\n. The point here is just to have things that aren\u2019t JSON serializable. To make these work on iOS and OS X, let\u2019s just pick some other garbage object out of Foundation that exists on both platforms. (Same with NSButton below.)\n. It may indeed be either unsupported or bad practice for an IBOutlout; my point is that this method is public, and existing code might call it directly (with no args), so we shouldn\u2019t break that API.\n. Indeed, that\u2019s sort of the point. They aren\u2019t supported (yet), so it should error. Maybe should an #else\u00a0clause that explicitly errors out the compiler with \u201cunsupported OS\u201d or something?\n. Ah, clearly I was too eager! Yes, please revert my change \u2014 and I won't mess further with anything OS X UI until you've had the chance to test it and get it all working. \n. We do still want this on iOS, though.\nYou had it right before:\n``` swift\nif os(iOS)\nlayer.zPosition = 10000\n\nendif\n``\n. Fantastic that the basics work! Great news. Given that, I\u2019m really only expecting nasty surprises with the UIKit-dependent stuff.\n. This should probably be in the user-level .gitignore (i.e. not checked in to the project)\u2026?\n. What\u2019s going on with these duplicate path entries? This seems like maybe a spurious change?\n. By convention, the project prefers to keep debugLog statements on one line, no matter how long, so that they don\u2019t interfere with reading too much.\n. Since it\u2019s not an extension on UINetworkActivityIndicator, let\u2019s just name the fileNetworkActivityIndicator.swift. Under project conventions, line 16 should be indented 4 spaces because it is a continuation of the expression on the line above.\n. Since this code is going in the library, it should follow the project\u2019s brace placement conventions. (They\u2019re odd, I admit, but that\u2019s how the project rolls!)\n- Every matching pairs of braces is either in the same line or the same column.\n- Braces containing multiple lines\n  - are always on a line by themselves and\n  - are indented the same as the code they surround.\n. I tend to think these should be outside of the extension, siblings of requestsInProgress because that\u2019s what they\u2019re most closely associated with. I\u2019m willing to be talked out of that, though!\n. I don\u2019t because (1) it doesn\u2019t (yet) accommodate this project\u2019s conventions and (2) it noticeably slows builds. If I start getting lots and lots of PRs, then maybe I\u2019ll add Siesta-style rules to it and use it.\n. They work fine at the global scope. (I checked locally.) It shouldn\u2019t be possible _not_ to trigger thedidSet`; if you find a case where it\u2019s not called, submit a Swift bug!\nMy thinking here is basically that Configuration.requestStarted() doesn\u2019t make a lot of sense. Service.requestStarted() would make more sense as a public API, if we ever needed to make it public. Since it\u2019s private, global scope is fine IMO.\n. This project never uses superfluous self.. I know the brace & indentation conventions of the project are weird, but please do follow them. Brace rules are at the end of the README, or you can just look around the project for examples.. What\u2019s the rationale for this? watchOS also supports NotificationCenter\u2026doesn't it?. OK, just making sure! macOS has the same problem, which is why MemoryWarningNotification is a Siesta-defined type that takes a different type on different platforms. watchOS can use the same solution.\nI'm pushing a couple of commits with this and a minor refactoring. Would you mind giving them a test before I merge them?. ",
    "piv199": "If there any updates? I would like to use ReactiveCocoa with Siesta!\n. @pcantrell, okay but I am a bit misunderstood with siesta\nWhat the difference between Request and Resource?\nI have AuthService with signIn, signUp requests, so I could call them when pressing on button and listen whether response is succeeded or failed, don't I?\nI have some TasksResource: Resource and I want to observe tasks changes? Or when I need to use a Resource.\nP.S.\napi.myMethod().onSuccess { entity in\n    let user: MyUserModel? = entity.typedContent()\n}\nI do not like this case, because it could be used lots across the program and will lead to potential duplication and requires changes in many places.... @pcantrell Also I have doubts if I have resource \"news\" and I want to call method \"all\" -> I do newsResource.child(\"all\").start(), but \"news\" resource won't get any updates :(. @pcantrell also why Resource marked as final class?. @pcantrell https://www.dropbox.com/sh/i8aeqd0z1o74xrh/AACFLcR3lXIqQvnaVNjBkyvZa?dl=0\nNo, Siesta NetworkActivityIndicator uses request decorators, and that's called once per each request. Otherwise NetworkActivityIndicatorManager is subscribing to Alamofire notifications and they are called - Resume - twice; Finished - once, thus the counter is not becoming zero.\nI personally like this library, because it ensures some time before and after spinner appears/disappears.... I suggest not to move such functionality inside Siesta, maybe some extension to the Siesta...\nI got it working with some hack:\nNotificationCenter.default.removeObserver(NetworkActivityIndicatorManager.shared)\n        service.configure {\n            $0.decorateRequests { resource, request in\n                NetworkActivityIndicatorManager.shared.incrementActivityCount()\n                request.onCompletion { _ in\n                    NetworkActivityIndicatorManager.shared.decrementActivityCount()\n                }\n                return request\n            }\n        }\nright after NetworkActivityIndicatorManager.shared.isEnabled = true.\nThe exact problem is in Notifications called by Alamofire... If we disable notifications by Alamofire for network activity indicator and call increment/decrement with decorate requests block then all is fine...\n. @pcantrell Hm... it seems the problem is inside AlamofireProvider...\ninit(_ alamofireRequest: Alamofire.Request)\n        {\n        self.alamofireRequest = alamofireRequest\n        alamofireRequest.resume()   // in case manager.startRequestsImmediately is false\n        }\nAnd what if manager.startRequestsImmediately = true? calling alamofireRequest.resume() fires new Alamofire.DidResume notification, and it increments a counter inside NetworkActivityIndicatorManager...\nWhere is the problem? We shouldn't call alamofireRequest.resume() on a started request, or NetworkActivityIndicatorManager should handle this situation?\nP.S. It seems a bit strange for me that we could call resume on running/cancelling/completed task and get notification about resuming the task.... @pcantrell \nAlamofire.Request.task?.state provides the current state of the task:\ncase running\n        case suspended\n        case canceling\n        case completed. > It would be great to get regression tests for this. It\u2019s subtle enough \u2014 and easy enough to mess up \u2014 that it\u2019s worth covering.\nI' not familiar with tests you have, also I haven't found siesta+alamofire tests at all...\n\nWhen does nil task even happen, and how is it different from suspended?\n\nAs for Alamofire sources, task should not be nil. When we initializing the Request object we pass there a task (that could be nil). So possibly, if something went wrong while creating a URLSessionTask object than nil will be passed to Alamofire.Request. Actually resume has guard for checking on task existense - it means that we could not resume task that is nil.\n. @pcantrell This option is selected\n\n[x] Allow edits from maintainers.. \n",
    "akaralar": "reactivecocoa plugin would be really nice, i would like to use that as well\n. I'm thinking about how this could be implemented, shall we need to return a hot signal for addObserver methods? what happens with request methods and one time hooks? Also resources can be released in cases of memory pressure, what happens to hot signals then? \nWhat are the cases that need to be handled at minimum for this to work properly?\n. @pcantrell I'm thinking about implementing at least some RAC wrapper for the library, but there is one issue I'm not certain about. In RAC a signal is terminated when an error event occurs, however the ephemeral nature of Siesta requires the subscription to continue even if there is an error. It is not a problem in the request-centric approach because each request is an operation that can succeed or fail. I can think of a few ways to overcome this:\n- Do away with RAC error handling mechanism and send the Resource and ResourceEvent parameters as next: values, even though there may be some error.\n- Have a signal of signals that converts each resourceChanged calls to signals that need to be subscribed by the observer each time, and if the event in the inner signal is an error, then forward it to error: instead of next:. The outer signal will not be terminated during the lifetime of the observer, the inner signals will be terminated upon completion or error.\n- Make latestData, latestError, and isLoading seperate signals and handle each in separate blocks. Or merge them with combineLatest so that a next event is sent whenever one of them gets updated. In both cases those properties (and I guess timestamp too) will be separate signals.\n- ...?\nBut in general, I'm not quite sure how to translate request-centric idioms. Anything you can point me to read more about the approach you have taken with this library is welcome.\nIf I can find a neat way to implement the bindings, this will be my first open source contribution so please feel free to nurture me with criticism. :)\n. @pcantrell Thanks for the detailed explanation! Yeah that makes sense. Great food for thought :) Let me see if I can get something working and send a PR.\n. I absolutely agree with you @pcantrell, but I couldn't be sure what happens if you initiate a request(and start it implicitly), and you subscribe to it later somewhere after the request is finished. The difference between a Signal and a SignalProducer is the latter's capability to encapsulate side effects like this. So if you're using a SignalProducer, you know side effecting code will run (like starting a request), whereas if you use a Signal you know there won't be side effects each time you subscribe to it, hence it's usage in the rac_signal for the Resource. A more detailed explanation can be found in the docs for RAC. The gist is that starting the network request is the responsibility of the caller, the extension only returns a SignalProducer that can be started. The whole need for this stems from the fact that the requestMutation block is denoted as @noescape hence can not be used inside the block for the SignalProducer. So if we can find a way that separates between request preparation and request initiation, I think that would be enough to remove all that intrusive work I guess. What do you think?\n. Yeah I think it clears up the problem :) I'll make the changes and push. Where should I include the tests?\n. I added a signal for progress and generic parameters as well. BTW I don't know why travis build is failing, I can pull the project in reactivecocoa branch and run carthage bootstrap --platform iOS,osx and build and test without errors on both platforms. I think the current configuration of Cartfile.private is correct as well. Travis doesn't seem to respect that Cartfile.private because it's not fetching RAC. Any ideas?\n. Ah I found the culprit! Downloading prebuilt libraries is preferred over carthage bootstrap in .travis.yml,  hence the fail. I'll send an update tomorrow.\n. Failed again :( It still doesn't fetch ReactiveCocoa, but it fetches code that references ReactiveCocoa, seems strange. Any ideas?\n. Seems fixed \ud83d\udc4d\n. I'll revert the travis file to the way it was as well.\n. Regarding long build times with carthage, I noticed that the dependencies were being built for all platforms. Would it make sense to build only platforms siesta supports, ie. mac and iOS? I made a little change in that part of the .travis.yml file, adding --platform iOS,osx to carthage bootstrap and it was building without timeouts. Redundant builds for tvOS and watchOS of all dependencies were slowing down the process. However if siesta supports these platforms in the future then again brebuilt binaries would be a better option, so maybe it is better this way?\nThere is something that causes me discomfort with this implementation. Right now the type has to be supplied when calling rac_signal on the resource. Is there a way to get that type from the response transformer or anywhere else so that if the response transformer is changed, we automatically get the correct type? There would be no need to supply a parameter as well. If there is no response transformer, latestData can replace typedContent() in ResourceState, or would it defeat its purpose? Or too magical? \n. Ah I found the reason for this. I was invalidating the configuration when auth token was changed, and the service.configure method I used was adding new transformers each time the configuration was invalidated, without removing previous transformer. Adding $0.pipeline[.model].removeTransformers() in the configure block did the trick, but now it leaves me with the boring task of adding that line to each service.configure(...) block I have. I wish there was an easier way to remove transformers in a certain stage for all configurations. Would that be possible?. I started seeing weird behaviour when I remove transformers from the pipeline. I set up my configuration for changing auth token this way, which is triggered from didSet: \n```swift\nvar authentication: Authentication? {\n  didSet {\n    service.invalidateConfiguration()\n    service.wipeResources()\n  }\n}\ninit() {\n  service.configure(requestMethods: [.get, .post, .delete]) {\n    $0.pipeline[.cleanup].removeTransformers()\n    $0.pipeline[.cleanup].add(ErrorMessageExtractor())\n    $0.headers[\"customertoken\"] = self.authentication?.token\n  }\n// More configs..\n}\n```\nBut the token sometimes disappears and I start getting 401s from the API. Since .replaceExisting can only be used with configureTransformer and not configure methods, actually I'm removing the transformers myself, and when I don't, they are added more than once to the pipeline. What's the correct way to evade this behaviour?. @BilalReffas It will most certainly depend on your app, I am doing it the same way it is described here: http://bustoutsolutions.github.io/siesta/guide/configuration/. @pcantrell It seems using \nswift \nvar authentication: Authentication? {\n  didSet {\n    service.invalidateConfiguration()\n    service.wipeResources()\n  }\n} \ndoesn't remove the previous configuration, as the transformers are added each time I change the authentication. So if I change the authentication a few times, (via logout - login), then even though configuration is invalidated, the transformers from previous configuration still remain. The configurations are done in an init() method that is called only once (there is only one Service instance and it is injected to each view model in the app), so I'm not adding them myself.\nHere is a screenshot from logs of Siesta when the app first opens and there is a cached logged in user:\nhttps://dl.dropboxusercontent.com/spa/6d4j003yz96ozkz/ppz0b7e2.png\nand this one is after logging in and out a few times. Notice that it is applying previous configurations as well.\nhttps://dl.dropboxusercontent.com/spa/6d4j003yz96ozkz/two_qpr5.png\nthe configurations that apply to this endpoint are as following:\n```swift\ninit() {\n  // ...\n    service.configure(requestMethods: [.get, .post, .delete]) { [weak self] c in\n      c.pipeline[.cleanup].add(ErrorMessageExtractor())\n      c.headers[\"customertoken\"] = self?.authentication?.token\n    }\nservice.configure(Endpoint.Profile.me.path, requestMethods: [.get]) {\n    $0.pipeline[.model].removeTransformers()\n    $0.pipeline[.model].add(DictionaryTransformer())\n  }\n  // ...\n}\n```\nThis seems like a bug to me, but feel free to correct me if this is intended behaviour.. Your answer lies in ConfigurationPatternConvertible.swift file. Taken from there:\n```\n/**\n      Matches URLs using shell-like wildcards / globs.\n  The `urlPattern` is interpreted relative to the service\u2019s base URL unless it begins with a protocol (e.g. `http:`).\n  If it is relative, the leading slash is optional.\n\n  The pattern supports three wildcards:\n\n  - `*` matches zero or more characters within a path segment.\n  - `**` matches zero or more characters across path segments, with the special case that `/\u200b**\u200b/` matches `/`.\n  - `?` matches exactly one character within a path segment, and thus `?*` matches one or more.\n\n  Examples:\n\n  - `/foo/\u200b*\u200b/bar` matches `/foo/1/bar` and `/foo/123/bar`.\n  - `/foo/\u200b**\u200b/bar` matches `/foo/bar`, `/foo/123/bar`, and `/foo/1/2/3/bar`.\n  - `/foo*\u200b/bar` matches `/foo/bar` and `/food/bar`.\n  - `/foo/\u200b\u200b*` matches `/foo/123` and `/foo/`.\n  - `/foo/?*` matches `/foo/123` but _not_ `/foo/`.\n\n  The pattern ignores the resource\u2019s query string.\n*/\n\n``. We will probably implement a workaround for this, doDELETE` methods allow a json body in siesta?. @pcantrell Sorry I didn't take this up myself. We have some holidays coming up and I might try to see if it works but I'll have to coordinate with our backend developers because they changed that endpoint to receive the data in the body instead of the URL.\nWill let you know within a few days. Thanks for the effort!. Totally makes sense, reverting\n. I didn't notice that, let me check\n. you're right, removed\n. I believe this most resembles my use case. If this passes then I guess my problem will be solved. Will let you know after this is merged.. ",
    "vdka": "For RxSwift\n``` swift\nimport Siesta\nimport RxSwift\nextension Request {\nvar rx_success: Observable {\nreturn Observable.create { o in\n\n  self.onCompletion { response in\n\n    switch response {\n    case .Success(_):\n      o.onNext(true)\n\n    case .Failure(_):\n      o.onNext(false)\n    }\n    o.onCompleted()\n  }\n  return AnonymousDisposable { self.cancel() }\n}\n\n}\nvar rx_response: Observable {\nreturn Observable.create { o in\n\n  self.onCompletion { response in\n    o.onNext(response)\n    o.onCompleted()\n  }\n\n  return AnonymousDisposable { self.cancel() }\n}\n\n}\nvar rx_entity: Observable {\nreturn Observable.create { o in\n\n  self.onCompletion { response in\n\n    switch response {\n    case .Success(let entity):\n      o.onNext(entity)\n\n    case .Failure(let error):\n      o.onError(error)\n    }\n    o.onCompleted()\n  }\n  return AnonymousDisposable { self.cancel() }\n}\n\n}\n}\n``\n. It won't be so easy to have a static method on the protocol typeRequest`. Protocols do not interact so neatly with static methods. For example\n``` swift\nextension Request {\n  static func requestFailure(error: Error) -> Request {\n    return FailedRequest(error)\n  }\n}\nfunc alwaysFails() -> Request {\n  return Request.requestFailure(error: Error(userMessage: \"Who else but failure\", cause: Error.Something)\n}\n```\nThe call to Request.requestFailure fails to compile with the error Static member 'requestFailure' cannot be used on instance of type 'Request.Protocol'\nThoughts?\n. It would be nice to be able to do something like this:\nswift\npublic static func configureMe() {\n  service.configure(\"/me\") {\n    $0.config.beforeStartingRequest { (resource, request) in\n      guard API.isAuthed else {\n        switch API.refreshToken {\n        case let refreshToken?:\n          request.pause() // Stop the request from going out until we are possibly authed.\n          API.login(refreshToken: refreshToken).onCompletion { response in\n            guard case .Success = response else {\n              request.cancel(API.Error.requiresAuth)\n              return\n            }\n            request.resume() // We are now authed and the request may proceed.\n          }\n        case nil:\n          request.cancel(API.Error.requiresAuth)\n        }\n      }\n    }\n  }\n}\nWhat are your thoughts on a system like this?\n. I haven't tackled the issue just yet @jordanpwood but I will in the next couple days, then report back.\n. The following should work, it doesn't do pre-auth for individual requests but it definitely could be made to. You will need some method of finding the expiration time of your tokens for this method (we are using a JWT which encodes expiration time)\n``` swift\nfinal class API {\nstatic var service = Service()\n// ...\nstatic func login(username username: String, password: String) -> Request {\nlet request = service.resource(.Auth)\n  .request(.POST, json: [\"grant_type\": \"password\", \"username\": username, \"password\": password, \"application_id\": clientId])\n  .onSuccess { entity in\n    let json = entity.json\n\n    guard let token = json[\"token\"].string else {\n      fatalError() // handle this better\n    }\n\n    guard let refreshToken = json[\"refresh_token\"].string else {\n      fatalError() // handle this better\n    }\n\n    API.token = token\n    API.refreshToken = refreshToken\n}\n\nreturn request\n\n}\nstatic func login(refreshToken refreshToken: String) -> Request {\nlet request = service.resource(.Auth)\n  .request(.POST, json: [\"grant_type\": \"refresh_token\", \"refresh_token\": refreshToken, \"application_id\": clientId])\n  .onSuccess { entity in\n    let json = entity.json\n    guard let token = json[\"token\"].string else {\n      fatalError()\n    }\n\n    guard let refreshToken = json[\"refresh_token\"].string else {\n      fatalError()\n    }\n\n    API.token = token\n    API.refreshToken = refreshToken\n}\n\nreturn request\n\n}\npublic static var token: String? {\n    didSet {\n      service.invalidateConfiguration()\n      service.wipeResources()\n  guard let token = token else { return }\n\n  let jwt = try? JWTDecode.decode(token)\n\n  tokenExpiry = jwt?.expiresAt\n}\n\n}\npublic private(set) static var tokenExpiry: NSDate? {\n    didSet {\n      guard let tokenExpiry = tokenExpiry else { return }\n  let timeToExpire = abs(tokenExpiry.timeIntervalSinceDate(NSDate()))\n\n  // Somewhat before the expiration happens\n  let timeToRefresh = NSDate(timeInterval: timeToExpire * 0.9, sinceDate: NSDate())\n\n  log.info(\"Token refresh scheduled for \\(timeToRefresh.descriptionWithLocale(NSLocale.currentLocale()))\")\n\n  NSTimer.after(timeToRefresh.timeIntervalSinceNow) {\n\n    log.info(\"attempting auto token refresh\")\n\n    guard let refreshToken = API.refreshToken else { \n      log.warning(\"No refresh token set. Cannot auto-refresh\") \n      return\n    }\n\n    API.login(refreshToken: refreshToken)\n      .onSuccess { _ in log.info(\"Token refresh successful!\") }\n      .onFailure { log.error(\"Token refresh failed with \\($0)\") }\n  }\n}\n\n}\n}\n```\n. Using it when I cannot construct a correct resource endpoint. eg:\nswift\n  public static func updateBusiness(business: Business) -> Request {\n    guard let id = business.serverId else {\n      return Resource.failedRequest(Siesta.Error(userMessage: \"Object does not exist on server\", cause: Error.objectNotOnServer))\n    }\n    return service.resource(.Businesses).child(id).request(.PUT, json: business, options: [.noSkipNull])\n  }\nswift\nextension Resource {\n  /// Perform request with a JSON object.\n  public func request(\n    method: RequestMethod,\n    json: JSONEncodable,\n    options: [JSON.Serializer.Option] = [],\n    contentType: String = \"application/json\",\n    requestMutation: NSMutableURLRequest -> () = { _ in }\n    ) -> Request {\n    do {\n      let rawBody = try json.serialized(options: options).dataUsingEncoding(NSUTF8StringEncoding) ?? NSData()\n      return request(method, data: rawBody, contentType: contentType)\n    } catch {\n      return Resource.failedRequest(Error(userMessage: \"Failed to encode JSON\", cause: error))\n    }\n  }\n}\nI guess in the second example I can just call the member function\n. @pcantrell, the Pipeline changes coupled with the request method specific transformers are great. Using them currently. \n. ",
    "hherman1": "PAUL!. ",
    "paddlefish": "Regarding the optional String result of that API, I couldn't think of why that would happen either.  The most I could think to do is generate a program error if it failed, until we had a better sense of why it would fail.\nI'm still learning Swift so the subtleties of ? and ! are still a bit vague to me.  I was sort of surprised that NSCharacterSet didn't have a more intuitive Swift API -- perhaps it's still on their todo list.  I'm happy to let you reject this PR if you want to address these issues yourself, or feel free to add more commits.\n. @pcantrell I fixed the formatting nit and rebased.\n. Hey @pcantrell, Troy and I were discussing this and I don't think any of the APIs I changed to require iOS SDK 8.1.  It looks like a bug in the Swift headers and/or Xcode integration.  But if you look at the ObjC headers all the APIs are old old like iOS2.\n. Interesting.  I agree that the first line (wat?) succeeding is counter-intuitive.  I wonder why they didn't just assert that Swift strings consist of complete graphemes?  Maybe because going that far would make it hard to do text editing?\n. ",
    "Rhuantavan": "Yes, the resource(url:) was the problem. Thanks.\n. ",
    "shaneneuerburg": "Awesome! That helps immensely.\nWorks great now! Thanks!\n. :+1: \n. The library used for the scaffolding of the API is Restler (PHP), which apparently doesn't abide by that rule. I'll post an issue with them and see if I can override that for now.\n. Great, thank you!\n. ",
    "gthrb22": "How to map the model for the response string  i am using object mapper and am facing the same issue \nMyAPI.configureTransformer(\"foo\") {                              //\n      Mapper().map($0)\n    }\nSomething like this and i get the error as \nCannot invoke 'configureTransformer' with an argument list of type '(String, () -> )'\n. ",
    "annicaburns": "I like your proposed solution a lot. I had not yet considered the pull-to-refresh use case, but would have run into it sooner rather than later! \nI'm partial to the \"enum\" version of your solution because it's so simple. \nHowever, I am struggling with how to handle the fact that we will want the ResourceStatusOverlay to act  DIFFERENTLY if the load is user-initiated than if it's an automatic background refresh.  We will want to display an unobtrusive error notice to the user after a pull-to-refresh, while continuing to make the cached data available. However, if an error is returned from an automatic background refresh we won't notify the user that a request has even been made. It's not clear to me if your proposed solution would make possible a ResourceStatusOverlay that acted differently depending on the type of request (user-initiated or not).\n. Many Thanks, Paul! I pulled your new code and set the displayPriority property on all of my ResourceStatusOverlay views to: [.AnyData, .Error, .Loading]\nEverything now works as hoped/expected. \nI also tried the setting you suggest above - [.Retrying, .AnyData, .Error, .Loading] - but did not get the results I needed. When I downloaded a resource and then went offline, the StatusOverlay displayed an error (rather than the stale data) the next time a request was made.\nThanks also for your suggestions and code samples above regarding how to communicate differently to the user after a user-initiated request using two separate observer views and request hooks. That all  makes sense and should work for us (although I haven't attempted to implement it yet). \nI really appreciate such prompt attention to this issue.\n. My apologies, Paul. It's working perfectly with [.Retrying, .AnyData, .Error, .Loading]\nI must have seen the error before I over-rode the displayPriority property on all of my ViewControlers. I see there is a default setting that would have caused the problem. Thanks for pushing back. Sorry to waste your time. Please close this issue!\nHave you been able to spend any time on the Realm-Siesta integration problem that we exchanged emails about?\n. Thanks for giving this so much thought, Paul. What you are suggesting above looks like it would work well for us and would solve the one roadblock we hit attempting to use Siesta and Realm in an integrated way.\nWe would still want to use Realm because we need database functions beyond persistence. We need to query objects and relationships and perform other business logic (calculations, summaries, rollups) on our data while offline (disconnected from the server). \nI'm really excited to hear you are considering making a change like this for v1. Many Thanks.\n. I totally agree that Siesta should NOT try to be responsible for syncing data or state back up to the server. We were not expecting or even hoping for that - we are writing our own code manage that process. So I support the line you are drawing there.\nHowever I do have concerns about the evolution you are proposing to your original suggestion. BUT... they may be specific to our requirements and beyond your scope. Because of the security requirements in our industry (Health Care) we cannot save any data to disk that is not encrypted. Any data we persist to disk will need to be inside an encrypted Realm instance so we wouldn't be able to make use of the File-based EntityCache you propose above (unless we can encrypt it somehow). I was depending on us being able to re-populate the EntityCache from the models in our encrypted Realm Instance - which means we would need to save the URL's in the database AND have a way to read the data back into the EntityCache from the data stored in Realm. \nAnd now that I think about it... I guess this is a problem that existed in your original suggestion as well. Any caching we do will need to read/write to and from an encrypted store - which is one of the two reasons I was trying point your PersistantCache at Realm in the first place. The second reason, of course, is the additional processing we need to do on the data we plan to persist: object and relationship queries and rollups. \nHmmmm....\n. That works for me, Paul. We will plan to write an encrypted implementation of EntityCache for now, and follow the roadmap you laid out above.... and wait patiently for v 1.0 with the solution to our Realm problem. Again... many thanks.\n. ",
    "joaomvfsantos": "@pcantrell I'm having the same issue, on my side I can't do anything about the server so I was looking to do something like the work around you suggested. Seems the syntax is for a deprecated version of Siesta. I'm adding the ChangeEmptyResponseContentType transformer like the below, but still have Siesta returning me the \"Cannot parse server response\" error.\nconfigure(configurer: { (configuration) in\n     configuration.pipeline[.rawData].add(ChangeEmptyResponseContentType())\n     configuration.pipeline[.rawData].cacheUsing(PersistentCache<Data>())\n     configuration.headers[\"Authorization\"] = self.headers[\"Authorization\"]\n})\nPersistentCache is my implementation of EntityCache I'm using and the Authorization header, well, it's just an Authorization header. Any ideas?\nThank you!. @edwardmp Hey! Yes that makes sense, I could do those changes. How would you suggest doing this? Using a pre processor macro like this:\n```swift\nif swift(>=4.1)\n// .compactMap\nelse\n// .flatMap\nendif\n```\nI confess I'm not used to use pre processor macros, as such my only concern is that I would probably duplicate a lot of code (at least the whole block inside the map function).. @Linnk Thanks for taking the time to give a concrete example. I started to doing an approach like that but after @pcantrell comment I did not proceed. His view also makes sense to me.. @pcantrell I changed travis to use the Xcode 9.3 image but it's failing only on iPhone 4s simulator. Any ideas why?. This is solved in #244 Needs to get merged.. ",
    "jonsteinmetz": "Hey Paul, thanks. Let me know if there is any further information I can provide.\n. Actually there is a spot in Progress.swift that refers to Siesta.now(). Changing this to now() and changing the variable name now to timeNow seems to fix the issue. If this seems reasonable perhaps I should try out my first pull request.\n. Makes sense. Thanks.\n. Changes made. Sorry for the extra commit. I was using the Atom editor which apparently likes to make extraneous tab changes.\n. ",
    "joshhornby": "The cookbook sounds great.\nQuestion wise, how would you handle oAuth 2 with Siesta?\n. ",
    "rayfix": "Guidelines are just that, and I like the changes and exceptions you have made.  One that I am not sure about is\nService.resource(url:) \u2192 resourceWithURL(_:)\nThere is another guideline that says not to repeat type information.  Which would make it:\nService.resource(url:) \u2192 resourceWith(_: NSURL)\nI think the deprecation plan sounds good.\n. I had forgotten about the \u201cCompensate For Weak Type Information\u201d section.  Thanks for reminding me.  I like the way resource(\"/user\") looks too.  Getting pedantic here but if you call it resourceWithPath I would naively think I need to specify the full path: e.g. service.resourceWithPath(\"/widgets/\\(widgetID)\") which is wrong.\nOne thing I was wondering about was resources always seem to with a forward slash.   Is the shorter resource(\"user\") frowned upon?\n. +1 Generally I am a fan less typing, but this seems like a good change.  The on prefix makes it 100% clear that a closure callback follows (rather than say returning a bool or error type).  I also like that it groups both related operations together alphabetically and how that works with autocomplete.\n. Thinking aloud here but what about \n    resource.content(or: placeholder) .  \nThen change the current content() to untypedContent() or rawContent()\n(The or: is an idea I got from some API that Airspeed Velocity did recently.  I think it looks nice and is still clear.)\nFor the issue:\nresource(url:)\nresource(path:)\nYou could define a simple Path type that better documents Path as something more akin to a Rails path type that gets appended to a base URL.\n. resource(\"/users\")\nresource(absoluteURL: \"https://other.server/dingbats\")\nLooks good to me.\nif let user: User = resource.contentAsType() {\nif let user: User = resource.typedContent() {\nI slightly prefer typedContent.  Seems just as clear if not more clear than the first one (first looks like it should have an arg) and also is less typing. :haha:\n. Thanks for the reply!  Yes, I am using Cocoapods.  Probably works but I will verify it either today or tomorrow.\n. Worked like a charm!  Thank you as always @pcantrell \n. ",
    "radex": "\nWithout the ifNone: label, a call sounds as if the argument indicates the type \u2014 which is true, sort of, but confusing:\nTo my eyes, the guideline-breaking alternative reads best:\n\nThat's why it's a guideline, not a law!\nI do agree that this:\nresource.contentAsType(ifNone: placeholderImage)\nSeems best. The rationale being, ifNone doesn't really describe the method (fundamentally the job is \"cast content so that it appears as T\"), it describes the parameter. Most of the time, the job of the method makes the first parameter obvious (hence the guideline), but here, it doesn't. So the parameter makes sense.\n(Having said that, I think it would be worth rethinking this particular API either way, because it's really not obvious that the ifNone not only supplies the default value but also determines the type of the cast return value.)\n\nService.resource(url:) \u2192 resourceWithURL(_:)\n\nAgain, I think url: is better than WithURL in the name. The whole \"fooWithType\" convention is bleh to me. The only potential upside is that you have a different symbol for the method so you can reference it unambiguously. But I'd consider it a language limitation and I'm not sure if it matters here anyway.\nCorrect me if I'm wrong, but AFAICT the difference between resourceWithURL and resource is that the former takes an absolute URL, and the latter is relative to the service's base URL \u2014 right?\nI feel like this semantic difference isn't well conveyed in the naming, and the fact that \"URL\" doesn't just mean \"NSURL\", as there's an override that takes an equivalent URL string, confuses matters even more.\nWhat about resource(absoluteURL:) perhaps? Or maybe even resource(absolute:), since at call site the type is clear. The former is a bit more verbose than just (url:), but clearer about the intention, I think.\n\nFor this one, there\u2019s not an obvious imperative verb rephrasing that isn\u2019t either too verbose or less clear:\nConfiguration.beforeStartingRequest(_:) \u2192 same\nThe guideline-conforming executeBeforeStartingEachRequest or addPreRequestHook don\u2019t read as well.\n\nAgreed. I think the general rule is sound, but I think there's great value in this idiom as well, and the reason it works well is because it's followed by a closure. So it's going to look like this:\nConfiguration.beforeStartingRequest {\n   ...\n}\nWhich is super clear and nice. And in situations where you'd pass a reference to a method (not sure if applicable here), it's going to be clear too, as you'd generally make that an imperative verb phrase:\nConfiguration.beforeStartingRequest(doSomething)\n\nRequest.completion(:) \u2192 onCompletion(:)\nRequest.success(:) \u2192 onSuccess(:)\nRequest.newData(:) \u2192 onNewData(:)\n\n+1 on that as well.\nI'm wondering if a similar pattern wouldn't also work well here:\nResourceObserver.onResourceChange(...)\nonResourceRequestProgress\n\nThis one also runs afoul of \u201cAvoid abbreviations\u201d:\nResource.withParam(_:) \u2192 same\n\nI think this is fine. param is a common abbreviation, especially in HTTP/REST handling domain.\n\nService.baseURL \u2192 base\n\nThis is one of those cases where repeating type information might be preferable after all. And the reason why is that \"URL\" isn't just type information here, it also actually describes the thing the property is. And \"base\" works to describe \"URL\", not as a standalone noun.\nAt first glance \"Service.base\" seems to suggest that there's a class called Base, or perhaps ServiceBase, or that there's some fundamental concept of a \"base\". And there isn't. There's just a base URL.\n. > let stringContent: [String]? = resource().contentAsType()\nBut that sounds weird too. \"content as type\"\u2026\u00a0yes, what type? Where's the type parameter? To my eyes, it looks incomplete.\nWhat about: resource().typedContent()?\nIt doesn't say much more, but there's no confusion. It just says \"this is a typed version of the content\", and you just about have to assume the type will be taken from the context this is passed to.\nYou're right that when assigning to a variable it's not very useful, since as? does the job. But it could be useful when you want to immediately pass the typed content as a parameter to some method. Then that method just supplies the type.\nAnd I think now typedContent(ifNone: ...) works much better, naming-wise.\n\nSince the distinction between the two methods is not absolute / relative, but rather URL / path, maybe this naming I shied away from is the right one after all:\nresourceWithPath(:)\nresourceWithURL(:)\n\nOkay, so I did get the point, just used the wrong words to describe the difference.\nBut I would argue that \"path\" vs \"url\" is just as confusing. At least in the context of our community. All fault is on Cocoa, where people sort of learned that \"path\" is nothing else than a NSString version of NSURL (caveats apply).\nMy reaction to this is \"oh, so if I want to pass a string I use resource(path:), and when I want to pass NSURL, I use resource(url:)\". Which misses the point.\nObviously something super verbose like \"resourceRelativeToBase\" would be undesirable as well...\nIdeas?\n\nYou have a good point about ResourceObserver.onResourceChange(...), thought it\u2019s a bit different because it doesn\u2019t accept a closure, so I\u2019m not convinced it should follow the same convention. The Cocoa way would be resourceDidChange(\u2026).\n\nFair point!\n. > What about this?\n\nresource(\"/users\")\nresource(absoluteURL: \"https://other.server/dingbats\")\n\nFunnily enough, that's exactly what I suggested a few comments before :) (albeit admittedly didn't make it this explicit).\nSo yes, +1. I'd also be willing to consider dropping the \"absolute\" word, and just have resource(\"/path\") and resource(url: \"http://...\"). I have a sense the distinction is still perfectly clear, but I could be wrong.\n\nThis isn\u2019t bad, but it's not perfect. It makes it sound like a resource can either have \u201ctyped content\u201d or not, but all content is typed; it just may be of the wrong type.\n\nGood point, haven't thought of that.\nI think the reason why I'm drawn to the typedContent name is that I'm finding this an increasingly common pattern in my Swift code, to have methods that provide typed versions of untyped methods. (Generally this takes a form of extending an Apple class when some method or property was just defined as id or NSArray, despite being more specific; but also makes sense in deserialization context, like here.)\nAnd when it starts being a pattern, seeing \"foo\" and \"typedFoo\" pairs in many places becomes a nice convention, and has a nice symmetry.\n\nOut of these:\nif let user: User = resource.contentAsType() {\nif let user: User = resource.typedContent() {\nif let user: User = resource.content() {\nif let user: User = resource.contentOfType() {\nif let user: User = resource.contentAsMatchingType() {\nI still like typedContent best.\ncontentOfType seems like no improvement over contentAsType (perhaps even worse since there's no connection to as?).\ncontentAsMatchingType is really good, most descriptive of all the above, but I think less verbose name would be good in this context, because I think we should to encourage people to use the typed version whenever possible.\nEDIT:\n\"content\" would be great (and, if needed for whatever reason, \"rawContent\" for untyped version) if only the type was explicit or unambiguous somehow. But since it's inferred from the context, I think it would only bring confusion.\n. > Even this simple case:\n\nif let user: User = userResource.typedContent() { \u2026 }\n\u2026is more pleasant than:\nif let user = userResource.latestData.content as? User { \u2026 }\n\nI'm not so sure about this use case (I tend to avoid explicit type declarations inside methods like that), but one that I find compelling is when the type can be inferred from a method you're passing typedContent() to.\n\nOn reflection, I\u2019m liking the new use of \u201cabsolute\u201d in the method name, but am on the fence about this:\nresource(absoluteURL: \"https://other.server/dingbats\")\n\u2026versus this:\nresourceWithAbsoluteURL(\"https://other.server/dingbats\")\nLike you all, I find the first one appealing, but it does clearly violate Apple\u2019s guidelines as well as common practice.\n\nThe common practice is based on the fact that Objective-C doesn't really have the concept of argument labels the same way Swift does, rather, it's all part of a single the method name. So you have a common pattern of fooWithBar(arg), but I would argue this is based on ObjC's limitations/design, rather than a preferred syntax in Swift.\nNotice how Objc->Swift bridging does a better job at translating init names.\n(instancetype) initWithName: (NSString*) name\nbecomes:\ninit(name: String)\nBecause it simply makes more sense. \"Name\" describes the parameter, it's not really a part of the method name itself.\n\nAs noted before, I also disagree with you saying that this \"clearly\" violates guidelines. Again:\n\nIn other words, usually:\nFirst parameters to methods and functions should not have required argument labels\n\nNote \"usually\". The guidelines note a few exceptions, but I would argue the list is incomplete, and this is a good use case where it makes more sense to use the explicit argument label rather than force it to be part of the name.\nAlso, don't forget about:\n\nOmit Needless Words. Every word in a name should convey salient information at the use site.\n\nWhy say \"with\" in the name, when separating \"absoluteURL\" into a param name conveys the same semantics (and arguably, better)\u2026\n. Awesome! Great discussion, and thanks @erica for chiming in!\n\nFWIW, I really like the new guidelines in a great many respects. They\u2019re just too prescriptive given the narrow range of cases they actually consider \u2014 particularly around part-of-speech questions and parameter naming.\n\nSame. I think the guidelines have room for refinements, and if there's something we can do as a community to show examples where seemingly the best option goes against the guidelines, then we should do it.\nLet's just not get hung up on following the guidelines 100%. It's \"guidelines\", not \"the law\" \u2014 the word itself suggests that it describes the 90% or maybe 95% cases, but there's always room for good judgement for the edge cases. I'm more interested in the spirit of the guidelines, not the letter.\n. ",
    "erica": "I'm not ignoring you as style is pretty much at the top of my interest list right now, it's just that I'm dealing with one ridiculous family drama after another. Last kid goes back to school on Thursday.\nI'm having big issues with the current minimized APIs in that you must quick-look the apis often to see the name of the parameter label, which is not a reasonable thing to do when you're trying to read code.\nApple's guidelines are squooshing together usecases: first, is implementation, where you see the entire signature (their primary design goal) but they're not properly serving the more common use-case: reading and reviewing. Remember: code is written once and read often, so readability should focus on serving the latter over the former and I'm not sure their guidance s proper here.\nThere's the older style API guides that would suggest: \nresourceWithAbsoluteURL(\"https://other.server/dingbats https://other.server/dingbats\")\nIt's clear, its immediately understandable, and it's a mouthful. vs this which is not \nresource(\"https://other.server/dingbats https://other.server/dingbats\")\nThis would be way better but it violates style with its initial label, use of type, etc.\nresource(absoluteURL: \"https://other.server/dingbats https://other.server/dingbats\")\nGuidance says:\n- Omit Needless Words: With is a needless word\n- Describe a role (\"resource\") rather than its type (\"URL\")\n- Use a noun phrase (this doesn't mutate and it's functional, returning something)\n- Avoid ambiguity (use \"absolute\" to differentiate from relative or whatever)\nso I suppose the \"suggested\" API would be:\nabsoluteResource(\"http://other.server/dingbats http://other.server/dingbats\")\nWhich I don't love\n-- E\n\nOn Jan 10, 2016, at 10:40 AM, Paul Cantrell notifications@github.com wrote:\nI'm not so sure about this use case (I tend to avoid explicit type declarations inside methods like that), but one that I find compelling is when the type can be inferred from a method you're passing typedContent() to.\nSure, you could also do this nice refactoring:\nshowUser(userResource.typedContent())\nYou\u2019d then have to make showUser()\u2019s arg optional:\nfunc showUser(user: User?) { \u2026 }\n\u2026but that\u2019s probably the right thing anyway, since \u201cshow that there is no user\u201d is also a valid & important operation.\nAnd I still do like typedContent just fine after sleeping on it and don\u2019t have a strong opinion either way, so I\u2019ll defer to the judgement of R* on this.\nOK, Radek, I think you\u2019ve convinced me on resource(absoluteURL:). I like it better that way as a matter of personal taste, and I agree completely with all of your reasoning.\nI say \u201cclearly violates\u201d because after that \u201cusually\u201d you mention, the Apple guidelines then say, \u201cThere are only a few exceptions,\u201d and this is not among those they list. However \u2026 I don\u2019t see any examples in the guidelines that clearly promote a first arg label to be part of the method name. The closest they come is this:\nfunc addObserver(_ observer: NSObject, forKeyPath path: String)\n\u2026but in this case, addObserver seems like an operation that\u2019s distinct from other kinds of adding, and it makes sense for \u201cobserver\u201d to be in the base name. Is that line of thought inconsistent with the guidelines? Well, they do say this:\nMethods can share a base name when they share the same basic meaning but operate on different types\nThat\u2019s \u201ccan\u201d and not \u201cshould,\u201d but it does suggest we\u2019re not out of line thinking that method base names are about the method\u2019s role, and not its first argument.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/bustoutsolutions/siesta/issues/15#issuecomment-170373590.\n. I think what we need to do is start writing some proper API guidelines that aren't limited to or just a response to the ones currently on offer (set up a repo?), start hitting them with real world examples like siesta, and then submit our guidelines once Apple opens up the API guides to public review.\n\n-- E\n\nOn Jan 10, 2016, at 2:32 PM, Paul Cantrell notifications@github.com wrote:\nThanks, Erica. I didn\u2019t think you were ignoring us! Certainly nobody\u2019s obliged to respond to a random Github mention, especially on the weekend, so I\u2019m delighted to have you jump in at all.\nTo give some background, because I know this is a long thread to jump into: there are several different resource(...) variants going on. They all are essentially the same operation underneath and return the same thing, but take different parameters.\nOne variant takes a subpath of a service\u2019s base URL; the other takes a fully independent URL, and that latter one comes in two flavors that accept String and NSURL. So there\u2019s both a \u201cpath vs. URL\u201d distinction and an \u201cunder the base URL vs. absolutely nothing to do with base URL\u201d distinction.\nI lean (as I think do Ray & Radek) toward making the more common \u201csubpath of base URL\u201d variant be unlabeled, because with the strings you\u2019d actually be passing to that, it really is pretty clear at the call site:\nmyAPI.resource(\"/dingbats\")\n\u2026whereas more explicit labels like this get ugly, especially given that they\u2019re such a common case:\nmyAPI.resource(subpathOfBaseURL: \"/dingbats\")\n(end of background)\nI totally agree that this is not good:\nabsoluteResource(\"http://other.server/dingbats\")\n\u2026because, among other reasons, there\u2019s no such thing as an \u201cabsolute resource.\u201d Every resource has a fully resolved URL; the only difference between all these resource(...) methods is how that URL is derived. The word \u201cabsolute\u201d modifies the parameter, not the result.\nWhen you say that \u201cthis would be way better:\u201d\nresource(absoluteURL: \"https://other.server/dingbats\")\n\u2026you are in agreement with everyone else in this thread. It passes my own gut check, and three other developers whose opinions I respect a lot say it looks good to them. That\u2019s enough for me to go against the Apple guidelines.\nIf we do get a chance to comment on the API guidelines on swift-evolution, then we can make our stand there! Get your torches and pitchforks ready, I guess?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/bustoutsolutions/siesta/issues/15#issuecomment-170396183.\n. \n",
    "lifeisfoo": "I've used the wrong .xcworkspacefile to open the xcode project.\nThe correct was in the the project root.\n. I'm trying to use it in a new production app :smiling_imp:\n. Sure. Thank you for your work.\nP.s.\nI've added this QA to stackoverflow to help as many people as possible: \nhttp://stackoverflow.com/questions/34185372/cocoapods-no-such-module-siesta/34185373\n. Ok, but I think that a short note in the README (with a link to the guide) could be also useful.\nEvery time I look for something, I start from the README :).\n. No problem, but add this information in the Contributing section of the README ;).\n. Yes, res is a SwiftyJSON.JSON.\nI've already tried with .dictionary but seems that it generates a non valid type for the method signature:\n\nArgument type '[String : JSON]?' does not conform to expected type 'NSJSONConvertible'\n. Yes, this is right, but there is a typo in the call: the parameter is called jsonDict, not json :).\n\nextension Resource\n    {\n    public func request(method: RequestMethod, jsonDict: JSON) -> Request\n        { return request(method, json: jsonDict.object as! NSJSONConvertible) }\n    }\nThank you for the help.\nDo you think that could be useful to add this example in a \"Cookbook\" page inside Siesta docs?\n. I'm using 1.0-beta4 with Cocoapods.\nThese files contains the version number:\n./Podfile\n./Podfile.lock\n./Pods/Manifest.lock\n./Pods/Siesta/README.md\n./Pods/Target Support Files/Siesta/Info.plist\nI fixed it editing the version number in the last file (now .ipa upload works fine).\n. Sure.\nPodfile:\n```\nplatform :ios, '8.0'\nuse_frameworks!\npod 'Siesta', '~>1.0-beta.4'\npod 'SwiftyJSON', '~> 2.3'\ntarget 'MyApp' do\nend\n```\nPodfile.lock:\n```\nPODS:\n  - Siesta (1.0-beta.4):\n    - Siesta/Core (= 1.0-beta.4)\n  - Siesta/Core (1.0-beta.4)\n  - SwiftyJSON (2.3.2)\nDEPENDENCIES:\n  - Siesta (~> 1.0-beta.4)\n  - SwiftyJSON (~> 2.3)\nSPEC CHECKSUMS:\n  Siesta: 4bda1f6e7e0431b64bdfe9d3f902c34d90822c27\n  SwiftyJSON: 04ccea08915aa0109039157c7974cf0298da292a\nCOCOAPODS: 0.39.0\n```\n. ",
    "onekiloparsec": "Hi. Yes I did a fork because I needed an OSX target. It is not entirely obvious since there are some UIKit stuff involved. As for now, I still have to make it work for my project. But as soon as I can, I'll make a pull request.\n. That's definitely something we must work on for the desktop, I agree. NSCache has 2 properties we could build upon, maybe? \n- var totalCostLimit: Int, The maximum total cost that the cache can hold before it starts evicting objects\n- var countLimit: Int, The maximum number of objects the cache should hold\n. Thanks for the interesting read. I was just suggesting taking these NSCache concepts, but not NSCache itself. I'm sure you've studied the subject a lot more than me!\n. Thanks for your great response to the PR. I need to make some more tests on my OSX projects, but so far it works. As for the prefixes, I agree. I used \"BOS\" since that's the one I found in your code. But if you prefer a more streamlined-swifty way, we go for it! In my other Swift projects I also removed all the prefixes, but that's for types I own. UIKit classes continue to hold their prefix for instance. And since we have here typealiases... \nAs for Nocilla, I would agree to completely remove it. Actually, the fewer dependencies the better. I have some troubles running the tests right now, but I'll try to find another way.\nI realise there is quite a bit of work left. Although I am enthusiastic to see this PR pushing things forward, it will require some more time.\n. Great work! I'm glad to see tests passing all green on OSX target.\nI will now work on the Swift sdk I am writing here https://github.com/onekiloparsec/arcsecond.io.sdks and let you know asap how well it works.\nAs for the other subjects:\n- Thinking on long term, I would go for no prefix at all. Look, Alamofire has no prefix, for instance.\n- As for Nocilla, I'll make a PR asap.\n. I have some troubles making the ResourceStatusOverlay work. And wondering... is this really the core of Siesta? It adds a lot of troubles (in addition of me not understanding how the xib is really hooked up).\nBut I'd love to keep the logic of it, with state changes. One just need to remove the UI part. At least, for OSX the whole coverParent stuff is not really useful anyway.\n. I'm glad to basically agree with everything. I will push the small changes to merge the PR asap.\n. I made the changes, which means basically getting rid of all the OSX work I did at first. But that's life. :-) I deleted the OSX tests target as well, as it doesn't make real sense to keep all typealiases just to run the tests (I must say I haven't read much the details of the tests, just that UIViews are used).\nI also had to keep the typealias for (NS/UI)Image, because it is used in the ImageResponseTransformer. \n. Ok I will put osx tests back \n. I'm glad I made an atomic commit on that matter. So I did a revert, and changed UIView classes for NSData in tests. On my side, I can run both iOS and OSX tests, and they all pass. \nYes, we're close!\n. Hm, Travis says it fails. But I couldn't find the error.\n. Got it. Yesterday I renamed the iOS scheme without changing the .travis file. Bad idea. I reverted to the old scheme name.\n. BTW, https://github.com/AliSoftware/OHHTTPStubs seems a good candidate to ditch out Nocilla.\n. Avec plaisir! If I have time, I'll keep an eye on the Nocilla replacement.\n. I had so many nightmares with the Behemoth, as you say, I still prefer the simplicity and distributed philosophy of Carthage. But to give a try, CocoaPods has certainly a larger userbase.\n. That should be enough complexity for now on OSX. Thanks!\n. That's one of the very motivation for writing middlewares... \n. @pcantrell Sorry for the delay. The short answer is no. But I wanted to make a detailed answer after investigating a bit more.\n. Still struggling... I've updated to beta10, but I have an error message (also present with beta 8): \n/Users/onekiloparsec/apps/arcsecond.swift/arcsecond/Arcsecond.swift:31:14: Cannot invoke 'configureTransformer' with an argument list of type '(String, () -> ())'\nFor some reason, subclassing Service and calling in the init method:\nself.configureTransformer(\"/\\(self.APIVersion)/objects/*\") {\n            //\n        }\nproduces this error (whatever I put in place of the //). Sorry for the trouble. I've re-read the documentation again, but I am probably missing something here.\nThe message says further more:\n/Users/onekiloparsec/apps/arcsecond.swift/arcsecond/Arcsecond.swift:31:14: Expected an argument list of type '(ConfigurationPatternConvertible, requestMethods: [RequestMethod]?, atStage: PipelineStageKey, action: PipelineStage.MutationAction, onInputTypeMismatch: InputTypeMismatchAction, transformErrors: Bool, description: String?, contentTransform: (content: I, entity: Entity) throws -> O?)'\n. Sure. here it is: SiestaSwiftTypeRabbitHole.zip\n. Thanks a lot for your insightful help. It compiles indeed. But somehow, I couldn't get anything out of it anymore. I mean, when I have the configureTransformer call uncommented, not only it is never called (hence decode is never called), but the resource observer closure isn't called either! Am I missing something?\n. Even stranger, whatever the presence of a custom transformer or not, the following makes my Xcode editor crashes:\nself.hd5980 = self.arcsecond.object(\"HD 5980\")\n    self.hd5980!.addObserver(owner: self) { (resource, event) in\n        print(\"resource \\(resource.typedContent())\")\n    }\nwhere the object func is defined like this in the Service subclass:\npublic func object(name: String) -> Resource {\n    return self.resource(\"/\\(self.APIVersion)/objects/\\(name)\")\n}\n. Thanks for the typedContent(), it's a misuse of mine.\nAs for the contentTransformer, I see \"The network connection was lost\". I have no clue how to fix it. Maybe with a different value of keep-alive, but still, I don't see why this suddenly stop working just because I'm using a transformer in my client code.\n. I am not so sure how I did fix that issue, but I did. It seems that increasing TIMEOUT value in my server from 30 to 60 did the trick, and I now have something that goes through the decoding of Argo! The only additional change was to set the type of content in the closure to NSDictionary rather than NSData. Thanks for your help! \n. Yes, I deleted the Test-only subgroup. I really wanted to keep things as exactly as it was, but it took quite a few steps to make sure I had the right frameworks all named the same in the right (build) places. And this subgroup just got deleted. That's the only subgroup deletion I made I think.\n. I didn't notice that both were present in the same FRAMEWORK_SEARCH_PATHS group. \nIt works even if these directories are not present. But it may pick up the wrong one, maybe. We have to make sure there is only Mac for OSX target and iOS for other targets.\nNotice how I struggle trying to answer the quick comments you make before attacking the big one. :-) I thought it would be quicker. But I am glad this PR is welcomed! I made it to piush work forward\n. Good point, definitely something to check before merge.\n. Yes, sorry. I'll fix that. I was too happy to submit the PR first.\n. Yes of course! (it's probably for historical reasons) I'll fix that \n. The one Xcode produces. At least on my machine. But I will fix all of this.\n. I couldn't remember why exactly I changed that. But indeed, I think I just came up with the conclusion that using the extension, and a struct inside it, ins't compiling on OSX, while putting everything on the main struct does.\n. Sure! You should have received an invite by now.\n. Great! It starts to be late for me. If you don't hear about me in the next hours that's because it's the night! I'll keep the Nocilla issue for the next days. Cheers.\n. I couldn't remember when I saw a no-args form, I thought it was supported but not really promoted as good practice. I may be wrong. We do as you prefer.\n. That's right! Very important to not break existing API.\n. Specifying iOS explicitly automatically discard support for tvOS and watchOS, isn't it? \n. I haven't the time to check this. A consistent behavior / error handling for tvOS and watchOS could be the subject of a next release. As for now, yes, some kind of compiler error is good.\n. This doesn't work on OSX (and was the reason for adding the #if directive. The layer isn't necessary present on OSX, as in iOS. And using a CAlayer, or not, is not as automatic as in iOS and requires more code. The #if directive was a quick workaround, but probably not satisfactory. I'll investigate.\nWhen building Siesta's OSX target with Carthage from another project, I get this:\n/Users/onekiloparsec/Apps/arcsecond.io.sdks/Swift/Carthage/Checkouts/siesta/Source/UI/ResourceStatusOverlay.swift:99:14: error: cannot use optional chaining on non-optional value of type 'CALayer'\n. No problem. I managed to make Siesta work on OSX. But only the basics (getting a resource). More to come soon.\n. ",
    "igostavro": "whoever starts on this, just a tip:\nI pulled from git and started my own local pod spec.\nHad to make the following changes:\n```\ns.resources = \"Source/*/.xib\" <<-- remove xibs\ns.subspec \"Core\" do |s|\n    s.source_files = \"Source/*/.swift\" #<<-- only copy swift files as source (WAS pulling xibs)\n  end\n```\nThe xib in the project is an iOS xib that prevents TVOS from compiling. Once I excluded it from the pod everything seemed to compile just fine. Testing now.\n. As a followup:\nmaybe ResourceStatusOverlay.xib (and maybe related code) should be moved into a subspec called ResourceStatusOverlayIOS\n. ",
    "victorcotap": "It would be very beneficial if it could work on watchOs as well. Being able to build one api client for all platforms would be a tremendous improvement\nAlso splitting UI and Core code might help the process as @igostavro suggested\nEDIT: Actually WatchKit includes way of getting data through the iOS app so it's ok if it's dismissed for now. tvOS would be amazing to get tho. Can we split Siesta and SiestaUI ?\n. I'm now using this method as well. It appears to be working fine. I will rebase on 1.1 and upgrade to swift 3.1 during the week, can't deal with having Xcode mess my dependency management at the moment ;). I replied into your question above ;). Ok through the swift 3.1 Xcode 8.3 update, it somehow botched the schemes so I had to re do them.\nI've also checked all your changes and it seems to be working fine.\nIn theory it should be rebased on master, working with Xcode 8.3 and Swift 3.1 but I could use a second pair of eyes on this.. watchOS does support NotificationCenter.\nwatchOS unfortunately doesn't support MemoryWarningNotification so since it's the only use of NotificationCenter here, I returned early since the #if needs a statement.\nI'm open to suggestions on how to make it cleaner. go for let. ",
    "tracicot": "What was the solution? I'm seeing the same thing now that I'm finally using Xcode 8.\n. ",
    "JoiMeseery": "I got the same issue here with iOS 11, Xcode 9 :\nUserInfo={NSErrorPeerAddressKey=<CFData 0x60400028d2f0 [0x1083299b0]>{length = 16, capacity = 16, bytes = 0x100201bb0de526680000000000000000}, _kCFStreamErrorCodeKey=100, _kCFStreamErrorDomainKey=1\n\n\"The operation couldn\u2019t be completed. Protocol error\". \n",
    "jyounus": "Hey there, was wondering if there has been any progress with the Realm integration and if/when to expect to get a sneak peak? Thanks.\n. No worries, I was just wondering if this got anywhere. Appreciate all the work and efforts that have and are being put into this project! :)\n. Hey @pcantrell, thanks for implementing this functionality. The project I was working on is done now, we ended up using a different API lib to accomplish what we were trying to do. I'm definitely going to use Siesta in the future to give this a try!\n. ",
    "Alex293": "Does anyone have made some kind of working entity cache with realm ? Or a realm extension ?\n. Hi, first great work ; this lib is really changing the way we do networks in iOS apps !\nAny updates on this issue ? \ni.e. I will have to use urls like /users/* /users/1 and /users/1/comments and I don't want to have to handle comments in /users/* resource. Should I use your proposal with reg ex (will it work) ?\n. Ok that's what i thought when i saw that this was exactly the same content\n. Its all ok now !\n. eventCategoriesResource.addObserver(owner: self) {\n            (resource, event) in\n            if case .NewData(.Wipe) = event\n            {\n                eventCategoriesResource.load()\n            }\n            else if case .NewData = event\n            {\n                gEventCategories = resource.latestData!.typedContent(ifNone: [])\n            }\n            if case .Error = event\n            {\n                print(\"Error : (resource.latestError?.userMessage)\")\n            }\n}\nIt seams that this solve my issue but i have to add this test to each request so I'm sure there is a better way to handle this. If anyone have a better way to do it ?!\nI'm pretty sure i'm missing something but if its the only way I suggest to move the wipe case to a new kind of event to make it clearer. Ex if case .Wiped = event\n. Awesome ; just what I wanted ! Thank you for these explanations. It is clear to me now. \n. Hi I'm not expert with siesta and I don't know moya.\nThere is an extension for reactiveCocoa and it's very shortly written so proving this to rx should be easy.\nI use JWT with siesta, tokens are not in the heart of Siesta but are easy to integrate with. Look at the sample in the user doc and in the closed questions there are samples with token.\nYou should definitely give Siesta a try :)\n. This works well but it would be better if it was handled by Siesta as Reedyuk requested. The main reason is that its easy to use with the code above but as RemoteImageView use it's own service I have to configure it too and so on for every small service designed for special cases.\nEdit : didn't saw the pr above when writing, going to check that\nEdit 2 : You still have to call service.showRequestsWithNetworkActivityIndicator() on every service you use. It would be nice to have this as the default setting and be able to remove it for a corner case service \n. The problem is that sometimes you have multiple service that you don't own like in RemoteImageView that create it's own service\n. Indeed that would be very convenient !\n. I've tested this in my project this is perfect\n. Same here !\n. Awesome at least I can go on ! Closing this for now, if I have issue with this fix I'll open it again. If you think of some way to apply it only on one particular resource or request to be sure there is no side effect I'd be interested.. Each URL give a different resource so I you have new/all and news/1 you have two resources. Now if you look at the quick start in the request section for post etc there is a way that you use the result of a request to update an existing resource. I you want to perform a request without cache you should use resource.request(.get) instead resource . I feel like ResourceStatusOverlay is supposed to be used as a drop-in composant and should not not be subclassed or customised a lot. So it would be very convenient that Siesta handle internationalisation but It would require then a lot's of work to keep it compatible with a large number of langages. On the other hand providing an optional title property wouldn't be a great effort and would give the user a more complete customisation.. Sure. This is what I did but it's not very convenient to keep a pointer to child and parent a t the same time. For now it's working with this so I close this issue but add here any informations on a better way to do it.. Use .withParam() to add a GET parameter.\nUse .child() to add a path component.\nEx : service.resource(\"/1234567\"/do-stuff).withParameter(\"timeframe\", 5). Your adapter could just chain a withParameter in a for loop. Otherwise there is a way to create a resource directly from url look for something like resource(withUrl ). I don't remember the actual way to do it but I think it's in the quick start doc. Would this library be complex to implement into Siesta's NetworkActivityIndicator ?. There are some closed issues about making an extension for Realm and a piece of code on the net. \nAltho I don't know the status of this but I'm interested in doing the same thing. As of now I didn't dived into developing the extension as I'm still building my app and improving my swift skills but I'd be glad to try to help if you start an extension.. Also as in Siesta Res and Res.child(id) is not the same resource you will need to add someway to link those two resource if you want to really benefit from using Realm as the cache for Siesta. Otherwise Realm would just give you persistent for Siesta but you would loose the Search Backlinks etc links or things like this. \nWell I not completely sure about that and I may have missed something but that what I came to while try to play around Realm with Siesta. You need to override the request, I've used something like this :  \nAPI.imageUploadResource.request(.post)\n{\n            (request) in\n            let boundary = \"Boundary-(NSUUID().uuidString)\"\n            request.setValue(\"multipart/form-data; boundary=(boundary)\", forHTTPHeaderField: \"Content-Type\")\n            let image_data = UIImagePNGRepresentation(myImage.resizeWith(width: 300.0)!)\n            if(image_data == nil)\n            {\n                return\n            }\n            let fname = \"photo\"\n            let mimetype = \"image/png\"\n            let body = NSMutableData()\n            body.append(\"--(boundary)\\r\\n\".data(using: String.Encoding.utf8)!)\n            body.append(\"Content-Disposition:form-data; name=\\\"photo\\\"\\r\\n\\r\\n\".data(using: String.Encoding.utf8)!)\n            body.append(\"hi\\r\\n\".data(using: String.Encoding.utf8)!)\n        body.append(\"--\\(boundary)\\r\\n\".data(using: String.Encoding.utf8)!)\n        body.append(\"Content-Disposition:form-data; name=\\\"photo\\\"; filename=\\\"\\(fname)\\\"\\r\\n\".data(using: String.Encoding.utf8)!)\n        body.append(\"Content-Type: \\(mimetype)\\r\\n\\r\\n\".data(using: String.Encoding.utf8)!)\n        body.append(image_data!)\n        body.append(\"\\r\\n\".data(using: String.Encoding.utf8)!)\n\n        body.append(\"--\\(boundary)--\\r\\n\".data(using: String.Encoding.utf8)!)\n\n        request.httpBody = body as Data\n    }\n    .onSuccess(\n    {\n        [weak self](entity) in\n        print(\"ok\")\n    })\n    .onFailure\n    {\n        (error) in\n        print(\"ko\")\n    }.start(). You still need to adapt the fname var tho. It is the name of the image file that the server will create upon data reception and \"photo\" the name of the var php will use. Boundaries related code is used for multiparty to separate parts. . https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2\n\nAt the very end of this page there are informations about multipart why a body example structure. Yes I managed to achieve what I wanted ! Closing this. ",
    "andrewloyola": "a bit more detail, the delegate version works with the following:\nfunc resourceChanged(resource: Resource, event: ResourceEvent) {\n    if let content = resource.typedContent() as MiniUser? {\n        refreshText(content)\n    }   \n}\nbut i'm having some trouble still with the closure version.  My understanding from the example is that it should infer the type of typedContext(), so there shouldn't be any ambiguity.\n. \ud83d\udc4d thanks @pcantrell that  worked well! (I went with the alternative version with the unwrap in the closure)\nthe only thing different from your untested version was that that XCode makes me add owner to addObserver, like this:\nAPI.resource(\"/profile/\").addObserver(owner: self) { ... }\n. Ah, yes the parens definitely needed to be added, but does not fix the problem.  Unfortunately removing the global SwiftyJSON transformer and instead using the raw jsonDict seems to have the same problem too.  Investigations ongoing...\n. Some progress!\nconfigureTransformer(\"/profile/\") {\n        Mapper<User>().map($0.content as Dictionary)\n    }\nthis is close! , but now I'm having trouble grabbing the data from the resource in the closure.  currently using this, which does not work.:\nif let user: User = resource.typedContent() {\n                self?.refreshText(user)\n            }\nor this:\nif let user = resource.latestData?.content as? User {\n                self?.refreshText(user)\n            }\nrefresh text is never called in either case, but I do see the below in the debugger, so I know that the object is in there somewhere...\n\nis there a good way to get at it?\n. ok this seems to fully work for accessing the data.  it seems like one too many unwraps, but since resource.latestData.content ends up as a User? from the transformer, I ended up with this:\nif let optionalUser: User? = resource.typedContent() {\n                if let user = optionalUser {\n                    self?.refreshText(user)\n                }                    \n            }\nfor reference from the previous posts, this was the ObjectMapper call that worked in configureTransformer:\nconfigureTransformer(\"/profile/\") {\n      Mapper<User>().map($0.content as Dictionary)\n  }\n. Sorry! I should have been more clear, all of your examples do indeed compile, but none of them succeed in unwrapping at runtime.\nI think the second one:\nif let user = resource.typedContent() as User? {\nshould work, based on what I see in the debugger, but it fails to unwrap like the others.\n. Yup, with that print()\n---------> Optional(Swift.Optional<SwiftAPI.User>)\nalso, appreciate the tip on optionalUser.\n. thanks, looking forward to it!\n. Confirmed as fixed, sorry for the delay.  much appreciated @pcantrell \n---------> Optional(SwiftAPI.User)\n. @pcantrell just curious, any plans to properly add a release with this change?\n. got it. thanks!\n. this change would be great.  we've actually gone outside of siesta in a couple of instances where the PUT/PATCH return data is different/nonexistent compared to the GET that is configured via Siesta and used 99% of the time\n. makes sense.  thanks for the update!\n. sure! i will take a look at that shortly\n. @pcantrell done.\n. ",
    "o15a3d4l11s2": "Is this change included in the latest released version?\n. @yehe01, if using Cocoapods, you could set the pod as\npod 'Siesta', :git=>'https://github.com/bustoutsolutions/siesta'\nThis will make Cocoapods use the master branch.. +1\n. ",
    "yehe01": "@pcantrell Hi,\nThis fix has not been merged to V1.0 right?\nWhich installation method should I follow to use master branch?\nI am using cocoapod.\nThanks.. ",
    "MPiccinato": "That makes a lot of sense with Swift. I guess from the API of a Siesta Service class I made an assumption that 'self' would be the qualifier for adding an extra observer to that resource. Is there a use case to adding multiple 'self' owners to a specific resource?\n. I understand now with that example. My pattern was to only have one observer per a resource per a controller. Having multiple closures available I can see being helpful. I will switch to using the just addObserver(self) for my current case and implementing ResourceObserver protocol.\n. Thanks for the detailed response! That last part was exactly what I was looking for.\nI assumed that the Error structs were useable since they are \"public\" structs. I guess I need to go back and read up on that.\n. ",
    "nabbestemmia": "Thank you, I'll follow your advices; I haven't other options, since I don't own the server side\n. Ok, thanks a lot!\n. I'll try asap and let you know. For the time being, thank you so much!. Unfortunately, the test server of the company I work for is \"untouchable\", because life is hard and then you die...\nAnyway, thank everybody for the help. I'll try the solutions you suggested. . I resolved this way:\nI created this class\nclass UntrustedCertificatesDelegate: NSObject, URLSessionDelegate{\n    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {\n        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust{\n            let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)\n            completionHandler(.useCredential, credential)\n        }\n    }\n}\nand then used it like this:\nlet delegate = UntrustedCertificatesDelegate()\nlet ns = URLSession(configuration: conf, delegate: delegate, delegateQueue: nil)        \nsuper.init(baseURL: testUrl, networking: ns)\n. Thank you @reversepanda \nThis topic was really useful to me.\nIn my humble opinion, redirects should be banned from REST APIs.\nMay I ask you how changing from 30x to 20x affected the behavior of your application?. @reversepanda \nSimilar scenario here.\nThank you for the infos!. ",
    "reubenwalkerau": "@nabbestemmia did you solve this? I have the same requirement to receive and send back a cookie but can't get it to work. . ",
    "korzonek": "We are currently working on nice integration of introduced quality issues with PR. Stay tuned :)\n. @pcantrell super! Thank you! We are almost there :) It was bigger task that we initially estimated :(\n. @pcantrell You are right :) To be honest, the first version is already deployed to production, but there are coming improvements, and I would like you to fall in love with our support for pull requests :) ...or at least trust and like it :)\n. @pcantrell support for pull request, together with new dashboard, support for Java, Kotlin, Obj-C, new dashboard, user management on projects level, enhanced slack notification and other improvements is available. Please give it a try. I hope you will like it :)\n. @pcantrell Pull Requests are available for only private repositories. I was not precise :( I'm sorry! We will support Pull Request for open source projects in the future but it requires changes in our architecture to support.\nHere you can find a few screenshots https://codebeat.co/ios how it looks. Please sign up for private repo and please let us know what you think about it. We have 14-day free trial so your credit card won't be charged.\nI'm sorry, I should be more precise Pull Request support is not available for open source projects.\n. \ud83d\udc4d \n. ",
    "majorgilles": "Ok thanks for your answer.\nThe current, and easiest temporary solution is attaching manually a transformer each time a ressource is accessed.\nFor example, for a resource of type Patient extending service,\nfor getPatients(), I would attach a transformer expecting an json array\nfor savePatient() (which returns the original json with valid id field filled in), I would attach a transformer expecting a json object\nNot the cleanest solution but it will do for now\n. Sorry have not tested yet, will do it asap.\nOn Wednesday, 25 May 2016, Andrew Loyola notifications@github.com wrote:\n\nthis change would be great. we've actually gone outside of siesta in a\ncouple of instances where the PUT/PATCH return data is\ndifferent/nonexistent compared to the GET that is configured via Siesta and\nused 99% of the time\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/bustoutsolutions/siesta/pull/54#issuecomment-221610459\n. @pcantrell Hello Paul, I'm in the process of migrating my web services to the standard form, and configuring my siesta resources with the new developments.\n\nI should have finished testing by the end of the day, and I'll report back to you.\nBest regards,\nGilles\n. I'm encountering issues with my webservices which are not related to siesta that prevent me from giving you full feedback right now.\nWhat I can tell you:\n- new API is simple and easy to use, being able to configure a transformer with several methods in one go is great\n- From some parts of my application that are still working, the correct transformer was indeed getting triggered according to the new configuration.\nI will need to fix issues on my end before telling if everything works.\n. After restoring my webservices, I can confirm the new specs are working correctly for  at least POST/GET methods. Have not tested other methods.\n. ",
    "roma86": "Thank you for quick answer. I will try to find the right configuration for CloudFront if it is possible first.\nAlso i got the point about Custom Service. Thank you one more time. \nIssue can be closed if it matter. \n. I come back with update.\nS3 storage does not determine content-type for uploaded images by self. \nOfftopic notes:\nThis is not related for Siesta, but nevertheless.\nClients should mark uploaded objects with appropriate content-type or it can be changed in s3 buckets interface manually for each file\n\nExample for ruby aws-sdk\nruby\nobject_name = \"uploads/images/#{img_name}\"\nobj = s3.bucket('demo_site').object(object_name)\nobj.upload_file(temp_file_path, :content_type => file_content_type)\nIssue not in Siesta, but noob as me can catch this, in reason AlamofireImage or SDWebImage successfully present image in UIImageView without warnings.\nThank you for help and for awesome library. \n. @pcantrell hello. Thank you for answer.\nIssue still here\n\n. It works now, but i need to remove DerivedData for that.\n@pcantrell i really appreciate your help. Thank you.\n. ",
    "enricode": "I'm running in a simpler problem that maybe has already a solution that I can't see.\nI have two endpoints:\n- products/\n- products/[id]\nConfiguring them like: \nservice.configureTransformer(\"products/\") {\n...\n}\nservice.configureTransformer(\"products/*\") {\n...\n}\nSiesta catches the latter also on \"products/\" call (and it's correct, I think).\nChanging the endpoint \"products/\" to \"products\" brings an OAuth 401 because Authorization header isn't added to request and I don't really know why (maybe it's a bug?)*\nSo the only solution that came to my mind was:\n```\nservice.configureTransformer(ProductIntPattern()) { ... }\nstruct ProductIntPattern: ConfigurationPatternConvertible\n{\n  func configurationPattern(service: Service) -> NSURL -> Bool {\n    return {\n      if let components = $0.pathComponents where components.count > 1 {\n        return (components[components.count - 2] == \"products\" && Int(components.last!) != nil)\n      }\n      return false\n    }\n  }\n  var configurationPatternDescription: String {\n    return \"\"\n  }\n}\n```\nThat really isn't so good as something like:\nservice.configureTransformer(\"products/:id\")\n\n* authorization is configured in this way\nservice.configure {\n  $0.config.headers[\"Authorization\"] = self.authHeader\n}\n. ",
    "jordanpwood": "I'm doing some initial evaluation of Siesta to handle an API with this exact issue.  @VDKA, can I ask, what approach did you end up with?\n. > The one-to-one relationship between URLs and resources is baked pretty deeply into the cache, so storing something with one key and retrieving it with another certainly does break the mold.\nIt seems like this could be implemented to be totally transparent to Siesta, since it would be the responsibility of the EntityCache implementor to take the url and the Entity in the pipeline (at whichever stage the persistent cache is working at), and output a key of their choice.  Then when it's time to do a lookup in the cache, the implementor has to be able to take the url and turn it into a key which can produce an entity with the correct value.  I'm confident that I could do that with my data and urls.  It doesn't matter to Siesta if the url being looked up was never actually seen, and its my understanding that it would then proceed after the persistent cache hit to actually request the url in question, which is fine by me.\nI do have some related EntitiyCache questions which the documentation doesn't cover (and I haven't yet dug in the code to find the answer for myself \ud83d\ude05).  Is there support for staleness in the EntityCache?  Since you don't know when something went into the cache, I assume there's no general support for that.  But what happens when a known resource is cleared from the in memory cache?  Is the EntityCache informed? \n. Let me start off by saying, Wow!  You got this code change out blazingly fast!!  I'm incredibly impressed.\nTo test things out, I've made a little sample app which loads a resource from our API, and have hooked up a pseudo persistent cache to it, just to check your new branch out.  \nOne possible bug I'm seeing is that the first time I call loadIfNeeded, I'm seeing a cache request for each of the resources in the path to the fully constructed URL.  What I mean is, I'm creating the resource like so:\nfunc articleInPressPageResource(journalId: String, cursor: String?) -> Resource {\n        return libraryResource\n            .child(Endpoint.journals.rawValue)\n            .child(journalId)\n            .child(Endpoint.aip.rawValue)\n            .withParam(QueryParameter.cursor.rawValue, cursor)\n    }\nAnd for every call to child, I'm seeing a key get created and a call to readEntity.  After that initial setup, everything behaves as I expect.\nAs to the behavior of wipe, I would say that I would expect Siesta to be generally in charge of the current state of caching, so when it gets a call to wipe it would pass that onto the persistent cache.  However, Siesta wouldn't know the full extent of which data should be purged, so maybe that wouldn't be good idea.  For my API, I can't really use an auth token as part of the persistent store, since they expire if they aren't used frequently enough.  So the same user can be authenticated with the same permissions, and have a different auth token.  I suppose I could update the cache when I get a new token... I'd love to hear any advice you have on the topic.\nIn general, I give a big \ud83d\udc4d to the cache key, it works just the way I would expect it to.\n. This is definitely a \"nice to have\" level feature, I'll let you know if I find any performance issues related to this.\n. I'll give it a poke, see what happens.\n. Thanks @pcantrell!  I was working on getting my own code migrated to Swift 3 on Friday, so I hadn't gotten to this yet.  Someday I'll have to buy you a \ud83c\udf7a.\n. It looks like s.ios.deployment_target is still set to 9.0 in Siesta.podspec in the Swift 3 release, @pcantrell.\n. Sorry, I was just doing something stupid in my tests. \nI agree, URLs shouldn't be used to identify resources in the app, I just wanted them for testing and reporting uses.\n. > \u201cDoes anybody actually read these PR comments?\u201d\nWell @pcantrell, I do!  \ud83d\ude04 \n. @pcantrell, I noticed this feature in the release notes, and I'm really glad its there!  I am trying to add a custom RequestDelegate and put it in a chain.  I have written a test to check that I am using this feature correctly, but I can't get the RequestCompletionHandler.willIgnore to not return true.  It looks like the LiveRequest that Resource.prepareRequest(using:) is returning is expecting onCompletion to be called on it by something.  My test has a very simple RequestDelegate that doesn't wait, and calls willIgnore and broadcastResponse from within startUnderlyingOperation(passingResponseTo:).  Is this synchronous behavior the problem?  \nAlso, my real implementation that uses this feature will open a web view and get the user to login so I can get the credentials I need for Siesta's headers.  I assume that this non NSURL based request will work in a request chain?. To be clear, the problem is that I get an error result from the URL mock because I sent it an extra, unexpected get request.  Also, it defeats the purpose of the test if I can't force the data to come from the cache.. Thanks Paul, you saved my test!   I didn't realize that I'd get a cached response after a wipe.  I'm good to go now.. I have found a different way of triggering what I believe is the same problem.  I have an excerpt from a debug log here.\nThis is my first use of Siesta after app start, and my persistent cache is empty.  I request several URLs in succession.  The lines of the form \"Got    0 articles out of the cache using...\" are coming out of my persistent cache, and are being triggered from Siesta.  There are 19 lines like this, so Siesta made 19 requests for cached data, which is the number I expect given the amount of data I was trying to retrieve.  The worrying part is that there are only 6 GET requests being sent for that set of 19 requests.  There are also only 6 URLs mentioned in the staleness checks.  Some are are mentioned in more than one staleness check, which I don't think should be happening, since I'm only requesting each one once.    There is a gist of the output of this set of requests being made with .all turned on for Siesta logging here.  As you can imagine, this file is slightly bigger!\nI found this problem because I'm implementing some performance improvements which have the side effect of not requesting data from Siesta quite as often when I first display a list of articles.  I hadn't noticed this problem before this point because subsequent calls to Siesta concerning the missing URLs do work.  My performance improvements are going to have to wait until we figure out what is going on in Siesta!  I have yet to be able to reproduce this problem in a test or other more controlled situation.\nLet me know if you have any other tests you would like me to do.\nJordan. Wait a sec @pcantrell!  Let me look into this some more, it might be that my \"performance improvements\" are asking for the wrong data! . Well, my \"related problem\" turned out to be something else; I wasn't properly setting the timestamp on the data coming out of my EntitiyCache implementation.  Its possible that my original problem was related to that, but I don't exactly know how.  I've not reproduced the original problem since I made my entity cache changes (plus some changes where I more intelligently request data from Siesta).\nI'll close this issue, and reopen it if I see the problem again.\nThanks again, Paul!. I punted on this problem and just stopped caching data not on the screen. \ud83d\ude1e This makes my VC a bit slower to draw than I like, but doesn't actually cause any additional network requests.  Having access to something like a Service.flushUnusedResource() would still be my preferred solution.. You might find this Stack Overflow issue interesting: http://stackoverflow.com/questions/39827137/how-can-i-mock-resource-responses\n. It looks good to me!  I would call this right after purging my own cache for everything not currently seen by the user.  In that cleanup, I call resource.removeObservers(ownedBy: self) and then get rid of all references to that class. . My first thought is that I see that authSessionController is a local variable to viewDidLoad.  Is there a strong reference to it somewhere?  I have the same question about api as well.. > I'm trying to figure out why this second request to my resource doesn't even trigger a disk cache lookup and immediately requests it from the network?\nI also use the persistent cache feature of Siesta, and from your description I would first recommend you look at the value of the ResourceEvent you are getting back in your observer.  I'm guessing that it is .requested.  You should get your expected stale data in your observer.  \nThe reason your persistent cache doesn't get hit is that Siesta has an in-memory cache which was initialized from the persistent cache, and then updated from the network request.  Your cache should only see new data to write to it until the resource in question is removed from the in-memory cache.  . To use Siesta for that purpose, you would need to develop your own class or struct which implements the EntityCache protocol, as described in the reference docs.  Basically, you need to provide your own backend storage solution, and EntityCache specifies the way that Siesta interfaces with your implementation.\nThe documentation for how to go about making one of these is pretty sparse, but I have successfully made one for my app (I am not a maintainer of Siesta, just a happy user of it).  A sample implementation of EntityCache has been a goal of @pcantrell, I know, but it has not yet happened.  The only really tricky thing for me was understanding that getting the timestamp updating properly in my cache is very important for Siesta to use the cache appropriately.. I'm trying this branch out, with the hope that when I need to release my new functionality in about a month, it'll be ready for prime time.  Let me know if that is going to be unlikely, I can muddle along with master if need be.  I have found one bug with what is currently in GitHub, which is that the standard transformer for JSON decoding isn't being applied by default.  I'm having to add:\n```\nself.service.configure(\"**\") { [weak self] in // all endpoints\n   // stuff\n   $0.pipeline.add(StandardTransformer.json)\n}\n```. >Curious. That\u2019s on the file-cache branch?\nYep.. I will say that I haven't tested that my particular setup gets the standard transformer applied on master.  I just removed from my code the following:\n```\n$0.pipeline[.parsing].add(strongSelf.SwiftyJSONTransformer, contentTypes: [\"*/json\"])\n```\nI used to use SwiftyJSON for all my data, but I am transitioning to using JSONDecoder.. I figured out my transformer problem @pcantrell!  I realized today that the transformers were only not being applied in my unit tests, and lo and behold, I was adding my URL mocking like this:\nservice = Service(baseURL: expectedV2Host, standardTransformers: [], networking: testConfig)\n\ud83d\ude05 \nAs I suspected, something was off in my configuration!  I removed the standardTransformers: [] bit, and everything is good.. Hey @pcantrell!  Thanks so much for jumping on this.  I'm planning to release a new version of my app this week, and I had included 1.4.0 in it.  Would you recommend using memory_leak, or do you plan on getting a new version of Siesta released shortly (Travis issues?)?  Is there anything I can do to help?. I'm trying to setup Siesta so I can build and run the tests on my local machine, but I'm unable to get Carthage to compile Nocilla, I'm getting the following error:\n```\nUser defaults from command line:\n    IDEDerivedDataPathOverride = /Users/woodj/Library/Caches/org.carthage.CarthageKit/DerivedData/9.4.1_9F2000/Nocilla/bd7ec7caa0576f08c00bbbf993a9204f93be16e3\nBuild settings from command line:\n    CARTHAGE = YES\n    CODE_SIGN_IDENTITY = \n    CODE_SIGNING_REQUIRED = NO\n    ONLY_ACTIVE_ARCH = NO\n    SDKROOT = appletvsimulator11.4\nxcodebuild: error: Unable to find a destination matching the provided destination specifier:\n        { platform:tvOS Simulator, id:ECE73D0A-02FC-4B82-A5CA-FF2A9EBD7C09 }\nIneligible destinations for the \"Nocilla tvOS\" scheme:\n    { platform:tvOS, id:dvtdevice-DVTiOSDevicePlaceholder-appletvos:placeholder, name:Generic tvOS Device }\n    { platform:tvOS Simulator, id:dvtdevice-DVTiOSDeviceSimulatorPlaceholder-appletvsimulator:placeholder, name:Generic tvOS Simulator Device }\n\n```\nIf I'm reading that right, it wants a tvOS simulator which is version 11.4, but since I'm not yet on Xcode 10, I only have access to devices up to 11.3.  Any suggestions on how to fix?. It's almost passing the tests, are those leaked services real, or is it more test artifacts?. ",
    "kadaj683": "Indeed I completely misunderstood the mechanism. Just because my transformers did not work I thought that \"content\" property is for plain data, not for transformed objects. Sorry for bothering.\n. ",
    "alecgorge": "@pcantrell been following this project since December waiting for this to land and I'm very excited about it! Thank you so much for your hard work and excellent documentation of what you are doing. These changes make the app I have in mind for a side project much more accomplishable in the limited time I have.\n. Also, @pcantrell how do you make those cool flow charts? Do you do them by hand or do you have a tool that can generate them?\n. @pcantrell I'm not sure I'll have a chance this week (still in the design phase myself and honestly I'm changing a few things based on the possibilities here) but I'll definitely get to playing around with it soon and I'll write up some feedback or a PR if necessary. Thanks again!\n. @dazzz1er @pcantrell yup that was exactly what I needed :) Sorry for not following up earlier!\nIt doesn't address the general scenario but it is exactly what I want.. ",
    "sahandnayebaziz": "@pcantrell I saw Siesta on the swift trending repositories page. You could try the traffic section of the graphs tab too to see referrers. Seems to show data up to but not including today, but might help\n. ",
    "Jissay": "Hi, sorry for the late answer (i was on vacation).\nSiesta has been installed using Cocoapods, removing file references means thats i need to create a script or something like a post-install hook to do so in my Jenkins build. \nI will update this thread as i get deeper in solving this issue,\nThank you for your help\nUPDATE\nIndeed, deleting file reference manually on my Jenkins' XCode solves the issue (it's a macbook running Jenkins as we need a UI to get automated testing done). I will update again when i will be able to do this automatically within Jenkins' build process.\n. I did found the trick !\nThis solution is actually working within Jenkins CI (using XCode plugin or not). The thing here is to use xcodeproj gem to access to Pods groups and files reference. xcodeproj must be installed on the running Mac before executing this script (use sudo gem install xcodeproj to do so).\nI switch this issue to closed. \nAdded this in my podfile's post_install hook : \n```\nNeed to execute \"sudo gem install xcodeproj\" before executing this post_install hook\npost_install do |installer|\n# Removing Info-OSX.plist and Info-iOS.plist to avoid crash while building\n# with Jenkins CI. After a fresh pod install, Siesta isn't able to delete properly\n# these files. See https://github.com/bustoutsolutions/siesta/issues/69\ninstaller.pods_project.pods.groups.each { |g|\n\n    if g.name == \"Siesta\"\n        puts \"--- Found Siesta group\"\n        g.groups.each { |g2|\n\n            if g2.name == \"Core\"\n                puts \"--- Found Core group, Removing Info-OSX.plist and Info-iOS.plist\"\n                g2.files.each { |f|\n                    if f.name == \"Info-OSX.plist\" || f.name == \"Info-iOS.plist\"\n                        puts \"--- Removing files\"\n                        f.remove_from_project\n                    end\n                }\n            end\n        }\n\n    end\n}\n\nend\n```\n. ",
    "xtravar": "I've been researching making a very similar framework recently and I'm excited to see someone else out there experimenting along the same lines.  \nSince I'm dealing with only RPCs, my idea is to have client-side identifiers replace URLs completely, offering more concise client code.  So, maybe your API doesn't need HTTP/URLs in the first place and you can separate the network layer completely.  My 2 cents.  YMMV.. Ashamed to say - I don't know a whole lot about Moya. Quick perusal of Moya's readme seems that it's not cache-observer based, which I think is really (one of) the key components of all of this.  I just stopped by to comment that I think you can open up a world of possibilities by not tightly coupling the API to network fundamentals.\nSurely, Siesta is revolutionary and suitable for a great number of projects, and my intention isn't to bust in and criticize or demand features.  I'm designing for an application with many interdependent, wide-ranging legacy RPC services, so my perspective is slightly different.  I've solved my networking abstractions, and I'm focused on solving data-flow issues.\nI'd love to take the conversation into email or something to compare notes on inspiration, research, and similar projects.  Thus far, Siesta is the closest project I've found to validating the design I've been working on.. ",
    "gcasar": "Hello, \nI also experienced this issue. A project clean fixed it for me. \n. ",
    "Reedyuk": "So, i have this happening on multiple machines, i have also done multiple cleans, removed derived data, restart machine, closed Xcode, changed provisioning profiles. \nAll did not work, then i changed the library version back to .6 and it works, when i change it back to .7 or .8, then it fails.\n. Ah, there is an 8a? i was using 8. \nLet me try now\n. Confirmed, 8a fixes the problem. Thanks\n. At the moment im using a preprocessor macro to handle the switch between the base url overall. e.g. https://cool.com and http://localhost, but that doesnt fix the issue with ports etc.\n. ok, sounds good. Thanks\n. ok thanks, \nAny chance you could either branch a 'Swift-3.0' or even add to the readme that you must point to master, as i easily overlooked this.\nYes, i will let you know how it goes.\nAs a note, I'm using:\npod 'Siesta' , :git => 'https://github.com/bustoutsolutions/siesta.git', :branch => 'master'\n. Thanks Paul, i will implement this, but because the loading indicator is already there by default(just not used by siesta), i think that this should be a property on the service layer. \nI can totally understand if i was talking about a 3rd party library, but because its apart of ios(so to say), it feels like this should just be a boolean property to enable disable in siesta.\n. Hi Paul,\nhttps://github.com/bustoutsolutions/siesta/pull/132\nI have created a pull request with my changes.\n. @Alex293 - you should be keeping an instance of your service object, so you should only need to do it once(depending on how many service object you keep).\nCheckout my PR, i added to the GitHub example to show the indicator. One line and it does the rest.\n. @pcantrell Paul, i'm not sure how to extend the configuration object to adhere to your suggestion. My xcode autocomplete doesn't seem to be working so its not giving me much help.\n. to be honest, i think useNetworkActivityIndicator() is good enough, i'm pretty sure most developers know what the network activity indicator is so prefixing use, is fairly minimal but makes sense.\n. Also, i think i was on the right route with decorateRequests, but for some reason my compiler was not working correctly as it was coming up with an error(probably just slow at updating) so i assumed that way wouldn't work. \n. Im using it for a contract for a fin tech call nutmeg. You can put them as a company using it if you want.\nwww.nutmeg.comhttp://www.nutmeg.com\nSent from my iPhone\nOn 2 Nov 2016, at 19:30, Paul Cantrell notifications@github.com<mailto:notifications@github.com> wrote:\nMerged #132https://github.com/bustoutsolutions/siesta/pull/132.\n\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://github.com/bustoutsolutions/siesta/pull/132#event-845465934, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ADrKztdz5YQbQj7kcSGtQ5wbqjkExUM7ks5q6OTsgaJpZM4KkWBW.\n. Actually, just to add. When i set the actual full path, then the observer works fine.\nSo this maybe a feature request instead.\nThe ability to wildcard add observers.. I created a quick fix for my code for now:\nswift\nextension Configuration {\n    public mutating func listenToRequests() {\n        decorateRequests {\n            resource, request in\n            request.onFailure { _ in\n                if let appDelegate = UIApplication.shared.delegate as? AppDelegate {\n                    appDelegate.resourceChanged(resource, event: .error)\n                }\n            }\n            request.onSuccess { _ in\n                if let appDelegate = UIApplication.shared.delegate as? AppDelegate {\n                    appDelegate.resourceChanged(resource, event: .newData(.network))\n                }\n            }\n            return request\n        }\n    }\n}\nThen to use it,\nswift\nservice.configure {\n            $0.useNetworkActivityIndicator()\n            $0.listenToRequests()\n        }. Amazing! Thanks Paul, exactly what i needed.\nSo i implemented it so:\nNetworkRequestAdapter.webService.configureTransformer(Urls.CreatePotService.createPotWildcard, requestMethods: [.post]) {\n            Pot.createPot(json: $0.content)\n        }\n        NetworkRequestAdapter.webService.configureTransformer(Urls.PortfolioService.getPotsWildcard, requestMethods: [.get]) {\n         Pot.createPots(json: $0.content)\n        }. hmm, is there anyway that i could just pass the string in, and siesta interpret it as formatted?\nThe reason being, i created a network adapter around my code and i don't want to have to either handle individual params, or directly call additional methods when there is parameters.. Great, for now i will take Pauls approach, but when i get time, i will write a method to add the parameters correctly.. hmm, yes i had a look at this but it didn't work. I will keep looking around to see if i can find a solution.\nThanks. Basically, i want to be able to 'intercept' the request and load a json object from a file instead. So no network request is made and it returns the request as if the server had returned the json object.. Ah thanks!. Nice work Paul, I'm sure you are aware of the issue with:\nSimultaneous accesses to 0x7f8abce14760, but modification requires exclusive access.\nPrevious access (a modification) started at Siesta NetworkRequest.broadcastResponse(_:) + 2338 (0x10717f042).\nCurrent access (a read) started at:\n0    libswiftCore.dylib                 0x000000010b101740 swift_beginAccess + 505\n1    Siesta                             0x0000000107179f80 Net. Yes just checked now, it\u2019s gone.\nThanks\nSent from my iPhone\nOn 3 Sep 2017, at 16:41, Paul Cantrell notifications@github.com<mailto:notifications@github.com> wrote:\nI thought I\u2019d fixed it. Are you getting this on the current swift-4 branch?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHubhttps://github.com/bustoutsolutions/siesta/pull/213#issuecomment-326812469, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ADrKzrupfbHfXt7WnUKP0h3aVEYeSd8Sks5sesiWgaJpZM4Ou6EN.\n. Yep makes sense.\n. Ok, do you use swift lint? You can add some rules to a lint file and it will come up as warnings in xcode.\n. Originally i added to the service class to count the requests there, but there i think i couldn't latch onto the didset.\nIn the end i moved it to the extension file, it seems right that it belongs in this file as its a property related to the file, unless you have a better suggestion?\n. ",
    "nikolay-dementiev": "Thank you\n. ",
    "jwardle": "Initial view of #98 having integrated it into our project looks spot on - will report back with any feedback. Additionally, this approach appears to have resolved a gap we were also facing with the token renewal / request retry cycle which you example clearly proposes a resolution for given the new changes. \n. All I am trying to to is react to a failed request (say server returns 500 error, or a network erro) by repeating the initial request. Normally in reaction to a \"Tapp here to retry\" type button.\n1. Create request\n2. Request is wrapped by a RequestChain, as I have configuration which chains the request to handle auth access token renewal etc.\n3. Request is sent & fails.\n4. User wants to retry the request - tapping retry button\n5. Repeated RequestChain is created and executed\n6. Retry fails as wrapped request has already been 'started' \n. @pcantrell: this issue appears to be fixed! Thanks!\n. I was attempting to create a reusable 'loading more' implementation using repeated(), however will review he above commentary to see if there is a better resource-centric method given my requirements! \n. ",
    "beniaminorossini": "Ok, i understand that few days ago you have splitted siesta and siestaui, but i not understand how to install the UI part.\nYou can help me?\nThx\n. @pcantrell It was cocoapods. \nOn https://cocoapods.org i've not found anything, not Siesta\u00a0nor SiestaUI, very strange don't you?\nAnyway, thank you so much for readme update.\n. Yeah, the repo is ok and i've loaded UI components in my projects.\nI have a little problem with the ResourceStatusOverlay: i've followed basic instruction on readme but i missed what i have to do in interface builder.\n@IBOutlet weak var statusOverlay: ResourceStatusOverlay!\nmust be linked to which IB component? A simple view? \n. ",
    "Aciid": "subscribing\n. @pcantrell upgraded from b 9 to b 10 using instructions provided everything works without a hitch, now both modules on b10 (y).\nIt was just unclear since the readme's and samples were not up to date. I didn't understand from the pod file nor the commits that the UI was branched.\nThanks!\n. ",
    "awclives": "Hi,\nI am one of the confused.\nI am using cocoapods, XCode 8, and swift 3.  \nWhat should I have in my podfile?\npod 'Siesta', '>=1.0-rc.0'\nor \npod 'Siesta' , :git => 'https://github.com/bustoutsolutions/siesta.git', :branch => 'master'\n?\nThanks.\n. The former looks correct; however, the following is not compiling:\nservice.configureTransformer(\"/highlight-feed/simple/\") {\n            if let dic = $0.content.dictionaryObject, let ret: HighlightFeed = try? Unbox(dic) {\n                return ret\n            }\n            return nil\n        }\nI get the error \"Type COnfigurationPatternConvertible does not conform to protocol ExpressibleByStringLiteral\".\n. Thank you, sir.  Can't test my full project yet, but your suggestion seems to be working.\n. ",
    "kl": "rc.1\nLoad before observe (overlay never removed):\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502 <deallocated: <SiestaUI.ResourceStatusOverlay: 0x7f9b8b51ef70; frame = (0 0; 375 667); hidden = YES; layer = <CALayer: 0x60800023dfe0>>> removing observer whose owners are all gone: <deallocated: <SiestaUI.ResourceStatusOverlay: 0x7f9b8b51ef70; frame = (0 0; 375 667); hidden = YES; layer = <CALayer: 0x60800023dfe0>>>\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502 Resource(\u2026/gists)[L] sending requested event to 1 observer\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502   \u21b3 requested \u2192 ClosureObserver(HomeDirector.swift:99)\nSiesta:stateChanges\u00a0\u00a0 \u2502 Resource(\u2026/gists)[] received new data from network : Entity<Any>(content: [Model.GistEntity(description: \"sddfs\", isPublic: false, file: Model.GistFileInfo(size: 12, raw_url: \"https://gist.githubusercontent.com/kl/494d25fe933ef0459d1f2c9441e91a0d/raw/e5c384274efafef1dd434c4648fbd7901a418f9d/sddfs\", filename: \"sddfs\", language: nil)), Model.GistEntity(\u2026\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502 Resource(\u2026/gists)[D] sending newData(network) event to 1 observer\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502   \u21b3 newData(network) \u2192 ClosureObserver(HomeDirector.swift:99)\nLoad after observe (overlay never shown):\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502 Resource(\u2026/gists)[L] sending requested event to 1 observer\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502   \u21b3 requested \u2192 ClosureObserver(HomeDirector.swift:99)\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502 <deallocated: <SiestaUI.ResourceStatusOverlay: 0x7faf0942d840; frame = (0 0; 375 667); hidden = YES; layer = <CALayer: 0x60800022f6c0>>> removing observer whose owners are all gone: <deallocated: <SiestaUI.ResourceStatusOverlay: 0x7faf0942d840; frame = (0 0; 375 667); hidden = YES; layer = <CALayer: 0x60800022f6c0>>>\nSiesta:stateChanges\u00a0\u00a0 \u2502 Resource(\u2026/gists)[] received new data from network : Entity<Any>(content: [Model.GistEntity(description: \"sddfs\", isPublic: false, file: Model.GistFileInfo(size: 12, raw_url: \"https://gist.githubusercontent.com/kl/494d25fe933ef0459d1f2c9441e91a0d/raw/e5c384274efafef1dd434c4648fbd7901a418f9d/sddfs\", filename: \"sddfs\", language: nil)), Model.GistEntity(\u2026\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502 Resource(\u2026/gists)[D] sending newData(network) event to 1 observer\nSiesta:observers\u00a0\u00a0\u00a0\u00a0\u00a0 \u2502   \u21b3 newData(network) \u2192 ClosureObserver(HomeDirector.swift:99)\nrc.0\nLoad before observe:\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[L] sending requested to 1 observer\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[L] sending requested to (ClosureObserver in _C44BB9FA2CCB62875EDCC4C65C6D80F6)(closure: (Function))\n[Siesta:stateChanges] Siesta.Resource(https://api.github.com/gists)[] received new data from network : Entity<Any>(content: [Model.GistEntity(description: \"sddfs\", isPublic: false, file: Model.GistFileInfo(size: 12, raw_url: \"https://gist.githubusercontent.com/kl/494d25fe933ef0459d1f2c9441e91a0d/raw/e5c384274efafef1dd434c4648fbd7901a418f9d/sddfs\", filename: \"sddfs\", language: nil)), Model.GistEntity(\u2026\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[D] sending newData(network) to 2 observers\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[D] sending newData(network) to (ClosureObserver in _C44BB9FA2CCB62875EDCC4C65C6D80F6)(closure: (Function))\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[D] sending newData(network) to <SiestaUI.ResourceStatusOverlay: 0x7f94d0704520; frame = (0 64; 375 603); layer = <CALayer: 0x60000022ae20>>\nLoad after observe:\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[L] sending requested to 2 observers\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[L] sending requested to (ClosureObserver in _C44BB9FA2CCB62875EDCC4C65C6D80F6)(closure: (Function))\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[L] sending requested to <SiestaUI.ResourceStatusOverlay: 0x7f8fc3c2c070; frame = (0 0; 375 667); hidden = YES; layer = <CALayer: 0x60800042ec40>>\n[Siesta:stateChanges] Siesta.Resource(https://api.github.com/gists)[] received new data from network : Entity<Any>(content: [Model.GistEntity(description: \"sddfs\", isPublic: false, file: Model.GistFileInfo(size: 12, raw_url: \"https://gist.githubusercontent.com/kl/494d25fe933ef0459d1f2c9441e91a0d/raw/e5c384274efafef1dd434c4648fbd7901a418f9d/sddfs\", filename: \"sddfs\", language: nil)), Model.GistEntity(\u2026\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[D] sending newData(network) to 2 observers\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[D] sending newData(network) to (ClosureObserver in _C44BB9FA2CCB62875EDCC4C65C6D80F6)(closure: (Function))\n[Siesta:observers] Siesta.Resource(https://api.github.com/gists)[D] sending newData(network) to <SiestaUI.ResourceStatusOverlay: 0x7f8fc3c2c070; frame = (0 64; 375 603); layer = <CALayer: 0x60800042ec40>>\nI guess the deallocated: <SiestaUI.ResourceStatusOverlay: 0x7faf0942d840 has something to do with it?\nIf you need to debug this you can use my app here https://github.com/kl/dehub\nYou can log in with your Github credentials.\n. Thanks for taking the time to debug this!  You have the latest code (btw I'm not using Gloss any more and had forgot to remove it from the project  :sweat_smile:). The reason you are seeing the loading indicator is because it works for requests using trackManualLoad (for example the login screen). Where it is not working is for resources added to the overlay with addObserver (the main gists screen).\nIf you go to HomeDirector and change this\nswift\n  override func stageDidLoad(stage: HomeStage) {\n    addApiObservers()\n    observe(outputs: stage.outputs)\n    stage.overlayResources = [api.gists]\n    api.gists.loadIfNeeded()\n  }\nto this:\nswift\n  override func stageDidLoad(stage: HomeStage) {\n    addApiObservers()\n    observe(outputs: stage.outputs)\n    api.gists.loadIfNeeded()\n    stage.overlayResources = [api.gists]\n  }\nYou should trigger the bug where the overlay is never removed that happens on rc.1 but not on rc.0\n. \ud83d\udc4d I can confirm it now works as expected!\n. ",
    "aescarcha": "Ty very much, this solved my problem and some issues that followed :)\n. ",
    "pavelsmelovsky": "I'm trying to add Siesta pod like this:\n\npod 'Siesta/Alamofire', '>=1.0.0'\n\nbut cocoapod return an error:\n\n[!] Unable to satisfy the following requirements:\n- Siesta/Alamofire (>= 1.0.0) required by Podfile\nNone of your spec sources contain a spec satisfying the dependency: Siesta/Alamofire (>= 1.0.0).\nYou have either:\n- out-of-date source repos which you can update with pod repo update.\n- mistyped the name or version.\n- not added the source repo that hosts the Podspec to your Podfile.\n\nI can install only 1.0-rc.3 version that requires iOS 9+\n. Ok, i'm trying later.\n\n1.0-rc.3 also supports iOS 8.\ns.subspec \"Alamofire\" do |s|\n    s.source_files = \"Extensions/Alamofire/*/\"\n    s.dependency \"Siesta/Core\"\n    s.dependency \"Alamofire\", \"> 4\"\n    s.ios.deployment_target = \"9.0\"\nend\n\nIn our project we use Siesta/Alamofire, and it require iOS 9. But it not a problem, for current time I fix it manualy\n. Topic can be closed.\nCocoaPods updated Siesta pod.\nThanks!\n. Paul, I see another problem with current version 1.0.0:\nThe deployment target of Siesta pod is 9.0 (I'm installing Siesta/Alamofire), cocoapods show me error:\n\nSpecs satisfying the Siesta/Alamofire (>= 1.0.0) dependency were found, but they required a higher minimum deployment target.\n\nFix this please.\nThanks!\n. Alamofire requirements (since 4.1.0):\n-     iOS 8.0+ / macOS 10.10+ / tvOS 9.0+ / watchOS 2.0+\n-     Xcode 8.1+\n-     Swift 3.0+\nOnly two pods in my list asked for iOS 9 - Siesta (I don't know why) and AlamofireImage.\nI manualy change deployment target to 8.0 and remove @available(iOS 9.0, *) in Siesta/Alamofire/Networking-Alamofire.swift and all working correct\n. ",
    "Tazer": "Manage to solve it I think.\nJust running resource.load()when I got the token \ud83d\udc4d \nSo basically just letting the request fail then reload stuff when I have the new token.\nIt will work fine for GET requests at least. and that's fine for now.. @pcantrell Thanks for your answer and I'm with you , guess it doesn't \"matter\" that much in my case. But it would be more performant to do the \"second\" flow. But not sure how to solve that.\nYes. \n```\nfunc fetchNewToken(refreshToken : String) -> Promise {\n        return Promise { fulfill, reject in\n            A0Lock.shared().apiClient().fetchNewIdToken(\n                withRefreshToken: refreshToken,\n                parameters: nil,\n                success: { token in\n                self.setToken(token: token.idToken);\n                if let newRefreshToken = token.refreshToken{\n                    self.setRefreshToken(refreshToken: newRefreshToken)\n                }\n                fulfill(token.idToken);\n        },\n            failure: { error in\n                log.error(error);\n                reject(error);\n        });\n    }\n}\n\n```\nSo fetchNewToken is using Lock Auth0's iOS client https://github.com/auth0/Lock.iOS-OSX and then I'm using PromiseKit , but I would get into same problems without PromoiseKit cause promisekit is just a helper library, so I don't need to pass around callbacks everywhere :) \nSo the problems starts with A0Lock.shared().apiClient().fetchNewIdToken() cause it's async and takes a success callback. \nWould you have any suggestions how to integrate that with the request decorator ? :). ",
    "AkdM": "Any update on this, Paul? \ud83d\ude42\nHaving something like interceptors, where you can intercept requests or responses before they are handled would be good, with promise/async support.. ",
    "wildthink": "I've been looking at ways to cache some images in a way so that volatile views (observers) are likely, but not required, to find the image locally. This happens in the reuse (q.v.) of CollectionCells as the user scrolls back and forth; a cell scrolls out of view, gets reused, and the original request is dropped on the floor only to be re-requested when the users reverses the scrolling.\nI'm thinking of creating a dedicated Service with an EntityCache that implements a \"keep the most n recently used\" (or such). This way a request for a particular image (URL) is likely to still be available if it is re-requested within a short time.\nThoughts?. This might be a bit of a hack but at least its surgical and it opens up a way to specify the \"main thread\" for the developer. She needs to set\nDispatchQueue. siestaMainThread = myThread before making any calls to the Siesta API.\nI've not tried nor tested this. Just sharing an idea. :-)\n```\nextension DispatchQueue\n{\n    public static var siestaMainThread: Thread = Thread.main\ninternal static func mainThreadPrecondition(caller: String = #function)\n{\n    precondition(\n        Thread.current.isEqual (DispatchQueue.siestaMainThread),\n        \"Illegal attempt to use Siesta method \\\"\\(caller)\\\" from a background thread. \" +\n            \"Except in specific situations, you must call Siesta APIs from its disignated main thread. \" +\n        \"See https://bustoutsolutions.github.io/siesta/guide/threading/\")\n}\n\n}\n```\n. Umm.. This is a shot in the dark but if this works in a .m file have you tried adding a level of indirection? Something like...\nObjCSDKAPI.h (with a .m)\n@interface ObjCSDKAPI : BOSService\n@end\nThen use the ObjCSDKAPI in your ObjC++ .h/.mm.. Glad to help even a little bit. Thanks for the good work!. Right but shouldn't the statusOverlay be observing the resource? There seems to be a problem/issue with it getting the notification after the resource is changed.. ",
    "reversepanda": "Hi @pcantrell,\nI would like to weigh in with another use case.\nI'm currently trying to implement some kind of in-app debug/network monitor.\nI'm trying to mimic something that sniffs on the network traffic (like Charles, https://www.charlesproxy.com does) but in a very Siesta-kind of way. I want to be able to track the used resources, responses and combine this with the data before transformation happens.\n@Reedyuk's listenToRequests extension was the first step. It let's me track all used resources and hook into their requests. But combining this with a custom transformer is fruitless.\n```swift\n// This no real implementation, just snippets\nstruct NetworkResourceState {\n    static var collected: [String: NetworkResourceState]\nlet rawData: Any?\nlet entity: Entity<Any>?\n\n}\nextension Configuration {\npublic mutating func sniffRequests() {\n    // I want to hook into the initial data before it passes the transformations,\n    // so I get the \"cleanest\" data possible \n    pipeline[.rawData].add(NetworkSniffer())\n    decorateRequests { resource, request in\n        // here I can track the resources and hook in into their requests\n        // I will save the needed data into memory using the resource's `absolutePath` as\n        // the key\n        var state = NetworkResourceState.collected[resource.url.absolutePath] ?? NetworkResourceState()\n        NetworkResourceState.collected[resource.url.absolutePath] = state\n        request.onCompletion { _ in \n            switch responseInfo.response {\n            case .success(let entity):\n                state?.latestData = entity\n            case .failure(_): \n                break\n        } \n     }\n }\n\n}\nstruct NetworkSniffer: ResponseTransformer {\nfunc process(_ response: Siesta.Response) -> Siesta.Response {\n    switch response {\n    case .success(let entity):\n        // While I can easily get the response data in a very basic state here\n        // I have no chance to reference it to the request (OR resource) that \n        // ended in this response\n        ...\n    case .failure(let error):\n        break\n    }\n    return response\n}\n\n}\n```\nNow if the response would e.g. include the absolute path of the initial resource/request I would be able to link these two steps together. But as it stand Siesta is too closed to be able to understand where things are coming from.\nI totally understand the reasoning and I believe it's very good practice to have all these little parts be independent from each other as possible, but maybe there is a way to piggy-pack some introspection information in the chains so one could connect the dots easier?\nPS: I could try to merge something like https://github.com/Kofktu/Sniffer and Siesta, but that's not really what I'm looking at (at least not right now). I would like to keep the flow in context of Siesta: Resources -> Responses, with the small issue to get to the rawest form of data as possible before Siesta's transformation chain does it's magic. . +1 to have a new minor release just with this change. Our API layer would benefit greatly.. Much appreciated!. @pcantrell Sorry for coming back that late.\nOur concrete use case was related to our backend which uses a OAuth token. The OAuth token is added to all requests via decorating (very much like described in the docs). We did a POST request that resulted in a redirect to the final resource, which would fail due to bad auth. Naturally the redirect wouldn't be decorated with the token, because Siesta would never see the redirect.\nNow I understand this is a very edgy use case.\nTo solve this we just disabled redirects via setting the URLSession delegate (as you already recommended):\n```swift\nclass OurService {\n       ...\n    func urlSession(_ session: URLSession,\n                    task: URLSessionTask,\n                    willPerformHTTPRedirection response: HTTPURLResponse,\n                    newRequest request: URLRequest,\n                    completionHandler: @escaping (URLRequest?) -> Void) {\n        completionHandler(nil)\n    }\n\n    ...\n\n        let urlSession = URLSession(configuration: .ephemeral, delegate: self, delegateQueue: nil)\n        service = Service(baseURL: \"https://....\", networking: urlSession)\n    ...\n\n}\n```\nWe would just chain the redirect request manually (which was the right way to do anyways in our case, because we would need the \"intermediate\" result).\nPS: we got back to our backend team and asked them to change the API and replace the redirect 30x with a 20x, because the API design was suboptimal. So in the end this resolved itself anyways.\nThus I believe you are correct and such use cases can be easily handled by app code without direct support by Siesta. I wonder about redirects with REST APIs myself and I'm not sure if they are very useful. Redirects change the flow of data and influence things like app entity caches etc. and we would lose control.\nThe only way I could think of adding support in Siesta, would probably mean a lot of code in Siesta to catch all redirects and send them through the configure process to allow the app code to \"change the redirect\" as needed to handle similar use cases. But I'm not sure if it's worth the complexity.\nIn conclusion: there is an easy solution (maybe worth adding explicitly to the documentation?) and you can better judge if the added complexity to catch redirect requests, configure them and resend them via Siesta is worth the effort. For now we don't have a need for this and are happy to use Siesta as is (which is a wonderful framework).. Hi @nabbestemmia, the change didn't affect us a lot. It essentially removed described workaround in the client code to avoid auto-redirects. \nI agree, It's a API design issue as far as we were concerned. The redirect was there to chain the POST to the final resource and the backend team believed this would be easier for the client to handle, which was not the case. \nWe rather preferred explicit vs. implicit and now do a POST followed by a GET to get what we want, allowing us setup the request independently with all the needed custom headers (which a unattended redirect would drop) and also to introspect the responses independently, which was also important in our specific case.. Please have a look at https://github.com/bustoutsolutions/siesta/pull/229. Let me know if you want to see additional changes regarding this issue. Hope you have the time to release a new version for Swift 3.2.. Yes, this worked for us.\nIn the meantime we are also on the Swift 4 version though.. ",
    "BilalReffas": "Okay awesome thank you for your fast reply :). I think it's a Swift or Xcode bug because the issue goes away for some reason. :/ . Currently we found a work around.  \n```swift\nprivate func refreshTokenOnAuthFailure(request: Siesta.Request) -> Siesta.Request {\n        return request.chained {\n            guard case .failure(let error) = $0.response,\n                error.httpStatusCode == 401 else {\n                    return .useThisResponse\n            }\n        if let refreshTokenRequest = self.refreshTokenRequest {\n            return .passTo(\n                refreshTokenRequest.chained {\n                    if case .failure = $0.response {\n                        return .useThisResponse\n                    } else {\n                        return .passTo(request.repeated())\n                    }\n                }\n            )\n        } else {\n            return .useThisResponse\n        }\n    }\n}\n\nprivate var currentRefreshTokenRequest: Request?\n\nprivate var refreshTokenRequest: Request? {\n    if let request = self.currentRefreshTokenRequest {\n        return request\n    }\n    guard let token = Keychain.luubra.token,\n        let refreshToken = Keychain.luubra.refreshToken else {\n            return nil\n    }\n    let resource = self.user\n        .child(\"refresh\")\n        .withParam(\"token\", token)\n        .withParam(\"refresh_token\", refreshToken)\n\n    self.currentRefreshTokenRequest = resource.request(.put).onSuccess {\n        if let token =  $0.jsonDict[\"auth_token\"] as? String,\n            let refreshToken = $0.jsonDict[\"refresh_token\"] as? String {\n            print(token)\n            print(refreshToken)\n            Keychain.luubra.token = token\n            Keychain.luubra.refreshToken = refreshToken\n        }\n            self.invalidateConfiguration()\n        self.currentRefreshTokenRequest = nil\n    }\n    return self.currentRefreshTokenRequest\n\n}\n\n```\nKnow it just make only one request. My question is if it's okay to implement it that way ? :)\n. @akaralar can you please post how you update your token from the api with a new one? I have some trouble with this :/ . Thank you for you're response I'm closing this :) \ud83d\udc4d. Thank you for the response. I'm closing this :). ",
    "Meseery": "i've Xcode 8.2.1 which comes with Swift 3 SDK !. ",
    "richardtop": "@pcantrell the problem is that I am trying to use Realm for data persistence. When the new resource arrives, the appropriate controller saves models in Realm and then gives these models to the ViewController. If there is no network connectivity, the controller just returns saved models.\nRealm concurrency model requires re-fetching or re-creating models on each thread, so I can't just pass them around the threads. Data persistence should happen on the same thread the models were mapped. So, as I don't know the thread resources has been created on, I can't just use GCD to make a new one (e.g. what if thread changes in next version of Siesta?). \nSuch a convention makes it difficult to combine the framework with other tools. \nI can't really see now, how can I embed object persistence in pipeline.\nWhat I'm really looking into is very simple app configuration. In previous version of the app I've used RestKit + CoreData and it worked awesome.\nNow, it's time for a new version in Swift, so what I'm looking into is something like this:\n(REST Resource) ->  ->  -> \nIf the app goes offline, it just fetches latest data from the DB. When the app is online, it first, fetches old data, updates it, and then refetches the new data from db.\nThat was the reason I decided to try Siesta in the first place - I looked for something simple to make this app quickly.. @pcantrell it seems that it is the solution I'm looking into.\nHowever, I have one more question, let's say, I have a Realm entity with such values:\nvar ValueThatHasOnlineRepresentation\nvar ValueThatIsStoredOnlyOnDevice\nSo, during the next update cycle, the app should update only online values and keep offline values the same, while also deleting orphaned objects.\nSo this is a little bit different than just EntityCache.. ",
    "dazzz1er": "Hi @alecgorge \nI'm not part of the team but you and I sound to be in very similar situations; I am currently developing an app using Siesta with Cache for offline features.\nI was looking to get the same/similar functionality with ResourceStatusOverlay as you are, and found that if I change the overlay's displayPriority to [.anyData, .loading, .error] then this will always show the cached data, no matter how stale, if the user is offline. Essentially, if latestData is not nil on any observed resource then no error is shown.\nThis may not be entirely what you wanted so if you require a reliance on Reachability I suggest amending ResourceStatusOverlay slightly by adding a new case in the StateRule enum for your use case and then implementing your rule in the updateDisplay method. That way you could specify displayPriority as [.yourRule, .nextRule, .loading...] etc. for those overlays that require your specific event handling.\nYou may have already worked that all out and be miles ahead, but as we seem to be working in such a similar vein I thought I'd post my thoughts in case it helped!. ",
    "xuaninbox": "Hi, is there any plan for adding watchOS and tvOS deployment_target to podspec?. ",
    "MageMasher": "Hey @pcantrell , I'm going to try putting this in a tvOS app and will report back the status. We are shipping a tvOS MVP (emphasis on M) tomorrow and need to get a polling solution in place so I'll let you know what I find. If you want to talk in person at some point we could do that (i'm at corner coffee as I type this haha) since I live close by BustOut.. Hey @pcantrell , our MVP was a success! Here were the changes I had to make to siesta https://github.com/Dept24c/siesta/commit/10d437cb1e464749e71b95dec72b197e30c3dec6 \nI then referenced this git fork in my podspec and everything worked smoothly. The big thing was removing the call to UIApplication.shared.isNetworkActivityIndicatorVisible. I'm quite ignorant of what the right thing to do here was, however this worked to make our deliverable.\n. ",
    "mpaclark": "\n@xuaninbox Please see the checklist at the top of #28. This is essentially waiting for community members who are actually using Siesta with tvOS to report back on whether it\u2019s working, and to send PRs. Please comment on that issue, let us know what is working and what is not, and if you had to tweak anything, please send a PR!\n\n@pcantrell is WatchOS a platform already accepted as working correctly? I see there is a tvOS issue that you referenced but didn't see a similar one for WatchOS.\nI've tried to use the framework with my project which will have a WatchOS extension, but I'm using cocoapods and the spec is missing a line such as:\ns.watchos.deployment_target = \"5.1\"\nJust curious if this was an oversight or if WatchOS support is in a similar place as tvOS.\nThanks!. ",
    "ToxaZhe": "thanks Alex for reply. I'm using now base64 it works great. The problem was at server. There was a limit of 100 kb. But i tried your solution and it doesn't work. The reason is seems to be at server too. . we are not using any fname. Maybe that is the reason? I'm not clearly understand why we need to send this parameters: \nbody.append(\"--(boundary)\\r\\n\".data(using: String.Encoding.utf8)!)\n        body.append(\"Content-Disposition:form-data; name=\\\"photo\\\"; filename=\\\"(fname)\\\"\\r\\n\".data(using: String.Encoding.utf8)!)\n        body.append(\"Content-Type: (mimetype)\\r\\n\\r\\n\".data(using: String.Encoding.utf8)!)\n        body.append(image_data!)\n        body.append(\"\\r\\n\".data(using: String.Encoding.utf8)!)\n    body.append(\"--\\(boundary)--\\r\\n\".data(using: String.Encoding.utf8)!)\n\ni can't understand what all this things means. Maybe you could share some link where i will be able understand more deeply uploading files logic and scheme. Yes , but we are using mongoDB. And i didn't find examples with sending images to mongo. Also the backend guy creates his own name for file. So that what is the problem. But anyway i'm very appreciate for your help))) . ",
    "juarezjaramillo": "@Alex293 the multipart code worked like a charm.\nThanks!. ",
    "rauanmayemir": "I'm not sure if you can use letsencrypt for local domains.\nAnyway, this is how I resolved the issue for Alamofire:\n```\nlet sessionManager: SessionManager = {\n  let serverTrustPolicies: [String: ServerTrustPolicy] = [\n      \"mydomain.local\": .disableEvaluation,\n      \"192.168.1.100\": .disableEvaluation\n  ]\nlet configuration = URLSessionConfiguration.default\n  configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders\nreturn SessionManager(\n      configuration: configuration,\n      serverTrustPolicyManager: ServerTrustPolicyManager(policies: serverTrustPolicies)\n  )\n}()\nIn your Service:\nclass ApiService: Service {\n// ...\n  init() {\n    super.init(\n      baseURL: \"http://yourbaseurl\", networking: sessionManager\n    )\n    // ...\n  }\n```. ",
    "rickvdl": "@jordanpwood \nMoving the variable above the viewDidLoad actually works.\nThanks!. @pcantrell Thanks a lot for clarifying, will take a look at the documentation :)\nBTW, I was running this on tvOS and so far it has been working perfectly.\n. @pcantrell Sure, I prefer Cocoapods, but since the spec wasn't updated yet I am just cloning the Siesta project and adding the .xcodeproj to my workspace just like the submodule method https://github.com/bustoutsolutions/siesta#git-submodule\nThanks a lot :). ",
    "harelw": "Thanks for the info!. Awesome, thanks!. ",
    "erenkabakci": "Since there is no absolute right or wrong, I will just write down what kind of solution I have chosen.\nMaybe someone with the same issue can benefit.\nSomehow singletons are defined as semi-evil in the community. While most of the reasoning is true, there are still very valid cases to use singletons. If you are comfortable with this and Siesta's preferred way of doing this then the only problem is code localization, ease of maintenance, code readability etc.\nI have a subclassed Service object which acts like one-and-only base for the same API. Because of configuration lifecycle, this class has to know how to act for all possible endpoints, parsing behaviours etc. beforehand.\nI have managed to overcome this with Swift extensions. For now it looks both maintainable and clean.\nclass myApiClient: Service {\n  static func sharedClient() -> myApiClient\n   // ...\n  private init() {\n     generalConfiguration()\n     userServiceConfiguration()\n     paymentConfiguration()\n     .....\n  }\n}\nAs seen in the example, singleton ApiClient knows how to configure itself according to the different feature sets. (user, payment etc. in our case). These feature specific configurations live in public extensions under protocols.\n```\nprotocol ApiUserResourceDispatcher {\n  func userData() -> Resource\n}\ntypealias UserServiceClient = myApiClient\nextension UserServiceClient: ApiUserResourceDispatcher {\n  func userServiceConfiguration() {\n    // User service based configuration comes here. Transformers, endpoints etc.\n  }\nfunc userData () -> Resource {\n    // return resource to be observed\n  }\n}\n``\nThis setup allows me to separate feature based needs without losing one centralService` object and polluting the same class.\nAny external resource can basically process this data:\nUserServiceClient.sharedClient().userData().addObserver .....\nBehind the scenes it is only one myApiClient singleton but external resources only reach it via public extensions. They don't even need to interact with myApiClient.sharedClient()\nI am not sure if this solution will be valid for complex needs in the future but wanted to share as an alternative.\nSiesta is very powerful but it lacks complex architectural examples like this one. Example app is also very clear but again uses only basic MVC approach.\nThanks for creating such a great library !. Hey !\nComing back after a long time. Sorry :) Thanks for the detailed reply and suggestions. I applied what you also suggested.\nThe only idea behind the typealias was to keep code clean in a way that I define different domains. As you said they already point to the same class anyways. The consumer of the API only knows about the typealias not the hidden service behind. That was just for accessor convenience.. ",
    "jrmsklar": "Thanks a ton for the detailed response here @pcantrell. All of your concerns make complete sense.\nI'd like the to have access to the URL in order to log it when handling API response errors. We have remote logging set up (via PaperTrail), and have not been able to send up the URL when logging response errors, and it would be very helpful for us in order to see where these errors are originating from.\nI'm happy to revert these changes and instead add a URL property to RequestError if you see fit.. @pcantrell I've reverted the earlier commits, and added a url property to RequestError. Thanks again for the helpful feedback/suggestions!. Hey @pcantrell,\nAny update here?\nThanks!. Thanks for the thoughtful response, @pcantrell! I appreciate you taking the time to look into this issue and solve in a clean and elegant way. I understand your concerns and am interested in moving this forward and coming up with a solution.\nTo answer your questions:\n\nYou said this was for logging errors?\n\nYep - this is for logging the URL related to a RequestError value.\n\nAre you logging them via an onFailure hook? A resource observer? What does that code look like?\n\nWe have a custom API response content transformer that conforms to ResponseTransformer. In our implementation of the process(_:) function, we have a handler for the failure case of the response that pulls our the URL from the associated error, and logs it.\nThe code looks as follows:\n```swift\nstruct APIResponseContentTransformer: ResponseTransformer {\n    func process(_ response: Response) -> Response {\n        switch response {\n        case .success(let entity):\n            return processEntity(entity)\n    case .failure(let error):\n        return processError(error)\n    }\n}\n\nfileprivate func processError(_ error: RequestError) -> Response {\n    let urlString = error.url?.absoluteString ?? \"unknown url\"\n    // Log it\n    return .failure(error)\n}\n\n```\nLet me know if you need more information!. Apologies for the delay here, and thank you for the thoughtful response!\nI also see value in having the URL for not only errors, but successes too - it would be very nice to log all requests made! If @Reedyuk's suggested will allow for the URL to be accessible in errors and successes, then I am all for that \ud83d\udc4d.. What are your thoughts on me changing it to a let?. \ud83d\udc4d will do. Thanks!. @victorcotap all set!. ",
    "jeffaburt": "@pcantrell when you get a free second, do you mind reviewing the changes here?. ",
    "gaming-hacker": "Is this going to merged?. ",
    "insidegui": "\nCan it guarantee that your code is consistently called on the same thread / GCD queue? (Or if not, can you use GCD to single-queue operations yourself?)\n\nI believe the answer is yes. GCD works on XPC services and I can configure a queue to run all of the networking operations.\n\nOne approach would be to give every Service instance an immutable \u201ccorrect thread\u201d property that records the thread the Service was created on, but (1) I'm not sure there\u2019s a well-defined way of checking thread equality and (2) passing the preferred thread everywhere Siesta needs to check it could have nasty ripple effects.\n\nMaybe there could be an option to disable the thread precondition? Since XPC is an advanced topic, you can assume the person using it would know the consequences.. ",
    "SilverTab": "Update: I managed to achieve this by writing my own URLSession NetworkingProvider, however, I'd still be interested to know if it's possible to get to this result without having to work at the URLSession level.. Oh, interesting! That would make sense. I can't test right now but I will as soon as I'm back home. I think I was actually only updating my UI on the .newData event, which might actually explain the slowness in updating the UI on a throttled connection that I was observing!?\nWill confirm once I get back home and close this issue if that's the case! \ud83d\udc4d. @pcantrell Perfect! This is exactly what I needed, and appears to work as expected. \ud83d\udc4d. ",
    "boardmain": "i can also add param to the request? if yes how?. ",
    "LavanayaV": "Please give me any link which tells how to make get and post calls using siesta rest api calls, Using 'Alamofire' as a network. Yes..\nCan u please explain ne how to use it as a networkprovider. When I use\n Service.init(baseURL: urlstring, useDefaultTransformers: true, networking: Alamofire.SessionManager as! NetworkingProvider) App crashes.\nError:\nCould not cast value of type 'Alamofire.SessionManager.Type' (0x608000242388) to 'Siesta.NetworkingProvider' (0x6080002605d8).\n. Im still getting the same error. It didn't worked.\nService(baseURL: \"http://some-url\", useDefaultTransformers: true, networking: SessionManager.default as! NetworkingProviderConvertible)\n. \n\n. \n. Yes \n\n. I did the project from the beginning. Its working fine, I am able to use Alamofire as a network provider.\nlet provider = AlamofireProvider.init(manager: SessionManager.default)\n let myAPI = Service(baseURL: \"seome-url\", useDefaultTransformers: true, networking: provider). ",
    "KRUBERLICK": "@LavanayaV have you included Alamofire pod in your Podfile?. @LavanayaV in your Podfile include these three pods:\npod 'Siesta'\npod 'Siesta/Alamofire'\npod 'Alamofire'\nThen import Siesta and Alamofire libs in your source file and instantiate a Service:\n```\nimport Siesta\nimport Alamofire\nlet service = Service(baseURL: \"http://some-url\", useDefaultTransformers: true, networking: SessionManager.default)\n``. @LavanayaV can you show yourPodfileand source code with error?. @LavanayaV removeas! NetworkingProviderConvertible. If you installedSiesta/Alamofire` pod it should work without cast.. @LavanayaV that's strange. Did you run 'pod install' after changing Podfile?. ",
    "lddd": "Thanks for your kind reply. Just found out about SwitfyPress which might do better for my kind of a project. . ",
    "mberndt92": "Thanks for the quick reply!\nYes, apparently I wasn\u2019t quick enough discovering the branch.\nGood to hear that its going to be released in a few days actually!\nBest regards,\nMaximilian Berndt\niOS-Developer\nfoodpanda\n. ",
    "axandreo": "You're welcome! =) . @wildthink loadIfNeeded() does not reload the resource unless there's a reason to. Specifically the resource has to be invalidated. If you want a reload from the network, you have to do that sort of manually. There are two ways to handle that:\n\ninvalidate the resource, as stated earlier, then call loadIfNeeded: \n```\nvar repositoriesResource: Resource? {\n        didSet {\n            oldValue?.removeObservers(ownedBy: self)    repositoriesResource?\n        .addObserver(self)\n        .addObserver(statusOverlay, owner: self)\n        .invalidate\n    repositoriesResource?.loadIfNeeded()\n}\n\n}\n\n\n```\nOr\n2. Tell the resource to load:\n```\nvar repositoriesResource: Resource? {\n        didSet {\n            oldValue?.removeObservers(ownedBy: self)\n        repositoriesResource?\n            .addObserver(self)\n            .addObserver(statusOverlay, owner: self)\n            .load()\n    }\n}\n\n``\n. @wildthink I'm sorry, I misunderstood your question. A tableview doesn't reload unlessreloadData` is called.. Fantastic! Can't wait. My apologies for re-opening this issue, in another issue. I didn't realize you closed it. Thank you.. So sorry! I knew I wrote something like this yesterday but I didn't see it so I thought I did something silly like wrote it but never actually sent it. But I realize now you closed it. Sorry about that. ",
    "LucasR93": "I am doing it like this:\n```swift\nservice.configure(\"**\", description: \"auth token\") {\n            if let authToken = self.authToken {\n                print(\"Siesta:Networking Setting AuthToken: \" + authToken)\n                $0.headers[\"Authorization\"] = \"Bearer \" + authToken         // Set the token header from a var that we can update\n            }\n            $0.decorateRequests {\n                self.refreshTokenOnAuthFailure(request: $1)\n            }\n    }\n\n```. Oh well, right.. I should have read more carefully . ",
    "Narsail": "Good idea. I tried in in your suggested way and it is compiler friendly in my project. Seems to be working.. You are welcome :)\nSent with GitHawk. ",
    "jwells89": "Quick update on this: in our application I've created an extension for Siesta's Service that allows transformers to be configured with instances of my custom Resource wrapping APIComponent class:\nfunc configureTransformer<T: Decodable>(for component: APIComponent, methods: [RequestMethod], type: T.Type) {\n    configureTransformer(component.resource.path,\n                         requestMethods: methods) {try self.decoder.decode(type, from: $0.content) }\n}\nwhich makes for syntax quite similar to that described in the original post:\nconfigureTransformer(for: Tasks(.v2), methods: [.get],   type: STKPaged<STKTask>.self)\nconfigureTransformer(for: Tasks(.v2).any,                type: STKTask.self)\nconfigureTransformer(for: Tasks(.v2).any.assignees,      type: STKUser.self)\nIt works and is an improvement on the string-based setup, but it'd still be very nice to see some less specialized form of this idea make its way into Siesta proper.. I'm seeing this as well. I'd have to roll back and verify to make sure, but I believe that this issue appeared after upgrading to 1.4.0.\n. I just tested memory-leak branch on a couple of different projects and it looks like it does indeed fix the problem.. ",
    "mglass": "@pcantrell The new build system is now the default in Xcode 10. Can we expect this fix (and incidentally, the fix for #244) anytime soon? Might be worth a bug fix release at this stage if 1.4 isn't ready.. ",
    "NermeenNery": "how can add this in pod file ? any example ??\ns.subspec \"Core\" do |s|\n    s.source_files = \"Source/Siesta//*.swift\"\n    s.exclude_files = \"/Info*.plist\"\n  end\ns.subspec \"UI\" do |s|\n    s.ios.source_files = \"Source/SiestaUI//*.swift\"\n    s.dependency \"Siesta/Core\"\n    s.exclude_files = \"/Info.plist\"\n    s.ios.resources = \"Source//.xib\"\n  end. ",
    "edwardmp": "Was going to introduce a PR for the same.\nBut the tests are failing because compactMap is only implemented in Swift 4.1+.\nHence, the tests fail on Swift 4.0 and earlier. The solution should be to conditionally use compactMap/flatMap based on the Swift compiler version used.. @pcantrell I would normally agree, but since flatMap is used in just 5 places it might make sense to do this the \"easy\" way. Although I do have to say that a lot of my dependencies cause warnings for the same issue, so I guess I'll be stuck with those warnings for a while!. @Linnk \nGood idea! Can you submit a PR implementing this, at least, if @pcantrell  is willing to settle for this?. Hi @pcantrell do you have any suggestion for a workaround?. Hi @pcantrell,\nThanks for the reply!\nThe error is:\n\nDetails: \n      failure\n        userMessage:    \"Cannot parse server response\"\n        cause:          dataCorrupted(Swift.DecodingError.Context(codingPath: [], debugDescription: \"The given data was not valid JSON.\", underlyingError: Optional(Error Domain=NSCocoaErrorDomain Code=3840 \"No value.\" UserInfo={NSDebugDescription=No value.})))\n\nSo the response has a 204 status code, the body is blank and the Content Type is not JSON.\nThe last workaround you suggested works great, but it's still a workaround.\nWhat I can't derive from your answer is whether this is expected behavior or a bug? It does not seem logical to me that if setting a 204 status code it still attempts to parse the body.\n. @pcantrell give me 30 minutes then I'll test it as well. Great job by the way.\nWithout diving into the code: wouldn't making self weak in a capture list in the cacheRequest.chained closure achieve the same and fix this leak?. @pcantrell Oh right, so the issue here was that that code was not called in some circumstances and that led to the timer not being deallocated down the line?. @pcantrell OK I just checked and no longer see this leak! Do see some other leaks than include Siesta stuff in the stack trace, but for now I'm assuming those are related to something else.\nOne unrelated remark though: in the Siesta source code, I notice you use a rather remarkable curly brace style that I've never seen before. Is this simply your preference, or wasn't it supposed to look like this?. @pcantrell Cool! I'll close this issue then. I'll be sure to report more memory leak if I can substantiate them.. ",
    "Linnk": "@joaomvfsantos Hi. In order to avoid code duplication as you said, you can store the closure in a variable. This way you only need one line inside the conditional cases.\nFor Example:\n```swift\nlet stringNumbers = [\"1\", \"2\", \"3\", \"x\", \"4\", \"5\"]\nlet closure: (String) -> Int? = { Int($0) }\nif swift(>=4.1)\nlet numbers = stringNumbers.compactMap(closure)\n\nelse\nlet numbers = stringNumbers.flatMap(closure)\n\nendif\nprint(numbers)\n```\nEdit: I mean, in this example the closure is just one line too, but it could be a bigger block of code with multiple lines.\nPS. I was about to make a PR about these annoying warnings lol, good think I checked first.. @edwardmp Well, I was doing it\u2026 but then I read the comment about the siesta and swift versions and stuff. And I get it, I'm not fan either of those #if conditions.. ",
    "massdonati": "@pcantrell I know that you guys are busy but do you have any comment about this?. Hello, no worries and thanks for the response! That was my first implementation and yes it did fix the issue, but by checking if the contentType is contained in the underlyingRequest header field I'm being more conservative: for example if the request has different and multiple content types. Instead if I were to use setValue i would replace the entire value. . I see so you suggest to basically replace whatever content-type the configuration set with the method's contentType parameter, correct? If so I'll make the changes.\nAs a side note, unrelated with this issue, I'm wondering if the contentType parameter in \npublic func request(\n            _ method:        RequestMethod,\n            text:            String,\n            contentType:     String = \"text/plain\",\n            encoding:        String.Encoding = String.Encoding.utf8,\n            requestMutation: @escaping RequestMutation = { _ in })\n        -> Request\nand \npublic func request(\n            _ method:        RequestMethod,\n            json:            JSONConvertible,\n            contentType:     String = \"application/json\",\n            requestMutation: @escaping RequestMutation = { _ in })\n        -> Request\ncan go away and be hard coded? The reasoning for that is that I think is more error prone letting the user the freedom to specify an application/xml even if for example is sending json.\nAnyway thanks for the response.. @pcantrell I just update the pr.. ",
    "dondi": "No worries @pcantrell! I know how it goes \ud83d\ude42 Glad you like the idea and I\u2019ll just monitor the PR as things develop.. ",
    "sapieneptus": "\nresource.relative()\n\nSeems to do the trick! Not the prettiest thing in the world, but far better than monkey patching to make Request#url writeable or swizzling #withParam().\n\nAPIs that use multi-valued keys are rare\n\nAgreed, I just happen to be working with one :) I'll close this issue as the workaround is sufficient, thanks!. ",
    "falcon283": "Probably there is a misuse of Resource.request(.post, text: \"SomeText\") in my app, thus I solved it using Resource.request(.post, json: jsonObj)\nIt's still valid anyway that the current behaviour is different from the hold one and it's up to you decide if this new behaviour is the real behaviour you wanted or not.\nThe thing is that the Resource \"Content-Type\" value provided by the configuration, got completely overwritten by Resource.request(.post, text: \"SomeText\"). Ok I found your thought here thus I guess we can close this issue.\nThanks. I also thought about it. \nContent-type does make sense to be  unique, I guess it\u2019s specified also in the HTTP specs. \nIt\u2019s the media type of the body you are sending. So multiple values doesn\u2019t make really sense.\nOnly exception, if I\u2019m not wrong, would be multipart ... but it has its own content-type and the Body, as multipart, define its content type per body part.\nRegarding the .request methods ... well they are utilities so text/plain does make sense for text utility and application/json make sense for the json utility. \nI\u2019m thinking if it would be nice for those two methods to completely hide the contentType just to avoid confusion.\nIf you use them it\u2019s because you want to send plain text or json object.\nThere is always the full .request method to create totally custom request with Data. \nThis anyway will have chance to break devs code due to API signature change. It took me a while digging into Siesta 1.4 to understand what happened to my failing request.\nI arrived here @pcantrell and I think this will break quite some code around.\nAt some point in my app I have a Resource R1 I need to load using a Resource R2. \nR1.load(using: R2.withParam(\"someParam\", value).request(.post, text: \"SomeText\") )\nDoing this the request contentType param has its default \"text/plain\" value\nThe change-set here is going to overwrite completely the contenType stored by my Service Resource Configuration.\nI don't think this is a wanted behaviour. Isn't it?. I guess this can be a viable solution. I Can't produce a fully tested PR due to my limited time. Sorry about it.\nif underlyingRequest.value(forHTTPHeaderField: \"Content-Type\")?.contains(contentType) == false {\n    underlyingRequest.addValue(contentType, forHTTPHeaderField: \"Content-Type\")\n}. ",
    "anatolyw": "After deeper research I have found that issue was on the server side as the server first check if the session is valid and if not only then verify presents of Authorization header. As result, after logout and wiping all resources, 5th call from above sequence has finished successfully because the session was still valid. So, I got response results cached for another one hour. \nSolution is to reset URL session. NOTE: that will still keep session valid on the server side. If you want to invalidate server session as well then you have to call server logout method first if it is available. \nTo fix my issue I have performed following changes in the code:\n```\nclass MyAPI {\nstatic let sharedInstance = MyAPI()\n\nprivate let urlSession: URLSession  // NEW keep urlSession to have chance for reset\nprivate let service: Service        // MOVE initialization into init()\n\nprivate init() {\n\n    // NEW: Init session as you like. Ephemeral is default by Siesta \n    let config = URLSessionConfiguration.ephemeral\n    config.timeoutIntervalForRequest = TimeInterval(60)\n    config.timeoutIntervalForResource = TimeInterval(30)\n    urlSession = URLSession(configuration: config)\n\n    // NOTE: provide urlSession into Service constuctor\n    service = Service(baseURL: \"http://localhost:9000/ws/rest/service\", standardTransformers: [.text, .image], networking: urlSession)\n\n    // rest part of the init() code\n}\n\nprivate var basicAuthHeader: String? {\n    didSet {            \n        urlSession.reset() {} // NEW: From Apple doc: Empties all cookies, caches and credential stores, removes disk files, flushes in-progress downloads to disk, and ensures that future requests occur on a new socket.\n        service.wipeResources()\n        service.invalidateConfiguration() \n    }\n}\n\n// rest part of the class\n\n}\n```\nProposal:\n-   Add to Service class session reset method; \n. Our Java server uses embedded Jetty. First class which comes to the game is AuthenticationFilter, which makes following in doFilter:\n```\n        if (httpSession != null && httpSession.getAttribute(USER_CONTEXT_KEY) != null) {\n            // already authorized, nothing to do anymore\n            chain.doFilter(req, resp);\n            return;\n        }\n    if (!checkAuthorization(request, response, chain)) {\n            return;\n    }\n\n```\nSo, the Authorization header is not validated so far that special key is stored in a session. \nIn Siesta URLSession class is hidden inside and there is not much control over it.\nYES, it would be nice to have either better documentation around session management or small set of functions to manipulate with it without keeping its own reference in ServerAPI class as in my workaround above.. I have found a workaround by using service.resource(absoluteURL: ) method\nservice.resource(CONTEXT) constructs resource with encoded URL (';' is replaced with '%3B').\nResult for my example: http://localhost/ws/rest/service/assets/asset%3Bsomething/json.\nservice.resource(absoluteURL: URL(string:baseURL+CONTEXT)) doesn't perform encoding and keeps original characters in url. Result for my example: http://localhost/ws/rest/service/assets/asset;something/json.\nAfter such fix I can return to use normal CONTEXT string for service.configure and service.configureTransformer\n. ",
    "TienVu-PW": "Yes, that's what I'm doing atm, just thinking it might be more global usage for others, I'm actually doing verification inside the function that have Siesta call, that have completion closure with single error param that can return either Siesta error or verification error, then read the localized description to display it, don't need to cares if its from verification or networking.\nUsually in iOS I only need to use error.localizedDescription to display for any kind of error, I think it will be more common use of Error inside the app. It's still kind of depends for others.. ",
    "CodeEagle": "@pcantrell \n\n. Yes, via CocoaPods. Target Swift version 4.2.\npod install without config anything, the pod target also set swift version to 4.2, pod cache clean --all first.. ",
    "Uncommon": "Perhaps this should be private(set). Yeah, if it's only set in init then I'd say that's appropriate.. "
}