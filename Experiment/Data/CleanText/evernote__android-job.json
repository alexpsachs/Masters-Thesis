{
    "xalep": "There are a few things that I'm not entirely satisfied of:\n- calling isCanceled() on a params object is strange. It's not really a param.\n- forcing Job.Action implementers to implement onReschedule even if they don't care about it. Maybe that should be in an optional sub-interface of Job.Action\n. You could also use bound parameters here (you're already doing it for the queries)\n. ",
    "vRallev": "To be honest, I don't really like this approach. A job is intended as standalone component similar to the JobScheduler and GcmNetworkManager API, but you don't need to register your job in the manifest anymore. \nA few things are smarter, like the constructor for the Job class and the moved reschedule() function.\nI don't really see a benefit for the API of this library.\n. @jess-anders The apply() method is used only once here https://github.com/evernote/android-job/blob/feature/db/library/src/main/java/com/evernote/android/job/JobStorage.java#L170 Since this is called from the UI thread, I would keep apply() instead of commit().\n. Why don't you create a JobCreator which delegates the requests to your libraries? It shouldn't be so hard or am I missing an important detail? \n. I agree now. \n. I'll add it next week. \n. I've created a pull request and uploaded a snapshot build, so you can give it a try\ndependencies {\n    compile 'com.evernote:android-job:1.0.2-SNAPSHOT'\n}\nLet me know if that works for you. \n. No hurry. I'll wait for your feedback before I merge the PR. Thanks!\n. That's the first sentence from the onRunJob() method: This method is invoked from a background thread.\nBut I'll check the documentation nonetheless. Let me know what else is confusing. \n. Do you mind checking the last commit with the new README.md here: https://github.com/evernote/android-job/tree/feature/add-option-to-attach-multiple-job-creators\nThe missing documentation and sources is a problem of your IDE. As you can see they are available at maven central: http://search.maven.org/#artifactdetails%7Ccom.evernote%7Candroid-job%7C1.0.1%7Caar\n. I've added a description. Note that with version 1.0.2 you don't need to worry about it anymore. \n. You might want to read the blog post: https://blog.evernote.com/tech/2015/10/26/unified-job-library-android/\nI'll add the link in the README\n. I try to give some advice. But your inquiries are out of the scope of this library. \n\nif a non-recurring job was successful\n\nYou should store this value (probably a timestamp and if successful) somewhere (database, preferences, etc.)\n\nFor example, some jobs can wait as long as the user hasn't logged in but as soon as they do we have to perform those immediately, if they didn't occur, successfully, yet.\n\nYou can't run a job immediately. You should extract the logic into a separate class and reuse this class from the Job and your other event.\n\nif this library is used extensively I presume the jobs will pile up quickly. Is there a way to reset the DB?\n\nThat's no issue. In the end the library relies on the AlarmManager or JobScheduler. It would be more system limitation. Jobs are stored in a database. A database with thousands of entries still is not much. Once a non periodic Job finished it's removed from the database.\nYou can delete jobs (and clear the database) with following methods:\nJobManager.instance().cancelAll();\nJobManager.instance().cancel(id);\nJobManager.instance().cancelAllForTag(\"Tag\");\n. A direct download can be found in the README. There you also find the JavaDoc. Here is a direct link to the latest JavaDoc jar (unzip the content): http://search.maven.org/remotecontent?filepath=com/evernote/android-job/1.0.2/android-job-1.0.2-javadoc.jar\n. Thanks!\n. Hi @grennis I didn't have time to respond earlier. Like you noticed, with this execution window it's possible that the job never runs. You accept, the the last start time is Long.MaxValue. \nIn your case I would use something like:\njava\nnew JobRequest.Builder(DemoJob.TAG)\n   .setExecutionWindow(TimeUnit.HOURS.toMillis(2), TimeUnit.DAYS.toMillis(2))\n   .setRequiresCharging(true)\n   .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n   .setRequirementsEnforced(false)\n   .build();\nsetRequirementsEnforced can be helpful for you. This checks if the requirements are met and reschedules the job if they are enforced automatically. That's especially important for the AlarmManager. The AlarmManager has no API to specify curtain criteria and requirements. Enforcing the requirements is like a fallback for this proxy. \n\nbut anything that the UI is waiting for would not be well served \n\nThat's true and also isn't the intent of this library.\n. I haven't used the library above, yet, but it looks like it's a replacement for AsyncTask, Thread and Loader to run tasks right away on a background thread. E.g. if you develop an email client and you want to send an email, then you want to do this after the user hit send.\nWhereas this library should help you to run tasks in the future. It's a wrapper around JobScheduler, GcmNetworkManager and AlarmManager. E.g. your app should sync data once during the night, then it's very easy to accomplish this task with this library.\n. I disagree. How do you know when a job needs to be persisted and when not? You never know when the app is getting terminated. You can't rely on the fact that the Bundle is still around, when your job starts.\nHowever, you can easily add this function. If you schedule a job, it returns an ID. You can use this ID for a global cache or something similar to get your objects from the memory.\n. setPersistet() means persisting the job across reboots. The job is always persisted in a DB. E.g. you schedule a job in one hour. Your app can be terminated and then everything in the memory is gone. That's why it's necessary to save the job to the storage. \n. The first is clear. You need to call create() before using the JobManager. If your app gets force killed, then you need to call create() again. It's best to do this in onCreate() of your Application class.\nI've never seen the other crash. It could help if you provide a sample, otherwise I'm not sure what to do with it. \n. You need to call JobManager.create() asap in the onCreate() method. The reason is that your app may be launched because of a scheduled job. This job needs to be initialized and for that purpose it needs the have access to the JobManager. In your case the manager isn't created, yet, because you do this asynchronously. \n. Thanks, @Saketme \n. I agree. At another place I'm already doing the same. Within the next hour a new version 1.0.3 should be available. It'll contain fixes for this and other crashes.\n. Hi,\nI'm sorry, but I don't understand your point. The JobCreator creates a job for a specific tag. The tag is only necessary to avoid reflection code and trouble with Proguard. When it's time to run your Job, the library loads the tag from a database. Then your JobCreator is called to create a Job for this tag. This Job is then executed.\nYou shouldn't cache jobs, because the cached versions may be already destroyed the next time the job should run. So your JobCreator should always create new instances even for periodic jobs.\nI also don't see why a unique flag would be necessary. If you always return the same Job for the same tag (what I recommend), then you have unique jobs for a tag. \n. Now I understand your problem. Yes, it's definitely allowed to schedule multiple jobs with the same tag. That's a valid use case (especially for non-periodic jobs). In our app we're doing it in the same way like you do. We check first if a job exists for this tag and then schedule it if necessary. \nI'm still unsure if a method like setUnique(true) works well. It would require to cancel to the existing pending jobs and to schedule a new one. If your execution window is too big and you call this method from time to time, then it's possible that your job never will run.\nI think your approach is better. Check if a job for this tag is already scheduled. If yes, don't schedule a new job.\n. I've uploaded a new snapshot with a setUpdateCurrent(boolean) method. I reused the method name from the GCM API to keep things similar. Feedback is appreciated. I'll probably upload a new final build during the next week.\nTo use the new snapshot build, add this maven repo in your build.gradle:\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\nThe dependency is \ndependencies {\n    compile 'com.evernote:android-job:1.0.4-SNAPSHOT'\n}\n@lurbas Good catch with the charging flag! It's fixed in the new version.\n. Yes, that's okay. You need to update Android SDK. http://developer.android.com/intl/in/tools/support-library/index.html\n. Any update? \n. Why did you need to change gradlew and gradlew.bat?\n. Great, thanks for the detailed explanation!\n. Why don't you use the JobCreator for this purpose? I think that's exactly what you're looking for. The JobManager singleton is basically only there to hold a reference to the application context and to do the actual work. But the JobCreator creates the tasks for your tags. You can instantiate multiple of them for different scopes.\n. That requirement is enforced by the AlarmManager and since this library is a wrapper for all of them I made this a global constraint. An explanation can be found here: https://code.google.com/p/android/issues/detail?id=161244\nThe GCM API has a minimum of 30 seconds: https://github.com/google/gcm/issues/58\n. This library is a wrapper around 3 APIs and only the JobScheduler supports the back-off for periodic jobs. If your job now relies on this feature, then you need to first make sure, that you're using the JobScheduler API. That's exactly what you don't want.\nIn your situation you can use a one-off task with a back-off and always return Reschedule as result or schedule a new task manually. That should work, too. \n. Which Android version are you using? If it's 5+, then this behavior is expected, because the JobScheduler runs the job once during the 6 hours whenever it's a good time. The timing isn't fixed nor exact. If you want to have an exact job (what I wouldn't recommend), you need to rely on the one-off task.\n. I'm not sure right now. Have you made sure that only one job is scheduled? \n. With Android N this will be even more important: https://developer.android.com/preview/features/background-optimization.html\n. Can be tested with 1.1.0-SNAPSHOT.\n. Fixed in version 1.1.0.\n. Which version are you using? I also don't see any solution for this issue. Some devices throw this exception and it's not possible to catch it. \n. That's what I'm doing: \njava\ntry {\n    if (wakeLock.isHeld()) {\n        wakeLock.release();\n    }\n} catch (Exception e) {\n    // just to make sure if the PowerManager crashes while acquiring a wake lock\n    CAT.e(e);\n}\nThe exception is still crashing the app (also our's).\n. Thanks for pointing this out. I'll take look. \n. Let me know if the issue is fixed with version 1.0.5.\n. Yeah, I agree with this. Although I also like your workaround so far and I would recommend it this way right now.\n. Why is it necessary to make them implement the Parcelable interface? The parameters should be only interesting for your actual job. I don't see a use case. If you want to pass them to another Service or Activity, then you should add the arguments in a new Bundle.\n. That's not possible. The reason is that the arguments need to be stored in a database. There's no way to serialize a parcelable. At least it's not recommended. The JobScheduler doesn't allow parcelable arguments either. \nIt works with the AlarmManager, because the extras are never written to the disk. After a reboot or a force close the alarm is gone.\n. I'm sorry, but after thinking a lot about this I came to the conclusion that I don't want to expose the Params API. That would also require to change many other internal APIs, what I'm trying to avoid. Please use instead my recommended approach. You can also take a look at the FAQ: https://github.com/evernote/android-job/blob/master/FAQ.md\n. Android 5+ is using the JobScheduler. But that's the whole purpose of this project. The platform should decide, when it's the best time to run your job. Normal and repeating jobs should be inexact like here.\nIf you need an exact repeating job, then you should use an exact job and reschedule it yourself.\n. What would you do instead? I could either change the start interval to maybe current time + interval / 2 or use setInexactRepeating. What would you prefer? \n. @Kpeved Any response? \n. The constant needs to be dynamic and now it's the interval\n. Is this still an issue?\n. You can test your job with a smaller period. You can also call JobManager#setVerbose() to enable logging. Maybe it helps to track down the issue. \n. Yes, I agree, thanks!\n. What do you mean with \"closing\" the app? If you force close the app, it's possible that the job is delayed until you start the app again. \nI tested this scenario several times and can't reproduce the issue.\n. That's expected, because you're telling the system to close the app and that's what happening. The app shouldn't run. Then the system clears all alarms (AlarmManager) and no job will run until you start the app. \nDon't force close the app, instead close it with the back button or leave it open by pressing the home button.\n. Why are you accessing the JobScheduler directly? You should use the JobManager instead and query the jobs there. \nYou also shouldn't access the job database and change any values. That could result in wrong behavior. \n. I see, thanks for the detailed explanation! I'll take a look.\n. I finally had time to take a look. This happens if you do the following.\nFresh install the app, schedule a periodic job with the JobScheduler (min SDK 21). Now delete the data of the app. The app is being force killed. This cancels all jobs for the AlarmManager and GcmNetworkManager, but not for the JobScheduler. Now restart the app and schedule a new periodic job. The new job has the same ID as the old one, that's why both jobs are valid. \nIf a job can't be found for an ID, then it's automatically cancelled. This worked since version 1. The issue only occurs, if the IDs are overlapping. I hope that explains it. \nIt's fixed with version 1.0.6.\n. No, only 2.3% are below API 15 and this value will decrease even more. It's not worth for me to spend this extra effort. \n. Thanks\n. No, that's not possible for the same reason like #24 \nInstead extract your code into a helper class and call the code from your job and your other methods. \n. I understood it this way. But what you're requesting is not supported with the JobScheduler. That's why I gave you the tip to extract the logic.\n. Hard to say what's wrong. Is it possible that mCustomerSyncJobId is null in stopCustomerSyncJob()? Do you store the value in a preference file?\nIn your case I would use JobManager#cancelAllForTag(tag) to cancel the job. Or you can use the shortcut down below.\njava\n        new JobRequest.Builder(DemoJob.TAG)\n                .setPeriodic(TimeUnit.MINUTES.toMillis(1))\n                .setUpdateCurrent(true) // calls cancelAlllForTag(DemoJob.TAG) for you\n                .build()\n                .schedule();\n. Please start experimenting with the API or feel free to ask such questions at Stackoverlfow. That's not the purpose of issue tracking. \nReally short: Use JobManager.cancelAll() to cancel all jobs. No, you don't to save the job ID in that case.\n. Are you sure that your job was executed? \n. I tried the exact same code and it's working for me (Nexus 6P, Android 6). It seams to be an issue in your code. So I'm closing this.\n. https://github.com/firebase/firebase-jobdispatcher-android\n. I closed it by accident. There is no need to integrate the JobDispatcher at the moment. The JobDispatcher tries to solve the same thing like this library. It's basically a wrapper around existing APIs. But at the moment it only uses the GcmNetworkManager. Since this one is already integrated, it isn't necessary to include the JobDispatcher. . So it looks like the JobDispatcher remains as wrapper around the GcmNetworkManager. I don't think it makes sense to integrated it. I'm closing this issue now. . The system decides when to run your job. Jobs can run in parallel. You need to implement the mechanism yourself. That's out of the scope of this project and not its purpose. Sorry\n. Thanks for your feedback.\nI agree with the first point. It should be clearer mentioned in the documentation. \nThe 2nd option is not possible and not the purpose of this library. You could create a conflict, e.g. if you require a network connection, but at the moment you're scheduling the job no connection is available. That's why the system should decide when your job should run. I recommend to extract the logic from your job so that you can reuse it at other places. \nA periodic job fires whenever it's the best time. You set a period and your job once during this period. That can be at the beginning or end.\n. Yes, but that's how periodic jobs work.\n. It's really simple. If you schedule a periodic job, it'll run once during each period and continues running until you manually cancel it. It's not possible to run a job immediately (that's not the purpose of this lib). However, it's possible to schedule a periodic job and a one-time job at the same time with the same ID. In  this case it's also possible, that this job runs twice at the same time (the periodic job will continue and the one-time job is done after that). \nIn your case I would extract the code from the job into a separate class and let the periodic job reuse this class. If you want to run your job immediately, then reuse the extracted class again from a background thread.\nI hope that explains it better. \n. I can't reproduce the issue with \n``` java\npublic class DemoJob extends Job {\npublic static final String TAG = \"job_demo_tag\";\n\n@Override\n@NonNull\nprotected Result onRunJob(final Params params) {\n    JobScheduler scheduler = (JobScheduler) getContext().getSystemService(Context.JOB_SCHEDULER_SERVICE);\n    ConnectivityManager connectivityManager = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);\n    return Result.SUCCESS;\n}\n\n}\n```\nPlease share an example. You can also call Looper.prepare(). Doesn't this work? A thread pool is necessary to run jobs in parallel. \n. I still can't reproduce the crash.\njava\n    @Override\n    @NonNull\n    protected Result onRunJob(final Params params) {\n        CaptioningManager captioningManager = (CaptioningManager) getContext().getSystemService(Context.CAPTIONING_SERVICE);\n        return Result.SUCCESS;\n    }\nNexus 6P Android 6. Any hints? \n. That's a platform bug and not a problem of the library. I can reproduce it with Android 4.4 but not 6.0. I'm sorry for you, but you should handle the issue in your app. I don't want to switch to a HandlerThread. Jobs should run in parallel and it would be necessary to create a looper for each thread. That's an overhead I don't want to add for everyone only because you need to find a workaround for the platform bug.\nA dirty workaround could look like this:\n``` java\n    @Override\n    @NonNull\n    protected Result onRunJob(final Params params) {\n        HandlerThread thread = new HandlerThread(\"hello\");\n        thread.start();\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    Handler handler = new Handler(thread.getLooper());\n    handler.post(new Runnable() {\n        @Override\n        public void run() {\n            CaptioningManager captioningManager = (CaptioningManager) getContext().getSystemService(Context.CAPTIONING_SERVICE);\n            latch.countDown();\n        }\n    });\n\n    try {\n        latch.await();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n\n    thread.quitSafely();\n\n    return Result.SUCCESS;\n}\n\n```\n. @zegnus As @jess-anders mentioned, it's a bug in the platform. That's why they create the handler with the main looper in newer versions of Android. I won't change the library. You either need to create your own fork or use this simple workaround.\n``` java\n    private CaptioningManager mCaptioningManager;\nprivate CaptioningManager getCaptioningManager() {\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    Handler handler = new Handler(Looper.getMainLooper());\n    handler.post(new Runnable() {\n        @Override\n        public void run() {\n            mCaptioningManager = (CaptioningManager) getContext().getSystemService(Context.CAPTIONING_SERVICE);\n            latch.countDown();\n        }\n    });\n\n    try {\n        latch.await();\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return mCaptioningManager;\n}\n\n``\n. No, that's not possible. The reason is simple. There is no way to serialize and deserialize an object. The extras need to be written to disk and loaded again. TheAlarmManagerdoesn't have this limitation, because the system service is never terminated and after a reboot your alarm is gone. However, theJobSchedulerhas the same limitation. BTW,PersistableBundleCompatis a copy of the system classPersistableBundle. \n. See also #18\n. That's not useful. The schedule method as private method doesn't make much sense. The schedule method was meant to be used in another class. Making the methodpublic staticin your example would work. Do you mind updating your pull request?\n. I've uploaded a FAQ which answers your question: https://github.com/evernote/android-job/blob/master/FAQ.md\n. Hi,\nI don't see why this is necessary. Can you explain more what you're trying to achieve? \n. Sorry for the long delay. Unfortunately, that's not possible and theJobRequestclass shouldn't be exposed. TheJobclass has some helper methods likeJob.isRequirementChargingMet()`. Maybe that's useful. As other workaround you can pass those parameters as extra and read them from there. That's the recommended way.\n. I changed my mind and will extend the params API.\n. I've uploaded a snapshot build. Can you give it a try and let me know if it works for you?\n``` groovy\nrepositories {\n    maven {\n        url \"https://oss.sonatype.org/content/groups/public/\"\n    }\n}\ndependencies {\n    compile 'com.evernote:android-job:1.0.8-SNAPSHOT'\n}\n``\n. When I close this issue, the stable version will be available. Thanks for your feedback! \n. Can be tested with1.1.0-SNAPSHOT.\n. Fixed in version1.1.0.\n. I'm sorry for the delay. No, such a feature isn't planned as you never know when a job runs. It's probably much easier if you implement something like this by yourself, e.g. with a lock or theExecutorService`. That shouldn't be part of this library.\n. I'm able to reproduce the issue and I also agree that the job should be rescheduled in this case. \n. I've uploaded a snapshot build. Can you give it a try and let me know if it works for you?\n``` groovy\nrepositories {\n    maven {\n        url \"https://oss.sonatype.org/content/groups/public/\"\n    }\n}\ndependencies {\n    compile 'com.evernote:android-job:1.0.8-SNAPSHOT'\n}\n```\n. Thanks for testing. The stable version will come this week.\n. Please tell me how to reproduce the issue. I installed Dropbox on a Nexus 6P with the most recent OS version, but still everything works as expected.\nMy only guess is that the broadcast intent is implicit. Although this shouldn't make a difference, because the intent filter isn't exported. Concrete steps are appreciated. \n. I've uploaded a snapshot build. Can you give it a try and let me know if it works for you?\n``` groovy\nrepositories {\n    maven {\n        url \"https://oss.sonatype.org/content/groups/public/\"\n    }\n}\ndependencies {\n    compile 'com.evernote:android-job:1.0.8-SNAPSHOT'\n}\n```\n. Cool, thanks\n. Yes, this should be addressed. Thanks for pointing this out!\n. I'll probably publish a new version this week. But you can give the latest snapshot version a try. There it's already fixed.\n``` groovy\nrepositories {\n    maven {\n        url \"https://oss.sonatype.org/content/groups/public/\"\n    }\n}\ndependencies {\n    compile 'com.evernote:android-job:1.0.8-SNAPSHOT'\n}\n```\n. Are you sure that you've added the GCM dependency?\ngroovy\ndependencies {\n    compile 'com.google.android.gms:play-services-gcm:8.4.0' // or newer\n}\nAlso try to remove the process attribute. I've never tested to run the services with different processes and I wouldn't recommend it.\n. Also test the proguard config with \n-keep public class com.evernote.android.job.gcm.PlatformGcmService {\n  public protected private *;\n}\nNot sure if that helps. \n. It's optional and not required. In my own app if don't need the Google Play Services, then I wouldn't want that this library requires the Play Services. I tested it this moment and don't get the exception. Does the library crash or is this just a warning? Can you add a full log?. Is it possible that you included the Play Services and switched to Firebase? Your crash looks really similar to another I saw a while ago. If yes, then this should help you. Unfortunately, there is no better way to do this. . That makes sense. Follow the instruction in the link and it shouldn't crash anymore. . No, good idea to remove that. I'll do this as part of #165 . Did you run into the crash? \n. Thanks for the PR. I'll publish a new version with the fix later.\n. No, it wasn't removed. E.g. this still works:\njava\nnew JobRequest.Builder(DemoJob.TAG)\n        .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.EXPONENTIAL)\n        .setExtras(extras)\n        .setExact(20_000L)\n        .setPersisted(true)\n        .setUpdateCurrent(true)\n        .build()\n        .schedule();\n. Any response? \n. Interesting, but how do you attach your job creator in this case? To be clear, I could prevent the crash (what's actually better), but your job won't run. \n. But then you job won't run at all. The JobManager will ask all JobCreators if they can create a job for the specific tag. Your creator won't be called, because you haven't registered the creator, yet. \nI only see the option that you need to tell the users of your lib to initialize your library in the Application.onCreate() method. \nLet me know if you have a better idea.\n. Fixed in version 1.0.10. Thanks for your feedback!\n. My guess is that GCM is using reflection internally. We at Evernote decided against it. Class name mappings may change between versions and could result in undesired behavior. \n. Please provide a sample to reproduce the issue\n. I cannot reproduce the issue. If you can, then please provide a sample (the job class and how you schedule it would be enough). \nThe time in the logs above is wrong, I fixed this for periodic jobs, see 82e128137c7222e4af9508b60ba6816936f46646\n. Wrong issue.\n. You created a new issue. I guess the sample is meant for #62\n. Then please explain what the issue is.\n. That's expected. A periodic job runs once during a period. This can be in the middle, at the end or like in your case right at the beginning. The JobScheduler didn't support a flex parameter until API 24, that's still an open issue, see #53. \n. I'm aware of this behavior, but everything is working as expected. A periodic job runs once during one period. This can be in the middle, end or like in your case at the beginning. A flex parameter isn't implemented, yet, see #53 \nHopefully I find some time soon. \n. No, that's not necessary. Rescheduling is necessary when the app was forced close, because Android cancels all alarms. Then it's necessary if we have jobs, which aren't scheduled.\n. Good catch! Thanks for the detailed explanation, I was able to reproduce the issue.\nThe weird thing is, even when I avoid the overflow .setOverrideDeadline(Long.MAX_VALUE) doesn't work as expected. The job is being scheduled immediately nonetheless. I don't know the internals of the JobScheduler, but using .setOverrideDeadline(Long.MAX_VALUE / 3 * 2) works.\nI tried to add a workaround in #67. Can you give it a try and tell me if it works for you? I've published a new snapshot version:\n``` groovy\nrepositories {\n    maven {\n        url \"https://oss.sonatype.org/content/groups/public/\"\n    }\n}\ndependencies {\n    compile 'com.evernote:android-job:1.0.11-SNAPSHOT'\n}\n``\n. Any feedback? If not, I would merge the PR. \n. Thanks a lot @zoltish The stable version will be available later today.\n. Usually the job should run especially for such small time windows. Not sure what's wrong, a full log would be helpful. My guess is that you called the code snippet again. ThesetUpdateCurrent()` method cancels your old job and schedules a new one. This would explain that your job didn't run, but another one is still scheduled. . Can you tell me what's unclear? Here it is explained how to schedule jobs and that you must return either SUCCESS, FAILURE or RESCHEDULE https://github.com/evernote/android-job#usage \n. I'm closing this as there is no reply. Feel free to answer nonetheless. \n. I see your point, but I won't do this. There are several reasons:\n1) If I change the type, then I'd break every app using the library out there.\n2) I would need to update the database scheme.\n3) I wouldn't be so flexible to add some logic. \n4) Maybe more :) \nSorry, but the benefit isn't worth the effort. If the library wouldn't be public already, I'd change it and I'll consider it in the future. \n. Did you remove the Service from your manifest file as well? In our project we don't use GCM either and don't have this problem.\n. That would have been my next guess. To be honest, I've never tested this scenario. Can you show the full stacktrace? I'll also try it later.\n. I tried it myself and can't the reproduce the issue. I schedule a periodic job with the GCM API wrapper, removed the GCM dependency and then reinstalled the app. The job was automatically rescheduled to another API and didn't crash.\nIf it works for you, too, then please close the issue.\n. Now that you brought up the issue, I don't see any reason why not to include the service declaration or why to disable it. It has historical reasons that GCM wasn't included by default. We didn't want to have a third party dependency handling our job scheduling and wanted to rely on the platform completely. But I'm fine with using a simple config field. \nWere there other reasons why you wanted to disable the service?\n. I guess it's probably better to check the compile dependency only like you suggested and not if the Play Services are available, too (GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context)). My concern was that this could be flaky with new Play Services versions. \n. This is fixed in version 1.1.0-SNAPHSOT. I've uploaded a new snapshot and you can give it try if you like. \n``` groovy\nrepositories {\n    maven {\n        url \"https://oss.sonatype.org/content/groups/public/\"\n    }\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.0-SNAPSHOT'\n}\n```\nI'll release the stable 1.1.0 soon. Until then I'll keep this issue open to remind myself to update the README.md. \nThanks again for the good idea!\n. Fixed in version 1.1.0.\n. Thanks! I was able to reproduce the issue. It happened only in Android 4.X, because newer Android versions were using the JobScheduler and not the GCM.\nIt'll be fixed in the next version released this week.\n. Version 1.0.12 released\n. @yudhir Your code snippets are a little confusing. Could you provide a simpler example to reproduce the issue (or a project)? I also need to know on which Android version this issue is happening. \n@akramShokri There shouldn't be any issues. Which Android version are you using? It would also be really helpful if you could provide the database evernote_jobs.db. Then I could tell you if the system is doing weird things or if this library has a bug.\nMy guess is that some power saving optimizations like Doze are stopping your jobs. The device can never sleep and save battery.\n. That's what I expected. The system is sleeping to save battery and no app is running. When you turn the screen on again or open your app, the work is resuming. You can read more about it here: https://developer.android.com/training/monitoring-device-state/doze-standby.html \nThat's how the library works. Jobs shouldn't run at an exact time. Instead they should run when the system thinks it's a good time. The library tries to integrate your pending work better into the system. You should also read more about the JobScheduler and how it's working. \nIf your job really should run at an exact time, use setExact().\n. @yudhir Simply schedule a new exact job when the old finished. But that's not recommended, a handler would work better in your case. What is failing? Please attach the correct part of the log where the library is crashing. \n@akramShokri Which device and which Android version? How did you disable the power saving mode? Can you attach a log the log, too? \n. Please understand that this library is backed by the JobScheduler starting with Android 5. Before that it's using the AlarmManager or the GcmNetworkManager. Jobs should be inexact and that's what the JobScheduler is doing in your case. This would explain why you see the issue with Android 5, but not Android 4. \nLike I said, if you need the jobs to be exact, then use the appropriate method.\nThe library logs everything: when a job is scheduled, when a job should run and the result of a job. It would help if you attach the full log of the library (only this library, not your logs). It would be even better if you attach a sample where I could reproduce the issue. \nBut to be honest, I guess that everything is working as expected and that Android kills your process when it's in the background. I can't say what Samsung is doing internally. \n. Do you need anything else? Can this issue be closed?\n. @akramShokri Please attach the necessary information nonetheless. Then I'll reopen the issue. \n. Hopefully it's clearer now. Let me know if it's still confusing. \n. If you take a look at the instruction, you'll notice that you need to register a JobCreator instance. The JobManager calls your JobCreator with the appropriate tag and you should return the job. You have full control how to instantiate your job. I tried to avoid using reflection, otherwise Proguard could cause trouble.\nI recommend registering the JobCreator in the application class.\nHere is the sample again:\n``` java\npublic class App extends Application {\n@Override\npublic void onCreate() {\n    super.onCreate();\n    JobManager.create(this).addJobCreator(new DemoJobCreator());\n}\n\n}\npublic class DemoJobCreator implements JobCreator {\n@Override\npublic Job create(String tag) {\n    switch (tag) {\n        case DemoSyncJob.TAG:\n            return new DemoSyncJob();\n        default:\n            return null;\n    }\n}\n\n}\n```\nLet me know if something is still unclear.\n. Can you tell me on which Android version you've tested this? I guess it's Android 4. Let me explain what's happening.\nThe AlarmManager sets an alarm to run once during your interval. If you force close the app or swipe it away in the recents list, then all alarms are cleared and your app won't run until the user opens it again. There is no way to trigger a job when that happens. \nThe same thing happens if you reboot the device. E.g. you have an interval of 24 hours. 22 hours after you've scheduled the job the device is rebooting and then the alarm is cleared. The library is rescheduling the job when the device is on. Now it can happen that the system waits again 24 hours until finally triggers your periodic job.\nBy the way, the you have the same behavior if you call setUpdateCurrent(true). This will cancel the old job and schedule a new one. If you cancel your job after 22 hours and schedule a new one, then it could happen that the job runs after 24 hours. \nI hope it explains things better. In our app we avoid periodic jobs. Instead we usually rely on one-off jobs and schedule a new job after the old one finished. You can also take a look at the sample in the FAQ.\n. I've tested it on my Nexus 6P (Android 6.0) with an interval of 1 minutes. My log:\n```\n09-14 12:35:52.976 7415-7441/com.evernote.android.job.demo.gcm D/PlatformJobService: Run job, request{id=1, tag=job_demo_tag}, waited 00:09:30, interval 00:01:00, flex 00:01:00\n09-14 12:35:52.977 7415-7441/com.evernote.android.job.demo.gcm I/JobExecutor: Executing request{id=1, tag=job_demo_tag}, context PlatformJobService\n09-14 12:35:53.986 7415-7446/com.evernote.android.job.demo.gcm I/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=true, class=DemoSyncJob, tag=job_demo_tag}\n09-14 12:35:53.988 7415-7441/com.evernote.android.job.demo.gcm D/PlatformJobService: Finished job, request{id=1, tag=job_demo_tag} SUCCESS\n// reboot, device was on at about 12:41:10\n09-14 12:41:23.471 4856-4904/com.evernote.android.job.demo.gcm D/PlatformJobService: Run job, request{id=1, tag=job_demo_tag}, waited 00:15:01, interval 00:01:00, flex 00:01:00\n09-14 12:41:23.473 4856-4904/com.evernote.android.job.demo.gcm I/JobExecutor: Executing request{id=1, tag=job_demo_tag}, context PlatformJobService\n09-14 12:41:24.484 4856-4905/com.evernote.android.job.demo.gcm I/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=true, class=DemoSyncJob, tag=job_demo_tag}\n09-14 12:41:24.486 4856-4904/com.evernote.android.job.demo.gcm D/PlatformJobService: Finished job, request{id=1, tag=job_demo_tag} SUCCESS\n// waited more\n09-14 12:41:41.780 5964-6006/com.evernote.android.job.demo.gcm D/PlatformJobService: Run job, request{id=1, tag=job_demo_tag}, waited 00:15:19, interval 00:01:00, flex 00:01:00\n09-14 12:41:41.790 5964-6006/com.evernote.android.job.demo.gcm I/JobExecutor: Executing request{id=1, tag=job_demo_tag}, context PlatformJobService\n09-14 12:41:42.811 5964-6008/com.evernote.android.job.demo.gcm I/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=true, class=DemoSyncJob, tag=job_demo_tag}\n09-14 12:41:42.814 5964-6006/com.evernote.android.job.demo.gcm D/PlatformJobService: Finished job, request{id=1, tag=job_demo_tag} SUCCESS\n```\nEverything is working for me as it should. \nHow often do you schedule your job? I guess your setUpdateCurrent(true) could cause issues like I explained. Also please attach a log so that I can see what is going on. \n. I'm glad you found the issue.\n. Like I explained, that's the system behavior. \n. But the alarms from your app are cleared, if the app is getting forced closed. \n. They're also removed if you swipe away the app in the recents list AFAIK. You can test this yourself. Set an alarm, remove the app from the recent list and then check all pending alarms with adb. Test this please with a Nexus, maybe another manufacturer changed the behavior. \nNo, there is no graphic. The order is\njava\n        if (V_24.isSupported(context)) {\n            return V_24; // JobScheduler\n        } else if (V_21.isSupported(context)) {\n            return V_21; // JobScheduler\n        } else if (gcmEnabled && GCM.isSupported(context)) {\n            return GCM; // GcmNetworkManager\n        } else if (V_19.isSupported(context)) {\n            return V_19; // AlarmManager\n        } else {\n            return V_14; // AlarmManager\n        }\n. No, it's decided at runtime.. This is fixed in version 1.1.0-SNAPHSOT. I've uploaded a new snapshot and you can give it try if you like. \n``` groovy\nrepositories {\n    maven {\n        url \"https://oss.sonatype.org/content/groups/public/\"\n    }\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.0-SNAPSHOT'\n}\n``\n. Cool, thanks for the feedback!\n. Fixed in version1.1.0`.\n. You're correct, that's not possible. I explain here why: https://github.com/evernote/android-job/blob/master/FAQ.md#why-cant-an-interval-be-smaller-than-15-minutes-for-periodic-jobs\nDoes this make sense? \n. @justincpollard I've uploaded a snapshot build, where you can override the default value. Please give it a try and let me know if that works for you.\n``` groovy\nrepositories {\n    maven {\n        url \"https://oss.sonatype.org/content/groups/public/\"\n    }\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.1-SNAPSHOT'\n}\n```\njava\nJobManager.create().addJobCreator(...);\nJobManager.instance().getConfig().setAllowSmallerIntervals(true);\nThis method only works on Android M or earlier.\n. Thanks for the feedback @pvegh. I've added the log statement and uploaded another snapshot. You should be able to pull the latest version with ./gradlew --refresh-dependencies. \nIt'll be included in the next version. I'll probably release it at the end of this week. \n. They'll see crashes, because on N I throw an exception. I think this should be enough. \n. @TimVelo No, only logging an error message is exactly what I don't want, because that's what platform is doing and your jobs silently don't work on N anymore like you'd expect. \n@pvegh I won't add the @Deprecated annotation, but I will rename the method to setAllowDebugWithSmallerIntervals(boolean). Also the JavaDoc mentions, that this method throws an exception on N+. \n. New version 1.1.1 is available. The final method name is setAllowSmallerIntervalsForMarshmallow(boolean)\n. Sorry, but I don't understand what you mean. The API is there. Do you mean that the unit test is missing? \n. Feel free to create a pull request with the necessary test.\n. In the latest version the minimum is 15 minutes. It's a system limitation, you can read more about it here.\nIn your case a handler would work much better.\n. This hasn't been addressed, yet. But I doubt that you'll reach 2147483647. Imagine you would schedule 1000 jobs per day, then it would still require 5883 years to reach the maximum. \n. I'll test this nonetheless. \n. Why should it? \n. Yep, I'm pretty sure that you can easily do this with both SDKs. It's definitely not necessary to integrate this here. That's out of the scope of this project. \n. I've addressed this issue in the FAQ. Does this help you? \n. I'm closing because of inactivity.\n. No, the job runs on a background thread. You only need to do this if you have an async operation, otherwise you can avoid this workaround.\n. No, that's not enough for periodic jobs. You need to cancel the job on all devices, otherwise the system still tries to execute your job. Because your job creator doesn't return a job, it'll stop executing the job for this interval, but it'll try again the next day in your case.\nSimply call JobManager.instance().cancelAllForTag(\"Job-Tag\"); and you should be good. \nDoes this help?\n. It's at the front page: https://github.com/evernote/android-job#advanced. I doubt that this is caused by this library. It doesn't allocate much RAM. How many jobs do you schedule and how many of them run at the same time? \n. 12 jobs are okay. I don't know what's causing OOM in your app. You should check how much RAM you allocate and if you have a memory leak. The allocation tracker and a heap dump should help. \n. Did you find out more? \n. Closing because of inactivity. Feel free to respond nonetheless.\n. It's important to understand that the execution window is relative to the current time. So if you schedule a job in the next hour, then you use TimeUnit.HOURS.toMillis(1) and NOT System.currentTimeMillis() + TimeUnit.HOURS.toMillis(1). \nLet's say it's 11:20 PM and you want to schedule the job at 1 AM, then the start time is 1 hour and 40 minutes. That's what my code snippet is computing. The minutes:\njava\nCalendar calendar = Calendar.getInstance();\nint minute = calendar.get(Calendar.MINUTE); // 20 in the example \nlong startMs = TimeUnit.MINUTES.toMillis(60 - minute); // 40 in the example\nAnd hours:\njava\nint hour = calendar.get(Calendar.HOUR_OF_DAY); // 23 in the example\nlong startMs = TimeUnit.HOURS.toMillis((24 - hour) % 24); // 1 in the example\nSo the result in our example is 1 hour and 40 minutes, exactly what we want. \nDoes this make sense? \n. I cannot reproduce the issue. Can you provide me any steps? Did you somehow modify the database or pref file used by the library? How many jobs do you schedule roughly?\n. That's a big project with many dependencies. Could you please provide a simpler sample for me? Also I don't have any experience with Scala on Android. Could this break my library? \nI don't see a way in the library that the ID isn't unique at this point where the exception occurred? Can you reproduce the crash continuously? I'm wondering if your app crashed before and that the database/pref file got in a bad state because of that. \n. Found the issue. Your services run in a different process, but the jobs are always executed on the main process. Your service schedules the job and bumps the ID, but the main process doesn't see the new ID, yet, and then tries to reschedule the same job with the same ID.\nI see two options now. You can either run the scheduling logic to the main process or you can override the process for the job services. I haven't tried the 2nd option, but it could work. \n. Cool! But be careful with new jobs, which you schedule in the main process.\n. Not every app needs this listener. You can do this on your own. \n. Did you add a JobCreator? Where do you initialize the JobManager?\n. Okay. How often do you call your schedule() method? My guess is that you call it too often. setUpdateCurrent(true) cancels the old job and schedules a new one. Imagine you would call schedule() every 5 minutes, then your job would never run. I'd recommend that you do the following:\n``` java\n    public static int schedule() {\n    // don't schedule a new job, if one is already scheduled\n    Set<JobRequest> jobRequests = JobManager.instance().getAllJobRequestsForTag(TAG);\n    if (!jobRequests.isEmpty()) {\n        return jobRequests.iterator().next().getJobId();\n    }\n\n    long interval = TimeUnit.HOURS.toMillis(6); // every 6 hours\n    long flex = TimeUnit.HOURS.toMillis(3); // wait 3 hours before job runs again\n\n    return new JobRequest.Builder(TAG)\n            .setPeriodic(interval, flex)\n            .setPersisted(true)\n            .setUpdateCurrent(true)\n            .build()\n            .schedule();\n}\n\n```\nI've tested this and it works. \n. I still cannot reproduce the issue. Please disable the .setRequiresDeviceIdle(true). Maybe Android N behaves differently. \n. Yep, but I can't do anything here. The system decides when it's best to run your job (during the maintenance windows in Doze mode). It may be even possible that the time gap increases. But that's how things work on N. \nIs everything clear now. If yes, please close the issue. \n. Thanks!\n. Correct, each job has its own ID. A job is more or less immutable, you cannot change the parameters after it has been scheduled. You can have multiple jobs with the same tag. .setUpdateCurrent() is a shortcut to cancel all jobs for this tag. But this could be problematic. Imagine a periodic job, which runs every 15min, but you schedule a new one every 10 minutes and cancel the old one. Then your job would never run. \nYour scheduleSync() method looks good, we follow the same pattern. I've recently uploaded a sample app. There I have a sync job, which looks similar to your's. On the other hand multiple reminder jobs can be scheduled at the same time. \nShort:\n1) The old job is removed from the table, a new table entry is created with the new parameters and a new ID. \n2) Yes, you'll have two jobs in the table.\n3) Yes, non-periodic jobs are removed. \n. I haven't seen this before. Looks more like an issue with the JobScheduler and you could file a ticket at AOSP. I don't think we can do anything here. \n. I'm not sure. The library calls jobFinished() asynchronously on a background thread. That's different than what the bug report states. \n. Maybe it was already fixed? https://code.google.com/p/android/issues/detail?id=170814 Do you use the JobScheduler at other places? \n. It looks like I can't do anything. This is a platform bug and there is no way to catch it. Do you have an idea? \n. Closing because of inactivity\n. That's a bug in the Android platform. You better file a bug here: https://code.google.com/p/android/issues/list I'm also not aware of any workaround :( . No, that's a completely different project.. I tried it and couldn't reproduce it (instant run disabled). \n. This should fix a bug in the platform code, where onStartJob() in the JobScheduler API is called twice, see http://stackoverflow.com/questions/33235754/jobscheduler-posting-jobs-twice-not-expected\nBut you're absolutely right, that periodic jobs shouldn't be canceled. Nasty bug, thanks for figuring out what's wrong. \n. @reiterp-avs Good point, I'll do that. \n. New version 1.1.1 and 1.0.14 were released.\n. I cannot reproduce the issue. The build works fine for me. Are you using the gradle wrapper? Did you try a clean? \n. You mean that you use the job library in your library project, which doesn't contain any resources? \n. Thanks Android gradle plugin! The problem is, that gradle packaged an old R class, which shouldn't be there. I'll publish another version :( \n. This is fixed in version 1.0.15 and 1.1.2. Please let me know if that works and feel free to reopen the issue if necessary. \n. Ups, I forgot to push the new version. It's working now.\n. Hi @junchengc,\nI've created a the feature/lint branch for you. Everything should be ready for you to commit on this branch.\nI think a good start would be the following checks.\n``java\n// if one is greater than (Long.MAX_VALUE / 3) * 2, then it's an error\n// if one is greater than a year, then it should be a warning. People like to useSystem.currentTimeMillis() + offset`, although it should be only offset\n.setExecutionWindow(TimeUnit.MINUTES.toMillis(2), TimeUnit.MINUTES.toMillis(3)\n.setExact(something)\n// interval should be at least 15min and flex at least 5min, flex shouldn't be greater than interval. Both would be errros\n.setPeriodic(long intervalMs, long flexMs)\n```. Closing because of inactivity.. What's your compile SDK version? Probably 24 or 25 is necessary. \n. Hm, hard to say what's wrong. If you don't have the GCM dependency, then this class shouldn't be called at all. But it seams like the play services do this (no one else would instantiate this class).\nMaybe adding this line helps. But it's more a shot in the dark:\ngroovy\ncompile \"com.google.android.gms:play-services-gcm:$firebaseVersion\"\n. I can reproduce the crash now with the demo application. It's simple: \n1. Install the app with the GCM dependency \n2. Open the app\n3. Install the app without GCM (without uninstalling while the app is open). \nRight after that I see that the app crashed.\n11-01 09:49:32.096 6438-6438/? E/AndroidRuntime: FATAL EXCEPTION: main\n                                                 Process: com.evernote.android.job.demo, PID: 6438\n                                                 java.lang.RuntimeException: Unable to instantiate service com.evernote.android.job.gcm.PlatformGcmService: java.lang.ClassNotFoundException: Didn't find class \"com.evernote.android.job.gcm.PlatformGcmService\" on path: DexPathList[[zip file \"/data/app/com.evernote.android.job.demo-2/base.apk\"],nativeLibraryDirectories=[/vendor/lib, /system/lib]]\n                                                     at android.app.ActivityThread.handleCreateService(ActivityThread.java:2746)\n                                                     at android.app.ActivityThread.access$1800(ActivityThread.java:151)\n                                                     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1386)\n                                                     at android.os.Handler.dispatchMessage(Handler.java:102)\n                                                     at android.os.Looper.loop(Looper.java:135)\n                                                     at android.app.ActivityThread.main(ActivityThread.java:5254)\n                                                     at java.lang.reflect.Method.invoke(Native Method)\n                                                     at java.lang.reflect.Method.invoke(Method.java:372)\n                                                     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\n                                                     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\n                                                  Caused by: java.lang.ClassNotFoundException: Didn't find class \"com.evernote.android.job.gcm.PlatformGcmService\" on path: DexPathList[[zip file \"/data/app/com.evernote.android.job.demo-2/base.apk\"],nativeLibraryDirectories=[/vendor/lib, /system/lib]]\n                                                     at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56)\n                                                     at java.lang.ClassLoader.loadClass(ClassLoader.java:511)\n                                                     at java.lang.ClassLoader.loadClass(ClassLoader.java:469)\n                                                     at android.app.ActivityThread.handleCreateService(ActivityThread.java:2743)\n                                                     at android.app.ActivityThread.access$1800(ActivityThread.java:151)\u00a0\n                                                     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1386)\u00a0\n                                                     at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\n                                                     at android.os.Looper.loop(Looper.java:135)\u00a0\n                                                     at android.app.ActivityThread.main(ActivityThread.java:5254)\u00a0\n                                                     at java.lang.reflect.Method.invoke(Native Method)\u00a0\n                                                     at java.lang.reflect.Method.invoke(Method.java:372)\u00a0\n                                                     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\u00a0\n                                                     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\u00a0\n                                                    Suppressed: java.lang.NoClassDefFoundError: com.evernote.android.job.gcm.PlatformGcmService\n                                                     at dalvik.system.DexFile.defineClassNative(Native Method)\n                                                     at dalvik.system.DexFile.defineClass(DexFile.java:226)\n                                                     at dalvik.system.DexFile.loadClassBinaryName(DexFile.java:219)\n                                                     at dalvik.system.DexPathList.findClass(DexPathList.java:321)\n                                                     at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:54)\n                                                            ... 12 more\n                                                    Suppressed: java.lang.ClassNotFoundException: com.evernote.android.job.gcm.PlatformGcmService\n                                                     at java.lang.Class.classForName(Native Method)\n                                                     at java.lang.BootClassLoader.findClass(ClassLoader.java:781)\n                                                     at java.lang.BootClassLoader.loadClass(ClassLoader.java:841)\n                                                     at java.lang.ClassLoader.loadClass(ClassLoader.java:504)\n                                                            ... 11 more\n                                                  Caused by: java.lang.NoClassDefFoundError: Class not found using the boot class loader; no stack available\nIt seams like the Play services are looking for the service. Since it's still declared in the manifest they start the service and then the app crashes. You can avoid this by removing the service. Then it won't crash.\nxml\n        <service\n            android:name=\"com.evernote.android.job.gcm.PlatformGcmService\"\n            tools:node=\"remove\"/>\nCan you give it a try and let me know if that works for you? \n. But you removed the GCM dependency (at least that's how I understand your first message). I don't see any other reason why the class couldn't be loaded. That's why I mentioned you should remove the service from the manifest.\nAdding the dependency should fix the crash. Without it the library can't use the GCM API. Please let me know if that works. \n. Good point, I'll do that in the FAQ.\n. That's expected. The job should run once during a period, that's the most important requirement. The other requirements like the network flag are only hints for the system to decide when it runs the job. If you want to skip your job if your requirements aren't met, the call .setRequirementsEnforced(true) on the builder object, like \njava\njobId = new JobRequest.Builder(INTENT_FEATURE_FLAG_UPDATE)\n                .setPersisted(true)                                         /* Persist it across reboots */\n                .setPeriodic(FlavorConstants.FEATURE_FLAG_ALARM_INTERVAL)       /* Wait for a max of 5 mins */\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)         /* Network mandated */\n                .setRequirementsEnforced(true)\n                .setUpdateCurrent(true)                                     /* override existing jobs */\n                .build()\n                .schedule();\nIf that works for you, please close the issue. \n. I'll do that in the FAQ.\n. java\nJobManager.instance().getConfig().setVerbose(false);\nThat's the trick :) Please close the issue if that solves it. \n. You should use the latest version, your jobs won't work correctly on Android 7.0 and 7.1. But I think on the old version you can call JobManager.instance().setVerbose(false);.\n. Unfortunately, that's a requirement and there is no better workaround. I don't know much about Cordova, but maybe you can create a ContentProvider with zero functionality. You can use its onCreate() method to initialize the JobManager, which is called each time the app launches. \nI have no other idea than that. \n. But a BroadcastReceiver can be used in Cordova? Maybe I'll add a workaround to register JobCreators. \n. No, a receiver doesn't help you in the moment. But I'm thinking about a solution to send a broadcast to initialize the job creators. \n. You don't need to listen for the reboot broadcast. The library is doing this for you. The new broadcast receiver get called once when your application starts. If the system kills your app, then the receiver will be called again the next time your app starts.\nA sample is here. There's nothing more to it. \nThe 1.0.X branch won't be maintained anymore. Always use the latest version mentioned in the README.\n. - You can rely on the receiver. Initializing the JobCreator in a Service doesn't make much sense in my opinion. Initialize it either in the your Application.onCreate() or in the receiver. Otherwise there's a big chance, that your jobs won't run, because the JobCreator is missing.\n- The receiver is only called when your app starts. I don't see a use case for anything else. \n- The receiver is called when JobManager.create(context) is called for the first time, see here.\n. A sample is here.\n. I gave you a sample and you should be able to do the rest. If not, please ask these questions at a better place like Stackoverflow. \n. You can use a non-periodic job to achieve that, then you have more control over it like here. Or you can schedule a non-periodic job, which then schedules your actual periodic job every 30 minutes. \nBut I would probably go with the first option. \n. Hm, hard to say what's wrong. Nothing has changed about periodic jobs between those versions. Note that you also should be using version 1.1.2, otherwise your jobs won't work properly on Android N.\nHow often do you call your schedule method? Your startService() could be problematic if the system kills your app, before your service starts (take a look at the WakefulBroadcastReceiver class to understand what I mean). \nA sample application which reproduces that issue would be helpful. \n. Simply use the latest version, which is 1.1.2. Android N changed the min interval for periodic jobs. So you maybe expect that a job runs every 5 minutes, but in the end it doesn't on N. \nThe log only shows, because you're testing an older emulator version (older than KitKat). There those methods aren't available. \n. https://github.com/evernote/android-job/blob/master/FAQ.md#why-cant-an-interval-be-smaller-than-15-minutes-for-periodic-jobs\n. That was probably a platform bug. In 1.1.2 the flex parameter gives you more control. \n. Is anything left? For the initial issue I need sample app, which reproduces the behavior in an emulator. Otherwise I can't do anything. \nIf nothing is left, then please close the issue.\n. I've tested the demo application and it works for the release type. Either add the rule @alfdev mentioned or add the default proguard config, e.g.\ngroovy\n        release {\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'your-proguard.cfg'\n        }\n. Wifi is usually JobRequest.NetworkType.UNMETERED. That means it doesn't cost the user any money and there's no quota. If you use your mobile phone connection, then that's usually JobReqest.NetworkType.NOT_ROAMING. \n. Do you have Proguard enabled? Can you attach a sample project to reproduce the issue? \n. That's weird. Did your disable the manifest merger? Which Gradle plugin are you using? Can you attach a really simple sample to reproduce the issue for me? \n. I cannot reproduce the issue. Something is wrong in your app and it seems to be unrelated to the library. \n. I didn't receive the sample, yet. This sound more like misconfigured Proguard rules. I guess without Proguard it's working. \n. That's a duplicate, please continue the discussion in #108 \n. Can you provide more information? E.g. the failing proguard config you're using?\n. Closing because of inactivity. . You need to schedule the exact job first (not periodic) and then schedule the periodic job from the first job. There is no other way in the moment. . No, jobs are independent of the timezone. You schedule jobs in the future relative to the current time, e.g. in 2 hours from now. Then the timezone doesn't play a role. You need to handle this case yourself. \nI also don't want to change the behavior or add this capability, because timezones don't make sense for the way things work currently. Also the API is tied to the JobScheduler, which doesn't support this feature either. . You can get the extras in the onRunJob() method. Each job has its own extras depending on what you pass in in\njava\n    @Override\n    @NonNull\n    protected Result onRunJob(final Params params) {\n        PersistableBundleCompat extras = params.getExtras();\n        return Result.SUCCESS;\n    }\nYou can also query the extras like the following\njava\nint id = 5;\nJobManager.instance().getJobRequest(id).getExtras();. I tested it and can't reproduce the issue. Few questions. Was the screen on all the time during the 90 seconds? Was your app open? How often do you call your schedule method? . Weird, I cannot reproduce it, I tried the following\njava\n        mLastJobId = new JobRequest.Builder(DemoSyncJob.TAG)\n                .setExecutionWindow(3_000L, 4_000L)\n                .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.LINEAR)\n                .setRequiresDeviceIdle(false)\n                .setRequirementsEnforced(true)\n                .setUpdateCurrent(true)\n                .build()\n                .schedule();\nAnd in the log\n12-01 08:48:30.088 3063-3084/com.evernote.android.job.demo D/JobManager: Reschedule 0 jobs of 0 jobs\n12-01 08:48:34.722 3063-3063/com.evernote.android.job.demo D/JobProxy24: Schedule one-off jobInfo success, request{id=1, tag=job_demo_tag}, start 00:00:03, end 00:00:04\n12-01 08:48:37.736 3063-3090/com.evernote.android.job.demo D/PlatformJobService: Run job, request{id=1, tag=job_demo_tag}, waited 00:00:03, start 00:00:03, end 00:00:04\n12-01 08:48:37.751 3063-3090/com.evernote.android.job.demo I/JobExecutor: Executing request{id=1, tag=job_demo_tag}, context PlatformJobService\n12-01 08:48:46.259 3063-3091/com.evernote.android.job.demo I/JobExecutor: Finished job{id=1, finished=true, result=FAILURE, canceled=false, periodic=false, class=DemoSyncJob, tag=job_demo_tag}\n12-01 08:48:46.261 3063-3090/com.evernote.android.job.demo D/PlatformJobService: Finished job, request{id=1, tag=job_demo_tag} FAILURE\nThere aren't any other log statements, right? Do you use multiple processes? You can debug the issue by adding a break point in the com.evernote.android.job.v21.PlatformJobService to see if it's being called. . Closing because of inactivity. Feel free to reply nonetheless. . I don't have a Nexus 6 here. Could you attach logs? Also please try to debug the issue by adding a break point in com.evernote.android.job.v21.PlatformJobService. Sounds more like an issue with this device. . Did you update the persisted jobs on the devices? If not, then they're still around. \nJobs are persisted. It isn't enough to change the code if you want to change some parameters. You also need to cancel old jobs and then schedule the new one with the new parameters.. Please attach logs, otherwise it's hard for me to understand what's going on. \nThat the job doesn't run can be explained with setRequirementsEnforced(true). If the network isn't connected, then your job won't run. But the logs could tell what's happening.. I think that can happen with the JobScheduler. If this is wrong, then it's more a system bug with the JobScheduler and not the library.\nImagine you schedule a periodic job with an interval of 15min at 10:00, then each hour has 4 intervals. 10:00 > 10:15, 10:15 > 10:30, 10:30 > 10:45, 10:45 > 11:00. The requirement is that your job runs once during an interval, so your job can run at 10:02 and 10:29. That would be correct. \nBut in order to save battery and resources, the system adjusts intervals or delays jobs. That's not a bug, that's a feature (see Doze mode). \nIf you job really should run every 15 minutes and it shouldn't be delayed, then you need to make the job exact. There is no other option. But I wouldn't recommend doing this, because then your app prevents the device from sleeping and going into Doze mode. That wastes a lot of battery. \nI hope that this makes it clearer. . Sure, glad that I could help.. You mean the home button? The device gets into an idle state when you turn off the screen and don't turn it on for a while. So you're saying that with setRequiresDeviceIdle(true) your job don't run? That would be expected if you're device's screen is still on.. The device will never go into idle state while the debugger is attached. . Can the issue be closed?. You didn't attach the full stacktrace. I'm assuming the crash mentions, that the required boot completed permission is missing. We had similar issues with some devices and ended up doing the same:\njava\nnew JobRequest.Build(PushJob.TAG)\n    .setAAA()\n    .setPersisted(JobUtil.hasBootPermission(context)\n    .build()\n    .schedule()\nThat works for us and I don't have a better solution. Also notice that the library reschedules all necessary jobs the next time it's being launched. So you don't have to do anything else and no job will get lost. . I don't know what happened with those devices either. Maybe it's a custom ROM or Samsung did something really weird. Can the issue be closed?. That's weird and I've tested it multiple times and it should work. If you cancel a not running job, then it shouldn't run anymore. If you cancel a job while it's running, then the you can call isCanceled() inside your job to check if it was canceled. \nPlease attach a log or a sample project. Otherwise it's hard for me to tell what's going on. . You misunderstood what was meant with async operation. onRunJob(params) is already called on a background thread. It's not necessary to create another thread. . java\n@NonNull\n@Override\nprotected Result onRunJob(Params params) {\n    doHeavyWork();\n    return Result.SUCCESS;\n}\nPlease attach logs or a sample project. . Then everything works as expected. It's not possible to destroy a thread and stop its work in Java. You need to check isCanceled(). Sorry, but that's not part of this library and you should ask such questions elsewhere like Stackoverflow. . Prove it and attach logs. . Sorry, no serious coder here.. Duplicate of #118 . Yes and everything looks normal to me\nD/JobProxy21: Schedule one-off jobInfo success, request{id=2, tag=background_job_all_leader_boards_tag}, start 00:00:01, end 00:00:01 (+1 day)\nI/JobManager: Found pending job request{id=2, tag=background_job_all_leader_boards_tag}, canceling\nI/JobManager: Cancel running job{id=2, finished=false, result=FAILURE, canceled=false, periodic=false, class=BackgroundJobAllLeaderboards, tag=background_job_all_leader_boards_tag}\nHere is another sample:\n```java\n    @Override\n    @NonNull\n    protected Result onRunJob(final Params params) {\n        boolean canceled = isCanceled(); // false\n    JobManager.instance().cancelAll();\n    canceled = isCanceled(); // true\n\n    return Result.SUCCESS;\n}\n\n```\nOnce you called cancel, your job doesn't immediately stop. That's how Java works. . Hi, you can easily add such features yourself and those shouldn't be part of the library. . You can easily add this check at the beginning of your Job. Like I said, there's no need to do this in the library itself. . This looks like an issue with Proguard. Which version of the library do you use? I remember that there was an issue, if classes were moved to the default package. But this was fixed a while ago. Which class is \ufee7$iF? You find this information in your mapping file.\nYou need to make sure that you cancel all jobs, otherwise they will run. . Which class is \ufee7$iF? You can call JobManager.instance().cancelAll(), then you should be good. . Yes. How should the system else know, that your jobs shouldn't run anymore? Call cancel.\nYou can remove the library completely, that should help. . I'm not responsible for your app ;-) Yes, that should solve it. . Can you share your gradle build files or a sample project? @akramShokri Gave a pretty good hint. Do you have proguard enabled?. The build file looks fine. Not sure what's wrong in your case. Maybe you can find the issue by running ./gradlew :app:dependencies. The dependency graph is really helpful. . @amalive Why did you reopen the issue? . What @akramShokri said. You should find many instructions, but Gradle is definitely recommended. . You can do the following\njava\n        Set<JobRequest> requests = JobManager.instance().getAllJobRequests();\n        for (JobRequest request : requests) {\n            long startMs = request.getStartMs();\n            long endMs = request.getEndMs();\n            JobRequest.NetworkType networkType = request.requiredNetworkType();\n        }\nBut right now it's not possible to get the timestamp when the request was scheduled. But with a little \"hack\" you can add a workaround:\n```java\npackage com.evernote.android.job; // package is important\npublic class ScheduledAtHelper {\n    public static long getScheduledAt(JobRequest request) {\n        return request.getScheduledAt();\n    }\n}\n```\nNote that this won't guarantee, that the job will run exactly at time (besides if the job is really exact). The OS can still delay the job for battery optimizations. \nDoes this help? . I don't see a reason to keep it protected. I'll keep the issue open. . The log says all, you scheduled the job 17171 days in the future. Not sure if you want to wait that long :) . Call setExact(60000). The documentation says:\nThe milliseconds specified are treated as offset from now, e.g. the job will run at {@code System.currentTimeMillis() + exactMs}.. You're saying it's still not working? . Closing because of inactivity. Feel free to reply nonetheless.. There is no easy solution. The recommended way is to schedule another job one time, which then schedules your periodic job at the desired time. This sample could also be helpful for you.. Closing because of inactivity. Feel free to reply nonetheless.. Good find. That's actually expected behavior and I don't know any way to prevent this issue. My assumption is that Google thinks that when the user swipes away the app, then he doesn't want to use it anymore and even cancels all alarms (it's like a force close). The next time the app starts it's possible to reschedule alarms and that's what this library does: https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobManager.java#L482\nSo your jobs aren't lost. . I don't know. That's not a problem of this library but a general issue with the AlarmManager. You could more broadcasts to your manifest so that you app is started again, but that's also a bad approach. . Can you post the full code how you created the PendingIntent? I'd like to try it myself. . Okay, I tried it myself again with following snippet and I couldn't reproduce what you mentioned. \n```java\nIntent intent = new Intent(this, PlatformAlarmReceiver.class);\n// will be null after force closing or swiping away\nPendingIntent pendingIntent = PendingIntent.getBroadcast(this, 4, intent, PendingIntent.FLAG_NO_CREATE);\npendingIntent = PendingIntent.getBroadcast(this, 4, intent, PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_UPDATE_CURRENT);\nAlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);\nmanager.set(AlarmManager.RTC, System.currentTimeMillis() + TimeUnit.HOURS.toMillis(30), pendingIntent);\n. I tried your test application and cannot reproduce what you've explained (Nexus 6P). My log\nD/TTTTT: PendingIntent.getBroadcast(...) != null: false // started app\nD/TTTTT: PendingIntent.getBroadcast(...) != null: true // scheduled alarm, swiped app away, reconnected device to PC\nD/TTTTT: PendingIntent.getBroadcast(...) != null: true // from the broadcast receiver\nD/TTTTT: PendingIntent.getBroadcast(...) != null: true // started app\nD/TTTTT: PendingIntent.getBroadcast(...) != null: false // canceled alarm, swiped app away, reconnected device to PC\nD/TTTTT: PendingIntent.getBroadcast(...) != null: false // from the broadcast receiver\nD/TTTTT: PendingIntent.getBroadcast(...) != null: false // started app\n``\nEverything works as expected. . Ah, yes, I missed that. But after swiping the app awayadb shell dumpsys alarmstill returns thePendingIntentfor me. SoPendingIntent.getBroadcast()` is consistent with the output. \nBut I'm not sure right now why the alarm isn't cleared after swiping the app away. However, force closing the app definitely clears the alarm. . Of course, that issue is specific to the AlarmManager. This library is using the JobScheduler and GcmNetworkManager if possible. The AlarmManager is only a fallback if the other two aren't available (exact jobs require the AlarmManager). . Closing because of inactivity. Feel free to reply nonetheless.. I see why this could be useful, but that's really hard to achieve. Android controls when your job should run and the library is relying on that. E.g. if you set Internet access as requirement, then it's very likely that your job will only run, when you have Internet access. The system takes this into account.\nOne workaround could be to schedule a 2nd one-time job like the following. \njava\n    private void schedulePeriodic() {\n        mLastJobId = new JobRequest.Builder(DemoSyncJob.TAG)\n                .setPeriodic(TimeUnit.DAYS.toMillis(30))\n                .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED)\n                .setRequirementsEnforced(false)\n                .setPersisted(true)\n                .build()\n                .schedule();\n    }\nThen inside your job:\njava\n    @Override\n    @NonNull\n    protected Result onRunJob(final Params params) {\n        if (Device.getNetworkType(getContext()) == JobRequest.NetworkType.UNMETERED) {\n            // do your work\n        } else {\n            new JobRequest.Builder(DemoSyncJob.TAG)\n                    .setExecutionWindow(TimeUnit.HOURS.toMillis(12), TimeUnit.HOURS.toMillis(24))\n                    .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED)\n                    .setRequirementsEnforced(false)\n                    .setPersisted(true)\n                    .build()\n                    .schedule();\n        }\n        return Result.SUCCESS;\n    }\nNotice that the one-time job is using the same tag and will execute the same job. This should solve your issue.\n. In such cases I tend to use one-time jobs and handle the rescheduling manually. That's easier and gives me more flexibility. Your use case sounds similar and I would recommend doing the same.\nI'll add the snippet in the FAQ.. Closing because of inactivity. Feel free to reply nonetheless.. You can use getContext() inside of onRunJob(params). . Hi, like most project nowadays it's using min SDK 14, it can be found here: https://github.com/evernote/android-job/blob/master/build.gradle. Here's a sample that does exactly this: https://github.com/evernote/android-job/blob/master/FAQ.md#how-can-i-run-a-job-at-a-specific-time-once-a-day\nOtherwise please ask such questions at Stackoverflow. There you reach more people who can help you.. Thanks for your feedback. After reading the JobScheduler documentation again, I noticed that the JobScheduler does what you're suggesting. \nI'll change that. . Fixed in version 1.1.5. Thanks!. The behavior has slightly changed. Previously when a job was rescheduled the start and end window increased by the corresponding back-off criteria. \nImagine this job:\njava\nnew JobRequest.Builder(DemoSyncJob.TAG)\n        .setExecutionWindow(3_000L, 4_000L)\n        .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.LINEAR)\n        .build();\nWhen this job was rescheduled for the first time, then the execution window changed to (8_000, 9_000), 2nd fail (13_000, 14_000), ...\nNow it has changed in that way, that the start and end window aren't added to the back-off criteria anymore. First fail (5_000, 5_000), 2nd fail (10_000, 10_000), ...\nIs this helpful?. Hi,\nJobs are rescheduled for all platforms, you can find the code here: https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobManager.java#L482\nThat should also work for the GcmNetworkManager. . Yes, Android clears alarms e.g. when you force close the app. You can call JobManager.create() only once and you should do this in your Application.onCreate(). Every extra call is ignored. I'm not sure how the AddReceiver plays a role.\nSo I don't quite understand what you're suggesting. It would probably help to listen for the update broadcast from the GcmNetworkManager, though. . No, ACTION_PACKAGE_REPLACED doesn't work, but ACTION_MY_PACKAGE_REPLACED does work well. Good hint @AlexFrost. \nAlthough this makes the GCM callback useless, I've added it nonetheless (see last two commits). I keep the ticket open until I've published a new version. In the meantime you can give the latest snapshot build a try:\ngroovy\ncompile 'com.evernote:android-job:1.1.6-SNAPSHOT'\n. That's probably correct. So I'll keep both and we should be fine. . Version 1.1.6 released.. Hi,\nThis has been discussed #128 and #135 already. So a short answer: No, the alarm isn't scheduled anymore, but it'll be rescheduled as soon as possible. \nNo, there isn't such a thing as START_STICKY, that wouldn't work well with the idea of jobs. But jobs create wake lock before they run, so you shouldn't run into the issue, that your process is being killed. In case the app is being force closed while a job is running, it is still scheduled and will be rescheduled the next time the app is being launched (see first question).\nI hope that helps. . Wow, this sounds horrible. But sounds like there is still nothing we could do?! :( . I think there's nothing more we could do. I've updated FAQ with this question.. Hi,\nTake a look at this sample: https://github.com/evernote/android-job/blob/master/FAQ.md#how-can-i-run-async-operations-in-a-job\nYou can store the result in a AtomicReference. . It still depends. Your job will run during the execution window and the system tries to find a time where all requirements are met. However, the execution window has a higher priority than the other requirements. \nSo once the end of the execution window is reached, your job will run no matter what the other requirements are. To avoid any extra check you can use setRequirementsEnforced(true). This will make sure that all requirements are met and if not, then it'll automatically reschedule your job instead of invoking your code.. I can't tell. The system controls when to run the job. Other users reported a similar issue. We don't use periodic jobs at all and rely on one-time jobs and reschedule them manually. That works well for us as it is much more flexible. . See #128, #135 and #136 for answers to your first question. \nHowever, jobs should be rescheduled after the device rebooted. How do you schedule jobs? Can you attach a log after the device booted? . The library comes with a broadcast receiver listing for the boot completed intent. It shouldn't be necessary to add another one.\nI've added your question in the FAQ with an explanation to what you're seeing: https://github.com/evernote/android-job/blob/master/FAQ.md#why-arent-my-periodic-jobs-running-as-expected-on-android-5-or-higher. Closing, I've updated the FAQ. Please continue the discussion in #136 . https://github.com/evernote/android-job/wiki/FAQ#why-arent-my-periodic-jobs-running-as-expected-on-android-5-or-higher. No, version 1.1.3 used the same version 9.8.0. That code wasn't changed between those two versions. Your app shouldn't crash in this case, but I'm wondering what the real exception is. Because this line shouldn't throw any exception:\njava\npackageManager.setComponentEnabledSetting(component, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);. It shouldn't be related to the support library, but what you can try is \ngroovy\n    compile('com.evernote:android-job:1.1.5') {\n        exclude group: 'com.android.support'\n    }\nThen it should work with the older support library. Note that always the highest version of an library is being used. Let's say this job library requires support library 25, but you include 24 in your build script, then version 25 is used in the end. gradle dependencies should help you to find out which dependencies are being used. . The library should still work, this is more of a warning. Are the Google Play Services installed on this device?. Are you sure that the job is not scheduled? Because that whole logic is in a big try-catch block. Can you attach a full log with the error message?\n```java\n    public static boolean isGcmApiSupported(Context context) {\n        try {\n            if (!checkedServiceEnabled) {\n                checkedServiceEnabled = true;\n                setServiceEnabled(context, GCM_IN_CLASSPATH);\n            }\n        return GCM_IN_CLASSPATH\n                && GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context) == ConnectionResult.SUCCESS\n                && isGcmServiceRegistered(context) == ConnectionResult.SUCCESS;\n    } catch (Throwable t) {\n        // seeing sometimes a DeadObjectException, return false, we can't do anything in this case\n        // still sometimes seeing a NoClassDefFoundError here\n        Cat.w(t);\n        return false;\n    }\n}\n\n``. No, I didn't mean the stacktrace. I meant a longer log. I want to know if the library prints something after that in the log.. As far as I can tell jobs are scheduled nonetheless. The stacktrace begins withW/`, what means this is a warning and not a crash. I'm also not able to reproduce what you're describing. I'm sorry, but I can't do anything. . Hi, good questions.\nRetries\nThere is currently no way to stop a job automatically after a curtain amount of retries. But this can be easily achieved in your job itself (what is more flexible).\n```java\n    @Override\n    @NonNull\n    protected Result onRunJob(final Params params) {\n        boolean success = doSomething();\n    if (!success && params.getFailureCount() >= 3) {\n        Log.d(TAG, \"too many failures, aborting\");\n        return Result.FAILURE;\n    }\n\n    return success ? Result.SUCCESS : Result.RESCHEDULE;\n}\n\n```\nConnectivity Change\nYes, simply schedule a job with a required network type. On Android Lollipop and above the JobScheduler will be used. The system tries to find a good time to run your job, e.g. is the job in the execution window, are the requirements met, etc. Those features are kinda back-ported to older Android versions where the JobScheduler is not available.\njava\n    public static void scheduleNetworkJob() {\n        new JobRequest.Builder(TAG)\n                .setExecutionWindow(TimeUnit.MINUTES.toMillis(1), TimeUnit.DAYS.toMillis(1))\n                .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED)\n                .build()\n                .schedule();\n    }\nRepeated period scheduling\nNo, you shouldn't reschedule the job, but instead schedule a new one. If you reschedule the old one, then the back-off criteria shifts the execution window. That's not what you want, if your job should run only once a day during a specific time. \nAlso note that onReschedule(int newJobId) tells you the new job ID. You can't control the rescheduling behavior from this method. You also don't need this method, if you schedule a new job. \nI hope that helps.. Can the ticket be closed?. ? :) . Closing because of inactivity. That won't work on Android N / O this way anymore. Instead you should schedule a job with a specific network connection as requirement. Then the system will start your job when the requirements are met. . No, there isn't such an option at the moment. But I see that this could be useful for rescheduled or periodic jobs. . This feature will available in the next version. You can give it a try with the latest snapshot build. Feedback is appreciated. \n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.10-SNAPSHOT'\n}\n. No, that should work out of the box. I tried it an emulator and there everything works for me. You could try a few things. First look for the following in the log after the reboot\n02-15 07:23:04.410 2311-2326/com.evernote.android.job.demo.gcm D/JobManager: Reschedule 0 jobs of 1 jobs\n```\nThis line should also occur when the application (the application process) starts.\nA couple of questions.\n1. Where do you create the JobManager?\n2. Is your job included if you call JobManager.instance().getAllJobRequests()?\n3. Can you make sure that you're requesting the boot completed permission? \nxml\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\nYou can also call JobUtil.hasBootPermission(context). I know that some devices don't grant this permission even if you requested in the manifest (especially Samsung does that). . That log statement explains it. That was really helpful. The library adds a pause of a few seconds before it reschedules jobs. For this pause it acquires a wakelock. The system kills the process although the wakelock was acquired.\nYou find a detailed explanation here.\nLike I said I cannot reproduce the issue with my devices. So I'd appreciate if you could help me. I have a fix ready and published a snapshot build. Could you give this build a try? \nYou need to add the snapshot repository to your build script and reference the new version:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.7-SNAPSHOT'\n}\n```\nNo more changes are required. \nThanks!\nEdit: Just to make sure, you can can guarantee that your app is not crashing, correct? I'm asking because that would also explain why the wakelock died. . Nice! Please keep using the snapshot build until I release the final build. Let me know if you detect something suspicious.\nThanks! . I just released the stable version 1.1.7. Thanks again for your help!. That's true and that's actually by design. How should the library inject the context, if the job wasn't created yet?\nImagine this sample\n```java\npublic class MyClass {\n    private final String mText;\npublic MyClass() {\n    getText().length();\n    mText = \"\";\n}\n\npublic String getText() {\n    return mText;\n}\n\n}\n``\nAlthoughmTextcan't be null, this throws a NullPointerException. If you need aContextin the constructor, then you should pass it in as parameter.. Closing because of inactivity. Are you sure that you want to get all jobs? That returns only jobs which are currently running or just finished. WhereasJobManager.instance().getAllJobRequestsForTag(\"TAG\")` returns all pending jobs. . I did and it works for me. Note that once your process died the jobs are cleared as there's no point to reload already finished jobs. Please attach logs that show when your job ran and when you're querying the jobs. Also make sure that your job doesn't crash or that the process died in between.. Any update?. Closing because of inactivity. Is this a periodic job? Otherwise a job can only run once. But maybe your job is crashing, then it tries to run the job again. Not sure what else could be the problem. Are you using multiple processes in your app? . And you're sure that the job isn't crashing or gets stuck in a loop? I guess you can't attach a log either? . And how do you know that the same job runs twice? Are you really sure that the 2nd job has the same ID? It could be also an issue with job scheduling code that the same job is scheduled twice (or is scheduled while the current job is running). \nLast question: Is this an exact job? That's important for the used API. \nDon't get me wrong, I believe you that there could be an issue in the library. But without logs it's a shot in the dark. It's weird that you job seems to finish successfully, but then the job runs again, because right after the job finished it removes all parameters from the database. If the job later can't be loaded, then it won't run again. . I think you mean this bug and this is avoided in the library. But your case isn't a race condition. Yes, your answer was helpful. \nIt would be great if you could confirm that the same ID is being used. The job rescheduling is independent of the platform implementation. My guess is that the job can't be deleted from the database and then is still around for some reason. That would also explain why the job is rescheduled after rebooting the device, because jobs are rescheduled after booting the device if they're in the database but not scheduled by the device anymore. You could confirm this with the logs :)\njava\n    public synchronized void remove(JobRequest request) {\n        mCacheId.remove(request.getJobId());\n        try {\n            getDatabase().delete(JOB_TABLE_NAME, COLUMN_ID + \"=?\", new String[]{String.valueOf(request.getJobId())});\n        } catch (Exception e) {\n            CAT.e(e, \"could not delete %s\", request);\n        }\n    }\nBut other than that I don't have any idea.. I'm sorry about the delay. 1.1.7 only has this one change, which fixes the other issue where you probably found it, and it shouldn't affect your problem.\nsetPersisted(..) is kinda broken at the moment. Like you said, jobs are rescheduled after the boot, although you set it to false. I don't know when I'll release 1.1.7, probably in a week. But you can safely use the snapshot build for the moment. . Well, I think I'll deprecate the method without changing its behavior. I'll explain in the JavaDoc why that's the case once I've decided to do this.\nThanks for trying!. Broken in which way? The Play Services are only used on Android 4.X, on 5.0 or above the JobScheduler is always used. The Alcatel phone should have used the JobScheduler. . That is really strange. You can add a break point in the constructor of the JobManager class. There are jobs being rescheduled. . I just released version 1.1.7. This commit is the only difference: 98d91332fd6ce2b2d3933ed8c2d7914a1bc3b773 I'm not sure how should affect what you both are describing. . Hi, could you find out more about the issue? . Android 5+ is always using the JobScheduler if the job is not exact (what's the case in your snippet above). If the job is exact, then the AlarmManager is used. \nThe GcmNetworkManager is only used on Android 4.X, if the Play Services are installed, otherwise the AlarmManager is used in all scenarios. . No, my only idea is that deleting the job from the database fails or that the job crashes on this device for some reason. . They don't affect this issue and I don't get why they should be the cause now. You said that this only happens on one specific device and that it happened with the JobScheduler before as well. Why do the Play Service now play a role? . It would be great if you could get logs. Otherwise I don't know how I should help you. Try verifying that the same job (with the same job ID, not tag) runs twice. . I'm closing the issue for now. Feel free to reopen when you've received logs. . Interesting, in 7.1 it's fixed: http://androidxref.com/7.1.1_r6/xref/frameworks/base/services/core/java/com/android/server/job/JobStore.java#265\nHowever, this issue shouldn't affect the library in the way you described it. It's not possible to have transient jobs because of the platform bug, meaning that setPersisted() is always true. But a job will only run once nonetheless. Like I said, the library maintains its own job database and after a job finished it's being removed from the database. If a job can't be found in the database, then it won't run. You find that code here https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobProxy.java#L147. The JobScheduler is more like a way to notify the library to run the job. \na) The library's jobs aren't stored in /data/system/job/jobs.xml. The app may get started because of the bug, but the library won't run the job and silently stop, see https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java#L62 and https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobProxy.java#L147\nb) Doesn't matter, see a). \n. Maybe https://github.com/evernote/android-job/commit/fd3bca9ba711f67f95fb3516207c245a8e4046d5. That'a good find. My guess is that the job isn't deleted from the library's database. Something could be odd with the SD card storage. . Is the storage full? That could cause write failures.. No, this bug doesn't affect the library, because it never sets needsToReschedule to true.\nhttps://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/v21/PlatformJobService.java#L75. Feel free to add a full log. I've done what I can.. Hi, have you seen the FAQ? https://github.com/evernote/android-job/blob/master/FAQ.md#how-can-i-run-a-job-at-a-specific-time-once-a-day\nI think this snippet should help you.. You're scheduling the job 17225 days in the future. I doubt that you want to wait that long :) Notice that the start and end time is an offset from the current time. E.g. your start time should be \njava\nlong startMs = System.currentTimemillis() - calendar.getTimeInMillis();. Can you explain what is out of date? . The output tells me, that you've scheduled the job in 5 hours. That looks good to me. I'm sorry, but what you're asking is unrelated to the library itself and should be asked elsewhere, e.g. at Stackoverflow.. Oh, good catch. That's mentioned at the front page: https://github.com/evernote/android-job#advanced You can pass in a bundle.. Hi, no that's not possible at moment. I'd recommend starting the service with the different process from the job. That would be the easiest solution I see. . Ah, that's bad. Thanks for reporting. . I've uploaded a new snapshot build with a fix. I'd appreciate if you could give it a try\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.8-SNAPSHOT'\n}\n```. No clue as the system controls that. Is your UI waiting until the job runs? It really can be anything\n not matching requirements (charging and network state)\n you cancel the job somewhere\n device rebooted \n system delays the job for some reason\n* your job creator isn't registered properly \nWhat should I do without a log? . Yes, it should. But your job also has other requirements. Can you reproduce the behavior?. Maybe start with getting some logs from the user? . Integrate JobIntentService once it's released https://www.youtube.com/watch?v=hbLAzwhBjFE&list=PLWz5rJ2EKKc-odHd6XEaf7ykfsosYyCKp&index=8&t=8m54s. We use the new version already in production: https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O The final release is around the corner. . Version 1.2.0 has been released.. Yes, that's a duplicate. Yep, makes sense. @Ernest-su You misunderstood something. Google chose a bad name, the GcmNetworkManager has not so much to do with networking. Jobs are stored on the device and not a server.. Hi, on which Android version is this happening? How do do you schedule your job? Can you share that part of the code?. Could be, also could have other reasons. A log after the boot from the Samsung device would be helpful.. Closing because of inactivity. Yes! Actually, Android O will make it even more important to use the JobScheduler and you're prepared for that when you use the library. \nIn the end the changes in O are a good thing.. My assumption is that the same argument as android.intent.action.BOOT_COMPLETED applies. Hopefully they will publish a more complete list. It might be a good idea to create an issue on their tracker to ask about this. . Thanks. I'm closing this issue as I can't do anything right now. In the worst case it's an implicit intent and we don't receive the broadcast anymore. Even then there's nothing I could do. . Yes, you can call JobManager.instance().getAllJobRequests() to get all scheduled requests. A JobRequest has many getter methods.\nWhereas JobManager.instance().getAllJobs() returns all running or finished jobs, which are still cached. . Thanks a lot for the pull request. Unfortunately, it has some problems which aren't your fault. If I could change my decision again, then I wouldn't use the Cat library today. Although it's convenient to use, it doesn't work well with Proguard.\nIf I receive bug reports, then I need to know from where the log statement are coming from. That's why it's necessary to have a concrete logging tag instead of relying on the Cat class. Some users repackage their classes and move all of them into the default package, meaning that no class has a package. That makes the global Cat class completely useless. \nHowever, your pull request showed me all the flaws when it comes to logging in the library. I've addressed those issues in my own pull request #163. I'd appreciate if you could give it a try and reply in the pull request whether this works for you or not.\nI'm really sorry to decline your pull request. Thanks for the work!. The bundled proguard consumer file only contains to minimal required rules. There is no reason to not allow repackaging if someone wants to do that. \nYes, I agree that it's the reporter's responsibility. But I often see myself even bagging for an obfuscated log :) . Can be tested with\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.9-SNAPSHOT'\n}\n```. I had the same issue in our app. I solved it by disabling that our internal logger prints all log statements for this library. \nBut now that you mention it as well, I think it's better to give an option to disable it. That makes easier.. Could you give it another try? Run ./gradlew --refresh-dependencies in a terminal. Then you should see the new library with the changes.. Thanks for getting back to me!. Thanks for reporting. It'll be fixed in then next version. You can give it a try if you want:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.9-SNAPSHOT'\n}\n```. We don't have a fixed release cycle. There's nothing wrong with the latest snapshot. But probably after #173 is merged I'll publish a stable release.. Fixed in version 1.1.9\nhttps://github.com/evernote/android-job/releases/tag/v1.1.9. Thanks for reporting. It'll be fixed in then next version. You can give it a try if you want:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.9-SNAPSHOT'\n}\n```. I pushed a new snapshot with all the changes. It would be great if you could give it a try \ud83d\udc4d . Nice, thank you. . Fixed in version 1.1.9\nhttps://github.com/evernote/android-job/releases/tag/v1.1.9. This method is better, but doesn't solve the actual issue. Problem is that you should check for the best network state first. . Ah, didn't you see that I was about to merge your PR? :) . Not at the moment. I noticed that the API was hidden for job requests, but for job it's already available. You can give the snapshot build a try, there it's working\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.9-SNAPSHOT'\n}\n```\nSample:\n```java\npublic class DemoSyncJob extends Job {\n@Override\n@NonNull\nprotected Result onRunJob(final Params params) {\n    int failureCount = params.getFailureCount(); // that's working already\n    return Result.FAILURE;\n}\n\n}\n// soon\nSet requests = JobManager.instance().getAllJobRequests();\nfor (JobRequest request : requests) {\n    int failureCount = request.getFailureCount(); // this will work in 1.1.9\n}\n``. Thanks for reporting. But there's already an existing issue, see #164 . Sorry, but that shouldn't be part of the library. You can easily implement this yourself.. Where is this considered bad practice? I consider weak type declarations as bad practice and prefer strong types with a better type safety. TheIntDef` declaration is only a lint warning.\nThe library has 4 enums with a total of 14 instances. 3 enum declarations could be replaced with ints, the other enum would require objects nonetheless. So I could potentially save 3 enums with a total of 9 instances. I've read that one instance requires about 20 bytes and the enum array 16 bytes, so I could save about 228 bytes (I guess the classes itself aren't included, please correct me here). \nIf I would change the enums to integers, I could save about 200-300 bytes. The downside is that every app out there would need to update their code. Then it's also necessary to check the parameters everywhere: Is this a valid integer or not?! \nI don't see the benefit here and the enums-matter debate is total fail in my opinion. I recommend reading the comments in this post. Especially Matthias K\u00e4ppler's response nails it. . If you follow the sample, then it should work. It's possible that devices adjust the execution window in order to save battery. Unfortunately, there isn't anything I could do.\nYou can start a job manually if the job schedule is used (Android 5+), see here.\nCan you show your onRunJob() method? If you follow my sample, then you shouldn't return RESCHEDULE. That explains why you see that your job runs at 8 PM.. You also should make your sync a blocking call, see https://github.com/evernote/android-job/blob/master/FAQ.md#how-can-i-run-async-operations-in-a-job. I don't like the design of the JobScheduler. The problem is that you need to launch a background thread on your own and manage its state. You end up with many callbacks, because you need to post the result to the service again.\nThe library is doing all of this for you. However, if you run an async operation then the worker thread of the library finishes and doesn't know that there's still an operation going on. \nCould be a problem, because when the library thinks it's done, then the service is killed and your app is more likely stopped by the system.. @mario Any update?. The log looks good to me. No job did run twice, but instead it seems like you've scheduled the same job multiple times.\n04-09 23:04:55.656 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: *job.delay* creator uid is: 1000\n04-09 23:04:59.440 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: *job.delay* creator uid is: 1000\n04-09 23:05:24.171 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: *job.delay* creator uid is: 1000\n04-09 23:05:24.222 9293-10462/? I/JobExecutor: Executing request{id=1, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.237 9293-10463/? I/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.296 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: *job.delay* creator uid is: 1000\n04-09 23:05:24.472 9293-10462/? I/JobExecutor: Executing request{id=4, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.476 9293-10464/? I/JobExecutor: Executing request{id=3, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.481 9293-10465/? I/JobExecutor: Executing request{id=2, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.483 9293-10463/? I/JobExecutor: Finished job{id=4, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.487 9293-10467/? I/JobExecutor: Executing request{id=5, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.488 9293-10466/? I/JobExecutor: Finished job{id=3, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.491 9293-10468/? I/JobExecutor: Finished job{id=2, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.495 9293-10463/? I/JobExecutor: Finished job{id=5, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:11:05.327 1223-1308/? W/JobInfo: Specified flex for 108438 is +57m36s0ms. Clamped to +1h12m0s0ms. I can't tell without a full log.. Hey there,\nThis method will be added in the next version. I'm waiting for some feedback in #173, after that I'll push a new release. But I'd recommend that you use this new version already now as it contains some bug fixes.\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.9-SNAPSHOT'\n}\n. I'm sorry about the confusion. It's licensed under Apache 2.0. Why is this a problem for you?. Thanks for sharing. Can you tell me which version you were using? Is this happening right after you call `.schedule()` or some time later?. Sorry, another question. Is it possible, that you are using multiple app processes? I'm asking because I don't get into the state where the library is crashing. . Awesome, thanks for the sample. I'll take a look at it next week. I can reproduce both issues.. Okay, I had some time left. Could give the snapshot build a try and see if that fixes the issue for you? I'd appreciate the help.groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.10-SNAPSHOT'\n}\n```. Can you reproduce it?. @PaulWoitaschek Can you post a full stack trace as well?. Yes, sure. . I think I found the reason, see the test in #33d64c8 \nIt would be great, if you could give it a try:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.11-SNAPSHOT'\n}\n. @eggcaker Could you give the snapshot build a try?. Thanks, I appreciate it!. Great. I'll probably publish a stable release at the end of this week. But I don't expect any changes compared to the last snapshot build anymore.. We're testing the latest snapshot build in our latest release at the moment (staged rollout). Once we're confident that the bug is fixed, I'll push a new stable release. But there's nothing preventing you to use the snapshot build as well.. Thanks, but unfortunately you're either shrinking your code or you were using and old build (that's the downside of snapshot builds, sorry). From the stacktrace\ncom.evernote.android.job.JobStorage.store(JobStorage.java:243)\n``\nBut this line is a comment in the most recent version: https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobStorage.java#L243. We haven't seen this issue anymore. But I won't publish the stable version until we're sure that it's fixed. Before you publish a new version, please run>./gradlew --refresh-dependencies` to make sure that you're using the latest snapshot build. \nI appreciate your help!. @mtrakal I'd appreciate if you could give the snapshot build a try!. That's great to hear. I guess then next week will be a good time for a stable release.. Done https://github.com/evernote/android-job/releases/tag/v1.1.11. No, that's the intended behavior. If the device is in a doze window and you then turn on the screen, then all jobs will run. Please take a look again at how Doze works: https://developer.android.com/training/monitoring-device-state/doze-standby.html\nThese slides from my recent talk also could be helpful, especially the page I'm linking: https://speakerdeck.com/vrallev/scheduling-background-job-on-android-at-the-right-time-1. A simple synchronized was missing. If you want to give it a try:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.10-SNAPSHOT'\n}\n. Can you provide a sample to reproduce the issue? I haven't seen this before. Is it possible that you moved the database file somewhere or deleted it? . Yes, what @jess-anders said. You should close all file streams. I'm closing this issue, it's not a problem of the library.. Can you explain this a little better? I don't understand what you mean with queue. When the job runs, then you immediately receive the callback in the job.. I'm sorry, but I don't intend to extend the API. You can achieve the same, if you set requirements enforced to false. Then you'll receive a callback and can manually check if the requirements are met. That has the same effect.java\nnew JobRequest.Builder(\"Tag\")\n        .setExecutionWindow(3_000, 4_000)\n        .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n        .setRequirementsEnforced(false) // that's the default\n        .build()\n        .schedule();\n// and in your job\nboolean requirementMet = isRequirementNetworkTypeMet();\n``. No, that's not true. The requirements enforced flag is mainly helpful for theAlarmManager` API, which does not support any requirements and they were back-ported. However, the other APIs respect the requirements, even if they're not enforced. . Closing because of inactivity. . I don't see why this is necessary. It sounds more like an IDE issue to me. . I'm sorry, but there is no reason to force a specific version. If another dependency needs a newer version, then this could cause conflicts. The library doesn't rely that much on the support lib.. Are you sure that you're using version 1.1.8? Because this code only exists since 1.1.9. SQLiteDatabase implements Closeable on all Android versions. This seems to be a different problem. \nI also wan't able to reproduce the crash. How do you include the library?. Ah, I only looked at the documentation there is says SQLiteClosable implements Closable. Thanks!. This will be fixed in the next version, you can give it a try if you want:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.10-SNAPSHOT'\n}\n. https://github.com/evernote/android-job/blob/master/FAQ.md#why-cant-an-interval-be-smaller-than-15-minutes-for-periodic-jobs. https://github.com/evernote/android-job/wiki/FAQ#why-cant-an-interval-be-smaller-than-15-minutes-for-periodic-jobs. That looks bad, but I'm not really sure what I should do. This must be a modded device or LG patched the database handler. Because if you look at\nandroid.database.DefaultDatabaseErrorHandler.repairDatabaseFile(DefaultDatabaseErrorHandler.java:140)\nat android.database.DefaultDatabaseErrorHandler.onCorruption(DefaultDatabaseErrorHandler.java:68)\n```\nthen you'll notice that this class only has 108 lines and the method does not exist: http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4.2_r1/android/database/DefaultDatabaseErrorHandler.java?av=f\nMaybe it's better to copy the default error handler and not use the device specific one. Any suggestions?. This will be fixed in the next version, you can give it a try if you want:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.10-SNAPSHOT'\n}\n```. Any means that there isn't any requirement. Your job is allowed to run while the device is offline or in any other network state. . Yes, this wording is better. . Cool thanks!. Thanks!. Just to be sure: you didn't just change the code, but you've also updated the scheduled job, right? Please attach some logs, otherwise I can't help you. . Closing because of inactivity. Please feel free to reply nonetheless. . As far as I understand the code, it creates a job once and then caches it in a Map. But that's wrong. Like the crash says, you need to create a new Job and don't cache it.\nStackoverflow might be a better place for such questions.. Thanks for the PR. Do you have a full stack trace for me? I'm a little afraid to merge this, because that doesn't seem to be the true fix. The result would be that your job doesn't run and the database doesn't get cleaned up properly. \nA better approach would be to fallback to another API if that happens. I can do that, but a full stacktrace would help a lot!. I fixed the issue in 014d6630f29b986bef276d86e19d5bae9b724751. It's better to fallback to a different API than not running jobs at all. Thanks for bringing up the issue!\nYou can give it a try in the latest snapshot build:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.11-SNAPSHOT'\n}\n``\n. Can you show the code of yourJobCreator? There you need to create a newJobinstance and not cache the jobs. . I agree that the documentation is a little bit unclear about that. The result doesn't matter for a periodic job. The only advantage of returningFAILUREcompared toSUCCESS` is better logging and the failure count is being incremented. The failure count might be helpful in your logic.\nYou can check the failure count in the JobRequest or Params object.. Updated documentation will be in the next version.\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.11-SNAPSHOT'\n}\n``. @hamberluo The library will throw an exception when you callJobManager.create()` and all services are disabled. You can give it a try if you want:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.11-SNAPSHOT'\n}\n```. Yeah, that's bad. The limitation of 100 jobs is expected, but the app shouldn't end in a crash loop. I've fixed this in the next version. You can test the snapshot build, if you want:\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.11-SNAPSHOT'\n}\n``. No, you don't need to check the deleted jobs. But if you have more than 4000 rows in the database, then you are doing something wrong. Not sure what I should do or how I should help.. Please create a separate issue for your case and please attach a sample to reproduce the issue. This bug was meant for version1.1.11`, which has been already released.. That's a system limitation with a purpose.. I can't give any recommendations as it depends on your architecture. Stackoverflow or a similar platform is better suited for such types of questions. . Cool, thanks!. Yes, this one is new, see here: https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobManager.java#L184\nThis exception is thrown when all APIs are disabled, e.g. when the services in the manifest are disabled. This usually happens only with rooted or modded devices. In this case the library can't work and you would schedule jobs and wonder why none of those jobs are running. \nAt the moment I don't have a better solution than to notify you about this issue as early as possible. Do you have any recommendation or better way to deal with this?\n. Yes, this was my intention how to handle it. . Xposed? I have no idea, honestly. Any idea what I should do instead?. No, it means that no API is supported for some reason. That's the way we setup the JobManager to prevent the crash.\n```java\n  private void setupJobManager() {\n    JobCat.addLogPrinter(new EvernoteJobCreator.JobLibraryLogger());\n    JobApi.setForceAllowApi14(true);\nJobManager jobManager = JobManager.create(this);\njobManager.getConfig().setGcmApiEnabled(false); // is only important for Android 4.X\njobManager.addJobCreator(new EvernoteJobCreator());\n\n}\nNote that `setForceAllowApi14` is deprecated and will be moved to a different place in version `1.2.0`.. `JobConfig`. There you can enable/disable APIs. . That's correct. It depends on you. We disable the GCM API, because we only want to use the platform version.. `JobConfig.setApiEnabled(JobApi.GCM, false);`. This is how we setup the library. We don't use a try-catch block.java\n    JobConfig.addLogger(new EvernoteJobCreator.JobLibraryLogger());\n    JobConfig.setForceAllowApi14(true);\n    JobConfig.setApiEnabled(JobApi.GCM, false); // is only important for Android 4.X\nJobManager.create(this).addJobCreator(new EvernoteJobCreator());\n\n. I don't think this is a problem of the library. Are you using Proguard or do you have multidex enabled? If it's a problem of the library, can you provide a sample to reproduce the crash?. Please also test with an emulator (if you haven't done already). I don't see a reason why the class shouldn't be found. So I'd also appreciate a hello world sample, that reproduces the bug.. I found the reason. It's not your fault, one dependency in the pom is missing. You should add the support library to your dependencies:\ncompile 'com.android.support:support-v4:25.2.0' // or newer\n. You've scheduled 3 different jobs with the same tag and Android is batching their execution. You probably only want to schedule this job once and not three times. . This can be tested withgroovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.1.11-SNAPSHOT'\n}\n``. I don't quite understand what you're trying to do. You can always cancel a job withJobManager.instance().cancel(jobId)` and after that schedule a new job.. It's not possible to update a job. It's also not expensive to cancel a job and to schedule a new one. \nIn your case I would schedule one job once there are changes in your app and cancel it when you sync them manually and the job didn't run, yet.. This could be nice addition, but right now I don't have any plans to support it. It'll require a lot of work. . I don't have a solution for backward compatibility. E.g. this method is required to start a job after a user took photos with the stock camera app. For Android 23+ you need to use the method from the JobScheduler, but for older devices you have to implement a BroadcastReceiver. It wouldn't make sense to add this receiver in the library.. Closing because there doesn't seem to be a good solution for backward compatibility.. This can be explained by the JobScheduler. It takes some time until it actually starts the job. . Yes, don't use this library :) You should use a Handler or Thread instead. The Android docs are also recommending this: https://developer.android.com/reference/android/app/AlarmManager.html\n\nNote: The Alarm Manager is intended for cases where you want to have your application code run at a specific time, even if your application is not currently running. For normal timing operations (ticks, timeouts, etc) it is easier and much more efficient to use Handler.. This is great, thanks!. Did you maybe grab the test results to see which check failed? \n\nI realized that the test wasn't doing what it was intended to do. I fixed that in 1277b41cf1d90074c3c68af97b2182dc3f5e5393. My assumption is that the threads didn't start fast enough and the timeout on the latch occurred too early. . Sounds good.. Can you please try the latest version? I made some changes and getMaxJobId() shouldn't fail anymore. . Closing because of inactivity.. Thanks, that's fixed in the latest release!. Are you caching jobs? The JobCreator should always return a new instance. BTW, you can switch to 1.1.11 now. . Yes, don't do that, like the crash says. . I close this issue for now. BTW, to get a job simply call JobManager.instance().getJob(id).. That's not possible at the moment. But it will be supported in the next version https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O#start-jobs-immediately\nRight now you need to use an exact job and a really small time. But I'd recommend simply using a background thread. . You should take a look at the FAQ: https://github.com/evernote/android-job/blob/master/FAQ.md#how-can-i-run-a-job-at-a-specific-time-once-a-day\nIf you still need help, Stackoverflow or similar websites are better suited for such questions.. Stackoverflow is a better place for such questions.. A periodic job can't be exact. A job is either exact or periodic. Periodic jobs are always inexact. That's simply the way how Android optimizes for longer battery life.. Yes. I really don't want to answer that here. That's an issue tracker where people can report defects in the library. I suggest that you take a look at this sample and if that doesn't help, then ask this question at an appropriate place like Stackoverflow.. That's the new link https://github.com/evernote/android-job/wiki/FAQ#how-can-i-run-a-job-at-a-specific-time-once-a-day. I mean there's not way in Java to kill a Thread and stop it from executing. But once the job is canceled, you can call isCanceled() is stop your work, e.g.\n```java\n    @Override\n    @NonNull\n    protected Result onRunJob(final Params params) {\n        for (int i = 0; i < 20; i++) {\n            if (isCanceled()) {\n                return Result.RESCHEDULE;\n            }\n        doSomething(i);\n    }\n\n    return Result.SUCCESS;\n}\n\n``. Success means the executing job won't be rescheduled. But you can easily try this yourself or ask such questions at a better place like Stackoverflow.. That's nothing bad. It can happen that a job isn't scheduled anymore, because the app was forced closed or the device rebooted. In this case theJobRescheduleServicereschedules the jobs if necessary. Exact jobs use theAlarmManagerunder the hood. TheAlarmManagerdoesn't provide an API to check if an alarm is still scheduled. So exact jobs might get rescheduled more frequently than your periodic job, which use theJobScheduler`. \nI'll add this info to the FAQ.. That's described here.. You are only declaring play-services-location, but for the GcmNetworkManager you need play-services-gcm as well. \nIt's only a warning in the log. Android 4.X devices use the AlarmManager instead, if the GcmNetworkManager is not available. We actually do the same. . The library can be used only in process. You find a solution here.. You shouldn't schedule many jobs on the main thread. That sounds more like work which should be offloaded to a background thread/service.. Yes, \nkotlin\nJobManager.instance().allJobs.filterNot { it.isFinished }. If the job is not finished, then it's running. If the job doesn't exist for a request, then it's not running, yet. . Yes, take a look how I setup the context to make it work: https://github.com/evernote/android-job/blob/master/library/src/test/java/com/evernote/android/job/BaseJobManagerTest.java#L121. Maybe you can change the application class in your test and override the methods. . I meant that your Application class has something like \n```java\npublic void onCreate() {\n    createJobManager();\n}\npublic void createJobManager();\n```\nAnd then you can override this one method in the test code.\nCool, good to know. I only saw the hook in the Config class in Robolectric. . I don't consider this as an issue, so I'm closing it.. Add a stacktrace and a sample app for this issue.. No, that's not supported. Why did you go back to an older version of the library? I'm not sure if I even want to support that. . Not sure what you mean with \"parse error\". Can you explain that? All changes can be found here: https://github.com/evernote/android-job/releases. We're using version 1.1.11 in production a while now and don't have any problems. . This dialog isn't coming from this library. . We didn't have this issue before so I doubt that the library is the reason. I won't add a downgrade option. It also doesn't make much sense, because you would need to upgrade the library in order to get the downgrade feature. . Like I said, I can't upgrade the older builds and I also don't intent to do so. I also don't know how this should be possible. You want to revert to version 3, but back then I couldn't know how version 4 looks like. When I know the new database scheme, then I need publish a new version. It just doesn't make sense. \nBut at least it's open source. You can fork the project, checkout the old build and implement the downgrade yourself. That shouldn't be difficult.. Version 1.2.0 has been released.. Periodic jobs should work this way. Usually it waits one period until the job runs for the first time. . Sorry, but I don't have a better solution than to manually skip the first period. You can either use the shared preferences or you can also check when the job was scheduled. . You can do this on your own, but I wouldn't recommend it. That's against the whole purpose of this library to make background jobs as battery friendly as possible. . Closing because of inactivity.. No, the idea is to provide a job library which works the same on all platforms. . Why don't you do that before returning the result in onRunJob()? You're not missing anything, such a method doesn't exist. . ```java\n    @NonNull\n    @Override\n    protected Result onRunJob(Params params) {\n      Result result = Result.SUCCESS;\n  try {\n    // do something\n    result = Result.FAILURE;\n    return result;\n  } finally {\n    if (result == Result.SUCCESS) {\n      Context context = getContext();\n      // do something\n    }\n  }\n}\n\n```\nDoes this help? \nisFinished() always returns the result for the currently running job. There is no difference between periodic or one-off jobs. . Closing because of inactivity.. Can you show how you schedule the job? Are you using setExact()?. Dang, you're already using the method. What you're describing sounds a lot like the JobScheduler is being used. It delays work until the screen is bing turned on. But setExact() is using the AlarmManager in the end. Did you maybe switch from setExecutionWindow() to setExact() and didn't update the scheduled job?\nHonestly, there isn't much I can do now. I need a reproducible sample. Maybe a user can send you the database from the device for further inspection. . Yes, that's fine. The important flag is mExact. . That's here https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobRequest.java#L127\nAnd then https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobManager.java#L227. How often and how many jobs do you schedule? I'm asking because the system may not deliver the alarms: https://developer.android.com/reference/android/app/AlarmManager.html#setExactAndAllowWhileIdle(int, long, android.app.PendingIntent)\n\nThese alarms can significantly impact the power use of the device when idle (and thus cause significant battery blame to the app scheduling them), so they should be used with care. To reduce abuse, there are restrictions on how frequently these alarms will go off for a particular application. Under normal system operation, it will not dispatch these alarms more than about every minute (at which point every such pending alarm is dispatched); when in low-power idle modes this duration may be significantly longer, such as 15 minutes.. I'm closing this for now because of inactivity. Feel free to reopen.. You need to use setExecutionWindow(..) otherwise the job wouldn't work well on Android 4.X \n\nMaybe use a time window between 1 millisecond and 1 day, that should be close to what you're trying to achieve. . Closing because of inactivity.. Please attach a thread dump or a reproducible example. . This is not a thread dump. I can't tell from the log what's happening.. Do they maybe block background services? Not sure what I should do. . That's a background check.. The main thread isn't blocked by this library. It looks more like a problem with multidex in your case. I've also tested an 4.2 emulator and can't reproduce the ANR.. Maybe I'm missing something, but where in the log do you see that the library is blocking the main thread? \n```\n\"main\" prio=5 tid=1 VMWAIT\n  | group=\"main\" sCount=1 dsCount=0 obj=0x414729a0 self=0x4009a010\n  | sysTid=10263 nice=0 sched=0/0 cgrp=apps handle=1074836444\n  | state=S schedstat=( 6948164000 3266126000 1290 ) utm=680 stm=14 core=0\n  native: pc 0000000000017d80  /system/lib/libc.so (__wait4+8)\n  native: pc 000000000005aaf1  /system/lib/libdvm.so (dvmOptimizeDexFile(int, long, long, char const, unsigned int, unsigned int, bool)+548)\n  native: pc 000000000004e05b  /system/lib/libdvm.so (dvmJarFileOpen(char const, char const, JarFile, bool)+366)\n  native: pc 0000000000064be1  /system/lib/libdvm.so\n  native: pc 00000000000276a0  /system/lib/libdvm.so\n  native: pc 000000000002b5f4  /system/lib/libdvm.so (dvmInterpret(Thread, Method const, JValue)+184)\n  native: pc 000000000006009f  /system/lib/libdvm.so (dvmInvokeMethod(Object, Method const, ArrayObject, ArrayObject, ClassObject, bool)+374)\n  native: pc 0000000000067979  /system/lib/libdvm.so\n  native: pc 00000000000276a0  /system/lib/libdvm.so\n  native: pc 000000000002b5f4  /system/lib/libdvm.so (dvmInterpret(Thread, Method const, JValue)+184)\n  native: pc 000000000006009f  /system/lib/libdvm.so (dvmInvokeMethod(Object, Method const, ArrayObject, ArrayObject, ClassObject, bool)+374)\n  native: pc 0000000000067979  /system/lib/libdvm.so\n  native: pc 00000000000276a0  /system/lib/libdvm.so\n  native: pc 000000000002b5f4  /system/lib/libdvm.so (dvmInterpret(Thread, Method const, JValue)+184)\n  native: pc 000000000005fdc9  /system/lib/libdvm.so (dvmCallMethodV(Thread, Method const, Object, bool, JValue, std::__va_list)+272)\n  native: pc 0000000000049a73  /system/lib/libdvm.so\n  native: pc 0000000000047729  /system/lib/libandroid_runtime.so\n  native: pc 00000000000483eb  /system/lib/libandroid_runtime.so (android::AndroidRuntime::start(char const, char const)+390)\n  native: pc 0000000000000db7  /system/bin/app_process\n  native: pc 000000000001271f  /system/lib/libc.so (__libc_init+38)\n  native: pc 0000000000000ae8  /system/bin/app_process\n  at dalvik.system.DexFile.openDexFile (Native Method)\n  at dalvik.system.DexFile. (DexFile.java:109)\n  at dalvik.system.DexFile.loadDex (DexFile.java:149)\n  at dalvik.system.DexPathList.loadDexFile (DexPathList.java:261)\n  at dalvik.system.DexPathList.makeDexElements (DexPathList.java:229)\n  at java.lang.reflect.Method.invokeNative (Native Method)\n  at java.lang.reflect.Method.invoke (Method.java:511)\n  at android.support.multidex.MultiDex$a.a (SourceFile:462)\n  at android.support.multidex.MultiDex$a.b (SourceFile:447)\n  at android.support.multidex.MultiDex$a.a (SourceFile:434)\n  at android.support.multidex.MultiDex.installSecondaryDexes (SourceFile:244)\n  at android.support.multidex.MultiDex.install (SourceFile:161)\n  at android.support.multidex.MultiDexApplication.attachBaseContext (SourceFile:39)\n  at android.app.Application.attach (Application.java:147)\n  at android.app.Instrumentation.newApplication (Instrumentation.java:984)\n  at android.app.Instrumentation.newApplication (Instrumentation.java:968)\n  at android.app.LoadedApk.makeApplication (LoadedApk.java:499)\n  at android.app.ActivityThread.handleBindApplication (ActivityThread.java:4364)\n  at android.app.ActivityThread.access$1300 (ActivityThread.java:141)\n  at android.app.ActivityThread$H.handleMessage (ActivityThread.java:1294)\n  at android.os.Handler.dispatchMessage (Handler.java:99)\n  at android.os.Looper.loop (Looper.java:137)\n  at android.app.ActivityThread.main (ActivityThread.java:5039)\n  at java.lang.reflect.Method.invokeNative (Native Method)\n  at java.lang.reflect.Method.invoke (Method.java:511)\n  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:793)\n  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:560)\n  at dalvik.system.NativeStart.main (Native Method)\n``. That's a platform bug.. It looks like a bug in native code, so I'd say no. . I'm closing this for now because of inactivity. Feel free to reopen.. That's actually a bug with thesetPersisted(..)flag. Even though you set it to falls, the library tries to run your job. In version1.2.0this method will be removed: https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O#api-changes I treat this as a bug, because thesetPersisted()` method is confusing.\nYou should call jobManager.cancel(id) or jobManager.cancelAllForTag(yourTag) to cancel the job if you don't want to run it anymore. . What you're asking for are transient jobs in version 1.2.0. I'm currently working on a new alpha version, but there's no ETA. I don't see why \"force close\" plays such a big role.. https://developer.android.com/reference/android/app/job/JobInfo.Builder.html#setTransientExtras(android.os.Bundle) \nTransient jobs are cancelled when the job is canceled in the JobScheduler or the alarm is cleared in the AlarmManager. That happens when the device reboots or the app is force closed. \nBut most people don't want that behavior, because you need to manually reschedule things the next time your app starts. Usually when you schedule a job you want it to run no matter what. . The library is trying the best it can: https://github.com/evernote/android-job/blob/master/FAQ.md#what-happens-with-jobs-after-the-app-was-forced-killed. Version 1.2.0 has been released.. No, there isn't such a feature. Why don't you schedule type2 and type3 after type1 is finishing? Then you should also know the ID.. Closing because of inactivity.. Yes: https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobRequest.java#L87\nAnd the explanation here: https://github.com/evernote/android-job/blob/master/FAQ.md#why-cant-an-interval-be-smaller-than-15-minutes-for-periodic-jobs. No problem. That means the time window for the job will start in 10 hours and 15min and end in 10 hours and 20min. That's not the time of the day. What you want is covered in #223 and will be available with version 1.2.0. Since yesterday you can try that feature already, see https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O#add-helper-class-to-run-jobs-daily . I'm closing this issue for now.. That looks good. Also I don't see a problem with the log statement. My guess is that you called your code and scheduled your job at 10:20am. Thanks for the feedback.. The log prints the offset from now and not the time for daily jobs. Version 1.1.12 has been released.. I don't see a problem to make job creators singletons. You also only need to overwrite the equals() method of your job creator to make the check pass (what is kinda dirty, though).. Your approach with classes wouldn't work well. What should happen if you add two instances of the same type? What if CreatorA extends CreatorB and you remove CreatorB.class? What should happen if you remove Object.class? \nYou don't need a singleton. Store you instances somewhere in a field and later remove those. In the end they need to be stored somewhere.. That's a problem in your app. The last part is important\nCaused by: java.lang.IllegalStateException: Could not read resource entities-xhtml.properties. Make sure you copy resources for org.a.b.i\n                                                    at org.a.b.i.b(Unknown Source)\n                                                    at org.a.b.i.a(Unknown Source)\n                                                    at org.a.b.i$b.<init>(Unknown Source)\n                                                    at org.a.b.i$b.<clinit>(Unknown Source)\n                                                    at org.a.b.f$a.<init>(Unknown Source) \n                                                    at org.a.b.f.<init>(Unknown Source) \n                                                    at org.a.c.m.b(Unknown Source) \n                                                    at org.a.c.m.a(Unknown Source) \n                                                    at org.a.c.b.a(Unknown Source) \n                                                    at org.a.c.g.a(Unknown Source) \n                                                    at org.a.a.a(Unknown Source) \n                                                    at com.myapp.test.c.a(Unknown Source) \n                                                    at com.myapp.test.c.a(Unknown Source) \n                                                    at com.evernote.android.job.a.a(Unknown Source) \n                                                    at com.evernote.android.job.d$a.b(Unknown Source) \n                                                    at com.evernote.android.job.d$a.a(Unknown Source) \n                                                    at com.evernote.android.job.d$a.call(Unknown Source) \n                                                    at java.util.concurrent.FutureTask.run(FutureTask.java:237) \n                                                    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113) \n                                                    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588) \n                                                    at java.lang.Thread.run(Thread.java:818)\nYou can see that a job is started and then in com.myapp.test.c.a something is crashing. Please check your own code. . I don't have a strong opinion. At least this allows our QA team to test curtain jobs and scenarios. I'm not sure if it makes sense to change that. Are there any other side effects? . Good explanation, I agree!. I'm sorry for the long delay. I finally had time to take a look at this. \nIf I switch to ELAPSED_REALTIME_WAKEUP, then for some reason exact jobs aren't exact anymore, although I only changed the constant and adjusted the time offset. The code looks like this:\njava\n        long triggerAtMillis = Common.getAverageDelayMs(request); // is 10_000L in my test\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            alarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, pendingIntent);\n        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n            alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, pendingIntent);\n        } else {\n            alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtMillis, pendingIntent);\n        }\nThe log \n08-20 15:56:10.136 17233-17233/com.evernote.android.job.demo D/JobProxy14: Scheduled alarm, request{id=6, tag=job_demo_tag, transient=false}, delay 00:00:10, exact true, reschedule count 0\n08-20 15:56:15.196 17233-17416/com.evernote.android.job.demo D/PlatformAlarmServiceExact: Run job, request{id=6, tag=job_demo_tag, transient=false}, waited 00:00:05, delay 00:00:10\nI can't explain why it's not working properly. Now I'm strongly considering not to change the current implementation as I don't want to introduce any bugs or regressions.\n@misrakli Do you have an idea why that's the case?. @misrakli I've created the branch test/elapsed-realtime. I was using an API 26 emulator. I'm getting such logs:\n09-11 09:21:04.236 10931-10931/com.evernote.android.job.demo D/JobProxy14: Scheduled alarm, request{id=2, tag=job_demo_tag, transient=false}, delay 00:00:10, exact true, reschedule count 0\n09-11 09:21:09.245 10931-10997/com.evernote.android.job.demo D/PlatformAlarmServiceExact: Run job, request{id=2, tag=job_demo_tag, transient=false}, waited 00:00:05, delay 00:00:10. @misrakli You can test 1.2.0-RC3. . No, it's not necessary to create a separate issue. This log message should be fixed. I use it a lot to make sure that jobs are running as expected. . So I finally had time to take look. Yes, the log message is misleading if the system time has changed, but it's really tricky to change the timestamps like you both explained. We need to live with the wrong log messages, but this was already the case with the JobScheduler on newer versions. \nThis ticket is implemented. But I'll keep it open until the final version 1.2.0 has been released.. No I just meant that even in the old versions of the library the log message could be wrong if you change the time and the JobScheduler is being used. Now we have the same behavior with the AlarmManager, what actually is good, because now it's consistent.. Version 1.2.0 has been released.. I've tested it again and can't reproduce what you're describing. I've used an API 19 emulator and the necessary tests all pass with the first run. Could you please try again? Make sure that you're using the branch dev-1.2, then no test will crash (I just fixed that). . GCM has some caveats, e.g. there is a delay of 30 seconds before a job runs, what slows down tests a lot. That's why the test is disabled. \nThe crash you're seeing should be fixed. Did you pull the latest changes?\nI cannot reproduce what you're describing. My tests run even after restarting the emulator. . You can disable the GCM Api for tests. That should help you. . I'm closing this for now because of inactivity. Feel free to reopen.. I don't quite get what you're trying to achieve. The problem with approach 2 is wrong, though. The library executes jobs as long as you don't manually cancel them. If the job is already over the time, then it executes the job immediately. . I recommend to schedule a job for each entry, e.g. \"weekly clear trash\". In case the user turns off the device for 3 weeks, then I would assume to either see a notification that I missed the event 3 times or when the last event was. But that's not the purpose of this library, that's something you can easily do in your job. . A job needs to be rescheduled only under some circumstances, e.g. if the device rebooted. You shouldn't worry about that log statement. It's only helpful to debug issues. \nIf the job runs immediately, that means the system thinks it was a good time to run it. Then the job won't be rescheduled. Isn't your job running as expected?. How do you initialize startDelay? What's the actual value?. Yeah, hard to say. Try to isolate the problem and create a sample app if you think the problem is in the library. Otherwise I can't help. . Great catch and thanks for the sample. I was able to reproduce the bug. It'll be fixed in the next version.. No, the reason is that the time window is the most important requirement. I see why this could be helpful with the setRequirementsEnforced() feature and the backoff criteria, but it would make things really complicated. . I'm closing this for now because of inactivity. Feel free to reopen.. Are you using Proguard or any code stripping tool? Does this happen with the debug and release build? \nNo, the library doesn't require the Play Services, they're optional.. There's something else wrong. Do you disable transitive dependencies in Gradle? What happens if you add this dependency compile 'net.vrallev.android:cat:1.0.5'? Can you provide a sample?. Yes, you can ignore that.. Sorry, but there are many tutorials and the official documentation out there, which describe how to acquire a wakelock. . Yes, setUpdateCurrent(true) basically cancels the old job and schedules a new one (see documentation).. That's by design. There are ways to mock this class. I'm sorry, but this isn't an issue, but a question that should be posted elsewhere.. Why don't you try it yourself? Yes, your job will run. Note that version 1.2.0 will have a better API for that: https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O#start-jobs-immediately. I'm closing this for now because of inactivity. Feel free to reopen.. Thank you for the detailed explanation. However, I can't find the reason for this issue. Can you provide a sample with the bug?\nPlease also give version 1.2.0-alpha3 a try: https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O It contains some fixes, maybe the issue is gone with the newer version. We already use 1.2.0-alpha3 in production.. Thanks, I'll take a look next week!. I've tested your demo with an SDK 25 emulator and couldn't reproduce what you describe. That's my log:\n08-20 17:05:19.106 1698-1719/system_process I/ActivityManager: Displayed dev.cosmos.android_job_reschedule_issue/.MainActivity: +412ms\n08-20 17:05:28.855 4730-4730/dev.cosmos.android_job_reschedule_issue D/JobProxy14: Scheduled alarm, request{id=1, tag=tag}, delay 00:00:20, exact true, reschedule count 0\n08-20 17:05:28.945 4730-4752/dev.cosmos.android_job_reschedule_issue D/JobRescheduleService: Reschedule 0 jobs of 1 jobs\n08-20 17:05:44.907 1698-2150/system_process I/ActivityManager: Killing 4730:dev.cosmos.android_job_reschedule_issue/u0a87 (adj 900): remove task\n08-20 17:05:48.898 4766-4782/? D/JobRescheduleService: Reschedule service started\n08-20 17:05:48.903 4766-4783/? D/PlatformAlarmService: Run job, request{id=1, tag=tag}, waited 00:00:20, delay 00:00:20\n08-20 17:05:48.908 4766-4783/? I/JobExecutor: Executing request{id=1, tag=tag}, context PlatformAlarmService\n08-20 17:05:48.929 4766-4784/? D/JobProxy14: Scheduled alarm, request{id=2, tag=tag}, delay 00:01:00, exact true, reschedule count 0\n08-20 17:05:48.929 4766-4784/? I/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=false, class=ReminderJob, tag=tag}\n08-20 17:05:48.930 4766-4783/? D/PlatformAlarmService: Finished job, request{id=1, tag=tag} SUCCESS\n08-20 17:05:50.026 1698-3069/system_process W/ActivityManager: startActivity called from non-Activity context; forcing Intent.FLAG_ACTIVITY_NEW_TASK for: Intent { cmp=dev.cosmos.android_job_reschedule_issue/.ActivityTopOpenFromNotification }\n08-20 17:05:50.251 1698-1719/system_process I/ActivityManager: Displayed dev.cosmos.android_job_reschedule_issue/.ActivityTopOpenFromNotification: +222ms\n08-20 17:05:58.942 4766-4782/dev.cosmos.android_job_reschedule_issue D/JobRescheduleService: Reschedule 0 jobs of 1 jobs\n08-20 17:06:48.933 4766-4857/dev.cosmos.android_job_reschedule_issue D/PlatformAlarmService: Run job, request{id=2, tag=tag}, waited 00:01:00, delay 00:01:00\n08-20 17:06:48.938 4766-4857/dev.cosmos.android_job_reschedule_issue I/JobExecutor: Executing request{id=2, tag=tag}, context PlatformAlarmService\n08-20 17:06:48.951 4766-4784/dev.cosmos.android_job_reschedule_issue D/JobProxy14: Scheduled alarm, request{id=3, tag=tag}, delay 00:01:00, exact true, reschedule count 0\n08-20 17:06:48.952 4766-4784/dev.cosmos.android_job_reschedule_issue I/JobExecutor: Finished job{id=2, finished=true, result=SUCCESS, canceled=false, periodic=false, class=ReminderJob, tag=tag}\n08-20 17:06:48.952 4766-4857/dev.cosmos.android_job_reschedule_issue D/PlatformAlarmService: Finished job, request{id=2, tag=tag} SUCCESS\nMy only idea what could cause issues was fixed in 072e2d410356364ab20ea225df0ed8a8c158b56c I've published a new version with this fix 1.2.0-alpha4. Could you give the new version a try and maybe test your demo again? If I can't reproduce the issue, I cannot help you or fix the bug.. @AndreiHarasemiuc I'm sorry for the delay, but I didn't forget you. There simply was too much other stuff on my plate.\n@Abdullah-Hussein Your issue sounds different. If you schedule 5 jobs, then it can happen, that they'll run at the same time. The system tries to batch jobs and alarms. That's expected behavior.. JobRescheduleService is an internal helper service, which reschedules YOUR jobs if that's necessary, e.g. after a reboot.. @Abdullah-Hussein https://developer.android.com/reference/android/app/AlarmManager.html#set(int, long, android.app.PendingIntent) Please don't post in this issue anymore. If you still have questions, create another issue. Your \"problem\" is expected behavior and working properly. . @AndreiHarasemiuc @dshatz I'm pretty confident that I found the cause for the bug. Thanks for your patience! Could you give version 1.2.0-RC2 a try? This one includes the fix.. Can you provide a quick sample and the full code of the scheduling method? What is createExtras() doing?. Thanks, I'll take a look.. I was able to reproduce the issue. The fix is included in the latest version 1.2.0-alpha4. Could you please test this version?\nI've also made a stupid mistake that I fixed. To schedule your you only need to do the following and not call your createExtras() method:\njava\nDailyJob.schedule(new JobRequest.Builder(DailyDataUsageJob.TAG), TimeUnit.HOURS.toMillis(0), TimeUnit.HOURS.toMillis(1));\nThanks for your help.. Version 1.2.0 has been released.. Hi Tyler, like you've mentioned most of this is already implemented. isRequireStorageNotLow() is implemented, but not in a backward compatible way. I'm waiting for an implementation in the support library, which isn't available, yet. \nThe work queue is implemented with the new startNow() method, which is using the JobIntentService under the hood. \nOnly the clip data feature is missing, because I didn't have a use case, yet.. See https://github.com/evernote/android-job/blob/dev-1.2/library/src/main/java/com/evernote/android/job/v14/PlatformAlarmService.java#L57\nThat's using the enqueue() method, see also https://developer.android.com/reference/android/support/v4/app/JobIntentService.html\nThe startNow() method enqueues the work for now und will run the job asap.. Yes, it's very similar to exact jobs\njava\nprivate void scheduleJob() {\n    int jobId = new JobRequest.Builder(DemoSyncJob.TAG)\n            .startNow()\n            .build()\n            .schedule();\n}\nEach time you would call this method, a new job would be scheduled. Calling it three times would run the job 3 times. . No problem, thanks. Duplicate of #176, it's fixed in the most recent version.. Thanks for reporting. This is a duplicate of #234. . This is a duplicate of #197. I explained what's happening and a possible solution for now in the other ticket. Feel free to reply there if you have any further questions.. We're testing currently the new version of the library. So far we haven't found any issues, so feel free to upgrade: https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O\nI don't expect that any further changes are necessary. I'll keep this issue open, although it has been already addressed in 1.2.0-alpha4.. I guess 1-2 weeks max for the final release. I won't release another alpha/beta/RC. . The last alpha should have been called RC. Thanks for the feedback. I'll close the issue when I release version 1.2.0 final.. There's nothing wrong with the latest RC. We already use it in production. For now the last missing piece is #237. I'd like to improve the log message, but didn't have time to take a look, yet. You can give it a try, if you want to. . Version 1.2.0 has been released.. This is a known issue: https://issuetracker.google.com/issues/63622293\nCan you try to use version 1.2.0-alpha4? Then the issue could be gone.. Closing because of inactivity.. Can you please file a ticket at b.android.com? That's an issue in the support library. Thanks.. https://issuetracker.google.com/issues/63622293. Thanks for the snippet. I'll add this workaround in the next version.. This should be fixed in version 1.3.0-alpha02. Please give it a try and let me know if it works for you. Thanks for all the comments and help!. I'm sorry for the delay. I'll take a look the next days. Thanks for all the feedback!. I've published a new release. Please let me know if this issue is fixed for you. Thanks for the PR! https://github.com/evernote/android-job/releases/tag/v1.3.0-alpha04. @galex Sorry, but I won't do this. You can use 1.3.0 WITHOUT WorkManager and shouldn't have any problems.. Soonish if no errors are reported. I'm on vacation for a week, probably after that.. Please provide a sample application. That code snippet isn't enough.. Please provide a full sample app, what I can build and install. It's also important how you've implemented the job.. Thanks for the sample. I now understand the problem. In this case I can't do anything, because the GCM API simply works differently than the others. E.g. the JobScheduler treats the time requirement as the most important one and I keep the library as close to the JobScheduler as possible. The GCM API goes a different route and waits until the network is connected. Even if I'd like to change that, I can't. That's the way GCM works.\nIn our app we disable the GCM API completely and only rely on the AlarmManager for Android 4. For Android 5 and above the library always uses the JobScheduler, so that's not an issue at all.\nI'm closing the issue, but feel free to reply and ask more questions nonetheless.. We use this\n```java\n  private void setupJobManager() {\n    JobConfig.addLogger(new EvernoteJobCreator.JobLibraryLogger());\n    JobConfig.setForceAllowApi14(true);\n    JobConfig.setApiEnabled(JobApi.GCM, false); // is only important for Android 4.X\nJobManager.create(this).addJobCreator(new EvernoteJobCreator());\n\n}\n. I think this is just a warning and not the library is logging it. . No that's not possible and don't be added. Just synchronize the method and you should be finejava\nprotected synchronized Result onRunJob(final Params params) { ...}\n``. The synchronize prevents thatonRunJob()can be called from two different threads simultaneously. In the end this job only can run sequentially. . I'm closing because of inactivity.. Please provide more information: which version were you using? A sample application to reproduce the issue, ... . There's nothing I can do. The library stores jobs in a database and if a database can't be created then scheduling the job fails. What else should happen in this case?. Closing because of inactivity.. That's not a problem of the library. You should be able to solve this on your own. I'm sorry, but there are better places like Stackoverflow to ask such questions. . I don't understand what you're trying to achieve. A job that completed successfully cannot be rescheduled and of course its request is also gone. . Use version1.2.0andJobConfig.setAllowSmallerIntervalsForMarshmallow(true);. There is the same method with version1.1.11, I think the API was something likeJobMananger.instance().getConfig().setAllo..(). . Yeah, I agree.. Hi, you can use version1.2.0-RC1. There I've reduced the pause from 10 to 3 seconds and you configure this in theJobConfigclass, e.g.JobConfig.setJobReschedulePause(0, TimeUnit.MILLISECONDS);. Version1.2.0has been released.. Version 1.2.0 will make this pretty easy: https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O#add-helper-class-to-run-jobs-daily. The problem in your sample is that you schedule the periodic job each time theonCreate()method of your activity is called. That cancels the old job and schedules a new one (withsetUpdateCurrent(true)`. So your job never really has a chance to run.\nSince this is not an issue in the library, I'm closing this issue here. . This is an issue tracker. Its purpose is to report defects in the library. Usually I try to help when questions come up and they're challenging, but in this case it's a very basic questions and there are better platforms like Stackoverflow, where you can ask for help.\nWhat you're describing isn't helpful at all. If you think that you found a bug in the DailyJob class, then please share the code with a description how to reproduce the bug. I can't say what's wrong in your case with such a vague explanation. The code you've shared simply implements it wrong and cannot work.. Which code? The sample above doesn't use the DailyJob class and contains bugs which I explained. That's why I said that your explanation is vague. Without a sample I must assume that you're doing something wrong like in the sample above. For us the DailyJob class is working fine in production with millions of daily users. \nI say it again: If you found bug, then please create a sample for me, where it's easy to reproduce the bug so that I can fix it. Just describing what you did isn't enough.. In your first app the problem is that you create the JobManager not in your application class. \nYour second app looks better, but the log looks also fine to me.\n09-02 09:19:35.541 6459-30625/com.finance.testapplication D/JobProxy21: Schedule periodic (flex support) jobInfo success, request{id=1, tag=SchedulerService, transient=false}, start 00:10:00, end 00:15:00, flex 00:05:00\n09-02 09:21:05.959 6459-6459/com.finance.testapplication W/IInputConnectionWrapper: getExtractedText on inactive InputConnection\n09-02 09:21:05.995 6459-6459/com.finance.testapplication W/IInputConnectionWrapper: getTextBeforeCursor on inactive InputConnection\n09-02 09:21:05.997 6459-6459/com.finance.testapplication W/IInputConnectionWrapper: getSelectedText on inactive InputConnection\n09-02 09:21:05.998 6459-6459/com.finance.testapplication W/IInputConnectionWrapper: getTextAfterCursor on inactive InputConnection\n09-02 09:22:06.764 6459-6459/com.finance.testapplication W/IInputConnectionWrapper: getExtractedText on inactive InputConnection\n09-02 09:22:06.765 6459-6459/com.finance.testapplication W/IInputConnectionWrapper: getTextBeforeCursor on inactive InputConnection\n09-02 09:22:06.766 6459-6459/com.finance.testapplication W/IInputConnectionWrapper: getSelectedText on inactive InputConnection\n09-02 09:22:06.770 6459-6459/com.finance.testapplication W/IInputConnectionWrapper: getTextAfterCursor on inactive InputConnection\n09-02 09:29:45.917 6459-6469/com.finance.testapplication W/art: Suspending all threads took: 10.037ms\nThe job was scheduled 10 minutes before the log ends and there are 5 minutes left to run the job. Also with such a short interval it can happen that the job doesn't run every 15 minutes. Please keep in mind how Doze and other power saving modes work. I'm referring to this slide from a talk I gave: https://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=76\nSo far everything works expected. . Your job will never run every 15 minutes on newer Android devices. That's expected and a good thing. . I just checked the logs with an API 21 emulator and don't see the exception. Which device are you using? I know that Samsung sometimes logs unnecessary errors. Also, this class is coming from the support library, so even if I would like to change it, I cannot do it. . Closing because of inactivity.. I just implemented this option last week! If you use version 1.2.0-RC1, then you can test it yourself. https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O\nYou can call JobConfig.setJobIdOffset(100);. Then the job IDs will start counting at 100. It should be exactly for what you're looking for.. Version 1.2.0 has been released.. No, this is not a problem of batching alarms. If you see the same behavior like in #248, then you don't need to create a separate issue. I'm closing this as duplicate.. It was a bug in this library, see c8f7a2fadbf397e54c17e0beb8af767d0e6f8c18. This crash is fixed in version 1.2.0-RC2 (stable version will be released soon).. I didn't create a tag, but you should find all information here: https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O. Thanks!. Let's continue the discussion in #237 . No, this won't be a problem, see https://github.com/evernote/android-job/blob/dev-1.2/library/src/main/java/com/evernote/android/job/JobStorage.java#L237\nWhen the job ID is being reset, then this checks will make sure that the next ID won't be below the offset.. I'm closing this since it has been resolved. Thanks again.. Thanks. I wouldn't make this too complicated and move everything over. I don't plan to add more static IDs. This looks fine to me. \nI already pushed a new commit, so unfortunately you have a small merge conflict. Before you push your changes, can you make sure that ./gradlew build builds successfully? I haven't setup any CI, yet, sorry. . Thanks!. This is only a test option. Don't do this in your production app. You should do this before creating the JobManager.. Please read the documentation of the method and what the exception is telling you. . Sorry, I thought a different ticket was open.. Did you dump the jobs in ADB? In either case I couldn't do anything. The library tries to reschedule jobs if necessary. If the user force closes the app, then he wants that your app doesn't run.. I'll update the FAQ after I've released version 1.2.0. For now I'll close the ticket.. I slightly updated the FAQ.. What @misrakli said. There isn't anything I could do about it.. Why didn't you try it yourself? It'll crash, you should provide a bigger time window instead.. Really? I didn't add an explicit check. But I also don't have a strong opinion either. I thinking of leaving it as is. . Again, daily jobs can't be exact, but you can use the same argument for the start and end milliseconds parameters. The execution window for the daily job will be 0 milliseconds, but it's possible that the job will run a little earlier or later than the given time (depending on the system state). Does this answer your question? . Thanks for your help, but like you explained in #237, this won't be helpful and instead more confusing.. Please follow the documentation: https://github.com/evernote/android-job#usage. Good catch! That's a bug. . This is fixed in RC4. . The FAQ answers the question how you can remove the GCM dependency AFTER you've used it. In your case you can't do anything about the log message. But I agree that it is not that important anymore and I'll remove the warning.. This is fixed in RC4. Let me know if you still have problems.. That snippet should work without any problems. Can you provide a full sample where it's broken?. Closing because of inactivity.. Please provide a sample so that I can reproduce the issue in the emulator. From the logs I see that this device is using Xposed.... Yes, you should use compile SDK 26. . I don't think so. The new library will rely on the support library 26. And the support library requires compile SDK 26 as far as I know. But the DailyJob class is basically a standalone helper, you can copy the source and it should also work with the old library.. No, that's not possible.. I'm sorry, you're on your own and need to address these lines yourself. I'm only supporting the DailyJob class inside of version 1.2.0 and recommend to use SDK 26 instead.. That's a warning and I can't change that? Do you have a sample for me to reproduce the issue? Can you reproduce the problem with the demo app?. Sorry for the long delay. I finally had time to double check what's going on. Yes, I see the same log messages when testing the demo app with a 4.4 emulator.\n10-03 12:43:27.860 2752-2752/com.evernote.android.job.demo W/dalvikvm: Unable to resolve superclass of Lcom/evernote/android/job/v21/PlatformJobService; (64)\n10-03 12:43:27.860 2752-2752/com.evernote.android.job.demo W/dalvikvm: Link of class 'Lcom/evernote/android/job/v21/PlatformJobService;' failed\n10-03 12:43:27.860 2752-2752/com.evernote.android.job.demo E/dalvikvm: Could not find class 'com.evernote.android.job.v21.PlatformJobService', referenced from method com.evernote.android.job.JobApi.isSupported\n10-03 12:43:27.860 2752-2752/com.evernote.android.job.demo W/dalvikvm: VFY: unable to resolve const-class 2155 (Lcom/evernote/android/job/v21/PlatformJobService;) in Lcom/evernote/android/job/JobApi;\n10-03 12:43:27.860 2752-2752/com.evernote.android.job.demo D/dalvikvm: VFY: replacing opcode 0x1c at 0x005d\nBut those are logged by Dalvik and are no problem at all. On Android 4.X the library is not relying on those classes. You can simply ignore those messages, the library still works probably. . Can you provide a sample for the bug? I couldn't reproduce it.. Closing because of inactivity. This looks like a bug in the system und is unrelated to the library. It's scary, though. But I don't know what I should do in this case. Maybe use a different API than the JobScheduler if that happens? I'm not sure.. The old library was silently eating the error. That was even worse.. Could you reproduce the issue?. The library is stable. This ANR is caused by in the native platform code and not in the library. You can fix this when you schedule your job in a background thread, not on the main thread. I'm talking about this line\nat pt.mycompany.myapplication.jobs.NotificationSyncJob.scheduleJob (NotificationSyncJob.java:153). Closing because of inactivity. Feel free to reply nonetheless.. I'm not sure what I should be doing in this case. Any recommendation?. The database is stored in the internal storage inside of your app dir (the default database folder). I don't know what's causing the issue. I also chatted with someone from Google about this issue, but he doesn't know either. \nOne problem could occur if the app is moved to the SD card. That's also possible on Android N with a virtual SD card. However, for me this feature isn't working in an emulator, so I couldn't test it myself.\nI have no idea what could be wrong.. Closing because of inactivity. Please add more information if you find something.. Which version of the library are you using?. I'll take a look the next days, thanks!. I'm sorry for the delay. The problem will be fixed in RC5. . I just released RC5. The issue is fixed. Thanks again!. Can you provide a sample app? We don't have any issues. . It depends what kind of job you're using. If you remove the app from the recent tasks, then it's possible that the Android OS clears all alarms. The library will then reschedule jobs as soon as it gets a chance. Scheduling jobs relies on the OS. If Android thinks it shouldn't run any job, then the library won't run jobs either.. It depends on the period. It's possible that the OS applies a different interval than you requested. \nI don't know a workaround. If you find one, I'd love to integrate it in the library.. If it works for you, use it. There's no need to use this library in that case. . That's just what I said above that alarms in the AlarmManager are cleared if you remove your app from the recents list. The description of the library explains that it's a wrapper around the AlarmManager and other job scheduling engines. So I'm aware of the AlarmManager.\nA utility library for Android to run jobs delayed in the background. Depending on \nthe Android version either the JobScheduler, GcmNetworkManager or \nAlarmManager is getting used.\nI also explained the situation here: https://github.com/evernote/android-job/blob/master/FAQ.md#what-happens-with-jobs-after-the-app-was-forced-killed\nI'm open to pull requests, but I doubt there is a solution. Because that's simply the way how Android works.. Closing because of inactivity.. Thanks!. Which version of the library are you using?. Is this reproducible in an emulator? How often do you run the job? \nIt's possible that some specific devices could cause issues. I also know that Android won't start alarms in Doze, if you schedule too many or schedule them too often. \nCan you provide a sample app?. Awesome, thanks for sharing your findings. . That's a bug, can you share the code how you schedule your job?. @thisismohitgupta This workaround is not needed anymore. \n@anukools Thanks again for reporting. The issue is fixed in RC6 (which should be available in 30 minutes).. I like the idea, I'll take a look at this.. I've released a snapshot build with the change. Could you give it try and let me know if that works for you?\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.2.1-SNAPSHOT'\n}\n. Version `1.2.1` has been released.. I'll improve the log message. How would you improve the log message? The job will run in 23 hours and 30 minutes, that's what the log message is saying.. The library logs the time as an offset from now. That's also true for daily jobs. You shouldn't read it as `runs at 23:00`, instead as `will run in 23 hours and 30 minutes`. That's also the case for regular jobs. Daily jobs aren't different, they're regular jobs with some custom logic for the time parameter. . No, the documentation is correct. Let's use this examplejava\nDailyJob.schedule(builder, TimeUnit.HOURS.toMillis(1), TimeUnit.HOURS.toMillis(6));\n``\nIf you schedule the job at midnight on your device, then you should find something like that in your log... start 01:00:00, end 06:00:00 (from now). However, if you schedule the job while it's 8am, then it should be... start 17:00:00, end 22:00:00 (from now)`. . The offset will be calculated every day and will be different depending on when your job actually ran. \nThe log message states (from now).. Sorry, that's not a problem of the library. I don't know what's wrong in your case.. ~~Yes, I'll remove the dependency after 1.2.0.~~ There you don't even see the dependency with the new Android Gradle Plugin. . Do you use the new Gradle plugin? Because you shouldn't see the cat dependency anymore. The library is very lightweight, there isn't much overhead when it's in the classpath.. But I don't see a reason to copy the code into the project either right now.. I'm sorry, but I still don't get the point. I don't want to remove the log messages and there is already a simple interface to customize the logging (see the Config class). By default I want to keep log messages enabled, that's why I can't move the cat class to a different module. With the Android Gradle Plugin 3.0 you don't see the Cat dependency anymore. But you're right, it's still used under the hood. \nThe Cat dependency doesn't cause any issues. Yes, it's another dependency, but does it really make things worse? . Closing because of inactivity. I still don't see a big benefit of removing the dependency.. Version 1.2.1 has been released. The cat dependency is gone. Let me know if you still have any issues. Thanks for all the feedback and arguments!. Thanks!. Yes, your assumptions are right. If the job fails multiple times either because no connection was available or you returned RESCHEDULE, then the retry delay will increase linear. . The Android OS decides when it should run the job, e.g. it works better on Android 5+ because there the JobScheduler is available. . You don't need to implement another job. You can reuse the existing job, it's only necessary to reuse the same tag like you did.\nYou need to remove setUpdateCurrent(true) on both jobs, because that would cancel any other job with the same tag. In the end something like this should work.\n```java\npublic static void scheduleJobPeriodic() {\n    int jobId = new JobRequest.Builder(WeatherFetchJob.TAG)\n            .setPeriodic(TimeUnit.HOURS.toMillis(6), TimeUnit.HOURS.toMillis(1))\n            .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n            .build()\n            .schedule();\n}\npublic static void scheduleJobOnce() {\n    int jobId = new JobRequest.Builder(WeatherFetchJob.TAG)\n            .startNow()\n            .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n            .build()\n            .schedule();\n}. Yes, I forgot about that.. I've released a snapshot build with the change. Could you give it try and let me know if that works for you?\n```groovy\nrepositories {\n    jcenter()\nmaven {\n    url 'https://oss.sonatype.org/content/repositories/snapshots/'\n}\n\n}\ndependencies {\n    compile 'com.evernote:android-job:1.2.1-SNAPSHOT'\n}\n``. Thanks for the feedback. I'll probably release a stable version next week.. Soonish :). Version1.2.1has been released.. You need to add this line to yourApplication.onCreate()method and not your activity. Then it should work. Otherwise please provide a sample app, so that I can reproduce the bug. Thanks.. No, there's no workaround in the library, because that isn't its purpose. You still need a broadcast receiver to monitor network changes. Note that you can do this only in code since Android 7.0 (or 7.1, I'm not sure right now). So it's impossible to monitor the network state while your app process is dead.. What @pec0ra said. If you callscheduletwice, then your job will run twice a day.. I would do something similar like you did. I don't plan to add any offset, theJobScheduler` doesn't provide such a feature either. Also be aware of that although you declare your periodic job to run every 15 minutes, it won't run every 15 minutes with Doze and other power saving modes. . That's not working with Doze on Android anymore. You can try to use an exact job and reschedule it manually every hour, but I also know that this might not work, see #290. . No, the system takes care of running them when it thinks it's best. They won't stop running, I'm saying that if you abuse the API by running too many jobs too frequently, then the system will stop doing that and apply smaller frequencies or delay jobs. . I didn't find any documentation about this.. Can you add a full stacktrace? Which version are you using? But database errors are usually hard to solve. Any recommendation?. Any idea how to fix the issue?. I'm sorry, but without a sample to reproduce the issue I cannot do anything.. Closing because of inactivity.. I've updated the release changes: https://github.com/evernote/android-job/releases/tag/v1.2.0. I'm sorry, but I don't quite get why you need this library in this case? The library can't help you with screen on/off notifications.. Closing because of inactivity.. There shouldn't be a problem with synchronizing the method access. The 2nd synchronize is redundant. Is the issue reproducible with other jobs?\nCould it be possible, that you accidentally scheduled multiple periodic jobs? Or could there be an other dynamic where you reschedule jobs? Can you share how you schedule the job? Which Android version is that?. @DvTonder That looks fine. I don't know what could be wrong. I hope you find steps to reproduce the issue.\n@akramShokri Do you mean cancelAndEdit()? That's fine. There weren't many changes in version 1.2.1, yet. Mainly\n- f23206b4b5f485f111d8237f0e4d2a6ecc3bf8e4\n- 8f73db9022939aa594619f144f06ba19bd45d498\nI don't know how that could affect running jobs.. There weren't any changes about scheduling jobs between these versions. Android 8.0 shouldn't use the GcmNetworkManager either, so the Play Services shouldn't be the problem.. You should see the difference in the git tree. Which result do you return in your job? Do you reschedule it? Maybe there's a bug in the library. But it's weird that it's happening with Android 8.0. For 6.0 I've backported some features where a potential could be, but not 8.0. I'm sorry, but that's a huge project and cannot check what's going on. The weird part in the log is that each job runs right after the other one. Then jobs aren't periodic, but one-off jobs. Do you also schedule one-off jobs? In your code snippet I only see periodic. Then the job IDs a really high, that means you've scheduled a lot of them. Is it possible that your code ends in a loop?\n```\n10-29 02:49:34.983 D/PlatformJobService(21800): Run job, request{id=69, tag=update_weather_periodic, transient=false}, waited 05:44:19 (+1 day), interval 00:30:00, flex 00:15:00\n10-29 02:49:34.992 I/JobExecutor(21800): Executing request{id=69, tag=update_weather_periodic, transient=false}, context PlatformJobService\n10-29 02:49:35.098 D/JobProxy26(21800): Schedule one-off jobInfo success, request{id=2986, tag=cancel_location_update, transient=false}, start 00:00:30, end 00:01:30 (from now), reschedule count 0\n10-29 02:49:35.179 I/JobManager(21800): Found pending job request{id=2986, tag=cancel_location_update, transient=false}, canceling\n10-29 02:49:35.211 D/PlatformAlarmService(21800): Run job, request{id=2987, tag=update_weather, transient=false}, waited 00:00:00, delay 00:00:00\n10-29 02:49:35.230 I/JobExecutor(21800): Executing request{id=2987, tag=update_weather, transient=false}, context PlatformAlarmService\n10-29 02:49:36.633 I/JobExecutor(21800): Finished job{id=69, finished=true, result=SUCCESS, canceled=false, periodic=true, class=k, tag=update_weather_periodic}\n10-29 02:49:36.664 D/PlatformJobService(21800): Finished job, request{id=69, tag=update_weather_periodic, transient=false} SUCCESS\n10-29 02:49:36.725 D/JobProxy26(21800): Schedule one-off jobInfo success, request{id=2988, tag=cancel_location_update, transient=false}, start 00:00:30, end 00:01:30 (from now), reschedule count 0\n10-29 02:49:36.741 I/JobManager(21800): Found pending job request{id=2987, tag=update_weather, transient=false}, canceling\n10-29 02:49:36.758 I/JobManager(21800): Cancel running job{id=2987, finished=false, result=FAILURE, canceled=false, periodic=false, class=k, tag=update_weather}\n10-29 02:49:36.797 D/WeatherUpdateJob(21800): Scheduled a manual Weather update job with id = 2989\n10-29 02:49:36.800 I/JobManager(21800): Found pending job request{id=2988, tag=cancel_location_update, transient=false}, canceling\n10-29 02:49:37.705 I/JobExecutor(21800): Finished job{id=2987, finished=true, result=SUCCESS, canceled=true, periodic=false, class=k, tag=update_weather}\n10-29 02:49:37.706 D/PlatformAlarmService(21800): Finished job, request{id=2987, tag=update_weather, transient=false} SUCCESS\n```. So it's a \"user error\"? :). Please provide a deobfuscated stacktrace. My tip is to schedule jobs in a background thread, because the library uses a database under the hood.. Closing because of inactivity.. I've double checked the database access and in all instances I'm closing the database. I don't know why this exception is thrown. Is it possible, that the devices are rooted? \nBTW, you shouldn't run async operations like an AsyncTask inside of your job, see https://github.com/evernote/android-job/wiki/FAQ#how-can-i-run-async-operations-in-a-job. Closing because of inactivity.. Hm, this is more of an internal limitation, because daily jobs are manually rescheduled. I'll try to change that. In the meantime you can use isRequirementNetworkTypeMet() in your job to check the condition yourself. . Daily jobs run daily, just return success as result. They're like periodic jobs, you don't need to reschedule them manually.. Version 1.2.1 has been released. It's now possible to enforce requirements. . The library isn't using native code. I also don't see any hint that the library is causing this crash.. Closing because of inactivity.. Did you turn off transitive dependencies in your gradle files? Can you show how you included the library in your gradle files? Do you have Proguard enabled?. If you just include the .aar file, then you need to download dependencies manually. Here's a list of all depedencies: https://github.com/evernote/android-job/blob/master/library/build.gradle \nYou need to include the Cat library as well: https://github.com/vrallev/cat\nYour problem isn't an issue with the library, so I'm closing this ticket.. Can you provide a sample to reproduce the issue in the emulator? The exception shouldn't crash your application, though.. Maybe file an issue at their library? I don't know what I should do.. I don't think I can do anything here, right?. Closing because of inactivity.. I think that's not possible right now. I'll try to add this feature.. Version 1.2.1 has been released. It's now possible to start a daily job once immediately. . What happens when you restart the app again, do the jobs start to run again?. That's what I expected that jobs run when you open the app again. Unfortunately, there isn't anything I could do. I've answered these questions in the FAQ:\n https://github.com/evernote/android-job/wiki/FAQ#why-arent-my-periodic-jobs-running-as-expected-on-android-5-or-higher\n https://github.com/evernote/android-job/wiki/FAQ#what-happens-with-jobs-after-the-app-was-forced-killed\nIf anyone has a solution, then I'm open to pull requests.. Closing because of inactivity. Sorry, but this question is better suited for Stackoverflow. You can do something like this: https://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=69. The library doesn't make any promises about how jobs are executed. In your case I highly recommend to create two separate threads inside of your job and to run them in parallel. You need to block your job until the execution is done. A similar sample can be found here: https://github.com/evernote/android-job/wiki/FAQ#how-can-i-run-async-operations-in-a-job. If they're independent, why do you need to run them in parallel? Yes, they should run irrespective of each other.. Sorry for the delay. I finally had time to test this myself and can reproduce the behavior. The behavior depends on the API. Exact jobs or jobs using the JobScheduler under the hood run in parallel. However, if you start jobs immediately, then a JobIntentService is used, which doesn't run jobs in parallel.\nI don't have a good solution for this since the JobIntentService is required for Android O+.. You're probably starting your job immediately. I recommend to not use the library in this case and use instead two background threads. If the background works could take longer and you want to use a job, then I suggest to use just one job like before.. Closing because of inactivity. Thanks!. That's a bug in the support library, see #255 . That looks right to me. Did you wait a full day until your job ran?. Closing because of inactivity.. This is a really good point. My only concern would be the consistency between the platform versions. But you're absolutely right, with setRequirementsEnforced(true) it doesn't really matter. Thanks for the feedback!. Version 1.2.2 has been released.. support-compat could be enough. Good point.. Version 1.2.2 has been released. It now relies on support-compat instead of the full support-v4. Please let me know if that works for you.. Use JobManager.getAllJobResults() \nhttps://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobManager.java#L358 . Closing because of inactivity. That's not an issue of the library. By the way, version 1.2.1 has been released, you don't need to use the snapshot build anymore.. For consistency. It also doesn't hurt to acquire another wakelock if one is already held. Also JobExecutor doesn't know from which platform it is being called.. It's not that easy, because it depends on the used job schedule engine. The JobScheduler doesn't acquire a wakelock for you, only JobIntentService does.. The problem is that the system will release the wakelock in onStopJob, too. This method is also called when the requirements aren't met anymore, but maybe you still want to continue with your job nonetheless. I'm sorry, but I won't remove the wakelock.. Because your approach basically creates a new job and this one didn't run, yet. Also note that only returns a value for periodic jobs as the documentation mentions. But maybe it's a good idea to change that for daily jobs.. Version 1.2.2 has been released. Please let me know if that works for you.. No, that's not possible. Since this is a very specific request you must implement this on your own, sorry.. Take a look at the sample https://github.com/evernote/android-job#usage\nYou can always schedule a new job after your job ran. You can also use a periodic job. . You just forked the project, right? In order to build the library, you need to have the play services as a compile dependency. But for a consumer of this library the play services aren't required.. I don't know what the stub library is doing, but it's isn't necessary for this library. The original play services library is only uses as compile dependency. It's basically working like a stub. \nBut yes, I think it should still work as expected.. This looks like a limitation in the system? There shouldn't be a reason why job stops running. You can also dump all jobs from the JobScheduler to find out if your job is still scheduled. Maybe this gives more insights. A sample can be found here: https://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=87. Please also use adb do dump all jobs from the JobScheduler. Closing because of inactivity.. The problem is that you swipe your app away and then alarms are cleared. The library is using the AlarmManager under the hood for exact jobs. See also https://github.com/evernote/android-job/wiki/FAQ#what-happens-with-jobs-after-the-app-was-forced-killed. Daily jobs use the JobScheduler on Android 5+, else the AlarmManager.. There may be other power optimizations for that device that prevents jobs from running. You can use ADB to check if the job is scheduled adb shell dumpsys jobscheduler.. This could be a bug in your app and you should look for help elsewhere, e.g. Stackoverflow.. Can you test your app with other devices?. Please provide a sample (tiniest app possible) for me which shows the issue. I don't have any other idea.. I'll give it a try\n. I've tested your app and couldn't reproduce the issue with the Nexus 6P. First I had to fix a bug, your app was crashing. Then I did the following\n Launch the app\n Press button 1 -> button 2 is enabled now\n Press the back button -> app is closed\n Wait until the next morning and open the app again -> button 1 is enabled.. You didn't add your Application class in your manifest file. That's why it isn't called.. I'm sorry, but this is an issue tracker. Stackoverflow or similar websites are better suited for such questions.. Thanks for bringing it up. There shouldn't any issues, if you force using a newer support lib version (specify all support library versions explicitly). I'll get to this soon.. Hey, I've just released version 1.2.2. Can you give this one a try and let me know if this now works better for you?. (sorry, I accidentally closed the issue). Glad that it worked for you.. Sorry, this is something I cannot fix. If the device tells that it has access to the Internet, then I need to believe that.. Make the logic reusable and schedule a separate job from your daily job. That should work.. Closing because of inactivity.. That's not a problem of the library. You should ask for help somewhere else.. It's enough to have one job, but you need different tags when you schedule them. E.g. you could use following tags MY_JOB_10_AM, MY_JOB_01_PM,... And in your job creator you map all tags to the same class.. Closing because of inactivity.. All the methods inside of JobStorage are synchronized. Honestly, I don't know what I should do here. Any recommendation?. But that's what the synchronized keyword is also achieving. Or am I missing something?. Dang, I thought I also synchronized the whole object when accessing it. Good catch! Thanks. Sorry for the confusion, but what you said is wrong. Synchronized methods prevent that calls on ALL synchronized methods of the same object don't interleave, see here. But I agree that a ReadWriteLock provides a better performance. Nonetheless, it won't fix your problem.. Version 1.2.2 has been released. It now uses a ReadWriteLock.. I'll make this feature optional through the JobConfig.. In version 1.2.3 I don't close the database anymore. Please let me know if that works for you all better now.. You can check the params. Please ask such questions somewhere else next time. This is an issue tracker.\njava\n        long scheduledAt = params.getScheduledAt();\n        long startMs = params.getStartMs();\n        long endMs = params.getEndMs();. No, I don't want to do this. The params are tied to the lifecycle of a job, e.g. calling getParams() before the job is executed would return null. If you want to expose something, you can always add you own getter.. This is not an issue of the library.. That looks like a multidex issue. The missing class is clearly not part of this library.. Yeah, good idea.. Version 1.2.3 has been released.. The library doesn't work well with foreground services and I'm not sure if this is even the right approach. The JobScheduler is intended for background work not foreground services. If you want to start a foreground service, then these are completely different requirements and you cannot use the JobScheduler. \nOne workaround for you could be not to enforce the requirements and start a foreground service from your job.\nI'm not sure if I'll add this option to the library.. Thanks for the explanation, but it isn't as easy as you make it sound. The library relies a lot on the JobScheduler. If it needs to start a foreground service, then it must use the AlarmManager. The AlarmManager doesn't respect any requirements like a specific network condition. The library would need to check them manually like it does currently. But in this case a notification needs to pop up for a second in order to check the requirements. \nThe only option I see to implement this well is to not allow enforcing requirements. You need to manually check in your job if they're met. There may be some other constraints. . Since this library will be deprecated in favor of WorkManger in the future, this feature won't be implemented.. Yes, that's fine, I did something similar here: https://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=68 I'm closing this since it isn't an issue.. You can check isCanceled() inside of your job to check whether it was canceled and then stop your work early.. You can ignore that, it's a similar issue like #283 and unrelated to the library.. https://github.com/evernote/android-job/wiki/FAQ#what-happens-with-jobs-after-the-app-was-forced-killed\n. Some manufacturers may implement different strategies. Also, Android is blocking your alarms if you use them too frequently, see https://developer.android.com/reference/android/app/AlarmManager.html#setExactAndAllowWhileIdle(int, long, android.app.PendingIntent). Thanks for the update, that info will be helpful in the future.. Thanks. There are many existing issues about that topic already, also see https://github.com/evernote/android-job/wiki/FAQ#what-happens-with-jobs-after-the-app-was-forced-killed. There is no know way as it would defeat the purpose of force closing an app. That's not the right place for such a discussion and there are already many issues regarding that topic.. The library detects when the alarm is gone in the AlarmManager and reschedules jobs. After a force close it can only reschedule jobs when the app is launched again. Before the app is not launched again it cannot reschedule jobs.. Please also search for existing issues https://github.com/evernote/android-job/wiki/FAQ#what-happens-with-jobs-after-the-app-was-forced-killed. Good idea. Version 1.2.3 has been released.. No, but you can use the bundle and add custom data.. https://github.com/evernote/android-job#download. Schedule a new one. Sorry, but this isn't an issue of the library. There are better places to ask such questions like Stackoverflow.. I haven't seen this before, but it should be fixed with #344 . That's expected, because for exact jobs the time requirement is the most important requirement. The JobScheduler doesn't support exact jobs.. Instead of \nmaven {\n    url \"https://maven.google.com\"\n}\nYou can use google(). I think it was recommended to put google() as the first repository. \nYour error is unrelated to the library and I don't know where the duplicate class is coming from, but definitely not from this library. That's why I'm closing the issue for now.. What's the advantage? But I'll be going a completely different route and don't close the database at all, see #344 . This is now obsolete after the changes in #344.. I don't know at which line it's crashing. Also Xposed is running on this device, so the device itself very likely has a few problems.. Closing because of inactivity.. Please describe your problem in more detail.. The library only acquires a partial wakelock. Your question isn't a problem of the library.. Good find. Thanks for reporting. It's fixed now.. It was quite challenging to find the problem for me, too.. Sorry, I missed that somehow. I've released version 1.2.4 with the change.. I answered asap: https://stackoverflow.com/. I'm sorry, but I don't quite understand your problem.. Closing because of inactivity.. I don't understand your problem. You can add a job creator like this: https://github.com/evernote/android-job/wiki/FAQ#i-cannot-override-the-application-class-how-can-i-add-my-jobcreator. No, this let's you only add a JobCreator, the JobManager needs to be instantiated nonetheless. . Yes, it's possible that the system tries to batch services to optimize the battery usage. . You mean keep running a service all the time so that your app won't be stopped?. You can do this in your app, but I won't add anything like that to the library. This can't be implemented in an battery efficient way. If a service keeps running, then the device can't go into Doze mode.. Closing because of inactivity.. That's possible, because the requirement for a periodic job is to run once during each interval. If the system decides it's a good time to run the job at the beginning of the period, then it'll run during that time. You can adjust the window when it's allowed to run the job with the flex parameter.. Use startNow(), what is basically an exact job and return RESCHEDULE. I'm closing this issue since it's an issue tracker.. I don't have any experience with Xamarin, so I can't help you, sorry. Stackoverflow might be a better place to ask this question.. I don't know how this setup looks like and I wouldn't be able to maintain it. You can create your own Github repository and I could link it on the main page.. Awesome, I'll update the README later.. I'm reopening the issue to keep in mind that I need to do it.. I've updated the FAQ https://github.com/evernote/android-job/wiki/FAQ#can-i-use-the-library-with-xamarin-android. Can you provide a sample project for me to reproduce this issue or even better a test case?. I honestly don't know what I should do here. The Samsung ConnectivityManager implementation has a problem and not the library. . Any suggestion what the fallback network type should be? I guess it doesn't matter that much because it doesn't happen frequently. But I agree with you, that it's probably better if the library handles that.. That's my plan. This issue has been fixed in version 1.2.5. Thanks for reporting it!. Each time you call schedule() a new job will be scheduled. Please use Stackoverflow a similar sites for questions the next time.. Google named the GcmNetworkManager poorly. It's actually a job scheduler engine that uses the Play Services under the hood. It's not using GCM or FCM, those are independent of the GcmNetworkManager.. I don't think so. Thanks for filing nonetheless.. Depends on the Android version. On Lollipop and above the JobScheduler is used, which should support that feature depending on your other parameters. . Good catch, thanks!. No, your problem is different @zishanj. You could also use scheduleAsync. This issue has been fixed in version 1.2.5. Thanks for reporting it!. Can you share the stacktrace? This one particular above should be fixed.. This can't be the complete stacktrace.. I see why you want to do that, but it's not really necessary. If you schedule a job with a big execution window, then the JobScheduler and Doze will make sure that the job won't run at the wrong time. \nThere's also no such requirement in the JobScheduler. It wouldn't make sense for the library to implement this requirement, because the system couldn't support it in an optimal way either and would always fallback to manual checking. So it's better for you to use the broadcast receiver.. Closing because this shouldn't be in the library.. TimeUnit.HOURS.toMillis(8) + TimeUnit.MINUTES.toMillis(30). I don't see a benefit of it. It only would it make it impossible to use the library with projects that still use Java 7 as language level.. I'm sorry for the delay, I've been offline for a longer timer.\nI can't quite follow your problem. The library uses the JobScheduler and AlarmManager. If your process isn't running, then the system will launch your process at the right time.. Closing because of inactivity.. The link should solve your problem.. That's a new feature, see https://github.com/evernote/android-job/releases/tag/v1.2.2 and #325. But the I see that the log statement should be updated.. This issue has been fixed in version 1.2.5. Thanks for reporting it!. Because you enforce the requirements. That means your job won't run, if the requirements aren't met. JobScheduler is smarter and will run your job when the requirements are met, that's why it allows to stretch the time window, if the requirements need to be met.. I'm sorry, but it's not possible to backport this feature to older platforms, see #203. The JobCreator isn't necessary for scheduling any job, so when you schedule a request the library doesn't know which creator will be used later. You can always cancel all jobs for a given tag. I think that's what you want.. Yes, but I don't have a solution to that and if they want to cancel all jobs, then they should be able to do that. In your library you should treat it like you're running for the first time and need to reschedule things.. Closing because there isn't anything that could be done.. Since this library will be deprecated in favor of WorkManger in the future, this feature won't be implemented.. I'll take a look, thanks for the sample. This issue has been fixed in version 1.2.5. Thanks for reporting it!\nNote that in your sample it's still possible that the job runs twice when the first job already starts before the 2nd has been scheduled. However, there was a different race condition that I've fixed.. I'd recommend to extract the business logic from the jobs into a separate class and only use one job that calls all of your business logic.. Stackoverflow helps in such cases. Also \nhttps://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=77\nhttps://github.com/evernote/android-job/wiki/FAQ#how-can-i-run-async-operations-in-a-job. You can always call JobManager.instance().getJobRequest(jobId).. Closing because of inactivity.. The min flex is 30 seconds and the min interval 1 minute in this case. These values are coming from the GcmNetworkManager. If you want to use smaller values, then it's better to use a handler or any other threading mechanism.\nI also encourage you not to use JobConfig.setAllowSmallerIntervalsForMarshmallow(true);. https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobBootReceiver.java. I don't know, you can always repackage classes.. The Android OS is stopping your job. The result in the log statement is a little misleading, it's just the default value.. https://developer.android.com/reference/android/app/job/JobService.html#onStopJob(android.app.job.JobParameters). The system might think that your job is running for too long.. Yes, it's only a hint from the OS that you should stop your work and your requirements aren't met anymore.. It seems like you're scheduling two jobs. Please provide a sample to reproduce the issue.. Please provide a full sample app and link the Github repo here.. Thanks for the PR, but there is no benefit of doing this. The information already is written to the pom file https://github.com/evernote/android-job/blob/master/build-config/gradle-push.gradle#L100. Do you have sample code for that?. Those names are coming from the JobScheduler. I'll take a look, but I can't guarantee that I'll make any changes.. I won't make any changes after looking into it. Like you've mentioned, the return type is correct, only a little confusing. I've added a test to make sure that this behavior will stay consistent. . This issue has been fixed in version 1.2.5. Thanks for reporting it!. No, not that I'm aware of :) Can you provide a sample for me to reproduce the problem?. This issue has been fixed in version 1.2.5. Thanks for reporting it and the help!. That's odd, canceling a job should work. It could be a bug. Can you maybe create a small sample to reproduce the issue?. I'll try to take a look the next days. Thanks for the sample and detailed steps.. I've tested your sample and cannot reproduce what you described\n03-18 22:37:16.023 3561-3583/com.evernote.android.job.demo W/JobRequest: AllowSmallerIntervals enabled, this will crash on Android N and later, interval 60000 (minimum is 900000), flex 30000 (minimum is 300000)\n03-18 22:37:16.023 3561-3583/com.evernote.android.job.demo D/JobProxy19: Scheduled repeating alarm (flex support), request{id=4, tag=demo_sync_job, transient=false}, start 00:00:30, end 00:01:00, flex 00:00:30\n03-18 22:37:16.023 3561-3583/com.evernote.android.job.demo I/JobExecutor: Finished job{id=3, finished=true, result=FAILURE, canceled=false, periodic=false, class=DemoSyncJob, tag=demo_sync_job}\n03-18 22:37:16.033 3561-3757/com.evernote.android.job.demo D/PlatformAlarmService: Finished job, request{id=3, tag=demo_sync_job, transient=false} FAILURE\n03-18 22:37:46.033 3561-4061/com.evernote.android.job.demo D/PlatformAlarmService: Run job, request{id=4, tag=demo_sync_job, transient=false}, waited 00:00:30, interval 00:01:00, flex 00:00:30\n03-18 22:37:46.033 3561-4061/com.evernote.android.job.demo I/JobExecutor: Executing request{id=4, tag=demo_sync_job, transient=false}, context PlatformAlarmService\n03-18 22:37:46.043 3561-3583/com.evernote.android.job.demo D/LOG::DemoSyncJob: onRunJob(params)\n03-18 22:37:49.043 3561-3583/com.evernote.android.job.demo D/LOG::DemoSyncJob: Cancel job TAG: demo_sync_job\n03-18 22:37:49.043 3561-3583/com.evernote.android.job.demo I/JobManager: Found pending job request{id=4, tag=demo_sync_job, transient=false}, canceling\n    Cancel running job{id=4, finished=false, result=FAILURE, canceled=false, periodic=true, class=DemoSyncJob, tag=demo_sync_job}\n03-18 22:37:49.043 3561-3583/com.evernote.android.job.demo I/JobExecutor: Finished job{id=4, finished=true, result=SUCCESS, canceled=true, periodic=true, class=DemoSyncJob, tag=demo_sync_job}\n03-18 22:37:49.053 3561-4061/com.evernote.android.job.demo D/PlatformAlarmService: Finished job, request{id=4, tag=demo_sync_job, transient=false} SUCCESS\nAfter that the job didn't run again. It was canceled without any issues. Can you please try again? When you're able to reproduce it again, please also attach the logs from the library.. Thanks, I was able to reproduce the issue now. I've tested with Android 4.4 before, but it only happens with Android 5-6. . No worries. I can reliably reproduce the issue in a test now. It'll be fixed soon. This issue has been fixed in version 1.2.5. Thanks for reporting it and the great help!. ```java\n        JobManager.instance().getJobRequest(jobId); // job is queued\n    Job job = JobManager.instance().getJob(jobId);\n    if (job != null) {\n        job.isFinished() // job finished or not\n    }\n\n    JobManager.instance().getAllJobResults().get(jobId); // result of job, might be null if the job isn't in memory anymore\n\n. No https://github.com/evernote/android-job/wiki/FAQ#why-cant-an-interval-be-smaller-than-15-minutes-for-periodic-jobs. That's possible when the requirements aren't met and your job is rescheduled multiple times.. There are no other logs between these two? Try without enforcing requirements.. If it's a device specific issue, then there's nothing I can do. Can you provide a sample app that reproduces the issue in the emulator?. The problem is that some devices delay jobs longer. There's nothing I can do about it. I rely on the `JobScheduler` API to start and execute jobs.. Please also keep Doze in mind. It won't always happen that the device meets all of your requirements. . All of this is by purpose and won't change. You can always make your method public, then you can test it. We tend to write our business logic not directly inside of job classes and that seems to work well. . Closing because of inactivity.. The device controls when the jobs run either with the `JobScheduler` or `AlarmManager`. There's nothing I could do about it.. Closing because of inactivity.. I can reproduce the issue. One-off jobs are removed if no `Job` was found, also daily jobs. But periodic jobs remain. So your assumption is that they're automatically canceled?. The library tries to start them, but then should clear them since no job was found. . That should be fixed in the new version. Please let me know if you're still having issues: https://github.com/evernote/android-job/releases/tag/v1.2.6. Yes, likely. It's probably also caused by how you're using the library. Are you synchronizing to access to your job object somewhere? I mean you either use a synchronized method in your job class or use a synchronized block with the job instance as monitor? This thread is holding the lock\n\"NewsFeedUpdateTask\" prio=5 tid=18 Native\n  | group=\"main\" sCount=1 dsCount=0 obj=0x32c05940 self=0xe803c100\n  | sysTid=4255 nice=0 cgrp=default sched=0/0 handle=0xcf9ff920\n  | state=S schedstat=( 0 0 0 ) utm=1166 stm=22 core=3 HZ=100\n  | stack=0xcf8fd000-0xcf8ff000 stackSize=1038KB\n  | held mutexes=\n  #00  pc 0000000000017530  /system/lib/libc.so (syscall+28)\n  #01  pc 00000000000b69a1  /system/lib/libart.so (_ZN3art17ConditionVariable16WaitHoldingLocksEPNS_6ThreadE+92)\n  #02  pc 0000000000271891  /system/lib/libart.so (_ZN3art3JNI11GetIntFieldEP7_JNIEnvP8_jobjectP9_jfieldID+212)\n  #03  pc 0000000000012c7d  /system/lib/libjavacrypto.so (???)\n  #04  pc 0000000000012cf7  /system/lib/libjavacrypto.so (???)\n  #05  pc 000000000000f225  /system/lib/libjavacrypto.so (???)\n  #06  pc 000000000000e4ed  /system/framework/arm/boot-conscrypt.oat (Java_com_android_org_conscrypt_NativeCrypto_SSL_1read__JLjava_io_FileDescriptor_2Lcom_android_org_conscrypt_NativeCrypto_00024SSLHandshakeCallbacks_2_3BIII+192)\n  at com.android.org.conscrypt.NativeCrypto.SSL_read (Native method)\n  at com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream.read (OpenSSLSocketImpl.java:789)\n- locked <0x03d86a6e> (a java.lang.Object)\n  at com.android.okhttp.okio.Okio$2.read (Okio.java:141)\n  at com.android.okhttp.okio.AsyncTimeout$2.read (AsyncTimeout.java:211)\n  at com.android.okhttp.okio.RealBufferedSource.read (RealBufferedSource.java:60)\n  at com.android.okhttp.internal.http.HttpConnection$FixedLengthSource.read (HttpConnection.java:466)\n  at com.android.okhttp.okio.RealBufferedSource$1.read (RealBufferedSource.java:396)\n  at java.io.BufferedInputStream.fill (BufferedInputStream.java:235)\n  at java.io.BufferedInputStream.read1 (BufferedInputStream.java:275)\n  at java.io.BufferedInputStream.read (BufferedInputStream.java:334)\n- locked <0x02a7050f> (a java.io.BufferedInputStream)\n  at com.dvtonder.chronus.misc.i.a (SourceFile:216)\n  at com.dvtonder.chronus.news.d.a (SourceFile:333)\n  at com.dvtonder.chronus.news.b.a (SourceFile:693)\n  at com.dvtonder.chronus.news.b.a (SourceFile:378)\n  at com.dvtonder.chronus.news.f.a (SourceFile:336)\n  at com.dvtonder.chronus.news.f.onRunJob (SourceFile:171)\n- locked <0x0674353b> (a com.dvtonder.chronus.news.f)\n  at com.evernote.android.job.Job.runJob (SourceFile:132)\n  at com.evernote.android.job.JobExecutor$JobCallable.runJob (SourceFile:191)\n  at com.evernote.android.job.JobExecutor$JobCallable.call (SourceFile:176)\n  at com.evernote.android.job.JobExecutor$JobCallable.call (SourceFile:159)\n  at java.util.concurrent.FutureTask.run (FutureTask.java:237)\n  at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1133)\n  at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:607)\n  at java.lang.Thread.run (Thread.java:762\n```. This can be fixed in the library, though. I just want to make sure that this is really the reason.. Got it, then this makes sense. Thanks for bringing the issue up.. Yes, it would. Unfortunately, I didn't have time to work on this, yet.. That's now fixed in version https://github.com/evernote/android-job/releases/tag/v1.2.6. Can you provide a sample to reproduce the issue?. I can reproduce the issue, but it's a bug on the GCM side. They must have changed something internally and now crash. You can forward them that information. \nI'll try to find a workaround.. No new updates. You can revert the play services library if you want. It's an issue in their library.. That's what's in there and it's working with older versions of the Play Services fine.. No, but you can turn off GCM in the meantime . I tried to reproduce this issue again in an emulator with Android 4.4, but I can't. Can somebody help me? Is this still an issue or did Google fix the problem? I tried GCM version 12.0.0 and 15.0.1.. Uuh, I used an emulator without the Play Services. My bad, thanks for the snippet!. I released a new version https://github.com/evernote/android-job/releases/tag/v1.2.6. The library shouldn't crash anymore, but will fallback to the AlarmManager, if you don't manually enable the service like mentioned in the workaround. I've also updated the documentation: https://github.com/evernote/android-job#google-play-services\nPlease let me know if you're still having issues.. @isnyaga Do you have a sample project to reproduce the issue for me? . Like @iNoles said, you need to use the latest version.. Did you setup a JobCreator?. It looks like your app is canceling the job. I can't tell from this stacktrace what's going on.. Can you create a tiny app to reproduce the issue? . I do, I only print the message and not the full stacktrace, see https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/GcmAvailableHelper.java#L135. Closing because of inactivity.. Please read the README and ask questions at Stackoverflow. This is an issue tracker. https://github.com/evernote/android-job#advanced. You can schedule the same job multiple times. That's probably what you're doing. You can take a look at this sample: https://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=68 Also, this is an issue tracker. Stackoverflow is better suited for those questions.. I'm sorry for the long delay, I somehow missed this issue. Are you sure that this is an issue in the library?. Fixed with the latest push.. Here's a sample: https://github.com/evernote/android-job/wiki/FAQ#how-can-i-run-a-job-at-a-specific-time-once-a-day. You can directly do this inside of the job. That's the reason why I created this library. You might want to take a look at these slides: https://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=67. I'm sorry, but I don't have the time to go through such a long log. Could you please describe your issue better or provide a tiny sample app?. Please provide a tiny sample. How often do you call the scheduleJob() method? . You can override onCancel(), see https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/Job.java#L124. Thanks. This isn't an issue of this library.. Unfortunately, it depends on the job scheduling engine used. The JobScheduler should support this feature out of the box, but the AlarmManager (Android 4.X) doesn't. More and more people are using newer devices, so it's not worth to implement this anymore. It's also difficult to implement this for other requirements and in general I don't want to reimplement the job scheduling engine. . I would do something like this and let the JobScheduler handle that\njava\nnew JobRequest.Builder(your tag)\n            .setExecutionWindow(30 minutes, 2 hours)\n            .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n            .setRequirementsEnforced(true)\n            .build()\n            .schedule();. No, that's not working. You need to handle this yourself.. Thanks. See #408. You need to add the job creator each time the app launches. I recommend doing this in the Application.onCreate() method.. I haven't seen this crash before. I also checked their APK and they don't seem to use the library. According to the documentation the wake lock tag is only important for debugging purposes. Why do you think that this specific wake lock is causing the crash?. I don't know how I should help. Please let me know if you find more information. . Make the onRunJob() synchronized. Note that there's currently a bug #414, though. . Closing because of inactivity.. I don't know what will happen with the GcmNetworkManager. Google chose a poor name for this class, because it's unrelated to GCM itself. But even if they remove the class, then I won't switch to JobDispatcher, because less and less people are using Android 4.X and the AlarmManager also works for them.. This library isn't using any of these classes. It only uses GcmNetworkManager and GcmTaskService.. Why does this make a difference? I see the difference of implicit/explicit intents, but is this behavior documented somewhere or this specific to some manufacturers?. Ohhh :/ . Please describe your problem and maybe add a sample project.. Closing because of inactivity.. setUpdateCurrent(true) cancels the old job and schedules a new one.. Closing because of inactivity.. Closing because of inactivity.. Fixed with 1.2.6.. Closing because of inactivity.. Why restrictive? You should always target the latest SDK versions.. You don't have much time anymore, so I won't revert this: https://android-developers.googleblog.com/2017/12/improving-app-security-and-performance.html. Update the library, see #344. Yes, that's expected, see https://developer.android.com/training/monitoring-device-state/doze-standby. Closing because of inactivity.. Are you sure that you're calculating the offset correctly? Can you provide a tiny sample app?. Closing because of inactivity.. The time is an offset from the current time and not a time in the future, e.g. .setExecutionWindow(TimeUnit.MINUTES.toMillis(30), TimeUnit.MINUTES.toMillis(40)) will schedule the job to run in 30-40 minutes.. Great. You can call job.isFinished() for all cached jobs. If true, then the job is not running anymore. Otherwise it's currently running.. Closing because of inactivity.. Canceling works without any issues in the tests. Please write a failing test case or provide a tiny sample app.. Closing because of inactivity.. Please read the documentation. You probably want to call JobManager.getInstance().getJobRequest(id). Stackoverflow is your friend.. Please keep in mind that this is an issue tracker. You're not reporting an issue, you only seem to have problems getting used to the API. Use this JobManager.instance().getJobRequest(id) and it should work.. The problem is that there will be race conditions. Another technical limitation is that you can't run some jobs in process A and some in process B. The library already defines its services and you can't change that at runtime. However, you could change all services to run in another process and only use JobManager in this other process. This should work.. Closing because of inactivity.. Yes, you must use a different tag. Otherwise it's always the \"same\" daily job.. What do you mean? This is expected. A daily job should run daily only once. If you want to have multiple daily jobs, then you should use a different name for them.. This should work. Can you provide a tiny sample app where you can reproduce the issue?. Everything works as expected. Your problem is that after a reboot or closing your app you don't launch the MainActivity and thus don't add the job creator. When the library tries to start you job, it doesn't know how to map your tag to your job, because your creator doesn't exist. It's to add the job creator in the application class, like described here: https://github.com/evernote/android-job#usage \n2018-05-23 09:08:30.830 1675-2653/system_process I/ActivityManager: Start proc 3196:appdevelopment.darkfield.tinysampleapp/u0a86 for broadcast appdevelopment.darkfield.tinysampleapp/com.evernote.android.job.JobBootReceiver\n2018-05-23 09:08:30.839 3196-3196/appdevelopment.darkfield.tinysampleapp W/zygote: Unexpected CPU variant for X86 using defaults: x86\n2018-05-23 09:22:54.096 3196-4480/appdevelopment.darkfield.tinysampleapp D/PlatformJobService: Run job, request{id=2, tag=job_sync_tag, transient=false}, waited 00:14:57, interval 00:15:00, flex 00:15:00\n2018-05-23 09:22:54.096 3196-4480/appdevelopment.darkfield.tinysampleapp W/JobCreatorHolder: no JobCreator added\n2018-05-23 09:22:54.096 3196-4480/appdevelopment.darkfield.tinysampleapp W/JobExecutor: JobCreator returned null for tag job_sync_tag\n2018-05-23 09:38:19.514 3196-5260/appdevelopment.darkfield.tinysampleapp D/PlatformJobService: Run job, request{id=2, tag=job_sync_tag, transient=false}, waited 00:30:22, interval 00:15:00, flex 00:15:00\n2018-05-23 09:38:19.514 3196-5260/appdevelopment.darkfield.tinysampleapp W/JobCreatorHolder: no JobCreator added\n2018-05-23 09:38:19.514 3196-5260/appdevelopment.darkfield.tinysampleapp W/JobExecutor: JobCreator returned null for tag job_sync_tag\n2018-05-23 09:52:54.086 3196-6031/appdevelopment.darkfield.tinysampleapp D/PlatformJobService: Run job, request{id=2, tag=job_sync_tag, transient=false}, waited 00:44:57, interval 00:15:00, flex 00:15:00\n2018-05-23 09:52:54.086 3196-6031/appdevelopment.darkfield.tinysampleapp W/JobCreatorHolder: no JobCreator added\n2018-05-23 09:52:54.086 3196-6031/appdevelopment.darkfield.tinysampleapp W/JobExecutor: JobCreator returned null for tag job_sync_tag\n2018-05-23 10:09:09.407 3196-6927/appdevelopment.darkfield.tinysampleapp D/PlatformJobService: Run job, request{id=2, tag=job_sync_tag, transient=false}, waited 01:01:12, interval 00:15:00, flex 00:15:00\n2018-05-23 10:09:09.407 3196-6927/appdevelopment.darkfield.tinysampleapp W/JobCreatorHolder: no JobCreator added\n2018-05-23 10:09:09.407 3196-6927/appdevelopment.darkfield.tinysampleapp W/JobExecutor: JobCreator returned null for tag job_sync_tag\n. Like explained, this is expected. The device decides when it wants to start the job.. Closing because of inactivity.. Use JobManager.cancel() and then you can schedule the job again.. Done. We have the same feature in Evernote and we use exact jobs, those work well, see https://github.com/evernote/android-job#advanced. The trick with changing the time doesn't work. I'd recommend you take a look at these slides: https://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=85. I don't know a good way. I can only recommend what I've linked in the slides.. Closing because of inactivity.. Thanks!. You need to handle this yourself. There is no way in the library to do this.. Closing because of inactivity.. Thanks for the early feedback, I'll take a look!. This is fixed in version 1.3.0-alpha02. Please keep the feedback coming! https://github.com/evernote/android-job/releases/tag/v1.3.0-alpha02. A new stacktrace from #476 \nCaused by java.lang.IllegalStateException: Cannot invoke removeObserver on a background thread\n       at android.arch.lifecycle.LiveData.assertMainThread(LiveData.java:435)\n       at android.arch.lifecycle.LiveData.removeObserver(LiveData.java:217)\n       at android.arch.lifecycle.MediatorLiveData$Source.unplug(MediatorLiveData.java:145)\n       at android.arch.lifecycle.MediatorLiveData.onInactive(MediatorLiveData.java:126)\n       at android.arch.lifecycle.LiveData$ObserverWrapper.activeStateChanged(LiveData.java:413)\n       at android.arch.lifecycle.LiveData.observeForever(LiveData.java:207)\n       at com.evernote.android.job.work.a.b(JobProxyWorkManager.java:150)\n       at com.evernote.android.job.work.a.d(JobProxyWorkManager.java:91)\n       at com.evernote.android.job.JobRescheduleService.a(JobRescheduleService.java:112)\n       at com.evernote.android.job.JobRescheduleService.a(JobRescheduleService.java:87)\n       at android.support.v4.app.v$a.doInBackground(JobIntentService.java:2391)\n       at android.os.AsyncTask$2.call(AsyncTask.java:333)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n       at java.lang.Thread.run(Thread.java:764). Can somebody share a new stacktrace? The stacktrace from #476 is definitely from alpha01. I can't reproduce this issue and don't know what to do. Is this crash really still happening?. This must be also from alpha01. The crash is happening in line 150, what's matching the source code: https://github.com/evernote/android-job/blob/1f346620ba77f55a05f88dd995e2797302fd8054/library/src/main/java/com/evernote/android/job/work/JobProxyWorkManager.java#L150\nBut in alpha03 I'm removing the observer in line 161 https://github.com/evernote/android-job/blob/ae95bb5a4d17ae8e7720c6f44094cf7b5a1c5c45/library/src/main/java/com/evernote/android/job/work/JobProxyWorkManager.java#L161. That's really odd. Thanks for trying! I'll take another look what could have gone wrong. I've published a new release 1.3.0-alpha04. Please let me know if this issue is fixed there. I appreciate all the help.. I'm sorry for all the hiccups. I didn't notice that there's a better API that should be used. Please give the new version a try: https://github.com/evernote/android-job/releases/tag/v1.3.0-alpha05. The Device class is treated as an internal class. I will take a look nonetheless.. I looked into it and I'm afraid of adding a try-catch, because I don't have a good default value. Like I said, this class wasn't intended for internal usage only. The next version of the library will make this restriction clearer. I won't be able to fix your issue.. The API is now more restrictive in version 1.3.0-alpha02 https://github.com/evernote/android-job/releases/tag/v1.3.0-alpha02. Yes, please don't use internal classes.. There seems to be an issue in your logic. Not sure what I should do now.. Closing because of inactivity.. I have no clue what you ask me to try. Please provide a tiny sample app for me and steps to reproduce the bug.. Please create a sample project at Github that I can easily checkout. I don't have the time to setup everything manually.. I haven't seen this issue before. It seems like a problem with the support library? Honestly, I don't know what I should do. . Can this issue be closed?. Can you provide a sample app? It's not unlikely that your job is delayed because of Doze, especially since you also have other requirements like a network connection. In Doze mode you usually don't have a network connection, that's why your job is delayed until you turn the screen on.. I looked into it and the problem is that you set the requirements. The library relies on the JobScheduler and it triggers the job. There's nothing I could do.. Closing because of inactivity.. Please provide a sample app if you think that's a bug in the library. Otherwise please use stackoverflow.. Closing because of inactivity.. No, don't create a background thread. I'll fix this in the library. This is a bug.. That's fixed in version 1.3.0-alpha02. Please let me know if you still run into issues.\nhttps://github.com/evernote/android-job/releases/tag/v1.3.0-alpha02. As you can see the ANR happens in native code. There isn't much I can do about it. You need to make sure that you schedule your job in a background thread . Because the job must in the this time window it ignores the requirements at the end of the execution windows. You can use setRequirementsEnforced(true).. Please use the latest version and provide a sample app to reproduce the issue.. Closing because of inactivity.. My bad, it should be available now or in the next 20 minutes.. I'm closing this as a duplicate of #464. Thanks for reporting!. Please see my comment in #464 . Thanks, I'll take a look.. I've published a new release 1.3.0-alpha04. The issue should be fixed there.. Yeah, I don't know :) If the library is deprecated, it doesn't mean it stops working. I guess you can also implement daily jobs with WorkManager on your own. There are many options.. Closing because of inactivity.. Please provide a tiny sample app so that I can reproduce the issue. https://github.com/evernote/android-job/wiki/FAQ#what-happens-with-jobs-after-the-app-was-forced-killed. Please use Stackoverflow for questions. That's not an issue in the library.\nShort answer, your logic is wrong\n```java\n   @Override\n   public void onCreate() {\n       super.onCreate();\n   JobManager.create(this).addJobCreator(new BackupJobCreator());\n   BackupJob.Companion.schedule();\n\n}\n\n```\nYou don't need to schedule a job each time the app is launched. Check if a job already exists, otherwise schedule one.. There's nothing I could do. They internally use reflection to try to instantiate a job. It's the same as scheduling a work item and then removing the class. I told them in early previous that it isn't a good idea, but they kept it nonetheless. You should file an issue at Google's issue tracker.. Yes, exactly. In this case WorkManager shouldn't crash, though.. Closing because of inactivity.. The stacktrace is clear, your argument(s) for scheduling the daily job is over 1 day. You're computing the time wrong.\nIf this isn't the case, then please provide a sample app to reproduce the issue for me.. Because the time of a day starts with 0 and not 1, so 24 * 60 * 60 * 1000 is already the next day.. 1. The OS controls that. It's likely to happen. Jobs run in parallel, but you can change this with JobConfig.setExecutorService(..), although I wouldn't recommend that.\n2. You better look at WorkManager https://github.com/evernote/android-job#workmanager\n3. No, they don't. You can have multiple jobs with the same tag.. What do you mean? You can always get the parameters and requirements.. Yes, you can find all specific jobs by tag. Closing because of inactivity.. Sounds more like you want to simple background work. This library is not meant for replacing threads.. This library is intended for work running at a given time in the future, where you can't guarantee that the application is alive anymore. You can set the change parameters and requirements when scheduling a job, after that they're fixed.. I don't know what you mean with that. Jobs are immutable, once scheduled you can't change them.. Did you take a look at the samples? https://github.com/evernote/android-job#advanced. I mean, the sample literally does what you want, so I can't follow your problem\n```java\nprivate void scheduleAdvancedJob() {\n    PersistableBundleCompat extras = new PersistableBundleCompat();\n    extras.putString(\"key\", \"Hello world\");\nint jobId = new JobRequest.Builder(DemoSyncJob.TAG)\n        ...\n        .setExtras(extras)\n        .build()\n        .schedule();\n\n}\n. This library relies on the `JobScheduler`. If the device decides it's better to wait, then your job won't run. There's nothing I could do about it and it's expected actually.. You are right. I don't expect that some jobs don't run forever, but delays aren't that uncommon and this is good, because your device should save battery whenever possible.. Closing because of inactivity.. This should be a warning and not crashing your app. Can you confirm it's crashing your app?. Is it crashing the app? I'm asking because some devices log error messages on their own, but they don't crash and shouldn't be. . We're using the same code in production and don't see any issues with that. Importing classes that aren't available at runtime is no problem. The `isSupported()` method checks first if the class is available. If not, then it's not calling any of these classes.\npublic static boolean isGcmApiSupported(Context context) {\n        try {\n            return GCM_IN_CLASSPATH && ...\n        } catch (Throwable t) {\n            // ... \n            return false;\n        }\n    }\n``\nIf I could reproduce an issue, then I would fix it. The library has to check whether the class is available. Can you reproduce the issue in the emulator? . But it's not crashing, is it? . I've tried it once again. I load the library without the GCM dependency and it's definitely not crashing. Please provide a sample application with exact steps how to reproduce the crash. I simply can't reproduce what you're describing.. Your PR #490 doesn't make a difference. I think you're running into this issue: https://github.com/evernote/android-job/wiki/FAQ#how-can-i-remove-the-gcm-dependency-from-my-app You should give this workaround a try.. Thanks for PR. I'll include this in the next version. Unlikely. But I'm going to publish a new version over the weekend that should be stable (hopefully) and very close to the final1.3.0.. Yes, WorkManager can completely be turned off. It's also not a necessary dependency similar to GCM. I've published a new release1.3.0-alpha04. Please let me know if this issue is fixed there. I appreciate all the help.. I don't expect any further issues. If there aren't issues, then I'd release this as stable as is.. Hm, I don't know why the creating a thread should cause an OOM. Usually there's an issue somewhere else in the app and it's crashing here because the system is so low on memory. Without a reproducible sample I won't be able to do anything. You also should take a look at your heap what's consuming all the memory.. I need a tiny sample to reproduce the issue. We don't have any problems with daily jobs.. Not really. Please create a full sample project at Github so that I can checkout the project and try it myself. I don't have the time to setup projects for every issue.. Closing because of inactivity.. Thanks for taking a deeper look. I'll fix this in the next version.. I've published a new release1.3.0-alpha04`. Please let me know if this issue is fixed there. I appreciate all the help.. 1) It's recommended to create a new request each time. It doesn't matter if you schedule them at once.\n2) More work means more battery consumption. You need to measure that yourself.. I'm declining this PR. I'm going to handle this directly in the isSupported() method.. That's fixed in 1.3.0-alpha02, see #471. Please provide a full stacktrace. . This happens in your code getLocationJob. Closing because of inactivity.. Thanks for reporting, this is a duplicate of #492. Thanks for reporting, this is a duplicate of #492. Please provide a sample app. Note also https://github.com/evernote/android-job/wiki/FAQ#why-arent-my-periodic-jobs-running-as-expected-on-android-5-or-higher. Closing because of inactivity.. Please provide a sample app. Note also https://github.com/evernote/android-job/wiki/FAQ#why-arent-my-periodic-jobs-running-as-expected-on-android-5-or-higher. Closing because of inactivity.. Closing, this is an issue tracker and this is obviously not an issue.. Yes, that's the right hook, but it's not a supported API. You can try it, though. FYI, I also don't plan to expose this API as most people don't need it and this library will be deprecated sooner rather than later.. Deprecated doesn't mean it stops working ;-) I'm pretty sure that we'll use both in our code base for a longer time.. Yes, if the database is deleted / cleared, then jobs won't run.. schedule() requires a database operation, that's why you have scheduleAsync(). cancel() also requires a database operation.. That's a bug in your app. You schedule a NEW job each time your app starts. I guess that's not what you want. I recommend doing something like here: https://speakerdeck.com/vrallev/doo-z-z-z-z-z-e?slide=68. Closing because of inactivity.. I don't think I can do anything. It's not the library code that is holding the lock but\nwaiting to lock <0x0e1bc935> (a java.lang.Class<android.app.ContextImpl>) held by thread 18\nWhat is thread 18 doing?. Ah, I see the issue. Thanks for reporting! . This is fixed in the latest version: https://github.com/evernote/android-job/releases/tag/v1.3.0-alpha06. This should be fixed in 1.3.0-alpha07. . Do you have a sample to reproduce the crash? Are you using the Jetifier? Do you use the WorkManager library? Are you using Proguard?. @Jeff11 What happens if you turn Proguard off? I can't reproduce your issue. It seems like Proguard is removing classes that it shouldn't remove.. I read somewhere else that somebody had the same issue. For him cleaning the project helped. I'm not really sure what I should do here.. Please file an issue at Google's bug tracker. This clearly is clearly an issue of WorkManager.. @SumirKodes I can reproduce the issue myself. Checkout this project: https://github.com/vRallev/job-sample/tree/69234b90a4bd1b09aca679fc489b5c818d0662dc (use the same commit). In the terminal run ./gradlew installDebug. This installs the app \"Job Sample\". When you launch the app, it should crash with the exact same error.\nI was using an emulator API 27.. This should be fixed in 1.3.0-alpha07 that relies on the latest version of WorkManager (alpha 09). Please use the latest versions of both libraries, then this issue should be gone.\nThanks for the patience.. Can you provide more information? Where was the main thread blocked?. Closing because of inactivity.. You can ignore that. I don't know why Android Studio is doing that.. Closing because of inactivity.. It moved a while ago already: https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobConfig.java#L135. I can't help with basic Java questions. This method is now static, so you can just call\njava\nJobConfig.setAllowSmallerIntervalsForMarshmallow(true);\n. Looks like you're shrinking too much. It's clearly not an issue of the library. Maybe can you provide a full a sample app?. Closing because of inactivity.. 1) Please read the JavaDoc and let me know what's unclear.\n2) The library takes care of this and reschedules jobs when necessary.\n3) The library takes care of this, you don't need to do anything.\n4) 14. This is an issue tracker. If you think it's a bug in the library, please create a sample project and describe the steps to reproduce the issue.. Closing because of inactivity.. Can you test the latest version of 1.3.0. There this issue should be fixed.. I'm closing this issue, because it should be fixed in 1.3.0. You can use 1.3.0 without WorkManager, so this shouldn't be a problem.. That's not an issue of the library.. I need to add this to the documentation. Just removing the library should be fine. If you want you can delete the prefs and database files, but this shouldn't be such a big overhead.. Yes. There is already an issue #511. We use daily jobs in production and they work. Can you provide a sample project to reproduce the issue for me? Just to be sure, you're extending DailyJob, right?. Closing because of inactivity.. I'm sorry, but I don't understand the problem.. Can you provide a sample app for me to reproduce this issue?. Please provide a full sample at Github, so that I can checkout the project. Please try to describe the bug. If you have problems understanding the library, then please ask at Stackoverflow. This is an issue tracker.. Thanks for the PR. The code needs to be tweaked a little bit, but I do this myself. I appreciate the help!. You can use the current alphas. They're stable and we use them in production. They're only declared as alpha because they optionally depend on WorkManager, which API isn't stable, yet.. Hm, no, this shouldn't be a problem. Are you sure that the job is running twice? I'm asking because JobScheduler has internal bugs und runs jobs multiple times. The library prevents that a job with the same ID runs multiple times. So even if the job is scheduled twice, it shouldn't run twice.. Closing because of inactivity.. Hm, no. Can you provide a full sample app for me to reproduce the issue?. Closing because of inactivity.. Oh, that doesn't look good. Do you have any idea what could be causing it?. I don't know what I should do here.. Closing because of inactivity.. This library isn't doing anything special. I have no idea what I should be doing here.. The system controls when the job should run. I can't tell what caused this behavior.. As you said Doze has an influence. I can guarantee you that your job won't run every 30 minutes, that's simply a too short time window. Devices are really aggressive and want to save battery.. Hm, I don't know what the devices are doing under the hood. I recommend using the latest version with WorkManager as engine, see https://github.com/evernote/android-job/wiki/Migrating-to-WorkManager#using-both-libraries-in-parallel. No, you can only use one android-job version. groovy\ndependencies {\n    implementation \"android.arch.work:work-runtime:$work_version\"\n    implementation 'com.evernote:android-job:1.3.0-alpha07'\n}. Closing because of inactivity.. This library depends on the support library 28. You need change the compile SDK to 28 and update your dependencies.. It depends on your task. One-off tasks are rescheduled using the backoff criteria.. Once a job ran it is removed from the database. You need to save these information yourself. You can get all jobs through JobManager.instance().getAll**(). The JobCreator interface only maps tags to specific job classes. So yes, you need to add your daily job there, too.. JobManager.instance().getAllJobRequestsForTag(\"Tag\"). I'm closing this ticket, this is not an issue of the library.. Actually, I don't know what the devices are doing in the background and whether this is expected.  But from the app developers perspective there isn't anything we could do about it. . I can only refer to https://developer.android.com/training/monitoring-device-state/doze-standby. The tag kind of gives you that information. In this case it's JobProxy26, so the JobScheduler was used and not WorkManager.. Closing because of inactivity.. Yep, I'm aware of that :-) . That's fixed in 1.3.0-alpha08. I don't know what the reason could be. Neither do I have experience with Android TV. You need to do the research on your own or ask somewhere else.. This library doesn't contain any activity. . That's not related to GCM for sending push messages, it was simply poorly named by Google. But I'm glad you found the issue.. I still need to upgrade to alpha10. I will close this ticket in favor of #539 . I don't know what the issue is. Try turning strict mode off.. Okay. You need to call JobManager.create() first.. With a parameter. This is an issue tracker. Please use Stackoverflow for questions.. Use DailyJob. If you think this is a bug, then please provide a sample app to reproduce the issue.. Stackoverflow is the better website to ask these questions.. Are you sure that the library is causing this issue? This message is definitely not coming from this library.. No, I don't have any idea. Sorry. Agree. Somehow it was turned off. Thanks for the issue. It's back online: https://github.com/evernote/android-job/wiki. You're running into this: https://github.com/evernote/android-job/wiki/FAQ#how-can-i-remove-the-gcm-dependency-from-my-app\nThe library is not using GCM, but only optional the GcmNetworkManager. Although the name implies it, the class is unrelated to GCM.. The reschedule method is great.\n. It's by design that these methods are protected. A job should have the option to check conditions if they are not enforced. \n. I liked that the Params class was protected. It's only related to a Job\n. Still using reflection here and default constructor is still required.\n. I agree that this constructor is cleaner than setting the variables after the job has been created.\n. An Action always has to implement this method, although that's not necessary in all cases, e.g. for periodic jobs it would be wrong. \n. I'm not sure if this is a good idea at all or if makes things only slower. At least we avoid creating some new objects. \n. Fixed with 52f74fc\n. No, persisted means across reboots. I wanted it to be consistent with the JobScheduler and GcmNetworkManager.\n. Actually it does if a PendingIntent launches the app. But we catch this when the job should be executed the second time. No job with the same ID runs twice. However, I reduced the chance with a slightly delay 6f5331a42fab03bd9e7afb06ac8e1c9e02ecd680\n. This is the default case. The Job is persisted in the play services app. Returning false could end up in bad things. \n. Class should be final. Could you rename the class to JobIdsInternal? I want to avoid that users think that this is an important class. Also please add some JavaDoc. . Good catch!. I think you need to update the unit tests. Some should be failing now.. ",
    "jess-anders": "Okay sounds good.\n. It is bad practice to create a Handler when you don't know what thread you\nare running on.  If you would like the code run on the main looper, you\nshould correct the code to explicitly do that:  new\nHandler(context.getMainLooper()).\n- Jess\nOn Wed, May 25, 2016 at 10:20 AM, Ferran Garriga notifications@github.com\nwrote:\n\n@vRallev https://github.com/vRallev Are you planning to solve this\nissue?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/evernote/android-job/issues/48#issuecomment-221642988\n. If a bug, I think that is more of a bug to log on the Android platform.\nThough I think they are somewhat justified in expecting that someone using\nthe Captioning Service would be an Activity that is displaying something.\n- Jess\n\nOn Wed, May 25, 2016 at 8:03 PM, Ferran Garriga notifications@github.com\nwrote:\n\n@jess-anders https://github.com/jess-anders The problem is that the one\nwho is creating the handler is the android framework, crashinig on < 21\nCaptioningManager captioningManager = (CaptioningManager)\ngetContext().getSystemService(Context.CAPTIONING_SERVICE);\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/evernote/android-job/issues/48#issuecomment-221765882\n. Hope the caching of the DB makes a difference.  Changes look good to me.. That shows that you are leaking file handles in your app.  You should look\nfor files you are opening, but not closing.\n\n\nJess\n\nOn Mon, Apr 17, 2017 at 7:25 PM, Tu\u1ea5n Ho\u00e0ng notifications@github.com\nwrote:\n\nI see it from fabric. I don't move of delete DB. I can't reproduce it :(\nbut I have more error log.\nFatal Exception: android.database.sqlite.SQLiteCantOpenDatabaseException:\nunable to open database file (code 2062): , while compiling: PRAGMA\njournal_mode #################################################################\nError Code : 2062 (SQLITE_CANTOPEN_EMFILE) Caused By : Application has\nopened two many files. Maximum of available file descriptors in one process\nis 1024 in default. (unable to open database file (code 2062): , while\ncompiling: PRAGMA journal_mode) ##############################\n############################# at android.database.sqlite.\nSQLiteConnection.nativePrepareStatement(SQLiteConnection.java) at\nandroid.database.sqlite.SQLiteConnection.acquirePreparedStatement(SQLiteConnection.java:1058)\nat android.database.sqlite.SQLiteConnection.executeForString(SQLiteConnection.java:762)\nat android.database.sqlite.SQLiteConnection.setJournalMode(SQLiteConnection.java:443)\nat android.database.sqlite.SQLiteConnection.setWalModeFromConfiguration(SQLiteConnection.java:417)\nat android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:315)\nat android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:210)\nat android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:512)\nat android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:206)\nat android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:178)\nat android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:908)\nat android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:878)\nat android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:699)\nat android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:633) at\nandroid.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:283)\nat android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:223)\nat android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:163)\nat com.evernote.android.job.JobStorage.getDatabase(JobStorage.java:288)\nat com.evernote.android.job.JobStorage.store(JobStorage.java:244) at\ncom.evernote.android.job.JobStorage.put(JobStorage.java:127) at\ncom.evernote.android.job.JobManager.schedule(JobManager.java:231) at\ncom.evernote.android.job.JobRequest.schedule(JobRequest.java:354)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/179#issuecomment-294654653,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACHP4Rjxhxao8DpaG3bBZ_74T1UK3QONks5rxB8HgaJpZM4M-znx\n.\n. by moving from commit to apply, there is now a file write on the calling thread, but the call is guaranteed to be persisted when the call completes.  Does that change your API expectations?\n. by moving from commit to apply, there is now a file write on the calling thread, but the call is guaranteed to be persisted when the call completes.  Does that change your API expectations?\n. Do we need to store persisted?  Seems like if it is here, the value is 1.\n. not a change for this specific time, but I think we should cap the max number of failures and just delete the job (possibly with a callback of permanently failed).\n. I'm thinking we should possibly hold the wake lock while running the jobs, until we have the chance to store the updated request info (updated run time, number of failures).  Right now, the store happens asynchronously, so even if the job had the wake lock, we could miss rescheduling or marking a failure.\n. we should lazy initialize this if we actually need it since it's parsing the xml.\n. Still want to limit the number of failures.\n. feels weird to just return true\n. I wonder if we have a race condition where we are launched because of the job or pending intent and then don't see it so schedule another instance of it?\n. \n",
    "davidvavra": "Yes I can do that. \nBut what I would like is a separation of concerns. Using android-job should be an implementation detail of the library. The consumer of the library (application) shouldn't know which library uses android-job and shouldn't handle logic for it. Now the application needs to know which libraries uses android-job, what Jobs they have, what tags these Jobs have and logic which matches tags with Jobs. GCM Network Manager works like that - libraries can schedule jobs with it and application doesn't have to care.\nI'm suggesting changes in android-job initialization. Now it's needed to pass Context and single JobCreator. It would be great if the library supported multiple JobCreators and those can be added on JobManager singleton. Each library could have it's own JobCreator and android-job will try to match all of them.\n. Great! Do you plan to implement this yourself? Can I speed it up by submitting a PR?\n. Good job! It looks fine. I will work on the app after Christmas.\n. I have tried to use the snapshot in my app and it works well. Good job, you can release.\n. ",
    "sahal8020": "Second that. Just looked at the library and I still don't know which thread the job by default run on (haven't looked at internal code yet).\n. I noticed that the code itself on github has documentation recently so I guess the remaining issues are:\n- Library README.md doesn't contain all info needed to get up and running with it\n- Not sure about others, but I'm unable to access the documentation at all from within the Intellij IDE even though my build.gradle includes the option to download sources and javadoc\nI guess the combination of the two makes it seem like a mystery to the passers-by :)\n. ",
    "hansenji": "Here is a cool script that will automate javadoc and github hosting https://github.com/JakeWharton/butterknife/blob/master/deploy_website.sh\n. ",
    "grennis": "After some more investigation I have determined that the other proxies actually will not necessarily run the job at the start of the window either. It seems random. So, the alarm manager functionality is fine as it is. The actual problem is \"run this job ASAP\" seems impossible with the GCMNetworkManager, Lollipop Jobs, etc. So it seems like this library is more appropriate for truly indeterminate sync jobs, but anything that the UI is waiting for would not be well served by these systems.\n. Great, thanks for the explanation!\n. ",
    "consp1racy": "It would be plausible to perform a check when JobRequest.Builder.build() is called. This would allow to fail early if JobRequest.Builder.setPersisted(true) has been called and extras contain non-primitives.\nThanks for the tip.\nEdit: Oh, JobScheduler does not take regular Bundle. That's a killer.\n. And GcmTaskService has onInitializeTasks method for this. Thank you, now I understand completely. \nhttps://developers.google.com/android/reference/com/google/android/gms/gcm/GcmTaskService.html#onInitializeTasks()\n. ",
    "saket": "The Application class is exactly where I'm setting up JobManager, but inside a separate thread so that it does not slow down the app startup.\nI only initialize the important components in the UI thread to avoid polluting the startup time. \nI will try calling JobManager.create() on the UI thread and see if this is solved.\n. Sorry for my late reply. Moving the create part outside of the thread inside onCreate() solved the issue :)\n. ",
    "saeedjassani": "I am facing the same issue. But, I don't have Application class hence using this link. Any solution?. ",
    "fdonzello": "It doesn't seem to be true.\nFollowing the docs I implemented my job. Every time the app starts it schedules the job with the same tag more times. I can see from logcat:\nScheduled repeating alarm, request{id=1, tag=mytag}, interval 12:00:00 (first start)\nScheduled repeating alarm, request{id=2, tag=mytag}, interval 12:00:00 (second start)\n... and so on.\nThen when it's time for the framework to run these jobs it runs all of them.\nThis caused a lot of devices running their (increasing every day per app start) jobs hitting really heavily the web servers.\nSo the problem has been found through the high load of the webservers (the job performs a http request).\nI fixed this by checking right before scheduling the job if more than one job was returned by JobManager.instance().getAllJobRequestsForTag(MYTAG) and I can say that more than one job was found.\nSo I debugged the problem, confirmed it and fixed it.\nMay I am missing something?\n. Actually you do nothing if the job count found by tag is 1. So you won't cancel it even if you call the method many times.. It's exactly our implementation, nothing more..\nIt's no big deal of course, but it would make the library more complete imho.\n. Testing.. ;)\n. Can't build gradle.. It can't find android support 23.2.1. Is everything ok with deps?\n. Yep, exactly.\n. Ok, I'll try to find some time to do it! thanks\n. ",
    "lurbas": "Correct me if I'm wrong but it's what PeriodicTask.Builder().setUpdateCurrent() from GCM Network Manager does. By default, it's set to false. It this case if you're trying schedule task, and there actually is one with the same tag it will not be scheduled. If set to true the previous one will be canceled and new one scheduled.\nIn this library it's always set to true but you are using jobId as a tag.\n```\npublic class JobProxyGcm implements JobProxy {\n...\n@Override\npublic void plantOneOff(JobRequest request) {\n    OneoffTask task = new OneoffTask.Builder()\n                .setTag(createTag(request))\n                .setService(PlatformGcmService.class)\n                .setUpdateCurrent(true)\n                .setExecutionWindow(Common.getStartMs(request) / 1_000, Common.getEndMs(request) / 1_000)\n                .setRequiredNetwork(convertNetworkType(request.requiredNetworkType()))\n                .setPersisted(request.isPersisted())\n                .setRequiresCharging(false)\n                .build();\nmGcmNetworkManager.schedule(task);\n\n}\n```\nBTW: PeriodicTask.Builder().setRequiresCharging(false) the requirements about charging are not passed from jobRequest to GCM OneoffTask\nSo, what I wanted to say, is maybe it will be nice to have this feature. Especially if it's easily supported by one of the implementations.\n. ",
    "chokkarg": "03-12 21:10:35.100 2887-2887/com.evernote.android.job.demo D/JobProxy21: Schedule periodic jobInfo success, request{id=1, tag=job_demo_tag}, interval 00:01:00\n03-12 21:10:35.183 2887-2887/com.evernote.android.job.demo D/JobProxy21: Schedule periodic jobInfo success, request{id=2, tag=job_demo_tag}, interval 00:01:00\nThanks for the great library . \nI am also getting 2 periodic jobs. Any work around an unique() api ?\n. setUpdateCurrent(boolean) works as expected.:) It cancel existing pending jobs and schedule a new ones. \n. ",
    "gustavobap": "What about if setUpdateCurrent is set to false, the job will be started despite the previous hasn't been finished or the new job will just be ignored ? Is there a way to control this behavior ? . ",
    "friederbluemle": "@vRallev I did not manually change them. I used an \"official\" task of type Wrapper, provided by Gradle,  to update to the latest version. See https://docs.gradle.org/current/userguide/gradle_wrapper.html\nThe minor changes to gradlew were made several versions ago, but were not reflected here because most likely the version number was updated manually before.\ngradlew.bat shows every line changed, that is because the file used to have Unix line endings. Since this file is used only on Windows, Gradle correctly assumes Windows-style line endings (CRLF).\n. Thanks :+1:\n. ",
    "tadfisher": "That... makes a lot of sense. Thanks!\n. ",
    "maniac103": "Hmm, I see. Wasn't aware that GCMNetworkManager doesn't support it. GCMNM seems to do exponential back off by default though, and it's a bit unfortunate that the default behaviour differs between the various back ends. The alarm manager back end could implement the policy by itself, leaving only the optional GCM back end not supporting it, which might be OK depending on the scenario.\nTo clarify on my scenario: I only want exponential instead of linear and don't require further options.\n. See https://android.googlesource.com/platform/frameworks/base/+/android-5.1.1_r37/core/java/android/os/PowerManager.java -> look for mReleaser. The release() call happens asynchronously, thus synchronously catching the exception doesn't help.\nInstead of catching any exception (which seems a bit broad anyway), why don't you just do a wakeLock.setRefCounted(false)? Calling isHeld() before release() still leaves a (small) race condition, and I don't see why refcounting would be needed in your case.\n. If you don't want to turn off reference counting for whatever reason, converting the Thread to an AsyncTask, acquiring the wakelock in onPreExecute() and releasing it in onPostExecute() likely would work as well.\n. I'll try it as soon as I get to it (in the next few days).\n. Indeed looks better, thanks!\n. ",
    "vibin": "I couldn't find a way to change the backoff behavior in GcmNetworkManager, but interestingly Firebase JobDispatcher supports it (called RetryStrategy), even for periodic jobs. See https://github.com/firebase/firebase-jobdispatcher-android/blob/3d82e89d1eb89cc7d0634cc0d71f96c45f63ce3d/jobdispatcher/src/main/java/com/firebase/jobdispatcher/GooglePlayJobWriter.java#L118 . Ideally yes :), but bumping targetSdkVersion is not as simple as bumping compileSdkVersion, and 26 (Oreo) is still kinda recent.. Sad that this library will be deprecated, as WorkManager doesn't have many features like exact jobs, daily jobs etc. \ud83d\ude1e . Thanks!. ",
    "distjoy": "Yeah, am running 6.0, but it should only run one job within the 6hours interval, so i should only get one possible notification within 6hours interval, i noticed more than one notification within the interval, does it mean JobScheduler runs job more than once within the specified interval? or is it possible an unsuccessful job is postponed till the next 6hours interval?\n. Just discovered a method silently rescheduling job scheduled already. Thanks\n. ",
    "mohamadAliMotlagh": "i have this problem...please help me. ",
    "reiterp-avs": "This was already answered in issue #24 \n. What about setting the interval to current time + constant ?\n. @gemiren if you want to check android-job database, the I can recommend you facebook stetho, also on API21+ you can list scheduled jobs by calling JobSchedule.getAllPendingJobs()\n. I am using JobManager but I have encounter strange behaviour in my application where periodic persisted job which was at first scheduled with interval A(2 minutes) and then rescheduled to interval B(10 minutes) was launching with both intervals. In android-job database I have found only one job with matching tag and interval matching B. After that I have called JobScheduler directly from debugger and found out that there is second job with same tag but old interval A.\nBut this is beside my point which is, you schedule periodic job on API 21+ with interval A which was supplied by your backend (and job id is high lets say 1000), then user clears data of your app and when he launches app he will get new interval B from server which will be again scheduled (because if I query JobManager for scheduled jobs I will get empty list), now the app will be launched by JobScheduler for both intervals because JobScheduler jobs are persisted despite the fact that all app data were purged.\nTherefore if I would like to save user battery by switching retrieval of data from backend from once per 2 hours to once per 8 I could end up with even worse result which will be solved only by app uninstall.\n. @vRallev I would like to kindly ask you to include this fix in 1.0 release branch\n. Additional info, the library project is only affected if it doesn't contain any resources\n. Yes, so far I was using version 1.0.13 without any issues.\n. ",
    "DvTonder": "Latest version. Was thrown on an Android 5.1 device.  \nCould you not check if the wakelock isHeld() before you try to release it? \n. We will let you know. Thank you \n. You can try triggering it via adb.  See https://developer.android.com/training/monitoring-device-state/doze-standby.html#testing_doze_and_app_standby. I have noticed a similar crash report in our Play store Crashes and ANR's page.  I will try to find it and post the log here.  I don't recall which version but I suspect it was with 1.1.9. . Reported on May 3rd, android-job 1.10, Android 6.0, Galaxy S5\nandroid.database.sqlite.SQLiteConstraintException: UNIQUE constraint failed: jobs._id (code 1555)\nin #################################################################.nativeExecuteForLastInsertedRowId\nCaused By : Abort due to constraint violation.\n    (UNIQUE constraint failed: jobs._id (code 1555))\n\nat android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(SQLiteConnection.java)\nat android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:915)\nat android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)\nat android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\nat android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1609)\nat android.database.sqlite.SQLiteDatabase.insertOrThrow(SQLiteDatabase.java:1505)\nat com.evernote.android.job.JobStorage.store(JobStorage.java:243)\nat com.evernote.android.job.JobStorage.put(JobStorage.java:125)\nat com.evernote.android.job.JobManager.schedule(JobManager.java:231)\nat com.evernote.android.job.JobRequest.schedule(JobRequest.java:366)\nat com.evernote.android.job.JobRescheduleService.onHandleIntent(JobRescheduleService.java:60)\nat android.app.IntentService$ServiceHandler.handleMessage(IntentService.java:66)\nat android.os.Handler.dispatchMessage(Handler.java:102)\nat android.os.Looper.loop(Looper.java:158)\nat android.os.HandlerThread.run(HandlerThread.java:61). Another crash log from May 2nd, v1.10, Android 6.0 LGG3\n\nandroid.database.sqlite.SQLiteConstraintException: UNIQUE constraint failed: jobs._id (code 1555)\nin at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(SQLiteConnection.java).nativeExecuteForLastInsertedRowId\n    at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:926)\n    at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\n    at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1581)\n    at android.database.sqlite.SQLiteDatabase.insertOrThrow(SQLiteDatabase.java:1477)\n    at com.evernote.android.job.JobStorage.store(JobStorage.java:243)\n    at com.evernote.android.job.JobStorage.put(JobStorage.java:125)\n    at com.evernote.android.job.JobManager.schedule(JobManager.java:231)\n    at com.evernote.android.job.JobRequest.schedule(JobRequest.java:366)\n    at com.evernote.android.job.JobRescheduleService.onHandleIntent(JobRescheduleService.java:60)\n    at android.app.IntentService$ServiceHandler.handleMessage(IntentService.java:66)\n    at android.os.Handler.dispatchMessage(Handler.java:102)\n    at android.os.Looper.loop(Looper.java:148)\n    at android.os.HandlerThread.run(HandlerThread.java:61). I will continue to monitor this. It's is a rare occurrence in my apps user base so it may be a while before I know for certain if it's fixed or not. . I have it out to about 130000 users at this time. I will scrub through my crash reports in a bit to see if it's gone.  . I just checked and I have 4 crashes with this error on 1.11-SNAPSHOT vs previous versions total of 755.\nAndroid 5.1:\nandroid.database.sqlite.SQLiteConstraintException: \n  at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(SQLiteConnection.java:0)\n  at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:788)\n  at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)\n  at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\n  at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1471)\n  at android.database.sqlite.SQLiteDatabase.insertOrThrow(SQLiteDatabase.java:1367)\n  at com.evernote.android.job.JobStorage.store(JobStorage.java:243)\n  at com.evernote.android.job.JobStorage.put(JobStorage.java:125)\n  at com.evernote.android.job.JobManager.schedule(JobManager.java:231)\n  at com.evernote.android.job.JobRequest.schedule(JobRequest.java:366)\n  at com.evernote.android.job.JobRescheduleService.onHandleIntent(JobRescheduleService.java:60)\n  at android.app.IntentService$ServiceHandler.handleMessage(IntentService.java:65)\n  at android.os.Handler.dispatchMessage(Handler.java:102)\n  at android.os.Looper.loop(Looper.java:211)\n  at android.os.HandlerThread.run(HandlerThread.java:61)\nAndroid 5.0:\nandroid.database.sqlite.SQLiteConstraintException: \n  at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(SQLiteConnection.java:0)\n  at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:791)\n  at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)\n  at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\n  at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1501)\n  at android.database.sqlite.SQLiteDatabase.insertOrThrow(SQLiteDatabase.java:1397)\n  at com.evernote.android.job.JobStorage.store(JobStorage.java:243)\n  at com.evernote.android.job.JobStorage.put(JobStorage.java:125)\n  at com.evernote.android.job.JobManager.schedule(JobManager.java:231)\n  at com.evernote.android.job.JobRequest.schedule(JobRequest.java:366)\n  at com.evernote.android.job.JobRescheduleService.onHandleIntent(JobRescheduleService.java:60)\n  at android.app.IntentService$ServiceHandler.handleMessage(IntentService.java:65)\n  at android.os.Handler.dispatchMessage(Handler.java:111)\n  at android.os.Looper.loop(Looper.java:194)\n  at android.os.HandlerThread.run(HandlerThread.java:61)\nand 2 on Android 6.0:\nandroid.database.sqlite.SQLiteConstraintException: \n  at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(SQLiteConnection.java:0)\n  at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:789)\n  at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)\n  at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\n  at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1501)\n  at android.database.sqlite.SQLiteDatabase.insertOrThrow(SQLiteDatabase.java:1397)\n  at com.evernote.android.job.JobStorage.store(JobStorage.java:243)\n  at com.evernote.android.job.JobStorage.put(JobStorage.java:125)\n  at com.evernote.android.job.JobManager.schedule(JobManager.java:231)\n  at com.evernote.android.job.JobRequest.schedule(JobRequest.java:366)\n  at com.evernote.android.job.JobRescheduleService.onHandleIntent(JobRescheduleService.java:60)\n  at android.app.IntentService$ServiceHandler.handleMessage(IntentService.java:66)\n  at android.os.Handler.dispatchMessage(Handler.java:111)\n  at android.os.Looper.loop(Looper.java:207)\n  at android.os.HandlerThread.run(HandlerThread.java:61)\nandroid.database.sqlite.SQLiteConstraintException: \n  at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(SQLiteConnection.java:0)\n  at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:786)\n  at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)\n  at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\n  at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1471)\n  at android.database.sqlite.SQLiteDatabase.insertOrThrow(SQLiteDatabase.java:1367)\n  at com.evernote.android.job.JobStorage.store(JobStorage.java:243)\n  at com.evernote.android.job.JobStorage.put(JobStorage.java:125)\n  at com.evernote.android.job.JobManager.schedule(JobManager.java:231)\n  at com.evernote.android.job.JobRequest.schedule(JobRequest.java:366)\n  at com.evernote.android.job.JobRescheduleService.onHandleIntent(JobRescheduleService.java:60)\n  at android.app.IntentService$ServiceHandler.handleMessage(IntentService.java:66)\n  at android.os.Handler.dispatchMessage(Handler.java:102)\n  at android.os.Looper.loop(Looper.java:234)\n  at android.os.HandlerThread.run(HandlerThread.java:61). Yes, it is likely a older snapshot build - this release has been out for several days already.  Won't be releasing a new build for a week or more though so will have to wait and see.. Seems ok here as well.  . I'm not seeing this exception in the Play store reports any more. Seems to be fixed :). Hmm, no, I cannot think of a better way of handling it.  I suppose all I can do it catch that exception in my app and display an error message.  Without the Jobs running my app is useless, may a well throw a big red warning triangle :). My apologies for not updating this sooner   I have not seen this reported in the store in recent weeks. Issue seems fixed. . Looks like the issue is back.  I'm seeing it reported with the latest RC of v1.2. I have created a new issue with the crash logs. . The WorkManager library is still very much alpha and has been very buggy, especially with periodic jobs. I strongly suggest staying with the default android-job implementation for now. I certainly am . I see Xposed framework in your log.  Whenever I see it in any crash reports for my app I usually ignore the crash report. Xposed interferes with the proper functioning of android APIs and I have spent many hours chasing bugs just to bump into Xposed being the culprit. I wonder if if is here as well?. I thought the same but then it would fail on all devices running 6+ and it doesn't.. I have not seen reports of it with other jobs in the app - I have 4 different ones - Weather, Stocks, News and Tasks - but not all users use all of them and I have not personally been able to reproduce it. This was just brought to my attention yesterday.\nAndroid 8.0 (latest security update) on a Nexus 6P using Nova Launcher.\nThe code that schedules the periodic job is called from a 3 places in the app - in the app's onCreate(), when the users changes the refresh interval in settings and when the user select to Reset the update jobs in help.  All call the following method that uses setUpdateCurrent(true) to ensure only one instance of the job is scheduled. \npublic static void schedulePeriodicUpdate(Context context) {\n    long interval = Preferences.weatherRefreshIntervalInMs(context);\n    if (interval == 0) {\n        // We are set to manual update, don't schedule a periodic job, cancel any existing ones\n        JobManager jm = JobManager.instance();\n        jm.cancelAllForTag(JOB_TAG_PERIODIC);\n        return;\n    }\n\n    boolean wifiOnly = Preferences.weatherDownloadOverWiFiOnly(context);\n    int jobId = new JobRequest.Builder(JOB_TAG_PERIODIC)\n            .setRequiredNetworkType(wifiOnly\n                    ? JobRequest.NetworkType.UNMETERED\n                    : JobRequest.NetworkType.CONNECTED)\n            .setUpdateCurrent(true)\n            .setRequirementsEnforced(true)\n            .setPeriodic(interval, interval / 2)\n            .build()\n            .schedule();\n\n    Log.v(TAG, \"Scheduled a periodic Weather update job with id = \" + jobId);\n}  . Update: We are still working our way through several versions of our app to find the point at which this problem started.  It will take a few more days.\n\nSide note: I have noticed instability on my own device with 1.2.1-SNAPSHOT.  I have now reverted to 1.2.0 and things seem more stable. I will monitor for a couple of days as well and provide feedback.. Ignore my instability statement.  It is possibly related to an issue in the new version of OKHttp.  Still investigating.. Update: We are a step closer to finding the release when the issue started.  It seems to be the release where I switched from v1.2.0-RC5 to v1.2.0 final. In the same release I also updated Play Services from 11.4.0 to 11.4.2.  \nI have reverted both changes (back to RC5 and 11.4.0) and sent new test APK to the user - if the problem goes away, it is one of those two things.  . It seems that reverting to RC5 from final solves the problem. We will however try one more time to validate the problem occurs with final.\nUnfortunately it seems that the 1.2 dev branch no longer exists so I cannot check what was changed between RC5 and final. I don't recall the details either. . Update: Seems this particular user turns off their data for long periods of time and the problem occurs when they turn their data back on again.  I suspect it may be an issue with the re-scheduling of the job when it tried running but the network is not available.  Any thoughts?. Ralf, I have invited you to the repository (https://github.com/DvTonder/Chronus/invitations). You will find the class in question, WeatherUpdateJob under the weather package.\nI think I may have found a pattern but not 100% sure. The filtered log is here -> https://pastebin.com/A3tRfu4N\nLook for the \"The location has changed, schedule an update\" text (I split the multiple executions for easy read).  Seems the issue is in the location change detection code.  Would appreciate your thoughts on how to optimize this class to work with android-job.. If the location is invalid on the start of the job we schedule a location listener that, on location change, schedules a manual job.  Now that I think about it, that is a manual job triggering from within a periodic job, probably causing the job loop.... I'm double checking and have made some changes to our code to try and prevent the occurance. In testing now. I will know for sure in a few days but yes, it is likely an error on our part and not in the library.. This appears to have been an issue on our side. Closing the issue. . Yes, I have my onRunJob() method set as synchronized. \n\npublic class NewsFeedUpdateJob extends Job {\n    public static class Creator implements JobCreator {\n        @Override\n        public Job create(String tag) {\n            switch (tag) {\n                case JOB_TAG_PERIODIC:\n                case JOB_TAG_MANUAL:\n                case JOB_TAG_MARK_ALL_AS_READ:\n                    return new NewsFeedUpdateJob();\n            }\n            return null;\n        }\n    }\n\n@NonNull\n@Override\nprotected synchronized Result onRunJob(Params params) {\n    // Job code runs in here\n\n    // When the job processing is done ...\n    if (hasFailure) {\n        return manual ? Result.FAILURE : Result.RESCHEDULE;\n    }\n    return Result.SUCCESS;\n}\n\npublic static void scheduleManualUpdate(Context context, int widgetId, boolean force, boolean clearCache) {\n    PersistableBundleCompat extras = new PersistableBundleCompat();\n    extras.putBoolean(EXTRA_FORCE, force);\n    extras.putBoolean(EXTRA_MANUAL, true);\n    extras.putInt(EXTRA_WIDGET_ID, widgetId);\n    extras.putBoolean(EXTRA_CLEAR_CACHE, clearCache);\n    new JobRequest.Builder(JOB_TAG_MANUAL)\n            .setUpdateCurrent(true)\n            .startNow()\n            .setExtras(extras)\n            .build()\n            .scheduleAsync(new JobRequest.JobScheduledCallback() {\n                @Override\n                public void onJobScheduled(int jobId, @NonNull String tag, @Nullable Exception exception) {\n                    if (DebugFlags.NEWS_DEBUG) {\n                        Log.d(TAG, \"Scheduled a manual News feed sync job with id = \" + jobId);\n                    }\n                }\n            });\n}\n\npublic static void schedulePeriodicUpdate(Context context) {\n    long interval = Preferences.newsFeedRefreshIntervalInMs(context);\n    boolean wifiOnly = Preferences.newsFeedDownloadOverWiFiOnly(context);\n    new JobRequest.Builder(JOB_TAG_PERIODIC)\n            .setRequiredNetworkType(wifiOnly\n                    ? JobRequest.NetworkType.UNMETERED\n                    : JobRequest.NetworkType.CONNECTED)\n            .setRequirementsEnforced(true)\n            .setUpdateCurrent(true)\n            .setPeriodic(interval, interval / 2)\n            .build()\n            .scheduleAsync(new JobRequest.JobScheduledCallback() {\n                @Override\n                public void onJobScheduled(int jobId, @NonNull String tag, @Nullable Exception exception) {\n                    Log.v(TAG, \"Scheduled a periodic News feed sync job with id = \" + jobId);\n                }\n            });\n}\n\n}\n. Quick question: if I remove the synchronized from my onRunJob() method, would it address the issue and allow me to use 1.2.5?  . Is the issue that the previous jobs were not cancelled before switching and therefore still exist / trigger the call via reflection?. I have a version of my app using native workmanager and find it very buggy still. Using Android Job with workmanager disabled is the most stable configuration in my experience. . Don't use workmanager yet, it is not stable. I use this library, without workmanager, on >1million installs and it works great. . ",
    "BlacKCaT27": "Thanks. \nAlso, regarding my comment on Params not supporting parcelables... Was that an intentional design decision or just something no one talked about yet? Seems like it would be very handy since parcelables are already how Android allows clients to pass objects, so lots of objects already support them. That, or just allowing Params to store objects that could be cast, though this comes with its own set of challenges.\nShould I open a separate ticket for discussion?\n. Sorry, I must not have been clear.\nIm not suggesting that Params implement parcelable. I'd like to be able to\npack a parcelable object INTO a Params object, just like a string, int,\netc.\nI do see that Params accepts some Compat form of bundle, but that doesn't\nappear to support packing parcelables either.\nOn May 4, 2016 12:10 PM, \"Ralf\" notifications@github.com wrote:\n\nWhy is it necessary to make them implement the Parcelable interface? The\nparameters should be only interesting for your actual job. I don't see a\nuse case. If you want to pass them to another Service or Activity, then\nyou should add the arguments in a new Bundle.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/evernote/android-job/issues/30#issuecomment-216915167\n. \n",
    "Kpeved": "I agree with this completely. That's the point that it should decide when to start it. But at pre-5 android task is definitely wouldn't run before this period is passed. Because time, when it should run firs time, is set to System.currentTimeMillis() + request.getIntervalMs(). \nProblem is in initialization of AlarmManager tasks, not in JobScheduler.\n. ",
    "Arash-gm": "@vRallev : Thank you for rapid response , closing the app by throwing away from task manager even the app main service is on. i'm logging the runnig task on : \n```\n@NonNull\n@Override\nprotected Result onRunJob(Params params) {\nHandler handler = new Handler(ApplicationClass.getContext().getMainLooper());\nhandler.post(new Runnable() {\n    @Override\n    public void run() {\n        Toast.makeText(ApplicationClass.getContext(),\"Job is Running\",Toast.LENGTH_SHORT).show();\n        Log.d(\"AppJob :\" ,\"is Running\");\n        Log.d(\"JobCount :\" , String.valueOf(JobManager.instance().getAllJobRequestsForTag(AppJob.TAG).size()));\n\n    }\n});\nreturn Result.SUCCESS;\n\n}\n``````\nand after clearing Task manager no log or toast showing.\n. ",
    "miroslavign": "My bad, \n.setExact(msStart)  <- time in millis should be OFFSET not exact time in future expressed in millis\n. ",
    "JosefHruska": "Ultimately I solved my issue. I'm newbie in android development... I moved JobManager.create() to Application class instead of MainActivity class. The problem was that I didn't realized the exact difference between Activity and Application class. \nAnyway, thank you for this great  library which you make. :)\n. ",
    "TurKurT656": "I saw the close issues. Sorry for quick openning issue.\nSo I have another question:\nCan u add a method to periodicJob that when it scheduled, there can be a way to run first second that scheduled?\nSorry for bad English\n. i think u didnt know what i mean. i dont want to change the interval time of schedule. \ni mean when user run a job (ex: by clicking a button) jub runs at first second and then after 60second run again and after 60sec run again and so on.\nAgain sorry for bad English\n. Yes, my data saved to my database before this notification in onRunJob()\n. ",
    "kuno": "@vRallev \nThanks will try that.\n. Another question is If the app was recovered from a crash, is it possible to stop all previous running jobs during the startup ?\n. If my understanding was not wrong, with JobManager#cancelAllForTag(tag), I dont need to save jobId reference any more ?\n. BTW:  I am testing it on an Emulaor, it showing following logs\n11-08 17:43:20.189 2106-2106/com.starbucks.cn I/dalvikvm: Could not find method android.app.AlarmManager.setExactAndAllowWhileIdle, referenced from method com.evernote.android.job.v14.JobProxy14.setAlarm\n11-08 17:43:20.199 2106-2106/com.starbucks.cn I/dalvikvm: Could not find method android.app.AlarmManager.setExact, referenced from method com.evernote.android.job.v14.JobProxy14.setAlarm\n. @vRallev \nWhat ? Do you mean neither 1.0.13 or 1.0.15 wont work for Android N?\n. @vRallev \nSo with 1.1.2 is not possible to run a periodic job for every 1 mintue ?\nI just upgraded to 1.1.2 in my app, the new  behaviors of the jobs surprised me, Can you explain a litter bit in details for me ?\n. @vRallev \nAnother behavior changing I noticed that with v1.0.7 There will be an immediate job running right after job was scheduled.\nBut with 1.1.2, it will not run right after scheduled.\n. @vRallev \nI am going to try 1.1.2 to see if it can solve my problem first. \nClosing the ticket for now.\nThanks for you help.\n. Sorry, it version 1.0.15  in our case.\nDo you mean if user did not properly cancel the jobs, under such condition, if they were updated to new version. Those jobs will still try to run even without code to start them ?\nIf we remove the the library and all Job Classes completed, will this solve the problem ?. Sorry, for some reason the apk was not build by us, so we can not give you the Dexguard mapping file.\nIf I am not wrong, Are you saying the only way to prevent crash is to manually call JobManager.instance().cancelAll() in the app. Is this right ?\nWhat if I removed this library totally from my project, will this prevent the crash ?\n. @vRallev \nThanks, but I want to double check it:\n Please confirm that  remove the library completely will solve this issue. \n. @vRallev\nunderstood. Thanks a lot. @nguyenvp08 \nThanks for the contribution.\nI didn't use this lib but has same crash on my app. If this fix been proved, Can I copy and paste this snippet into my own app?. ",
    "tprochazka": "What is the status of this issue? It was closed, then reopened.. It's quite serious issue. Because if your app is running on background with scheduled periodic job. And PlayServices will be updated or application itself. Periodic task will not run anymore until user open the app manually.  Override onInitializeTasks() helps to solve the issue when GcmNetworkManager is used. But it doesn't helps in situation when just the AlarmManager is used.. As I know normally it is not a issue. Normal phone doesn't kill alarms or services after swipe out from recent task. But some phones do that as I know for example Xiaomi phones. I tested Nexus, Sony Z4+ and also Huawei works correctly. But Huawei with A6 kill all the alarms after some time automatically, based on package name of the app. If app id contains words like clock, alarm, calendar, everything is OK, but if no, Huawei simply kill everything, also GCMTaskManager doesn't work here. Most probably theirs white-list is more complex. But if you are not lucky there is no way to run periodic tasks on Huawei with A6.. Yes. Just do not bought Huawei ;-) I think that Google should forbid this type of changes brooking framework/SDK functionality.  And don't provide certification for such broken ROMs. But this is different story.. I will test 1.2.7 in our app.\nIs the fix solution based on the same thing like this one?\nhttps://github.com/optimizely/android-sdk/issues/194. We have a lot of ANR caused by calling shedule()\nat android.database.sqlite.SQLiteConnection.nativeExecuteForChangedRowCount (Native method)\n  at android.database.sqlite.SQLiteConnection.executeForChangedRowCount (SQLiteConnection.java:742)\n  at android.database.sqlite.SQLiteSession.executeForChangedRowCount (SQLiteSession.java:754)\n  at android.database.sqlite.SQLiteStatement.executeUpdateDelete (SQLiteStatement.java:64)\n  at android.database.sqlite.SQLiteDatabase.delete (SQLiteDatabase.java:1543)\n  at com.evernote.android.job.JobStorage.a (JobStorage.java:241)\n  at com.evernote.android.job.JobStorage.b (JobStorage.java:230)\n  at com.evernote.android.job.JobManager.b (JobManager.java:400)\n  at com.evernote.android.job.JobManager.d (JobManager.java:422)\n- locked <0x0857ef4d> (a com.evernote.android.job.JobManager)\n  at com.evernote.android.job.JobManager.c (JobManager.java:393)\n  at com.evernote.android.job.JobManager.a (JobManager.java:183)\n- locked <0x0857ef4d> (a com.evernote.android.job.JobManager)\n  at com.evernote.android.job.JobRequest.D (JobRequest.java:436)\nIs it related to this fix?\nOr just scheduleAsync() should help in this case?\nBut we are running schedule() from background thread now.\nReport is from version 1.2.5. ",
    "kaushikgopal": "Nope that's good to know \ud83d\udc4d. Thanks\n. ",
    "tomblenz": "Cheers for the info, that makes a lot of sense.\nRe: my #2 suggestion... I'm not saying it skips the scheduling process, rather that it enqueue it for the next possible execution window, at the discretion of the manager.  Like specifying an execution window of 1 milliseconds to a bajillion milliseconds.\n. But a period job would then continue to execute periodically, you'd need to manually cancel it after it has completed the job?  I feel like we're each thinking about something different\n. ",
    "PaNaVTEC": "Thanks your quick reply! I'm running in the DemoJob:\nCaptioningManager captioningManager = (CaptioningManager) getContext().getSystemService(Context.CAPTIONING_SERVICE);\nAnd I get:\n05-25 11:15:39.154 16136-16740/com.evernote.android.job.demo E/JobExecutor: Crashed job{id=3, finished=true, result=FAILURE, canceled=false, periodic=false, class=DemoJob, tag=job_demo_tag}\n                                                                            java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()\n                                                                                at android.os.Handler.<init>(Handler.java:200)\n                                                                                at android.os.Handler.<init>(Handler.java:114)\n                                                                                at android.view.accessibility.CaptioningManager.<init>(CaptioningManager.java:55)\n                                                                                at android.app.ContextImpl$3.getService(ContextImpl.java:422)\n                                                                                at android.app.ContextImpl.getSystemService(ContextImpl.java:2072)\n                                                                                at android.content.ContextWrapper.getSystemService(ContextWrapper.java:552)\n                                                                                at com.evernote.android.job.demo.DemoJob.onRunJob(DemoJob.java:26)\n                                                                                at com.evernote.android.job.Job.runJob(Job.java:109)\n                                                                                at com.evernote.android.job.JobExecutor$JobCallable.runJob(JobExecutor.java:139)\n                                                                                at com.evernote.android.job.JobExecutor$JobCallable.call(JobExecutor.java:120)\n                                                                                at com.evernote.android.job.JobExecutor$JobCallable.call(JobExecutor.java:98)\n                                                                                at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n                                                                                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n                                                                                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n                                                                                at java.lang.Thread.run(Thread.java:841)\n. I changed the code of the library and I'm using a HandlerThread in both PlatformAlarmService and PlatformJobService and the problem seems to be gone. If you agree with this change, I can create a PR\n. I'm running that exact piece of code in a Galaxy S4 mini with 4.4.2\n. @vRallev If you just do in the Job\nnew Handler(); \nis crashing as well, I can reproduce it a Genymotion with 4.4.4:\njava.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()\n                                                                              at android.os.Handler.<init>(Handler.java:200)\n                                                                              at android.os.Handler.<init>(Handler.java:114)\n                                                                              at com.evernote.android.job.demo.DemoJob.onRunJob(DemoJob.java:27)\nThis is not a platform issue, this is an issue that you can reproduce in any device < API 21 and is because the background thread that you are creating does not have a Looper attached, so when you create a Handler inside is getting myLooper which is null. In Api > 21 they changed the implementation of the CaptioningManager and they are getting the handler with new Handler(context.getMainLooper()) so it is not crashing. \nyou should attach a Looper inside the Thread in APIs < 21 if you want the same behaviour. I thought the aim of this library was just that, to have an scheduler that works the same in API pre 21.\n. ",
    "zegnus": "@vRallev Are you planning to solve this issue?\n. @jess-anders The problem is that the one who is creating the handler is the android framework, crashing on < 21\nCaptioningManager captioningManager = (CaptioningManager) getContext().getSystemService(Context.CAPTIONING_SERVICE);\n. ",
    "spatrickapps": "Updated\n. ",
    "kkbhav": "Hello,\nMy requirement is to schedule the same job if some extra parameters meets the condition. \nSo for that I need the JobRequest object for the conditions that were specified when it was first scheduled, for e.g. requiresCharging parameter or conditionsEnforced parameter\n. Hi, \nI tried the Snapshot build and it was working perfectly satisfying all the requirements.\nThank you for extending the Params API.\nPlease let me know when you update the library.\n. ",
    "ened": "@vRallev looking good, just tested it on a few scenarios and works well!\n. ",
    "nbonavia": "Do you have an ETA on when this fix will be available on production. I'm currently building a scheduler and this fix is the determining factor of whether I'll use this library or not.\n. Sorry for the late reply. I confirm that the 1.0.8 release fixes the issue, and the fact that the last 20 finished jobs are being cached gives an added potential to the solution as there is a limited time where one can reference a finished job.\n. fair enough, thanks for the clarification.\n. ",
    "MRezaNasirloo": "Thanks for response.\nMy bad. One of our team members accidently had deleted the compile 'com.google.android.gms:play-services-gcm:8.4.0' line from the gradle file.\n. ",
    "latsson": "Why does the readme for this project not mention that you need this dependency?. Well, it works for me without the dependency on Android 4.4, but I need it on Android 7.1.1, otherwise I will get Caused by: java.lang.ClassNotFoundException: Didn't find class \"com.google.android.gms.gcm.GcmTaskService\". Interesting, I have attached the log file. First a info/warning then it crashes.\nevernote_android-job_gcm_error.txt\n. Thank you I will test it! \ud83d\udc4d  I used Firebase JobDispatcher with that dependency before, but had to switch to evernote android-job due to I don't have Google Play Services installed on all internal devices we use.. There is no crash, but I can still see the ugly stacktrace coming from the following line: https://github.com/evernote/android-job/blob/1dfcca57615f80bd816bae0b8e19df04889a0d56/library/src/main/java/com/evernote/android/job/util/GcmAvailableHelper.java#L55\nI can see the comment \"still sometimes seeing a NoClassDefFoundError here\". Do you have to log the whole throwable object? Thanks for the help.. ",
    "imran0101": "@vRallev Yes.\njobManager.getJobRequest(jobId);\nNullPointerException if the jobId is invalid at jobRequest.isTransient()\n. ",
    "ghost": "It works now. Did not work while I posted with a '+' as the version identifier in the gradle. With the 1.0.10 it is working. \n. ",
    "ha-D": "I attach the the Jobcreator once my library is initialized. The problem is my library isn't necessarily initialized in Application.onCreate,  the user can initialize it in any arbitrary place, such as Activity.onCreate.\n. ",
    "akramShokri": "If for example I call JobCreator in Activity.onCreate, the JobManager will call my JobCreator form then on and jobs are scheduled and run. The problem is when application is not running, this exception (IllegalStateException) is raised. I may initialize JobCreator in a service so as it exists even when app is closed but if user force-close the app, this exception will happen again. \nAs I cannot prevent occurrence of this exception in this scenario, I need this exception to not happen. At least even f my jobs are not running, the app still can have its normal behaviour.\n@vRallev \n. Thanks for update. It is really helping.\nBy the way, I am curious about a solution that completely resolve this issue. I mean while google gcmNetworkManager has no problem even when the app which is using it for scheduling its task is closed; it seems to me that this problem can be completely avoided here too. Maybe by relying on some sort of permanent storage (like SharedPref, a file or DB) for handling jobs when AlarmManager is used for scheduling jobs. \nAm I correct or there is some other consideration that I missed?\n. I am experiencing similar issue. I used periodic task. The task is not dependent on network or charging or anything. It is just scheduled to run every 10 minutes. But it is killed after a while. For example, in a recent test, it worked for 15 hours and then stops completely. In another run, it worked for 2 hours and then suddenly stopped. \nMy app is using services and broadcast send/receiver. Does library has any issue with them?\n@vRallev \n. @vRallev \nI tried to copy the .db file from the same device which I reported its problem before. But it was not successful. And about power saving mode: the device was not enabled power saving mode and it is always disabled on our test devices (as it interferes with functionalities we are testing).\n. @vRallev I am using several devices for test.\n- Sumsung s4 with android 5.0.1\n- Sumsung A500H with android 5.0.2\n- LG Nexus 4 with android 5.1.1\nin S4 device (which I reported its task stopped in my first post as a sample) power saving mode is disabled from: settings->my device->power saving mode is disabled.\nMy first post referred to a four-day run log. As I am changing and deploying my app constantly, I do not have such log right now. If you explain what information you need as log, I will try to provide it.\nPS: It seems that it works flawlessly on Sumsung GT-I9105P device with android 4.2.2\n. Well, it doesn't matter that jobs are inexact. I just need them to keep working as long as they are not canceled. I don't think that android is killing my process but to be sure, I will check it. Thanks.\n. Thanks.\nI am using version 1.0.13 of job-library (so as I can have periodic tasks with less than 15m intervals). Seems that getConfig() is not availbale in this version?\n. Thanks. That was it.\n. @vRallev \nI was going to use this receiver that is added in release 1.1.3, but I am a bit confused. \nIt seems that that new mechanism is that when system reboots, evernote-job library got informed and loads the reciver class that we implement in our app to instanciate JobCreator. \nIs it correct?\nIf so, can I just add a reciver for boot_complete and initialize JobCreator in it? I think if it is the behaivour it cannot solve the problem of Jobs being killed when app is closed.\nBy the way, I would like to add a request here too: \n- Please add some more info in readMe to explain what is the difference beween 1.0.x and 1.1.x relases. It gets kind of confusing and new users have to figure it out themselves.\n- I added my above question from reading your commit for release 1.1.3. It will be very helping if you add a doc on how to use this reciever and how it works.\nMany thanks for your supports.\n. Thanks. I saw the sample in faq, but I wanted to know how it works. My library already has a boot_complete receiver and I wanted to know if the behaivour is the same, so as I can do the initialization of JObCreator myself (I rather prefer to avoid another reciever in my library). \nSo please let me know:\n- If I use this receiver I can remove my JobCreator intilization and rely totally on the receiver (currently I am initializing JobCreator in a service)?\n- Does the reciver get notified everytime that Jobcreator is destroyed and tries to reinitilize it? or it just tries to initilize it on certain events (when app opened or when device reboots)?\n- How the reciever get called when my app (the app using my library to be precise), is started?\n  I understand that the provided sample is enought to use the receiver, but as some important functionalities of my lib are depending on evernote-job-library, I need to know how it works to avoid potential problems.\n  @vRallev \n. If you don't use gradle for fetching dependencies and you manually inclued evernote-job library aar file in your project, this error can haapen. You need to manually include cat library in your project too.. @vRallev Yes, I use proguard too. In fact we provide our library for different development environments (including eclipse, android studio, unity and cordova) and so we need to provide offline form of dependencies too.. @amalive \nYou can check gradle cache path which is .gradle/caches/modules-2/files-2.1 and try to find net.vrallev.android in this directory. If it doesn't exist, your gradle have a problem with fetching dependencies (maybe internet connection or proxy setting problem).. You can add jar file of android-job and cat libraty to your project.. Would you please elaborate a bit on this problem? \nI am using exponential backoff withouth setExact and I need to know should I update my code with new version or not.\nThanks. . Yes, very helpful.\nThank you.\n. Seems that my problem was related to support-v4.jar library. I am using some version before 25.0.0 and it seems there are significant changes from 24 to 25.\nI don't know whether the error log which I posted is related to support library or not (it does not cuse force stop of app) but in my case support library being lower than 25 is preventing library from working properly.. setEnabledSetting:ComponentInfo{<appPackageName>/com.evernote.android.job.gcm.PlatformGcmService} newState:1\n                                                                                  java.lang.Exception: setComponentEnabledSetting\n                                                                                      at android.app.ApplicationPackageManager.setComponentEnabledSetting(ApplicationPackageManager.java:1527)\n                                                                                      at com.evernote.android.job.util.GcmAvailableHelper.setServiceEnabled(GcmAvailableHelper.java:119)\n                                                                                      at com.evernote.android.job.util.GcmAvailableHelper.isGcmApiSupported(GcmAvailableHelper.java:46)\n                                                                                      at com.evernote.android.job.util.JobApi.isSupported(JobApi.java:99)\n                                                                                      at com.evernote.android.job.JobProxy$Common.cleanUpOrphanedJob(JobProxy.java:237)\n                                                                                      at com.evernote.android.job.JobManager.schedule(JobManager.java:225)\n                                                                                      at com.evernote.android.job.JobRequest.schedule(JobRequest.java:349)\nThis error happened again in an android studio app, which uses the latest support library and build tools. This won't crash the app, but JobScheduler will not work and therfore my library stops working. I am using v1.1.5 of your library. \nDo you have any suggestion?. Yes, google play service is installed and I have some other apps using my library which are working properly on this device. \nUnfortunately this error message happens when my library tries to schedule a job and after this message, no job would run.. It is misterious for me too, because the same lib works fine on many different apps but these few cases have this problem. \nHere is the full stacktrace:\nW/ApplicationPackageManager: setEnabledSetting:ComponentInfo{<APP-PACKAGE-NAME>/com.evernote.android.job.gcm.PlatformGcmService} newState:1\n                                                                                  java.lang.Exception: setComponentEnabledSetting\n                                                                                      at android.app.ApplicationPackageManager.setComponentEnabledSetting(ApplicationPackageManager.java:1527)\n                                                                                      at com.evernote.android.job.util.GcmAvailableHelper.setServiceEnabled(GcmAvailableHelper.java:119)\n                                                                                      at com.evernote.android.job.util.GcmAvailableHelper.isGcmApiSupported(GcmAvailableHelper.java:46)\n                                                                                      at com.evernote.android.job.util.JobApi.isSupported(JobApi.java:99)\n                                                                                      at com.evernote.android.job.JobProxy$Common.cleanUpOrphanedJob(JobProxy.java:237)\n                                                                                      at com.evernote.android.job.JobManager.schedule(JobManager.java:225)\n                                                                                      at com.evernote.android.job.JobRequest.schedule(JobRequest.java:349)\n                                                                                      at <MY-LIB-PACKAGE>.task.scheduler.a.c.a(Unknown Source)\n                                                                                      at <MY-LIB-PACKAGE>.task.d.a(Unknown Source)\n                                                                                      at <MY-LIB-PACKAGE>.task.d.a(Unknown Source)\n                                                                                      at <MY-LIB-PACKAGE>.c.a.o.a(Unknown Source)\n                                                                                      at <MY-LIB-PACKAGE>.MYLIB.d(Unknown Source)\n                                                                                      at <MY-LIB-PACKAGE>.MYLIB.a(Unknown Source)\n                                                                                      at <MY-LIB-PACKAGE>.MYLIB.initialize(Unknown Source)\n                                                                                      at <APP-PACKAGE-NAME>.GoToLoginDesign.onCreate(GoToLoginDesign.java:47)\n                                                                                      at android.app.Activity.performCreate(Activity.java:6039)\n                                                                                      at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1106)\n                                                                                      at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2298)\n                                                                                      at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2407)\n                                                                                      at android.app.ActivityThread.access$700(ActivityThread.java:155)\n                                                                                      at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1317)\n                                                                                      at android.os.Handler.dispatchMessage(Handler.java:102)\n                                                                                      at android.os.Looper.loop(Looper.java:135)\n                                                                                      at android.app.ActivityThread.main(ActivityThread.java:5298)\n                                                                                      at java.lang.reflect.Method.invoke(Native Method)\n                                                                                      at java.lang.reflect.Method.invoke(Method.java:372)\n                                                                                      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:911)\n                                                                                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:706)\n. No, I have disabled Cat logs in my lib so there is no other log except for this error message.. Ok, it's fine.\nThank you.. @vRallev \nSo,\u00a0JobApi.setForceAllowApi14(true)\u00a0in v 1.2.+ it should become\u00a0JobConfig.setForceAllowApi14(true)\nBut what to set instead of\u00a0jobManager.getConfig().setGcmApiEnabled(false)\u00a0to have the same effect? I found JobConfig.forceApi() but what object needed to send to it.. I have this error log on android 4.2.2 and my job is not get running on this device:\nCould not find class 'com.evernote.android.job.v21.PlatformJobService', referenced from method com.evernote.android.job.a.c.a\nW/dalvikvm: VFY: unable to resolve const-class 2586 (Lcom/evernote/android/job/v21/PlatformJobService;) in Lcom/evernote/android/job/a/c;\n W/dalvikvm: Unable to resolve superclass of com/evernote/android/job/v21/PlatformJobService; (81)\n W/dalvikvm: Link of class 'Lcom/evernote/android/job/v21/PlatformJobService;' failed\n E/dalvikvm: Could not find class 'com.evernote.android.job.v21.PlatformJobService', referenced from method com.evernote.android.job.a.c.a\n W/dalvikvm: VFY: unable to resolve const-class 2586 (Lcom/evernote/android/job/v21/PlatformJobService;) in Lcom/evernote/android/job/a/c;\nHow can I resolve it?\np.s: It works when I use v1.1.10. I will try to reproduce it and will get back to you.. @vRallev \n\nWhat should one do to make sure a job runs at about every 60 minutes, for ever?\nThat's not working with Doze on Android anymore. You can try to use an exact job and reschedule it manually every hour, but I also know that this might not work, see\n\nDoes this mean that periodic jobs are stopped while we didn't canceled them and expect them to run? How long will a periodic job run? Is there anyway to know when a periodic job is stopped working?. @vRallev \nExcuse me,  I read below part of your answer and I got worried about my usage of library:\n\nCould it be possible, that you accidentally scheduled multiple periodic jobs? Or could there be an other dynamic where you reschedule jobs? \n\nI am scheduling several periodic jobs with different period (from some hours to 7 days for example). And in some ocassion I reschdule them using the \"replace\" option of jobs so as the job become replaced instead of being created again.\nIs it a wrong approach?\n. ",
    "shgharib": "why?\n. No, it's different issue. please open it.\n. issue updated.\n. ",
    "zoltish": "I can verify that jobs are not running instantaneously as they did before with this. Guess Im playing the waiting game to see when/if it does actually run; but considering that you havent modified that logic it should be fine. \nI cant thank you enough for catching this.\n. ",
    "RustamG": "Hi @vRallev!\nSo how do I set up the request when I don't have an expiration time?\nLet's say I need to schedule a job (show birthday reminder) at 8 AM. And It's ok if the job will be executed by 11 AM (for the sake of battery). In the worst case I need the job to be run till the end of the day or when the device is awake. \nCurrently I'm testing with smaller periods. So my request looks like this:\njava\nnew JobRequest.Builder(SyncBirthdaysJob.JOB_TAG)\n                .setExecutionWindow(120_000L, 240_000L)\n                .setPersisted(true)\n                .setUpdateCurrent(true)\n                .build()\n                .schedule();\nI saw the log saying that the job scheduled at the appropriate window and switched off the phone for 10 minutes. When I turned it on again the period has passed and the job was not executed. But I need it to be done today. \nThe log after device boot:\nJobRescheduleService: Reschedule 0 jobs of 1 jobs\nI tested it on Nexus with Android M.\nCan you suggest how to schedule the job at the time range making sure it is executed even after that period's passed while the phone was switched off or dozing?\nPlease let me know if the goal is not clear enough.\nThanks for the library. Good job!. ",
    "karntrehan": "Yes, we removed the service from the manifest and the app runs fine. Would it have an impact on Android versions < 5? Would the periodic tasks still run as they depend on GCM services?\n. Thank you for the prompt replies.. \nI will be running certain tests on a Kitkat physical device and get back to you with the results.\n. Here is a result of the tests done.. \nAndroid 4.4.2 : Physical device\n08-18 18:16:37.747 3443-3443/app D/JobProxy14: Scheduled repeating alarm, request{id=10, tag=Job}, interval 00:02:00\n08-18 18:18:39.343 3443-5248/app I/JobExecutor: Finished job{id=10, finished=true, result=SUCCESS, canceled=false, periodic=true, class=EarnPartnerJob, tag=Job}\n08-18 18:18:39.346 3443-5247/app D/PlatformAlarmService: Finished job, request{id=10, tag=Job} SUCCESS\nPASSED!\nAndroid 4.1.1 (16) : Emulated Device\n08-18 18:26:31.061 1798-1798/app D/JobProxy14: Scheduled repeating alarm, request{id=10, tag=Job}, interval 00:02:00\n08-18 18:28:31.262 1798-5777/app I/JobExecutor: Finished job{id=10, finished=true, result=SUCCESS, canceled=false, periodic=true, class=EarnPartnerJob, tag=Job}\n08-18 18:28:31.262 1798-5776/app D/PlatformAlarmService: Finished job, request{id=10, tag=Job} SUCCESS\nPASSED!\nWorked well on an Android 4.4.2 as well as 4.1.1 device. Thanks\n. Thanks a lot for the info.. Was this a part of the FAQ and I missed it?\nWill be closing the issue. \n. On first install, we are scheduling 12 jobs which run concurrently the first time they are scheduled. Is this causing an issue? What could be a possible solution?\n. Sorry for not being active on this. \nAs you said, this might not be linked to this library, we are now looking at closing all memory leaks and optimizing our scheduling code. Thanks as always for being prompt.\n. ",
    "commonsguy": "Well, not every device is a Play ecosystem device. There is no sense in having a component enabled in cases where it would never be used. And, on a non-Play ecosystem device, the android:permission may not be as effective, since that permission would not be pre-defined by pre-installed apps. I was trying to strike a balance between \"ease of integration\" and \"keeping the attack surface small\".\n. Ah, OK. Thanks!\n. ",
    "anonymouce": "I had an issue with Fabric Answer Plugin when using on Broadcast receiver. Which said that, the Fabric Instance was not initialized. The initialization is done in the Application class , the same with the Androi-job Creator. Could this be the case .  Haven't tested.\n. ",
    "yudhir": "I have added comments on above code.\nMy own device is Marshmallow Galaxy s6 . When I check services \"DeveloperOptions>Services\" , My app isn't shown. I am not using GCM  or forcing a API (should I ?).   It works for certain times , but later on it stops notifying. Then One thing to Note is that the notification appears after I open the app.  I use Greenfly , but app is excluded , Samsung Smart Manager is turned off.\nOther user complained that the app does nothing , possibly because of the 5 minute delay and In other cases Termination. I don't know exact version they complained on , Most are marshmallow , some lolipop.\n. But exact jobs cannot be repeated periodically isn't it. How do I implement that,using android job.\nI also suspect the job is failing too. Is my cancelling and resuming effecting the library. When the app is fresh, it works okay even after a long time. Its the consequent runs that seem to be  failing.\n. I have changed the Jobs to be setExact(time) , It is working fine  now.\nMainActivity > setsJobsExact()\nJobs > condition? cancelthemselves() :   setsJobExact()\nPowerBroadcastReceiver > setsJobsExact()\n. Yes It can be closed from my side  . Thank you for your help.  Things are working as expected  with the modified code. \n. I was just about to make one issue, 35 seconds ago.\n. ",
    "VictorAlbertos": "I just forgot that the onCreate method is called before running any Service. Because I thought that the onCreate method wasn't called when the Service was started, I couldn't figure out how you were available to instantiate the jobs without using class and reflection.\nThanks :)\n. ",
    "amphora001": "It does work if I exit the app by using the back button, and if I don't restart the phone.\n. Actually I'm running my app on Android 6.0.1, a Samsung Galaxy S5.\n. Ah my bad. I had a bug where I was calling JobManager.cancelAll when the app starts. \n. Thanks so much for the help! Sorry it was my own fault =(\n. 7 of the crash reports are from Lollipop and Marshmallow devices. My understanding was that JobScheduler would be used, so why is it even trying to start this PlatformGcmService?\n. we noticed that in GcmAvailableHelper\nstatic {\n        boolean gcmInClasspath;\n        try {\n            Class.forName(\"com.google.android.gms.gcm.GcmNetworkManager\");\n            gcmInClasspath = true;\n        } catch (Throwable t) {\n            gcmInClasspath = false;\n        }\n        GCM_IN_CLASSPATH = gcmInClasspath;\n    }\ngcmInClasspath was set to false. So we added back\ncompile \"com.google.android.gms:play-services-gcm:${firebaseVersion}\"\nin addition to \ncompile \"com.google.firebase:firebase-messaging:${firebaseVersion}\"\nwhere firebaseVersion is currently set to 9.8.0\nWe've been testing over the weekend and it seems like we still get the crash report. But even for devices that we receive the report from, the user cannot receive that a crash happened, probably because it's trying to start a background service.\n. If I remove the service, wouldn't that mean that I would not have the GCM-based scheduling? That leaves me with just Job Scheduler and Alarm Manager, which is 30% less functionality.\nAlso we haven't really been able to reproduce the issue in house. We only see these issues in the field via Fabric/Crashlytics. I tried your repo steps, but I didn't see any error log in ADB. But I trust your steps are useful in coming up with a resolution. If what you say is true, then it's not a big deal since it would only be an upgrade issue. Once all users are upgraded, then it won't crash anymore.\nWhat we are doing now is adding\ncompile \"com.google.android.gms:play-services-gcm:${firebaseVersion}\"\nand releasing a hot fix release and see if the crash stops. That's what we're going with. But we look forward to what else you may discover. Thanks for investigating and opening this library to the community!\n. I removed it because my understanding is that if you have firebase messaging, then you don't need play-service gcm. But we added it back and released it and we haven't seen any crash reported in the last 48 hrs. Although I feel like maybe there should be some notes on your website concerning gym and firebase-messaging so others don't run into the same problem.\n. ",
    "jemshit": "\nThe AlarmManager sets an alarm to run once during your interval. If you force close the app or swipe it away in the recents list, then all alarms are cleared and your app won't run until the user opens it again. There is no way to trigger a job when that happens.\n\n@vRallev what is the point if this cant run job when app is killed  on Android 4?!\n. AlarmManager runs in background even app is killed from recent history.\n. yes, if force closed, not by clearing it from recent history. Is there any graphic shows in which cases (Android version etc...)  you use AlarmManager, JobScheduler or GcmNetworkManager under the hood ?\n. @vRallev FAQ is not quite explanatory. Job runs in Main thread i guess, and there is async task in it which runs on different thread, so should we still return Result.SUCCESS even async task is not finished running?\n. ",
    "rpattabi": "Is the selection between AM/JS/GCM decided at compile time? I think I would prefer JobScheduler on a Lollipop+ device even if my app supports Jelly Bean. Please correct, if I misunderstood.. If I understand correctly, this answer provides work around for the situations where JobManagerCreateException is thrown. Is that correct? If so, even in 1.2.0, do we still need to (1) force allow api 14 (2) disable GcmApi for Android 4.X as shown above?. A release with the fix for this would be much appreciated.. If I understood the requirement correctly, couldn't it be achieved by running one daily job between 11 to 12, another daily job 12 to 1 and so on?. So this check is required prior to actually scheduling DailyJob\nif (JobManager.instance().getAllJobRequestsForTag(TAG).isEmpty())\n  scheduleDailyJob();\nelse\n  alreadyScheduled(); // nothing to do here\nThanks.. ",
    "Imranmech786": "I am using Job scheduler to trigger a notification daily to user .it works fine if app is live . If I force close the app the job scheduler do not get triggered.help me to work out on this . ",
    "ExploiTR": "@vRallev I'm having the same problem. But, I'm certainly sure that it's not my fault.. @vRallev How to get Job information like when it's scheduled?\nLike : \nSet<Job> jobs = JobManager.instance().getAllJobsForTag(Tasker.TAG);\n        for (Job job : jobs) {\n         String time  = job.getScheduledTime();\n        }. https://github.com/evernote/android-job/blob/master/FAQ.md#why-arent-my-periodic-jobs-running-as-expected-on-android-5-or-higher\nlink outdated. @vRallev  Job returns null when JobManager.instance().getJob(id) is called. I posted a new issue for that. Please help by checking it out.. @Dooks123 Awesome man. I don't use Xamarin though.. @vRallev  job.isFinished is blocking next line of code to execute. Try to do this : \nint id =JobRequest.Builder(FollowJob.TAG)\n                .setPeriodic(900_000L)\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n                .setUpdateCurrent(true)\n                .setRequirementsEnforced(true)\n                .build()\n                .schedule()\nJobManager.instance().cancel(id);\nThough I have a bug with it. It works good to cancel, but trying to get the job it returns null.\n. oops\nOn Mon 21 May, 2018, 09:40 Vahid Aghakhany, notifications@github.com\nwrote:\n\n@ExploiTR https://github.com/ExploiTR I also tried to cancel by id but\nit doesn't work\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/452#issuecomment-390548107,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ATw55wY2UPHVzGt8B8xRbcNZma86jXmPks5t0j4YgaJpZM4UF-Y1\n.\n. oops. I've read the whole doc already. Ok, I'm giving you a screenshot of the error:\n\n. No way. You've created the library. Please..\n\nOn Tue 22 May, 2018, 22:53 Ralf Wondratschek, notifications@github.com\nwrote:\n\nStackoverflow is your friend.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/453#issuecomment-391072918,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ATw556SWyMppZn5Mg1S0ITY7-QR7suYXks5t1EmEgaJpZM4UGBPW\n.\n. Ok, it's fixed now. I just didn't include the WorkManager in gradle as a dependency.. @AlexKnyazyk Try by just don't including the WorkManager in gradle as a dependency.. \n",
    "Haoxiqiang": "I test two repos:\ncompile 'com.evernote:android-job:1.0.12'\nand\ncompile 'com.evernote:android-job:1.1.0-SNAPSHOT'\n1.1.0-SNAPSHOT works well,I think you have fix it.\n. sorry,I think instant run  may be the killer.I will try more test\n. I know.But I don't know what happened to the samsung 4.4.4 device.\nThis is the stacktrace,very little.\n```\n662 java.lang.IllegalStateException\nDoes not have RECEIVE_BOOT_COMPLETED permission, which is mandatory for this feature\ncom.evernote.android.job.JobRequest$Builder.com.evernote.android.job.JobRequest$Builder setPersisted(boolean)\ncom.evernote.android.job.JobRequest$Builder.com.evernote.android.job.JobRequest$Builder setPersisted(boolean)(SourceFile:824)\ncom.codoon.persistent.sync.SyncJob.void scheduleJob()(SourceFile:33)\ncom.codoon.snowx.ui.activity.SplashActivity$2.run(SourceFile:83)\nandroid.os.Handler.handleCallback(Handler.java:733)\nandroid.os.Handler.dispatchMessage(Handler.java:95)\nandroid.os.Looper.loop(Looper.java:136)\nandroid.os.HandlerThread.run(HandlerThread.java:61)\n```\nI find the error message in :\npublic Builder setPersisted(boolean persisted) {\n    if (persisted && !JobUtil.hasBootPermission(JobManager.instance().getContext())) {\n        throw new IllegalStateException(\"Does not have RECEIVE_BOOT_COMPLETED permission, which is mandatory for this feature\");\n    }\n    mPersisted = persisted;\n    return this;\n}\nI think this is a special case and I will use setPersisted(JobUtil.hasBootPermission(context) .\nThank you!\n. Yes!You are right,. ",
    "rajool": "Tnx for your answer. \n. ",
    "justincpollard": "@Unfortunately, this limitation makes debugging kind of a pain ... any suggestions on how to force a shorter interval in a debug environment?\n. Thanks @vRallev! I'm under the gun with a current release right now, but going to try this out ASAP! Really appreciate it :-)\n. ",
    "pvegh": "Worked for me, would be nice to see it in 1.1.1.\nI would add a log.w if this flag is active so this debug state is visible in the logs.\n. Warning looks good, I think this is useful.\nThanks\n. This is probably not the best idea, but marking the method deprecated would make it stick out in the reports in case someone actually does commit this unknowingly.\nI would probably choose misusing the annotation if it lowers the possibilty for a mistake though.\nJust a thought..\n. Worse if they do not (local testing on <N). Crashes will happen in production! Worst case ever.\nLike I said, just a thought\n. ",
    "TimVelo": "Also, as a side vote, I would definitely use this override for debug and \"production\". In my case, I develop for a select device pool of which I control (I develop for in-house use) and know that I will never be targeting anything over 4.4 for the next 1000 years. Most of my jobs are >1 hour, but I have a few that need to run 1-3 minutes, and I like being able to use the same scheduler for everything. This has truly helped my progress on my project, so also a thanks to all that developed this!\nP.S. Maybe instead of crash, push a LogE and adjust to 15 minutes for any N+ devices? :)\n. ",
    "esoxjem": "@vRallev For example, perform a job if the headphone is plugged in and the device is charging?\n. ",
    "yccheok": "@vRallev Thanks. We should really have \"How to cancel job\" info in FAQ.. May I know is there any TAG on 1.2.0-RC2? I look at https://github.com/evernote/android-job/tags but can't find it. Just would like to look at the code changes to tackle this issue, in order to have more understanding.\nThank you.. ",
    "lidox": "Thanks for your fast answer! \ud83d\udc4d \nSo if I want to schedule a job between 10:15 AM and 10:16 AM every day the code looks like this:\njava\n        int minutesToStart = 15;\n        int hoursToStart = 10;\n        long startMs = TimeUnit.MINUTES.toMillis((minutesToStart - (minute))) + TimeUnit.HOURS.toMillis( ((hoursToStart - hour) % 24) );\n        if(startMs < 0){\n            Log.info(\"next scheduling in a day...\");\n            startMs += TimeUnit.DAYS.toMillis(1);\n        }\n        long endMs = startMs + TimeUnit.MINUTES.toMillis(1);\n. ",
    "Mygod": "The app didn't crash but I see this in the logcat. No modifications. 1 job.\nHere's the code: https://github.com/shadowsocks/shadowsocks-android/blob/master/src/main/scala/com/github/shadowsocks/job/AclSyncJob.scala\nYou might want to tweak it to make it return RESCHEDULE so that you can try it out.\n. Okay just tried it again and here's a more complete log: (it finished successfully but I made it to return RESCHEDULE)\n10-12 17:23:25.360 6016-7000/com.github.shadowsocks D/PlatformJobService: Run job, request{id=9, tag=AclSyncJob:bypass-lan-china}, waited 00:00:00, start 00:00:00, end 00:00:00 (+28 days)\n10-12 17:23:25.369 6016-7000/com.github.shadowsocks I/JobExecutor: Executing request{id=9, tag=AclSyncJob:bypass-lan-china}, context PlatformJobService\n10-12 17:23:25.376 6016-7001/com.github.shadowsocks W/System: ClassLoader referenced unknown path: /system/framework/tcmclient.jar\n10-12 17:23:26.934 6016-7001/com.github.shadowsocks I/JobExecutor: Finished job{id=9, finished=true, result=RESCHEDULE, canceled=false, periodic=false, class=AclSyncJob, tag=AclSyncJob:bypass-lan-china}\n10-12 17:23:26.950 6016-6016/com.github.shadowsocks D/PlatformJobService: Called onStopJob for job{id=9, finished=true, result=RESCHEDULE, canceled=false, periodic=false, class=AclSyncJob, tag=AclSyncJob:bypass-lan-china}\n10-12 17:23:26.965 6016-7001/com.github.shadowsocks W/InstanceID/Rpc: Found 10070\n10-12 17:23:26.972 6016-7001/com.github.shadowsocks E/SQLiteDatabase: Error inserting persisted=false exact=false networkType=UNMETERED flexSupport=false isTransient=false tag=AclSyncJob:bypass-lan-china intervalMs=0 numFailures=1 backoffPolicy=EXPONENTIAL flexMs=0 scheduledAt=1476264206969 requiresCharging=true requiresDeviceIdle=false backoffMs=30000 requirementsEnforced=true endMs=2419200000 _id=9 startMs=1\n                                                                      android.database.sqlite.SQLiteConstraintException: UNIQUE constraint failed: jobs._id (code 1555)\n                                                                          at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(Native Method)\n                                                                          at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:782)\n                                                                          at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)\n                                                                          at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\n                                                                          at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1472)\n                                                                          at android.database.sqlite.SQLiteDatabase.insert(SQLiteDatabase.java:1343)\n                                                                          at com.evernote.android.job.JobStorage.store(JobStorage.java:192)\n                                                                          at com.evernote.android.job.JobStorage.put(JobStorage.java:109)\n                                                                          at com.evernote.android.job.JobManager.schedule(JobManager.java:231)\n                                                                          at com.evernote.android.job.JobRequest.schedule(JobRequest.java:320)\n                                                                          at com.evernote.android.job.JobRequest.reschedule(JobRequest.java:351)\n                                                                          at com.evernote.android.job.JobExecutor$JobCallable.handleResult(JobExecutor.java:166)\n                                                                          at com.evernote.android.job.JobExecutor$JobCallable.runJob(JobExecutor.java:153)\n                                                                          at com.evernote.android.job.JobExecutor$JobCallable.call(JobExecutor.java:135)\n                                                                          at com.evernote.android.job.JobExecutor$JobCallable.call(JobExecutor.java:118)\n                                                                          at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n                                                                          at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n                                                                          at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n                                                                          at java.lang.Thread.run(Thread.java:761)\n10-12 17:23:26.977 6016-7001/com.github.shadowsocks D/JobProxy24: Schedule one-off jobInfo success, request{id=9, tag=AclSyncJob:bypass-lan-china}, start 00:00:30, end 00:00:30 (+28 days)\n10-12 17:23:26.979 6016-7000/com.github.shadowsocks D/PlatformJobService: Finished job, request{id=9, tag=AclSyncJob:bypass-lan-china} RESCHEDULE\nThe app didn't crash. Here's evernote_jobs.db:\nsqlite> .tables\nandroid_metadata  jobs            \nsqlite> select * from jobs;\nsqlite> select * from android_metadata;\nen_US\nIn evernote_jobs.xml, there is only JOB_ID_COUNTER = 9.\n. Oh there's one more log:\n10-12 17:23:56.997 6016-6016/com.github.shadowsocks D/PlatformJobService: Job 9 already finished, null\nAfter that it stops retrying.\nAnd I don't think scala will interfere with other libraries. (it works well with every one I've encountered so far)\nRelated code: (in execution order)\n- https://github.com/shadowsocks/shadowsocks-android/blob/master/src/main/scala/com/github/shadowsocks/ShadowsocksApplication.scala#L186\n- After either ShadowsocksVpnService or ShadowsocksNatService starts, it calls AclSyncJob.schedule(profile.route): https://github.com/shadowsocks/shadowsocks-android/blob/master/src/main/scala/com/github/shadowsocks/job/AclSyncJob.scala#L19\n- Then this: https://github.com/shadowsocks/shadowsocks-android/blob/master/src/main/scala/com/github/shadowsocks/job/DonaldTrump.scala#L15\n- And this: https://github.com/shadowsocks/shadowsocks-android/blob/master/src/main/scala/com/github/shadowsocks/job/AclSyncJob.scala#L29\n. Yep you are right! The 2nd option works just fine. Thanks!\n. An unrelated request: could you suppress the stack trace for this error? I intentionally turned off GCM in my app because it targets API 21+.. ",
    "rhonyabdullah": "Sorry, didn't mean to spamming this issue, i'm using this pattern to implement clean architecture but get stuck on replacing CONNECTIVITY_CHANGE, i read the demo code but still get confused. Any idea ? @vRallev & @androidmi . ",
    "akshuu": "Sorry forgot to post that:\n```\n        JobManager.create(this).addJobCreator(new WHJobCreator());\npublic class WHJobCreator implements JobCreator {\n    @Override\n    public Job create(String tag) {\n        switch (tag) {\n            case Constants.INTENT_DEVICE_CHECKIN_VIA_JOBSCHEDULER:\n                return new DeviceCheckinJob();\n            default:\n                return null;\n        }\n    }\n}\n```\nI do this in my MultiDexApplication class.\nThe same code works perfect on 6.0 device.\n. I tried your approach and it did not work.\nhere is the data from the evernote-jobs.db \n1|INTENT_DEVICE_CHECKIN_VIA_JOBSCHEDULER|-1|-1|30000|EXPONENTIAL|900000|0|0|1|0|ANY||1|0|1476305766869|0|300000|0\n. that seems to work. The only thing is that the job runs even after the Flex time (printing the wrong \"waited\" time here)\n```\n10-13 15:25:28.115 D/PlatformJobService(31220): Run job, request{id=1, tag=INTENT_DEVICE_CHECKIN_VIA_JOBSCHEDULER}, waited 00:40:00, interval 00:15:00, flex 00:05:00\n10-13 15:42:33.223 D/PlatformJobService(31220): Run job, request{id=1, tag=INTENT_DEVICE_CHECKIN_VIA_JOBSCHEDULER}, waited 00:57:05, interval 00:15:00, flex 00:05:00\n``\n. sure. THe problem seems to be resolved by removing the.setRequiresDeviceIdle(true)`\n. Cool. Thanks. setting the requirementsEnforced() worked.\nCan you please put up some sample code in your ReadME highlighting this ?\n. ",
    "KChernenko": "Thanks for the explanation!\n. ",
    "tobiasschuerg": "Might be related to this one: JobScheduler: Calling jobFinished from onStartJob makes the app crash randomly\n. I don't think so as I only added this library about ten days ago, already using the latest available version.\n. Version 1.1.9, according to the logs, it happens right after calling .schedule ().. > That's great to hear. I guess then next week will be a good time for a stable release.\nWhat's the status of the release @vRallev ?. ",
    "NiaNingXue": "I have the same issues. ",
    "hkllzh": "I have the same issues. ",
    "varunasingh": "Is the explaination mentioned here relevant ? : https://github.com/yigit/android-priority-jobqueue/issues/157#issuecomment-222320643. different project, but same android issue and bug. I'm wondering if their workaround (mentioned in the comment) can be applied as a workaround here. . ",
    "yeduRaghav": "Has anyone found a resolution for this ? . I faced similar problem and created a stackoverflow question. Here it is, with the answer : https://stackoverflow.com/questions/46161930/scheduled-job-executes-multiple-time-in-evernote-androidjob/46163527#46163527. ",
    "robelgado": "Seeing the same issue here\njava.lang.NullPointerException: \n  at android.os.Parcel.readException (Parcel.java:1552)\n  at android.os.Parcel.readException (Parcel.java:1499)\n  at android.app.job.IJobCallback$Stub$Proxy.jobFinished (IJobCallback.java:167)\n  at android.app.job.JobService$JobHandler.handleMessage (JobService.java:147)\n  at android.os.Handler.dispatchMessage (Handler.java:102)\n  at android.os.Looper.loop (Looper.java:135)\n  at android.app.ActivityThread.main (ActivityThread.java:5422)\n  at java.lang.reflect.Method.invoke (Native Method)\n  at java.lang.reflect.Method.invoke (Method.java:372)\n  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:914)\n  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:707). ",
    "VladislavNikolaev": "I am also still getting this crash with com.evernote:android-job:1.2.6 and Android 6\nFatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'int com.android.server.job.controllers.JobStatus.getUid()' on a null object reference. > Handling that NPE was only option that I found. So surround it with try-catch.\nHow did you syrround it with try-catch, could you show your implementation, please?. Have you tried to reproduce it on play-services 12.0.1? Was it fixed?. ",
    "rrigoni": "Same issue here. Happening all the time. \nFatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'int com.android.server.job.controllers.JobStatus.getUid()' on a null object reference\n       at android.os.Parcel.readException(Parcel.java:1562)\n       at android.os.Parcel.readException(Parcel.java:1509)\n       at android.app.job.IJobCallback$Stub$Proxy.jobFinished(IJobCallback.java:168)\n       at android.app.job.JobService$JobHandler.handleMessage(JobService.java:147)\n       at android.os.Handler.dispatchMessage(Handler.java:111)\n       at android.os.Looper.loop(Looper.java:210)\n       at android.app.ActivityThread.main(ActivityThread.java:5833)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1113)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:879). ",
    "chuks": "Has anyone found a work around for this? It looks like Google is not fixing this, as several people have reported this bug, but they've closed it.. Also seeing this on Nexus 6 Android 7.1.1 logcat. \nOn further investigation, it looks like \"android.app.job.JobServiceEngine\" is only available on Oreo.. ",
    "kumarravi2": "I am too facing the same issue. Is it fixed ?\nFatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'int com.android.server.job.controllers.JobStatus.getUid()' on a null object reference\n       at android.os.Parcel.readException(Parcel.java:1552)\n       at android.os.Parcel.readException(Parcel.java:1499)\n       at android.app.job.IJobCallback$Stub$Proxy.jobFinished(IJobCallback.java:167)\n       at android.app.job.JobService$JobHandler.handleMessage(JobService.java:147)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:135)\n       at android.app.ActivityThread.main(ActivityThread.java:5422)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:914)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:707). Handling that NPE was only option that I found. So surround it with try-catch. . I did it as follows.\n```\n@Override\n    public boolean onStartJob(JobParameters jobParameters) {\n        // TODO Add your task\n    // Should be protected to avoid crash in a device where call to jobId() results in NPE. Seems platform error\n    try {\n        jobFinished(jobParameters, true);\n    } catch (NullPointerException ignored) {\n    }\n\n}\n```. ",
    "Codyfjm": "I am facing this project nearly, How to fix it. ",
    "joimxjtuse": "i use WorkManager, i also found this uncaught exception: \njava.lang.NullPointerException: Attempt to invoke virtual method 'int com.android.server.job.controllers.JobStatus.getUid()' on a null object reference\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at android.os.Parcel.readException(Parcel.java:1636)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at android.os.Parcel.readException(Parcel.java:1583)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at android.app.job.IJobScheduler$Stub$Proxy.schedule(IJobScheduler.java:122)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at android.app.JobSchedulerImpl.schedule(JobSchedulerImpl.java:42)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at bp.a(SourceFile:85)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at bp.a(SourceFile:71)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at bc.a(SourceFile:98)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at bc.a(SourceFile:69)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at bf.g(SourceFile:369)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at bf.a(SourceFile:240)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at bf.run(SourceFile:166)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)\n01-25 09:15:47.495 E/AndroidRuntime(15729):     at java.lang.Thread.run(Thread.java:818)\n. ",
    "GrahamBorland": "Yes, updating to compileSdkVersion 25 solves the problem. Thanks.\n. Ah, OK. Thanks. :). A much simpler fix would be to just open the database connection once, and reuse it everywhere. You don't need to open and close the database connection every time you read or write. SQLite itself takes care of thread safety.. ",
    "oipat": "Thanks for the swift answer! I'll look into that and if it's not helping I'll just have to fall back into using services.\n. I don't see any obstacles in that. I'll look into BroadCastReceiver's too.\n. ",
    "ruhul015": "```\n   Calendar calendar = Calendar.getInstance();\n    int hour = calendar.get(Calendar.HOUR_OF_DAY);\n    int minute = calendar.get(Calendar.MINUTE);\nint minutesToStart = 00;\nint hoursToStart = 9;\n\nlong startMs = TimeUnit.MINUTES.toMillis((minutesToStart - (minute))) +         TimeUnit.HOURS.toMillis(((hoursToStart - hour) % 24));\n    if (startMs < 0) {\n        Log.d(TAG, \"next scheduling in a day...\");\n        startMs += TimeUnit.DAYS.toMillis(1);\n    }\n   new JobRequest.Builder(DemoSyncJob.TAG)\n            .setExact(startMs)\n            .setPersisted(true)\n            .setUpdateCurrent(true)\n            .build()\n            .schedule();\n```\nIs it ok for firing alarm at 9am and every day ??\n. it is not worked for me :(\n. ",
    "jeffmcnd": "Dumb question guys. My bad. Just set the startMs to when you want it to start.\nAs you were.\n. Ugh. I was reading the method declaration for the setExecutionWindow function. #dumbtwice\n. I'll give it a whirl. Thanks for getting back to me so soon!\n. ",
    "vaibhav-jani": "Just setting minifyEnabled \"true\" in Ever-note demo app the build fails. \n. ",
    "alfdev": "Hi,\ni don't know if its correct but i found a workaround, add the following to your proguard:\n-dontwarn com.evernote.android.job.v24.**\n. ",
    "Brajendra": "Thanks for Quick Reply, Actual problem is on manifest merge, i copy the same class and use in my app manifest, then its work.\n.  com.android.tools.build:gradle:2.2.2\nyes, i have  Proguard enable but i test  in debug mode only, i will sent you a sample.\n. ",
    "fangyu286": "I can solve this issue. if you manifest 'tools:replace' attribute is not merge you must copy the android-job libs manifest content to you manifest. and the default manifest tools:replace is merge. good luck.\n. ",
    "sntdevco": "@vRallev Can you please provide an example?. ",
    "Kisty": "There's an Intent action called Intent.ACTION_TIMEZONE_CHANGED. Am hoping to use it to fix an issue where daily reminders that don't take in to account new time, such as daylight saving time. I see that implicit broadcasts aren't fired off in API 26+ however the ACTION_TIMEZONE_CHANGED action is exempt from it.. Any plans to support this natively? Would help a lot!. But surely a Job is abstractly just a task, without a scheduled time. The library takes care of scheduling for you, no?\nCan't you run multiple one-off or periodic jobs scheduled at different times, with the same tag? By seeing the JobManager#getAllJobRequestsForTag(String), I guess so. If so, then surely the daily job could have similar functionality? Forgive me if I'm wrong or I've missed something. \nThanks!. ",
    "stingare": "Yes! The second part it is, I was just running the getJob method, I see my mistake. Thanks. ",
    "sashatinkoff": "\nScreen is on all the time\nApp is open\nSchedule method was nat called ever. It doesn't matter what frequency of method I tried to use - 10 seconds, 30 seconds, a minute... . \n",
    "JRVilela": "I am having the same problem using Android N (Motorola Nexus 6). The problem is the same, onRunJob is never called.\nOther devices running Android N (Ex: Nexus 5x) are working.\nAlso tested on Android M and L. Everything works as expected.\nI am testing something as simple as this:\nnew JobRequest.Builder(DemoSyncJob.TAG)\n                .setPeriodic(TimeUnit.MINUTES.toMillis(15), TimeUnit.MINUTES.toMillis(5))\n                .build()\n                .schedule();\nNotes:\nScreen is on all the time\nApp is open\nThanks.. ",
    "SergiLlamasGuerrero": "Thank you very much for your fast answer!\nThe call I use to start my periodic job is:\nJobRequest.Builder(PERIODIC_JOB_TAG)\n          .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n          .setPersisted(true)\n          .setPeriodic(intervalMs, flexMs)\n          .setRequirementsEnforced(true)\n          .setUpdateCurrent(true)\n          .build()\n          .schedule()\n(where intervalMs is 8 hours in milliseconds and flexMs is 5 minutes in milliseconds)\nand before each call I delete all jobs with this:\nJobManager.instance().cancelAllForTag(GeofencesJob.PERIODIC_JOB_TAG)\nWhat I'm noticing is that if I write setPeriodic(intervalMs) the job acts more often as intervalMs, for example, acts 3 times in a 5 minutes interval.\nIn addition, if I write setPeriodic(intervalMs, flexMs) sometimes the job doesn't act. And the intervals are called don't match with intervalMs, flexMs.\nFor more information, the version I'm using now is 1.1.3.\nAnd I have another non-periodic job:\n      JobManager.instance().cancelAllForTag(GeofencesJob.ONE_TIME_JOB_TAG)\n  JobRequest.Builder(ONE_TIME_JOB_TAG)\n      .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n      .setRequirementsEnforced(true)\n      .setExecutionWindow(startMs, endMs)\n      .setPersisted(true)\n      .build()\n      .schedule()\n\nThank you very much again!\nSergi. After testing with different values, we have decided to set the periodic job with an interval of 15 minutes and 15 minutes of flex. And we get this log:\n12-13 09:25:47.634 D/JobManager: Reschedule 0 jobs of 1 jobs\n12-13 09:27:37.893 D/PlatformJobService: Run job, request{id=3, tag=periodic_geofences_job}, waited 00:02:00, interval 00:15:00, flex 00:15:00\n12-13 09:27:37.895 I/JobExecutor: Executing request{id=3, tag=periodic_geofences_job}, context PlatformJobService\n12-13 09:27:37.904 V/ConnectivityManager: isActiveNetworkMetered() returns:false\n12-13 09:27:39.172 I/JobExecutor: Finished job{id=3, finished=true, result=SUCCESS, canceled=false, periodic=true, class=GeofencesJob, tag=periodic_geofences_job}\n12-13 09:27:39.174 D/PlatformJobService: Finished job, request{id=3, tag=periodic_geofences_job} SUCCESS\n12-13 09:56:59.874 D/PlatformJobService: Run job, request{id=3, tag=periodic_geofences_job}, waited 00:31:22, interval 00:15:00, flex 00:15:00\n12-13 09:56:59.875 I/JobExecutor: Executing request{id=3, tag=periodic_geofences_job}, context PlatformJobService\n12-13 09:56:59.899 V/ConnectivityManager: isActiveNetworkMetered() returns:false\n12-13 09:57:01.108 I/JobExecutor: Finished job{id=3, finished=true, result=SUCCESS, canceled=false, periodic=true, class=GeofencesJob, tag=periodic_geofences_job}\n12-13 09:57:01.109 D/PlatformJobService: Finished job, request{id=3, tag=periodic_geofences_job} SUCCESS\n12-13 09:59:01.164 D/PlatformJobService: Run job, request{id=3, tag=periodic_geofences_job}, waited 00:33:23, interval 00:15:00, flex 00:15:00\n12-13 09:59:01.164 I/JobExecutor: Executing request{id=3, tag=periodic_geofences_job}, context PlatformJobService\n12-13 09:59:01.182 V/ConnectivityManager: isActiveNetworkMetered() returns:false\n12-13 09:59:02.311 I/JobExecutor: Finished job{id=3, finished=true, result=SUCCESS, canceled=false, periodic=true, class=GeofencesJob, tag=periodic_geofences_job}\n12-13 09:59:02.314 D/PlatformJobService: Finished job, request{id=3, tag=periodic_geofences_job} SUCCESS\n12-13 10:17:14.098 D/PlatformJobService: Run job, request{id=3, tag=periodic_geofences_job}, waited 00:51:36, interval 00:15:00, flex 00:15:00\n12-13 10:17:14.098 I/JobExecutor: Executing request{id=3, tag=periodic_geofences_job}, context PlatformJobService\n12-13 10:17:15.282 I/JobExecutor: Finished job{id=3, finished=true, result=SUCCESS, canceled=false, periodic=true, class=GeofencesJob, tag=periodic_geofences_job}\n12-13 10:17:15.284 D/PlatformJobService: Finished job, request{id=3, tag=periodic_geofences_job} SUCCESS\nIf you can see, the job was executed after 2 minutes, after 31, after 33, and after 51, even the interval and flex are set to 15 minutes. Is this normal behavior?\nAfter seeing this log, we are afraid of losing job executions.\nThank you again!\nSergi\nPD: We are testing in a Android 5.1 device. We understand better how it works now.\nThank you very much!. ",
    "shomronh": "@vRallev the test i'm doing is:\n\nstart debugging (with breakpoints) using android studio on my device\nmake screen device off\nwait a lot : )\n\nthen: nothing happen. great i will try that\nmeanwhile, running the test from the device only, is not working.\nI'm actually updating my firebase with tag that says that background activities is starting and actually this does not happen \ni really need a way to run the background activity the easiest way possible\nto test it i need to create a release => install on device => run ?\nor i can run it once using android studio then reopen the app without the IDE ?\nany Idea ? \nThanks.. For Those who need more control of the idle mode:\nI'm not using the setRequiresDeviceIdle(true) anymore, another way is to wait until going into background.\nmode then handle the jobs has needed.. sure.. @vRallev any idea ?\nthis is the jobrequest i'm using:\nint jobId = new JobRequest.Builder(jobTag)\n                .setExecutionWindow(startMs, endMs)\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n                .setRequirementsEnforced(true)\n                .setUpdateCurrent(updateCurrent)\n                .build()\n                .schedule();. so this is my abstract class:\npublic abstract class AbstractAsyncJob extends Job {\nprotected String jobDescription;\n\nprotected Integer jobId;\n\n@NonNull\n@Override\nprotected Result onRunJob(Params params) {\n    final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n    Utils.makeToastText(getContext(),jobDescription + \": Started\");\n\n    new Thread() {\n        @Override\n        public void run() {\n            // do async operation here\n            startJob();\n\n            Utils.makeToastText(getContext(),jobDescription + \": Completed\");\n\n            SystemClock.sleep(10_000L);\n            countDownLatch.countDown();\n        }\n    }.start();\n\n    try {\n        countDownLatch.await();\n    } catch (InterruptedException ignored) {\n        jobInterruptedException();\n    }\n\n    return Result.SUCCESS;\n}\n\nprotected static ArrayList<Long> getStartAndEndForEvery24Hours(){\n    //Calendar calendar = Calendar.getInstance();\n\n    //\n    long startMs = 1_000L;\n    long endMs = startMs + TimeUnit.HOURS.toMillis(24);\n\n    ArrayList<Long> values = new ArrayList<>();\n    values.add(startMs);\n    values.add(endMs);\n\n    return values;\n}\n\npublic static int scheduleEvery24Hours(String TAG, boolean updateCurrent) {\n\n    ArrayList<Long> values = getStartAndEndForEvery24Hours();\n    Long startMs = values.get(0);\n    Long endMs = values.get(1);\n\n    int jobId = createScheduledJob(\n            TAG,\n            updateCurrent,\n            startMs,\n            endMs\n    );\n\n    return jobId;\n}\n\n// .setRequiresDeviceIdle(true) // this not working for some reason, so i decided to manage the idle mode\n// by code\nprotected static int createScheduledJob(String jobTag, boolean updateCurrent, Long startMs, Long endMs){\n    int jobId = new JobRequest.Builder(jobTag)\n            .setExecutionWindow(startMs, endMs)\n            //.setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.EXPONENTIAL)\n            //.setRequiresDeviceIdle(true)\n            .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n            .setRequirementsEnforced(true)\n            //.setPersisted(true)\n            .setUpdateCurrent(updateCurrent)\n            .build()\n            .schedule();\n\n    return jobId;\n}\n\n// to override\nprotected void startJob() {\n\n}\n\nprotected void jobInterruptedException(){\n\n}\n\n\npublic interface JobResult {\n    void onJobStart();\n\n    void onJobComplete();\n}\n\n}. what do you mean by that ? i can take off the thread use ? this is actually a code from the FAQ page\nactually the job i'm processing is async operation related to firebase query\nso it can not return success until it finishes right ?\nwhat do you advice me to make it work better ?\nthis is the change i've made right now:\nnew Thread() {\n            @Override\n            public void run() {\n                // do async operation here\n                startJob(new JobResult() {\n                    @Override\n                    public void onJobStart() {\n                }\n\n                @Override\n                public void onJobComplete() {\n                    Utils.makeToastText(getContext(),jobDescription + \": Completed\");\n                    countDownLatch.countDown();\n                }\n            });\n        }\n    }.start();\n\nbut still not working. even if i'm not using anymore the Thread object this still not working ..... this is the code i'm using now:\npublic abstract class AbstractAsyncJob extends Job {\nprotected String jobDescription;\n\nprotected Integer jobId;\n\n@NonNull\n@Override\nprotected Result onRunJob(Params params) {\n\n    Utils.makeToastText(getContext(), jobDescription + \": Started\");\n\n    startJob(new JobResult() {\n        @Override\n        public void onJobStart() {\n\n        }\n\n        @Override\n        public void onJobComplete() {\n            Utils.makeToastText(getContext(), jobDescription + \": Completed\");\n            //countDownLatch.countDown();\n        }\n    });\n\n    return Result.SUCCESS;\n}\n\nprotected static ArrayList<Long> getStartAndEndForEvery24Hours() {\n    //Calendar calendar = Calendar.getInstance();\n\n    //\n    long startMs = 1_000L;\n    long endMs = startMs + TimeUnit.HOURS.toMillis(24);\n\n    ArrayList<Long> values = new ArrayList<>();\n    values.add(startMs);\n    values.add(endMs);\n\n    return values;\n}\n\npublic static int scheduleEvery24Hours(String TAG, boolean updateCurrent) {\n\n    ArrayList<Long> values = getStartAndEndForEvery24Hours();\n    Long startMs = values.get(0);\n    Long endMs = values.get(1);\n\n    int jobId = createScheduledJob(\n            TAG,\n            updateCurrent,\n            startMs,\n            endMs\n    );\n\n    return jobId;\n}\n\n// .setRequiresDeviceIdle(true) // this not working for some reason, so i decided to manage the idle mode\n// by code\nprotected static int createScheduledJob(String jobTag, boolean updateCurrent, Long startMs, Long endMs) {\n    int jobId = new JobRequest.Builder(jobTag)\n            .setExecutionWindow(startMs, endMs)\n            //.setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.EXPONENTIAL)\n            //.setRequiresDeviceIdle(true)\n            .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n            .setRequirementsEnforced(true)\n            //.setPersisted(true)\n            .setUpdateCurrent(updateCurrent)\n            .build()\n            .schedule();\n\n    return jobId;\n}\n\n// to override\nprotected void startJob(final JobResult result) {\n\n}\n\nprotected void jobInterruptedException() {\n\n}\n\n\npublic interface JobResult {\n    void onJobStart();\n\n    void onJobComplete();\n}\n\n}\nbut still not working. the test i'm doing is:\n\nrun the app\nclick home button, i'm detecting it inside my code => run BackgroundJobAllPersons.scheduleJob();\n   BackgroundJobAllPersons inherit from my abstract class, as i sait the job i'm doing is accessing asynchronously firebase entity\nwhen i have a toast that said job started i'm going back to the app which my code detects it and i stop all current jobs using: \n\nJobManager jobManager = JobManager.instance();\n        jobManager.cancelAll();\nthis is a simple flow i'm doing to test the cancel functionality. i know, but i've been following your documentation, so it's not enough clear people.\nagain, while testing your library i see: \njob start and job completed all the time even if i'm stopping jobs, this means that something not working properly. @vRallev i'm telling you the issue i'm not here to wast my time and even yours, i need to make it work as soon as possible, if you do not want to do your work it's ok.\nis there a serious coder that can help me out ?. @vRallev is there a test case where your library is starting jobs when the home button is clicked then when comming back it's stopping all the current jobs ? it's an important usecase make one and you will see that this is not working.\nProve it and attach logs. ; ). you have just proved it about you  : ). @vRallev is it enough ?. @markcerqueira  you are right but actually because of a misunderstanding @vRallev closed my issues while it was not really resolved. @vRallev Thanks for your answer\nso i need to delay the jobs so i can gain more control on the cancelation ?\nif so it's solved : ). actually i finally understand why it's not cancelling right a way thanks to @vRallev \n. Thanks people !. ",
    "markcerqueira": "@shomronh - please keep anything related to your issue in a single issue. Opening multiple issues and spreading out information across them introduces unnecessary noise and is like refactoring a perfectly working class into multiple classes for no good reason.. @shomronh The problem you are discussing is not a \"problem\" with this library; it's how threading works in Java. @vRallev has multiple times told you what you would need to do to work around expected behavior of Java threads (i.e. checking isCanceled()). I kindly ask you review multi-threading in Java and provide a complete project (feel free to post to GitHub so we can check it out and run it ourselves) of code that does not work. \nThank you!. ",
    "sytolk": "@vRallev thanks but I'm thinking how to add dynamically event to the library something like:\n.addCustomEvent(new CustomEventImplementation()). Or simple: https://twitter.com/videolan/status/1022033608670961665. ",
    "amalive": "@akramShokri I'm using gradle for fetching the dependencies and there is no dependencies error. @vRallev \nbuild.gradle.zip\n. ",
    "fengjunren": "i done it.thank you\n2017-01-04 \n15221951775 \n\u53d1\u4ef6\u4eba\uff1aakramShokri notifications@github.com\n\u53d1\u9001\u65f6\u95f4\uff1a2016-12-26 19:47\n\u4e3b\u9898\uff1aRe: [evernote/android-job] can i use this lib in eclipse? (#124)\n\u6536\u4ef6\u4eba\uff1a\"evernote/android-job\"android-job@noreply.github.com\n\u6284\u9001\uff1a\"junfeng.ren\"15221951775@163.com,\"Author\"author@noreply.github.com\nYou can add jar file of android-job and cat libraty to your project.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.. ",
    "deviant-studio": "Wow, helpful indeed. Thanks!\nCould you make it public in next releases? (just for more convenience). ",
    "hdtuan87": "You can see file db\nI have a job scheduled at 5/1/2017\nWhy delay 17171 days? :( \nmy code:\n`PersistableBundleCompat extras = new PersistableBundleCompat();\n        extras.putLong(JobRepeatBudget.EXTRA_BUDGET_ID,1);\n    int jobId = new JobRequest.Builder(JobRepeatBudget.TAG)\n            .setExtras(extras)\n            .setExact(System.currentTimeMillis() + 60000)\n            .setPersisted(true)\n            .build()\n            .schedule();'\n\n. if call setExact(60000) job do not wait to run immediately. I see it from fabric. I don't move of delete DB. I can't reproduce it :( but I have more error log.\n`Fatal Exception: android.database.sqlite.SQLiteCantOpenDatabaseException: unable to open database file (code 2062): , while compiling: PRAGMA journal_mode\n\nError Code : 2062 (SQLITE_CANTOPEN_EMFILE)\nCaused By : Application has opened two many files. Maximum of available file descriptors in one process is 1024 in default.\n    (unable to open database file (code 2062): , while compiling: PRAGMA journal_mode)\n\n   at android.database.sqlite.SQLiteConnection.nativePrepareStatement(SQLiteConnection.java)\n   at android.database.sqlite.SQLiteConnection.acquirePreparedStatement(SQLiteConnection.java:1058)\n   at android.database.sqlite.SQLiteConnection.executeForString(SQLiteConnection.java:762)\n   at android.database.sqlite.SQLiteConnection.setJournalMode(SQLiteConnection.java:443)\n   at android.database.sqlite.SQLiteConnection.setWalModeFromConfiguration(SQLiteConnection.java:417)\n   at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:315)\n   at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:210)\n   at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:512)\n   at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:206)\n   at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:178)\n   at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:908)\n   at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:878)\n   at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:699)\n   at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:633)\n   at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:283)\n   at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:223)\n   at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:163)\n   at com.evernote.android.job.JobStorage.getDatabase(JobStorage.java:288)\n   at com.evernote.android.job.JobStorage.store(JobStorage.java:244)\n   at com.evernote.android.job.JobStorage.put(JobStorage.java:127)\n   at com.evernote.android.job.JobManager.schedule(JobManager.java:231)\n   at com.evernote.android.job.JobRequest.schedule(JobRequest.java:354)`.\n",
    "alexandr2levin": "Simple project that reproduces this behavior with AlarmManager: https://github.com/Try4W/AlarmManagerDemo\n\nThe next time the app starts it's possible to reschedule alarms\n\nBut what should I do if my application is \"alarm clock\"? One of the possible ways is to add my app to 'whitelist'(protected apps).\nThere is an app on my phone: My Therapy. It shows notification every evening even if app is swiped out from recent without being marked as 'protected app'.\nI tried to decompile it's apk, but I can't find anything special in scheduling their alarms.\nNote: alarms scheduled by BroadcastReciever on ACTION_BOOT_COMPLETED works okay until I open and 'force-close' my application. Note 2: even after force-stopping app via swiping it from recent apps this expression:\nPendingIntent.getBroadcast(context, REQUEST_CODE, notificationIntent, PendingIntent.FLAG_NO_CREATE) != null (explanation)\nreturns true. I will provide sources and video demonstration within a few days.\nThere is some code in Kotlin:\n```\n    companion object {\n        const val REQUEST_CODE = 3434\n    }\nfun schedulePendingIntent(triggerTimeMillis: Long, pendingIntent: PendingIntent) {\n    if (Build.VERSION.SDK_INT >= 23) { // https://stackoverflow.com/questions/34378707/alarm-manager-does-not-work-in-background-on-android-6-0\n        logger.debug(\"setExactAndAllowWhileIdle\")\n        alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerTimeMillis, pendingIntent)\n    } else {\n        if (Build.VERSION.SDK_INT >= 19) {\n            logger.debug(\"setExact\")\n            alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTimeMillis, pendingIntent)\n        } else {\n            logger.debug(\"set\")\n            alarmManager.set(AlarmManager.RTC_WAKEUP, triggerTimeMillis, pendingIntent)\n        }\n    }\n}\n\nfun checkAlarmScheduled(): Boolean {\n    val notificationIntent = Intent(BringUserBackAppReminder.ACTION_FIRE_NOTIFICATION)\n    return PendingIntent.getBroadcast(context, REQUEST_CODE, notificationIntent, PendingIntent.FLAG_NO_CREATE) != null\n}\n\nprivate fun getNotificationPendingIntent(): PendingIntent {\n    val notificationIntent = Intent(BringUserBackAppReminder.ACTION_FIRE_NOTIFICATION)\n    return PendingIntent.getBroadcast(context, REQUEST_CODE, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT)\n}\n\n```. (sorry for the mistakes, English is not my native language)\n\nNote 2: even after force-stopping app via swiping it from recent apps this expression:\nPendingIntent.getBroadcast(context, REQUEST_CODE, notificationIntent, PendingIntent.FLAG_NO_CREATE) != null (explanation)\nreturns true\n\nI can reproduce this bug on my device. I can't stream my phone screen on my pc and I can't make a clear  video demonstration.\nHere is updated demo project: https://github.com/Try4W/AlarmManagerDemo\nHow to reproduce:\nListen to ACTION_POWER_CONNECTED action:\n<receiver android:name=\".PowerConnectedBroadcastReceiver\" >\n            <intent-filter>\n                <action android:name=\"android.intent.action.ACTION_POWER_CONNECTED\"/>\n            </intent-filter>\n        </receiver>\nIn this demo I just print PendingIntent.getBroadcast(...) != null result in console:\n```\npublic class PowerConnectedBroadcastReceiver extends BroadcastReceiver {\nprivate static final String TAG = \"PowerConnectedBroRe\";\n\n@Override\npublic void onReceive(Context context, Intent intent) {\n    AlarmHelper alarmManager = new AlarmHelper(context);\n    Log.d(TAG, \"PendingIntent.getBroadcast(...) != null: \" + alarmManager.isAlarmScheduled());\n}\n\n}\n```\nAnd there is the problem. If you swipe an app from recent apps and try to call alarmManager.isAlarmScheduled() after starting an application from 'apps menu' it will return FALSE.\nIf you will try to call the same method from PowerConnectedBroadcastReceiver(via connecting your phone to pc via USB) after swiping an app from recent apps it will return TRUE.\nAnd if then you launch your application again, you will see that alarmManager.isAlarmScheduled() still returns TRUE even if there is no scheduled alarm in adb shell dumpsys alarm output.. I describe the same behavior. It looks right, but you missing the problem:\n\nIf you will try to call the same method from PowerConnectedBroadcastReceiver(via connecting your phone to pc via USB) after swiping an app from recent apps it will return TRUE.\nAnd if then you launch your application again, you will see that alarmManager.isAlarmScheduled() still returns TRUE even if there is no scheduled alarm in adb shell dumpsys alarm output.\n\nPendingIntent.getBroadcast(...) != null shouldn't return true if you swipe away demo application('force close' it).\nCan you reproduce the problem described in the first issue's message?\nIf so, try to list your alarms with adb shell dumpsys alarm after 'force stop' demo application.\nIf there is no Intent in the list, how can PendingIntent.getBroadcast(...) != null return true?. Yeah, It looks like this problem is partly in my rom. LeTv One runs on EUI. But the same behavior is seen on different roms with their own 'optimizers'.\nAnd some developers find a workaround for this issue.\nI managed to get a response from the developers of Bookmate's android application. They use GCM for pushing notifications. But it doesn't work without an internet connection and moreover, can't be applied to your library.. ",
    "IgorGanapolsky": "Did you consider using a Foreground Service to solve you issue?. ",
    "getSafiq": "it's late but i hope someone will get help from this.\nRecently i have worked on an android project based on schedule alarm.I faced the same problem and got it working by stopping the debugger and  running the app from the device.\n(sorry for my bad english). ",
    "tsirolnik": "I would like to comment and say this - I've tried to schedule a Service class using Android's AlarmManager but it failed miserably. \nAfter switching for a Service to a BroadcastReceiver it did work. I'm not sure what's the specific reason but I want to think that maybe the service is running in the background and therefore AlarmManager doesn't start another instance of the service.\nHere's my current, working, code - \n```java\n    Intent serviceIntent = new Intent(this, <BroadcastReceiver>.class);\n    PendingIntent pendingIntent = PendingIntent.getBroadcast(this, 0, serviceIntent, 0);\n    AlarmManager alarm = (AlarmManager) getSystemService(Context.ALARM_SERVICE);\n    alarm.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), 1000*60, pendingIntent);\n\n```\nThis will send a broadcast every minute.. ",
    "AlexMisiulia": "@tsirolnik you're absolutely right. \nThis is because of Android Background limitation:\nBackground start not allowed: service Intent ...\nMore info here: https://stackoverflow.com/questions/45016174/android-o-and-background-limits-prevents-simple-alarm-notification. ",
    "nick1Jian": "It appears I should use getAllJobRequestsForTag() instead. .  That's how I going to solve this issue. But It will be easier to handle all the condition in one place if there's a way to control rescheduling when the job's requirement is not match. It also improve readability since you don't need to read onRunJob to make sure it actually re-run itself. \nAlso it's going to help if you add the code above to Q&A section. . ",
    "powder366": "Thanks (should have looked there :-)) Maybe update README anyway.... ",
    "Scrounger": "Thanks, i know this example, but it doesn't do exactly what i want. \nI need no specific time, i need an option \"start as soon as possible\" with the combination of  .setRequiresDeviceIdle(true) and this for a periodic  job.\nOk, i will open an issue at StackOverflow:\nhttp://stackoverflow.com/questions/41811893/android-job-periodic-once-a-day-deviceidle-true-as-soon-as-possible. ",
    "AlexFrost": "Yes, lib reschedule jobs at  https://github.com/evernote/android-job/blob/master/library/src/main/java/com/evernote/android/job/JobManager.java#L482\nbut this code is called when we call JobManager.create() and instantiate  JobManager().\nbut after app/gplay update app gets broadcast from GcmNetworkManager to call onInitializeTasks() and call onCreate() for application class. And this is ok, if you use initialization in onCreate() but this doesn't work for something like <receiver android:name=\".DemoJobCreator$AddReceiver\" initialization.\nSame thing for alarm manager based. I'm not sure but android can clear app alarms on update app and nothing doesn't reinitialize alarms(because without gplay it doesn't get update broadcast) before user open app or reboot device. . > I'm not sure how the AddReceiver plays a role.\nWhen you use AddReceiver you don't have initialization on application onCreate(), so android can't call your initialization when app created to get any broadcast\nhttps://github.com/evernote/android-job/blob/master/FAQ.md#i-cannot-override-the-application-class-how-can-i-add-my-jobcreator  \n\nSo I don't quite understand what you're suggesting\n\nadd \n```\n    @Override\n    public void onInitializeTasks() {\n        super.onInitializeTasks();\n    JobManager.create(getApplicationContext());\n}\n\n```\nto PlatformGcmService as you do in JobBootReceiver, for same reason\nand maybe subscribe to https://developer.android.com/reference/android/content/Intent.html#ACTION_PACKAGE_REPLACED for alarms or add this to readme to show that you have to implement this in application \n. >Although this makes the GCM callback useless\nMyabe you a right, but when app use GCM you can lose events not only when your app have updated bay when GCM itself have updated also. And after GCM update you get GCM callback call  but don't get ACTION_MY_PACKAGE_REPLACED...\nGCM update is hard to test.. ",
    "adnanharis": "We are also facing issues with Xiaomi, Oppo like phones where periodic scheduler's interval is unexpected. \n@vRallev your FAQ link is broken. Updated FAQ. ",
    "abhishek-cashify": "Check out the following link . It thoroughly discusses the topic.\nEffect of swiping an android app in recent app list\n. ",
    "coder966": "Sorry didn't notice that file.\nOne more question, Does setRequiredNetworkType(JobRequest.NetworkType.CONNECTED) grantee a real active Internet connection or just checks the connectivity to a network that may not have an actual Internet ? Like does it work in Doze mode (wait for an execution window where Internet connections are allowed) ?\nThank you for your quick response.. If all requirements are met, the job still not executed (in case the app is already running). Is there like any limits on how many jobs are allowed to execute per minute ? I'm suspecting Doze mode to be the issue, but it is not ASAIK, since the app was running and the screen was on.. Thank you very much.. ",
    "kjayan": "public static int schedulePeriodicJob() {\n        return new JobRequest.Builder(TAG)\n                            .setPeriodic(JobRequest.MIN_INTERVAL, JobRequest.MIN_FLEX)\n                            .setRequiredNetworkType(JobRequest.NetworkType.ANY)\n                            .setPersisted(true)\n                            .setUpdateCurrent(true)\n                            .setRequirementsEnforced(true)\n                            .build()\n                            .schedule();\n    }\nThis is how I am scheduling the periodic job. This job runs when the app is running in foreground and background. I made the job run after reboot by using a Broadcast receiver for android.permission.RECEIVE_BOOT_COMPLETED. I am not able to run the job when the app is killed.\nI read that by using Alarm Manager, a job can be scheduled and executed even when the app is not running. If that is the case, why can't we do the same using this library?\n. Somehow, I couldn't make the app satisfying my requirements using this library. I had to run the job even if the app is killed. \nI tried firebase and GCM Network Manager and finally settled with GCMNetwork Manager to meet the requirements.\nThanks for the quick help. :-). ",
    "vijaysimhajoshi": "How did you manage to get the task running using GCMNetwork Manager post the app is killed?. ",
    "paveltech": "@kjayan hello, \ni am facing same issue can you share your working code when app killed. How you manage to do this.\nPlease this will be very helpful for me. . ",
    "shrikantsalunkhe": "I am also facing same issue. Please if it is working just share code. It would be helpful. Thanks. ",
    "AbhijitGite28": "Can Work Manager executes if the application is killed? . ",
    "nanugarg93": "I am having same problem that Job Scheduler is not working when the app is killed.. ",
    "cesards": "I've been so busy, but I wanted to ask something else. If you give me one more week Ill make a couple of more questions and I'll try to make a PR updating documentation as well ;-). ",
    "ShivamDev31": "Hi @vRallev Sorry for commenting on a closed issue.\nActually my query is similar to this one only. I want to listen to Connectivity change and whenever connectivity changes I want to start a service. Not sure how above mentioned method will help with that. What I want is an event like we used to get for CONNECTIVITY_CHANGE in BroadcaseReceiver below Android N.\nTIA. Got your point. \nSo my use case is I start a service with Network as requirement and return RESCHEDULE from onRunJob() and in the service first step I check internet is there or not, if its not there then I stop the service. \nSo the below method will start the service again when the network reconnects? \n public static void scheduleNetworkJob() {\n        new JobRequest.Builder(TAG)\n                .setExecutionWindow(TimeUnit.MINUTES.toMillis(1), TimeUnit.DAYS.toMillis(1))\n                .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED)\n                .build()\n                .schedule();\n    }. Hi, @vRallev can you please look into this whenever you get time. As the crashes are increasing with each passing day. Each day we are getting around 2000 crashes and this number is also increasing every day. The main issue is we are not able to reproduce it at our end on any of the Samsung devices so can't be sure of any fix we make.. ",
    "rcholley": "After the reboot I'm not able to see the log you provided, only the ones already pasted on first post.\nI found also this one:\n02-15 21:59:19.228 886-1070/? D/PowerManagerService: [api] handleWakeLockDeath : release WakeLock : PARTIAL_WAKE_LOCK              'com.evernote.android.job.JobManager' (uid=10226, pid=4357, ws=null) (elapsedTime=6461)\nThe reschedule log line is well displayed when the app is launched.\n\nThe JobManager is created in the Application.class\nWhen calling JobManager.instance().getAllJobRequests() I see my job, but I'm calling it from my app so the JobManager is created\nEven when I add it to the manifest, still same issue. \n\nI tried the JobUtil.hasBootPermission(context) it is returning true.\n. Ok I got it.\nI will try tonight the snasphot build and let you know.\nI cannot guarantee at 100% for the crash, but I don't see any crash pop up and nothing in the logs when filtering on my app. I will need to check the log without filter to be sure I'm not missing an exception. With the snapshot build the job is well reschedule on the device reboot! I tried to reboot 3 times, the job was rescheduled the 3 times.\nGood job!. Ok no problem, I will continue to use it and check if I see some side effects.\nThanks to you!. Thanks, you were right, you can close this issue.\nI didn't notice this 2 lines mean the job has been executed:\n07-19 11:23:42.961 27228-27244/? D/PlatformJobService: Run job, request{id=1, tag=MyGetProductsJob}, waited 01:02:08, interval 01:00:00, flex 00:05:00\n07-19 11:23:42.962 27228-27244/? I/JobExecutor: Executing request{id=1, tag=MyGetProductsJob}, context PlatformJobService\n. ",
    "VictorJava": "Hi @vRallev,\nThanks for your reply.\nYes it`s strongly right. Could you chek this on your android 4 os device?. ",
    "mario": "No, its a one off job and only one process.\nIts strange because afaik it only happens on alcatel phones which I dont\nhave access to :-/\nOn Tue, 21 Feb 2017 at 18:10, Ralf notifications@github.com wrote:\n\nIs this a periodic job? Otherwise a job can only run once. But maybe your\njob is crashing, then it tries to run the job again. Not sure what else\ncould be the problem. Are you using multiple processes in your app?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/145#issuecomment-281409752,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAAWshEwi7K1d6LAalX1OK3MG7GbAMocks5rexp4gaJpZM4MHlN8\n.\n. I am sure because the job finishes doing what it needs to do.\n\nNo phone, no logs :(\nOn Tue, 21 Feb 2017 at 18:20, Ralf notifications@github.com wrote:\n\nAnd you're sure that the job isn't crashing or gets stuck in a loop? I\nguess you can't attach a log either?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/145#issuecomment-281412771,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAAWssz5EK7WnGY94mzZaNSy1cg0_Iyeks5rexzRgaJpZM4MHlN8\n.\n. An operation which otherwise can't repeat repeats itself - and I see the job being run (didn't put the logging in place for the ID though). So to clarify:\n\n\nschedule a job\njob runs and finishes\nreboot\nsame operation/job happens again\n\nHere's the builder:\n        new JobRequest.Builder(AutoUploadJob.TAG)\n                .setExecutionWindow(30_000L, 40_000L)\n                .setRequiresCharging(syncedFolder.getChargingOnly())\n                .setRequiredNetworkType(syncedFolder.getWifiOnly() ? JobRequest.NetworkType.UNMETERED :\n                        JobRequest.NetworkType.ANY)\n                .setExtras(bundle)\n                .setPersisted(true)\n                .build()\n                .schedule();\n\nFor full disclosure, before switching to a library I was using Job Scheduler directly, and it exhibited the same behavior - my guess is that somewhere, somehow removing the job from the persistence layer (pending Intent?) fails and that's why it runs on boot again. I was hoping that the library was aware of such a problem, and would work around it since it uses several scheduling mechanisms underneath.\nDid I answer all your questions? :)\n. Okay, so I just made the app use 1.1.7-SNAPSHOT and initial findings seem to be positive.\nI've changed setPersisted(true) to setPersisted(false), and all jobs that don't finish running are re-scheduled on boot, but the ones that did finish are not scheduled!\nSo progress? Do we know why is this? Where are the relevant commits?. (Btw. I've tried setting setPersisted(false) before on 1.1.6 and that caused failed/non-completed jobs to never run on boot). Do you know when is 1.1.7 planned? :). Well if this is \"broken\" please dont fix it :D\nOn Thu, 23 Feb 2017 at 11:37, Ralf notifications@github.com wrote:\n\nI'm sorry about the delay. 1.1.7 only has this one change, which fixes the\nother issue where you probably found it, and it shouldn't affect your\nproblem.\nsetPersisted(..) is kinda broken at the moment. Like you said, jobs are\nrescheduled after the boot, although you set it to false. I don't know\nwhen I'll release 1.1.7, probably in a week. But you can safely use the\nsnapshot build for the moment.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/145#issuecomment-281957025,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAAWsk-88ZH7iEh2NXqd_MZVAzSOqkmNks5rfWGEgaJpZM4MHlN8\n.\n. Btw I will try 1.1.6 once more just in case.\n\nOn Thu, 23 Feb 2017 at 11:48, Mario \u0110ani\u0107 mario.danic@gmail.com wrote:\n\nWell if this is \"broken\" please dont fix it :D\nOn Thu, 23 Feb 2017 at 11:37, Ralf notifications@github.com wrote:\nI'm sorry about the delay. 1.1.7 only has this one change, which fixes the\nother issue where you probably found it, and it shouldn't affect your\nproblem.\nsetPersisted(..) is kinda broken at the moment. Like you said, jobs are\nrescheduled after the boot, although you set it to false. I don't know\nwhen I'll release 1.1.7, probably in a week. But you can safely use the\nsnapshot build for the moment.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/145#issuecomment-281957025,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAAWsk-88ZH7iEh2NXqd_MZVAzSOqkmNks5rfWGEgaJpZM4MHlN8\n.\n. OK, so 1.1.6 works when using combined with play services. Otherwise it's broken.. Still investigating btw, will keep you posted.. I agree with you - in theory :) Without Play Services, it schedules past jobs like crazy after boot. With Play Services, it properly schedules only jobs to execute after boot that haven't finished executing before the reboot/shut down.\n\nHow can I help debug?. I agree. But we double checked several times - Play Services (all good), No Play Services (all broken).\nLet me see when I can have a remote session with the user to debug this - scheduling millions of jobs is killing his phone :-/. I don't know either, but it fixes it shrug. Thank you!. @vRallev we're gonna try - it's really, really strange :-/. Can you clarify what would be used on Android 5 and 6 WITH and WITHOUT Play Services, just to be absolutely sure on what we're investigating? :). OK, so do you even have a theoretical reason why stuff would be broken without Play Services if it uses the same thing?. OK, and how do Play services help prevent that?. From what I've been told by the user later on, at least 2 devices (Android 5.0 and 6.0) and one with 7 (if I remember right) have experienced the issue.\nYes, to that particular user it happened with just Job Scheduler as well.. This is the relevant issue: https://code.google.com/p/android/issues/detail?id=195528\nSo a platform bug. The question is: can we workaround it?. Sure, but if the case is as described in the issue, wouldn't:\na) Job always be stored in /data/system/job/jobs.xml\nb) Once you start the system, JobScheduler itself would read it and run, SOMETIMES even before boot completed receiver. Follow-up on this, even if I'll investigate the commit you've mentioned:\n\nwhenever jobs work with the internal storage, all is fine. When they work with an SD card, on reboot they get repeated...\n\nStrage.... @vRallev I'll try to investigate more, but would appreciate collaboration :). No, definitely not for all the users who experience this.. So I've noticed one more bug report which might have something to do with this:\nhttps://code.google.com/p/android/issues/detail?id=215975. No, of course not :)\nUpdate: sorry, just saw everything after the first line. Sorry about no logs, wish I had them :-/\nJob creator should be registered properly since some jobs do start, but others don't. Anything else is ... strange. \nI'll close the question for now, sorry for bugging.\nOn Fri, 17 Mar 2017 at 19:45, Ralf notifications@github.com wrote:\n\nNo clue as the system controls that. Is your UI waiting until the job runs?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/154#issuecomment-287439808,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAAWsqAd8g70IY_DLw_jbbbK-AWT2uHqks5rmtTEgaJpZM4Mg8q9\n.\n. I just wanted to follow up on this. I've identified at least one group of users with \"flawed\" functionality.\n\n\nGo on 4G network\nSet job to only run on wifi\nJob is created\nGo back to wifi\nJob never runs\nReboot the phone\nJobs run (while on wifi)\n\nShouldn't the jobs just run when wifi appears?. Not on any of my phones, but a lot of users who can have Galaxy S6 so I'll try to get ahold of that phone.. Seems to be the same as #153 - if so, please close.. I think you've misdiagnosed the problem. I don't know what fix @vRallev implemented, but the real issue is in using telephony, rather than data roaming check.\nhttps://github.com/evernote/android-job/pull/167. Yea so this is broken too. I've tested my PR in real-world conditions and it works.\nThanks for showing the updated code @danielkucera . @danielkucera no sorry, I do not use owncloud clearly - sorry :). @vRallev would be happy to, but fails to resolve for now :). Nevermind ... :). @vRallev works, thanks!. Putting this here, just in case:\n04-09 23:04:55.656 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: *job.delay* creator uid is: 1000\n04-09 23:04:59.440 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: *job.delay* creator uid is: 1000\n04-09 23:05:24.171 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: *job.delay* creator uid is: 1000\n04-09 23:05:24.222 9293-10462/? I/JobExecutor: Executing request{id=1, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.237 9293-10463/? I/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.296 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: *job.delay* creator uid is: 1000\n04-09 23:05:24.472 9293-10462/? I/JobExecutor: Executing request{id=4, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.476 9293-10464/? I/JobExecutor: Executing request{id=3, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.481 9293-10465/? I/JobExecutor: Executing request{id=2, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.483 9293-10463/? I/JobExecutor: Finished job{id=4, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.487 9293-10467/? I/JobExecutor: Executing request{id=5, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.488 9293-10466/? I/JobExecutor: Finished job{id=3, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.491 9293-10468/? I/JobExecutor: Finished job{id=2, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.495 9293-10463/? I/JobExecutor: Finished job{id=5, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:11:05.327 1223-1308/? W/JobInfo: Specified flex for 108438 is +57m36s0ms. Clamped to +1h12m0s0ms\n. For some reason, this happens on reboot/package replace. All previous jobs are executed again. Testing with this PR now.. Ergh, sorry, wrong issue where I've pasted stuff :-/. You can close this issue now though, it's fixed!. @vRallev glad we found a solution together nevertheless. Now we only need to find why jobs repeat themselves after reboot even if they're finished :). @vRallev no, sorry xD Thanks :D. Thanks. Will try testing this tomorrow.. @vRallev waiting on client testing :-/. Works. Please merge.. (Now I'm double checking if it works without play store dep as well :-/). Strange...so just by installing new version of the app it starts uploading stuff :-/\nRelated to the alarmmanager log I pasted in one of the other issues?. So far, identified brands include:\nHuawei, VFD, Some Nexus phones (LG mainly from what I've gathered), LG phones. So it repeats the jobs, but after they're finished (for the second time!) ... it won't repeat them again after reboot. Doing a bit more long-term testing to see if it starts issuing jobs at random at a later time.. That could be the case, but why:\nA) are they only ran after reboot\nB) are only ran if there are no play services\nOn Mon, 10 Apr 2017 at 10:18, Ralf notifications@github.com wrote:\n\nThe log looks good to me. No job did run twice, but instead it seems like\nyou've scheduled the same job multiple times.\n04-09 23:04:55.656 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: job.delay creator uid is: 1000\n04-09 23:04:59.440 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: job.delay creator uid is: 1000\n04-09 23:05:24.171 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: job.delay creator uid is: 1000\n04-09 23:05:24.222 9293-10462/? I/JobExecutor: Executing request{id=1, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.237 9293-10463/? I/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.296 1223-1409/? W/AlarmManager: mIsScreenOn is: true, WAKEUP alarm talarm.operation == null,package name is: android listenerTag is: job.delay creator uid is: 1000\n04-09 23:05:24.472 9293-10462/? I/JobExecutor: Executing request{id=4, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.476 9293-10464/? I/JobExecutor: Executing request{id=3, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.481 9293-10465/? I/JobExecutor: Executing request{id=2, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.483 9293-10463/? I/JobExecutor: Finished job{id=4, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.487 9293-10467/? I/JobExecutor: Executing request{id=5, tag=AutoUploadJob}, context PlatformJobService\n04-09 23:05:24.488 9293-10466/? I/JobExecutor: Finished job{id=3, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.491 9293-10468/? I/JobExecutor: Finished job{id=2, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:05:24.495 9293-10463/? I/JobExecutor: Finished job{id=5, finished=true, result=SUCCESS, canceled=false, periodic=false, class=AutoUploadJob, tag=AutoUploadJob}\n04-09 23:11:05.327 1223-1308/? W/JobInfo: Specified flex for 108438 is +57m36s0ms. Clamped to +1h12m0s0ms\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/pull/173#issuecomment-292880797,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAAWssRb7ivqOJa-qm2P9RPQF3MLe0vEks5rueXPgaJpZM4MzI6V\n.\n. I would also vote for supporting this.. Well rather than introducing UNKNOWN, why not just set it to ANY? That's as good as UKNOWN with the benefit of not introducing another variable.. Sure, I just bugged @tobiasKaminsky  to do it for something else :P\nCheck isOnlineWithWifi method here:\nhttps://github.com/nextcloud/android/pull/2352/files\n\nAnd my explanation here:\nhttps://github.com/nextcloud/android/pull/2352#issuecomment-373310256. Now that I think about it, NOT ROAMING is appropriate return value, but maybe poorly worded for this particular use case. It means metered (since it's not unmetered), it's just the fact that it would be good to know if it's via WIFI or VIA mobile.. Sounds good, thanks.. ",
    "AndyScherzinger": "\nDo you know when is 1.1.7 planned? :)\n\n@vRallev any infos on the date? Just asking since like @mario mentioned we are using the snapshot at the moment but for a release of the app we would of course like to use a stable release version and 1.1.6 seems to cause the problems @mario described. Just want to make sure we can bank on a stable version \ud83d\ude04 \nThanks for all the work you are putting into this library! \ud83d\udc4d . @vRallev I can't explain, just telling what @mario told me and regarding the app we are working on I am just not wanting to do a release with a SNAPSHOT dependency, that's all. So again thank you very much for doing a stable even if it is just for us! \ud83d\udc4f . ",
    "georgikoemdzhiev": "Thank you for your answer! Yes, I saw the FAQ before and actually this is how I found how to schedule a job that runs every day at a specific time. However, the code above does not run on the same day once schedules. For example, If I schedule a task at 9:40am for 10:00am (the code above) it dose not run at all. I see this in the console when the taks is schedules but never runs at 10:00am. Not sure what I am doing wrong:\nD/JobProxy24: Schedule one-off jobInfo success, request{id=1, tag=StartSleepingHoursJob}, start 10:00:31 (+17225 days), end 10:05:31 (+17225 days), reschedule count 0. Thank you for your suggestion! Really did not notice that.. Thank you for your comment. If the question is out of the scope of the library that is fine. I will close the ticket now. Thanks! :) . ",
    "nextdimension": "Ok, I got it working.......The instructions page is severely lacking, I had to read the javadoc and then it was simple. The examples here are very out of date. I would suggest maybe updating the instructions and 100% the sample app needs updating. . Ok, maybe I was a bit harsh, I apologize for that. The documentation is not that bad, I was just slightly frustrated because I was missing the point that I needed to actually execute the schedule. I expected that when I called JobManager.create(this).addJobCreator(new MySchedule()), that it would automatically queue up the job, but of course this is not the case. I have to manually execute the job schedule, just as I do with a normal service. Then when I tried to view the demos they were using some old version, which got me even more frustrated.  tldr: Its my fault, im sorry.. ",
    "gr8woo": "Thank you :). ",
    "jsu4650": "Can you please release a version with this fix soon, I am facing this crash in my production build. Thanks in advance :). Thank you! :). ",
    "AlejandroHCruz": "Any estimations about when this will be released? :). Wouldn't the regular \"ignore battery optimizations\" settings do the trick for OnePlus too?\nval intent = Intent()\nintent.action = Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS\nactivity.startActivity(intent). ",
    "beylerian": "JobApi.getDefault\n-> GCM.isSupported \n-> GcmAvailableHelper.isGcmApiSupported -> GcmAvailableHelper.isGcmServiceRegistered\nLooks like if the service doesn't register, it will not use it.\nThere could be issues with jobs previously created (when the service did register), but need to confirm.. -> GcmAvailableHelper.isGcmApiSupported:\n...\nreturn GCM_IN_CLASSPATH\n                    && GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context) == ConnectionResult.SUCCESS\n                    && isGcmServiceRegistered(context) == ConnectionResult.SUCCESS;\n...\nI think GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context) == ConnectionResult.SUCCESS will check that.. ",
    "Ernest-su": "@beylerian My assumption is GCM is enable ,BUT can't connect to GCMServer. @beylerian Thanks. . ",
    "Kunal8337": "Can it be Device issue? because ,On my Nexus it is working fine. But on\nSamsung, it seems to fail.\nAndroid M. 6.0.1\nOn Fri, Mar 24, 2017 at 5:44 PM, Ralf notifications@github.com wrote:\n\nHi, on which Android version is this happening? How do do you schedule\nyour job?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/159#issuecomment-289007298,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AYv9ZIJaLMmy0faY0JJnFa2fH-tnBXW3ks5ro7OKgaJpZM4MoK6Y\n.\n. \n",
    "mradzinski": "Thanks. My main question is due to the use of android.intent.action.QUICKBOOT_POWERON which to me seems to be an implicit broadcast receiver. At least is not listed on the exceptions. Yes, I assumed the exact same thing, but it's not a bad idea to open an issue as you said. Want me to open it or you'll take care of it?. I opened up an issue on their tracker: https://issuetracker.google.com/u/1/issues/36622480. Go ahead and star it. Let's hope its just an omission in the documentation and nothing else.. ",
    "aminelaadhari": "Ok thanks for the explanation, and no worries, I understand.\nA few points to explain my choice instead of adding a method to add a printer: \n- You provide proguard consumer rules, so I assumed that it's ok to rely on Cat library auto tags (I am not a big fan of this technique though).\n- Also, for bug reports, I think it's the reporter responsibility to provide deobfuscated stack traces.\nI will take a look into your new PR and let you know.\nThanks \n. @vRallev works well but with an issue concerning my use case \nI already have an Android Logger using Timber like library.\nSo if I add my logger, JobManager logs will be duplicated.\nIs there a way to disable it's default logger?\n. @vRallev works well, thanks! . ",
    "PaulWoitaschek": "When is the next release scheduled?. I see this crash too. I don't use multi processes.\nHowever the builder class has a flaw which could cause this. It generates an id upon builder creation, not upon build.\nSo something like this:\n```java\npublic class App extends Application {\n@Override public void onCreate() {\n    super.onCreate();\nJobManager.create(this)\n    .addJobCreator(new JobCreator() {\n      @Override public Job create(String tag) {\n        return new Job() {\n          @NonNull @Override protected Result onRunJob(Params params) {\n            return Result.SUCCESS;\n          }\n        };\n      }\n    });\n\nfinal JobRequest.Builder builder = new JobRequest.Builder(\"tag\")\n    .setExecutionWindow(1000, 2000);\nbuilder.build().schedule();\nbuilder.build().schedule();\n\n}\n}\n```\nWill immediately throw the SQLiteConstraintException. I don't reuse my builder instances but when touching the JobManager from different threads it will cancel each job id multiple times:\n04-15 09:28:28.066 7604-7632/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10403, tag=tag}, canceling\n04-15 09:28:28.069 7604-7708/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10395, tag=tag}, canceling\n04-15 09:28:28.073 7604-7715/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10403, tag=tag}, canceling\n04-15 09:28:28.077 7604-7706/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10460, tag=tag}, canceling\n04-15 09:28:28.081 7604-7702/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10460, tag=tag}, canceling\n04-15 09:28:28.086 7604-7709/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10467, tag=tag}, canceling\n04-15 09:28:28.091 7604-7707/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10459, tag=tag}, canceling\n04-15 09:28:28.095 7604-7638/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10395, tag=tag}, canceling\n04-15 09:28:28.100 7604-7713/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10388, tag=tag}, canceling\n04-15 09:28:28.106 7604-7712/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10395, tag=tag}, canceling\n04-15 09:28:28.110 7604-7717/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10395, tag=tag}, canceling\n04-15 09:28:28.115 7604-7710/de.paul_woitaschek.evernotecrash I/JobManager: Found pending job request{id=10395, tag=tag}, canceling. It's still happening with 1.1.10;\n```\nError Code : 1555 (SQLITE_CONSTRAINT_PRIMARYKEY)\nCaused By : Abort due to constraint violation.\n    (UNIQUE constraint failed: jobs._id (code 1555))\ncom.evernote.android.job.JobStorage.store (SourceFile:243)\ncom.evernote.android.job.JobStorage.put (SourceFile:125)\ncom.evernote.android.job.JobManager.schedule (SourceFile:231)\n```. Can you reopen this?\nFatal Exception: android.database.sqlite.SQLiteConstraintException: PRIMARY KEY must be unique (code 19)\n       at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(SQLiteConnection.java)\n       at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:972)\n       at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)\n       at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\n       at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1590)\n       at android.database.sqlite.SQLiteDatabase.insertOrThrow(SQLiteDatabase.java:1486)\n       at com.evernote.android.job.JobStorage.store(SourceFile:243)\n       at com.evernote.android.job.JobStorage.put(SourceFile:125)\n       at com.evernote.android.job.JobManager.schedule(SourceFile:231)\n       at com.evernote.android.job.JobRequest.schedule(SourceFile:366)\n       at com.evernote.android.job.JobRescheduleService.onHandleIntent(SourceFile:60)\n       at android.app.IntentService$ServiceHandler.handleMessage(IntentService.java:65)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:146)\n       at android.os.HandlerThread.run(HandlerThread.java:61). New week has begun. Any news on this?. No more crashes here either.. For me it's an Android 7 device, crashlytics reports as not rooted.\nWhat is the reason this crashes?. ",
    "jplazcano87": "thanks, but my app is crashing in prod. now i have to send an update :(. ",
    "danielkucera": "Updated code looks like this.\n@vRallev probably you should check for networkInfo.isRoaming() really\npublic static JobRequest.NetworkType getNetworkType(@NonNull Context context) {\n    ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();\n    if (networkInfo == null || !networkInfo.isConnectedOrConnecting()) {\n        return JobRequest.NetworkType.ANY;\n    }\n\n    boolean metered = ConnectivityManagerCompat.isActiveNetworkMetered(connectivityManager);\n    if (!metered) {\n        return JobRequest.NetworkType.UNMETERED;\n    }\n\n    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);\n    if (telephonyManager != null && telephonyManager.isNetworkRoaming()) {\n        return JobRequest.NetworkType.CONNECTED;\n    } else {\n        return JobRequest.NetworkType.NOT_ROAMING;\n    }\n}\n\n. @mario do you have a working updated owncloud apk? could you send it to me? my e-mail is in my Github profile.. I also confirm it works. Thank you guys for cooperation :). I didn't test the the patch in #166 but this makes more sense to me too.. ",
    "subhasha1": "Apprentice prompt response!!. appreciate. ",
    "kurtisnelson": "Proguard also generally discards the classes involved in enums.. ",
    "v4-adi": "@vRallev I suggest you watch this video  on enums .. ",
    "tatocaster": "```java\nmSyncService.getLastSyncDateFromServiceObservable()\n                .subscribe(\n                        lastSyncDate -> {\n                            // something\n                        }, error -> Log.e(TAG, \"onError: \", error)\n                );\n    return Result.RESCHEDULE;\n\n```\nyeah, here it is. \nit's clear now, I missed point that, setUpdateCurrent with parameter false will not cancel current running job and schedule new one. According to this, RESCHEDULE is no more needed, and seems more clear.\n. but why? Firebase Job Dispatcher allows us to run async on start. here and returns true, that means job is not finished yet. but it runs in background thread. \nof course I can make my call as blocking and whole operations blocking using RxJava (too simple), but why exactly? Do you think  this is a main problem here ?\n. OK, that was clear explanation.\nThank you, very much!\nI will refactor to a blocking call and schedule job when it needs to updateCurrent or not. \nI will close this issue and open new if something unexpected will occur.. \nthanks. . I can reproduce bug only on 4.4.2. I see lots of crashes in Crashlytics. Play services 12.0.1, Android-job 1.2.5.\nPlay Services 15.0.0 works at this moment without any workarounds. \n@s-hocking  how? It works for me atm. Hmm, that's weird. Will try to investigate more about this bug but as a hotfix, I shipped a new version with 15.0.0 to avoid most crashes caused by 12.0.1. Google f@$%ed up seriously. . UPDATE: 15.0.0 is not fully working solution. It solves most of the crashes but I still got some crashes in Crashlytics from 15.0.0, which I could not reproduce on emulator anymore. The workaround above + v15.0.0 works right now. Let's see what will happen.. ",
    "fmendes6": "Awesome, thanks a lot for the help and for releasing this library!\nCheers!. ",
    "nitzanj": "I want to use it for an open source project which is currently under the MIT license. We'll review our options and may use this library eventually...\nThanks.. ",
    "eggcaker": "same issue +1. @vRallev  looks the snapshot build fixed this issue. I use the latest version (1.1.11), i start a job from application, somehow i got around 4K rows in the evernote_jobs table then the app cannot start any more, do i need check the total jobs i have then delete from db ?. Okay. I need check the code make sure not make the app crash before the job execute . Thanks . or you can catch the JobManagerException when you call JobManager.create(). @doc-rj  same as us with the unitest run  i guess just because the context issue. Maybe just specific device or rom issue(OnePlus with 7.1.1), close for now. will open if had more informations.. ",
    "mtrakal": "Upgrade app in google play.\nUpdated android job from 1.1.9 to 1.1.10.\nOnly Samsung and Lenovo devices crashing:\nGalaxy Note7 - 35%\nGalaxy S4 Mini - 13%\nGalaxy Note 8.0 - 13%\nGalaxy Tab3V 7.0 - 13%\nGalaxy S3 - 13%\nGalaxy S5 - 13#\nLenovo VIBE X3 Lite\nAfter upgrade few users get:\n```\nFatal Exception: java.lang.RuntimeException: Unable to create application com.droid4you.application.wallet.Application: android.database.sqlite.SQLiteConstraintException: UNIQUE constraint failed: jobs._id (code 1555)\n\nError Code : 1555 (SQLITE_CONSTRAINT_PRIMARYKEY)\nCaused By : Abort due to constraint violation.\n    (UNIQUE constraint failed: jobs._id (code 1555))\n\n   at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6319)\n   at android.app.ActivityThread.access$1800(ActivityThread.java:221)\n   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1860)\n   at android.os.Handler.dispatchMessage(Handler.java:102)\n   at android.os.Looper.loop(Looper.java:158)\n   at android.app.ActivityThread.main(ActivityThread.java:7224)\n   at java.lang.reflect.Method.invoke(Method.java)\n   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\n\nCaused by android.database.sqlite.SQLiteConstraintException: UNIQUE constraint failed: jobs._id (code 1555)\n\nError Code : 1555 (SQLITE_CONSTRAINT_PRIMARYKEY)\nCaused By : Abort due to constraint violation.\n    (UNIQUE constraint failed: jobs._id (code 1555))\n\n   at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(SQLiteConnection.java)\n   at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:915)\n   at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)\n   at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\n   at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1609)\n   at android.database.sqlite.SQLiteDatabase.insertOrThrow(SQLiteDatabase.java:1505)\n   at com.evernote.android.job.JobStorage.store(SourceFile:243)\n   at com.evernote.android.job.JobStorage.put(SourceFile:125)\n   at com.evernote.android.job.JobManager.schedule(SourceFile:231)\n   at com.evernote.android.job.JobRequest.schedule(SourceFile:366)\n   at com.droid4you.application.wallet.jobs.internal.BaseJob.schedulePeriodicJob(SourceFile:69)\n   at com.droid4you.application.wallet.jobs.internal.BaseJob.schedule(SourceFile:27)\n   at com.droid4you.application.wallet.jobs.internal.JobsEnum.scheduleAll(SourceFile:70)\n   at com.droid4you.application.wallet.Application.initJobs(SourceFile:271)\n   at com.droid4you.application.wallet.Application.onCreate(SourceFile:189)\n   at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1036)\n   at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6316)\n   at android.app.ActivityThread.access$1800(ActivityThread.java:221)\n   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1860)\n   at android.os.Handler.dispatchMessage(Handler.java:102)\n   at android.os.Looper.loop(Looper.java:158)\n   at android.app.ActivityThread.main(ActivityThread.java:7224)\n   at java.lang.reflect.Method.invoke(Method.java)\n   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1230)\n   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1120)\n\n```\nBaseJob.java\n```\n    private int schedulePeriodicJob() {\n        long timeDiff = getTimeIntervalFromExactTimeOrTomorrow(getTimeToShow());\n    JobRequest.Builder builder = new JobRequest.Builder(getJobEnum().getTag())\n            .setExecutionWindow(timeDiff, timeDiff + DateHelper.ONE_MINUTE)\n            .setUpdateCurrent(true)\n            .setPersisted(true)\n            .setUpdateCurrent(true);\n    addSpecialParamsToJobRequest(builder);\n    JobRequest jobRequest = builder.build();\n    int jobId = jobRequest.schedule();\n    Ln.d(\"Job \" + getJobEnum().getTag() + \" scheduled at \" + DateTime.now().plusMillis((int)jobRequest.getStartMs()).toString());\n    return jobId;\n}\n\n``. @vRallev I will, thanks for hint. I'll notify after release new apk to play store. Thanks. @vRallev looks fixed withcompile 'com.evernote:android-job:1.1.11-SNAPSHOT'.\nNo new crashes on it in Fabric. Thanks.implementation 'com.evernote:android-job:1.2.6'`\nFatal Exception: java.lang.RuntimeException: Unable to create application com.droid4you.application.wallet.Application: com.evernote.android.job.JobManagerCreateException: All APIs are disabled, cannot schedule any job\nGalaxy S5 Mini: 6.0.1 (SM-G800H)\nNever seen before on older android-job versions. User is using our app for 5 months, so it didn't crashed on 1.2.5 or previous, but start with 1.2.6 (for now just one user with one crash). We try to cache only when job is not yet finished, so maybe it's relevant?\n```\nprivate BaseJob mBaseJobInstance;\npublic BaseJob getBaseJob() {\n        try {\n            if (mBaseJobInstance == null || mBaseJobInstance.isFinished()) {\n                mBaseJobInstance = mBaseJobClass.newInstance();\n            }\n            mBaseJobInstance.initJob(mJobsConfigCallback.getPersistentConfig());\n        } catch (InstantiationException e) {\n            Ln.e(e);\n        } catch (IllegalAccessException e) {\n            Ln.e(e);\n        }\n        return mBaseJobInstance;\n    }\n``BaseJobis extendedcom.evernote.android.job.Job`. Thanks, I remove it, I will inform when we will still handle some issues with it.\nThanks again for your help.. Thanks, we will try to put it into background async task.\nI was thinking (but thinking is not enough) that it's doing in background in lib.. Have same. Only Samsung devices, only Android 4.\nplayServicesVersion = '15.0.0'\nGalaxy S4 Mini 69%\nGalaxy Tab E 9.6 20%\nGalaxy S3 Neo 7%\nGalaxy Grand Neo Plus 2%\nGalaxy Tab3 Lite 7.0 2%\nCaused by java.lang.IllegalArgumentException: The GcmTaskService class you provided com.evernote.android.job.gcm.PlatformGcmService does not seem to support receiving com.google.android.gms.gcm.ACTION_TASK_READY\n       at com.google.android.gms.gcm.GcmNetworkManager.zze(Unknown Source)\n       at com.google.android.gms.gcm.GcmNetworkManager.getInstance(Unknown Source)\n       at com.evernote.android.job.gcm.JobProxyGcm.cancel(JobProxyGcm.java:111)\n       at com.evernote.android.job.JobManager.cancelInner(JobManager.java:399)\n       at com.evernote.android.job.JobManager.cancelAllInner(JobManager.java:422)\n       at com.evernote.android.job.JobManager.cancelAllForTag(JobManager.java:1393)\n       at com.evernote.android.job.JobRequest.schedule(JobRequest.java:436)\n       at com.droid4you.application.wallet.jobs.internal.BaseJob.scheduleJob(BaseJob.java:66)\n       at com.droid4you.application.wallet.jobs.internal.BaseJob.schedule(BaseJob.java:27)\n       at com.droid4you.application.wallet.jobs.internal.JobsEnum$ScheduleAllAsyncTask.doInBackground(JobsEnum.java:104)\n       at com.droid4you.application.wallet.jobs.internal.JobsEnum$ScheduleAllAsyncTask.doInBackground(JobsEnum.java:95)\n       at android.os.AsyncTask$2.call(AsyncTask.java:288)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n       at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\n       at java.lang.Thread.run(Thread.java:841)\nMaybe some bug in PlayServices?. 1.3.0-alpha04 with archWork 1.0.0-alpha04\n2018-07-23 12:59:01.473 20935-20961/com.droid4you.application.wallet.debug E/AndroidRuntime: FATAL EXCEPTION: AsyncTask #1\n    Process: com.droid4you.application.wallet.debug, PID: 20935\n    java.lang.RuntimeException: An error occurred while executing doInBackground()\n        at android.os.AsyncTask$3.done(AsyncTask.java:353)\n        at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:383)\n        at java.util.concurrent.FutureTask.setException(FutureTask.java:252)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:271)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n        at java.lang.Thread.run(Thread.java:764)\n     Caused by: java.lang.IllegalStateException: Cannot invoke removeObserver on a background thread\n        at android.arch.lifecycle.LiveData.assertMainThread(LiveData.java:435)\n        at android.arch.lifecycle.LiveData.removeObserver(LiveData.java:217)\n        at android.arch.lifecycle.MediatorLiveData$Source.unplug(MediatorLiveData.java:145)\n        at android.arch.lifecycle.MediatorLiveData.onInactive(MediatorLiveData.java:126)\n        at android.arch.lifecycle.LiveData$ObserverWrapper.activeStateChanged(LiveData.java:413)\n        at android.arch.lifecycle.LiveData.observeForever(LiveData.java:207)\n        at com.evernote.android.job.work.JobProxyWorkManager.getWorkStatusBlocking(JobProxyWorkManager.java:180)\n        at com.evernote.android.job.work.JobProxyWorkManager.isPlatformJobScheduled(JobProxyWorkManager.java:109)\n        at com.evernote.android.job.JobRescheduleService.rescheduleJobs(JobRescheduleService.java:112)\n        at com.evernote.android.job.JobRescheduleService.onHandleWork(JobRescheduleService.java:87)\n        at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:391)\n        at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:382)\n        at android.os.AsyncTask$2.call(AsyncTask.java:333)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\u00a0\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\u00a0\n        at java.lang.Thread.run(Thread.java:764)\u00a0\n2018-07-23 12:59:01.512 20935-20961/com.droid4you.application.wallet.debug W/System.err: java.lang.RuntimeException: An error occurred while executing doInBackground()\n2018-07-23 12:59:01.512 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.os.AsyncTask$3.done(AsyncTask.java:353)\n2018-07-23 12:59:01.512 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:383)\n2018-07-23 12:59:01.513 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at java.util.concurrent.FutureTask.setException(FutureTask.java:252)\n2018-07-23 12:59:01.513 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at java.util.concurrent.FutureTask.run(FutureTask.java:271)\n2018-07-23 12:59:01.513 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n2018-07-23 12:59:01.513 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n2018-07-23 12:59:01.513 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at java.lang.Thread.run(Thread.java:764)\n2018-07-23 12:59:01.513 20935-20961/com.droid4you.application.wallet.debug W/System.err: Caused by: java.lang.IllegalStateException: Cannot invoke removeObserver on a background thread\n2018-07-23 12:59:01.514 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.arch.lifecycle.LiveData.assertMainThread(LiveData.java:435)\n2018-07-23 12:59:01.514 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.arch.lifecycle.LiveData.removeObserver(LiveData.java:217)\n2018-07-23 12:59:01.514 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.arch.lifecycle.MediatorLiveData$Source.unplug(MediatorLiveData.java:145)\n2018-07-23 12:59:01.514 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.arch.lifecycle.MediatorLiveData.onInactive(MediatorLiveData.java:126)\n2018-07-23 12:59:01.514 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.arch.lifecycle.LiveData$ObserverWrapper.activeStateChanged(LiveData.java:413)\n2018-07-23 12:59:01.514 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.arch.lifecycle.LiveData.observeForever(LiveData.java:207)\n2018-07-23 12:59:01.514 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at com.evernote.android.job.work.JobProxyWorkManager.getWorkStatusBlocking(JobProxyWorkManager.java:180)\n2018-07-23 12:59:01.515 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at com.evernote.android.job.work.JobProxyWorkManager.isPlatformJobScheduled(JobProxyWorkManager.java:109)\n2018-07-23 12:59:01.515 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at com.evernote.android.job.JobRescheduleService.rescheduleJobs(JobRescheduleService.java:112)\n2018-07-23 12:59:01.515 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at com.evernote.android.job.JobRescheduleService.onHandleWork(JobRescheduleService.java:87)\n2018-07-23 12:59:01.515 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:391)\n2018-07-23 12:59:01.515 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:382)\n2018-07-23 12:59:01.515 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at android.os.AsyncTask$2.call(AsyncTask.java:333)\n2018-07-23 12:59:01.515 20935-20961/com.droid4you.application.wallet.debug W/System.err:     at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n2018-07-23 12:59:01.515 20935-20961/com.droid4you.application.wallet.debug W/System.err:    ... 3 more. can't reproduce by myself, but crash for 300 users in last 30 days.. Maybe related to: https://github.com/evernote/android-job/issues/255\nand https://issuetracker.google.com/issues/115560697 but not sure, it looks a bit different...\nHave no idea how to reproduce yet, will investigate on some Samsung device... But we don't have Flagship on which it crashed, just some \"hacked\" Samsung with a forced update to 8.0.\n. It's maybe not a device, but platform only specific (8.0.0), because of next (same) issue on ONEPLUS but with different lines: http://crashes.to/s/e6adecdd68b. Neither me, so I think, that related to Arch, and hope, that maybe one time will be fixed. Closing this issue here.. ",
    "fAns1k": "right, but when we don't meet requirements (like connection, etc) - there are no callbacks in the job, right? just reschedule every time we don't meet requirements.. i meant callback similar to android async task:\nonPreExecute, onBackground, onPostExecute.\nBut in this case it could be: onBeforeRun, onRun, onAfterRun, or something similar.. In this case my job will be executed every time even if requirements were not met. it's the same as just to run a job.... ",
    "Vigi0303": "Of course it's not necessary, not an issue. Even not an IDE issue in my opinion.\nIt's just an elegant practice on gradle script in here.\nWhen press Ctrl+N, and input an class name within support-v4, this pr only help to remove the 24.0.0 version result, that otherwise 2 ones will be shown.\nSo it only helps people that is elegant-code freak like me.\nIf you don't care about it, just ignore it. It's ok.\n. ",
    "letos": "I'm sorry, it's really 1.1.9.\nI looked at grepcode 4.0.3: http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.0.3_r1/android/database/sqlite/SQLiteDatabase.java/ Database extends SQLiteClosable, which not implement Closeable. \nCrash is from fabric, I wan't reproduce too. \nIncluded via Gradle:  compile 'com.evernote:android-job:1.1.9'. ",
    "mohitagrawal": "@vRallev  - Your link is broken !. ",
    "krokyze": "Probably the only solution is copying default error handler.\nHere's another LG device mentioned with the same error: https://issuetracker.google.com/issues/37019699 . ",
    "tilmanginzel": "The confusing part is probably the comment Network must not be connected, as it indicates that a connected network will not allow this job to run. Maybe change it to something like Network does not have to be connected?. ",
    "SwiftyWang": "thanks @tilmanginzel @vRallev . @vRallev I schedule job when application oncreate. After test, when my app start, the onRunJob callback will be called immediately...\nhere is my job code.\nprivate void scheduleNetworkJob() {\n        int jobId = new JobRequest.Builder(NetworkChangeJob.TAG)\n                .setPeriodic(JobRequest.MIN_INTERVAL)\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n                .setPersisted(true)\n                .setUpdateCurrent(true)\n                .build()\n                .schedule();\n    }. ",
    "JairAviles": "@saturov I did create a sample project using AndroidJob as a Dagger2 dependency. You may take a look on it:\nhttps://github.com/JairAviles/AndroidJobDemo. @vRallev How did you disable the GCM API ? By not adiding the library on the gradle file?. Did the same configuration, however, I got the following exception when running my application\n```\nW/JobConfig: setApiEnabled - GCM, false\nI/art: Rejecting re-init on previously-failed class java.lang.Class: \njava.lang.NoClassDefFoundError: Failed resolution of: Landroid/app/job/JobServiceEngine;\nCaused by: java.lang.ClassNotFoundException: Didn't find class \n\"android.app.job.JobServiceEngine\" on path: DexPathList[[\nzip file \"/data/app/br.com.ahgora.ahgorapool-1/base.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_dependencies_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_0_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_1_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_2_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_3_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_4_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_5_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_6_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_7_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_8_apk.apk\", \nzip file \"/data/app/br.com.ahgora.ahgorapool-1/split_lib_slice_9_apk.apk\"],nativeLibraryDi\n```\n. ",
    "hamberluo": "Fatal Exception: java.lang.IllegalArgumentException: No such service ComponentInfo{com.evernote.android.job.v21.PlatformJobService}\n       at android.os.Parcel.readException(Parcel.java:1624)\n       at android.os.Parcel.readException(Parcel.java:1573)\n       at android.app.job.IJobScheduler$Stub$Proxy.schedule(IJobScheduler.java:121)\n       at android.app.JobSchedulerImpl.schedule(JobSchedulerImpl.java:42)\n       at com.evernote.android.job.v21.JobProxy21.schedule(JobProxy21.java:174)\n       at com.evernote.android.job.v21.JobProxy21.plantPeriodic(JobProxy21.java:84)\n       at com.evernote.android.job.JobManager.schedule(JobManager.java:238)\n       at com.evernote.android.job.JobRequest.schedule(JobRequest.java:366)\n       at com.evernote.android.job.JobRescheduleService.onHandleIntent(JobRescheduleService.java:60)\n       at android.app.IntentService$ServiceHandler.handleMessage(IntentService.java:66)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:148)\n       at android.os.HandlerThread.run(HandlerThread.java:61). (4.2.1)OPPOR823TandroidLOG\u65e5\u5fd7-Testin\u4e91\u6d4b.zip\n. I cannot provider a thread dump or a reproducible example because this is happening in cloud testing.. But job service only available on 5.0 android devices.. Caused by java.lang.SecurityException: Caller no longer running, last stopped +1s803ms because: unexpectedly disconnected\n       at android.os.Parcel.readException(Unknown Source:69)\n       at android.os.Parcel.readException(Unknown Source:10)\n       at android.app.job.IJobCallback$Stub$Proxy.completeWork(Unknown Source:29)\n       at android.app.job.JobParameters.completeWork(Unknown Source:12)\n       at android.support.v4.app.JobIntentService$JobServiceEngineImpl$WrapperWorkItem.complete(JobIntentService.java:267)\n       at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:393)\n       at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:382)\n       at android.os.AsyncTask$2.call(Unknown Source:22)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n       at java.lang.Thread.run(Thread.java:764). ",
    "blackberry2016": "I still get Fatal Exception: java.lang.IllegalStateException: Apps may not schedule more than 100 distinct jobs\nversion 1.2.0. @vRallev When i restart the app, it runs all the jobs which don't run during \"Force Stop\" state. I have got the answer from 1.2.6 release note. ",
    "Khareesh0892": "@vRallev This is still happening in V1.2.5\nApp is going to crash loop (In prod). I could see 200+ crashes for a single user.\nHere is what i am doing...\n```\npublic class MyApplication extends Application {\n@Override\npublic void onCreate() {\n    super.onCreate();\n\n    // Initializing jobs\n    JobManager.create(this).addJobCreator(new AppJobCreator());\n    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N) {\n        JobConfig.setAllowSmallerIntervalsForMarshmallow(true);\n    }\n    SocketIOJob.schedule();\n}\n\n// some app related code here!\n\n}\n```\n/ Job Code /\n```\npublic class MyJob extends Job {\npublic static int schedule() {\n    Timber.i(\"Checking pre-scheduled jobs: %s\", JobManager.instance().getAllJobRequestsForTag(TAG));\n    Set<JobRequest> jobRequests = JobManager.instance().getAllJobRequestsForTag(TAG);\n    if (!jobRequests.isEmpty()) {\n        Timber.i(\"Existing %s: %d -> %s\", TAG, jobRequests.size(), jobRequests);\n        return jobRequests.iterator().next().getJobId();\n    }\n\n    long interval = JobRequest.MIN_INTERVAL; // every 15 minutes\n    long flex = JobRequest.MIN_FLEX; // wait 5 minutes before job runs again\n\n    Timber.i(\"Creating new: %s\", TAG);\n    return new JobRequest.Builder(TAG)\n            .setPeriodic(interval, flex)\n            .setUpdateCurrent(true)\n            .setRequirementsEnforced(false)\n            .build()\n            .schedule();\n}\n\n@NonNull\n@Override\nprotected Result onRunJob(@NonNull Params params) {\n    // job related code...\n}\n\n@Override\nprotected void onCancel() {\n    // cancelling job here..\n}\n\n```\nNeed help asap.. Ty. ",
    "sundxing": "I got this report in Android 6.0. I suspend android device may not finish boot?. ",
    "fxmeister": "@vRallev Now that 1.2.0 is out, this answer no longer works, as you anticipated. It seems the location for setting GcmApiEnabled, and setForceAllowApi14 have moved. What is the solution for 1.2.0?. @vRallev Is the memory leak fix coming to the stable release anytime soon?. # Platform: android\nOS Version: 6.0\nDevice: TECNO-N9S\nRAM Free: 18.7%\nDisk Free: 8.2%\n0. Crashed: main: 0 0 0x0000000000000000\n   at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4966)\n   at android.app.ActivityThread.-wrap1(ActivityThread.java)\n   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1553)\n   at android.os.Handler.dispatchMessage(Handler.java:111)\n   at android.os.Looper.loop(Looper.java:207)\n   at android.app.ActivityThread.main(ActivityThread.java:5737)\n   at java.lang.reflect.Method.invoke(Method.java)\n   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:789)\n   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:679)\n\n--\nFatal Exception: java.lang.RuntimeException: Unable to create application \nandroid.database.sqlite.SQLiteDatabaseLockedException: database is locked (code 5)\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4966)\n       at android.app.ActivityThread.-wrap1(ActivityThread.java)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1553)\n       at android.os.Handler.dispatchMessage(Handler.java:111)\n       at android.os.Looper.loop(Looper.java:207)\n       at android.app.ActivityThread.main(ActivityThread.java:5737)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:789)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:679)\nCaused by android.database.sqlite.SQLiteDatabaseLockedException: database is locked (code 5)\n       at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(SQLiteConnection.java)\n       at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:789)\n       at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:788)\n       at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:86)\n       at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1501)\n       at com.evernote.android.job.JobStorage.store(SourceFile:261)\n       at com.evernote.android.job.JobStorage.put(SourceFile:135)\n       at com.evernote.android.job.JobManager.schedule(SourceFile:192)\n       at com.evernote.android.job.JobRequest.schedule(SourceFile:408)\n       at com.example.jobs.JunkScanJob.schedule(SourceFile:74)\n       at com.example.jobs.JunkScanJob.schedule(SourceFile:59)\n       at com.example.application.Application.onCreate(SourceFile:77)\n       at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1018)\n       at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4963)\n       at android.app.ActivityThread.-wrap1(ActivityThread.java)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1553)\n       at android.os.Handler.dispatchMessage(Handler.java:111)\n       at android.os.Looper.loop(Looper.java:207)\n       at android.app.ActivityThread.main(ActivityThread.java:5737)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:789)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:679)\n. No idea. Just started using the library, I have two jobs setup through this library, both run on a daily basis and are an hour apart from each other.. Check FAQ: https://github.com/evernote/android-job/wiki/FAQ\nTDLR: By default network status takes a back seat to the time scheduled for execution. If you want to enforce the network_connected policy, use setRequirementsEnforced(true). ",
    "procedurallygenerated": "@vRallev For us all reports so far are from non-rooted LG devices running android 7.0. We only support api > 16. So we shouldn't see this error?\nOn API 24 & 25 android.app.job.JobService is supported. So why does the JobApi.getDefault(context) return a JobApi.V_14 object.. ",
    "wverdese": "\n@vRallev For us all reports so far are from non-rooted LG devices running android 7.0. We only support api > 16. So we shouldn't see this error?\n\nSame here, minSdk 16 and on Crashlytics we see a lot of \ncom.evernote.android.job.JobManagerCreateException: All APIs are disabled, cannot schedule any job \nespecially on non-rooted devices running android 7.0 (Moto G4). \n@vRallev could you please clarify how force allow JobConfig.forceApi(JobApi.V_14) and JobConfig.setApiEnabled(JobApi.GCM, false) could help in this scenario? . ",
    "Jeff11": "would this be the correct workaround?\n```\nprivate void setupJobManager() {\n  try {\n    JobManager.create(this).addJobCreator(new EvernoteJobCreator());\n  } catch (JobManagerCreateException e) {\n    JobConfig.forceApi(JobApi.V_14);\n    JobConfig.setApiEnabled(JobApi.GCM, false);\n    JobManager.create(this).addJobCreator(new EvernoteJobCreator());\n  }\n}. @henriquenfaria this is not fixing it. We have this exact issue as far back as 1.2.1.. I've found a way for me to reproduce this crash. I only need to start debug from Android Studio for my app. \nAlways getting\nCaused by: java.lang.SecurityException: Caller no longer running, last stopped +12s589ms because: timed out while starting\nI hope this helps to find a solution for this. I'm willing to investigate if anyone wants me to try something.. @Agraphie I just needed to start the app with the debugger from Android Studio and would get this crash. My app has a rather big Application class and JobManager.create(this) is in onCreate().\nStrangely, the crash is not happening anymore when starting the debugger.. Nice, @vRallev! Will try as soon as 1.3.0-alpha02 is available.. Got this on 1.3.0-alpha03 without WorkManager on different Huawei devices running Android 8.0.0\nFatal Exception: java.lang.RuntimeException: An error occurred while executing doInBackground()\n       at android.os.AsyncTask$3.done(AsyncTask.java:365)\n       at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:383)\n       at java.util.concurrent.FutureTask.setException(FutureTask.java:252)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:271)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n       at java.lang.Thread.run(Thread.java:784)\nCaused by java.lang.SecurityException: Caller no longer running, last stopped +1m17s624ms because: timed out while stopping\n       at android.os.Parcel.readException(Parcel.java:1945)\n       at android.os.Parcel.readException(Parcel.java:1891)\n       at android.app.job.IJobCallback$Stub$Proxy.completeWork(IJobCallback.java:218)\n       at android.app.job.JobParameters.completeWork(JobParameters.java:220)\n       at android.support.v4.app.v$f$a.b(JobIntentService.java:267)\n       at android.support.v4.app.v$a.doInBackground(JobIntentService.java:2393)\n       at android.os.AsyncTask$2.call(AsyncTask.java:345)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n       at java.lang.Thread.run(Thread.java:784). I have removed WorkManager, so I don't see it happening on newer builds, but still on old builds.\nHere's another stacktrace from 1.3.0-alpha03\njava.lang.RuntimeException: \n  at android.os.AsyncTask$3.done (AsyncTask.java:318)\n  at java.util.concurrent.FutureTask.finishCompletion (FutureTask.java:354)\n  at java.util.concurrent.FutureTask.setException (FutureTask.java:223)\n  at java.util.concurrent.FutureTask.run (FutureTask.java:242)\n  at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1133)\n  at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:607)\n  at java.lang.Thread.run (Thread.java:761)\nCaused by: java.lang.IllegalStateException: \n  at android.arch.lifecycle.LiveData.assertMainThread (LiveData.java:435)\n  at android.arch.lifecycle.LiveData.removeObserver (LiveData.java:217)\n  at android.arch.lifecycle.MediatorLiveData$Source.unplug (MediatorLiveData.java:145)\n  at android.arch.lifecycle.MediatorLiveData.onInactive (MediatorLiveData.java:126)\n  at android.arch.lifecycle.LiveData$ObserverWrapper.activeStateChanged (LiveData.java:413)\n  at android.arch.lifecycle.LiveData.observeForever (LiveData.java:207)\n  at com.evernote.android.job.work.JobProxyWorkManager.getWorkStatusBlocking (JobProxyWorkManager.java:150)\n  at com.evernote.android.job.work.JobProxyWorkManager.isPlatformJobScheduled (JobProxyWorkManager.java:91)\n  at com.evernote.android.job.JobRescheduleService.rescheduleJobs (JobRescheduleService.java:112)\n  at com.evernote.android.job.JobRescheduleService.onHandleWork (JobRescheduleService.java:87)\n  at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground$10299ca (JobIntentService.java:391)\n  at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground (JobIntentService.java:382)\n  at android.os.AsyncTask$2.call (AsyncTask.java:304)\n  at java.util.concurrent.FutureTask.run (FutureTask.java:237)\n  at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1133)\n  at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:607)\n  at java.lang.Thread.run (Thread.java:761). I've uploaded a test version today for a few Versuchskaninchen with alpha03 and workmanager. Same crash appeared again. It is definitely alpha03. Maybe removeObserver is running too late somehow or it's a lifecycle bug.. No jetifier. No MultiDex in release builds. Yes, the WorkManager is used by android-job. ProGuard in debug builds. \nThe crash happens on both debug and release builds.\nAnother example:\nJobRequest.Builder(\"my_tag\")\n    .setExecutionWindow(1, 1)\n    .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n    .setRequirementsEnforced(true)\n    .setUpdateCurrent(true)\n    .build()\n    .scheduleAsync()\nproduces:\njava.lang.NoSuchMethodError: No virtual method build()Landroidx/work/OneTimeWorkRequest; in class Landroidx/work/OneTimeWorkRequest$Builder; or its super classes (declaration of 'androidx.work.OneTimeWorkRequest$Builder' appears in /data/app/com.my.app-RZ1hW1OBMDqZinwQqxbSEw==/split_lib_dependencies_apk.apk)\n        at com.evernote.android.job.work.JobProxyWorkManager.plantOneOff(JobProxyWorkManager.java:54)\n        at com.evernote.android.job.JobManager.scheduleWithApi(JobManager.java:244)\n        at com.evernote.android.job.JobManager.schedule(JobManager.java:199)\n        at com.evernote.android.job.JobRequest.schedule(JobRequest.java:426)\n        at com.evernote.android.job.JobRequest$2.run(JobRequest.java:455)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n        at java.lang.Thread.run(Thread.java:764). By turning off WorkManager with JobConfig.setApiEnabled(JobApi.WORK_MANAGER, false); everything's ok again.. Had to enable multidex to deactivate proguard. Same crash happens\nFATAL EXCEPTION: AndroidJob-1\nProcess: my.app, PID: 9939\njava.lang.NoSuchMethodError: No virtual method build()Landroidx/work/PeriodicWorkRequest; in class Landroidx/work/PeriodicWorkRequest$Builder; or its super classes (declaration of 'androidx.work.PeriodicWorkRequest$Builder' appears in base.apk)\n    at com.evernote.android.job.work.JobProxyWorkManager.plantPeriodic(JobProxyWorkManager.java:72)\n    at com.evernote.android.job.JobManager.scheduleWithApi(JobManager.java:241)\n    at com.evernote.android.job.JobManager.schedule(JobManager.java:199)\n    at com.evernote.android.job.JobRequest.schedule(JobRequest.java:426)\n    at com.evernote.android.job.JobRequest$2.run(JobRequest.java:455)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\n    at java.lang.Thread.run(Thread.java:764)\nThere is actually a method with this signature in the classes.dex:\n\nThat's so strange.. I made an example project for reproducing that crash\nhttps://github.com/Jeff11/com.example.jeff.android_job_workmanager_alpha6_crash. The crash during runtime is the problem, not building. Yes, I've cleaned and rebuilt more than once. Work Manager alpha05 doesn't crash, just alpha06 and I can switch between them and it's reproducible at least for me. . ",
    "emartynov": "We've got the same crash. I'm reading docs and there is written that setApiEnabled is intended only for test purposes. Is it correct?. ",
    "swapnilgt": "@vRallev \nJobConfig.addLogger(new MyJobCreator.JobLibraryLogger());\n        JobConfig.setForceAllowApi14(true);\n        JobConfig.setApiEnabled(JobApi.GCM, false); // is only important for Android 4.X\n        JobManager.create(this).addJobCreator(new MyJobCreator());\nI have used the above as mentioned by you. But I am unable to find MyJobCreator.JobLibraryLogger() in the first line. Any pointers here?. ",
    "pavel-ismailov": "Be aware of tool:node=\"replace\" in your AndroidManifest file.\nThat leads to the same problem.. ",
    "karthikveeramani": "I do not have proguard or multidex enabled (they seem disabled by default with the latest android studio-generated project). I can see if I can cleanup what I have to provide you a sample, but it is just a simple hello world activity, that does something similar to what is on this readme - https://github.com/evernote/android-job  ..  I tried to schedule a periodic job (using the Advanced section) and triggered the scheduling of the Job in my main activity's onResume().  My main activity's onCreate() calls JobManager.create() using the context of the activity.\n. I made a fresh hello world app that reproduces this problem (for me at least) - https://github.com/karthikveeramani/EvernoteJobTest  ..  Please check. Sorry about the weird package names, I'm new to Android Studio and didn't get it right during the project creation.. Thank you so much! I'll try that tonight and confirm. . @vRallev , first of all, thanks again for getting to this so quickly and helping me out, I appreciate this a lot.\nI no longer see the crash after using your suggestion. I have a question though before I sign off ... now that my periodic job (15 min interval) runs, I see the following logcat dump -- notice the timestamps on the lines with \"onRunJob\", which is printed when the  job executes.  They don't seem to be 15 min apart as requested.  What am I missing here?\n05-25 01:30:01.005 2828-2974/com.hello.world I/JobExecutor: Executing request{id=11, tag=MyJob}, context PlatformAlarmService\n05-25 01:30:01.005 2828-2976/com.hello.world I/MyJob: onRunJob called\n05-25 01:30:01.005 2828-2976/com.hello.world I/JobExecutor: Finished job{id=11, finished=true, result=SUCCESS, canceled=false, periodic=true, class=MyJob, tag=MyJob}\n05-25 01:30:01.015 2828-2975/com.hello.world I/JobExecutor: Executing request{id=9, tag=MyJob}, context PlatformAlarmService\n05-25 01:30:01.015 2828-2978/com.hello.world I/MyJob: onRunJob called\n05-25 01:30:01.015 2828-2978/com.hello.world I/JobExecutor: Finished job{id=9, finished=true, result=SUCCESS, canceled=false, periodic=true, class=MyJob, tag=MyJob}\n05-25 01:30:01.055 2828-2977/com.hello.world I/JobExecutor: Executing request{id=10, tag=MyJob}, context PlatformAlarmService\n05-25 01:30:01.055 2828-2976/com.hello.world I/MyJob: onRunJob called\n05-25 01:30:01.055 2828-2976/com.hello.world I/JobExecutor: Finished job{id=10, finished=true, result=SUCCESS, canceled=false, periodic=true, class=MyJob, tag=MyJob}\n. ",
    "digitalbuddha": "you're a machine!. ",
    "judemanutd": "@vRallev I am trying to include offline sync into my app so for that whenever the phone is offline it stores the item locally and creates a job to sync the item when the phone comes back online.\nNow the next time when the phone is offline and there is already a job to sync the items then i would like to update that particular job and its details instead of creating a new job for every item that is created when the device is offline.\nAlso i would like to know if a job is updated does the timer for the backoff criteria reset or would the time persist even after the job is updated,. @vRallev I think i will use that method,thank you.. another question on the same lines\nSuppose a job of type XYZ is scheduled and it starts executing and while it is executing,in another part of the code all jobs of type XYZ are cancelled and rescheduled.\nNow the above job that was executing will complete its execution and return success so in that case will there be a new job of type XYZ created or there will be no job since it completed and returned a success.\n. @vRallev great thanks.\nThis might be off topic but is there a way i can check if the job is running,maybe check if the thread spawned by that job is running or something like that?. @vRallev Thank You . ",
    "budowski": "Weird - is there a way around this? Or is there an other recommended solution for high-frequency jobs like this?. OK, got it - thanks! :-). ",
    "benjamin-bader": "Sadly, no - I've been unable to reproduce, and lost the failing test result :(\nIn any event, the failure was that there were fewer job requests than expected.  Probably the change you just made will fix the problem.  I'll close this, and re-open if I see failures again.. ",
    "prashantwosti": "Thanks! @vRallev . ",
    "tvvbbb": "Thanks a lot.. Sorry for my poor English. I mean, if one job will run at 13:00 but when I scheduled it for 13:02 it also runs.. java\nlong timeInterval = nextRemindTime - System.currentTimeMillis();\n        if (timeInterval < 0)\n            return;\n        builder.setExact(timeInterval)\n                .setUpdateCurrent(true)\n                .build()\n                .schedule();\nThis is the main code.. Sorry. I can't provide a full sample now. If I meet this exception again, I reopen this issue. Thanks.. ",
    "mrpep80": "Ok \nbut can I fire a job every friday at 4.00 PM for example?\nIf it is not exact the 4.00 PM but 4.15 PM for me is the same. How can I do that?. ok thaks. ",
    "swarna-sathya": "Hi,\nThe link mentioned in the above messages throws a 404, is there any way I can get to it?. ",
    "hosseinjafari9574": "@mrpep80  I have your problem.\ndid you find anything bro?. ",
    "kishanatdelta": "Not Really Helped !!. ",
    "RoelVG": "Excellent! Thanks for the quick answer.. ",
    "worstkiller": "Hey @vRallev thanks for replying back.\nI got from the link that its not bundled in library but i have included it manually for location purposes\nbelow one:\ncompile 'com.google.android.gms:play-services-location:11.0.0'\nand it's still showing as information in logcat, not crashing actually. Does this affects job scheduling on older devices or it shifts to Alarm manager or something for scheduling if GCM is not available.\nThanks \n. Thanks for confirming that.\nThis library is really helpful for problems you guys have mentioned in slides.\nThanks :thumbsup:. ",
    "zishanj": "I have noticed the similar stack trace when I close the app and my periodic event is going to happen after 15 mins in background. Does this message:\n\n03-28 14:19:19.083 24411-24441/com.alhuda.al_huda_live.debug I/JobManager: Found pending job request{id=6, tag=refreshapp_tag, transient=false}, canceling\n\nmeans it will cancel the current task? Because I have not seen any trace in log about the processing of current task. After another 15 mins I have seen it to be recorded in the log.. same here... I am also facing this error intervalMs is out of range of [900000, 9223372036854775807] (too low) on Android Marshmallow even I have tried to use JobConfig.setAllowSmallerIntervalsForMarshmallow(true); before creating JobManager.. I also have this issue and I have to run both JobManager.create and .schedule inside thread like this, to avoid that error:\nnew Thread() {\n            @Override\n            public void run() {\n                JobManager.create(getApplicationContext()).addJobCreator(new AppJobCreator());\n                JobManager.instance().schedule(SocketNotificationJob.buildJobRequest());\n            }\n        }.start();. Actually I am also using StrictMode in debug and I have to use separate Thread to overcome that error.. Just updated to 1.2.5 and the error is still there.... Here it is:\n\nStrictMode policy violation; ~duration=320 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=65567 violation=2\n                                                                             at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1293)\n                                                                             at java.io.UnixFileSystem.checkAccess(UnixFileSystem.java:249)\n                                                                             at java.io.File.exists(File.java:780)\n                                                                             at android.app.ContextImpl.getDataDir(ContextImpl.java:1938)\n                                                                             at android.app.ContextImpl.getDatabasesDir(ContextImpl.java:712)\n                                                                             at android.app.ContextImpl.getDatabasePath(ContextImpl.java:694)\n                                                                             at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:644)\n                                                                             at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:289)\n                                                                             at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:223)\n                                                                             at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:163)\n                                                                             at com.evernote.android.job.JobStorage.getDatabase(JobStorage.java:331)\n                                                                             at com.evernote.android.job.JobStorage.getMaxJobId(JobStorage.java:361)\n                                                                             at com.evernote.android.job.JobStorage.nextJobId(JobStorage.java:255)\n                                                                             at com.evernote.android.job.JobRequest$Builder.build(JobRequest.java:1168). @naushad-madakiya Using with Dagger does not run the job after you close the app unless you have started the job from Application.onCreate. That github example have this issue because he is running it from Activity.onCreate(). Just thought to let you know about this issue. :). Its just for Debug mode. :) I will test it and update here.. yes its working now with those 30 sec flex and 1 min of interval.. Further testing it I have seen that this happens after 10 mins. Before 10 mins my app was connected to a socket and awaiting for any message. After 10 mins the job automatically  return FAILURE.\n03-14 10:05:44.904 6443-6443/com.alhuda.al_huda_live.debug I/SocketNotificationJob: Connected\n03-14 10:15:44.876 6443-6443/com.alhuda.al_huda_live.debug D/PlatformJobService: Called onStopJob for job{id=98, finished=false, result=FAILURE, canceled=true, periodic=false, class=SocketNotificationJob, tag=socket_notification_tag}. Here is the complete log:\n03-14 10:05:44.868 6443-6512/com.alhuda.al_huda_live.debug D/PlatformJobService: Run job, request{id=98, tag=socket_notification_tag, transient=false}, waited 00:01:00, start 00:00:30, end 00:01:00\n03-14 10:05:44.880 6443-6512/com.alhuda.al_huda_live.debug I/JobExecutor: Executing request{id=98, tag=socket_notification_tag, transient=false}, context PlatformJobService\n03-14 10:05:44.883 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: --> GET http://192.168.1.18:2898/getjwt\n03-14 10:05:44.883 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: --> END GET\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: <-- 200 OK http://192.168.1.18:2898/getjwt (2ms)\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: X-Powered-By: Express\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: Access-Control-Allow-Origin: http://192.168.1.7\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: Access-Control-Allow-Methods: POST\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: Access-Control-Allow-Headers: X-Requested-With,content-type,Authorization\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: Access-Control-Allow-Credentials: true\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: Content-Type: application/json; charset=utf-8\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: Content-Length: 164\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: ETag: W/\"a4-rESSed6qaKn5iC8WxyHtuOYbd20\"\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: Date: Wed, 14 Mar 2018 10:05:45 GMT\n03-14 10:05:44.885 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: Connection: keep-alive\n03-14 10:05:44.886 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: {\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzb3VyY2UiOiJtb2JpbGUiLCJpYXQiOjE1MjEwMjE5NDUsImV4cCI6MTUyMTAyMTk1NX0.6OlaPZPI1yGUkDcNhjupRF5TjJXoTl3p6gHukn9i31g\"}\n03-14 10:05:44.886 6443-6514/com.alhuda.al_huda_live.debug D/OkHttp: <-- END HTTP (164-byte body)\n03-14 10:05:44.891 6443-6443/com.alhuda.al_huda_live.debug I/SocketNotificationJob: Connecting\n03-14 10:05:44.904 6443-6443/com.alhuda.al_huda_live.debug I/SocketNotificationJob: Connected\n03-14 10:15:44.876 6443-6443/com.alhuda.al_huda_live.debug D/PlatformJobService: Called onStopJob for job{id=98, finished=false, result=FAILURE, canceled=true, periodic=false, class=SocketNotificationJob, tag=socket_notification_tag}\n\nAny idea why is this happening, it looks very odd.. I have tested my code without Android-Job and it works fine.. Just did some more testing and came to know that I was using disposables.clear() to clear my RxJava subscriptions in onCancel() which would clear the subscriptions. This onCancel() is called after every 10 mins due to which it cancel the subscriptions.\nI have checked your link but I am not using any such restrictions. Here is my job creation code:\nnew JobRequest.Builder(SocketNotificationJob.TAG)\n                .setExecutionWindow(30000L, 60000L)\n                .setBackoffCriteria(60000L, JobRequest.BackoffPolicy.LINEAR)\n                .setUpdateCurrent(true)\n                .build();\nI have removed my disposables.clear() code for the time being and its working fine now. But still not sure under what criteria its calling onStopJob after every 10mins which triggering onCancel of AndroidJob.. hmm... I have seen that after onStopJob, my thread is still active and performing its work perfectly. Is this odd or normal? I was expecting to have my background thread also terminated.. This is my jobBuilder request:\nnew JobRequest.Builder(SocketNotificationJob.TAG)\n                .setExecutionWindow(30000L, 60000L)\n                .setBackoffCriteria(60000L, JobRequest.BackoffPolicy.LINEAR)\n                .setUpdateCurrent(true)\n                .build();\nThis is onRunJob code, I am using RxJava2:\nfinal CountDownLatch countDownLatch = new CountDownLatch(1);\ndisposables.add(\n            ServiceBuilder.createJSONService(FHAPIService.class, BuildConfig.SOCKET_URL)\n                .getJWT()\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(this::getNotification, error -> {\n                    Timber.e(error);\n                   isError = true;\n                    countDownLatch.countDown();\n                })\n        );\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            Timber.e(e);\n        }\n        disposables.clear();\n       if (isError)\n           return Result.RESCHEDULE;\n      else\n           return Result.SUCCESS;\nThis is code for getNotification which I am using inside subscribe:\ndisposables.add(\n            socketUseCase.getNotification(\"/notification\", jwt.token)\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .distinctUntilChanged(status -> {\n                    if (status.getArgs().length > 0)\n                        return status.getArgs()[0]; // if status is of notification related; message\n                    else\n                        return status.getStatus();  // if status is of core socket; connecting, connected etc.\n                })\n                .subscribe(notification -> {\n                    Timber.i(notification.getStatus().name());\n                    isConnected = notification.getStatus() == NotificationStatus.Status.Connected;\n                    if (notification.getStatus() == NotificationStatus.Status.Unauthorized) {\n                        isError = true;\n                        countDownLatch.countDown();\n                    }\n                }, Timber::e)\n        );\nThese codes run the socket.io and wait for a message. If there happens to be unauthorization error or any other error occurred then it will RESCHEDULE the job.. I am just calling the schedule only from Application.onCreate() like this:\nnew Thread() {\n            @Override\n            public void run() {\n                JobConfig.setAllowSmallerIntervalsForMarshmallow(true);\n                JobManager.create(getApplicationContext()).addJobCreator(new AppJobCreator1());\n                JobManager.instance().schedule(SocketNotificationJob.buildJobRequest());\n            }\n        }.start();. seems like its an issue in Lollipop and Marshmallow, but on Android N it works fine. Here is the link with suggested solution from developer of JobScheduler Mathew Williams. I was testing this app on Marshmallow.. To remedy this issue I have put a check in the beginning of onRunJob and it works fine now.. My app is not canceling it and there is no such code I am using. Check this issue also #216. He has also similar trace with first line canceling the job.. ",
    "doc-rj": "Thanks @vRallev but it appears that this solution won't work for us, since we're calling JobManager.create() from our Application class (GHDelivery) and passing \"this\" for context. Here's the line of code from our Application class onCreate() method:\nJobManager.create(this).addJobCreator(new JobFactory());\nRoboelectric is trying to create the Application when this failure occurs in onCreate(). Do you have another way to get around this problem? Maybe a custom test runner or a roboelectric shadow would help?. Thanks @vRallev ... I had to create a new subclass of Application. I couldn't subclass our GHDelivery, because super.onCreate() would fail... so there's a lot of duplicated code. Anyhow, thanks for the ideas.. FYI, Roboelectric automatically picks up the class with \"Test\" prefix followed by the application declared in the manifest, so I created \"TestGHDelivery\" which subclasses Application.. ah, ok. Here's the info on their website: http://robolectric.org/custom-test-runner/. @eggcaker Yes, that's what we're doing indeed. But we're only swallowing the exception during unit testing, not in the production Application subclass.. Version 1.1.10 had an update problem for some users on older Android versions. We think it was a \"Parse Error\" issue in most cases... We rolled users back to 1.1.9 and it fixed the problem... We'd like to upgrade again (to 1.1.11 or latest), but we're wary of the update problem showing up again. Have there been any other reports of this?. Here's a screenshot.\n\n. No, it's definitely not. It's an Android OS dialog. It can be caused by the following:\n\nParse error can occur if you have made changes to the app\u2019s manifest file like changing the Android version.\nIt can also occur due to a corrupted .apk file or may because of a partially downloaded apk file.\nNot enough permission to install third-party apps from unknown sources.\nYour Android smartphone OS version or the hardware is not compatible with the app.\nA third-party security application is blocking the app installation.\n\nIn this case, who knows? Maybe #1 or #4 above... and/or perhaps an issue merging the AndroidManifest.xml for android-job.\nSee this article for a little more info: http://www.technicalnotes.org/fix-parse-error-in-android-there-is-a-problem-parsing-the-package/\n. Rolling back the library was the only thing we changed, and it fixed the issue. It could also be a problem with android gradle build tools, etc., but it's hard to know at this point.\nIn my humble opinion, a library like yours should support downgrades, because the host application may undergo downgrades for various reasons... (In our case, it is a business-critical app, so we have to force our users to use specific versions of the app, and our business fails when the app doesn't work.). ",
    "asafkin": "You can create two jobs where the first is executed once after an offset and it will execute the 2nd which will be periodic.. I am still getting this issue in Version 4.4, Nexus 7.. im having a similar issue with 1.2.6.\nCaused by java.lang.IllegalStateException: Apps may not schedule more than 100 distinct jobs\n       at android.os.Parcel.readException(Parcel.java:1966)\n       at android.os.Parcel.readException(Parcel.java:1904)\n       at android.app.job.IJobScheduler$Stub$Proxy.schedule(IJobScheduler.java:180)\n       at android.app.JobSchedulerImpl.schedule(JobSchedulerImpl.java:44)\n       at com.evernote.android.job.v21.JobProxy21.schedule(JobProxy21.java:209)\n       at com.evernote.android.job.v21.JobProxy21.plantOneOff(JobProxy21.java:64)\n       at com.evernote.android.job.JobManager.scheduleWithApi(JobManager.java:232)\n       at com.evernote.android.job.JobManager.schedule(JobManager.java:187)\n       at com.evernote.android.job.JobRequest.schedule(JobRequest.java:426)\n       at com.example.libs.sync.managers.AnalyticsJobManager.startSync(AnalyticsJobManager.java:54)\n       at com.example.libs.network.managers.NetworkManager.init(NetworkManager.java:60)\n       at air.com.example.mobile.main.MainApplication.onCreate(MainApplication.java:179)\n\n. ",
    "ruha9005": "@vRallev \nIt would be very good to make possible to use .setExact(...) and .setPeriodic(...) both in one job.... Hi everyone!\nI'm not using android-job in my current project, but I also have this error (mostly in Huawei devices):\njava.lang.RuntimeException: \n  at android.os.AsyncTask$3.done (AsyncTask.java:365)\n  at java.util.concurrent.FutureTask.finishCompletion (FutureTask.java:383)\n  at java.util.concurrent.FutureTask.setException (FutureTask.java:252)\n  at java.util.concurrent.FutureTask.run (FutureTask.java:271)\n  at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1162)\n  at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:636)\n  at java.lang.Thread.run (Thread.java:784)\nCaused by: java.lang.SecurityException: \n  at android.os.Parcel.readException (Parcel.java:1945)\n  at android.os.Parcel.readException (Parcel.java:1891)\n  at android.app.job.IJobCallback$Stub$Proxy.dequeueWork (IJobCallback.java:191)\n  at android.app.job.JobParameters.dequeueWork (JobParameters.java:196)\n  at android.support.v4.app.JobIntentService$JobServiceEngineImpl.dequeueWork (JobIntentService.java:314)\n  at android.support.v4.app.JobIntentService.dequeueWork (JobIntentService.java:639)\n  at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground (JobIntentService.java:2389)\n  at android.os.AsyncTask$2.call (AsyncTask.java:345)\n  at java.util.concurrent.FutureTask.run (FutureTask.java:266). ",
    "JoyMitra": "The thing is I need the \"context\" instance do perform certain operations eg. update something in the sqllite db. The onRunJob() does not have access to the context. If such a method does not exist then I will probably have to create a static flag and use that to indicate the successful completion on the Job I am scheduling. But I am hoping to avoid that because it could create a potential mess. \nAlso I was wondering if the job I am scheduling is periodic how does job.isFinished() behave?. Ah! that should work. I don't how I missed that method. Thanks for replying to my queries.. ",
    "mbagliojr": "This is written in Kotlin so it isn't java syntax but should be fairly self explanatory.\n   JobRequest.Builder(tag)\n            .setExact(jobTimeMs - Date().time)\n            .setPersisted(true)\n            .setUpdateCurrent(true)\n            .build()\n            .schedule()\n\nThen for displaying the notification when the job is run.\n  override fun onRunJob(params: Params?): Result {\n    val data = (context.applicationContext as MyApplication).data\n\n    notification_id = Random().nextInt((Date().time % 354533L).toInt())\n\n    val resultIntent = Intent(context, MainActivity::class.java)\n    val resultPendingIntent = PendingIntent.getActivity(context,\n            0,\n            resultIntent,\n            PendingIntent.FLAG_UPDATE_CURRENT\n    )\n\n    val soundUri = Uri.parse(\"android.resource://com.myApp/\" + R.raw.ding)\n\n\n    val mBuilder = NotificationCompat.Builder(context)\n            .setSmallIcon(R.drawable.ic_notification)\n            .setLargeIcon(BitmapFactory.decodeResource(context.resources,\n            R.mipmap.ic_launcher))\n            .setContentTitle(\"Reminder!\")\n            .setContentText(\"Sample code\")\n            .setDefaults(Notification.DEFAULT_LIGHTS)// or Notification.DEFAULT_SOUND)\n            .setSound(soundUri)\n            .setContentIntent(resultPendingIntent)\n            .setAutoCancel(true)\n\n    var notifyMgr = context.getSystemService(NOTIFICATION_SERVICE) as NotificationManager\n    notifyMgr.notify(notification_id, mBuilder.build())\n\n    return Result.SUCCESS\n}. It appears like setExact calls setExecutionWindow. Is that correct?\n\nIn JobRequest.java\n /**\n     * Specify that the job should run at an exact time. This type of job must only be used\n     * for situations where it is actually required that the alarm go off even while in idle.\n     * A reasonable example would be for a calendar notification that should make a sound so\n     * the user is aware of it.\n     *\n     * <br>\n     * <br>\n     *\n     * Note that an exact job can't be periodic. It's also not allowed to specify any requirement,\n     * the exact timing is the most important requirement for such a job. This method overrides\n     * any specified time window.\n     *\n     * <br>\n     * <br>\n     *\n     * The default value is set to {@code false}. Internally an exact job is always using the\n     * {@link AlarmManager}.\n     *\n     * <br>\n     * <br>\n     *\n     * The milliseconds specified are treated as offset from now, e.g. the job will run at\n     * {@code System.currentTimeMillis() + exactInMs}.\n     *\n     * <br>\n     * <br>\n     *\n     * The maximum value of the argument is {@code Long.MAX_VALUE / 3 * 2} (about 53_375_995_583 days).\n     * No exception is thrown if the argument is greater than the maximum value, the argument is\n     * silently being clamped.\n     *\n     * @param exactInMs The exact offset when the job should run from when the job was scheduled.\n     * @see AlarmManager#setExact(int, long, android.app.PendingIntent)\n     * @see AlarmManager#setExactAndAllowWhileIdle(int, long, android.app.PendingIntent)\n     */\n    public Builder setExact(long exactInMs) {\n        mExact = true;\n        if (exactInMs > WINDOW_THRESHOLD_MAX) {\n            CAT.i(\"exactInMs clamped from %d days to %d days\", TimeUnit.MILLISECONDS.toDays(exactInMs), TimeUnit.MILLISECONDS.toDays(WINDOW_THRESHOLD_MAX));\n            exactInMs = WINDOW_THRESHOLD_MAX;\n        }\n\n        return setExecutionWindow(exactInMs, exactInMs);\n    }. In the JobApi, It is not apparent to me how the later versions of Android will ever use the AlarmManager. If I'm reading it correctly, it appears as though it decides what implementation it will use based on the phone version not the Job or JobRequest.isExact(). Could there be a problem in there?. I am waiting to hear back from a team member whom opened the bug. I made a change that has to do with the 15 minute timer (there was one reminder coming through every 15 minutes and another that happened 3 times a day). It appears as though the 15 minute one may have been preventing the others from coming through. I'm attempting to confirm this.\n\nThanks for the help. I should have an answer soon.. ",
    "Mahabub21": "is it possible to run scheduled service for every 2 hours, without internet connection to update the database on android's all versions?. ",
    "AAverin": "Example thread dump\n```\n\"main\" prio=5 tid=1 VMWAIT\n  | group=\"main\" sCount=1 dsCount=0 obj=0x414729a0 self=0x4009a010\n  | sysTid=10263 nice=0 sched=0/0 cgrp=apps handle=1074836444\n  | state=S schedstat=( 6948164000 3266126000 1290 ) utm=680 stm=14 core=0\n  native: pc 0000000000017d80  /system/lib/libc.so (__wait4+8)\n  native: pc 000000000005aaf1  /system/lib/libdvm.so (dvmOptimizeDexFile(int, long, long, char const, unsigned int, unsigned int, bool)+548)\n  native: pc 000000000004e05b  /system/lib/libdvm.so (dvmJarFileOpen(char const, char const, JarFile, bool)+366)\n  native: pc 0000000000064be1  /system/lib/libdvm.so\n  native: pc 00000000000276a0  /system/lib/libdvm.so\n  native: pc 000000000002b5f4  /system/lib/libdvm.so (dvmInterpret(Thread, Method const, JValue)+184)\n  native: pc 000000000006009f  /system/lib/libdvm.so (dvmInvokeMethod(Object, Method const, ArrayObject, ArrayObject, ClassObject, bool)+374)\n  native: pc 0000000000067979  /system/lib/libdvm.so\n  native: pc 00000000000276a0  /system/lib/libdvm.so\n  native: pc 000000000002b5f4  /system/lib/libdvm.so (dvmInterpret(Thread, Method const, JValue)+184)\n  native: pc 000000000006009f  /system/lib/libdvm.so (dvmInvokeMethod(Object, Method const, ArrayObject, ArrayObject, ClassObject, bool)+374)\n  native: pc 0000000000067979  /system/lib/libdvm.so\n  native: pc 00000000000276a0  /system/lib/libdvm.so\n  native: pc 000000000002b5f4  /system/lib/libdvm.so (dvmInterpret(Thread, Method const, JValue)+184)\n  native: pc 000000000005fdc9  /system/lib/libdvm.so (dvmCallMethodV(Thread, Method const, Object, bool, JValue, std::__va_list)+272)\n  native: pc 0000000000049a73  /system/lib/libdvm.so\n  native: pc 0000000000047729  /system/lib/libandroid_runtime.so\n  native: pc 00000000000483eb  /system/lib/libandroid_runtime.so (android::AndroidRuntime::start(char const, char const)+390)\n  native: pc 0000000000000db7  /system/bin/app_process\n  native: pc 000000000001271f  /system/lib/libc.so (__libc_init+38)\n  native: pc 0000000000000ae8  /system/bin/app_process\n  at dalvik.system.DexFile.openDexFile (Native Method)\n  at dalvik.system.DexFile. (DexFile.java:109)\n  at dalvik.system.DexFile.loadDex (DexFile.java:149)\n  at dalvik.system.DexPathList.loadDexFile (DexPathList.java:261)\n  at dalvik.system.DexPathList.makeDexElements (DexPathList.java:229)\n  at java.lang.reflect.Method.invokeNative (Native Method)\n  at java.lang.reflect.Method.invoke (Method.java:511)\n  at android.support.multidex.MultiDex$a.a (SourceFile:462)\n  at android.support.multidex.MultiDex$a.b (SourceFile:447)\n  at android.support.multidex.MultiDex$a.a (SourceFile:434)\n  at android.support.multidex.MultiDex.installSecondaryDexes (SourceFile:244)\n  at android.support.multidex.MultiDex.install (SourceFile:161)\n  at android.support.multidex.MultiDexApplication.attachBaseContext (SourceFile:39)\n  at android.app.Application.attach (Application.java:147)\n  at android.app.Instrumentation.newApplication (Instrumentation.java:984)\n  at android.app.Instrumentation.newApplication (Instrumentation.java:968)\n  at android.app.LoadedApk.makeApplication (LoadedApk.java:499)\n  at android.app.ActivityThread.handleBindApplication (ActivityThread.java:4364)\n  at android.app.ActivityThread.access$1300 (ActivityThread.java:141)\n  at android.app.ActivityThread$H.handleMessage (ActivityThread.java:1294)\n  at android.os.Handler.dispatchMessage (Handler.java:99)\n  at android.os.Looper.loop (Looper.java:137)\n  at android.app.ActivityThread.main (ActivityThread.java:5039)\n  at java.lang.reflect.Method.invokeNative (Native Method)\n  at java.lang.reflect.Method.invoke (Method.java:511)\n  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:793)\n  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:560)\n  at dalvik.system.NativeStart.main (Native Method)\n\"GC\" daemon prio=5 tid=2 VMWAIT\n  | group=\"system\" sCount=1 dsCount=0 obj=0x416f7bb8 self=0x40f0f7f0\n  | sysTid=10265 nice=0 sched=0/0 cgrp=apps handle=1565150600\n  | state=S schedstat=( 123084000 444177000 73 ) utm=12 stm=0 core=0\n  native: pc 0000000000018104  /system/lib/libc.so (__futex_syscall3+8)\n  native: pc 000000000000e41c  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)\n  native: pc 000000000000e478  /system/lib/libc.so (__pthread_cond_timedwait+60)\n  native: pc 0000000000071a37  /system/lib/libdvm.so\n  native: pc 000000000005405b  /system/lib/libdvm.so\n  native: pc 000000000000e3d8  /system/lib/libc.so (__thread_entry+72)\n  native: pc 000000000000dac4  /system/lib/libc.so (pthread_create+160)\n  at dalvik.system.NativeStart.run (Native Method)\n\"Compiler\" daemon prio=5 tid=4 VMWAIT\n  | group=\"system\" sCount=1 dsCount=0 obj=0x416f7d90 self=0x5d5b4008\n  | sysTid=10269 nice=0 sched=0/0 cgrp=apps handle=1074436864\n  | state=S schedstat=( 47519000 18168000 253 ) utm=2 stm=2 core=0\n  native: pc 0000000000018104  /system/lib/libc.so (__futex_syscall3+8)\n  native: pc 000000000000e41c  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)\n  native: pc 000000000000e478  /system/lib/libc.so (__pthread_cond_timedwait+60)\n  native: pc 0000000000072c85  /system/lib/libdvm.so\n  native: pc 000000000005405b  /system/lib/libdvm.so\n  native: pc 000000000000e3d8  /system/lib/libc.so (__thread_entry+72)\n  native: pc 000000000000dac4  /system/lib/libc.so (pthread_create+160)\n  at dalvik.system.NativeStart.run (Native Method)\n\"ReferenceQueueDaemon\" daemon prio=5 tid=5 WAIT\n  | group=\"system\" sCount=1 dsCount=0 obj=0x416f7e80 self=0x5dd0a008\n  | sysTid=10270 nice=0 sched=0/0 cgrp=apps handle=1074437104\n  | state=S schedstat=( 714000 394000 12 ) utm=0 stm=0 core=0\n  at java.lang.Object.wait (Native Method)\n- waiting on <0x41468538>\n  at java.lang.Object.wait (Object.java:364)\n  at java.lang.Daemons$ReferenceQueueDaemon.run (Daemons.java:130)\n  at java.lang.Thread.run (Thread.java:856)\n\"FinalizerDaemon\" daemon prio=5 tid=6 WAIT\n  | group=\"system\" sCount=1 dsCount=0 obj=0x416f7fe8 self=0x5df3cb58\n  | sysTid=10271 nice=0 sched=0/0 cgrp=apps handle=1565144848\n  | state=S schedstat=( 1612000 10664000 10 ) utm=0 stm=0 core=0\n  at java.lang.Object.wait (Native Method)\n- waiting on <0x41468610> (a java.lang.ref.ReferenceQueue)\n  at java.lang.Object.wait (Object.java:401)\n  at java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:102)\n  at java.lang.ref.ReferenceQueue.remove (ReferenceQueue.java:73)\n  at java.lang.Daemons$FinalizerDaemon.run (Daemons.java:170)\n  at java.lang.Thread.run (Thread.java:856)\n\"FinalizerWatchdogDaemon\" daemon prio=5 tid=7 WAIT\n  | group=\"system\" sCount=1 dsCount=0 obj=0x416f8140 self=0x5d51af18\n  | sysTid=10272 nice=0 sched=0/0 cgrp=apps handle=1565635432\n  | state=S schedstat=( 480000 31630000 5 ) utm=0 stm=0 core=0\n  at java.lang.Object.wait (Native Method)\n- waiting on <0x4147c5e8> (a java.lang.Daemons$FinalizerWatchdogDaemon)\n  at java.lang.Object.wait (Object.java:364)\n  at java.lang.Daemons$FinalizerWatchdogDaemon.waitForObject (Daemons.java:230)\n  at java.lang.Daemons$FinalizerWatchdogDaemon.run (Daemons.java:207)\n  at java.lang.Thread.run (Thread.java:856)\n\"Binder_1\" prio=5 tid=8 NATIVE\n  | group=\"main\" sCount=1 dsCount=0 obj=0x416fcaf0 self=0x5d986230\n  | sysTid=10273 nice=0 sched=0/0 cgrp=apps handle=1565150272\n  | state=S schedstat=( 4343000 22702000 8 ) utm=0 stm=0 core=0\n  native: pc 0000000000016fe4  /system/lib/libc.so (__ioctl+8)\n  native: pc 000000000002a9ad  /system/lib/libc.so (ioctl+16)\n  native: pc 0000000000016ba1  /system/lib/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+132)\n  native: pc 0000000000017363  /system/lib/libbinder.so (android::IPCThreadState::joinThreadPool(bool)+154)\n  native: pc 000000000001b15d  /system/lib/libbinder.so\n  native: pc 0000000000011267  /system/lib/libutils.so (android::Thread::_threadLoop(void)+114)\n  native: pc 0000000000047657  /system/lib/libandroid_runtime.so (android::AndroidRuntime::javaThreadShell(void)+66)\n  native: pc 0000000000010dcd  /system/lib/libutils.so\n  native: pc 000000000000e3d8  /system/lib/libc.so (__thread_entry+72)\n  native: pc 000000000000dac4  /system/lib/libc.so (pthread_create+160)\n  at dalvik.system.NativeStart.run (Native Method)\n\"Binder_2\" prio=5 tid=9 NATIVE\n  | group=\"main\" sCount=1 dsCount=0 obj=0x416fd238 self=0x5d988208\n  | sysTid=10274 nice=0 sched=0/0 cgrp=apps handle=1557805320\n  | state=S schedstat=( 1165000 11492000 5 ) utm=0 stm=0 core=0\n  native: pc 0000000000016fe4  /system/lib/libc.so (__ioctl+8)\n  native: pc 000000000002a9ad  /system/lib/libc.so (ioctl+16)\n  native: pc 0000000000016ba1  /system/lib/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+132)\n  native: pc 0000000000017363  /system/lib/libbinder.so (android::IPCThreadState::joinThreadPool(bool)+154)\n  native: pc 000000000001b15d  /system/lib/libbinder.so\n  native: pc 0000000000011267  /system/lib/libutils.so (android::Thread::_threadLoop(void)+114)\n  native: pc 0000000000047657  /system/lib/libandroid_runtime.so (android::AndroidRuntime::javaThreadShell(void)+66)\n  native: pc 0000000000010dcd  /system/lib/libutils.so\n  native: pc 000000000000e3d8  /system/lib/libc.so (__thread_entry+72)\n  native: pc 000000000000dac4  /system/lib/libc.so (pthread_create+160)\n  at dalvik.system.NativeStart.run (Native Method)\n\"pool-1-thread-1\" prio=5 tid=10 WAIT\n  | group=\"main\" sCount=1 dsCount=0 obj=0x41816a78 self=0x5d513128\n  | sysTid=10322 nice=0 sched=0/0 cgrp=apps handle=1570304000\n  | state=S schedstat=( 7403000 16707000 23 ) utm=0 stm=0 core=0\n  at java.lang.Object.wait (Native Method)\n- waiting on <0x41812f80> (a java.lang.VMThread) held by tid=10 (pool-1-thread-1)\n  at java.lang.Thread.parkFor (Thread.java:1231)\n  at sun.misc.Unsafe.park (Unsafe.java:323)\n  at java.util.concurrent.locks.LockSupport.park (LockSupport.java:159)\n  at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await (AbstractQueuedSynchronizer.java:2019)\n  at java.util.concurrent.LinkedBlockingQueue.take (LinkedBlockingQueue.java:413)\n  at java.util.concurrent.ThreadPoolExecutor.getTask (ThreadPoolExecutor.java:1013)\n  at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1073)\n  at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:573)\n  at java.lang.Thread.run (Thread.java:856)\n\"Signal Catcher\" daemon prio=5 tid=3 RUNNABLE\n  | group=\"system\" sCount=0 dsCount=0 obj=0x416f7c98 self=0x5d5b4598\n  | sysTid=10268 nice=0 sched=0/0 cgrp=apps handle=1074374712\n  | state=R schedstat=( 30872000 40702000 218 ) utm=0 stm=3 core=0\n  at dalvik.system.NativeStart.run (Native Method)\n```. Issue is limited to Android 4.2.X devices.\nNo particular carrier is affected, present on all devices.\n. I can provide about 200 more example dumps.\nIf that would have been a multidex issue we would have many more of those.\nSo I suspect it doesn't reproduce on every 4.2 device, and emulator is usually not the best thing for testing.\nAccording to our statistics, issue is most prominent on:\nGalaxy S3 Mini Value Edition (goldenve3g) \u2013 32% of all cases\nGalaxy Tab3 Lite (goyawifi) \u2013 22% of all cases\nGalaxy Tab2 10.1 (espresso10wifi) - 6% of all cases\n. Maybe you're right, because even though library is added to the project, we don't really use it or call it at the moment.\nStill, error is registered as if this library blocked main thread and caused ANR.\nStrange. ",
    "aamir2590": "In my case, Google Play console showing me this\n\"main\" prio=5 tid=1 Native\n  | group=\"main\" sCount=1 dsCount=0 obj=0x73990648 self=0xb8314850\n  | sysTid=900 nice=0 cgrp=default sched=0/0 handle=0xb6f4db34\n  | state=S schedstat=( 1678370971 1836936574 2507 ) utm=140 stm=27 core=0 HZ=100\n  | stack=0xbe197000-0xbe199000 stackSize=8MB\n  | held mutexes=\n  native: pc 00000000000429f4  /system/lib/libc.so (__ioctl+8)\n  native: pc 00000000000495d1  /system/lib/libc.so (ioctl+14)\n  native: pc 000000000001e82d  /system/lib/libbinder.so (_ZN7android14IPCThreadState14talkWithDriverEb+132)\n  native: pc 000000000001ee6b  /system/lib/libbinder.so (_ZN7android14IPCThreadState15waitForResponseEPNS_6ParcelEPi+38)\n  native: pc 000000000001f021  /system/lib/libbinder.so (_ZN7android14IPCThreadState8transactEijRKNS_6ParcelEPS1_j+124)\n  native: pc 0000000000019fe3  /system/lib/libbinder.so (_ZN7android8BpBinder8transactEjRKNS_6ParcelEPS1_j+30)\n  native: pc 0000000000088fd1  /system/lib/libandroid_runtime.so (???)\n  native: pc 0000000000d8f531  /data/dalvik-cache/arm/system@framework@boot.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+140)\n  at android.os.BinderProxy.transactNative (BinderProxy.java)\n  at android.os.BinderProxy.transact (BinderProxy.java:503)\n  at android.app.job.IJobScheduler$Stub$Proxy.schedule (IJobScheduler.java:120)\n  at android.app.JobSchedulerImpl.schedule (JobSchedulerImpl.java:42)\n  at com.evernote.android.job.v21.JobProxy21.schedule (JobProxy21.java:173)\n  at com.evernote.android.job.v21.JobProxy21.plantPeriodicFlexSupport (JobProxy21.java:94)\n  at com.evernote.android.job.JobManager.create (JobManager.java:233)\n  at com.evernote.android.job.JobManager.schedule (JobManager.java:233)\n  at com.evernote.android.job.JobManager.e (JobManager.java:233)\n  at com.evernote.android.job.JobRequest.schedule (JobRequest.java:337)\n  at com.touchtalent.bobbleapp.services.BackgroundBinaryDictSyncJob.scheduleBackgroundJob (BackgroundBinaryDictSyncJob.java:40)\n  at com.touchtalent.bobbleapp.services.BobbleKeyboard.scheduleABackgroundJob (BobbleKeyboard.java:4163)\n  at com.touchtalent.bobbleapp.services.BobbleKeyboard.onCreate (BobbleKeyboard.java:1030)\n  at android.app.ActivityThread.handleCreateService (ActivityThread.java:2877)\n  at android.app.ActivityThread.-wrap4 (ActivityThread.java)\n  at android.app.ActivityThread$H.handleMessage (ActivityThread.java:1427)\n  at android.os.Handler.dispatchMessage (Handler.java:102)\n  at android.os.Looper.loop (Looper.java:148)\n  at android.app.ActivityThread.main (ActivityThread.java:5417)\n  at java.lang.reflect.Method.invoke! (Native method)\n  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:726)\n  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:616). Is there any solution for this.. Sorry @vRallev for replying you late, Your suggestion finally resolve the issue. Thank you!. ",
    "misrakli": "Thanks for the quick response.\nBy the way the library runs the job even after a reboot, I think this is same bug you are pointing to.\nThe problem with cancelling the job is that I cannot determine whether i should cancel the job or not, the jobs should run as long as the app is running.\nI don't know a way to get informed when the app is force closed, the system should decide itself if any alarms or jobs should be fired or not in such a case.\nI will try the same use case on an Google Pixel device and will come back to you.\nIs there a ETA for 1.2.0  (release)?\nUPDATE\nOn Google Pixel device (OS version 8 beta program)  the jobs are not executed after force closing the app (via the Settings). I believe, that the library behaves the same way on Nexus 5x and 6p.\nTo be honest, thats what I would expect, because as a user I also would not want that an app  runs or reschedules jobs even if force closed.. What dou you mean exactly with \"transient jobs\", do they survive in a special context (e.g. Activity) or as long as the application is running and the process is not killed?\n Force close is I think from the users perspective important, but this is as I understood nothing that I can manage as the system decides to keep the jobs scheduled even if the app process is killed (in case of Samsung).. Ok, I see, thats really exactly what I need in special cases. Looking forward for 1.2.0 \ud83d\udc4d\n But the fact that Pixel cancels jobs on force close is in my eyes the right behaviour ( I think this is default android behaviour, Samsung follows here a different approach). @AndreiHarasemiuc As @vRallev mentioned, the setPersistedmethod has a bug  and will be removed in 1.2.0.\nThe behaviour on Pixel is independent of this flag as it removes all jobs and alarms when force closing the app. You can test this by implementing a test app by using the android API instead of this library.\nI don't know if there is a way to go around this behaviour.. @AndreiHarasemiuc an option is to use an MDM tool if you have managed devices and prohibit the users force closing the app\nBy the way, swiping away the app from the task list doesn't cancel the alarms, neither set by JobScheduler nor by AlarmManager. This is the behaviour I can see on many different devices (nexus, pixel, samsung, enterprise devices from motorola, honeywell, ...). The only difference I have seen is that force closing the app on an xcover4 the jobs remains still scheduled (maybe this is also not always the case and Samsung has its own strategy depending on system state like memory, battery state,...)\n. @TakeoffAndroid I think that manufacturers follows their own strategy on handling force closing app and removing from recent task list. Some will remove all pending jobs and alarms, others maybe not in all cases. Did you looked via adb if your jobs are still scheduled after removing the app?\nadb shell dumpsys jobscheduler\nadb shell dumpsys alarm\n. Hmm, I would like to avoid singletons, we have a high modularized app where (independent) features are activated / deactivated on demand and each feature has its own jobcreator.\nMaybe i will find another approach, thank you.. Two instances of same type doesn't make sense for me, that's a users' fault, inheritance could be a problem, but here I would suggest to compose objects and not to inherit (can also be handled by user), \nbut I see that's not easy for a library to expect that every user follows specific patterns.\nObject.class is really a point hat i didn't consider and don't have an idea yet.\n. 1) Android's JobScheduler and your way of using AlarmManager are working differently. \nJobs scheduled with JobScheduler are not effected by system time changes (this is what can i see in sample test app).\nSo using this library the app will work differently on devices with different OS versions..\n2) As noted in the documentation of SystemClock System.currentTimeMillis()\nshould only be used when correspondence with real-world dates and times is important, such as in a \ncalendar or alarm clock application.\nelapsedRealtime() is the recommend basis for general purpose interval timing.\nI think if the library provides an abstraction of different schedulers then it have to assure that\nevery concrete implementation works the same way.\nThe API with JobRequest says \"run this job in x ms\", but it does not say \"run this job in x ms according to the wall clock\".. @vRallev sorry for the delay, I was on vacation.\nI don't have any idea why the alarm is not treated as exact.\nOn which device/API did you run your tests?\nAre you calculating the offset using SystemClock.ellapsedRealtime()?\nDid you try different offsets for testing purpose?\nDo you have a branch with this changes so I can have a look on the code and try to test it?\n@strooooke Your way is only a workaround, the preferred way is I think that the library handles this the right way, see the discussion before.\n. Thanks for the quick response, I will give it a try.. Works as expected, changing the system time does not effect the alarms!\nHowever, there is one little problem when logging the time we waited for the alarm (JobProxy#executeJobRequest). The calculation there is based on System.currentTimeMillis, which will return a wrong result when the system time changes while waiting for the alarm.\nDo you think that we can use for scheduledAtthe elapsedRealtime? Actually I cannot evaluate the impact, for example the behaviour after reboot. \nWe can create a new issue for that if you want and close this one.\n. @nesterov-n it was not a suggestion but a thought, so this is your way of implementation :-)\nI share your concerns. The point with the negative value struck me, too, that's why I asked cautious.\nFor a correct way of the calculation of the wating time I think we need a monotone time running we can rely on, which we don't have on the system AFAIK (only the elapsedRealtTime which is reseted after reboot).. @vRallev \n\nbut this was already the case with the JobScheduler on newer versions.\n\nI didn't understand what you exactly mean with that. Is there already a known restriction?\n. Ok, I see. Maybe we'll find a solution in future releases :-). If you have any other issues with that than let me know.\nDo you have any roadmap for the merge back to 1.2?. Yes, I did. I don't expect anything you can do for the library itself, but maybe update the FAQ as it can lead to misunderstanding.. I didn't see any distinction between periodic and non periodic alarms, both are cleared when system determines that no more pending alarms for this application must exist.. If 'JobIntentService' cannot be referenced than check your dependencies and see which support library version is used at runtime.\n'JobIntentService' is supported since version 26.0.0. ",
    "AndreiHarasemiuc": "\nUPDATE\nOn Google Pixel device (OS version 8 beta program) the jobs are not executed after force closing the app (via the Settings). I believe, that the library behaves the same way on Nexus 5x and 6p.\nTo be honest, thats what I would expect, because as a user I also would not want that an app runs or reschedules jobs even if force closed.\n\nIf you set .setPersisted(true), is the job still running after you close the app on a Pixel?\nI'm dependent on the jobs running no matter what.. Well this is unfortunate. @vRallev Is there any way around this? I'd hate to refactor everything and stop using this library but the app that I'm building will be used in hospitals and the Jobs represent medication reminders. I need them to run in every situation imaginable except when the device is off.. I will not have managed devices but I think I can live with this if the jobs only get cancelled when force closed (through settings). Thanks for your answers!. First off, thanks a lot for responding.\nI will do my best to explain what I want to achieve. I'm building a calendar/clock type app. I need to be able to show the user precise daily, weekly and monthly reminders, on the clock.\nex. User set an alarm called \"Take heart pills\" for every day 14:25 PM. I need a job to run every day at that precise time. The job's purpose would be to simply show a UI notification reminding the user to take his pills. The exact same thing for weekly (ex. every Tuesday at 15:35 PM) and Monthly (ex. every 28th of every month at 15:35 PM)\nSo based on your last response, the second approach I mentioned:\n\nschedule an exact job after which on the exact job's onJobRun, schedule another exact job ad infinitum\nshould work just fine?\n\nMy worry is that if the job is over time by a factor of days (therefore passing multiple points where it should've been rescheduled) the scheduling of the next job will be messed up, but I guess I can calculate the correct next occurrence.. Thank vRallev, I have managed to implement a working solution.. Hey, I made a repository with a sample app with which I have managed to reproduce the issue 100% of times provided I follow these exact steps.\nhttps://github.com/AndreiHarasemiuc/Android-Job-Rescheduling-Issue-sample\n\nLaunch the app\nApp will wait 10 seconds (Handler.postDelayed) and schedule an exact job with a delay of 20 seconds.\nAt the moment you see in the logs that the job has been scheduled, close off the app from recent tasks.\nIn 20 seconds the job will run. The job will do 2 things. Show a notification & schedule another job with a delay of 1 minute.\nWhen the job runs and the notification is displayed, immediately click the notification. Clicking the notification will take you to an empty activity. As soon as that activity opens, background the app.\n\nResult: The second job that you just scheduled (with a delay of 1 minute) will run with a delay of 0 seconds soon after you background the app.\nPlease note that the sample app does not use 1.2.0-alpha3 because I had some weird errors and couldn't buld the project and didn't have time to see what they were about. so I used 1.1.11 However, I succesfully added 1.2.0-alpha3 in my main project and I could still reproduce the issue just like before.\n\n. I have tested the new version you published and I can still replicate the issue on several of my devices as well as on an emulator. Looking at your logs, I am under the impression you are missing a step when trying to replicate the issue.\n\nThe last step says:\n\nWhen the job runs and the notification is displayed, immediately click the notification. Clicking the notification will take you to an empty activity. As soon as that activity opens, background the app.\n\n\nThe highlighted part will make the reschedule service run when the app was backgrounded, and only in that case it will mis-schedule a job for me.\nLet me summarize:\n\nOpen app (it will schedule a job in 20 sec)\nClose app completely (swipe off task list)\nImmediately tap on the notification when it shows (due to the 20 sec job running)\nBackground the app (tap Home) immediately after the empty activity appears (as a result of tapping the notification)\nJob scheduled a minute from now will run a couple of seconds later.\n\nI am aware this is frustrating but I have triple checked everything and I can still reproduce this with a 100% success rate on any device I try. Please give it another shot.. @vRallev My last comment might have flown under the radar because of all the other new tickets and I also failed to mention your name. Could you please take a look at this when you have a chance?\nThanks!. @vRallev No worries, thank you for your responses, I was just making sure my comment didn't fly under the radar. I'm a novice github user.\n. @vRallev Hey man, looks like the bug is gone! Thanks for the fix!. ",
    "TakeoffAndroid": "Exactly same issue. My Job is stopped when I remove the app from the recent task. Is there any work around? Will it work if I make setPersisted(true) instead?. I have similar issue. When I remove the app form the recent task, then application job class stops executing. Is this the expected behaviour of Android job? . I get that. But what if my periodic service needs to be executed if the app is not opened at all?. Let's say if the user has not opened since long time but my periodic job should be executed irrespective of these scenario, then what should be the work around?. Sure. But how come some famous apps and games sends a notification locally when the app is not opened at all.(i.e. Without fcm or gcm). I guess there should be a way to achieve this. . @vRallev I found this from AlarmManager official docs https://developer.android.com/reference/android/app/AlarmManager.html\n\nNote: The Alarm Manager is intended for cases where you want to have your application code run at a specific time, even if your application is not currently running. For normal timing operations (ticks, timeouts, etc) it is easier and much more efficient to use Handler.\n\n. Dude. This was just a suggestion. I was figuring out a way to fix in this repository. But I guess you took it in a different way. Anyways thanks. . ",
    "raheeladnan": "Thanks @vRallev for quick response. . ",
    "FlorangOutang": "Okay thank you for the explanation ! \nI, indeed, misunderstood the execution window system. \nI will take a look at the helper you linked and wait for the 1.2.0 to come out !\nThank you again\nFlorent. No problem for me. \nJust to let you know : \nI am using the 1.2.0-alpha3\nI used your exemple : \n```Kotlin \nval startMs = TimeUnit.HOURS.toMillis(23)\nval endMs = TimeUnit.HOURS.toMillis(6)\nval builder = JobRequest.Builder(TAG)\n                    .setRequiresDeviceIdle(true)\n                    .setUpdateCurrent(updateCurrent)\nDailyJob.schedule(builder, startMs, endMs)\n```\nAnd I get the following schedule time : \nD/JobProxy24: Schedule one-off jobInfo success, request{id=1, tag=job_notif_tag, transient=false}, start 12:39:41, end 19:39:41, reschedule count 0\nI guess it's an issue with the alpha version ? \nOr Am I still writing something wrong ... ? :(\nThanks anyway\nFlorent. ",
    "vishna": "the documentation says the job would schedule between 11PM and 6AM - whereas the log output says something else. ",
    "strooooke": "I vaguely recall running into this before - ended up listening for time_changed and timezone_changed broadcasts and adjusting and rescheduling the alarms there.. @misrakli I agree that the library should handle this; I was just trying to be helpful by relaying my on experience about the \"for some unclear reason, alarms aren't exact anymore when switching to ELAPSED_REALTIME_WAKEUP\" snag - maybe a bit too vague to be actually helpful, but as I said, I've seen this before.. Perfect!. Ah, now I see; you're completely right. So 1 is a non-issue.\nFor 2, I have a suggestion that's easier to express as a PR than in prose - I guess the help wanted tag means you'd like to get one?. Sure will - tomorrow.. All fixed, test added, build is successful.. Sorry, I failed at github.. ",
    "nesterov-n": "I have some concerns about using SystemClock.elapsedRealtime() for JobRequest#getScheduledAt field\n- It's part of public api. Clients could rely some logic on its value. Semver doen't allow backward incompatible changes in minor update 1.1 -> 1.2\n- If job is executed after device reboot long waited = SystemClock.elapsedRealtime() - request.getScheduledAt() can have negative value. Reboot is more common case than changing system time. So it won't be useful for debuging purposes.\nfix suggested by @misrakli  is implemented in #277 . @vRallev Maybe you have some estimation when 1.2.0 final will be ready? I'm ready to help with blocking issues. ",
    "olgadg": "Hi, \nthanks for answering.\nI've checked out the branch, I see you ignored the testGCM test, is it just the test is not reliable? Can I still trust scheduling jobs requiring internet connection?\nNow all the test fail on an API 19 emulator due to not having android JobScheduler\njava.lang.NoClassDefFoundError: android.app.job.JobScheduler\nat com.evernote.android.job.JobManagerRule.getJobScheduler(JobManagerRule.java:43)\nat com.evernote.android.job.JobManagerRule.after(JobManagerRule.java:30)\nat org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:50)\nat org.junit.rules.RunRules.evaluate(RunRules.java:20)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runners.Suite.runChild(Suite.java:128)\nat org.junit.runners.Suite.runChild(Suite.java:27)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\nat org.junit.runner.JUnitCore.run(JUnitCore.java:115)\nat android.support.test.internal.runner.TestExecutor.execute(TestExecutor.java:59)\nat android.support.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:262)\nat android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1701)\nIf I comment out the line\ngetJobScheduler().cancelAll(); in the after method, I have the same behaviour as before:\nThe tests run fine if the emulator is already running, but testApi14 and sometimes testApi19 fail when I don't have the emulator running before running the tests. \nMy CI sometimes restarts emulators, I reproduce it locally by closing the emulator and running the tests from Android Studio and then selecting a not connected emulator. \n. Ok, thanks for checking. \nAssuming there is no reason why the scheduled job wouldn't run sometime in the future, we are willing to let the test flaky and just trust it.\nPlease, let me know if you find anything new about this in the future. . ",
    "ilarisahi": "Thanks for quick response.\nMy job is not running as expected. I have following builder in my Job's schedule-function\njava\nJobRequest.Builder builder =  new JobRequest.Builder(TAG);\nbuilder\n        .setExtras(extras)\n        .setExact(startDelay)\n        .setUpdateCurrent(update)\n        .build()\n        .schedule();\nI can set the startDelay variable to for example 2pm, and the job is still run immediately if I press home and it's 1am. However if the job has been previously created and is scheduled to be run at 2pm, it will run at 2pm.. I am actually using the calculations from 1.2.0's DailyJob\n```java\nprivate static final long DAY = TimeUnit.DAYS.toMillis(1);\npublic static void schedule(int initHour, int initMinute, boolean update, boolean updateTime) throws IllegalArgumentException {\n    if (!JobManager.instance().getAllJobRequestsForTag(TAG).isEmpty() && !update && !updateTime) {\n        return;\n    }\nSystem.out.println(\"Scheduling daily job\");\n\nlong timeMs = TimeUnit.HOURS.toMillis(initHour) + TimeUnit.MINUTES.toMillis(initMinute);\nif (timeMs >= DAY || timeMs < 0) {\n    throw new IllegalArgumentException(\"startMs or endMs should be less than one day (in milliseconds)\");\n}\n\nCalendar calendar = Calendar.getInstance();\nint hour = calendar.get(Calendar.HOUR_OF_DAY);\nint minute = calendar.get(Calendar.MINUTE);\nint second = calendar.get(Calendar.SECOND);\n\n// current time + startDelay = 00:00\nlong startDelay = TimeUnit.SECONDS.toMillis(60 - second)\n        + TimeUnit.MINUTES.toMillis(60 - minute)\n        + TimeUnit.HOURS.toMillis((24 - hour) % 24)\n        - TimeUnit.HOURS.toMillis(1); // subtract because we're adding minutes and seconds\n\nstartDelay = (startDelay + timeMs) % TimeUnit.DAYS.toMillis(1);\n\nif (startDelay <= 0) {\n    startDelay = TimeUnit.DAYS.toMillis(1);\n}\nSystem.out.println(\"startDelay: \" + startDelay);\n\nPersistableBundleCompat extras = new PersistableBundleCompat();\nextras.putInt(\"EXTRA_HOUR_MS\", initHour);\nextras.putInt(\"EXTRA_MINUTE_MS\", initMinute);\n\nJobRequest.Builder builder =  new JobRequest.Builder(TAG);\nbuilder\n        .setExtras(extras)\n        .setExact(startDelay)\n        .setUpdateCurrent(update)\n        .build()\n        .schedule();\n\n}\nI am getting the right values for `startDelay`, for example `17682000` and it is correctly scheduled\n07-26 15:06:18.454 7263-7263 D/JobProxy14: Scheduled alarm, request{id=1, tag=DailyNotificationJob, transient=false}, delay 04:54:42, exact true, reschedule count 0\n```\nbut it is still run immediately if I press home immediately.. I'm unable to reproduce the issue with the demo project, so I guess the problem is with my project.. I'll re-open this issue if I manage to repro.. ",
    "sethmuss": "No problem. Thanks for getting that fixed so quick! I verified your fix works in our app.. ",
    "jjfster": "I disabled Proguard and the same issue continues:\nHere is the original snippet from the build.gradle file:\n   debug {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\nYes, happens in release also.\nAs mentioned, the net.vrallev.android file exists in the gradle cache, but I'm wondering if it isn't being read properly in 4.x for some reason?\nLog snippet:\nW/dalvikvm(26009): Unable to resolve superclass of Lcom/evernote/android/job/util/JobCat; (5240)\nW/dalvikvm(26009): Link of class 'Lcom/evernote/android/job/util/JobCat;' failed\nE/dalvikvm(26009): Could not find class 'com.evernote.android.job.util.JobCat', referenced from method com.evernote.android.job.JobManager.\nW/dalvikvm(26009): VFY: unable to resolve new-instance 3589 (Lcom/evernote/android/job/util/JobCat;) in Lcom/evernote/android/job/JobManager;\nD/dalvikvm(26009): VFY: replacing opcode 0x22 at 0x0000\nW/dalvikvm(26009): VFY: unable to find class referenced in signature (Lnet/vrallev/android/cat/CatLog;)\nI/dalvikvm(26009): Could not find method net.vrallev.android.cat.CatLog.i, referenced from method com.evernote.android.job.JobManager.cancelInner\nW/dalvikvm(26009): VFY: unable to resolve virtual method 37778: Lnet/vrallev/android/cat/CatLog;.i (Ljava/lang/String;[Ljava/lang/Object;)V\nD/dalvikvm(26009): VFY: replacing opcode 0x6e at 0x0018\nI/dalvikvm(26009): Could not find method net.vrallev.android.cat.CatLog.i, referenced from method com.evernote.android.job.JobManager.cancelInner\nW/dalvikvm(26009): VFY: unable to resolve virtual method 37778: Lnet/vrallev/android/cat/CatLog;.i (Ljava/lang/String;[Ljava/lang/Object;)V\nD/dalvikvm(26009): VFY: replacing opcode 0x6e at 0x000c\nI/dalvikvm(26009): Could not find method net.vrallev.android.cat.CatLog.w, referenced from method com.evernote.android.job.JobManager.create\nW/dalvikvm(26009): VFY: unable to resolve virtual method 37779: Lnet/vrallev/android/cat/CatLog;.w (Ljava/lang/String;)V\nD/dalvikvm(26009): VFY: replacing opcode 0x6e at 0x002b\nI/dalvikvm(26009): Could not find method net.vrallev.android.cat.CatLog.w, referenced from method com.evernote.android.job.JobManager.create\nW/dalvikvm(26009): VFY: unable to resolve virtual method 37779: Lnet/vrallev/android/cat/CatLog;.w (Ljava/lang/String;)V\nD/dalvikvm(26009): VFY: replacing opcode 0x6e at 0x0038\nI/dalvikvm(26009): Could not find method net.vrallev.android.cat.CatLog.w, referenced from method com.evernote.android.job.JobManager.forceApi\nW/dalvikvm(26009): VFY: unable to resolve virtual method 37780: Lnet/vrallev/android/cat/CatLog;.w (Ljava/lang/String;[Ljava/lang/Object;)V\nD/dalvikvm(26009): VFY: replacing opcode 0x6e at 0x0013\nI/dalvikvm(26009): Could not find method net.vrallev.android.cat.CatLog.w, referenced from method com.evernote.android.job.JobManager.schedule\nW/dalvikvm(26009): VFY: unable to resolve virtual method 37779: Lnet/vrallev/android/cat/CatLog;.w (Ljava/lang/String;)V\nD/dalvikvm(26009): VFY: replacing opcode 0x6e at 0x000c\nI/dalvikvm(26009): Could not find method net.vrallev.android.cat.CatLog.w, referenced from method com.evernote.android.job.JobManager.schedule\nW/dalvikvm(26009): VFY: unable to resolve virtual method 37779: Lnet/vrallev/android/cat/CatLog;.w (Ljava/lang/String;)V\nD/dalvikvm(26009): VFY: replacing opcode 0x6e at 0x005d\nW/dalvikvm(26009): Unable to resolve superclass of Lcom/evernote/android/job/util/JobCat; (5240)\nW/dalvikvm(26009): Link of class 'Lcom/evernote/android/job/util/JobCat;' failed\nD/dalvikvm(26009): DexOpt: unable to opt direct call 0x6fb3 at 0x04 in Lcom/evernote/android/job/JobManager;.\nW/dalvikvm(26009): Exception Ljava/lang/NoClassDefFoundError; thrown while initializing Lcom/evernote/android/job/JobManager;\nD/AndroidRuntime(26009): Shutting down VM\nW/dalvikvm(26009): threadid=1: thread exiting with uncaught exception (group=0x417e4b90)\nE/AndroidRuntime(26009): FATAL EXCEPTION: main\nE/AndroidRuntime(26009): Process: app, PID: 26009\nE/AndroidRuntime(26009): java.lang.NoClassDefFoundError: com.evernote.android.job.util.JobCat\nE/AndroidRuntime(26009):    at com.evernote.android.job.JobManager.(JobManager.java:83)\n. No, not disabling transitive dependencies.\nI had tried adding that dependency before, seeing it in the demo, with no change.  Just tried it again with no luck.\nI'm going to probably have to look thru everything between the demo and this app to see where the problem lies I guess.  I have several gradle compile statements, so maybe something is conflicting there.  \nOtherwise, I guess I'll have to find another way to manage jobs (go back to the old way, yuck!).\n. I think I may have it (doh!).\nI was loading job before multidex in the Application class:\n         JobManager.create(this).addJobCreator(new JobCreator());\n         android.support.multidex.MultiDex.install(this);\n. Ok, so here's another problem.  \nOn 4.4, I get this (even though it is 4.4 and not 6.0):\nCould not find method android.app.AlarmManager.setExactAndAllowWhileIdle, referenced from method com.evernote.android.job.v14.JobProxy14.plantOneOffExact\nCan I just ignore it?\n. I'll just ignore it.  Seems benign.\n. ",
    "Abdullah-Hussein": "@AndreiHarasemiuc   I have same issue , but happen with my huawei device only and not in emulator , i set 5 alarm with same way you use and some times 1 alarm fire , but alot off times 3 , 4 or all alarm fire together !!\ndid you find solution for this issue ? . @vRallev  thanks for fast replay , but i confused how to schedule 5 jobs in different times everyday without faceing this problem ?\nand i see in documentation that if i use setExact this job will not reschedule , so why JobRescheduleService called? . @vRallev  but in my case just alarm fire! ,why it called ? \n. May be this issue from Huawei Protected Applications, you must give app permission to run in the background, see here\nhttps://android.stackexchange.com/questions/152649/what-is-protected-apps-in-huawei-phones\nI don't know if this optional in OPPO, let us know!. ",
    "ariefradityo": "Scheduling code:\njava\nJobRequest.Builder builder = new JobRequest.Builder(DailyDataUsageJob.TAG).setExtras(createExtras(TimeUnit.HOURS.toMillis(0), TimeUnit.HOURS.toMillis(1)));\nDailyJob.schedule(builder, TimeUnit.HOURS.toMillis(0), TimeUnit.HOURS.toMillis(1));\ncreateExtras:\njava\nprivate PersistableBundleCompat createExtras(long start, long end) {\n        PersistableBundleCompat extras = new PersistableBundleCompat();\n        extras.putLong(DailyPhoneScraperJob.EXTRA_START_MS, start);\n        extras.putLong(DailyPhoneScraperJob.EXTRA_END_MS, end);\n        return extras;\n  }\nThe scheduling method started on the start of the application, I experienced the crash accidentally when starting the application at midnight 00:08. On the other time of the day it's working perfectly fine. \ncreateExtras method is for passing the start and end time for the daily job (since without this, dailyjob does not reschedule for the next day). ",
    "TylerMcCraw": "Actually, I just saw that you all are already working on the new constraints here: https://github.com/evernote/android-job/wiki/Version-1.2.0-and-Android-O\nBut what about the work queue and clip data features?. I saw the new startNow() method, but how is that making use of the new enqueue functionality?\nCorrect me if I'm wrong, but it seems as if enqueue() could be used to submit new work for a new or existing job. And so I could see a strong use case for someone wanting to be able to, for example, queue up new, locally-updated changes to a server for a job whose sole responsibility is pushing changes up to a server.\nI could absolutely make use of this sort of functionality.\n(Also, I don't have a great use case for Clip Data yet either. I'd just ignore that for now until someone has no other option.). Ok so we could call startNow() multiple times to queue up more work and it would essentially reuse the same job? Is that correct?. Ok cool thanks for the heads up and the info.\nYou can close this issue, if you'd like.. ",
    "cre8ivejp": "Thank you for your quick reply!\nI will upgrade the library and I will let you know if there is any issue.. @vRallev \nHi!\nJust to let you know the alpha4 worked fine for us. We just released it\nYou can close this issue when you want.\nThank you!. @clayjh I'm sorry, I thought I was replying another thread. \nPlease ignore the last message.\nYes, in my case I only needed to upgrade to fix it.. ",
    "ngoctranfire": "@vRallev Just curious. Now that Android-O has been officially released, what is the timeline for evernote job library to move from alpha-4 to a RC or even a stable release version?. ",
    "clayjh": "@cre8ivejp Did upgrading fix your android O issue?. Encrypt? Hmm do you mean rebuild the project?\nOn Wed, Mar 14, 2018 at 9:02 PM, cre8ivejp notifications@github.com wrote:\n\n@clayjh https://github.com/clayjh It depends.\nYou need to encrypt again after you upgrade. If you can do that, then the\nanswer is yes, otherwise no.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/254#issuecomment-373253880,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AUIr6LZvjMpbk2rtkBbn_zpFI86PKOrvks5teefTgaJpZM4O_mkB\n.\n. @cre8ivejp Perfect thanks \ud83d\udc4d . \n",
    "talklittle": "Issue still present as of 1.2.0-RC3.. ",
    "KennyGoers": "Issue, maybe not the same but similar is still present in 1.2.0:\nFatal Exception: java.lang.RuntimeException: An error occurred while executing doInBackground()\n       at android.os.AsyncTask$3.done(AsyncTask.java:353)\n       at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:383)\n       at java.util.concurrent.FutureTask.setException(FutureTask.java:252)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:271)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n       at java.lang.Thread.run(Thread.java:764)\nCaused by java.lang.SecurityException: Caller no longer running, last stopped +663ms because: timed out while starting\n       at android.os.Parcel.readException(Parcel.java:1942)\n       at android.os.Parcel.readException(Parcel.java:1888)\n       at android.app.job.IJobCallback$Stub$Proxy.dequeueWork(IJobCallback.java:191)\n       at android.app.job.JobParameters.dequeueWork(JobParameters.java:196)\n       at android.support.v4.app.JobIntentService$JobServiceEngineImpl.dequeueWork(JobIntentService.java:314)\n       at android.support.v4.app.JobIntentService.dequeueWork(JobIntentService.java:639)\n       at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:389)\n       at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:382)\n       at android.os.AsyncTask$2.call(AsyncTask.java:333)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n       at java.lang.Thread.run(Thread.java:764). My question is, is this a long running job issue? I can't find limits stated anywhere for jobs, but guessing they exist? And this is a problem as I'm doing network communication and timeouts would cause havoc on run length limits.... This is in the 26.1.0 version, build with the 3.0 Android Studio and I haven't seen the problem myself with a Nexus 5X with 8.0 and not 8.1, only shows with my users in Fabric and it's pretty common there. I don't know if it just happens occasionally and reruns later or continually.  . I've had over 127 users with this crash with production code. This error, closed, it should not be.. ",
    "divergentdave": "@KennyGoers Which version of the support library are you using? My problems went away when I upgraded from the beta version to the production version.. ",
    "alexanderkjeldaas": "@vRallev @KennyGoers did you file an issue?. ",
    "dkijkuit": "```\njava.lang.RuntimeException: An error occurred while executing doInBackground()\nat android.os.AsyncTask$3.done(AsyncTask.java:353)\nat java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:383)\nat java.util.concurrent.FutureTask.setException(FutureTask.java:252)\nat java.util.concurrent.FutureTask.run(FutureTask.java:271)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\nat java.lang.Thread.run(Thread.java:764)\nCaused by: java.lang.SecurityException: Caller no longer running, last stopped +2s519ms because: timed out while starting\nat android.os.Parcel.readException(Parcel.java:2004)\nat android.os.Parcel.readException(Parcel.java:1950)\nat android.app.job.IJobCallback$Stub$Proxy.dequeueWork(IJobCallback.java:191)\nat android.app.job.JobParameters.dequeueWork(JobParameters.java:208)\nat android.support.v4.app.JobIntentService$f.b(SourceFile:314)\nat android.support.v4.app.JobIntentService.d(SourceFile:639)\nat android.support.v4.app.JobIntentService$a.a(SourceFile:389)\nat android.support.v4.app.JobIntentService$a.doInBackground(SourceFile:382)\nat android.os.AsyncTask$2.call(AsyncTask.java:333)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\n... 3 more\njava.lang.SecurityException: Caller no longer running, last stopped +2s519ms because: timed out while starting\nat android.os.Parcel.readException(Parcel.java:2004)\nat android.os.Parcel.readException(Parcel.java:1950)\nat android.app.job.IJobCallback$Stub$Proxy.dequeueWork(IJobCallback.java:191)\nat android.app.job.JobParameters.dequeueWork(JobParameters.java:208)\nat android.support.v4.app.JobIntentService$f.b(SourceFile:314)\nat android.support.v4.app.JobIntentService.d(SourceFile:639)\nat android.support.v4.app.JobIntentService$a.a(SourceFile:389)\nat android.support.v4.app.JobIntentService$a.doInBackground(SourceFile:382)\nat android.os.AsyncTask$2.call(AsyncTask.java:333)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\nat java.lang.Thread.run(Thread.java:764)\n```. ",
    "apoi": "Optimizely recently fixed a similar-looking issue at https://github.com/optimizely/android-sdk/pull/193. Could this problem be the same?. ",
    "ymmike": "That fix would be sufficient for us.  We're seeing this as one of our top crashes in an app with widespread use as well, increasing each day the more users that onboard via O.. We see it on all kinds of devices.  We're in the 1000s of users with this crash.\nOur spread is:\nSamsung 55%\nGoogle 17%\nHMD Global 12%\nHuawei 4%\nOther\u2026 12%\nFrom what we can tell yigit's job library doesn't have this issue, so we are experimenting with moving off the evernote library since it's getting to be a year with this issue at large.\nhttps://github.com/yigit/android-priority-jobqueue\n. ",
    "laminina": "We're seeing this issue with a high number of crashes +100K. . ",
    "henriquenfaria": "I have experienced this crash using android-job version 1.2.5. Downgraded it to 1.2.2 and the issue was gone.. Yes, but in my case I was just including the com.android.support:appcompat-v7:27.0.2.\nThis version clashed with the com.android.support:support-media-compat:26.0.1.\nMaybe this situation can be somehow improved after fixing #326. And of course, after updating the compile API and all support libraries.. It is fixed for me now. Thanks @vRallev. ",
    "iNoles": "I am wondering that JobScheduler really have timeout.. It may need android.permission.WRITE_EXTERNAL_STORAGE. DailyJob only schedule BETWEEN one time to another times per day. . I think it needs\n<action android:name=\"com.google.android.gms.gcm.ACTION_TASK_READY\" />\nfor that service in AndroidMainfest.xml. Latest version is 1.2.5. Google Play Services 15.0.0 - \"Deprecated the GoogleCloudMessaging, GcmPubSub, GcmReceiver, GcmListenerService, InstanceID, and InstanceIDListenerService classes. Use FirebaseMessaging instead.\". I think you don't need .java. ",
    "xXxXxXxXxXam": "Interestingly, only seeing this issue reported from HUAWEI devices. Anyone else seeing that?. Does anyone have a reliable repro case for this one? Only seeing it in the wild, haven't been able to repro it yet myself.. thanks. ",
    "Agraphie": "I can also confirm that this crash happens occasionally across all kind of devices. Unfortunately I also couldn't find a way to reliably reproduce the issue...\nEDIT: @Jeff11 how did you reproduce the issue? Can you please provide all steps?. ",
    "ankit010cse80": "has anyone find solution ? I am facing this problem when I start app with debugger . ",
    "zenyagami": "I have the same issue with Android O. I have the same issue as @Jeff11 in a Huawei running 8.0.0 using 1.3.0-alpha03\nCaused by java.lang.SecurityException: Caller no longer running, last stopped +3s72ms because: timed out while stopping\n       at android.os.Parcel.readException(Parcel.java:1945)\n       at android.os.Parcel.readException(Parcel.java:1891)\n       at android.app.job.IJobCallback$Stub$Proxy.completeWork(IJobCallback.java:218)\n       at android.app.job.JobParameters.completeWork(JobParameters.java:220)\n       at android.support.v4.app.JobIntentService$JobServiceEngineImpl$WrapperWorkItem.complete(JobIntentService.java:267)\n       at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:393)\n       at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(JobIntentService.java:382)\n       at android.os.AsyncTask$2.call(AsyncTask.java:345)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)\n       at java.lang.Thread.run(Thread.java:784). The Version 1.3.0-alpha04 is working great in my production app it does not crash anymore sometimes crash but really normal thing. ",
    "bipinayetra": "Hi evernote,\nwe had this issue, we made a child class out of the JobIntentSerivce. And started using the child class throughout our project.\nwe also wrapped the dequeWork method in the framework with try catch.\npackage android.support.v4.app;\nimport timber.log.Timber;\npublic abstract class MyJobIntentService extends JobIntentService {\n@Override\nGenericWorkItem dequeueWork() {\n\n    try {\n        return super.dequeueWork();\n    } catch (SecurityException ignored) {\n        Timber.e(ignored);\n    }\n\n    return null;\n}\n\n}\nTake a note here, i have mentioned the same package name, to get access to GenericWorkItem. ",
    "galex": "Having this issue as well... so the try/catch workaround isn't enough?. @vRallev Would it be possible to release a 1.2.7 version as 1.2.6 + this fix only? \n1.3.0 is in alpha06 (which uses WorkManager, also in alpha) so it doesn't feel stable yet for a production app right now, so I'm afraid to upgrade to 1.3.0-alpha06 but would not mind a stable 1.2.7 just with this fix.\nThis crash happens a lot in our app so I am looking for ways to get this fix quickly.\nThank you in advance,\nAlex. @vRallev I understand but I can't use something with \"alpha\" in its name our production app. Do you have any idea when 1.3.0 will be official / stable ? . I've made a version 1.2.7 which is 1.2.6 plus a fix for this issue. Feel free to build it and use it locally for your project. \nHere's the branch: https://github.com/galex/android-job/tree/1.2.7. > I will test 1.2.7 in our app.\n\nIs the fix solution based on the same thing like this one?\noptimizely/android-sdk#194\n\nSeems to me, yes.. ",
    "ductranit": "@vRallev I still got crash in 1.3.0-alpha03\nIf you look at the source code of JobServiceContext, you should try to do something with doCompleteWork as well\n. @vRallev base on @nguyenvp08 's suggestion, I create a new pull request #502 to fix this issue. Please review it and add to new release. Thanks!. ",
    "nguyenvp08": "HI @vRallev can you try this, i try to replace the CompatJobEngine mJobImpl by new one and try-catch both dequeueWork and completeWork methods : \n`public abstract class SafeJobIntentService extends JobIntentService {\n    public CompatJobEngine mJobImpl;\n@Override\npublic void onCreate() {\n    super.onCreate();\n    if (Build.VERSION.SDK_INT >= 26) {\n        mJobImpl = new JobServiceEngineImplEx(this);\n    } else {\n        mJobImpl = null;\n    }\n}\n\n@Override\nGenericWorkItem dequeueWork() {\n    try {\n        return super.dequeueWork();\n    } catch (SecurityException e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n\n/**\n * Implementation of a JobServiceEngine for interaction with JobIntentService.\n */\n@RequiresApi(26)\nstatic final class JobServiceEngineImplEx extends JobServiceEngine\n        implements JobIntentService.CompatJobEngine {\n    static final String TAG = \"JobServiceEngineImpl\";\n    static final boolean DEBUG = false;\n    final JobIntentService mService;\n    final Object mLock = new Object();\n    JobParameters mParams;\n\n    final class WrapperWorkItem implements JobIntentService.GenericWorkItem {\n        final JobWorkItem mJobWork;\n\n        WrapperWorkItem(JobWorkItem jobWork) {\n            mJobWork = jobWork;\n        }\n\n        @Override\n        public Intent getIntent() {\n            return mJobWork.getIntent();\n        }\n\n        @Override\n        public void complete() {\n            try {\n                synchronized (mLock) {\n                    if (mParams != null) {\n                        mParams.completeWork(mJobWork);\n                    }\n                }\n            } catch (Exception e) {\n                // Exception Here\n                e.printStackTrace();\n            }\n        }\n    }\n\n    JobServiceEngineImplEx(JobIntentService service) {\n        super(service);\n        mService = service;\n    }\n\n    @Override\n    public IBinder compatGetBinder() {\n        return getBinder();\n    }\n\n    @Override\n    public boolean onStartJob(JobParameters params) {\n        if (DEBUG) Log.d(TAG, \"onStartJob: \" + params);\n        mParams = params;\n        // We can now start dequeuing work!\n        mService.ensureProcessorRunningLocked(false);\n        return true;\n    }\n\n    @Override\n    public boolean onStopJob(JobParameters params) {\n        if (DEBUG) Log.d(TAG, \"onStartJob: \" + params);\n        boolean result = mService.doStopCurrentWork();\n        synchronized (mLock) {\n            // Once we return, the job is stopped, so its JobParameters are no\n            // longer valid and we should not be doing anything with them.\n            mParams = null;\n        }\n        return result;\n    }\n\n    /**\n     * Dequeue some work.\n     */\n    @Override\n    public JobIntentService.GenericWorkItem dequeueWork() {\n        JobWorkItem work = null;\n        try {\n            synchronized (mLock) {\n                if (mParams == null) {\n                    return null;\n                }\n                work = mParams.dequeueWork();\n            }\n        } catch (Exception e) {\n            // Exception Here\n            e.printStackTrace();\n        }\n        if (work != null) {\n            work.getIntent().setExtrasClassLoader(mService.getClassLoader());\n            return new WrapperWorkItem(work);\n        } else {\n            return null;\n        }\n    }\n}\n\n}\n`. ",
    "cgillions": "How stable is 1.3.0-alpha06? I'm seeing this issue on Android 8 devices (LG-H870DS & Motorola G6) with version 1.2.6.. If you aren't using android-job already, you should use the WorkManager library as it is created and maintained by Google. Evernote suggest using this library from now on.. ",
    "UFreedom": "@ruha9005 \nIf you not use android-job, you can check this SafeJobIntentService \nThe code was copy from android-job and just for solving the crash\n. ",
    "mikelibg": "Is there any solution for this issue? Because it seems that this issue occurs while using WorkManager as well.. Is it possible to schedule a periodic job every 2 hours but run immediately for the first time?. ",
    "FlorianMalapel": "Hi there ! Still no solution ? It's the same for me, I can't put your alpha version in production...\nIs there any fix schedule for the 1.2 version ? . ",
    "chris-prop": "I'm curious if the above solution has been verified and if there are any plans to release 1.2.7?. ",
    "afollestad": "+1 to releasing a fix. ",
    "chainsingh": "My application on create:\n@Override\n  public void onCreate() {\n    super.onCreate();\n    ...\n    JobManager.create(this).addJobCreator(new JobCreator());\n    JobManager.instance().forceApi(JobApi.GCM);\n    ....\n  }\npublic class JobCreator implements com.evernote.android.job.JobCreator {\n  @Override\n  public Job create(String tag) {\n    if (tag.equals(TAG)) {\n      return new JobClass();\n    }\n    return null;\n  }\n}\nOn click of a button, I trigger job as mentioned above.\nPlease let me know if anything else is required. It might help if you can tell me what is the confusion exactly.\n. Please find the sample app https://github.com/chainsingh/Android-Job-Rescheduling-Issue-sample. \nWhile testing, please keep device offline.\nSteps for reproduction are:\n1. In one case, keep JobManager.instance().forceApi(JobApi.GCM) commented in \n   SampleApplication. Click on schedule button. We would notice that job requiring network \n   connection will still be scheduled, even if we keep device offline. (The bug in my mind)\n2. In second case,  uncomment JobManager.instance().forceApi(JobApi.GCM) in SampleApplication, \n    i.e. use JobApi.GCM. Jobs will not be scheduled until i have the device online. And then it would\n    be immediately scheduled. (Which is what i desire, but do not want to force jobapi.gcm).\nMain question is the behavior in first point even intended behaviour? \nFWIW, my android version is 6.0.1 and mobile is nexus 5.. ",
    "koh-osug": "The onRunJob is executing this asynchronously with an intent call to a service. So, I guess synchronize does not help?. ",
    "henrichg": "I have the same report from Crashlytics.\n- android-job version: 1.1.11\n- device: Sony XPeria Z1, Android 5.1.1, rooted\nFatal Exception: java.lang.RuntimeException: Unable to create service sk.henrichg.phoneprofilesplus.PhoneProfilesService: android.database.sqlite.SQLiteCantOpenDatabaseException: unknown error (code 14): Could not open database\n       at android.app.ActivityThread.handleCreateService(ActivityThread.java:2835)\n       at android.app.ActivityThread.access$1800(ActivityThread.java:156)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1434)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:211)\n       at android.app.ActivityThread.main(ActivityThread.java:5389)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1020)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:815)\nCaused by android.database.sqlite.SQLiteCantOpenDatabaseException: unknown error (code 14): Could not open database\n       at android.database.sqlite.SQLiteConnection.nativeOpen(SQLiteConnection.java)\n       at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:215)\n       at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:199)\n       at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:463)\n       at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:185)\n       at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:177)\n       at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:806)\n       at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:791)\n       at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:694)\n       at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:1167)\n       at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:268)\n       at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:223)\n       at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:163)\n       at com.evernote.android.job.JobStorage.getDatabase(JobStorage.java:297)\n       at com.evernote.android.job.JobStorage.store(JobStorage.java:239)\n       at com.evernote.android.job.JobStorage.put(JobStorage.java:122)\n       at com.evernote.android.job.JobManager.schedule(JobManager.java:237)\n       at com.evernote.android.job.JobRequest.schedule(JobRequest.java:366)\n       at sk.henrichg.phoneprofilesplus.WifiScanJob.scheduleJob(WifiScanJob.java:109)\n       at sk.henrichg.phoneprofilesplus.PhoneProfilesService.onCreate(PhoneProfilesService.java:470)\n       at android.app.ActivityThread.handleCreateService(ActivityThread.java:2825)\n       at android.app.ActivityThread.access$1800(ActivityThread.java:156)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1434)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:211)\n       at android.app.ActivityThread.main(ActivityThread.java:5389)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at java.lang.reflect.Method.invoke(Method.java:372)\n       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1020)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:815)\nMy code:\nJobRequest.Builder jobBuilder;\njobBuilder = new JobRequest.Builder(JOB_TAG_SHORT);\njobBuilder.setExact(TimeUnit.SECONDS.toMillis(5));\njobBuilder.setPersisted(false)\n          .setUpdateCurrent(false)\n          .build()\n          .schedule();. 1.2.0 working with target sdk 25. But required is compile sdk 26. Working in my projects.. Not possible, I'm using setExact(). Also in onRunJob().. ",
    "aanandshekharroy": "Hey I am getting the exact same error. Running on API 19 without Google services. RAM 2 GB, ANdroid-Job version 1.2.5. ",
    "yanhuibin315": "maybe you could try to active to get the storage permission. ",
    "sandeshlasnapure": "There is no proper documentation . see if you can help.. Finally got the solution. thanks. ",
    "krasawa": "@sandeshlasnapure I understand it was long time ago, but maybe you remember how you solved this issue?. ",
    "long1eu": "Perfect, thanks!. ",
    "ibu2710": "Where to set this  JobConfig.setAllowSmallerIntervalsForMarshmallow(true);\nI am using 1.2.0 I am facing IllegalStateException\nPlease help me. Also @vRallev  you can make a exact method in periodic too.. Sure it i will help people like me... I want to set alarms at 9am and 6pm everyday. So i don't need to set start and end time... Please consider... @aminezghidi  I am trying to set the same time for start and end in daily job... Will it work? Please help me with this. ",
    "lsuski": "It works, thank you very much .\nBTW. You can add some info about it in FAQ to save yours and other devs time in future.. You can compile with 26 and has target = 25, it should work. It works. Thanks. ",
    "jagan999": "Thanks for the quick reply. I tried a sample program made available here https://github.com/rkpattanaik/AndroidJobDemo but it also did NOT work when the app was in the background or closed normally with a back button.\nDoes this DailyJob solve this issue? Will it work even when the app is normally closed and not in the foreground?. I had a specific query but closing this issue didn't help clarify. A few observations/comments on your last comment:\na. This sample code was NOT written by me. It was written by some blogger who advocated your library. :-)\nb. I incorporated DailyJob exactly as you had indicated in your answer above. I set it up to run between 10am and 4pm. It didn't fire the job anytime during this period. Deliberately, I exited my app normally (using the log off button in my app), so I suspect the same issue exists where the scheduled jobs ONLY fire if the app is in the foreground and NOT if the app goes to the background or is exited normally without a force close.\nI had a small piece of code to show the status of existing job requests by calling JobManager.getAllJobRequestsForTag and it indeed showed my job was scheduled but it never fired. \nDo you mind explaining why it didn't work when the app was exited?. ok thanks. I'll figure it out myself. I already mentioned the issue and I'm surprised you say my explanation is vague. Your DailyJob doesn't get triggered if the app is moved to the background. This is true with all job schedulers I've tried and yours is no exception. I thought you've addressed this issue somehow but looks like the issue persists. You can try the code yourself.. ok, let me send you my sample code in some time.... Attached is my simple test application for testing DailyJob. I don't see any notification even if the app is open. Am I doing anything wrong? I have also attached the logcat output. Don't see any errors either.\nsrc.zip\nlogcat.txt\n. Now here's an updated test application to test whether the periodic job works fine or not. As you see here in the log cat output, onRunJob was called twice and the corresponding notification was issued - once at 9:08 and again at 9:19 as long as my app was in the foreground. After 9:19, I relegated the app to the background by clicking the Home button on my Asus phone and using the phone app for calling. After this event, onRunJob has never been invoked and my notification has never been updated with a newer run. . This is exactly what I was complaining about earlier.\nsrc.zip\nlogcat.txt\n. Thanks for your reply. But I have a few unanswered questions:\na. Once my app goes into background, the scheduled job NEVER fires. It's not about whether the job frequency was too high or not. A similar code example where I tried the DailyJob also failed to fire even after 24 hours. It definitely has something to do with the Doze mode on Marshmallow. However...\nb. If the background job never runs when the app goes to the background on Doze mode, what's the point of having a background job? I might as well use AsyncTask or a regular JobScheduler/Service to run long running jobs in a background thread when the app is active. This is definitely not serving my purpose even if you argue it's working as expected\nBased on what I understand from Doze mode, there's no solution for getting my requirement fuflilled unless my app is in the foreground and kept active. ???. ",
    "MateuszMlodawski": "OK, looks like jobs are scheduled correctly and they work also on pre-Oreo devices (my mistake, sorry!).\nThe error above is still visible in logs. It would be great to get rid of it.. ",
    "sillysachin": "I am seeing this on Moto X Play with Android 7.1.1\nI/art: Rejecting re-init on previously-failed class java.lang.Class<android.support.v4.app.JobIntentService$JobServiceEngineImpl>: java.lang.NoClassDefFoundError: Failed resolution of: Landroid/app/job/JobServiceEngine;\nI/art:     at void com.evernote.android.job.JobRescheduleService.startService(android.content.Context) (JobRescheduleService.java:32)\nI/art:     at void com.evernote.android.job.JobManager.<init>(android.content.Context) (JobManager.java:159)\nI/art:     at com.evernote.android.job.JobManager com.evernote.android.job.JobManager.create(android.content.Context) (JobManager.java:112)\nI/art:     at void com.appbootup.ipo.news.data.Application.onCreate() (Application.java:133)\nI/art:     at void android.app.Instrumentation.callApplicationOnCreate(android.app.Application) (Instrumentation.java:1046)\nI/art:     at void android.app.ActivityThread.handleBindApplication(android.app.ActivityThread$AppBindData) (ActivityThread.java:5444)\nI/art:     at void android.app.ActivityThread.-wrap2(android.app.ActivityThread, android.app.ActivityThread$AppBindData) (ActivityThread.java:-1)\nI/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1558)\nI/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:102)\nI/art:     at void android.os.Looper.loop() (Looper.java:154)\nI/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6165)\nI/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\nI/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:888)\nI/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:778)\nI/art: Caused by: java.lang.ClassNotFoundException: Didn't find class \"android.app.job.JobServiceEngine\" on path: DexPathList[[zip file \"/data/app/com.appbootup.ipo.news.debug-2/base.apk\", zip file \"/data/app/com.appbootup.ipo.news.debug-2/split_lib_directories_apk.apk\"],nativeLibraryDirectories=[/data/app/com.appbootup.ipo.news.debug-2/lib/arm, /data/app/com.appbootup.ipo.news.debug-2/base.apk!/lib/armeabi-v7a, /data/app/com.appbootup.ipo.news.debug-2/split_lib_directories_apk.apk!/lib/armeabi-v7a, /system/lib, /vendor/lib]]\nI/art:     at java.lang.Class dalvik.system.BaseDexClassLoader.findClass(java.lang.String) (BaseDexClassLoader.java:56)\nI/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String, boolean) (ClassLoader.java:380)\nI/art:     at java.lang.Class java.lang.ClassLoader.loadClass(java.lang.String) (ClassLoader.java:312)\nI/art:     at void com.evernote.android.job.JobRescheduleService.startService(android.content.Context) (JobRescheduleService.java:32)\nI/art:     at void com.evernote.android.job.JobManager.<init>(android.content.Context) (JobManager.java:159)\nI/art:     at com.evernote.android.job.JobManager com.evernote.android.job.JobManager.create(android.content.Context) (JobManager.java:112)\nI/art:     at void com.appbootup.ipo.news.data.Application.onCreate() (Application.java:133)\nI/art:     at void android.app.Instrumentation.callApplicationOnCreate(android.app.Application) (Instrumentation.java:1046)\nI/art:     at void android.app.ActivityThread.handleBindApplication(android.app.ActivityThread$AppBindData) (ActivityThread.java:5444)\nI/art:     at void android.app.ActivityThread.-wrap2(android.app.ActivityThread, android.app.ActivityThread$AppBindData) (ActivityThread.java:-1)\nI/art:     at void android.app.ActivityThread$H.handleMessage(android.os.Message) (ActivityThread.java:1558)\nI/art:     at void android.os.Handler.dispatchMessage(android.os.Message) (Handler.java:102)\nI/art:     at void android.os.Looper.loop() (Looper.java:154)\nI/art:     at void android.app.ActivityThread.main(java.lang.String[]) (ActivityThread.java:6165)\nI/art:     at java.lang.Object java.lang.reflect.Method.invoke!(java.lang.Object, java.lang.Object[]) (Method.java:-2)\nI/art:     at void com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run() (ZygoteInit.java:888)\nI/art:     at void com.android.internal.os.ZygoteInit.main(java.lang.String[]) (ZygoteInit.java:778). ",
    "pranaysharma": "Same here. I am also seeing such errors.. ",
    "lordhong": "I'm seeing it on samsung galaxy S8\nCaused by: java.lang.ClassNotFoundException: Didn't find class \"android.app.job.JobServiceEngine\" on path: DexPathList[[zip file . ",
    "monowar1993": "Same error on Nexus 5 with Lineage OS 7.1.1. This custom ROM is based on AOSP ROM. \n\n. ",
    "ZimM-LostPolygon": "Same here, OnePlus 5, official Android 7.1.1.. ",
    "CoderickLamar": "Seeing this on an LG V410 with 7.1.1\nHappens intermittently, so unfortunately I don't have additional information to add. ",
    "DonKeyHot1": "Same error on Nexus 5 with Lineage OS 7.1.1. This custom ROM is based on AOSP ROM.\n+1\nv. 1.2.4. ",
    "shidobecker": "Same here on Nexus 5 Android 7.0 \nJobScheduler still works properly though\nV 1.2.4\nEdit: Only happens in debug build.. ",
    "adheus": "Same here on Moto G4 Plus - Android 7.0. ",
    "konstzv": "Same on Xiomi mi4c Android 8. ",
    "pedrodimoura": "Same on Samsung Galaxy A5 2016 (SM-A510M). I just changed my build.gradle minifyEnabled to false:\n...\nminifyEnabled false\nuseProguard true\n...\nAfter that, this issue is not showing up.\nI did not figure out what the hell was going on.. Hi, @ebnrdwan !\nYou can't call setExecutionWindown on a periodic job.\nIf you want to schedule a periodic job, just set a time interval in milliseconds on setPeriodic method.\nFor example, I have a job that execute every 15 minutes and 5 minutes flex time interval, check it out:\nJobRequest.Builder(JobServiceSync.TAG).setPeriodic(TimeUnit.MINUTES.toMillis(15), TimeUnit.MINUTES.toMillis(5)).build();\nAnd remember, when you use setPeriodic to schedule a job, the min. time interval is 15 minutes.\nThis is a AlarmManager limitation.. > @pedrodimoura thanks for helping out.\n\nfeature not supported yet, hope to be supported soon\n\nAnytime, @ebnrdwan  :D. > Is it possible to schedule a periodic job every 2 hours but run immediately for the first time?\n@mikelibg I think a Periodic Job runs at the moment you schedule for the first time and, then, after 2 hours.\nBut, I am not sure.. ",
    "djrsousa": "+1 Moto G 2014 (Android 7.1.2). ",
    "SrikantKarnani": "Anyone here giving solution or everyone going to say same here...Same Here in Nextbit Robin. ",
    "BramscoChill": "same on galaxy s6 (SM-G930F) Android 7.0. ",
    "micer": "same on Huawei P10 (WAS-LX1) , Android 7.0. ",
    "phileo": "It sounds like it could be a V4 support library issue with trying to call a new API (API 27) on  older devices (ie. Android 7.x). \nI have filed ticket with Google's Issue Tracking system.  \nPlease follow this link and star the issue, hopefully that will give it enough attention for Google to expedite a fix.. Try the suggestions within this SO post to see if it  resolves your issue:\nhttps://stackoverflow.com/questions/46161930/scheduled-job-executes-multiple-time-in-evernote-androidjob/46163527#46163527. ",
    "BackEndCode": "Please  Give me the information about it.\nThanks. ",
    "dshatz": "\nNo, this is not a problem of batching alarms.\n\nThen why is the job rescheduled to before the desired time? The official documentation of AlarmManager`s set method you referenced in issue 248 says that:\n\nBeginning in API 19, the trigger time passed to this method is treated as inexact: the alarm will not be delivered before this time, but may be deferred and delivered some time later.\n\nPlease give an explanation, or a link where it can be found. Thanks.. Thanks for the fix! And sorry for the duplicate :) @vRallev . ",
    "harrynull": "It is confusing. I have encountered the similar problem that my job gets cancelled when the app is forced killed. I was wondering what I did wrong because I saw your FAQ claim that it would reliably.\nBTW, what is the recommended way to run regular jobs even if the app gets killed? or is it just impossible in Android?. ",
    "derekpitts": "My question is in regards to the \"pending alarms\" that are cleared. I assumed this included periodic alarms that have been scheduled but I want to be sure. Is it true that periodic alarms that are scheduled are also cleared when the app is killed? It would be great if they are not killed.\nFrom the FAQs:\n\nAfter the app was force killed (or swiped away from the recent list on some devices) Android clears all pending alarms from the AlarmManager for this app. This is problematic, because until the app is being relaunched alarms can't be rescheduled and jobs won't run. Unfortunately, there is no known workaround.. \n",
    "aminezghidi": "Thanks, I asked because it worked and didn't crash for me.. Yes! So in the library logic a DailyJob cannot be exact event if I don't set the exact flag from the JobRequest builder and it should always be built with a time window bigger than 15 mins right?. Yes, thanks @vRallev! I'm closing this.. ",
    "allowthere": "My problem is that create is never called.. ",
    "jihadnaji": "@allowthere set the name of the class App as a value to attribute (name) to application tag in the manifest file.. ",
    "thisismohitgupta": "I am using config multiDexEnabled true in gradle file, I was able to reproduce it in the Emulator too. I think it boils down to android studio not being able to Refference android.support.v4.app.jobintentservice in JobRescheduleService.java. compilesdk = 25\nThis might be the issue, any fix for this? \n@DvTonder I was able to reproduce it inside emulator too and other android devices too not just rooted devices . I really want the DailyJob helper class implementation but it might not be the right time for switching to 26 for my app. Can this be done on api 25? . @Merka84 I have been using  v1.1.12 on Oreo without any known troubles. As suggested by @vRallev there is a helper class DailyJob in v1.2 which I copied over and used. works fine for my use case.  . @Merka84 most probably yes. compile 'com.evernote:android-job:1.2.0-RC4'. java\nDailyJob.schedule(builder, TimeUnit.HOURS.toMillis(23), TimeUnit.HOURS.toMillis(6));\nSince\njava\nstartMs = TimeUnit.HOURS.toMillis(23) // outputs 8280000\nendMs = TimeUnit.HOURS.toMillis(6) // outputs 2160000\nso on the first run\njava\n        if (startMs > endMs) {\n            // e.g. when job should run between 10pm and 2am\n            endMs += TimeUnit.DAYS.toMillis(1); // 2160000 + 86400000 = 88560000\n        }\n        long endDelay = startDelay + (endMs - startMs);\n        PersistableBundleCompat extras = new PersistableBundleCompat();\n        extras.putLong(EXTRA_START_MS, startMs);\n        extras.putLong(EXTRA_END_MS, endMs);\nthen on the next run\njava\n// 88560000(endMs) > 86400000(DAY)\nif (startMs >= DAY || endMs >= DAY || startMs < 0 || endMs < 0) {\n            throw new IllegalArgumentException(\"startMs or endMs should be less than one day (in milliseconds)\");\n        }\ncould this be an issue? I haven't yet debugged  this file, just an idea\n. java\n        Long tempEnd = endMs;\n        if (startMs > endMs) {\n            // e.g. when job should run between 10pm and 2am\n            tempEnd += TimeUnit.DAYS.toMillis(1);\n        }\n        long endDelay = startDelay + (tempEnd - startMs);\nI think this should solve the problem ?. Change\n```java\n    if (startMs > endMs) {\n        // e.g. when job should run between 10pm and 2am\n       endMs  += TimeUnit.DAYS.toMillis(1);\n    }\n    long endDelay = startDelay + (endMs - startMs);\n\nTo this in DailyJob.java in libjava\n    Long tempEnd = endMs;\n    if (startMs > endMs) {\n        // e.g. when job should run between 10pm and 2am\n        tempEnd += TimeUnit.DAYS.toMillis(1);\n    }\n    long endDelay = startDelay + (tempEnd - startMs);\n\n```\nThis worked for me, I hope it does for you too. @anukools I think this depends on the OS and there are many other factors involved. I think you should look into firebase cloud messaging for notifications its more robust . ",
    "Merka84": "Hi\nIs it possible to use v1.2.0 of library without using support-v4:26.+ ?\nI ask because I get the error message posted in this issue when I exclude support-v4 from library in gradle.. Does using v1.1.11 cause any problem on android 8? I use it for running some periodic jobs which runs every x hours or x days.. @thisismohitgupta \nThanks for your comment.\nDo you use it for running any periodic job , similar to mine?. @thisismohitgupta\nWould you please tell me how to copy and use DailyJob in my code? . ",
    "SahilMunjal": "@thisismohitgupta & @vRallev I tried using DailyJob Helper class with v1.1.12 but It is giving various issues like \n\n'isTransient()' is not public in 'com.evernote.android.job.JobRequest'. Cannot be accessed from outside package\nCannot resolve symbol 'JobConfig'\nCannot reslove method addExtras\n'getRequest()' is not public in 'com.evernote.android.job.Job.Params'. Cannot be accessed from outside package\nCannot resolve method 'createBuilder'. @thisismohitgupta can you tell me how are you using DailyJob Helper class with lower version of library.. \n",
    "mumia7575": "Hi, I am having the same type of problem in Android 4.4.2. Logcat in errors tab:\n09-23 15:59:42.075 2066-2066/com.mycompany.myapp E/dalvikvm: Could not find class 'com.evernote.android.job.v21.PlatformJobService', referenced from method com.evernote.android.job.JobApi.isSupported\n09-23 15:59:42.075 2066-2066/com.mycompany.myapp E/dalvikvm: Could not find class 'com.evernote.android.job.v21.PlatformJobService', referenced from method com.evernote.android.job.JobApi.isSupported\n09-23 15:59:42.075 2066-2066/com.mycompany.myapp E/dalvikvm: Could not find class 'com.evernote.android.job.v21.PlatformJobService', referenced from method com.evernote.android.job.JobApi.isSupported\nThere isn't much science to replicate those errors simply test it in the android emulator API 19, with a scheduled job.. This bug is occurring in several Huawei phones in my app. Previous to this I used the version 1.1.11 with the following schedule option and no bug was occurring:\npublic static void scheduleJob() {\n         new JobRequest.Builder(NotificationSyncJob.TAG)\n                .setPeriodic(TimeUnit.MINUTES.toMillis(60), TimeUnit.MINUTES.toMillis(5))\n                .setUpdateCurrent(true)\n                .setPersisted(true)\n                 .build()\n                 .schedule();\n     }\n. It might be that, but I changed some of the options as well, maybe that caused the crash. I will test with different options, I might find which option is causing the crash. \nLuckily a close family member have an Huawei P9 which is one of the phones that are in the logs.. It seems this is not a bug in the phone model/brand, same behavior occurring in several Samsung devices (S6, S7 Edge, etc...) as well, although every phone have the same version Android 7.0 (API 24). Same log, same code.. Hi, I got one ANR error log from Android 6.0 (Huawei P8 Lite), it seems it's not only a Android 7.0 problem or at least is a different bug.\nI could not reproduce this on my brother's Huawei P9 but I am getting new crashes every day with identical logs. However after replacing the previous code:\npublic static void scheduleJob() {\n        new JobRequest.Builder(NotificationSyncJob.TAG)\n                .setPeriodic(TimeUnit.MINUTES.toMillis(30))\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n                .setUpdateCurrent(**false**)\n                .build()\n                .schedule();\n    }\nWith this:\npublic static void scheduleJob() {\n        new JobRequest.Builder(NotificationSyncJob.TAG)\n                .setPeriodic(TimeUnit.MINUTES.toMillis(30))\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n                .setUpdateCurrent(**true**)\n                .build()\n                .schedule();\n    }\nI get a different exception (Important note: This is not a crash but a annoying ANR warning)\nat android.database.sqlite.SQLiteConnection.nativeExecuteForChangedRowCount (Native method)\n  at android.database.sqlite.SQLiteConnection.executeForChangedRowCount (SQLiteConnection.java:742)\n  at android.database.sqlite.SQLiteSession.executeForChangedRowCount (SQLiteSession.java:754)\n  at android.database.sqlite.SQLiteStatement.executeUpdateDelete (SQLiteStatement.java:64)\n  at android.database.sqlite.SQLiteDatabase.delete (SQLiteDatabase.java:1543)\n  at com.evernote.android.job.JobStorage.remove (JobStorage.java:218)\n- locked <0x0bdefc52> (a com.evernote.android.job.JobStorage)\n  at com.evernote.android.job.JobStorage.remove (JobStorage.java:210)\n- locked <0x0bdefc52> (a com.evernote.android.job.JobStorage)\n  at com.evernote.android.job.JobManager.cancelInner (JobManager.java:380)\n  at com.evernote.android.job.JobManager.cancelAllInner (JobManager.java:403)\n- locked <0x083e9b23> (a com.evernote.android.job.JobManager)\n  at com.evernote.android.job.JobManager.cancelAllForTag (JobManager.java:373)\n  at com.evernote.android.job.JobManager.schedule (JobManager.java:181)\n  at com.evernote.android.job.JobRequest.schedule (JobRequest.java:408)\n  at pt.mycompany.myapplication.jobs.NotificationSyncJob.scheduleJob (NotificationSyncJob.java:153)\n  at pt.mycompany.myapplication.classes.ApplicationClass.onCreate (ApplicationClass.java:29)\n  at android.app.Instrumentation.callApplicationOnCreate (Instrumentation.java:1015)\n  at android.app.ActivityThread.handleBindApplication (ActivityThread.java:4793)\n  at android.app.ActivityThread.access$1600 (ActivityThread.java:165)\n  at android.app.ActivityThread$H.handleMessage (ActivityThread.java:1437)\n  at android.os.Handler.dispatchMessage (Handler.java:102)\n  at android.os.Looper.loop (Looper.java:150)\n  at android.app.ActivityThread.main (ActivityThread.java:5621)\n  at java.lang.reflect.Method.invoke! (Native method)\n  at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run (ZygoteInit.java:794)\n  at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:684)\nI guess I will downgrade to 1.1.11 until you guys figure out what is happening, it seems stable (even if was not doing a wished behavior).\n. Hi @vRallev, sorry for being such an annoying person, but I have a \"feeling\" that most of these errors might have to do with permissions post Android 6.0 (API 23). Asking for permissions in run-time (post 6.0) would not fix issues like this one? Or change the evernot_jobs.db path.\n(https://developer.android.com/training/permissions/requesting.html) \nIn which path evernote_jobs.db is stored?\nI would advise the OP to test it by enabling the app storage permissions.. ",
    "arjankc": "hello, any update on this issue? We seem to be facing similar problems here..\n\n. ",
    "basithnewscorp": "Got any solution for this, we are facing issue with Samsung devices. ",
    "DilipMani": "We are facing the same issue with Samsung Galaxy S8 (android version 7.0) multiple times for the same user.. got any solution for this ?. ",
    "iamrocklobster": "compile 'com.evernote:android-job:1.1.11'\nAlso, the device where I'm testing is an SM-G925P (Samsung Galaxy S6 Edge) with Android 7.0.. So, I had a deeper look at this and it seems that it is indeed an limitation of the setExactAndAllowWhileIdle method, which is what seems to be user by your library for exact jobs with SDK > 23.\n\nTo reduce abuse, there are restrictions on how frequently these alarms will go off for a particular application. Under normal system operation, it will not dispatch these alarms more than about every minute (at which point every such pending alarm is dispatched); when in low-power idle modes this duration may be significantly longer, such as 15 minutes.\n\nSo, when I reduced the frequency that I was scheduling this job the delay disappeared.\nThank you for the information regarding the AlarmManager restrictions.. ",
    "anukools": "Here is the Class that I have created extending DailyJob.\n`public class DailySyncJob extends DailyJob {\npublic static final String TAG = \"DailySyncJob\";\n\npublic static void schedule() {\n    if (!JobManager.instance().getAllJobRequestsForTag(TAG).isEmpty()) {\n        // job already scheduled, nothing to do\n      return;\n    }\n\n\n    JobRequest.Builder builder = new JobRequest.Builder(TAG);\n\n    // run job between 1pm and 2pm\n    DailyJob.schedule(builder, TimeUnit.HOURS.toMillis(13), TimeUnit.HOURS.toMillis(14));\n}\n\n@NonNull\n@Override\nprotected DailyJobResult onRunDailyJob(Job.Params params) {\n    // do something\n\n    PendingIntent pi = PendingIntent.getActivity(getContext(), 0,\n            new Intent(getContext(), MainActivity.class), 0);\n\n    Notification notification = new NotificationCompat.Builder(getContext())\n            .setContentTitle(\"Android DailyJob Sample\")\n            .setContentText(\"Notification from Android Job Sample App.\")\n            .setAutoCancel(true)\n            .setContentIntent(pi)\n            .setSmallIcon(R.mipmap.ic_launcher)\n            .setShowWhen(true)\n            .setColor(Color.RED)\n            .setLocalOnly(true)\n            .build();\n\n    NotificationManagerCompat.from(getContext())\n            .notify(new Random().nextInt(), notification);\n\n    return DailyJobResult.SUCCESS;\n}\n\n}`\nI am calling it from MainActivity.class by..\nDailySyncJob.schedule();\n. thanks @thisismohitgupta  will try this. Also is it possible to give exact time for job scheduling or less span of time like between 2:00pm to 2:05pm (Hours and minutes both) as I wanted notification should reach to all the user at somewhat similar time.. @thisismohitgupta  my notification are in-app notification like reminders that should be shown offline also. So I thought Is there any workaround to give minimum interval in start/end time.. ",
    "piisku78": "I think the job is scheduled correctly at 11-12. \nThe Logs are bit misleading, they don't actually tell the moment of execution like I supposed. They tell the delay from this moment. . ",
    "Danm72": "I'm still a little confused by the behaviour here. \nIf I schedule a job to run between 11 and 12 like so:\nDailyJob.schedule(builder, TimeUnit.HOURS.toMillis(11), TimeUnit.HOURS.toMillis(12))\nI get this log: \nSchedule one-off jobInfo success, request{id=72, tag=morning_job, transient=false}, start 23:30:09, end 00:30:09 (+1 day) (from now), reschedule count 0\n-- current time is 11:30 so that explains the minutes/seconds\nI think the TimeUnit.HOURS.toMillis(11) which is used in the docs and sample code is returning a different value than we are expecting.. I would have expected TimeUnit.HOURS.toMillis(11) to be 11:00 not 23:00. \nIs it saying currentTime+11 hours, or is it saying run at 11:00?\nThe javadocs seem to indicate that you're giving it a time to run at, not currenttime + startMs\nDoes this API tell it what time to start at, or how many hours from now to start?\n(Cheers for the work btw, the lib is great.). Okay, so the docs probably need to actually say that.\n\nhttps://evernote.github.io/android-job/javadoc/com/evernote/android/job/DailyJob.html\n // schedule between 1am and 6am\n DailyJob.schedule(builder, TimeUnit.HOURS.toMillis(1), TimeUnit.HOURS.toMillis(6));\n\nThis actually means, schedule between 1 -6 hours from now? The references to AM are incorrect?\nSo if i want a job to run at say 11:00 every day, I need to generate the offset between current time and 11:00 is that correct?. Well, the missing piece in the documentation is the fact that its time from now, and not time as per 24 hour clock.\nSo if i set it to run at 12:00, will it execute at that time every day or will the offset be recalculated every day?. ",
    "pks90": "@Danm72 , I second to what you just said. I was also confused about this until I stumbled upon this thread.. How does this answers the question ? I am aware that the new method is there in place but what about the error which I am getting  ?. I did call this method only and am talking about the following message that comes in the logs i.e.\nflexMs is out of range of [30000, 60000] (too high) android job\n. So the code above is expected to run the jobs in the required intervals and nothing else is required from my side isn't it ? Additionally what can I log so as to understand why this didn't work ?. As long as doze was up it was fine for me , its just that once the calls to onJobRun stopped in doze  they never resumed even when I was actively using the app. That is more strange.. I am using the latest version with WorkManager as engine but as suggested , I can use both the libraries in parallel i.e. both the dependencies ...1.2 & 1.3.__ ... of evernote-job to be put in the gradle right ?. So , you mean the following ,\ndependencies {\n    implementation \"android.arch.work:work-runtime:$work_version\"\n    implementation 'com.evernote:android-job:1.2.6'\n}\ni.e. android work dependency and evernote's old job dependency ?\n. Looks like I was already doing the same i.e. \nimplementation 'com.evernote:android-job:1.3.0-alpha06'\n    implementation \"android.arch.work:work-runtime:1.0.0-alpha05\". ",
    "pforhan": "it's not that it's hard to import with gradle, it's more an issue when we build our sdk; we have an explicit list of dependencies we compare against so we know when a new one shows up, to guard against accidentally including something new & large.. I wouldn't recommend copying anything, just add a simple interface that you implement in another module that is implemented via the cat library.\ntrying to find a current example.  An earlier release of retrofit had something like this: https://github.com/square/retrofit/blob/parent-1.9.0/retrofit/src/main/java/retrofit/RestAdapter.java#L112 :\n```\n  / Simple logging abstraction for debug messages. */\n  public interface Log {\n    / Log a debug message to the appropriate console. */\n    void log(String message);\n/** A {@link Log} implementation which does not log anything. */\nLog NONE = new Log() {\n  @Override public void log(String message) {\n  }\n};\n\n}\n```\nIn master it looks like they've dropped logging altogether, still looking through other libraries.. Basically, it's that a library shouldn't dictate structure / dependencies to consumers.  If every library picks its own logging framework then all of a sudden my app has 20 of them, none of them used by my own code.\nLogging is not necessarily bad, but it is pretty optional -- a simple interface and a vrallev-logging module would both keep the current functionality and provide options for those who either want no logging or want the logging tied into their own logger.. ",
    "MethDamon": "Thanks. One more question, the job does not seem to run automatically when the phone connects. Is this something I cannot achieve in general with JobScheduler or the other APIs. Do I need a SyncAdapter for this?. Ok, thanks. ",
    "hasansidd": "Thanks works great. Had to take out the setRequiredNetworkType(), but I believe that's expected for startNow().. Using the application class worked. ",
    "pyricau": "Thanks! I passed it on to the team that's been testing android-job.. ",
    "knickknacking": "Thanks, @vRallev (a member of the team @pyricau mentinoned here) \u2013\u00a0the update fixed the leak in the mFinishedJobsCache. Appreciate it!. ",
    "shailesh-mota": "OK. Thanks for the information.. ",
    "pec0ra": "You should look at the example evernote provides here.\nIn the schedule method, they explicitly don't start a new DailyJob if it was already scheduled:\nif (!JobManager.instance().getAllJobRequestsForTag(TAG).isEmpty()) {\n            // job already scheduled, nothing to do\n            return;\n        }\n. ",
    "ControlAdad": "@vRallev  What should one do to make sure a job runs at about every 60 minutes, for ever? I tried \"android-job\" but it stops working after a while, maybe after a day...\nI used both setPeriodic and setExact. And how does Android OS define \"abuse\"? A simple task (update a text in a widget) in every 15 minutes is abuse or not?. ",
    "MatheusDinni": "Sorry for the late comment. Thanks for the answer @vRallev, i'll keep doing that way than.\nI'm struggling at this \"power saving modes\" of Android OS for a while, but it's hard to fight with.\nOne last thing. The periodic job has an variable delay to fire, right? There's a way to reduce this delay, or Android OS take full responsability on that? Thanks again for the attention.  . I'm having the same issue. I can set exact or periodic job and with app on background it runs fine, but when i close the app the jobs do not run, never. When i start the app all jobs play at the same time.\nI'm using a Xiaomi Redmi 2 with Android 4.4.4 (kitkat). ",
    "jmineraud": "I have been able to get rid of the issue by disabling Instant Run on Android Studio. May it help someone else. As far as I could see, it is because of the reflection used when checking\nif the class com.evernote.android.job.gcm.PlatformGcmService exists. I\nbelieve that the hot swap does not handle reflection well. This did not\nused to be a problem prior Android 3.0. Disabling Instant Run has limited\noverhead in my case so I did not spend much time to find an alternative to\nkeep Instant Run. If you do please share it here.\n2017-11-12 19:59 GMT+02:00 GARCIA Cl\u00e9ment notifications@github.com:\n\nI just got exactly the same issue and disabling Instant Run is fixing the\nissue too. Don't know how it is related.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/312#issuecomment-343754957,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AGf5ISWPuA6Iu6x-RdoT4Y5bXHEr0lmXks5s1zITgaJpZM4QNAOg\n.\n. \n",
    "HappyDr0id": "I just got exactly the same issue and disabling Instant Run is fixing the issue too. Don't know how it is related.. ",
    "gitkobold": "It's not possible to set. That's I'm writing..\nIt is a limitation in the code.... Hi!\nThat would be great,thanks!\nIf i'm right isRequirementNetworkTypeMet is not good because if there isn't net it would never run again. There isn't reshedule in dailyjob.. It should be if net is required but no net during running . ",
    "Paul75": "for Gragle question I don't think so.\nI not include that 'compile 'com.evernote:android-job:1.2.0'' because when try to search it failed to found. I take the .aar file and add to library folder ....\nThanks. the error of download library is I use proxy on works but at home none I desactive proxy and download it.\nI have proguard and add lines.\nNow not failed and not crash but not do the action on : \n`public static void schedule() {\n        // schedule between 19 and 20\n        /DailyJob.schedule(\n                new JobRequest.Builder(TAG),\n                TimeUnit.HOURS.toMillis(19),\n                TimeUnit.HOURS.toMillis(20)\n        );/\n    DailyJob.schedule(\n            new JobRequest.Builder(TAG),\n            TimeUnit.HOURS.toMillis(1),\n            TimeUnit.HOURS.toMillis(2)\n    );\n}\n\n@NonNull\n@Override\nprotected DailyJobResult onRunDailyJob(Params params) {\n    Log.i(TAG, \"onRunDailyJob\");\n\n    return DailyJobResult.SUCCESS;\n}`. And for my after problem now I include by gradle.\n\nBut If I implement DailyJob it nothing do : Log.i(TAG, \"onRunDailyJob\");\n. @vRallev and what I can start immediatly ?. it strange because in android Studio the method schedule on MyDailyJob tell me that is not used .... No ...\nI can do it in application file ? Not in activity. Because I want the job works in background all time and do action....\n\u2063Envoy\u00e9 par TypeApp \u200b\nLe 27 nov. 2017 \u00e0 08:57, \u00e0 08:57, PYPL notifications@github.com a \u00e9crit:\n\nhave you added MyDailyJob.schedule() somewhere in your app ? \n-- \nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/evernote/android-job/issues/324#issuecomment-347104324\n. Hello,\n\nIf I wrote this : \nDailyJob.schedule(builder, TimeUnit.HOURS.toMillis(20), TimeUnit.HOURS.toMillis(9));\nit in console tell : \nD/JobProxy24: Schedule one-off jobInfo success, request{id=3, tag=MyDailyJob, transient=false}, **start 09:02:50, end 22:02:50** (from now), reschedule count 0\n=> execute between 9 and 20 ?\nand if i do : DailyJob.schedule(builder, TimeUnit.HOURS.toMillis(9), TimeUnit.HOURS.toMillis(20)); \nit say : \nD/JobProxy24: Schedule one-off jobInfo success, request{id=2, tag=MyDailyJob, transient=false}, **start 22:04:12, end 09:04:12 (+1 day)** (from now), reschedule count 0\n=> execute 22 and 09 ?\n????\nThanks. Okay that seams works but it send me in 01:01:07 hours but for me I must send only at 07pm to 08pm ? When I can do ?. That mean I can't do action exactly on 7pm o clock ? and repeat it all days ?. @iNoles : you mean that between one time to another okay but for me when I do DailyJob.schedule(builder, TimeUnit.HOURS.toMillis(9), TimeUnit.HOURS.toMillis(20)); it say execute : D/JobProxy24: Schedule one-off jobInfo success, request{id=2, tag=MyDailyJob, transient=false}, start 22:04:12, end 09:04:12 (+1 day) (from now), reschedule count 0\nOr for me i want it execute in between 9' and 20' in this exemple (in reality I want to start between 19' and 20' ....\nThanks. ",
    "nigelbro": "Yes you are correct it doesn't crash my application however it does effect the library i use . If you notice in the stacktrace  the cloudinary  library is what utilizes your library . I did and I linked this issue in it also. ",
    "XabierGoros": "@Paul75 in version 1.2.1 the method startNowOnce was added and you're able to start a DailyJob at the very moment you want.\n. Same here while adding the WorkManager library. I got the crash both for 7.0 and 5.1.1 Android versions.. I didn't even try alpha03 since it's changelog has nothing to do with this issue, but here you have one from alpha02 which should be useful for that:\nFatal Exception: java.lang.RuntimeException: An error occurred while executing doInBackground()\n       at android.os.AsyncTask$3.done(AsyncTask.java:330)\n       at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:354)\n       at java.util.concurrent.FutureTask.setException(FutureTask.java:223)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:242)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n       at java.lang.Thread.run(Thread.java:776)\nCaused by java.lang.IllegalStateException: Cannot invoke removeObserver on a background thread\n       at android.arch.lifecycle.LiveData.assertMainThread(SourceFile:435)\n       at android.arch.lifecycle.LiveData.removeObserver(SourceFile:217)\n       at android.arch.lifecycle.MediatorLiveData$Source.unplug(SourceFile:145)\n       at android.arch.lifecycle.MediatorLiveData.onInactive(SourceFile:126)\n       at android.arch.lifecycle.LiveData$ObserverWrapper.shouldBeActive(SourceFile:413)\n       at android.arch.lifecycle.LiveData.observeForever(SourceFile:207)\n       at com.evernote.android.job.work.JobProxyWorkManager.getWorkStatusBlocking(SourceFile:150)\n       at com.evernote.android.job.work.JobProxyWorkManager.isPlatformJobScheduled(SourceFile:91)\n       at com.evernote.android.job.JobRescheduleService.rescheduleJobs(SourceFile:112)\n       at com.evernote.android.job.JobRescheduleService.onHandleWork(SourceFile:87)\n       at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(SourceFile:391)\n       at android.support.v4.app.JobIntentService$CommandProcessor.doInBackground(SourceFile:382)\n       at android.os.AsyncTask$2.call(AsyncTask.java:316)\n       at java.util.concurrent.FutureTask.run(FutureTask.java:237)\n       at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n       at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n       at java.lang.Thread.run(Thread.java:776). This issue was posted in #464 and solved in 1.3.0-alpha02 apparently. However I can assure it persist on 1.3.0-alpha02 and according to you in 1.3.0-alpha03 too.. ",
    "fjr619": "same issue here,\nEmulator with Pixel Android 8.0.0, when app in background, the job is working fine, until i force close the app from recent app, and the periodic job did nothing. But when I reopen my app, it will work again\n```\n        Set jobRequests = JobManager.instance().getAllJobRequestsForTag(LocationTrackerJob.TAG);\n    if (!jobRequests.isEmpty()) {\n        jobRequests.iterator().next().getJobId();\n    } else {\n        new JobRequest.Builder(LocationTrackerJob.TAG)\n                .setPeriodic(JobRequest.MIN_INTERVAL, JobRequest.MIN_FLEX)\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n                .build()\n                .schedule();\n    }\n\n```\napp in background : \n11-17 07:07:38.841 9940-32157/id.co.cicil.staging I/JobExecutor: Executing request{id=1, tag=location_tracker_job, transient=false}, context PlatformJobService\n11-17 07:07:38.859 9940-32158/id.co.cicil.staging I/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=true, class=LocationTrackerJob, tag=location_tracker_job}\nafter 15 minutes ++, i didn't receive any log from the job\nthen I reopen my app, then i got the log immediately\n11-17 07:26:18.001 14870-15082/id.co.cicil.staging I/JobExecutor: Executing request{id=1, tag=location_tracker_job, transient=false}, context PlatformJobService\n11-17 07:26:18.026 14870-15083/id.co.cicil.staging I/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=true, class=LocationTrackerJob, tag=location_tracker_job}. ",
    "anudeepreddygopu": "I am facing the same issue. . ",
    "Sorbh": "what if I create the job with separate tags??\nI need separate Jobs as both are completely independent of each other.\nIs there any way we can execute jobs irrespective of other running jobs??. yes, they should. By parallel I mean they should run irrespective of each other. But they are running in sequence. . so what do you suggest?? should I use Exact Job?. ",
    "devlee-team": "\nThat's a bug in the support library, see #255\n\nCan you explain how this issue (Neither user 10101 nor current process has android.permission.WAKE_LOCK) is related to #255 ?. ",
    "DenisMakovskyi": "use getContext() method.. ",
    "rocker19943": "have you added MyDailyJob.schedule() somewhere in your app ? \n. @Paul75 Does not matter if you will execute MyDailyJob.schedule() from the application or an activity. In any case your scheduled job will start in background. You just must add this part (that contains if statement) to your schedule method to avoid scheduling same job all time when your application starts.\n```\npublic static void schedule() {\n    if (!JobManager.instance().getAllJobRequestsForTag(TAG).isEmpty()) {\n        // job already scheduled, nothing to do\n        return;\n    }\nJobRequest.Builder builder = new JobRequest.Builder(TAG).setRequiredNetworkType(JobRequest.NetworkType.UNMETERED);\n\n// run job between 11pm and 6am\nDailyJob.schedule(builder, TimeUnit.HOURS.toMillis(23), TimeUnit.HOURS.toMillis(6));\n\n}\n```\n. ",
    "alwaystest": "Since Google Play Console Reports Excessive WakeLock issue, maybe we should decrease the count of unnecessary WakeLock.\nJust add a simple method in Device.java\npublic static boolean isVersionLollipopOrHigher() {\n        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP;\n    }\nAnd check it before acquire WakeLock.. @vRallev Looks like JobScheduler also acquires a wake lock.\nPlease look at comments of JobService.jobFinished, it says \nWhen the system receives this message it will release the wakelock being held.. ",
    "touchchandra": "Issue resolved finally after Cleaning the project. Thanks. . ",
    "mik-dass": "Ok no problem. Thanks for your time.. @rpattabi Yes it is possible, had that on my mind, but I am looking for a simpler approach. \nThanks :). ",
    "mat-dr": "Actually I tried to build the library without the play services, by using this stub library as compile dependency instead of the play services.\nIf I'm not wrong it should work as the original version even when the play services are used/present at runtime.. Ok. Thanks for your time.. ",
    "shobhik": "Ah, thanks for the follow-up. Using Stetho, I see a single row in the jobs table, showing my single scheduled periodic job. \n\nSo it seems to run, but then the notifications seem to spaz out. I'll look more into that angle and update this thread if I find something.... ",
    "faizwaghoo": "\nThe library is using the AlarmManager under the hood for exact jobs\n\nIs this true for DailyJob as well? Because I tried the code below in an attempt to test it but it didn't work either.\njava\n//Execute between 1 PM and 2 PM\nDailyJob.schedule(new JobRequest.Builder(TAG), TimeUnit.HOURS.toMillis(13), TimeUnit.HOURS.toMillis(14));\nAlso if I can't possibly have exacts job then is there a workaround that I can use that will provide me a similar kind of functionality?\nP.S. I'll be on a holiday for the next 2 days so please do not close this if I don't reply. :). Okay so since I am testing on an Android 6 device, it should be using JobScheduler so my job shouldn't be getting cleared even if I swipe away my app. So why is my job not executing then? Am I doing anything wrong?. I did extensive testing and used the above command and I can see that my job is scheduled\n\n[ComponentInfo{com.package.name/com.evernote.android.job.v21.PlatformJobService},jId=53,u0,R=(17:57:03,18:57:03),N=0,C=false,I=false,F=0,P=true,ANI=true]\n\nBut when I check my fragment after the time period has elapsed I see no change in the button status indicating the job was never executed hence not setting my flag.. Following is my onRunDailyJob() method:\njava\n@NonNull\n@Override\nprotected DailyJobResult onRunDailyJob(@NonNull Params params) {\n    // run your job here\n    mCtx = getContext();\n    PermanentLoggerUtil.logMessage(mCtx, \"onRunDailyJob, jobId: \" + params.getId());\n    SharedPreferences sharedPrefs = mCtx.getSharedPreferences(Constants.CONFIG_VARS, Context.MODE_PRIVATE);\n    SharedPreferences.Editor editor = sharedPrefs.edit();\n    editor.putInt(Constants.KEY_BUTTON_STATE, 2);\n    editor.apply();\n    mCtx.stopService(new Intent(mCtx, LocationUpdateService.class));\n    PermanentLoggerUtil.logStatus(mCtx);\n    return DailyJobResult.SUCCESS;\n}\nAs you can see there's not much in the method except for setting a flag, stopping a service and some loggers for debugging purposes. So it's highly unlike there's a bug because the method itself isn't getting executed in the first place.\n  . Tested on OnePlus 2 running 6.0.1. Same result - time elapsed but job didn't execute. :(. I've created a demo app here: https://github.com/faizwaghoo/JobSchedulerTest\nIt's a very basic app that contains 2 buttons out of which only 1 will be set based on the flag. Pressing 1st  button will set it and unset 2nd and my job will be scheduled. When the job executes it is supposed unset the flag for Button 1 so that when the user will open the app after the scheduled time it will see that Button 1 unset and Button 2 set.. Thanks for testing it. What was the bug that you had to fix?\nEdit:\nAlso I am noticing this warning being thrown:\n\nW/JobManager: you haven't registered a JobCreator with addJobCreator(), it's likely that your job never will be executed\n\nBut as you can see in my Application class I have registered it -\njava\nJobManager.create(this).addJobCreator(new EmployeeAttendanceJobCreator());\nIs there anything I am missing out?. Yeah I missed that out in the demo app. Added it in the manifest and stopped getting the warning.\nBut I think I figured out the actual problem. I misunderstood reading R=(13:46:34,14:46:34) parameter in the scheduled jobs list. I thought it indicates the time at which my job is to be run but in fact it shows the time remaining. I was actually gonna ask you to explain me the usage of TimeUnit.HOURS.toMillis() method because I wasn't seeing the expected times after I've scheduled the job and then it clicked me.\nSo let me test this in my main app and I'll let you know.. Did a complete testing and it was indeed the problem(lack of). I completely misunderstood the timings. I am so sorry for troubling you on this and thank you very much for taking your time out to help me with the problem. Closing this issue now. Thanks once again.. ",
    "alexkazakov": "Also sometimes app crashed with another kind of sqlite related error:\nandroid.database.sqlite.SQLiteDatabaseLockedException: database is locked(Sqlite code 5): , while compiling: PRAGMA journal_mode,(OS error - 11:Try again)\n    at com.android.internal.os.ZygoteInit.main\n    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run\n    at java.lang.reflect.Method.invoke\n    at java.lang.reflect.Method.invoke\n    at android.app.ActivityThread.main\n    at android.os.Looper.loop\n    at android.os.Handler.dispatchMessage\n    at android.app.ActivityThread$H.handleMessage\n    at android.app.ActivityThread.access$1900\n    at android.app.ActivityThread.handleBindApplication\n    at android.app.Instrumentation.callApplicationOnCreate\n    at xxx.Application.onCreate\n    at xxx.FavoriteJob.runJobDelay\n    at com.evernote.android.job.JobRequest.schedule\n    at com.evernote.android.job.JobManager.schedule\n    at com.evernote.android.job.JobStorage.put\n    at com.evernote.android.job.JobStorage.store\n    at com.evernote.android.job.JobStorage.getDatabase\n    at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase\n    at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked\n    at android.content.ContextWrapper.openOrCreateDatabase\n    at android.app.ContextImpl.openOrCreateDatabase\n    at android.database.sqlite.SQLiteDatabase.openDatabase\n    at android.database.sqlite.SQLiteDatabase.open\n    at android.database.sqlite.SQLiteDatabase.openInner\n    at android.database.sqlite.SQLiteConnectionPool.open\n    at android.database.sqlite.SQLiteConnectionPool.open\n    at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked\n    at android.database.sqlite.SQLiteConnection.open\n    at android.database.sqlite.SQLiteConnection.open\n    at android.database.sqlite.SQLiteConnection.setWalModeFromConfiguration\n    at android.database.sqlite.SQLiteConnection.setJournalMode\n    at android.database.sqlite.SQLiteConnection.executeForString\n    at android.database.sqlite.SQLiteConnection.acquirePreparedStatement\n    at android.database.sqlite.SQLiteConnection.nativePrepareStatement. Source code shows that db access is not synchronized at all - maybe any ReadWriteLock can be added to resolve concurrent access to database between database access methods inside JobStorage class?. Well, I was talking about synchronized access to database object, i.e. use readLock to access for queries and writeLock for database modify operations.. synchronized keyword for the method just guarantee that just a method is\nthread-safe. But calling several methods from several threads do not\nguarantee thread-safety for database object.\nOn Thu, Jan 11, 2018 at 4:15 PM, Ralf Wondratschek <notifications@github.com\n\nwrote:\nBut that's what the synchronized keyword is also achieving. Or am I\nmissing something?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/344#issuecomment-356873158,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABGgmlX3PXJCPtXk0TDhTX63yNowLPHmks5tJdFIgaJpZM4RYBWw\n.\n. > Sorry for the confusion, but what you said is wrong.\n\nYep, sorry, my fault. . ",
    "kukuhyoniatmoko": "In android's training its said we should leave our database connection open for as long as we possibly need to access it\n\nSince getWritableDatabase() and getReadableDatabase() are expensive to call when the database is closed, you should leave your database connection open for as long as you possibly need to access it. Typically, it is optimal to close the database in the onDestroy() of the calling Activity.\n\nRef: https://developer.android.com/training/data-storage/sqlite.html\nAlso post post by a Google engineer (Dianne Hackborn)\n\nAndroid made a deliberate design decision that is can seem surprising, to just give up on the whole idea of applications cleanly exiting and instead let the kernel clean up their resources.  After all, the kernel needs to be able to do this anyway.  Given that design, keeping anything open for the entire duration of a process's life and never closing it is simply not a leak.  It will be cleaned up when the process is cleaned up.\n\nRef: https://groups.google.com/forum/#!msg/android-developers/nopkaw4UZ9U/cPfPL3uW7nQJ. ",
    "antoxa2584x": "@AlexeyIke add something like\n```\nPowerManager.WakeLock wakeLock = null;\npowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);\n        if (powerManager != null) {\n            wakeLock = powerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK\n                    | PowerManager.ACQUIRE_CAUSES_WAKEUP\n                    | PowerManager.ON_AFTER_RELEASE, TAG);\n        }\n\n        if (wakeLock != null)\n            wakeLock.acquire(500);\n\n        localNotificationManager.showNotification();\n\n        if (wakeLock != null)\n            wakeLock.release();\n\n```. ",
    "sandeep-voxer": "Well, we want to use it for a messaging app, for message sending jobs - we need to use a foreground service for the following reasons:\n\nHeavily reduce possibility of app getting killed due to memory pressure while message sending jobs are executing\nIf the user has enabled data saver mode, background jobs cannot make network calls over cellular data - jobs don't get run even if network connectivity is present, since all network connectivity checks fail\nPrevents app from going into app standby before/while executing message sending jobs\nTo work with Android 8.0 background restrictions\n\nThe main reason we're using jobs for this purpose is because an internet connection isn't always available at the time a message is sent. Our app persists the pending message request, and sends it out as soon as it can. Due to problems such as getting killed due to memory pressure/crashes, system going to sleep, app standby, data saver etc. the app doesn't always get woken up when internet connectivity is regained.\nBut with jobs, our message sending code will get executed even if the app was killed, or the device was rebooted.\nSome problems we've found due to lack of foreground service creation by the library:\nIf there's no internet connectivity when the job is scheduled, the job doesn't get executed later when internet connectivity is regained, due to following problems:\n- Data saver is enabled. The library doesn't know it has an active internet connection that it can use so the job doesn't get executed.\n- App was moved to app standby mode. According to the docs, apps with foreground services won't be moved to app standby mode.\n- Light doze mode. App's jobs don't get executed when system regains internet connectivity.\nIf the library creates a foreground service when jobs are scheduled, app standby and data saver won't prevent jobs from executing.. I found that this library works better than GCMNetworkManager and Firebase job dispatcher, since they don't respect network connectivity constraints, and if the execution window is flexible, the job is run 2-3 minutes late even in ideal conditions (app is in the foreground, user is interacting with it, strong unmetered WiFi connection).. Right, but you don't actually need to execute the job inside the foreground service. You just need to keep a foreground service open. This helps with memory pressure, prevents app from going into app standby, and helps with network access if data saver is enabled. I'm not sure if this will help with Android 8.0 background restrictions though, need to test that.\nOf course, not all jobs require foreground services, so this can be configurable, but disabled by default. You could also allow apps using the library to configure the notification title, message and maybe app icon. That way, only those people who need to use such a feature will do so, and others won't see a difference.\nOf course, I get that adding more options is always a bit of a gamble, and as you've said this library was meant more for background jobs and not foreground jobs. Thanks for responding, and looking into it!. ",
    "Dooks123": "In a chat application you don't need to keep the connection running. Implement Firebase Cloud Messaging on your server. If your client is offline or unreachable, (i presume you use XMPP) then send the firebase message to the user's token. FCM is always running on the device whereas your service/job will not.\nPS: Firebase Notifications is free.. Oh so basically to sync the data to the server? This does not sound like a normal chat app then. You need to be a little bit more specific about the app.\nBecause a messaging app is quite instant, you would handle the send message in real time with an open connection to the server (your device should be awake at this point). Receiving a message whilst connected should also be instant. If you exit the app, you close the connection. Even if the device goes into doze mode, it does allow for push notifications. So for your previous employer's purpose, the device is woken with a push notification, therefor you do not need long running services.\nC2DM was there from the beginning, wasn't as good as GCM or today's FCM.\nEDIT:\nYou can schedule android job for every 15 minutes or so, check if there is internet access, do your sync and close the connection.  The OS will allow enough time to do small sync jobs, otherwise you should push a Sticky Notification (foreground service) to do your big data syncs, close the notification and allow the device to return to doze mode\n. Huawei has a similar implementation, https://stackoverflow.com/a/51140127/1876355 There should be a similar intent for OnePlus as well. There are more of these solutions whether to check if your app is white listed and to ask the user to add your app. . No.\nEach manufacturer has their own rolled battery management built into their OS.\nhttps://stackoverflow.com/questions/47284735/prevent-android-battery-managers-from-stopping-my-application-service\nThis post above explains why Whatsapp, Facebook, Telegram, Line and a bunch more apps don't have this issue. The manufacturers add those apps to the white list from the start. Your app which is no-name compared to theirs must suffer the conditions.\nALSO CHECK https://stackoverflow.com/a/48641229/1876355\nPeople attempt to gather a list of all Android flavors to implement a popup which tells the user to add your app to the white list.. I will attempt at converting it to Xamarin.Android. Thank you\n. Okay, I have successfully created a Xamarin.Android dll.\n1. Cmd > gradlew.bat\n\n\nCmd > gradlew build > Successful\n\n\nFollow these instructions:\n\nXamarin Binding a .JAR\n\n\n\nUse the classes.jar file in ..\\library\\build\\intermediates\\intermediate-jars\\release\\classes.jar\n--Had to add these two lines to the Transform > Metadata.xml\n\n<attr path=\"/api/package[@name='com.evernote.android.job.util']/class[@name='JobPreconditions']/method[@name='checkNotEmpty']/parameter[@name='p0']\" name=\"name\">refparam</attr>\n<attr path=\"/api/package[@name='com.evernote.android.job.util']/class[@name='JobPreconditions']/method[@name='checkNotEmpty']/parameter[@name='refparam']\" name=\"type\">Java.Lang.CharSequence</attr>\n\n\n\nInclude the output dll into the main project\n\n\nDone\n\n\nI will test to see if it works. Great, It works in Xamarin.Android!\nI have bound the library classes.jar file, needed to add Metadata to rename all the parameter names from p0, p1 to actual names. Added the proguard lines and the Android Manifest to my project with the Bound DLL, works like a charm.\nIf you would like to have the Xamarin Binding for this project, just give me a shout.. I have created a respository\nhttps://github.com/Dooks123/Android-Job-XamarinBinding. Thank you :). You could change your code to work like this:\nNetworkType networkType = Device.getNetworkType(context);\nif(networkType != null && !networkType.equals(JobRequest.NetworkType.ANY) { ... }\n\n. You need to Create a customJob class extending Job each with their own tags. Then call the static function ScheduleJob within them.\nnew JobRequest.Builder(TAG)\n                 .SetExecutionWindow(30000, 40000)\n                 .Build()\n                 .Schedule();. I saw this post:\nStackOverflow - Android. GcmNetworkManager on Firebase SDK?\n\nAnd the answer points to:\nGitHub - Add AlarmManager-based Driver for pre-L, non-Google devices. Well, as people stated in the GitHub discussion, one can include both GcmNetworkManager libraries and the latest Firebase libraries in the project and doesn't clash. As for my project, it works! Thanks for all your hard work with this great library. ",
    "sandy-8925": "@Dooks123  I non longer work in that company, but the purpose of that job wasn't to receive messages from the server - it was to send messages to the server. The purpose isn't to keep the connection open, it's to ensure reliable message upload, as quickly as possible, to the server.\nYou don't expect a messaging app to send a message 2 hours later, in the next doze mode window, when the device has an internet connection now, and can send the message to the server immediately.. ",
    "meryem20": "Hi !\nI develop an app to send notification with Cloud MQTT , I try it with JobSevice but i don't know how can i running a service when i receive message from a server ?..\nCan you help me please !\nThank you . ",
    "felangga": "I'm running on Android 8.0 and on Oneplus 5 too, but it get killed too even I'm using foreground service. \nI'm already trying to using job, trying this library, trying to pin the app, and using foreground service but no luck. The app still being killed, this famous issue called BgDetect on OnePlus to increase battery life. \nThe only way to save my app from getting killed is to white-listing my app on battery optimization.. ",
    "deeps2HOG": "Oh, so even if I use AlarmManager I can't schedule notifications for exact time? But then, how 3rd party alarm apps can trigger alarms at the same time even if the difference between 2 alarms is only 1 minute. Do they apply for whitelisting or they use some other techniques?. thanks for the quick response. I will see whether AlarmManager APIs will work on not. I was going through some StackOverflow answers and it seems even setExactAndAllowWhileIdle() doesn't guarantee exact time. https://stackoverflow.com/questions/33110246/setexactandallowwhileidle-is-not-exact-as-of-developer-reference. So, I tried with standalone AlarmManager APIs and still the same behaviour. Even worse, I was not able to receive BOOT_COMPLETED broadcast on One Plus and Oppo. I did more research and it seems that this is happening because of custom battery optimisation imposed by manufacturer.\nOn One plus 5T-> settings->batter optimisation->select the app and choose don't optimise\nadb shell dumpsys deviceidle whitelist\nsystem-excidle,cn.oneplus.photos,10084\nsystem-excidle,com.android.providers.downloads,10011\nsystem-excidle,com.android.vending,10047\nsystem-excidle,com.google.android.gms,10014\nsystem,cn.oneplus.photos,10084\nsystem,com.android.providers.downloads,10011\nsystem,com.google.android.gms,10014\nuser,com.truecaller,10234 //Don't know how truecaller is the only app under user in whitelist\nuser,com.tf.eros.faythTv,10355 // My App\n& on Oppo -> Security center app ->privacy permission->startup manager->select the app and choose allow. In Oppo adb shell dumpsys deviceidle whitelist throwsCan't find service: whitelist.\nAfter this I am able to create notification when app is killed or after restart on both devices and I am also receiving BOOT_COMPLETED broadcast\nSample log statement:\n01-19 18:09:12.804 com.tf.eros.faythTv D/HOG_ALARM_MANAGER: OUTSIDE_IF()---got BOOT COMPLETED BROADCAST\nThis is seriously frustrating :-( . My app users are mostly old people and I can't guide them to go to battery manager and turn on this settings\nUPDATE:\nhttps://stackoverflow.com/questions/41524459/broadcast-receiver-not-working-after-device-reboot-in-android\nthe accepted solution talks about something called as 'AccessibilityService' in order to receive BOOT_COMPLETED broadcast. but I think its a hack to bypass these battery optimisation and not the right approah.\nUPDATE:\nThe library also works fine as expected if the app is whitelisted in these battery manager Apps. I am going with this library as it takes out the pain of rescheduling jobs after reboot, creating a receiver for BOOT_COMPLETED and a lot of boilerplate code. @vRallev thanks for the quick reply. I have applied the changes mentioned in above link and also added \ngcm dependency implementation 'com.google.android.gms:play-services-gcm:16.0.0' in apps' gradle file.\nI am able to build my project now. But is it safe to have both gcm and fcm dependency ? (update: today morning when i try to build apk without gcm dependency in gradle file, it worked. But Android Studio is showing error:  PlatformGcmService is not assignable to Service. So shall I keep the gcm dependency or not?)\nAlso, I am unable to reproduce this crash on my end. Any idea how can I reproduce it so that I can verify whether the fix you have mentioned will work or not.. @vRallev I made the changes as per link which you have shared. We released the app update last week and so far no crash was observed. Thanks for the help. you can close this issue.. ",
    "Noble-Mushtak": "I just read this article about AlarmManager and they said the solution to this problem was to put the android:process=\":remote\" attribute in the <receiver> element for the BroadcastReceiver class setup for use by the AlarmManager. However, in this library, we use Jobs, so we can't just edit the manifest for the BroadcastReceiver like this. Is there any equivalent to android:process=\":remote\" in the Evernote library? If you haven't already done it, is there anyway to integrate this attribute into your library?. I would like to say that this is also happening for me. My Android is the ZTE Maven (Z812). Here is my code:\nnew JobRequest.Builder(ModifyAlarm.TAG)\n        .setExecutionWindow(alarmWindow, alarmWindow+10000) //alarmWindow is set to 1\n        .setBackoffCriteria(5_000L, JobRequest.BackoffPolicy.LINEAR)\n        .setExtras(arguments)\n        .build()\n        .schedule();\nHere is my log info:\nD/JobProxy21: Schedule one-off jobInfo success, request{id=314, tag=ModifyAlarm, transient=false}, start 00:00:00, end 00:00:10 (from now), reschedule count 0\nD/PlatformJobService: Run job, request{id=314, tag=ModifyAlarm, transient=false}, waited 00:02:00, start 00:00:00, end 00:00:10\nI/JobExecutor: Executing request{id=314, tag=ModifyAlarm, transient=false}, context PlatformJobService\nI/JobExecutor: Finished job{id=314, finished=true, result=SUCCESS, canceled=false, periodic=false, class=ModifyAlarm, tag=ModifyAlarm}\nD/PlatformJobService: Finished job, request{id=314, tag=ModifyAlarm, transient=false} SUCCESS. I know it might not be your fault, but it is still a critical error. When I try to schedule things for a longer period of time, the error in the alarm time only gets worse. Here's an example where it was off by almost 40 minutes:\nD/PlatformJobService: Run job, request{id=362, tag=ModifyAlarm, transient=false}, waited 01:12:17, start 00:33:08, end 00:33:18\nI/JobExecutor: Executing request{id=362, tag=ModifyAlarm, transient=false}, context PlatformJobService\nI/JobExecutor: Finished job{id=362, finished=true, result=SUCCESS, canceled=false, periodic=false, class=ModifyAlarm, tag=ModifyAlarm}\nD/PlatformJobService: Finished job, request{id=362, tag=ModifyAlarm, transient=false} SUCCESS. OK, I know that this may be an obvious solution, but for me, the solution here was to use .setExact() instead of .setExecutionWindow(). This is probably less efficient/more draining for the battery, but I am building an alarm app, so it is pretty important for me that the alarm goes off at the right time. Therefore, if any other people come to this thread and feel like .setExecutionWindow() is not accurate enough for them, then I would suggest using .setExact() instead of .setExecutionWindow(). However, as discussed in this issue, using .setExact() requires AlarmManager which comes with its own potential set of problems with alarms not running after the app is killed.. Honestly, I have no idea why this makes a difference. However, on my ZTE Maven (Z812), which is Android 5.1 (API 22), this change makes the alarm work even after the app is removed from the recent task list. I have not seen this documented anywhere. However, I observed that the default Clock app works after it is killed and then I looked at the source code for this app. The source code uses an implicit intent for its AlarmReceiver, so I decided to try that with this library and it fixed the issue.. Also, I just did some more research about android:exported and the documentation says \"If you are using intent filters, you should not set this element \"false\". If you do so, and an app tries to call the activity, system throws an ActivityNotFoundException.\" However, that is exactly what I am doing here and it still works. Furthermore, the PendingIntent.getBroadcast() documentation says \"For security reasons, the Intent you supply here should almost always be an explicit intent, that is specify an explicit component to be delivered to through Intent.setClass,\" but my change means that the API is now putting an implicit intent into the PendingIntent.getBroadcast() method in JobProxy14.getPendingIntent().\nGiven all this, I am even more confused as to why my code works, but it is working most of the time.. Unfortunately, it seems that this implicit intent means the alarm does not go off at all on the Google Pixel 2 with Android 8.1 (API 27). Therefore, I think it's best if I close this pull request since it seems to make the issue worse for some devices.. ",
    "dirkam": "In your presentation, you said that jobs are rescheduled even after force close (though here we are not talking about force close directly, there many other ways these apps mess up scheduled tasks).\n\nCan you please elaborate on what you meant here by \"even after force close\"?. I see, thanks for clarifying this.\nI'll run some tests to see if using this library survives such cleaner apps.. ",
    "RajaParikshit": "But how to handle this situation in Devices with API >=  26.\nAndroid documentation tell us to run the service to be executed in background, should be run as a foreground service with Notification.\nCan you add this to your library ? Means, if API >=26 all services will run in foreground with notification.\nOtherwise is their any other way to add this functionality in existing library to handle this situation.. ",
    "samlu": "Agree. The following issue has the exactly the same calling stack as mine. The suggested solution is also DON'T call db.close()\nhttps://stackoverflow.com/questions/23293572/android-cannot-perform-this-operation-because-the-connection-pool-has-been-clos. The current implementation may cause an exception while calling \"mDbHelper.getWritableDatabase()\" after you close SQLiteOpenHelper.mDatabase in closeDatabase(). Although you catch the exception in getDatabase() but the current imlemention is basically improper. . ",
    "burnermanx": "Debugging my app I discovered JobApi is returning v_14.\n. I discovered that exact jobs (like using startNow()) will run on PlataformAlarmManager. I don't known if that is a pretended behaviour. But I resolved my issue using a low exectution window (between 1 and 5 seconds) and then my jobs are running on JobScheduler.. ",
    "abhinav011085": "I wanted to start an alarm whenever the job completes. I think wake lock means that my mobile's screen will be lit whenever that happens. But in the current scenario, it only sounds the alarm without waking my mobile screen. Will it require anything else than what is given in readme to enable that feature?. ",
    "fkorotkov": "@vRallev thank you! I wasn't able to fix it due to my poor knowledge of Android. I founded it because of https://github.com/evernote/android-job/pull/370 . Rebased after https://github.com/evernote/android-job/commit/94059ca5b61c4a87f3ae52b9a442bbcbe6387d36 and now it works as expected:\n\n. ",
    "Sandeecdn": "Hey Ralf, \nThanks for your response,\nCan you please share a specific link to your answer for my question, I am unable to find the same on Stack.. ",
    "RafficMaleo": "Sorry for this dumb question but is declaring the AddJobcreatorReciever\nsubclass in the manifest file enough to instantiate the job manager . I was\nthinking you need to you to instantiate it through a intent filter .\nOn Feb 11, 2018 20:47, \"Ralf Wondratschek\" notifications@github.com wrote:\n\nI don't understand your problem. You can add a job creator like this:\nhttps://github.com/evernote/android-job/wiki/FAQ#i-cannot-\noverride-the-application-class-how-can-i-add-my-jobcreator\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/374#issuecomment-364786947,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAQrYyLDB1nScvqGZvAt7iJxFvAZRuxRks5tT1H7gaJpZM4SA8Y3\n.\n. Thanks for the response.\nWill revert if I run into some challenges\n\nRegards\nOn Feb 11, 2018 21:08, \"Ralf Wondratschek\" notifications@github.com wrote:\n\nNo, this let's you only add a JobCreator, the JobManager needs to be\ninstantiated nonetheless.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/evernote/android-job/issues/374#issuecomment-364788740,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAQrY43NDYiCWxV_wQEF_D60MCMykDlgks5tT1a6gaJpZM4SA8Y3\n.\n. \n",
    "hi-manshu": "We can add a service class which runs with the application and when we swipe the the app from app tray, we can call the DailyJob.run() from onTaskRemoved() and it will work fine. It worked for me on OnePlus as it was not working before this.. Yes, but in a battery efficient way.. ",
    "sylvain-toptal": "Thanks Dooks, I will try your bindings tomorrow as the Firebase scheduler fails to cancel jobs and that causes obvious problems.. ",
    "tobiasKaminsky": "Unfortunately I could not reproduce this.\nAccording to google play console it happened on\n- android 7.0\n- Galaxy S6 Edge+ (zenltetmo)\n- Galaxy S8+ (dream2qltesq)\nIn total it only affected two users.\nOur code is only this one:\nif (!Device.getNetworkType(context).equals(JobRequest.NetworkType.ANY)) {\n...\n}. I do neither ;-)\nBut I would have to put Device.getNetworkType() in a try / catch to prevent NPE crashing the app and so would every other user of the lib has to.\nSo I assumed it would be best to handle this on the closest point where it occurs, and that is the lib. \nAs a user of the lib, I would rather have a generic NetworkType than a crashed app, so maybe some kind of fallback can be used?. Maybe enhance this and if networkInfo is null and return NetworkType.UNKNOWN, which basically it is: the library could not reliable get an info about the network (due to vendor problems).\nThen this would be absolutely clear to the user of the lib.. @Dooks123 unfortunately not. As linked in the opening comment, on certain vendors the fucnction itselfs crashes/produces a NPE.. This is a nice way to circumvent the problem :+1: . As Device.getBatteryStatus() is now restricted, do you suggest to use the official android check instead?. @vRallev \nis there a chance to have 1.3.0 stable soon? We also experience this bug, but I do not want to use an alpha version in our app.\nOtherwise I'll patch this in latest stable release, if possible.. ",
    "azlanjamal": "thanks for the clarification. ",
    "frmz": "Yeah problem is that Broadcast Receivers requires a listening service and starting services when targeting API 26 is not possible from a BG app and widgets are always BG apps. Also a widget never knows when its on screen and needs much different job scheduling times when screen is on so having an easy way to switch from 60 secs updates to zero based on screen state would be awesome. \nThat said i think its still possible to have a sub optimal solution by requesting an update every 10 mins and just checking if a thread is alive and use the thread to update when needed.. ",
    "vipinClassic": "Ya, Nice question. I have the same question.. Why don't we use 11.8.0 till google fixes all the bugs?. ",
    "anri-vin": "Sorry for not answering for so long. \nMaybe I don't understand how library should work, but error not only in log message. \nAs I wrote here in original message:\n\nIf I replace execution window to .setExecutionWindow(1000L, 2000L) I get start 00:00:01, end 00:03:20 which is completely wrong too.\n\nAnd job execution will start EXACTLY AFTER 03:20 since scheduling. Not after 2 seconds as I requested. Can you explain me why if it is not a bug? \nP.S. Library v1.2.5\nP.P.S On other devices then API23 it will start in 2 seconds as expected.\nP.P.P.S Log message is now correct. But execution window - not.. @vRallev could you, please, explain me? I I really don't understand this behavior.. Here is my sample code:\n```\nclass CustomApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n    JobManager.create(this).addJobCreator(CustomJobCreator())\n    CustomJob.schedule()\n}\n\ninternal class CustomJobCreator : JobCreator {\n    override fun create(tag: String): Job? {\n        return when (tag) {\n            CustomJob.TAG -> CustomJob()\n            else -> null\n        }\n    }\n}\n\ninternal class CustomJob : Job() {\n    override fun onRunJob(params: Params): Result {\n        return Result.SUCCESS\n    }\n\n    companion object {\n        const val TAG = \"JOBTAG\"\n\n        fun schedule() {\n            JobRequest.Builder(TAG)\n                    .setExecutionWindow(1000, (60 * 5 * 1000).toLong())\n                    .build()\n                    .schedule()\n        }\n    }\n}\n\n}\n```\nIt runs perfect on Android 8 in emulator, but crashes at startup on my test tablet with 4.4.2.. E/AndroidRuntime: FATAL EXCEPTION: main\n                  Process: com.example.anri.crashexample, PID: 18681\n                  java.lang.RuntimeException: Unable to create application com.example.anri.crashexample.CustomApplication: java.lang.IllegalArgumentException: The GcmTaskService class you provided com.evernote.android.job.gcm.PlatformGcmService does not seem to support receiving com.google.android.gms.gcm.ACTION_TASK_READY\n                      at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4703)\n                      at android.app.ActivityThread.access$1800(ActivityThread.java:143)\n                      at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1346)\n                      at android.os.Handler.dispatchMessage(Handler.java:102)\n                      at android.os.Looper.loop(Looper.java:136)\n                      at android.app.ActivityThread.main(ActivityThread.java:5398)\n                      at java.lang.reflect.Method.invokeNative(Native Method)\n                      at java.lang.reflect.Method.invoke(Method.java:515)\n                      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:864)\n                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:680)\n                      at dalvik.system.NativeStart.main(Native Method)\n                   Caused by: java.lang.IllegalArgumentException: The GcmTaskService class you provided com.evernote.android.job.gcm.PlatformGcmService does not seem to support receiving com.google.android.gms.gcm.ACTION_TASK_READY\n                      at com.google.android.gms.gcm.GcmNetworkManager.zzc(Unknown Source)\n                      at com.google.android.gms.gcm.GcmNetworkManager.schedule(Unknown Source)\n                      at com.evernote.android.job.gcm.JobProxyGcm.plantOneOff(JobProxyGcm.java:73)\n                      at com.evernote.android.job.JobManager.scheduleWithApi(JobManager.java:242)\n                      at com.evernote.android.job.JobManager.schedule(JobManager.java:197)\n                      at com.evernote.android.job.JobRequest.schedule(JobRequest.java:436)\n                      at com.example.anri.crashexample.CustomApplication$CustomJob$Companion.schedule(CustomApplication.kt:38)\n                      at com.example.anri.crashexample.CustomApplication.onCreate(CustomApplication.kt:14)\n                      at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1009)\n                      at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4700)\n                      at android.app.ActivityThread.access$1800(ActivityThread.java:143)\u00a0\n                      at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1346)\u00a0\n                      at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\n                      at android.os.Looper.loop(Looper.java:136)\u00a0\n                      at android.app.ActivityThread.main(ActivityThread.java:5398)\u00a0\n                      at java.lang.reflect.Method.invokeNative(Native Method)\u00a0\n                      at java.lang.reflect.Method.invoke(Method.java:515)\u00a0\n                      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:864)\u00a0\n                      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:680)\u00a0\n                      at dalvik.system.NativeStart.main(Native Method). Looks like 15.0.0 is working fine and ticket could be closed (I think you should add information about buggy 12.0.X to readme). It's really interesting what kind of bug made them to bump up version from 12 to 15 in two weeks.. So why not to simply update this in library and set android:enabled=\"true\"? Maybe it is simpler to disable service programmatically in code when it is not required, rather than enabling it when it needed, if new PlayServices require this and it does't look like a google bug? Or I'm wrong?. ",
    "kevinmost": "Ah, that makes sense. I do usually use cancel for tag, but what I mean is that app developers might call cancelAll, not realizing that if a library uses android-job under the hood, they just broke that library. . Yeah, there is no real solution, just wanted to bring up that it seems problematic to me. The thing is, our library in particular schedules periodic jobs, and if they're canceled by the app developer unexpectedly, it's not like we have any other entry-points that will be called.. ",
    "deathstroke007": "is it possible to run both the jobs chronologically? i have this use case where i have to update data to server in  background  60 seconds after a Transaction(Monetary transaction). \nSo suppose i make a first transaction and schedule a job to run after 60 seconds and now within these 60 seconds i make another transaction and for this i scheduled another job but with the same tag. i found out that the second override the first and it somehow makes me think of any enqueue functionality to be embedded in this Library if there is none. is there?. what could be the solution to this?\nis it possible to run both the jobs chronologically? i have this use case where i have to update data to server in background 60 seconds after a Transaction(Monetary transaction).\nSo suppose i make a first transaction and schedule a job to run after 60 seconds and now within these 60 seconds i make another transaction and for this i scheduled another job but with the same tag. i found out that the second override the first and it somehow makes me think of any enqueue functionality to be embedded in this Library if there is none. is there?. ",
    "naushad-madakiya": "JobManager.instance().getJobRequest(jobId) will not help if we need to start job for the first time.\nEx: I want to schedule the job with DI and JobManager like jobManager.schedule(MyDailyJob.getJobRequest())\nWhere MyDailyJob#getJobRequest() can be like.\nMyDailyJob extend DailyJob {\n    public static JobRequest getJobRequest() {\nreturn buildJobRequest(new JobRequest.Builder(TAG), TimeUnit.HOURS.toMillis(1), TimeUnit.HOURS.toMillis(6));\n      }\n}\nthe daily job can also build the JobRequest and returns instead of always schedule and returns the ID and can use the same JobRequest to schedule job internally. I can create PR also if this is fine\nI am using this example by @JairAviles to schedule Jobs with Dagger\nhttps://github.com/JairAviles/AndroidJobDemo. @zishanj thanks for the Info, I will keep that in mind :). ",
    "daniel-bluesea": "@vRallev :) thanks but i meant what is \"co.tmobi\"? the receiver code is clear. ",
    "dlackty": "Oops. I overlooked that file. Thanks for pointing this out!. ",
    "stschwark": "Here's the project I've use to try and replicate the issue. The multiple execution thing happens sporadically, but more often than not. I've tested on an API 26 emulator and an API 27 device. The app schedules a daily job on launch and then shows how often the job ran.. ",
    "luizfp": "@vRallev I will provide a sample to reproduce.\nI agree this should work. In fact, our original way of canceling the job was the following:\njava\nif (!JobManager.instance().getAllJobRequestsForTag(TAG).isEmpty()) {\n            JobManager.instance().cancelAllForTag(TAG);\n}\nBut looking at the library code, I realized that in this line JobManager::285 the includeStarted parameter is assigned to false. So, I assumed that that was the problem to cancel the job, because I was calling the method inside a running job and, therefore, getAllJobRequestsForTag(...) was returning an empty set.\nThat's the reason we are using JobManager.instance().cancelAllForTag(TAG); directly. Because this method (JobManager::419) sets includeStarted to true.\nNone of the solutions worked, obviously. Another thing to say is that the usage of includeStarted in those methods is kind of misleading and maybe a better way would be to expose this parameter in getAllJobRequestsForTag(...) method... Anyway, maybe I could open another issue for this or provide a PR.. @vRallev Here is the sample: https://github.com/luizfp/EvernotePeriodicJobBugSample\nI added Stetho to the dependencies so it's easy to see the internal database.\nHere is the logs provided by the above sample:\n03-15 18:49:47.967 27400-27400/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: scheduleJob\n03-15 18:49:47.967 27400-27400/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: startNow\n03-15 18:49:48.038 27400-27452/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: onRunJob(params)\n03-15 18:49:48.038 27400-27452/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: No internet connection\n03-15 18:49:48.038 27400-27452/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: runPeriodic\n03-15 18:50:18.147 27400-28306/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: onRunJob(params)\n03-15 18:50:21.140 27400-28306/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: Cancel job TAG: demo_sync_job\n03-15 18:51:21.248 27400-28899/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: onRunJob(params)\n03-15 18:51:24.251 27400-28899/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: Cancel job TAG: demo_sync_job\nAfter the periodic job runs and get's canceled, it runs again after ~1 min.\nHere is a image from the database showing the job just after I capture the logs above:\n\nTo precisely reproduce the problem:\n1 - Disable any internet connection\n2 - Open app and click SYNC DATA button\n3 - The startNow() job will run, gets canceled and schedule the periodic job\n4 - Enable internet connection\n5 - When the periodic job runs, it will \"sync data\" and then continuously execute after ~ 1 min (debug time)\nPlease note that I tested with an Android version bellow marshmallow to enable smaller intervals. \n. Another thing to add:\nIf you reproduce only the 3 first steps\n\n1 - Disable any internet connection\n2 - Open app and click SYNC DATA button\n3 - The startNow() job will run, gets canceled and schedule the periodic job\n\nWhen the job returns Result.FAILURE the numFailures does not increment. . @vRallev you are welcome. Let me know if I can help with anything else. . I executed the sample again and the problem still happens\n03-19 10:16:50.787 9710-9710/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: scheduleJob\n03-19 10:16:50.787 9710-9710/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: startNow\n03-19 10:16:50.917 9710-10150/br.com.luizfp.evernoteperiodicjobbugsample D/PlatformAlarmService: Run job, request{id=1, tag=demo_sync_job, transient=false}, waited 00:00:00, delay 00:00:00\n03-19 10:16:50.957 9710-10150/br.com.luizfp.evernoteperiodicjobbugsample I/JobExecutor: Executing request{id=1, tag=demo_sync_job, transient=false}, context PlatformAlarmService\n03-19 10:16:50.967 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: onRunJob(params)\n03-19 10:16:50.967 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: No internet connection\n03-19 10:16:50.967 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: runPeriodic\n03-19 10:16:51.037 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/JobProxy21: Schedule periodic (flex support) jobInfo success, request{id=2, tag=demo_sync_job, transient=false}, start 00:00:30, end 00:01:00, flex 00:00:30\n03-19 10:16:51.037 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample I/JobExecutor: Finished job{id=1, finished=true, result=FAILURE, canceled=false, periodic=false, class=DemoSyncJob, tag=demo_sync_job}\n03-19 10:16:51.037 9710-10150/br.com.luizfp.evernoteperiodicjobbugsample D/PlatformAlarmService: Finished job, request{id=1, tag=demo_sync_job, transient=false} FAILURE\n03-19 10:17:21.137 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/PlatformJobService: Run job, request{id=2, tag=demo_sync_job, transient=false}, waited 00:00:30, interval 00:01:00, flex 00:00:30\n03-19 10:17:21.137 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample I/JobExecutor: Executing request{id=2, tag=demo_sync_job, transient=false}, context PlatformJobService\n03-19 10:17:21.147 9710-11664/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: onRunJob(params)\n03-19 10:17:24.187 9710-11664/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: Cancel job TAG: demo_sync_job\n03-19 10:17:24.187 9710-11664/br.com.luizfp.evernoteperiodicjobbugsample I/JobManager: Found pending job request{id=2, tag=demo_sync_job, transient=false}, canceling\n03-19 10:17:24.217 9710-9710/br.com.luizfp.evernoteperiodicjobbugsample D/PlatformJobService: Called onStopJob for job{id=2, finished=false, result=FAILURE, canceled=true, periodic=true, class=DemoSyncJob, tag=demo_sync_job}\n03-19 10:17:24.227 9710-11664/br.com.luizfp.evernoteperiodicjobbugsample I/JobExecutor: Finished job{id=2, finished=true, result=SUCCESS, canceled=true, periodic=true, class=DemoSyncJob, tag=demo_sync_job}\n03-19 10:17:24.227 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/PlatformJobService: Finished job, request{id=2, tag=demo_sync_job, transient=false} SUCCESS\n03-19 10:17:24.277 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/JobProxy21: Schedule periodic (flex support) jobInfo success, request{id=2, tag=demo_sync_job, transient=false}, start 00:00:30, end 00:01:00, flex 00:00:30\n03-19 10:18:24.267 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/PlatformJobService: Run job, request{id=2, tag=demo_sync_job, transient=false}, waited 00:01:00, interval 00:01:00, flex 00:00:30\n03-19 10:18:24.267 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample I/JobExecutor: Executing request{id=2, tag=demo_sync_job, transient=false}, context PlatformJobService\n03-19 10:18:24.277 9710-12764/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: onRunJob(params)\n03-19 10:18:27.327 9710-12764/br.com.luizfp.evernoteperiodicjobbugsample D/LOG::DemoSyncJob: Cancel job TAG: demo_sync_job\n03-19 10:18:27.327 9710-12764/br.com.luizfp.evernoteperiodicjobbugsample I/JobManager: Found pending job request{id=2, tag=demo_sync_job, transient=false}, canceling\n03-19 10:18:27.327 9710-9710/br.com.luizfp.evernoteperiodicjobbugsample D/PlatformJobService: Called onStopJob for job{id=2, finished=false, result=FAILURE, canceled=true, periodic=true, class=DemoSyncJob, tag=demo_sync_job}\n03-19 10:18:27.357 9710-12764/br.com.luizfp.evernoteperiodicjobbugsample I/JobExecutor: Finished job{id=2, finished=true, result=SUCCESS, canceled=true, periodic=true, class=DemoSyncJob, tag=demo_sync_job}\n03-19 10:18:27.357 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/PlatformJobService: Finished job, request{id=2, tag=demo_sync_job, transient=false} SUCCESS\n03-19 10:18:27.417 9710-10156/br.com.luizfp.evernoteperiodicjobbugsample D/JobProxy21: Schedule periodic (flex support) jobInfo success, request{id=2, tag=demo_sync_job, transient=false}, start 00:00:30, end 00:01:00, flex 00:00:30\nI don't know if you have used a emulator but I tested on a real device: LG G2 Mini.. Ok. I forget to add the OS version I was testing on. I tested with other releases of the library and this seems not to be a new problem. I was able to reproduce the same behavior with releases from the beginning of 2017.. That was fast! Thanks.. ",
    "TheVinhLuong": "Is there any more hidden requirement other than the requirement I specify in the JobRequest.Builder? The log say reschedule count 0 so I don't think it was being rescheduled:\nD/JobProxy21: Schedule one-off jobInfo success, request{id=10, tag=PendingHttpRequestJob, transient=false}, start 00:00:03, end 00:00:10 (from now), reschedule count 0\nI/Timeline: Timeline: Activity_idle id: android.os.BinderProxy@3a973c21 time:57934670\nI/art: Explicit concurrent mark sweep GC freed 30079(3MB) AllocSpace objects, 6(96KB) LOS objects, 62% free, 7MB/19MB, paused 821us total 93.531ms\nD/PlatformJobService: Run job, request{id=10, tag=PendingHttpRequestJob, transient=false}, waited 00:02:27, start 00:00:03, end 00:00:10\nI/JobExecutor: Executing request{id=10, tag=PendingHttpRequestJob, transient=false}, context PlatformJobService\nThis is how I recreate the issue on that device: At the begining I turn off the network connection, schedule a job and then turn the network on asap. In the first try it is executed within the time range, but from the second try onward it is not.. What I have post is a full logs between these two.\nThis is the specs of the device that I have tested on:\nAsus Zenpad\nModel number: P024\nAndroid version: 5.0.2. No luck, I tried without enforcing requirement and it is still the same. Here is the log:\nD/JobProxy21: Schedule one-off jobInfo success, request{id=24, tag=PendingHttpRequestJob, transient=false}, start 00:00:03, end 00:00:10 (from now), reschedule count 0\nI/Timeline: Timeline: Activity_idle id: android.os.BinderProxy@1cd7ea20 time:1243604\nI/art: Explicit concurrent mark sweep GC freed 19699(1178KB) AllocSpace objects, 2(32KB) LOS objects, 61% free, 7MB/19MB, paused 870us total 65.509ms\nD/PlatformJobService: Run job, request{id=24, tag=PendingHttpRequestJob, transient=false}, waited 00:02:19, start 00:00:03, end 00:00:10. Nope, all the emulator I have tried on so far is behaving normally. I think it is really a device related issue then. Thanks for your feedback and great library. . ",
    "pdapnz": "I am probably run into same issue.\nMy application start DailyJob, to shows notifications once at day. According to FAQ I makes Job windows 15 minutes. When application run in debug mode in Android Studio, job started as expected. But the same application installed from Play Market sometimes don't run Job.\nAlso is a topic starter I see this problem on two Xiaomi devices with Android 6.0 and 7.0.\nI understand this FAQ explanation, but one time in day is not a problem for battery drain.\nhttps://github.com/evernote/android-job/wiki/FAQ#why-arent-my-periodic-jobs-running-as-expected-on-android-5-or-higher\nSo is any idea how I can more deeper debug this problem? \n. Thank you for reply.\nI solved problem by adding necessary offset to avoid crash. \nThe last question for full understanding.\nYou said \"daily job is over 1 day\", but it is not \"over\" it is strongly \"equal\":\n23 * 3,600,000 + 45 * 3,600,000 + 15 * 3,600,000 = 86,400,000 (it is ONE day).\nSo 86,399,999 is valid value, but 86,400,000 - not valid for endMs. Why?\nMay be this condition should be startMs >= DAY || endMs > DAY ?. ",
    "Nimrodda": "More like hoping than assuming :)\nWhat about exact jobs? We have a few that are using startNow() when scheduling the jobs. Will they also be removed if their tag cannot be found?. ",
    "mtudora": "Same happening here, any news on this, i have a lot of crashes because of this.  On 12.0.1 i tried. And i actually need to have the playservices at this version it is not an option for me to downgrade it.\n    On Friday, March 30, 2018, 3:28:00 PM GMT+3, Vladislav Nikolaev notifications@github.com wrote:  \nHave you tried to reproduce it on 12.0.1? If it was fixed\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n    . ",
    "nitin3210": "crashing in pre lollipop devices also with gcm:12.0.1. any updates ???. ",
    "pamartineza": "Experiencing same issue, how should I turn off GCM?. ",
    "maximrahlis": "Same issue over here any updates on this?. Always crashes on pre lollipop devices with gcm:12.0.1. I temporarily fixed it with by adding the service declaration in manifest:\n    <!-- Patch fixing issue of evernote SDK with new gcm 12.0.1 -->\n    <service\n        android:name=\"com.evernote.android.job.gcm.PlatformGcmService\"\n        android:enabled=\"true\"\n        android:exported=\"true\"\n        android:permission=\"com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE\"\n        tools:replace=\"android:enabled\" >\n        <intent-filter>\n            <action android:name=\"com.google.android.gms.gcm.ACTION_TASK_READY\" />\n        </intent-filter>\n    </service>.\n",
    "s-hocking": "~~Has anyone tried reproducing this bug with Play Services 15.0.0? I've been trying myself, but I haven't been able to reproduce the bug on 12.0.0 either.~~\nJust managed to reproduce this bug with 15.0.0 as well.. @tatocaster That's interesting - it doesn't work on my device. Samsung Galaxy Tab 3 8.0 with Android 4.4.2, Play Services 15.0.0, android-job 1.2.5. Using the sample code posted earlier in this thread.. Edit: I may have spoken too soon about this one. Now I can't reproduce this crash any more. Can anyone else confirm whether the android:enabled=\"true\" workaround works fine with no Play Services dependencies?\n@anri-vin There's one downside to setting the PlatformGcmService to be always enabled - if the library is used in a project that does not have any Play Services libs linked, then the app will crash on launch with this exception:\nE/AndroidRuntime: FATAL EXCEPTION: main\n    Process: com.example.mavendeploytest, PID: 9807\n    java.lang.RuntimeException: Unable to instantiate service com.evernote.android.job.gcm.PlatformGcmService: java.lang.ClassNotFoundException: Didn't find class \"com.evernote.android.job.gcm.PlatformGcmService\" on path: DexPathList[[zip file \"/data/app/com.example.mavendeploytest-MIrKK22dIN8B9y1rmchYSg==/base.apk\"],nativeLibraryDirectories=[/data/app/com.example.mavendeploytest-MIrKK22dIN8B9y1rmchYSg==/lib/arm64, /system/lib64, /vendor/lib64]]\n        at android.app.ActivityThread.handleCreateService(ActivityThread.java:3324)\n        at android.app.ActivityThread.-wrap4(Unknown Source:0)\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1677)\n        at android.os.Handler.dispatchMessage(Handler.java:106)\n        at android.os.Looper.loop(Looper.java:164)\n        at android.app.ActivityThread.main(ActivityThread.java:6494)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)\n     Caused by: java.lang.ClassNotFoundException: Didn't find class \"com.evernote.android.job.gcm.PlatformGcmService\" on path: DexPathList[[zip file \"/data/app/com.example.mavendeploytest-MIrKK22dIN8B9y1rmchYSg==/base.apk\"],nativeLibraryDirectories=[/data/app/com.example.mavendeploytest-MIrKK22dIN8B9y1rmchYSg==/lib/arm64, /system/lib64, /vendor/lib64]]\n        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:125)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:379)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:312)\n        at android.app.ActivityThread.handleCreateService(ActivityThread.java:3321)\n        at android.app.ActivityThread.-wrap4(Unknown Source:0)\u00a0\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1677)\u00a0\n        at android.os.Handler.dispatchMessage(Handler.java:106)\u00a0\n        at android.os.Looper.loop(Looper.java:164)\u00a0\n        at android.app.ActivityThread.main(ActivityThread.java:6494)\u00a0\n        at java.lang.reflect.Method.invoke(Native Method)\u00a0\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)\u00a0\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)\u00a0\n        Suppressed: java.lang.NoClassDefFoundError: Failed resolution of: Lcom/google/android/gms/gcm/GcmTaskService;\n        at java.lang.VMClassLoader.findLoadedClass(Native Method)\n        at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:738)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:363)\n                ... 10 more\n     Caused by: java.lang.ClassNotFoundException: Didn't find class \"com.google.android.gms.gcm.GcmTaskService\" on path: DexPathList[[zip file \"/data/app/com.example.mavendeploytest-MIrKK22dIN8B9y1rmchYSg==/base.apk\"],nativeLibraryDirectories=[/data/app/com.example.mavendeploytest-MIrKK22dIN8B9y1rmchYSg==/lib/arm64, /system/lib64, /vendor/lib64]]\n        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:125)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:379)\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:312)\n                ... 13 more. @vRallev I can still consistently reproduce this issue on an Android 4.4 emulator and a 4.4 Samsung device, with GCM 15.0.1. My test project is pretty simple:\nbuild.gradle\n```\nandroid {\n    compileSdkVersion 27\n    defaultConfig {\n        applicationId \"com.example.evernotejobcrash\"\n        minSdkVersion 14\n        targetSdkVersion 27\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.android.support:appcompat-v7:27.1.1'\n    implementation 'com.android.support.constraint:constraint-layout:1.1.0'\n    implementation \"com.google.android.gms:play-services-gcm:15.0.1\"\n    implementation 'com.evernote:android-job:1.2.5'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n}\n```\nMainApplication.java\n```\npublic class MainApplication extends Application {\n@Override\npublic void onCreate() {\n    super.onCreate();\n\n    JobManager.create(this).addJobCreator(new CustomJobCreator());\n\n    new JobRequest.Builder(CustomJob.TAG)\n            .setExecutionWindow(1000, 10_000)\n            .build()\n            .schedule();\n}\n\nclass CustomJobCreator implements JobCreator {\n    @Nullable\n    @Override\n    public Job create(@NonNull String tag) {\n        if (tag.equals(CustomJob.TAG)) {\n            return new CustomJob();\n        }\n\n        return null;\n    }\n}\n\nclass CustomJob extends Job {\n    public final static String TAG = \"JOBTAG\";\n\n    @NonNull\n    @Override\n    protected Result onRunJob(@NonNull Params params) {\n        return Result.SUCCESS;\n    }\n}\n\n}\n```. ",
    "tdtran": "I spent a couple of hours debugging. This is what I found:\n1) GcmNetworkManager behavior changed in Play services v 12.x and later. It calls PackageManager.queryIntentServices to find registered services which have com.google.android.gms.gcm.ACTION_TASK_READY. This is not new. \n2) What's new is  GcmNetworkManager now runs an additional check on the returned List<ResolveInfo>. It checks if resolveInfo.serviceInfo.enabled == true. Per official Android documentation the values in serviceInfo are from service declaration in app manifest.\n3) android-job declares com.evernote.android.job.gcm.PlatformGcmService in the library manifest  with android:enabled=\"false\". The service is enabled programatically via code. The check in (2) only sees the static value in the manifest.\nThis is why the workaround posted by @maximrahlis (https://github.com/evernote/android-job/issues/415#issuecomment-380017997) works. It basically zeroes out android:enabled=\"false\" in the library manifest\n. ",
    "DavidEdwards": "I have this issue with a fleeting number of users that run Android 4.x. This isn't a huge issue for me and I don't expect a fix. Just providing this in-case it helps with debugging.\nGCM version\nimplementation \"com.google.android.gms:play-services-gcm:15.0.1\"\nandroid-job version\nimplementation 'com.evernote:android-job:1.2.1'\nMerged Manifest\n\nLogcat\n05-25 10:04:43.554 3177-3177/com.example.app E/AndroidRuntime: FATAL EXCEPTION: main\n    Process: com.example.app, PID: 3177\n    java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.app/com.example.app.LauncherActivity}: java.lang.IllegalArgumentException: The GcmTaskService class you provided com.evernote.android.job.gcm.PlatformGcmService does not seem to support receiving com.google.android.gms.gcm.ACTION_TASK_READY\n        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2195)\n        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2245)\n        at android.app.ActivityThread.access$800(ActivityThread.java:135)\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1196)\n        at android.os.Handler.dispatchMessage(Handler.java:102)\n        at android.os.Looper.loop(Looper.java:136)\n        at android.app.ActivityThread.main(ActivityThread.java:5017)\n        at java.lang.reflect.Method.invokeNative(Native Method)\n        at java.lang.reflect.Method.invoke(Method.java:515)\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)\n        at dalvik.system.NativeStart.main(Native Method)\n     Caused by: java.lang.IllegalArgumentException: The GcmTaskService class you provided com.evernote.android.job.gcm.PlatformGcmService does not seem to support receiving com.google.android.gms.gcm.ACTION_TASK_READY\n        at com.google.android.gms.gcm.GcmNetworkManager.zze(Unknown Source)\n        at com.google.android.gms.gcm.GcmNetworkManager.schedule(Unknown Source)\n        at com.evernote.android.job.gcm.JobProxyGcm.plantPeriodic(JobProxyGcm.java:86)\n        at com.evernote.android.job.JobManager.scheduleWithApi(JobManager.java:237)\n        at com.evernote.android.job.JobManager.schedule(JobManager.java:195)\n        at com.evernote.android.job.JobRequest.schedule(JobRequest.java:406)\n        at com.example.app.services.job.NewVersionJob.schedule(NewVersionJob.java:66)\n        at com.example.app.services.job.JobUtils.scheduleAllJobs(JobUtils.java:41)\n        at com.example.app.services.job.JobUtils.listJobs(JobUtils.java:36)\n        at com.example.app.LauncherActivity.continueCreating(LauncherActivity.java:63)\n        at com.example.app.LauncherActivity.onCreate(LauncherActivity.java:57)\n        at android.app.Activity.performCreate(Activity.java:5231)\n        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1087)\n        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2159)\n        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2245)\u00a0\n        at android.app.ActivityThread.access$800(ActivityThread.java:135)\u00a0\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1196)\u00a0\n        at android.os.Handler.dispatchMessage(Handler.java:102)\u00a0\n        at android.os.Looper.loop(Looper.java:136)\u00a0\n        at android.app.ActivityThread.main(ActivityThread.java:5017)\u00a0\n        at java.lang.reflect.Method.invokeNative(Native Method)\u00a0\n        at java.lang.reflect.Method.invoke(Method.java:515)\u00a0\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)\u00a0\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)\u00a0\n        at dalvik.system.NativeStart.main(Native Method). ",
    "isnyaga": "@vRallev I am still receiving this issue in Version: 4.4.2\nFatal Exception: java.lang.IllegalArgumentException\nThe GcmTaskService class you provided com.evernote.android.job.gcm.PlatformGcmService does not seem to support receiving com.google.android.gms.gcm.ACTION_TASK_READY\nin:\ncom.evernote.android.job.gcm.JobProxyGcm.cancel (JobProxyGcm.java:102)\ncom.evernote.android.job.JobManager.cancelInner (JobManager.java:389)\ncom.evernote.android.job.JobManager.cancel (JobManager.java:362). ",
    "landarskiy": "@vRallev have the same issue on samsung galaxy s4 mini (4.4.2)\nnew JobRequest.Builder(ReportJob.TAG)\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n                .setExecutionWindow(1, EXECUTION_WINDOW)\n                .setUpdateCurrent(true)\n                .build()\n                .schedule();. ",
    "blakearnold": "Looks like this is still happening when calling JobManager.instance().cancelAllForTag(TAG);\nCaused by java.lang.IllegalArgumentException: The GcmTaskService class you provided com.evernote.android.job.gcm.PlatformGcmService does not seem to support receiving com.google.android.gms.gcm.ACTION_TASK_READY\n       at com.google.android.gms.gcm.GcmNetworkManager.zze(Unknown Source:5000)\n       at com.evernote.android.job.gcm.JobProxyGcm.com.google.android.gms.gcm.GcmNetworkManager.cancelTask(SourceFile:7000)\n       at com.evernote.android.job.JobManager.cancelInner(SourceFile:389)\n       at com.evernote.android.job.JobManager.cancelAllInner(SourceFile:412)\n       at com.nomorobo.worker.CheckSubscriptionStatusWorker.com.evernote.android.job.JobManager.cancelAllForTag(SourceFile:8383)\n       at com.nomorobo.util.NomoroboBackgroundJobs.stop(SourceFile:95)\n       at com.nomorobo.receiver.UpdatedAppCompleted.onReceive(SourceFile:42)\n       at android.app.ActivityThread.handleReceiver(ActivityThread.java:2427)\n       at android.app.ActivityThread.access$1600(ActivityThread.java:139)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1487)\n       at android.os.Handler.dispatchMessage(Handler.java:102)\n       at android.os.Looper.loop(Looper.java:137). @mouli1382\nThe work-around/solution is to add GCM to your manifest:\n<service\n    android:name=\"com.evernote.android.job.gcm.PlatformGcmService\"\n    android:enabled=\"true\"\n    tools:replace=\"android:enabled\"/>\ngradle:\ndependencies {\n    compile \"com.google.android.gms:play-services-gcm:latest_version\"\n}. ",
    "mouli1382": "We are currently stuck on this one w.r.t our release cycle. We don't see the fix in 1.2.6.. Can we get an ETA on this?. We are currently stuck on this one w.r.t our release cycle. Can we get an ETA on this?. ",
    "amarilindra": "Updating to latest version fixed the issue.. ",
    "yanivtwin": "My bad , i had an if that checks if it's 7 or less on the JobCreator , \nThanks a lot ! . I tried removing the line for test it's still doing the same\nE/JOBSCHED: schedualed13\nCancelling job. JobID: 812057698\nit happens on samsung 8 with android 8\nevernote version 1.2.5. ",
    "auras": "After every .scheduleAsync() is called inside GeofenceNotificationSyncJob.scheduleJob() I print out JobManager.instance().allJobRequests.size.\nWhen running the tests individually I see in the logs\nRunning scheduler\nTask scheduled\n1\nRunning scheduler\nTask scheduled\n2\nWhen running all the test suite at once I get\nRunning scheduler\nTask scheduled\n0\nRunning scheduler\nTask scheduled\n0\nfor each test. ",
    "Bridouille": "Great, thanks for the slides! \ud83d\udc4d . ",
    "OlegIvanov95": "I have same problem. My onRunJob or sheduleJob performed on average every ~15 milliseconds.\n4-17 16:33:20.494 : WebSocketConnectionTimer onRunJob\n04-17 16:33:20.509 : WS2 - connect socket\n04-17 16:33:20.648 : AUTOCOMM_PA ru.piteravto.avtocomm.network.ws.WebSocketSender$1:onConnected\n04-17 16:33:20.662 : WS1 - connected - urls/messages\n04-17 16:33:20.699 : hash is: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:20.699 : \u0417\u0430\u043f\u0440\u043e\u0448\u0435\u043d firebaseID: f29OF44c_yA:APA91bF2wvqmymsSdmXqL49hVbvwQvSgyl3yYdRZYdqBV7h6Hu77XLXKxKsenMSJhZ5O3naCnrWNblnt5ASLE3CTRa44Oke_Ba0kVQO8eJDa8by5Hk2erx8hmN-hmCvpA_gFKIv_r_gi  hash: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:20.777 : WS1 - disconnected\n04-17 16:33:20.831 : WebSocketConnectionTimer onRunJob\n04-17 16:33:20.845 : WS1 - connect socket\n04-17 16:33:20.938 : WS2 - connected - url\n04-17 16:33:21.007 : hash is: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:21.007 : \u0417\u0430\u043f\u0440\u043e\u0448\u0435\u043d firebaseID: f29OF44c_yA:APA91bF2wvqmymsSdmXqL49hVbvwQvSgyl3yYdRZYdqBV7h6Hu77XLXKxKsenMSJhZ5O3naCnrWNblnt5ASLE3CTRa44Oke_Ba0kVQO8eJDa8by5Hk2erx8hmN-hmCvpA_gFKIv_r_gi  hash: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:21.072 : WS2 - disconnected\n04-17 16:33:21.106 : WebSocketConnectionTimer onRunJob\n04-17 16:33:21.121 : WS2 - connect socket\n04-17 16:33:21.198 : AUTOCOMM_PA ru.piteravto.avtocomm.network.ws.WebSocketSender$1:onConnected\n04-17 16:33:21.220 : WS1 - connected - urls/messages\n04-17 16:33:21.239 : hash is: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:21.239 : \u0417\u0430\u043f\u0440\u043e\u0448\u0435\u043d firebaseID: f29OF44c_yA:APA91bF2wvqmymsSdmXqL49hVbvwQvSgyl3yYdRZYdqBV7h6Hu77XLXKxKsenMSJhZ5O3naCnrWNblnt5ASLE3CTRa44Oke_Ba0kVQO8eJDa8by5Hk2erx8hmN-hmCvpA_gFKIv_r_gi  hash: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:21.308 : WS1 - disconnected\n04-17 16:33:21.349 : WebSocketConnectionTimer onRunJob\n04-17 16:33:21.374 : WS1 - connect socket\n04-17 16:33:21.482 : WS2 - connected - url\n04-17 16:33:21.497 : hash is: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:21.497 : \u0417\u0430\u043f\u0440\u043e\u0448\u0435\u043d firebaseID: f29OF44c_yA:APA91bF2wvqmymsSdmXqL49hVbvwQvSgyl3yYdRZYdqBV7h6Hu77XLXKxKsenMSJhZ5O3naCnrWNblnt5ASLE3CTRa44Oke_Ba0kVQO8eJDa8by5Hk2erx8hmN-hmCvpA_gFKIv_r_gi  hash: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:21.544 : WS2 - disconnected\n04-17 16:33:21.558 : WebSocketConnectionTimer onRunJob\n04-17 16:33:21.593 : WS2 - connect socket\n04-17 16:33:21.630 : AUTOCOMM_PA ru.piteravto.avtocomm.network.ws.WebSocketSender$1:onConnected\n04-17 16:33:21.673 : WS1 - connected - urls/messages\n04-17 16:33:21.691 : hash is: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:21.691 : \u0417\u0430\u043f\u0440\u043e\u0448\u0435\u043d firebaseID: f29OF44c_yA:APA91bF2wvqmymsSdmXqL49hVbvwQvSgyl3yYdRZYdqBV7h6Hu77XLXKxKsenMSJhZ5O3naCnrWNblnt5ASLE3CTRa44Oke_Ba0kVQO8eJDa8by5Hk2erx8hmN-hmCvpA_gFKIv_r_gi  hash: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:21.748 : WS1 - disconnected\n04-17 16:33:21.760 : WebSocketConnectionTimer onRunJob\n04-17 16:33:21.773 : WS1 - connect socket\n04-17 16:33:21.936 : WS2 - connected - url\n04-17 16:33:21.958 : hash is: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:21.958 : \u0417\u0430\u043f\u0440\u043e\u0448\u0435\u043d firebaseID: f29OF44c_yA:APA91bF2wvqmymsSdmXqL49hVbvwQvSgyl3yYdRZYdqBV7h6Hu77XLXKxKsenMSJhZ5O3naCnrWNblnt5ASLE3CTRa44Oke_Ba0kVQO8eJDa8by5Hk2erx8hmN-hmCvpA_gFKIv_r_gi  hash: d835eda5bc8b5379dcb0ddac95cb5edd9ebc93fde508268f8bf7b53ead83b519\n04-17 16:33:22.048 : WS2 - disconnected\n04-17 16:33:22.069 : WebSocketConnectionTimer onRunJob\n\n04-16 19:13:34.750 : APP  .job.UpdateMessageJob:scheduleJob\n04-16 19:13:35.251 : APP  .service_and_receiver.MyFirebaseMessagingService:onMessageReceived\n04-16 19:13:35.256 : APP  .util.Util:createMessageFromRemote\n04-16 19:13:35.259 : Message came - action: 3392ce81-7e23-45fc-983d-2e3aada83d9a\n04-16 19:13:35.266 : APP  .service_and_receiver.MyFirebaseMessagingService:lambda$onMessageReceived$3$MyFirebaseMessagingService\n04-16 19:13:35.269 : APP  .job.UpdateMessageJob:scheduleJob\n04-16 19:13:35.669 : APP  .service_and_receiver.MyFirebaseMessagingService:onMessageReceived\n04-16 19:13:35.680 : APP  .util.Util:createMessageFromRemote\n04-16 19:13:35.687 : Message came - action: 3392ce81-7e23-45fc-983d-2e3aada83d9a\n04-16 19:13:35.700 : APP  .service_and_receiver.MyFirebaseMessagingService:lambda$onMessageReceived$3$MyFirebaseMessagingService\n04-16 19:13:35.705 : APP  .job.UpdateMessageJob:scheduleJob\n04-16 19:13:36.242 : APP  .service_and_receiver.MyFirebaseMessagingService:onMessageReceived\n04-16 19:13:36.248 : APP  .util.Util:createMessageFromRemote\n04-16 19:13:36.252 : Message came - action: 3392ce81-7e23-45fc-983d-2e3aada83d9a\n04-16 19:13:36.261 : APP  .service_and_receiver.MyFirebaseMessagingService:lambda$onMessageReceived$3$MyFirebaseMessagingService\n04-16 19:13:36.262 : APP  .job.UpdateMessageJob:scheduleJob\n04-16 19:13:36.880 : APP  .service_and_receiver.MyFirebaseMessagingService:onMessageReceived\n04-16 19:13:36.886 : APP  .util.Util:createMessageFromRemote\n04-16 19:13:36.890 : Message came - action: 3392ce81-7e23-45fc-983d-2e3aada83d9a\n04-16 19:13:36.902 : APP  .service_and_receiver.MyFirebaseMessagingService:lambda$onMessageReceived$3$MyFirebaseMessagingService\n04-16 19:13:36.911 : APP  .job.UpdateMessageJob:scheduleJob\n04-16 19:13:36.920 : APP  .service_and_receiver.MyFirebaseMessagingService:onMessageReceived\n04-16 19:13:36.925 : APP  .util.Util:createMessageFromRemote\n04-16 19:13:36.934 : Message came - action: 3392ce81-7e23-45fc-983d-2e3aada83d9a\n04-16 19:13:36.955 : APP  .service_and_receiver.MyFirebaseMessagingService:lambda$onMessageReceived$3$MyFirebaseMessagingService\n04-16 19:13:36.959 : APP  .job.UpdateMessageJob:scheduleJob\n04-16 19:13:37.667 : APP  .service_and_receiver.MyFirebaseMessagingService:onMessageReceived\n04-16 19:13:37.675 : APP  .util.Util:createMessageFromRemote\n04-16 19:13:37.679 : Message came - action: 3392ce81-7e23-45fc-983d-2e3aada83d9a\n04-16 19:13:37.686 : APP  .service_and_receiver.MyFirebaseMessagingService:lambda$onMessageReceived$3$MyFirebaseMessagingService\n04-16 19:13:37.690 : APP  .job.UpdateMessageJob:scheduleJob\n04-16 19:13:38.177 : APP  .service_and_receiver.MyFirebaseMessagingService:onMessageReceived\n04-16 19:13:38.185 : APP  .util.Util:createMessageFromRemote\n04-16 19:13:38.189 : **Message came - action: 3392ce81-7e23-45fc-983d-2e3aada83d9a\n04-16 19:13:38.199 : APP  .service_and_receiver.MyFirebaseMessagingService:lambda$onMessageReceived$3$MyFirebaseMessagingService\n04-16 19:13:38.203 : APP  .job.UpdateMessageJob:scheduleJob\nAnd another question. I delete the job from the application, but its code continues to run, even if I delete the application from the device!\nVersion in Gradle - 'com.evernote:android-job:1.1.11'. In emulator and real devices.. ",
    "Martindgadr": "Hi @vRallev, \nI put the explanation on first question, if you don't have time to read LOG that @OlegIvanov95 and I put in order to provide you more information, please read that issue is simple. Both put A service call to run every 15 minutes doing most simple example provided by info library on this repo, so I follow steps provided by this repo and instead of run every 15 minutes the job run more than once in less than 3 minutes, and run when it want, do not respect 15 or 20 minutes (+ - 5 minutes SO), so something happened on it.... if you want more information, maybe you have to check LOG that both put on this page. hope you can help us. #. Thanks @Bennith, with .setUpdateCurrent(true) was solved. #\n@OlegIvanov95 Maybe you have to add this line in your job too in order to solve the issue. Thanks again.. ",
    "bendothall": "I have the same issue as such, I have a Periodic() that should run every hour & flex of 10 minutes, but I can see the task runs erratically and also multiple times in a minute.\n    long interval = TimeUnit.HOURS.toMillis(1); // every HOUR\n    long flex = TimeUnit.MINUTES.toMillis(10); // wait 10 MINUTES before job runs again\n\n    return  new JobRequest.Builder(SyncTask.TAG)\n            .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n            .setPeriodic(interval , flex)\n            .build()\n            .schedule();\n\nSee below logging multiple runs within a few minutes (sometimes even seconds) ...\n04-30 17:06:54.866 23278-2912/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:54.876 23278-2916/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.056 23278-2911/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.056 23278-2916/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.146 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.156 23278-2916/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.196 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.196 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.276 23278-2911/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.276 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.346 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.346 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.396 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.396 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.456 23278-2911/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.456 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.526 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.526 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.616 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.616 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.686 23278-2911/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.696 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.786 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.786 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.856 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.866 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.916 23278-2911/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.926 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:55.966 23278-2912/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:55.966 23278-2914/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.046 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.056 23278-2914/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.146 23278-2911/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.156 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.226 23278-2912/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.226 23278-2916/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.266 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.266 23278-2914/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.326 23278-2911/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.326 23278-2914/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.406 23278-2912/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.406 23278-2914/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.486 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.496 23278-2914/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.556 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.566 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.626 23278-2912/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.626 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.676 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.686 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.746 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.746 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.806 23278-2912/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.806 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.906 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.906 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:56.966 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:56.966 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:57.046 23278-2912/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:57.046 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:57.126 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:57.126 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:57.206 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:57.206 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:57.286 23278-2912/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:57.296 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:57.396 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:57.406 23278-2911/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:57.456 23278-2911/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:57.456 23278-2914/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:57.536 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:57.536 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:57.696 23278-2916/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:57.706 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask()\n04-30 17:06:57.776 23278-2914/app.sync.ordertracking E/JobCreator(): ScheduledTask().JobCreator(): running...\n04-30 17:06:57.776 23278-2912/app.sync.ordertracking E/ScheduledSync():: activateScheduledSync().onRunJob().doSyncTask(). Good read .. https://stackoverflow.com/a/46163527/1423608. ",
    "bhylak": "Oops, I was looking at isCancel not onCancel! Sorry for not double checking the code before posting -- thanks for the help.. ",
    "froesmatheus": "@vRallev Okay, so, what would you do in this situation? Is my solution good enough?. ",
    "rishabh876": "Will this solution trigger job immediately if internet is connected?. Can we have a fix for this in a separate version 1.2.7? . I think WorkManager Beta2 is not supported yet. Alpha11 is what was supported in last updated of this library.. beta04 is available now for WorkManager\nhttps://developer.android.com/jetpack/androidx/releases/work#1.0.0-beta04. We finally have a stable release of work manager 1.0.0\nhttps://developer.android.com/jetpack/androidx/releases/work#1.0.0. ",
    "frielspak": "Yep, its where i am doing it.So its ok ;)\nThank you.. ",
    "tettk": "@vRallev , I'm not positive on that specific line. I just found that while I was digging around the code. \nIt's weird that this crash happens even when WhatsApp isn't using the library. Oh well, might it really be a platform bug? Or the user did something weird with the packages.\nThank you for looking into this.. I'll close the issue for now since there's no real next step to take action on.\nWill report if anything changes.\nThanks!. ",
    "ebnrdwan": "@pedrodimoura  thanks for  helping out.\nfeature not supported yet, hope to be supported soon. ohhh okay,\ni guess if i subtracted the current milliseconds from the milliseconds of my targeted date it will be scheduled right, doesn't it ?\n\nsolved with this trick . ",
    "vahidaghakhany": "@ExploiTR  I also tried to cancel by id but it doesn't work . ",
    "DarkF1eld": "\nThis should work. Can you provide a tiny sample app where you can reproduce the issue?\n\nI will provide a tiny sample app tomorrow. i created a tiny sample app and attached it to this post.\nIts function is a small version of the original app. it is showing a notification every 15 minutes if the app isn\u00b4t in the front. Without reboot and closing the app (from \"last apps list\") it works fine, but if i reboot the smartphone or emulator the notification is not showing after 15 minutes.\nTinySampleApp.zip\n. ok, you are right, i fixed it using an \"AddJobCreatorReceiver\"-Class and added this class to AndroidManifest.xml like this:\n</activity>\n        <receiver\n            android:name=\".AddReceiver\"\n            android:exported=\"false\">\n            <intent-filter>\n                <action android:name=\"com.evernote.android.job.ADD_JOB_CREATOR\"/>\n            </intent-filter>\n        </receiver>\n    </application>\nMy Receiver-Class:\npublic final class AddReceiver extends JobCreator.AddJobCreatorReceiver {\n    @Override\n    protected void addJobCreator(@NonNull Context context, @NonNull JobManager manager) {\n        manager.addJobCreator(new TestJobCreator());\n    }\n}\nProblem is solved, Thanks for your help. ",
    "fgustovo": "same issue here but a bit difference. i watched app in foreground mode 2-3 times, and job never trigerred.\nnew JobRequest.Builder(AdActivitySyncJob.TAG)\n                .setPeriodic(TimeUnit.MINUTES.toMillis(15), TimeUnit.MINUTES.toMillis(10))\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n                .setUpdateCurrent(true)\n                .build()\n                .schedule();. ",
    "ali-android": "I think its documented here, that its not possible to run a schedule, if app is in killed state.\n. ",
    "TooLazyy": "Okay. I have found out what is the reason.\nI my onRunJob() i use CountDownLatch and RxJava to make and API call.\nPlease add in FAQ section \"How can I run async operations in a job?\" a note that countDownLatch.countDown() should be called in onCancel() method.. ",
    "aldovincenti": "@vRallev thank you for your prompt reply. Why does it work correctly on Android 8.1 and Android P? Maybe Android 6 implements Doze differently than Android 8.1 or Android P? Anyway, how could I get on all android versions what you can see in the first GIF using Android-Job?. ",
    "chrjsorg": "Have the same issue. I removed the WorkManager Dependency for now, which works again. . ",
    "vinitthaker": "I am still getting this error even though I am using 1.3.0-apha02 version of the library.. ",
    "rjouvet": "Hum me too, the comments are only here to show that at the program start up the tag shouldn't be found and triggered.. But what is the issue?. Hum... I have writing the same problem on StackOverflow and it seems that some people have the same issue.\nHave you tried it? Do you need further information?. Ah OK. No problem, yeah it misses some information in fact. So to reproduce the issue.\nCreate a JobService:\n```\nclass JobService : Job() {\ncompanion object {\n\n    private var jobId = 0\n\n    fun scheduleJobPeriodically(ms: Long) {\n        if (jobRequested()) {\n            cancelJob()\n        }\n        jobId = JobRequest.Builder(\"JOB_TAG\")\n                .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n                .setPeriodic(ms, TimeUnit.MINUTES.toMillis(5))\n                .setRequirementsEnforced(true)\n                .build()\n                .schedule()\n    }\n\n    fun cancelJob() {\n        JobManager.instance().cancel(jobId)\n    }\n\n}\n\noverride fun onRunJob(params: Params): Result {\n    Timber.d(\">>>>>>>>>>>Job is Running\")\n    Result.SUCCESS\n}\n\n}\n```\nA JobCreator:\nclass MyJobCreator : JobCreator {\n  override fun create(tag: String): Job? {\n    return when (tag) {\n        \"JOB_TAG\" -> {\n            JobService()\n        }\n        else -> null\n    }\n }\n}\nIn application class add the required line to register the job:\nJobManager.create(this).addJobCreator(MyJobCreator())\nAt this point the application is started and the JobService class is created. (OK) \nBut in this class, there is this method scheduleJobPeriodically, and this method is fired and it shouldn't, because I don't explicitly start it. \nI have started my app in debug mode and I am sure that the periodic creation is not called directly, as well as the JobRequestBuilder that set the tag for a job. But the code in the onRunJob is fired and it's the issue.. ",
    "adek": "Your library should be OK with v4, right?\ncom.android.support:support-v4:27.1.1\nYes. I'll try to dig tomorrow if there is a way to ignore this error. \nI've just upgraded android-job to 1.2.6 from 1.2.4. \nI'll try also 1.2.4 tomorrow and see if this error is still there.\nBut yeah, it looks like some kind of problem with support library 27.1.1. But this is the latest one (stable).. Yes. Please, close this issue. I'm investigating this. It's not crashing, just showing in logs and as you said. It's support library issue. I need some more time to check other  versions of support libs. I'll migrate also to 28 and let you know. . ",
    "teshlya": "I have the same problem when using AppMetrica\nYandexMetricaConfig.Builder configBuilder = YandexMetricaConfig.newConfigBuilder(API_KEY);\nYandexMetrica.activate(getApplicationContext(), configBuilder.build());\n        YandexMetrica.enableActivityAutoTracking(this);\n   YandexMetricaPush.init(getApplicationContext());. ",
    "hikermillerman": "I had the same problem with com.android.support:appcompat-v7:28.0.0.\nIt kept showing an error in logs Rejecting re-init on previously-failed class java.lang.Class<android.support.v4.view.ViewCompat$OnUnhandledKeyEventListenerWrapper>: java.lang.NoClassDefFoundError\nThis is resolved by adding  below to app build.gradle\nconfigurations.all {\n    resolutionStrategy.eachDependency { DependencyResolveDetails details ->\n        def requested = details.requested\n        if (requested.group == \"com.android.support\") {\n            if (!requested.name.startsWith(\"multidex\")) {\n                details.useVersion \"27.+\"\n            }\n        }\n    }\n}. ",
    "mohamadk": "this is my sample https://github.com/mohamadk/EvernoteJobSchedulerTest \nabout delay in google document says https://developer.android.com/training/monitoring-device-state/doze-standby \n\nFigure 1. Doze provides a recurring maintenance window for apps to use the network and handle pending activities.\n\nso it must run not at exact 1 am but it must run. correct?. any progress?. ",
    "vkhirani93": "@vRallev I have the exact same issue. I have scheduled multiple daily jobs using different job tags. These jobs will run and make a network call to fetch some data. Now there is a weird behavior in this case.\n1) These jobs run perfectly when the app is in foreground but fails to make a network call when in background or killed state.\n2) Now these failed daily jobs are accumulated and are fired when I launch my app.\nJust to give a brief that I too have enforced network requirements.\n**Also tried removing network requirements but no success at all. Works fine when the app is in foreground but fails if in background or killed state.. Found answers to Question 3 & 4 using Issue Tracker. Would still like more clarification on Question 1 & 2.. @vRallev thanks.. @vRallev sure. I'll provide the sample app with in couple of days.. ",
    "Nikita-13": "I scheduled my jobs by using below code:\nnew JobRequest.Builder(PeriodicUnmeteredDistributionJob.JOBTAG)\n                    .setPeriodic(JobRequest.MIN_INTERVAL, JobRequest.MIN_FLEX)\n                    .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED)\n                    .setRequirementsEnforced(true)\n                    .setUpdateCurrent(true)\n                    .build()\n                    .schedule();\nand as far as I see the logs it got scheduled but I didn't got any callback from the OS to run the job. This issue was not see on the regular basis but once in a while. . ",
    "zloyreznic": "The some error. ",
    "SergeyBurlaka": "Thanks @vRallev for your answer.  . ",
    "dhaksddj": "That leaves me no choice but to add some logic to each job when it fires to see if it should do the work or not.\nIs there some way to interrogate the jobs? . So lets say a job is submitted twice during a period of no network (and the jobs require it). Could I check to see if there are other similar jobs waiting?. ",
    "wessimtrimeche": "care to explain why do I need a thread instead ? knowing that I managed to make it work with your library for the battery state instead of the location, and I am only struggling with the parameters injection here.  why are the params in the onRunJob method, there in the first place if I can't manipulate them from the calling activity.\nThank you.. Which is exactly my case since the work, being a position update, isn't guaranteed to happen any time soon, and I can't guarantee that the application will be up and running at the time that might happen.\nSo you're saying I can only change the parameters in the same class where I am scheduling the job and not from the calling activity?. it's not the Job that would change, consider a main activity in which I write these lines of code (written in kotlin)\nval extras: PersistableBundleCompat = PersistableBundleCompat()\nextras.putDouble(\"longitude\", latLng.longitude)\nextras.putDouble(\"latitude\", latLng.latitude)\nJobManager.create(applicationContext).addJobCreator(DemoJobCreator())\nDemoSyncJob.scheduleJob()\n\nwhat should I do to pass this bundle to the job and retrieve it afterwards from the onRunJob method in DemoSyncJob by doing \nparams.getExtras(). yes I did, that's from where I got the idea of the PersistableBundleCompat, but it still does not solve my problem since the extras are used within the same class and not passed from one to another.\n\nAnyway thank you for your time I'll try some other alternatives.. okey I was blindly following the sample I didn't actually notice that the scheduling method wasn't overridden, I thought it had to belong to the same class as the onRunJob, sorry my bad, you can delete the issue if you want thank you again for your time.. ",
    "nkadu1": "Thanks for the feedback.\nThat means if the device lets say is low on memory or too busy in other processes then there might be a delay for the job to get executed, Am I right ? Can I expect the job would never run under some circumstances?. @prasant-in : Cool, will try that out on oreo.\nI am getting expected behavior on lower versions.\nThanks!!. ",
    "prasant-in": "@nkadu1 , I am not sure about your issue. But what I was facing like similar to above issue. So I have added channel and it started working.\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            NotificationChannel channel = new NotificationChannel(TAG, \"MyTag\", NotificationManager.IMPORTANCE_DEFAULT);\nchannel.setDescription(\"MyTag Des\");\ngetContext().getSystemService(NotificationManager.class).createNotificationChannel(channel);\n        }. Along with above class \"NotificationJob \" below are two more files, hope it is sufficient to repro the issue.  Let me know in case you need more info :\npublic class MyApplication extends Application {\n    public static final String TAG = MyApplication.class\n            .getSimpleName();\nprivate static MyApplication mInstance;\n\n@Override\npublic void onCreate() {\n    super.onCreate();\n    mInstance = this;\n\n   JobManager.create(this).addJobCreator(new NotificationJobCreator());\n}\n\n}\npublic class NotificationJobCreator implements JobCreator {\n@Override\n@Nullable\npublic Job create(@NonNull String tag) {\n    switch (tag) {\n        case NotificationJob.TAG:\n            return new NotificationJob();\n        default:\n            return null;\n    }\n}\n\n}\n. ",
    "softworkz": "Since most or the related issues were closed without solution, I started looking in to this myself and I think I've found the reason that leads to the above exceptions:\n\nThe GcmAvailableHelper class is meant to check if GcmNetworkManager is available or not\nBut at the same time, GcmAvailableHelper is referencing PlatformGcmService (in imports and in method isGcmServiceRegistered)\nPlatformGcmService is in turn a subclass of GcmTaskService (from the google package that we actually want to test for availability)\n\nObviously this cannot work. Once the GcmAvailableHelper class gets loaded, the used types are tried to be loaded, but PlatformGcmService cannot be loaded because its parent class GcmTaskService isn't included.\nThis can be easily fixed in various ways, probably no need to elaborate any further.\nWhat I would really be concerned about: Could this be fixed for version 1.2.6, like as 1.2.6.1 or 1.2.7?\nThanks!. This is not the warning from the catch clauses inside GcmAvailableHelper that you had recently surrounded with \"if (Build.Debug)\".\nIt doesn't even get to that point because the GcmAvailableHelper  class cannot be loaded at all.. Hm, whether the app is crashing or not shouldn't be a measure to determine if there's a bug or not ;-)\nAnd whatever mysterious situation you are referring to, I'm pretty sure that this is not the case here, as from the call stack we can see this:\n\nThe exception is unhandled because the stack trace goes straight through from Thread.run until the ClassLoader stuff. If this would be an exception that you have caught (and still got logged \"by the device\"), then the callstack would be starting at where the exception is caught and not from Thread.run\nWe can also see that it is crashing inside the cleanUpOrphanedJob method\nNext frame in the call stack is a call to JobApi.isSupported(). When I look at the source code of cleanUpOrphanedJob, I can see that the call to JobApi.isSupported() is outside of the try...catch block - that's why it throws all the way back to Thread.Run\n\nThough,, the actual problem is not about putting the call to isSupported inside the try...catch. As I tried to explain in my previous post, the problem lies in the GcmAvailableHelper class. This class should not use types for which it is actually meant to check for existance (or in this case using types derived from such types). Yes I can reproduce it in the emulator.\nJust look a bit closer at the error messages:\n\n\nCaused by: java.lang.ClassNotFoundException: Didn't find class \"com.google.android.gms.gcm.GcmTaskService\" on path: DexPathList[[zip file ...\n\n\nRejecting re-init on previously-failed class java.lang.Class: java.lang.NoClassDefFoundError: Failed resolution of: Lcom/google/android/gms/gcm/GcmTaskService;\n\n\nThis means that: GcmTaskService cannot be instantiated because its base class GcmTaskService is not available (since we don't have the Google dependency included)\nWhat happens exactly is this and in the following order:\n\n....\ncleanUpOrphanedJob in JobProxy is called\nThis is calling JobApi.isSupported\nThis method wants to call GcmAvailableHelper.isGcmApiSupported, but the call is never completed because the java runtime tries to load GcmAvailableHelper.isGcmApiSupported but it doesn't succeed because GcmAvailableHelper uses PlatformGcmService here: https://github.com/evernote/android-job/blob/4ac5b23bdd51346aab13b396686177d85a26a3c8/library/src/main/java/com/evernote/android/job/GcmAvailableHelper.java#L84\nSince GcmTaskService doesn't exist, PlatformGcmService cannot be instantiated and since GcmAvailableHelper is using PlatformGcmService, instantiation of GcmAvailableHelper fails as well\n\nThis failure appears in two different ways in the log:\n1. ClassNotFoundException: Didn't find class.....\n2. and then: Rejecting re-init on previously-failed class .....\nThe latter (\"Rejecting re-init\") appears because the class loading process is not repeated when it has already failed once for a class.\n. It is crashing the thread and cleanUpOrphanedJob is never completed. Do you need any more information from me?\nActually I'm reporting a bug here,, this shouldn't be labeled as a question ;-). Our app was previously using GCM and we dropped this. It is happening after upgrading.\nThen it comes to the cleanUpOrphanedJob call which is calling jobApi.isSupported which is checking in turn for GMC.\nSo, to reproduce, you'll need to:\n\ninstall an app with GCM enabled\nlet this app schedule jobs with GCM\nthen upgrade the app to a version that doesn't include GCM\nrun at watch the debug output\n\nThis way, you should see this error.. Please see the PR. This should fix it but I haven't tested yet.\nThey key would be to avoid the runtime loading the PlatformGcmService class, which it can't load because its superclass GcmTaskService (from the google package) does not exist.. Unfortunately this is not the issue that you are referring to.\nI can say this with absolute confidence because we had experienced this \"FAQ issue\" as well!\nWe saw the error \"Unable to instantiate service...\" and it could be fixed by making the entries that you're suggesting in the FAQ.\nI even checked this again just recently. I removed the service-delete-entry from the manifest and then I got the documented error again:\n\"Unable to instantiate service...\"\nBut the error that I'm reporting here is different:\n\"ClassNotFoundException: Didn't find class \"com.google.android.gms.gcm.GcmTaskService\"\nAnd it still occurs even after adding the suggested entries to the manifest (as mentioned: adding these entries does has the effect that the \"FAQ-Error\" disappears but it doesn't eliminate the error that I'm describing in this thread.\nWhether you can reproduce this or not, shouldn't matter that much in this case. It happens in cases and the callstack proves that. With the callstack it is even trivial to follow the function calls that are executed when it comes to that Exception. . I closed the PR now and created a new one with the most trivial fix one could think of:\nFrom the callstack we can see that the exception is thrown in the Method JobProxy.cleanUpOrphanedJob when if calls jobApi.isSupported(context).\nThe call to isSupported was not inside a try block, and that's why the whole thing ended up in an \"unhandled\" Exception (=Crash).\nWith the latest PR I have simply moved the call to isSupported() to the inside of the try block.\nThat should definetely fix the situation and doesn't impose any significant risk for regressions.\nI hope you'll find this change acceptable, so that we can finally settle this issue... :-)\nThanks a lot for your patience :-)\n. Thank you very much!\nWe're not ready for 1.3 (it's still alpha anyway), but we need to roll out a new version of our app in the next 2-3 weeks.\nIs there a chance for a patched 1.2.6 or 1.2.7 version?\n. Can the 1.3.0 version be configured to behave exactly like the 1.2.6 version?\nCould we rely on that? \nWhat I mean is: Is 1.3 the same like before just with WorkManager added as an alternative?\nOr does it include global changes that also introduce differences in common behavior?. OK, good! But the existing scheduling methods and the common implementation - are they unchanged?\nI mean, can we upgrade to 1.3.0 without significant regression risks?\nOr would we need to go through another test phase with 1.3.0?. Now that you even followed both approaches that I've been suggesting, we should be on the safe side :-)\nI'm still concerned about the alpha state, though:\n\nBut the existing scheduling methods and the common implementation - are they unchanged? \nI mean, can we upgrade to 1.3.0 without significant regression risks?\nOr would we need to go through another test phase with 1.3.0?. superceded by #495. \n",
    "aconsuegra": "We are being more strict now canceling pending jobs, so this should hopefully reduce the number of crashes. Closing the issue.. ",
    "Anurag--Singh": "I have figured it.. ",
    "fengzee-me": "I overlooked a fact that is actually causing most occurrences of the NPE. You set a 3s timeout for the CountDownLatch#await() method call in getJobStorage():\nmJobStorageLatch.await(3, TimeUnit.SECONDS);\ngetJobStorage() may return null because of this timeout. But all 41 usages of it seem to have the assumption that the method never returns null. I would suggest that you remove the timeout and just let getJobStorage()'s calling thread hang if initialization of mJobStorage is that slow. The \"volatile\" issue I mentioned before is a problem, but not as serious as this one. Please consider my suggestion and work out your own fix.\nFor my project, I temporarily reverted your #471 fix and build an AAR for my own use.. Thanks for the fix. My project has switched to use WorkManager so I'm sorry I cannot test your fix on production builds anymore. Anyone who shares the same issue can give a feedback here.. ",
    "Gnzlt": "Happened the same to me requesting location updates while using a CountDownLatch\nlocationClient.requestLocationUpdates(locationRequest, callback, null)\nStacktrace:\n08-07 13:11:10.804 24341-24448/com.example.android.debug E/ErrorReporter: GetLocationJob\n    java.lang.IllegalStateException: Can't create handler inside thread that has not called Looper.prepare()\n        at com.google.android.gms.common.internal.Preconditions.checkState(Unknown Source:8)\n        at com.google.android.gms.internal.location.zzbm.zzc(Unknown Source:11)\n        at com.google.android.gms.internal.location.zzbm.zza(Unknown Source:3)\n        at com.google.android.gms.location.FusedLocationProviderClient.requestLocationUpdates(Unknown Source:4)\n        at com.example.GetLocationJob.getLocationFromDevice(GetLocationJob.kt:99)\n        at com.example.GetLocationJob.getLocation(GetLocationJob.kt:59)\n        at com.example.GetLocationJob.onRunJob(GetLocationJob.kt:47)\n        at com.evernote.android.job.Job.runJob(Job.java:124)\n        at com.evernote.android.job.JobExecutor$JobCallable.runJob(JobExecutor.java:181)\n        at com.evernote.android.job.JobExecutor$JobCallable.call(JobExecutor.java:166)\n        at com.evernote.android.job.JobExecutor$JobCallable.call(JobExecutor.java:149)\n        at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)\n        at java.lang.Thread.run(Thread.java:764). ",
    "mohammadranjbar": "new JobRequest.Builder(DemoSyncJob.TAG)\n            .setPeriodic(TimeUnit.MINUTES.toMillis(15), TimeUnit.MINUTES.toMillis(5))\n            .build()\n            .schedule();\nthis job will work every 15 minutes if you want do job every 6 hours you must change MINUTES to HOURS and 15 to 6,\nand if you want do every week you can change MINUTES to DAYS and 15 to 7 \nThe repo documentation is good and almost has all answers. ",
    "alexkutsko": "Thanks. After fix works perfect!. ",
    "ZDZN": "I met this crash too. When I change work-runtime's version to 1.0.0-alpha05 , everything is ok. But get crash with work-runtime:1.0.0-alpha06.\n\n. ",
    "SumirKodes": "I've been able to build the sample project just fine.  Can you try cleaning and rebuilding and let us know what happens?. This is most likely happening because you have an explicit dependency in the sample on 'android.arch.work:work-runtime:1.0.0-alpha06', but android-job is internally depending on work-runtime:1.0.0-alpha05.\n\nYour sample doesn't need a dependency on work-runtime if it's already defined in android-job.\nIf you do make a dependency on work-runtime, have it match what's used in android-job.\nandroid-job's dependency should probably be work-runtime:1.0.0-alpha-06 or 07 at this point.. \n",
    "Mobitsolutions": "on reboot, i have registered following receiver, please check if, i can reschedule job on reboot like this?\n ```\npublic class MyStartServiceReceiver extends BroadcastReceiver {\n@Override\n    public void onReceive(Context context, Intent intent) {\n        if(JobManager.instance() == null) {\n            JobManager.create(context).addJobCreator(new DemoJobCreator());\n            MyJobs.scheduleJob();\n        }\n        else\n        MyJobs.scheduleJob();\n    }\n}\n```. Hi, \nI am using following version of library:\nimplementation 'com.evernote:android-job:1.3.0-alpha06'\nand doing:\n```\npublic class MyJobs extends Job {\n{\n@Override\n    @NonNull\n    protected Result onRunJob(Params params) {\n        // run your job here\n      //  getContext().getApplicationContext().startService(new Intent(getContext().getApplicationContext(), MainService.class));\n        Intent intent = new Intent(getContext(), SeparateProcessService.class);\n        getContext().startService(intent);\n        Log.v(\"schedulePeriodicJob(15)\", \"------------JOB Done--------------------------\");\n        return Result.SUCCESS;\n    }\npublic static void scheduleJob() {\n    int jobId = new JobRequest.Builder(MyJobs.TAG)\n            .setRequiredNetworkType(JobRequest.NetworkType.CONNECTED)\n            .setPeriodic(TimeUnit.MINUTES.toMillis(15), TimeUnit.MINUTES.toMillis(5))\n            .setUpdateCurrent(true)\n            .build()\n            .schedule();\n}\n\n}\nMainActivity: on create i am calling: \n   MyJobs.scheduleJob();\nMy Grade:\napply plugin: 'com.android.application'\nandroid {\n    compileSdkVersion 28\n    useLibrary 'org.apache.http.legacy'\n    defaultConfig {\n        applicationId \"com.mobit.solutions.inventoryutility\"\n        minSdkVersion 18\n        targetSdkVersion 28\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n}\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation 'com.evernote:android-job:1.3.0-alpha06'\n    implementation 'com.android.support:appcompat-v7:27.1.1'\n    implementation 'com.android.support.constraint:constraint-layout:1.1.2'\n    testImplementation 'junit:junit:4.12'\n    implementation 'com.google.android.gms:play-services-location:15.0.1'\n    implementation 'com.android.volley:volley:1.0.0'\n    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n}\n```\nI am testing on nougut device: but my intentservice is not called after specified time.\nNote: after running app first time, when oncreate completes, i remove application from memory.\nSame i have tried with reboot.\nPlease guide me how to debug or investigate it further, i will be very thankful to you.. ",
    "nghlong93": "Thank you for your anwser.\nI will try and inform you ASAP.\nLong. Hello,\nAs your suggestion in the guide, I have migrated to WorkManager.\nHowever, I'm so confused about the result of the work. I make a periodic work. Do the work repeats if I return Result.FAILURE?\nThank you very much,\nLong. ",
    "nitinsethi86": "@vRallev Can you confirm the file names? \nevernote_jobs.xml\nevernote_jobs.db. ",
    "dineshmm23": "Closed .since the big is fixed. ",
    "slole": "Ooooh, I didn't even notice that I have to extend the DailyJob class instead of the Job class. Thanks fo the quick answer, but I discovered that jobs get canceled upon swiping away the app, so I switched to firebase's implementation for handling my background tasks. Now that I know what was the problem, I will definitely consider using android-job for my future projects. . ",
    "shivam-mygate": "facing similar crash for PlatformAlarmService\nFatal Exception: java.lang.RuntimeException: Unable to start receiver com.evernote.android.job.v14.PlatformAlarmReceiver: java.lang.IllegalArgumentException: No such service ComponentInfo{com.mygate.user/com.evernote.android.job.v14.PlatformAlarmService}\n       at android.app.ActivityThread.handleReceiver(ActivityThread.java:3243)\n       at android.app.ActivityThread.-wrap17(Unknown Source)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1696)\n       at android.os.Handler.dispatchMessage(Handler.java:106)\n       at android.os.Looper.loop(Looper.java:164)\n       at android.app.ActivityThread.main(ActivityThread.java:6545)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:857)\nCaused by java.lang.IllegalArgumentException: No such service ComponentInfo{com.mygate.user/com.evernote.android.job.v14.PlatformAlarmService}\n       at android.os.Parcel.readException(Parcel.java:2009)\n       at android.os.Parcel.readException(Parcel.java:1951)\n       at android.app.job.IJobScheduler$Stub$Proxy.enqueue(IJobScheduler.java:211)\n       at android.app.JobSchedulerImpl.enqueue(JobSchedulerImpl.java:53)\n       at android.support.v4.app.JobIntentService$JobWorkEnqueuer.enqueueWork(JobIntentService.java:343)\n       at android.support.v4.app.JobIntentService.enqueueWork(JobIntentService.java:1523)\n       at com.evernote.android.job.v14.PlatformAlarmService.start(PlatformAlarmService.java:47)\n       at com.evernote.android.job.v14.PlatformAlarmReceiver.onReceive(PlatformAlarmReceiver.java:55)\n       at android.app.ActivityThread.handleReceiver(ActivityThread.java:3236)\n       at android.app.ActivityThread.-wrap17(Unknown Source)\n       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1696)\n       at android.os.Handler.dispatchMessage(Handler.java:106)\n       at android.os.Looper.loop(Looper.java:164)\n       at android.app.ActivityThread.main(ActivityThread.java:6545)\n       at java.lang.reflect.Method.invoke(Method.java)\n       at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)\n       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:857)\nProguard rules: \n-dontwarn com.evernote.android.job.gcm.\n-dontwarn com.evernote.android.job.GcmAvailableHelper\n-dontwarn com.evernote.android.job.work.\n-dontwarn com.evernote.android.job.WorkManagerAvailableHelper\n-keep public class com.evernote.android.job.v21.PlatformJobService\n-keep public class com.evernote.android.job.v14.PlatformAlarmService\n-keep public class com.evernote.android.job.v14.PlatformAlarmReceiver\n-keep public class com.evernote.android.job.JobBootReceiver\n-keep public class com.evernote.android.job.JobRescheduleService\n-keep public class com.evernote.android.job.gcm.PlatformGcmService\n-keep public class com.evernote.android.job.work.PlatformWorker\nIn final merged apk manifest I can see PlatformAlarmService entry:\n\n    <service\n        android:name=\"com.evernote.android.job.v14.PlatformAlarmServiceExact\"\n        android:exported=\"false\" />\n\n    <receiver\n        android:name=\"com.evernote.android.job.v14.PlatformAlarmReceiver\"\n        android:exported=\"false\">\n\n        <intent-filter>\n\n            <action\n                android:name=\"com.evernote.android.job.v14.RUN_JOB\" />\n\n            <action\n                android:name=\"net.vrallev.android.job.v14.RUN_JOB\" />\n        </intent-filter>\n    </receiver>\n\nLib version: com.evernote:android-job:1.3.0-alpha06\nDevice manufacture - LAVA (Currently only for one manufacturer I am facing this crash)\nAndroid os version - 8 (oreo)\n. Occurrences: 3 users 19 crashes\nLib initialisation snippet:\n                JobConfig.setForceAllowApi14(true);\n                JobConfig.setApiEnabled(JobApi.GCM, false); // is only important for Android 4.X\n                JobConfig.setApiEnabled(JobApi.WORK_MANAGER, false); // wait for stable version\n                JobManager.create(App.this).addJobCreator(new JobCreator());\n. Thanks mourjan. I had also the same conclusion. This issue doesn't belong to evernote lib.. ",
    "jacobras": "It seems to work after all! Maybe I tried to often and the system decided to block/defer background jobs. I don't really have any idea, but right now the jobs are executed after a reboot so everything seems fine.. Beta05 is now also available: https://developer.android.com/jetpack/androidx/releases/work#1.0.0-beta05. Release candidate is now available! :) https://developer.android.com/jetpack/androidx/releases/work#1.0.0-rc02. ",
    "jaydangar": "@vRallev , Thanks Man, I got your point. I really appretiate your help. I have solved my problem with this \nDailyJob.schedule(new JobRequest.Builder(TAG)\n                .setRequiredNetworkType(JobRequest.NetworkType.ANY)\n                .setBackoffCriteria(BackOffTime, JobRequest.BackoffPolicy.LINEAR)\n                .setUpdateCurrent(true)\n                .startNow()\n                .setRequirementsEnforced(true), TimeUnit.HOURS.toMillis(1), TimeUnit.HOURS.toMillis(2));. @vRallev , I got your point. Let me tell you my scenario. I have created 2 Jobs which start Immediately and a separate Daily job which will gonna schedule from one of the 2 jobs which start immediately. I have Registered those 2 jobs inside JobCreator, but not the Daily Job. Do i need to register it inside jobCreator subclasss to run it? I have seen the Evernote db via File Explorer and it shows 2 jobs there which are registered via jobCreator subclass, but not that daily Job which is gonna sceduled via one of the immediately running Jobs. Will this daily job still be scheduled or not, I am unable to find that answer. . @vRallev , But without mapping of the daily job it runs/schedules as well. I have seen it being scheduled via logs. Please exaplain me that. I mean it gets scheduled via immediate Job from the code that i have written. So still i need to Add Daily Job inside the Jobcreator Interface to work it properly? is it unstable(might not work properly?)?. @vRallev , Hello sir, I want to run a specific Job if it's not running. I have seen this Method JobManager.instance().getJobRequest()  which gives me JobRequest If the Job is pending else null, But in this method the parameter is Job Id. How can i determine JobId for a specific Job By Tag? In Evernote-Job we set Jobs by TAGs and not IDs. please clear my doubt. Thanks in advance.. @fernandodeveloper, Yes, it's possible, but please don't use it for getting Location periodically instead go for fused location provider, it's easy to implement and practical for this kind of use cases. also, the minimum period required by Evernote-Job is 15 mins, so that constraint might also come into the picture. \nSee this arcticle to know more about fused location provider -> \nhttps://developer.android.com/training/location/receive-location-updates\nhope, this helps.. ",
    "JonasGe": "So it happens to every periodic task that the interval gets larger after less than a day and will eventually be so large, it will never run again?. ",
    "Pecana": "can it be becasue your project contains a mainactivity as laucher which does not implement:\n\nCan you simply add this line into the manifest as test ?. Hello, I found the problem, it is in the manifest, if you remove the \n<service\n            android:name=\"com.evernote.android.job.gcm.PlatformGcmService\"\n            android:enabled=\"false\"\n            android:exported=\"true\"\n            android:permission=\"com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE\">\n            <intent-filter>\n                <action android:name=\"com.google.android.gms.gcm.ACTION_TASK_READY\"/>\n            </intent-filter>\nIt will work , i guess it is probably due to deprecation as described here \ud83d\udc4d \nhttps://developers.google.com/cloud-messaging/android/android-migrate-fcm\nIn my case I don't nedd the Google Cloud Messaging so removing the service from the manifest did the trick !\nHope this could help someone else :-). ",
    "mkaflowski": "I think that can be the issue:\nhttps://issuetracker.google.com/issues/116296569\nIt should be fixed in alpha10.. ",
    "chlegou": "following this , i have found that it's for the strict mode when debugging in the App class, so i commented that code out, and worked like a charm.. Without context parameter? should it work perfectly? \nOnce created, will it reschedule pending schedules (who are scheduled before killing the app)? or shall i reschedule all my schedules?. OK, please rely it with the related issue, so i keep track it in the future. ",
    "blocha": "You can use Dagger2 to initialize JobManager. Like this:\n```\n@Module\npublic class JobsModule {\n@Provides\n@Singleton\npublic JobManager provideJobManager(Application application, SampleJobCreator jobCreator) {\n    JobManager jobManager = JobManager.create(application);\n    jobManager.addJobCreator(jobCreator);\n    return jobManager;\n}\n\n@Provides\n@Singleton\npublic SampleJobCreator provideSampleJobCreator(NewContentService newContentService) {\n    return new SampleJobCreator(newContentService);\n}\n\n}\n```\nAnd then Inject JobManager in one of your \"beans\" to initialize it, or just load it eagerly.. ",
    "freewheelnat": "Thanks very much for your quick reply.\nIt's logged when trying to run a job scheduled using the library, but I guess it's a problem with the JobScheduler, not the library itself. What makes it hard to understand is that it is intermittent.\nWhen it's logged though, the jobs don't run, so I was hoping you may have seen it before and would have an idea of what this message means? Stack Overflow and Google not really being helpful.... ",
    "mourjan": "my app (not using this library) is also facing the same problem and I too do not have a LAVA device but if I may add, I called one of the users who have a LAVA device and suffering this crash and his response was: \"After installing the app everything works perfectly, but on second launch it crashes and he would re-install it once again for it to work\". it is 100% related to LAVA software's hierarchy and I tried to contact LAVA's software development team without any luck.. ",
    "taimur38": "Wiki seems to be gone. ",
    "AlexKnyazyk": "I have the same problem. \nD/PlatformWorker: Run job, request{id=1, tag=PedometerWakeupJob, transient=false}, waited 00:10:30, interval 00:15:00, flex 00:05:00\nI/JobExecutor: Executing request{id=1, tag=PedometerWakeupJob, transient=false}, context VhpApplication\nD/PedometerWakeupJob: onRunJob()\nI/JobExecutor: Finished job{id=1, finished=true, result=SUCCESS, canceled=false, periodic=true, class=PedometerWakeupJob, tag=PedometerWakeupJob}\nD/PlatformWorker: Finished job, request{id=1, tag=PedometerWakeupJob, transient=false} SUCCESS\nE/AndroidRuntime: FATAL EXCEPTION: pool-1-thread-1\n    Process: com.copes.android.dev, PID: 25691\n    java.lang.NoSuchFieldError: No field SUCCESS of type Landroidx/work/ListenableWorker$Result; in class Landroidx/work/ListenableWorker$Result; or its superclasses (declaration of 'androidx.work.ListenableWorker$Result' appears in /data/app/com.copes.android.dev-1/split_lib_dependencies_apk.apk:classes86.dex)\n        at com.evernote.android.job.work.PlatformWorker.doWork(PlatformWorker.java:56)\n        at androidx.work.Worker$1.run(Worker.java:84)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)\n        at java.lang.Thread.run(Thread.java:760)\nBut i use regular child class, extends from com.evernote.android.job.Job.\nAfter completion of the job this crash happens.. ",
    "tiwiz": "Closing as it is already covered in PR #575. Amazing, I'll update the PR tomorrow, I'm sorry for the delay!. "
}