{
    "goodwinnk": "I moved your commit to master repository. Did it manually because didn't want unnecessary merge (654c79e) be in history. According to Send pull request GItHub will monitor any additional commits pushed to the pull request\u2019s branch and it's better to create separate branches for fixes.\n. Of course, everything that can make sense :)\n. So this commit is now in master! Congratulations!\nBut at the same time it should be clear that it's a temporary commit for temporary code. There will be someone who prefers to have no space before colon and even someone who doesn't put spaces at all. So in fact we need to create an number of options for managing all code styles and that's why all spaces between meaningful elements should be inserted with code formatter. \nFor a quick demonstration how formatter can help in solving this issue try to insert a line in JetFormattingModelBuilder class\n.between(FUN, PROPERTY).blankLines(1) // line 58\n.between(COLON, TYPE_REFERENCE).spaces(5) // to insert\nSo in fact I can't close KT-1378 right now.\n. Ok, nice, thank you. Certainly there will be more tasks concerning project view in future and we can defer other refactorings until then.\n. Ok, nice! Merged!\n. Sergey, thank you for this pull request, and I hope you will finish and resend it.\n. I'm afraid, that it's not possible. In fact we will need even more knowledge about imported item because there can also be traits and properties. The possible solutions are to give pairs FqName + Info as import suggestions or try to use PsiElement as a base for every import.\n. Hm... As there will be different items (also interfaces, enums, properties, traits) I think it's OK to title import popup \"Imports\" and don't specify what entities these imports are :)\n. Sorry for delay in processing this.\n. Sergey, won't you mind to add some tests for this?\n. It is not hard. I could be done by analogy to files in idea\\testData\\codeInsight\\overrideImplement and adding a new method to OverrideImplementTest class.\n. Have just you merged your request with slight modification. Found that processTail moves caret by itself.\nThank you!\n. Oh my! Many thanks for noticing it!\n. Thank you! Simple but needed patch. \nI also did couple of test for it to prevent this feature brake in future.\n. Thank you!\n. Sergey, can you please let me know when you're ready with it, so I could check updated version promptly?\n. There are some notes I wrote in comments and also think that both fix classes could be refactored a little, but in general this is a nice pull-request. I'm gonna apply it so we could continue working on it together. Many thanks!\n. In fact it is not fixed yet as my commit solved a different problem. There're still two intentions for tt!!.other() code and I'm going to merge your pull request a little bit later.\n. Sergey, sorry for a delay. I finally merged your pull request today with this commit https://github.com/JetBrains/kotlin/compare/62ff95205c...83d0e8ebb5.\nI had a think about it all and decided to move processing of !! call to separate class. Hope it will sometimes help with creating quick fixes for val a : Int? = 12; a + 12 situation.\n. Thank you for your help!\n. This pull request contains NullPointerException problem.\n. I answered in line comment here: https://github.com/crazyproger/kotlin/commit/13f2d01b366ac7f8ba5e18b9e8a65243daa5bc35#idea-src-org-jetbrains-jet-plugin-codeinsight-overrideimplementmethodshandler-java-P4\nThank you for being  persistence with this deceptively simple request!\n. Vladimir I have just accepted you commits. There were some minor notes during review but in general you did a great job! Thank you! Renewed override/implement dialog with icons looks cute.\nThe only thing I would like to ask you for future is to avoid mixing reformat and meaningful changes in the same commit. It's difficult to understand what was really changed and what was just moved around. \n. Finished with this. I've just merged your last commit with fixes into master. Thank you.\n. As far I can see after a quick review, your fix looks good. \nCould add a couple of tests for this functionality? This can be done rather quickly for override feature with the help of OverrideImplementTest class.\n. Ok, I'm going to accept the patch, and will check if early body assignment works as expected later. \nThank you for help!\n. Merged, thank you.\nI also edited commit to remove overriding of the getText() method, so don't be surprise :)\nAnd I didn't expect that it will be so simple fix too.\n. Vladimir, this pull request is fine. I'm going to merge it after Andrey is ready with his fixes to KotlinLightClassForExplicitDeclaration. Expect it will be done in two days.\n. Merged in 99aee736d11084f459eacfe75897269ac64f8268.\nThank you for this patch.\n. Nice commit. Thank you for contribution.\n. Accepted, thank you.\n. Please fix the the warnings and the mentioned bug. An additional test is expected showing the bug was eliminated.\n. Cool feature! Thank you for contribution, I've merged it manually.\n. In fact I was trying to remember an exact reason for introducing ASTAlignmentStrategy while was reviewing your code. Unfortunately I haven't got a flashback about why I did so. \nProbably there were two reasons for the change. I expect that I tired of getting ElementTypes from the node and the parent and wanted to abstract it somehow. I hope that the second reason was a conclusion that strategies should be context dependent.\nHope this will help.\n. Accepted, thank you. Only one minor note about formatting for future. We place \"else\" keyword and right brace on different lines, like this\nif (condition) {\n}\nelse {\n}\nI did this fix in your commit.\n. Accepted, thank you.\n. Please fix the mentioned problems\n. Thank you for this pull request, but I think some improvements can be done with this commit.\n. It's almost done, but invoke() method can be tweaked.\n. Generally this is a good and well-tested work. But I expect there was a misunderstanding. A compiler time warning is too much for extra parentheses that one can want to add for make code more readable and obvious.\nThere should be only an IDE-intention for removing useless parentheses and front-end should not know about it anything. See the Java plugin example: \n\n. I merged it manually. Thank you!\n. I expect two last commit are from other pull request and I didn't examined them. Only a minor bug was found and I hope it won't be a big trouble to fix it.\n. Accepted, thank you.\n. Merged manually. Thank you for contribution!\n. Thank you for contribution! I've just merged it manually with minor formatting corrections.\n. A good pull-request, which I believe is almost done, please fix the mentioned remarks.\n. I'm sorry for the quite delayed feedback. The fix is important and will be accepted, but I would like to propose to squash the commits because the latest three are fixes for the first one and to fix mentioned problems with string comparison.\nPlease let me know if you're out of time for doing corrections, I will probably be able do it myself.\n. Extracting method could be done better :)\n. Your commit is merged in. Thank you for contribution!\n. Thank you for contribution. Hope that nobody uses wrapping already written variables and expressions massively:\nval something = 12\nval a = \"$<caret>something\"\nOr this small feature will need further adjustments :)\n. I have just accepted you commit, so thank you for contribution!\nOne important note, about quoting in batch files. I found that quoted parameter didn't work because of quoting \"time\" and \"notime\" constants, so there was a check between \"\"time\"\" and \"time\" which didn't work. \nUsing undefined variable without quotes in \"if\" makes the script fail, so I returned quotes in checks and remove them from string literals in variable assignment.\nSorry for misleading you. \n. I have accepted the request, thank you. One thing I've added is a testTypeStringTemplateStartWithCloseBraceAfter() method with a little bit simplified but important test case: \nfun test() { \"$<caret>\" }\n. Some problems are revealed, please try to solve them or let's discuss them.\n. Hello Jayson, \nThank you for contribution. I was going to accept it with a adding several annotations to JetTestNgConfigurationProducer.java and removing unused methodLocation (there're warnings at those places), but found \"libraries/lib/testng-6.8.jar\" added without any usage. Could you explain the reason why it was added or it was commited accidentally?\n. I see, thank you! I have just accepted your commit with small modifications. I removed testng-6.8.jar and added several annotations to JetTestNgConfigurationProducer.java\nThank you for contribution.\n. Thank you!\n. Thank you. Good commit, but some improvements are expected to be done.\n. Please also check cases when get has explicit type arguments or last argument is lambda function.\n. Although only minor fixes are left, I think another iteration should be done.\n. Please comment when you are ready.\n. Thank you. This task is accepted.\n. Overall I'm ready to accept this pull request, because it removes obvious errors from the code, but let's discuss maybe it is possible to improve those commits by fixing relative code while you have latest knowledge about it.\n. Well done, thank you. Special thanks for good commit splitting, it was very convenient to review them. There were some minor remarks, but I decided to fix them myself to avoid another iteration. Still please pay attention to those comments in future pull request.\n. Please leave a comment when you're ready for new review.\n. I fixed found minor notes by myself to avoid another round of review, so your changes are in master now, thank you :)\n. > For some reason, the former currently only works in the IDE itself and the test itself is failing. For some reason, the programmatic rename is not finding any usages of the parameter. \nEach test for intention emulates IDE environment, it creates project, register plugins and other components in test setUp(). Currently it creates java project with some subset of JDK and fills it with one kotlin file. ReplaceExplicitFunctionLiteralParamWithIt test doesn't register Kotlin standard library, so compiler isn't able to resolve filter() function and doesn't know that it has one parameter. So no usages found.\nYou can add some function with lambda to your test data, and this will probably solve your problem.\nAnother good thing to do is to add analog of QuickFixActionsUtils.checkForUnexpectedErrors() for intentions test to be aware about such problems.\n\nI also had to subclass RenameProcessor to do the removal of the parameter list afterwards (since the rename might be done asynchronously), which is probably not the best solution.\n\nI don't know a better way.\n\nAlso, the tests for the other transformation are a bit incomplete since I'd need to communicate with the interactive renamer somehow.\n\nWhat kind of communication do you need?\n. Don't hesitate to ask more questions and please comment for another iteration. \n. Please fix new notes and rebase onto master. Leave a comment when you're ready.\n. I really thought it would be last iteration, but another revision is needed.\n. I've decided to accept this pull request with some modifications. There was a misunderstanding after last review. I didn't mean to remove activation of \"Replaces the explicit parameter with it\" from parameters usages. I wanted isAvailable() be more accurate and don't call heavy 'resolve' when result of the method can be predicted from PSI only. luckily I had a copy of your previous commits and merged them with current version. See the result in master.\nAlso I have found another more interesting problem with this intention:\nkotlin\nfun foo(p: Int, a: (Int) -> Int): Int = a(p)\nval x = foo(2) { foo(1) { <caret>t -> t + it } }\nYou can't remove parameter if there are usages of some external it variable.\nWould you mind to fix it?\n. I'm afraid that the most relevant thing I've found is PsiSearchHelper.processElementsWithWord(). Another way is to iterate through all references in function literal and check none of them has 'it' name. It can be done with JetVisitorVoid, please take a look to KotlinImportOptimizer to get an example.\nThis task is interesting because as far I know there're no similar code in our project :)\n. KT-4807 documents the issue left unsolved.\n. Merged manually\n. Merged manually\n. Of course tests for recursion line markers should be added. I think it's OK to rename OverrideImplementLineMarkerTest to something like 'LineMarkersTest' and probably rename some existent files to make more evident, that they're testing override/implement markers. If you want to avoid adding test methods manually you can think of adding those tests to GenerateTests.kt generator.\n. I'm sorry but I didn't noticed this pull request had been updated while I was on vacation. I think it's OK to ask about pull request status if there's no activity for three days.\nTwo major things left for this PR. Please be more accurate in selecting elements for recursion call check and see RecursiveMethodCallMarkerInfo to fix issue with breakpoints.\nI'm going to close this pull request, please open a new one when you're ready.\n. I suggest extracting commits 1, 2 and 4 to separate pull request, because they are almost ready to push, and continue work with commit 3.\n. Merged manually. Thanks!\nI did some modifications in converted file. Several !! were removed where warnings were reported.\nThere was another interesting commit to fix compilation on build server. Please, see the commit message for more details.\n. Please add tests for updated behavior and add another pull request when you are ready.\n. Nice pull request. Please fix mentioned issues with separate commit and leave a comment when you're ready.\n. The review is finished. The pull request is good, thank you. To avoid another iteration I decided to rebase and squash your commits myself. I did some changes in intention during review. The most important one is use of KotlinBuiltIns instead of \"kotlin.String\" magic constant. Commit is prepared (https://github.com/JetBrains/kotlin/commit/9dbc75196e18d8c469185a0a5a116edec2c25288) and I'm going to push it when we solve problems with our master branch.\nI was going to close KT-4750, but noticed that it mentions converting string template to concatenation. Do you have any progress in it?\n. I have finally pushed you changes to master. Thank you!\n. Commented in mailing list.\n. Merged manually with minor modifications. I did import optimize and inline for text varialbe (https://github.com/JetBrains/kotlin/commit/9679e3ce4aa3458463bfa321dd9158c40da89ccb).\nThank you!\n. Please rebase onto master, squash the commits and fix problem with \"if\" in template. Please consider rewriting your algorithm and make it more readable.\n. Thank you! I've squashed your commits into one and pushed it to master.\n. Merged manually\n. Merged without \"Minor: toString() for filter for better debug\" commit.\n. It looks like that idea core have usages for these extension points: https://teamcity.jetbrains.com/viewLog.html?buildId=473986&buildTypeId=Kotlin_CompilerAndPluginBootstrapNoTests&tab=buildLog\n. Pushed to idea_continuous/br142, commit.\n. Looks good to me.\n. Pushed manually.\n. Pushed to master\n. Merged, thanks\n. Thank you for this contribution, and sorry such a long review process.\nAfter some discussion, we have decided to leave current behavior unchanged. I have left a comment explaining this decision at the ticket: https://youtrack.jetbrains.com/issue/KT-11143#focus=streamItem-27-3212804-0-0.. @yarulan I did an improvement that allows auto-close when user types ${ and insert only { before identifier otherwise. This allowed me to accept this PR as https://github.com/JetBrains/kotlin/commit/30c2b26339e77c59d344e1d22bbca7aaebfd8b59. \nThank you for the contribution!. @VladRassokhin Do you see an effect from adding '\\n' to placeholder text in editor?\n. Great, thank you! Merged with addition modification in SmartEnterTest.\n. Great, thank you!\nThere're slight modification I would like to add to your commits, please check the following links:\nhttps://github.com/JetBrains/kotlin/commit/f1ba3dca5fc983ab45c14d1e4dce5bfd273997df\nhttps://github.com/JetBrains/kotlin/commit/235fd18a07e2f2b6f6e5a43b902f3dce5e2dd168\nOur buildserver revealed 4 broken tests after changes in infix call formatting, as it now works better, I've just update test data. I've also added notes about changes to ChangeLog.md and modified commit messages a bit.\nPlease review the changes and give me know if everything is fine. \n. Merged manually, thank you!\n. Merged manually with tests modification, thank you!\nhttps://github.com/JetBrains/kotlin/commit/5c68681f962334bf58785346b3f48c909309ffe6\nFeedback will be very important on this change because interesting corner cases are affected:\nsynchronised (obj) {}\nwith (s) {}\nMaybe some options or advanced logic will be required in future for these cases.\n. All changed are merged manually, thanks!\nThere was a test that had revealed problem with an unconditional placement space after a semicolon (https://teamcity.jetbrains.com/viewLog.html?buildId=802099&tab=buildResultsDiv&buildTypeId=bt345). \nI have fixed it with this commit f8196d8331eaf2d19c7d34ec63948844206411ff.\n. Accepted with small modifications in commit message and ChangeLog.md. Thank you!\n. Merged manually with slight modifications (in ChangeLog.md and commit message) into master and 1.0.4.\nThank you!\n. Merged manually to master and 1.0.4 branches with minor modifications in ChangeLog.md\nThank you!\n. Please add a test for suppression action availability. https://github.com/JetBrains/kotlin/blob/master/idea/testData/quickfix/suppress/declarationKinds/class.kt file can be used as example.\n. Great, thanks! The fix is now merged into 1.0.4 and master branches.\n. Hello! Your changes were merged manually after some heavy refactoring: https://github.com/JetBrains/kotlin/commit/06dad5f45baa960d80fbdc476513d676347bf91e. Please try to do movement refactorings and Java to Kotlin conversions beforehand to make relevant changes more obvious. \nThank you!. @yole Wrapping is out of the scope of KT-7718. The fix looks valid to me, I going to test it on buildserver to see are there any accidental test fails in other test groups.\n. Merged manually into 1.0.5 and master branches with slight modification in commit message and test.\nThank you!\n. The spacing between label and comment is modfied when there're several lines. Please test it the the following code:\n``` kotlin\nfun test3() {\n    block@\n/*comment*/ {\n\n}\n\n}\nfun test4() {\n    block@\n//eol comment\n{\n\n}\n\n}\n```\nI would suggest to use 'betweenInside(LABEL_QUALIFIER, EOL_COMMENT, LABELED_EXPRESSION).spacing(0, Int.MAX_VALUE, 0, true, settings.KEEP_BLANK_LINES_IN_CODE)' or remove custom rules for the comment cases.\n. Merged into master, thank you!\n. Hello @cypressious! Thank you for the contribution! \nWhile it's nice to have a common solution for all affected keywords, I think the behavior should be restricted a to avoid unexpected behavior. \nWill you update the request?. Sorry, I thought it can be reopened from both ends :). I merged it to master with a very small change in handlerUtils.kt, we have a code guide rule to format if-else as\nif (condition) {\n}\nelse {\n}\nThank you!. It looks with the change in this line https://github.com/JetBrains/kotlin/blob/f6b805a973cd35eef695efdc8f985b7befc75371/idea/idea-jvm/src/org/jetbrains/kotlin/idea/configuration/KotlinWithLibraryConfigurator.kt#L330, this is all that left from this pull request https://github.com/JetBrains/kotlin/commit/e36b1037bbbabf84cba5083772f7e0eabb0c0e29. \n@dmitry-zhuravlev Can you please confirm that it will be enough? . I have pushed the commit to master: https://github.com/JetBrains/kotlin/commit/ab259c2d6faca987009e6fccd6b43e71b118977e.\nThank you for the contribution. . Thank you for the update.. Merged as https://github.com/JetBrains/kotlin/commit/5aa7216c13f83e7a2ef0df8e0ded638615cbd012 with small corrections.\nThank you!. The was no activity in this pull request for a long time. Please reopen the request when it's ready. . I think nullability issue with KotlinIfSurrounderBase.getRange() the only thing that left. Would you mind squashing intermediate commits?. I will merge the changes after a remote run, thank you!\nI also did some follow-up refactorings, please, take a look at https://github.com/JetBrains/kotlin/compare/rri/nk . Thank you for the contribution! Your commit was merged manually and now is in master:\nhttps://github.com/JetBrains/kotlin/commit/6f350c032d51a995028eb7fb695d82a5cfe51638\n. Thank you for this pull-request. I see this commit more like a framework, but I don't think it's a good idea to merge it to master at the current state. Current message \"It is modifier\" doesn't explain anything, and I think does more harm. \nAlso defined in should be removed for keyword documentation.\nI would suggest to select some modifier and write a fully functional prototype for it and disable the feature for other modifiers.\nI'm closing this PR for now, but feel free to open a new one, if you decide to continue working on this feature.. I think implementing the feature for one or some subset of modifiers will make the change immediately valuable and independent from any further work. Reading documentation for some external source is appealing idea but may postpone the actual implementation significantly (actually already did :( ). \nP.S. I didn't expect such a fast answer after a year this PR is inactive. If you want to continue your work, I'm ready to reopen it. . I like an idea to start from lateinit or tailrec, and leave other keywords for future contributions. \n\nI believe what I will need to do is adding cases to this line https://github.com/JetBrains/kotlin/pull/1435/files#diff-d9206ebe78be3db8c8e3f9ac8aaac3c0R230\n\nYes, it would be enough for now.\nAlso please can you investigate removing defined in part, as it a bit misleading for keywords?. > This is the test case for quick doc of the variable name lateinit, not keyword.\nI see now thank you, there's no need to remove it than.. Nice! I'm going to accept it after the remote run. The only thing I noticed are very long string literals, but I'm going to refactor them in this commit https://github.com/JetBrains/kotlin/commit/685659164b8138b9046f9071927fa09e327b12a9.. Done, your commit is in master (https://github.com/JetBrains/kotlin/commit/d3895c519ce6502380ad9e5da0fe1a20df031cfd). \nThank you for the contribution!\nI forgot to say that it's a profound idea to use links to articles with more information.. I have updated state in https://youtrack.jetbrains.com/issue/KT-9934. Technically it's still open. . Nice work, thank you!\nI have merged you commit manually: 9fad40b5862868e82d35b8b61de1592c4ec621eb.. Hello, thank you for the contribution!\nI would like to accept the change, but could you please merge two commits into one. It's proved to be useful when main changes and corresponding tests are in the same commit.. I have merged commits once again and added a directive for YouTrack to commit message so it could link the issue with the commit.\nThe final commit is now in master: 809cc220edd5316bee37880584041d41461391b4.\nThank you!. Thank you for the contribution!\nI'have squashed and merged your commit manually: https://github.com/JetBrains/kotlin/commit/8252b35ed5f5bb457b3c0744219bf2a5f5e27e47\nThere were several issues with the change, that I've decided to fix right away with https://github.com/JetBrains/kotlin/commit/af930b8364e99a84c1f51a5ae09427bde16974f9:\n - Backspace insertion tests didn't start. Please use \"Generate All Tests\" to generate test methods.\n - Closing triple-quote was added in this scenario: val test = \"\"\"\"\"\"<caret>.\n - testAutoCloseRawString didn't work.\nThank you, I'm really glad this old issue is finally closed!\n. Thank you! I have merged both commits into one: 4232ad8dfe2b6cef732be6a31cbbce1fa5b93b75.. Thank you!\nI have merged commits into c06aaf6128c8d51211a05c075554534c077fb35f.. Great, thank you!\nThe commit is now in master: 7e417272b2bfd6c89f9f6cc0377c6f6e0a378fa2.. I have created an issue about this proposal, with the list of additional connected task: https://youtrack.jetbrains.com/issue/KT-29346.. Would you mind merging it into one commit?. What exceptions are meant in commit message? Are they for Kotlin plugin? \nI think \"Do not use hardcoded plugin ID for update checks\" would be a better name, and some explanation why this is needed would be nice.. Merged manually as 53946456cfe90100f1ffc4af9a0eefe5a60b2a35. Thank you!. Awesome! Thank for the fix and great commit description. I'm going to accept the commit with a modified title: \"Hitting breakpoint in Kotlin sometimes doesn't work (KT-22205)\".. This pull request is merged manually: 94ee78c0ca321274cf87f81bf74e8eefde1ddcf1, thank you!\nActually, more investigation is needed from our side to check other places for the same problem.\n. Thank you for the contribution! I have merged it manually as https://github.com/JetBrains/kotlin/commit/d3b1b7a5be1a69e5b3b4bdcf7a2dbd311e5a144b.\nHave you used some analysis tool to find it? . Ok, thanks! Just thought that there might be some other interesting results :). Thank you and sorry for the delay in review!\nI have merged your commit as 9d6b36c2496c6b3816166b5185e24f4a114cb357.\nYou should have probably converted the file to Kotlin first :). Great, thank you! I have accepted the change with the message modification (it's better to place ticket number at the message end for readability).\nhttps://github.com/JetBrains/kotlin/commit/3f96e1dabc5db7973c49dc7bff3cba42d5a8a7e3. Merged as https://github.com/JetBrains/kotlin/commit/f3bb952148b3dd5ea029e30f5ca8fbdf9c0e30c7. Thank you!. Thank you for the contribution and sorry for the long review! I have merged your commit manually as https://github.com/JetBrains/kotlin/commit/e6de8e9cd34111ced09f0cf7e7e7c9051f246302.\nI have also added some follow-up fixes, that might be worth to take a look for future contributions: https://github.com/JetBrains/kotlin/commit/d3ec145f13db47e5668c356425b196351f6997db.. Thank you! Your commit was merged manually as https://github.com/JetBrains/kotlin/commit/c1f43558b98b383220dd75f3c088d96387c548da.. Thank you for the first contribution to Kotlin project! \nI have accepted your commit manually: https://github.com/JetBrains/kotlin/commit/3a83983bfcc2f96acf1867c5ff3ebb06c83d82a9\nI'm sorry for the long review process. I'd decided that it's unfair to ask for additional changes after almost a month from the pull request so I did review commit myself: https://github.com/JetBrains/kotlin/commit/b6699d7522fc6844a57ab2b6fd5950de1a0ed6d5.\nYour commit was great and fixed the issue, but  there're still several important things that are worth mentioning for future pull-requests:\n - analyze() call can be very time-consuming, and should be performed when all other light-weight checks (psi, context) are done.\n - We're trying to avoid direct dealing with BindingContext. Usages of KtReference.resolveToDescriptors(), KtReference.resolve() or methods from resolutionApi.kt are preferable.\n - It's better to have tests for different non-trivial cases that you've faced during writing the code.\nI have also changed logic of the fix a bit. An ideal solution would be to enable folding arguments for all single-parameter vararg calls. But I've decided to leave only predefined set of names for now, to get a quick check and avoid analyze in folding feature for most calls. We will see if there are requests for other functions.\nAgain, thank you for the contribution!\n. This is now obsolete, so I'm closing it. In general, please avoid creating pure refactoring pull-requests, especially when refactoring doesn't significantly improve the existent code, as it gives a little value but adds an additional overhead for repository history.\nThanks for the PR, nevertheless!. Sorry for a long review, and thank you for the contribution.\nCommit was merged manually as 90be6235f758d28f62334d0588972126dc2e5d4c.. Merged as  https://github.com/JetBrains/kotlin/commit/5aa0b7d2aaca26defb4c173c755ae02dd95b2a93, thank you!. I have accepted commit with reformatting already. . I'm afraid, that the original request wasn't correct. It was a wise for inspection to check usages before reporting. Please take a look at this example:\n```\nclass Test(val str: String) {\n    private fun Test.print() {\n        println(str)\n        println(this.str)\n        println(this@Test.str)\n        println(this@print.str)\n    }\nfun test(test: Test) {\n    test.print()\n}\n\n}\nfun main(args: Array) {\n    Test(\"one\").test(Test(\"two\"))\n}\n```\nIt was unfortunate that there were no tests for this situation, and I think only they should be commited as result. \n. The original request might be still valid, but change signature should not be used as a fix, as for this case it's an error to remove the receiver at call place. \nThe inspection should still be inapplicable if there's an access to surrounding this via label this@ClassName.. Wow, it was very fast fixes! \ud83d\ude80 \nI have squashed your commits and pushed them to master as e7a9614fb5eab5f1ed45ee8760566a0c53f8a954. \nAs a follow-up commit, I have removed runtime usage for tests in fdc6372776b187ec4a08cb73f2b0b2d1630b2765, generally it better to avoid it, if it's not relevant for a test.\nThank you for the contribution!\n. @andreyfomenkov Thank you for the fixes! I think at this point code would be ready for the push.\n\nwe should keep kotlin.Generated class because without it annotation processor gives NoClassDefFoundError when running tests on Android;\n\nI'm sorry, I was wrong about it. I didn't think about annotations processors at the moment of commenting. An absence of the annotation class file will probably also cause a warning from the proguard tool. So you're absolutely right, the annotation must be kept.\nBut there's a problem. After an internal discussion, we have decided that such annotation should not be added to Kotlin runtime till other ways of resolving coverage problem are tried (I added some reasons behind this decision in this comment: https://youtrack.jetbrains.com/issue/KT-18383#focus=streamItem-27-2890396-0-0).\nI'm still hoping that this pull request can be partially reused (the commit and authorship will be preserved in the log in that case) for writing a compiler plugin if it would be necessary.\nI'm very grateful for your effort as it practically closed one possible solution and I believe gave a great boost in future resolving the coverage problem issue.. Merged manually as https://github.com/JetBrains/kotlin/commit/18ed031e7e559d4de79dda045375f32c0593df1c. I've added additional check for index  is zero as CodeFragmentCompletionHandlerTestGenerated.testInsertImport  fails without it.\nThank you!. I have merged the fix as https://github.com/JetBrains/kotlin/commit/5564102a3e4c64213c2431776edeb783186f57a6. Thank you! . Merged as https://github.com/JetBrains/kotlin/commit/3f5a2c642732ec3c8ecae492815a0c4221b0e144.\nThank you!. Closed in favour of https://github.com/JetBrains/kotlin/pull/1711.. Hello, we may push an intermediate result to Kotlin repository if we agree on the general PluginUpdateVerifier extension structure. I've added some notes after reviewing dce30351ad14ffb5560cfaf87a6b2c9b5334f880 commit.. Merged manually, thanks!. @lsmaira Thank you for the contribution! \nI wonder if you have failure stack traces?. I have accepted the commit manually: https://github.com/JetBrains/kotlin/commit/5820656aaeb915edefecf7eba7b143c0bdf589d3.\nThank you!. That was an impressive tests coverage! I have accepted changes with minor modifications: https://github.com/JetBrains/kotlin/commit/9e83506c020d670f6244660206eb0e34bdfb9cf6.\nThank you!. This is finally in master as https://github.com/JetBrains/kotlin/commit/7aa195b017f7a5e4c636b25f3dab6f5bd5f7abf1\nThank you!. I have merged the commits manually as https://github.com/JetBrains/kotlin/commit/2547612d54b606858e0232796d7884cd0a3515d2. Thank you!. Thank you! Merged to master as https://github.com/JetBrains/kotlin/commit/c44d3a8d68ea2dabdde0f5f4c89c21bbf1a60d70.. It was a smart inspection reuse. Thank you!\nMerged as e409007749114edc2cec8c06e400acf827305cdc.\n. Great, thanks!\nI have merged it as https://github.com/JetBrains/kotlin/commit/ed9d53acaa013cfc9b9499f3a6a9bf0a8ede45f6 after updating test data in  KeywordCompletionHandlerTestGenerated.testCompanionObject test. . Have you used some tool for spotting those typos? I think it would be more useful to clean all such typos at once, than fixing them one by one. . Thank you, I'm going to accept this PR after remote run.. I have merged this pull request after small modifications (please disable organize imports for commits with spelling fixes) and squash.\nResulting commits are https://github.com/JetBrains/kotlin/commit/33961acb8d30b14961de0f9792dfa6fc8248e1ae and https://github.com/JetBrains/kotlin/commit/686cfa6fd29b8e096ea04a2b96e2dc08adced512.\nThank you.. Thank you!. Thank you for this contribution!\nYour commit is now in master: https://github.com/JetBrains/kotlin/commit/827e04ae3e1dd436c5ba7f409e49918f027afe7c. The only addition I have done is adding a weigher test to test the order in completion list.. The was an internal review, so this PR doesn't show the actual status anymore.. Also I recommend to replace Omit -> Remove as it's going to be more consistent with other intentions.. I have merged commits after squashing and renaming. This is the result commit: https://github.com/JetBrains/kotlin/commit/185d0c61659c8c2855c27e102237e8cbb67cd7a9.\nThank you for the contribution!. I think it's not an expected behavior to reformat the whole declaration on modifier replacement. Can you narrow the applicability range to modifier only?. Did you do an investigation why this test is properly formatted without additional code?\n```\nannotation class A1\n@A1   \n     private fun test(a:     Int / check no reformat/) {}\n```\n. Great fix, thank you!\nI have merged it already as https://github.com/JetBrains/kotlin/commit/6f7830a4b2585bd517e725050f0722f74644136b with formatting check in primaryConstructor.kt test and test-data fixes in change signature tests.. Thank you for the contribution!\nI did only a quick overview, but as decapitalizeSmart is used from compiler, it means this might be a breaking change. Can KT-28485 be resolved for IDE only?\nAlso some tests are expected. Do you need help with writing them?. @Tiltorito @igorwojda Thank you for the contribution! I have pushed the commit to master as https://github.com/JetBrains/kotlin/commit/6ba134b1be3239920d264e0bac7e86c1c4dd6016 after squashing and humanizing commit message a bit. \nAlso please take a look at https://github.com/JetBrains/kotlin/commit/213b98fefe86b822063450c8432770cd1f97dfe9 commit with reverting compiler behaviour and adding tests that might be useful for future contributions. . Great commit, thank you! \nResulting commit is https://github.com/JetBrains/kotlin/commit/80e1fc2acefff3ee9ad345d7b0ee4cb48ff593b9.. https://youtrack.jetbrains.com/issue/KT-2387. Thank you for the contribution! I have relayed your commit to master with the commit message modification https://github.com/JetBrains/kotlin/commit/f1cc7cecceeffdfbc3a9ae5f4cbdf14a5245324d. . Thank you! Your commit in master https://github.com/JetBrains/kotlin/commit/7149d4cd1ce8e2dc423ee5b70db4979d6fec6b63.. Thank you for the contribution. This commit is now in master: https://github.com/JetBrains/kotlin/commit/bee7736bafa5875e281b16e7456628510f37b35d.\nI wasn't sure about simple constructor parameters, so did an additional check and left a comment:\nhttps://github.com/JetBrains/kotlin/commit/bee7736bafa5875e281b16e7456628510f37b35d#diff-423ce3b5ea52d59cd3946d4d4f82850aR237. Thank you for the contribution! I have relayed your commit to master as https://github.com/JetBrains/kotlin/commit/6acf3ad629329dfcf0bf4074b1ca0add2017e911. \nPlease let me know if you will find out how to resolve caret issue in tests. . I have added it as https://github.com/JetBrains/kotlin/commit/0acecb493651f97bce1c2a68105b0d8aad0a59e5. Thanks!. Thank you! Your commit was cherry-picked as https://github.com/JetBrains/kotlin/commit/dfd39478564459406c639d9095f18e1b0c2ab704 with a small fix in scripts check https://github.com/JetBrains/kotlin/commit/dfd39478564459406c639d9095f18e1b0c2ab704#diff-55ae7e03e0a32466e3603dba94628d58R104. Please use isScript() check instead of direct check of file extension. Also it's worth to check if some string literal is already declared as constant (STD_SCRIPT_EXT could be used). . Such spaces should be controlled by formater. An ideal solution should check state of \"Before colon in new type definition\" option or just reformat prepared template. The proposed solution does the right step and now we have a right behaviour with all default settings. \nSo this is now in master: https://github.com/JetBrains/kotlin/commit/fd262bcd8dd2cbfc8ba5c09577e645fb3588eb71. Thank you!\nPlease consider another PR witch will work for any code style. . Thank you for the contribution! Your commit is in master now as https://github.com/JetBrains/kotlin/commit/e1f26ffc74e420411db7752c33cffb3912e358b0.. Super! Thank you! \n(commit after relay https://github.com/JetBrains/kotlin/commit/e06514c945c47298789d5513fce66151b5140ef4). It's not very critical now, but I think that your decision to barter flat and simple structure of this method to one more iteration over parameters collection was a bad deal. Now it's really difficult to understand the logic of filling StringBuilder variables.\n. I expect this functionality will be under development for some time, so as I said it's not very urgent. There's also a check is element first or not. And it's always makes iteration over \"for\" to look ugly. So you can treat my comment as side note for future)\n. Two booleans in parameters almost always look bad because it's difficult to read such code. It's better to provide static constructors like ReplaceCallFix.toDotCall(), ReplaceCallFix.toQuestionMarkCall(), ReplaceCallFix.toExclamationCall(). Another alternative is to create and pass as parameter some enumeration.\n. I understand why you decided to create another class for that task but still think that there should be another logic in UnnecessaryNotNullAssertionFix and ReplaceCallFix. I propose ReplaceCallFix could also be used for replacing !!. call to something else as it can be used for introducing such calls now. And this class can could be responsible only for introducing and removing a!! postfix operation.\nWhat do you think?\n. Both quick fixes are available for this code snippet:\nfun test(value : String) : String {\n  return value!!.toString()\n}\nI suggest to forbid one from UnnecessaryNotNullAssertionFix if warning is in the middle of DOT_QUALIFIED_EXPRESSION.\nBy the way, Sergey, what tools do you use for monitoring PSI tree. I don't remember did I tell you about Tools->View PSI structure of current file?\n. There's a problem with removing PSI element this way. It looks like IDEA can't handle the region for update correctly. I'm going to debug and fix it. It can be reproduced with this chunk of code. After applying the fix idea shows errors in internal mode (with -Didea.is.internal=true in javac string).\nfun test(value : String) : String {\n  return value!!\n}\n. Almost right, but here's the way to do it without constant:\nif (leaf instanceof LeafPsiElement && ((LeafPsiElement)leaf).getElementType() == JetTokens.MUL) {\n}\n. There's a good rule to avoid introducing warnings in new code, so both which are highlighted in this code should be fixed.\nYou can use local variables and assert statement to express your knowledge:\nassert prev != null : \"A non-whitespace element should exist before super class declaration\";\n. Spelling: doign -> doing\n. eastlty -> easily\n. Maybe it's worth to mention default target for constructor parameters? Will it be parameter for simple parameters and for fields? \n. Shall we really allow omitting the non-default target in code? It's a clear message with quick-fix for a code writter and possible source of misunderstanding for a reader that can't be resolved without navigating to annotation declaration. And annotation target settings modification can lead to unexpected tools failures without any compiler messages on rebuild.\n. Do we need Name.isValidIdentifier() here at all?\n. Why getNextSiblingIgnoringWhitespaceAndComments() is needed? I expect that it is for 'for' keyword completion, but at least one test needed for it.\nI also think that there shouldn't be comments skipping.. I think it will be more safe to use == instead of startsWith(). The following a bit artificial snippet can be used as an example of unexpected behaviour:\n```\nfun other() {\n  try\n// Some\n  {\n    println()\n  }()\n}\n```\n. More natural example:\nfun other(a: Any) {\n  if<caret>\n  (a as Int).let { println(a + 12) }\n}. I think proposed fixes are great.. I see, thank you for the explanation.. This comments doesn't explain anything and can be dropped safely.. Please consider inverting if.. With lambda argument destructuring and isInstance method you could write this method as\nreturn this.parents.zip(sequenceOf(*parentClasses)).all { (elem, clazz) ->\n        clazz.isInstance(elem)\n    }. I think this restriction leaves the majority of use-cases out of scope. Can we overcome it? I'm not sure it all worth it without the solution.. Will it work with comments? Maybe it would be better to check for '=' and extend it with spaces from left and right.. Do we need scriptFilePattern in this restricted form at all? \n- IDE uses ScriptTemplatesProvider.filePattern that allows to determine scripts without loading script definition annotation.\n- There might be scripts of different kind that differentiate by full path or maybe content.. '\\n' can be removed here, like in KotlinTryCatchFinallyExpressionSurrounder.. There should be a statement check, otherwise there are too many \"try/catch\" items in simple cases like this\n```\nfun foo() {\n    fun call() {}\n<selection>call()</selection>\n\n}\n``\n. I think using sealed class for KotlinTryExpressionSurrounderBase could make 'as' cast here look less dangerous.. I'm not sure, but canKotlinTrySurrounderBasebe merged withKotlinTryExpressionSurrounderBaseso that if there's only one element and it'sKtExpressionit behaved asKotlinTryExpressionSurrounderBaseandKotlinTrySurrounderBaseotherwise? This way we could avoid potentially expensiveResolutionUtils.analyzecall, and also gettry/finally` for expressions.. There is an exception when if expression is also wrapped into brackets:\nfun foo() {\n    <selection>\"asdf\"</selection> + 1\n}\norg.jetbrains.kotlin.psi.KtParenthesizedExpression cannot be cast to org.jetbrains.kotlin.psi.KtIfExpression\njava.lang.ClassCastException: org.jetbrains.kotlin.psi.KtParenthesizedExpression cannot be cast to org.jetbrains.kotlin.psi.KtIfExpression\n    at org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinIfElseExpressionSurrounder.getRange(KotlinIfElseExpressionSurrounder.kt:35)\n    at org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinControlFlowExpressionSurrounderBase.surroundExpression(KotlinControlFlowExpressionSurrounderBase.kt:41)\n    at org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinExpressionSurrounder.surroundElements(KotlinExpressionSurrounder.java:65)\n    at com.intellij.codeInsight.generation.surroundWith.SurroundWithHandler.doSurround(SurroundWithHandler.java:204)\n    at com.intellij.codeInsight.generation.surroundWith.SurroundWithHandler$InvokeSurrounderAction.lambda$actionPerformed$0(SurroundWithHandler.java:297)\n    at com.intellij.openapi.command.WriteCommandAction$1.run(WriteCommandAction.java:252)\n``\n. I have found that there was an analyze call for getting expression type inKotlinExpressionSurrounder.isApplicablesing long ago. Ok than :). It looks likeisApplicableToStatements() == !isApplicableToUnit()is always true while there's separation to toKotlinExpressionSurrounderandKotlinStatementsSurrounder..KotlinIfSurrounderBase.getRangewill fail whenexpressionisnull.  .as? KtIfExpressioncan be moved our ofwhen.. Why we change recursive search to search among children? Do I miss something?. This is probably unneeded. If something is parsed asKtLambdaArgumentit won't be invalueArgumentList.. You're right about including/excluding logic forvalueArgumentList, but it's still enough to check thatKtLambdaArgument` is present.\nKtValueArgumentList contains only nodes with type VALUE_ARGUMENT, and if there's a KtLambdaArgument psi element, it means that there's LAMBDA_AGRUMENT, and lists sizes would differ. \nPlease take a look to KtCallExpression.getValueArguments() implementation. \nhttps://github.com/JetBrains/kotlin/blob/78e278ec4c2a6c012897910d3829eb0ddead65ab/compiler/frontend/src/org/jetbrains/kotlin/psi/KtCallExpression.java#L78 \nAlso all tests pass after function remove :). I have understood that it can be implemented as lambdaArguments().isNotEmpty() after lambdaIsOutsideBrackets() discussion.. In general, it seems to work fine. But can you come up with the better name for expand and collect functions, it's not clear what they do now? Also I would suggest rewriting expand and collect without recursion.. I've found KtPsiUtil.isStatementContainer as on of the usages for KtContainerNodeForControlStructureBody, can it be used here? \nAre checks for THEN and ELSE needed? It looks like parent instanceof KtContainerNodeForControlStructureBody should work for them too. . (callableDeclaration is KtProperty || callableDeclaration is KtNamedFunction) check is probably reduntant, as check is called only for such declarations.. I think origin test with this should also be added.. I'm afraid it works incorrectly for this test case: \nclass A {\n  fun String.foo() {\n    print(this@foo)\n  }\n}\nCan you please take a look if something can be done to fix it?. While it is might be beneficial to know if a function was generated or is present in a code (some IDE inspections can use this information), I would recommend removing it from this pull request. \nThe problem is that descriptors are used everywhere and usually are read-only after initialization. They are also expected to be serialized/deserialized to metadata, so descriptor retrieved from compiled code are equivalent to descriptors before compilation. \nAs current implementation violates all those implicit rules and uses isGenerated only for passing message inside JVM backend code, I'm sure we may avoid bringing it in for now.. It looks like in order to check annotation presence in coverage tool it's not necessary to have an actual implementation at runtime library. \nIt's enough to have a desired description:\nmv.visitAnnotation(\"Lkotlin/Generated;\", false);\n. I think there should be a general message and all specific have to come from the extension implementation. \nWe can change this message to\nform.setUpdateStatus(\n        \"<html>A new version $version is found.<br/>${pluginUpdateStatus.message}</html>\", false)\nand have Plugin is not verified by Android Studio prefix reported from the verifier.\nWhat do you think?. This way message can be very long to show it in UI, but still not long enough to understand what happened.\nAlso, I think it is worth to process http exceptions separetly:\nAndroid Studio verification failed: unable to connect to compatibility repository will be searchable and won't have irrelevant information about plugin version.\nIf there're unexpected errors, they can be written to LOG.error() with the full information.. I this message should have a common and reasoning part as a separate sentence. It might not flexible enough to have extensions contributing to the message, as you must change full message thinking about all possible contributors, and you have to write extensions with the full message in mind.\nAlso, it's now unclear who is responsible for the unverified result.\nI have prepared c31a6af98c4062723b7a61eaa3e94d5b623012d2 commit with adressesing these concerns. Can you please check if such solution suitable for you?\n. I think some minor fixes are still possible for exception handling.\nFor example, separate processing for MalformedURLException looks to be unneeded, because only a static URL is processed here.\nWhat's more important, is that IOException probably shouldn't have LOG.error() call, because it will be possible to send such messages through exception reporter. These errors can be caused by user local network settings and nothing can be done about them by authors of the code.. This test looks strange. Please try this example as well, the caret is shifted after smart enter, and it doesn't look as expected behavior. \nfun foo(i: Int) = 1\nfun test4() {\n    foo(1, <caret>\n}. Can you please try to remove the space between class name and (, otherwise result is not properly formatted.. >  if you do Make public, it becomes class Foo (x: Int)\nOh...\nYou may choose to fix the issue only for removing constructor intention, as other intentions lay out of scope for this PR. You may report found bug with Make public to tracker and decide if you want to fix it too later.\nOn the other hand if you see some general solution for both intentions I don't mind if it would be a separate commit fixing them at once in this PR. . This line is outdated. Please run Generate All Tests shared configuration, and re-run tests. LocalInspectionTestGenerated.java file is expected to be modified after this launch, and this change should also be commited.. Some additional tests. Please note, that there's no need to fix them all, some fixes may be postponed if the fix is hard. I think the one with exception is most important. A test with try/finally also should be added to the test suite. I don't like the one with false positive too.\n```\nimport java.io.BufferedReader\nimport java.io.File\nfun test1(args: Array, reader2: BufferedReader) {\n    val reader = File(\"hello-world.txt\").bufferedReader()\n    if (args.size > 2) {\n        try {\n            reader.readLine()\n        } finally {\n            reader.close()\n        }\n    return\n}\n\nreader.readLine() // Exception on fix apply\nreader.close()\n\n}\nfun test2(reader: BufferedReader) {\n    reader.readLine() // No warnings\n    reader.close()\n}\nfun test3(reader: BufferedReader) {\n    try {\n        reader.readLine()\n    } finally {\n        // Comment that is deleted after fix\n        reader.close()\n    }\n}\nfun test4(reader: BufferedReader) {\n    // Works well, but should be added as an additional test.\n    try {\n        reader.readLine()\n    } finally {\n        reader.close()\n    }\n}\nfun test5(reader: BufferedReader): BufferedReader {\n    val reader = File(\"hello-world.txt\").bufferedReader()\n    reader.toString() // False positive\n    return reader\n}\n``. I'm not sure this a valid fix in general case. This is not a refactoring and what ifclose()throws an exception on the second execution?. Why is visitor needed? Can only parent be checked?. I think this code should be rewritten. It's really difficult to understand what's going on. . Please addFixsuffix and make those classes private. I think selecting better names for classes could make preceding comments redundant.. Please don't use!!that much. From our practice, many such calls were fixed after getting an unhanded exception. I thinkpointer.elementis a good candidate for extracting to local variable. . Have you investigated why caret position is not before()`?. ",
    "Frostman": "Ok, I will create separated branches at the next time.\n. https://github.com/JetBrains/kotlin/pull/6 created to skip unimportant commits.\n. Yes, I agree, I'm sorry for the stupid mistake in the previous attempt. Commit has been updated, I think that this version should be better.\n. There are no tests for Arrays.kt as I understand and so, I will create /libraries/stdlib/test/ArraysTest.kt and add some tests to it. \n. Ok\n. Is it correctly works with static methods?\n. I agreed with all of your notes. It is easy to fix all issues, but to fix icon we need more time.\nHere is the method that should return icon for FqName - https://github.com/JetBrains/kotlin/blob/master/idea/src/org/jetbrains/jet/plugin/actions/JetAddImportAction.java#L143\nCan we determine by FqName what it is - function or class?\nI will fix the issues and create a new pull request for it.\n. Yes, I'm already trying to pass a pair of FqName + Info as suggestions. I send you an email, can you look at it?\n. Ok\n. Ok, I will try to do it.\n. Some tests for override action has been added.\n. Ok, I'll do it.\n. Are there any comments about it? :)\n. Andrey, I will do it for the next time.\n. Yes, sure. Unfortunately now I have no time because of the university.\n. Nikolay, can you please check an updated version?\n. This issue is already fixed by Nikolay.\n. Ok, I will replace it with additional loop.\n. Ok, I will add static constructors.\n. ReplaceCallFix is used for replacing !!. now. I will rename UnnecessaryNonNullAssertionFix to PostfixNonNullAssertionFix and will implement removing of a!! postfix operation. Additionally I will try to implement introducing of !! postfix operation.\n. I used debug for monitoring / researching PSI tree and I don't now about View PSI tool :( Thank you for this tip.\n. Unfortunately I didn't understand how to easily verify that we are inside the JetDotQualified element, so, I think that the check for the next leaf is not bad too.\n. I think that it'll be good to use StringBuilder#append instead of strings concatenations.\n. ",
    "abreslav": "Thanks for the patch!\nDid you run the tests after making this change? You can use the All Tests run configuration in IDEA\n. The biggest question is whether we actually want HEREDOCs with no templates at all, they don't seem very much of a fit with the other two string formats...\n. Thanks for your contribution. We'll have to discuss this feature further in order to see how to accomodate it nicely with the overall language design.\n. Thanks for the corrections. Please refer to the discussion here: http://youtrack.jetbrains.com/issue/KT-850\n. Thanks. We're still not sure whether we should have this feature or not.\n. I'm reverting the 75dcb84 (the NPE one). It breaks the compilation for me: fails with IllegalAccessError. \nPlease, do not submit unrelated changes under the same pull-request. This makes it harder to properly review them. Thanks.\n. Hiram, if you get an NPE from the compiler, please provide us with some info about it and we'll look for the problem together. \n. I'm putting the 75dcb84 back: it seems it was some kind of a local problem on my machine. Sorry about it.\nStill, please avoid putting unrelated things under the same request. Thanks.\n. This seems to be too early for this change\n. It would be nice if you could use rebase instead of merge to avoid having those \"Merge remote-tracking branch 'upstream/master'\" commits\n. I'd say \ngit pull --rebase\n. !\"...\" stands for \"...\".not() in Kotlin\n. We can't just copy Python, because we have infix function calls:\nkotlin\nfoo r \"my string\"\nThis is a valid call, so removing a space shouldn't break it...\n. We use '@' for labels... \n. By label I mean label: something you can break to as in\n@loop for (i in j) {\n  if (...) break@loop\n}\nRe-using the character is possible, but makes it inconsistent.\nThe -proposal is not bad conceptually, but I think people won't like it since it looks as if the first quotation mark were escaped. \nWe already have back-ticks in a role similar to this. Maybe we should think about using them somehow.\n. We are currently focusing on other issues. I talked to Scala guys and they are planning to use the r\"...\" syntax proposed above. Probably, we should consider this option\n. No need for an issue, but you should add tests of some sort.\n. Good point, btw\n. Sergey, have a look at these files: https://github.com/JetBrains/kotlin/tree/master/jdk-headers/src/java\n. Stepan, it doesn't outweight the reasons not to implement it.\n. Please, clean the request up. I'm afraid we can't merge this one in.\nOne can think of many ways of doing that: from some clever git manipulations to simply making a patch, reversing your changes in your fork and then applying the patch again.\n. I think, it makes sense to close this request and open a new one.\n. James, didn't we agree on making lazy evaluation work over iterators, not iterables?\nDoing it via iterables is wrong: iterating twice causes doubling of side-effects.\n. We'll revert this, re-do the APIs and then put it back\n. What compiler bug? Could you provide an issue ID? Thanks.\n. We'll be back to this functionality when it's reworked to use iterators\n. Good to see you can already do advanced stuff!\nBut why would this method need to be intrinsic? I think, a simple extension in the stdlib would be fine\n. The primary use case is, of course\nfor (i in someIndex..array.lastIndex) {\n  doSomething(a[i])\n}\n. Thanks for the patch!\nCould you notify us about you going to fix an issue by posting a comment to bugtracker first? Just to prevent duplication of effort. Thanks\n. It says ACC_FINAL instead of ACC_SUPER\n. Maxim, many thanks for the fix! \nOrganizational thing: please, include the issue title in the comment + before you start, let us know that you are working on the issue by leaving a comment in YouTrack, to avoid duplications of effort. Thanks.\n. Pushed manually\n. Any test cases?\n. Any tests?\n. For the reviewers: this pull-request is not supposed to be merged right away. The author requested a review only. To familiarize with our codebase and be able to make some progress\n. Merged manually\n. Do you recall the issue ID's that must be fixed with this request?\n. You can add \n  #KT-2532 Fixed\nto your commit message for the issue to be closed as fixed right when the commit gets pushed to our repo.\nYou need to add a test exactly reproducing the issue, though.\nSee this commit: https://github.com/JetBrains/kotlin/commit/7b01ce5acba02173176544e38b0315bc4b4eecb0\nAnd its effect in the tracker: http://youtrack.jetbrains.com/issue/KT-2532#comment=27-378141\nThanks a lot for your help!\nOn Sep 6, 2012, at 21:39 , Kirill Berezin wrote:\n\nIn the delegation feature ticket's subtasks I can see only this one become fixed now\n\u2014\nReply to this email directly or view it on GitHub.\n\n\nAndrey Breslav\nJetBrains, Inc.\nhttp://www.jetbrains.com\n\"Develop with pleasure!\"\n. Pulled manually b84f068c3320fa5e28ee79357272859dd8f32cbc\n. Btw, it's better to comment on the request you are working on to let the team know and avoid duplication of the effort\n. I'm sorry for the delay. We are working on the milestone release, and I have very little time this week.\nI'll get to it as soon as the milestone is out.\n. Integrated manually\n. Pavel, this looks correct. I wonder if it's possible and/or needed to write any additional test cases?\n. Please provide commit messages that can be pushed to the main repository\nIt would be also nice to have unrelated things submitted as separate pull-requests, so that different people could review them\n. Alexey, please make sure we have these annotations\n. Inferred by KAnnotator\n. Alexey, please make sure this annotation is included in our inferred set. Thanks\n. I think we should do a special check and report a special error: both the code will be cleaner and the diagnostics\n. Pulled. (I squashed the correcting commits to keep the history nicer)\n. This commit looks like a pure refactoring: I couldn't spot a change in logic. \nIf the logic is changed somewhere, please make it a separate commit and add tests. If no, please extend this pull-request by adding commits that change logic (and change the message in this commit).\n. Then please write commit messages that precisely describe the contents of the commits\n. Oh, I got it now. The change is correct, but I have a few questions:\n1) JPS runs in a separate process, who cares what is loaded there?\n2) In your code you even use a synchronized method, why? It's a separate process for your builder, there are no other threads involved. Am I missing something?\n. It's better to squash these three commits together, I can see no value in separation in this case\n. Thanks for your contribution!\n. Pulled manually. Thanks for your contribution\n. Pulled manually\n. Thanks for you help\n. Good job. Most of my notes are minor, but they need to be fixed anyway.\nI'm closing this pull-request, since you'll need to rebase your commit to match the new master.\n. Good job. Pulled manually\n. Good job. Merged manually\n. Merged manually. Thanks.\n. Merged manually\n. Please, separate this into two commits: one for each quickfix\n. Merged manually\n. Merged manually\n. Accepted.\nNext time please amend the commits (I squashed them manually for this pull request).\n. Accepted\n. Accepted\n. Next time, don't forget to run GenerateTests\n. If all you did is added test cases for quick fixes, nothing but quick fix tests should be changed.\nAccepted.\n. See https://github.com/JetBrains/kotlin/pull/185\n. Wow, this is an impressive piece of logic :) I think we'll be better off without it, though. Thanks for the effort.\n. See https://github.com/JetBrains/kotlin/pull/183\n. Accepted\n. Accepted\n. Accepted. Thanks a lot.\n. Unfortunately, I was wrong, and this should not be a trivial quick fix: we should put the right class name into \"<...>\" if there's only one that fits, or propose to choose from a list otherwise. Feel free to return to this task when you are finished with trivial ones. Sorry for having mislead you\n. There are three other quickfixes that essentially have the same code in them: RemoveImportFix, RemoveSpreadFix, RemoveVariableFix. Please investigate the possibility of unifying the code between these three and your RemoveTypeArgumentsFix, so that there is only one class. You can do it in a separate commit.\n. Good job!\n. Look like another iteration is needed.\n. Having a merge commit (whose commit message doesn't say it is a merge commit) in the middle of a pull request is indeed an inconvenience...\n. Since the required changes are quite severe, I'll close this pull-request. Please put a reference to it in the new one.\n. Accepted. Thank you.\n. Looks good to me. The only issue: I commented out these lines in BasicExpressionTypingVisitor\nif (recordResolvedDecsriptor && resolutionResults.isSuccess()) {\n            context.trace.record(BindingContext.RESOLVED_CALL, binaryExpression, resolutionResults.getResultingCall());\n        }\nAnd the tests pass. Seems like the RESOLVED_CALL is there even without this addition\n. Accepted. Thanks!\n. It's a lot better now, but a few improvements are still needed\n. Merged manually. Thanks!\n. Unfortunately, these changes broke very many tests: http://teamcity.jetbrains.com/viewLog.html?buildId=81461&tab=buildResultsDiv&buildTypeId=bt345\nI'll look into fixing them\n. I had to revert these changes in master: they break too many tests and they are not straightforwardly fixable. Please open a new pull request with commits relative to the present state of master and make sure to run All Tests\n. I'm sorry I can't review this today. Will do tomorrow\n. Commit messages like \"Fixed tests\" are rather unhelpful: someone will be looking at Annotate one day wondering why this change was made and will have no clue. A commit message should explain the changes and why they were made. Also, I'd squash fb55561 into the previous commit (did it manually last time). \n. Integrated manually. Thank you and sorry for the delay\n. Thanks\n. A revision of this pull request is necessary. I'm closing it. \nPlease mention the id of this pull request when submitting a new one.\n. If you amend commits, please let me know, because github does not send notifications about this.\n. I'll close this now, since it will take some time to fix.\n. Looks like these should be two separate pull requests, shouldn't they?\n. I'm closing this, as it should be split anyways\n. Thanks for your contribution, I'll review it by Tuesday.\n. Reassigned to @svtk as @geevee has too much to review\n. Integrated manually\n. Integrated manually\n. Oh, that's where the deja-vu comes from! I'm terribly sorry, but I somehow lost the #266 request. Closing this one.\n. Looks good (will integrate when test execution finishes).\nI think it's worth it to investigate whether this functionality should be integrated with Change Signature action: https://github.com/JetBrains/kotlin/tree/master/idea/src/org/jetbrains/jet/plugin/refactoring/changeSignature\n. Integrated manually\n. Note: very many commits, some of them definitely deserve being squashed together\nOTOH, some commits should probably be divided, like this one:\nMore tests\nAdded warning for tail-recursion in finally since it's not always tail\nFixed bug in finally tal generation\nTwo consecutive commits have identical comments\nTail recursion optimization\nMore tests\nFixed bug in finally tal generation\nCommit messages have a very long prefix \"Tail recursion optimization\" which make the log unreadable\nCommits that support tail recursion in finally-blocks are present, although the feature is removed in later commits, it makes me review code I wouldn't have to review.\nProblems found:\n- \"codegen\" package in the \"frontend\" module\n- \"TraceStatus\" is an unfortunate name for our project, because the word \"trace\" is used ubiquitously in a very different meaning. Same for \"TraceData\", which uses the name \"track\" inside for some reason\n- TraceData has public non-final fields\n- Error message should be improved: \"Function invocation is non tail-recursive\"\n- Unfortunate constant name: TAIL_RECURSIVE_FUNCTION_WITH_NO_TAILS\n- What happens when a tail-call is made to a different instance? (labeledThisReferences.kt)\n  - we could potentially re-assign the this-reference as well as other parameters\n- Extra diagnostics in CallResolver seem out of place. ControlFlowAnalyzer or at least a CallResolverExtension would be more appropriate\n- assertions without messages\n- ArrayList as variable type\n- Bad constant name: FUNCTION_RECURSIONS\n- May be use a collective slice for FUNCTION_RECURSIONS\n- Why some parts appear in CallResolver and some in ControlFlowAnalyzer?\n- Diagnostic tests are insufficient:\n  - check all cases of non-tail calls\n  - check \"no tail calls\" message for the case when there are recursive calls, but not tail-recursive\n- What's the idea behind using [suppress(\"warnings\")] in functionWithNonTailRecursions.kt?\n- Bad constant name: PARTIAL_TAIL_RECURSIVE_CALL. If it's all about \"finally\", why not say so in the constant name?\n- Unused class: TailRecursionType\n- More diagnostic tests needed for finally: nested expressions etc\n- Strange error message: \"Function recursive invocation is not optimized (could be non tail-recursive or unsupported case)\", I'm sure we can be more specific here\n- The logic in AbstractTailRecursionTest.java is rather convoluted...\n. Merged manually (a while ago)\n. The description is lacking detail. Could you describe the main idea behind these changes?\n. Thanks for your contribution!\n. Tests fail: http://teamcity.jetbrains.com/viewLog.html?buildId=102974&tab=buildResultsDiv&buildTypeId=bt345\nThe reason for most of the failures is that we now request getAllFields(), which apparently triggers light class generation earlier than the necessary information is ready. Will investigate\n. The problem is that these changes make hasStaticMembers() compute getAllFields(), which in turn triggers creation of all superclasses, which causes problems with TypeHierarchyResolver when a light class gets constructed before the appropriate parts of the hierarchy are computed. Possible ways of mitigation: \n- make everything in Kotlin's own resolve very lazy (no guarantee of success),\n- don't call hasStaticMembers() when deciding whether to create a package for a Java class or not: always create the package (i.e. chicken out for this time, and maybe have some problems later),\n- make light class construction truly lazy (a lot of work, no hope of re-using existing IDE ClsBuilder).\nSeems a high price to pay altogether. Need to think more.\n. I never noticed \"Complete statement\" doing this. We should support it then. Feel free to file an issue\n. You can do it automatically by adding \"#KT-3714 Fixed\" to your commit message\n. Any progress on this one? Nikolay, don't hesitate to ping someone if needed\n. Looks like we have a consensus here: we should make Map contravariant in K. This requires some extra work in the compiler, but is probably worth the effort.\nI created an issue for this: http://youtrack.jetbrains.com/issue/KT-4336\nThis PR will be closed\n. Thanks!\n. As it needs severe revision, I'm closing this pull request. Further contributions are very welcome. Thanks for your help!\n. As Nikolay @chashnikov is going on vacation today, I'm taking over from him. There are two more things to discuss, see my comments to diffs.\n. Sorry, missed that part of the discussion.\nI think everything looks great now. I squashed your commits pushed manually to master. Thanks a lot for your help!\n. Two commits would be better, sorry for not mentioning this right away.\n. Merged manually. Thanks for your contribution!\n. > Excluding java.io.StringWriter from IdeaJdkAnnotationsReflectedTest since annotation from IDEA is incorrect\n\nIt will break at runtime. We need to fix the problematic annotation in IDEA. Did you contact Anna Kozlova about it?\n. I had to merge the two commits together. Next time please make sure that changes are properly grouped.\n. Merged manually\n. @jrenner, only highly-optimizable core function need to be members in Char, all other functions can be implemented as extensions.\n. @christian-laakmann As we are having New Year holidays in Russia at the moment, people responsible for out standard library will review this pull request after Jan 8th. Thanks for your help!\n. At this point the caching is done, I'll try to work a little more on the KotlinClassHeader API\n. Questions remain:\n- I used @Nullable getKind() method in KotlinJvmBinaryClass, to indicate a non-kotlin class. Maybe a special kind is better?\n- VirtualFileKotlinClass calls contentsToByteArray() many times to compute different things. Maybe all those things should be computed once any one of them is requested?\n. A bug fixed (last commit amended). All tests pass now\n. Integrated manually\n. It's great that you have a generic solution for all such intentions!\n. > It doesn't allow named arguments because they can't be preserved in the [...] syntax.\n\nI think it's better to allow named arguments. It requires some more analysis though, because the order may need to be changed\n\nIt doesn't allow the dangling functional argument because I would have to put it inside the square brackets.\n\nThere's nothing bad in doing so.\n\nIt preserves whitespace and comments.\n\nThis is great!\n. Regarding omitted arguments, you are right, but what I'd like to avoid is the user not knowing why the intention is not available. So I'd suggest to support it and in tricky cases show a tooltip window explaining why it didn't work.\nFor balloons and popups, see JBPopupFactory class and its (rather elaborate) usage here:\nhttps://github.com/JetBrains/kotlin/blob/master/idea/src/org/jetbrains/jet/plugin/ktSignature/EditSignatureBalloon.java#L78-78\n. Sorry for the lag in review. I'll be at it shortly.\n. Since a significant change is needed, I'm closing this PR.\nI consider your task 0 completed successfully. Now your task 1 is to address my comments above and add your generalized version for other named functions.\nNext step (task 2) will be to think about other conventions described here, including .set\nAlso, there's a special case for Map.put() since map[foo] = bar looks better than map.put(foo, bar) it would be nice to have both an intention to transform it and an inspection to show a warning in the IDE to which such inspection would be a quick fix. And then it would make sense to generalize this inspections to get() and other such methods\n(hope it's not too much information at once, anyway the first step is to address my comments).\nKeep up the good work!\n. No need for a separate pull request here. It's enough to add commits to the same branch you have already submitted and simply write a comment to let the reviewers know that something has changed. Also, it's a good idea to amend some of the previous commits to avoid meaningless changes dangling in the history\n. Oh, sorry, I haven't noticed that the changes were only in imports.\nThe reason here is that somebody checked in a generated file where imports were optimized by the IDE after generation. So, yes, it would be best to simply push a new version with original imports as a  part of a commit that changes this file in a meaningful way.\n. You needed to delete the changes you made to misc.xml from your commits. Instead, you deleted the file altogether. This is a configuration file which is necessary for correct operation of the IDE, it must not be deleted.\nPlease, have a look at how to modify commits in git (interactive rebase). As a result you should get a history with only meaningful changes (you'll need to squash some commits together) + no merge commits.\nThanks\n. Task completed\n. Changes reviewed. Task completed. Thanks\n. Please note that PR and commit messages should be informative for the reader. \"First attempt at my intention\" tells nothing to an unprepared person.\n. Please get rid of merge-commits (rebase on current master and force-push) + group your changes so that every commit is logically self-contained.\n. Add a comment here to let us know when it's done\n. Task 0 completed.\n. Please tell us your real name. Thanks\n. Task 0 completed\n. Pasha, should I fixup the changes and push, or are there any more comments?\n. Ok, I got it: the changes are pushed already. Next time, please-please-please, close the PR :)\n. :)\n. Thanks, added both N? and NN? cases and pushed\n. Please fixup those commits that address logically identical issues (i.e. the iml-related stuff)\n. Please leave a comment when you are done\n. Review finished. Revision is needed\n. More problems formatting/codestyle problems found. Another revision needed.\nI'm closing this PR to avoid confusion, please squash your commits together before submitting another PR and mention this PR in that new one. Thanks\n. Task 0 completed\n. Accepted. Thanks (I squashed the commits manually)\n. Next step is to generalize this to all conventions, see http://confluence.jetbrains.com/display/Kotlin/Operator+overloading\n. Don't delete your previous contribution :)\n. It's best to have this intention available on the whole if/while/do statement as opposed to the braces of a block\n. In Java it's called \"Flip binary expression\"\n. Review finished. Revision is needed\n. We are going to ignore this case, i.e. flip and get red code\n. This doesn't seem to be properly rebase. Only your commits should be listed.\n. Also, please mention the corresponding issue ID\n. You can try to rebase interactively onto upstream/master and remove other people's commits\n. One problem I found with this intention: in the case of having multiple '+' in a row: 1 + 2 + 3, swapping the last + gives an unexpected result: 3 + 1 + 2. See how Java does this\n. I'm closing this PR to avoid confusion. Please submit a new one when the issues above are fixed\n. There a few minor issues I missed on the previous reviews, and I'd fix them myself if not for the bug found for triple-quoted strings. I'm closing this PR to avoid confusion, please file another one when the issues are addressed\n. Google for 'git interactive rebase' + some generic information on git, i.e. what is merge and what is rebase.\n. Too many irrelevant commits. Please clean up the history. A rebase on upstream/master might help\n. Oh, I see you've closed it already\n. In Python this is called \"slicing\", people seem to like it there\n. Regarding the name of the intention: there are two separate things here:\n- What the user sees when he invokes the intention. This is highly desirable to be specialized (i.e. \"negate comparison\", \"negate is/!is\" etc). Can be achieved by calling setText() from isApplicable()\n- What is displayed in the Settings page. There it can not be specialized, and we should have a generic name, e.g. \"negate binary operation\" \n. Is this a separate PR or should it be reviewed together with the one about safe calls?\n. I mean this one: https://github.com/JetBrains/kotlin/pull/367\n. Please rebase on upstream/master and make sure commits group the changes logically\n. The issues are minor, please note them for your future tasks.\nTask 0 is completed. Please proceed to selecting a new one.\n. Let's adhere to our process.\nWhat is the issue ID for this PR?\n. You forgot to comment on the issue\n. Another revision is necessary\n. What is the issue ID for this PR?\n. Ooops, missed it\n. Revision required\n. You forgot to comment on the issue in the tracker\n. If it's connected to code in the PR, it's better to post it here, if it's about general functionality, issue tracker is better\n. Merged. Thanks\n. There's no such convention that you either name all arguments or none. It's hard to tell which is the best way, probably, asking the user would make sense here, but let's make it a separate task. For now, let's stick to your strategy\n. Revision needed\n. More commits added\nThe general principles are\n- Never carry components in contexts\n- Never inject contexts (not all context injections are eliminated, but we are on our way)\n- Parameters are either carried in contexts or passed to injectors\n. What is the issue id? And please comment on that issue too\n. What is the issue id? And please comment on that issue too\n. Yes, you need to clean up your branch. One option is to interactively rebase onto upstream/master and remove all commits but yours\n. Merged manually\n. Also, this PR breaks this test:\nQuickFixTestGenerated$TypeMismatch$ParameterTypeMismatch.testChangeFunctionParameterType4\njunit.framework.ComparisonFailure: Some unexpected actions available at current position: %s. Use // ACTION: directive expected:<[<empty>]> but was:<[Disable 'Move lambda function into parentheses'\nEdit intention settings\nMove lambda function into parentheses\n]>\n    at junit.framework.Assert.assertEquals(Assert.java:100)\n    at com.intellij.testFramework.UsefulTestCase.assertOrderedEquals(UsefulTestCase.java:420)\n    at org.jetbrains.jet.plugin.quickfix.QuickFixActionsUtils.checkAvailableActionsAreExpected(QuickFixActionsUtils.java:87)\n    at org.jetbrains.jet.plugin.quickfix.AbstractQuickFixTest.checkForUnexpectedActions(AbstractQuickFixTest.java:85)\n    at org.jetbrains.jet.plugin.quickfix.AbstractQuickFixTest.doTest(AbstractQuickFixTest.java:57)\n    at org.jetbrains.jet.plugin.quickfix.QuickFixTestGenerated$TypeMismatch$ParameterTypeMismatch.testChangeFunctionParameterType4(QuickFixTestGenerated.java:2243)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n    at java.lang.reflect.Method.invoke(Method.java:597)\n    at junit.framework.TestCase.runTest(TestCase.java:176)\n    at com.intellij.testFramework.UsefulTestCase.access$001(UsefulTestCase.java:73)\n    at com.intellij.testFramework.UsefulTestCase$2.run(UsefulTestCase.java:296)\n    at com.intellij.util.ui.UIUtil.invokeAndWaitIfNeeded(UIUtil.java:2031)\n    at com.intellij.testFramework.UsefulTestCase.invokeTestRunnable(UsefulTestCase.java:328)\n    at com.intellij.testFramework.UsefulTestCase.runTest(UsefulTestCase.java:312)\n    at com.intellij.testFramework.LightPlatformCodeInsightTestCase.access$001(LightPlatformCodeInsightTestCase.java:69)\n    at com.intellij.testFramework.LightPlatformCodeInsightTestCase.doRunTest(LightPlatformCodeInsightTestCase.java:109)\n    at com.intellij.codeInsight.daemon.LightDaemonAnalyzerTestCase.access$000(LightDaemonAnalyzerTestCase.java:46)\n    at com.intellij.codeInsight.daemon.LightDaemonAnalyzerTestCase$1.run(LightDaemonAnalyzerTestCase.java:69)\n    at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:124)\n    at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:99)\n    at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:85)\n    at com.intellij.codeInsight.daemon.LightDaemonAnalyzerTestCase.runTest(LightDaemonAnalyzerTestCase.java:65)\n    at com.intellij.testFramework.LightPlatformTestCase.startRunAndTear(LightPlatformTestCase.java:693)\n    at com.intellij.testFramework.LightPlatformTestCase.access$700(LightPlatformTestCase.java:120)\n    at com.intellij.testFramework.LightPlatformTestCase$8.run(LightPlatformTestCase.java:656)\n    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:199)\n    at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:646)\n    at java.awt.EventQueue.access$000(EventQueue.java:84)\n    at java.awt.EventQueue$1.run(EventQueue.java:607)\n    at java.awt.EventQueue$1.run(EventQueue.java:605)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)\n    at java.awt.EventQueue.dispatchEvent(EventQueue.java:616)\n    at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:269)\n    at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:184)\n    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:174)\n    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:169)\n    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:161)\n    at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)\nPlease run All Tests before submitting PRs\n. Merged manually\n. Could you answer comments in-place? It's a lot more convenient to have some context when reading your answers. Thanks\n. Fix + rebase + squash needed. I'm closing this PR to avoid confusion\n. Hi Gavin,\nPavel (the reviewer) found that functionality of this intention duplicates the functionality of the one you did before: add braces to statement. This duplication is present in Java too, which is a pity.\nYour code is fine, but I don't think we should add a duplicate. \nSorry, it's my fault that I added this intention at all (you could catch it early, but it crawled past you:) )\nThanks for your time\n. It very well may be! Thanks for mentioning it\n. The code looks fine. Is there a corresponding issue in the tracker?\n. Merged manually. Thanks\n. All I can offer at the moment is switch to some other task, Svetlana comes back on Monday, maybe she can help you\n. BTW, it still makes sense to split this PR in two, and the one for adding explicit arguments presents no problems\n. Svetlana is travelling at the moment, she'll be back on Monday and will hopefully help you\n. Cool, Tal. Congratulations! How about adding an inspection for this http://youtrack.jetbrains.com/issue/KT-4854? (Have a look at how similar inspection works for Java)\n. This functionality duplicates another intention\n. Pushed to master\n. Accepted, thanks. It's best to avoid irrelevant commits in your PRs by, for example creating new branches for each PR.\n. Merged manually. Thanks\n. Hm, indeed. We got too focused on the \"+\" case, and forgot that there can be operations with different precedences.\nSo, it seems that it should work along these lines:\n- If there are many operations with the same precedence in a row (1 + 2 + 3), it should work as it does now\n- If the precedence of the operation beings swapped is lower than its arguments, it should respect the tree order, i.e. swap left and right children of the operation\nJetPsiPrecedences will be useful in tackling this.\n. I filed an issue: http://youtrack.jetbrains.com/issue/KT-4868\n@kuity, please make sure to claim it. Thanks\n. You can say \ntypes.map {args[it]}.makeString(\", \")\n. Revision required\n. + please rebase onto upstream/master\n. > I thought of taking the types as text and using the JetPsiFactory to turn them into JetTypeReference with createType and then getting the JetType from a context and seeing if they match\nYou don't need to invent a new approach here. It's always better to look at how it's done elsewhere. \nSee how \"Specify type explicitly\" works, and try to do likewise\n. Type refs are only used for templates here, and you don't need templates at the moment.\nAll you need is render the type like this:\nreturn DescriptorRenderer.TEXT.renderType(element);\nit will always produce a fully-qualified name, and then do something like this:\nShortenReferences.instance$.process(getTypeRef(namedDeclaration));\nThis will add necessary imports and shorten the long names where possible.\n. This test fails for me:\norg.jetbrains.jet.plugin.intentions.CodeTransformationTestGenerated.InsertExplicitTypeArguments#testSimpleInsertTypeFun\nError: Unresolved reference: println\n. Hm, now this one fails:\norg.jetbrains.jet.plugin.intentions.CodeTransformationTestGenerated.InsertExplicitTypeArguments#testInapplicableTypeNotInferred\nError: Unresolved reference: s\nCould you fix all of them? :)\n. Intention description files are missing\n. Please rebase onto master\n. Merged. Thanks\n. Nikolay is on vacation this week. I think, it makes sense for you to pick another task to work on until he comes back\n. Merged. Thanks.\nReleased here: https://github.com/JetBrains/kotlin/releases/tag/dot-operator\n. I'm sorry to interfere, but do you mean to say that this code is somehow tested elsewhere? Because the logic is not very straightforward, and deserves to be tested, I think...\n. But can you simply re-use the same test data files for a different test class?\n. I don't think there's a need to modify the generator framework, changing GenerateInjectors.kt will be enough\n. About the argument: agree, but commas look strange to me. Maybe spaces are enough?\n. The additional command line arguments (in the Compiler Settings in the IDE) look more than enough to me\n. Can't finish review completely at the moment, but you can proceed with the issues pointed out, I'll be back at it tomorrow\n. Review finished. Revision needed. I'm closing this PR, please open a new one when done with revision\n. For reviewers: Please keep in mind that this is very similar to KT-4552 and KT-4554, that are already implemented\n. The commit message here does not convey anything about the actual changes\n. Sorry for the delay in review. It would be better to investigate possible ways of implementing this that are more reliable than simply searching strings for commas.\nFor example, this test results in rubbish:\n```\n    fun bar(a1: Any, a: Any) {}\nfun foo() {\n    bar(\"\", /*,*/{\n      bar(\"sdf,sdf\", \"\")\n    })\n}\n\n```\n. I'm closing this PR, submit the new version into another one, squashing the commits, please\n. Sorry for the delayed review.\nIntuitively, one test seems to be too little for this problem, and indeed at least one case doesn't work:\n2 - 3 * 5 + 6\nflipping the + here just swaps 5 and 6\n. Merged with corrections\n. May 1 - 4 is public holidays in Russia, so we'll be able to review this PR after that. Sorry for the delay\n. @nskvortsov you now have the rights to push to repository.jetbrains.com\n. Merged manually, thanks for you contribution!\n. This may turn out wrong is the actual Java method we generate returns Unit, not void. The questions is what are such cases?\n. Remote run: http://teamcity.jetbrains.com/viewQueued.html?itemId=223022&tab=queuedBuildOverviewTab\n. Did you review it? Or is it just for my choice of occupation on Saturday? :)\n. Thanks. Will fix\n. Bootstrapped the initial commit. Here are the removed \"public override val\"s\n. @amal, I see, thanks\n. Pushed for remote-run to rr/osr-optimization\n. Build successful: http://teamcity.jetbrains.com/viewLog.html?buildId=154133&buildTypeId=bt345&tab=artifacts\nLooks like there was a force-push. Should I re-run the build with the new code?\n. Pushed remote run branch rr/bintree\n. Merged manually\n. Merged manually\n. Merged manually, some broken links corrected. Thanks!\n. Once the tests are fixed, I'd suggest that you guys do the review the way we always do it inside the team: seat next to each other and discuss.\n. This version of the docs is not supported (tbh, I should have deleted them from the repo long time ago). If you are looking for the kotlinlang.org sources, you can find them here: https://github.com/JetBrains/kotlin-web-site\n. Before we dive into discussing this PR, let's make sure it's not a joke this time (by the way, we all loved the previous one and even \"released\" it, thanks a lot!) :) So, is this not a joke?\n. Ok, let's discuss it then.\nFirst, I'd like to point out that implementing a feature whose design was never discussed before is definitely a brave move, but a little hasty.\nSo, first thing to be reviewed here is language design decisions, some of which are kind of implied here, but not spelled out. For example:\nkotlin\nfor (i in 1..2, i in 2..3)\nis this an error (redeclaration) or a warning (shadowing)?\nSome questions I have off the top of my head:\n- How is it possible that yield is a soft keyword? I can always say yield(1), and if I have a function named yield that takes one parameter, it's an ambiguity that can not be reconciled.\n- Do you imply that yield only works at the root of the body expression? What about ifs in the body? Can I not skip some of the items in a collection by no yielding results for them?\n- Incidentally, what about label-qualified yields: yield@outer e?\n- Your approach only concerns maps, what about filters?\nAlso, connection to monadic constructs is not entirely clean, at the first glance...\n. I'm not entirely convinced that limiting ourselves to the Scala-inspired approach is beneficial.\nFirst of all, I think we should at least give some thought to the issue of possibly incorporating \"generator blocks\", C#-style.\nThen, we should consider other generalizations, at least the following: \n- traditional monadic operations,\n- control abstraction (translating other language constructs than yield and if by convention),\n- incorporation of CPS-like transformations into the picture (for async and maybe some other constructs along these lines).\nOther issues to consider:\n- deeper look into interactions with inlines,\n- possible optimizations (avoiding allocation of multiple collection instances by the calls to map and filter),\n- using C#-style yield in other expressions, especially loops and lambdas.\nWhy I think we should first spend (possibly a lot of) time on this: Once implemented, a language feature can't be taken back, and if we rush into the simplest-looking direction, the consequences are usually along the lines of painfully fitting improvements on top of prior decisions under very restricting circumstances.\n. > C# generator-blocks (all the more their generalization for lambdas, loops and other control structures) is no doubt very useful feature, but for me it seems quite orthogonal to comprehensions. \nThe underlying implementation may (or may not) be orthogonal, but we'd definitely prefer to share syntactic forms, unlike C# (the appearance of VB-style LINQ there has a kind of political nature, AFAIU, and looks very alien to the language). And the intention to share syntactic forms totally requires thinking through the general cases beforehand, otherwise we may find that adding generalizations in a backwards-compatible way is impossible, which would be a blocker.\nYou are right about flatMap and traditional monads, thanks.\nOn the Scala-like filter clauses: they seem overly special-case to me. This is something I'd love to generalize more in the direction of full control abstraction (give meaning to other built-in operators than if).\n. By the way, if you are interested in working on some smaller but more clearly understood features, we can discuss what's on the table.\n. Do any of the following features look interesting?\n- Format strings (a-la what Scala has, but we'd need to work out the details.\n- Support for local delegated properties (currently we only support delegated properties in classes and packages, but not inside functions)\n- For Java interop: When a function bearing a special annotation has a number of default parameters in Kotlin, generate overloaded method in Java that allow Java clients skip passing values for default parameters.\n. Great. Would you like to work out and submit initial version of a spec document for it, or do you prefer only working on the implementation?\n. Ok, looking forward for it. I'll close this PR for now.\n. Merged manually\n. remote-run branch name rr/plugin-api\n. At least one test has failed: https://teamcity.jetbrains.com/viewLog.html?buildId=354506&tab=buildResultsDiv&buildTypeId=bt345\n. Please ignore NPE's in JetDiagnosticsTestGenerated, other test failures should be fixed\n. Pushed to rr/plugin-api\n. Build fails on Windows agents:\nhttps://teamcity.jetbrains.com/viewLog.html?buildId=356224&buildTypeId=Kotlin_CompilerAndPluginBootstrapNoTests&tab=buildLog\n. Is it important to merge this PR very soon? If not, we'll wit until @geevee is back from his vacation\n. Merged manually\n. My guess is that a number of tests is broken by these changes (test data contains serialized descriptors from built-ins)\n. @erokhins we'll try discuss specs as PRs\n. Merged into #633 \n. Moved to https://gist.github.com/abreslav/6ae8195ebae37ab5219351eb576e0a00\n. No need for a spec document here. Decision: deprecate $backingField syntax, do nothing else\n. Moved to https://gist.github.com/abreslav/6ae8195ebae37ab5219351eb576e0a00\n. > Would we still be able to use @-based annotations without any special syntax (i.e., data instead of @data) on classes?\nYes.\n\nare you open to hearing language suggestions in the form of Pull Requests here from people outside of JetBrains?\n\nFor people not on the Kotlin team, it's better to discuss suggestions with us in the forum first\n. Moved to https://gist.github.com/abreslav/6ae8195ebae37ab5219351eb576e0a00\n. Merged manually\n. Moved to https://gist.github.com/abreslav/6ae8195ebae37ab5219351eb576e0a00\n. Moved to https://gist.github.com/abreslav/6ae8195ebae37ab5219351eb576e0a00\n. Moved to https://gist.github.com/abreslav/6ae8195ebae37ab5219351eb576e0a00\n. @damianpetla In a matter of days\n. The new version 0.11.91.2 has been pushed to Maven Central\n. Looks good to me\n. Yes, when it is exactly the same T on both sides. This is already supported, btw, and you don't even have to specify T explicitly\n. Force-pushed the actual diff with master\n. @ilya-g You are right, it should be a warning, not an error\n. Merged manually\n. Merged manually\n. @bintree this may concern you as well\n. Reviewed, everything's OK\n. Looks good to me\n. Maybe things like this should be somehow super-hidden? I.e. -XX prefix or something?\n. Moved to https://gist.github.com/abreslav/6ae8195ebae37ab5219351eb576e0a00\n. Ok to remove package inside a file, reassigning to @bintree for annotation entries\n. Looks good to me\n. Looks good to me\n. Merged manually. Thanks!\n. We are not going to merge it now, are we?\n. I have some reservations about the need to put the annoying | on every line. Can we not do it more conveniently? What do other languages do?\n. @cy6erGn0m Maybe I'm being na\u00efve, but it seems to me that it would be enough to check if the first line is empty and ignore it in this case, otherwise it's pretty straightforward to strip the indent of the first (nonempty) line from all other lines.\n. @cy6erGn0m could you write down a summary of what we decided here, for others to be able to comment?\n. Thanks for your contribution! We will review and integrate it as soon as we can, but I'm afraid, it may take some time\n. Bootstrapped and pushed two new commits that finish the transition\n. Thanks for your contribution, we will review it soon.\nNext time please let us know in the issue tracker before starting to work on an issue, it will help us avoid possible duplicated effort. This time it went ok, and nobody else has been working on this simultaneously.\n. Thanks for your contribution. It will be reviewed and integrated soon\n. Thanks for your contribution, we'll review it soon!\n. @geevee What are your plans regarding this?\n. @geevee It's becoming urgent, RC is close, so let us know if you won't be working on it after all\n. @geevee Any news?\n. Merged manually\n. Merged manually\n. Merged manually. Thanks!\n. Could you create/find an issue in YouTrack for this request and mention this PR in the comments? Thanks!\n. Hello,\nWe appreciate the amount of work you invested into this PR.\nUnfortunately, it introduces changes to the language, and such things can not be done without a thorough discussion and coordination with the language designers. \nThe main reason why the features you implemented are not in the language yet is that there are many questions about possible better uses of the syntactic elements they employ. There are very few special characters on our keyboards, so we have to be very cautious here. My personal hunch is that | and & have a decent chance of becoming overloadable operators in Kotlin at some point, but it\u2019s less likely for ^, <<, >>, >>>. In any case, to make such decisions we have to finalize a few other bigger features with high syntactic uncertainty: collection literals, some DSL-related features, etc.\nDue to these reasons, this PR cannot be accepted at this time, so we will close it. Thanks for your time and effort, we regret that we can\u2019t accept your work.\nP.S. As a side note, I haven\u2019t really run the tests, but from a glance at the code I suspect that this PR may break a lot of functionality around generics because things like A<B<C>> are now lexed in a different way than before.. When a KEEP gets accepted, of course, we can reopen this PR if it will still be relevant.. Seems like you haven't updated from our trunk for a while. There is a conflict on this change. I'll resolve it manually, but in the future it would be a good idea to update frequently.\n. It's a very complex way of creating this expression, why not use createExpression(\"$\" + fieldName)?\nAlmost the same would work for createClassLabel, which BTW has nothing to do with classes and simply creates a label.\n. We do not mark variables final unless this is required by the compiler.\n. Should be simply \nreturn expression\nAnd the return type should be changed accrodingly\n. See the comment below\n. Unfortunately, we don't have one written down\n. Looks nice )\n. This change must sit in a separate commit, as it has no relation to the problem being solved by this one\n. This piece of code occurs at least three times in the code base, it probably means that we should create a utility method for it.\n. It's a lot better to explicitly throw an exception here + provide a comprehensible message that tells me why this behavior is not legitimate\n. Why do you call it \"bound element\"?\n. Why is this method nullable?\n. Let's stick to conventions: \"+\" should be surrounded by spaces\n. Formatting: space after comma\n. You can use getIndicesNode().getText() and then remove the square brackets\n. It means that the array() function is not found. Perhaps, the standard library is missing for dependencies.\n. The function \"contains()\" seems to be unavailable. Same library issue, I guess\n. Yes, if the method you are calling takes several parameters. Array.get(), obviously, takes only one\n. If a function takes only one argument, you shouldn't pass two, otherwise you get an error.\n. Why do you think your reference should be ambiguous? If it is not, AMBIGUOUS_REFERENCE_TARGET is null\n. No, it isn't: https://github.com/JetBrains/kotlin/blob/master/core/builtins/native/kotlin/Array.kt\nYes, you should\n. If you want to know what function something is resolved to, use RESOLVED_CALL, and then getCandidateDescriptor()\n. \"UNAMBIGUOUS_REFERENCE_TARGET\" is called REFERENCE_TARGET, but RESOLVE_CALL is more universal\n. This may be extensible, but there are semantic differences which we need to look into\n. Well, it's not an annotation class until this annotation is applied to it... But maybe you are right, not sure\n. We could also support the ones from Android and FindBugs by default\n. I re-checked, and those differences (mostly in what NotNull means) seem to be irrelevant, so I added a list of other annotation packages below\n. Thanks for your feedback!\n. I think, it's OK\n. Missed that, thanks!\n. I suspect that this may lead to some unexpected errors in subclasses\n. No, looks like I was wrong: the fakes are not final themselves, but simply inherit modality from parent, it's ok\n. Agree\n. Why?\n. Good point. Will change to \"Using ...\"\nHave you looked through other changes?\n. Can't do. This is used in descriptors\n. \"Provider\" is not a great name for it, I think\n. This may materialize a huge file as a single string (in case of this file being commented entirely)\nWe could probably use other means, such as:\n- changing the lexer to emit a special token type on unfinished comments\n- using the CharSequence API to only materialize the last two characters as String, and not the entire text\n. This error is placed before the comment, in Java it is at the end of the file\n. Looks like this fixes it:\nPsiBuilder.Marker marker = myBuilder.mark();\n                marker.error(\"Unclosed comment\");\n                marker.setCustomEdgeTokenBinders(WhitespacesBinders.GREEDY_RIGHT_BINDER, null);\nBut I think the Java version uses some other technique\n. ",
    "olegkunov": "I changed the test data (*.after) so that there are spaces before ':' there, too. All the tests passed.\n. ",
    "chirino": "Thanks for the thorough review/comments.  Since there are several bits that need modification, I'll make your suggested changes, rebase off master, and open a new pull request .\n. I've squashed the commits for easier review and now the heredocs support being used enabling or disabling being used as template. <<<$ starts a template enabled heredoc.\n. Can you have the folks who have reservations about the feature voice them on the KT-850?\n. Rebased off master.\n. Any updates?\n. yep\n. Got any better symbols we could replace that with?\n. Andrey so how's roja's @ option look to you?\n. By label do you mean annotation?  If that's the case, would @\" some string\" be confused for a label?  Seems a label would always be followed by type symbol.\n. Another option might be \n\\\"my raw stri\\ng\"\n. Going to update the the patch by replacing '!' with '\\'.  Kinda makes sense if you read \\\"${foo}\" as being an escaped string.  '\\' is normally used to escape things within a string.  Prefixing as string with '\\' make everything in it already escaped.\n. Any more thoughts on this patch?\n. I don't agree.  The primary function of an executor is to execute other code blocks.  Notice that the Executor interface only has one method, and it take a Runnable (which can be thought of as a code block).  So executors look and feel like functions which take a code block.\n. Added a test case.\n. I've rebased and also added support for submitting callables to an ExecutorService in the same way as runnables to an Executor.\nval future = executorService<String> {\n  \"hello\"\n}\n. ",
    "geevee": "Thank you for your patch! I have added spaces around \"->\" in function types.\n. I have refactored DescriptorRenderer a little bit, and also added some code to render types like Iterator<#(Int, Boolean)> nicely :)\n. Thank you for your effort! We decided to postpone this feature for futher versions.\n. Thank you for implementing this!\n. > Debugging Kotlin plugin for JPS. In this case it would be rather inconvenient to rebuild Kotlin compiler just to see command line args.\nOK, fair enough.\n. To avoid extra bureaucracy, I'll merge this, changing method name doDoMain()\n. Thank you.\n. We think that function shouldn't be called \"times\" to be used as \"*\" operator. It's not going to be used as often as \"+\" for concatenating strings and random values, so it will confuse people who are not familiar with Ruby or Python, if they read it in the code for the first time.\nPlease, fix all of the mentioned issues and send new pull request.\n. Thank you! It would be better to have it as a one commit, but I can do it myself. If you don't know how to do it, I recommend you reading Rewriting History in Git Book.\nThere are also some minor issues, which I will fix myself, as well.\n. I have merged this pull request.\n. Please, add test for it.\n. Thank you for your pull request. I have simplified your code a bit by next two commits after yours.\nYour commit contains three loosely related changes (moving two methods, checking for built-in classes, fix for KT-2601 itself). It's better to commit such changes separately.\n. @abreslav The last comment was posted into wrong window, it was meant for #163 :)\n. Unfortunately, this PR cannot be applied now. Even manual application wouldn't help, because the affected code is changed too much. Sorry for forgetting PR...\nFYI: We are going to implement modules support soon. Some of your implementation may be reused then.\n. This pull request broke a couple of tests (unexpected warning appeared): http://buildserver.labs.intellij.net/viewLog.html?buildId=1703184&tab=buildResultsDiv&buildTypeId=bt1416\nNext time, please run 'All Tests' run configuration before sending pull request.\n. I'm sorry, that was wrong URL. Here's the correct one: http://teamcity.jetbrains.com/viewLog.html?buildId=75037&tab=buildResultsDiv&buildTypeId=bt345\n. Thank you for your contribution! It looks kool.\n. Unfortunately, I have found out that this code causes our JS backend test to fail (same happened with String.repeat() function, see https://github.com/JetBrains/kotlin/commit/be7989af36197879774e55335216ca0fa4b6df5d) I'll move it from Strings.kt to StringsJVM.kt.\nNext time, please run 'All Tests' run configuration in root idea project. If your code affects libraries written in Kotlin (such as stdlib), please also run 'mvn install' in libraries dir.\n. Thank you for your contribution!\n. Thank you for your contribution!\n. Thank you for your contribution! I have merged it manually.\n. It would be better to introduce NullableKind enum inside RemoveNullableFix, and pass it instead of action text parameter.\nAnd anyway, I think that quick fixes for both USELESS_NULLABLE_CHECK and REDUNDANT_NULLABLE can have \"useless\" word in their text.\n. Good job!\n. Everything is fine, but why didn't you include generated test file?\n. What is the content of the left panel on your diffchecker link? Seems that you have broken working copy or generating tests in wrong branch.\nWhen I check out your branch named \"5\", it has different content: here left is equal to your left, and right is your \"5\" branch. When I generate tests in your branch, I got only changes which are expected. Can \n. Your right part has imports, automatically optimized by IDEA. I recommend you disabling \"Optimize imports\" option in commit dialog and \"Optimize imports on the fly\" in Settings.\nPlease, revert changes in imports manually or invoke GenerateTests once again, and commit.\nAbout \"Can\": I started writing sentence, but then changed my mind, but forgot removing it.\n. Accepted, thank you.\n. Sorry, but I had forgot to commit your changes into the repository. Now they are there.\n. Accepted.\n. Accepted.\n. Please fix small issues I have mentioned and send another pull request.\n. Your colleague @sapal submitted pull request with similar quick fix, but your implementations are completely different. Please unify these two quick fixes and and submit them in one pull request. Thank you.\n. Next attempt: https://github.com/JetBrains/kotlin/pull/214\n. Good job!\n. I have pulled first commit (\"Common fix for FINAL_SUPERTYPE and FINAL_UPPER_BOUND errors\").\nSecond one, about OVERRIDING_FINAL_MEMBER has some issues. Fix them and file new request.\nWhen filing new pull request which is next attempt for already existing one, please add link to old attempt in its description or comment.\n. Previous attempt: https://github.com/JetBrains/kotlin/pull/200\n. Please fix mentioned issues and open new pull request.\n. When filing new pull request which is next attempt for already existing one, please add link to old attempt in its description or comment.\n. Consider renames in imports. In the following code your quick fix throws exception:\n``` kotlin\nimport java.lang.Double as jDouble\nimport java.lang as jl\nfun f(a: Double, b: jDouble, c: jl.Double) {\n}\n``\n. This one is better, but still some issues needs to be fixed. One more iteration is necessary.\n. Good job. Accepted, but I have fixed small issues by myself (see 89407fdcb23ab65d298c147d44a7af653d54c097):\n1. Typo in parameter name.\n2.advertisementwas passed as parameter, which is redundant.\n3. Extracted another method frominvoke`. As a rule of thumb, avoid IDEA's inspection \"Method is too complex to analyze by data flow algorithm\". If method is complex for a machine, what can we expect from a human? :)\n. Do you use IDEA's \"Extract Method\" refactoring? If not, get used to it, it is very useful.\n. Great job! Accepted.\nOnly minor remark: it's better to use postfix form of increment (i++). Prefix form may have been useful for old C compilers, but now it doesn't make sense.\n. Good job. Accepted.\n. Surely you changed format and made it better, so first option is the best (update test data).\nI can offer shortcut for this. Remove all .txt files in test data of related tests: loadJava, loadKotlin, etc. You can write tiny script or shell command for this. Afterwards, restart tests. .txt files will be generated automatically.\nDon't forget to look through changes in test data before committing to check that nothing was broken.\n. I looked through your pull request (not all, but big part of it). Generally, the functionality is good. But implementation seems to be overcomplicated. I spent a lot of time, but couldn't understand TypeCandidate, TypeOrExpressionThereof structures: they have a lot of state, difficult workflow, and hard to understand what they mean. The comprehension is also complicated by the fact that everything is one big source file, which is added in one commit. A dozen of small commits with gradual adding functionality would simplify the job of any reviewer. Now it's too late to split big commit into small ones, but keep this in mind later.\nFirst, try to simplify your code as much as it is possible. Prefer stateless data structures instead over stateful. Think about modularity (several small files are usually better than one big).\nFix various minor and medium problems all over the code, I'll add comments today.\nAfter it, explain how your implementation works, step-by-step. I guess, it would be better to start from explaining data structures.\nP. S. When fixing your code after my notes, please do it in next commits, so I'll be able to see the difference. If you will rebase it over origin/master, do it in new branch, because otherwise Github will lose all these comments.\n. If several componentX functions are missing, they it would be better to create them using one quickfix. Same about next + hasNext.\n. Bug. In this case quick fix is missing:\nfor ((a, b) in x) {\n    }\n. I have reviewed your change.\nThank you for contribution, your version is better, because it disallows \"\".toString(null). But it would be even better if you switched back to version with default value, but with String parameter type instead of String?. You can use Charset.defaultCharset().name() as a default value. This will require adding some external annotations for Charset methods, to avoid !! operator.\nPlease, change it and open new pull-request, with link to this one.\nBy the way, you seem to have something wrong with your git setup, because github doesn't recognize you as a author of this commit: 79311236078e6f4ff152b14e71e1c99bb1041cf4\n. I am proposing the following implementation:\npublic inline fun ByteArray.toString(encoding: String = Charset.defaultCharset().name()): String = String(this, encoding)\nor this:\npublic inline fun ByteArray.toString(encoding: Charset = Charset.defaultCharset()): String = String(this, encoding)\nOne function with default value is better than two overloaded functions, isn't it? It's Kotlin, not Java, let's use its power :)\n. There is a problem in your implementation. Adding type cast which never succeeds (Int to String or Int to some enum) is useless. Only casting to subtype makes sense.\nWhen adding tests, please add at least two with generic types (where quick fix is available, and where it is not).\n. I have performed some cleanup in your code and added external annotation for Charset.defaultCharset(). Please check 267bb01f62fa17f8aa93d21dbf0f814dc3118ef9\n. Yep. Done.\n. 1) \"Change to star projections\" and \"Change star projections to explicit types\" intentions are useful in any case.\nI think that it doesn't really matter if CastExpressionFix casts to type with stars or explicit types. Checking for stars would make implementation more complex (is Foo<*> and is Foo<Number> should be treated differently), and it doesn't worth it. Anyway, this case deserves a test :) Please add it without sending new pull request.\n2) It is a bug (see KT-624). I have also created related bug about this quick fix: KT-3543. Fixing bug in quick fix before fixing diagnostic doesn't make much sense.\n. Accepted.\n. Sorry, but I didn't have time to reply on previous pull request. I'll review it as soon as possible.\n. Sorry, but I couldn't review your pull request, because I was preparing for talks which I am going to give this weekend. I hope to answer you in the beginning of the next week.\n. I have looked through your pull request. It is much better. Thank you for not rewriting history, because otherwise I woudn't be able to tell reviewed code from not reviewed :)\n\nstill using MutableClassDescriptor.getScopeForMemberResolution() and not JetType.getMemberScope()\n\nYes, I checked and understood what the problem is. Anyway, depending on implementation class MutableClassDescriptor is bad, anyway. But it can be fixed pretty easily. LazyClassDescriptor has similar method, getScopeForMemberDeclarationResolution. It can be renamed to getScopeForMemberResolution and pushed to ClassDescriptor interface.\n\ndid not combine componentX or next/hasNext fixes\n\nOkay, this needs changing diagostics, I have added request: KT-3658\n\nOn a side note, I keep running into java.lang.OutOfMemoryError: PermGen space, even on master, when I run QuickFixTestGenerated.\n\nThat's strange, it doesn't reproduce for me.\nPlease fix problems mentioned above and in other commits. It makes sense to do it within current pull reqest instead of opening a new one.\n. About getScopeForMemberResolution: I see that you'll have to do it for java frontend. It really can be tricky, so don't bother to implement it.\nAbout PermGen: what is perm gen size when you run LoadJavaTestGenerated, and what JDK you have: 32 or 64 bit? You seem to have some default value which is not enough. You can run All IDEA Plugin Tests run configuration or provide VM option for default run configuration (you can just copy them from some of predefined run configuration).\nSummary: fix all that I mentioned except for casting to MutableClassDescriptor, and also try to get rid of substuting code, reusing TypeSubstitutor mechanism.\n. Yes, seems that TypeSubstitor won't help you.\nIn discussion of previous pull request you answered that type to be replaced is always a type parameter, which is wrong (Iterable<String> is not a type parameter). You seem to mix up parameter and argument terms. Parameter is variable, and argument is a concrete value provided for parameter.\n. Okay, now I see why misunderstanding happened :)\n. If you rebase now, it will be too different to review. Am I right that everything you have done by now is in this pull request?\nAfter reviewing, I'll try to rebase it myself. If it goes off smoothly, then great. If not, I'll ask you to fix integration problems.\n. I couldn't rebase smoothly, so I merged your changes instead. Tests were green.\nThank you!\n. If you want to continue working on this, please feel free to open new pull request.\n. Thank you! Merged manually.\n. @abreslav This needs corresponding YouTrack permissions for committer\n. Thank you!\nMerged manually.\n. Thank you, merged manually.\n. Thank you for your pull request. I beleive it could be implemented in a much simpler way. \nYou are resolving type from type reference manually, which is low-level. Alternatively, you can resolve function descriptor from function declaration, which is easier (e. g., you don't need scope provider). And in most use-sites of MainFunctionDetector the descriptor is already calculated, and can be obtained from binding context/trace:\n- KotlinToJVMBytecodeCompiler: see GenerationState;\n- ControlFlowAnalyzer: see trace field;\n- Translation: see context.bindingContext().\n  And the only one place really needs lazy resolve session, JetRunConfigurationProducer. Here you can use ResolveSession.resolveToDescriptor().\nPlease try to simplify it, and don't forget to run all tests. You can either update and reopen current pull request or create a new one.\nP. S. There were several files with unused imports. Please commit green code (without warnings) when it is possible.\n. The biggest problem with your pull request is that your intention is not integrated into IDE: it is tested, but it can't be invoked from UI. Please refer to plugin development documentation and other intentions in Kotlin plugin. Don't forget about intention description and before-after samples.\nThere are also a lot of cases which are not tested and can break user's code, here are some of them:\nx.get (property access)\nx.get(a = 1, b = 2)\n*x.get(23) { 2 * it }\nPlease check if there are other cases.\nAlso, there are several issues which I will mark in the code.\n. Yes, it's the easiest way to do. You can invoke git reset --soft HEAD^ to revert last commit, but not touch any local files.\n. By the way, reverting using \"git revert\" is not a good way to do, because it pollutes commit history. Use interactive rebase, amend commit and similar features. See Keeping Commit Histories Clean and other articles (google \"keeping git history clean\")\n. This attempt is better, but there are still several issues.\nI think that typechecking is not necessary for this intention, since it is pretty trivial. It's more important for the intention to leave the code correct, if it was correct before. If user's code has errors, but we we can understand what it means, why not apply intention?\nDid you try your intention in IDEA? For me it throws exception each time I try to invoke it: java.lang.AssertionError: 'get.call.replacement.family' is not found in java.util.PropertyResourceBundle@2d285de9\nAlso, some cases are still not covered by implementation and/or tests:\n- x.get(23) { 2 * it }: it just removes function literal; see Function literals\n- infix call of get\n- infix call with simple argument plus function literal\n- maybe, something else? Please look through Kotlin documentation for possible syntax constructs.\nUsability problem: your intention is available when caret is on any part of qualified expression. Consider the following case: args.map { <caret>it.length }.filter { it > 3 }.get(1). Here your intention becomes applicable, but it's hard for user to understand why is it here at all. What if receiver is even longer, several lines long? What if there are more intentions available at that, and \"Replace with array access\" is just polluting list of them? Maybe it should be applicable when caret is on callee only? And don't forget about tests.\nPlease note that PR and commit messages should be informative for the reader, which reads VCS history or title of PR. Clean history is important if PR is going to be accepted.\nYou changed UI name for the intention, which is good. But internal name of it (class name & bundle ID, etc) is still of ouf sync with other intentions. All our intentions are called \"DoSomethingIntention\", whil yours is \"SomethingDoingIntention\". When coming up for a name for some entity, find something similar in existing code base and follow the convention.\n. Okay, please comment when your code is ready for reviewing.\n. Please clean commit history before reviewing. It shouldn't have merge commits, etc. You can start from clean master branch, and then cherry-pick commits that you want.\nDid you rerun \"Generate Tests\"? Because if you do, obsolete method call should be gone.\n. Am I right that you're ready for reviewing now?\n. I tried to checkout your current version, and it's not compilable (because of broken references in the code). If the code is not compilable, you can't run \"Generate Tests\". How did you manage to run generator at all?\nIn abstract test class, you need to fix compilation error manually. In generated test you can just comment out broken code or even remove the class completely, and rerun \"Generate Tests\".\n. About commit history. Now it looks much better. The main criterion for commit messages and structure is how these commits will be readable in several months for people who are out of context.\nTo satisfy you requirement \"Implemented foo bar intention\" is better than \"Finished first iteration of foo bar intention\". And regarding this particular task, where new feature is pretty isolated, it may be better to cosolidate (squash) all of your commits into one with concise message.\n. Good news! Don't forget to comment that you are ready.\n. Oh, yes, sure. But infix call can take function literal as right hand argument, don't forget about that.\n. This looks good!\nThere are still some minor issues. E. g., these cases are neither tested nor supported:\n- get { it } \u2013 intention is not applicable;\n- x.get(   ) { it } \u2013 is transformed to x[   , { it }].\n. Why did you open a new pull request, which is also not ready for reviewing?\n. Alternative way is to reset state of your branch to master, and cherry-pick your commits one-by-one using their hashes.\n. Steven, when are you going to continue working on this task?\n. Steven, what are your plans regarding this pull request?\n. Sorry for delay, I'll look into it this week.\n. Good job, thank you for your contribution!\nDon't think that code in JetRunConfigurationProducer can be done simpler.\nI have removed unused imports in JetRunConfigurationProducer, updated code to current master, and merged manually.\n. Already in master.\n. Looks good, but there some issues with implementation.\nIf-else should be supported, indeed.\nCases which are not covered with tests:\nadd tests:\n- if-else, incl. cases when one branch is with braces, and other is not\n- if-else in expression position (assigned or passed somewhere)\n- if (true) println(); (with semicolon)\n- \nif (true) {\n      //comment\n      println()\n  }\n. Please comment when you fix issues and are ready for next review iteration.\n. Yes.\n. What are your plans for fixing these issues?\nIf you have any questions or problems, don't hesitate to ask.\n. This one is better. I have marked up your code with notes.\nAnother one: \"Second Iteration\" in commit message means nothing to somebody who will read VCS history later.\nTell me when you are ready for next review.\n. I'm not sure if case with comments should be supported at all. My initial suggestion was to add test for this case. I didn't think if this case should be supported or not, but it should be tested at least.\n. That's a reason to support it in Kotin, as well. What's the problem with putting extracted comments before constrol structure?\n. I have checked your current implementation, it looks good, disregarding comments issue.\n. Hm. Why not use JetPsiFactory.createNewLine?\n. Here's the dirty code that you can use as a starting point:\nval whitespace = element.getParent()!!.addBefore(JetPsiFactory.createNewLine(element.getProject()), element)\n            element.getParent()!!.addBefore(comments[0], whitespace)\n. Now it looks good! I have merged it manually, thank you.\n. Gavin, can you look into it?\n. Oh, wow, so quick :)\n. You can sign up in our issue tracker by yourself.\n. @jdkaplan, when this pull request is going to be ready for next review?\n. @amal Can you please respond on this feedback?\n. Side note: please write meaningful commit messages, e. g.:\n```\nKT-4569 Intention to simplify booleans expression with constants\n#KT-4569 fixed\n```\nAnd commits like \"fixes\" should be squashed into original one at the end of review. Thank you.\n. Seems that you rebased master onto your branch, instead of the opposite. No need in opening new pull requests. You can use force push to fix it.\n- Checkout my_brahch\n- git fetch --all\n- git rebase origin/master\n- git push -f origin my_branch (branch name is essential, because otherwise it will force push all branches, which is bad)\n  Be careful, force push is a dangerous feature, it should be used only for your private branches, but not for ones which are shared among users (e.g., master)\nImplementation-related question will be answered by @NataliaUkhorskaya\n. Mikhail is on vacation now, he will look into your changes at the end of this week or next week.\n. Please always add reference to previous iteration of pull request\n. Reference to original issue (KT-4564) is better than nothing ;)\n. What exactly is wrong with interactive rebase?\n. It's @orangy, who will be actually reviewing this pull request, but I wanted to point on issues that I see: there are too much commits. Most of them have the same commit message and similar meaning. If you have problems with interactive rebase, you can try to cherry-pick desired commits manually onto clean head.\n. It seems that you rebased/cherry-picked onto master, but after it you merged everything with remote branch (perhaps, by invoking git pull), and now it looks even more weird :) I guess that you need to remove last merge commit and then perform git push -f origin KT-4288_slice_func\n. Yes, it's better to fix it. It shouldn't take much time :)\ncheckout KT-4288_slice_func\ngit reset --hard HEAD^\ngit push -f origin KT-4288_slice_func\n. Please add always issue ID in description commit message and don't forget to comment corresponding issue in YouTrack.\n. I look at the code and don't understand why safe call is needed at all after expressionKind is already checked for null. Any ideas?\n. Yes, I looked at stack trace and it looked weird for me, as well. But anyway you need to reproduce the bug and investigate why it happened to be sure that it is fixed correctly now.\nAnd also, this is not really a good fix, because in situations when there would be exceptions now \"Add braces to 'null' statement\" would be shown, which is also a bug :)\n. BTW, no need to close pull request, you can leave it open and add commits later.\n. First, investigate the workflow of intentions creation and calls of isApplicable and invoke methods. From which threads they are called? Who does call them? How many instances of intention objects are created? Are they per-project, per-editor, per-psifile, or per-application, how they are reused?\nAdd debug output with thread names, breakpoints in corresponding methods, etc. When you understand how the problem is induced, it will be easier to verify if some fix really fixes it.\nRegarding your current fix: you converted expressionKind to local val, but caretLocation is still a property which is shared among different threads. When some threads share state, code accessing this state doesn't even need to be called at the same time from different threads: one thread can have cached value and not see other thread state.\nI think that the easiest fix for this would be to eliminate object state at all. Probably, it means that you'll need to override isAvailable without calling methods defined in JetSelfTargetingIntention. But first, you need to diagnose the problem to understand which causes it.\n. We need to get it fixed before releasing M7 today, so I'll have to fix it myself.\n. Just for your information: f61470943aa0576c159190f589df483e68431d48\n. Guys,\nTo avoid such coincidences, it's a good idea to add comment on issue you'd like to fix before actually fixing it :)\n. And also, when issue is already assigned to anybody (like it was for this issue), it's probably a bad idea to implement it silently, without notificating assignee.\n. @jrenner No worries, just be careful next time :)\n. Merged manually\n. @alextkachman, any news on this pull request?\n. Please don't forget second part of this intention ;)\n. Please don't forget to add reference to issue in tracker next time.\n. @pk382 Any news on this?\n. Hello, Ross,\nPlease tell if you are going to finish work on this pull request.\n. Please describe what happens in pull request in its name.\n. Previous pull request: #459\n. merged manually\n. Type checking for += merged, disambiguation of plus and plusAssign and related commits postponed.\n. Thank you! Merged manually.\n. Merged manually.\n. Makes sense, thank you. Merged manually.\n. Looks reasonable, thank you. I'm cherry-picking it.\n. Is that all error log you have?\n. You're right, that is caused by JDK 8. There is compilation error:\nERROR: libraries/stdlib/src/kotlin/io/ReadWrite.kt: (156, 37) Type mismatch: inferred type is java.util.stream.Stream<kotlin.String!>! but kotlin.Stream<kotlin.String> was expected\nThank you!\n. Thank you!\n. What do you think about removing redundant abstraction which becomes redundant? I mean KotlinModuleDescriptionBuilder and KotlinModuleDescriptionBuilderFactory interfaces, and also KotlinModuleScriptBuilderFactory implementation which is trivial.\n. Thank you! Merged it manually.\n. Looks good to me (except for minor notes)\n. This looks not very intuitive to me.\n. Pushed\n. Oops, my fault\n. I would like to finish it next week.\nOn Tuesday, 19 January 2016, Andrey Breslav notifications@github.com\nwrote:\n\n@geevee https://github.com/geevee What are your plans regarding this?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/798#issuecomment-172847311.\n\n\n\nEvgeny Gerashchenko\n. Since I have access to main kotlin repo no more, I have created new pull request with my fork. See #813\n. Also, for loop is more readable than while.\n. semicolons are noise which is unnecessary in Kotlin :)\n. I think it's better to throw IllegalArgumentException if n < 0, because it doesn't make much sense to hide user's error and return empty string in this case.\n. Quadruple complexity is unacceptable for standard function. It's better to add custom implementation for this function in JS runtime later.\n. Exception should surely contain meaningful message.\n. Yes, require() will do, only if you add error message. It should contain actual parameter passed, for easier diagnostics.\n. All the boilerplate starting from this line can be avoided by casting to DiagnosticWithParameters1> instead of raw type.\n. Is this check necessary? Maybe remove it or replace with assert?\n. This condition is equivalent to usages.isEmpty(), which is more straightforward and can be checked before loop.\n. This method is pretty long. Consider extracting methods for it. First candidate for extracting is code about live template in the end of the method.\n. Makes sense.\n. Yes, you're right.\n. UnsupportedOperationException would be a better choice\n. This piece of code can be replaced with NavigationUtil.activateFileWithPsiElement(klass)\n. A lot of not optimized imports.\nWhen committing, check that you your code is green (no warnings). If you edit some code, assure that you don't introduce new warnings.\n. Why converting this to array? Why not return list?\n. In Kotlin, we call them functions, not methods. Please, rename it here and in other code.\n. Can you come up with better use case for quick fix creating class object? This one from the test doesn't seem useful.\nCreating class object via intetion could be useful in case of T.foo() call, but in this case foo() function should be created as well (actually, it should be \"create function from usage\" quick fix, not \"create class object from usage\").\n. Isn't it better to remove type parameter of class to avoid confusing when reading test? Or is it intentional?\n. Five constructors for non-API constructor seems to be too much. Maybe provide default values manually on call sites?\n. Use ArrayList instead of array. This won't take much extra memory, but will simplify code.\n. I don't understand what this method does.\n. What does mean \"applied\"?\n. Use list, and Collections.reverse() afterwards.\n. We already have class called TypeSubstitution in Kotlin codebase, so, this name is too confusing.\n. Make popup look the same as for Java, see screenshot:\n\n. Why not use TypeCandidate instances as list elements? This would make it possible to avoid having String \u2192 TypeCandidate map.\n. Why not check getSelectedValue() for null, if we access it anyway?\n. doInvoke is not a good name, because it doesn't explain how it differs from simple invoke. Rename it to addFunctionToSelectedOwner or something like that.\n. Why is project passed via parameter, while other stuff (currentFileContext, etc) is passed via fields? That's strange. By the way, project can be obtained from any psi element, so you don't need save/pass it explicitly.\n. It's class declaration, not type declaration. Please rename.\n. Checking for null is redundant when checking for instanceof.\n. This code relies on implementation details. What if actual type of ownerClassDescriptor is LazyClassDescriptor? Replace it with receiverType.getMemberScope()\n. project parameter is redundant, see above.\n. Return immediately to avoid reassignment.\n. Return immediately to avoid reassignment.\n. Don't use such names, please. Even if parameter is not used.\n. I don't understand what does this method do, but I feel that it can be replaced with using already existing TypeSubstitutor mechanism. Please check it.\n. You seem to mix up \"co\" and \"contra\" prefixes.\n. I think, it's better to merge this and next method (with @Nullable scope)\nAdd comment, that for Foo name from parameter it returns itself, if it is available, and Foo1, Foo2, .. if it's not.\n. If this method returns several types, maybe it should be named guessTypes...?\nThe method is very complex.\n- Reassigning local variables is usually a bad style, because it makes code harder to comprehend and refactor.\n- Combination of reassignments and deep if-else-if is even worse.\n  I offer extracting method guessTypesForDeclaration and use it immediately instead of assigning to declaration. This will allow removing reassigned variable and make each if end with return, and elses will be unnecessary.\n. Why not just guess by declaration immediately, without checking BindingContext.TYPE? Wouldn't it be enough?\n. Method is trivial and used once. It's redundant.\n. Yes, I know. Anyway, can you come up with use case for \"Create class object from usage\"? If not, why not remove the subfeature that won't be used?\n. Yes, it's okay to preserve consistency. The API itself worth changing to lists, but it's not critical.\n. When they are referred as \"methods\" in code, it is usually an error (except for some individual cases). For UI it is error as well, but more critical.\n. When some class is a \"processor\", i.e. it exists only for computing something, it is the best practice to pass initial data via constructor and save it to final fields, to avoid redundant parameters passing.\n. What does mean \"cannot resolve\"?\n. Isn't type to be replaced always a type parameter?\n. You know what is JetType. TypeConstructor is a function (mapping) from type parameters to type. When you provide type arguments for TypeConstructor, you get JetType. Each TypeConstructor is associated with classifier: either class or type parameter descriptor.\nPlease replace all your type substituting logic with reusing TypeSubstitor. It will simplify everything a lot.\n. This behavior is objectionable: order of predicates evaluation can change program behavior, when evaluated expressions have side effects. I'll disable intention in this case.\n. Changes like this in meta-information should be carefully reviewed before committing, because they can easily break compilation or workflow for other developers.\n. This change is harmful, as well.\n. That's not a good name for an intention. The name should be \"Do something\", with correct capitalization.\nIn such cases, always refer to existing UI elements, so the new features will be consistent with common style.\n. Code formatting is inconsistent.\n. No need to save project to local property: it can be obtained from element\n. Specifying return type in function literal is redundant here. Explicit parameter can be also omitted (\"it\" name will be auto-generated for it).\n. Why not applicable here? x!![1] looks pretty okay\n. This should be reverted\n. Capitalization of family name is correct, but of intention text is not. See other intentions as a reference.\n. Obviously, won't work for else\n. \"bodyNode\" would be a better name\n. You are replace element before expression with block, and then add whitespace. Why not replace expression with block directly? Also, this works incorrectly for if (true)println()\n. Am I right that this sequence of safe calls is only because bodyElement can be null? Shouldn't it be checked in isApplicable? Otherwise there can be case when intention is available i UI, but will have no effect, which is confusing.\nSide note: if some condition is to hard to check in isApplicable, it's a good idea to show error message.\n. Duplicate code.\n. Safe call is redundant: we already checked for null in isApplicable.\n. Redundant safe calls again\n. Some imports are unused here :)\n. Why are this and the following functions extensions, but you don't use this in them and require call sites to pass same value twice?\n. Use the power of Kotlin :) Four lines can be replaced with return bodyNode?.getPsi()?.getFirstChild() as? JetBlockExpression\n. \"Expression type\" phrase usually means different thing, so this usage of it is misleading. Better to replace \"type\" word with \"kind\". Don't forget that you have this phrase in several other places.\nAlso, it's better to use enumeration instead of strings, because it's more type-safe. Enumeration can be named ExpressionBlockKind or something like this.\n. Stricter way is to find \"else\" keyword directly by element.getNode().findChildByType(JetTokens.ELSE_KEYWORD). And this \"minus 5\" looks very esoteric anyway :)\n. This code for distinguishing \"if\" from \"else\" has two problems:\n- It is duplicated (here and symmetric intention)\n- It is spread among two places: first getExpressionType returns else (which actually means \"if or else, I don't know yet), and then it is recalculated for if-else case.\n  Alternative it to pass caret position to getExpressionType, so all these calculations will be there.\n. Checking for is PsiWhiteSpace is more robust.\n. Shouldn't it be just an else for previous if?\n. What is this for? Couldn't understand without comment.\n. With this function name, it's hard to guess what it does and what does it return. What about \"extractComments\"?\nIt return ArrayList, while just List would be enough.\n. This indent blows minds. I thought that this assignment relates to if.\nWhy safe call here? sibling is not null before assignment here.\n. Another redundant safe call.\n. Typo in file name.\n. Storing string representation in enum is a good idea.\nI think this enum shouldn't be public and is better to put it near corresponding methods in Utils.kt\n. Commented imports? Are you sure? :)\n. [this is a dummy comment, please ignore it]\n. Please, get rid of code duplication.\n. What does \"call\" mean here?\n. IDEA says this method can be static. And I believe it ;)\n. constant == null can be removed, because \"instanceof\" is false for null anyway\n. This check seems redundant, because we already checked that constant is not long\n. Should be replaced with assert, because it can be null only for code with syntax errors.\nCommon rule: if some method of PSI (JetExpression, JetWhenCondition, JetWhatever...) is annotated as @Nullable @IfNotParsed, it returns null only if code has syntax errors. Front-end should be tolerant to nulls here, while back-end can be assert it.\n. Why is this filtering here? It seem to have no effect, anyway.\n. I beleive it would be good to add comment explaining why \"status\" here is top-level property instead of local variable.\n. Please make function literal here non-trivial.\n. I beleive this was commited erroneously.\n. public?\n. Thank you, I have rewritten to materialize last two characters as String.\n. Thank you! I have used your idea. Java doesn't have check for unclosed comments in parser at all. It is performed in HighlightUtil instead.\n. ",
    "jstrachan": "Patch applied with thanks!\n. I think this can be closed now right? its implemented now?\n. I've merged this pull request for now - thanks! Any jdk-headers changes can be added later too\n. Yeah - I'm mid-way through implementing the lazy versions of the standard map/flatMap/filter/find et al on Iterator (hit a compiler bug) - will take a look at merging those and the Sequence things together next week...\n. Agreed BTW that these should be Iterators rather than Iterables - as the function is likely not going to support re-iteration\n. On 23 March 2012 15:20, Andrey Breslav\nreply@reply.github.com\nwrote:\n\nWhat compiler bug? Could you provide an issue ID? Thanks.\n\nAn issue will be on the way shortly :)\n\nJames\nFuseSource\nEmail: james@fusesource.com\nWeb: http://fusesource.com\nTwitter: jstrachan\nBlog: http://macstrac.blogspot.com/\nOpen Source Integration\n. Incidentally we've now an iterate { ... } helper method for creating an Iterator from a function returning T? (using the null to indicate the end of the iteration)\nhttp://jetbrains.github.com/kotlin/versions/snapshot/apidocs/kotlin/package-summary.html#iterate(jet.Function0)\nthere's also lazy versions of the filter methods; lazy versions of map/flatMap to follow soon...\n. These changes look great - I wonder is there any chance you could rebase (merge latest changes from the repo into your fork) and then resubmit this change; then I can merge it in with a single click? :) Let me know if you can't easily do that and I\"ll try figure out how to merge this in\n. patch applied with thanks! sorry it took so long!\n. Thanks for this - great catch :) \nI wonder if fold-with-Comparitor should be the exception; so \"fold\" should be the foldLeft (the really common fold operation most folks tend to do). foldRight is as you suggest, then use foldWith / foldBy / foldSorted the method which requires a comparator first?\n. Agreed. Thanks for your patch & looking forward to the next one for foldRight :) \nMaybe we just punt on the foldSorted method for now as folks can always do\nsomething.sortBy{ ...}.fold(0) { a, b -> a + b }\ni.e. sort the collection with a comparator first then fold\n. Yay! :) \n. Hi Alexander!\nOn 24 June 2012 16:02, Alexander Zolotov\nreply@reply.github.com\nwrote:\n\n@jstrachan. Hi. I have some problems with implementing functions for processing collections. Since you have closed my previous pull requests may be you can help me?\nProblem 1.\nI've implemented sortBy function in this commit but kotlin-js-tests fails and I don't understand why. Stdlib tests pass successfully, but js-tests fail with following message:\nERROR: /kotlin/JLangIterablesSpecial.kt.jet: (83, 44) Unresolved reference: comparator\n\u00a0 \u00a0ERROR: /kotlin/JLangIterablesSpecial.kt.jet: (83, 57) Cannot infer a type for this parameter. To specify it explicitly use the {(p : Type) => ...} notation\n\u00a0 \u00a0ERROR: /kotlin/JLangIterablesSpecial.kt.jet: (83, 60) Cannot infer a type for this parameter. To specify it explicitly use the {(p : Type) => ...} notation\n\nIts a long story - but I've disabled kotlin-js-tests for now in the\nbuild. Its taking some time getting the standard library compiling to\nJS, then getting the unit tests compiling to JS and getting the tests\nto pass :). More on how all that stuff works here:\nhttps://github.com/JetBrains/kotlin/blob/master/js/ReadMe.md\nFor now don't worry about it and I can try fix it up. (Getting the JS\ngenerated code working is rather a long story).\nIf you do a pull and re-run your build it'll probably work. If so\nsubmit a pull request and I can merge it super quickly with a single\nclick :)\n\nProblem 2.\nIn the same commit I've placed sortBy function in JLangIterablesSpecial because in other way, generated code for arrays doesn't pass test case:\ntest fun sortBy() {\n\u00a0 \u00a0 \u00a0 \u00a0expect(arrayList(-1, 2, -3)) { intArray(-3, -1, 2).sortBy { Math.abs(it) }}\n\u00a0 \u00a0 \u00a0 \u00a0expect(arrayList<Float>(-1.toFloat(), 2.toFloat(), -3.toFloat())) { floatArray(-3.toFloat(), -1.toFloat(), 2.toFloat()).sortBy { Math.abs(it) }}\n\u00a0 \u00a0 \u00a0 \u00a0expect(arrayList(-1.0, 2.0, -3.0)) { doubleArray(-3.0, -1.0, 2.0).sortBy { Math.abs(it) }}\n\u00a0 \u00a0 \u00a0 \u00a0expect(arrayList<Byte>(5, 3, 4)) { byteArray(3, 4, 5).sortBy { it mod 5 } }\n\u00a0 \u00a0 \u00a0 \u00a0expect(arrayList<Short>(5, 3, 4)) { shortArray(3, 4, 5).sortBy { it mod 5 } }\n\u00a0 \u00a0 \u00a0 \u00a0expect(arrayList<Long>(5, 3, 4)) { longArray(3, 4, 5).sortBy { it mod 5 } }\n\u00a0 \u00a0 \u00a0 \u00a0expect(arrayList('1', '2', '3')) { charArray('1', '3', '2').sortBy { it } }\n\u00a0 \u00a0}\nIt's can't resolve it variable.\n\nLets go ahead and commit the working code for collections and we can\nlook at how to get it working for arrays; it'll be easier for me to\ngrok once the collection code is there.\n\nProblem (question) 3\nCurrent implementation of List<T>.sort (JUtil.kt) method leads astray. It change inner state of list and returns it in the same time. For example:\nval someList = arrayList(3, 1, 2)\nval minimum = someList.sort().first() // 1, its OK\nval firstValue = someList.first() // 1, WTF? :-)\nIt don't make sense return Unit from this function because it becomes simple shortcut for Collections.sort().\nBut it make sense to return sorted copy of list, I believe. It will allow to extend sorting method for all iterables (or collections) including immutable lists, not only for mutable lists.\nWhat do you thing about it?\n\nYeah - I agree.\n\nBtw, List<T>.reverse method (JUtil.kt) confused me even more=) It return reverted list for List and reverted copy for other iterables:\n```\n\u00a0 \u00a0 \u00a0 \u00a0val list : java.util.List = arrayList(1, 2, 3)\n\u00a0 \u00a0 \u00a0 \u00a0println(list.reverse().first()) // 3\n\u00a0 \u00a0 \u00a0 \u00a0println(list.first()) // 3\nval coll : java.util.Collection = arrayList(1, 2, 3)\n\u00a0 \u00a0 \u00a0 \u00a0println(coll.reverse().first()) // 3\n\u00a0 \u00a0 \u00a0 \u00a0println(coll.first()) // 1\n```\n\nGreat catch - that sucks.\nEither we have 2 special List only methods for reverse-this and\nsort-this (rather than making a sorted/reversed copy), or we make\nreverse() and sort() always return a mutated copy - and so work for\nany collection/iterable/array.\n\nProblem 4\nI want to implement flatten function for iterables. In Java it may looks like this:\n```\nimport static org.testng.Assert.assertEquals;\nimport org.testng.annotations.Test;\nimport java.util.*;\npublic class FlattenTest {\npublic > List flatten(Iterable iterable) {\n```\n\nWonder if it should take an Iterable>; rather than just a\nCollection? Though I guess some Collection implementations may have\nmore optimal addAll methods.\n\nList result = new ArrayList();\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (Collection innerCollection : iterable) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0result.addAll(innerCollection);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return result;\n\u00a0 \u00a0 \u00a0 \u00a0}\n@Test\n\u00a0 \u00a0 \u00a0 \u00a0public void test() {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0ArrayList expectedList = new ArrayList() {{\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(1);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(2);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(3);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(4);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}};\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0assertEquals(flatten(new ArrayList>() {{\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(new ArrayList() {{\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(1);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(2);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}});\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(new ArrayList() {{\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(3);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(4);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}});\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}}), expectedList);\nassertEquals(flatten(new ArrayList>() {{\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(new ArrayList() {{\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(1);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(2);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}});\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(new ArrayList() {{\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(3);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0add(4);\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}});\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}}), expectedList);\n\u00a0 \u00a0 \u00a0 \u00a0}\n}\n``````\nIn Kotlin I can't implement it. May be it is a bug of Kotlin or bug of me, I don't know=)\nThis implementation can't resolve fold method for R:\n``````\npublic inline fun > java.lang.Iterable.flatten(): java.util.Collection {\n\u00a0 \u00a0return this.fold(arrayList()) { (x, y) ->\n\u00a0 \u00a0 \u00a0 \u00a0x.addAll(y)\n\u00a0 \u00a0 \u00a0 \u00a0x\n\u00a0 \u00a0}\n}\n\ndoes passing the fold type parameter explicitly help?\nreturn this.fold>(arrayList()) { (x, y) ->\noften Kotlin can't automatically guess the inferred types on methods currently.\n\n```\nAnd this implementations works for Collection, for List and for ArrayList, respectively:\n```\n// works only for arrayList>(arrayList(1, 2), arrayList(3, 4)).flatten()\npublic inline fun  java.lang.Iterable>.flatten(): java.util.Collection {\n\u00a0 \u00a0return this.fold(arrayList()) { (x, y) ->\n\u00a0 \u00a0 \u00a0 \u00a0x.addAll(y)\n\u00a0 \u00a0 \u00a0 \u00a0x\n\u00a0 \u00a0}\n}\n// works only for arrayList(arrayList(1, 2), arrayList(3, 4)).flatten()\npublic inline fun  java.lang.Iterable>.flatten(): java.util.Collection {\n\u00a0 \u00a0return this.fold(arrayList()) { (x, y) ->\n\u00a0 \u00a0 \u00a0 \u00a0x.addAll(y)\n\u00a0 \u00a0 \u00a0 \u00a0x\n\u00a0 \u00a0}\n}\n// works only for arrayList>(arrayList(1, 2), arrayList(3, 4)).flatten()\npublic inline fun  java.lang.Iterable>.flatten(): java.util.Collection {\n\u00a0 \u00a0return this.fold(arrayList()) { (x, y) ->\n\u00a0 \u00a0 \u00a0 \u00a0x.addAll(y)\n\u00a0 \u00a0 \u00a0 \u00a0x\n\u00a0 \u00a0}\n}\n```\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/JetBrains/kotlin/pull/78#issuecomment-6533534\n```\n\nIf you're stuck on the flatten, feel free to shoot me a patch and I'll\ntry get it working for you.\nKeep up the great work! :)\n\nJames\nFuseSource\nEmail: james@fusesource.com\nWeb: http://fusesource.com\nTwitter: jstrachan\nBlog: http://macstrac.blogspot.com/\nOpen Source Integration\n. On 25 June 2012 11:49, Alexander Zolotov\nreply@reply.github.com\nwrote:\n\n@jstrachan thank you for your answers, very helpful.\n\nIf you do a pull and re-run your build it'll probably work\n\nHowever js-tests fail anyway :) I'll try to work it out.\n\nFeel free to comment out the js-tests module in the libraries/pom.xml\nin the  section and I can help fix that one later if you\nlike?\n\n\nEither we have 2 special List only methods for reverse-this and\nsort-this (rather than making a sorted/reversed copy), or we make\nreverse() and sort() always return a mutated copy - and so work for\nany collection/iterable/array.\n\nIf you don't mind I'll reimplement all reverse and sort functions for all iterables with copy-returning strategy and delete that special function for List.\n\nSounds good!\n\n\ndoes passing the fold type parameter explicitly help?\n\u00a0return this.fold>(arrayList()) { (x, y) ->\noften Kotlin can't automatically guess the inferred types on methods currently.\n\npublic inline fun <in T, R : java.util.Collection<T>> java.lang.Iterable<out R>.flatten(): java.util.Collection<T> {\n\u00a0 \u00a0return (this as java.lang.Iterable<java.util.Collection<T>>).fold(arrayList<T>()) { (x, y) ->\n\u00a0 \u00a0 \u00a0 \u00a0x.addAll(y)\n\u00a0 \u00a0 \u00a0 \u00a0x\n\u00a0 \u00a0}\n}\nIt helped to resolve fold method, but anyway I have to passing explicity help for clients of method too:\narrayList(arrayList<Int>(1, 2), arrayList<Int>(3, 4)).flatten<Int, java.util.Collection<Int>>()\nLikely I'll send you patch with that function and tests :)\n\nAwesome thanks!\n\nJames\nFuseSource\nEmail: james@fusesource.com\nWeb: http://fusesource.com\nTwitter: jstrachan\nBlog: http://macstrac.blogspot.com/\nOpen Source Integration\n. you could write this as the following right?\nauthenticate(username, password).map {\n    views.html.index(it)\n} ?: views.html.login(\"Invalid username or password\")\n. Many thanks for this pull request! Good stuff! We really could do with language level string templates too! :)\nI've made a few minor changes after the merge:\n- moved the Map.toProperties() function into the standard library itself (along with a test case) as its kinda handy generally\n- migrated the test cases to JUnit 4 style annotations rather than the JUnit 3 style (which we only used way back when due to annotation support not quite being there)\n- made Connection.use() take a  and return it as the value so a use block can be an expression now\n- am still pondering ResultSet.getMapped(); which is basically the same as the existing ResultSet.map() (which is similar to the Collection/Iterable/Iterator map() function). I like using 'map' as the function name everywhere on any kind of container/collection/iterable/array. However folks usually want to process ResultSets lazily. So I'm wondering if we should amend ResultSet.map() to return an Iterator? Then there would be no 'getMapped' there'd just be map() and by default ResultSet would work lazily; forcing users to use toList() if they really want to materialise the entire thing?\nIncidentally here's a test case showing the current map() in effect:\nhttps://github.com/JetBrains/kotlin/commit/9a33ca43bbf1dcb104c66174fab1dfe67320af3d\n. Actually I just went a head and used your getMapped() implementation as the map() implementation on ResultSet and removed mine :). (i.e. renamed your getMapped() to map). So ResultSet has a map() function like everything else in the standard library; being lazy by default.\nThis should avoid folks accidentally blowing their memory if they use map() on a massive result set.\nOne effect of this is that you tend to need to explicitly add a toList() or something inside the function when doing queries to return a List e.g.\nhttps://github.com/JetBrains/kotlin/blob/master/libraries/kotlin-jdbc/src/test/kotlin/test/kotlin/jdbc/JdbcTemplateTest.kt#L30\nbut thats a small price to pay I think\n. I wonder if you could create a pull request without the \"Merge remote-tracking branch 'upstream/master'\" changes? e.g. just with the 4b3cb9a and fc74a62 commits? Then its super easy to apply? (BTW the git trick is to rebase rather than merge to avoid getting those merges in your commit log)\n. sure, I'll get around to it eventually - its just if you omitted the merge in a pull request I can apply it with 1 click of a mouse button on the github website. \ndoing manual cherry picks of individual commits from a remote repo requires much more work for folks trying to apply your pull request\n. ",
    "shemnon": "It is a workaround for sure, good enough for an immediate fix.   \nThe real question is if anyone depends on the ACC_STATIC flag being set before the class bytes are generated.  I still consider it an error that the object class is having ACC_STATIC requested from the backend of the code.\nIf we were to be rigourous we would likely want to only allow the legal flags through at that point., and not just snipe out static (there are some others IIRC).  But it should be good enough for now to toss it into dalvik and see what the next problem it complains about.\n. ",
    "alextkachman": "Yes, someone depends and depends big time :(\nOn Mon, Mar 12, 2012 at 4:25 PM, Danno Ferrin <\nreply@reply.github.com\n\nwrote:\nIt is a workaround for sure, good enough for an immediate fix.\nThe real question is if anyone depends on the ACC_STATIC flag being set\nbefore the class bytes are generated.  I still consider it an error that\nthe object class is having ACC_STATIC requested from the backend of the\ncode.\nIf we were to be rigourous we would likely want to only allow the legal\nflags through at that point., and not just snipe out static (there are some\nothers IIRC).  But it should be good enough for now to toss it into dalvik\nand see what the next problem it complains about.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/JetBrains/kotlin/pull/20#issuecomment-4452769\n\n\nBest regards,\nAlex\nBest way to call / chat with me\nhttp://lucy.me/alex\n. Natasha, could you please email me patch file. No idea how to take it from GitHub\n. Could you please update pull request, so it can be merged automatically.\n. Very nice.\niterator() method could be useful.\n. Re: Maybe 'sum' of Bytes and Shorts should return 'Int' to be consistent with '+', what do you think?\nABSOLUTELY\n. It can't be done this way - no chance for is/instanceof to work\n. You can do\nvar arr = IntArray(10)\narr.iterator()\nbut you will always have on JVM level \"arr instanceof int[]\", so in Kotlin \"arr is Iterable == false\"\n. I think contra-variant option is most natural. Never was able to understand java convention of get(Object) except that it allows avoid unneeded checkcast\n. My pleasure. I am using k2js a bit now so you can expect few more PR\n. It's both performance and obfuscated code size issue. I consider to move with very big js code base to kotlin and both are requirements.\nAs of now the pull request not only moves static functions but also substitute all calls.\n. It's a possibility. But then it need to be enabled in IDE as well. Right?\nI still not sure why generating better compressible and a bit more\nperformant code should be optional? Is there anything we lose by making it\nstandard mode?\nOn Tue, Apr 8, 2014 at 6:32 PM, Zalim Bashorov notifications@github.comwrote:\n\nWell, I think it should be optional feature which will be disabled by\ndefault and user can enabled it by command line argument.\n\nReply to this email directly or view it on GitHubhttps://github.com/JetBrains/kotlin/pull/439#issuecomment-39862663\n.\n\n\nBest regards,\nAlex\nBest way to call / chat with me\nhttp://lucy.me/alex\n. So how do we propagate this to IDEA settings?\nOn Tue, Apr 8, 2014 at 7:33 PM, Zalim Bashorov notifications@github.comwrote:\n\nif I remember correctly the library which we used now for parsing command\nline arguments don't allow use space here.\n\nReply to this email directly or view it on GitHubhttps://github.com/JetBrains/kotlin/pull/439#issuecomment-39870716\n.\n\n\nBest regards,\nAlex\nBest way to call / chat with me\nhttp://lucy.me/alex\n. So effectively the benchmark says that performance-wise the difference is\nnot that important and browser dependent. Still the gain from obfuscated\ncode size is obvious.\nOn Tue, Apr 8, 2014 at 7:26 PM, Zalim Bashorov notifications@github.comwrote:\n\nAdditionally, it probably will be interesting for you\nhttp://jsperf.com/direct-call-vs-qualified-call .\nI made a little benchmark and ran it in some browsers.\n\nReply to this email directly or view it on GitHubhttps://github.com/JetBrains/kotlin/pull/439#issuecomment-39869848\n.\n\n\nBest regards,\nAlex\nBest way to call / chat with me\nhttp://lucy.me/alex\n. not yet\nOn Fri, Apr 25, 2014 at 4:03 PM, Evgeny Gerashchenko \nnotifications@github.com wrote:\n\n@alextkachman https://github.com/alextkachman, any news on this pull\nrequest?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/JetBrains/kotlin/pull/439#issuecomment-41389764\n.\n\n\nBest regards,\nAlex\nBest way to call / chat with me\nhttp://lucy.me/alex\n. FunctionalList/Queue have important feature missed in regular Java collections - of being persistent, so neither copy nor sync is needed\n. Traditionally (???) convention is append returns original (parent) element and there is also appendTo\n. ",
    "shalupov": "Thanks, fixed in master by myself\n. Looks like I've not reviewed all consequences, reverting pull request for now.\nCompiling in pom packaging is a valid case (i.e. in custom execution steps).\nWhy your build is failing? My test build with empty sources directory and pom packaging yields warning \"No sources found skipping Kotlin compile\"\n. merged manually\n. Hi! Thanks for the changes.\nCouple of comments:\n- KT-3257 is a separate issue, open another pull request, please\n- Could you retain pom.xml formatting?\n- Is it possible to place all required tags to parent pom only?\n. yes, please\n. Tags is ok. I've committed them manually with better project information.\n- maven-install-plugin will just install package to local repository. Even after adding maven-deploy-plugin, your change will break mvn package (I don't want to install anything to local repository before install phase)\n- adding source and javadoc generators to all poms is just as bad as adding licenses, scm and developers tags to all poms - it's code duplication. And javadoc is not applicable to all poms since it's Kotlin sources, not Java.\nI've started reviewing all Kotlin modules and found that it's not required to deploy them all.\nThanks for your ideas, I think I'll continue to fix modules myself one by one.\nCould you transfer rights to org.jetbrains.kotlin group to \"shalupov.jetbrains\" account on sonatype?\n. Many thanks for the script! We'll try to publish with it and (hopefully) switch to deploying directly with deploy plugin (and without internal repository)\n. Do we need all those repositories here?\n. ",
    "ae6rt": "That means I should keep up with the Jetbrains repository using\ngit fetch upstream; git rebase upstream/master\n?\n. closing this.\n. ",
    "roja": "C# uses the @ symbol to prefix \"unsecaped\" strings? Could be a potential symbol in kotlin?\n. ",
    "terencehonles": "what if you just copy Python and use \"r\" as a prefix\n``` python\nr\"my raw stri\\ng\"\nR\"my raw stri\\ng\"\n```\nany reason it needs to be a symbol?\n. I didn't realize Kotlin had infix functions (just started checking it out again because I recently found out it was open sourced)\nLabels appear to only be a valid java identifier or java identifier quoted by \"`\" (http://confluence.jetbrains.net/display/Kotlin/Grammar#Grammar-label)\nSo would it be a problem? I guess you could argue it might initially be confusing for @label vs @\"label\" which is not really a label, but for @label identifier identifiers vs @\"label continuing raw string\" it is a little more obvious what is happening (plus if syntax highlighting gave them different colors it would be more obvious)\n. ",
    "stepancheg": "Shouldn't issues like this be fixed by fixing jdk-headers instead?\n. AFAIU, no. I forgot about static methods.\nAndrey, this is BTW one more reason to implement \"static\" annotation.\n. I'm not sure that:\nmyExecutor { foo() }\nis better than\nmyExecutor.execute { foo() }\nIt is like having invoke on Lock:\nmyLock { foo() }\ninstead of\nmyLock.hold { foo() }\nI think invoke should be defined for types that look like functions, e. g. java.lang.reflection.Method, but not on objects that can execute other functions.\n. Executor interface has only one method, however, Executor is rarely used directly. Executor has ExecutorService subclass that has more methods. 'submit' is one that is called often, because it returns Future, that allows to get result and track if task is completed successfully or failed.\n. ",
    "franckrasolo": "I will now close this pull request and submit two separate ones taking your comments into account.\n. ",
    "detouched": "I've rebased but result looks strange. I'm new to git so might have done something wrong :(\n. Well, I'll better close this request and find a way to resubmit only my changes.\n. Finally, I've done rebase. But still I wonder why there are duplicate commits...\n. Seems that Pavel Talanov resolved same issue in cd2783eac89c75c7f64d8c68cd43c11879a28f8a\n. I've also removed unnecessary import in K2JSCompilerPlugin.java -- that's a trace of my previous pull request\n. When no cast, I get message that no function can be called with arguments supplied (Pattern.quote() returns java.lang.String), particularly, jet.String.split(jet.String).\nSo there are two ways: either to declare this as java.lang.String or to declare java.util.regex.Pattern.quote(ch.toString()) as String (jet.String here). Why I decided to use the first statement is because it's widely used in Strings.kt.\nPlease correct me if I'm wrong.\n. Well, here's no point to cast, I agree. But just for uniformity... :) And one function less in call chain.\n. No, we don't. I needed them while test project was standalone. I've removed them.\n. ",
    "cy6erGn0m": "Which usecase you are trying to cover by this property? Whats for we may need last index in array? The only thing I can understand is array[array.lastIndex]. But why not just add #last property to get last element then it will be array.last. Also array.lastIndex returns -1 for empty array that a bit dangerous and sometimes hard to debug and understand. array.last is better because we can throw NoSuchElementException (or smth like that) for empty array.\n. Hmm... is there way to split different commits to separate pull requests? I want to write explanation for Regexp extensions separately..\n. According to diff changes are not complex.. \n. Also most of my changes in separe file I've created so it should be easy to apply it to trunk\n. @geevee , done\n. I see no big difference against appendChild except return type. Unfortunately it is not obvious for user which element will be returned: parent or child as it looks like a builder function\nSee example:\nkotlin\nbody.addElement(div1).addElement(div2).addElement(div3)\nIs it obvious for user which of the following trees will be built:\nbody\n    div1\n    div2\n    div3\nor \nbody\n    div1\n        div2\n            div3\nThis is why I believe it is error-prone approach\n. @Tip-Sy body.appendTo(div1) should add body to div according to the name. addElement still doesn't hint you what is the result. \nI believe you don't need this actually. Look to Kara or Yested frameworks. \n. Anyway it is not intuitive whether it will be 0 .. this -1   or 1 .. this \n. @bashor Notice also https://youtrack.jetbrains.com/issue/KT-8126 \n. @udalov do you think we have to test logging functionality? :smile: \n. It's easy to run plugin as part of testing phase but don't know what should be tested: what criteria to be met by plugin's output?\n. @udalov see test just commited\n. Merged manually, thanks\n. All related issues resolved and merged manually. Thanks to everyone\n. @abreslav I see no solution to detect indent automatically that will work predictable in any case. In both Scala and Groovy there is stripMargin that requires | on every line. Also in Groovy there is stripIndent but it requires higher user attention: all lines should have indentation (including first line). We can include it too but not sure we have to. In Python there is dedent function that does it the same way\n. @abreslav what if we have\n\"\"\"\n    a\n  b\n\"\"\nShouldn't we find minimal common indentation level (except blank lines)?\nWe can do it like this:\n``` kotlin\npublic fun String.trimIndent(): String {\n    val minCommonIndent = lineSequence()\n            .filter { it.isNotBlank() }\n            .map { it.indentWidth() }\n            .min() ?: 0\nreturn lineSequence()\n        .map { it.drop(minCommonIndent) }\n        .joinTo(StringBuilder(length()), \"\\n\").toString()\n\n}\nprivate fun String.indentWidth(): Int = indexOfFirst { !it.isWhitespace() }.let { if (it == -1) length() else it }\n``\n. After all we decided to implement both trimMargin and trimIndent: the first one uses a specific prefix (|) and the second one detects common minimal indent and removes it from every line\n. @ilya-g see changes\n. @andrewoma thank you for info.trimIndentdrops first and last lines if they are empty\n.trimIndentdoes drop buttrimMargindoesn't so I have introduced the same behaviour for it too. See last commit that does it\n. Merged manually\n. Merged manually\n. @bashor fixed\n. @bashor thanks, merged manually\n. it shouldn't be so much changes in the imports section\n. @DanielThomas it's a bit strange that so much changed, ok, let it be\n. Merged manually\n. @yole all tests seems to be passed\n. Merged manually\n. @udalov haha, yes, thank you. I was looking at kotlin-reflect when was introducing kotlin-test.jar. Will fix\n. merged manually\n. @udalov ops, fixed in master https://github.com/JetBrains/kotlin/commit/c5e43a132767af71331126cb98981d9318e6e3cd\n. @ilya-g see updates\n. merged to master and 1.0.2 branch\n. Merged manually tomasterandbeta4. what about tests for ignore case = true?\n. I also believe we need few tests for unicode characters\n. Another one could beassertEquals(\"abaabaaababac\".occurrencesOf(\"abAa\", ignoreCase = true).toList(), listOf(0, 3)). Should we return _all_ occurrences or only non-overlapping? egAAA.occurrencesOf(AA)=0, 1or0?\n. @ilya-g what do you think? what behaviour is better by default? as far as I understand all our api doesn't return overlapping occurrences, isn't it?\n. Doesn't vararg getter conflict with the regularget? \n. For megetwith vararg is unnecessary thing but I like theIntRangeidea\n. But I am not sure about implementation: shouldn't we dosubList(range).toList()instead? \n. Generally it is much better now, thank you for your help. Fix the remaining notes and we'll discuss it. I think it is the good one candidate for merge \n. @MarcinMoskala Another one problem I can see islist[1..10 step 2]. Open question is:list[10 downTo 1] = ?`\n. Regarding negative range bounds: not sure it is good idea as it may cause strange consequences. See\nfun myfun(someRange: IntRange) = myList[someRange]\nIn this case we can potentially get unpredictable results as IntRange could be computed somehow\nmyfun(1..someString.indexOf(something))\n. Why do you need toList() here?\nI still believe it is not good idea to support negative values\n. Looks good to me, have pulled it into rr/pull/857 and waiting for CI \n. The only question is about static initialization: will look at it a bit later\n. Merged into master and 1.0.3\n. Thanks, @yarulan !\n. 1 - yes, 2 - no (maybe \"yes\" if I configure plugin in parent module as well but it will test one more way to compile, not this particular issue)\n. I believe these functions needs to be moved to a separate library with all required declarations. \n. \"all required declarations\" = \"all jquery related declarations\". I believe kotlin's library shouldn't be aware of any libraries. The only exceptions for now are w3c DOM and ES5 (6 or whatever) that we keep in kotin-js-library for now\n. We don't have any official jquery bindings library for now. So there are options: you can find best of existing community libraries or create new one and merge in all you can find from other frontend libraries. \n. Existing declarations in kotlin js library are going to be removed one day for sure.\n. Also you can ask in slack channel \"javascript\" (get invite here if not registered yet) to coordinate with other kotlin2js user. Thank you anyway\n. The idea is to throw compiler exception that Teamcity is waiting for (there is a special Teamcity maven agent that can listen for exceptions). We have our own based on the required type with additional information that Teamcity can use in the future.\n. it's too difficult to do the same as Teamcity does. Unfortunately see no easy way to do a test\n. The main question here is what if the same dependency exists in both lists? Is it safe to have duplicate dependencies in the plugin classpath? . Why here you are casting \"this\" to String? \n. The same\n. Has it real effect during run? Is it enough to just set it to a configuration?\n. @udalov we don't have exact thing in stdlib because there is elvis operator in K that covers this functionality\n. We can omit some of safe calls using filterNotNull and padStart trick:\nkotlin\nprivate fun comparableVersionStr(version: String) =\n        \"(\\\\d+)\\\\.(\\\\d+).*\"\n                .toRegex()\n                .match(version)\n                ?.groups\n                ?.drop(1)?.take(2)\n                ?.filterNotNull()\n                // checking if two subexpression groups are found and length of each is >0 and <4\n                ?.let { if (it.size() == 2 && it.all { it.value.length() in 1..3 }) it else null }\n                ?.map { it.value.padStart(3, '0') }\n                ?.joinToString(\".\")\n. ~~Why do we need our own isAlive implementation?~~\nMy bad. Process.isAlive was introduced in Java 8\n. But if it is not then the child process could hang if there are bytes were not consumed: generally it may happen if the child process is trying to write to the pipe but nobody reads it anymore and the pipe internal buffer is full\n. pidfile, some kind of ping, shutdown port?\n. listOf() -> emptyList()\n. We can use kotlin's measureTimeMillis or measureTimeNano: http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.util/index.html\n. It is not guaranteed that the read operation reads the same amount of bytes as buffer can contain and it even may read zero bytes even if the file pointer is not at the end \n. shouldn't we use use function here:\nDigestInputStream(file.inputStream(), md).use { stream ->\n    // do stuff\n}\n. Will we see black console window on Windows if we start java.exe? Shouldn't we run javaw.exe instead?\n. do we need to keep them in home dir? can we use tempdir instead to eliminate possible issues caused by NFS-backed homedir, etc ?\n. ~~Why do we have :Boolean function that always returns true ?~~\nI see, sorry\n. Can't we replace it with something like that:\n``` kotlin\ndo {\n    if (lockFile.createNewFile()) return true\n    Thread.sleep(...)\n} while (!timeout)\nthrow timeout exception\n```\nIt is better because the function has only two cases: return or exception. Now we have true/false/exception\n. java.net.InetAddress.getLocalHost() may crash with IOException (actually, UnknownHostException) on some machines due to strange network configuration. Notice that it is not a wrong machine configuration but Java's limitation. In some cases it couldn't be fixed on some corporate machines. I faced it few times in different companies. It is possible at least on Linux and Solaris machines\n. will we see non-latin characters? it could be significant for error messages with path to files, for example\n. How long this thing work? Does it shutdown itself?\n. You also can run host utility in catch block\n. Ah I see: as far as daemonOut.toString() uses Charset.defaultCharset() it seems to should work\n. Why do you put project.version here? shouldn't you somehow lookup Kotlin plugin version here?\n. why do we need guava in such simple example? we can replace ugly Joiner.on(\" and \").skipNulls().join(names) with names.filterNotNull().joinToString(\" and \"). We also don't need com.google.common.primitives.Ints at all...\n. here it is not clear which project version it will be: kotlin's version or user's project version. So I think you better to rename it and ensure it actually contains valid version (you can change sample project's version to some particular value (for example, 1.0.0))\n. if (pattern.isEmpty() || pattern.length > this.length)  ?\n. What is the value of last of empty range and of lastIndex of the empty list? Don't they throw an exception? You have to add corresponding tests \n. Negative factor should throw an exception \n. It should be more debug information: exact range bounds and the list size\n. Formatting\n. assertEquals(expected, actual) is preferred as it dumps diff on failure\n. Yes, our other functions do that so times should as well \n. I should be expected value at the first place, the second argument is actual, swap these arguments please\n. I believe we also need tests on an empty list: should fail at any range but empty range on empty list should produce empty list \n. You may just do require(factor >= 0) {\"error message\u2026 \"}. Also notice that in Java wrong arguments should cause IllegalArgumentException (so it is done inside of the require function) \n. It should be toList() after because we need a copy but subList just refers to the original list. \n. typo: than\n. Type: than\nAlso lets include actual value in the message \n. Also, in fact the message is not exact correct: factor shouldn't be negative so zero is also included \n. done\n. Are they zero-based in CompilerMessageLocation ?\n. Isn't compiler exception logged as error?\n. -1 should be 0 so CompileMessage will handle it properly. I've extracted a function fixLocation to handle it.\n. yes, but in this case it looks not so clear that there is -1 and 0 with special meaning\n. @{18f15b45-4413-42a3-82e7-d057983d1e65,Ilya Gorbunov} sourceIterator() or just source() ? Need to be documented: whether it creates iterator every time or keep the same instance. If the behaviour is undefined we have to notice it here.. Why don't we use aggregateTo instead?. value vs accumulator, v vs acc. as we already use internal API hack we could do even more: we can create replace IntRef to Int inplace and then do unchecked cast.. why there is specialization here? the implementations look the same. Unfortunately it is not going to work with UTF-8 as it could contain multi-byte characters with 0x0d or 0x0a inside. For example http://www.fileformat.info/info/unicode/char/020d/index.htm or even http://www.fileformat.info/info/unicode/char/040d/index.htm. I personally like this particular change however isn't it a breaking change?. @Meztihn to work properly with any encoding you could try to adopt something like this: https://gist.github.com/cy6erGn0m/464453a2059c11f9b31b949aacc3b8ce (feel free to copy it if needed)\nAlso it is important to write tests: you can use old-school PipedInputStream/PipedOutputStream to verify corner-cases . Populating MDN cache over internet in the constructor... well,  I'd extract it to an additional function prepare(). ",
    "pTalanov": "Hey, I did merge your pull request. But there are some stylistic inconsistencies and a couple of errors, they are fixed in the following commits, namely b9b9e46275727b1647315ee3c7b05cd0e41d3984 .\nAlso I improved tests so that now they test both v3 and v5 versions. Tests that fail on v5 are easy to track, just look for JsTestUtils#failsOnEcmaV5(). I guess you would want to get rid of those.\nThere are also a couple of things I'm planning to improve, but I decided to postpone them a bit.\n. Thanks!\n. Thanks! Pulled it. \nIf you pull the latest version:\nThere is some work in progress on detecting js modules. To specify that your module is compiled to ecmascript version 5 you will have to modify your *.iml file so it contains the following lines:\nhttps://gist.github.com/2875840\nYou will also have to manually replace kotlinLib.js file.\n. Ok. This is pretty big.\nWhat do we need dart sources for?\nIf we do need to modify them, can we just patch and rebuild them?\nAs for adder test, I understand that it's the only test that checks that you can actually modify variables caught in closure from function literals. And that's an important feature.\n. Hi!\nThe semantics of check changes. It no longer checks if variable is equal to undefined. We generally want to think that undefined is the same as null in Kotlin. I guess we need a test that checks that \"!!\" behaves the same way for \"undefined\" values as it does for null values.\n. Hello, Lingzhang. \nMy name is Pavel and I am the reviewer for your PR.\nFeel free to ask any questions (and leave comments) here or via Pavel.Talanov@jetbrains.com\n. General issues (and these are important):\n1. Changes to GenerateTests.kt should be included in commit.\n2. It's a bad practice to leave your test cases unnamed when you can come up with a meaningful name. For example \"applicableFunction2\" can instead be \"callWithMultipleArguments\", \"unapplicableFunction2\" can be \"unapplicableWhenNoArguments\" and so on.\n3. Your \"unapplicableFunction*\" tests in fact do not test anything. Make intention applicable everywhere and see for yourself.\nThis is a big issue because untested code that appears tested can be a disaster.\n4. Your test suite is too thin: \n- There is no test checking that intention is available in any position other than exactly before \"get\".\n- There is no test checking that intention is not available when get(...) has no receiver (the code is there).\n- There are no tests for cases when some specific features of the language are used in call expression, see what happens for the following expressions:\n  1. a.get(i = 2)\n  2. a.get(2) { doSomething() }\n  3. a.get<Int>(2)\nOverall:\nEvery issue that I pointed out should be addressed: the code should be improved or you can persuade me that I am wrong.\nFor now you can add commits to this PR if you want or close this one and submit a new one. Anyway the result of your first task should be a PR with a single commit (implementing the feature).\nGood luck and don't forget to ask questions.\n. > One of which is how the intention action will only display if the caret is placed before the get(...) and not elsewhere\nWhat do you mean \"intention will not display\"? Please clarify. If you mean the yellow bulb, I think it is shown correctly when I run your code.\n. >  I was wondering if for example in Foo.get(x) , the yellow bulb should also display when the cursor is somewhere inside the get(x) and not just exactly before get(x)\nYes, it absolutely should. I think it works for me (I'll recheck tomorrow). What you can do:\n- Try to write a test that the intention is available in other positions. Does it fail?\n- Check whether the intention is available via alt + enter shortcut.\n- As a last resort you can try to debug (either test or IDEA plugin) and see why this happens for your environment.\n  Anyway that seems very strange to me.\n. I ran your code again and the bulb is shown correctly: \n\n. > Disallow the intention action if one or more arguments have '='.\nYes, it's ok. It is possible to support this case, but it is beyond the scope of the first introductory task.\n\nCheck for a function literal after the ValueArgumentList and include that inside the ArrayAccessExpression.\n\nCorrect.\n\nTake out the type parameter list from the converted ArrayAccessExpression.\n\nThat would not be correct behavior. It would be possible to convert valid code to a compilation error. Please come up with an example yourself. Hint: specifying explicit type arguments is sometimes necessary.\nBy the way, did you solve your problem with the bulb?\n. You added some commits. Are they ready for review?\nPlease leave a comment whenever you want me to review new code.\n. The names of the tests look much better. It would of course be nice if you manage to include the tests themselves.\nSee https://github.com/kuity/kotlin/blob/4e65006bdd2561574c6669305ce7ff1fa866c794/idea/testData/intentions/replaceGetWithSquareBrackets/noReceiverExpression.kt\nFive test data files are empty.\n. Overall:\nA lot of minor issues but most of the logic is ok. Please fix them.\nI didn't review the test suite since some tests are empty. But the names imply you covered most of the cases. Please add the tests.\nLeave a comment when you want to me to review again.\nP.S. Please keep you code formatted properly. Our formatter can sometimes produce undesirable result (you can workaround by formatting only selected text) but poor formatting is guaranteed to annoy the reader.\n. Almost everything is good. There are minor codestyle issues which I pointed out and some misleading test names.\nThere are two more issues:\n- Information about you squashing any commits is useless to the reader (he will only see one commit)\n- You are missing a test for combined value arguments and functional literal arguments.\n. In Kotlin it is possible that a + b is a valid code and b + a results in compilation error. How are we going to deal with this?\n. No, it's not.\n. Hello, I am the reviewer for your PR. I left comments for some minor issues in the code.\nThere are some serious issues in your implementation:\n- It is applicable in cases it should not be. Some examples:\n  - if (!(a && b)) {\n    } results in if (a) {\n    if (b) {\n    }\n  - It is applicable for if (/**/) val v = a && b resulting in exception. \n- It has wrong semantic for cases when else branch is present.\n- getRight() function is indeed confusing so it is very hard to tell if it does the right thing. Try to work on code readability when you're done with other issues.\nFeel free to ask any questions. Don't forget to leave a comment when you want me to review again.\n. Hello.\nGood job fixing minor issues. Unfortunately the applicability of the intention is still not correct.\nTry:\n- if (bar(a && b)) {} - should not be applicable\n- if (a && (!b)) {} - should be applicable\nI suggest you figure out what are the exact conditions under which the intention should be applicable.\nYou can use java implementation as a reference.\nThere are of course some differences because of different PSI structure.\nJava intention is also applicable for if (a || b) {} case. Do you plan to implement it?\n. Hello again. The implementation is good. Good job.\nBefore I can accept:\n- Add tests for cases with mixed && and || operators. Do you know what happens in if (a && b || c) case?\n- The scope in which intention is available should be changed: it should be available only for && and || tokens as it is in Java. The reason is that left and right operands can be complex expressions and we do not want to show unrelated intentions inside them.\nAlso, we decided that it would be cool if the intention is available for if keyword. It should increase usability and discoverability of the feature. If the intention is applicable for multiple tokens inside condition choose the first (leftmost) occurrence.\nIt can be done as a part of this PR or as another PR later. It's for you to decide.\nI will leave some comments about minor codestyle issues. Most of them are not mandatory to fix. Just my opinion of how readability can be improved.\nUPD: Please rebase to current master.\n. Hey, sorry if I wasn't clear.\nI meant for it to be additionally available on the if keyword.\n As well as on && and || tokens (which will allow to choose which you want to split).\n. Well. Another intention solves the problem (but you still need to avoid code duplication) but I would explore the API more. You would probably need some other class, not SelfTargetingIntention. See how java intentions do that. I'm not sure we have similar intentions in our project.\nIt's a separate task so as I mentioned before you can do that afterwards if you wish.\n. Now, It is available inside the operands as well. \nif (ope<should not be available here>rand1 &<should be available here>& operand2)\nIsn't that so?\n. Correct. \nIt's good that you ask to questions to clarify =)\n. Hi, Gavin.\nVery sorry for the delay. I just pushed your intention manually with some very minor changes:\n- Formatting and optimized imports in SplitIfIntention.kt\n- Missed <caret> in splitIfOperatorAsFunctionParam.kt\n- Typo in commit message\nGood work!\n. Hello, Gavin.\nThe approach is OK. Code could be better, see my comments.\nI haven't tested your code in the IDE but I'm pretty sure intention is available inside the body of the if expression while it should be available only when caret is inside if keyword (or inside ||, &&).\nPlease add test for that case. Restore splitIfCaretWrongLocation test, intention should NOT be available in this case. Add tests for case when there are nested ifs to which intention can be applied.\n. > I just wanted to make sure you were aware that Tuesday, April 8th is my last day to contribute during my school semester.\nThanks for mentioning it. I hope this is the last iteration that is required before merging your work.\n. Everything else looks good.\n. Hi, Gavin.\nI got around to the final testing before merging changes in and found a bug. I feel silly since I should have spotted it earlier. Please tell me if you still have time to fix it. \nHere's the bug:\n<caret>if (a && b || c) { }\nIntention should be applicable to split ||. But it's not. It is because of how getFirstOperator function is implemented.\n. Hi, I will have to time to fully review your implementation later (hopefully today).\nPlease make sure that it works for cases like: (a || b) && (c || d) and (a && b || c) || d. You may come up with your own tests. If it doesn't you can try another approach:\nMy hint to you is you already have the code checking that intention is applicable to an operator. You can extract that code to a separate method. Then your isApplicableTo function would be like: if it is a simple name expression call that method, if it is an if expression check that cursor is inside if keyword and search for an operator to which intention is applicable.\n. Hi, implementation looks good. \nSadly I will only be able to merge tomorrow. Is it okay with you? If not I can try to ask someone else to do it.\nP.S. Why did you abandon firstOrNull function? :)\n. Lines 91-96 are equivalent to return childElements.firstOrNull { isOperatorValid(it) }\nThe == JetTokens.* check is done inside isOperatorValid.\n. Absolutely.\n. You are welcome. Good luck with your studies!\n. Good job, Gavin.\n. Merged manually with Kolya's improvements.\n. Hello. Your approach is correct. I left comments how the code can be improved. \n\nimmediately after it\n\nI understand you mean the case when caret is immediately after the callee expression receiver.callee<caret>(arg). It's debatable whether it is the expected behaviour but most of IDEA intentions do not work if caret is immediately after the target element. If you desire to support this case you can use this equation for callee expression getTextOffset() <= caretLocation <= getTextOffset() + getTextLength() instead of the approach I suggested.\nAs always feel free to ask any questions\n. Hello. Please fix the issues I pointed out.\n. Ok, fix those minor issues, squash the changes, rebase on master and it's good.\n. Ah, sorry. I wasn't aware.\nIsn't there a warning on line 49 on !! operator? If so, please fix it. Everything else looks ok.\nWill get to final testing by tomorrow evening.\n. Sorry for the delay, Lingzhang. And thank you for your contribution.\n. Sorry for not responding earlier.\nThe demo.foo(\"\") case should be supported. Also doesn't your fix prohibit cases when kotlin.io is in fact not a package but a valid receiver for infix call? (That means some tests should be added)\nTo know whether demo is package or not you can resolve the reference and check whether it references a package. But resolving a reference can be time consuming and should not be done in isApplicableTo function, so general policy for such cases is:\n- Use PSI  structure in isApplicableTo function to filter out as many unsupported cases as possible without using analysis (reference#resolve(), ResolveSession, etc).\n- In applyTo() function use analysis to check other conditions. If intention can not be applied, show a pop up message explaining the reason.\nAn example of this approach is AttributeCallReplacementIntention family of intentions.\nI close this PR, but this is the right place to ask questions.\n. Sorry for such a huge delay. I was away and forgot to notify someone to take over.\nYour code works just fine. Good job.\nI simplified it a little bit in ca15d77f1df0bc9b83fe16d87a49e33bc28c0a93.\nAlso it turned out there is an issue in the code I referred you to. I fixed it in 9ef700b081a6ad3a70dfb9c35a6cfbfe6b68a1b9.\nThanks a lot for your effort.\n. Ok. \nWhat are the pros and cons of using properties bundle file vs hard coded strings? \nI'm asking because you moved some of the strings out of bundle to code. Does it matter?\n. Merged manually.\n. Hello.\nFirst of all, thank you for your effort. \nUnfortunately we won't be accepting your PR. Similar changes (using different API) were just introduced into master as an effort to fix https://youtrack.jetbrains.com/issue/KT-15084 . \nSadly I wasn't aware of your work on KT-16722 until today. I checked master branch against your example https://github.com/Minecrell/kotlintest2 and the problem is partially gone. Navigation works correctly for all declarations except for builtins which are somewhat of a special case ( Array.iterator() is a builtin). I'll be testing another patch to cover this case also.. This will crash the build miserably.\n. Can you please tell me what this is about?\n. What is this file? Is it for manual testing?\n. Okay, say there that resolver has failed with an exception (reports an error and returns ScriptDependencies.Empty). Should we update script highlighting in IDE in that case? We should display an error for sure but is marking all references as unresolved actually helpful? I believe that API you propose doesn't allow to handle this scenario.. Honestly, everything should be documented. We can reference jars and directories, not sure about files. . sources means source roots. Enables navigation in IDE.\nscripts means some script files this script depends on. Not sure what it means exactly. It isn't supported in IDE (nor compiler I think).. annotations are actually lazily loaded (we need reflection to do this so it's relatively expensive). Iterable indicates that there is no container yet that holds all the instances. I think Sequence is better suited to express lazy and no-container ideas.\nI like fileAnnotations btw. We just have to make sure that we have no plans to expand the meaning. . It can. That's why i'm not sure if that's needed at all. I think we have to wait for @ligee to comment on what's the initial purpose of this. \nFrom IDE point of view I can say that since it has to construct ScriptContents object synchronously before sending (potentially) async request we can't achieve true laziness when loading annotations since the file may have changed by the time client calls ScriptContents::annotations (moreover we can't read file content from the thread that actually handles the request). That's why being able to skip loading some unrelated annotations is potentially helpful but in reality I have no idea if that's ever the case (script file with file annotations that resolver ignores).. Not sure about users calling isEmpty. I think it's more likely that users will ignore this property or search for annotations that their logic depends on (annotations.filterIsInstance<UserAnnotation>()).. That somewhat maps to current API in a following way:\ndata class ResolutionResult(\n    val dependencies: ScriptDependencies?,\n    val diagnostics: List<ScriptDiagnostic>\n) {\n    val isSuccess get() = dependencies != null\n}\nNot sure why we should avoid hierarchies. Can you explain your reasoning a bit? . My main concern with your proposal is that the user has to pass both isSuccess flag and notnull dependencies in both cases. While ScriptDependencies.Empty is a completely valid value for a successful resolution, it's not clear that it's meant to be ignored if isSuccessful == false. That could be explained in the docs of course.\nI agree that using sealed class makes API a bit cumbersome. What I find problematic in the current API is that it's not clear that successful resolution can actually contain error diagnostics and that may be confusing for implementors of the API. \nI would not put a lot of emphasis on ease of consuming the API (since it's gonna be us who'll be doing that) but rather focus on the API being easy to implement.\nIn my mind those snippets would look like (with the current API):\nwhen (result) {\n    is Success -> ...\n    is Failure -> ...\n}\nor \nval dependencies = result.dependencies ?: ScriptDependencies.Empty\nval diagnostics = result.diagnostics\n.... Talked to @udalov in person. We seem to agree that: \ndata class ResolutionResult(\n    val dependencies: ScriptDependencies?,\n    val diagnostics: List<ScriptDiagnostic>\n)\nis simpler and covers all the required cases. It needs some documentation around what dependencies == null means but so do all other considered variations.. val diagnostics: List<ScriptDiagnostics> = emptyList() would be better?. @ligee See the beginning of this thread.. I think we should think ahead if it makes sense to support this. Because if we provide only the simplest API right now and decide to add 'content-based' API later we'll end up with two APIs that do the same thing and have problems merging their results later. \nThe snippet I came up with just illustrutates that the user can potentially want to decide to change compiler arguments based on ScriptContents with some custom logic.\nAPI proposal: expand ScriptDependencies class with val extraCompilerArguments: List<String> = emptyList() so this can managed uniformly with other scipt content depent stuff.. We should consider if implementing https://youtrack.jetbrains.com/issue/KT-19120 is the way to go.. Let's think about what we can do instead. Something like:\ndata class ScriptDependencies {\n   val sdkBinaries: List<File> = emptyList(),\n   val dependencyBinaries: List<File> = emptyList(),\n   val dependencySources: List<File> = emptyList(),\n   val scriptDependencies: List<File> = emptyList(),\n  ...\n  extraCompilerArguments, imports\n}\nNaming needs some work.\nIdea is that maybe just changing the naming so it would makes sense on other platforms is enough.. Wanna stress that this isn't a trivial issue. For now scripts files must have \".kts\" extension I believe. And we may or may not decide to lift this restriction later. But determining script type by it's content is something else entirely. What're the potential usecases?\nProblem arises when we allow both non-standard extensions and content-based matches. Say we have some file \"script.stk\" and there is custom matcher that says that it is a script of specific type based on it's content so we must load it's content even before we know how to parse this file (and parsing decision should not involve any complex logic).. ",
    "maxmanuylov": "OK, no problem, but in this case it was me who reported this issue, and I added comment with the link on this pull request almost right after creating the issue, so I do not think someone else could actually start working on it :)\n. I did something strange and now this pull request contains 397 commits instead of one :(\nI will send another pull request with only my commit.\n. I wrote a converter, see https://github.com/JetBrains/kotlin/pull/60\n. See https://github.com/JetBrains/kotlin/pull/57\n. Added.\n. > What is the use case for this optional output, except for debugging Kotlin compiler, which can be done by local modification?\nDebugging Kotlin plugin for JPS. In this case it would be rather inconvenient to rebuild Kotlin compiler just to see command line args.\n. Ok, thanks.\n. I broke the tests at http://teamcity.jetbrains.com/viewType.html?tab=buildTypeStatusDiv&buildTypeId=bt345 and committed the fix, but it is not visible in this pull request (seems due to request is closed). Commits are here: https://github.com/maxmanuylov/kotlin/commits/better-compiler-output\n. ",
    "NataliaUkhorskaya": "Alex, you can add \".patch\" for link to commit.\nhttps://github.com/NataliaUkhorskaya/kotlin/commit/f6226485e82a50f58e4a5eacea15d9682bcf94fd.patch\n. This quickfix should be available also for imports (there is the same warning). Quickfix should delete the line with these import.\n. The caret after this quickfix should be placed at the same place as before applying it (see editor.getCaretModel().moveToOffset). Note that you can check caret position in tests (use  tag)\n. This quickfix should be available also for constructors with vararg arguments and arguments with default values \n. Great job! Thank you.\nAs you see, I have few small remarks and I can merge your pull request after you fix it. Than you can continue with other cases.\nI have one more for you :) \nopen class A(i: Int)\nclass B(s: String): A(s<caret>)\n. About http://youtrack.jetbrains.com/issue/KT-3660: you are right - it's a sepatate bug, so it can be fixed later. \nI'll merge your pull request, thank you for contribution!\n. Thank you for contributing! \nThere are a few problems: \n1. In your built-ins classes there are illegal modifiers, so they must be removed.\nNow there is an exception when you open an IDE : java.lang.RuntimeException: builtin library initialization failed: java.lang.IllegalStateException: ILLEGAL_MODIFIER: Illegal modifier 'public' (3,28) in /jet/Arrays.jet\n    at org.jetbrains.jet.lang.types.lang.KotlinBuiltIns.initialize(KotlinBuiltIns.java:128)\n2. We have a vararg keyword, that parsed as modifier, but it should be allowed for function parameters.\nThere are a lot of failed test.\n3. About tests: we use JetDiagnosticsTest for these errors, so it would be better if you use it unstead of DiagnosticMessageTest (it check that message in IDE is correct)\nFeel free to contact us if you need some help and don't forget run all tests before submitting a pull request.\n. @mhshams It would be better to merge those 2 commits to avoid polluting the history\n. @mhshams Merged manually. Thank you!\n. Now your solution works in IDE, great!\nBut there are some cases where code will be broken after applying an intention:\na.get(a = 1)\na.get(1) { 2 }\nAlso it's better to merge all your commits into one to not polluting the commit history.\n. Note that the issue was about named arguments, not about comparasion:\nfun get(i: Int, s: String) {}\nx.get(s = \"a\", i = 1)\nYou shoudn't transform it to x[s=\"a\", i = 1], there will be a compilation error.\n. Hi, \nYou are right that such expressions shouldn't be reduced to constant.\nBut to make it works, you should refactor ConstantExpressionEvaluator, because now it computes a constant for all constant expressions (including final properties). \nFirst of all you should add a flag in CompileTimeConstant which will mean that this value use variables as a constant values. There are already some flags (like isPure or canBeUsedInAnnotations), so it will be great if you combine them into one int field. \nThen you should write this flag in ConstantExpressionEvaluator when it creates a compileTimeConstant for expression. \nAnd finally you can use only expresions with constants with this new flag when you check is your intention applicable or not.\nIt isn't an easy task, so feel free to ask any questions you'll have.\n. Yes, as long as it will become a one int field for all flags, you can move isPure  to base class. As for new flag: it should be set to true for expressions that uses properties. For example if there this a property val a = 1:\n- a - compileTimeConstant for this expression should have this flag to true\n- a + 1 - also true\nSo you should check that the expression isn't a property call and inner expressions don't contain calls to properties\n. It will be good if the flag for AnnotationValue and ArrayValue will be true when at least one argument has this flag to true. \nWhat about enums: now I see that MyEnum.A == MyEnum.A isn't a constant expression right now, so evaluator return null for this expression. So it's an another issue, and I'll do it myself, thank you. \nWhat about a test: it checks compileTimeConstant which it written for property initializer, so if in initializer for this property there isn't an another property, the flag should be false. If you always get true it will mean that something works wrong. I think that the problem is that you didn't change a default flag to false in EvaluatorContext class, so the compileTimeConstant for variable has always this flag to true.\n. Good work! There are two small notes (see my line comments for the commit). \nBut also it seems to me that you are going to separate your commit on two - for evaluator and for intention it self, aren't you?\n. Unfortunatly, there are two tests failed. Please, fix them and run 'All tests' configuration before submitting a final version of pull-request. \n. We have some problems with QuickFixTestsGenerated on local machines, so you can ignore errors about \"Some unexpected actions available..\" for now. Have you fixed ControlFlowTestGenerated$ControlStructures and JetDiagnosticsTestGenerated$Tests$Annotations tests? \n. You should add fixes of tests to the first commit, because they failed after your changes in it. Also be careful with imports in generated files: now you have changes in JetDiagnosticTestGenerated and if you run 'Generate Tests' run configuration, this file will be modified.\n. It seems that you have 'Optimize imports on the fly' option turned on. You can disable it in Settings -> Editor -> Auto Import \n. You can simple rerun 'Generate Tests' run configuration. with this option enabled IDE optimize imports in JetDiagnosticTestGenerated file when you open it and remove unused imports.\n. You should run Generate tests and commit the result. If after that you compare JetDiagnosticTestGenerated file with master, there should be changes about new test method and no changes in imports.\n. As I see in master there are those imports (https://github.com/JetBrains/kotlin/blob/master/compiler/tests/org/jetbrains/jet/checkers/JetDiagnosticsTestGenerated.java), so I don't understand where the problem is.\n. Thank you!\n. It seems that most of files in Android project under res folder are unused, so could be removed.\n. I merge your pull request manually. Next time it's better to amend commits with fixes after code review to previous commits to not polluting commit history. Thank you!\n. I think that one simple test will be enough in this case, so you can simple remove most of test cases in the second commit and amend it to previous one.\n. Merged. Thanks!\n. As for pull-request 434: one simple test is enough, no needs to duplicate tests. Thank you!\n. Merged manually. Thank you. \nNext time submitting a pull-request make sure that there aren't any changes in imports in generated tests (see changes in JetInspectionTestGenerated.java).\n. Hi,\nI've fixed the problem you mentioned in master, so you should update your branch on master and remove all changes from test files.\nFeel free to ask us any questions when you have such problems.\nThank you, i'll wait for update.\n. This time I fixed small errors by myself, but next time, please, review your changes more carefully before submitting a pull request. Thank you!\nSee those commits:\nhttps://github.com/JetBrains/kotlin/commit/020c127831461e447e8631636bfa7bd22b7efd08\nhttps://github.com/JetBrains/kotlin/commit/13f7ca51b0a18f6154fa872f8b3ba6698b46f201\n. There are failed tests after your changes: org.jetbrains.jet.codegen.generated.BlackBoxCodegenTestGenerated.DelegatedProperty.\nPlease, run 'All Tests' Run configuration before submitting a pull-request. You can ask somebody from Kotlin Team to run tests on your buildserver, if tests take a lot of time on your machine.\nAs for changes, you should add some tests for front-end (see JetDiagnosticsTest) to check that there is an ambiguity for propertyDelegated method and there is no errors in other cases. \nYou can update this pull-request when tests will be fixed. \nPlease, inform me when it will be done, so I will continue to review your changes. \nThank you!\n. Thanks!\n. Merged manually. Thanks!\n. @rusmonster Thank you!\n. Java has a warning if the path to jre is not valid, seems that Kotlin should have it too.\n. Shouldn't we align all lines by vertical?\n\n. Thanks  a lot and sorry for delay!\n. Thanks! \nMerged manually with minor improvements in testdata\nhttps://github.com/JetBrains/kotlin/commit/534cbae4ef55856949f6f5023093fd80ff409a53. Merged manually. Thank you!. @t-kameyama Yes, I've merged it manually, thank you for contribution!. The solution that you implemented is quite complex. This quickfix should only insert one '!!', because it is applicable for one PsiElement. So in the situation with Array? it's ok that \"Add non-null asserted (!!) call\" intention won't fix all problems.\nThe correct fix is to pass the correct psiElement to AddExclExclCallFix in case of UNSAFE_CALL for array. Hello @t-kameyama! First of all I want to apologize for such a long delay in my response. Thank you for your pull-request.\nThe initial problem of this issue is that the quickfix is created in two different situations: when there is a type mismatch error (then the quickfix should be applied for the whole array expression) and when there is an unsafe call (then the quickfix should be applied for the receiver of array get call).\nSo I've implemented my own solution, feel free to see it here: https://github.com/JetBrains/kotlin/commit/1b715ab25371b00225c9ee80299dd640c6545a6e. It would be better to assert type of diagnostic.getFactory() at the begining, and cast diagnostic to DiagnosticWithParameters1>. See AddStarProjectionsFix. Don't forget to supress unchecked warning in this case.\n. Colon variable should be renamed to senilicon\n. Please fix code formatting in this test\n. The same: code formatting is wrong\n. Sorry, I forget that this is the test format.\n. Already merged with master, thank you for contribution.\n. fun foo(public abstract x: Int) //abstract should also highlighted as error \n. You should add a test with annotation and modifier like\nfun foo(deprecated(\"ss\") public a: Int) \nbecause annotations are parsed in modifier list.\nAlso a test for more than one modifier on parameter is missed\n. There is no need to make resourcesRoot a property: you can remove val keyword to make it a constructor parameter\n. You can avoid specifying type for this property: it can be inferred automatically from the initializer. Also it is better to add a private modifier for properties that are used only in this class\n. variantData.getExtraGeneratedSourceFolders() is Nullable, so you should check for null, before calling addAll\n. You're right. I've updated the commit.\n. We shouldn't create kotlin codeFragments for scala files. See KotlinCodeFragmentFactory.isContextAccepted\n. Now such variables are skipped during text rendering, so it doesn't matter if they are present in resulting map (this map is used only to get values for kotlin variables that are present in resulting text)\n. I've replaced it with codeFragment.getContentElement().statements.lastOrNull() to make this line clearer\n. I think that we should report a warning in this case, but do not provide a quickfix, because such code looks like user mistake. It's better to use context[BindingContext.USED_AS_EXPRESSION, callExpression]. There is it.getLabelName() method. Which test checks this code?. You need also check the case when resolvedCall is VariableAsFunctionResolvedCall\n```\nfun test() {\n    val c = MyClass()\n    with(c) {\n        println(f())\n    }\n}\nclass MyClass {\n    val f: () -> String = { \"\" }\n}\n``. As I say bellow I think that we should also report a warning in case when thewith-argument isn't a simple expression. \nSo you can extract the code from UnusedReceiverParameterInspection that find usages of a descriptor in specified PsiElement. There is already ChangeVariableMutabilityFix that can be reused: you can use it with some custom text like \"Make variable '$propertyName' immutable\". I'd suggest to change the name to 'replace with ...' as in ReplaceCallFix-quickfixes. There isJavaToKotlinClassMap.isMutable(type: KotlinType), so you can check the type it self and it's supertypes:type.constructor.supertypes.any {..}`. You should check the type it self (for MutableList and etc)  and also its supertypes (for ArrayList and etc). This test can be removed. ",
    "develar": "All tests passed now.\n. I have updated pull request to latest upstream changes. (StdLibToJSTest.testCompileStandardLibraryFiles failed)\n. StdLibToJSTest.testCompileStandardLibraryFiles fixed.\n. only one commit pull request without unrelated changes \u2014 https://github.com/JetBrains/kotlin/pull/67\n. only one commit pull request without unrelated changes \u2014 https://github.com/JetBrains/kotlin/pull/67\n. Why ecma version as \"v5\" instead of \"5\"?\nMay be we rename kotlin-jslib.jar to kotlin-js-lib.jar? idea spellchecker shows errors otherwise :)\n. Please see corresponding issue \u2014 http://youtrack.jetbrains.com/issue/KT-2191\n. Yes, I cannot add it to PredefinedAnnotation because see StaticContext 217:73 (predefinedObjectsHasUnobfuscatableNames)\nIf I add it to PredefinedAnnotation any generated property name will be incorrect.\n. IGNORE this pull request, was merged to https://github.com/JetBrains/kotlin/pull/71 (another my changes require it)\n. IGNORE, was merged to https://github.com/JetBrains/kotlin/pull/71\n. http://youtrack.jetbrains.com/issue/KT-2296\n. http://youtrack.jetbrains.com/issue/KT-2298\n. Improve class declarations translation (see details in commit message).\nAdd ArrayList improvements (toArray/addAt (kotlin side: add(index, element))).\n. About your latest changes to kotlin_lib \"var isTestMode = id === \"JS_TESTS\";\" \u2014 it is hack and we can use another normal solution, see RhinoUtils\nNativeObject kotlin = (NativeObject) parentScope.get(\"Kotlin\");\nkotlin.put(\"modules\", kotlin, new NativeObject());\nFailed test: testAdder, local variables in closure is not yet fixed.\n. > > What do we need dart sources for?\n\n\nGoogle removed it from repository, so, I decided to move it under our source control. If it is not suitable, I can grab latest rev, where this is still exists, and patch it.\n. Another incomplete task: http://youtrack.jetbrains.com/issue/KT-2367#comment=27-355531\n. number test failed but I cannot fix it because I don't understand \u2014 what is NumberConversionFIF generated code is wrong \n\n\n3.6 % 1 never can be equals to 3. \n. number tests fixed (subtract operation was restored)\n. testAdder passed. I didn't implement data transfer object or transformation captured mutable outer var to ref \u2014 just translate fun as inner. In this case \u2014 testAdder should be inner (we don't pass it outside) and other solution is too cost (runtime memory). Support (it works now, but memory leak is possible as before) captured mutable outer var in callback passed outside will be added later.\n. JFY: callbacks also translated as inner (i.e. as before except KT-2388 is fixed now) if it is initialization value of class or namespace property.\n. https://github.com/JetBrains/kotlin/pull/118\n. localFunction test failed after latest changes. Well, localFunction is not yet supported. I am fixing it now. Will be pulled as separate pull request when this request will be closed.\n. Yep :) Local functions and local variables modification without possible memory leak are supported. Also problem with nested inner functions was resolved (test case testKt2388). Will be pulled as separate pull request when this request will be closed (https://github.com/develar/kotlin/commit/2028b6b11455bb92d3231da8776e7fb4a6f502b8 and https://github.com/develar/kotlin/tree/3dfc008549d612ffdaac395676d69bdab82e285f).\n. Email related to definition place of inner functions/objects was sent.\n. Thank you! I will inspect current diff and send normal pull requests feature by feature.\n. It is not pull request, but you can cherry pick it (or I will open pull request later).\n1) don't call toString for simple number literal and string https://github.com/develar/kotlin/commit/c82a332326ddeb06b587dcf02519eabe90dad263 As we discussed, my solution is not good, but works, may be you know better.\n2) cosmetics related to List https://github.com/develar/kotlin/commit/34de4bf74eb2ef1c4a89b8b5641bda7b39e420a0 \n3) Throwable constructor parameter message should be nullable string https://github.com/develar/kotlin/commit/d21287a333acca8d2ceae1868e182503896d4a2f\nRemain diff \u2014 37 files, related to better js code generation (while, cached test nullablity) and generate literal fun in corresponding class/namespace. Will be pulled in next week.\n. I just want to avoid merge conflicts. JS code was modified several months ago, so, I cannot add js-related commits to this pull request.\n. \"PrimitiveHashSet and toJSON ability\" \u2014 don't worry, it will be implemented as intrinsic in the end.\ngenerated functions should be inside corresponding class/namespace definition (cherry picked from commit 1fb8142) and \"transform local vars captured in closure as object ref\" 0c53ebc0b7e4996ec44908e79d7e9fedd237c407 \u2014 don't worry about test data, it will be added and the entire code will be rewritten in the end. I am totally agree that this commit contains two different parts, but I have already merged these conflicts several times (master -> master2 (5 months ago) -> attempt to pull request -> now!) and I am tired. \nonly IteratorsTest.foldReducesTheFirstNElements (org.jetbrains.k2js.test.config.JsUnitTestReporter$1) failed (fixed in next commits).\nabout descriptor.getName().getName().equals(\"invoke\"), don't worry, it will be implemented as intrinsic in the end.\n. stdlib tests IteratorsTest.foldReducesTheFirstNElements and IteratorsTest.takeExtractsTheFirstNElements passed, so, all tests passed.\n. Another commits will be pulled after this pull request will be accepted.\nAlso, I cannot continue due to unclear http://youtrack.jetbrains.com/issue/KT-3284\n. Summary (I think, you are agree, that all changes can be done only after other 290 commits will be added (I cannot break my history (otherwise I cannot merge it properly))):\n- [x] 1. Wrap WhenTranslator constuctor (use static method).\n- [x] 2. Move WhenTranslator.translate (must be at the top of the class).https://github.com/develar/kotlin/commit/9ac88b2b839fb263a536c0eed1cce899f027908e\n- [ ] 3. createTemporary \u2014 Refactoring needed: using pairs everywhere is ugly (introduce a class with a meaningful name).\n- [x] 4. Get rid of Trinity (namespace translator)\n- [x] 5. Simplify setDefinitionPlace code.\n- [x] 6. fix https://github.com/develar/kotlin/commit/4b2c96954b7b3b02c53bb4f743850a8f88d78612#commitcomment-2629334 https://github.com/develar/kotlin/commit/e25c8baf1c4e2279800870b0fd57174a97ff079a\n- [ ] 7. Get rid of inner functions in constrictor \u2014 just use bind.\n- [ ] 8. add test \"We don't have tests for index == length.\" list.add\n. Happy new year 2013 ;( Number of merge conflicts, ok, I will rebase and merge my fork again. It seems I will create another branch, because history of this may be lost as result of forced push.\n. Ok, I wanted to add some commits to this pull request, but after \"Happy new year 2013\" I cannot. I hope you will be able to pull my commits without any serious problem and then I open new pull request with new commits.\n. Any news? I spend my sunday to prepare commits for you and... and you again forget about it. I don't want to resolve merge conflicts to prepare commits for you again.\n. Ok, if you cannot wait \"when with only else entry\" commit, please see 8ad5fd183b7579d13bbcf4c1a50cf01b5d1a6d34 and ebad0c929a58eeca471ec982336994cc3ac616e9 (Note: you can cherrypick this commit without any merge conflicts). But my suggestion \u2014 pull and close this request, and then I create another pull request with this and another commits.\n. Ignore it.  I forgot to exclude this file from commit.\n. It is unrelated change, must be as separated pull request.\nCommon practice (maven and flexmojos flex config generator in flex do it) \u2013 if plugin produce or change virtual file content, it should force update it, so, user don't need to call \"Sync\" or wait auto file sync. May be, we need to update only out file, but not all out dir.\n. ignore this file\n. ignore this file\n. Yes, this file needed for manual js debug of test file.\n. ",
    "zolotov": "@jstrachan, the method which requires a comparator could be named as simple fold I guess. But I don't sure that this kind of folding needed. I've found bug in foldRight because I was needed use this function. The question is that folding with comparator is really esoteric case and I have never used it in Scala. So may be we shouldn't generate vast amount of inline functions in kotlin?\n. Agreed. \nBtw, I guess your example may looks better with reduceLeft/reduceRight function:\nsomething.sortBy{ ...}.reduceLeft { a, b -> a + b }\nI'll implement it tonight :)\n. @jstrachan. Hi. I have some problems with implementing functions for processing collections. Since you have closed my previous pull requests may be you can help me?  \nProblem 1.\nI've implemented sortBy function in this commit but kotlin-js-tests fails and I don't understand why. Stdlib tests pass successfully, but js-tests fail with following message:\nERROR: /kotlin/JLangIterablesSpecial.kt.jet: (83, 44) Unresolved reference: comparator\nERROR: /kotlin/JLangIterablesSpecial.kt.jet: (83, 57) Cannot infer a type for this parameter. To specify it explicitly use the {(p : Type) => ...} notation\nERROR: /kotlin/JLangIterablesSpecial.kt.jet: (83, 60) Cannot infer a type for this parameter. To specify it explicitly use the {(p : Type) => ...} notation\nProblem 2.\nIn the same commit I've placed sortBy function in JLangIterablesSpecial because in other way, generated code for arrays doesn't pass test case:\ntest fun sortBy() {\n        expect(arrayList(-1, 2, -3)) { intArray(-3, -1, 2).sortBy { Math.abs(it) }}\n        expect(arrayList<Float>(-1.toFloat(), 2.toFloat(), -3.toFloat())) { floatArray(-3.toFloat(), -1.toFloat(), 2.toFloat()).sortBy { Math.abs(it) }}\n        expect(arrayList(-1.0, 2.0, -3.0)) { doubleArray(-3.0, -1.0, 2.0).sortBy { Math.abs(it) }}\n        expect(arrayList<Byte>(5, 3, 4)) { byteArray(3, 4, 5).sortBy { it mod 5 } }\n        expect(arrayList<Short>(5, 3, 4)) { shortArray(3, 4, 5).sortBy { it mod 5 } }\n        expect(arrayList<Long>(5, 3, 4)) { longArray(3, 4, 5).sortBy { it mod 5 } }\n        expect(arrayList('1', '2', '3')) { charArray('1', '3', '2').sortBy { it } }\n    }\nIt's can't resolve it variable.\nProblem (question) 3\nCurrent implementation of List<T>.sort (JUtil.kt) method leads astray. It change inner state of list and returns it in the same time. For example:\nval someList = arrayList(3, 1, 2)\nval minimum = someList.sort().first() // 1, its OK\nval firstValue = someList.first() // 1, WTF? :-)\nIt don't make sense return Unit from this function because it becomes simple shortcut for Collections.sort().\nBut it make sense to return sorted copy of list, I believe. It will allow to extend sorting method for all iterables (or collections) including immutable lists, not only for mutable lists.\nWhat do you thing about it?\nBtw, List<T>.reverse method (JUtil.kt) confused me even more=) It return reverted list for List and reverted copy for other iterables:\n```\n        val list : java.util.List = arrayList(1, 2, 3)\n        println(list.reverse().first()) // 3\n        println(list.first()) // 3\n    val coll : java.util.Collection<Int> = arrayList(1, 2, 3)\n    println(coll.reverse().first()) // 3\n    println(coll.first()) // 1\n\n```\nProblem 4\nI want to implement flatten function for iterables. In Java it may looks like this:\n```\nimport static org.testng.Assert.assertEquals;\nimport org.testng.annotations.Test;\nimport java.util.*;\npublic class FlattenTest {\npublic <T, R extends Collection<T>> List<T> flatten(Iterable<R> iterable) {\n    List<T> result = new ArrayList<T>();\n    for (Collection<T> innerCollection : iterable) {\n        result.addAll(innerCollection);\n    }\n    return result;\n}\n\n@Test\npublic void test() {\n    ArrayList<Integer> expectedList = new ArrayList<Integer>() {{\n        add(1);\n        add(2);\n        add(3);\n        add(4);\n    }};\n    assertEquals(flatten(new ArrayList<Collection<Integer>>() {{\n        add(new ArrayList<Integer>() {{\n            add(1);\n            add(2);\n        }});\n        add(new ArrayList<Integer>() {{\n            add(3);\n            add(4);\n        }});\n    }}), expectedList);\n\n    assertEquals(flatten(new ArrayList<List<Integer>>() {{\n        add(new ArrayList<Integer>() {{\n            add(1);\n            add(2);\n        }});\n        add(new ArrayList<Integer>() {{\n            add(3);\n            add(4);\n        }});\n    }}), expectedList);\n}\n\n}\n```\nIn Kotlin I can't implement it. May be it is a bug of Kotlin or bug of me, I don't know=) \nThis implementation can't resolve fold method for R:\npublic inline fun <T, R : java.util.Collection<T>> java.lang.Iterable<R>.flatten(): java.util.Collection<T> {\n    return this.fold(arrayList<T>()) { (x, y) ->\n        x.addAll(y)\n        x\n    }\n}\nAnd this implementations work only for Collection, only for List and only for ArrayList, respectively:\n```\n// works only for arrayList>(arrayList(1, 2), arrayList(3, 4)).flatten()\npublic inline fun  java.lang.Iterable>.flatten(): java.util.Collection {\n    return this.fold(arrayList()) { (x, y) ->\n        x.addAll(y)\n        x\n    }\n}\n// works only for arrayList(arrayList(1, 2), arrayList(3, 4)).flatten()\npublic inline fun  java.lang.Iterable>.flatten(): java.util.Collection {\n    return this.fold(arrayList()) { (x, y) ->\n        x.addAll(y)\n        x\n    }\n}\n// works only for arrayList>(arrayList(1, 2), arrayList(3, 4)).flatten() \npublic inline fun  java.lang.Iterable>.flatten(): java.util.Collection {\n    return this.fold(arrayList()) { (x, y) ->\n        x.addAll(y)\n        x\n    }\n}\n```\n. @jstrachan thank you for your answers, very helpful. \n\nIf you do a pull and re-run your build it'll probably work\n\nHowever js-tests fail anyway :) I'll try to work it out. \n\nEither we have 2 special List only methods for reverse-this and\nsort-this (rather than making a sorted/reversed copy), or we make\nreverse() and sort() always return a mutated copy - and so work for\nany collection/iterable/array.\n\nIf you don't mind I'll reimplement all reverse and sort functions for all iterables with copy-returning strategy and delete that special function for List. \n\ndoes passing the fold type parameter explicitly help?\n return this.fold>(arrayList()) { (x, y) ->\noften Kotlin can't automatically guess the inferred types on methods currently.\n\npublic inline fun <in T, R : java.util.Collection<T>> java.lang.Iterable<out R>.flatten(): java.util.Collection<T> {\n    return (this as java.lang.Iterable<java.util.Collection<T>>).fold(arrayList<T>()) { (x, y) ->\n        x.addAll(y)\n        x\n    }\n}\nIt helped to resolve fold method, but anyway I have to passing explicity help for clients of method too:\narrayList(arrayList<Int>(1, 2), arrayList<Int>(3, 4)).flatten<Int, java.util.Collection<Int>>()\nLikely I'll send you patch with that function and tests :)\n. ",
    "udalov": "patched in b989c701e9801903cf4db97421281c80e2a286ab\n. Done\n. Thanks!\n. @univerio Since 'System.out.println()' outputs a system-dependent line ending and it's used a lot in our generators, you should have system line endings in your local copy to prevent 'git status' including every generated file. If you work on Windows, you should set core.autocrlf to true (and possibly run 'git checkout' after that)\n. :+1: \n. I fixed a NPE warning in your code and pushed to master. Thanks!\n. It's impossible on JVM since Array<T> is not a class, but merely a syntactic construct to represent JVM arrays like Java's T[]. jet.Iterable is also not a class, but an alias for java.lang.Iterable. In Java T[] doesn't extend Iterable<T>, thus doing so in Kotlin would result in runtime exceptions, e.g. when passing a value of type Array<T> to a function expecting Iterable<T>.\n. Thank you, merged upstream\n. Looks mostly good, please fix the remaining issues and notify us about it here. Thanks!\n. Gavin,\nPlease fix the remaining note, squash all your commits into one with a short yet helpful message (no need to repeat all the notes and corrections from the pull request in the message), and notify us here. Thanks\n. OK, everything looks fine now, thanks\n. OK.\nAnd I conclude from this that you read Github before your mail :)\n. I have a few questions.\n1) Is it intended that any complex expressions are not supported by this intention?\nFor example,\n!(true && 1 == 2) becomes !true || !1 == 2, which is a red code\n!(1 == 2 && true) -- not applicable\nThis practically makes the intention useless in a lot of cases.\n2) In Java a similar action is named Replace '&&' with '||' or Replace '||' with '&&'. Why such a scary name here, if it does the same?\ncc @max-kammerer \n. Ross, please also investigate the second case I pointed out. This was the case I've noticed it in the first place -- that the intention is inapplicable almost everywhere in my code.\nThank you!\n. Please fix issues mentioned by Andrey (for some reason they ended up in comments to other commits): \nhttps://github.com/JetBrains/kotlin/commit/60e7670e1a39625781ca40e94a65aec85d7e5b6c\nhttps://github.com/JetBrains/kotlin/commit/40b0fdd741132f24045fce9f7d832bf04e8c5eb2\n. So I tried to invoke this intention on the code:\nif (1 == 2 || 3 == 4) {\n        }\nand got this:\nif (1 == 3 || 2 == 4) {\n        }\nI believe something went wrong...\ncc @abreslav \n. Merged manually, thanks\n. Hi, Lingzhang.\nPlease fix the issues I mentioned on the diff before we start another round of review.\nAlso I think your current tests should be pretty much reworked. Some other notes, mostly about tests:\n- Your intention produces red code for these lambdas:\n  - { -> 42 }\n  - {(): String -> \"a\" }\n  - { a, b, c -> 0 } -- here ??? is inserted for the types. This probably means that this is some special error type coming from resolution (probably one of those at the beginning of TypeUtils). You should either make your intention not applicable here or replace error types with Any. Have a look at how the similar code handles this.\n- All your current tests work with type Int only. This is rather bad, considering you're invoking the process of shortening references several times. Basically at least every line where you use ShortenReferences should be covered by a test.\n- I see a rather non-trivial code about inserting a whitespace in makeTypeExplicitInLambda, but can't find a test on this behavior. Did you forget to add such test?\n- Test where a lambda is inside another lambda: only one of them (the inner) should be processed.\n- At least one of the tests should have the lambda stand-alone, not as an argument to any function: we'll test here that the intention is applicable and works on such lambdas as well.\n- Maybe a test where the expected lambda type is something returning Unit, but on the call site we're passing a lambda which returns a value in the end. This is known as coercion to Unit in our codebase.\n- Please think about any relevant additional tests. You can browse our codebase for an inspiration.\nAlso please rebase your branch on the latest master.\nI'm closing this pull request to avoid confusion, please open another one as soon as you're ready. Thanks!\n. Hi, Lingzhang.\nOverall the code looks much better. Thanks for adding a lot of tests this time, I think it's enough for now. Some remaining issues:\n- Make types explicit: it appears that your algorithm of identifying intention applicability doesn't cover some cases:\n  - { x<caret> -> x }, this is a very important case\n  - { <caret> x -> x }, notice the whitespaces\n  - I'm not 100% sure, but I think it also should be available on the arrow. So, overall, availability on any character starting from the left brace and up to (and including) > in the arrow would be nice\n- Make types implicit transforms {(x: Int, y: Int): Int -> x + y } into {(x, y) -> x + y }, while I'd expect it would have removed the parentheses: { x, y -> x + y }\nAlso I've marked remaining minor issues in inline notes. Please fix those as well, and you can either force-push and comment here, or open a new pull request (as you wish).\nThank you!\n. For the case you've provided in the first message I think your intention should not be applicable there, not to produce red code. The case is when the compiler doesn't know the future type of the lambda when it sees one until it started resolving the lambda. This is known as \"expected type\" in our codebase, and this case is when upon resolution of the lambda there's no non-trivial expected type recorded for the place where this expression is standing. Take a look at usages of BindingContext.EXPECTED_EXPRESSION_TYPE to figure out how to prevent your intention from firing up in such cases. Good luck!\n. > Remove confusing test case(lambdaWithLambdaParam)\nPlease don't remove the test case itself, I meant that it can be simplified: the code inside the function is not needed\n. Hi, Lingzhang. I'm sorry for the delay.\nYou're right, unfortunately it seems that resolution of function literals specifically pushes expected type into the lambda, so that the \"type mismatch\" diagnostic will be displayed on returned expressions and not on the whole lambda itself. So there's no possibility at the moment to find out what type was expected to be seen on the lambda's position. I'll double-check that with my colleagues and get back to you tomorrow if I happen to be mistaken.\nMeanwhile I think it wouldn't be too difficult to solve the problem manually. Your intention should be available if the lambda is located somewhere where its type (and exactly its type) was already specified:\n- on the right-hand side of a property/variable/function declaration with specified type\n- as an argument to a function. Note that there are several possible expressions in our PSI which denote function calls: unary expressions, binary expressions, call expressions, etc.\nKeep in mind that the specified-somewhere type should be exactly equal to the type specified in the lambda itself. Otherwise you would be able for example to erase types of a lambda which was passed to a function taking a generic lambda, which wouldn't be good, because erasing types there produces red code.\nThis will involve a lot of tests (obviously), but I think it's worth it. Good luck!\n. We've discussed this matter again with the team and came to the conclusion that it's acceptable to make the intention applicable even if its result will be red code. The approach I described to you was actually flawed, since it wouldn't work at all for lambdas passed as arguments to generic functions. Sorry about that!\nIn the future we plan to add an inspection on lambda parameters that types may be omitted. I'm pretty sure your code will be useful there.\nAs of this pull request, please delete all debug code and comments and prepare for apparently the last round of review. Thank you!\n. Also please change intention name to \"Make types implicit in lambda (may break code)\". That way it will do exactly what it claims to do.\n. Take a look at the test which fails with your intention: http://teamcity.jetbrains.com/viewLog.html?buildId=130354&tab=buildResultsDiv&buildTypeId=bt345. You might want to do something about it\n. I've left some additional comments to address\n. Okay, there's some really minor stuff left, but I'll be able to finally test and hopefully merge your changes tomorrow (in about 12-14 hours).\n. Take a look at this case:\nval x = {(): Unit -> }\nHere \"make types explicit\" intention is applicable, while it shouldn't be. Please fix this and add a test\n. Merged to master in https://github.com/JetBrains/kotlin/commit/6066d19de5a093b54870e1a9aff08aa7f65a115d\nI've fixed a few things:\n- Don't copy all newlines when specifying types, we need to insert just one (see manyNewlines.kt test)\n- Fixed the test. As I mentioned above it was failing again because you've changed intention name and family name\n- Used Kotlin's Pair to be able to write val (whitespace, arrow) = ... (https://github.com/JetBrains/kotlin/commit/de273c04186832a3da8a112968802c3aecd37cfb)\nGood job, Lingzhang. Thank you!\n. An important test case that is missing:\nfun foo(a: List<Pair<String, Int>>) {\n    for ((x, y) in a) {\n    }\n}\nIdeally I'd like the \"add indices\" intention to be still applicable here, transforming it to something like:\nfun foo(a: List<Pair<String, Int>>) {\n    for ((index, element) in a) {\n        val (x, y) = element\n    }\n}\n, where index and element are both templates.\nI suggest you look into this case, whether or not it's reasonable to support or reject it at the moment\n. In total you should have at least one test for each of the receiver variants of withIndices:\n- array\n- primitive array (one of them is enough)\n- iterable\n- stream\n- string\n. I think both intentions should not be available inside the for loop body, only on the for keyword and inside the parentheses\n. Hi, Ross.\nThe approach is mostly fine, however there are some issues I highlighted on the diff and in the comments. Please fix them before we start another round of review.\nThank you!\n. Hi, Ross.\nI've left some additional comments on the diff. To make your intention unavailable on the for-loop body, I guess you shouldn't be using JetSelfTargetingIntention at all. Are there any difficulties in extending just the BaseIntentionAction class?\nIf you don't have enough time to support \"add withIndices\" on a multi-variable for, it's fine. Just please add a test certifying how it works at the moment.\nThe critical issue is still the availability scope, which I think should start with the for keyword and end with the closing parenthesis of the loop range. Good luck!\n. Please add the copyright to all newly created source files. If you work in IntelliJ IDEA, make sure you have \"Copyright\" plugin turned on. Thanks!\n. Please add a test certifying your change, otherwise we can't be sure that you've fixed the original issue.\nWe don't have any performance tests at the moment, but you can add a test asserting that the printed bytecode text has the required method invocations. See BytecodeTextTestGenerated. In the test data file you should provide several regular expressions and number of occurrences that the printed text should have of each of the regular expressions. Please test all of the appends you supported (you can do it all in one test).\nLeave a note here when you're ready. Thanks!\n. I've seen this problem recently, and a full rebuild helped, i.e. ant dist and Build -> Rebuild project in IntelliJ.\nWe don't run tests from ant/maven, we have an All Tests run configuration in IntelliJ for that. Alternatively you can manually navigate to the test and launch either the whole test class or a single test method. To add a generated test case, you should add a .kt test data file, then find and launch GenerateTests.kt\n. Please try to update the plugin as well, we had an unstable version in master for some time lately. Altogether you should have done the following:\n- fetch and rebase to the latest master\n- ant -f update_dependencies.xml\n- ant\n- update IDEA (135.689+ should be fine) and Kotlin plugin\n- rebuild project\n- run GenerateTests.kt\n- rm -rf ideaSDK/system (clear caches from previous test runs)\nI'm still assuming it's a local problem caused by inconsistencies in plugin/compiler versions or something. Looking at the bytecode I don't see anything suspicious, we generate both methods, one of them is a bridge, and everything works fine on my machine.\n. @abreslav is right, the correct way would be to call JetTypeMapper.mapSignature on the callable descriptor we're generating annotations on, and check whether its return type is non-primitive and non-void.\nAlso note that your changes break some tests (you can run All Tests to check, ignore the non-relevant tests). Please fix the data for all relevant tests, in this case it's NullabilityAnnotationsTest\n. The test is fine, thanks. However take a closer look at the method's name: stringValueOfOrStringBuilderAppendType clearly suggests that it's used not only for determining the type of StringBuilder.append parameter type, but also that of String.valueOf. The latter doesn't have overloads with parameters of these types, so presumably your code will fail at runtime in some cases. You can investigate the usages of this method to construct a test. Good luck!\n. Merged with minor corrections (https://github.com/JetBrains/kotlin/commit/9dec0fb779451c31a2a7bcfe17611995276a2d06). Thanks!\n. Also https://github.com/JetBrains/kotlin/commit/69dd2bbf10244f05e0ad91d28a8ba54e288cb14d\n. Pushed, thank you!\n. Is this safe to close? Please do so if it is\n. :+1: \n. Not a lot to review. Looks good to me, except:\n1) optimized imports in generated tests\n2) there's probably a lot of public override val's in our codebase, you might want to get rid of them\n. OK\n. I've merged to master with the following corrections:\n- revert unnecessary change in docs/\n- delete unused field and getter GenerationState#optimizationEnabled\n- merge two last commits into one\n  Thanks!\n. Thanks\n. Misha, take a look on these tests' history and also remember what @geevee said on the meeting, they are fixed in master\n. You're only testing 70 default arguments :) Please at least add a test of a function with exactly 32 default arguments\n. Hi Denis,\nI've left some notes on your diff, please fix them before we can merge it to master. Leave a comment here when you're done. Thanks!\n. Pushed with some minor changes: https://github.com/JetBrains/kotlin/commit/1533c0e9f3d92e82632601ed310c81cc0b801019\nThank you for the contribution!\n. Merged partially, except for the questionable type checker change. Thanks\n. Merged\n. The test was passing even without the change... I've fixed it and pushed, thanks\n. Maybe add a test when superclass' generic parameter is substituted in the subclass? I believe that is the case when f.getOriginal() != f and kdoc is not showed on the function in the subclass as far as I can see\n. Looks good to me\n. Ok\n. Ok\n. Char is not a Number and hence should not be declared in the file named Numbers.kt\n. Ok\n. I've added a test and merged manually, thanks!\n. @orangy @yole Please review this (more docs on reflection later).\nOne of my concerns as a Dokka user is generic parameters (e.g. R for property return type) that have the same meaning all over the property hierarchy. Should I copy-paste their @param docs to each class?\n. Thanks! Will merge manually in a bit\n. Looks ok to me.\ncc @max-kammerer, the original author of this code\n. This change breaks the following case for example:\nfun box() = if (4 as? Unit != null) \"Fail\" else \"OK\"\nThe reason is that all cast-like operators go through this method, including :, as, as?, is\n. Ok, looks good to me. Also this seems to fix KT-3066, please add a test, squash and merge\n. Ok\n. Ok\n. I propose to add more tests:\n- a test where default arguments come after non-default, or even when defaultness changes multiple times\n- constructors (primary and secondary)\n- a Java interop test (boxWithJava)\n- traits & method implementations in traits. Currently this breaks the compiler with the exception:\ntrait A {\n    overloads fun foo(s: String = \"OK\")\n}\n. Also, not sure what of this should be fixed or put into the tracker:\n- NotNull/Nullable are not generated on the synthetic functions and their parameters, this will make them less pleasant to call from Java\n- we should report a warning when this annotation is used on functions with no default parameters or on private functions or anywhere else it makes little sense\n- accidental override is not reported on inheritance and declaration of the function with the conflicting signature:\n```\nopen class A {\n    overloads fun foo(s: String = \"OK\") {}\n}\nclass B : A() {\n    fun foo() {} // <-- should be an error\n}\n```\n. Also you seem to skip generic signatures for generated functions, is that intended? Raw functions are not so nice to call as generic ones.\n. Looks good to me except a couple minor remarks\n. @abreslav Please review the changes since (and including) 56016fd, and I'll merge to master\n. Pushed, thanks\n. Isn't this in master already?\n. Thank you! I've merged this manually and also done the same with the Unix script (https://github.com/JetBrains/kotlin/commit/1b7ba320c76895936fa8354534cb3289c9ab899c)\n. OK, let's try it\n. Ok\n. Ok; \"invert if\" maybe?\n. Ok\n. Ok\n. Ok\n. Ok\n. It's ok, I don't see any problems, but what have you tested after these changes?\n. Ok, thanks\n. Ok, looks good\n. I'm glad that this workarounds the problem, thank you for your time spent on this! I'll merge this manually.\nWe should try to locate the issue in ART though, to prevent it from happening in the future. I'll contact you over email about that.\n. Yes, I think it would be more consistent and less surprising. Thanks!\n. How about a test? :)\n. I'm not sure, but if it's not too difficult to test the compiler output of the hello world project, why not? We have a bunch of such tests for the CLI compiler\n. I'd take the full compilation log of the hello world project, replace environment-sensitive substrings like date, time and paths with some wildcards, and compare it with a text file. This way we will see if something changes to the basic compiler output, which ideally probably should not happen. See for example Ant task tests.\n. Awsome, thanks\n. Ok\n. Done\n. Would make sense to also rename other stuff in our project which has PlatformStatic in its name, e.g. PlatformStaticAnnotationChecker, isPlatformStaticIn, etc.\n. ^ BTW manifest name still isn't fixed\n. I don't like this approach because the order of tests may now have a subtle effect on their outcomes, is there any other solution?\n. > find out how to properly detect testing mode in our ApplicationEnvironment\nApplicationManager.getApplication().isUnitTestMode()?\n\nWill it look good enough if I'll implement storing and restoring the value of the property on setup and shutdown respectively, as proposed by Michael Nedzelsky?\n\nI'm OK with it, although it's still not perfect because tearDown is not called if a test fails in setUp\n. I think you can just do something like this:\nvalue.put(parameterDescriptorType, codegen.v);\n    StackValue.coerce(parameterDescriptorType, parameterType, codegen.v);\nNo checks for primitives are needed, put invokes coerce which handles that by itself.\nAlso please add a box (BlackBoxCodegenTestGenerated) test which would produce ClassCastException now and remove the bytecode text test. We're trying to add tests on the bytecode text only when absolutely necessary, because they are more fragile than box tests.\nThanks!\n. I guess it's OK if there's no easy way to solve it on another level.\n. After an offline discussion with @max-kammerer, it became clear that the problem is reproducible only for constants which are not instances of KtConstantExpression. For the latter, ExpressionCodegen#visitConstantExpression works fine by generating the value computed eariler by the front-end of the compiler. Non-constants are fine because you can't pass an Int where Long is expected and vice versa.\nAn expression such as -1 is a unary expression and codegen ends up in ExpressionCodegen#visitUnaryExpression where it doesn't then try to lookup the constant value like it does in visitConstantExpression, although that value is computed and is stored in the corresponding slice of the binding context. The same happens for binary expressions in visitBinaryExpression.\nThe solution we've came up with is to manually check for evaluated compile time constants in those methods (just like in visitConstantExpression) and avoid the normal code generation which would box the primitive in a wrong wrapper class. Besides unary and binary expressions we should also consider labeled and parenthesized expressions and maybe something else I overlooked which ConstantExpressionEvaluatorVisitor is able to process but codegen is ignoring.\nThe major problem of that approach is that, if implemented as described, it would start to inline values of Kotlin const properties sometimes (values of const properties are currently not inlined and that is correct, we're not sure we should do that yet). For simple expressions like x (where x is declared as const val x = 0) codegen ends up in ExpressionCodegen#visitSimpleNameExpression where it eventually creates a StackValue.Property instance which is able to prevent inlining in case when it's a Kotlin const val, that is fine and will continue to work. But if you have an expression like -x, you can't unconditionally get its constant value and put it to the stack like visitConstantExpression does, because that would change semantics, we want invokevirtual + lneg still generated here. Note that it's relevant only for Kotlin properties, Java fields should be inlined.\nOne workaround to this would be of course to manually check if an expression which has an evaluated constant value contains a Kotlin property referenced somewhere in it, with a custom KtVisitor. This sounds pretty fragile to me but it's the best that we could think of. Maybe there are other solutions, if you find one, please share. Overall this issue turned out to be a rather difficult one from my point of view, feel free to withdraw if you feel the same way :)\n. @mcgee Sorry for the delay. It seems that the issues you mentioned have been fixed in the compiler, would you be willing to continue working on this issue? Thanks!\n. This seems to break when the usage does not contain a slash, i.e. please try . paths.sh or source paths.sh. Do you maybe know the solution to that problem?\nAlso which is so basic I couldn't imagine it's missing on some systems. Even MinGW has it. I'm not sure how NixOS is even usable without which? :)\n. Sorry for the delay! I've merged your commit manually: https://github.com/JetBrains/kotlin/commit/7cad65a1e707c73f594e1ae8cf9c75b609f177c5\nThank you!\n. > Constructor test already exists in compiler\\testData\\codegen\\box\\reflection\\constructors\\constructorName.kt\nKCallable#name itself is already tested, and not only for constructors but for properties and functions as well. I think I was wrong in suggesting you to use codegen/box tests initially, they won't test anything here, so maybe they should be deleted.\n. I think the implementation is fine, could not think of anything substantially better. I've launched a remote run with your changes.\n. Merged (https://github.com/JetBrains/kotlin/commit/4a619db7219e1a09b63c27d28db25b44ae10066c), thank you for the contribution!\n. I've fixed the name of the inspection description. Otherwise \"Can't find inspection description\" was reported in the settings\n. Could you please explain why such change is needed? In what circumstances is the Kotlin Ant task launched without the compiler and/or the runtime beside it?\n. Thanks, I've also changed the declaration in core/reflection.jvm/src/kotlin/reflect/KAnnotatedElements.kt and added a test, will push soon.. Obsolete?. Thanks for the contribution, but I don't think this is the right place for such change. addToStdlib.kt is a part of the Kotlin compiler code. We only declare something there which is used in the compiler code and is generic enough to be a good candidate for the standard library. Until a function is used in the compiler code, there's no need to declare it there. We try not to keep unused declarations around in our project.\nIf you're expressing an opinion that a function would be useful for the standard library, please file a YouTrack issue instead. If you mean to actually add a function to the standard library, it would require a bit more than adding its implementation: it should be documented and tested as well.. @ilmat192 Has this been reviewed by someone from the Kotlin team?. Other primitive classes also had this typo, I've fixed it in https://github.com/JetBrains/kotlin/commit/43f1c843ce09d4fa834559df30def9f05029b82f. FYI lazy { ... } is very expensive here, in my opinion. Both in terms of memory (bytecode size and memory used by the program) and execution performance. Most of the methods in JavaElement and subclasses are invoked once or twice, so there's usually no need to cache anything. Please refer to the PSI-based implementation (JavaElementImpl and subclasses).. Please move packages components and wrappers in the module javac-wrapper from org.jetbrains.kotlin inside org.jetbrains.kotlin.javac. Thanks!. Fixed in #1111 . Thank you!. Hi, thanks for the pull request. The main problem with this approach is that the classes loaded during the execution of the compiler might differ significantly from the classes that are being compiled. For example, since the Kotlin compiler is used to compile itself, it won't be easy to remove a supertype from one of the classes in the compiler itself (because with these changes, the compiler would still think that the supertype is there, leading to bad code generated). In general, it's incorrect to draw any information about the code being compiled from the JVM process that is running the compiler.\nAnother problem is that Class.forName leads to initialization of the class, which may lead to undesired side effects during compilation.\nLastly, I suspect that trying to load a class every time in StackValue.coerce causes the class loader to go look for it, involving a noticeable amount of I/O operations, which may lead to worse performance here.. Looks fine, I don't have any other comments at this point.\n@ligee Please review as well. To render a KotlinType to a string, use DescriptorRenderer.renderType. You can either get the pre-declared renderer instance from DescriptorRenderer's companion object (FQ_NAMES_IN_TYPES and SHORT_NAMES_IN_TYPES are some of the most commonly used ones), or construct a DescriptorRendererImpl with custom DescriptorRendererOptions if none of the pre-declared ones suit your needs.. > What is wrong with KotlinType::toString()? Do we really need all machinery with DescriptorRenderer.renderType?\nThe difference between the two is that we use toString for debug and tests only, and DescriptorRenderer -- for presenting types and declarations to the user (e.g. in the IDE, in reflection, etc.). So, the former has no requirements on what it should return, but the latter is relatively much more stable and tested. You may notice that some KotlinType implementations use DescriptorRenderer.DEBUG in their toString, which outputs some additional debug information. Some have their own ad-hoc implementation that can change at any moment. Some can even return things like \"<Not computed yet>\" in their toString.. Thank you!. @sandwwraith I suppose this can be closed?. @mglukhikh Could you please use your own fork in the future for pull requests which should neither be reviewed nor merged?. Hi, thanks for the contribution.\nThere are several problems with your pull request:\n1) This won't work if a user passes -cp explicitly, because the Kotlin compiler doesn't support multiple -cp arguments (in kotlinc -cp ... -cp ..., the second argument would be ignored). To fix this, you can change K2JVMCompilerArguments.classpath to be of the type Array<String>\n2) The Windows batch script at compiler/cli/bin/kotlinc.bat needs to support this too\n3) An integration test must be added. Please add a test case to LauncherScriptTest, for example. To test this behavior, you need to pass environment variables to the GeneralCommandLine instance created in that test\n4) Instead of replicating code, it's better to append (or prepend) the needed argument to the kotlin_args variable in the script\nFinally, even though this seems easy and natural to support, it'd be nice to have a YouTrack issue describing what behavior is exactly missing and why is it necessary for you.\nThanks!. To update *Generated tests, you can run ./gradlew generateTests or the run configuration \"Generate All Tests\" in IntelliJ. Could you please report a separate issue describing your use case, so that we could track it properly, it'd end up in the changelog in the correct place, etc. Thanks!. Merged to master and 1.2.20. Thank you for the contribution!. This will likely change some test data that uses .txt files with rendered Kotlin declarations. Please run all compiler tests with ./gradlew cleanTest :compiler:test. I've fixed the remaining tests, squashed everything into two commits, and merged to master. Thank you for the contribution!. I've replaced Regex(\"...\") to \"...\".toRegex() which is considered more idiomatic Kotlin, and pushed to master. Thanks!. Thank you for the contribution!. Please make sure that nothing is reported in\n```\nclass C {\n    companion object {\n        fun foo() {}\n    }\n}\nfun test() = C.Companion::foo  // should be green\n```\n. I've squashed the commits into one, combined the commit messages and merged manually. Thank you for the contribution!. I've reviewed the main codegen part and the tests, and everything seems OK.\n@max-kammerer Please review the compiler/backend.jvm part. I'm not sure about the fact that the code is copy-pasted and whether we can do something about it, but seems like all other new backend intrinsics are copy-pasted as well.... Thanks! Merged manually.. Thanks, but I'm afraid this makes the message unnecessarily long. Maybe we should drop the \"i.e. <...>\" part?. I've pushed the following version:\n\nExpected performance impact of inlining ''{0}'' is insignificant. Inlining works best for functions with parameters of functional types\n\nThank you!. Merged manually. Thanks!. Follow-up: https://github.com/JetBrains/kotlin/commit/30b9caeae6ea399dd160d6d504315d5a21b8d22b. If you'd try to compile these files after the change, you'd know the answer, which is: according to the Kotlin grammar, the next word token after the words companion object is parsed as its name, and so the word public a few lines below would actually be parsed as the name of the companion object, not as the function modifier. I think there would be a parser error about the fact that one declaration (companion object public) is not separated from the next (fun ...) with ;.. This looks great and probably fixes https://youtrack.jetbrains.com/issue/KT-23707. Please also add a test case to MethodOrderTest just in case (even if it doesn't reproduce on your machine). I've added the test case and merged these changes. Thank you!. Thank you! I've simplified the test case and merged manually.\nAlso I've investigated this a bit and I think there should be an assertion in the bytecode, so I've reported an issue: https://youtrack.jetbrains.com/issue/KT-24210. Hi @Hemachandar! Are you sure you've selected the correct branch for the pull request? This branch contains several commits from one of our team members, no commits authored by you.. Sorry for the delay! We've merged your change and it'll be released in 1.2.70.\nThe delay was mainly caused by us trying to find the correct set of changes to adapt our optimized representation of Kotlin classes in the IDE, so that newly added nullability annotations would be seen correctly from Java sources: see eaa58c3ec226b94a8613439f21efd6e199bfba4c, be611cd15464f31c9d9a755f8f6c9491e0c28a53.\nI've also changed the way the annotations are generated to make them appear in RuntimeInvisibleAnnotations, not RuntimeVisibleAnnotations, since NotNull/Nullable have retention CLASS, not RUNTIME: 628833af65c4cb4ac8be6376bf5971950e70ef2e.\nThank you for your contribution!. Please run CliTestGenerated and fix test data of failed tests. Pushed at 8ce658ab546b128bb298d33c8980ac95341fd80a. Thank you for the contribution and sorry for the long delay! I've merged your commit in 05f6ed40f1, and used a new test instead of the obsolete PropertyGenTest in 5fb1bbe3f3. The fix will be available since Kotlin 1.3.20.. @ilya-g sure, but I think this doesn't belong in the checklist. Merged manually. Minor, but performance is usually said to be improved, not increased. Maybe \"increase\" is also fine in some contexts, but here performance is not a number, so it feels incorrect (cc @mglukhikh). Thank you for the contribution! I've taken a look and figured out a way to avoid dealing with the PSI directly and support most of the annotation argument kinds, but that involved using code from another module (frontend.java), so I've moved this logic there: https://github.com/JetBrains/kotlin/commit/5fa6f7db5a0e7eea5af00df5ac3fdf7ff1cc449f\nI'm now finishing work on my other branch which would help in supporting class literal (.class) arguments here too, after which I'll merge this branch to master. Sadly, I have to postpone the support of annotations as annotation arguments because it requires a major refactoring around AnnotationValue and related classes. But otherwise, all argument kinds are supported and I've added them all to the test.. I've merged your change as c08540175b, and my follow-ups as 49d6a7a7cb and 3bfe138dbe. These changes will be available since Kotlin 1.3.20. I've reported KT-28077 for the remaining case with the annotation values in annotation arguments.\nOnce again, thanks for the contribution!. Thanks for your contribution!\nI'm afraid this approach won't work on macOS because readlink on Darwin is derived from BSD and has a slightly different syntax, for example -f there means the format, not the option to canonicalize the path. Also, I'm having some doubts in general about the problem you're seeing, let's head to the issue you've created and discuss it there, after which we can update the pull request as necessary.. As discussed above and in KT-27880, we can't accept this pull request because it won't work on macOS. However, even though KT-27880 turned out to be a different problem, it still fixes a problem reported as KT-28217. I've left a reference to this pull request there, and we'll get back to it when fixing KT-28217. Thank you again!. Why would you like to contribute this change? Does it solve any problem you met?. I see no coding convention that this code does not satisfy. Are you using this document or something else? AFAIK it's perfectly allowed by the official Kotlin style guide to have if statements without braces. Even if it's not: we have the style rules configured in our project in the \"Reformat\" IntelliJ action, and you can verify that this code satisfies them by invoking Ctrl+Shift+L / Cmd+Shift+L on this statement.\nSince this change does not solve any existing problem, I'm closing this pull request. We appreciate your desire to contribute, but in the future, please explain precisely what do you want to achieve when submitting a pull request, and please refrain from suggesting pure style changes, since they bring very little value but take some time to review and add some overhead to the repo's history.. This file is actually copied from intellij-community where the problem is already fixed. @Alefas Do you remember the reasons why it was copied to our repository? Maybe it'd make more sense to get rid of the copy-paste, and only use the logic from the original class instead, if that's possible.. Hello and thanks for your pull request! Since Kotlin 1.3 is already released and we cannot add new API to kotlin-reflect in an incremental release (see Stability of Different Components), this can only be released starting from 1.4. Therefore please adjust the @SinceKotlin annotation value to \"1.4\".\n\nI'm not sure how to add tests to this, as there are no tests for KAnnotatedElement nor there are tests for KAnnotatedElements file\n\nPlease add a test on this to a new file near compiler/testData/codegen/box/reflection/annotations/findAnnotation.kt, regenerate tests by ./gradlew generateTests (or \"Generate Compiler Tests\" IntelliJ Run configuration) and check that all newly added tests pass. Thank you!. @Kerooker Sorry for the delay! No, the change looks OK now (except for the compilation error in the test, which I'll fix). The problem is that the 1.4 release is so far away that we don't even have the necessary branch in place, and we can't merge this change to master since it's a new API (even though it's @SinceKotlin(\"1.4\"), it's still a change in the ABI and can be observed if called from Java for example).\nI'll try creating a separate branch soon where stable language/API versions are increased to 1.4, and at that point it'll be possible to merge your changes. Thanks once again!. Instead of creating a separate branch for 1.4 as we did in previous releases, we've decided to release most of the new library API as experimental in master, under @ExperimentalStdlibApi. I've annotated hasAnnotation with this marker and merged it to master. Therefore hasAnnotation will be available since 1.3.40, but to use it, one must either annotate the call site with @UseExperimental(ExperimentalStdlibApi::class) or provide the compiler flag -Xuse-experimental=kotlin.ExperimentalStdlibApi.\nThank you for the contribution!. @pyos Please configure git config user.name to show your first/last name. Has this been reviewed by someone else?. Hi Mads,\nWe've looked at this problem and your solution in more detail and @anton-bannykh convinced me that the current approach of dealing with Boolean.not needs to be refactored in another way. Namely, we should avoid using the fake NOT operator completely, even in psi2ir, and always get the real declaration not found in kotlin.Boolean. Anton has implemented this solution and it's being reviewed at https://upsource.jetbrains.com/kotlin/review/KOTLIN-CR-2839. It has allowed to get rid of the complex check in JvmBuiltinOptimizationLowering in exactly the same way as in your pull request.\nAlso, by @max-kammerer's request I un-inlined isNegation since the code looks more concise this way.\nI apologize for the way this has been handled. Since this code affects all backends, I think I needed to raise this issue to JS and Native teams earlier, to make sure that they're fine with the proposed solution, before implementing it. Will do that for such issues from now on.. I think this is actually a nice and free optimization: when we search for null, there's no need to execute the whole item == null ? this[i] == null : item.equals(this[i]) comparison on each iteration, since nullability of item doesn't change throughout the loop. Effectively fewer bytecode instructions are executed, specifically conditional jumps (1 vs size). I believe @jrenner used java.util.AbstractCollection#contains as a reference, sorry if I'm wrong\n. Please update this file to be exactly the result of your intention on before.kt.template. Also you can use <spot> tag to highlight the place where the user should put his attention\n. \"takes\"\n. You declare this variable here, but for some reason only use it once: in other places, you still call element.getValueArguments()\n. Please don't just copy-paste code without adapting it :) Here you use any, but a few lines earlier you use a hand-written for-loop. You should attempt to use similar constructs for similar intents: either any everywhere, or for-loops everywhere. You can also combine these two and save a few lines\n. Note that in Kotlin == is equivalent to equals. The former looks a lot more readable, so we usually prefer it over equals\n. return in applyTo should give you a hint that's something's not right: your isApplicableTo should've already filtered out inapplicable usages and applyTo should only apply the intention on a good code. Here it appears that your intention says that it is applicable to expressions other than JetDotQualifiedExpression (in isApplicable), but applyTo doesn't do anything on them. As a result, your intention is available on get(0) (without any receiver expression), but does nothing, which is not right for an intention\n. This variable is no longer used. Please watch out for compilation warnings in your code (yellow spots on the scroll bar in IDEA)\n. There's an inspection here saying that you should use [] instead of get\n. Ditto ([] instead of get)\n. There are warnings saying that !! is useless on func, since it's been already checked to be non-null.\nAlso these variables don't add much to the readability, it may be a good idea to inline them\n. There's a warning saying that getValueParameters never returns null. Maybe you meant to check if it's non-empty?\n. There's a warning here and on the previous line about a useless ?:\n. There's a warning here about a useless !!: you've already asserted that descriptor is non-null on the previous line\n. You call element.getFunctionLiteral() a lot in this function. Why not extract it to a named variable?\n. There's a warning about a useless !! here\n. Ditto (element.getFunctionLiteral() deserves to be extracted into a variable)\n. Missing a space before {\n. A nicer way would be to use makeString, which allows to pass a prefix and a postfix:\nval parameterString = valueParameters.map { ... }.makeString(\", \", \"(\", \")\")\n. Again, please declare all variables exactly before they are needed. In this function, expectedReturnType is only needed in Step 2, so declare it there. expectedReceiverType is only needed in Step 3, and so on\n. Why not ... in lambda ?\n. Please declare all variables exactly before they are needed. It's usually a bad idea to declare all variables at once and then write the whole logic. A reader might think that the following behavior somehow depends on values of all these variables, while in reality your code should look more like: if doesn't have declared param types, return true; else if doesn't have declared return type, return true; else and so on. That's a lot easier to grasp, since you don't have to carry a lot of context while reading the code\n. Changes in this file shouldn't have been included in your pull request\n. Basically you've used the same test data file in all tests on makeTypeExplicitInLambda, altering the calling function in each case. This is not a good idea, because once one of such tests fails, the investigating person might think that the fact that there are several functions in this file is relevant to the test case, while in reality it's not.\nPlease try to make your tests as minimal as possible, i.e. only include relevant data in each test.\n. Why not \"Make types explicit/implicit in lambda\"? I believe I asked you this the first time\n. Please don't store any information in mutable vars inside your intention: it might cause problems with concurrency. E.g. see what problems Gavin encountered in #411\n. This can be simplified to paramsTextRange != null && caretLocation in paramsTextRange or paramsTextRange?.contains(caretLocation) ?: false, whichever you like the most\n. Yes, you should probably use some other mechanism to prevent code duplication, for instance write a function which computes everything relevant and invoke it twice, in isApplicable and apply\n. Type of descriptor can be a non-null ValueParameterDescriptor here, because Kotlin sees Java generic types with non-null type arguments by default, so valueParameters is actually List<ValueParameterDescriptor>, not List<ValueParameterDescriptor?>\n. This is rather minor, but you should always strive to do simple checks first and complex checks later. It increases both readability and performance. Here params.isEmpty() is obviously very cheap compared to the other condition which involves looping over a collection\n. I think params should have been named oldParameterList, to oppose newParameterList\n. There's a warning on ?. here :) If you're not sure whether or not your code has warnings, check the small box in IntelliJ's top-right corner, it should be green\n. Please convert this to && by DeMorgan, it'll be more readable that way\n. Ditto\n. Ditto (paramsTextRange != null && caretLocation in paramsTextRange or paramsTextRange?.contains(caretLocation) ?: false)\n. I think I noticed the first time: such code creates a false sense that the applicability of the intention here depends on all three of these variables. Your code should look more like this:\n1. if has declared params type, return true\n2. if has declared return type, return true\n3. if has declared receiver type, return true\n4. return false\nOnce you refactor your code to look like this, you'll notice that these variables are no longer needed since they can be inlined. This will make the code shorter. Please do this.\n. Also you can change the order of these checks for efficiency (hasDeclaredParamsType should go last)\n. This is a nice test case, but is this code really needed to test your intention? I think it's just confusing...\n. Ditto\n. A little elaboration won't hurt: types of parameters, receiver and return type\n. Ditto\n. Don't forget to delete all debug output from your changeset\n. Are all three sub-expressions of this elvis expression tested?\n. A one-liner would be nicer in my opinion:\nreturn hasExplicitReturnType(element) || hasExplicitReceiverType(element) || hasExplicitParamType(element)\n. It's not very acceptable to compare text of nodes, especially when you can do the same structurally:\nfirstChild.getElementType() == JetTokens.LPAR\n. Ditto (JetTokens.RPAR)\n. Please add a space before ( :)\n. Ditto\n. This code looks a little awkward to me.\nFirst, consider using other standard library functions such as none or all instead of any to prevent at least some negations.\nSecond, why can't you iterate the parameter list with one simple for and check two conditions for each parameter in the loop body?\n. Your intention would be helpful to make types implicit here :) I think they don't really add anything to readability\n. The last 2 functions in this file should be private\n. Ditto (private)\n. I couldn't find tests on this code, am I missing something? It looks kind of complex\n. Ditto: I don't think types are needed here\n. Please collapse these two lines. if (condition) return true; return false can be simplified to return condition\n. Formatting got screwed up while you were modifying this code. It should be:\nval ....map({\n    parameter -> ...\n}).makeString(...)\n. !! shouldn't be needed here\n. Better, but shouldn't it be a boolean hasExplicitParamType? :)\n. Yes, our formatter fails here at the moment, but you still should indent this line manually with 4 spaces\n. Note that this test is now failing again due to obvious reasons :)\n. Do you allow to use the intention only if the resulting code will be green? In that case, I'm not sure what's wrong, but it's still applicable whenever there are errors in the initial code, e.g.\nfun foo() {\n    for (a in b) { // <-- still applicable here, although 'b' is unresolved\n    }\n}\n. Also please read the latest message by Andrey at kotlin-students@, rebase on the latest master and use AnalyzerUtil\n. You should use // WITH_RUNTIME directive in this and all other tests where you use standard library functions to avoid errors\n. Also:\n```\nfun String.withIndices(): Int = 42\nfun foo(s: String) {\n    for (a in s) {\n    }\n}\n```\nI think the intention should not be applicable here, because it would produce a bad code (Int is not iterable). This means you actually need to check what the newly inserted withIndices would resolve to (should be the one in package kotlin).\n. I'm not sure what's happening here because SortedMap is not an iterable/stream/array, so it doesn't have withIndices extension and the intention should not be applicable on it as well as on Map\n. You don't need this cast (experience the power of Kotlin)\n. Please use == instead of equals in Kotlin code\n. Once again experience the power of Kotlin and just use a var here\n. Similarly to the first intention, I think we should check here if withIndices is actually resolved to kotlin.withIndices (don't forget about a test)\n. How about ++?\n. Do you really need to continue processing all usages if you've already found one? This also means that you should just have a boolean flag instead of an integer value\n. Processor is a Java interface with a single method (SAM interface), so you should be able to just pass a lambda instead of an object expression, thanks to SAM conversion in Kotlin\n. I'm not sure what's the point in creating a Runnable and immediately running it?\n. Also mind whitespaces after commas\n. Please add a whitespace after the comma\n. You shouldn't call getFqNameSafe, because FQ name can be unsafe here (consider functions in class objects)\n. Ditto (getFqNameSafe)\n. This is a nice optimization, but I'd check if selector is a call expression with a callee named withIndices. People can have different weird code style settings, for example ones requiring spaces before parentheses; it would be a pity if this intention wouldn't work in that case (withIndices ())\n. The same here, I wouldn't want add withIndices intention to be applicable where I've typed withIndices ()\n. The test is fine, the naming is not: overridden function is a function declaration in a subclass with the same signature as in the superclass. There are no overridden functions here, withIndices is just an extension function\n. Should be Add Indices to For Loop, take a look at https://github.com/JetBrains/kotlin/commit/5a0055cbeb90b0c6d80c223d4d68cc451d0ccfc1\n. Remove Indices from For Loop\n. Also please rename this test\n. As I mentioned earlier, this should be a boolean flag, rather than an integer variable\n. Should be getResultingDescriptor, not getCandidateDescriptor\n. Also should be getResultingDescriptor\n. You should check if there are any entries. Otherwise your intention fails with the exception on the following test case:\nkotlin\n        for (() in listOf(1).withIndices()) {\n        }\n. I think declaring a Set<Type> would be more straightforward. You can use Type.getType(Class<?>) to create corresponding Type objects\n. Please add a space after if\n. StringUtil.repeat(INT_TYPE.getDescriptor(), maskArgumentsCount)\n. Typo? count, not cont\n. Also to calculate a ceiling of an integer division a / b, you should do (a + b - 1) / b. Or use IntMath.divide (in more complex cases)\n. This comment is useless :) If I don't understand >> 2, I'll go and read what the method returns by myself, and if I do, I need not this comment at all\n. Not sure why you're encoding no masks with null when an empty list would work just fine. Might also be a good idea to annotate the return type of the method with @NotNull\n. Take a look on the usages, this method should take a Method as a parameter rather than a String\n. Unfortunately no test checks the introduced behavior in FunctionCodegen#generateConstructorWithoutParametersIfNeeded().\nThis test looks almost as if it does, but A() here is only a syntactic sugar for invoking the $default method :)\nTo test precisely the synthetic no-args constructor we generate for a class whose constructor's arguments are all default, you could either invoke it from Java or call it reflectively via newInstance (I recommend the latter).\n. Should this iconst still be done if there's exactly 32*n parameters?\n. Use i here, introduced a few lines earlier\n. The correct spelling is extension :)\n. It's alright, their time will come\n. I suggest to use a temporary trace here (and discard it) instead of state.getBindingTrace() so that ConstantExpressionEvaluator won't unexpectedly write to the global trace and alter the subsequent code generation.\n. Similar code is present in generateInstanceOf which probably means Unit is Int? is also affected?\n. There's AsmUtil#isIntPrimitive\n. FqName(\"kotlin.jvm.overloads\") would be more grep-friendly. Also I would make it a constant (either top-level or in the companion)\n. Please extract state.getTypeMapper() to a property\n. else should be on the next line :) Several times in this file\n. Already calculated a little earlier (paramType)\n. Maybe use the value returned by enterTemp instead of 0 for better readability\n. Maybe it will be useful to document exactly what overloads are generated here? One might think that 2^n overloads will be generated, if n is the number of default parameters\n. Please also add an internal member with overloads here, to ensure the warning is not reported on it\n. Correct, fixed now, thanks!\n. Please use Visibilities.isPrivate instead & add a test on a private-to-this fun/val in a trait\n. Looks good, thanks\n. Probably this shouldn't be reported at all here?\nConsider this example:\n```\ntrait A\ntrait B\ntrait C : A, B\nfun foo(a: A) {}\nfun foo(b: B) {}\nfun bar(c: C) = foo(c as A)   // <-- incorrect warning here, the cast is not useless\n``\n. I don't think another exit code is needed\n. Something wrong with formatting in this file I suppose?\n.Collections.emptyList()?\n. If you're usingPredicate, you might as well go ahead and callCollections2.filterhere. Also I would recommend to usekotlin.Function1andKotlinPackage.filterinstead, but that's up to you\n. Just add a newline between(andprojectand press Ctrl+Shift+L / Cmd+Shift+L\n. Other stuff under theNew...menu doesn't start with \"New\", this probably shouldn't start as well\n. No, I mean inkotlin-runtime.jar, will fix\n. \"assignable\" looks much better, thanks\n. This means that the situation in which you would only need to implement a single method when passing a lambda from Java to Kotlin is the best. Much better than the situation in which you would  need to override, say, two methods each time (this sounds like nonsense, but still).\n. An unfortunate contraction ofFunction0, will remove to reduce confusion\n.FunctionImplcovers only the case of Kotlin lambdas of arity <= 22.Function.arityhighlighted in the previous point also supports arity of lambdas of bigger arities and lambdas created in Java, which do not inherit fromFunctionImpl.\n. If a receiver parameter type is specified in the beginning of the function literal ({ Int.() -> }) or in the function expression (fun Int.() = ...`), this means that literal or expression represents an extension lambda and must only be used where the corresponding parameter's type is an extension function. The opposite is only relevant for function expressions though: if a function expression doesn't have a receiver type specified, it's a non-extension function and must only be passed to a parameter which type is a non-extension function. (If a function literal doesn't have a receiver type specified, it still can be an extension function.) Generally we want to keep as much old behavior as possible.\nI'll rewrite this point in the document, currently it makes little sense\n. Yes\n. Is it not possible with Kotlin stdlib?\n. interface Function2<in P1, in P2, out R>: Function<R> {\n    fun invoke(p1: P1, p2: P2): R\n    fun P1.invoke(p2: P2): R   // <-- first type parameter of Function2, P1, is the extension receiver type here\n}\n. Please do not put it under package kotlin as this is what's used by our stdlib, reflection and other public API. I propose org.jetbrains.kotlin.com.google.protobuf and org.jetbrains.kotlin.javax.inject\n. Why not package kotlin?\n. There's another fileset which is used in the compiler-quick target and declared just below, please also add these modules there.\nAlso please add them to compiler-sources.\n. Documentation should probably not mention JavaScript anymore\n. Mistyped whitespace\n. Other lines here use <fileset dir=...>\n. Why are you printing this & other information to stdout, not stderr?\n. Please use Kotlin's map { ... }\n. toTypedArray()\n. This try/catch and rethrows are not needed in Kotlin\n. when\n. Early return would be helpful\n. toTypedArray()\n. Please use Kotlin's split\n. Not related to changes, but why is it uppercase?\n. I think underscore is not needed here\n. Somewhat yes, otherwise what's the point in conversion? The converter is not perfect, the stuff I mentioned and the like is left very often after the conversion and is very easy to spot and fix, so why not? Of course there's no need to rewrite the whole file to make more idiomatic Kotlin, but I don't see the problem in a basic cleanup to reduce and simplify the produced code.\n. I think this error message looks weird on classes in type positions...\n. This was corrupted by the refactoring and is now in fact \"kotlin.Deprecated\". Let's use a hard-coded string instead.\n. I think this whole file should be moved to frontend...\n. Yes\n. rename PlatformStaticGenerator -> JvmStaticGenerator?\n. hasJvmStaticAnnotation?\n. Why is this needed here?\n. use String#toBoolean()\n. String#toBoolean() is just a Kotlin way of saying Boolean.parseBoolean, look at its implementation\n. as? Int should work I think\n. What about ICONST_M1?\n. is is a \"check\", but as is not :) generateCast?\n. BTW, this is exponential; please use TypeUtils#getAllSupertypes instead\n. This test doesn't check that no classes were generated for the property reference. I don't think it's possible in a box test, please try a bytecode listing test instead (compiler/testData/codegen/bytecodeListing).\nAlso please test constructors and functions\n. descriptor.name.asString()\n. @baratynskiy Please use getBoolean(...) instead of get(...)!!. I think you should create a custom KotlinJvmBinaryClass implementation here: there's no need to look up the class that is already found and passed in the argument. This is rather inefficient because it creates a lot of lists. Try something like this:\nprivate val VirtualFile.javaFiles: List<VirtualFile>\n        get() = mutableListOf<VirtualFile>().apply {\n            VfsUtilCore.processFilesRecursively(this@javaFiles) { file ->\n                if (file.fileType == JavaFileType.INSTANCE) {\n                    add(file)\n                }\n                true\n            }\n        }\n. Please fix formatting here. Since you're passing CompilerConfiguration here, there's no need to pass classPathRoots and messageCollector separately because in production code, they can be trivially obtained from the configuration (and tests can be adapted to mimic that). allJavaFiles maybe?. If the chunk contains multiple modules and -Xuse-javac has been specified, maybe we should report a warning saying that we won't in fact use javac for compilation. There's no need to put false as the configuration value if you're using getBoolean at call sites. Consider something like \"Use javac for analysis of Java source and class files\". Please rename to project. Please extract the first and the third line of this method into AbstractJavaClassFinder.initialize and call it here and in JavacBasedClassFinder.initialize. Please do not omit return types at least where inspections are reported (there's an inspection about platform type here).. Do you know if it's possible to download sources of this artifact from somewhere? This would be very useful. Multiple its in nested lambdas are dangerous and confusing, please rename at least one of them. Note that ClassId.asSingleFqName is an operation that loses some information, namely where package name in the FqName ends and where the class name starts. For example, FqName \"a.b.c\" might mean class c nested in class b in package a, or it might mean class c in package a.b.\nPlease consider either using ClassId when possible, or at least destructuring it into package FQ name and relative class name and using them, to avoid problems related to resolution of nested classes.. This is too hacky. We normally use a bunch of protected methods to inject custom behavior in abstract test class. Do I understand correctly that xxx2.txt differs from xxx.txt only in members that come from Java 8 and this is caused by the fact that the original test was run against JDK 6, but the test with javac is run against JDK 8?\nI suggest just using JDK 8 then in both tests, to avoid complicating things too much.. +1. +1. +1. Why is there @test.AByte(value = 11.toByte()), but only @test.AByte(value = 11) in the main test data, is worth investigating, I think. Loading annotation arguments with different types than what is done now might break some invariants in the compiler. Ditto (@test.AByte(value = 11.toByte()) vs @test.AByte(value = 11)). I think it would be nice to move parts of this class that use com.intellij.openapi to other compiler modules, to get rid of dependency of module javac-wrapper on openapi. This can be done in the future, I suppose.. There's no point in calling safeIdentifier on a non-null string, it's the same as simply Name.identifier. Maybe you meant to handle the case of anonymous classes? The docs say an empty string will be returned in that case.. Ditto, replace with Name.identifier. Looks like generic parameter T can de dropped here and element could just have the type TypeElement. To be honest, I prefer properties and functions with explicit return type, unless omitting it makes code substantially more readable, which is not the case here, I think (I mean not only this file, but all files added in these commits).. Please avoid using toString in this way in production code. I don't see anything in TypeMirror.toString's javadoc that would suggest that the returned string is equal to @ + annotation type's FQ name, which means that it can change between releases. I think inspecting the type directly via AnnotationMirror.getAnnotationType would be more robust. .map { (key, value) -> ... }. index == parameters.lastIndex. Please mark such declarations as internal (those that are only used from this module). Also in the other utils.kt. Name.identifier. I think you should handle the case of IntersectionType here by expanding it into multiple bounds. TypeVariable.getUpperBound's javadoc implies that this is possible here.. Annotation argument has no FQ name, a Name should be enough. I'd assume that all SymbolBased*AnnotationArguments are subclasses of SymbolBasedAnnotationArgument, but only one of them is (SymbolBasedReferenceAnnotationArgument). I suggest either inheriting all of them from SymbolBasedAnnotationArgument, or getting rid of the latter altogether. Please inspect the underlying element instead of toString.\n. Consider merging small and relevant declarations together into one file, e.g. JavaType implementations into symbolBasedTypes.kt, JavaAnnotationArgument implementations into symbolBasedAnnotationArguments.kt and so on. I think it'd be more readable in the end. Please inspect TypeMirror.getKind instead of toString. Please deduplicate this with SymbolBasedClassifier.findAnnotation, SymbolBasedValueParameter.findAnnotation, SymbolBasedType.findAnnotation. Looks like generic type parameter T is not needed here as well. This class should just inherit from SymbolBasedType<WildcardType> and typeMirror should have the type WildcardType. Instead of generic type parameter, inherit from SymbolBasedType<ArrayType>, cast typeMirror to ArrayType once at creation site. Drop generic type parameter here and inherit from SymbolBasedType<*>. t.kind.isPrimitive || t.kind == TypeKind.VOID -> .... Why doesn't it inherit from SymbolBasedElement to get equals/hashCode/toString for free?. Using instanceof on GlobalSearchScope is very risky and should be avoided at all costs. For example, if I wrap the everything-scope twice into the not-scope:\nGlobalSearchScope.notScope(GlobalSearchScope.notScope(\n    GlobalSearchScope.allScope(project)\n))\nThe resulting scope will be effectively the same, but your code won't work anymore because it would be another instance.\nAlso, relying on specific scopes being passed here (like a scope with all .java files) is risky as well, because we might reconfigure the compiler in such a way that the compiled module is split into a different set of scopes in the near future.. I'm not yet sure but looks like we'll need to abstract the scope as well, with GlobalSearchScope-based implementation in the PSI/Binary JavaElement models, and some other implementation here. (UPD: I don't expect this to be done as a part of this changeset, as I'm not completely convinced it's even in fact possible). There's no need to make it lazy (it will be accessed anyway any time JavacOptionsMapper.map is called). Please don't use expression body syntax for Unit-returning functions, it's slightly confusing (I was figuring out what does this function return). else -> null is not needed here, I think. Why? A comment would be helpful here. Name.identifier. You should return false here and in other implementations of isDeprecatedInJavaDoc. The call site looks for the annotation itself if needed. Note that there's a corner case of enums with abstract members, which are considered abstract in Java but do not require (and even prohibit) the abstract keyword. Please add a test and ensure that it works. Also please add a test on a nested enum (enum is never inner in Java). map + filterNotNull = mapNotNull. Not sure if isInterface returns true for annotations, please check and call isAnnotation if needed (a test would be nice in any case). Also test annotations in addition to interfaces here. There's also an implicit supertype java.lang.annotation.Annotation for all annotations. Please also call .associateBy { it.name } to make this a map from name to class. This will allow innerClassNames and findInnerClass to work in O(1). get() = null. Consider renaming to TreeBasedNonGenericClassifierType and TreeBasedGenericClassifierType. You can remove .filter { ... } above, and use else -> emptyList() here. Name should be enough here as well. Again, please inspect tree.getKind() instead of the string returned by toString. Please ensure there's a test on static fields in annotations. Shouldn't TreeBasedPackage contain only TreeBasedClasses, and SymbolBasedPackage -- only SymbolBasedClasses?. Similarly to SymbolBasedPackage, I think it can inherit from SymbolBasedElement and avoid overriding equals/hashCode/toString. This filter is not needed. It would be easier to pass the expression type explicitly to ReplCompileResult.CompiledClasses's constructor where it's created at GenericReplCompiler.compile with:\nval expression = psiFile.getChildOfType<KtExpression>()\ncompilerState.analyzerEngine.trace.bindingContext.getType(expression)\n(+ handle the case when there's no expression in a REPL line). I think you can obtain this type from compileResult at GenericReplEvaluator.eval and pass to ValueResult's constructor here. > File (or Path) does not support other protocols\nPath does support other protocols AFAIK. You can create a custom java.nio.file.FileSystem and resolve paths within that file system.. +1 for ResolutionResult. I think requiring JDK 8 in scripts is fine. I think we should do the following with these:\n SimpleScriptTemplate -> remove (script with args can be always used instead of it)\n kotlin.script.templates.standard.ScriptTemplateWithArgs -> rename and move to kotlin.script.templates.StandardScriptTemplate\n* kotlin.script.templates.standard.ScriptTemplateWithBindings -> move to kotlin.script.templates.ScriptTemplateWithBindings. This doesn't look like an appropriate place. If I understand correctly, it has nothing to do with scripts, so putting it into package kotlin.script.extensions is risky. As soon as we decide to publish it as a supported compiler plugin, we'll have to move it to another package and artifact, causing incompatibilities, so maybe it'd be better to do this earlier.. I think, we should not. Maybe use Collection here?. Why not String??. +1 for val diagnostics: List<ScriptDiagnostic>. I'd simplify this by assuming that the result is \"success\" iff there are no errors:\ndata class ResolutionResult(\n    val dependencies: ScriptDependencies, // ScriptDependencies.Empty in case of failure\n    val diagnostics: List<ScriptDiagnostic>\n) {\n    val isSuccess: Boolean get() = diagnostics.none { it.severity == ERROR } // maybe an extension\n}\n. I think it's fine if we don't support extra compiler arguments based on script content now. If this becomes really needed, we can support it in the future, e.g. with an annotation like you mentioned here.. Maybe move this file to package kotlin.script.annotations? To leave kotlin.script.templates for actual templates only. Also maybe rename to fileAnnotations to highlight that those are only @file: use-site-targeted annotations, but I'm not sure if that's necessary. I'm confused, why is this needed? Can't the DependenciesResolver implementation just filter out the unneeded annotations from ScriptContents.annotations?. What is javaHome: is it required to be a path to the JDK, or a path to the JRE is enough?. What's the difference between sources and scripts?. You're right, we shouldn't mark everything as unresolved in this case. But I still think we should avoid hierarchies here. For example, we can make isSuccess a boolean property\ndata class ResolutionResult(\n    val isSuccess: Boolean,\n    val dependencies: ScriptDependencies,\n    val diagnostics: List<ScriptDiagnostic>\n)\n. Users are likely to call .isEmpty on it, in which case it's still probably fully computed eagerly.\nI'm fine with either Collection or Sequence or Stream. Iterable looks weird though. > That somewhat maps to current API in a following way\nThis way is fine too but in (the most useful) case of success, you have to use dependencies!!, which is unfortunate.\n\nNot sure why we should avoid hierarchies. Can you explain your reasoning a bit?\n\nBecause the two subclasses here are not very different, and IMHO they add more complexity than value. A data class is easier to read and use than a sealed hierarchy of two nested sealed classes. Compare\nval result = resolver.resolve(...)\nif (result is DependenciesResolver.ResolutionResult.Success) {\n    ...\n}\nval result = resolver.resolve(...)\nif (result.isSuccess) {\n    ...\n}. I suggest to remove scripts and support it in the future when the requirements become clear . Noun+noun is more correct grammatically and is wider used in our project (for example, AnalysisResult, CompilationResult, DeadCodeEliminationResult, FileProcessingResult, etc.). I would prefer if this annotation was removed completely and the same mechanism as in allopen and noarg plugins was used: a configuration parameter that specifies which annotations enable the SamWithReceiver behavior. There aren't many annotations usually so the benefits of this laziness are not clear to me. I suggest to remove this and reintroduce in the future only if someone meets real performance problems.. > the (manual) construction of the script requires actual arguments array\nWhy would that be a problem?. Yes, I think once KT-19120 is implemented, users can just pass something like -Xplugin:kotlin-sam-with-receiver.jar -P plugin:sam-with-receiver:annotation= org.gradle.api.HasImplicitReceiver. Of course it is, but it isn't an argument as to whether we should keep it :) The string array is a trivial concept and we require everyone starting Kotlin programming to understand that the entrypoint is always fun main(args: Array<String>) anyway. We didn't introduce fun main() just because it's easier, there was no demand. So I hope that almost everyone will immediately understand why scripts need arguments, and if a script doesn't need arguments, it can just ignore them.. I believe it's easier for the client code to work with this text as a string, there's no real reason for the implementor to return any other char sequence except string, and CharSequences are rarely found in good APIs anyway.. Expanding on the idea proposed in https://github.com/JetBrains/kotlin/pull/1210#discussion_r129553174, another option would be to drop this class altogether and just use the compiler arguments list instead of ScriptDependencies. So, on JVM I'd pass -java-home and -classpath, on JS -- -libraries, etc.. val pluginLoadResult please. Looks fine to me. Why else?. Are there any cases when this option should be false?. Yes, I think it'd be best to always render suspend because I don't see why it would be useful not to do that. JvmAbi.isPropertyWithBackingFieldInOuterClass already checks that the containing declaration is a companion object, so DescriptorUtils.isCompanionObject here is unnecessary. I think this can be simplified a bit to\nif (!isCompanionPropBackedInOuter || propertyContainingDeclaration.getContainingDeclaration() !=\n    context.getContextDescriptor().getContainingDeclaration()) {\n    return false;\n}\n. 1) Why not just propertyContainingDeclaration != context.getContextDescriptor()?\n2) Is it necessary to check this at all? It looks like the if (!isCallInsideSameClassAsDeclared(...)) condition checked above guarantees that the property is called outside of its container. Or are there any corner cases that I'm missing?. Could you please explain how are inline classes related to this commit and why is this change necessary?. Shouldn't this be // 1 GETSTATIC?. I think this test is no longer necessary and can be safely deleted instead. his -> its. propertyDescriptor.isConst() looks unnecessary here because const properties always have default accessors. Minor: these could be named shorter, directAccessToGetter and directAccessToSetter. I'm a bit confused by this. Why is the fact that both property accessors are default so important that it defines whether or not should we generate each of those accessors? The common sense is that the getter should be generated only if the getter is non-default, and the setter should be generated only if the setter is non-default. If only one of them is non-default, then that should be generated, and the other should not.\nFor example, in this case:\nclass A {\n    companion object {\n        private var x: String = \"\"\n            get() = field\n    }\n}\nI'd expect A.Companion.getX but no setter to be generated.\nI also couldn't find any tests on this behavior, since after dropping these lines (and relying on the accessor visibility check below in this method) all codegen tests still pass.. Please remove the accessor from the .java file in this test instead of this change. Please remove the accessor from the .java file in this test instead of this change. I think this box test is unnecessary since it doesn't really check what's described here, it only checks that private properties in companion objects work, which is done elsewhere, so please delete this test. fun box() is not needed in bytecode text tests. Why have you deleted the kt-14258.kt test from your earlier commits where a lot more cases were covered? If you think that test was getting too big to understand, you can always split it into several independent tests, e.g. kt14258_1.kt, kt14258_2.kt, .... Let's remove this line since it's irrelevant to what we're testing here. What do you mean by this comment?. Let's make this a var in this test, call the setter and test that there are 2 PUTSTATICs. Let's make this a var as well. It would be more helpful to comment what instructions are executed here, I think:\nfun getMyValue(): String {\n        // INVOKESTATIC My$Companion.access$setMy$p\n        my = \"Overriden value\"\n        // GETSTATIC My.my\n        return my\n    }\n. I'd name this test file javaObjectType.kt. I'd name this test file javaObjectType.kt. I'd name this test file javaPrimitiveType.kt. I'd name this test file javaPrimitiveType.kt. Please also add a test on side effects inside the class reference expression LHS, e.g.:\nvar x = 42\nif ({ x *= 2; x }()::class.javaObjectType != Int::class.javaObjectType || x != 86) {\n    return \"Failure 10\"\n}\n\u00a0+ the same for javaPrimitiveType. You can replace this line with receiverStackValue.put(extensionReceiverType, iv) and then the first line is the same in each of the three when expressions and can be extracted and moved before the when. Please remove this println. I'd rephrase this comment to simply say something like // TODO: add new operation kind to ReifiedTypeInliner.OperationKind. Use internalName instead of getInternalName() here and elsewhere in this file; also drop the ;. == instead of equals. Can be simplified similarly to the when in KClassJavaObjectTypeProperty. There's already Type.VOID_TYPE, please use it instead. I suppose you can merge this to } else if { .... This if is unnecessary, you can call boxType even on an already boxed type. Please fix inspections and reformat this file and KClassJavaPrimitiveTypeProperty.kt. After three checks, I'd be surprised if it wasn't a IrClassReference... :) This cast and the assert above are not necessary. Similarly, this if is not needed. Instead of this, can we check the receiver expression type before applying the intrinsic and return null if it's not primitive? E.g.\nif (lhs is DoubleColonLHS.Expression && !lhs.isObjectQualifier) {\n    val receiverType = codegen.bindingContext.getType(receiverExpression) ?: return null\n    if (!KotlinBuiltIns.isPrimitiveTypeOrNullablePrimitiveType(receiverType)) return null\n}. I think it's fine to continue calling invokevirtual java/lang/Object.equals for interfaces, since it's not immediately clear that invokeinterface I.equals is better. So I propose to replace this if with:\nType owner =\n        DescriptorUtils.isInterface(propertyDescriptor.getType().getConstructor().getDeclarationDescriptor())\n        ? AsmTypes.OBJECT_TYPE\n        : asmType;\niv.invokevirtual(\n        owner.getInternalName(), \"equals\", Type.getMethodDescriptor(Type.BOOLEAN_TYPE, AsmTypes.OBJECT_TYPE), false\n);\n. Similarly to the equals case, I propose to replace this with something like\niv.invokevirtual((isInterface ? AsmTypes.OBJECT_TYPE : type).getInternalName(), \"hashCode\", \"()I\", false);\n. Does this box test check something which is not covered by current tests in codegen/box/dataClasses? If no, I propose to delete it. TBH I'd prefer this to be private lateinit var + an init method that takes type parameters as a parameter, and require everyone to call init after construction explicitly, for clarity. What do you think?. Please use c.storageManager.createLazyValue instead of lazy in compiler code to prevent possible deadlocks in case this code becomes less trivial. Would be nice to name this bindingContext or context, since we don't usually use abbreviations for identifier names in our project. As far as I see, we never iterate over this set, so it can remain a HashSet. This one can also remain a HashSet. This one can also remain a HashSet. @pakoito Please see primitiveCompanionObjects.kt (JS) and PrimitiveCompanionObjects.kt (JVM) and look for how primitive companions are substituted with these internal classes in the compiler code by grepping for example \"IntCompanionObject\" on the whole project.. This change will probably confuse the compiler and reflection of older versions when they encounter a declaration with kotlin.Boolean.Companion in the signature. The generated bytecode will be correct, but annotations (such as Deprecated, for example) will not be loaded, and reflective call will throw an exception. For more information, see the comment on this class.\nPlease revert this change and add a short comment noting that we explicitly omit Boolean here. Thanks!. @mglukhikh In fact, TypeConstructor.getSupertypes returns immediate supertypes only (as a proof, see how TypeUtils.getImmediateSupertypes and TypeUtils.getAllSupertypes are implemented).\nNevertheless, I agree that this function is not implemented optimally. In addition to the name heuristic, I'd propose to get rid of recursion here completely, and also get rid of checking if the type is a subtype of MutableMap (MutableMap is a subtype of Map anyway) and implement it like this:\nprivate fun KotlinType?.isMap(builtIns: KotlinBuiltIns): Boolean {\n    return this != null && constructor.declarationDescriptor?.name?.asString()?.endsWith(\"Map\") == true && isSubtypeOf(map)\n}\n. It's not the implementation that @mglukhikh or me have suggested. Please re-read the discussion. This code would return true on a Java class named SomethingMap which does not inherit from Map, which is incorrect. What we're looking for is classes whose names both end with \"Map\" and who inherit from Map.. @t-kameyama Why don't you just use the implementation I've suggested in my first comment in this PR? Is there anything wrong with it?\nprivate fun KotlinType?.isMap(builtIns: KotlinBuiltIns): Boolean {\n    return this != null && constructor.declarationDescriptor?.name?.asString()?.endsWith(\"Map\") == true && isSubtypeOf(map)\n}\n(note that this is copied from https://github.com/JetBrains/kotlin/pull/1753#discussion_r204414873). The reason for this behavior is that you're taking the default type of kotlin.Map (builtIns.map.defaultType). Default type of that class is Map<K, V> where K and V -- type parameters of Map. This type only makes sense inside the Map interface, as that is the only place where these type parameters can be used. Using this type for subtype checks is incorrect. Taking the example of MutableMap: MutableMap<K, V> is not a subtype of Map<K, V> because although the class MutableMap is a subclass of Map, the type arguments K and V in the left type are not the subtypes of the type arguments K and V in the right type, because they're different K and V: the ones on the left are from MutableMap and the ones on the right are from Map. Of course, they aren't compatible in any way because these are type parameters declared in different declarations, and there's no explicit relation between them. You can see how using default type makes little sense in this type of code.\nI suggest you use isSubclassOf instead, which checks that out of any types in the hierarchy of the given type, some type has the given class as the type constructor.. \ud83d\udc4d . Maybe we could skip txt generation for all these tests automatically by adding an abstract method into AbstractDiagnosticsTest and overriding it in this test, instead of adding SKIP_TXT to each file?. Thanks. There's an empty line at the beginning of each file now though \ud83d\ude00. Please make sure that the inspection is not suggested when using the function expression syntax:\nfoo(fun(it: String?): Int {\n    if (it != null) return@foo 1\n    return 0\n})\n. Because this is valid code, unlike in the issue fixed in this pull request. Consider using safe call here: myCaches?.clear(). Can we extract this to a separate file? (Would be nice to avoid making this ExpressionCodegen as enormous as the one in the old backend :) ). Is it possible to somehow use operations in OperationsMapGenerated.kt instead of manually enumerating them here? That would also make it future-proof in case we add more built-in operations in the future (like we did with rem in 1.1 for example). It would be awesome to extract names used here into constants in IrBuiltIns and use them where the corresponding operators are created, to be able to quickly see that both refer to the same concept. I'd somewhat prefer if the public API would be something like this:\nval switch = SwitchGenerator(expression, data, this).generate()\nif (switch != null) return switch\nIn this case, you wouldn't need mutable fields in SwitchGenerator to retain information between match and gen; the logic in match could be inlined into gen with local variables holding things like thenExpressions and elseExpression. Please consider rewriting this to avoid modification of mutable fields, as it isn't very easy to debug code operating with mutable state. For example, instead of modifying subject and cases along the way of computing whether this is an optimizable when-condition, consider making matchConditions return a nullable list of case + subject, where null would mean that this is not an optimizable when-condition. Something like this:\n```\nprivate data class ConditionInfo(val case: Pair, val subject: IrGetValue)\n...\nprivate fun matchConditions(condition: IrExpression, thenLabel: Label): List? { ... }\n```\nAt the call site, we can then return if any matchConditions returned null, ensure that all subjects of these conditions are the same, and flatten the results to pass to gen. An example advantage here is that if I'm debugging this code I can easily go backwards and forwards, re-evaluate matchConditions on anything I like without side effects, etc.. Please move the comment to the assertion message and add context-specific info, e.g. something like\nassert(condition.type.isBoolean() { \"WHEN_COMMA should always be a Boolean: ${condition.dump()}\" }\n(We try to avoid asserts without messages in our project as much as is reasonable.). Thanks!. Please move to JvmLoweredDeclarationOrigin. According to our license, all code in this repository is copyright by JetBrains. Therefore we need our default copyright on all sources. Is there any particular reason why you've changed this to Google LLC?. Please use reflectionClass.functions here and below, and remove casts in buildReflectedContainerReference. listOfNotNull(...).size here and below (will get rid of the IDE inspection about it). reflectionClass.functions -> no as IrFunction needed. I think we should avoid doing complicated logic like this in the compiler backend. It's the frontend's job to resolve everything down to the specific types that the backend should use in code generation, including whether to use KMutableProperty or KProperty as a property reference superclass.\nCurrently the frontend already infers this information in DoubleColonExpressionResolver.createKCallableTypeForReference and stores it into BindingContext.VARIABLE binding context slice (at DoubleColonExpressionResolver.bindPropertyReference). It seems that psi2ir loses this information when transforming KtCallableReferenceExpression to IrCallableReference in ReflectionReferencesGenerator.generateCallableReference. Could you please look into obtaining that information there and changing the created IrPropertyReference to have no setter if it's not visible? I.e. get the \"synthetic\" local variable via getOrFail(BindingContext.VARIABLE, ktCallableReference) and only generate a setter in the property reference if that variable is mutable.. Do you mean Class()::field in the comment?. There's a typo in the string... :) REFERECE -> REFERENCE. I think it should be fine. That local variable is only needed for backends anyway, so I hope no other code relies on it being a val right now.. Why isn't it enough to encode names as strings with Name.guessByFirstCharacter as a way to distinguish special names from identifiers?. IMHO an if was simpler (in the original version) but it's minor. Please add expression.dump() to the message. Please replace it.name == Name.identifier(\"xxx\") with it.name.asString() == \"xxx\". I suppose we could use getOrFail here. I think this value is actually already computed by the compiler frontend and you can get it via (codegen.getCompileTimeConstant(resolvedCall.getReceiverExpression()) as? StringValue)?.value. To obtain the codegen instance, intrinsics can override the other toCallable method (with 4 parameters). You can also use the fact that null is returned if the string is not constant to get rid of checks on interpolation.\nUPD: as a bonus, it seems that it might fix the TODOs in tests. AsmTypes.JAVA_STRING_TYPE. We've discussed internally the idea to apply the intrinsic unconditionally and figured that it might lead to compatibility problems in case we decide to change the behavior of trimMargin/trimIndent on some corner case in a future release. It seems that these kinds of problems will only arise if the compiler of version X is compiling code against standard library of version Y where Y > X: the user expects behavior of version Y at runtime, but will actually observe behavior of version X because that's what was executed in the compiler at compilation time.\nTherefore we'd like to restrict these intrinsics to be applicable only if the version of the standard library in dependencies is not greater than the version of the compiler itself. This can be achieved by checking if the API version (can be obtained via languageVersionSettings.apiVersion at the call site) is <= than the version of the standard library in the runtime of the compiler (can be obtained via KotlinVersion.CURRENT). (Sorry if this sounds confusing, I can do it myself if it's unclear, just wanted to notify you that we'd like it to work that way -- maybe you have some other related concerns.). Oh, you're right. I think both these functions can now be inlined. ",
    "kouphax": "Indeed you can.  However I feel that this approach offers slightly better syntax when chaining method calls.  Plus if I'm being honest getOrElse looks a bit neater (though I accept that is entirely down to personal taste) :)\n. Though I do see now that my second \"lambda style\" method isn't in fact necessary.\nEDIT\nCome to think of it if you want to execute more than a single line the lambda syntax would avoid the overhead of having to create a method each time.\n. Inclined to agree with this sentiment.  It's not a necessary core feature.  Closing this now.\n. ",
    "tomhal": "I feel this is not a needed feature. There's already an idiomatic way to doing this in Kotlin(the way you use when implementing your \"shell\" around it).\n. I saw that there was test cases already for checking things such as that the expression isn't evaluated more than once. \nFor the moment I can't think of any other tests needed.\n. You are right Pavel. I missed that. I think I'll add so ensureNotNull() checks against both null and undefined.\nPlus, there should be a unit test to test this. Hmm, it is possible to create a value of undefined in Kotlin?\nI'll update with these fixes.\n. Btw, Pavel, which one of null and undefined do you think is more common? :)\n. The goal was to have a unit test to test that ensureNotNull also tested for undefined, but I didn't manage to find a way to get undefined in Kotlin and there didn't seem to exist any tests in Javascript for the Javascript std library.\n. Ok, thanks for the comment. I'm new to git and github. I'll read up about how to edit my commit messages.\n. Yes, please merge them for me. I'm a git newbie. :) I'll read up on the link.\n. Also, I read the jslib and found that both StringBuilder and IllegalArgumentException seem to have JS counterparts, so I guess everything is done.\n. Thank you! Don't forget to close the issue linked.\n. This patch fixes: http://youtrack.jetbrains.com/issue/KT-2976\n. All js-backend tests passd both before and after the change.\n. If you don't want this code, just say so. :-(\n. I wanted the code to be runtime independent and couldn't find a non-JVM StringBuilder. Sorry for the semi :)\n. Would require(n >= 0) do instead of a manual if + throw?\n. ",
    "djcsdy": "Pull requests are linked to a branch in your fork. You need to create a separate branch for each separate pull request.\n. ",
    "pechlambda": "In the delegation feature ticket's subtasks I can see only this one become fixed now\n. Are there any comments on the pull request? Thank you\n. Please, take a look at another pull-request\n. Any comments, please?\n. Please, take a look at next attempt here - https://github.com/JetBrains/kotlin/pull/160\n. It was, actually, my own change, from the Java interface delegation patch. I've sent both these requests simultaneously, so I couldn't rely on one's code in another, sorry. I always try to merge latest changes locally before sending the pull request. \n. ",
    "yole": "Thanks Peter!\n. Updated to modern Kotlin, fixed a bunch of issues and resubmitted as https://github.com/JetBrains/kotlin/pull/713\n. This pull request is from my fork, so it's not going to be picked up by TeamCity. That's why I closed it.\n. We decided to change the platform API used here, so I'll resubmit a new pull request based on a different API.\n. Merged manually.\n. Merged manually.\n. merged manually\n. merged manually\n. This doesn't really matter because the bare compiler plugin isn't distributed outside of the company, but I've updated it anyway.\n. Squashed.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Thanks for the tip! I've added such a test, and indeed it fails without the\nfix and passes with it.\nOn Fri, Feb 27, 2015 at 8:19 PM, Alexander Udalov notifications@github.com\nwrote:\n\nMaybe add a test when superclass' generic parameter is substituted in the\nsubclass? I believe that is the case when f.getOriginal() != f and kdoc is\nnot showed on the function in the subclass as far as I can see\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/578#issuecomment-76454471.\n. Merged manually.\n. We plan to offer wrappers around Clojure's persistent structures, which are a much more mature and complete implementation than this one.\n. Merged manually.\n. Merged manually.\n. Merged manually\n. Fixed and rebased\n. Merged manually.\n. Merged manually.\n. I will merge this only when I get a successful remote run.\n\nOn Tue, Mar 10, 2015 at 5:30 PM, Andrey Breslav notifications@github.com\nwrote:\n\nMy guess is that a number of tests is broken by these changes (test data\ncontains serialized descriptors from built-ins)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/593#issuecomment-78091361.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Pushed another commit to fix the path.\n. Merged manually.\n. Done.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Added this testcase, fixed the problem in a different way.\n. Merged manually.\n. Fixed issues and merged manually.\n. Merged manually.\n. Merged manually.\n. Fixed backend-side issues; filed https://youtrack.jetbrains.com/issue/KT-7203 for remaining frontend work\n. Added frontend diagnostics as well (\"accidental overrides\" still don't work, need to discuss how to implement that)\n. Merged manually.\n. @VladimirReshetnikov such classes cannot be correctly represented in Java, because the JVM does not support this kind of specialization\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Done\n\nOn Mon, Apr 27, 2015 at 2:51 PM, asedunov notifications@github.com wrote:\n\nIt's probably worth converting isOverrideHierarchyElement() function to\nextension\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/650#issuecomment-96638874.\n. Merged manually.\n. merged manually\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. The main purpose of using the properties bundle file is localization. We see no benefit in localizing the Kotlin plugin, especially given that IntelliJ IDEA itself is not going to be localized in the near future, so we're gradually removing the uses of the properties bundle in the plugin code and inlining the strings directly.\n. Merged manually.\n. Merged manually.\n. Reviewed by @svtk and merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually (and applied 'invert if').\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. @asedunov: please take another look\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. I think that we'll simply drop this flag before release, so the users of the final version won't see it anyway.\n. Merged manually.\n. Added an implementation of checkConfiguration() to JetRunConfiguration.\n. Added alignment.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Rejected during code review.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Thanks for the fix!\n. Merged manually.\n. Merged manually.\n. Merged manually.\n. Thanks for your fix! I've submitted a different pull request which changes this paragraph to up-to-date information: https://github.com/JetBrains/kotlin/pull/759\n. merged manually\n. merged  manually\n. Merged manually.\n. LGTM\n. Could you please send a new pull request from a branch containing only this commit, and not from master? I'll merge it then.\n. Merged manually.\n. Merged manually.\n. Thanks for your contribution!\n. Merged manually.\n. Thanks!\n. Feel free to merge.\n. Merged. Thanks! Sorry that it took so long; to make this faster, consider joining #kontributors in the Kotlin Slack\n. Merged. Thanks!\n. We can't accept this pull request because the Kotlin stdlib needs to be compilable against Java 6, which doesn't have AutoCloseable. We do plan to support stdlib multitargeting in future versions of Kotlin, which will allow us to address this problem propertly. See https://youtrack.jetbrains.com/issue/KT-5899 for the issue tracking this.\n. Thanks for the contribution! I've left a few comments (mostly stylistic); please correct the issues and I'll merge this.\n. Thanks again! Merged.\n. I don't think that't the right fix for the issue. Silently returning incorrect data is not the way index updates are supposed to be handled.\n. The correct fix for the project view exception is to mark IDEA ClassesTreeStructureProvider as non-DumbAware.\n. These links are not dead. The file is interpreted by Dokka, and the links are the way they need to be for Dokka-generated documentation to work correctly.\n. - Since docs are inherited in Kotlin, you should not report an overridden public method if the base class method has documentation.\n- If an element was protected and is now public, it needs documentation.\n- The \"public\" keyword is highlighted as redundant in Kotlin, so you definitely should report problems where the visibility is implicitly public.\n. Thanks for your contribution! I've squashed the commits in this PR, disabled the inspection by default and merged the changes.\n. Thanks a lot for your contribution!\n. Thanks a lot for your contribution!\n. Thanks for your contributioN!\n. Looks good now. Thanks a lot for your contribution!\n. The names of these functions conflict with the standard Java live template macro function names. You need to add the \"kotlin\" prefix to the names to ensure they don't conflict.\n. Yes, the names still need to be distinct to ensure the templates are parsed correctly.\n. A test would be nice.\n. Rewritten and merged manually.\n. It turns out that there's no really good way to test a live template macro in the IntelliJ Platform, so I pushed the change without tests.\n. Looks good other than a couple of small issues.\n. Merged manually. Thanks a lot for your contribution!\n. March 7th is not the release date for Kotlin 1.0.2, nor any other version of Kotlin.\n. There are more than enough places that can be used to keep track of the history of Kotlin, including the blog, Twitter and the release notes on GitHub. The changelog file is an internal document that will be used to prepare the official release notes on GitHub, and is not intended as a primary source of information for external users.\n. Merged manually. Thanks!\n. Merged manually. Thanks a lot!\n. I don't think that adding the operator modifier automatically is a good idea at this time. I think that in Kotlin 1.0 we can rely on the fact that functions intended to be used with the 'in' operator already have the modifier, and simply disable the quickfix if the modifier is not present.\n. Thanks for your contribution!\n. Thanks for your contribution!\n. Thanks for your contribution!\n. Thanks for your contribution!\n. Thanks for your contribution!\n. Merged manually. Thanks for your contribution!\n. Thanks for your contribution!\n. Thanks for your contribution!\n. Merged manually.\n. Thanks for your contribution!\n. Thanks for your contribution!\n. Thanks for your contribution!\n. Thanks for your contribution!\n. Please don't remove the 'public' modifier from the standard library methods; it is left there intentionally.\n. Looks good except for the minor style issue.\n. Thanks for your contribution!\n. Looks good except for the noted issues.\n. Thanks for your contribution!\n. Thanks for your contribution!\n. The tests for this feature are here. Please do add the tests for the changes you're making.\n. Right now the selectioner handles every variable type: for example, if you have fun foo(bar: Bar), it will select : Bar. I don't see why this is useful for parameters or local variables. This should work only for supertypes of a class and the return type of a function.\n\nAnd once again sorry that the review takes so long; I've been busy with other things :(\n. Thanks a lot for your contribution!\n. - Please provide tests for the feature you're adding. See here and here for existing auto import tests.\n- Please avoid copy/pasting existing implementation classes. If you need to reuse code from them, please refactor them so that there is no duplication.\n. Thanks for your contribution!\n. What are you trying to achieve with this pull request? There is nothing wrong about the position of the dots in the original document, and no visible difference in rendering between the original and the new version.\n. Thanks a lot for your contribution!\n. Thanks for your contribution!\n. Reviewed the code so far, please see comments.\n. The pull request introduces an unfortunate regression: all Kotlin methods are shown twice in the Goto Symbol dialog (one version coming from KotlinGotoSymbolContributor and another from the new KotlinShortNameCache implementation). For methods that have a custom @JvmName this is actually fine: it's useful to show them with both their Java and Kotlin name. For those that don't, this should be fixed.\n. This causes some test failures: https://teamcity.jetbrains.com/viewLog.html?buildId=868124&buildTypeId=bt345\nThe failures actually point to at least one clear problem: KotlinIndicesHelper.processJavaStaticMembers is intended to return only non-Kotlin members, and with this change it will look at Kotlin members too. One possible fix is to exclude Kotlin files from the search scope that it uses to look for elements.\n. Merged manually. Thanks for your contribution!\n. Thanks for your contribution!\n. You're getting the error because the PSI structure that you get when you replace a call expression with its argument is different from the PSI structure that Kotlin builds for this text. You need to fix this. Please use the Tools | View PSI Structure... menu item in the debug IDEA (the one started when you run the \"IDEA\" run configuration in the Kotlin project) to see the differences between the two.\n. Thanks for your contribution!\n. Thanks for your contribution!\n. Looks good except for some minor notes regarding correct API usage. Please fix, and I'll merge and backport to 1.0.5. Thanks!\n. Thanks for your contribution!\n. Merged into master and 1.0.5. Thanks for your contribution!\n. I think it's a bug in the validator; there is no other reason\n. Thanks for your contribution!\n. The current rules for checking the 'in' operator are implemented intentionally, and also intentionally suppressed for CharSequence.contains. Instead of changing the language rules, you should change the logic in ReplaceContainsIntention.kt:51 so that the intention is always enabled when the target function is an operator.\n. Sorry for the delay. I've merged your changes and added some extra logic that allowed to preserve the withoutOperatorModifier test (we now make a distinction between Java and Kotlin methods).\nThanks for your contribution!\n. Merged manually into branch for 2016.3.\n. If you're converting an existing Java file to Kotlin, please do it as a sequence of the following commits:\n- Rename the file from .java to .kt and commit without any changes (this ensures the history is preserved)\n- Rename the file back, run J2K and make the minimum number of changes required for the code to compile.\n- Clean up the code to convert it into idiomatic Kotlin.\nAfter that, make the changes that you need to fix the issue as a separate commit. Right now I can't review your changes because I don't see what you changed compared to the original Java code. Also it's not OK that you left the old Java class around.\n. Yes, let's try to apply this to the other statements as well.\n. Thanks!\n. Thanks a lot for your contribution!\n. Merged manually into branch for 2016.3.\n. Thanks for your contribution!\n. And one more thing: this will break usages from Java because with a val they can refer to the property name directly, and with an object they require the .INSTANCE qualifier.\n. After the rename is complete, you can search for usages of the new declaration in Java files and update them as needed.\n. Thanks a lot for your contribution!. Thanks for your contribution!. The intended formatting for this code is to wrap before the colon, not after it.\n. Sure, just pointing out that the formatting is not optimal in any case\n. Pushed a sligthly different fix (compatible with IJ 2016.2) in 38a448ebbdfe2d39e452ca83c25db7b46ff7e669\n. Given your last comment in https://youtrack.jetbrains.com/issue/KT-14654, I assume you won't be needing this extra flexibiity any more.\n. |libraries/stdlib/src/kotlin/collections/Grouping.kt:35|\n|---|\nTrue. I don't have any better suggestion to improve this, so let's keep it as is.. |libraries/stdlib/src/kotlin/collections/Grouping.kt:47|\n|---|\nYou're using inconsistent wording - \"aggregates with\" or \"accumulates with\" - and neither of those is a standard usage of the corresponding verbs with the preposition. I think you need to provide a more detailed explanation of what happens here - something like applies [operation] to the elements of each group sequentially, passing the previously accumulated value and the current element as arguments, and stores the results in the given [destination] map\". This applies to other functions as well.. |libraries/stdlib/src/kotlin/collections/Grouping.kt:213|\n|---|\ncount of element_s_. |libraries/stdlib/src/kotlin/collections/Grouping.kt:219|\n|---|\nWhy the space after the open parenthesis?. |libraries/stdlib/src/kotlin/collections/Grouping.kt:240|\n|---|\nWhy is this function called eachSumOf and not eachSumBy, which would be consistent with Iterable.sumBy?. Thanks!. Merged manually. Thanks a lot for your contribution!. Thanks a lot for your contribution!. The Kotlin repository contains no code with Lightbend copyright. The scripts were copied in 2011, before Lightbend existed, so the appropriate Scala license to include is the older one. I've added it in af1ed78e171065cc4faa46c22cfe0ceaef517f62. And thanks for bringing this issue to our attention!. Thanks a lot for your contribution!. Thanks for your contribution!. I've started a branch based on your work and made some additional changes (still work in progress):\nhttps://github.com/JetBrains/kotlin/tree/rr/yole/filtermay-inlays\nYou're welcome to send feedback regarding these changes. And thanks a lot for your contribution! The core implementation is very good; I'm mostly adding new logic rather than rewriting your code.. Merged to master manually.. Thanks!. Thanks!. Thanks!. Thanks!. Thanks for your contribution!. Thanks!. Thanks again!. Thanks!. Thanks a lot for your contribution!. Thanks for your contribution!. This was in fact merged a while ago; forgot to close the pull request.. How exactly does the build fail for you? I have paths without slashes in my environment configuration and everything works correctly.. Merged manually. Thanks a lot for your contribution!. Merged manually. Thanks for your contribution!. The fix is good; the test modification you did is fine.. Fixed one additional test and merged manually. Thanks for your contribution!. Merged manually. Thanks a lot for your contribution!. Merged manually. Thanks a lot for your contribution!. Merged manually. Thanks a lot for your contribution!. Merged manually. Thanks a lot for your contribution!. Thanks!. While this is a good change and I'll accept it, this is not what the original issue was about. The original issue asks to change the behavior of Edit | Extend Selection so that it includes an extra step for the declaration with comment. See https://github.com/JetBrains/kotlin/blob/master/idea/src/org/jetbrains/kotlin/idea/editor/wordSelection/KotlinDeclarationSelectioner.kt for related code.. Thanks a lot for your contribution!. Please provide a test for this change.. I didn't just reject the issue; I also left a comment telling you where to ask for help in getting the tests running.. I've pushed https://github.com/JetBrains/kotlin/commit/0e2bdb8e6646667c12d0afc46485d4f2bb8ada45 which restores tests for this inspection and incorporates your fix for the bug. Thanks a lot for your contribution!. Please provide tests for this change. See here for an example of a test that verifies that an intention is not available.. Merged manually. Thanks a lot for your contribution! Please take a look at the additional commit: https://github.com/JetBrains/kotlin/commit/a6d80b78de012dfe569b55557c4d56383da44673. Merged manually. Thanks a lot for your contribution!. I actually just commited a set of changes implementing the same options - I needed an implementation of those for my work on the Kotlin style guide. Sorry about the duplicate work you've had to do!. I think it's better to fix the logic so that type parameters can be checked correctly, and not to suppress the check. . Thanks!. This intention should not be offered when the receiver is a var, otherwise there will be an overload resolution ambiguity after you change to += (see https://youtrack.jetbrains.com/issue/KT-5488).\nfun foo() {\n    var f = mutableListOf(1)\n    f.addAll(listOf(2))\n}. Thanks!. There's already RemoveExplicitTypeIntention which provides the same action as your intention on the fun bar(): Unit = println(\"ok\") example. We should avoid showing such duplicated actions. Also, you don't need to reimplement the logic for deleting the type specification; simply .setTypeReference(null) should work.. Now the inspection highlights any return type of a function with an expression body as redundant, even if it is not Unit:\nfun shazam(): Int = 1. Thanks!. We've already committed the same change internally (https://github.com/JetBrains/kotlin/commit/2e823a4816c13076efc89c96c567d666acd9203b). Thanks anyway!. Thanks!. Thanks!. Please don't forget to rerun affected tests when you make a change; this change breaks the quickfix tests for this inspection. (I've fixed them.)_. Just wanted to note that non-infix calls are still not handled. Please add support for them, and I'll merge.. Already fixed in https://github.com/JetBrains/kotlin/commit/1ed1751b63dec3ef78bc9e1f69059e95c12648c0, sorry.. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks!. Those links work only for people who already have an account in Slack, and give no clue how to create an account to those who don't. The correct place to link to is http://slack.kotlinlang.org/. Thanks a lot for your contribution!. Basically same comments as for https://github.com/JetBrains/kotlin/pull/1206. OK, I'll fix those myself.. Merged manually. Thanks a lot for your contribution!. Not sure why you think the getter and setter checks are needed. I want the quickfix to appear in the most basic case:\nclass Foo {\n    lateinit var s = \"\"\n}\nThe quickfix should add an explicit property type and remove the initializer.. Merged manually. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks! This is indeed helpful.. Thanks!. Thanks a lot for your contribution!. We're in the process of migrating the build of Kotlin to gradle-kotlin-dsl.. Merged manually. Thanks a lot for your contribution!. Thanks for your contribution!. @piotrek1543 Could you please stop marking Kotlin pull requests as approved by you? GitHub doesn't make it obvious whether an approval comes from a contributor to the project, and your approvals may confuse the authors of pull requests and lead them to think that their changes have been approved by the Kotlin team, which is not the case.. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Merged manually. Thanks a lot for your contribution!. Merged manually (with some minor wording changes). Thanks a lot for your contribution!. I'm not sure this is actually a good idea. There is no rule or code style requirement saying that enum constants should be always imported, and it's not true that importing them always makes code more readable. I'd rather fix the original issue by providing a separate, explicit action to replace all qualified references to members of a certain class in a file with imports.. Thanks!. Merged manually. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. This pull request doesn't make any sense. If you want to request a feature added to the Kotlin standard library, please file a YouTrack issue.. Thanks a lot for your contribution!. Thanks a lot for your contribution, and sorry for the delay with the review!. Thanks a lot for your contribution!. Thanks!. Thanks!. Thanks!. This is already reflected in https://github.com/JetBrains/kotlin/blob/master/license/LICENSE.txt; no need to introduce another copy.. Sorry, but I don't think this is really appropriate. Kotlin has been covered in many different podcasts, articles and other places, and I don't think this podcast is so exceptional that it deserves to be the only one featured in the Kotlin README.\nWe'll tweet about this episode from the @kotlin account, and you're also welcome to submit a PR to https://kotlin.link/ with a link to the episode.. This README is entirely out of date. Libraries are now built with Gradle and not Maven; there's no need to build the compiler separately, because libraries are part of the main project now. I've filed https://youtrack.jetbrains.com/issue/KT-20995 to update the README.. Merged manually. Thanks a lot for your contribution!. @piotrek1543 I understand your good intentions, but really this isn't helpful. @bulenkov is a JetBrains engineer. The Kotlin project does not have any policy on pull request titles and does not use them in any part of the process.. Merged manually. Thanks a lot for your contribution!. Thanks!. Thanks a lot for your contribution!. Thanks!. Merged manually. Thanks a lot for your contribution!. Merged manually. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks a lot for your contribution!. You can also remove the unused import.. This is actually an incomplete fix: it fixes the highlighting but not other features (target validation, navigation etc.). It would be much better to fix parsing so that KDocTokens.MARKDOWN_INLINE_LINK is also parsed into a KDocLink, and to fix the KDocLink implementation so that it handles links with alternative text too.. Also please add a reference to https://youtrack.jetbrains.com/issue/KT-2582 to the commit description.. Looks good, but one issue is still not addressed: \"This is inconsistent with how backspace works for regular string literals. With a normal string literal, if the caret is between the quotes, both quotes are deleted, and if it is after the quotes, only the trailing quote is deleted. Similarly, this handler should delete the quotes only if the caret is between the two triple quotes.\". I may miss something but I don't see any code in KotlinRawStringBackspaceHandler which checks the caret offset.. The parentOfType method is missing from the pull request as it's currently submitted; the code doesn't compile.. The issue is still not addressed, and it can't be addressed using parentOfType(), you actually need to check the caret offset. To make it clear what issue I'm talking about, I've recorded a screencast:\nhttps://www.screencast.com/t/iFrnhG0fM\nThe triple quotes should be deleted only when the caret is in the first location shown (between the two triple quotes), not when it is moved backwards.\nAlso while testing this I noticed that insertion of paired triple quotes does not work at the very end of the file.\nIf you'd like to, I can fix the remaining issues myself.. I'd rather fix the issue by adding code to remove the JAVA_TOOL_OPTIONS line in KotlinIntegrationTestBase.normalizeOutput().\n@vak280974 Please refrain from reviewing pull requests on this project; your reviews do not add any information and only confuse contributors.. Thanks a lot for your contribution!. Thanks a lot for your contribution!. Thanks!. Thanks!. Merged manually. Done\n. done\n. done\n. done\n. done\n. done\n. done\n. done\n. done\n. Probably not, but I'd rather stay focused on documentation in this PR.\n. done\n. done\n. There is nothing in the language docs about Nothing. Reworded the text a bit.\n. done (reworded slightly differently)\n. done\n. done\n. The methods are different for each type; there's no good way to link.\n. done\n. done\n. done\n. done\n. done\n. done\n. done\n. We do. \"which first characters does it return? the first characters that satisfy\"\n. done\n. Not sure. Non-ASCII characters may not be appropriate in all environments.\n. I'm not sure that it's worth documenting. The code is simple and the overhead is small, and if the user cares about such low-level details, they'll know not to use the class.\n. done\n. done\n. done\n. done\n. done\n. done\n. done\n. done\n. done\n. done\n. done\n. done\n. I think the current wording is clearer.\n. done\n. done\n. Fixed. Monitor is the correct term.\n. Why not rename the function then?\n. done\n. Indeed, this is completely unnecessary. Removed.\n. done\n. done\n. done\n. Any specific wording you'd like to suggest?\n. done\n. done\n. Made an attempt. This is in any case not a suitable place for explaining the Java memory model in detail.\n. done\n. That's not allowed by the frontend: \"Incompatible types: kotlin.Int? and kotlin.Unit (3,31)\"\n. No, and this is intentional (doesn't make sense).\n. fixed\n. Do you have any specific case that needs to be checked? Otherwise I'd rather trust the completeness of our test suite and commit the change.\n. @udalov done; please take another look\n. @udalov Will do, thanks\n. This file is autogenerated. As for the reason of the change, 'interface' is\na reserved word in ES6, and now it's also a keyword in Kotlin (previously\nit wasn't).\nOn Mon, Apr 27, 2015 at 12:32 PM, Andrey Breslav notifications@github.com\nwrote:\n\nIn js/js.translator/testData/reservedWords/cases/SHOULD_BE_ESCAPED.txt\nhttps://github.com/JetBrains/kotlin/pull/652#discussion_r29135991:\n\n@@ -8,6 +8,7 @@ false\n for\n if\n in\n+interface\n\nWhy?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/652/files#r29135991.\n. Yes. JetRunConfiguration already implements CommonJavaRunConfigurationParameters and exposes those values through that API to the shared code in IDEA.\n. This is the dialog title, not the name of the action in the menu. The dialog titles for Java and Groovy do have \"New\" in them.\n. typo: stdoutThread\n. Would be simpler to use an AtomicBoolean here. Or better yet, a semaphore, in which case you won't need a wait loop.\n. mapValues()\n. I think that such dangling ?: are fairly hard to understand.\n. : RemoteOutputStream by out\n. Do we really need all those throws annotations?\n. I think you can get more accurate information using the MemoryMXBean class.\n. perms.any { it.implies(p) }\n. why var?\n. Fixed\n. Fixed\n. You should reuse the BindingContext from the first analyze() call.\n. The quickfix will do nothing if there is no editor. It's possible to perform the change through the PSI, and it's better to do it that way.\n. I think the code will be cleaner if you merge the two loops into one.\n. You also need to check for nested lambdas/functions/classes - the continue statements inside them must be left alone.\n. OK, agreed regarding the two loops. As for the second comment, intentions are not always invoked on green code, and it's usually best to avoid breaking it even further.\n. This seems to be an accidental change, please revert\n. No period here please\n. I'd add a test for more than one argument, and/or for type with type parameters\n. I think that all intentions that modify the declaration of a function need to be available on the function name. Showing this only on the parameter list is confusing\n. If a constructor has one parameter with a default value, adding @JvmOverloads won't modify the resulting bytecode in any way, so the intention shouldn't be displayed.\n. I think this is far too specific to live in a general PSI utlilities class; I'd move it into the quickfix file.\n. The name of this function doesn't describe what it does. A more descriptive name would be \"findContainingClassConstructorParameterWithName\" (which is long enough to hint that it may be better to split the logic: a function to generate a sequence of outer classes for a class and a single-line call to find the parameter of the class by name).\n. You can still make it public and reference it from that other quickfix.\n. In the case when we're updating an outer class, it'd be better to show the name of that class in the inspection text.\n. Simply nonStaticOuterClasses()\n. This is not exactly the check that I meant. Specifically for the primary constructor, Kotlin will generate a no-argument overload when all arguments have default values, even if the @JvmOverloads annotation is not present. This doesn't happen for regular functions.\n. You can add WITH_RUNTIME directive so that the run function will be resolved correctly.\n. = getText()\n. This is not clear. A better description would be \"Use of Java API that has a Kotlin equivalent\" or something like that.\n. This should be a WEAK_WARNING at most. There's nothing wrong with the original code - it's simply not as concise as it could be.\n. This is not good enough. You need to resolve the call to make sure that it points to the correct method, and not to a method of a different class that also happens to be called Collections.\n. LIKE_UNUSED_SYMBOL highlighting is applied to code fragments that can be removed entirely. In this case, the quick fix is not removing the code, but is replacing it with different code.\n. This check isn't necessary: a statement where return is not enclosed in braces is no less trivial.\n. expression.statements.singleOrNull() as? KtReturnExpression ?: return null\n. I find it somewhat confusing that the KtNodeTypes.BOOLEAN_CONSTANT check is separate from the value check. It would be clearer to add the corresponding isFalseConstant() method to KtPsiUtil and to remove the node type check from getReturnedExpression().\n. You need to handle the case when the expression passed to this method is itself a PsiReturnExpression: if (foo) return true else return false\n. This is no more clear than the same text in the inspection description, and also needs to be changed.\n. The calleeExpression is not always a KtSimpleNameExpression, so you should use a safe cast here.\n. Once again \"unnecessary java usage\".\n. This boolean value is quite unclear. Much better to use an enum instead.\n. Better to unpack the pair and to use separate arguments for the text and conversion mode.\n. This is really minor, but still: to make the code easier to follow, I'd move this line next to the rule for the AS keyword.\n. I'd rather use element.text.trimEnd('l', 'L')\n. This line doesn't do anything\n. This doesn't seem to be needed, either\n. Please do not use the text or regular expressions to perform the action. All the necessary information is available in the PSI; please do use it.\n. As I said, please use the PSI. Go up the tree to find a KtCallableDeclaration and use its getColon method to locate the colon. This will ensure that the action will work only where needed (and will not work in parameter type declarations, where it's not needed).\n. Those parameters are actually non-null. You don't need the null checks here and in the other selectioner.\n. You can use the PsiElement.getParentOfType() extension function to do this with less code.\n. There is no need to create a new object here; it's OK to hard-code the token texts.\n. Please make sure that the line has at most one leading and at most one trailing space after you've remove the prefix and suffix\n. You can avoid multiple replace calls if you use asSequence().map { it.replace(...) }.firstOrNull { it.isNotBlank }\n. It's better to add surrounding spaces in getLanguagePlaceholderText(), not in this function. (This applies also to getFirstLineOfComment().)\n. Yes, you're right that the current solution produces somewhat cleaner results.\n. You can simplify this code by changing the return type to Sequence<PsiClass> and using generateSequence()\n. This implementation defeats the purpose of this method. You should calculate the candidates lazily and stop evaluating if you've found more than maxCount candidates.\n. This will be extremely slow. It's OK to return names for which getMethodsByName() will then not find any methods, but it's not OK to look up every single method in the index. You should only use getAllKeys() and then calculate possible accessor names from those, without any lookups to the property index.\n. Same here. No property index lookups please.\n. It's a minor issue, but the correct way is to use field.getResolveScope() instead of allScope here. Otherwise you may get incorrect results if the project uses multiple JDKs in different modules.\n. And also JavaPsiFacade.findClass() instead of PsiType.geTypeByName(). And CommonClassNames.JAVA_IO_SERIALIZABLE instead of a hard-coded constant.\n. Please try to ensure that testdata files are valid Java code. This file does not compile ('status' is undefined, the types do not match, etc.)\n. You need to include the generated test class into your commit.\n. You are accessing cases[i+1] without checking that i+1 is a valid index in the cases collection.\n. Please add a test for the case when 'default' is in the middle of the list of other cases (case \"error\": default: case \"busy:\") and make sure that this test passes.\n. You don't need a main method but you need a file that can be highlighted without errors in the editor.\n. Yes\n. This accesses the property index even if it's not actually necessary (if the sequence enumeration stops before we reach the property names). Would be nice to use something like sequenceOfLazyValues().flatMap to avoid this.\n. You can avoid repeated iteration of the sequence if you use take(maxCount+1) and check if you actually got N+1 elements.\n. Please remove this comment\n. You can use SearchUtil.excludeKotlinSources\n. Nevermind, made the change myself.\n. Why are you checking for PsiField specifically? Won't the same problem happen if the anonymous class is used as a local variable initializer?\n. x.let { it != null && ... } is much better expressed as x?.let { ... }\n. Please avoid irrelevant syntax errors in testdata. Java does require semicolons :)\n. This doesn't seem to be a correct check. This is valid Kotlin:\n\nkotlin\nval foo: Int = 0\n    external get\n. This will break the use of the intention with Java methods, which don't use an explicit operator modifier but still can be used as operators. The correct fix is to replace || with && in the original check.\n. reports and offers to remove\n. removes\n. There is nothing bad about an empty class body, so this should be severity INFO, not WARNING\n. If you want your inspection to run as part of code cleanup, you need to specify cleanupTool=\"true\" in its XML registration.\n. This doesn't actually work: Unit has no javaPrimitiveType. For void.class, the previous variant of the code should be used.\n. I think that automatically changing the name without user input is not a very good idea. It's better to trigger a rename refactoring where the user inputs the name, initialized with the capitalized version of the old name.\n. You're losing all annotations on the original property. (I think that it would be best not to offer the intention if the property has any, because the semantics of annotations on a val and an object is significantly different.)\n. I think you should check the supertype list in isApplicableTo as well, so that you don't end up with an intention which is enabled and does nothing.\n. This object serves no purpose; the contents of the file should simply be top-level functions\n. typo: statemnt -> statement\n. It should never be necessary to create newlines from text. All newlines should be inserted by the formatter.\n. I don't think this code is structured well enough. You have three functions that do three sets of entirely different things based on a value of a boolean parameter. I think it's clearer to pull the check out to the top level and to avoid introducing the functions altogether.\n. It's not OK that you're losing the variable type here.\n. I do think it's a problem that should be fixed if possible.\n. |line 32|\n|---|\n\"a group\" -> \"the group\" here and below. |line 61|\n|---|\nAny chance for some @sample's?. Ouch. This should be handled by a formatter rule, not by AST manipulations.. Actually yes, the way this intention replaces the internal child nodes of KtFunction is quite ugly. I think it would be much nicer to use KtPsiFactory.CallableBuilder to construct the property.. I don't like the idea of adding a preference for this behavior. First of all, the name of the preference says nothing at all to the user. Second, if anyone becomes annoyed by the behavior, it's quite hard for them to discover how to change it.. Why not simply at.getNonStrictParentOfType<KtStringTemplateExpression>()?. I think that it's better to create a single StringBuilder to hold the entire preprocessed contents, and to use the overload of escapeStringCharacters that takes a StringBuilder as a parameter.. Please reformat the files to remove unnecessary blank lines.. Can be object NewLineChunk. I think this naming is kind of confusing; a tokenizer is something that returns a sequence, not something that is a sequence. I'd call it TemplateTokenSequence. Better to declare the result of substring as a variable outside of the apply block.. No reason to use when here; if would be cleaner.. I think this assumes that all escapes are single-character? That's not true; there are also \\uxxxx escape sequences.. Also would be great to have some unit tests for TemplateTokenizer (separate from the overall functional tests).. OK, I see. Then this is fine.. You don't need to call analyze() multiple times; calling it once will return a BindingContext with information about all the expressions.. DescriptorUtils.isSubtypeOfClass(this, expression.builtIns.getComparable()). My suggested change to KotlinType.isComparable() will break this test, but I think it's OK because this test should be red, and we make no guarantees regarding the behavior of intentions on red code.. This should be object a. This should check val/var parameters defined in the primary constructor, too (KtParameter). You can use declaration.hasModifier() directly. This is very inefficient: usages search is an expensive operation and most of the cost is wasted. You should iterate over all usages and stop as soon as you find one outside the local search scope.\nSee also the corresponding Java inspection for inspiration.. You can reuse AddModifierFix. This is now reported on local variables (which are also KtProperty instances).. Wouldn't hurt to handle members of object declarations too.. Better to include name of declaration in the message, otherwise it's hard to understand results of a batch inspection.. You should use KtPsiFactory.CallableBuilder instead of building the text manually.. Better to show a more full name here: \"Class member can have 'private' visibility\". This highlights the entire declaration with a wavy underline, which is very intrusive. Should highlight only the name identifier.. There is never a line break in these locations, so you should better use spaceIf.. I think this is as it should be. The \"Keep line breaks in code\" option tells the formatter to keep all line breaks, including weird ones like that, so it preserves them. In real-life cases, the important thing is to add or remove the space when the statement is on a single line.. Here it's also necessary to check that the KtClassOrObject is not an object declaration. I'll add this check.. Please provide a group path and group name for the inspection according to https://github.com/JetBrains/kotlin/commit/a09b31b5680952c56bb3ea5bbcb7939084e9f027. No need to say \"Recommended...\" in the problem description; \"redundant\" implies that already.. Please use ConstantExpressionEvaluator.getConstant() instead.. You should use KtPsiUtil.deparenthesize() to handle the case when the range expression is in parentheses.. This only handles \"step\" called as an infix function; would be better to handle regular \"step\" calls too.. Why is this limited to call expressions? Backticks can be used around any occurrence of identifier in Kotlin code, and the inspection should detect those in any context.. This detects any backticks, not just redundant backticks. Backticks are redundant only if they enclose a valid identifier (not a keyword and not containing any invalid characters).. I would do this as a general fix to AddModifierFix (which already has special logic for handling modality modifiers), not as a single-case override here.. Please use none instead of any with a negative condition.. It's better to move this line out of the run block.. It doesn't seem necessary to create a copy; you should be able to apply all the changes to the original KtClass directly.. The constructor keyword can only be deleted if there are no annotations or other modifiers on the constructor. Please add a test for the case with annotations.. It should never be necessary to do that manually; the formatter should take care of whitespaces.. Since you aren't changing the intention text dynamically, there's no need to include INTENTION_TEXT in testdata files.. The template shows a top-level method, not a method inside an object. Please update it to show what the intention action actually does.. See KotlinRunLineMarkerContributor for the correct way to check that a function is main.. Please use KtDeclaration.containingClassOrObject.. It's better to change the intention text so that it says \"constructor\" and not \"method\".. I think it's worth fixing PsiFormatUtil to handle constructors correctly, but that's a separate task indeed.. Yes, please do. You don't actually need the super call here.. Please don't forget FileModificationService.getInstance().preparePsiElementForWrite(). Please convert this file to Kotlin if you're adding substantial new code to it. (Rename to .kt, commit, then rename back to .java, run J2K, make any changes needed for the project to compile, commit again, then make your changes.). The getter and setter checks are not needed. This quickfix should apply to any lateinit property; _late_init means that it's initialized somewhere in the class, and this applies to regular properties with default getters and setters too.. I think this nested run expression is far too complex. Better to extract this logic into a method.. Please don't add @author tags to the code. We already have ConvertPropertyInitializerToGetterIntention which is offered as an intention action in this context; you should be able to reuse it directly.. Neither the existing intention action nor your suggested quickfix handle var properties correctly. They should create a stub for the setter with no implementation.. IntelliJ always normalizes text of files to use \\n line breaks, the \\r will never be there. Please remove it from the check.. The parentheses are only required if the line break is before the operator. In this case they should not be added.. This still handles only a random subset of PSI elements. The correct way to handle this is to override visitKtElement and to look for all children with element type KtTokens.IDENTIFIER, similar to how it's done here. Please don't use regular expressions here. Use startsWith and endsWith.. If you replace an arbitrary element in a PSI tree (such as the name identifier of a property) with an expression, this will create an invalid PSI structure and will break other code insight features until the file contents is reparsed. You need to always replace an element with another element of the same type (in this case, an identifier with an identifier). Use KtPsiFactory.createIdentifier().. Please add a test to verify that the quickfix is not offered when an actual keyword is in backticks.. Backticks can also be used to enclose identifiers containing spaces and other characters not allowed in Java identifiers. In this case they must not be highlighted as redundant.. It's OK to keep the formatting changes.. Now that it's a separate function, there's no need to cramp it all into a single expression.\nif (args.any { it.isNamed () }) return true\nval callee = ...resolve as? KtFunction ?: return true\nreturn callee.valueParameters.any { ... }\nAlso the grammatically correct name would be shouldLambdaParameterBeNamed.. I think the intent of this code will be much clearer if you used an explicit class instead of a Pair:\n``\ndata class ComparisonOperands(val eqEqOperands: MutableList<KtExpression>, val eqEqEqOperands: MutableList<KtExpression>). Please don't useLinkedListfor anything ever. :). I'd check that the operands areKtNameReferenceExpression's, to make the behavior more predictable.. This can actually be expressed aseqeq.intersect(eqeqeq).isNotEmpty(). https://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist. @piotrek1543 Please let the Kotlin team decide on the coding conventions used in the Kotlin project. Thanks.. I don't think this is correct.untilshould be used only in the case where the original code used-1. Cases where0..9was generated should remain unchanged.. @piotrek1543 If you can suggest a different way to fix the underlying issue so that J2K does not generate red code, you're welcome to do so. Leaving a comment saying that you're unsure whether something is the right fix is not helpful; please don't.. See my comment to https://youtrack.jetbrains.com/issue/KT-19555. You're still handling only a random subset of elements. Please do what the linked comment says. If you're not sure how to do this, please join the #kontributors Slack channel and ask for help there.. I don't think you need to usefindClass; (callDescriptor as DeclarationDescriptorWithSource).source should point to either the constructor itself or its containing class.. Would love to see an optimization here that skipsgetResolvedCall()if there are no injections into classes with the name of the annotation entry.. Why not simply add afterelementand then deleteelement`?. FQN no, but you can check the short name.. You can use the PSI to check if they're present in the containing file.. This behaves differently for a destructuring assignment and a destructuring used in a loop:\nval map = mapOf(1 to \"two\")\n        for ((key, value) in map) { \n        }\nThe behavior should be the same in both cases.. This is redundant; the next line will also return if entries is empty.. Please specify groupPath and groupName as in other Kotlin inspections (the groupName should be \"Redundant constructs\"). You can use KotlinNameSuggester.isIdentifier() to check if the string with backticks removed is a valid identifier - this does all the necessary checks.. You can use SharedImplUtil.getChildrenOfType(element.node, elementType) and change isRedundantBackticks so that it accepts an ASTNode and not a PsiElement.. This is not what I meant as \"non-constant strings\". Simply check whether the argument is a PsiLiteralExpression.. The copy constructor is not needed here.. Why so complicated? eq will be always equal to =. . Better call this isAssignment. Better use createExpressionByPattern. Yes, the caret needs to be in the same place.. I think this is surprising behavior. Lines should be joined into a single expression only if both the left hand side and the right hand side of the concatenation are constants.. The Join Lines action joins the line where the caret is with the next line. It always acts on exactly two lines.. Minor nit: we're using 'producer' and 'provider' for two parameters that work in exactly the same way. Better be consistent.. Ouch. Can we do better than .take(4)?. Why did you remove the filtering of methods generated by class delegation?. I think that, if a class has no primary constructor, the body of each secondary constructor should include the list of initializer blocks prepended to it. This will match the behavior of the JVM backend.. Then maybe copy it only under the first secondary constructor?. FYI Instead of map().toHashSet() it's more efficient to use .mapTo(HashSet()). This is not a very good fix. A value argument may contain a lambda with a lot of code, and your check would consider all expressions in the lambda to be used, which could hide many problems. I think the right fix there would be to understand why USED_AS_EXPRESSION is not recorded in this case, and to fix it if possible.. The fill() and shuffle() methods have been added in Kotlin 1.2. You need to check the API level for the current module, and offer these replacements only if the API level is at least 1.2.. Please don't use nameIfStandardType (this is a JS frontend function, and should not be used in common code), and please use KotlinBuiltIns.mutableList.. The name of this class is no longer appropriate now that you've extended it to support other functions.. This should show the specific replacement.. I wouldn't use also() here. Please wrap before ?.. isKtPrimaryConstructorParam?. Looks like this won't accept @param:Foo annotation on regular (non-constructor) parameters.. I don't think it makes any sense to report such annotations; this name isn't defined anywhere.. This will always return null for expression body methods with inferred return type.. This can be implemented. Wouldn't it be better to report the type reference (if any) as the source PSI, so that inspection reports could be attached to some element?. Also please don't forget about the @receiver target; it also maps to parameters.. The @delegate: target also maps to fields.. Yes, you can specify the use site target anywhere even if it's redundant.. You should use GENERIC_ERROR_OR_WARNING here, so that the highlighting severity will depend on the inspection settings.. BodyResolveMode.PARTIAL should be sufficient here, and will also work faster.. Please use module.languageVersionSettings.apiVersion instead of this process (this honors the API version specified in the Gradle build or facet settings).. Please unify common cases so there's less duplication in this code. This syntax works only if the argument to Collections.sort() is a lambda, and I don't see any check where you make sure that it is one.. Please use context.psiElementAtStartOffset.containingFile as? KtFile instead.. Source code in IntelliJ always uses \\n as a line separator. No need to access the system line separator here.. You don't need a smart pointer here. If you need to keep track of a range in a document which is updated when the document changes, use Document.createRangeMarker().. You can simply use getParentOfType().. This is inconsistent with how backspace works for regular string literals. With a normal string literal, if the caret is between the quotes, both quotes are deleted, and if it is after the quotes, only the trailing quote is deleted. Similarly, this handler should delete the quotes only if the caret is between the two triple quotes.. You don't need the nullability marks here. The file and editor parameters in BackspaceHandlerDelegate and TypedHandlerDelegate methods are annotated as @NotNull.. Please add tests for the logic you're adding. See TypedHandlerTest and BackspaceHandlerTestGenerated.. This is really unfortunate. We shouldn't be using the Kotlin lexer to scan the text between parentheses, which is not supposed to have any defined format at all. The text between LPAR and RPAR should be a single token. (Maybe the right way to fix this is not to pass KotlinLanguage.INSTANCE to the MARKDOWN_INLINE_LINK constructor, but to create a separate language with its own lexer that will produce Kotlin tokens.). I don't think people will actually understand what this means. I'd change this into two radio buttons: \"Create top-level empty module with common and platform modules as children\" and \"Make platform modules children of common module\".. ",
    "crazyproger": "Sorry for this, I tried to not make wrong formatted code. In future I will reformat only changed piece of code.\nI also has this problem on one project an my job - it was solved by reformatting all project in one commit, and then just check that every have 'reformat before commit' checked. Did you think about something like this?\n. Yes, of course, I will make tests with pleasure. \n. Oh, thank you, now code really looks nice. I didn't change the label because text after 'Oirginal' already contains 'java' word - so I focused on issue subject problem.\n. Squashed, will try to group changes better in future.\n. Ok - I'll get this into the habit, sorry for this.\nThe url that you provide is unavailable.\n. Ah, yes, I forgot to remove this method - it is useless since this text already inserted in call to super.\nThank you!\n. Link to issue http://youtrack.jetbrains.com/issue/KT-2723\n. Removed \"@author\" and rebased on master\n. Glad to hear!\nThank you for good news, Nikolay.\n. Ok, now it looks better\n. Ok, will be fixed in 5 minutes.\nWhere can I find codestyle guidelines for reading to avoid such problems in future?\n. Cool, thanks again - I thought that \"val x=$name\" will produce error since backing field can be accessed only in accessors and constructor(http://confluence.jetbrains.net/display/Kotlin/Properties+And+Fields#PropertiesAndFields-Backingfields)\n. Much nice\n. However I have one question: in current variant org.jetbrains.jet.JetNodeTypes#LABEL_QUALIFIER returned - this is normal that org.jetbrains.jet.lexer.JetTokens#FIELD_IDENTIFIER replaced by org.jetbrains.jet.JetNodeTypes#LABEL_QUALIFIER?\n. Maybe this one will be final :)\n. Copying replaced with delegation, please, pay attention - I rebased on master and squash fix into existing commit.\n. ",
    "bashor": "Thank you and very sorry for the delay.\nCan you rebase to master and create new pull request? \nThanks.\n. Merged manually. \nFYI: Many commits was changed(splited, joined, edited message). Some commits rejected.\n. Good works, thanks!\n(Optional) Would be better if the comment of last commit was more verbose.\n. Good work!\n. I hope my draft version will help you\n```\n@NotNull\nprivate static JetType computeExpressionType(PsiFile psiFile, JetExpression expression) {\n    BindingContext bindingContext = AnalyzerFacadeWithCache.analyzeFileWithCache((JetFile) psiFile).getBindingContext();\n    JetType expressionType = bindingContext.get(BindingContext.EXPRESSION_TYPE, expression);\nassert expressionType != null;\n\nreturn expressionType;\n\n}\npublic static JetIntentionActionFactory createFactoryForTypeMismatch() {\n    return new JetIntentionActionFactory() {\n        @Nullable\n        @Override\n        public IntentionAction createAction(Diagnostic diagnostic) {\n            assert diagnostic.getFactory() == Errors.TYPE_MISMATCH;\n            @SuppressWarnings(\"unchecked\")\n            DiagnosticWithParameters2 diagnosticWithParameters =\n                    (DiagnosticWithParameters2) diagnostic;\n        JetExpression expression = diagnosticWithParameters.getPsiElement();\n\n        JetFunction function = PsiTreeUtil.getParentOfType(expression, JetFunction.class);\n        if (function == null) return null;\n\n        JetExpression returnExpression = null;\n\n        if (function instanceof JetFunctionLiteral) {\n            JetBlockExpression bodyExpression = ((JetFunctionLiteral) function).getBodyExpression();\n            PsiElement lastChild = bodyExpression.getLastChild();\n            if (lastChild instanceof JetExpression) returnExpression = (JetExpression) lastChild;\n        }\n        else if (!function.hasBlockBody() && function instanceof JetWithExpressionInitializer) {\n            returnExpression = ((JetWithExpressionInitializer) function).getInitializer();\n        }\n        else {\n            JetReturnExpression expressionWithReturn = PsiTreeUtil.getParentOfType(expression, JetReturnExpression.class);\n            if (expressionWithReturn != null) returnExpression = expressionWithReturn.getReturnedExpression();\n        }\n\n        if (returnExpression != null) {\n            JetType expressionType = computeExpressionType(diagnostic.getPsiFile(), returnExpression);\n            return new ChangeFunctionReturnTypeFix(function, expressionType);\n        }\n\n        return null;\n    }\n};\n\n}\n```\n. Some use cases:\n```\npackage qfix\ntrait A\nclass B: A\nclass C: A\nfun boo(): Int {\n    return B()\n}\nfun foo(): Int {\n    return if (2 < 3) B() else C()\n}\nfun baz(): Int = if (2 < 3) B() else C()\nfun f(l: () -> T) = l()\nfun ff(l: () -> Int) = l()\nfun funLit() {\n    ff { (): Int -> \"\" }\n    f { (): Int -> \"\" }\n    f { (): Int ->\n        try {\n            if (2 < 3) B() else C()\n        } catch(e: Exception) {\n            C()\n        }\n    }\n}\n``\n. MaybecomputeExpressionType` should be located in some utility class.\n. I think in last examples we can change  Foo#plus.\n. Yes, you are right -- createFactoryForTypeMismatch needs rework. Do you have any idea?\n. I merge this PR soon (after testing on buildserver)\n. Look please my vision (i hope it help You)\n+---->BinOp--+\n               |            +--->find callee Function +----+\n               +---->UnOp---+                              +---> fix callee Function\n               |                                           |                     ^\nfindParent+----+---->Call----------------------------------+                     |\n               |                                                                 |\n               +---->Return----->find (Named?)Function+--------->fix Function    |\n               |                                                                 |\n               +---->Function+-->has Initializer (& no Body)                     |\n                             |                                                   |\n                             +-->is Function Literal                             |\n                                         +                                       |\n                                         |                                       |\n                          Yes            v         No                            |\n                       +--------+has type decl?+--------+                        |\n                       |                                |                        |\n                       v                                v                        |\n                   fix FunctionLiteral              where used+---------->function call\n                                                                    |\n                                                                    +---->assign (with type)\n                                                                                 |\n                                                                                 v\n                                                                               fix it\n. Maybe I didn't cover all the cases, please check it.\n. Thank you for your requests. We will review it soon. Right now we have the holidays.\n. Can try add qfix for:\nfun boo2(x: Foo): String {\n    return 42\n}\nProbably will be better to make it in another PR\nThanks\n. ```\nclass A(val a: Int)\nfun foo() {\n    A(\"\") // qfix should be available\n}\n.\nfun foo3(): Int = if (true) B() else C()\n```\nFor this case we can suggest(additionally) common type.\n. I expected some quickfixes in next case:\nval b = {():Int ->\n    try {\n        if (2 < 3) B() else C()\n    } catch(e: Exception) {\n        C()\n    }\n}\n. Thank you for your request, but KT-3715 fixed in another PR.\nFeel free to ask questions and to make another requests.\n. Can you add tests?\n. I think the right place for tests in Kotlin is testFiles/rtti/cases/ and RTTITest.java for declare.\nAdditionally you can write some tests in JS and add them to testFiles/kotlinLib/cases/ and declare in KotlinLibTest.java.\nFeel free to ask any questions.\nThanks for contribution.\n. ECMA 3 no longer supported. \nThanks for contribution.\n. I created the related issue -- http://youtrack.jetbrains.com/issue/KT-4619. \nI think right now it isn't ready for merge to the master. Feel free to ask any question and create a new PR.\nThanks for your contribution.\n. I think will be better to extract common logic of both backends.\n. I think we need the separate folder for tests of this feature.\n. Thanks for good job, @asuhan\n. Nice, thanks\n. Will be better if you cleanup(merge/fixup some commits) commit history and create new PR.\n. What about toString and hashCode? \n. Ok, we will wait another PR with toString and hashCode.\nBut I don't sure that it should be implemented only in runtime.\n. It's ok, thanks, Alex. I'll merge it to master later.\nCan you describe about how do you want to implement equals, hashCode and toString for data classes?\nI don't agree that we can implement them in the runtime library without changes in compiler, because we want to have the same behavior on both backends.\n. If you saved unsquashed commits and if it will not be difficult I think will be better if split commits by stages like \"refactoring/preparation\", \"add component functions (maybe with tests)\", \"add copy function\" etc.\nPlease understand me correctly  -- It's optional and it's just for supportable.\nThanks.\n. I will try to review this PR at the weekend.\n. Please don't replace commits after fix and just commit otherwise it make difficult to see changes and another reviewers may miss comments from previous commits.\nYou can clean history later and create new PR if need.\n. What implementations of hashCode we should have in JS lib?\nMy suggestions:\nhashCode(v) -- using for Any\nnumberHashCode(v) -- for classes inherited from Number (may be intrinsic)\nstringHashCode(v) -- for String and Char (temporary, because right now we don't have a separated implementation for Char class)\narrayHashCode(v, hasher) -- for Array including IntArray, ByteArray etc\nThoughts?\n//cc @erokhins\n. Oh, sorry, I missed second parameter for arrayHashCode\n. About hashNullableImpl -- I don't see any case for using it. Do you see?\n. I think:\nhashCode, numberHashCode and stringHashCode for null should throw NPE.\narrayHashCode for null element should not generate any exception, but should throw NPE for null parameter\n. Yes, thanks, I miss this case. \nWe can inline this check or use hashNullableImpl. You can implement either.\nP.S. I prefer inlined version.\n. Another thoughts:\nWe discussed with @erokhins and decided that maybe we should keep only hashCode which inlined other implementations. \nThat solution should be simpler for implementation but maybe have performance problems in some cases. \nWhat do you thinks?\n. Invokes of equals, toString, hashCode should be compiled as a direct call instead of as call to a library implementation.\n. > Calls to toString, hashCode and equals are compiled as direct calls when possible. \nI don't think so. For example:\nfrom equals.kt:\nbox: function () {\n        var lhs1 = new _.foo.Bar(true, 'a', 1, 2, 3, 4.5, 3.405691582E9, 4.2, [new _.foo.TwoThings(5, 'z'), null]);\n        var rhs1 = lhs1.copy();\n/*here*/ if (!Kotlin.equals(rhs1, lhs1)) \n           return 'fail: rhs1 != lhs1';\n...\n      }\nfrom hashCodeJvmConsistency.kt:\n```\n      box: function () {\n/here/var h = Kotlin.hashCode(new .foo.ThreeThings('hello world', 42, new .foo.OneThing('foo'), [new .foo.OneThing('hello'), new .foo.OneThing('world'), null])); \n        if (h !== 1667209151) {\n          return 'fail';\n        }\n        return 'OK';\n      }\n```\n\nauto-boxing...\n\nIt sounds interesting and I agree that it should be a separated PR.\n. I think that happens because frontend doesn't declare hashCode and other as a part of class (like for componentN and copy) when it should be generated and resolve them calls to other function like Any.hashCode.\n. Can we generate separate implementation for Arrays?\n. Will be better if you separate commits with safe access -> if-then expression and if-then expression -> safe access.\n. Missed test cases:\n- [ ] if as expression\n- [ ] safe call as expression\n- [ ] simple property as receiver of safe call\n- [ ] property with side effects(with custom getter/setter) as receiver of safe call\n- [ ] local val/var as receiver of safe call\n. Feel free to ask any questions.\n. You can try inline temp variable back when convert if-then expression -> safe access.\nMaybe we should ask user before inline it back. \nAny thoughts?\n. I don't have any idea how it happened, but my comments located outside of this PR. \nhttps://github.com/zgrannan/kotlin/commit/02b2a3de9153a8ad2f469ff031e82a50eab3dafd\nhttps://github.com/zgrannan/kotlin/commit/16bd8c458e78ce69f6536ed23a3ec5e05cd580bb\nLooks like these changes and changes in this PR are similar, please let me know if it's not so.\nThanks\n. Please, let us know if you have any questions.\n. Hi, @zgrannan\n1. See the Inline... refactoring, probably you should just call it, anyway the behavior should be same.\n2. I dont sure, but try use this function:\nkotlin\nfun isStatement(expression: JetExpression): Boolean {\n    val context = AnalyzerFacadeWithCache.getContextForElement(expression)\n    val isStatement = context.get(BindingContext.STATEMENT, expression) ?: false\n    return isStatement\n}\nIf it will not work I suggest You write any simple implementation and update PR and later I try to help you to fix it.\n1. I think will be better if you rebase to master, restructure and clean commit history. And add, please, commits from #374.\n. Thank You, I'll see it soon.\n. I think will be better if you merge this changes to #367.\nThanks.\n. Please write links to your issues.\n. > Should the IDE instead automatically extract the variable?\nI think, Yes, IDEA should start extract the variable silently but ask a name for the new variable.\n. - [ ] Convert 'if' to safe call failed on\nkotlin\nif (a != null) a.capitalize()\n. Fix please same problems in other commits and update.\n. Additionally you can integrate to your next update my minor changes from 89608c22a11c8ca9ed3d58ba0de19d106e18a025\n. Additionally i made some renames in e922f6b1052df72950c475c28af384a7a0948c58, please see it and integrate to your commits if you agree and feel free to discuss.\n. Good job, thank you!\n. Unfortunately, as far as I know, when we ask an user something in intention in current test framework we can test only default choice.\n. Good job, Zack!\nThanks for Your contribution!\nI'll merge it to master manually with minor changes after test it on CI.\nFeel free to ask any questions.\n. Merged manually with minor changes.\nThanks for contribution!\n. About your issues:\n1. I agree, let's do it.\n2. I prefer first\n. 3) I don't have any solution now, I'll continue to investigate it on Monday.\n. About (3): \nthe problem was that we had an invalid code -- with many unresolved reference, because in the test environment(for intentions) we don't have access to the Kotlin stdlib and JRE. I made some changes in test framework which by default forbid use invalid code in tests. But you can declare expected errors if need. For examples see https://github.com/JetBrains/kotlin/commit/b43958f4b36a22a0429eddab47a029072b9b4c14.\nSo please update to master.\n. Additionally for ifThenToDoubleBang test you should add to testData files the directive // WITH_RUNTIME for allow to use NullPointerException etc.\n. Don't forget to comment after any update. \nAnd note that github doesn't send notification after update a comment.\n. Well, I fixed minor problems and merged it manually.\nGood job, Zack! \nThank You!\n. Thanks again :)\n. I fixed it in https://github.com/JetBrains/kotlin/tree/rr/pr/428 and I'm going to merge PR soon.\n. Thanks, Alex\n. Hi, Gavin.\nOk. You can just reopen this PR or ask us about it when you are ready.\nThanks for your efforts!\n. Hi, Alex\nSorry for delay.\n\nWhat we try to achieve at be able to make all calls to static function (which are so common in kotlin thanks to extension methods and closure factories) without many redirects like .foo.bar.func() but let say fun$foo$bar()\n\nRight now I see just move function declarations, what are you going to do next?\nIt's really performance issue for You?\nAnyway I think will be better to discuss before doing any big changes.\n\nAs nice side effect at the final result would be the package definition objects will be completely free from artificial members like closure factories.\n\nIt's trade off between performance and readability. We moved function declarations to closer as possible to usages(or to original declarations) for improve readability. And I don't sure that we want revert it.\nBut it's discussable.\nThanks for your efforts.\n//cc @abreslav \n. Well, I think it should be optional feature which will be disabled by default and user can enabled it by command line argument.\n. > It's a possibility. But then it need to be enabled in IDE as well. Right?\nYes, of course, right now we have ability to declare additional arguments for kotlin compiler in Project Settings. Additionally we can add checkbox for this feature.\n. > I still not sure why generating better compressible and a bit more\n\nperformant code should be optional? Is there anything we lose by making it\nstandard mode?\n\nProbably we can enable it by default in the future. But now, afaik many users prefer readable code.\n. I think we should add one argument for enable any optimization, something like enableOptimizations with list of optimization names as argument, e.g -enableOptimizations foo,bar\n// @abreslav \n. Additionally, it probably will be interesting for you http://jsperf.com/direct-call-vs-qualified-call .\nI made a little benchmark and ran it in some browsers. \n. if I remember correctly the library which we used now for parsing command line arguments don't allow use space here.\n. I think will be better to declare one DefinitionPlace for module scope and suppress other. Than we will get same effects for all local functions and lambdas (note: they may be defined not only package object). Probably we have to make some changes in TranslationContext#define to get better names(with package).\nBtw, it should fix problems with recursive(named) functions\n. And for package level function probably will be more right if we change FileDeclarationVisitor and name generators in StaticContext.\n. I close PR, but promise that we'll keep it in mind when rethink code generation.\n. Failed on:\nkotlin\n    val f = { \"bbb\" }\n    assert(true, f)\n. Manually merged and fixed tests.\nThanks for your effort! \n. Common issues:\n- please reformat all new code(by reformat action)\n- please fix IDE warnings\n. Feel free to ask any questions here or by email zalim.bashorov@jetbrains.com or skype zalim.bashorov.\n. Thanks!\n. You can just push to previous PR/branch\n. Well I closed previous PR, let's work with this.\n. Another suggestion -- please don't overwrite commits, it complicates reviewing.\nWe prefer next workflow:\n1. Create new PR\n2. Review\n3. If don't have any problems goto 8\n4. If need big changes goto 1\n5. Fix problems/remarks and implement the new features in new commit\n6. Push to the same branch(PR)\n7. Goto 2\n8. Clean commit history(rebase, fixup)\n9. Push to master\n. Well, I think it close to merge to the master. But before do it we should clean up code and history.\n. And don't forget to rebase to current master.\n. I close this PR, please make a new when it will be ready.\n. > That means I cannot reply on github to you...\nWhy? You can reopen PR if need.\n\nWould you like to have the rename commit still separate?\n\nYes. \nAdditionally I think will be better to split second commit to \"extract common logic\" and \"implement data in js\", but it's optional.\n. About empty blocks I agree with you -- it's unnecessary.\n. Good work!\nI cleaned commit history and merged it manually. \nThank you for contribution!\n. I'll fix \"Copyright\" problem when merge it\n. Well, I rebased it to master and merge it manually with minor fixes.\n. Additionally I added test for the overridings in data class?\n. Good job!\nThank you for your effort!\n. Well, I merged commits and I going to push it to master soon after build on CI.\nThanks for your contribution!\n. please fix IDEA(Ultimate) warnings and reformat code(by IDEA action) in new code in `kotlin_lib_ecma5.js\n. Will be pushed manually.\n. Merged manually.\nThanks for your contribution!\n. Will be pushed manually.\n. Any news?\n. Sorry for delay! \nI'll see it today.\n. Looks like all commits should be merged in one. Thoughts?\n. or maybe two -- impl and tests\n. Thanks for your efforts!\n. You can find some my minor changes in https://github.com/JetBrains/kotlin/commits/rr/z/pr/524__4.\nIt includes:\n- fixes of windows specific issues;\n- temporary disable assert for source map which fails on windows(build log;\n- temporary drop copying source files(AFAIR something fails on windows).\nYou can see build results for this branch here\n. Would be nice if You cherry-pick my changes.\n. > does adab044 mean that I shouldn't add kotlin-js-library as a dependency (and thus add the jar to libraryFiles) anymore? \nI think in maven and in gradle user should declare kotlin-js-library as dependency explicitly.\nProbably You already saw that I added args.noStdlib = true in your code\n. What version of the compiler you?\nDid you rebase on current master?\n. They(maven, gradle) have own dependency manager and probably will be proper to use it.\n. For developing Kotlin we use plugin from https://teamcity.jetbrains.com/guestAuth/repository/download/bt345/bootstrap.tcbuildtag/updatePlugins.xml\nYou can find more information here\n. 0.9.686 is OK, it's latest bootstrap compiler. So, I'll try build your branch locally.\n. I got it -- it's conflict between kotlin's Stream and java's Stream, try to run build on older runtime.\n. > I take it you don't think we should do this, the user should specify it explicitly; I'll remove the code from the plugin that adds the dependency.\nYes, for maven and gradle we prefer this way.\nAnyway we should provide a way to build with and without stdlib.\n. Hi, Zolt\u00e1n!\nSorry for delay!\nRight now I waiting some changes in master, I hope it'll happen in some days.\nThis changes allow to avoid your \"hack\" in kotlin-javascript-library and allow to use kotlin2js gradle project from IDEA.\nAdditionally we don't sure that our buildtools(ant, maven, gradle) should copy js files from libraries to out dir. Maybe user should do it himself(by own tools)?\nFeel free to share your thoughts.\nThanks!\n. Good points, thanks! Let's continue discussion here.\n. Hi, @abesto!\nI pushed PR commits manually with minor fixes.\n. Thanks a lot for your contributions!\n. Additionally I turn off now copy js kotlin.js from jar, it's current common behavior of all our build tools. we'll continue to think how simplify build process.\n. Merged manually.\nThanks!\n. FYI: You can just force push instead of close and create new PR.\n. Merged manually.\nThanks for your contribution!\n. Ok, it may be merged\n. looks good for me\n. Ok\n. Merged manually\n. Sorry for delay, I didn't notice that some day ago my comment is not received because of connection issues.\n. Fix already in master.\nLet me know if You need this in M12.\n. Ok, thanks for your efforts!\nDon't hesitate to say if anything will be changed.\n. I think these commits may be squashed\n. ok, let's squash and push\n. Thanks!\n. ok\n. ok, please merge manually\n. ok\n. ok\n. how about master?\n. ok\n. Why do you use module.xml file for gradle?\n. branch not compiled now, rebase should fix it\n. Most of previous comments are actual \n. Please don't push commented code\n. Good job, @soywiz!\nI've already fixed it as KT-9954 (rr/z/kt9954), but didn't push it yet because some tests failed on some agents on CI.\nI'll take your changes in KotlinCompilerRunner.kt manually and push the fix as soon as possible.\nThanks for your effort!\n. Looks like the issue and PR are obsolete, so I close it.\nAnyway, thanks again!. Thank You!\n. Thanks, @ajalt!. @ilya-g, I think, it would be nice to improve existing declaration anyway.. @devulex the changes will be available since 1.2.20. Merged manually with cosmetic changes. \nThanks!. Thank you!\nI've pushed it manually with minor changes.. Merged manually.\nSorry for the delay and thank you for your contribution!\n. Merged manually, thank you!. Field may be 'final'\n. Use SuppressWarnings, please, like line 92-95 in idea/src/org/jetbrains/jet/plugin/quickfix/AddStarProjectionsFix.java\n. Use SuppressWarnings, please.\n. Add please checking for diagnostic factory. Look like line 91 in idea/src/org/jetbrains/jet/plugin/quickfix/AddStarProjectionsFix.java\n. I think property is not enough good name.\n. Maybe typeReference == null should be just assert\n. It works for me, try please again and push it even it doesn't work.\n```\n        val assertText = \"kotlin.assert(${element.getCondition()?.getText()}, $param)\"\n        val assertExpr = JetPsiFactory.createExpression(element.getProject(), assertText)\n    val newExpr = element.replace(assertExpr) as JetExpression\n    ShortenReferences.process(newExpr)\n\n``\n. Unnecessary space before colon(:)\n. The call chain may be written in one line\n. looks like we don't needsourcesinpopulateTargetSpecificArgs`\n. I think will be better if move up populateTargetSpecificArgs and afterCompileHook declarations, because it's part of API of this class\n. should be it private?\n. I think more properly to check that it's kotlin file.\nP.S. I see that it's legacy code\n. You can get file extension by file.extension.\nAnd You can use JetFileType.EXTENSION instead of magic string.\n. Why just not List?\n. May be replaced with filterNotNull\n. May be List?\n. I think outputFile can not be omitted and if it omitted compilation should be failed.\n. charset parameter may be omitted -- UTF-8 will by use by default\n. let's do it :)\n. ok\n. ok\n. They are similar but not the same.\nIn k2js compiler right now file name will be used as module name, so I think this parameter should be provided explicitly. (Probably in the future it will be replaced with moduleName)\n. As far as i understand JVM task, by default, use project's build dir.\n. Why we need javaTask?\n. Ideally it should be fixed in compiler as part of KT-4078. You can just add TODO comment that this hack should be dropped after KT-4078 will be fixed or fix it :)\n. I think we should extract all libraries from dependencies instead.\n. I think we should not be able to copy source files.\n. Could we avoid to use it? \n. I think that this gradle task should not be able to copy source files because user can do it in plain gradle if need, and how he want. And maybe it can lead to accidental leakage of sources.\nBut we should provide better way to setup source map generation(KT-4078).\n. It's not JVM specific.\n. Should it be ANNOTATION_CLASS?\n. What about a file as target?\n. Is it ok that it called the same as other Java constant? Can it mislead?\n. why do you filter it twice?\n. what for this?\n. Maybe we should have another exit code for such cases? e.g. ILLEGAL_ARGUMENTS_ERROR.\n//cc @udalov \n. cheating\n. let's write comment about it\n. Could we cover it in tests, if didn't?\n. We can fix CliCompiler.exec :). Any way I don't like that in the same cases we return different code(COMPILATION_ERROR and INTERNAL_ERROR)\n. I think we should report INTERNAL_ERROR only our (internal) issues (crash, exception etc)\n. Well, let's fix it in separate commit\n. Looks like it should be object\n. Why ClassCastException is not enough here?\n. Try to run optimize imports and reformat\n. we prefer to first declare a public API\n. private?\n. minor: I'd inline connectToDaemon\n. We prefer to use braces in if except one-line ifs: if (cond) return/break/continue\n. braces\n. i'd just add default value for name to primary constructor\n. we can get list with string which ends with \"null\" and filterNotNull is unnecessary here\n. Should allowMergedArg be false here?\n. I'd extract { it.isEmpty() } to constant\n. i'd extract { it } or use identity() from core/util.runtime/src/org/jetbrains/kotlin/utils/functions.kt\n. Do  You think about merge PropExtractor and PropParser?\n. replace ; with \\n\n. I think it'll be simpler if rewrite with while\n. please don't mix blocks with and without braces\n. I think we need better name for this function\n. what is cs?\n. minor: I don't like Cmdline\n. I'd toggle case of s or drop auto prefix\n. in bytes?\n. IMHO constant better than comment :)\n. private?\n. Why is not on the top?\n. private?\n. getName() can be replaces with name\n. or You can use File.extension property\n. platformStatic deprecated now\n. it has only one usage\n. don't mix factory methods and constructors in public API\n. i'd rename it to create\n. I think these properties should not be part of public api\n. what for it's Serializable?\n. I don't like public vars and public constructor in inheritors of CmdlineParams\n. why we skip empty parameters?\n. containsAll\n. the order in classpath is important\n. Why generated equals (from data class) is not enough?\n. I'd write something like:\n``` kotlin\n    override fun remoteCompile(args: Array, errStream: RemoteOutputStream, outputFormat: CompileService.OutputFormat): Int =\n        doCompile(args, errStream, outputFormat) { compiler.exec(it, *args) }\noverride fun remoteIncrementalCompile(args: Array<out String>, caches: Map<String, CompileService.RemoteIncrementalCache>, outputStream: RemoteOutputStream, outputFormat: CompileService.OutputFormat): Int =\n    doCompile(args, outputStream, outputFormat) { throw NotImplementedError(\"Only XML output is supported in remote incremental compilation\") }\n\nfun doCompile(args: Array<out String>, errStream: RemoteOutputStream, outputFormat: CompileService.OutputFormat, compileWithPlainOut: (PrintStream) -> ExitCode): Int =\n        ifAlive {\n            checkedCompile(args) {\n                val remoteStreamClient = RemoteOutputStreamClient(errStream)\n                val printStream = PrintStream(remoteStreamClient)\n                when (outputFormat) {\n                    CompileService.OutputFormat.PLAIN -> compileWithPlainOut(printStream)\n                    CompileService.OutputFormat.XML -> compiler.execAndOutputXml(printStream, Services.EMPTY, *args)\n                }.code\n            }\n        }\n\n``\n. nothing to filter out byfilterNotNull.mergeDelimiterand the result oftoStringcan be null.\nTry to useString?.orEmpty()to process this case correctly\n. During the previous review I slightly rewrite this and something else, I hope this will be useful.\nhttps://github.com/JetBrains/kotlin/commit/ef2ea84a85c3415fc9fa1c933e44c880df979d80#diff-4ff40116c0033e709c32c7abef5b2b0eR84\n. let's drop it\n. I was not right aboutmergeDelimiterhere\n. I don't think that Your solution  better than oneorEmptycall\n. but of course it's up to you \n. Ok, may be You are right.\nBut I'd move the gettingcodetodoCompileat least.\n. ok\n. You can uselethere instead of \"another if\"\n. Is it ok that behavior changed?\n. I think return type should not beLonghere since it's not native JS type and it's emulated in Kotlin. Probably it should beNumberorDouble.. Similarly, all usages of Long in this file should be reviewed. Also, sometimes it can beInt. I think it can be moved tokotlin2js.xml`. what for do we to generate any other synthetic nested class?. I think would be better to report something here.\ncc @udalov \n. ok. It's not good practice to hack builtin classes.. would be better to use void 0 instead of undefined. would be better to avoid changing ctor, and I think we can just return any of [], null, void 0. TODO: use Set when it's possible?. actually, it's not all interfaces, but all parents + class itself. I think we can push superConstructor at 60 line instead of pushing ctor here.. It could be added to some file inside libraries/stdlib/js/src/js or reimplemented in Kotlin. But before that, would be nice to decide do we need it in stdlib or not.\ncc @ilya-g @cy6erGn0m . ",
    "marschall": "Works well with M5, I'm a happy camper.\n. ",
    "svtk": "Thanks! I've merged the commit (here https://github.com/JetBrains/kotlin/commit/f5d6e8d75151a4427a4e43ac115243e4f0018acd). \nThe comments (corrected already in https://github.com/JetBrains/kotlin/commit/7a03c855490e301cd7223e6157c166f28748fe2b, because I was touching this code anyway):\n1. There is no need to have a variable \n'List nextInstructions = Lists.newArrayList();'\nand then to clear it in the end. You can easily iterate over insruction.getNextInstructions()\n2. You can check 'visited.contains(instruction)' before adding to a stack.\n3. There is no need in two methods (in spite of there were two before:) ).\n. Hi Ioannis! Sorry for the delayed answer. \nI'm afraid it's better to rebase these commits or to create a new pull request to avoid unnecessary changes.\nThanks.\n. I've merged your changes manually (here: https://github.com/JetBrains/kotlin/commit/c27427434fadd3477d8fb9c236406d4324793d70). Thank you for your participation!\n. I'm closing this pull request, please create the new improved one with reference to this (if you want).\n. Hi Stebalien!\nTo invent a name for intention you may try to find similar Java intention (see \"Settings -> Intentions\"). To my mind the closest one is \"Negate comparison\", so we can use \"Negate operation\" or \"Negate binary operation\" name.\nBut the best for the user is setting operation name explicitly, like \"Negate comparison\" or \"Negate 'is' operation\"\n. Yep, it's a good idea. Let's name it JetSingleValueToken and make JetKeywordToken inherit from it.\n. Everything looks good. Please rebase your commits to make a nice history.\nIf a user sees \"Simplify Negated Comparison\" he won't follow your thoughts about  1 in array(1,2,3) as a comparison, but will be confused by this name. So it's better to change it.\n. Hi! Sorry for not so fast review =).\nLet's improve this functionality by covering not only \"true\" and \"false\" constants, but any constant expressions that can be reduced to \"true\" or \"false\" as well, like \"1 < 2\".\nThis can be done automatically for you by our ConstantExpressionEvaluator, and I've extracted the method \"canBeReducedToBooleanConstant\" in CompileTimeConstantUtils (you have to update to get it).\nIt needs the trace, the best way to get is \nval bindingContext = AnalyzerFacadeWithCache.getContextForElement(expression)\n. I've by accident left the check for JetConstantExpression in 'canBeReducedToBooleanConstant'. \nSo the first check \nif (!(expression instanceof JetConstantExpression) || expression.getNode().getElementType() != JetNodeTypes.BOOLEAN_CONSTANT) {\n        return false;\n    }\nshould be just \nif (expression == null) return false;\nPlease add this change to your pull request. Thank you.\n. Your intention removing type arguments doesn't work for ('isApplicableTo' returns false):\nfun foo(s: String) {\n    <caret>bar<String>(s)\n}\nfun bar<T>(t: T) = t\nIt seems the best way to fix it is to create a fake call and resolve it in the current scope.\nYou need a method CallResolver.resolveFunctionCall(trace, scope, call, expectedType, dataFlowInfo,). \nYou can create InjectorForMacros to get CallResolver component. The scope, expected type, data flow info should be taken from binding trace for element (on which the intention is invoked) by keys RESOLUTION_SCOPE, EXPECTED_EXPRESSION_TYPE, EXPRESSION_DATA_FLOW_INFO.\nTo create a call without type arguments you can use DelegatingCall. \nIt's important to resolve a fake call in an empty trace to avoid reusing cached information about value arguments.\nIt's better to divide this pull request into two (for adding and removing type arguments).\nPlease add more different tests for both intentions (like the example above).\n. You can look through usages and find that:\nCALL, RESOLUTION_SCOPE should be got by the key element.getCalleeExpression();\nif EXPECTED_EXPRESSION_TYPE is null it means TypeUtils.NO_EXPECTED_TYPE;\nif EXPRESSION_DATA_FLOW_INFO is null it means DataFlowInfo.EMPTY.\n. The function \"makeString\" is an extension function and is imported by default, so I don't understand why you can't find it (just \"iterator.makeString()\" should be resolved).\n. If you analyse the same element twice, having two different binding contexts, no wonder you have incomparable data. \nPlease understand what you are doing, it seems you are trying to apply everything (the first approach you tried that didn't work, the second approach I've proposed, creating several new binding contexts and traces for no reason).\nThe first question is: what was wrong with your initial idea? (With creating an element from text and analyzing it in the current context). Please return to your first pull request and see why it doesn't work for the example that I posted above.\n. Let's look at the example:\nfun foo(s: String) {\n    <caret>bar<String>(s)\n}\nfun bar<T>(t: T) = t\nIf you just use cached information about the value argument 's', it means you know it refers to a value parameter of function 'foo' and its type is String. Then without explicit type argument 'String' your call is 'bar(s)' and through analysis successful resolved call for 'bar' should be recorded.\nHowever, in your initial pull request it doesn't record successful resolved call. And 'isApplicable' on this example returns 'false'. Why?\n. When you create newElement from String (by cutting out explicit type arguments), what file do you  actually analyse? AnalyzerFacadeWithCache.getContextForElement(newElement!!) anyway analyses an element in a file. You can understand it by looking how createExpression works or in the debug.\n. When I said \"It's important to resolve a fake call in an empty trace to avoid reusing cached information about value arguments\", I meant you could try to resolve your fake call with the same binding trace we got after analysing initial call. In this case all value arguments are the same expressions, and since you reuse them, you have cached types for them (in EXPRESSION_TYPE) and it may lead to unexpected successful result. Like in the example:\n```\nfun  id(t: T) = t\nfun  emptyList(): List = ArrayList()\nid>(emptyList())\n```\nImagine you resolve a call id(emptyList()), but you have cached type List<Int> for the argument emptyList(). This means the new call is successful, but it's wrong.\n. I'm going on a vacation now, so Andrey will follow this pull request further. \nIt seems it should be a bit more complicated, because we can't afford doing an expensive analysis through \"isApplicable\" check. So we'll have to make an approximation in \"isApplicable\" and then to resolve a new fake call in \"applyTo\". \nBut now please return to your idea with creating \"newElement\" from String and see what's actually wrong with it.\n. I'll repeat my question. What was wrong with your first approach when you tried to analyse the following code?\nfun foo(s: String) {\n    <caret>bar<String>(s)\n}\nfun bar<T>(t: T) = t\n. Ok. I'll repeat my another question giving you a hint: \nWhen you create newElement from String (by cutting out explicit type arguments), what file do you  actually analyse? AnalyzerFacadeWithCache.getContextForElement(newElement!!) anyway analyses an element in a file. You can understand it by looking how createExpression works or in the debug.\nPlease forget now about creating a new fake call and just return to the first approach with creating an element by cutting explicity type arguments and analyzing it. And find out what was wrong there. You don't need to read code of CallResolver or CandidateResolver to do it.\n. You don't have to create a new expression from text without explicit type arguments to analyse it, you should just create a fake call with the same value arguments and resolve it in a current scope with empty binding trace. Something like:\nval call = object: DelegatingCall(callWithExplicitTypeArguments) {\n        override fun getTypeArguments() = Collections.emptyList<JetTypeProjection>()\n        override fun getTypeArgumentList() = null\n    }\n    ....\n   resolveFunctionCall(BindingTraceContext(), scope, call, expectedType, dataFlow, false)\nThe problem with creating an expression with JetPsiFactory.createExpression is that it's created in a new file like val x = bar(s) and there is no enclosing context (function arguments, etc.) for it. That means when you say AnalyzerFacadeWithCache.getContextForElement(candidate) all arguments are unresolved. That's why your first approach didn't work for all cases with non-trivial arguments. (You wrote only tests with constants as arguments).\nBecause of this problem we proposed you to create and resolve a fake call without creating an expression, just to reuse all the arguments expressions. When you mix these two ideas, you win nothing: your current code doesn't work with non-trivial arguments. Moreover after reanalysing an expression you have a mess with descriptors.\n. Good, thanks, I merged it.\n. I'm afraid your approach to remove unnecessary labels doesn't really work for more complicated cases:\nclass A\nclass B {\n    fun A.foo() {\n        bar(this@B)\n   }\n}\nfun bar(b: B) = b\nHere if you remove the @B label, you change a reference, and the code doesn't compile.\nThat means you have to resolve 'this' without label in the current context, and check whether it refers to the same element as with label (the same with adding labels).\nYou can see RemoveExplicitTypeArguments intention for an example of how to resolve an expression in a current context. But now you don't have to resolve a call, just to invoke 'injector.getExpressionTypingServices().getTypeInfo()' for labeled expression.\n(For now LabelResolver isn't cached, so labels don't work correctly, but tomorrow I'm going to push the fix).\n. I've pushed the commit, thank you.\n. It will be pushed soon.\n. Pushed manually with the changes: https://github.com/JetBrains/kotlin/commit/0b4f313b6d6cda82a99e2a34bcc37a95c50c680e.\nAlso 'break/continue' in condition were forbidden (http://youtrack.jetbrains.com/issue/KT-5724).\n. About functionality:\n1. It's not good to give a user a partial functionality.\nHe would be surprised to find that the case 'super.foo()' is working, but 'super.foo().bar()' isn't.\n2. I'd expect some choice which receiver I'd like to invoke here.\n. It's better to use less concrete types like Set or Collection here. (The following code should be independent of concrete implementation of collection to make it easy to change it later if necessary).\n. I'd rather divide this method into several smaller ones with meaningful names.\n. Please annotate return type as Nullable if a method may return null.\nThe method name should explain what this method does (better using some verbs like 'do something') and what it returns ('memberNameAndArgsFound' returning JetType is unclear).\n. Don't override 'Deprecated' method.\n. You shouldn't copy code. You may change this method in its class or/and move it to util instead.\n. ",
    "sigito": "Sorry, it was my fail. Will do all as it should be done next time.\n. ",
    "lopekpl": "I amended changes to the commit:\n- handling with traits\n- handling with superclasses from java sources\n- finding superclass once rather than twice\nIt's ready for review I believe.\n. I amended to the commit:\n- new line before else\n- test when rename is possible, but there are multiple overridden methods\n. I would like to get familiar with your solution later today or tomorrow (first I need some warm up with trivial quickfixes ;) ), and let you know what I think. We can choose the one which we will decide is better and possibly improve it if needed.\n. When method overrides methods from multiple supertypes my quickfix offers to change the return type only if it is possible to match all of them, and get rid of the error. I think removing type is useful - technically it's not necessary, as we could change the return type to 'Unit', but I think that would look strange. My quickfix also allows to introduce a return type when none is specified.\nI was thinking on how to merge our solutions, and eventually decided to modify my code by applying some of your ideas. This is what I ended up with: https://github.com/lopekpl/kotlin/compare/RETURN_TYPE_MISMATCH_ON_OVERRIDE2\nIf you have any comments, please let me know, or pull request me. If you dislike this piece of code you can convince me to something else ;) Or we can let Andrey choose.\n. 1 Quickfixes look similar but I'm afraid combining will produce 'if' statement in almost all methods. Also in 'ivoke' method where different overloads of 'addTypeAnnotation' are used. Right now I don't have good idea how to do it, I will think about it tomorrow (it's 2am here and I'm tired). Don't hesitate to pull request me with 'combining commit' if you want to.\n2 Done\n. I resigned from merging quickfixes, and opened new pull request.\n. Amended: I renamed method to 'findLowerBoundOfOverriddenCallablesReturnTypes' and made it public.\n. I amended changes:\n- rename 'colon' to 'semicolon'\n- place caret at the position it was before applying quickfix\n. Amended. Works with constructors with vararg arguments and arguments with default values now.\n. Amended: replace diagnostic test with parser test.\n. Amended: improved test for ChangeVariableTypeFix + COMPONENT_FUNCTION_TYPE_MISMATCH\n. Amended. You were right that the call for compareTo() is already recorded in trace. I only needed to change context.get(BindingContext.RESOLVED_CALL, expression) to context.get(BindingContext.RESOLVED_CALL, expression.getOperationReference()). I also removed my changes in BasicExpressionTypingVisitor.java.\n. I sent this pull request from wrong branch, sorry.\nhttps://github.com/JetBrains/kotlin/pull/238\n. I modified commit and fixed mentioned issues.\n. I was not very effusive indeed ;)\n. I split previous commit into more meaningful ones.\nAre you going to create quickfix for NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY too?\nGood idea, done.\n```\nAdditionally would like to have quckfix for next cases\nfun foo() : A {\nreturn expression //:B\n}\nto:\nfun foo() : B {\nreturn expression //:B\n}\nand\nfun foo() : A = expression //:B\nto:\nfun foo() : B = expression //:B\nAre you going to do something similar?\n```\nIn these cases TYPE_MISMATCH is reported. I was thinking about it, best logic I came up with is:\n```\npublic static JetIntentionActionFactory createFactoryForTypeMismatch() {\n    return new JetIntentionActionFactory() {\n        @Nullable\n        @Override\n        public IntentionAction createAction(Diagnostic diagnostic) {\n            assert diagnostic.getFactory() == Errors.TYPE_MISMATCH;\n            @SuppressWarnings(\"unchecked\")\n            DiagnosticWithParameters2 diagnosticWithParameters =\n                    (DiagnosticWithParameters2) diagnostic;\n        JetExpression expression = diagnosticWithParameters.getPsiElement();\n        JetFunction function = PsiTreeUtil.getParentOfType(expression, JetFunction.class);\n        if (function == null) return null;\n        if ((function instanceof JetWithExpressionInitializer && ((JetWithExpressionInitializer) function).getInitializer() == expression) ||\n             expression.getParent() instanceof JetReturnExpression) {\n            return new ChangeFunctionReturnTypeFix(function, diagnosticWithParameters.getB());\n        }\n        return null;\n    }\n};\n\n}\n```\nBut it doesn't work in such case:\nfun foo(): Int = if (2 < 3) \"\" else \"\"\nIt might also misbehave when \"returns at labels\" are implemented. I think it might be good idea to create new slice in BindingContext and for each returned expression (also in initializers) store appropriate function. But it doesn't seem to be trivial change.\n. Thanks for this code and examples! Seems most of work is done, I will work on this quickfix next week (I have little time this week left, and also some other quickfix work in progress).\n. I fixed null issue I mentioned, when you clarify how should I use NameUtils.isValidIdentified, I will modify it (next week).\n. Closing as it became quite messy. I will submit new pull request with some additional quickfixes. Thanks again for suggestions, the code snippet and some use-cases !\n. Thanks!\nI think in last examples we can change Foo#plus.\nGood point, appended to my TODO queue :)\ncreateFactoryForTypeMismatch needs rework. Do you have any idea?\nOk, so now I have two different cases:\n1) TYPE_MISMATCH on some expression with operator - qfix should change return type of the overloaded operator\n2) TYPE_MISMATCH on expression that is returned by function - qfix should change return type of function that contains this return expression\n1) as I mentioned is queued\n2) This is partially solved. It seems the only case it doesn't work is this return if(...) A else B structure. I think similar strategy to the one proposed by you can be used, but I just need to add recursion to it (as we need to iterate over all parent if(...) A else B statements of expression on which TYPE_MISMATCH is reported, to decide whether  this expression is returned by function and this is the cause of TYPE_MISMATCH).\n. Very transparent case study, I will be super-helpful :) I'm going to work on this tomorrow.\n. https://github.com/JetBrains/kotlin/pull/261 - first part of work. It still doesn't cover all cases from your schema, but I want to split work into two (or more) pull requests.\n. I don't map this qfix to INCOMPATIBLE_TYPES any more - it appears there can never a reasonable cast be done in case of this error.\nTwo thoughts.\n1) In such case, where AUTOCAST_IMPOSSIBLE is reported on 'x'\n```\ntrait Foo {\n    fun foo(x: T)\n}\nfun bar(_x: Any) {\n    var x = _x\n    if (x is Foo<*>) {\n        x.foo(42)\n    }\n}\n```\nmy quickfix casts 'x' to Foo<Number>. It could cast it to Foo<*>. I guess that the second way might be preferred (e.g. to expose Kotlin star projections feature, and just because it's more handy). I thought I could implement \"ChangeToStarProjectionIntention\" (and then go back to to this code and change it as well). Would it be useful and is worth doing?\n2) In such case:\n```\ntrait X {\n    fun foo() {}\n}\nopen class A\nclass B : A(), X\nfun foo(a: A) {\n    if (a is X) {\n        (a as X).foo()\n    }\n}\n```\nCAST_NEVER_SUCCEEDS is reported. I wonder if this is a bug or just an issue that is not worth solving (although I think such situation can occur in \"real code\" when for example someone uses traits as markers).\n. I added the test from above to the commit with qfix.\n. I've made a lot of changes in these commits, and I will push them by Friday, so please don't review this pull request by this time.\n. https://github.com/JetBrains/kotlin/pull/271\n. Thanks! I will try to submit a new pull request later today.\n. > What about the following test\n\nbefore:\nfun <T> f(t: T?) {}\nafter:\nfun <T: Any> f(t: T?) {}\n\nI added this test to the commit.\n.  I admit I didn't research enough before I started implementation.\nEDIT: Andrey already answered my first question:\n\nNow I feel confused about how compiler works and would appreciate some clarification.\nWhy fun <T> testMore() : T = null does not compile? Error message says Null can not be a value of a non-null type T. At the same time 'T' has a nullable upper bound. This means that a value of this type may be null. (that's what says warning when I type T?). This looks to me as a contradiction.\nWhy typing T? produces warning? - though ? is meaningful as removing it produces error.\n\nAs for the quickfix:\n\nThe problem with current implementation of this quickfix that it can harm existent code:\n```\nopen class Some {\n    open fun foo(t: T?): T? = t\n}\nfun testSome() {\n    val a: Some = Some()\n}\n```\n\nThis is even worse:\nfun foo<T>(x: T?) {\n    foo<Any?>(null)\n}\nThe only way I see to prevent this quickifx from harming existent code is to make it not available if in any usage of generic class/function declared type parameter is nullable. I'm not sure how expensive such check can be. Anyway first I need to understand compiler behaviour and I will be grateful if you could make it clear for me.\n. I don't love name 'removeAfter' but I didn't come up with anything better.\n. ",
    "kfc35": "added test for when the user is extending a trait -- test passes\n. added private keyword and added @NotNull annotation\n. Added the enum like geevee suggested -- I decided to keep the texts separate just because!\n. NEVERMIND i just realized this was already done by agnieszka!!\n. got it -- removed the troublesome line! thanks :)\n. i understand :) I will make sure to see that there's no irrelevant lines in my code\nConcerning the LeafPsiElement having a spread sign -- I just updated the file now that checks whether the text of the element is \"*\", is this the correct way to go about this? I wasn't sure if there was a global variable somewhere called SPREADSIGN or something... searching for usages did not yield any such results\n. Ah I see =) Thanks for being super helpful (even though I've been difficult) Nikolay! I'll be sure to remember everything you said for my future pull req's\n. just updated this pull request -- removed a line checking if element == null because it's not necessary!\n. I'm going to close this for now and work on it more based on comments I received on my other pull request -- be back shortly!\n. addressed in a different pull request in a diff. branch! closing this one\n. (The first two commits (1656ecb and ac208fd) are the same thing. Hope it's not an inconvenience)\n. ",
    "univerio": "Sorry - I didn't know I was supposed to commit the generated files. It also changes a bunch of unrelated files in /compiler, do I commit those as well or just QuickFix*Generated.java?\n. @abreslav I figured out why it was changing every single file - line endings. Specifically, when working on Windows, the Printer class thinks it's a good idea to output system line endings, i.e. CRLF. Perhaps that could be changed? I tried messing with git's core.autocrlf to no avail.\n. @udalov Ah, that's it, I didn't re-checkout the files after setting core.autocrlf to true. Curiously, setting it to input doesn't work. Perhaps I'm misunderstanding what \"input\" does. GenerateTests doesn't use System.out - it uses the Printer class. When I changed Printer.LINE_SEPARATOR to \"\\n\" everything was fine.\n. Shoot. How should we proceed? Just choose one of them?\n. It appears that yours considers overriding a method of the same signature but having different return types and from different supertypes as valid, and offers an option to change it to either. However, changing it to either type does not fix the error. Mine also fixes PROPERTY_TYPE_MISMATCH_ON_OVERRIDE as well.\nYours, on the other hand, has more test cases. It also gives the option to remove the type completely (although I'm not sure if that's necessary). Thus, I think the best way to do this would be to merge our solutions and resolve the differences between them. I will wait until you finish looking at mine.\n. Two things.\n1. Can ChangeReturnTypeToMatchOverriddenMethodFix and ChangePropertyTypeToMatchOverriddenPropertyFix really not be combine together?\n2. I understand the purpose of removing the return type now. Perhaps you could refine the message to say something like \"remove return type to match overridden method\" instead, since the way you have it now sort of implies that the return type remains the same after removal (\u00e0 la type inference on a property), when in reality it's changed to Unit.\n. Okay. Closing this in favor #189.\n. I've never used that feature before, thanks for pointing it out! I'll be sure to keep that in mind. :)\n. TypeCandidate represents a choice of a type, i.e. one of the dropdown options for a type annotation (e.g. return type or parameter type). TypeOrExpressionThereof encapsulates a set of these type choices. Type refers to a set of choices obtained from a JetType, while ExpressionThereof refers to a set of choices obtained/guessed from a JetExpression.\nI actually have a series of small(er) commits; I squashed them for this pull request. If you'd like, I could open a new pull request with those smaller commits instead.\n. I'm also not quite sure how to group quickfixes together, since there is a diagnostic for each missing function.\n. Adding getScopeForMemberResolution to ClassDescriptor is trickier than I thought. Notably, ClassDescriptorFromJvmBytecode requires an implementation of it, which I am reluctant to do since I don't fully understand all the various different kinds of scopes. I'll try to see if I can come up with something reasonable. If not, I'll ask some more questions.\nRegarding PermGen space, what OS and Java version are you using? I'm using Windows 7 with JDK 1.6.0u38, and it's reproducible on all (two) of my machines.\n. I'm still not sure using TypeSubstitutor would replicate what my code is doing. From my understanding, you said that a TypeConstructor does not have its type parameters specified, so I can't use it to do what I want to do, which is replacing a whole type, including the type parameters. As an example, if I want to replace Iterable<String> with T in Array<Iterable<String>>, it should produce Array<T>, but if I want to do the same substitution in Array<Iterable<Int>>, producing Array<T> (which is what TypeSubstitutor would do) would be incorrect. Am I understanding this correctly?\n. Sorry - so I have three types: (1) the original, unsubstituted type; (2) the type to look for in (1); and (3) the type that will replace all occurrences of (2). I meant that (3) is always a type parameter. In my previous example, (1) is Array<Iterable<String>>, (2) is Iterable<String>, and (3) is T.\n. I think I've fixed everything you've asked. Would you like me to rebase on top of master and resubmit since it's been a month since I last did it?\n. Yes, everything I've done is here.\n. I think it is. This ensures that PLATFORM_CLASS_MAPPED_TO_KOTLIN errors talking about a different platform class is not \"fixed\" as well.\n. I'm not sure I understand what you mean by \"guess by declaration immediately\". Are you saying to just fall through? If so, I'm not sure that works because it could be the case that there are no references to the declaration.\n. This substitutes one JetType for another JetType, in a JetType. For example, given Array<Iterable<T>>, and the substitution T/Iterable<T>, it produces Array<T>.\nThe existing TypeSubstitutor maps TypeConstructor to a TypeProjection, which I don't think suits my needs.\n. Regarding passing via fields vs parameters, I (generally) pass things via fields only if it's used across many methods. Would you prefer that they all be passed via fields or all via parameters?\n. I couldn't figure out how to do that without basically re-implementing PsiClassListCellRenderer. I guess I will do just that.\n. So for a particular substitution, e.g. Array<Iterable<T>>[S/Iterable<T>], I want to offer the user two choices, the unsubsituted version (unapplied) and the substituted version (applied), i.e. both Array<Iterable<T>> and Array<S>.\n. Basically, it computes TypeCandidates from either the JetExpression or the JetType this instance refers to. This involves either guessing a set of types from the JetExpression or using the JetType directly, and then performing substitutions on them.\n. In case of T.foo() call, the compiler reports UNRESOLVED_REFERENCE on foo instead of NO_CLASS_OBJECT on T.\n. I can't come up with a non-trivial use case -- I guess I'll remove it then.\n. To be consistent with the existing API. Should I change it to List?\n. I see that there are other references to \"method\" in the code - is it just the UI that should say \"function\" instead?\n. It's intentional. I'll change it to make that more obvious.\n. This doesn't work. receiverType.getMemberScope() cannot resolve type parameter names for some reason.\n. But this class is more of a \"lazy processor\", so a lot of the fields can't be computed in the constructor (prior to invoke()).\n. True, but a TypeConstructor, from what I understand, is not a JetType, so I can't use it to replace entire types in another type.\n. ",
    "lina2002": "When I try to generate test file more changes are being done, than it probably should be. I don't know what does it happen, but imports are being changed too. Difference between my file and current file: http://www.diffchecker.com/vZ9ZBEhs\nWhat am I supposed to do? Should I commit this file (choosing only good changes) and make another pull request?\n. In my comparison left was current file in project. But here is a comparison between my \"5\" branch before (left side) and after changes: http://www.diffchecker.com/5KGz131u As you can see everything is ok, except imports...\nShould there be something after \"Can\" at the end of your comment?\n. It helped, thank you for your advice.\n. ",
    "sapal": "I've created another pull request, because I didn't manage to update this one (I did 'commit --amend' and then \n'push --force' to the same branch and the commit changed in my repo, but not in this pull request). Sorry for inconvenience. This is the fixed pull request: https://github.com/JetBrains/kotlin/pull/203\n. I've added test with qualified access to the backing field.\n. I'll try to merge this pull requests into one today or tomorrow.\n. Merged pull request: https://github.com/JetBrains/kotlin/pull/204\n. I'm sorry, I have tried to  rebase my pull request on top of two weeks worth of commits in master branch and I messed something up, because all these commits were added. I'm closing this request and opening a new one: https://github.com/JetBrains/kotlin/pull/240\nOnce again, sorry for the mess.\n. This is my fault: when working on quickfixes I usually run only \"All IDEA Plugin tests\", but this time it was not enough, because I've modified DescriptorRenderer which is used also in other parts of the code. I'm terribly sorry for this.\nAs far as I can see, the problem is that I've changed whitespaces around colons to be consistent with Kotlin coding convention ( http://confluence.jetbrains.com/display/Kotlin/Coding+Conventions ). I'll gladly fix these errors, but I need guidance which option is the best: \n- keeping these changes and fixing the tests (i.e.: removing whitespaces in some places).\n- dropping these changes (and fixing some IDEA Plugin tests which rely that the code conventions are followed).\n- adding a flag that would determine the DescriptorRender behaviour (spaces before all the colons or only when coding convention requires them).\n. Thanks for your time. It was a really big pull request and I'm sorry you had to go through it several times. I hope next pull requests will be better and shorter :)\n. Thanks for your comments, I like the final code better than the first version :)\n. I've ammended the commit. There still is no support for generics and visibility checking for function arguments, but the basic version is working.\n. At first, I've added the parentheses because this way it's more readable to me. But as I was trying to implement the quickfix I realised that it would be possible to make mistake in this case: change \"(List)\" to \"List<*>\". That's why I left the parentheses in one test case.\n. While I know it's technically not 100% correct and maybe \"Add Function to Superclassifier\" would be a more accurate name for this quickfix I still want to stick with the name \"Add Function to Supertype\". In my opinion the user would be confused by using word \"superclassifier\". I can change the name though if you disagree. \n. I have changed hasDefaultValue to declaresDefaultValue() - I think that is correct (the constructor parameter is named declaresDefaultValue). Besides, hasDefaultValue is computed lazily in hasDefaultValue() and can be null resulting in NullPointerException (which, in fact, it does).\n. ",
    "max-kammerer": "OK\nOn 02/20/2013 09:36 PM, Evgeny Gerashchenko wrote:\n\n\u041f\u043e\u0441\u043c\u043e\u0442\u0440\u0438\u0448\u044c \u043f\u0443\u043b\u043b-\u0440\u0435\u043a\u0432\u0435\u0441\u0442 \u043f\u0440\u043e  \u0444\u043e\u0440\u043c\u0430\u0442\u0442\u0435\u0440?\nOn 20.02.2013, at 21:32, Andrey Ponomarev notifications@github.com\nwrote:\n\nThis option allows formatting 'when' statements in two ways:\noption is OFF:\nwhen (x) { parseInt(s) -> print(\"s encodes x\") else -> print(\"s\ndoes not encode x\") } option is ON:\nwhen (x) { parseInt(s) -> print(\"s encodes x\") else -> print(\"s\ndoes not encode x\") } You can merge this Pull Request by running\ngit pull https://github.com/ponomandr/kotlin format_when_statement\nOr view, comment on, or merge it at:\nhttps://github.com/JetBrains/kotlin/pull/202\nCommit Summary\nRefactoring: build subblocks of JetBlock in one pass New formatter\noption: Align in columns 'case' branches File Changes\nM idea/src/org/jetbrains/jet/plugin/formatter/JetBlock.java (56) M\nidea/src/org/jetbrains/jet/plugin/formatter/JetCodeStyleSettings.java\n(1) M\nidea/src/org/jetbrains/jet/plugin/formatter/JetFormattingModelBuilder.java\n(3) M\nidea/src/org/jetbrains/jet/plugin/formatter/JetLanguageCodeStyleSettingsProvider.java\n(7) M idea/testData/formatter/When.kt (8) M\nidea/testData/formatter/When_after.kt (6) A\nidea/testData/formatter/When_after_inv.kt (8) M\nidea/tests/org/jetbrains/jet/formatter/JetFormatterTest.java (2)\nPatch Links:\nhttps://github.com/JetBrains/kotlin/pull/202.patch\nhttps://github.com/JetBrains/kotlin/pull/202.diff\n\n-- Evgeny Gerashchenko Developer JetBrains, Inc.\nhttp://www.jetbrains.com \"Develop with pleasure!\"\n\u2014 Reply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/202#issuecomment-13845164.\n\n\n\n\nMikhael Bogdanov\nDeveloper\nJetBrains, Inc\nhttp://www.jetbrains.com\n\"Develop with pleasure\"\n. Merged manually. Thank you for contribution!\n. Thank you!\n. Inline annotation is redundant, add 'isInline=false' to 'init' function\n. It's also redundant This annotaion applicable when your function has parameters of Function type. 'Fold' function invocation in 'sum' one will inline its parameters.\n. Pushed manually. Big thanks!\n. Good work!\n. 1. Plugin.xml with intention action definition is missed!\n2. Make test data compilable: add missed declarations\n. Rebase your commits on current master HEAD. Be free to ask if you have any question!\n. There are still a lot of code duplication and non clear logic, it's best to introduce some new util function - total number of function parametes (that will allow you to remove rusbish size checking in several places and make restrictions more clear) and one that returns last function parameter so it allow you to fold two if branches in checkParametersOfFunctionCall and in convertDotQualifiedExpression. \n. It seems that you have made merge instead of rebase and there is about ~4k files in your pull request!\n. Intention code is much better than in previous versions, but\n1. Plugin.xml is missed in new version\n2. All tests still not compilable, e.g.:\nfun foo() {\n    x.forEach(0) { it.bar() }\n}\n3.Throw IllegalArgumentException instead of UnsupportedOperationException one. Also include appropriate JetElement.getText() to exception message.\n. Squash files from last \"Suggested pull request changes applied\" commit with appropriate previous commits and make rebase on current master again\n. Split plugin.xml and squash it with appropriate commits\n. incorrectNumberOfArguments.kt added in first commit and removed in second...why?\n. Move files related to first commit to it don't keep it in second one\n. Support JetBinaryExpression in getFunctionLiteralArgument and checkTotalNumberOfArguments, it allow to make your code more simple. You also can use JetPsiUtil.getCalleeExpressionIfAny() to extract callee function.\n. Add tests for inapplicable intention. For example forEach with several arguments (0 and 2, you will need define it in test).\n. Since forEach could be user defined function with additional logic it also would be best to check not only function name but also it package:\nSubstitute callee is JetSimpleNameExpression && callee.getReferencedName().equals(\"forEach\") check with \n   val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()\n        val resolvedCall = context[BindingContext.RESOLVED_CALL, callee]\n        val functionFqName = if (resolvedCall != null) DescriptorUtils.getFqName(resolvedCall.getResultingDescriptor()) else null;\n\n\"kotlin.forEach\".equals(functionFqName)\n. Yes, i have mean user defined variant for forEach with different numbers of arguments. \nFor formatting add at least tabulation for lines after \"return\"\n. Is it mean that callee is null?\n. 1. The problem was in missing toString on functionFqName:\n   val functionFqName = if (resolvedCall != null) DescriptorUtils.getFqName(resolvedCall.getResultingDescriptor()).TOSTRING() else null;\n. I made rebasing and some patching of your code. It avaliable in 'foreach' branch. But before commit in master i found new bug with transformation of next sample:\nfun foo() {\n    val list = 1..4\n    for (x: Int in list) {\n        x\n    }\n}\nAdd test for ConvertToForEachFunctionCallIntention with empty for body.\n. All is fine except same problem with \"for (i: Int in s) 11\"\n. It seems that it's best to extract variable for \"element.getLoopParameter()!!\"\n. You have code duplication again, it best to extract code generation template to separate function:\nval bodyText = when (body) {\n            is JetBlockExpression ->\n                when {\n                    loopParameter.getTypeReference() != null -> \" (${loopParameter.getText()}) -> ${buildStatements(body.getStatements())}\"\n                    else -> \"${loopParameter.getText()} -> ${buildStatements(body.getStatements())}\"\n                }\n            else ->\n                when {\n                    loopParameter.getTypeReference() != null -> \" (${loopParameter.getText()}) -> ${body.getText()}\"\n                    else -> \"${loopParameter.getText()} -> ${body.getText()}\"\n                }\n        }\nAnd there is should be one additional checking for parenthesizing binary and unary expressions in loopRange cause operator precedence (see 'expressions.grm' file for details) and deparenthesizing on backward operation:\n1. for (i in 1 rangeTo 2) {}\n2. for (i in 1..2) {}\n3. for (i in 1..2 ?: 2..3) { }\nDon't merge new commit to previous one just add another one\n. Thanks! Merged manually. Not misuse with local functions in future  - a lot of them in external one make code less readable. It best to convert them to private members.\n. move ConvertNegatedBooleanSequenceIntention from second commit to first one\n. Transformation for 'if (!(!a || b)) {}' not works. \n. Negation could be defined for not boolean type. In this case it is no possible to remove double negation:\nfun String.not(): Boolean {\n    return isEmpty();\n}\nfun main(args: Array) {\n    val a = false;\n    val b = false;\n    val s = !(!\"\" || b)\n}\nIt's best to keep  \"!${expression.getText()}\"  in all cases.\nI added separate intention for !! removal in tracker\n. And add test for 'if (!(!a || b)) {}' transformation\n. Thanks! Good work! And it seems a last note: when you throw exception with invalid state it's best to add this state (received operator in your case) to exception message! \n\"Invalid operator: ${binaryElement!!.getOperationToken()}. Only expressions using '&&' or '||' can be converted.\"\n. Big thanks! Merged mannualy.\n. It possible to split if (!(!\"\" && b)) {} and get wrong result\n. 1. Make formatting for both intention files - Ctrl+Alt+L.\n2. false and true is JetConstantExpression so you never get \n            JetTokens.TRUE_KEYWORD -> JetTokens.FALSE_KEYWORD.getValue()\n           JetTokens.FALSE_KEYWORD -> JetTokens.TRUE_KEYWORD.getValue()\n3. for last element index use collection.lastIndex not collection.size - 1\n4. use arrayListOf() instead of ArrayList()\n. Thanks! Merged mannually!\n1. \"true\" and \"false\" is JetConstantExpression. So you could add special case for processing it, but not forget to add same logic to revert intention if you will do this optimization.\n2. In future: it's best to use kotlin analog for java collection constructor call: linkedListOf(), arrayListOf()!\n. Thanks!!!\n. Could you merge last commit to previous ones and rebase to current master?\n. remote run says that incremental compilation failed\nhttp://teamcity.jetbrains.com/viewLog.html?buildId=165967&tab=buildResultsDiv&buildTypeId=bt345\n. Source rebased on current master....what is wrong?\n. Seems that was some delta...\n. Thanks, i pushed new rr\n. Thanks!\n. Could you rebase commits on master?\n. Thanks! Merged mannualy.\n. Thanks! Merged mannualy.\n. Big thanks! Merged manually.\n. Vararg and inline cases missed:\n```\nclass Box(val s: T)\ninline fun  calc(z: T): Box {\n    return Box(z)\n}\nfun  run(vararg z: T) {  \n}\nfun main(args: Array) {  \n     calc(-1)\n     run(-1, -1, -1)\n}\n```\n. And super constructor calls:\nopen class Base<T>(val s: T)\nclass Box(): Base<Long>(-1)\n. @mcgee, Could you rebase your commits on current master?\nBoth mentioned cases was fixed in master branch:\nval a = false\nval b = false\nval c = false\nif (!(a && b && c)) {\n    \"then\"\n} else {\n    \"else\"\n}\n and \nif (!(1 < 2)) {\n    val p = 1\n}\n. @mcgee, I just noticed that we already have some additional information about constant expressions: check CompileTimeConstant.Parameters class. Seems 'ReferenceExpressionChecker' could be replaced with 'pure' check\n. @mcgee, yes you are right, 'negateConstantCompare.kt' test is about 'check' and 'goto' instructions optimization. To keep this test you can replace '1' and  '2' with const vals. What about another 3 test?\n. @mcgee, thanks for your pull request. I merged it mannually. I also updated codegen to generate byte and short constants instead of 'ldc' instuctions (they replaced I2B and I2S instuctions in tests): https://github.com/JetBrains/kotlin/commit/384d2ea0d121c57a503d43e9edafe0722d9508af\n. @mikaelpeltier Why do you need 'JVM_TARGET: 1.8' in tests? Seems both tests could be moved to  codegen/box and codegen/bytecodeText. Yes, smth could be broken, but:\n1. I didn't see anything in your test that could do it (and i can't  come up with anything)\n2. we also run common tests with switched default jvm target to 1.8 (see :compiler:codegenTarget8Jvm8Test)\nso, pls move tests. Thanks! Merged manually. Thanks! Merged manually. Thanks! Merged manually. Suggested solution wouldn't work now as is, cause there is some ambiguites in 'not' operator representation:\n1. From one side it's defined in IR symbols:\nfun defineOperator(name: String, returnType: KotlinType, valueParameterTypes: List<KotlinType>): IrSimpleFunction {\n        val operatorDescriptor = IrSimpleBuiltinOperatorDescriptorImpl(packageFragment, Name.identifier(name), returnType)\n        for ((i, valueParameterType) in valueParameterTypes.withIndex()) {\n            operatorDescriptor.addValueParameter(\n                IrBuiltinValueParameterDescriptorImpl(operatorDescriptor, Name.identifier(\"arg$i\"), i, valueParameterType)\n            )\n        }\n        return addStubToPackageFragment(operatorDescriptor)\n    }\n2. but from another side, there is bug in psi2ir that creates new 'not'  symbol from deserialized descriptor regards on symbol in 1: \nval functionSymbol = context.symbolTable.referenceFunction(functionDescriptor.original)\n           val superQualifierSymbol = call.superQualifier?.let { context.symbolTable.referenceClass(it) }\n           val irCall = IrCallImpl(\n               startOffset, endOffset,\n               returnType.toIrType(),\n               functionSymbol,\n               functionDescriptor,\n               origin,\n               superQualifierSymbol\n           ).apply {\n               ....\n           }\n3. 2 symbol expects dispatch receiver but 1 expects value parameters (also bug)\nSo working solution should looks like:\nif (condition is IrCall && (\n                        condition.symbol == classCodegen.context.irBuiltIns.booleanNotSymbol ||\n                                classCodegen.state.intrinsics.getIntrinsic(condition.symbol.descriptor) is Not\n                        )\n            ) {\n                gen(condition.dispatchReceiver ?: condition.getValueArgument(0)!!, data)\n                jumpIfFalse = false\n            }\nNB: New behavior is untested cause  'bytecodeText' test is not yet added to IR-test framework. Yes, i meant bytecode tests. We have such kind test for old backend in 'bytecodeText', to support IR we need to make AbstractIrBytecodeTextTest extending AbstractBytecodeTextTest by AbstractIrBlackBoxInlineCodegenTest analogue. \nFor first execution switch KotlinTestUtils.AUTOMATICALLY_MUTE_FAILED_TESTS for test muting. Let's wait for tests). Many thanks, Mads! Merged manually. Thanks! Merged manually!. Discussed to make separate lowering. @madsager Yeah, i meant exactly this. Will look more precisly on monday. Seems 'isNegation' checking could be shared with ExpressionCodegen: you have done similar logic in previous pr. @madsager It's best to move them to new NegatedExpressionLowering companion, as at some point it would be common.. Thanks!. Thanks Mads! Merged manually. Many Thanks!. Thanks, Mads!. @madsager  your approach is one of possible solution.\nBut maybe best to move COERCION_TO_UNIT inside branches\nBut I'm not sure would it be much more tricky.\nIt's also intresting to mix long and int types in branches, e.g.:\nfun test(arg: Int) {\n    if (arg == 1) {\n        result = \"firstResult\"\n        longValue\n    } else if (arg == 2) {\n        result = \"secondResult\"\n        arg\n    }\n}. @madsager NB: There is also could be a bug in ExpressionCodegen with coercionToUnit processing. @madsager I will merge pr as is, seems we need to perform more investigations to avoid Unit instance generation in branches with further poping them outside of when.\nMany thanks!. @punzki Many thanks!. Thanks!. @ting-yuan Please rebase: #2153 is merged. @ting-yuan https://github.com/JetBrains/kotlin/pull/2111/files#r265006614 is still missed. Thanks!. @madsager Many Thanks!. @ting-yuan Do you plan to support String/Enums in separate pr?. @ting-yuan Many thanks!. @punzki Thanks!. @ting-yuan Why you need this change?. I've merged pr.\nJs tests are generated via another generator - GenerateJsTestsKt,\nso all tests (except JVM_IR) could be annotated with JVM. Thanks. @pyos Great work!. @ting-yuan Many Thanks!. @sfs Many thanks!. @punzki You have several TODOs in codes, it would be best to implement them before this pr would be merged in master (so K/N could migrate to common lower). \nIt also worth to await JVM integration to check correctness at least in one of backend. > I couldn't figure out why, but currently the symbol table contains duplicate symbols for the same class, which seems to be a difference in behavior from K/N. For example, I've seen multiple symbols in the table for kotlin.Int, therefore the array element types wouldn't match.\nYes, we have such problem and @udalov working on it.\nMigration to irTypes looks good, but seems you will get same instance duplication even with irTypes, but AbstractTypeChecker.equalTypes should help (https://upsource.jetbrains.com/kotlin/review/KOTLIN-CR-2795). @punzki Yes, it best to avoid KotlinTypes and Descriptors in new code\n\nMy intention is to make ForLoopsLowering use the properties for non-trivial Progressions. This would greatly simplify the lowering logic at the cost of creating the Progression object. What are your thoughts on this?\n\nYes, it would as same as old backend works (seems you already made investigation in ForLoopGenerator/AbstractForInRangeLoopGenerator/AbstractForInProgressionLoopGenerator hierarchy in old backed).. @punzki Just to clarify your original point\n\n... use the properties for non-trivial Progressions\n\nDid you mean that trivial progression wouldn't be constructed at all?. @punzki If I undertand you correctly, new lower will  simulate logic of old JVM backend. OK!. @sfs Thanks!. @sfs Thanks!. @sfs Could you look at failed test after pr: https://teamcity.jetbrains.com/viewLog.html?buildId=2051455&buildTypeId=Kotlin_dev_Compiler ?. @punzki Please rebase on master: there is conflict after #2153 . @punzki Please split all new/affected tests in more granular files, e.g. if/while/doWhile:\nso negatedNonZeroCompare.kt ->\nnegatedNonZeroCompareInIf.kt\nnegatedNonZeroCompareInWhile.kt\nnegatedNonZeroCompareInDoWhile.kt. @punzki Many Thanks!. @madsager Thanks!. @sfs Please add next test to compiler/testData/codegen/box/multiplatform/defaultArguments\n```\n// !LANGUAGE: +MultiPlatformProjects\n// WITH_RUNTIME\n// FILE: common.kt\nexpect class Foo() {\n    fun member(a: String, b: Int = 0, c: Double? = null): String\n}\n// FILE: jvm.kt\nimport kotlin.test.assertEquals\nactual typealias Foo = Foo2\nclass Foo2 constructor() {\n    fun member(a: String, b: Int = 0, c: Double? = null): String = a + \",\" + b + \",\" + c\n}\nfun box(): String {\n    val foo = Foo()\n    assertEquals(\"OK,0,null\", foo.member(\"OK\"))\n    assertEquals(\"OK,42,null\", foo.member(\"OK\", 42))\n    assertEquals(\"OK,42,3.14\", foo.member(\"OK\", 42, 3.14))\nreturn \"OK\"\n\n}\nand test with typealias to Kotlin annotation. @sfs Thanks! Merged manually!. @pyos there are several failed JS tests (seems mostly unmuted): https://teamcity.jetbrains.com/viewLog.html?buildId=2067446&tab=buildResultsDiv&buildTypeId=Kotlin_dev_Compiler. @pyos Many thanks!. Maybe 'var binaryExpression : JetBinaryExpression? = element' would be best\n. What about Demorgan transformation here?\n. Why you need 'rightChild is PsiErrorElementImpl' check?\n. It case of error first condition will be true: rightChild !is JetPrefixExpression. It would be best to also check other conditions in this block!\n. what about test1, test2 call?\n. SourceTask has \"protected final List<Object> source\" field from version 1.10 (or 1.11)\n. @yole, Maybe there would be best to use String.hashCode() approach? It doesn't require additional volatile field. \nWhat about caching fqnames for descriptors? Will it waste memory?\n. Unused import\n. replace 'println' with if check\n. Combine this method with original one by adding checkPure flag, and create overload with original signature to keep old invocations\n. Why not `param in irFunction.valueParameters`?. It would be cleaner to create new label here. I'm not sure that name is good, maybe 'nameForDestructuredParameter' or smth else. same. ...and same. It's should be possible to find register from 'frame', see 'findLocalIndex' (maybe except 'this' parameter). maybe rename to 'writeParameterInLocalVariableTable'. Move this to ir part and keep old logic for non-irs. It's best to keep old compare logic cause it's allow FileComparisonFailure allows easily update failed testdata. Don't add new line!  Use empty  one before '// 2 3 ....'. Same, don't change line count. Why not compile this with ir backend?. What is purpose for this tricky code?. Use updateConfiguration/extractConfigurationKind to configure ir stuff (rebase is required). Use updateConfiguration/extractConfigurationKind to configure ir stuff (rebase is required). A bit obsolete: see updated origin. In some cases manual changes are required, especially in test for linenumbers and smap. \nIf not removed automatically it will fail again.. It should be redundant after rebase, it's only one compilation now. Is it ir specific? Than please move condition (maybe: fun shouldKeepInheritedLines(...)) to ir part. This method called after function body generation (irFunction.body!!.accept(this, info)). Should we use  markLineNumber(startOffset = FALSE)?.\nexp.accept(this, data).also {\n       (exp as? IrExpression)?.markEndOfStatementIfNeeded()\n}\n. This line is not clear, do we really need it?. Maybe extract whole if (!elseBranch)  branch body to separate method: 'genConditionWithOptimizationsIfPossible()'. Checked expression could have side effects:\ncalcPrimitiveWithSideEffects() != null . pls, don't use println in tests\nit would be best to rewrite it viavar result = \"fail\"\nfun withSideEffect() : Int {\n    result = \"OK\"\n    return 42\n}\nfun box(): String {\n    if (withSideEffect() == null) {\n        return \"fail 1\"\n    }\nif (result != \"OK\") return \"fail 2\"\nresult = \"fail3\"\n\nif (withSideEffect() != null) {\n    return result\n}\n\nreturn \"fail4\"\n\n}\nAnd add same test to box ones. . pls, rename class to JvmBuiltinOptimizationLowering. Maybe best: \n  return if (expression.branches.isEmpty())\n                    IrBlockImpl(expression.startOffset, expression.endOffset, context.irBuiltIns.unitType)\n              else\n                    expression.branches.first().takeIf { it.condition.isTrueConst() }?.result ?: expression\n```. Pls remove this file from pr. Please avoid descriptors in ir lowerings when possible, we are still in process of removing them from ir transformations.\nSeems next code would be equivalent: statement.origin == IrDeclarationOrigin.IR_TEMPORARY_VARIABLE. If I understanding correctly visitBlock/visitGetValue transformations are required to clean redundant bytecode after other transformation in this lower? If true please mention it in code with some examples. ~This is not correct: value  == 0.0 check performed via IEEE754~,\nso 0.0 == - 0.0 (true),\nbut 0.0.equals (-0.0 ) (false). Please also add test for -0.0 and -0.0F. I'm not sure but maybe we need also tests non const vals?. @punzki Thanks, I've filed KT-29691, KT-29692. Pls, replace with 'when'. We have 2 representations for compare and equals operation in IR:\n1 < 1 is binary operation with 2 argument \n1.compareTo(1) - call with dispatch receiver and 1 argument \nMaybe call.receiverAndArgs()  would be worth to use\nSeems this cases are not tested.\nPlease also note that:\n-0.0 < 0.0 calculation is performed in IEEE754 arithmetics and\n-0.0.compareTo(0.0) in non-IEEE754 \nThis affects  registerSymmetricBinaryOp(DOUBLE, opType, \"compareTo\") { a, b -> a.compareTo(b) } same applies for == and equals operation. (Similar with Floats)\nSeems other operations should be equals to each other (+ and plus and so on), but maybe I miss smth @dnpetrov . seems // WITH_RUNTIME directive is required. @punzki LocalNameProvider in LocalDeclarationsLowering is totally wrong concept. It was appeared only for fast bootstrapping. In some future it would be replaced with proper logic similar to one to CodegenAnnotatingVisitor in old backend. \nSeems name related problems will be solved with gettting rid of descriptors (https://upsource.jetbrains.com/kotlin/review/KOTLIN-CR-2697) and totally rewrited KotlinTypeMapper for IR.. It may be a bug in LocalDeclarationLowering, but i'm not sure.\nIn any way maybe it's best to postpone this pr for some time until new typeMapper will be appeared and KOTLIN-CR-2697 merged in master. I'm just starting it. Why you touch this test?. and this?. Please extract test7 to separate test. @madsager seems it's a bug in your optimizer:\nfun box() {\n    val y: String?\n    if (1 == 0) { //no nop and linenumber in bytecode        \n        y = \"123\"\n    }\n    else {\n        y = null\n    }    \n}. @ting-yuan I would prefer to add new tests with suggested changes (for this one and below). And for kt2269.kt \n. @ting-yuan change in concat.kt is still totatly unclear for me, maybe this change is redundant after pr2132.\nFor primitiveToString.kt it would be best to add new test with suggested change. In old backend properties are 'final static synthetic'\nSyntheticness could be specified via IrDeclarationOriginImpl(\"KPROPERTIES_FOR_DELEGATION\", true)\nTODO in such case would be redundant or I miss smth?. JvmAbi.DELEGATED_PROPERTIES_ARRAY_NAME. Please add TODO that visibility should be package local,\nor maybe best switch it temporary to INTERNAL (some inliner test should be passed)  with same TODO. AsmTypes.REFLECTION. Would it simpler to use AsmTypes.PROPERTY_REFERENCE_IMPL/MUTABLE_PROPERTY_REFERENCE_IMPL ?. Property references should not be processed as delegated ones: anonymous class for them should be generated in CallableReferenceLowering.kt to support non-reflective get/set/invoke. It's more tricky than I though:\nJvmClassName.byInternalName(AsmTypes.REFLECTION).fqNameForClassNameWithoutDollars. Do you mean this case:\n```\nval z by lazy  { 1 } // delegatedProperties\nfun main() {\n    z // delegatedProperties\n    ::z.get()     //new anonymous class  should be generated\n}\n``` \n?. > Of course, calling get/set on a KProperty passed to getValue/setValue is of rather limited usefulness, so the performance of that might not matter, but still.\nYes, it's useless (and in most case will produce SOE)\nReflection here is used to avoid a lot of anonymous class generation.\nPlease also note that there are two strategy for local delegated properties: \n```\nobject O {\n    operator fun getValue(a: Any?, b: Any?): String = \"OK\"\n}\nfun noInline() {\n    val z by O //same as z$delegate.getValue(this, ::z)\n}\ninline fun InlineFoo() {\n    val b by O // after inline access to $$delegatedProperties in most cases are lost so anonymous object as for general CallableReference is generated\n}\n. Maybe:\n(if (mutable) mutableProperties else properties)[needReceivers - boundReceivers]\n. @punzki Old codegen also checks range inerval:\nif (rangeLength > 2L * labelsNumber || rangeLength > Int.MAX_VALUE) \nPlease move this code to old codegen companion and reuse here. @punzki Sorry!. @ting-yuan Please name variable properly: 'true' condition could also be in non-else. Don't use print in tests. @dnpetrov Shoudn't we use IF origin  for irBranches.size > 1 below:\nval irWhen = IrWhenImpl(ktIf.startOffsetSkippingComments, ktIf.endOffset, resultType, IrStatementOrigin.WHEN)\n```\n@ting-yuan Please also add next test:\n```\nfun cond() = false\nfun bar() {}\nfun foo() {\n    if (cond()) {\n        bar()\n    } else if (true) {\n        bar()\n    } else {\n        bar()\n    }\n}\n// 1 LINENUMBER 6\n// 1 LINENUMBER 8\n. Similiar tests with 'false' would be also appreciated. Please use data classes here .... and here. Please avoid descriptor usage: we are getting rid them from lowers and codegen. Now only one receiver is supported: dispatch or extension and presented one passed to superconstuctor call. Reuse 'receiver' from base class. I would prefer to patch KotliTypeMapper.internalNameForPackageMemberOwner\nif (isIrBackend && directMember is IrPropertyDelegateDescriptor) {\n                return internalNameForPackageMemberOwner(directMember.correspondingProperty, publicFacade, isIrBackend)\n            }\n```\nWith some time there would be IR-specific KotliTypeMapper without any hacks. Maybe it's best to extract const's to separate object:\nclass IrBuiltIns {\n   .....\n    object OperatorNames {\n        const val LESS = \"less\"\n       ....\n     }\n}\ncc @udalov . private. private. private. private. @ting-yuan Please remove also OPERATOR_NAME prefixes (it wasn't clearly mentioned but presented in suggested example in https://github.com/JetBrains/kotlin/pull/2111/files#r264669713). Please add box test for this case similar to original one in compiler/testData/codegen/box/when/stringOptimization/duplicatingItemsSameHashCode.kt. Is LOOKUPSWITCH is absent cause of hashAndSwitchLabels.size <= 2 condition?. @sfs Seems this is redundant. @sfs areCompatibleCallables asumes platformModule in parameter list, but here commonModule is passed.\nCould you explain in mode details why default parameter is wrong for typeAliases?. @sfs Seems here some misunderstooding: platformModule always contains expect declarations, common only common/expect ones. \nThere is only one platform module (common one is merged in platform //@udalov) in 'annotationsViaActualTypeAliasFromBinary' test. @sfs \n\ncommonModule to actual.module, right?\n\nYes, and it's same as default  parameter\nTest is a bit tricky: there is module for java annotation which is used as dependency for kotlin module. And this kotlin module is actually a platform module not common!. Missed. Please also add box test for such case. Please avoid descriptor usage:\nit.owner.name.asString() == \"not\". val rangeLength = caseMax.toLong() - caseMin.toLong() + 1L\nIt would be best to also add some test for overflow case\n. I would prefer to explicitly clarify here that gen works only if there are enough cases\ngen -> genOptimizedIfEnoughCases (not sure that new name couldn't be better)?. Branches seem identical except return value: maybe merge then with explicit cast for cases in each constructor. Please use data class instead of Pair. Please add box test for integers (if it's not present). Avoid Pair usage (it's not trivial to read code with pairs below). Could  be extracted to precondition check and called within base class. mapImplementationOwner: $$delegatedProperties are always located in DefaultImpls, not in interface. Maybe best to move this lowering after LocalDeclarationsLowering?. Maybe best\nreturn when {\n            areConstIntComparisons(calls) ->\n                IntSwitch(\n                    subject,\n                    defaultLabel,\n                    endLabel,\n                    elseExpression,\n                    expressionToLabels,\n                    cases\n                )\n            areConstStringComparisons(calls) ->\n                StringSwitch(\n                    subject,\n                    defaultLabel,\n                    endLabel,\n                    elseExpression,\n                    expressionToLabels,\n                    cases\n                )\n            else -> null // TODO: Enum, etc.\n        }?.genOptimizedIfEnoughCases(). Please add comment to this heuristic (seems it was lost). @pyos Even with mapImplementationOwner $$delegatedProperties are located and initialized in interface not interface DefaultImpl. Moving this phase after 'interfacePhase' should help, but could you add some clarification about java field problem?. @ting-yuan Please add box tests for  comparisonFalse/comparisonTrue\n. @pyos Oh, so could you add several TODOs: about location of $$delegatedProperties and it's visibility and I will merge pr. ",
    "ponomandr": "Since you are the author of the code, can I ask you something?\norg.jetbrains.jet.plugin.formatter.JetBlock#getAlignmentForChildInParenthesis\ncontains this code:\n``` Java\n    ASTNode prev = getPrevWithoutWhitespace(node);\n    if ((prev != null && prev.getElementType() == TokenType.ERROR_ELEMENT) || childNodeType == TokenType.ERROR_ELEMENT) {\n        return parameterAlignment;\n    }\n```\nIt looks like ASTAlignmentStrategy was added solely to have this if statement.\nWhat is the purpose of this fragment?\n. The same format is used in all converter tests. If I change formatting, the test will fail.\n. This one cannot be fixed too.\n. ",
    "Spasi": "Hey Svetlana and thanks for the input.\nThe new commit reverts the ed491cc changes and restores the variablesInScope hashset. It also introduces a variableInitializers field in which the result of getVariableInitializers() is cached.\nI'm not sure if you can merge this in a clean way (only PseudocodeVariablesData changes in the end). Let me know and I'll make a new pull request if necessary.\n. +1 for <in K, out V>.\n. ",
    "saltnlight5": "Hello Geevee,\nWhat do you mean by \"better if you switched back to version with default value, but with String parameter type instead of String?\"? The patch I give is using String and not \"String?\", which is the point of the fix. I already provided a extra overloaded method for default platform charset version, so I am not sure what are you asking here. Can you be more specific?\nYes, I forgot to set my git user.name in my local machine, and hence the author is messed up. I will see in future to set it correctly.\n. Ahh, I see what you mean now. Yes, I need to get used to default param feature more. :) \nI will pick the String version with default value and generate another pull request later.\n. Cool, I see how the annotation xml is updated to minize !! usage. Things look good. Glad this works out.\n. ",
    "orangy": "Is it merged? Should we close http://youtrack.jetbrains.com/issue/KT-3533?\n. What are use cases for such a feature? \n. The patch itself looks fine, however we are in process of updating some code generators in the library and thus waiting to integrate it first into master branch, and then we'll get this patch onboard as well. Probably not exactly as authored, cause most of the code (esp for primitive arrays) should be generated as well.\n. I will be manually merging code into generators in few days, but I'd like to see some tests as well. Thanks.\n. Merged manually into rr/stdlib\n. Will review and integrate soon, when we finish merging new stdlib into master. Thank you!\n. Merged manually, thanks.\n. rr/stdlib merged, closing.\n. rr/stdlib merged and this function is there\n. I think I explained why ScriptName should return FqName, do you mean to update return value and/or function name?\n. Merged into master, fixed.\n. Merged manually and released in M9.\n. Reviewed by @geevee \n. Ok. But... It's incorrect to modify generated file. I can merge it manually later when I have another branch for stdlib collections, or you can modify generator and regenerate code, and update PR. Thanks!\n. I believe sortDescending should also be updated. \n. Great, will merge tomorrow. Too late here for a serious work :)\n. It would be nice to have tests for this specific case being fixed.\n. Merged manually into branch rr/stdlib/fixes.\n. Reviewing pull request and preparing to merge. We think that \"walks\" part is still too complex and not entirely idiomatic to Kotlin. I think we have an idea on improvement. Will implement it and merge.\n. Thinking more about it, shouldn't we have asList() instead? It will cover asIterable() cases, and will trigger performance checks when appropriate \u2013\u00a0size is known and indexed access available.\n. Working on integrating it into master. I will squash some commits and resolve issues in other pull request and then merge.\n. Fixed issues, moved asList to JVM-specific place, updated tests, merged manually.\n. Working on integrating the pull request. It's not possible right away, because it causes ambiguity between plus() and plusAssign() on mutable maps. We will update compiler to resolve ambiguity and then merge.\n. Fixed issues, added overloads, merged manually.\n. JetBrains doesn't maintain Discord and no official support for it is planned. Please don't submit any more PRs to our public pages. The badge you use cannot be accepted since it is not our official resource. . Do not use first/last properties, they will be removed. Use first()/last() methods.\n. typo: functin \n. Shouldn't it return File instead?\n. Name of the function is not very good. First, it can be perceived if \"path\" contains \"name\", not contents of the folder. Second, it will fit \"in\" by convention, and while if (\"build.gradle\" in folder) looks nice, for the overload with predicate it is a little bit strange. Consider using a different name.\n. I don't really like global functions in stdlib, until absolutely necessary. They pollute global namespace, since they are in the kotlin package. Consider creating object to group them into. \n. Referencing Java in such a way doesn't make it look like a standard library for a language, which is targeting different platforms. E.g. for JS it may be different contract.\n. Expand \"null-safe call\". I would read it as \"a?.equals(b)\" which is wrong, because expression type for == is Boolean, not Boolean?\n. Same note about Java-ism.\n. We usually call it \"index operator\", I think, not \"brackets notation\".\n. bad example, \"val\" is keyword. \n. Same here for \"brackets\" and \"val\"\n. \"Returns number of elements in the array\". Method called \"size\" shouldn't be described with word \"length\"\n. Not necessary \"in a collection\". \n. Do we need overrides here?\n. Will it affect what is returned next? Unclear from the text. What if previous was called?\n. Link to Any.equals() on \"equal\" would be good, to refer to explanation of equality.\n. There are more use-cases for Nothing, e.g. Iterable is ok to exist, but it will never enter \"for\" loop, etc. Needs link to lang docs.\n. \"When processing data class, compiler will generate\"...\n. Typo: \"annotates as [inline]\" -> \"annotated as [inline]\"\n. Add cross-reference to other annotations, like noinline\n. Link to downTo method.\n. start \"a progression\", end \"the progression\"\n. Should it be @throws tag instead?\n. May be replace null with null?\n. Back-tick quote \"null\"?\n. null -> null\n. if if\n. copypasta: Array is not a string\n. \"the first characters\", do not need \"the\"\n. Linkify postfix\n. Ideally trucated should default to \"\u2026\", not \"...\"\n. Warning, using this class has performance penalty compared to plain raw implementation per case, measured with JMH when operation per element is relatively cheap.\n. \"Creates Iterator<T> for an Enumeration<T>\"\n. \"ranged for-loop\" -> \"for loop\"\n. initial -> given as in the function above\n. specify, that it behaves as sequential put calls, so that if conflicting keys exist in source sequence, last one wins.\n. \"Returns the key component of the map entry\"\n. \"Returns the value component of the map entry\"\n. This doc uses first/second component, while doc for mapOf/hashMapOf/\u2026 uses first/second value. Should use the same word.\n. \"Puts given values\", and again value vs component for Pair.\n. \"Puts elements of the given collection\"\n. \"[destination] mutable map.\", looks confusing a bit.\n. Returns a new map\n. Returns a new map\n. Documentation is backwards. Normally it reads \"Returns a \u2026 if \u2026, otherwise \u2026\"\n. \"brackets notation\" -> \"index operator\"\n. \"Replaces\", \"of the string\"\n. Somewhere I saw you called it \"semaphore\", and here calling \"monitor\"\n. Runs -> Calls?\n. Missing @param for type parameters.\n. Linkify LinkedList\n. Returns an IntRange specifying the valid... \n. calculation -> action\n. Need to put it in conventions, wording around documenting parameter with default value.\n. self -> this Writer\n. self -> this Reader\n. \"can be modified async\" is strange wording. Even if field is not volatile, you still can modify it async by concurrent threads, but effect may be different. Need better description.\n. backtickify value, linkify StringBuilder\n. doc for T?\n. size is a little bit unclear, may be \"number of key-value\" pairs? \n. May contain duplicate values\n. Comparing byte with char for ordering probably requires more description about what it really means.\n. \"Adds the other value to this value.\"\nlike in minus\n. Multiplies this value by the other value.\n. We don't have other overloads for rangeTo, like in other types?\n. As a name?\n. \"argument\", no \"s\"\n. There are no arguments, so just \"Invokes the function\"\n. no arguments\n. plural use for 1\n. \"this lambda\" is unclear, may be \"options for annotated functional parameter\"?\n. typo \"returnsn\"\n. Returns\n. \"Allows you\" - not good for docs.\n. Allows you.\n. Shouldn't we update usages in this file to invoke TimerTask constructor directly?\n. charsetName parameter missing\n. charset parameter missing\n. I think non-JVM scripts is what we should anticipate. Kotlin/Native specifically. So dependencies infra should be flexible enough, e.g. no javaHome & classpath, but instead may be native libs. Native scripting is also potentially used in game dev, like Lua. . ",
    "chocolateboy": "Thanks for your comments. I've merged those changes into #276.\n. Isn't this covered already by #266?\n. ",
    "snrostov": "Looks like my commit breaks everything other with typing \"}\" or \"{\". E.g: extra \"} inserted after fun test(){\" and hit enter, and mach more... Sorry :( I'm going to fix it\n. In this example\nfun test() {\n    \"$<caret>something\"\n}\ntyping \"{\" does not insert \"}\", because \"}\" in the last line of source will be treated as pair for \"${\" (see method handleAfterLParen in /com/intellij/codeInsight/editorActions/TypedHandler.class for details)\n. ",
    "kareez": "Hi, Do you want me to close this request and submit another one ? \n. @shalupov the repository permission is granted to \"shalupov.jetbrains\"\nhttps://issues.sonatype.org/browse/OSSRH-6556?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel&focusedCommentId=195160#comment-195160\n. @shalupov \n- In order to publish the artifacts, you should either release and deploy them directly into sonatype repository or install them in your local repository and then upload  it to sonatype repository. Since you have your own internal repository,  first option is not the case here. so you must release them in your internal repository, or local repository and then upload them into sonatype's one.\n- since \"kotlin-compiler\" is not maven artifact, I needed to convert its normal jar file to maven artifact before uploading it. that's way \"maven-install-plugin\" is there. \n- In order to deploy the artifacts into sonatype repo, they MUST have sources and javadoc bundle. even if they don't have javadoc or source bundle, you must attach a fake one.\n-   I was told by Andrey Breslav, that everything in \"kotlin/libraries/tools\" must be available in central repository. \n- I have submitted the transfer request and I believe will be done by next Monday. you can follow up the process here: https://issues.sonatype.org/browse/OSSRH-6556#comment-195117\n- here is the sample shell script that i'm using to install artifacts into sonatype repository. i thought it may be useful. good luck with it.\n```\n###### You DO NOT need to change this section\nMaven GPG plugin to sign and deploy artifacts\nGPG_CMD=gpg:sign-and-deploy-file\nSonatype repository url\nREP_URL=\"https://oss.sonatype.org/service/local/staging/deploy/maven2/\"\nSonatype repository id\nREP_ID=\"sonatype-nexus-staging\"\n###### You need to change varialbes in ths sction\nMaven command (path + command name)\nMVN=$MVN_HOME/bin/mvn\nMaven local repository (must contains the released artifact that we want to deploy)\nMVN_REPO=/opt/m3-repo/org/jetbrains/kotlin\nList of all jar modules that need to be deployed\nJARS=(\"kdoc\" \"kdoc-maven-plugin\" \"kotlin-compiler\" \"kotlin-gradle-plugin\" \"kotlin-gradle-plugin-core\" \"kotlin-js-library\" \"kotlin-js-tests\" \"kotlin-js-tests-junit\" \"kotlin-maven-plugin\" \"kotlin-stdlib\" \"kotlin-stdlib-gen\" \"kotlin-runtime\")\nList of all pom modules that need to be deployd (the artifact packaging must be pom)\nPOMS=(\"kotlin-project\")\nArtifacts versoin (including poms and jars)\nVERSION=\"0.0.2-test-deploy\"\n###### You DO NOT need to change this section\nfor pom in ${POMS[*]} \ndo\n    printf \"[SCRIPT-INFO] Preparing [POM] artifact for sign and deploy....... %s\\n\" $artifact\nrm -rf ./$pom\ncp -r $MVN_REPO/$pom/$VERSION ./$pom\n\nfilename=$pom/$pom-$VERSION\n\nprintf \"[SCRIPT-INFO] Deploying [POM] file for artifact....... %s\\n\" $pom\n$MVN $GPG_CMD -Durl=$REP_URL -DrepositoryId=$REP_ID -DpomFile=$filename.pom -Dfile=$filename.pom\n\ndone\nfor jar in ${JARS[*]} \ndo\n    printf \"[SCRIPT-INFO] Preparing [JAR] artifact for sign and deploy....... %s\\n\" $jar\nrm -rf ./$jar\ncp -r $MVN_REPO/$jar/$VERSION ./$jar\n\nfilename=$jar/$jar-$VERSION\n\n# If sources are not available, create a fake sources.jar file\nif [ ! -f ./$filename-sources.jar ]\nthen cp ./fake.jar ./$filename-sources.jar   \nfi\n\n# If javadocs are not available, create a fake javadoc.jar file\nif [ ! -f ./$filename-javadoc.jar ]\nthen cp ./fake.jar ./$filename-javadoc.jar   \nfi\n\nprintf \"[SCRIPT-INFO] Deploying [BINARY] for [JAR] artifact....... %s\\n\" $jar\n$MVN $GPG_CMD -Durl=$REP_URL -DrepositoryId=$REP_ID -DpomFile=$filename.pom -Dfile=$filename.jar\n\nprintf \"[SCRIPT-INFO] Deploying [SOURCE] for artifact....... %s\\n\" $jar\n$MVN $GPG_CMD -Durl=$REP_URL -DrepositoryId=$REP_ID -DpomFile=$filename.pom -Dfile=$filename-sources.jar -Dclassifier=sources\n\nprintf \"[SCRIPT-INFO] Deploying [JAVADOC] for artifact....... %s\\n\" $jar\n$MVN $GPG_CMD -Durl=$REP_URL -DrepositoryId=$REP_ID -DpomFile=$filename.pom -Dfile=$filename-javadoc.jar -Dclassifier=javadoc\n\ndone\n```\n. @NataliaUkhorskaya  thanks for the feedback. I'll submit another pull request. \n. @NataliaUkhorskaya  submitted the new pull request, please have a look: https://github.com/JetBrains/kotlin/pull/301\n. @NataliaUkhorskaya / @udalov, \nI've merged all previous commits and updated the code based on your last feedback.\n. I'll submit a new pull request.\n. @udalov thanks.\n. Some functions (e.g. map, flatMap, ...) are missing in Iterables.  I found that these functions were available previously but because of the changes in http://youtrack.jetbrains.com/issue/KT-3373, they have been removed (i believe mistakenly). \nIn order to add back those functions and avoid reproducing KT-3373, I've separated all functions in following groups:\n- Commons: common functions for  Iterables, Iterators and Arrays\n- Iterables:  these functions are specific for iterables and Arrays.\n- Iterators: these functions are specific for iterators.\n- Collection: collection related functions (so far only one).\ncode generator generates following files:\nIterators.kt  :   all functions from _commons and iterators\nIterables.kt :   all functions from _commons and  iterables\nArrays.kt    :   _commons + iterables\n<Primitive>Arrays.kt: _commons + iterables  (for each primitive type)\nCollections.kt : _collections  (All functions in Iterables will be inherited by collections).\n. Updated the pull request, using suggested \"for loop\". \n. \"Int.times\" has been deprecated and this functionality now is available in \"repeat\"function.\n. ",
    "apatrida": "Hello, that file was added on accident to the commit.  I had started to look at compiler codegen test and also searching for annotation test, but realized it was redundant since other annotation finding and calling tests were already well in place and testing for this case wasn't adding any value.\n. The interfaces in ReplApi.kt are broken into parts because I was trying to limit what functionality had to be present for things like remote daemon REPL compiler.  They might be able to be combined back into fewer but currently act as a list of small Traits each part can implement in part.   . Maybe after 1.1 we can look at ReplInterpreter.kt and unifying it with using the Generic* classes\n. ",
    "dukeboard": "Ok for adding tests , where is the right place in your repository ?\n. ",
    "asuhan": "I've pushed the copy function generation as well. Inner classes appear not to work properly with the JS backend, so auto-generating copy functions for nested classes seems a moot point as of now and I left it out.\n. Regarding common logic between JVM and JS, there's some logical overlap, but I hesitated to do it since the functionality which can be factored out didn\u2019t look generally useful and it\u2019s rather small. I\u2019ll see what I can do about it, code duplication is annoying indeed.\n. Most comments addressed, all tests pass, ready for another round of review. \n. @bashor: I guess I'll take care of them as well. There seems to be some kind of toString support in the Kotlin JS runtime, but needs some improvement. Also, hashCode should go in the runtime as well. I don't think further changes to the JS backend will be needed to support them, they can either go in another PR or I can piggy-back them to this one -- doesn't really matter to me. Depending on my schedule, I might be able to get them done tomorrow.\n. New pull request: https://github.com/JetBrains/kotlin/pull/321.\n. I'm pretty much done with hashCode, check this commit: 09c2dd9e8b. We'll use that branch for review and I'll cherry pick to this one. I was hoping that hashCode & friends can be done via object reflection, but it wasn't the case. I ended up generating a strongly-typed, inline hashCode. It works pretty well -- seems to handle overloading properly and it's somewhat consistent with the JVM backend as well. We'll probably need some unique id per object created if we want something similar to JVM's Object.hashCode(), other than that works just fine -- well, sort of, JavaScript chokes with big integers since all the numbers are floating point and rounding errors are killing us.\nI've noticed two problems which might be serious, though -- and I'm not sure they can be easily fixed using the current approach (which is mostly source-to-source, style preserving). Or it might be the way I'm declaring hashCode in core.kt, I'm not sure I'm doing the right thing there.\n1. Overloading of hashCode might be problematic. I like to think I've successfully worked around by doing some delegation / black magic through Kotlin.hashCode -- check the diff for more details. I'm curious whether we have better options for handling overloading with synthetic functions which don't have descriptors -- even if it works for hashCode seems more by accident than by design.\n2. I'm not sure how we could properly handle hashCode on numeric literals. If we stick with using JavaScript primitives, there has to be a way for binding to different Kotlin.hashCode functions for statically known types, at runtime it's too late to know whether the original parameter was a float, a double, an integer etc. Or we could use a richer representation (JavaScript objects) for Kotlin primitives.\n. Seems like my patch has some trouble with overloading indeed. Consider this test:\n``` kotlin\npackage foo\nopen data class Base(val x: Int)\nopen data class Derived : Base(1) {\n  open fun hashCode() = 2\n}\nfun makeInstance(x: Int) : Base {\n  if (x % 2 == 0)\n    return Base(x)\n  return Derived()\n}\nfun box() : String {\n  val b = makeInstance(1)\n  if (b.hashCode() != 2) {\n    return \"fail\"\n  }\n  return \"OK\"\n}\n```\nhashCode$DataClassAutogen is inherited through the prototype by Derived, thus Kotlin.hashCode will dispatch to it -- breaking the dynamic binding semantics. With a bit of JS acrobatics and a bunch of hacks I can probably get it right, but it doesn't sound maintainable nor reasonable. Ideally, frontend (lang.resolve) should handle this and also do the renaming for overloads based on arity -- as long as the function descriptor is generated, which is not the case for hashCode, toString and equals. I could change the frontend to do this but it has implications for the JVM backend as well, so I'd rather go for a more localized change. Any advice?\n. Yup, I have the full history and I can squash it at different granularities / rebase from different points. Also, feel free to merge the other pull request (#321) first and this one will get smaller. Take your time reviewing it, there's no rush. Most likely I'll split this pull request to be #321 + preparation + hashCode, toString, equals.\n. I think I've addressed all the comments, except for the open questions.\n. Regarding hashDoubleImpl and hashFloatImpl, if we agree that unconditionally using hashLongImpl for all numbers is the way to go (since it's at least consistent), they'll simply vanish.\n. I agree with merging all the numeric hashes for the previously discussed consistency reasons. Removing the callback for the array hash code is fine with me, although I like it better the way it's now -- since the array is typed in Kotlin, why not making this explicit in the JS backend and rely less on runtime magic? Same thing with hashNullableImpl -- not really needed, but less flexibility (not allowing null except for things which are nullable in Kotlin) can help catching bugs.\n. Array<T?> vs Array<T> -- in the first case, it's fine to check whether the current element is null when computing the hash for the entire array (which would be zero), in the second case hitting a null is a logical error. The hash implementation for T shouldn't silently fail to zero and maybe hide a bug in the back-end.\n. What if one of the fields of a data class object is Int?? If numberHashCode should throw for null, having a wrapper for nullable numbers makes sense and hashNullableImpl is that wrapper.\n. I'd rather not guess about performance -- unless we have some way of measuring it's not a factor in my opinion, as long as we're not doing clearly outrageous things. Also, the complexity moves from plain sight (the JS runtime library) to the code generator -- why do you think it's simpler? \n. @bashor: Calls to toString, hashCode and equals are compiled as direct calls when possible. What do you mean by this comment? Also, I've quickly hacked yesterday the auto-boxing I was talking about (when needed, that is only when Byte | Int | Short | Long | Float | Double are converted to Any or Number), which will make all those builtins unnecessary and allows different behavior for hashCode and equals depending on the number type, just like the JVM backend. But I don't think it's a good idea to bundle it together with this PR as well.\n. Ok, one of my previous attempts did compile to direct calls when possible, but I think it was the one with delegation. So it's entirely possible that this behavior is due to the renaming I've done to avoid the delegation. Unless you've spotted something wrong with the way I'm using the front-end, I can't address this comment.\n. I agree, I've already said above that the synthetic functions logic happens after the front-end is already done, thus the resolver doesn't have an opportunity to bind them directly. This can be fixed in a few ways, none of which belong to this pull request. Note that for copy and component function this issue doesn't exist, because the front-end generates the descriptors for them, so the binding itself works, it's just missing references before my patch.\n. ",
    "chashnikov": "Maybe 'sum' of Bytes and Shorts should return 'Int' to be consistent with '+', what do you think?\n. It appears that we cannot have methods 'Iterable.sum():Int' and 'Iterable.sum():Int'. Kotlin compiles them fine but they have the same signature in class-file so the code will fail at runtime with ClassFormatError. Can I somehow instruct Kotlin compiler to rename a function in class-file? I don't want to rename these functions to sumOfBytes and sumOfShorts.\n. max-kammerer, could you please clarify why 'inline' is redundant here? 'makeString' function has similar functionality and it's marked as 'inline'.\n. Ok, I've removed 'inline' annotations and changed return type to Int for arrays of Byte and Short skipping methods for Iterable and Iterable for now.\n. Oops, I'd just committed fix for formatting issues and then saw that you fixed them yourself. Thank you!\nP.S. I'm used to spaces being insert automatically by 'Complete Statement' action.\n. It appears that 'Complete statement' (SmartEnterProcessor) isn't implemented in Kotlin at all, and we already have issue about that: http://youtrack.jetbrains.com/issue/KT-3600.\n. I think we can mark http://youtrack.jetbrains.com/issue/KT-3714 as fixed now.\n. It seems to be ok for Iterable but the same code for Array and primitive arrays should be written using index-based iteration to avoid unnecessary overhead of creating the iterator. I can rewrite them accordingly if you think that it's worth it.\n. Ok, I've changed implementation to avoid unnecessary null checks.\n. I think that if argument of 'put' method isn't assignable to K it usually indicates an error. IDEA even shows warnings in such cases. So I think that get() and containsKey() should take 'K' as an argument and Map should be contra-variant by the first type parameter. It seems to be natural to have same variance for Map and for function type (K) -> V.\n. It also make sense to add test for arrays of primitives to ArraysJVMTest.kt.\n. Merged. Thank you for contribution!\n. Merged manually with cosmetic improvements, thank you for contribution.\n. No, it's just a refactoring.\nOn Dec 29, 2014 11:28 AM, \"Andrey Breslav\" notifications@github.com wrote:\n\nIs it important to merge this PR very soon? If not, we'll wit until\n@geevee https://github.com/geevee is back from his vacation\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/538#issuecomment-68246516.\n. Merged to 'master'.\n. We usually don't add space before colon in parameters list\n. Why do you need to handle 'item==null' case separately? '==' operator works properly with nulls.\n. size-1 can be replaced by lastIndex.\n. Value of 'Boolean' type cannot be 'null' in Kotlin.\n. \n",
    "voddan": "I'm afraid I miss your point. Please, spell it out.\nI don't think this change can damage any code, bacause Iterable<> requied ONLY iterator():\nkotlin\npublic trait Iterable<out T> {\n    public fun iterator() : Iterator<T>\n}\nThank you for further explanations.\n. I still do not understand the problem, but I believe you there is an issue inside JVM.\nThen can  we change at least Array<T>: Iterable<T> ? It seems to be safe and it will shorten my code by half.\n. I am sorry for this strange commit.\nI'd like to merge only a few chenges in \n  /libraries/stdlib/src/kotlin/Arrays.kt\n  /libraries/stdlib/src/kotlin/Strings.kt\n  /libraries/stdlib/src/kotlin/Lists.kt\n  /libraries/stdlib/src/kotlin/Maps.kt\n. How do I merge all recent changes localy befor a merge request?\nI use IDEA CE\n. Is everything ok with this patch?\nI believe there could be some issues about naming and testing, but please - do not take it wrong, because it is my first patch to kotlin.\nSo I am happy to improve anything related to this patch.\nJust contact me via a comment here.\n. Ok, I see\n. new pull request with new branch was created: pull #405 \n. I have no idea how I've managed to grub this commit:\nFix for \"NoSuchFieldError: this$0$inlined\"\nI'm sorry about that.\nInteractive rabase can not be lunched.\nMerging gets an error.\n. Thank you, @geevee!\nIt works now! Cool!\nEnjoy the shortened list of commits.\nI've done the rebasing, and the commit messages are not accurate.\n. Yes, some commits are duplicated, but all files are ok at the end.\nShell I keep improving the commit history, or it's good enough?\n. see #412 \n. cool, thank you!\n. Ha, we commited for the same issue!\nI like your implementation more, but I believe that Array.contains(item: Any?) is better, because it  acts like List.contains(o: Any?) from Java.\nOf course, for primitive arrays it is ok.\n. I purpose resolving some of the functionality of https://youtrack.jetbrains.com/issue/KT-8286 together with this PR\nOne part of KT-8286 is providing String.toInt() with an optional parameter String.toInt(radix=10). This is very easy to add in this PR since it affects those functions. More other, some functions in this PR (String.toIntOrNull() and String.toLongOrNull()) were not made inline, which would be an obstacle for adding an additional functional parameter to them later due to binary compatibility.\nI can \na) add a commit to this PR with the changes described above\nb) create a new PR after that one is closed and implement the functionality there \n. this two commits add DSL for the tests, streamlining the code. I hope they don't add too much extra mental load\n. @ilya-g by mental load I meant the whole DSL thing.\n. @ilya-g What about the radix versions from KT-8286?\n. @ilya-g updated the Kotlin version annotation. Funny thing is I had to learn half of the Kotlin compiler before I found the simpler solution. Took me long enough \ud83d\ude04 . BTW, the build process for the project is just horrible. \nI spent a day and a half in the beginning before I could compile tests without issues. Even worse, IDE stoped compiling after I rebased to the current master. Deleting the folder and downloading everything from scratch did not help. \nPlease do something about it. Migrating everything to a proper Maven project could definitely help.. Glad to hear that! \nPlease also migrate the downloading of the dependancies, as well as the build targets \ud83d\ude4f  Updating dependancies was a nightmare over unstable internet, I had to hack the script and download archives by hand. Build targets, dependent on the IJ configuration, is a very unstable solution. The ide is not really up to reconstructing builds.. will fix, thank you\n. ",
    "tryge": "I uncommitted the unnecessary changes. I'm used to cleaning up the code as I go, but of course it makes the commit more understandable if only the relevant parts are in the commit.\n. ",
    "valentinkip": "I also always disliked get() and containsKey() accepting Object. This is opens possibilities for errors and also prevents smart IDE features from working (smart completion).\nIt's a pitty that making them to accept K make Map not covariant by its first type parameter. This does not seem to be natural too.\n. I have integrated it and will merge it into master soon. Unfortunately you added 2 more commits later. I integrated the first one but dropped the last one as it was difficult to merge it with my changes.\n. @semoro The code which it fixes was rewritten completely. And the test data files changed too. Most likely the bugfix has already been done by my changes.\n. Changes have been pushed into master (rebased onto the head).\n. @cypressious comments can be easily lost. Anyway it makes sense to refactor the code to have one implementation of this feature.\n. ",
    "jrenner": "regarding the null check, please see this discussion:\nhttps://github.com/JetBrains/kotlin/pull/331#discussion_r8562482\nIt is not my optimization, but based on the java implementation\n. I rebased into one clean commit (actually that was my original intention).\nIs this satisfactory, or would two separate commits be better?\n. moved readme changes to its own PR\n. Return value is no longer nullable\n. Is this the proper way to implement this? I was under the impression that it should be implemented through builtins like the following in idea/builtinsSrc/jet/Char.kt:\n``` kotlin\npackage jet\npublic class Char private () : Hashable, Comparable {\n    public fun compareTo(other : Double) : Int\n    public fun compareTo(other : Float)  : Int\n    public fun compareTo(other : Long)    : Int\n    public fun compareTo(other : Int)    : Int\n    public fun compareTo(other : Short)  : Int\n    public override fun compareTo(other : Char)  : Int\n    public fun compareTo(other : Byte)   : Int\npublic fun plus(other : Double) : Double\npublic fun plus(other : Float)  : Float\npublic fun plus(other : Long)   : Long\npublic fun plus(other : Int)    : Int\npublic fun plus(other : Short)  : Int\npublic fun plus(other : Byte)   : Int\n//  public fun plus(other : Char)   : Int\n\n```\nalthough I am confused about the issue as you can see here:\nhttp://devnet.jetbrains.com/thread/451783?tstart=0\n. What a coincidence! only an hour apart, too.\nIn my version, the boxed version is generated as\nkotlin\npublic fun <T> Array<out T>.contains(item: T) : Boolean\nI'm no sure if \"out T\" or \"Any?\" is preferrable here, but \"out T\" follows the API of indexOf\n. @geevee sorry, did not mean to offend. I am still not used to youtrack\n. stdlib tests pass, but fail on JS and I do not know why\n```\nrun28  Time elapsed: 0.03 sec  <<< FAILURE!\njava.lang.AssertionError: ArraysTest.lastIndexOf result: fail. Died on test #1: net.sourceforge.htmlunit.corejs.javascript.Undefined@2d098f1f is not a function, it is undefined.\n    at kotlin.test.DefaultAsserter.fail(TestJVM.kt:82)\n    at kotlin.test.TestPackage-Test-f28b25bc.fail(Test.kt:68)\n    at kotlin.test.TestPackage.fail(Unknown Source)\n    at org.jetbrains.kotlin.js.qunit.SeleniumQUnit.runTest(SeleniumQUnit.kt:76)\n    at tests.SeleniumTest.run(SeleniumTest.java:65)\nResults :\nFailed tests: \n  SeleniumTest.run:65 ArraysTest.lastIndexOf result: fail. Died on test #1: net.sourceforge.htmlunit.corejs.javascript.Undefined@2d098f1f is not a function, it is undefined.\n```\n. That is correct, I used java implementation as a reference\n. Since it is handled by code generation, how do I handle this special case?\n. This is true for all primitive type arrays, isn't it?  Then perhaps the implementation for Array should be hand coded, while the implementation for primitive type arrays should use this generated code with the null check portion removed?\n. ",
    "Ladicek": "Thank you. Looks like I've learnt a valuable lesson :-) I'll try to look into it shortly.\n. Is that an issue? It works in Java, so I guess it should work in Kotlin too. I'll try to look at that.\n(TBH, I don't quite like how varargs work in Kotlin. The vararg annotation modifies the type of the argument, which is unusual at best. IMHO, the type of vararg parameter should still be Array<...>, the compiler shouldn't do this tranformation at all.)\n. So I looked into it and with this patch, main with vararg parameter works just fine. Rebased on current master and added tests for main with vararg.\n. No worries. There's one part of the code that I'm not very satisfied with: I couldn't figure out how to call MainFunctionDetector from JetRunConfigurationProducer without passing in a ResolveSession. If you could help, that would surely simplify the code a bit.\n. I was working on rebasing to current master (the jet -> kotlin rename) just now, looks like I don't have to :-) Thank you!\n. ",
    "Stebalien": "\nI think it's better to allow named arguments. It requires some more analysis though, because the order may need to be changed\n\nIt also won't work if any arguments have been skipped.\nkotlin\nclass MyClass {\n    fun get(a: Int = 1, b: Int = 2) {\n        return a + b\n    }\n}\nMyClass().get(b=3)\n\nThere's nothing bad in doing so.\n\nIt just looks a little odd but you're right, it isn't incorrect and the user doesn't have to follow the intention.\n. > Regarding omitted arguments, you are right, but what I'd like to avoid is the user not knowing why the intention is not available. So I'd suggest to support it and in tricky cases show a tooltip window explaining why it didn't work.\n\nFor balloons and popups, see JBPopupFactory class and its (rather elaborate) usage here:\nhttps://github.com/JetBrains/kotlin/blob/master/idea/src/org/jetbrains/jet/plugin/ktSignature/EditSignatureBalloon.java#L78-78\n\nSo make isAvailable return true but, instead of making a change, fail?\n. Also, I'm currently rendering the actual change in the intention menu (\"Replace inst.get(a, b) call with inst[a, b]\"). However, this obviously wouldn't work given this^^ change. Would it be better to say something like \"Replace get call with array index operator\"? \n. Updated and significantly reworked.\n1. I now subclass JetSelfTargetingIntention because I don't mess with getText. Before, I was showing a before and after in the intention popup however (a) that isn't possible if the intention might fail (as noted above) and (b) might become awkward when converting very long statements.\n2. Named parameters are now accepted however, if I can't reasonably convert them into unnamed parameters, I display a (hopefully accurate) message explaining why the intention failed. I don't bother preserving whitespace and comments when rearranging parameters.\nAlso, I got bored and got rid of the for loops (but this version is probably a lot slower so I put it in a separate branch).\n. I kept this separate because it's entirely independent. That is, running \"Generate Tests\" on master (without any modifications) produces this change.\n\nAlso, it's a good idea to amend some of the previous commits to avoid meaningless changes dangling in the history\n\nSo merge the two commits in #341? \n. Take a look at idea/testData/intentions/branched/when/merge/mergeWithConflictingDeclarations.kt.\n. I updated the pull request with one commit per requested change. I'll squash it down later but I thought this would make it easier to review.\n. I added the extra tests and reworked the commits into logical (independent) pieces.\n. Fixed the two issues (author and changed exception name). Sorry this took so long, I was working on my other task.\n. Thank you for taking the time to review this.\n. Yes. Sorry, I've been working on several tasks at once. Now that you're here, I have a question.\n@svtk suggested that I split out the unparsing logic into JetPsiUnparsingUtils. However, it almost makes more sense to put it in the tokens themselves. That is, make all tokens that have a fixed \"value\" JetValueTokens and give them a getValue() method (like keywords; actually, JetKeywordToken would be a subclass of JetValueToken).\nInstead of:\njava\nJetToken EXCL = new JetToken(\"EXCL\");\nWe would have:\njava\nJetToken EXCL = new JetValueToken(\"EXCL\", \"!\");\nAnd:\njava\nJetTokens.EXCL.getValue() == \"!\"\n. I updated the PR. I left the previous commit for comparison but I'll squash them down when the review is done.\nWhile I got rid of some redundant logic shared between the isApplicableTo and applyTo methods, I couldn't get rid of all of it because I need intermediate values.\nAdditionally, I changed the name from \"Push Not In\" to \"Simplify Negated Comparison\".\n. @geevee Finish it soon. Again, sorry (same excuse but I still need to finish this one ASAP).\n@svtk I addressed most of your comments. I didn't change the intention name because https://github.com/Stebalien/kotlin/commit/202d224e81df22a6a5a45d2872873221bc72ee75#commitcomment-5706613. If you still think I should change it, I will; I just think comparison is more accurate.\nAs usual, I'll squash the commits when you're ready to pull. \n. Done.\n. Thanks.\n. Good point. I added the helper function and rewrote the class in kotlin to get rid of the warning (I should have written it in kotlin in the first place anyways).\n. > Several !! were removed where warnings were reported.\nI thought I got all of those. Sorry about that.\n\nThere was another interesting commit to fix compilation on build server. Please, see the commit message for more details.\n\nDoes this kind of thing happen often? (If so I'll try to start testing under both jdk 7 and 6.)\n. Is this kosher?\n. There has to be a better way to do this.\n. ",
    "dezgeg": "Follow-up at https://github.com/JetBrains/kotlin/pull/346 since this one was closed in GitHub.\n. Well, this time github made all the comments on the previous revision.\nv3 changes:\n- added  properly to all tests\n- allow function literals in arguments again: (f.get({ it + 1}) -> f[{it + 1}])\n- fixed capitalization of family strings\n- back to fixed description of 'Replace get() with bracket syntax'\n. Addressed.\n. http://www.cs.helsinki.fi/u/tmtynkky/kotlin/ for screenshots of the problem the second commit fixes.\n. Added tests for smartSelectExpression, though this is starting to diverge a bit from the original issue :)\n. New revision, now with tests.\n. > > Also, the tests for the other transformation are a bit incomplete since I'd need to communicate with the interactive renamer somehow.\n\nWhat kind of communication do you need?\n\nI was thinking of giving the resulting parameter a name other than 'it'. But since that's completely handled by the existing interactive renamer, perhaps it shouldn't be needed to test it again here.\nSo, this should be complete now.\n. Addressed comments. Now both intentions are only available if the cursor's over 'it' or a singular lambda parameter or parameter list.\n. Here's the new revision.\n. Sure. What's the way to find a variable reference with just a variable name? All I've found is methods that require an existing PsiElement for reference search.\n. ",
    "wutalman": "Hi, just pushed fixes to all the issues you raised (hopefully)\n. Fixed indentation of tests and templates\n. oops had a line in the test for my new task, removed it from this commit, sorry\n. fixed the things Andrey pointed out in the last PR (string builder, raw string, and simplified example)\n. added issue id to original PR message\n. sorry, commented on the issue now.\nthe var is a mistake, should be val, I'll fix it in the next commit after I get all your comments\n. isn't the number that i wrote the issue id ?\nKT-4564 ?\n. added the missing space,\nsorry for the mess Andrey, I'll pay more attention to that in the future\n. fixed the description and changes parenthesis to parentheses in the names\n. fixed Andrey's comments\nabout the question you asked, why I name the lambda when some of the parameters are named, I felt like the convention is either naming or not naming the variables and I thought this made more sense:\nfoo(a = 2) { it } -> foo(a = 2, b = { it }) \nfoo(2) { it } -> foo(2, { it }\n. Hey, I'm having some problems with getting canBeReducedToBooleanConstant to work correctly, so far the only thing that it evaluates is true or false, here is the test function i've been using for it:\n\n    private fun JetExpression.canBeReducedToTrue(): Boolean {\n          val bindingContext = AnalyzerFacadeWithCache.getContextForElement(this)\n          val trace = DelegatingBindingTrace(bindingContext, \"trace for constant check\")\n          val res = CompileTimeConstantUtils.canBeReducedToBooleanConstant(this, trace, true)\n          println(this.getText() + \" can be reduced to true? \" + res)\n          return res\n    }\nfun trueReturner(): Boolean = true\n\nand when i test it i get these results:\n\ntrueReturner() can be reduced to true? false\n2 > 1 can be reduced to true? false\ntrue can be reduced to true? true \nany idea where i'm going wrong ? \nthanks!\n. Hey, I'm having trouble with the behavior of canBeReducedToBooleanConstant\nif i have something like this\nval x = 2\nval y = 3\nif ( y > x ) { ... }\nit will turn it into \nval x = 2\nval y = 3\nif ( true ) { ... }\nbut i don't think that behavior is correct, while vals can't be reassigned the user can change the text in them sometime and then the condition will remain true and might cause problems.\nwhat do i do about that ?\nthanks\n. umm okay, it looks like i've screwed up here, i realized this PR was opened a while ago and i wanted to update my stuff so i pulled and rebased into this branch, and it turns out that everything i pulled got into this PR.\nI'm not sure what to do in this situation, should i open a new one with the new repo state instead ?\nsorry\non a programming related note:\nI see the isPure flag exists only on IntegerValue and on those inheriting from it but not on the abstract CompileTimeConstant, should the new flag exist on the abstract class ? \nwould the new flag basically say whether or not this compileTimeValue is referenced from by a name or not ? (like set it to true in the visitor for SimpleNameExpression but false in the visitor for ConstantExpression ?)\nthanks!\n. hey, I pushed the updated version \nI added the flag and turned the flags into an int field in CompileTimeConstant, I also changed the inheriting classes' constructors to work with that, and I added the flags to the calls where necessary (mostly in ConstantEvaluator, but in a few other places as well)\nSeem to work quite well on what i've tried it on\nso now my intention will simplify\n 2 > 1 -> true \nbut not \n val x = 2\n    x > 1  \n. Hey, I pushed some changes to the compile time stuff (not a very meaningful commit message since ill soon squash it with the other and seperate them into the intention and the compile time stuff)\nI changed the flag to default to false and instantiate to true from SimpleExpressions\nI'm not completely sure how to handle AnnotationValue and ArrayValue, (both in visitCallExpression) do I evaluate a flag for them somehow  or do I always instantiate them with false ?\n\"a\" == \"a\" now works fine, but when i try to evaluate MyEnum.A == MyEnum.A I actually get null (ie nothing to do with the new flag, the evaluator ecaluates just returns with null, i made sure MyEnum.A is evaluated fine (not null and correct flag) but then the comparsion returns null, is that bad ? should i change the logic in the implementation ?\nI tried adding tests for the new flag in AbstractEvaluateExpressionTest, but I couldn't use the doTest from isPure since it relies upon using vals which means that it will always evaluate to true. \nI wrote a short test of my own instead but it's not working great (because if the bad expectd type i think) is there a more suitable doTest already in use somewhere ?\nthanks\n. Hi, pushed the latest stuff:\n- renamed the tests in more meaningful ways\n- added tests for the new flag, seems to be working fine i think\nas for ArrayValue: I changed it to check if any of the values assigned to it have the flag set to true and if so set it to true (I didn't change it in the constructor because I was worried it will make in inflexible, i just made it so in all usages (3 instances)), I'm also unsure how to test it, in the test if i do something like  prop1 = array(1, 2, 3)  it evaluates to null and never gets into the place that creates the ArrayValue, I'm not sure in what case the ArrayValue is being created?\nas for AnnotationValue and JavaClassValue: i could not understand how to instantiate those flags, currently they are being set to false by default\nas for the intention itself, i changed the assert you pointed at and added the elvis you suggested, but the suggestion to remove the handling for binary expressions and parenthesized expressions doesn't seem to be applicable when you think about it, the intention does logic that the constant evaluation doesn't.\nexample:\n(a && b && true) || (b && true)\nif we just check if it can be evaluated to constant the answer is no, we need handling for binary to get inside, now we have \nleft = (a && b && true)\nright = (b && true)\nnow again for left the constant evaluation will still not evaluate it to a constant and we will need to handle the parentheses, we will simplify what's inside and need to handle those binaries as well etc)\nwhen we're done and we've removed the true we will need to make a decision about whether to keep the parentheses or not (ie (a && b && true) -> (a && b) but (a && true) -> a)\nthanks\n. fixed the inline comments, separated commits\n. Oh sorry, I ran all tests a while ago and I thought the change in compile time wouldn't change it, it was a while ago though, right now i'm getting more than 2 failed tests (I think for reasons not related to this intention) so I'm working on figuring that out \n. Hey, I'm looking at the tests that fail and I can't really figure them out, here is an example of one:\nin the QuickFixTestsGenerated a test for typeAddition fails (beforePublicFunWithoutBody.kt)\nand this is what it says https://gist.github.com/wutalman/02fe57affae75fb3e931, but when i look at the file this is what it contains https://gist.github.com/wutalman/86ea85c358a0a97a0614 and when i check this in the debug instance of IDEA i get http://i.imgur.com/WpuAdYV.png\nso basically all the actions that i get in the editor are those that are mentioned in the test, yet it tells me that it gets unexpected ones \ndo you know what could be causing this ? \nthanks\n. fixed the tests you pointed out, rebased it into the 2nd commit (i hope that's okay)\n. hey, yes i see what you mean about generate tests now modifying JetDiagnosticTestGenerated, but i'm not sure how to avoid it ?\nthanks\n. after disabling it, what imports do i remove to make it not change the generated test though ?\n. It still creates the JetDiagnosticTestGenerated file when i run\nmaybe i'm not understanding this correctly, i want it to stop generating a new JetDiagnosticTestGenerated when generate tests is run right? or do i want to commit this new one ? \ni tried it both with and without the Optimize imports on the fly option\n. seems the new test is adding two imports that weren't there before\nimport junit.framework.Assert;\nimport org.jetbrains.jet.checkers.AbstractJetDiagnosticsTest;\nbut how can i remove them ? (obviously just removing them won't change anything because they will be generated like that again)\n. okay so it seems the new generated diagnostic test has the same imports as master, i added it to the first commit as well as the fixes for the failing tests, and the second commit is again just the intention\n. relates to https://github.com/JetBrains/kotlin/pull/390\n. removed the unused variable Andrey pointed out\n. hey, there's no issue in the tracker\n. first PR for this issue\n. Hey,\nI'm having some trouble with the fake call thing, right now my problem is that i cant get a Call object, though I'm very unsure about everything I'm doing here, here is what i have so far (I know the castings are bad it's just for testing now, ill change it to null checks after i get a handle on things)\n\n        val resolveSession = AnalyzerFacadeWithCache.getLazyResolveSessionForFile((element.getContainingFile() as JetFile))\n        val context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()\n        val trace = DelegatingBindingTrace(context, \"trace for fake call\")\n        val injector = InjectorForMacros(element.getProject(), resolveSession.getModuleDescriptor() as ModuleDescriptor)\n        val newContext = AnalyzerFacadeWithCache.getContextForElement(newElement!!)\n        val newTrace = DelegatingBindingTrace(newContext, \"trace for fake call\")\n        val call = DelegatingCall(context.get(BindingContext.CALL, element) as Call)\n        val resolved = injector.getExpressionTypingServices()?.getCallResolver()?.resolveFunctionCall(\n                                   newTrace,\n                                   trace.get(BindingContext.RESOLUTION_SCOPE, element) as JetScope,\n                                   call,\n                                   trace.get(BindingContext.EXPECTED_EXPRESSION_TYPE, element) as JetType,\n                                   trace.get(BindingContext.EXPRESSION_DATA_FLOW_INFO, element) as DataFlowInfo,\n                                   false)\n\nI tried using both context and newContext for the DelegatingCall and both element and newElement as the keys, all 4 options seem to return null\nunrelated: I couldn't find a Iterator.makeString() method on Iterator, is it supposed to be in Iterator.kt ?\nThanks!\n. Hey Svetlana,\nI created the fake call in the remove intention (it's uploaded just to be kept up to date but definitely not done) I have a strange issue, all my tests pass except this one where i try to infer this:\nBox>(Box(\"x\")) \nnow the part where it fails is the comparison of the actual types and the resolved types, though they do seem to be found correctly, \nin this picture: http://i.imgur.com/e4VPJhf.png\nargs are the actual arguments from element\nnewArgs are the arguments from the resolved call for the fake one we created, \neven though they seem to be the same (first 2 prints), all my tries to compare them return false (last 3 prints) and it does succeed for normal tests (like Box(\"x\") works fine)\nany idea why my comparison fails ? \nthanks!\n. I thought the reason it wasn't working the way I did it first is that I didn't create a new trace for the new expression but just resolved it in the current context which meant that I used cached information about value arguments.\nI thought the entire idea of fixing it was creating 2 contexts, one for the original element and one for the new one, then checking if the resolved type arguments still match, if I can't compare type arguments taken from different context than how can I make sure that the old resolved call and the new resolved call still have the same types ?\n. Hey, I looked through the results of that example in both my old implementation and new and in both cases it seems that it's not that the call isn't being revolved, it's that it's being resolved incorrectly, (i think), the resolved call exists (in both cases) and is not null, but when i look at the arguments assigned i get  defined in barr=CANT_INFER_TYPE_PARAMETER, like the resolution could not get the type for 's'.\nwhen we say use the cache that means using the AnalyzeFacadeWithCache class right ?\nI've tried to look through the places where trace records RESOLVE_CALL but I couldn't understand well enough what's happening there to get why the type isn't being inferred correctly.\n. Hey Andrey, following what we talked about on IRC, I'm still struggling with both issues i can't seem to get those to work, i expanded my scope but it doesn't help\nfor example in this case:\n\nfun foo() {\n    val x = \"hello\"\n    barr(x)\n}\nfun barr(t: T) = t\n\nI tried getting the parent's scope and i printed the parent, the parent was the block expression\n\n{\n    val x = \"hello\"\n    barr(x)\n}\n\nbut still the type of the call could said could not be inferred and i couldn't find x in the scope either, I also tried using BindingContext.TYPE_RESOLUTION_SCOPE instead of BindingContext.RESOLUTION_SCOPE but that didn't change anything.\nas for the comparison problem I still can't figure out why I can't compare between two JetTypes/TypeDescriptors that describe the same type but come from different contexts. (the second thing we spoke about on IRC)\nthanks!\n. separated PRs, this is now only for remove\n. Hi Svetlana, \nSo as I wrote above I'm still having the two problems, the one with the types not being inferred correctly from variables, Andrey suggested that the scope might be the issue (using the injecetor) so i tried to expand it and call bigger scopes but it still didn't infer the types even when the scope was clearly big enough. When not using the injector i don't even control the scope so I haven't  been able to play too much with that method, currently they both produce the same result.\nI still can't figure out how to compare elements between two maps that come from different descriptors, even when i get down to the JetType level and let's say they're both String, they still show as not equal, so far the only way i've actually had any success comparing them is by comparing their strings.\nI've been kind of stuck on both these issues for a while now :/, i'd love any ideas\nthanks!\n. I really don't know, it just doesn't recognize s, i've been wrecking my brain about it for so long i literally searched through all the uses of type arguments in the kotlin project and read through all the CallResolver, TypeResolver CandidateResolver etc classes to find a utility to give me the correct scope or correctly resolve my new call and infer the types but i can't figure it out\n. Hey, I managed to get it mostly working with something Andrey suggested, by just taking the original call and overriding getTypeArguments to return an empty list i could resolve that call and check the results, it seems to work well on most things but it's not working right on this case\nfoo<(Int) -> Int>({ it * 2 })\nit resolves it like the types can be removed and then \nfoo({ it * 2 })\ndoesn't work.\nwhat I guess is happening is in the call it sees that the function type gets an Int as input, therefore knowing that 'it' is an Int, then when i resolve the untyped version it thinks it already knows that 'it' is Int so it resolves correctly, but then after i remove it, it stops knowing\nbasically we infer 'it' from the type args and then infer the type args from 'it'\ni'm not sure how to avoid this situation, maybe if i have a function literal try to resolve it aswell without the type args ?\nany ideas on that?\nthanks!\n(i pushed what i have so far)\n. Hey,\nI couldn't understand why you were writing those things and then i realized that since i renamed my branch my pushes weren't getting into this pr and you were still looking at the old code\nim so sorry for the mix up, and also i think i solved the problem I had before, so hopefully things work well now :)\nchanges actually pushed now\nthanks\n. This is a second fix for this intention, the first one was already accepted, they are on the same branch\n. changed formatting of what Andrey said\n. separated from this PR https://github.com/JetBrains/kotlin/pull/406\n. Hey, \njust about the makeString(), the way i understand it since im not turning the list itself into the string (i use the list items as keys in a map)\n types.forEach { sb.append(\"${args[it]},\") }  \nI don't think i can use that, unless i first create a new list of these items and then uses makeString() on that new list \nor is there another use that i'm not getting ?\n. Fixed the things Andrey pointed out\n. Added tests to all the cases Andrey pointed out, except for the case with the clashing names.\nI really didn't think about the clashing name case, my intention currently doesn't handle it correctly.\nI thought of taking the types as text and using the JetPsiFactory to turn them into JetTypeReference with createType and then getting the JetType from a context and seeing if they match, but right now the JetType im getting is null, I guess my context isn't comprehensive enough, not sure how to get a better one (tried element's and containingFile's), would love an idea for how to get the correct context (if that's really the problem)\nis this the correct direction of doing this? do you think there's a better way?\nand after i've checked, if i find that the new type is different, i want to switch it's string to the qualified name, how do i get the type's qualified name ?\nthanks!\n. Hey, so I looked through it quite a lot and i tried some stuff with it but i'm still having some problems, \nI assume the part where they decide whether or not to use the qualified name is where they do \n \n        Expression expression = new JetTypeLookupExpression(\n                types,\n                types.iterator().next(),\n                JetBundle.message(\"specify.type.explicitly.add.action.name\")\n        ) {\n            @Override\n            protected String getLookupString(JetType element) {\n                return DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(element);\n            }\n```\n        @Override\n        protected String getResult(JetType element) {\n            return DescriptorRenderer.TEXT.renderType(element);\n        }\n    };\nJetTypeReference newTypeRef = getTypeRef(namedDeclaration);\nTemplateBuilderImpl builder = new TemplateBuilderImpl(newTypeRef);\nbuilder.replaceElement(newTypeRef, expression);\n\n```\n\nI tried playing with something similar, but I think my problem is that I don't have the typeRef for the type i want to create, i can get a typeRef by using JetPsiFactory.createType with the string of the type i want but then it's a reference to whatever string i gave and not the correct type, it doesn't seem like there's much I can reuse since the whole specify type intention is hardcoded for declarations and so it's a bit of a different situation.\ndo you think i can get the correct typeRef somehow ?\nthanks\n. Cool! It seems to work now, I added the tests for the clashing name case.\nBut I haven't ran all tests yet because I'm getting some failed tests on another intention that I assume need fixing (asked about it in the group)\n. sorry about that, updated the test\n. that is very strange, for some reason it's not failing for me, i ran them all before pushing and they all passed, ill do a manual check on all of them..\nsorry\n. fixed\n. added details (oops i guess i forgot to grab them when i separated PRs) \nremoved the unnecessary checks\n. fixed the things pointed out and added the test (inapplicableAssertOverloadedWithPackage)\n. Hey, I fixed the things you pointed out but i'm having trouble with using the simplify negated intention, basically i check if it applies and if so i apply it, and in my test cases it actually gets the correct response for isApplicableTo and runs the applyTo, but the condition doesn't change, (if i print it before and after the intention runs on it, it stays the same) is it related to the fact that it's an expression in a temp file made with JetPsiFactory ? \n(pushed the changes i made, there are 2 tests that check the simplifying condition part that fail)\n. pushed changes,\n- made stateless\n- AE(null) and AE() now become assert(condition)\n- your suggestion on shortenReferences worked, seems my problem was running it before inserting it into the file\n- changed the bundle text (on both sides of the intention, figured it's okay to have them both in this commit)\nas for the else cases that you stated, should i make the intention applicable for them ? i feel like if the user has an else, even if it's empty he might want to add stuff in it later, it's most likely not there without reason, and running over it with my intention might not be what he wants, also there's an intention to remove unused else, so we would probably want the user to get that one first\nbut if you think i should implement those cases let me know and ill add support for them\n. pushed fixes\n- using JetCallExpression instead of reolvedCall in application\n- fixed tests\n. thanks!\n. I had a lot of problems with some of my tests failing in a seemingly random pattern, took me a lot of time to realize that it was because I had functions with a similar signature in many of my tests, and for some reason it caused conflicts, I think the testing infrastructure either uses too wide of a scope (looking at more than just 1 file) or does not clean up the context between each inspection test, because basically if i have this situation:\nfun foo(t: T, v: T) in test file 1 \nfun foo(t: T, v: V) in test file 2 \nand then i call foo(\"x\", \"y\") from file 2 it will not be able to resolve the function (ambiguous call).\nright now i solved it for my specific case by giving a unique name to the functions in each of my tests \n. I've reverted the changes to the tests in the commit and it seems to work fine now, I couldn't run all tests though because since the last pull I have an issue where hundreds of tests fail.\nbut the inspection tests now work with the old test files\n. thanks!\n. not sure on this line, basically i just want that string, but later i use messageExpr as an expression, so i was debating whether to create an expression with the string and then have easier handling at line 62, or i thought maybe setting messageExpr to be Any and then just assigning the string and adding a special check for String in line 62, probably more efficient but less readable.\nEnded up going for readability\n. fixed to use DescriptorUtils.getFqName\n. !lambdas.isEmpty changed to lambdas.isNotEmpty()\n. ShortenReferences was not working for \"kotlin.assert\" it would always process it back to the full \"kotlin.assert\", i tried debugging it for a couple of days but when i couldn't i figured this method should be just as good, I create the element with the short name \"assert\" and then get the resolved call, if it doesn't resolve to \"kotlin.assert\" i replace it with the dot qualified call\n. ",
    "pkukkapalli": "How do I remove changes to the configuration files on the git, but not change them locally? Would it be best to revert this commit and only commit the non-config files?\n. How do I write a test for a negative case, such as x.get or x.get(23) { 2 * it }? Do I simply make the .kt.after file a copy of the original, meaning the intention should not be applied in this case?\n. Sure I will keep that in mind for the future.\n. What exactly does the expression x.get(23) { 2 * it } do? I tried looking for it in the online Kotlin documentation, but was not sure where to find it.\n. Also, do we have to do any sort of type checking? In the sense that if the get function takes an integer as a parameter, and the user does x.get(\"hello\"), do we still convert it to x[\"hello\"]?\n. This actually wasn't the final commit, I committed my changes so they would stay intact. There were some issues with my kotlin build, so I had to do a rebase. I didn't get a chance to test in IDEA yet, because of the issue I was having, but I will do so. Thank you for the feedback.\n. After changing the name of the class and amending GenerateTests.kt, the generated test file is still trying to reference the GetCallReplacement class. Is there something extra I have to do in such cases?\n. Sorry about the recent string of commits, I have been trying to figure out rebasing and conflict merges on git.\n. So to start clean and cherry pick, should I do git rebase -i upstream/master and then pick the commits that follow that I wish to use, or do I use git rebase -i master?\nI did run \"Generate Tests,\" but the obsolete method was still there.\n. Ah, I figured it out, it was quite easy to accomplish once I saw that IDEA had an option for rebasing.\n. I believe this should clean up the git history quite a bit, should I edit the commit messages to make them more detailed?\n. Oh I'm afraid not, I am still having issues with the testing. I've tried updating the plugins and the repo. But, that didn't seem to affect it at all, and I also rebuilt the project. I am not sure why the old one is still preserved, while the new tests are not at all generated.\n. Would it be worth a try to change the name, at least so I can test the code, because right now I cannot confirm whatever code does what is intended.\n. Ok, yes after deleting the entire generated file, it worked. I shall do some testing and possibly more fixes, and then commit for a review. Thank you!\n. Wouldn't an infix call with a simple argument and a function literal be syntactically incorrect, since infix calls only take one right hand argument?\n. I am ready for review now.\n. This should fix the previous issues. Shall I squash this commit back into the original one?\n. When I was talking to Andrey about the testing issue, he told me to open a new pull request, to help resolve the issue.\n. This issue has been resolved.\n. Updated intention to replace dot-qualified function call with infix function call.\n. Fixed conflicts with upstream/master.\n. This is issue # KT-4563.\nAlso I believe I need a login to make comments on the issues. Were we given any?\n. I added a comment to the issue.\n. I have updated my project to reflect the naming and coding conventions that you have suggested.\nWhen I tried to use the getDefaultType() function on the descriptor, I get an unresolved reference error. I am also still getting the illegal access error when I call setText(). I have commented these sections of the code in the file ReplaceWithOperatorAssignIntention.kt.\nI have also moved the intention to go from a += b to a = a + b to this branch.\n. Rebased on top of master\n. Pushed rebased commits.\n. Updated with suggested changes.\n. Fixed the checks for primitive operations.\n. Rebased on top of master and converted nested if's into when statement. Shall I squash all of the commits together?\n. Rebased and squashed.\n. Rebased and retested.\n. I believe that I never forced pushed, the tests should be fixed now.\n. Updated to convert from for (a in x) { ... } and x.forEach { a -> ...}.\n. Rebased on top of master and applied suggested changes.\n. I cleaned up my code, and fixed my commit tree.\n. Rebased on top of most recent master and squashed together commits.\n. Sorry this was pushed by accident, when I was trying to rebase a different branch. I am still having trouble getting the tests to compile with the new testing restrictions, because I cannot use the WITH_RUNTIME directive without getting OutOfMemoryExceptions.\n. Tests fixed.\n. I am not sure what you mean by \"Make formatting.\" Should I merge all of the boolean expressions into one line?\n. Also tests for zero or two arguments to forEach is handled as a compiler error, so those tests shouldn't be necessary. I am making a test with a user defined function however.\n. I'm also having a problem with\nval context = AnalyzerFacadeWithCache.analyzeFileWithCache(element.getContainingFile() as JetFile).getBindingContext()\nval resolvedCall = context[BindingContext.RESOLVED_CALL, callee]\nval functionFqName = if (resolvedCall != null) DescriptorUtils.getFqName(resolvedCall.getResultingDescriptor()) else null;\n\"kotlin.forEach\".equals(functionFqName)\nMainly, the problem is that isApplicableTo is being called on all of the elements in the file, and thus if the first element it's called on is not the function we are examining, then we get false, which throws the entire program off.\n. No, for example in the isApplicableTo() function, if I add a line saying println(\"element: ${element.getText()}\"), with the following test:\n// WITH_RUNTIME\nfun foo() {\n    val x = 1..4       x.forEach { it.equals(1) }\n}\nthe printed output is:\nelement : x\nelement : x.forEach { it.equals(1) }\nelement : x\nelement : x.forEach { it.equals(1) }\nSo, when we check the function's package name it evaluates to false. I don't really understand how this wasn't a problem before.\n. Updated repo with new tests, formatting changes, and the function name check.\n. Should I just make the changes in my own copy of origin/foreach and open a new pull request?\n. I have added appropriate code to handle both tests.\n. This fix should take care of the latest issues.\n. Suggested pull request changes made.\n. Oh, I see, I think I was looking at the groovy version of the intention.\n. Not at the moment, sorry. I'm still working through all of the Java implementation. I hope to have something soon either today or tomorrow.\n. Is there an equivalent to ControlFlowFactory for JetElements?\n. In the Java implementation, they seem to use it to figure out what to change the then branch to, if there is no else branch specified.\n. Made the necessary changes to invert the branches.\n. Additional tests added.\n. Squashed and rebased.\n. I just realized that my current fix does not fix a function call like demo.foo(\"\"), where demo is a package.\n. I'm confused about a few things. Let's say that I take a RESOLUTION_SCOPE slice with a BindingContext, and get all the descriptors. I'm not really sure how to then verify whether the receiver of the function is a package or value/variable.\nAlso, would it be simpler to refactor the intention to extend AttributeCallReplacementIntention?\n. When I use setText(), I get an IllegalAccessError.\n. Is there a way to extract type from a Descriptor? In KotlinBuiltins, there is a method to check for primitive types, but it only accepts a JetType, and I don't see any obvious to get a JetType out of descriptor.\n. ",
    "gavinkeusch": "Ok, makes complete sense.\nFirst attempt at my itention\n- created GetToSquareBracketsIntention.kt class which contains my intention to change any function call .get with arguments to square brackets.\n- added a before, after and an intention description to the intentionDescription directory.\n- added an intentionAction to plugin.xml.\n- create diretory getWithSquareBrackets in idea/testData/intentions and created two tests (getWithSingleArguments and getWithMultipleArguments)\n. Hi Udalov\nHere are my changes I've made since your last review. Thanks in advance\nChanges recommended from PR #347 \u2026\n- removed created by in GetToSquareBrackets.kt\n- removed dots from JetBundle.properties discription\n- changed description.html to adhere to the form of other intention descriptions\n- edited isApplicableTo and added cases for the fallowing as well as tests for each:\n  a.get(x = 0, y = 1)\na.get(2) { doSomething() }\na.get(2)\n- added tests for no arguments and no receiver\n- changed if (condition) return true else return false to return condition\n- used Ctrl-Alt-L to reformat code, ie clean up spacing before colon\n- used StringBuilder instead of concatenating strings\n. Hi Alexander\nI made the recommended changes. Thanks again.\n- fixed spelling error in description.html\n- changed after.kt.template to match before and added  to both\n- removed .any use and combined the check into the for loop\n- added JetDotQualifiedExpression check to isApplicableTo and changed getWithNoReceiver test to be IS_APPLICABLE: false\n- removed variable numberOfArguments which is never used\n. Hi Alexander\nI have squashed my 3 commits into one. Thank you so much for the review.\n. Awesome. Thank you so much.\n. Made recommended changes from last PR\n-edited JetBundel.properties to match similar intention name\n-edited intentionDescription to have spot around entire expression\n-added empty braces test and changed isApplicableTo to cover this condition\n-edited when expression\n*renamed all class and file names (removed \"unnecessary\")\nI believe this intention mimics the same intention offered in Java. \nThanks in advance.\n. Sorry for future reference, I should post concerns about how to implement an intention under the issue in the tracker?\n. When you say redundant safe call, I should replace it with !!. since I have already checked that it can't be null?\n. Thanks, I will. I have fixed the semicolon case. Currently working on the comment case and will then add the functionality for the if else case. Hoping to summit my next PR by the end of the week.\n. Hi Evgeny\nI have implemented all your recommendations. I still don't have the output for comments working properly, will continue to work on this. Just felt that it was time for another iteration for so much of the code has changed. Thanks in advance for the review.\n. I thought I should mention that I am aware that by using cursor positions to determine if the cursor is in the if or the else part might not be the best way of doing this. It won't work correctly if the if else statement isn't formatted as expected. Is there a better way of accomplishing this. I have been trying to think of one and haven't been able to come up with a better way. Thanks.\n. Hey Evgeny. Made your recommended changes. Thanks for those. Still don't have the comments case working properly. I am having trouble getting the comment on the line before the control statement. Thanks in advance for this review.\n. I would of course be easier if we didn't support it. Although the Java intention I have been basing this one on does support it.\n. Leaving commented imports... sorry I should be catching that kind of stuff. Thanks for the review. My current problem with implementing the comments case is when I add the comment before the control structure they end up on the same line and then the whole thing becomes a comment. I can't seem to get it to add a newline after the comment.\n. I have been trying to do that. I was trying to add a new line before the control structure then add the comment line before the newline. Still can't get it to work. And if I add the newline after I add the comment the whole structure becomes a comment and the newline is added after the whole thing.\n. Thanks for the help. I got it to work. Think this might be the one, or at least we are really close to being finished this intention :)\nNote: In order to make the comment case look clean it removes all whitespace before it added the comment. This means that if the user intentionally has a bunch of newlines before their control statement when RemoveBracesIntention is called it will remove all that whitespace. I think this is ok, but just wanted to note that I am aware of this case.\n. Awesome, thanks you\n. I have submitted what I believe to be a fix. Please see PR #411 \n. Ok, no worries. I had noticed that they were very similar just thought since they were both offered in Java that is what we wanted here as well. Will this be the same for my Remove Braces and Lingzhang's Merge Else If (PR #408) thought I should mention it just in case it is to save time for both him and the reviewer. \n. No I am also confused about what is causing the NPE. Though the stack trace says its coming from that line. And I can't seem to get the NPE again after I have made these changes.\n. Yah I agree. I actually just got the NPE exception again after implementing this fix so I don't think fix actually works :( my stack trace is now saying its coming from findBlockInExpression in the Utils.kt. Which is a function of mine as well. I will investigate more and get back to you. I will close this PR. Its 3am here so I'll continue investigating tomorrow. Thanks\n. Closed\n. K sounds good.\n. Hi Evgeny\nTo be honest I'm not sure where to begin when it comes to trouble shooting something that is caused by concurrent threads. I was able to get the NPE exception error and after making these changes I am not able to get it anymore. I took Ilya's lead and made expressionKind a val so it can't be changed. It means calling findExpressionKind in both isApplicableTo and applyTo but seems to fix the NPE. I'm not sure if I have tested it enough to 100% confirm this fixes the issue. Thanks in advance for your help.\n. Sorry I did not get to completing this fix. I have 2 midterms today so they have taken up my time the last few days. Thank you.\n. Yah I saw it. Thanks again for doing his fix, wish I had completed it before you had to.\n. Hey Pavel\nI have made the recommended changes. I fixed the implementation when there is an else statement.  I have also address the intention being offered when it shouldn't be. \nA few things to note:\n- to make sure the JetBinaryExpression is located inside the condition of the if statement I am using text offsets. Not sure if this is the best way of accomplishing this but it is simple and works.\n- due to the way that JetBinaryExpression's are nested inside the condition, my getRight() function uses text offset's in order to build the right side of the expression. \nThanks again for the review.\n. Hey Pavel\nI have made the recommended changes. I also took at look at the java implementation. Thank you for that link. I had looked for an implementation to work off of and I had only found SplitIfIntention.java which was the implementation for the groovy intention I believe. I took your recommendation of working off of what should be offered not what shouldn't. That is a much better way to work at it. I also added support for \"||\". Thanks in advance for the review.\n. I had initially started writing this intention to be offered for the if keyword but then thought it was better to give the user the option of which && or || inside the condition they would want to split on. This is because when you are coding and you determine you have to split up an if statement sometimes you may want to split it on the last &&. If we offer it on the if it will be easier to discover but in my opinion if we split the first occurrence it might not be what the user is looking for. I will still change it if you think its best. Thanks\n. Oh I see. I would go about doing that by making another intention with almost the same implementation that fires of JetIfExpression correct?\n. Ok thanks. I will complete this one and then look into it.\n. Hey Pavel\nJust to clarify. When you say the scope should be changed, it should only be offered for || and && tokens. Isn't that how it is at the moment?\n. Disregard that question please. After reading your statement I understand that you want the intention to only be available if the caret is on the && or ||. Where at the moment it is available on any binaryExpression with the operator being && or ||\n. Hi Pavel\nI have made the changes you asked for. The intention is now only offered when the caret is on && or ||. As for when you have both || and && in the same condition. It is only available on the ||. I believe this is the way the Java implementation is done as well. Thanks in advance.\n. Awesome. Thank you.\n. Hey Pavel\nI have made the recommended code changes. Thanks. The intention is now only offered if the cursor is on the if keyword. I also added a few tests. Not sure if these are what you meant by tests for nested if. Thanks in advance for the next review.\n. Hi Pavel. I just wanted to make sure you were aware that Tuesday, April 8th is my last day to contribute during my school semester. I am hoping to get this intention merged before that. Thanks again.\n. Hi Pavel\nHere are my changes. Thanks for your recommendations.\n. Hi Pavel. Thanks for those final touches. I appreciated learning these subtle ways of making the code so much more readable. I have made the recommended changes \n. I have time. I'll get right on it.\n. Hi Pavel\nI believe by slightly changing my getFirstOperator function I have fixed this bug. I also renamed it getFirstValidOperator.\n. Hey Pavel\nThanks for the hint. That is a perfect way of implementing the missing functionality. Please disregard the above changes. I am currently implementing the above methods. I will push a new update as soon as I'm finished.\n. Hi Pavel\nHere are the changes. I think I've covered all cases now. Thanks in advance.\n. Merging tomorrow if fine :) Thanks again for all the reviews. I thought firstOrNull only would return the first matching elements and I wanted to be able to return each matching elements until I found one that was valid. I could have used firstOrNull?\n. wow your totally right. is it cool if I push that change right now?\n. Thanks again for everything Pavel. Its been a wicked learning experience having my code reviewed by you.\n. Hi Zalim. My semester has come to and end. So I will not have time with exams to work on this task for a few weeks. I have mentioned to Andrey that I wish to finish this task. Just won't be working on it for a bit. So I am going to close this PR and start a new one once I continue working on it. Thanks.\n. ",
    "zgrannan": "Rebased off of master and re-organized commits\n. Will create a new pull request that uses the correct term: SafeAccess\n. Updated based on pull-request comments.\n. Edit -- Just @abreslav just answered these questions. I'll implement the choice using a dialog and create a new branch with the changes I make in order to preserve history here.\nHey @bashor, sorry for the delay in responding to you. I've been working on making the modifications you suggested and am almost complete, but I have a few questions:\n1. I think it makes sense to give the user the choice to inline the variable. What is the best way to ask the user if they would like to inline the temp variable?\n2. How can I determine if the return value of a safe access expression is checked? As far as I can tell, if the return value is not checked, I can remove the else clause when converting to an if-then, otherwise I think it must remain.\n3. When I commit the code based on your changes, should I restructure commits that I have already pushed (i.e rebase to clean commit history)? I think it may be possible that if I rebase the previous line comments you made may be deleted, but I'm not sure. I don't know if that matters or not.\n. I made changes, combined this with #374, and cleaned up the commit history. The new branch is \nhttps://github.com/JetBrains/kotlin/pull/393. There are two issues I have regarding the result value for safe access expressions and variable extraction that I have mentioned there. \n. As it stands now it can be applied as a seperate PR. However there is code that is common with the other intention, so if one gets accepted the other will need to be refactored in order to reduce code duplication. Should I merge them both into one pull request?\n. There are two issues that I would like help getting addressed.\nAll functions will be automatically extracted\n~~Variable Extraction~~\nFor a code fragment of the form \nfoo()?.length\nWhen converting this into an if-then expression, the IDE will create an expression of the form\nif (foo() != null) foo().length()\nAnd prompt the user to extract foo() as so:\n\nHowever, if the user chooses not to extract foo(), the code will not compile because foo().length() is not valid: foo() requires a safe-qualified or !! expression.\nShould the IDE instead automatically extract the variable?\nSee  here for relevant code:\nThis issue has been resolved\n~~Checking if the result of a safe-access expression is checked~~\nIf the result of a safe-access expression is not checked, then an expression of the form\nx?.y()\ncan be converted to the form\nif (x != null) x.y()\nhowever if the value is checked, then the expression must be converted to the form: \nif (x != null) x.y() else null\nTo check if the return value is checked, I use the following code :\nfun isStatement(expression: JetExpression): Boolean {\n    val context = AnalyzerFacadeWithCache.getContextForElement(expression)\n    val isStatement = context.get(BindingContext.STATEMENT, expression) ?: false\n    return isStatement\n}\nUsing this method, it works to see if the result is checked in most cases, but the following \ncase fails:\nval y = if (true) x?.y() else null\nBecause here x?.y() is technically a statement, this code will convert to \nval y = if (true) if (x!= null) x.y() else null\nInstead of:\nval y = if (true) if (x!= null) x.y() else null else null\nThis can be seen in the failure of test testUsedAsResultOfCheckedIf\nRelevant file: IfThenUtils.kt:58\nHow can this issue best be resolved?\n. I made changes based on the comments made, included missed tests and added the failed one mentioned.\nAlso, I was able to solve the problem I mentioned earlier about being able to determine if the return value from a safe call expression was used or not. \n. I integrated changes from https://github.com/JetBrains/kotlin/commit/e922f6b1052df72950c475c28af384a7a0948c58 and https://github.com/JetBrains/kotlin/commit/89608c22a11c8ca9ed3d58ba0de19d106e18a025. \nAlso added prompt to inline left side of elvis / safe-access when for if-then -> safe-access and if-then -> elvis. I also have made some comments in parts of code that I am unsure about.\n. Also, is it necessary to test the code generated if the user decides not to inline the variable for if-then -> safe-access and if-then -> elvis?\nIf so, how would this be done?\n. I have a couple issues:\nFirst, currently whenever the IfThenToDoubleBangIntention is applicable, the\nIfThenToElvisIntention is also applicable. I think that if the exception thrown is a \nNullPointerException or KotlinNullPointerException and does not have any arguments\npassed into the constructor, then the IfThenToElvisIntention action should not be available.\nFor example, for the code below:\nkotlin\nif (a != null) a else throw NullPointerException()\nI think it would always be better to use a '!!' expression instead of an elvis expression. Thoughts?\n\nSecondly, with regards to DoubleBangToIfThenIntention, if the expression is extracted in order to use a stable value in the if-then expression, should the argument passed to the\nNullPointerException use the original expression content or the extracted variable name?\nSpecifically, should code of the form:\nkotlin\nvar a: String? = \"foo\"\na?.length!!\nbe coverted to\nkotlin\nvar a: String? = \"foo\"\nval l = a?.length\nif (l != null) l else throw NullPointerException(\"Expression 'a?.length' must not be null\")\nor \nkotlin\nvar a: String? = \"foo\"\nval l = a?.length\nif (l != null) l else throw NullPointerException(\"Expression 'l' must not be null\")\n\nFinally, I have one issue with DoubleBangToIfThenIntention in the functional tests.\nThe test ExceptionTextEscapeQuotes converts the code below\nkotlin\nval map = hashMap(\"one\" to 1, \"two\" to null, \"three\" to 3)\nfun main(args: Array<String>) {\n    map.get(\"one\")<caret>!!\n}\nto\nkotlin\nval map = hashMap(\"one\" to 1, \"two\" to null, \"three\" to 3)\nfun main(args: Array<String>) {\n    val value: [ERROR : <ERROR FUNCTION RETURN TYPE>] = map.get(\"one\")\n    if (value != null) value else throw NullPointerException(\"Expression 'map.get(\\\"one\\\")' must not be null\")\n}\nHowever, when this intention is performed in the IDE, there is no issue. I suspect that this\nis due to the fact that while running in the test, after creating the if-then expression, the\nBindingContext has not been updated to provide a type for the then-clause of the if-statement\n(which is the value that is inlined). The relevant code is in DoubleBangToIfThenIntention.kt around line 80. What is the best way to address this issue?\n. I have one issue regarding obtaining the FQ name of a thrown expression. the following test fails: https://github.com/zgrannan/kotlin/blob/double_bang_if_then_intention/idea/testData/intentions/branched/ifThenToElvis/notApplicableForSimpleNPE.kt\nBecause for some reason it evaluates the FQ name of \"NullPointerException\" as \"main\"\nThe relevant method throwsNullPointerExceptionWithNoArguments is here: https://github.com/zgrannan/kotlin/commit/19aa1e8741477b71e4c3025a009aef3edefee70f#diff-82d95f27dda0d037ab2a6975cdd0774cR99\n~~Any clue where I'm going wrong here?~~\nEDIT: Nevermind, abreslev instructed me on how to fix this. I will modify the PR with the update.\n. I have updated this PR. Sorry, I thought that I had already commented, but it looks like I did not.\n. Regarding testing,\nShould the tests for intention-based inspections be based off some generator? All that was necessary was to remote the <caret> indicators from the tests from the intention.\nI was also thinking these tests may not be necessary, as the code that is actually being tested is the same code used for the intention.\nAny thoughts regarding this?\n. This inspection is based off of an intention that has already been tested. Besides modifications to XML configuration files etc, the only kotlin code that is being added here is one line in IfThenToElvisInspection.kt\nAll of the kt files in the testData directory for this inspection that have been added were copied from the testData folder from the IfThenToElvisIntention intention. So these new tests are really testing the same test files with just about the same code. \nThat said, these tests also ensure that the inspection detects expressions on the correct line and and displays the proper prompt to the user, which the tests for IfThenToElvisInspection do not do. So there could be reason to leave them as is.\n. Yes that should work \n(with one possible minor issue: the <caret> that indicates the caret position in the test file for Intentions does not apply to the tests for Inspections).\nShould I modify the test generator to provide an option to use the intention test files for the inspection?\n. Removed the test-cases I added and rebased off of current master\n. Updated to remove tests. (Now using the same test files as the intention)\n. I made changes based on your comments, and also modified the intention to handle triple-quoted string literals.\n. I will be submitting a PR for that one shortly.\n. Sorry about not responding earlier, yeah I agree that the function is tackling too many issues and could be rewritten. I will submit a new PR soon!\n. Submitted new PR: https://github.com/JetBrains/kotlin/pull/475, based on the code you wrote, and fixed problem with if statement.\n. ",
    "kuity": "I am Lingzhang Jiang, from CMU.\n. Hi Pavel,\nThank you for taking time to review my code.\nI have went through the issues mentioned I will try to fix all of them in my next commit.\n\nWhat do you mean \"intention will not display\"? Please clarify. If you mean the yellow bulb, I think it is shown correctly when I run your code.\n\nYes, that is what I meant. I was wondering if for example in Foo.get(x) , the yellow bulb should also display when the cursor is somewhere inside the get(x) and not just exactly before get(x)\n. > There are no tests for cases when some specific features of the language are used in call expression, see what happens for the following expressions:\nFor these 3 cases, would these be the correct behaviors?\n\na.get(i = 2)\n\nDisallow the intention action if one or more arguments have '='.\n\na.get(2) { doSomething() }\n\nCheck for a function literal after the ValueArgumentList and include that inside the ArrayAccessExpression.\n\na.get(2)\n\nTake out the type parameter list from the converted ArrayAccessExpression.\n. > By the way, did you solve your problem with the bulb?\nYes, I opened it in IDEA and its working correctly. It might have been an isolated instance or I remembered wrongly. Thanks anyway!\n. Yes, they are ready.\n. Issues:\n- [x] Variable Naming\n- [x] Unnecessary Comments\n- [x] Parens around function literal \n- [x] Use isNamed() instead of != null\n- [x] getFunctionLiteralArguments\n- [x] assert messages\n- [x] get instead of charAt\n- [x] avoid using mutable variable\n- [x] using isEmpty and isNotEmpty\n- [x] Code Formatting\n. Ready for review\n. Rebased\n. All but assert message issue addresed\n. Rebased, ready for review. \n. This for KT4549. I'm not very sure what to do about the rebasing. What happens is that I started work on it and then updated my repo and then continued working, so my commits are like:\n1. Own commit\n2. Own commit\n3-30. Other people's commits\n31. Own commit\nSo I rebased and squashed my own commits together and submitted a PR, which ended up looking like this. Should I just drop the other commits in git rebase -i ?\n. Thanks for the suggestions abreslav and geevee, I decided to go with using a reset plus cherry pick.\n. Hello Alexey,\nAs Jeremy appears not to be working on this any more, I have volunteered to take over.\nPlease pardon me if I am making mistakes as I am not familiar with this PR and have just acquainted myself today by reading over all the code.\nI have made a new PR at https://github.com/JetBrains/kotlin/pull/458, please check it out when you have time.\nThank you.\n. Ready for review.\n. Got it, added.\n. > I'd suggest to add a spot to both parts. Does the Java intention have only one?\nYeah, the Java intention only had for the first part.\n\nIf you mean these values as constants, use UPPER_CASE_NAMES. Plus did you intend to make them visible outside this class? If not, please use private\n\nYes, I meant them to be private. Will change it.\n\nHard-coded constant 4. Why, if you already have named constants above?\n\nYou are right. My mistake.\n\nCould you explain the meaning of the position parameter?\n\nYes. Given some binary expression, I need to get the immediate left and right operands. To get the immediate left operand, I need to call getLeft() on the expression. But if the resulting left operand is still a binary expression, I need to recursively call the function to get the rightmost operand now. And so the position parameter is used to determine whether to call getLeft() or getRight() on an expression.\n. > Could you answer comments in-place? It's a lot more convenient to have some context when reading your answers. Thanks\nOk, I got it. Will do that from now on.\n. Ok, I made the edits that you brought up.\n. Ok, I made the change with regards to the enum. Was this what you meant?\n. Hi pTalanov, thanks for the review.\nI have made the changes that you suggested and made a new commit.\nI think since the other IDEA intentions work this way, it would be better if I stuck to the convention.\n. Ok, fixed the highlighted issues.\n. Ok\n. Hi Pavel,\nReminder that this PR has been updated with the newest edit. Thanks.\n. Ok, fixed it.\n. No prob. Thanks!\n. Hi Alexander, thanks for the quick response. I will attempt to fix this asap.\nSummary of review so I won't miss out anything:\n- [x] JetBundle.properties\n- [x] Mutable var\n- [x] Simplify paramsTextRange if else statement (explicit)\n- [x] descriptor doesn't need ?\n- [x] simple check before complex check\n- [x] Naming of old/new parameterlist\n- [x] Warning in ?.\n- [x] && DeMorgan in if statement (explicit)\n- [x] && DeMorgan in if statement (implicit)\n- [x] Simplify paramsTextRange (implicit)\n- [x] Refactor the applicability\n- [x] Changing the order of checks to improve efficiency\n- [x] Simplify confusing test case(lambdaWithLambdaParam)\n- [x] Elaboration of intention description\n- [x] Implicit -> remove braces from params list\n- [ ] Implicit -> Availability of implicit intention when types could not be resolved\n- [x] Explicit & Implicit -> Availability should be up to and including > in a lambda\n. Ok, most of the problems should be fixed.\nHowever, I'm still having an issue with the expected type problem.\nI think I understand what you are saying, and I have looked at a few applications of BindingContext.EXPECTED_EXPRESSION_TYPE, however, when I tried to apply it in my intention, the expected type always seem to be null even if the type for the lambda is specified, say in the val declaration or in a class declaration(See the commented out code in MakeTypeImplicitInLambdaIntention.kt).\n. Ok I think I get what you're saying. So I would have to get the types that were specified in the lambda and the types that are expected and compare them. May I ask what would be an application of a lambda in a binary or unary expression? Not very sure about that.\n. Made changes + made new PR.\nFor the failed test case I added an ACTION direction.\nAlso I modified hasExplicitParamType() function in MakeTypeImplicitInLambda intention to do one more check.\n. Ok, issues have been addressed(I hope).\nAs per the commit message, I added a test to verify the white-space generating code segment.\n. Alright, fixes are made.\n. Ok, those problems should be fixed. Added a test case for the issue you mentioned. I jumped the gun and rebased off the new master as I realized my master was rather out of date.\n. Thanks, Alexander!\n. Hi Andrey.\nGot it, will add more tests. \n. Added more cases and fixed the case that you mentioned.\n. Ok, added many more test cases and fixed the mentioned problems. Pending second review.\n. Oops, it's properly rebased now\n. Fixes made.\n. Ok, fixed.\n. Squashed and rebased.\n. Thank you.\n. My bad. I must have missed it. Will fix.\n. Oh I see, I put them in to prevent code duplication in applyTo(). Will change it.\n. That's a good point. I'm actually not too sure when parameter.getNameIdentifier()?.getText() or for that matter, parameter.getText() would fail so I haven't been able to test these. \n. Ah I see, you are right xD\n. ",
    "RossHanson": "Ok, I think I have fixed it, though I'm not familiar enough with GitHub itself to ensure the rebase worked. As far as I can tell, everything has been reduced to a single commit?\n. Fixed commented issues, appears some of them were due to a incomplete rebasing. Added consistent caret placement and additional test for \"foo.get(1,2\". Slightly unsure about the comments as the description and example comments but I think it's now consistent with conventions.\n. Ah sorry, I've amended the commits and pull request description.\n. Fixed the unnecessary PsiErrorElementImpl check, missed DeMorgan conversion, and odd formatting for the binaryElement declaration.\n. -Changed calls to getFirstChild() and getLastChild() to getLeft() and getRight()\n-Changed \"||\" and \"&&\" literals to JetTokens.*.getValue()\n-Pulled operator value out of the while block for ConvertNegatedBooleanSequence\n-Fixed ConvertNegatedBooleanSequence commit placement\n-Changed to getBaseExpression call for JetPrefixExpression\n-Added support for !(!a ||,&& b ||,&& ...) expressions\n-Fixed some rebase artifacts\n. Ah, I didn't realize we could overload prefix expressions like that; definitely a cool feature. Anyway:\n-Fixed negation setup for expressions like !(+a && b) and !(!a || b).\n-Added tests for !(+a && b) type expressions (nonstandardPrefixOperator.kt). My last commit actually  a test for (!(!a || b)) (mixedExpression.kt and longMixedExpression.kt) but I've adjusted them to reflect double negations.\n-Changed getLastChild() call to getBaseExpression()\n-Removed operator text from while block and added exception for the else condition.\n-Updated exception text in both intentions to be more informative \n. Ah, that makes sense; I've updated the exception message to reflect this.\nAlso, I realized there was a bug in ConvertNegatedExpression in which isApplicable would return true for operators besides \"&&\" and \"||.\" I've fixed this and added a relevant test (inapplicableOperator.kt).\n. Thanks!\n. Hi Alexander,\n1) No, that is not intended behavior. The parentheses should have been\npreserved; I'll fix that ASAP.\n2) That does seem like a better name choice. If it's no problem elsewhere,\nI'll refactor the code to reflect it.\nOn Apr 16, 2014 2:23 PM, \"Alexander Udalov\" notifications@github.com\nwrote:\n\nI have a few questions.\n1) Is it intended that any complex expressions are not supported by this\nintention?\nFor example,\n!(true && 1 == 2) becomes !true || !1 == 2, which is a red code\n!(1 == 2 && true) -- not applicable\nThis practically makes the intention useless in a lot of cases.\n2) In Java a similar action is named Replace '&&' with '||' or Replace\n'||' with '&&'. Why such a scary name here, if it does the same?\ncc @max-kammerer https://github.com/max-kammerer\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/JetBrains/kotlin/pull/409#issuecomment-40633844\n.\n. Hi udalov and everyone,\n\nBecause this issue is closed, I've submitted a fix for the bug affecting ConvertNegatedExpressionWithDemorgansLaw at #448. I believe the same issue affects ConvertNegatedBooleanSequence so I'll pushing a commit to fix that as well shortly. \nAs for renaming the function, I don't think we can actually use the same name as the Java equivalent, due to the fact each intention operates on both '&&' and '||' so I'll try to come up with some more user friendly and change it with the next commit. \nThanks for pointing out the bug!\n. Sorry to respond so late; I was unexpectedly without a computer all last week. Anyway, I've fixed the style issues, lack of tooltip for functions without FQ names, and added functionality for functions like plus as well as 3 test cases. \nI haven't been able to figure out how to add a breakpoint on a single click, as simply returning null like in Java does not work. However, a double click will still add a breakpoint. Finally, I tried to get generateTests working with the LineMarker tests but figured that was ok to leave for a later update. \nAh and finally, there is a bit of hack in which \"this\" is explicitly filtered out of permissible recursive functions. I don't understand why in an example like \"fun A.plus,\" the \"this\" keyword is treated as a reference to \"A.plus\" and not the instance of \"A\" when the line marker pass occurs. If there is a cleaner fix for this, I'd be happy to implement it!\n. 1. Done\n2. Removed these cases entirely. I'll try to reintroduce them if there's a clean way to do so\n3. Done\n4. Realized I didn't actually need the array aspect so I switched to a simple LinkedList instead.\n. Hi udalov,\nSorry to be getting back to you so late - end of the semester is always hectic! Anyway, I believe made all of the requested changes except for supporting multi-parameters with AddIndices and prompting for the intention only if the caret is in the for loop header. I'd be happy to support mutli-parameters but I wanted to go ahead and submit this PR since it'd already been so long. As for only prompting on the multi-parameter, would you know how I would go about doing that? Using the self-targeting intention base class, it seems I would have to trigger on either the loop range or the variable, which seems like it would be a bit of an inconsistent user experience. \nThanks!\n. I believe without it, the isApplicable function can return true when there are syntax errors in the target code. Running the intention on this code can then lead to unexpected results, which I thought may be a poor user experience. \n. Are you referring to the 'if (!(...) && !(...))' statement? I can't believe I didn't think to transform that! \nI've fixed this oversight in the latest commit. \n. Ah right! I've fixed this, though I don't quite follow what you mean by checking other block conditions (outside of a DeMorgan transformation). These issues are fixed in the new commits.\n. ",
    "asedunov": "Ok, looks good enough for me. Two more things before we can integrate it to Kotlin:\n1) These intentions should work for both operator functions declared in classes and operator functions declared as extensions. For that reason tests should also cover those cases where operator function is an extension.\n2) Since now we have intentions with dynamic descriptions, it makes sense to test that description is chosen correctly. I suggest to introduce new \"metadata comment\" (say, // INTENTION_TEXT: ...) and check that it matches actual intention description in AbstractCodeTransformationTest.\n. You're welcome. \nWe greatly appreciate your contribution\n. Could you, please, rebase your pull request to the current revision of master\n. Please, rebase you changes on current master and then we can merge them\n. Yes, squash the commits, please\n. As intention test data were modified, rebase your PR once more and fix failing tests if any, please\n. Some tests are still failing due to resolution errors. For example, in nonRepeatingAssignment.kt you have \nfun foo() {\n    var x = 0\n    <caret>x = y + z\n}\nwhich produces two \"unresolved references\" errors (for y and z)\nSo, please, either fix test data so that no errors are produced (this options is preferable), or add necessary // ERROR: directives\n. Merged. Thank you!\n. What tests are you speaking about?\n. Do you have any progress in fixing compilation/tests?\n. Do you mean quickfix tests? In this case you can just update corresponding test data so that your intention appears there.\n. Continued in https://github.com/JetBrains/kotlin/pull/458\n. There is no need to create pull request for reverse transformation, since it corresponds to the same issue (http://youtrack.jetbrains.com/issue/KT-4563). Besides, that's not a good practice to create pull request without some description.\nI'm closing this pull request, so please put all commits related to KT-4563 into the original one (https://github.com/JetBrains/kotlin/pull/386)\n. Looks good enough.\nThank you for your contribution\n. I've modified inspection test so that it can reuse existing intention test data. You can enable inspection test for particular intention by adding \"inspectionData\" directory inside of corresponding intention test data. Use testData/intentions/attributeCallReplacements/replaceGetIntention/inspectionData as an example.\nMake sure your PR is rebased against current master. \n. This intention doesn't work as intended. It should swap then/else branches, not just negate an \"if\" condition. Please, look at how \"Invert If condition\" works in Java.\n. PseudocodeUtil.generatePseudocode() is pretty much an equivalent. Why do you need one?\n. Thank you. Your changes are merged to master\n. Please, squash your commits and rebase against current master\n. Merged to master. Thank you.\n. Please squash all the commits together\n. Merged. Thank you!\n. Merged. Thank you\n. Merged, thanks\n. Last two commits could be squashed together\n. Merged, thanks.\n. It's probably worth converting isOverrideHierarchyElement() function to extension\n. Merged, thanks\n. Merged. Thank you\n. Merged, thanks\n. Pushed to master\n. Pushed to master, thanks\n. Pushed to master\n. Ok, seems good to me\n. Thank you for your contribution! I'll add some tests and do a manual merge afterwards. Merged, thank you!. Thank you!. Thank you!. Merged, thank you!. Merged. Thank you for the fix. Merged, thank you!. Thank you! I'll merge it manually. Merged, thank you!. Merged, thanks. Merged manually. Thank you for your contribution!. Merged to master. Thank you!. I'll merge it manually. Thank you for your contribution!. Merged! Thank you. Merged! Thank you for your contribution. Merged! Thank you. Merged manually. Thnak you!. Merged manually. Thank you for your contribution!. Merged! Thank you. Merged manually. Thank you!. Merged! Thank you for the contribution. Merged! Thank you. Thanks! We'll merge it manually. Merged manually. Thank you!. Merged! Thank you. Merged! Thank you. Merged! Thank you. Merged to master. Thank you!. Merged! Thank you. By convention every significant word in the intention family name should be capitalized. Compare unfold.assignment.to.when and unfold.assignment.to.when.family, for example\n. 1) Extract element.getLeft() just like you did for element.getRight() (let's call it leftExpression)\n2) There is no point in using element.getRight()/element.getLeft() in comparisons since they are/will be extracted to variables\n3) leftExpression !=null is redundant (it's implied by leftExpression is JetSimpleNameExpression)\nThe same goes for element.getRight() != null\n4) Also I'd change the function name since it doesn't just check for null safety. Something like isWellFormedAssignment, for example.\n. 1) JetPsiMatcher class provides more reliable and generic way to compare PSI elements. Please, use it instead of comparing element text directly. For example, JetPsiMatcher.checkElementMatch(variableExpression, expression.getLeft())\n2) I suggest to use when expression instead of nested \"ifs\". Like this:\nreturn when {\n    JetPsiMatcher.checkElementMatch(variableExpression, expression.getLeft()) -> ...\n    ...\n}\n3) This function is tail-recursive, so it's worth annotating it with tailRecursive. Then compiler can apply tail-call optimization to it.\n. It may be dangerous to permit transformation in cases like a = b + a and a = a + b + c. Since operators are overloadable in Kotlin, we can't guarantee that + and * are both commutative and associative aside of several builtin functions operating on types like Int or String. So we need to check beforehand that operator is resolved to one of these predefined operations.\nThe idea is as following. First, we perform analysis of operator reference and get back descriptor of its containing class:\nval context = AnalyzerFacadeWithCache.getContextForElement(expression)\nval descriptor = context[BindingContext.REFERENCE_TARGET, expression.getOperationReference()]?.getContainingDeclaration()\nThen we can check that descriptor corresponds to one of the \"safe\" types (like primitive ones or String) using KoltinBuiltins class.\n. This function is also tail-recursive, so please add [tailRecursive] annotation.\n. It would be better if we could show more specific description instead of some generic \"operator-assign expression\". For example, when applying intention to a = a + b, show \"Replace with += expression\". In order to do this you need to change intention description dynamically by calling setText(\"...\") inside of isApplicableTo() method\n. Yes, in this case descriptor should be ClassDescriptor which exposes corresponding type through getDefaultType() method\n. Could you show the code?\n. It still produces unnecessary code. If a has a non-nullable type, a == b should be replaced by a.equals(b), not a.equals(b) ?: b.identityEquals(null)\n. This function is not available anymore. Please, rebase against current master and use AnalyzerFacadeWithCache.getContextForElement(element) instead\n. Basically, we need to retrieve ResolvedCall corresponding to call of interest and check if resulting function is invoke.\nval resolvedCall = AnalyzerFacadeWithCache.getContextForElement(element)[BindingContext.RESOLVED_CALL, element.getCalleeExpression()]\nval descriptor = resolvedCall?.getResultingDescriptor()\nif (descriptor is FunctionDescriptor && descriptor.getName().asString == \"invoke\") {\n    // do whatever we need\n}\n. Please, add test for the case of non-nullable receiver\n. Condition element.getParent() !is JetDotQualifiedExpression is too restrictive. If, say, you have class A (val foo: (Int) -> Int), then a.foo(1) can be safely transformed to a.foo.invoke(1) and vice versa\n. The branches aren't swapped in the after-template\n. Please add some tests for the cases where \"if\" is used as an expression, like \nval t = if (a > 0) a else -a\nCombinations of valued ifs with returns and other \"jumps\" is of particular interest, e.g. return if ... or val t = if (a > 0) a else return 0, etc.\n. You can do it via rename: expression.mainReference.handleElementRename(\"\") (look at KtSimpleNameReference.handleElementRename(String)). ",
    "hhariri": "There's also the issue of main not being detected when using varargs as opposed to Array. \n. ",
    "ilya-klyuchnikov": "FYI: I repeatedly getting NPE from this intention - http://youtrack.jetbrains.com/issue/KT-4683\n. I guess, that NPE is caused by concurrent modifications. I very often get this NPE when opening/closing second/third project. Look that this happens inside codeInsight daemon thread:\nnull\nkotlin.KotlinNullPointerException\n    at org.jetbrains.jet.plugin.intentions.RemoveBracesIntention.isApplicableTo(RemoveBracesIntention.kt:49)\n    at org.jetbrains.jet.plugin.intentions.RemoveBracesIntention.isApplicableTo(RemoveBracesIntention.kt)\n    at org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention$getTarget$1.invoke(JetSelfTargetingIntention.kt:37)\n    at org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention$getTarget$1.invoke(JetSelfTargetingIntention.kt)\n    at org.jetbrains.jet.lang.psi.psiUtil.PsiUtilPackage-jetPsiUtil-3e25f7d0.getParentByTypesAndPredicate(jetPsiUtil.kt:68)\n    at org.jetbrains.jet.lang.psi.psiUtil.PsiUtilPackage.getParentByTypesAndPredicate(jetPsiUtil.kt:1)\n    at org.jetbrains.jet.plugin.intentions.JetSelfTargetingIntention.getTarget(JetSelfTargetingIntention.kt:37)\n    at org.jetbrains.jet.plugin.intentions.RemoveBracesIntention.isAvailable(RemoveBracesIntention.kt:38)\n    at com.intellij.codeInsight.intention.impl.config.IntentionActionWrapper.isAvailable(IntentionActionWrapper.java:56)\n    at com.intellij.codeInsight.intention.impl.ShowIntentionActionsHandler.isAvailableHere(ShowIntentionActionsHandler.java:113)\n    at com.intellij.codeInsight.intention.impl.ShowIntentionActionsHandler.availableFor(ShowIntentionActionsHandler.java:104)\n    at com.intellij.codeInsight.daemon.impl.ShowIntentionsPass$3.process(ShowIntentionsPass.java:276)\n    at com.intellij.codeInsight.daemon.impl.ShowIntentionsPass$3.process(ShowIntentionsPass.java:273)\n    at com.intellij.codeInsight.intention.impl.ShowIntentionActionsHandler.chooseBetweenHostAndInjected(ShowIntentionActionsHandler.java:138)\n    at com.intellij.codeInsight.daemon.impl.ShowIntentionsPass.getActionsToShow(ShowIntentionsPass.java:272)\n    at com.intellij.codeInsight.daemon.impl.ShowIntentionsPass.getIntentionActionsToShow(ShowIntentionsPass.java:212)\n    at com.intellij.codeInsight.daemon.impl.ShowIntentionsPass.doCollectInformation(ShowIntentionsPass.java:186)\n    at com.intellij.codeHighlighting.TextEditorHighlightingPass.collectInformation(TextEditorHighlightingPass.java:61)\n    at com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass$1$1.run(PassExecutorService.java:380)\n    at com.intellij.openapi.application.impl.ApplicationImpl.tryRunReadAction(ApplicationImpl.java:1153)\n    at com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass$1.run(PassExecutorService.java:371)\n    at com.intellij.openapi.progress.ProgressManager.executeProcessUnderProgress(ProgressManager.java:209)\n    at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:212)\n    at com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass.doRun(PassExecutorService.java:368)\n    at com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass.run(PassExecutorService.java:344)\n    at com.intellij.concurrency.JobLauncherImpl$VoidForkJoinTask.exec(JobLauncherImpl.java:193)\n    at jsr166e.ForkJoinTask.doExec(ForkJoinTask.java:260)\n    at jsr166e.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:858)\n    at jsr166e.ForkJoinPool.scan(ForkJoinPool.java:1687)\n    at jsr166e.ForkJoinPool.runWorker(ForkJoinPool.java:1642)\n    at jsr166e.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:109)\nI guess that this action is used in several threads simultaneously by the daemon.\nSo, saving expressionKind into a var seems to be a root cause for NPE.\n. ",
    "jdkaplan": "Updated both.\nAlso, my intention (for some reason) breaks some unrelated tests. Is this just my system (due to update weirdness) or is it something I should investigate?\n. I forgot exactly which ones. I can't get them now due to compilation errors. I rebased on upstream/master and now nothing compiles (due to java: cannot find symbol in storage, lang, and descriptors). I'll have a list once I can get it to compile again.\n. Yes, my compilation errors were solved with a round of updates to IDEA/Kotlin/dependencies. \nI'll update with a list of tests next time I get a chance to work on this. Right now, I seems like some tests break because my intention is applicable during their operation, and there should be some sort of annotation that disables my intention for that test.\n. Apparently some divergence occurred somewhere in here. Do I need to do anything about this?\n. I believe I've cleaned things up.\n. This line feels like a hack. It also doesn't preserve comments. Is there any way to get the contents of the indices without losing comments?\n. functionCandidates is always null for me here. I think it has to do with me using a the PsiElement left rather than a JetElement. I can't seem to figure out what it is, though. Is there a way to create a JetElement from a string?\n. I can't seem to fix the source of this error, so I declared it.\n. This wouldn't work unless the second argument was a function. Is it still possible to give multiple indices to this construct (i.e, a[i, 2])?\n. I don't understand this error.\n. I don't understand this error.\n. I was told to use the val context ... and val functionCandidates ... lines would allow me to see whether a method such as plusAssign was defined on a in a += b. \nWhat should I be using instead?\n. I've been following this page: http://confluence.jetbrains.com/display/Kotlin/Operator+overloading\nIs get simply not defined this way on Array? Should I make a small class for this test case, or can I use something that already exists?\n. Is there a such thing as an UNAMBIGUOUS_REFERENCE_TARGET? \nI guess what I'm really asking for is directions to other places where the functions defined on the class of the contents of a JetExpression are determined.\n. ",
    "amal": "Tests improved, so locale now really makes difference.\n. Oh, sorry, did not pay attention that it is in generated file. My fault. PR updated.\n. You are right. Added. It seems to be no more negations in comparison.\n. @abreslav Cause we need to return Int instead of Boolean? So usage of \"<\" will add two useless conversions: from Int to Boolean and vice versa.\n. ",
    "nskvortsov": "Will try to move into different branch\n. OK, I extracted common integration test code to separate module. removed extra binaries and cleaned up annotations in test data\n. 1. Fixed constructor parameter\n2. Removed explicit type definitions\n3. Removed unused files from android test project\n. Since 1.11, as far as I can see.\nYet the plugin currently supports Gradle versions 1.6+\n. thanks!. Modules are stored as children of Project node. Full recursive search will visit huge number of extra nodes (e.g., dependenices).. ",
    "prybin": "I guess this patch should address all the comment that the previous patch received.\nI am not sure I entirely clear understand JS approach to hashcode/equals:\n1. maps.js calls method named \"equals\", while the actual method name should be mangled; I tried to fix it naively;\n2. collections expect hashcode to be string, while signature clearly demands integer; I tried to work with the latter, as we probably need interoperability with Java platform; it required adding hash calculation for strings; don't know whether I push in right direction.\n. > Another suggestion -- please don't overwrite commits, it complicates reviewing.\nThank you. Haven't committed to github before. Was totally possessed with idea that commit sequence go 1 to 1 to resulting master branch log, so I tried to keep the history clean.\n. > Function is not pre-created but it will be cached after first access.\nMy bad, didn't properly trace it.\n. I pushed another commit. I must address everything, except for toString/equals/hashCode calls, which I guess needs more discussion.\n. I redesigned hashcode.kt test (old version went to keyrole.kt as testing how a data class works in a role of map key). The new test only directly compares hashcode values.\nI tried to intensively use language features and collections framework. I ran into some difficulties, which are likely from my missing something in the Kotlin syntax. However, some probably indicate documentation inconsistency. I put everything in temporary comments.\n. That means I cannot reply on github to you...\n2014-05-05 15:05 GMT+04:00 Zalim Bashorov notifications@github.com:\n\nClosed #453 https://github.com/JetBrains/kotlin/pull/453.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/JetBrains/kotlin/pull/453#event-117787939\n.\n. Would you like to have the rename commit still separate?\n\n2014-05-05 15:02 GMT+04:00 Zalim Bashorov notifications@github.com:\n\nWell, I think it close to merge to the master. But before do it we should\nclean up code and history.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/JetBrains/kotlin/pull/453#issuecomment-42177322\n.\n. renamed\n. Thank you for your guidance. It was an interesting introduction to Kotlin.\n. \n",
    "K0zka": "I have only tested the patch manually. I am trying to write test and added to the kotlin compiler tests, the problem is that the about 4200 of the ~8000 tests fail on master in my environment with this exception:\njava.lang.AbstractMethodError: org.jetbrains.jet.lang.resolve.calls.model.VariableAsFunctionResolvedCallImpl.getDataFlowInfoForArguments()Lorg/jetbrains/jet/lang/resolve/calls/model/DataFlowInfoForArguments;\nBtw VariableAsFunctionResolvedCallImpl indeed does not override getDataFlowInfoForArguments...\nAlso, I have found no information on how to run the tests from ant or maven, both seem to ignore the mentioned compiler tests.\nCan you help?\n. I have completely rebuilt and executed the tests again, but it resulted in the same set of test failures. I looked at the bytecode generated by the kotlin compiler and it looks OK, however the getDataFlowInfoForArguments method resolved from ResolvedCall interface was not compatible with the interface definition. Interestingly if I cast the ResolvedCall to MutableResolvedCall and then call the method, it works.\nPossibly something is wrong with the bytecode generated from VariableAsFunctionResolvedCallImpl. Same results with jdk 1.6 and 1.7\n. Hi Alexander,\nThank you for your assistance, I noticed that the build downloads a snapshot version of IDEA, and with that version the tests worked fine. I will be back with the updated patch with tests included in a few days/weeks.\n. Indeed it is problem. I splitted that method to two different methods. see https://github.com/JetBrains/kotlin/pull/479\n. - Added test for empty list and set for plus and minus\n- Added test on duplicates in the collections\n- assertTrue replaced with assertEquals\n- set tests\nLooks like all done\n. oops, screwed by branch, replacement for this pull req: https://github.com/JetBrains/kotlin/pull/547\n. Thank you, Ilya!\n. replaced https://github.com/JetBrains/kotlin/pull/893\n. I understand that, at the same time I need optimizations, please decide if you want it in kotlin or I should keep it in my own project.\n. purely cosmetic change, TODO(\"something\") is so much more easy to spot since it means code is not ready, compared to throwing an exception - which in some cases can be the implementation of the function\n. > list of\noops\n. ",
    "AbeJellinek": "I swear I ran the tests, too. Sorry. I'll fix it as soon as possible.\n. I'll reopen this issue once I get it fixed.\n. ",
    "ilya-g": "An extension function run with the required signature was introduced.\n. Thanks for the PR, but we've decided not to provide event listeners facility in the standard library. Therefore we've removed these classes from kotlin.properties package entirely.. Would it be possible having a value of Iterable<T> to check whether it is an instance of List<T>?\n. Prohibiting unchecked cast to non-runtime-available types would render some of our APIs impossible\n. Good work!\nAlthough we'll have to adapt it somehow to be compilable to JS: namely we do not have Integer.SIZE and Integer.MAX_VALUE constants there.\n. Thanks for your pull request. I've merged it manually. You can review the changes here.\n. This would slightly change the behavior, better to let user to decide manually.\n. Merged manually and regenerated docs after, thanks for PR.\n. https://youtrack.jetbrains.com/issue/KT-8020 is going to be fixed in Kotlin/JS compiler in 1.1.4. merged manually\n. - [x] need to add dependency on kotlin-test (-junit?)\n- [x] name, description, url in archetype's pom\n- [x] kotlinVersion in kotlin-only archetype\n- [x] no need to set url in resulting project pom\n- [ ] ~~default package $package seems to be derived from artifactId~~\n- [x] minor: folder structure should reflect package structure (packageInPathFormat)\n. Archetype provider: \n- [x] support dash versions, \n- [x] filter archetypes to have same major.minor version as the plugin has (consider also .patch as the patch versions can introduce source incompatibilities and it would be misleading if the maven-plugin compiler and the idea-plugin compiler would produce different compilation results)\nArchetypes:\n- [x] archetypes as submodules in parent pom\n- [x] JVM: kotlin-test-junit scope=test\n- [x] JS: index.html instead of tests to launch js built from Hello.kt, description in readme or Hello.kt comments how to launch build results\n- [x] Hybrid: take down for now\n. No, it's not required, the implementation is fine, but we need some time to discuss internally about inclusion of these functions in the stdlib.\n. Thanks, Gabriel, I've merged this PR manually.\n. Thanks for PR, I've merged it manually\n. Since we have no plans merging this PR in the standard library (see this comment in the related KEEP discussion), I'm closing this for now.\nSince it's linked to the KEEP, it would be easy to recover it when it will become required again.. This PR has not gone through a discussion as a KEEP proposal or at least as a youtrack issue.\nSince we have no plans merging it to the standard library I'm closing it now.. Thanks for PR.\nI've decided to reformat js-stdlib instead, including removing of redundant semicolons.\n. I'm going to close it for now, but I've added a reference to this PR to the issue.. > I hope they don't add too much extra mental load\nNevermind, I'll squash some commits together anyway.\nBtw, you can do it yourself and force push to your branch.\n. Oh, then it's ok. It's compensated by much less mental load from clean tests.\n. I propose making it a separate PR (branched on the top of this one)\n. This was superseded by PR #846. I've squashed several commits, made some improvements and merged it manually.\nThanks for the great work.. merged manually\n. @geoand Yes,  please do a rebase and squash the third commit with the first one.\n. Ok, I've fixed minor issues by myself and merged manually, thanks.\n. Going to merge this one soon.\n. @K0zka I've merged it manually, thanks for PR.\n. @mikehearn had some concerns about this overload in slack, I'll quote him here:\n\ni guess my main concern/thought is that stdlib methods that abbreviate code by only a tiny amount should probably be things that you use all the time. map/filter/forEach/etc are all like this\npre-sized StringBuilders are usually an optimisation and that's not something you see every few lines\n. This approach is quite inefficient. The same functionality is to be covered by PR #839.\n. @oshai Can you explain why it's not relevant anymore? We still cannot delegate implementation of abstract  methods inherited from an abstract class to another instance of that class.. The code around that place is going to be refactored and the comment is likely to be gone. See PR #1008.. TODO\n- add SinceKotlin\n- add headers for platform specialized functions.. |libraries/stdlib/src/kotlin/collections/Grouping.kt:35|\n|---|\nI'm not sure how could it be possible without wrapping each value. And wrapping each value is very ineffective in terms of number of allocations.. > Why is this function called eachSumOf and not eachSumBy, which would be consistent with Iterable.sumBy?\n\nWe're going to rename sumBy and sumByDouble to sumOf for Iterables, however it's blocked by KT-11265. Maybe we should not introduce eachSumOf until then.. By the way, there is no need to close pull request and submit another one, when you want to add some edits. You can push you commits to the same branch (or even force push them), and they will be attached to the same review.. Relates to https://youtrack.jetbrains.com/issue/KT-8247\n. We have introduced these constants as SIZE_BITS and SIZE_BYTES in each companion object of the integer primitives, i.e. excluding Float and Double types. See this commit: a2eb62d8f1370b2f152f21f6c9cd605d9f85758c. Since this change is going to be targeted to version 1.2, please annotate new API with @SinceKotlin(\"1.2\"). The work is continued in branch rr/stdlib/bignumbers. I've merged it as 7ebd86725f0, thanks.. It's interesting that Lock.withLock() acquires the lock uninterruptibly and on the other hand Semaphore.withAcquired acquires the semaphore interruptibly. Is there a reason for this difference besides the default method is used in each case? . Thanks for spotting this. I'll merge this after all tests have run.. Thanks for the fix!. Note that you could just force push commits to your branch and they will be updated in the related PR immediately. There's no need to close it and create another one.. Nice function, though there are some implementation decisions that need to be discussed:\n- what should be the default case of characters and whether should it be customizable?\n- do we need an optional byte separator, like space?\n- do we need to cover the use case of separating longer groups of bytes, for example to have a newline after each 40 bytes?\nPerhaps it's worth to write a KEEP to have a place for discussion, or at least an issue in the tracker.. Thanks, I've merged it manually.. I've merged it with #1160 manually.. This pull request in making no progress so I'm going to close it for now. I'll merge however doc fixes for getProgressionLastElement function.. > I'm using the same sample for every kind of Array. \nThat's enough to give the usage example.. It would be nice to cover this with some tests, despite that they might look trivial.\nTo get this merged, we should first discuss this function on a design meeting, and it could take some time to complete, so please be patient.. @pun-ky While Kotlin encourages working with non-nullable values it also provides expressive ways of dealing with nullable ones, e.g. safe call ?. and elvis ?: operators. It might be advantageous to turn an empty collection into null and then use these operators:\nval keywords = getFilterKeywords().nullIfEmpty() ?: return\n...\nSo there's nothing wrong with this feature request. \nThough in Kotlin 1.3 the issue KT-15695 was implemented in a different way: as a more general purpose function ifEmpty, so that ifEmpty { null } could be used instead of nullOfEmpty().\n. Could you explain why this fix is required? As far as I can see here https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/split.html there's no problems with this particular overload.. Then it seems to be a bug in Kotlin IDE plugin, please file it to http://kotl.in/issue. That's strange, 'cause I don't see a newline in the limit parameter in the sources of the first overload (they could be navigated to right from the docs page). Do you?\nWe should investigate where that new paragraph comes from, when the page is built.. While we agree that having date/time API is essential, we don't think that JS Date is an example of a good API design.\nWe have plans to provide typed Kotlin definitions for https://www.npmjs.com/package/js-joda. This way one will be able to use the same date/time API in JS and JVM.. The most of the missing members of JS date were introduced in the commit 43302ce00. I've merged it with minor edits: https://github.com/JetBrains/kotlin/compare/485ca10~2...485ca10. Please see this comment about the plan for multiplatform test annotations: https://youtrack.jetbrains.com/issue/KT-19696#comment=27-2419074. Thanks for PR anyway, I think I could partially use it later.. I've rebased it to the latest 1.2 branch and run it on build server. The branch is https://github.com/JetBrains/kotlin/compare/1.2-Beta2...rrr/1.2-Beta2/pr1300\nAs far as I can tell, all relevant tests are passing: https://teamcity.jetbrains.com/viewLog.html?buildId=1187205\nIf you don't mind I'll squash the first two commits.. I've merged it to the master, thanks for your effort.\nhttps://github.com/JetBrains/kotlin/compare/781ca6d~2...781ca6d. @paplorinc no, it's all good here, I think no changes are needed. But we need to discuss this behavior change in the language committee, so it may take some time to be accepted.. I've addressed the remaining issues and merged it into 1.3-M2 branch.\nThanks for the PR.. Sorry, but the size of this proposal isn't justified by the problem it tries to solve.. Thanks for the PR, I've merged it. \nIt really results in less code being produced both in JVM and JS!. @fvasco Done, I've just used the inspection, that checks that rangeTo can be replaced with until. Here are the results (preliminary): 81aaf6f1cd05a77d49376f23f8e57080cd6588e0. Thank you for the contribution, I've merged this PR manually with some corrections on top of it.. > Maybe we should put this text inside libraries/stdlib/samples/test/samples/README.md\n@ltongues Sure, I'm going to write one soon.. Very well, now it's much better. I'll just change thenComparator sample not to use listOf(*array), since sorted* functions always create a copy of list, then squash all these commits and merge them.. Squashed and merged, thanks!. Nice, it would be interesting to compare this implementation with PR #1008.. Thank you for your efforts,\nI'm going to close this for now according to the comments in KT-20891. I've merged it manually with some improvements, thanks.. Thanks for spotting!. I'm closing this for now according to the reason in the issue \u2014 until the compiler is able to eradicate that redundant bytecode during inlining.. Regarding the proposed append parameter of outputStream -- it should be possible to add it (better with an overload in this case), but this proposal should be backed with use cases, which are not covered by File.appendText and appendBytes. If you know some, feel free to submit the proposal to YouTrack.. @colriot @piotrek1543 Thank you guys for the PR and other ideas.\nI've merged it partially and named the length variable in readBytes.. Thank you, I've merged it with some corrections (dca23e339a). Thank you. I've squashed the commits and merged them to master. They should get into the documentation with the release of 1.2.20.. Though it was noted that making UNINITIALIZED_VALUE just an instance of Any may complicate debugging, because instead of the name of the class UNINITIALIZED_VALUE@5305068a you'll get something like java.lang.Object@5305068a when evaluating/watching over lazy instance fields.\nThe proposed solution is to introduce internal enum for all such constant-like objects in the standard library.. Thanks, I've merged the samples with some minor edits. Thanks, I've squashed and merged it with minor edits (assertTrue/assertFalse instead of assertPrints for booleans). @Samaritan1011001 sorry, I've made some review comments, but forgot to submit the review, so they all were left pending.. Good, but some problems are still unaddressed.\n\nPlease reformat samples according to the Kotlin style guide (Ctrl+Alt+L could help to do that)\nString-to-number conversion samples should be extracted to a separate class with samples.\nThe second argument of assertPrints should be a literal string\nfunction and local variable names should be camel-cased\ntrailing spaces in trim* samples will be invisible when printed\n. Ok, I've compared the results with the reference implementation and added more test cases, all seems fine.\nI'll make all remaining minor edits by myself and merge it.. I've finally merged this PR.\n\n@Meztihn, Thanks for your effort and patience.. Thank you, I've merged the samples and added some operations on these constructed ranges there.. Have you tried to regenerate code from templates and see what happens? \nAdding sample for a template itself doesn't have any effect. You need to place the sample reference in the doc { } block.\nThe command to regenerate stdlib sources is here: https://github.com/JetBrains/kotlin/tree/master/libraries/tools/kotlin-stdlib-gen. Do you have plans for other coerce* function samples?. I think it would be just inconsistent only to provide coerceAtLeast with samples leaving other coerce* (at least coerceAtMost) functions without ones.. Thanks, I've merged it manually and added missing samples for comparable types and coerceIn with  ClosedFloatingPointRange parameter.. Thank you for the sample.\nI've merged it, but moved the Sets class into the samples.collections.Collections class.. Thanks for idea, I've merged an alternative way to fix that.. Questions to discuss: \n- should there be overloads with startIndex for Iterable and Sequence, given that they do not have efficient way to skip elements.\n- should we leave overloads like List<T>.indexOf(element: T), those that delegate search to the list itself, which may be more efficient.\n- how to implement List.indexOf(element, startIndex) better:\n  - using indexed access\n  - using listIterator(startIndex)\n  - using subList().indexOf(element). Interesting idea, but the name of the function should chosen more thoroughly.. I've improve this sample a bit and merged it manually, thanks for the PR.. Looks good, please add a test that split fails with IllegalArgumentException on negative limit for each code path.. All tests have passed, so I'm going to merge this soon. Would you mind if I squash some commits?\nCould you also share the code of benchmarks? A comment here or a gist would be enough.. I've simplified it a bit more and merged, see the commits https://github.com/JetBrains/kotlin/compare/2805371bdcfa05bd2e72f86077f3a54518fd89ae~1...6b9520ec73c8a6c0f83d4ec3afd2a295364ed54a\nThank you for the PR.. Please do not merge master branch into your branch. Instead rebase your branch on top of master.. @Kerooker Do you need any help with this?. @Kerooker Sorry for your experience, that shouldn't work like that.\nThank you for your effort.. Looks good. Does it make sense to provide overloads for specialized streams as well?. @neonailol You can just force push to your branch, and this review will be updated accordingly.. The code seems fine now, next I'll run this branch on our build server.\nJust one question's left: do we need to specify something in build.gradle to trigger testng runner for test? Like \ntest {\n  // enable TestNG support (default is JUnit)\n  useTestNG()\n}. Thanks, I've merged the PR manually into master and 1.2.30 branches, see the commit range https://github.com/JetBrains/kotlin/compare/ad7701922c9c083875b759a30a8522ced734178a~1...0f130a0a5aa384393d5393166cfab8a9182d7fe1. Thanks, I've merged it.. Thank you. Since the fix affects the generated code template, could you also run the generator, just as the modified ReadMe section says? ;-) . Thank you, I've merged this PR manually with minor edits.. Closing this, according to the issue comment: https://youtrack.jetbrains.com/issue/KT-22869#comment=27-2709680\nIf you want to submit the docs improvement, please reopen this PR or open a new one.. > I choose to use assertPrints instead of assertTrue\nIt might be more readable when a sample contains just one assertion, but when there are several of them, you'd get the output something like the following if you actually run sample:\ntrue\ntrue\nfalse\nfalse\nSo it would be hard to correlate which expression yields which result.. Another option to get more compact but not less expressive samples for is* extensions is the following:\n```\nval chars = listOf('a', '\u03b2', '+', '1')\nval (letters, notLetters) = chars.partition { it.isLetter() }\nassertPrints(letters, \"[a, \u03b2]\")\nassertPrints(notLetters, \"[+, 1]\")\n```\nWDYT?. We have implemented this idea in PR #1738. Thanks, I've reformatted samples a bit and merged them with squash.. Related issue: https://youtrack.jetbrains.com/issue/KT-23279. Thanks, I've merged it into 1.3-M1 branch.. Thanks, I've merged your PR manually.. For builtin classes it's not enough just to declare companion objects, because builtin declarations are not compiled. The corresponding objects are to be provided in runtime and compiler must substitute them instead of the declared ones. This has to be done in all platforms (not sure about native though) respectively.\nI believe the more general solution https://youtrack.jetbrains.com/issue/KT-11968 should be provided instead for the purpose of declaring static-like extensions.. It has a lot of votes (you can add one), therefore it has a big chance to be considered when we're going to plan the next release.. I've reworked the sample a bit and merged it, thanks!. I'm afraid this PR may have a negative impact on the inlined bytecode size (similar to PR #1377) bringing no other measurable advantages to user. \nCould you inspect the bytecode of getOrPut function before and after the change?. How did you conclude that the bytecode size is the same?\nI've compared the bytecode of a usage like map.getOrPut(\"x\") { 2 } before and after https://www.diffchecker.com/yIPh6lUP and it could be clearly seen that some extra instructions were generated. I've fixed the docs, thanks for spotting this.. Related issue: https://youtrack.jetbrains.com/issue/KT-19805. Thanks, but we already have samples for String.toUpperCase and String.toLowerCase, see PR #1762. Only the jvm-specific overloads with Locale are left uncovered with samples.\nIf you're willing to provide them, please note, that a sample should illustrate why one would like to provide a Locale when calling toUpperCase/toLowerCase, for example by showing a difference between calling them with and without Locale argument.\nFeel free to reopen this PR or create a new one, if you're going to provide samples for these overloads.. We deliberately have omitted such functions because it's unclear whether it's is(NotNull)OrEmpty or isNot(NullOrEmpty). Part of this pull request is duplicated by PR #1531. Thanks, I've merged this pull request with the other one and incorporated it into 1.3-M1 branch.. This PR seems to be too quick, given that your ultimate goal is to remove error function entirely following the deprecation cycle, the issue must be discussed first by the language committee.\nTherefore I'm closing this for now, but I'll link this PR there in case if the issue would be approved.. Since _Collections.kt is a generated source file, the docs should be changed in the corresponding template instead: https://github.com/JetBrains/kotlin/blob/1.2.30/libraries/tools/kotlin-stdlib-gen/src/templates/Generators.kt#L1002. Thanks, I've added the remaining samples for Strings and Sequences and merged it manually.. Please do not use pull requests to ask questions. If you have a question, ask it in the forum https://discuss.kotlinlang.org/ or slack http://slack.kotlinlang.org/\nFor other Kotlin online resources please refer to http://kotlinlang.org/community/#kotlin-online-resources. Related issue: https://youtrack.jetbrains.com/issue/KT-14119. Nice. \nPlease move these tests https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/test/text/StringNumberConversionJVMTest.kt#L47-L82 to common StringNumberConversionTest class, to ensure these functions behave the same in JVM and JS.. FYI, you can push or force-push to the same branch to update pull request. There's no need to recreate it.. Thanks, merged!. Since kotlin-test-junit5 depends only on junit-jupiter-api and doesn't bring the implementation as a transitive dependency, so that that dependency has to be declared in a consuming project, it makes sense to depend on the minimal compatible  junit api version instead of the latest.. Thanks, I've merged the changes manually and added some settings to the project to target it correctly for JDK 1.8.. Ok, I've added these constants. Thanks for helping with actual companion object implementations.\nSee this commit d85c21ba14600a739219547e0813f494b3d691cf in 1.3-M1 branch.. Thanks, I've merged new docs with some edits.. Good work!\nI've merged it.. Note that this file is generated. Have you obtained it by running the generator?. I'm ok to merge the first commit into the 1.3 branch.\nRegarding the inspection, I wonder if it takes into account that the extension is introduced in Kotlin 1.3, and thus it should not trigger when apiVersion 1.2 or lower is used in a project?. @mglukhikh Thanks for the clarification.\n@t-kameyama Thanks for the PR, I've merged it into 1.3-M1 branch.. The issue is here: https://youtrack.jetbrains.com/issue/KT-7922. Could you please add there the examples of Boolean companion extensions as use cases?. Note, there's already a pull request with Char functions samples #1526, however it looks abandoned.. @takattata You could take the branch from that PR and try to implement the proposed approach to demonstrate how these Char extensions work https://github.com/JetBrains/kotlin/pull/1526#issuecomment-382585961. I think I can extract sample for Char.equals function from this PR and merge it separately.. Thanks, I've merged these samples, except the following:\n- isDefined() \u2014 doesn't illustrate what this method is for\n- isSurrogate(), isHighSurrogate(), isLowSurrogate(), isIdentifierIgnorable() \u2014 these tests contains non-printable characters and wouldn't look good in docs. Need to find some other approach how to show them.\n. Closing for now as per the decision here https://youtrack.jetbrains.com/issue/KT-25180. I've fixed remaining tests and merged it into 1.3-M1 branch. Nice, maybe you could author toUpperCase sample as well?\nAlso I think it would be better to use mixed case characters in the source string and include some non-alpha and diacritics chars too, e.g. \"Iced frapp\u00e9!\". Squashed and merged, thank you for the PR. Thanks. I've simplified the sample and merged it.. Currently it is blocked until the decision on the overall design of Char-to-Number conversions is made: https://youtrack.jetbrains.com/issue/KT-23451.. Please delimit summary from the detail description with a blank line. You can also use blank lines to separate paragraphs in the description.. Thanks, I've merged it.. Can we advise user that s/he could rebase the PR branch freely and force push it to update the PR?\nI've seen several times PRs being closed and new ones being reopened in this situation.. Could you elaborate why it is upper case comparison and not the lower case or both of them?\nCould you ensure that the order of \"A\", \"a\" and \"[\" is the same according to the proposed case-insensitive comparison on both platforms?\nLook for the hints in the contract of compareToIgnoreCase, regionMatches functions https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#compareToIgnoreCase-java.lang.String-. Ok, I've merged it and implemented String.CASE_INSENSITIVE_ORDER comparator on top of that.\nThanks for the implementation.. Thanks, I've merged it manually.. Now it's better, thanks. I'd rather rename padWithoutChar to padWithSpace, because it still is padded with char, just that char is space by default.. Thanks for the samples, we've merged them manually.\nNow it's ok to close this.. Thanks I've reviewed this PR and merged it manually into 1.3-M2 branch. . We believe that this is a case of operator overloading misuse. \nThe standard library provides the repeat(n) extension for CharSequences, that should be used instead: http://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/repeat.html.. Thanks, I've improved the sample and merged it.. Thanks, I've merged the sample with minor edits.. Good. Could you provide a similar sample for elementAtOrNull too?. Thanks, I've added a sample for elementAtOrElse for completeness, and merged it.. This way the predicate function is inlined twice which is undesirable.. Making a function non-inline is a source-breaking change in case if that function takes a functional parameter, because it prohibits non-local control flows (return from an outer function) that was possible before in a lambda passed to that parameter:\nfun doSearch(searchValue: String) {\n    val result = items.last { \n         if (it == null) return  // returns from 'doSearch', only possible when 'last' is inline\n         it.property == searchValue\n    }\n    ...\n}. Inlining lambda body several times may lead to an exponential growth of the generated bytecode in  cases like:\nelements.last { it.properties.last { p -> ... some predicate ... } }\nHere the code of the inner lambda becomes inlined 4 times. Or even twice more if this code is in a finally block.\nTherefore I think we should not merge this PR.. How does this relate to KT-10900 (Lazy Sequence concatenation)?. Thank you for your pull request. We haven't yet decided on the naming of the proposed function, but should we settle on withEach, we might use this pull request as a base.. Good. Please also rename bound argument to until.. Also ensure that all inheritors of Random get their parameters renamed as well.\nIt's worth renaming test methods like nextIntBound and nextIntOriginBound accordingly.. Have you checked Random inheritors, such as PlatformThreadLocalRandom?. Ok, I'll finish the rest myself, thanks for working on this.. Thanks again, I've merged the changes manually. You can rebase your branch on master and force-push it. This PR will be updated with the new commits.. Thanks for the sample!. There was already an attempt to simplify this function (see #1573), but unfortunately it didn't bring any advantages to its callers. \nOn the contrary it leads to a small increase of the inlined bytecode size, and that doesn't justify a slight readability improvement this change tries to achieve.. Thanks for the idea. That would definitely improve assertFails/With documentation.\nI've merged the PR with some edits as 3c46bb9d03e78279c492c949d495d3493ed43c35.. Thank you for the effort.\nWe do not encourage using experimental coroutines anymore, when there are stable ones in 1.3.\nIf you find that reusing samples from the stable sequence/iterator builders is very confusing, we could consider removing them entirely.. I've edited deprecation notes a bit and merged manually, thanks.. Interesting approach to the initialization synchronization, however what concerns me is the increased memory footprint due to using AbstractQueuedSynchronizer. Did you estimate how much more memory it would require for:\n- uninitialized lazy\n- uncontended lazy initialization\n- contended lazy initialization\n- initialized lazy?. In pure Kotlin project there's no need to create all these subdirectories for common package prefix: .../org/jetbrains/idl2k/...\nhttps://kotlinlang.org/docs/reference/coding-conventions.html#directory-structure. I don't think it's worth to leave this project in the state of dual maven/gradle build, so it makes sense to include it in the main Kotlin project.\nCurrently this project is deployed when idl2k.deploy.skip system property is set to false and then that artifact is used in kotlin-native to generate declarations from IDL for WebAssembly target (@alexander-gorshenev, correct me if I'm wrong).. We can setup deployment as in other libraries projects, e.g. https://github.com/JetBrains/kotlin/blob/769a0d7701a7eae9ee7b49e4a26e62961eca8392/libraries/tools/kotlin-annotations-jvm/build.gradle#L8\nthough it should be done conditionally, based on the value of that idl2k.deploy.skip property.. Merged manually. Doesn't the contract only have effect if the value passed to lambda is a lambda expression?. Great! Thank you for the sample. As far as I can see, transitive dependencies are already being filtered to exclude processed ones in the line https://github.com/JetBrains/kotlin/pull/1976/files#diff-43944464c59a60c7a1fcd00f7b969ed5R175.\nWhat cases the proposed condition is supposed to cover?. That sounds reasonable. Perhaps it could be better to track the set of discovered nodes instead of processed ones.. Thank you for spotting that. Merged manually.. The implementations of EnumSet for JS look suspiciously similar to the ones from JDK. \nJDK source code is licensed under GPLv2 license, and the Kotlin project uses Apache 2.0 license.\nSorry, but we won't be able to accept this PR because of the conflicting licenses.\nHowever we're still open to the idea of having common EnumSet. You can try to provide a clean room implementation (though that still gonna be questionable, if you have seen the JDK implementation), or better take an inspiration in the codebase with a compatible license, e.g. in Apache Harmony: https://github.com/apache/harmony . Merged, thanks!. Thanks for the proposal.\nI'd stick with the wording used in associate* function docs, because associate is essentially map { e -> Pair<K,V> }.toMap() operation:\n\nIf any of two pairs would have the same key the last one gets added to the map.\n\nhttp://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html\nhttp://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate-by.html\nhttp://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate-with.html. Merged, thanks. Thanks for the effort, but now we already have samples covering the functions isEmpty, isBlank, etc:  6bc7c060386. Thanks, I've improved the proposed samples to cover all take* and drop* extension functions for strings and char sequences and merged them manually: https://github.com/JetBrains/kotlin/compare/42120b93b87f8fc779687aa5c7d5d91db7e4b045~2...42120b93b87f8fc779687aa5c7d5d91db7e4b045. I've merged it, thanks.. At this point this pull request is too hurried, please follow https://youtrack.jetbrains.com/issue/KT-27970 for updates on this feature.. Thanks for the fix. Still it makes sense to check an actual type of this Iterable and switch to Collection.toArrayList in case if this is a collection.\n. I believe this should be consistent with the result of Regex(\"\").findAll(input = \"....\"), i.e. a match in every position.\n. It should be (0..length).asSequence(), because you need to count an empty match before the first character and empty one after the last characater.\n. We could extract CharSequence.occurrencesOf(char: Char, ignoreCase) function from here.\n. Please specify input string in the detail message, i.e. something like \"Expected to fail (or return null) on $input\"\n. Behaviour we prefer American English in identifiers :)\n. It might be cleaner to use listOfNotNull instead of ?.let { listOf } ?: emptyList()\n. It's added by IDEA's pre-commit action. Really shouldn't for generated files.\n. ok, could be mentioned\n. This test won't compile in JS because there is no StringBuilder.capacity there.\nTo make this test JVM-only, move it to StringBuilderJVMTest.kt\n. Constructor parameter is called capacity so it should have the same name here.\nAlso there should be no space before : in parameter definition.\n. I'm not sure the prefix function is computed correctly. For the following example \"ABCDABD\" it returns [0,0,0,0,1,2,0], while according to the reference it should be [-1,0,0,0,0,1,2].\nAlso it loops infinitely on the input \"AAABAAB\".\n. expected value comes first, actual value second.\n. Should the ignoreCase parameter affect prefix function?\n. This approach requires two character comparisons per position when matches > 0. Is it possible to restructure the loop body? Also applies to computePrefixFunction.\n. Missing public modifier.\n. > documentations is\nNot sure if it's consistent: either \"documentations are\" or \"documentation is\"\n. Will fix formatting upon rebase.\n. @ensirius  Could you ensure the inspection is only triggered when put result isn't used?\n. Changed exception type to OutOfMemoryError. If we're not going to buffer contents, stdin wrapper isn't required anymore.. What is mystdin here?. Why do you choose StringBuffer instead of StringBuilder?. We should support \"\\n\" and \"\\r\\n\" line delimiters, and \"\\r\" alone can be treated like a plain character.. Overall, buildString + imperative loop might be more clear than tail recursion approach.. I believe elementIterator being a fun conveys the intent well. If that was the same instance every time, it would be a property. . It's how the code is generated now.. It was called source in the beginning, that I renamed it to iterator and then to elementIterator. I wouldn't call it internal API hack, because that API is used publicly by the compiler in the generated bytecode.\nmapInPlace is possible as JVM-only optimization, otherwise it would make the code non-portable to platforms, where generics are reified.. After some consideration, sourceIterator seems to look better.. Unfortunately, this will work only for US-ASCII encoding. . aggregate and aggregateTo are not intended to be used much in user code, they are here more to implement other folding functions when fold or reduce do not fit for some reason.\nOther functions (fold, reduce, eachCount, etc) will get samples eventually.. This implementation doesn't conform to the setLength method contract.. this == null \n^ expression is always false. Please extract unrelated changes, such as formatting improvement in a separate PR.. DependencyResolver instead of DependenciesResolver. no one adds .bat actually. it's unclear that it is \"IDEA\" run configuration. This requires importing kotlin.js.Math class.. There's no swap in JS currently. JS backend doesn't optimize such loops, so it would be better to rewrite it as plain old while loop.. JS backend doesn't optimize such loops ATM.. We're going to provide common Random , see https://youtrack.jetbrains.com/issue/KT-17261, though it isn't there yet.. kotlin.test/common is the project directory, then src/test/kotlin is the source root for tests, then kotlin/test/tests is the package name for tests of kotlin.test :). You can just specify explicit nullable List type here to avoid the warning (same for other orEmpty samples).. It would be nice to show how to use that inverted insertion point. For example we have a mutable sorted list, then we search for an item that is missing, and after insert it at the position obtained from the inverted insertion point, so that the list remains sorted.. It's just the naturalOrder comparator for integers. Can we alter the sample so that some more advanced comparator is used? For example String.CASE_INSENSITIVE_ORDER. Better to introduce another nested class, since ContentOperations class is to group samples for content* array extensions.. We could use some standard charset from Charsets object here.\nAlso we could combine both ByteArray.toString(charset) and String.toByteArray(charset) in one sample, so it would be clear how to convert string to bytes back and forth. Though that sample had better be placed with String operation samples then.. It might be unclear from this example that the list must be sorted so that the sign of comparison is monotonically increasing.. When one has a Box instance to compare with, he could use another overload. This overload might be useful when you have just a value (which is not comparable itself or you want to employ some custom comparator for it) and you want to find the matching Box instance.. We can also print the contents of byteArray here.. Should be Collection<Char>? otherwise another overload is called.. This sample doesn't use the function it is attached to.\nThe function may be useful for turning into Iterable something that has iterator or is an Iterator, but isn't Iterable itself, for example buildIterator { }\n. naturalOrder<Int>().reversed() is just reverseOrder().\nBetter to use some non-trivial compator, for example produced by compareBy { }.thenBy { }\nWe can sort a list with that comparator in direct order and then in reversed one.. It's enough to have plain comparator produced by compareBy for this example.. In this situation one can use just thenBy. \nTo make it more practical you can extract compareBy {it.key} into a variable keyComparator, and then produce valueThenKeyComparator from it.. This sample still doesn't call Iterable function for which it is provided.. Hmm, now it's confusing why do we get an iterator immediately from that Iterable: if one wanted to have an iterator, he could use directly that one returned by buildIterator.\nUsually we want to wrap something in Iterable to pass it where Iterable is expected. For example there are a lot of extension functions taking Iterable as a receiver: map, filter and so on.. Also list of consecutive numbers here can be replaced with a range 1..3 . I've spotted another copy-paste related issue: it uses not this string, but the provided [format] string.\nCould you improve these two overloads' docs as well?. Sorry, I don't see Iterable function call here again. Have you forgotten for which function this sample is? :)\nWhat I've meant is something like:\n```\nval someIterable = Iterable { buildIterator { ... } }\n// now you can call extensions on the Iterable\nval result: List = someIterable.mapIndexed { index, value -> \"$index => $value\" }\nassertPrints(result, \"...\")\n``. Since we're not wrapping it in a reader anymore, we could callreadmethods directly onSystem.inand remove this val entirely.. We could just convert these bytes to string with theByteArray.toString(encoding)` function.\nBy the way, I wonder which encoding is used to encode characters in System.in?. Perhaps we could use this solution to decode chars one at a time in the given encoding, though I'm concerned with how much garbage it would produce.. Better to add a more descriptive name instead of it, as it is inside a multiline lambda, for example stream or input.. This annotation originates from use function and is contagious for all inline functions in the standard library, so it would be incorrect to remove it here.. >  I'm not sure it's worth it so I'll use UTF-8 for now.\nI don't think it's a matter of choice. Making readLine only work with UTF-8 default encoding will lead to plain wrong chars being read from Windows console for example.. There's no point in calling iterator() when you already have an iterator. Usually this extension is used to satisfy for operator convention for an Iterator. For example you can get a MutableIterator from a MutableCollection, then iterate it with for operator and do something with it at the same time, namely remove some items.. If you want to get a List from Enumeration, you can just call Enumeration.toList(). Usually this iterator extension is to safisfy for operator convention, so that you could use for on Enumeration: for (e in vector.elements()) { ... }. The value is not used here. \nThis sample may be hard to understand, because this iterator itself returns integers and indices are also integers, so they can be easily confused.. It's worth to extract iterator into a variable, otherwise it's unclear why can't one call forEach directly on the range.\nWe also can do something with iterator before calling forEach on it, for example skip some entries.. Better to assert assertTrue(destinationMap === filteredMap) to emphasize it's the same instance. Same in filterNotTo example.. I don't expect there will be distinct samples for each primitive type. Also naming this class the same as the built-in Int looks dangerous.\nSo if you're going to improve further the samples for coerce* functions, this can be named as Coercion. \nAlso it's worth to find a more general package name, since not only numbers could be coerced in range, but also any Comparable type could.. These functions are generated from a template. I think it'd be ok to provide the single sample for all overloads, so this sample reference can be placed in that template. You can find this template here: https://github.com/JetBrains/kotlin/blob/master/libraries/tools/kotlin-stdlib-gen/src/templates/Comparables.kt#L27. Another common use case of vetoable is to throw an exception before the new value is assigned if it is invalid. It could be illustrated in a separate sample.. nonNullDelegate and notNullAccessError can be merged in one sample.. Here should be proper camelCase \ud83d\udc2b \nThe same for chararray and expectchararray identifiers.. Here should be proper camelCase \ud83d\udc2b . Here should be proper camelCase \ud83d\udc2b . samples.comparisons.ComparableOps is fine too. . I don't think it would significantly improve the sample. On the other hand we could add a separate sample for some comparable types other than numbers.. Have you succeeded with this? I mean a sample for some comparable type.. This property seems no longer required, System.in can be used directly instead.. It should work with both types of line separators automatically, and there's no requirement to work with custom ones, so the lineSeparator parameter is not needed.\n  . I thinks it is enough to show only two examples of modification: structural like add or remove, and non-structural like set.. It should be shown how changes of reversed affect the original list.. It should be shown, how changes in original affect reversed list in case if original is a mutable list.\nLike:\nval original = mutableListOf(...)\nval originalReadOnly = original as List<...>\nval reversed = originalReadOnly.asReversed()\n// reversed is read-only list, but can be changed by modifying original one\n. Usually IllegalArgumentException is used in this case. Also there are redundant parentheses here.. This change is not related to samples, better to revert\n  . Usually IntRange is constructed with the .. operator: 1..2. Better to use named parameter to pass ignoreCase for clarity. I think it'd be ok to merge first and third sample. \nBetter to use some real use case to illustrate these functions, for example to take a part of a dot-delimitied identifier, or a slash-delimited path.. Could you also show a usage of these functions with missingDelimiterValue parameter specified?\n  . Please use assertTrue/assertFalse assertions instead. These trailing spaces will be invisible when printed.. setOf is already covered by the sample above. Take a look at readOnlyList and singletonReadOnlyList samples for an example.. Agree, please do, but only for isLimited case.\nBetter to use minOf, it's available without import.. minOf(limit, 10) is 0 when the limit is 0. Is the capacity intended to be so?\nActually it would be better to use limit.coerceAtMost(10) here to communicate the intent more clearly.. As far as I can see in the sources, ArrayList() and ArrayList(0) constructors initialize the list state differently, the latter grows its capacity more often, so it may result in more reallocations.. delimiters[0] value is already in delimiter local val.. Looks like we can return result right after this.. Also if we get here, it means that nextIndex search at the previous iteration is unused.. Primitive arrays are padded with the default values of the respective primitives rather than null.\nPerhaps this doc block should be only for InvariantArraysOfObjects, and ArraysOfPrimitives should get its own version.. It's good that you've provided some samples, but please use @sample tag. Check this short guide about sample authoring.. Yes, the generated sources are in vcs, so you need to commit them.. Also in 1..2 range, the end index 2 can be confused with the range length which also happens to be 2.. Consider the case when you want to split strings like key=very_long_value with limit=2. In this case the function will search for the second = to the end of a long string, though it could have stopped already.. Looks like we can add || limit == 1 because it should return the same single item list.. Though there isn't a lot of use cases for limit=1, thus we can avoid introducing a special path for this case.. break instead of -1 would be more clear. In string extensions lastIndexOf begins search from startIndex position (which is lastIndex by default) and goes down to zero.. Use deprecate(forBinaryCompatibility) instead.\n. Interesting, I hadn't noticed this annotation in javadoc of testng before, seems that it's rather new. What is the testng version it's available from?. Package name seems incorrect. asserter is a public top-level property, it can be obtained directly without reflection.. And a copyright here is not required. isn't className already String?. This won't pass most likely, you're comparing Asserter object with a String. minor: add a space after colon. IntRange is already an Iterable. What does this conversion intend to show?. Always true, this check can be moved to the end of loop, just replace while () { } with do { } while (). Due to compatibility reasons we cannot introduce an overload in a patch release. So if you don't mind, I'd make it a function without parameters for now.. Better to place it as a nested class of samples.collections.Collections. Though we can definitely use all/any/none with a callable reference, the most common usage is with a lambda function: .all { isEven(it) }. Probably, we can show both options.. But in either case the root project should not be common.. We can add one initial accumulator value here to show the difference from aggregate. Grouping by a boolean value doesn't look natural. Better to group by radix instead.. assertPrints(aggregated, ...) is better here. This looks like a fancy way to do groupBy (though with in-place filtering). Anyway the accumulator could be just MutableList instead of pair. I understand this is to show the overload of fold passing key to the lambda, but it looks a little contrived.. assertPrints is better here. assertPrints is better here. assertPrints is better here. This block could be replaced with maxOf(a, b, compareBy { it.count { .... } }). There's no such overload of valueOf. Please ensure it compiles.. The return value is not used, so it can be just flipBack() { ... }. The buffer is not used after, so this flip doesn't affect anything.. minor: apply here doesn't add clarity.. Actually this statement is incorrect, to has not be <= this, but if it isn't, the returned progression will be empty.. I'll write something similar to until function docs here.. I wonder, is there such an example that shows why locale could be used for toUpper/LowerCase? I mean so that it would result in a different result compared to no locale overload.. Here we specify the versions that will be used throughout the entire project,  e.g. in case if Kotlin project would be using JUnit 5 to run its own tests. That version should not necessary be the same as the version against which kotlin-test-junit5 is being built.. I don't think this way of linking is supported in @see tag.  I'm not sure what is the purpose of these links anyway.. It's worth to provide common String(chars: CharArray) too.. Not a very efficient way to build a string from a CharArray especially if the length is way more smaller than the length of the array.. Better to move common tests into libraries/stdlib/test/text/StringTest.kt instead of duplicating them for each platform.. I mean something like that: https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String. Better to provide each sample only to the related overload of copyOf. Please add a blank line to separate summary and description.\nThe text can be specialized for primitives based on the current value of overloads family.. Worth to add truncating sample too.. inline is an implementation detail of these functions, which may be or may not be suitable on a particular platform.\nThere's no reason to require it to be inline in the expectation.. This overload doesn't benefit from being inline. Consider using copyOfRange instead of sliceArray as the latter requires a range to be instantiated.. If textWhen is messy, you can use plain if or when expression inside ${...} . Given that both String  and CharArray are sequence of UTF-16 code units (and not Unicode code points), I don't think any special support for surrogate pairs is required in these two functions.\nThe function that converts an array of Unicode code points to a String is out of scope of this PR.. I don't get what is the point of this condition. So if there's a pair of chars matching that predicate, we get a pair of chars in the resulting string, and if not, we get those chars one by one? That's what String.fromCharCode invoked on the entire array does, doesn't it?. These declarations are already inside Char.Companion, they shouldn't be extension properties.\nTake a look at other companion properties around.. The extensions are removed, but instead of them there should be const properties in this companion.. This is only sufficient to declare that Boolean has a companion. Boolean class is not compiled neither in JVM nor in JS, thus in order to provide the actual companion object some special support in the compiler is required.. The idea of throwing exception in the end of the resulting sequence is very questionable. Can you provide a justification for it?. According to your tests the resulting sequence completes normally. If you're documenting the next function behavior, than it's definitely wrong place to do it, and it's actually not needed because that's the standard iterator contract.. I've refactored companion object tests, so a test for Boolean companion can be added there.\nhttps://github.com/JetBrains/kotlin/blob/cbc3480d9e7c62e5ded6c6c339fcf17ac1adf3b2/libraries/stdlib/test/numbers/BuiltinCompanionTest.kt. The missing part is some compiler code that glues together these declared companions and their runtime implementations. I don't know where it is exactly, but I've found some entry points in CompanionObjectMapping.kt and ClassMapperLite.kt.\nAfter that you will have to bootstrap compiler before compiling stdlib tests, so that it would know how to compile this new companion object reference. This can be done with commands:\n./gradlew publish\n./gradlew coreLibsTest -Pbootstrap.local\nOr you may postpone that part with stdlib tests for now.. The exception message isn't correct because Int.MIN_VALUE does have an inverse: it's Int.MAX_VALUE.\nI'll reword the message.. The cast like Int.toInt is a no-op, so it isn't worth to complicate generator code to avoid it.. It would be nice to start with a sample where it is not used, as it's the most common use of repeat. You can use some action here that normally fails, to emphasize that the lambda is not executed.. You can use until instead of subtracting 1 from the end.. minOf is available without import. I doubt that this method of comparison is efficient, given how Char type and its toUpper/LowerCase extensions are implemented in JS. Here we make char code -> 1 char string -> upper/lower case -> back to char code conversion two times for each char. At least we can take a substring of length 1 instead of a char and avoid char code <-> string conversions.\nHave you considered converting the entire strings toUpperCase().toLowerCase() and then comparing them? That however will probably be less efficient for long strings that differ in first several chars. \nMaybe we can apply some compromise approach so that the strings are split to batches each of several chars long and than each batch is transformed (toUpper -> toLower) and compared?. There's expect counterpart and another actual implementation for JS, it's worth to place a sample reference there too. . It would be informative to show what is the static type of list by using explicit type specification\nval list: List<...> = ...\nIt's worth to add another example, where both components have the same type.. I'm not sure this assertion adds something, after you've asserted that this element is String. I don't think we should inline it, given its current size.. We're going to mangle top-level function names with unsigned types in their signatures to avoid this type of clashes. It would be possible to rename this function after that mangling is turned on.. Better to delegate each nextUBytes to the corresponding nextBytes in order to benefit from the better implementations of more specialized overloads.. Consider providing it for the same receivers as forEach.\nAlso it makes sense to make it inline same as forEach (note that different overloads have different inline modifiers). Could be just assertEquals(listOf(\"f\", \"b\"), substrinList). The search should query only KT project as it did before.. minor: formatting\nsuggestion\ntask downloadAllIdls(type: JavaExec) {. Please preserve the old behavior: the artifact was published only when idl2k.deploy.skip property is false. Note that the artifact name is changed to kotlin-idl2k (by default it's the name of the project). It may be ok or may be not, please ask @alexander-gorshenev, are they ready for that?. I've checked that the property was set only for the maven build, so we should setup something like that to preserve the same for gradle build \u2014 I can do that. \nBut we do not longer need to preserve the inverted logic, i.e. publishing when the property is false, so I propose to introduce new property idl2k.deploy and publish only when it is set to true.. No, by default it's false. system.idl2k.deploy teamcity parameter translates to a project property idl2k.deploy in Gradle, rather than a JVM system property. So we need to use gradle's Project.findProperty/getProperty/hasProperty. suggestion\n            val fileRepository = parseIDL(CharStreams.fromFileName(e.absolutePath, Charsets.UTF_8))\nCharsets object available in kotlin.text. import looks redundant. Minor: space between ) and {\nsuggestion\n        fun minBy() {. kotlin.collections package is imported by default. Why these imports are required? \ud83d\ude15 . Perhaps it would be better to read expected output from a file too. Please revert unrelated line ending change. Hmm, strange, the new line is still there.\nOk, I'll merge the commit manually and clear it up.. suggestion\n            File(testResourcePrefix).resolve(expectedOutputName).readText(),\nThen it would be possible to pull File(testResourcePrefix) to the outer scope.. Same here.. Two subsequent map calls can be joined together.\nThe default delimiter of joinToString would produce more pretty output.. ",
    "MichaelNedzelsky": "Ok, I'll do it...\n. After some discussion the following improvements were proposed:\n- [ ] clean javascript code\n  - [ ] get rid of unnecessary local variables\n  - [ ] remove unused code\n  - [ ] simplify use of an arguments object (it's optimization and is not necessary right now)\n  - [ ] more meaningful names for functions (getCallableRefFun -> getCallableRefForMember etc.)\n- [ ] add new tests for callable references for top level and local functions\n- [ ] add new tests for interaction callable references with native (javascript) code\n- [ ] use  K.(T1,...,TN) -> R instead of ExtensionFunction<...> for types in tests\n- [ ] extract and refactor code for ExpressionVisitor.visitCallableReferenceExpression  (create class CallableReferenceTranslator, preferably implemented in Kotlin)\n  - [ ] remove unnecessary comments \n  - [ ] check for ClassDescription instead of ClassDescriptionBase\n  - [ ] more natural conditional statements\n- [ ] Refactor \"InvokeIntrinsic : FunctionCallCase\" in FunctionCallCases.kt for reflection types--- check JVM backend implementation \n. What's new:\n- support for callable references to native (js) extension and member functions\n- some improvements which were mentioned in previous comment\nWhat's left to do is to translate CallableReferenceTranslator in Kotlin and refactor \"InvokeIntrinsic : FunctionCallCase\" for reflection types.\n. Rebase on master, check all js-backend tests\n. New commit adds support reflection for properties.\n. The following improvements were suggested during review:\n- reformat source code to meet the requirements (space after \":\" , etc.)\n- search for existing analog of kotlinFilesInDirectory function\n- move kotlinFilesInDirectory to utils (see JsTestUtils and LibraryFilePathsUtil)\n- CallableReferenceTranslator: the first parameter of translateForFunction should be of type FuncionDescriptor\n- CallableReferenceTranslator: assert (descriptor is property or function)\n- CallableReferenceTranslator: meaningful names instead of jsLiteral\n- CallableReferenceTranslator: extract check for isVar into function\n- add @NotNull to getStringLiteral method\n- correct comments for tests, adapted from jvm (get rid of \"cases\" at the end)\n- Kotlin_lib: uniform names: getCallableRefForMemberFunction,...\n- Kotlin_lib: getCallableRefForExtensionProperty simplify use of getFun and setFun\n. Fixes after review.\n. The following improvements were suggested during review:\n- use meaningful name for test file (add comment about KT-5345 at the beginning)\n- get rid of auxiliary test<...>  functions\n- add comment (toInt32) before return from  INTEGER_DIVISION_INTRINSIC\n- reformat source code to meet the requirements (space after \":\" , etc.)\n. Fixes after review.\n. The following improvements were suggested during review:\n- use meaningful name for test file (add comment about KT-5320 at the beginning)\n- reformat source code to meet the requirements (space after \":\" , etc.)\n. Fixes after review.\n. Merged manually.\n. @typeinference \nPlease take a look at this branch\n. Merged manually\n. Merged manually.\n. @udalov\nPlease take a look at this commit\n. I created Kotlin/Jvm project and added shared library (which contains both .class files and .js files). This library have valid JVM ABI but invalid JS ABI. In that case there is no notification now.\nSame for Kotlin/JS project with shared library which have valid JS ABI but invalid JVM ABI.\n. @udalov \nfixes\nhttps://github.com/JetBrains/kotlin/commit/2f43c56e5e71239ce3ebb2aea1280c74a5296d05\n. Merged manually.\n. Merged manually.\n. @typeinference \nPlease take a look at this pull request.\n. This pull request has been closed as obsolete.\n. Aside some minor observations, the code seems Ok.\n. That was a mistake. Of course it should be compileList = compileListForJavac;.\nhttps://github.com/JetBrains/kotlin/commit/e7958c1b10b9efe28f35e0fc1b058b682f150efb\n. kotlinc.execute() invokes fillArgument(), if execute() is not invoked, then kotlinc.getArgs() will be empty. But addRuntimeToJavacClasspath(kotlinc) uses kotlinc.getArgs().\nWithout code at line 103, for empty kotlin sources and the following configuration\n<withKotlin>\n                <compilerarg value=\"-no-stdlib\"/>\n            </withKotlin>\nruntime will be added to classpath for javac (no-stdlib will be ignored).\n. This exit code is used only in CliCompiler.exec:\nExitCode code = doExecute(arguments, services, severityCollector, rootDisposable);\nreturn severityCollector.anyReported(CompilerMessageSeverity.ERROR) ? COMPILATION_ERROR : code;\nOf course it is possible to add new enum entry into ExitCode but it seems not very useful for ILLEGAL_ARGUMENTS_ERROR (CliCompiler.exec will return COMPILATION_ERROR in that case anyway).\n. I'll add necessary tests.\n. Ok, I'll replace COMPILATION_ERROR with INTERNAL_ERROR.\nThough in K2JVMCompiler, line 129,  COMPILATION_ERROR is used for empty script source path.\n. It seems in K2JVMCompiler.doExecute INTERNAL_ERROR is used only for return from catch block. For K2JSCompiler.doExecute we have sometimes INTERNAL_ERROR and sometimes COMPILATION_ERROR.\n. In really, I don't know what type of format should be here. Shift to the left?\n. Agreed, I'll fix it (and UnsupportedAbiVersionNotificationPanelProvider.collectBadRoots, where some files added to result of this method, which will be lead to UnsupportedOperationException, if not corrected).\n. It seems it is better to have one parameter per line.\n. Same here --- one parameter per line.\n. Extra empty line.\n. start -> offset (as in the supertype) in order to get rid of corresponding warning.\n. It seems this file should be placed in the appropriate subdirectory in order to get rid of warning about file location?\n. It seems it is possible to simplify conditional expressions by using the following function instead of toBooleanLenient\n```\nfun String.systemPropertyAsBooleanOrTrueOtherwise(negate: Boolean): Boolean {\n    val propValue = System.getProperty(this) ?: return true\nreturn when (propValue.toLowerCase()) {\n    in listOf(\"\", \"yes\", \"true\", \"on\", \"y\") -> !negate\n    in listOf(\"no\", \"false\", \"off\", \"n\") -> negate\n    else -> true\n}\n\n}\n```\nSee comments below.\n. This could be written as\nif (KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY.systemPropertyAsBooleanOrTrueOtherwise(negate = true)) {\n. This could be written as\nif (KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY.systemPropertyAsBooleanOrTrueOtherwise(negate = false)) {\n. This could be written as\nif (KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTY.systemPropertyAsBooleanOrTrueOtherwise(negate = false)) {\n. Also, I suggest to store previous value of property KOTLIN_COMPILER_ENVIRONMENT_KEEPALIVE_PROPERTYand restore it in tearDown.\n. ",
    "dittert": "The implementation is a lot simpler than the previous implementation because it relies on standard Java mechanisms (PropertyChangeEvent, PropertyChangeListener) instead of introducing its own event and listener classes. This increases compatibility with Java classes because those mechanisms probably are already used there. \nAlso, it allows to create a delegate by just using PropertyChangeSupport and does not force the user to inherit a trait (maybe because bean class uses it's own methods to manage listeners). \nThings I don't like so much right now:\n- if you inherit the trait, the method property becomes part of the public API of the bean even though it is declared protected in the trait (at least in Java; might be KT-2406)\n- the trait forces the PropertyChangeSupport to become part of the public API: it has to be declared public because of KT-3029\n- mixing Kotlin Beans and Java Beans isn't really an option at the moment. The current implementation of delegated properties break Serialization. Thus, I did not make any efforts in this change to handle Serialization\n- No support for indexed properties (which are rarely used anyway).\n- Breaks any code that used the previous implementation. No care was taken to stay compatible, because the previous implementation seemed incomplete and was used nowhere else in stdlib\n. ",
    "dzharkov": "Done\n. There were no @geevee commits when I rebased last time.\nSo I rebased again\n. No, you shoudn't, I just changed commits' headers\n. Done\n. Last remote run build https://teamcity.jetbrains.com/viewLog.html?buildTypeId=bt345&buildId=188258\n. Build successfully completed\n. Merged manually\n. Please look at JetParsing.parseTupleType and it's usages\n. Hi!\nThank you for contribution, your commit seems very reasonable, but as far as I can see it opens some problems with recursive cases again. For example:\ninterface A<T : A<T?>?> {\n    fun foo(): T?\n}\nfun testA(a: A<*>) {\n    a.foo()\n}\nCompilation of such code fails with StackOverflowError if you're changes are applied.\nI'm not sure but think that such problems could be solved by making type of star projection lazy in a sense that calculation of it's type constructor and arguments is deferred, and when they are needed, then next recursive substitution step should be done.\n. Current solution seems to be better, but IMO it still looks fragile.\nIn particular I would not like adding new field to TypeSubstitutor class.\nMy point was that in current version of StarProjectionImpl it defers calculation of type as whole object, while such calculation may lead to infinite recursion, so we have to place isStarProjection check almost everywhere we retrieve type from projection.\nBut we could make type for StarProjectionImpl lazy in different aspect, instead of deferring itself type\ncalculation we defer calculation of it's contents.\nYou can see something similar here: https://github.com/JetBrains/kotlin/blob/32151c077e3718851f7a3ca9a55913099d95c2a0/compiler/frontend/src/org/jetbrains/kotlin/resolve/TypeResolver.kt#L85\nBy doing this we win in a sense that calling StartProjectionImpl.getType NEVER leads to StackOverflow and even getting it's contents won't be unsafe anymore (because nested occurrences of projection will be calculated as lazy entities in the same way).\nAfter such changes a lot of isStarProjection usages become redundant, and what's important here,\nwe can remove this check:\nif (replacement.isStarProjection() && (substituteStarProjectionAsIs || !type.isMarkedNullable())) {\n   return replacement;\n}\nand therefore to solve #KT-9893\n. @mcgee I'm sorry, but I think, that idea my from previous post can be dangerous too.\nPlease let me some time to think about our solution\n. Ok, thanks.\nI'll squash my fixes and merge manually\n. I think you forgot to commit generated test.\nYou can generate them either with 'Generate Tests' action in IDEA project or just run org.jetbrains.kotlin.generators.tests.GenerateTestsKt\n. I've merged your changes manually. Thank you!\n. The annotation is already supported, but because of special semantics (there is an optional parameter determining nullability) it should be treated differently from common NonNull annotations.\nSee https://github.com/robfletcher/kotlin/blob/master/core/descriptor.loader.java/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt#L34 \nPlease, let me know if annotation was not handled properly in your cases\n. @robfletcher Behavior is different because of annotation processor instrumenting bytecode for methods marked as NotNull. \nIt's not related to Kotlin compiler, you can achieve the same result with raw Java\n. Merged manually. Thanks a lot for your contribution!. I've squashed your commits and pushed them manually.\nThank you for the contribution!. Thank you for suggestion, but this fix may not help because how the test works it really depends on what minor version of JDK is being used (calculateCapacity is only present in the newest versions).\nI'm considering to avoid rendering private inherited members in tests like this or just remove the one.. Thank you for the contribution!. Merged manually with minor fixes.\nFYI: For new generated tests you can run ./gradlew generateTests -x :ultimate:generateTests. I've merged changes manually.\nThank you for the contribution!. I've merged your commit manually.\nIt's expected to be released with the next eap of 1.3.20.\nThank you for the contribution!\n. Thanks!\nEverything looks fine but you needed to run :generateTests gradle task to add actual JUnit tests for the test-data you've attached (or you can just fixup the following commit https://github.com/JetBrains/kotlin/commit/8b8bdb41c1b9e8b3335e88d807a56ac98df16a6b) \nAlso, please add something like ^KT-29586 Fixed to the body of the commit message to link the change and the issue.\n. Merged manually.\nThanks for the contribution!. Forgot it :(\nDone\n. JetPsiFactory.createInitKeyword became unused\n. I think it should be unescapedAnnotation instead of annotation.\nProbably we should also remove (\":\" \"file\")? part from annotationPrefix.\n. I'd better called it createCandidates. Also, the formatting like this is preferred for long headers\nfun resolve(\n        collector: Collection<CandidateWithBoundDispatchReceiver>,\n        f: (Boolean) -> Boolean,\n        kind: ExplicitReceiverKind,\n        receiver: ReceiverValueWithSmartCastInfo?\n    ): Collection<C> {. f parameter seems redundant because it's either { it } when receiver is not null and { !it } when it's null. Code is supposed to be formatted like\nTowerData.Empty -> resolve(\n                MemberScopeTowerLevel(scopeTower, explicitReceiver).collectCandidates(null),\n                { !it },\n                ExplicitReceiverKind.DISPATCH_RECEIVER,\n                null\n            )\n            is TowerData.TowerLevel -> resolve(\n                data.level.collectCandidates(explicitReceiver),\n                { it },\n                ExplicitReceiverKind.EXTENSION_RECEIVER,\n                explicitReceiver\n            ). And here, like this\nis TowerData.TowerLevel -> resolve(\n            data.level.collectCandidates(null),\n            { !it },\n            ExplicitReceiverKind.NO_EXPLICIT_RECEIVER,\n            null\n        )\n        is TowerData.BothTowerLevelAndImplicitReceiver -> resolve(\n            data.level.collectCandidates(data.implicitReceiver),\n            { it },\n            ExplicitReceiverKind.NO_EXPLICIT_RECEIVER,\n            data.implicitReceiver\n        ). ) is supposed to be placed on the next line.\nThe same applies to the when entry below. I think it's safe.\nLooks like, it should be candidate.requiresExtensionReceiver == (receiver != null). I'd prefer moving the line container.get<JavaClassesTracker>().onCompletedAnalysis(module) to the beginning of invokeExtensionsOnAnalysisComplete since JavaClassesTracker is also a kind of extension and invokeExtensionsOnAnalysisComplete has the single call-site now. ",
    "dmekhanikov": "Alexander, I am done with fixing the defects you noted. Please check it again.\n. Some other files in the project have the same typo. Should I fix them?\n. ",
    "abesto": "Can do. ETA 1 hour.\nOn Nov 11, 2014 5:52 PM, \"Zalim Bashorov\" notifications@github.com wrote:\n\nLooks like all commits should be merged in one. Thoughts?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/524#issuecomment-62577304.\n. Fixed the two code style comments, squash coming up soon.\n. Sorry for the delay, I shot myself in the foot by upgrading my default java to 8, causing strange gradle internal errors. Almost done with \"fail if outputFile not set\".\n. ... and then proceeded to shoot myself in the foot repeatedly with various tools. Anyway, that's it for me today. Next time I'll have more than 10 minutes to hack on this will probably be Thursday. Thanks for the review so far!\n. Thanks for linking your changes, they look good to me. Should I merge / cherry-pick them into this branch, or will you take care of that after the next squash?\n. Done. Also: does https://github.com/JetBrains/kotlin/commit/adab0445de7bf7c3d2c14ea4066bee95acc1fd2a mean that I shouldn't add kotlin-js-library as a dependency (and thus add the jar to libraryFiles) anymore? Edit: atm I can't try it out because my build against master fails with [error] /Users/abesto/playground/kotlin/libraries/stdlib/src/kotlin/io/ReadWrite.kt: (156, 37) Type mismatch: inferred type is java.util.stream.Stream<kotlin.String!>! but kotlin.Stream<kotlin.String> was expected, not yet sure if I messed up my local env or there's really a bug.\n. Ok, I'll make it so. I'm curious: is there a reason besides \"let's not surprise the developer by adding dependencies\"?\n. Agree with using Gradle to define the dependency, that's how it's implemented currently. The plugin uses the Gradle dependency manager to set kotlin-js-library as a compile dependency. I take it you don't think we should do this, the user should specify it explicitly; I'll remove the code from the plugin that adds the dependency.\n. Wrt/ the build error: rebased on latest master (321e758451f4b97163bdb0cc3f3e1dd4431f5b35). I'm using CLI tools to build. Did ant -f update_dependencies.xml, then ant -f build.xml dies with the above error. AFAICT I don't even have a working Kotlin compiler since I can't build the stdlib.\n. ./dependencies/bootstrap-compiler/Kotlin/kotlinc/bin/kotlinc-jvm -version                                                                                                                                                           22:29:22\nINFO: Kotlin Compiler version 0.9.686\n. Bah. This again.\n\nNice, thanks for figuring it out, build works with Java 7. Will now fix if any tests are broken and squash the commits.\n. Quick check, are you waiting for some changes, or just didn't get around to moving on with this?\n. No problem at all, thanks for the prompt response.\nAvoiding hacks is great, I'm fine with waiting for it.\nAbout not copying the library to the out dir: as a user of the plugins, I have no idea where to find the kotlin.js for the version of Kotlin I'm using in my project. OTOH, I can see how automatically copying the file is not clean. How about providing a task type, but not creating a task by default? That way the user can manage what happens explicitly, without having to think about Kotlin internals.\n. \\o/ best :christmas_tree: :gift: :)\n. Absolutely.\n. In an ideal world, yes. I don't know enough to confidently say no-one will ever need to override it. If you say go, I'll change it.\n. Good point :)\n. Great! I spent a minute or so looking for this method but couldn't find it for some reason.\n. It needs to be a set because generally there will be several files in each source root, leading to multiple entries for each source root. But I've generalized it from HashSet to just Set.\n. FYI, I'll rebase to the latest master to get JetFileType.EXTENSION. Would have to do it anyway. I'll squash the commits again once we're done with the review.\n. Isn't this the same case as destination for the JVM task? There the plugin defaults to kotlinDestinationDir. This is basically the same logic. Of course we don't need to keep symmetry between the plugins.\nI don't have a strong preference, it's up to you :)\n. JavaFileType has slightly different constants, so I used the common interface to make the symmetry obvious.\n. Ok, that makes sense. I'm convinced.\n. Because a bunch of tasks are added to its dependencies, so that they run on gradle build.\n. I'm not exactly sure what you mean. Let me explain the use-case I tried to solve here, maybe that's an answer; if not, please clarify.\nThere are two things you may want to do with source maps. One, use them locally. In this case it doesn't matter where the Kotlin sources are, the browser will find them over the file:// protocol. Two, distribute the source-map and Kotlin sources with the project; either as a debug build of the application, or as an example of kotlin2js. In this case the Kotlin sources need to be copied to a place the sourcemap can reference; also it needs to be edited to point to paths relative to the sourcemap (that's what createRewritePathsInSourceMapTask does).\n. Ah, nice to know this is something you've already thought about. I'd prefer not to attack 4078, added TODOs in https://github.com/abesto/kotlin/commit/c50a32ebb9717bc613adb6ad9821619338505646\n. Agree, thanks for pointing it out. Done in https://github.com/abesto/kotlin/commit/99df6618f94bdbec0011270bab8a61a11d8d87ad and https://github.com/abesto/kotlin/commit/fe3060d9afd8382e1ce770360a0f710b997cb60d\n. Fair enough. Removed them in https://github.com/abesto/kotlin/commit/dbeacf02080389968423d06240567859fc740f32\n. Sure: https://github.com/abesto/kotlin/commit/3e1461c48babeeac542bfb2b9653bd1ea80c8a89\n. ",
    "ghost": "No, it's not (not this time, anyway :) ). It was more like an interesting challenge which I'd engaged myself in. I'm well aware that my implementation may be somewhat \"off\" since my experience with Kotlin compiler code is pretty tenuous. Still, if it's not conceptually wrong I look to you for the help with bringing it to a completion (hopefully it's not taking too much of your time).\n. > ``` kotlin\n\nfor (i in 1..2, i in 2..3)\n```\nis this an error (redeclaration) or a warning (shadowing)?\n\nSince clause scopes are nested, this is the case of shadowing just like in the following code:\nkotlin\nfor (i in 1..2) for (i in 2..3)\n\nHow is it possible that yield is a soft keyword?\n\nYes, it's my fault. It should be the strong one.\n\nDo you imply that yield only works at the root of the body expression? What about ifs in the body? Can I not skip some of the items in a collection by no yielding results for them?\n\nIn this case yield only serves as a syntactic marker which turns for-iteration (effective statement) into comprehension (i.e. expression with value) which is translated to the combination of map/flatMap calls. In this regard it's similar to Scala comprehensions or LINQ select while the construct you're talking about resembles the C# generator where you control which elements are emitted using yield return. IMO both features have their usages, but this PR is concerned with simpler Scala-style comprehensions only (C#-style generators in Kotlin would be extremely cool, though). However yield may be misleading, and I favored this syntax mostly because it's already used in Scala. Probably some other keyword (maybe, select) or new syntax (like SQL-ish LINQ) would fit better, but as a first step I decided to reuse existing syntax as much as possible.\nWhat do you think?\n\nIncidentally, what about label-qualified yields: yield@outer e?\n\nFor the aforesaid reason labeled yield makes no sense in the context of a for-comprehension. Also break, continue and return are interpreted as if they are used inside of lambda (so, for example, return can't be used unless map/flatMap call is inlined).\n\nYour approach only concerns maps, what about filters?\n\nYes, filters are necessary, I just decided to not include them in this PR since first of all I wanted to make sure that my current implementation is on the right way. I thought about adding optional guard condition to each clause as well as introducing special kind of filter clause. For example,\nkotlin\nval list = for (p in persons if p.age > 20, // generator clause with guard\n      a in p.addresses\n      if a.city != null                    // filter clause\n) yield a.city.name\nIt's also supposed to work by convention. For example, the code above is treated like this:\nkotlin\nval list = persons.filter { p -> p.age > 20 }.flatMap { p ->\n    p.addresses.filter { a -> a.city != null }.map { a -> a.city.name }\n}\n. Well, I didn't mean limiting it to Scala approach, just to note that Scala-style comprehensions can be useful in their own right. Besides, comprehensions are basically just a syntactic sugar over DSL-like calls map { p -> ... }, so as long as equivalence is maintained, all tricks applicable to such calls (inlines, map().filter() optimizations, etc) are available for free.\nC# generator-blocks (all the more their generalization for lambdas, loops and other control structures) is no doubt very useful feature, but for me it seems quite orthogonal to comprehensions. The main question here is whether comprehensions would be supplanted by generators (if you decide to implement them at some point). Still, both features coexist in C# and each one has its own range of applications (LINQ counterpart could be an interesting way to evolve for-comprehensions :) )\nAt this point flatMap (together with constructor functions of some sort) allows to express monadic operations (with map providing optimization in simple cases). So if we have, for example,\n``` kotlin\ntrait Try {\n    fun map(f: (T) -> U): Maybe\n    fun flatMap(f: (T) -> Maybe): Maybe\nclass Success<T>(val value: T): Try<T> {...}\nclass Failure<out T>(val exception: Throwable): Try<T> {...}\n\n}\nfun  Try(f: () -> T): Try = try { Success(f()) } catch(e: Exception) { Failure(e) }\n```\nwe can chain Trys:\nkotlin\nval result = for (\n    a in Try { 2/5 },\n    b in Try { 2/a },\n    c in Try { b + 1 }\n) yield c\nIt somewhat resembles Haskell do notation.\nBut I see your point: the benefits of this feature may be controversial especially in the context of more general alternatives\n. That would be interesting\n. Format strings seem like an interesting one\n. I'll start with a spec (also will take a closer look at Scala interpolators)\n. @valentinkip Please review user PR\n. ",
    "kharvd": "Added more tests for asIterable\n. Sounds reasonable. Added asList() as well.\n. ",
    "artem-zinnatullin": "@geevee you want full log? It will be pretty huge\nAnyway, try to build Project Kotlin with JDK 1.8, maybe it's problem of my environment, but I don't think so\n. @geevee no problem, go Kotlin!\n. @ilya-g I've used blank lines as you suggested \ud83d\udc4d . Can you introspect that please? I'm afraid that'd pass classpath of whole kapt plugin here\nYou probably want something more isolated that only have tools.jar classes. ",
    "EddieRingle": ":+1: I always thought @-style annotations in Java made sense considering \"@\" is basically just a stylized \"A\"\nWould we still be able to use @-based annotations without any special syntax (i.e., data instead of @data) on classes?\nSide-note: @abreslav Out of curiousity, are you open to hearing language suggestions in the form of Pull Requests here from people outside of JetBrains?\n. Looked into it more and @orangy is correct, it's definitely a lot more involved than someone new to the codebase like myself is prepared to deal with. Closing this, but I've submitted a PR (#848) that adds a test for KT-11750.\n. ",
    "yanex": "Thank you for the pull request!\nHowever, it lacks corresponding unit tests which is very important.\nAnd, actually, I have already done some work in order to support . So, if you don't mind, I could use some parts of your code directly.\n. Looks good and reasonable for me.\n. Commit was merged manually. https://github.com/JetBrains/kotlin/commit/69038ba6c09a4427ace5158fd434e27f1672d3f0\nThank you for the contribution!\n. Project importing in Kotlin now correctly marks the kapt output directory as \"generated source set\" (not only for Android projects but also for plain \"Java-style\" Gradle projects). Please check if the project importing works properly for you.\nSo looks like remapping destination directories for AP is not needed anymore. @sagara-, what do you think?. Looks like this is not actual anymore.\nPlease file an issue to our issue tracker if you still have a problem with this.. https://github.com/JetBrains/kotlin/pull/823 was merged instead.\nAnyway, thank you for the contribution!\n. Commits are in master: https://github.com/JetBrains/kotlin/commit/100252b18b052ddfc07dafd2a2da81a678881551, https://github.com/JetBrains/kotlin/commit/b9dc92d7cf0a1423d4bc510fce6b956f04bda373.\nThank you for the contribution!\n. Unfortunately, kapt2 implementation was deprecated in preference to kapt3, which should work with star suffixes exactly the same as javac. Please check 1.0.6-eap-77 build.. Merged manually. Thank you!. Merged manually. Thanks!. A number of users requested the opposite: they don't see messages from annotation processors in terminal unless the build is ran with the --info or --debug option specified.\nSo I'd not merge this until there will be a solution that wouldn't harm both sides.. There will be a toggle in 1.2.60: https://youtrack.jetbrains.com/issue/KT-24985.. I'll close this as KT-24985 is done and will be available in 1.2.60.. @Josh-Allen-ConnectedLab Kapt now has a infoAsWarnings option. If it's enabled, kapt translates 'info' messages as warnings.\nThe option is disabled by default.\nYou can pass it as a free argument: -P plugin:org.jetbrains.kotlin.kapt3:infoAsWarnings=true.. Merged manually. https://github.com/JetBrains/kotlin/commit/4fd076e4f420d12df0d78aa7ff9af9c795654fe8\nThanks!. Looks like ResourceRepositoryManager is already used in the as32 bunch:\nhttps://github.com/JetBrains/kotlin/blob/master/plugins/android-extensions/android-extensions-idea/src/org/jetbrains/kotlin/android/model/impl/AndroidModuleInfoProviderImpl.kt.as32#L39\nSo I will close this. Please ping me if this is still actual for some reason.. Failing (1):\nclass Test {\n    fun a() {\n        throw myError()\n    }\n}\nfun myError() = RuntimeException(). Failing (2):\nfun a() {\n    class Ex : RuntimeException()\n    throw Ex()\n}. Failing (3):\n@get:Throws(RuntimeException::class)\nval a: String\n    get() = throw IOException(). Not suggested (4):\nfun a() {\n    throw if (Random().nextBoolean()) RuntimeException() else Exception()\n}. Failing (5, 6):\nfun a() {\n    Runnable { throw RuntimeException() }\n}\nfun a() {\n    class X {\n        init {\n            throw RuntimeException()\n        }\n    }\n}. Failing (7, 8, 9):\n@Throws(exceptionClasses = RuntimeException::class)\nfun x() {\n    throw IOException()\n}\n@Throws(exceptionClasses = [ RuntimeException::class ], IOException::class)\nfun x() {\n    throw IOException()\n}\n@Throws(exceptionClasses = arrayOf(RuntimeException::class), IOException::class)\nfun x() {\n    throw IOException()\n}. Multi-platform projects, failing (10):\n// In a common or JavaScript module\nfun a() {\n    throw RuntimeException()\n}. I really liked how well it works now.\nWill be merged soon. Thanks!. Merged manually.\nSuppose this can be closed.. Merged manually. Thanks!. Merged manually. Thanks!. Merged manually. Thanks!. I don't like the javaClass.classLoader approach as it includes kotlinc+kapt classes, and I don't see any good reason for allowing annotation processors to have access to kotlinc.\nLooks like we need to change our ClassLoader hierarchy inside the compiler daemon to fix this. I hope we will manage to do it in the scope of 1.3.20 (1.3.10 is reserved for the critical issue fixes).. Hello, @GVFiQst.\nThank you for the contribution, but I'm afraid we can't merge it.\nAn android-extensions-runtime library is not a place for Android-related utilities, it's a very small library that's needed for Android Extensions compiler plugin to work.\nI suggest you contribute to the Android Ktx project instead.. Thanks for the contribution! I've merged the commit manually.\n Note that I've also added this commit to support non-existent super interface types: https://github.com/JetBrains/kotlin/commit/c517b85de1ec42c57fc30b6e9b4652b6e508c86c.. That's ok :) Please ping me when the branch becomes ready.. \ud83d\udc4d . Merged manually.\n1.3.20: https://github.com/JetBrains/kotlin/commit/12e03c34c66baf0712c196bbde35485c1e8e2dd6\nmaster: https://github.com/JetBrains/kotlin/commit/72e351a0e3610051fe4222dca4e1eeedf7ae45da\nThanks for the contribution!. I suppose this solution may be incomplete, as kapt doesn't require annotationProcessorFqNames to be declared explicitly. If the user provides no AP names, kapt uses a ServiceLoader to load processors. So it's better to check both annotationProcessorFqNames and kaptClasspath.\nIf I am right, some of the Gradle integration tests should fail after your change. Did you run them (./gradlew :kotlin-gradle-plugin-integration-tests:test)? Also, I would add a new test for this (or reflect the change in the existing ones).. Could you please put else on the new line and add {} for it? So it would be agreed with our coding conventions.\n. Why? :(. Formatting: { should be on the next line.. {: the same.. Why null?. annotationEntry.toLightAnnotation()?. Well, it's the other possible solution, but annotation processing phase will be skipped then, and the user likely get an error such as \"Unresolved reference <...>\" later. And it will be a bit harder to find the actual problem.\nSo I think this is closer to error.. The message sounds unclear to me.\nCan you add some more context, like This intention adds a <b>@Throws</b> annotation for an exception under the caret?. Suspicious empty line.. FqName constructor is extremely cheap. Do we really need to wrap it into a lazy box?. Add '@Throws' annotation. Shouldn't we check for the getCalleeExpressionIfAny() presense instead?. I don't think this is the best approach.\nYou rely on the fact that user will write something like throw MyException() while the thrown expression may be virtually everything (throw if (flag) MyExpression() else factory.makeOtherExpression(text)).\nI'd check the thrown expression type instead.. descriptorToDeclaration() is unreliable and doesn't return declarations from the decompiled code.\nYou should not use it unless it's the last hope.\nCompare KotlinTypes or descriptors instead.. getChildOfType<KtReferenceExpression>()?.mainReference?.resolve() uses the IDEA reference resolution mechanisms.\nPlease use the Kotlin resolution (org.jetbrains.kotlin.idea.caches.resolve.ResolutionUtils#resolveToCall). As a bonus, it gives you descriptors that you can compare against.. What about common modules? I'd rather check if it's JvmPlatform instead.. I'd move this check above val type = element.thrownExpression?.resolveToCall() as it looks cheaper (it doesn't trigger the resolution if @Throws is absent).. There's filterIsInstance() exactly for this purpose.. Hard to read (especially the surprising .any {} after the when block). I'd move when out to the separate function.. What's the meaning of this?. I'd add here a check if the called function is arrayOf().\nIt's effectively true on valid code but, IMO, intentions shouldn't add more chaos if things are already bad.. Broken English. IMO, This inspection reports 'EXPRESSION'-targeted annotations with a  non-'SOURCE' retention. (or something like this) would be better.. This doesn't describe the problem. should have a 'SOURCE\" retention or should not have a 'BINARY' or 'RUNTIME' retention would be better.. Hm, nice idea! \ud83d\udc4d . Looks too complicated. Maybe replace a let with if?. Exactly.. (Here and there) please do not commit commented code to the repository.. What's the purpose of this? You can use KotlinLanguage.NAME in Kotlin project.. Is this needed? Looks like all 'stream-debugger'-related code is either in idea-jvm or in tests.. We do not allow @author comments (CodeConformanceTest#testNoBadSubstringsInProjectCode).. Why can't we just reuse DescriptorRenderer.FQ_NAMES_IN_TYPES without assigning it to the private property?. There are already a number of KotlinPsiUtil-like classes, let's do not create an another one :)\nHow about compiler/frontend/src/org/jetbrains/kotlin/resolve/calls/util/callUtil.kt?. I'd name it receiverValue.. Please, please, please, get rid of these !! (also in other functions in this file). Leave it for ones who like NPEs.\ngetType() explicitly returns a @Nullable value, and I don't see a reason why we should believe it won't return null someday.. I suppose this was ok for the debugging purposes. But I don't expect getText() to return something meaningful in all cases, considering it's invoked on the KtExpression instance (which can be horribly gigantic). And getText() is not a callName, it can return virtually everything.\nAlso, !!.. I'd rename this object to SequenceKotlinTypes or something else as we have a KotlinType and KotlinTypes will appear in auto-completion.. There's a org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames class which contains more or less all of these constants.. There are unsigned numeric types in Kotlin 1.3 (org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames#uByteFqName). Is it critical to support now?. Why it's named TIME? I know, Java has the same implementation of this method, but still.. Is it ok to ignore kotlin.collections.List?. Why can't we generate this test (and also others) from the test data?. Please replace an anonymous function with a lambda argument.. Don't trust the names in PSI, this won't work with type/import aliases.\nIt's good idea to check them firstly (as it's very cheap), but please check the calls/descriptors as well.\nIf would be really nice if you could reuse a single BindingContext from the element.analyze().. Please move KotlinBuiltIns.FQ_NAMES.annotationRetention.shortName().asString() to a constant.. Please move this to a companion object.. Message is not capitalized:\n\n. By the way, in Kotlin 1.3. we have compiler warnings/errors for this (RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION, RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION_WARNING). I think it will make the perfect sense to remove AnnotationTargetExpressionInspection and bind ChangeAnnotationRetentionToSourceFix directly to them.. Please insert the qualified name and then call ShortenReferences.\nYou code won't work with something like this:\n```kotlin\nclass AnnotationRetention // unrelated class in the same package\n@Retention()\n@Target(AnnotationTarget.EXPRESSION)\nannotation class Ann\n``. Looks like switching toRESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION_WARNINGshould fix this.. Maybeexpect / actual?. Probably broken English,ForGeneratedDeclaration`?. Is this possible?\ntargetFile.packageDirective?.fqName != originalFile.packageDirective?.fqName && targetFile.declarations.***isNotEmpty***(). I'd either remove the variable, or just use the old-school if {} block.. Don't know if this would be correct here, but I would replace generated as KtNamedDeclaration to generated as D.. Shouldn't we use DescriptorToSourceUtilsIde here?. Not critical, but:\nMaybe use case-insensitive comparison instead of hard-coding several possible combinations?. Maybe delete the comment?. I feel like it would be a good idea to rename this to something like allowedTypes.\nNot critical, of course.. Missing space? Also below.. ",
    "michalfaber": "Sure, you can use it. This new feature is really convenient alternative to butterknife. Thanks.\n. ",
    "damianpetla": "When we can expect new Kotlin to be released with this fix?\n. Great! It works like a charm :+1: \n. ",
    "mzgreen": "It seems that this does not work in 1.0.0-beta-1103.\n. ",
    "VladimirReshetnikov": "@yole What is the motivation for this change?\n. Yes, looks like a copy-paste mistake.\n. Typo: trageting -> targeting\n. Typo: Possbile -> Possible \n. give -> gives\n. aproperty -> property\n. could have use -> could not use (?)\n. teh -> the\n. delcared -> declared\n. lamg -> lang\n. Missing backtick?\n. Doesn't Function2 have 3 type parameters (2 for parameter types and 1 for return type)?\n. If you inline this variable, you can get rid of as operators below.\n. If you revert this condition, you can get rid of else.\n. \"in the runtime\" -> \"at runtime\"?\n\u0418\u043c\u0435\u0435\u0442\u0441\u044f \u0432 \u0432\u0438\u0434\u0443 \"\u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\"?\n. \"coercible\" usually assumes some transformation of the value representation to fit to a new type. If it's exactly the same object, just viewed as an instance of a new type, then maybe it would be better to say \"implicitly convertible\" or \"assignable\"?\n. I do not get the meaning of \"overriding invoke only would be the best\".\n. What is Fun0?\n. So, is it Function or FunctionImpl who knows the function arity? For which type are we going to check in is operator?\n. What could make it evident that there is or there isn't a receiver parameter?\n. \"first type parameter\"? Are you talking about <T, ...>?\n. By the way, the syntax { Int.() -> } is now deprecated.\n. Then I do not understand the shape of the invoke method descibed here. Could you give an example?\n. ",
    "Tip-Sy": "@cy6erGn0m I agree with you, the behaviour of this function is really confusing.\n@alextkachman I don't think returning the parent is a convention for append functions, see this example\nPersonnaly, I would see it like this:\n```\nbody.appendChild(div1).appendChild(div2).appendChild(div3)\nbody\n    div1\n        div2\n            div3\n```\nVS.\n```\nbody.addElement(div1).addElement(div2).addElement(div3)\nbody\n    div1\n    div2\n    div3\n```\nBut according to the behaviour of Element.addElement(name: String...), I thought I had to return the child element as well.\n. Ah I realize that I mistook append_To_ for append_Child_ in my comment (I've corrected it). To clarify things up: appendTo returns the parent element, whereas appendChild returns the child.\nYou're right, maybe we don't really need this function after all.\n. ",
    "staltz": "Thanks. I don't have an application that depends on this issue fixed, so it can wait until it is published.\n. ",
    "mglukhikh": "Added manually to 1.0.4 and master.\n. See fixing commit: https://github.com/jetbrains/kotlin/commit/75832f9d80218a495253f6c55b733ee01f1e4981\n. And separate commit for annotations: https://github.com/JetBrains/kotlin/commit/8bdc88f76331c544dd1db81f5266bda53093be42\n. Ok, I will do a pair of minor changes myself and then push your commit into the main repo. Thanks again for your contribution!\n. Edited and pushed manually\n. Under investigation\n. Pushed to master. I don't think additional code with indirect supertypes is really necessary because we will not have any error and thus no quick-fix. Anyway, I added a test for this case. Sorry for slow consideration.\n. Pushed to master (manually). Many thanks again.\n. Merged manually with master and 1.0.2 branches.\n. Merged manually into master and 1.0.2 branches.\n. Processed manually.\n. IMO the solution is unnecessary complex. Why you do not want to take KtAnnotatedExpression (and not KtAnnotated) as the basic for your intention? You can mark each such expression separately if 'at' is unnecessary. I think it will be more clear for the user.\n. I'm investigating it. Probably will finish tomorrow morning.\n. By the way: files like IntentionTestGenerated.java (to be precise, *TestGenerated.java) should never be changed manually. To regenerate them, please use \"Generate Tests\" run configuration (I've already done it for your changes).\n. Refactored and added manually to master and 1.0.4 branches.\n. Thank you for your help\n. I think everything is OK with this PR\n. Thanks!\n. Mostly everything is OK but this 'property::findAnnotation' is a bound reference and cannot be compiled without Kotlin 1.1. I will fix it myself for future Kotlin 1.0.4.\n. Manually added to 1.0.4 branch. I'll cherry pick this commit to master today later. Thanks.\n. You forgot to add RemoveUnnecessaryLateinit.html into idea/resources/inspectionDescriptions\n. Also I would say that 'LIKE_UNUSED_SYMBOL' highlighting would be better for this inspection (to change this, you can override problemHighlightType)\n. Also the method you are using to resolve secondary constructor dependency is not the most optimal (you analyze the same constructor more than once in recursion). Moreover, it's dangerous when some constructor accidentally delegates to itself, AFAIK you will have stack overflow as result.\n. Added manually to 1.0.4, will add to master branch tomorrow morning. Thanks for your efforts!\n. Added manually to 1.0.4 branch. Will add to master branch today later. BTW: in its original state, intention was suggested on simple strings, like \"Hello\", I've fixed it. Also, I decided that inspection should be reported only for string types, otherwise we should have only intention (syntax with .toString() is longer, and performance boost got is very questionable).\n. Thanks!\n. Sorry but in this case intention / inspection pair is not appropriate. There is already a compiler error about it: REIFIED_TYPE_PARAMETER_NO_INLINE, so you should not detect it second time. Instead, a quick-fix should be added for this compiler error. You can look at QuickFixRegistrar.kt as binding place for such quick-fixes and ChangeVisibilityOnExposureFactory.kt as possible example.\n. Thanks, I will merge it today manually.\n. Polished a little bit, added a few tests, merged manually into master (will merge into 1.0.4 today later). Thank you!\n. I polished it a little bit: changed inspection type to LIKE_UNUSED_SYMBOL; added change of foo = ${foo.toString()} just to foo = $foo without curly braces + some minor details. Merged manually into master (today later into 1.0.4). Thanks.\n. It handles the following case incorrectly:\nfun test(n: Int) {\n    var a: String = \"\"\n//  v Replace if with assignment: incorrect (should not be active)\n    if (n == 1)\n        a = \"one\"\n    else if (n == 2)\n        a = \"two\"\n}\n. It should be enough to check here that last if in branches has else.\n. OK thanks, pushed manually into master, will push into 1.0.4 a bit later.\n. I've added a few minor details and merged manually into master (today later in 1.0.4). Thanks.\n. Manually merged into master, later to 1.0.4. Thanks!\n. (I've fixed some minor details)\n. Merged manually with minor corrections into master. Thanks!\n. Merged manually with some corrections (candidateDescriptor -> resultingDescriptor, analyzeFully -> analyze, function extracted, etc.) into master. Thanks!\n. Thanks!\n. I've rewritten the intention and merged it manually. Thank you. You can see changed code in the master branch, if you're interested.\n. Quick-fix you have implemented is not RemoveFinalUpperBoundFix. I'd name it like InlineTypeParameterFix, because it removes not a bound but a parameter itself, replacing its usages with usages of the bound. I'll integrate it in the source with some renaming & polishing but in fact it's not a solution of KT-13674.\n. As stated, it should remove a bound and leave parameter as is.\n. However, I integrated your fix in master & 1.0.5, so thank you, this fix is also helpful.\n. OK, with pleasure.\n. I'll integrate it in master & 1.0.5 today, so thank you. Some notes: you've forgotten to add 'inline' modifier to a function; the recommended way to create quick-fix test is separate .kt and .kt.after files, and stuff for multi-file tests is not needed for them. Also, I've performed some polishing.\n. Merged into master branch with minor fixes.\n. Thank you\n. Mostly everything is Ok. I added some notes for your changes, please fix them, and I'll integrate the result into master branch.\n. Thanks, I added everything to the master and 1.0.5 branches\n. Mostly everything is Ok, so thank you. I added some notes into your code. Please do the requested changes, and I integrate them into master.\n. May be concatenatedStringGenerator would be a bit better.\n. Thanks, I'll squash and merge it.\n. It's not necessary, done already. BTW, for some reason your testNewLine does not work on my PC. Now I'm trying to investigate it.\n. Yes but I got an exception \"Failed to create expression from text\". At this moment it's unclear, why. However, this case works in IDE, so I integrated your PR without this test, will investigate the situation a bit later.\n. I think it's OK with changes, so I'll integrate your PR in master, thanks.\n. I've added it into master and 1.0.5, thanks.\n. I think also that this case with maps can be ignored in tests.\n. About Maps I do not know details, but probably they are not included into runtime library which is in use inside tests. It's fixable but it's not very important.\n. Thank you for your efforts. I'll integrate this change into master and (probably) 1.0.5 on Monday\n. We already have fixes for both required actions: ChangeVariableMutabilityFix and RemoveNullableFix, so it's enough just to create factories for these actions. Nevertheless, thank you for your efforts. Added into master & 1.0.5 with changes.\n. Thanks, I've integrated this in master with minor style fixes.\n. As far as I can see now, these two tests are in the same order in master branch? . Pushed into master & 1.0.5, thanks for your efforts\n. BTW, I don't think that LIKE_UNUSED_SYMBOL highlighting is so gut for this inspection (usually, such a highlighting is in use when something can just be deleted).\n. Pushed into master & 1.0.5 with some refactoring (also changed highlighting style to WEAK_WARNING), thanks for your efforts\n. Thanks, I'll integrate this PR today.\n. Thanks for your efforts. I've moved your change into the intention itself to avoid behaviour changes for other callees. Merged manually into master & 1.0.6.. Thanks for your efforts. Merged manually into master & 1.0.6 branches.. OK. If we do not invent some better solution in a few days, I will integrate this one into master. Thanks for your efforts!. Integrated into master. Will integrate in 1.0.6 probably tomorrow. Merged into master & 1.0.6, many thanks.. Ok, thank you, I will merge it manually. Later (probably tomorrow) you can look at this when code, I have simplified it successfully.. Finally merged it. Sorry, too many things to do these days . Ok, quick-fixes are really controversial here so we can omit them.. isUsedAsResultOfLambda is not the only case. What about something like val eq = if (...) a == b else c == d, or the same with braces: val eq = if (...) { a == b } else { c == d }?. Merged manually into master. Thank you, I'll merge it into master but probably after 1 Jan. Happy new year!. Merged into master with some minor changes, thanks. . Merged into master, thanks.. Merged into master, thanks. Ok, thank you, I'll changed this a bit and merged into 1.1 & 1.0.7. . Thank you, merged it into master.. Merged into master, thank you.. What about chained calls like a.foo().bar() or a.x.bar()? There are no such tests, and I'm not sure they are handled correctly here.. Also, seems important to distinguish apply() from two other functions here because it generates its result differently. I'd say that by default apply() should have less priority or even should not be shown if we do not want to use its result. rcv.run() and with(rcv) looks more logical in these situations.. Yes, it's possible way. I just do not like an idea to have three effectively identical intentions.. Sorry please, will merge it today or tomorrow :). We're in release rush now.. I have to say that the code is not clean enough, because large part exists in both ConvertToScopeIntention and ConvertToApplyIntention. This should be solved before merging into master. I see that they have different base element types, but really it's not an obstacle. You can try to solve the problem yourself if you wish, or I can do it myself when we're out of release rush -- your choice.. So OK, I have finally merged it, thanks.. Technical PR, please do not merge. Slightly polished and merged into master, thanks!. Slightly polished and merged into master, thanks!. There is ChangeVisibilityFix already, there is no need to re-invent it.. See also MakeVisibleFactory.. Really situation is even more simple because we already have MakeVisibleFactory. I'll do all integration needed today. https://github.com/JetBrains/kotlin/commit/27e1462b006915ce375540467f5ff05bb3a988c0. Everything except the last commit (controversial one about JPS plugin) was merged into master. Hope we have not broken anything. Thanks for everybody who helped!. Also I think this intention should not be suggested for abstract members, either explicitly or implicitly, because making them open will likely make code red.. Yes, I will merge it today, thanks :). Merged manually. Intention forbidden for everything not KtProperty or KtNamedFunction, e.g. for KtConstructor. Intention allowed for enum class members.. So thanks, I merged it into master, with some refactorings. Probably I should mention that IntentionBasedInspection is no more recommended as base class for inspections. You may look at the final commit as possible example: https://github.com/JetBrains/kotlin/commit/0eceef1519653d37cf2f6177da5d5aa059375436. Thanks, I've merged it. Added one test from the issue just to be sure.. Thank you. I will extend this intention, because there are some cases that are not considered in your code. Probably will add it into master today.. So thanks, it was finally merged :). Thank you, will merge it today.. Thanks, merged into master. Just to document: I'm investigating it now. We have two very similar intentions (IfThenToSafeAccess, IfThenToElvis) and I'm trying to make them working in the similar way.. Thank you, I've finally added it into master (with the set of commits making IfThenToSafeAccess / IfThenToElvis working in the same manner).. Sorry but it's not so easy :(. At least I should mention that lateinit is not applicable for val, nullable types, and primitive-in-Java types. Please check DeclarationsChecker.checkPropertyLateInit for more information about.. This time looks good to me. Will merge it soon.. OK, I'll try to find the solution myself :). I'll improve this inspection and merge it into master myself.. Merged into master, thank you.. Sorry, but NON_EXHAUSTIVE_WHEN is intentionally not reported on sealed classes, it's a very controversial warning :(. About an issue, we need here an intention only, not an inspection or compiler warning.. You can here, for example, take AddWhenRemainingBranchesFix and convert it to an intention, it's relatively easy. Then NON_EXHAUSTIVE_WHEN for enums can use this intention as quick-fix via IntentionWrapper.. Yes, I think this way is also possible. Will check everything manually and merge.. @nd Looks good, but I'd say the second case like below (duplicating comment in the issue) is even more important. Not sure should it be the same inspection, probably the other one is better.\n// JavaInterface.java\npublic interface JavaInterface {\n    String getSmth();\n}\n// Test.kt\nclass Test {\n    val smth: String\n    fun createJavaInterface() = object : JavaInterface {\n        override fun getSmth() = smth // expected this@smth, but synthetic property is used instead!\n    }\n}. @nd At the moment I've almost done it myself. It can work almost in the same way as the first part. So thanks for your help. Also, I've added a fix for the first part (done by you) which replaces recursive access with field.. Merged into master and 1.0.3, thank you. I think it's OK, thank you. Will merge soon.. Thank you. I'll try to take best from both this PR and https://github.com/JetBrains/kotlin/pull/1091. Partially merged into master. Thank you. I'll try to take best from both this PR and https://github.com/JetBrains/kotlin/pull/1090. Merged into master. Merged into master, thanks.. I think in this particular case the best way is to delete existing intention, because inspection duplicates it. You can easy use extension functions from this file making it internal or public instead of private. In case we would need both intention and inspection (e.g. inspection reports only some subset of cases coverable by intention), we should add a property of intention type into inspection and use isApplicable function from it to find problems. I'll do all necessary actions myself today.. Merged into master, thanks.. Thanks, I will merge it.. Thanks, I'll merge it.. Thank you, merged into master.. Slightly changed and merged into master. Thank you.. Technical PR, please do not merge it.. Fixed manually, thank you :). Thank you, I'll integrate this.. Edited and merged into master, thank you!. Edited and merged into master. Receiver analysis by text replaced with analysis by descriptors. Thank you.. Thanks, merged into master. Thanks, will merge it today. Thank you, merged into master. This <file>temp:///src/test.kt</file> should be replaced with just <file>test.kt</file>. Thanks you, merged.. Thank you, merged into master. Thank you, merged into master. Please pay attention to the fact that function you've changed KotlinType.isResolvableInScope is used in different places, not only in the intention you are trying to fix. That's why some logic was broken.. Thank you, I've merged it.. Thanks, looks great. After your fix, intention will not be available on ! (which was true before), but looks like it's not a problem.. Merged manually. Mostly OK, thanks, will merge into master. Merged manually. Looks like you must check all qualified expression' components on stability, otherwise offered transformation is not semantically equivalent. For example, class mutable property is not stable, because it can return different results on different reads. As an example, use KtExpression.isStable from IfThenUtils, however, it works correctly not for all expression types. Full set of stability-related functions is available in DataFlowValueFactory.. More exactly, if you're converting to a?.b?.c?.d != null, three components a, a.b, a.b.c must be checked. Looks like last component a.b.c.d may not be checked, because it's read just once in either case.. Mostly it's OK now. Will merge it today. BTW, a counter-example found:\n```\nval a: Testtt? = Testtt()\nfun main(args: Array) {\n    if (a != null && a.a != null) {\n}\n\n}\nclass Testtt\nval Testtt?.a: Testtt? get() = null\n```\nYour version of inspection suggest to make replacement, but it's not equivalent here (already fixed by me).. Also, this test is buggy:\n```\nfun main(args: Array) {\n    val a: Testtt? = Testtt()\n    if (a != null && a.a.a != null) {\n}\n\n}\nclass Testtt {\n    val a: Testtt = this\n}\n```\nYou're replacing it now with a?.a.a != null, which is certainly not true (dot call is unsafe here).. Excellent false-positive (extracted from Kotlin project):\n```\nclass KotlinType\nclass KotlinTypeInfo(val type: KotlinType?) {\n    fun foo(other: KotlinTypeInfo) {\n        if (type != null && other.type != null) {\n    }\n}\n\n}\n```\nHere you erroneously suggest to apply fix, and we get an exception.. So merged manually, but with some fixes. BTW I eliminated cases like x != null && x.y.z != null, thus allowing only one additional selector. Anyway, thank you.. Fix looks correct, thank you. Merged manually. FYI: in Kotlin project we use non-standard formatting of if-else:\nif (something) {\n}\nelse if (smthOther) {\n}\nelse {\n}. Also, your fix is correct but it may be extended to situation when expression is not a null constant but exactly null. E.g.\nfun foo(arg: String?) {\n    if (arg == null) {\n        val x: String = arg // Don't add !! here, it's obviously KNPE\n    }    \n}\nI can think about it myself or you can do it, your choice. To do it, we should extract KotlinTypeInfo for arg expression in RHS using EXPRESSION_TYPE_INFO slice, then read dataFlowInfo from it and extract arg nullability.. However, I do not think this quick fix should be in cleanup / migration because this transformation is not a migration, just a fix of syntax error. I will remove it from there.. OK, I will merge it. Merged manually, thank you. Merged manually. Thank you. This fix looks correct, thank you. Merged manually. I think it's OK, thank you.. Merged manually. NB: in future, please write both GroupName and GroupPath in inspection description inside plugin.xml.. Thank you, I've merged it with minor changes. I recommend using LocalInspectionTestGenerated for inspection fix tests, it requires less text than QuickFixTestGenerated (and can check more).. Thank you, merged manually.. Kotlin project already includes control-flow analysis tool which is located in compiler/frontend/src/cfg and used at this moment for initialization analysis and usage analysis. I think it is the perfect way to implement analysis like yours. Implementing the same analysis in an inspection is bad because you are repeating the same logic there (with less coverage of PSI elements) and also spending more time.. I will close this PR. If you have interest, you can try to implement the same feature using our CFA tool, it's relatively easy. If you have questions about this tool, you can ask me in comments to https://youtrack.jetbrains.com/issue/KT-18897 or directly by e-mail (mikhail.glukhikh@jetbrains.com).. Thank you! (merged manually). Thank you, will merge it. Merged. Merged, thank you.. Merged manually, thank you.. Rewritten and added to master. About resolve of JvmField, it's some inspection test artifact. I recommend to use tests from inspectionsLocal group because they are easier to debug and more flexible. Also, the function to detect JvmField annotation already exists.. Thank you!. Thank you, it looks good.. Merged manually. Merged manually, thanks.. Looks good, I will test this inspection.. Also, inspection description was forgotten, added (hint: run InspectionDescriptionsTest). Merged manually into master, thank you.. Merged after minor edit. Thank you. Merged after minor fix. Fixed & merged manually, thank you.. Thank you, merged (added also EffectiveVisibility.LOCAL).. Merged. However, I removed yet JAVAX_NONNULL_ANNOTATION due to its unclear status. May be it should be restored a bit later.. Thank you, merged. Merged manually. Merged manually, thank you. Also, please add test when super function is called in expression body format:\noverride fun foo() = super.foo(). I think mostly it's Ok, I will recheck it, slightly correct style, and merge.. Merged manually. Please do not merge. My review is finished at this point. Probably deprecated. Merged manually after some polishing, thank you.. Merged after some polishing. For example, you do not require separate quick-fix class for this purpose.. I think generally it's good now, but not exactly sure about ReferencesSearch usage (it can affect performance). I'll think a little bit and accept it.. Finally I merged it. Thank you and sorry for so long reviewing!. Thank you, merged after minor refactoring.. Thank you, merged into master.. Merged manually. Fixed and merged manually. Thank you, merged manually. Thank you, merged manually. Thank you, I will merge it.. Ok in general. Will polish and merge it.. Fixed & merged manually. Now both intention & quick-fix support this feature.. Merged manually, thank you. I will check the test and merge it. Accepted. The only point is we should not delete primary constructor for expect class in any case. But this is multi-platform stuff and it's easier for me to fix it myself. Thank you.. Merged, thanks. Ok, thank you, I will test it once more and merge it.. Looks good in general. Will look at it once more in IDEA and merge.. Discovered a few important things, see comments.. @t-kameyama You can either try to fix problems or wait for my fix.. At this moment I already have a solution.. Added to master. Thank you for good tests!. Thank you, merged. Excellent, I will merge it today.. Merged, thank you.. I'm sorry for long delay. Will process all feature PRs when I have time.. Slightly fixed and merged manually. In particular, I forbid to suggest this quick-fix for library annotations or annotations from read only files.. Looks pretty good, will merge it today.. Merged, thank you.. Thank you, will merge it today.. Merged. Thank you.. Merged, thank you. I found a bug here: Unit should not be reported as redundant when inside lambda, because it can influence type inference. return Unit or return@labeled Unit can be reported even in this case. I will fix it.. Merged, thanks. BTW I converted it to inspection, it looks more logical.. Merged, thank you. Closed because of no activity. Also I suspect it can be invoked simultaneously with AssignToPropertyFix.. Excellent counter-example found:\nclass Your(val x: Int)\nfun Your.foo() = <caret>this.x // Add explicit 'this'\nafter it we get fun Your.foo() = (this.this).x together with NPE provoked by broken PSI :). Fixed, slightly simplified, and merged manually. Thank you. NB: I was not sure about analyzeFully vs analyze here, but looks like analyze also works.. It's too unclear to document it. I can only say you that analyzeFully() should have results equivalent to full compilation, and analyze() has no such guarantees. E.g., as I can remember analyze() will not produce CFG information.. Looks good, I will merge it, thank you.. Done, thank you again.. Merged, thank you. Merged manually. . Additional checks revealed many false positives here. Really we should report \"recursive equals\" only for checks like this == other, with this and nothing else on the left and other (equals parameter) and nothing else on the right. On this stage it's easier for me to fix everything myself, but it's better for you also to know it.. Merged with some significant fixes. Thank you, merged. Thank you, merged.. Thank you, probably will polish a little bit and merge.. Finally merged, thank you.. Looks good. I will test it and then merge.. Slightly changed and merged, thank you.. Don't quite understand the situation, will recheck myself. But probably Ok, thank you.. PSI problem, understood. Commit message changed, merged, thank you again. BTW it could affect some other IDE actions using this part of PSI factory.. Fixed and merged, thank you. Edited and merged, thank you. Looks good, will merge it. Merged, thank you. Fixed and merged Thanks.. To be clear: this work is very far from finish. I created this PR just to review code myself.. Mostly it's good. However, we shortly discussed it and decided that it's better to have an inspection, not an intention here. You can leave conversion to me or convert it yourself, your choice. In the latter case, you should derive from AbstractKotlinInspection and move your tests to inspectionsLocal directory in testData. . Thanks! Then I'w waiting for your changes. Yes of course. Will merge it soon.. Thank you, polished, added to J2K and merged. @devbridie Have you intentionally closed this PR or by mistake? Update: understood, old PR is available.. Ok, will merge it. Merged, thank you.. After some thinking I decided there is no much reason to suggest \"convert to array literal\" in this case, because * is anyway redundant and after application of its fix arrayOf or [] will be anyway removed. So I will merge it in the current state, thank you.. Should be Ok, will merge it. Merged, thank you. Looks good, will take on remote run and test it a bit.. Thank you, merged.. Fixed and merged. Thank you.. Merged, thank you. Thank you, merged. Merged with minor fixes. Thank you.. Looks good, but how does it behave in a situation like\nfun foo(x: String?, y: String(?)) {\n    if (x != y) { ... }\n}\nWill check and fix if necessary.. Merged, thank you. Simplified a bit and merged, thank you. Thank you, I will test it and fix the remaining things myself.. About an idea to make it an inspection: it's possible but harder. We must remember that substring(0, 1) has a type of String and [0] has a type of Char, so changing one with another will sometimes provoke a compilation error. Such behaviour of intention is IMHO acceptable but for inspection it's absolutely not possible.. So thank you, merged it. Small fix added. Merged, thank you. Thank you, merged . Thank you, polished & merged. Thank you, merged.. Fixed & merged manually.. I think it's Ok, thank you. The only point: may be using modifier list and/or val/var keyword looks a bit nicer and operates a bit faster than getNextSiblingIgnoringWhitespacesAndComments. I'll try to refactor your code this way.. Merged. Looks great, thank you.. Merged. Merged without changes, thank you.. I think it's Ok, but now it's logical to derive from SelfTargetingOffsetIndependentIntention. I'll add the relevent commit. Thank you.. Merged. @Megamiun Ok. @Megamiun I reviewed your inspection again and mostly it's OK. I will recheck it on real code base and merge. Thank you.. NB: in future, please do not set cleanupTool to true unless your are absolutely sure your inspection is applicable as part of automatic code cleanup. Same applies to inheritance from CleanupLocalInspectionTool.. It's mostly good. However, we have a special class CommentSaver which is intended to save and restore comments during code transformations. I will try to change your code to use this saver and check results on your tests.. So it can work with CommentSaver but comments still have to be deleted manually. You can look at my commit if you are interested (it's added to yours): https://github.com/JetBrains/kotlin/commit/dd106cb65c4ccbb96a0c02f28ba44e9f9a69f96b. Fixed and merged. Fixing commit (again, CommentSaver was in use): https://github.com/JetBrains/kotlin/commit/bec28c8388d050d371c333391bc0b3f81cf35a7a. Thank you. I think now it's Ok, I will recheck and merge it. Thank you.. Polished a bit and merged, thank you.. Well, I like the code but I don't like the diagnostic messages. I will change them and merge this.. Thank you, I fixed & merged it.. It should work, thank you.. Ok, I'll merge it, thank you. Merged. Yes, such a replace is enough, so I did it. Thanks.. I think it's Ok. I'll try to find easier solution and merge it.. Merged, thank you. After some consideration I decided that it's good to process all visibility & modality modifiers after others, because all of them easily can be redundant and such logic can be included into addModifier.. @tommykw Now it looks good for me, thank you.. Merged, thank you.. Merged, thank you. Merged, thank you. I merged it but have some doubts about suggesting \"Add braces\" and \"Remove braces\" at the same point. Especially if they're suggested as \"Add braces to if\" and \"Remove braces to if\" (for the first, upper if is in mind). Not quite sure how it can be done best way. . Merged, thank you.. Mostly it's good, thank you. In future, I recommend you to squash all commits before creating PR. Also, I do not recommend to declare in compiler front-end functions which are used entirely in IDE. I'll fix this details myself.. @fg123 Please pay some attention to the resulting commit: https://github.com/JetBrains/kotlin/commit/95392121808d5ab22dd56e56a25adbf8f1c1f944. In future, don't forget to regenerate automatic tests (Generate All Tests run configuration). Also, your tests should belong to quick-fix group (see withJava.before.Main.kt, withJava.after.kt, withJava.before.UsageJava.java in the resulting commit). Anyway, thank you for your contribution.. Thank you, so much work. We accept you change.. Thank you, merged.. Merged, thank you.. Thank you, merged. Tested & merged it, thank you!. Merged, thank you. Merged, thank you. Thank you, merged.. Looks great. Merged, thank you.. Merged (with minor polishing), thank you. Fixed and merged, thank you. Merged, thank you. Merged, thank you. Looks well. Merged, thank you. NB: it's much better to separate reformat from valuable actions (do them in different commits).. Merged with a little polishing, thank you. Looks pretty good, thank you. Well, you've forgotten to add intention descriptions, but it's not a large problem. What's worse, I tried to use it on our code base and it does not work (fails silently so code isn't changed at all). Will try to understand what's happened.. Finally solved via document operations, see commit: https://github.com/JetBrains/kotlin/commit/de0cbf584411f22dedb012b2536a8813b857cf5d.. Merged, thank you. Ok, thank you, I will think about CallableBuilder myself.. Another point about this PR is type rendering. I'm afraid we can get type representations like java.util.Deque instead of just Deque (probably KotlinType.toString() gives us fully qualified name). Also will recheck this.. > CallableBuilder will break format\nThe situation you described is a formatter bug. See https://youtrack.jetbrains.com/issue/KT-24360\n. Finally merged (with lot of small fixes) into 1.2.60. Thank you.. I'm afraid I already fixed it different way (not yet in master). I will think once more which way is better and push the chosen fix into master, and may be 1.2.40 too.. Own fix used. Merged, thank you. Merged, thank you (may be other similar cases possible, but yet I have not enough time to check it attentively).. Merged, thank you. Thank you, merged. Thank you, merged. Merged, thank you. Thank you, merged. Thank you, merged.. I think the same is possible for functions with expression body. Extended for functions with expression bodies and merged.. > What should be happen when element.right !as ktBinaryExpression?\nNothing special, just insert safe calls in this expression (fixText) everywhere.. > And I can't use Generate All Tests due to the bug with Windows. What should I do?\nYes, we had an error at this point with a message like \"too long command line\". However, it's already fixed. You can rebase your branch on master and everything should work properly (I use Windows myself).. Yes, many thanks. PR accepted, I'll merge it this week.. Merged, thank you. Merged, thank you. Looks good, thank you. May be I will polish code a little bit. Just as comment: it's generally a good idea to do reformat in a separate commit, as done in this PR. It makes much easier to understand purpose and changes of each commit.. Merged. Merged, thank you. Merged, thank you. Merged, thank you. Thank you, merged and closed. NB: it's better to use createExpressionByPattern when possible, see here: https://github.com/JetBrains/kotlin/commit/84d71e5a8ca145e23adf634e5814ceb7163c8e29. Merged, thank you.. Thank you, merged. Could you please check that the case from https://youtrack.jetbrains.com/issue/KT-24066 also works after your fix?. In general it's Ok but it seems to me we can done both these things in more simple way. I'll make a few experiments and merge it (as it is or with some polishing).. Ok, I merged it. You can look at fixing / polishing commit: https://github.com/JetBrains/kotlin/commit/e07f83ddbc0cb1f558caef1f6d0e1db548fe9698. In particular: you took the first argument of function type, but should take the last one; it's better to use argument mapping to determine corresponding value parameter; it's better to use getTargetFunctionDescriptor to determine which function we are returning from.. Thank you, finally merged.. Thank you, merged.. Fixed and merged, thanks.. Fixed and merged, thanks.. Merged, thank you!. Merged, thank you!. Thank you, merged. Merged, thank you. Merged, thank you!. Merged, thank you!. @t-kameyama Thank you!. Finally I decided that I refactor this a little bit and merge. Mostly I do not like this piece of code:\nval argumentsText = when {\n                secondCallArgumentList?.arguments?.isNotEmpty() == true && firstCallArgumentList?.arguments?.isNotEmpty() == true -> {\n                    \"${secondCallArgumentList.text.removeSuffix(\")\")}, ${firstCallArgumentList.text.removePrefix(\"(\")}\"\n                }\n                secondCallArgumentList?.arguments?.isNotEmpty() == true -> secondCallArgumentList.text\n                firstCallArgumentList?.arguments?.isNotEmpty() == true -> firstCallArgumentList.text\n                else -> \"\"\n            }\nBecause it's very non-regular and relies on a fact that argument list starts with \"(\" and ends with \")\" which can be true but not very stable :(. Your fixes are not necessary here, I will finish everything myself.. Finally merged after some changes.. Merged. Thank you, merged!. Merged, thank you!. Merged, thank you!. Merged, thank you!. Merged. Merged, thank you!. Merged. Merged. Generally it's good, but (probably) can be simplified. Will refactor and merge.. Simplified and merged.. Looks good. I will test it on our code base and then merge.. I optimized inspection a bit and merged it, see commit: https://github.com/jetbrains/kotlin/commit/e1d223937b54e8abb3dbc83917eef6de65c316d6. Usually it's good for performance to check first something on PSI and only then perform more precise check via resolved call or descriptor. Anyway, thank you.. Merged. Merged. Merged. Merged. Merged. Looks good, but I'd like to test it on our code base first. I remember well enough that \"redundant let\" has a tendency of giving false positives :). BTW this case is not \"false positive\". Inspection is not reported when we expect, so it's \"false negative\".. Merged, thank you. @t-kameyama I sent you an e-mail yesterday, have you received it?. Thank you, merged.. Thank you, merged.. @ilya-g I don't think it's really important. As you can see, this inspection works for a wide range of functions. Sequence.orEmpty() does not exist in 1.2, but this only means that in 1.2 inspection has no chances to highlight this call. So I'd recommend to merge both commits into 1.3 branch.. Thank you, merged.. Additional question: what about termination-like calls (first() etc.)? Should they block conversion into sequence in situations like someList.map { it.toSomething() }.firstOrNull()?. What do you think about this, @t-kameyama ?. And I found another point which is better to be fixed: highlighting range is too wide, it looks ugly. You can compare it, for example, with SimplifiableCallChainInspection.. Final testing in progress.... Note: probably forEach & forEachIndexed should not be count as termination function to prevent possible concurrent modifications.. Finally merged it. Thank you.. Merged with some style fixes, thank you.. Thank you, merged.. I will test it a little bit and then merge.. Merged, thank you. NB: I downgraded this case to INFORMATION level (so just an intention).. Asked somebody from JS team to review.. Ok but I'm not sure isUsedAsExpression works correctly here. Asked Dmitry Savvinov to review this part.. Thank you, merged.. Thank you, merged.. @aleksZubakov Could you explain what do you want to achieve with this PR? Why do you want it to be merged?. Thank you, merged with some corrections.. Thank you, everything looks good. I will perform the final testing and accept it, either with some fixes or not.. Final testing revealed important problems, sorry (I can fix it myself if you wish).. Also, I have recently found that this inspection is reported when destructuring declaration is used inside forEach lambda, no matter whether its components are used or not. Example:\nfun foo(map: Map<String, String>) {\n    map.forEach { (t, u) -> \n        println(\"$t: $u\")\n    }\n}. And yet another revealed false positive:\n```\nclass My {\n    operator fun invoke() / can include parameters, no matter / {}\n}\nfun bar(my: List) {\n    my.forEach { it() }\n}\n```. Meanwhile, I found one true positive in Kotlin project (ConvertSealedSubClassToObjectFix):\nprivate fun KtClass.changeToObject(factory: KtPsiFactory) {\n        getClassOrInterfaceKeyword()?.replace(factory.createExpression(KtTokens.OBJECT_KEYWORD.value))\n        secondaryConstructors.forEach { delete() } // should be it.delete()\n        primaryConstructor?.delete()\n    }\nSo thank you for your work!. I hope now it's the final state :) Thank you.. Finally merged it. Thank you for your efforts!. Merged. I increased level of this inspection to weak warning. Thank you.. Ok but I'd change the display name from plugin.xml too. Will do myself.. Thank you, merged.. Thank you, merged.. Thank you, merged. Thank you. I will take this inspection on remote run and complex testing.. Ok, I approved this. I consider this inspection also a bit questionable (that's why I'm holding this PR for so long time), but yet I think we can accept it but should consider all suggested quick-fixes carefully (and probably do not highlight anything in situations we have nothing to suggest). At this moment fix to list = list + ... is considered as most reliable and understandable (it shows explicitly that the list is changed, and we should not suggest \"replace with +=\" for this particular case). Will look a bit how it works in practice and either fix myself or return back to you.. Finally merged this (manually).. Thank you, merged. Thank you, merged.. Merged, thank you. Generally looks good, I will test the inspection a bit and then fix / merge it.. Finally merged, thank you. Thanks, taken on complex testing.. During complex testing, I noticed the following:\n\nfix works incorrectly for code like if (...) return ... else return ..., converting it to if (...) return ... return ..., I expect here a new line before second return\nsometimes (yet I don't understand when and why) it works incorrectly with long block of statements in else, shifting one tab back only first of them and keeping indent of all other statements\nin tailrec functions, it may be dangerous to use the fix (not quite sure, I should think about it)\n\n@t-kameyama , you may try to investigate and/or fix some of these issues yourself, or I will do it when have some time.. Also we may have some performance problems here because when launched on Kotlin code base, the inspection eats all memory, CPU time and hangs IDEA (at least it happened in my only experiment). This can mean nothing, or can point on some important problem. To be investigated.. Ok, I've taken it on final testing again.. This problem is still intact: \"it works incorrectly with long block of statements in else, shifting one tab back only first of them and keeping indent of all other statements\". I cannot accept it until it's fixed.. Ok, I'm taking this for testing third time :). Finally merged. Thank you.. Looks generally good, thank you. I will test it on the code base. Also look at my comment, please.. Merged manually, thank you.. Thank you, merged.. Thanks, taken on remote testing. Ok, I'm doing final check and merge :). Thank you, merged. Thank you, merged with minor corrections.. It looks now generally good. I will polish it a little bit and merge.. Merged manually, thank you. NB: here https://github.com/JetBrains/kotlin/commit/248e09ff2c2683c69d534a180cd326f5c041a665 I converted collectFixesAndRegisterProblem to just collectFixes to avoid side-effects.. Ok, I will polish it a little bit and merge. Merged manually, thank you. @tommykw Are you going to fix it yourself? This issue has some importance, so please do it or leave it to me, as you wish.. Thanks for fixes, I will now consider everything more attentively.. Merged manually, the part related to smart-casts is implemented aside. Thank you.. Merged manually, thank you.. Merged manually (with small refactoring), thank you.. Merged manually, thank you.. Ok, I'm doing final check and merge :). Thank you, merged. Merged manually, thank you. Merged manually with minor fixes, thank you. Thank you!. Merged manually. Merged manually, thank you. @rsauciuc Thank you. I will merge it into master (after remote run), and then into 1.2.71 and 1.3 branch too.. Thank you!. Generally, it looks good, thank you.. Looks generally good, I'll take this for testing.. Finally merged, thank you. . In future, please don't forget to run \"Generate All Tests\" and then run at least all new tests locally. At this moment two of your tests fail.. Fixed and merged manually. Thank you.. @Monchi Yet no, I've done everything already, but do it in future PRs, please.. Ok, I merged it. Last commit was merged partially, because I do not want too global checks inside this canBePrivate.. I added one more example (see last comment in the issue). Also, I don't like your check itself, I'd say it's easier to get variable type from its VariableDescriptor. Will try to rework myself.. Merged and extended by the following commit: https://github.com/jetbrains/kotlin/commit/9b4bcabbd3104a5a8bdef36d4a690d171d13bd06. Thank you.. Merged manually. This looks good, so I will merge it soon. Merged manually. Thank you, I think now it's shiny enough. Will merge it.. Merged manually. Merged manually, thank you. All code in this PR is not needed, so I will close it. @DeFuex please create new PR if you want to do a new try. Yes, it's something close to the thing we need here. Will review it more attentively. Generally, I don't like the fact we have to create comment first, then create it again at another place, and then delete it at the old place. You may think about it if your want, however, I'm not exactly sure that better solution is possible here.. Ok, I will take it on remote run and merge if successful.. Merged, congratulations!. Generally looks good, I will simplify code a little bit and then merge it.. Extended by https://github.com/JetBrains/kotlin/commit/c5c0cbccde1e53a651b6a2815129f4075e77eb96 (see commit message). . Merged \ud83d\udc4d manually. Yes, it really would be great to migrate arguments. However, PR can be accepted as is and enhanced later. Thank you!. @DeFuex You should generate tests using \"Generate All Tests\" and then run generated tests to be sure that your code works correctly. . @DeFuex Excuse me please, I have to close this PR without accepting because of just too many problems inside. If you wish to continue working under it, please squash all your commits and try to fix all problems I will try to enumerate here (and then create a new PR).\n\ndon't forget to generate and run tests (use \"Generate All Tests\" run configuration)\npay attention to IDE warning (condition is always true, potential memory leak in quick-fix, etc), you should not have them remaining in your code\ndon't leave TODO in your code. This task is not so complex to leave some parts for future\nlarge if / else in your visitor contains code which is mostly duplicating\nlook at ConvertTryFinallyToUseCallIntention which solves similar task, may be some code could be reused\nyour comparison of descriptor name with Closeable don't probably work, you should use qualified name here\nall your tests are very strange. Where do you see any resources inside them? Why in this situations we should use this syntax with use? Please use real resources, like BufferedWriter for example, in tests\nuse highlight type GENERIC_ERROR_OR_WARNING, not UNUSED_SYMBOL\nthink carefully about inspection & fix message, they should be clear for user\nand so...\n. Merged, thank you!. I approved changes however I still consider the inspection itself as very questionable. For example, I'm almost sure that we will have tons of warnings from this inspection in Kotlin project itself. Also: in case when inspection is explicitly downgraded to INFORMATION level, in IDE we have two actions \"add name to call argument\", and to remove this probably AddNameToCallArgument should be just converted to an inspection (with INFORMATION level or not depending on exact situation), and this inspection should be removed.. Finally merged this (manually).. Thank you, merged.. Good job!. Looks good, I will merge it, thank you.. Looks good, thank you :). Looks good, thank you. I think (not exactly sure) that existing local quick fix and intention can be just re-used here, without modifying their source code. You can try to do this yourself, or I will think about it more attentively later.. I think it should be accepted now.. Merged \ud83d\udc4d and then modified a bit. Thank you, good work :). @t-kameyama I accepted it but you handled only the second part of the issue (about effective visibility). The first part is still intact (finalize is marked as unused).. Thank you, merged \ud83d\udc4d . I still do not see generated tests. Please generate tests and run them.. Each inspection should also have HTML-description. You can look at this https://github.com/JetBrains/kotlin/commit/7b43d5c97255b132ef579d25c9f0e55776f9f452#diff-53469d7f3cdcbbaebd0c4ad9d7894de9 as the example.. Also, there is already ConvertTryFinallyToUseCallIntention which performs similar transformation but assumes there is try...finally and resource.close() is performed inside finally. May be some parts of code could be reused.. Good work, thank you \ud83d\udc4d . I think it's Ok, thank you. Will merge now.. Merged manually. Merged, thank you \ud83d\udc4d . Great, thank you!. Merged manually. Thank you.. Merged \ud83d\udc4d . Thank you :). Great work, thanks!. Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . I made a mistake about some lateinit limitations. Will fix myself.. Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged manually.. Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . @NikitaKatkov Sorry but yesterday evening we have migrated to 183 branch, and it means your PR is obsolete in its current form. Could you please make a new one with relevant bunch file state?. @NikitaKatkov Why do we need similar DispatchersTypeCheck.kt and DispatchersTypeCheck.kt.182? What did you have in mind?. @NikitaKatkov I made DispatchersTypeCheck.kt.182 empty and then merged it.. Merged \ud83d\udc4d . Merged \ud83d\udc4d . I have a vague feeling that somebody already implemented something like this in the past... Will try to find.. Got it, it was MoveIntoParenthesesIntention. But it was for callable references only, so it's not so close as I thought.. Merged \ud83d\udc4d . Merged \ud83d\udc4d . @t-kameyama Thank you, you have noticed an important mistake.. Merged manually, thank you. Merged \ud83d\udc4d . Merged manually (with minor corrections). Thank you \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . @semoro IMO now it can be accepted. The conflict arose because we've recently deleted AS31 branch.. Merged \ud83d\udc4d . I will test it a bit and merge.. Merged manually \ud83d\udc4d . Merged \ud83d\udc4d . @fg123 I think it's good enough, thank you. If we have a comment saver, why don't use it here? So I'll merge it.. @fg123 Answering your side note: you should perform Gradle import to fix your problems.. @fg123 For your future PRs, could you please run tests at least for the intention you are trying to fix? Your commit broke 17 tests, 15 of them are directly for IfThenToElvisIntention. Moreover, even the test you have added does not work \ud83d\udc4e . I think style settings in your IDE differs from default.. @fg123 At this moment it's easier for me to fix test myself (because I already fixed part of the problem). However, thank you for the PR.. Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . I approve it but ask @goodwinnk to look at this PR shortly. NB: I suspect this PR can break some other tests. @t-kameyama Which tests did you run locally?. Thank you @t-kameyama . Merged, thank you.. Merged \ud83d\udc4d . Merged, thank you!. Merged \ud83d\udc4d . Merged manually, thank you.. Super, thank you!. Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . I already fixed these tests myself.. BTW there are also five tests in \"QuickFixMultiFile\" group broken in the same way.. Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . @burakeregar Sorry, this code is very ad-hoc, I cannot accept this. In the general case we have no guarantees that generated code is correct. The problem arises here because safeDeparenthesize in the beginning drops label, you can think about a version of safeDeparenthesize that keeps labels.. Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . Merged \ud83d\udc4d . I would suggest \"KtValVarKeywordOwner\" instead\n. Usually = text is in use here.\n. What happens if we have character literal like '$x' ? Should we get \"$x\" or \"\\$x\"? I'd say the first case (without dollar escaping) is more logical, but I'd add a test for it.\n. For me it's suspicious. We can have a literal like 'Bye\\n' and expect to get \"Bye\\n\" as result, so I'd not touch these back slashes. Please add a test for such case.\n. Changing double quote to escaped double quote is logical, I think it should be left as is.\n. There is getTopmostParentOfTypes, I think it should work here\n. I'd declare it as something like private fun KtBinaryExpression.appendTo(sb: StringBuilder). And the same for the next function.\n. inspection\n. inspection\n. This intention replaces 'Math.max' calls with safe 'coerceAtLeast' ... or something like. Inspection detects, but inspection does some change.\n. Already exists in ReplaceSingleLineLetIntention. Should be extracted to some Utils file, e.g. intentions/Utils.kt.\n. I think abstract class should be extracted from this intention and the next one. Too many similar code inside\n. I think we should implement only intentions here and not inspections. Math.max(1, 2) for many cases is as good as 1.coerceAtLeast(2).\n. Moreover, the word 'safe' is not needed here. Looks like replacement is possible in any case.\n. I think these redundant calls should be highlighted as unused symbols.\n. What is it? Looks like it's not needed here :)\n. Looks like we can apply this intention for all qualified expressions, not only unsafe ones.\n. Also I think that only selectors should be highlighted. And probably, even the intention should be active on selector only (imagine that receiver is some long expression).\n. I'm not sure here what will be happened if somebody defines custom toType() function. Probably it's not too important, because it's expected that toType() has result of Type anyway.\n. There is also KtSafeQualifiedExpression like ofType?.toType(). And it seems to me that if ofType has a type of Type?, then toType() in this context is also redundant because ofType?.toType() will also have a type of Type?.\n. I think the best way here is to check it.\n. Ok, probably you're right.\n. This transformation does not look correct for me. I would expect this + 1 as a result here,\n. I think createExpressionByPattern should be better here and below. I'm trying to avoid using text, when possible.\n. Why is the first isApplication, but the second isApplicable?\n. This construction is hard to read. I'd rewrite it like\n\nwhen (...) {\n    is ... -> if (...) return false\n}\n. I'd say this condition is too strict. E.g. your intention will not work for code like\nfor (element in list) {\n    if (element in 1..4) { ... }\n}. Why do you need Any here?. This when is written in a very straight-forward way. Please, think a bit how to make it shorter. All branches are very like one another.. This is very controversial. What if expression is a String, for example?. I think it is better to replace character with character, either explicit e.g. 'z' - 1 or implicit 'y'. All of this looks too nasty and unsafe. Please use KtExpression.isUsedAsExpression from BindingContextUtils.kt to determine whether your equals result is used or not.. Should we provide some quick fix? I'd say that in simple cases with local variables or constants binary expression could be completely deleted, but in cases like foo() == bar() we should get\nfoo()\nbar()\ninstead. I'd say it's better to provide also text range here and highlight == only as unused.. Definitely should be removed. I'm not sure javac is the best possible name here. May be something like javac-wrapper?. Use {} here. Looks like this if / else is better to be moved above (just before environment definition). It's more consistent with previous code.. Check attentively that nothing is changed without use-javac option. I'd write here JavacBasedClassFinder. The current name is too close to just JavaClassFinder.. I think it's better to remove this function and add boolean flag useJavac to the next one instead. The code is mostly the same. Not to this PR but just to note: this TODO above should be handled somehow. JavacBasedClassFinder?. I think a good idea is to do also the following:\n\nconvert JavaClassFinderImpl to Kotlin (usually it's done in two separate commits, first one to rename .java to .kt without changing text, and the second one to apply J2K and fix errors if any)\nextract AbstractJavaClassFinder by the third commit, because there is a lot of common code. There is already JavaPropertyInitializerEvaluator.DO_NOTHING with the same functionality. Also, I'm not sure it's a good idea to do \"nothing\" in this implementation. Pavel Talanov should know more exactly what consequences we can get because of it.. In LazyJavaResolverCache both of them are val, why we do not want the same behaviour here?. Here we also could extract AbstractJavaResolverCache. JavacBasedSourceElement?. JavacBasedSourceElementFactory?. This function already exists (anyway you will not need it after processing the previous comment). Again, it's better not to repeat the same code. Extract some protected function from VirtualFileFinder. May be JavaCompilerWrapper?. There is keysToMap in Kotlin project itself & also associateBy in stdlib. I'm not sure it's quite important but they may be faster (one internal container instead of two) and definitely shorter.. See above. There is filterValues.. I don't quite understand the idea with this object. As I can see, it's used in contains only. Who does put it into the scope?. May be (if you need this object at all) it's better to provide some message like \"Should never be called\". . Should we do it if a class already has a super class?. Here (and for many other properties) getters are in use. Are you sure this property is read just a few times and we do not spend too much time here? As a possible alternative, you can use by lazy.. Why always false?. Again, why false?. isLastParameter && isVarArgs. May be create separate file like JavacElementUtils.kt for such things.. I'd consider removing let from this and next getter. I suppose code without it will be easier to read. Why do you need to override equals from JavacElement here?. You can extract typeMirror.toString(). In NB plugin you're using containing class at this point, but here you aren't. Are you sure it's not a mistake?. Why the second part is needed? Looks like TypeMirror for void also should be primitive? You can also consider extracting this condition as if and continue with when (t.kind).. annotations and findAnnotation are implemented in a different way in NB plugin. In NB plugin, equals & hashCode are also implemented for this class. Should we have them here?. boundMirror.let { create(it, javac) }. You'd better not to change existing tests, but to create a new test group with the same test data and your flag enabled.. Unclear. Why should you have kotlin. here and how it works without it?. I'd make this a class property, set it into false for old tests and true for new tests.. CompileKotlinAgainstJava but AbstractCompilerJavaAgainstKotlin? Looks very strange. I think this test group should be auto-generated, as well as CompileJavaAgainstKotlinTestGenerated. To do it, you should change GenerateTests.kt. Of course, these two groups should use different test data (e.g. from neighbor directories). With your current state, your new tests will pass but the old tests will fail.. Here you also should create your own separate test, and leave the old one as is. . Is it true for interfaces? They are abstract without a modifier. I'm not sure should we return abstract = true for them, but probably yes.. Why?. What do you want to find in the empty list (see above)?. Again, do we need it if super class is given explicitly?. Here you're using by lazy instead of get. Why here, and why just here?. May be throw an exception here? We should not achieve this point. Don't quite understand this branch. Do you have some example?. May be it should be sealed. Is it true we have some stub cache here? If yes, consider creating some class / object and integrate both stubs and createStubClassifier inside. I do not like mutable global properties, even private.. containingClass.isInterface || tree.modifiers.isStatic. Probably false if class is nested in interface (see JCField). Probably false if class is nested in interface (see JCField). Constructor never can be static. Also it never can be overridable. Not sure should it be considered as final or not.. Constructor never can be abstract. This can be extracted into JCMember. This can be extracted into JCMember. Non-static methods in interface are abstract by default. However in Java 1.8+ they are not abstract if default modifier exists. Here we have complex logic, so be accurate, please.. I think interface methods are never final. Consider making it an initializer and remove getter. Value parameter in Java can have annotations. Again, what do you want to find in the empty list?. I think this should be dropped. As was said today, similar actions must be done for two previous branches. And this code should also be performed for previous branches. This return null is unnecessary. Here you can use mapNotNullTo without toSet at the end, it may be a bit faster. It would be better to avoid toString() call here, if possible. Does this typeMirror have something like name or fqName?. What about interface member classes? (they're always static as I know). What about interface member classes? (they're always public as I know). What about interface members? (not sure it's important). Not needed. Things are not so easy here. First of all, there is KtDeclaration.implicitModality(), please use it. For example, interface functions with body are implicitly open and do not require explicit open modifier. Also, you need containingClassOrObject and not getNonStrictParentOfType<KtClass>, you are risking to miss e.g. companion object in the middle this way. Remember also that object / interface members should never have open added, as well as top-level guys. And at last, class can have open members if it's open, abstract or sealed itself, I'd not limit it to just open classes as described in an issue. . Also, element can easily be KtClassOrObject, please consider this case. The easiest way here is to limit this intention only to properties and functions, this way you need KtCallableDeclaration. Remember also nice cases like KtParameter or KtDestructuringDeclarationEntry, both of them should never be open.. This question looks still actual. Here we have kotlin. added too. And here we have kotlin. too. It's better to write here\n\n(outerClass?.isInterface ?: false) || tree.modifiers.isStatic. Are you sure this list should be empty? In JavaTypeImpl it's not so. May be it's not the best name. For me it's more or less obvious, that JCClassifierTypeWithTypeArgument is an inheritor of JCClassifierType, but in fact it's not so. I'd change one of these two names.. May be we should name it like StubJavaResolverCache. The thing here is obviously not javac based.. This string must be removed due to licensing problems. Why does this test have so strange name? I see no invoke here, either safe or unsafe. Looks like not-deleted trash. I'll remove it.. I thinks it's more precise just to check here that getDeclarations() isn't empty, instead of doing these operations with nextLeaf.. any { it == descriptor } is equivalent to just contains(descriptor). FYI: in Kotlin project if...else is formatted in a different way:\nif () {\n}\nelse {\n}. No, I don't know a better way, and yes, LBRACE check is still needed. . At least one or two tests required here. You can check the case when a is nullable extension property. Also, you can modify last check to a?.a?.a != null.. Well, it's an exceptional case but here we can also do something :). If a condition in when branch is definitely true, we can replace the condition with else and delete all subsequent branches because they are unreachable anyway. If the condition is definitely false (add test for this case), we can delete this when branch.. There is already getParentOfType, please use it here. I recommend never delete the whole when. For your examples, we should get\n```\n// false condition\nwhen (1) {\n}\n// true condition\nwhen (1) {\n    else -> print()\n}\n```\nI don't think it's something dangerous because user can always undo the optimization.\nKeep in mind also when without subject case. Here we can just replace conditions into true and false, as for simple conditions.. You should not delete all entries here, but only subsequent ones. E.g.\nval something: Base = ...\nwhen (something) {\n    is Derived -> forDerived()\n    is Base /* always true */ -> forBase()\n    is Any /* unreachable */ -> forAny()\n    is SomethingWrong /* also unreachable */ forWrong()\n    else -> forElse()\n}\nHere is Base branch must be left intact.. Not a good name, may be it's better to leave it as before. This action is applicable also for when without subject, or just for code like val a = b is Any.. It's also not the best way, you can meet something like\nMath.max(max(1, 3), max(2, 4))\nand will have the same problem. Will fix it myself.. Suppose getQualifiedExpressionForSelectorOrThis() should be better here. For future: use here GENERIC_ERROR_OR_WARNING if you want to get highlight type depending on inspection severity level (by default, from plugin.xml, or configured by user). Explicitly given WEAK_WARNING enforces this severiry level making it unconfigurable by user (will fix myself).. Should work without this line, at least in theory. Will check it myself.. Really works (add abstract also removes other modality modifiers, if any). It's better to use here expressions and not their text. I should mention that overridden function is not redundant if it has some other modifiers. For example, sometimes is reasonable to add final here, so function itself is not changed, but derived classes are made unable to override it. Also, I think that any annotation here makes the function not redundant. The same for any visibility modifier when you make overridden function more visible then original one. Please consider these cases, fix inspection, and add tests for them.. It's not so easy, because protected should not be offered if member is referenced not from a subclass. Please add necessary checks here and such a test.. It's matter of taste but I'd use here some enum with three elements. Unclear place. First, why TYPE_MISMATCH? In this context, x should probably have Nothing type. Second, UNREACHABLE_CODE is expected here. Third, I don't quite understand why it appears after introduction of language features (the last but one commit).. Also, I suspect we require also the third feature, something like \"value analysis in conditions\". I have in mind checks like if (1 == 2).. This line appears in the last but one commit, when the language features were added. It's quite unclear for me, why it appears in this commit.. In this function we have some strange combination of getResultDataFlowInfo and checkAndRecordDefiniteInvocations. I think some refactoring is needed here.. Can we annotate also both TODO functions?. I'd try to avoid repeated access to bindingTrace here.. For me this place is not very clear, check it with @erokhins . This test has no annotation of some language feature on. Looks strange. I'd check all new tests, and most probably all of them should have some annotation. Otherwise backward compatibility can be broken. Related to some other tests. Can we annotate also error below?. Should we throw here IllegalStateException?. I'd expect here some language feature check.. Also, I recommend to extract some variables from two these very similar calls.. And don't forget about PatternMatchingTypingVisitor!. I didn't notice any use of this annotation (may be I missed something). Also, may be it's better to move this interface to effects package, to be together with all three derived effects.. Why do we need this unconditionalClause? As far as I understand it's interpreted as \"if effect takes place then true is true\", and this statement is always true.. May be it's better to move this into functors package. Fully qualified names for some reason. I don't like this null because its meaning is unclear. It's better to introduce thing like ESFalseClause.. Just to ask: how does it work with different kinds of comparisons (==, ===)?. BTW this guy is not in use now. Not quite sure should reference comparison be here.. E.g. how does it work with strings? Or nullable primitives?. Looks like this arrow has the wrong direction. As we have discussed, logically this conclusion is erroneous. I strongly recommend to fix this, because you can create true clause condition in some other context thus getting really wrong conclusion. This name contradicts with real semantics. May be it's better to return here just lists of conditions, not lists of clauses. Then you can accept list of conditions in foldConditionsWithOr.. Ugly construction. Are you sure it's really needed?. Not quite sure this wrapper is needed. Can DataFlowValue itself serve you here?. I recommend some self-describing name for this label. Remove me. Formatting. OK, understood. No, I think it can be done in either way. But please check your logic for statements like if (1 == 2) { ... } does not work in 1.1.. This and previous can be written in one line. I'd inline this function. isNotEmpty() ?. This can be rewritten shorter using e.g. none. Also, seems to me this logic works incorrectly if arguments are replaced.. It's not the correct way. KtThrowException is not the only one that has Nothing type, e.g. null!! has the same type. You should check bodyExpression type directly.. All this else branch together with examples looks very dangerous to me. Looks like these actions change function semantics so I'd not recommend to perform them. I'd prefer to use this quick-fix only if type parameter exists.. Just expression is better here than expression.text. Also, I suppose you may need to take expression into brackets sometimes. E.g. for a call like functionOnList(a + b).. I'd prefer here Make 'name' data class. When some of these val / vars is invisible (e.g. private and we're outside of the class), this fix is not applicable. I recommend to analyze constructor parameters and modality using descriptor and not PSI. You can convert descriptor to PSI just before quick-fix creation. Also, data class cannot have vararg parameters.. Full example. A bit exotic but quite possible:\nfun foo(a: List<String>, b: List<String>) {\n    bar(a + b) // expected: bar((a + b).toTypedArray()), got erroneous bar(a + b.toTypedArray())\n}\nfun bar(a: Array<String>) {}. if (modality != Modality.FINAL) .... This code should be also rewritten using descriptors.. I think there is a reason to improve this case for secondary constructors. Inside them, var is not required if property does not have its own initializer and is not declared in primary constructor. Code like foo = foo is high probable in this case.. Please consider the case with ambiguous this, e.g. with (...) { ... }. NB: this case is relatively rare, so if it appears to be too hard to solve it correctly, leave it as is (may be I think about it myself).. I don't understand how == works here, because we have PSI on one side and descriptor on the other side. Here it's also not clear why super interfaces only and not the super class. Got it! It works in your test just because both lists are empty.. It's better to convert this intention to local quick-fix, because effectively it's a quick-fix and not an intention. You can look at some other inspection, like RedundantGetterInspection for example.. It's not enough. Class can also have secondary constructors. I would require no constructors with parameters in a class, either primary or secondary.. In contrast, I think this check is too complex. It's enough to check that class has final modality.. Please do not set cleanupTool = true if you are not absolutely sure that your inspection should be included into \"Code Cleanup\" action.. You do not check that expression is an assignment. Expressions like list[i] = list[i] also can be highlighted by this inspection. Also it is invoked for x = other.x. It's better to use here tests from inspectionsLocal directory (LocalInspectionsTestGenerated).. Please, do not mark everything as cleanupTool=true. And here, CleanupLocalInspectionTool is also not needed. I'd check it from the beginning to avoid more expensive unnecessary checks. Sorry, I missed your message. You can use QuickFixMultiFileTestGenerated.. Don't quite understand why only RANGE is allowed here. Please consider other binary operators. It seems to me (may be I miss something) that it should be allowed for most of them.. It's Ok but I don't like that we now invoke references search twice, it can affect performance. I'd consider here to do this only for particular case with JvmName. Will fix myself.. Please avoid commiting changes in all configuration files without a reason. This file is intentionally deleted from repo. Please do not add it back. Please avoid commiting changes in all configuration files without a reason. Please avoid commiting changes in all configuration files without a reason. This file also should not be in repo. Avoid such formatting changes. They have nothing to do with the feature you are trying to implement. I'd probably move all of this down, to different when-related nodes. Same: please avoid such \"random\" formatting changes. Same. You have here mixed formatting / non-formatting changes, and it makes search of changes to review much harder. Ok, let it be soft keyword at the moment. Exact syntax and status of this thing is up to serious discussion. Is it necessary?. When possible, it's better to report simple errors (from Errors.java) and not parsing errors. I think it's not a problem to parse different match patterns separated by a comma, and report an error later in front-end.. Avoid such commented blocks. There is nothing good in having them in code. Rewrite this loop to avoid double AT check. You should not change this file. I see only codegen tests here, and this is quite bad. You should add, at least, some new parsing tests, because you modified the parser (ParsingTestGenerated), and some front-end diagnostics test, because you modified front-end analysis (DiagnosticsTestGenerated).. I don't think this class is really necessary. Don't understand this place at all. Why do you need these nulls?. Why so? Quick-fix can still be applied, but * should be preserved!. This can be converted into @Some(*[\"alpha\", \"beta\", \"omega\"]). Here you break PSI structure: KtWhenCondition must be here, not a KtExpression. Here and below, I think better report problem just on is, not on a whole expression. Don't understand why it's needed. You check for very special case here, it's not too much reason to add a new inspection for just (0, 1) case. I think c.substring(25, 26) can also be replaced with c[25]. Also, c.substring(n, n+1) can be replaced with c[n].. Try to rewrite this. First, it's too complex, and second, you are using !! in getArgumentExpression which can result in an exception. Why do you consider just this case? What if we have (e.g.) KtSafeQualifiedExpression instead?. I'd say any KtExpression at next level should work here.. This check is too wide. Imagine something like\nreturn listOf(0, 1).find { true }\nYour intention will be not applicable here due to return some levels above.. May be it's better to start from block here. Why this case with Unit result is important? Why can't we write something like\n1.let {\n    return@let Unit\n}. Anyway, test should be created for this case. What if the lambda is labeled? E.g.\nlistOf(1, 2).find label@{\n        true\n    }. Here the case with labeled lambda (see above) also should be considered.. Not sure it's good to call isApplicableTo on any KtExpression. I'd consider deriving from SelfTargetingRangeIntention  and using something like KtLambdaExpression as a base type.. Much better to have safe cast (as?) here, otherwise you can get CCE in strange cases like x.substring(\"alpha\"). Of course they are erroneous, but it's quite possible user write them during editing. Will fix myself. No! Why so? Why setter with empty block can be redundant, either for overridden property or not?. Try to avoid such constructions in future, they are too complex to understand something. Why should this diagnostic be moved?. What's the difference between this syntax and just !is Child2?. Strange diagnostics here. And here too (USELESS_IS_CHECK). Changing PSI for existing files can be dangerous. For example, some IDE actions may cease to operate after it. We should either consider keeping PSI for old code or check attentively that IDE tests (like IntentionTestGenerated, InspectionTestGenerated, LocalInspectionTestGenerated, QuickFixTestGenerated) still pass.. Don't quite understand why this is needed. If you write a design document, please mention this moment there.. @shiraji You can try KtExpression.isUsedAsExpression to control whether this 1 is really lambda result or not. In the second case, isUsedAsExpression should return false.. Don't forget about this point please. from last expression. Please use GENERIC_ERROR_OR_WARNING here, otherwise highlight level is not configurable by user. You have already set default INFORMATION level in plugin.xml.. You should use KtDeclaration.getModalityFromDescriptor() to get declaration modality (open / final / sealed / abstract). There are such nasty things as all-open plugin, which can modify modality got from PSI. Also, this function processes some cases you forgot here, for example, abstract or sealed classes which are also non-final.. There is already factory.createObject. You should also delete all secondary constructors, if any.. Here please use addModifier(FINAL_KEYWORD) directly on KtClass. This function includes necessary logic to delete incompatible modifiers (like open, abstract or sealed) and not to add redundant modifiers (like final in most cases).. There are some more rules that should be either considered here (to remove suggestions for these cases, it's easier) or processed inside fix (to convert them to object correctly). In particular: 1) Class, but not object, may have companion object(s) inside; 2) Class, but not object, may have inner class(es) inside.. It's probably correct, but we should add some tests for: 1) Callable reference usages like MyClass::myFunction or MyClass()::myFunction; 2) Nested class usages liked MyClass::NestedClass() or MyClass()::NestedClass().. You should use KtDeclaration.getModalityFromDescriptor() to get declaration modality (see detailed comment below). Probably distinct() is better here. I don't like an idea to change front-end code in this commit: as result we get an additional parameter used only from IDE code. I think it's better to call getActualTargetList from fix (make it public for this), and then take necessary targets from this list (effectively inlining your function here). As alternative idea, you can write separate function in IDE for a case with all = true.. if (target !in actualTargetList). Really inspection is enough here. Since IDEA 2016.3, we have INFORMATION level for inspection (= No highlighting, only fix), so separate intentions are not necessary in this situation.. Not quite sure but I'd prefer INFORMATION level here. I think these two kinds of syntax are more or less equivalent. May be to looks a bit nicer, but not in every case.. Please move declaration of this getCallableDescriptor to Utils file. It's normal place for such functions, if they have multiple use-sites.. This is suspicious place for me. Could you please explain why ValueParameterDescriptor, and only this descriptor, should be handled separately here?. LIKE_UNUSED_SYMBOL should be better here. Redundant constructs should be better here. I'd upgrade it to WARNING. Please check also the following case: \nval obj = C.Companion // PROBLEM: none. Should be Ok. I'll check whether descriptor can be just replaced with getCallableDescriptor() here.. I suspect it should be done other way. First of all, it's quite unclear why only constructors should be handled here, and why only case with one value parameter should be considered. And second, there is MoveLambdaOutsideParenthesesIntention which solves the same task. Probably the best we can do here is to convert it to the inspection using AbstractApplicabilityBasedInspection. I checked, and intention works in your case too.. I think we should report it on value argument and not on the whole call expression.. It should be not just \"some\" parameter, but this lambda parameter. See this fixing commit: https://github.com/JetBrains/kotlin/commit/b739db3c3573fb24daf1e97c42746d617dea4692. . It's not enough. Both declarations must be either top-level or class inside super-class (the last case is covered by isVisible). Otherwise you cannot inherit sealed class.. I fix it myself. The same is true for local classes / objects. I'd rephrase this a little bit, like \"a main function with incorrect return type (should be Unit)\" or something like.. Please perform some PSI-based check before (e.g. compare function name with main). Converting to descriptor in the very first line of inspection can be performance consuming.. Should be probably not applicable to documentation comments:\n/**\n * ...\n */. What about '\\t'? Of course it's rare case but it's possible. it's enough to check that beginning of comment is /**. Here tabulation is also possible. Please check how this and other intention work with situation like below (multiple new-lines between comment and declaration).\n```\n/ \n   block comment \n/\nfun foo() {}\n``. Just for safety, I'd useas?instead ofashere. Also, some test should be provided. Please look atidea/testData/inspectionsLocal/replaceWithOperatorAssignmentfor examples. You should use \"Generate All Tests\" run configuration to regenerate automatic tests (LocalInspectionTestGeneratedin our case). . Also I recommend to run other local inspection tests to be sure that nothing is broken. It's quite possible here that labeled return expression is making return *not* from this function literal, but e.g. from the outer one. You can usegetTargetFunctionDescriptorto determine it.. Here it's much better to useCallableBuilderfromKtPsiFactorythan build function directly by text. . I think that it's enough to findKtValueArgumentparent here, becauseKtLambdaArgumentis a subclass of it. An I wrong?. Why this check is important?. For future PRs: we have now \"branch\" filesplugin.xml.172etc. that also should be modified if you are modifyingplugin.xml.. You are right aboutin`, but we can also have problems when no variance is stated. E.g.\nfun bar(arr: Array<String>) {\n    arr[0] = \"\" // arr cannot be made vararg here\n}\nWith out variance, this assignment is not possible, but with no variance, we have to check function body for a possible assignment to array elements :(. Here and below, please select vararg with bold.. Probably getPrimitiveArrayElementType from built-ins should work here.. I think that for performance reasons it's not a good idea to implement such a check. So I suggest to change intention message in case no variance is stated, adding something like (may break code) at the end.. This test does not test your change yet. You should add comment above (to both this file and after file):\n// FIX: expected fix text\nto check that fix text is correct.. It seems to me these checks are not relevant here already (we can return null without them). Will recheck it and fix if necessary.. Another example you've probably missed:\n```\nfun returnFun2(i: Int): (() -> Unit) -> Unit = {}\nfun test22() {\n    returnFun2(1)() {}\n}\n``. What if ILLEGAL_ESCAPE is reported inside string literal?. I will consider this case separately. What about case like below? Here we still cannot deleteCompanion`, but your check does not work here.\nclass My {\n    val name = \"My name\"\n    val greeting = \"Hello \" + Companion.name\n    companion object {\n        val name = \"Your name\"\n    }\n}. Here we can build same example as for properties above. I think one example may be not enough here. At least, it would be good to test comment preserving for all three when branches above.. I'd suggest to report \"JUnit test should return Unit\" or \"Test function should return Unit\" or something like. \"test should return Unit\" looks not very pretty. Please add // PROBLEM: <problem text> to one test with JUnit function and one test with main function. Please look at the following line in QuickFixRegistrar:\nPROPERTY_INITIALIZER_IN_INTERFACE.registerFactory(RemovePartsFromPropertyFix, ConvertPropertyInitializerToGetterIntention)\nAs I can see we are able to use intention as quick fix, and should not provide a wrapper. Try to do the same here. What if this companion object belongs to some other class, not to the class we are inside? Please add test for this case and fix it if necessary.. It's definitely not the fastest way to find the compatible transformation, if any. You have O(n) in your solution, but you can easily get O(1) instead.. Looks nice but it's a bit unusual to see such things in source code. My first reaction on call in transformations was \"it's just a mistake, because types are incompatible\". Well, it's not a mistake, but it takes time to understand. See also previous comment.. I'm not quite sure about this code. First of all, the replaceReference is required to be calculated only in one branch, see the only usage. Second, I'd rename let parameter here, otherwise it's difficult to understand the code. And at last, this search among KtNameReferenceExpressions looks suspicious. Too many of them can exist in general case and I suspect (may be I'm wrong) this can give false positives.. I'd add at least one test with regular (non-redundant) let and more tests with redundant let, e.g. a?.let { foo(it) } and may be something else.. Before it, I'd obtain a descriptor for forEach call and make sure that it's forEach from standard library, defined either in kotlin.collections or kotlin.sequences. Otherwise we have a risk of reporting this inspection on wrong call (some user-defined forEach).. It's better to highlight just forEach name and not the whole lambda.. I'd add some tests with nested forEach, to make sure we handle correctly situations with multiple it.. What if we have a comment between type reference and = defaultValue, like this: a: Int /* very important */ = 42?. What if we have already it in name scope. Is it possible to get a name conflict and/or semantic change?. Nested its are very hard to read here.. And I'd extract the whole condition (beginning from baseClause as?) into a function and simplify it a bit, for example to avoid safe call chains and let. I'm not quite sure about performance here. First, looks like constructor.supertypes will return you all supertypes, not just immediate ones, so this recursion proceeds some supertypes more than once. Second, even checking of all supertypes once can be performance-consuming for deep hierarchies. May be (just as idea) it's better to check name first (either it contains Map or not). This can give us false negatives, but I think it's better than to check all types in hierarchies are they subtype of Map or not.. There are properties which can have getter but cannot have initializer, e.g. interface properties. Please add extra check and tests for these cases.. Please check how comments are handled here.. It's better to make assertions property of a companion object.. Take assertion in quotes here please, like Replace with 'assertEquals'. I'd implement this as a map from pair of <oldName, operationToken> to newName.. @udalov Thank you for clarification!. This check (isUnitTestMode) is suspicious and it would be good to remove it. See also my comment to related test. For multi-platform testing, we have a specific group of tests. In your case, multiModuleQuickFix group should work properly (it should work for intentions too). This should also solve your problem with target platform detection.. Most inspection classes have Inspection suffix. Please add it.. For performance reasons, it's a bad idea to get descriptor at the very first line. Here I recommend to check name first via PSI, and only after it check name via descriptors.. Also, space is required after when keyword (code style requirements). Here you have to add // WITH_RUNTIME line, otherwise all your tests fail. In the future, please re-run your own tests before re-submitting PR.. (comment: this line adds full Kotlin SDK to test project, without it forEach function is not visible).. I don't like this description. It says nothing to normal user. I think we should say something about list under the hood, at least.. I think we need more detailed explanation here.. This description is bad for the same reasons as above.. I'd consider other fixes, like \"change type to mutable list\". Just as an idea: why don't fix it by changing var to val?. I'd say here we should fix KtDeclaration.implicitVisibility() itself and not insert some work-arounds just here.. I don't like the name here (because it associates directly with IDEA registerProblem). Something like getFixesAndRegisterProblem or collectFixesAndRegisterProblem would be better here.. I'd extract this and previous function to companion object, if possible. Also I don't like this name too. Something like applySingleFixIfAny or applyFixIfSingle would be better.. Please add also test with explicitly given Float or Double types, like this: fun test(a: Double, b: Double) = ..., and another test with Double or Float literals, like fun checkPi(x: Double) = x.equals(3.14) // or 3.14.equals(x). This implementation is very strange. You focus here on a given example, but there are some simpler cases which probably will not be detected by this implementation correctly. I'd suggest you should find (via resolveToCall()) type of equals receiver and type of equals argument, and in case at least one of them is FP type (Float or Double) and another of them is numeric type (FP or Byte, Short, Int, Long), the function should return true, otherwise false.. Here we should not just drop a suggestion. It should be kept, but its highlight type should be changed to INFORMATION, and its fix text changed to Replace total order equality with IEEE 754 equality.. (See related functions above). It seems to me that five lines above are encountered in our code more than once (see SimplifiableCallChain for example, and may be your inspection about asSequence too). I think we should extract them into an utility function. You can do it yourself, if you want, or leave it to me.. Not quite sure is it really important. Could you explain why did you insert this check?. What do you think about other assignment operators, like PLUSEQ? I'm not sure exactly but think that with them we should report this. . There is anyDescendantOfType, use it here please.. There is KtTokens.AS_SAFE, please use it instead of raw text. Please use KtTokens.ELVIS. I suggest it should be INFORMATION by default. Here I'd prefer just \"Style issues\". Don't report it as unused symbol, otherwise it looks like the whole else block is redundant which is not true.. I don't like this piece of code. Are you sure it's required here? Please explain why.. The priority of annotation without use-site application is value parameter (the highest), property, field (the lowest) for constructor parameter property. For regular property it is property (the highest), field (the lowest). So, if some annotation is not applicable to value parameter (VALUE_PARAMETER target is not included), then we should not add use-site while moving to constructor because it will be redundant (priority queue will be the same). And only in case VALUE_PARAMETER target is included we should do all this checks you have done here. . I think this parameter should be always true (yes, even for IfThenToElvisInspection), so it's not required.. This piece of code will be dropped (see comment above).. I think something like \"Property setter does not influence its getter result\". \"Probable bugs\". It's only one case when they are the same. The important thing here that getter should not reference backing field.. Take from inspection description. ...) + (.... Add braces. Please add tests for getter which references backing field (no warning) and does not reference it (warning).. Suggestion from Lilia: (applicable also to Multiplatform Library sample): it would be nice to detect which Native target may be actually built on the given host and uncomment the corresponding target in the build.gradle file instead of leaving iOS by default. If you know how to implement such logic, please do it here, otherwise I will think about it myself (and fix later both this wizard and library wizard in case of success). You should (probably) change also gradle.xml.181, otherwise your wizard will not bee seen in IDEA 181 or earlier versions.. I'm not sure how valid is the hack related to this property. Hope @asedunov will tell something about it.. May be it's a good idea to add also a line about iosX64. What about internal visibility?. I'd say it's not the best way to fix it. It's more correct to have all necessary checks inside canBePrivate and canBeInternal (which does not yet exist). Take into account the fact that both ChangeVisibilityFix and ChangeVisibilityModifierIntention use canBePrivate (and should probably share the same logic). Also I'd recommend to consider content of canBePrivate inside MemberVisibilityCanBePrivateInspection (private fun). I suspect that some checks from there (not all) could be used inside global canBePrivate (that can also fix a bunch of minor bugs, not reported yet).. I'd say it's not the best way to fix it. It's more correct to have all necessary checks inside canBePrivate and canBeInternal (which does not yet exist). Take into account the fact that both ChangeVisibilityFix and ChangeVisibilityModifierIntention use canBePrivate (and should probably share the same logic). Also I'd recommend to consider content of canBePrivate inside MemberVisibilityCanBePrivateInspection (private fun). I suspect that some checks from there (not all) could be used inside global canBePrivate (that can also fix a bunch of minor bugs, not reported yet).. Not quite sure adding TODO() is a good idea here (because removing it can be also not easy enough). I'd agree with the suggestion from an issue comment: \"generate \"else -> \" and put the caret after it (do not forget space after the arrow: \"-> \"!)\". Please add a test with label before lambda: \nc.mapNotNull label@{\n    return@label \"\"\n}. You should probably use bodyExpression.forEachDescendantOfType<KtReturnExpression>, otherwise you can miss multiple return descendants of the same statement. This name does not correspond to the executed actions. I'd suggest a name like renameGivenReturnLabels and also rename calleeName to labelName.. I'd change name to something like \"Existing backing field is not assigned by the setter\" or \"Setter for a property with backing field should assign backing field\". Choose what you think is better, or suggest your own name (current name is grammatically incorrect).. It's not a redundant construct, it's much more likely to be in \"Probable bugs\".. You forget the most important check here. The property should have backing field for this inspection to be reported. Property may have no backing field at all, and in this case it's ok when its setter does not access backing field. Please add also relevant tests.. I think we should remove first \"Collection\": \"Augmented assignment creates ...\". Do not highlight it as unused symbol, it's not \"unused\". Generic error or warning is Ok here. This range is too wide, I think it's enough to highlight operation reference (+=, -=). May be it's better to extract this list to a class field. This fix works strangely because it breaks code. May be it's not needed at all, or we should immediately assign this variable to the relevant list.. For -=, we may also suggest filtering the original list:\nlist -= otherList\nis equivalent to\nlist = list.filter { it !in otherList }. We may suggest also the following:\nvar list = emptyList<...>()\n...\nlist += otherList\nto\nvar list = emptyList<...>()\n...\nlist = otherList. And the following:\nvar list = createSomeList()\nlist += otherList\nto\nvar list = createSomeList() + otherList. Why you did not want just to remove groupingBy from termination list, is there some reason I do not see?. This check looks dangerous for me. The check like if (receiverType?.isIterable() != true) return null would be much more consistent and safe here (so we convert iterables only).. There is BindingContext.BACKING_FIELD_REQUIRED, please use it and not a raw text check. Ok, I will add this as an additional test and probably create listOf(\"groupingBy\") as a list of some \"lazy terminators\".. Looks like it's a hard question and a hard task. I will implement this piece myself. There is BindingContext.BACKING_FIELD_REQUIRED, please use it and not a raw text check. No, you should not create any new compiler diagnostics, you should just modify intention AddBracesIntention. Also you should not create new quick-fixes here. And yes, you should add tests to this pull request. You need to create some files in idea\\testData\\intentions\\<YourIntention> (look at existing examples please), then run \"Generate All Tests\" and then run IntentionTestGenerated to check your tests are passing. Please add tests to this pull request.. Yes, because this property foo really has backing field (it will disappear if you remove initializer and write custom setter). Why you do not like it?. Yes, understood. So you should  both check BACKING_FIELD_REQUIRED and check we do not reference it in getter. Ok.. I would consider also the case like \"$bar(1, 2) sometext\". No tests are inside. Please add them. You could use LocalInspectionTestGenerated test group, see idea/testData/inspectionsLocal. Looks like not used. Please convert it to a parameter of restore, with default value. Don't introduce additional class state when it's not required. Please use named argument syntax for boolean arguments. I think separate allElements aren't required, because anyway you perform additional filtering for sibling.. After merge of KT-23512, this requires some rewriting.. Your manual sorting method has estimated performance of O(N^3) because of this removeAt, and this could slow everything down.. There is already AddNameToArgumentFix. Why didn't use it?. I confess I'm not sure about default level it should have. Will discuss it with my colleagues.. Why you do not want to use IntentionWrapper here?. This logic looks as good idea. May be, in this case we can really left INFO level for the inspection itself.. May be we should extract this fragment to some local function, to avoid code duplication? What do you think, @t-kameyama ?. This fix has a problem: it works incorrectly with long block of statements in else, shifting one tab back only first of them and keeping indent of all other statements. If you like, you can download custom plugin from here: https://teamcity.jetbrains.com/viewLog.html?buildId=1749508&buildTypeId=Kotlin_dev_CompilerAllPlugins&tab=artifacts (beware, after some days artifacts will perish) and test the fix just on Kotlin project (I ran the inspection on just idea module and applied all fixes automatically).. Looks like it does not work as you want, see my title comment.. Why this Elvis is necessary here? It looks very strange.. Please change it to GENERIC_ERROR_OR_WARNING, otherwise users will not be able to change inspection level manually.. Please check highlighting range here when inspection's level is increased manually. Too wide highlighting range is bad. I think here we should highlight just isEmpty reference, not the whole !someVeryImportantList.isEmpty(). Why we cannot just check functionType.receiver != null?. Please make sure this cannot be applied to local variables. And also to top-level properties. Also, I would recommend to read LateinitModifierApplicabilityChecker and re-check that we do not suggest conversion to lateinit in other situations when it's not applicable.. For example, lateinit is not allowed on primitive types, on unsigned types, etc.. I mean here \"get file to generate declaration inside\". May be it's wrong, will recheck. \ud83d\udc4d . There is no mistake here, it's rare but possible case. I suspect it was provoked by some real case (don't remember exactly, almost two years have passed), so I will keep it.. \ud83d\udc4d . D is its original type. Sorry, it doesn't work, addDeclaration has reified type parameter,. I just don't exactly know the difference :). Mostly I use just DescriptorToSourceUtils.. I gave function different name (findExistingFileToCreateDeclaration) to avoid misunderstanding. Here we can have problems with default parameters. I think it's better to simplify this part and check just by name.. > > Please make sure this cannot be applied to local variables\n\nActually, you can have lateinit local variables as long as they're not of primitive types and it'd be weird not to have the intention in this case.\n\nThanks, it's true from version 1.2. Could we also handle the case when enum entry is imported? E.g.\n```\nimport test.A.* // enum A { X, Y }\nfun foo() {\n    if (X == Y) { ... }\n}\n``. It's correct, because for entries of different enum classes we have the compiler warningINCOMPATIBLE_ENUM_COMPARISON. I suppose this check covers only one particular case. See also test comment below.. What if we writeC(3, 4)here? Suppose thisC(3, 4)will be changed toC(3, 2), which is not correct.. Here and below, I suppose you should compare the result ofshowYesNoDialogwithMessages.YES, not withMessages.OK. According toshowYesNoDialogcontract, it can returnYESorNO, and never returnsOK.. I think it would be better to highlight all modifiers, not only the last one (but annotations should not be included). Just to be sure, could you please also add original example from the issue?. Good point, will change it myself.. I'm almost sure this can be done easier, without additional reference resolve. Probablytypeshould beWrappedTypefor type alias (not sure exactly).. Probably we should use hereisCallingextension we have added some time ago. I'm afraid we can break something in back-end with this change, because this function has the second use-site in back-end. Also, this change contradicts with the function name. We should keep back-end behavior here. I'd consider adding a lambda as the last function parameter, which takesgivenTypeandstableTypesas arguments and returns something likedefaultType. By default this lambda should returngivenType, but in inspection we can change its value tostableTypes.firstOrNull() ?: givenType..PARTIAL_WITH_CFAshould be enough here. Why don't you want to useisUsedAsExpressionextension here?. Not sure it's necessary here. I think it's enough just to check that property is used at all.. Consider using a heuristics to prevent resolve here: we could first check whetherExceptionorErroris a substring incalleeExpression`, and if not, just return (I'm not quite sure is it a good idea or not, decide it yourself). I have two concerns here: \n\nI would extract all four FqNames into companion object properties. \nWe call analyze on each dot qualified expression, which is slow (yes, it's slow in practice, you can try to launch this inspection on Kotlin project). isCalling could solve this problem, but unfortunately you call analyze before. It's also bad solution to remove context here. I think we should first check that callee name starts with associate and then check that function is resolved to one of four (better not via isCalling because it would repeat the same text check).\n\n. It's an intention, not an inspection. . You could use ktAnnotationEntry.analyze() to get BindingContext, and then use context[BindingContext.annotation, ktAnnotationEntry] to get AnnotationDescriptor which contains all necessary information. Of course it's much better than parse PSI text manually. Note: to do all of this, you should pass the wholy ktAnnotationEntry to quick-fix constructor, not just arguments and annotation FQ name.. Sorry for late review.. ",
    "ligee": "I'm no longer sure that we need this jar at all, since for a moment custom child-first classloading seems better solution. So, it probably disappear in the branch I'm going to offer for merging to the master.\nI can remove it from here too, if you think this is important.\n. merged into master\n. Thank you for the PR and sorry for the delay. I'll try to reproduce it first in order to check the fix, and then (if everything is ok) will merge it.\n. Unfortunately, I cannot reproduce the problem, therefore cannot check the fix. I merged it into separate branch, and build results are available at https://teamcity.jetbrains.com/viewType.html?buildTypeId=bt345&branch_Kotlin=rr%2FDanielThomas-gradle-publish-compatibility&tab=buildTypeStatusDiv\nCould you, please, take it and test whether it fixes the problem.\nIf you have any suggestions, how to reproduce it, it would be very nice. I used some simple config like:\n```\nbuildscript {\n  repositories {\n    mavenCentral()\n    maven {\n        url 'file://' + pathToKotlinPlugin\n    }\n  }\n  dependencies {\n    classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:0.1-SNAPSHOT'\n  }\n}\napply plugin: \"kotlin\"\napply plugin: 'maven-publish'\nrepositories {\n  maven {\n     url 'file://' + pathToKotlinPlugin\n  }\n  mavenCentral()\n}\ndependencies {\n    compile 'com.google.guava:guava:12.0'\n    compile  'org.jetbrains.kotlin:kotlin-stdlib:0.1-SNAPSHOT'\n}\npublishing {\n    publications {\n        maven(MavenPublication) {\n            groupId 'test'\n            artifactId 'deploy.test'\n            version '0.1'\n        }\n    }\n    repositories {\n        maven {\n            url 'file://' + pathToTestMavenRepo\n        }\n    }\n}\n```\n. application environment lifetime change breaks too many tests\n. rebased onto master\n. Rebased onto master \n. Merged into master\n. Merged into beta 3\n. It was merged into master before branching beta 3. With the message I meant that it is in the mainline since beta 3.\n. There is is another solution - find out how to properly detect testing mode in our ApplicationEnvironment and dispose stuff in tests using that detection. But it seems require much more effort from my side, since I'm not familiar with that part, and much more testing as well, since it may affect many parts. So I'd prefer if this solution will be accepted for now.\nWill it look good enough if I'll implement storing and restoring the value of the property on setup and shutdown respectively, as proposed by Michael Nedzelsky?\n. > >  find out how to properly detect testing mode in our ApplicationEnvironment\n\nApplicationManager.getApplication().isUnitTestMode()?\n\nThis is how it is implemented now (MockApplication.java:85):\njava\n public boolean isUnitTestMode() {\n   return true;\n }\n. The build lib (build-common) parts are merged into master, after some rework by bashor, the rest (gradle plugin changes) will be extracted into separate branch\n. @cypressious I think you should remove snappy from classpath now and rebuild kotlin (starting from ant part)\n. @cypressious the issue is not known, at least to me. Is it related to incremental compilation? Anyway, please file it.\n. @cypressious yes, please. just mention the branch in the issue\n. The most parts from this PR is already merged into kotlin long time ago.\nThe most important omission is dealing with readers/writers in JSR-223, should be handled separately https://youtrack.jetbrains.com/issue/KT-29501. @khud it seems that passing our internal KotlinType class to the REPL API is not a good idea. Could you, please, change it so the ValueResult contains a string with type instead. \n@udalov please, provide an example, how to render the type into a string properly.. @khud Thank you for the PR. I cleaned up unused imports, squashed commits into the single one and merged into the master. (https://github.com/JetBrains/kotlin/commit/d165ea9ea75d9a4ee278db16b8257b56e83cb528). The PR itself is obsolete, but the comments are useful and shall be reviewed during the next round of scripting API reviews. https://youtrack.jetbrains.com/issue/KT-28528. Cherrypicked into master. Thanks!. Merged manually - https://github.com/JetBrains/kotlin/commit/a9280cdbcda6dcbe8349b1f4c73b58f1a1d53501. Merged into master. filterNotNull theoretically is not suitable, because it may drop groups in the middle, while I want the result be null if any of the group is null or have incorrect length.\nThanks for the padStart!\nThe expression would be probably simpler with toInteger conversion, but I assume it to be slow and less safe.\n. Ok, I noticed it.size == 2 condition, so my comment above is slightly wrong. But still I prefer my variant as more robust, e.g. if number of the components in the regex will change.\n. I know about this quirk, but if you look into the daemon code, at about that moment daemon reroutes its stdout/stderr to a log file and closes original streams, that in fact leads to the EOF and closing the streams on the runner side. Theoretically it is possible that daemon will dump a lot of info into stdout before rerouting, but in this case everything already too wrong anyway.\n. Yes, something in that line, need to be thought through, so left as a TODO\n. Is it now idiomatic? Doesn't look too appealing to me - it is longer and no more expressive for my eyes.\n. Thanks! When finally we'll have any kind of search in the docs? :)\n. Yes, my bad; Comparing with -1 is a proper solution for a file-based stream.\n. Yes, thanks.\n. good point, I've overlooked that.\n. Ok, agreed, thanks!\n. Yes, thanks. mapValuesTo though.\n. Ok, agreed\n. Yes, this is an RMI requirement\n. No, doesn't work for me, OutputStream does not implement RemoteOutputStream\n. Ok, I added it along with the existing info to compare\n. Ok, yes, thanks. That was converted from java, and so far unused.\n. I disagree, for me it looks like mechanical \"compression\", hiding out the logic for a questionable sake of total code reuse.\n. Ok, thanks, but seems the following variant will be more appropriate here:\nmergeDelimiter != null -> listOf( listOf(prefix + names.first(), toString(prop.get(dest))).filterNotNull().joinToString(mergeDelimiter))\n. Ok, thanks. I made it a bit differently though, hopefully cleaner a bit. See the next commit then it lands.\n. Cannot imagine what you mean. If it is empty, I should skip the delimiter as well, looks like orEmpty is not enough and another \"if\" is needed.\n. Taking into account that I need recognisable file names and use parts of the names for discovery, it seems that straightforward approach with temdir has several potential security flaws, to fix which I'd need a platform-specific code with native function calls (at least until an access to a robust way to create a secure temp subdirs, implemented in java 7).\nAnother problem is that e.g. Idea substitutes \"java.io.tmpdir\", so it is no longer points to the system one, which with current mechanism makes sharing daemons between various clients impossible.\nHomedir solution probably is not ideal, but seems safe enough, and there is a fallback possibility to specify run directory for daemons. \n. Ok, thanks, I'll wrap it into try/catch accordingly.\n. There were no false case in fact. But I rewrote it a bit differently, may be it is more clear and robust now\n. This is a bit too much for this case, imho. I even don't need localhost address as such, just the default addressing scheme.\n. At least I do not see how unicode support could be broken here, provided that String supports it, and all streams used here are not touching contents.\n. What is the root of the questions? What concerns you have here?\nThe daemon may stay alive arbitrary long time, but current default idle timeout is 2 hours, after that it shuts itself down.\n. No, it is not ok. Thank you!\n. Hm, am I supposed to throroughtly rework the code I just converted from Java to Kotlin? \nI understand that it would be nice, but I think if this is the rule - I'd better avoid converting files unless absolutely necessary, because rewriting them properly takes time. (This is a comments to all but last comments below).\n. Ok, anyway, I did it.\n. I tried and I don't like how it looks: understandable structure is lost. Left it as is.\n. I do not like the suggestion - looks too cumbersome and hiding the logic. But may be it will look better if combined with storing and restoring of the property value\n. That's a good one, thanks!\n. I'm using exactly the code used in idea now to avoid different interpretation.\n. ok\n. They are extracted from much more specialized code in builder, and partially rewritten. It will be nice if we can reuse them in the builder, but this is a separate piece of work, that I'm not ready to take right now.\n. 1. I never paid attention to that part, but I'll have a look.\n2,3. I strongly believe that almost any code should be written as close to library design principles as possible without hurting performance, readability, simplicity (to certain extent), and may be few other constraints. Because if it is written properly it could be reused. Hence the generalizations there that going beyond actual usage at the moment.\n. Perhaps yes. The environment in which we'd compile script using e.g. the daemon running under java 8, but run it under java 6 is theoretically possible but practically seems too complicated to be useful.. It is unused yet but meant for support of multifile scripts, some form of use or include functionality.. Is the meaning of \"classpath\" in java already nailed somewhere? I guess we're using it in exactly the same sense.. How is \"ResolutionResult\" better than \"ResolveResult\"? In my understanding - we have an action named \"resolve\" and the result of this action is \"ResolveResult\". With \"ResolutionResult\" one has to make an additional (albeit grammatic) mapping.. Why? There are potentially many of them.\nWe're using plural form everywhere now.. I'm still confused by the fact that Sequence is not Iterable, but otherwise Sequence is a good variant for me.\nAbout annotations - the fact that we're able to use only file annotations here is an unfortunate limitation of the current parser, that I believe could be lifted later. So I don't think that this limitation should be reflected in the API.. Should it go to the runtime/stdlib then?. Fine with me, although this one doesn't seem critical to me.. I thought about it as well, but it looked too flexible. But we can consider something like\nval scriptMatcher: KClass<out ScriptMatcher> = StandardScriptFileMatcher::class\ninstead of scriptFilePattern. The main reason is not to construct annotations unless the resolver needs them. And potentially more type safety.. Since the (manual) construction of the script requires actual arguments array, the simple no-arg variant could be useful in some applications. So, I'd leave it, maybe renamed to ...NoParameters (although I like Simple better).\nThe rest - I agree.. Changing API here is very painful. Maybe that is something to address as well with this review.\nThe requirements are quite clear. People want to be able to write something like\n@file:use(\"other-script.kts\")\nand use all definitions from the included scripts after that. It is not clear how we can implement it, but from the API point of view - it is clear.\nThat's why I'd leave it as is, and tried to implement on the next iteration.. The problem is that now the script template is the only configuration transfer channel for gradle kotlin DSL, therefore the annotation SamWithReceiverAnnotations is a natural way to convey the info. If we'll drop it, we'll need to introduce another channel, which is quite unfortunate.. Seems we're talking about two things here:\n1. The laziness of the annotation creation\n2. Additional filter in the form of @AcceptedAnnotations\nI generally disagree with the \"pessimization\" approach, especially when the optimized one is already in place. Usually, nobody meets real performance problem in one clearly visible bottleneck, but the problem is usually distributed evenly. Skipping the job that nobody needs is usually quite straightforward and implementation here is quite simple. \nOn the other hand, if the laziness will become problematic (as @pTalanov mentioned above), the second mechanism of filtering will eliminate the need of constructing unneeded annotations (and in most cases will eliminate the construction altogether, since there are not many annotation-processing resolvers yet written).\nAnother consideration is that the annotation creation code (https://github.com/JetBrains/kotlin/blob/master/compiler/frontend.script/src/org/jetbrains/kotlin/script/scriptAnnotationsPreprocessing.kt#L35) is not simple, and is relying on some frontend magic, and may need some more logic on to of what is already written, so I don't think that the performance is something we can easily discount here.\nAnd finally, the filtering annotation could be used as an additional type check, ensuring that the resolver receiving the annotations it is able to process.. The simple variant is easier to grasp by someone who is trying understand the samples or to use the code, no?. Yes, that would be a generic solution for such problems, I like it. But then we should implement it before dropping this annotation from here.. Because CharSequence is more generic and should be enough for the most of the actual use cases - searching or parsing. But I'm not really against making it a String, provided that we have a reason.. This sounds nice and interesting, but how far we are from providing compilation facilities on non-JVM platforms? . Please, add the snapshots repo directly to the kotlin-script-util build script. I think we don't want (yet) to add it to all projects.. ",
    "andrewoma": "FYI, this is what I'm currently using - it's a variant of your trimIndent: https://github.com/andrewoma/kommon/blob/master/src/main/kotlin/com/github/andrewoma/kommon/lang/StringExtensions.kt#L27\nI found it necessary to drop leading and trailing blank lines in my usage patterns (in particular splitting groups of SQL statements separated by semicolons.\n. ",
    "RodrigoQuesadaDev": "Hi yanex, so do you need me to make any other changes? I'm just wondering. :)\n. I just created ticket KT-10289 to track this small PR. :)\n. Okay, done. :)\n. ",
    "ezhaka": ":ok_hand: \nhttps://github.com/JetBrains/kotlin/pull/786\n. I've fixed all comments except for the case with the only setter. If you still don't agree with me that it could be useful case, I'll remove it.\n. Sorry, I amended the commit, so comments are not visible in this pull request anymore. They can be seen here: https://github.com/mcgee/kotlin/commit/60cd5ae131f134dae9ae831b17fb6fe2e4b74fee\n. Thank you for the new test case. I'll think about your lazy type suggestion and try to implement it.\n. As far as I understand, star projection is already lazy and it causes original bug (KT-9893). It is kind of \"too lazy\" and substitutes star projection \"as is\" in place of nullable T\nThere are 2 conflicting cases in which TypeSubstitutor should behave differently:\n1. Star projection tries to determine type of itself. It is needed to be sure that star projection's getType() will not be called inside, so TypeSubstitutor should substitute star projection \"as is\" \n2. Substitution of star projection into nullable function return type T?. In this case TypeSubstitutor definitely should check return type on nullability.\nAs a solution I've added parameter to TypeSubstitutor in order to control its behavior for star projections. I've amended the commit so you can check it out. \n. @dzharkov I suppose this pull request can be closed because you fixed the issue in https://github.com/jetbrains/kotlin/commit/e2c02f825f0bc812e48fd692ca657c30e87b47a4\nI see that you fixed the issue in more general way. Unfortunately, I cannot grasp your fix right now. Despite the fact I have contributed nothing, it was interesting experience. I hope one day I will be able to solve problems like that. Thanks for your patience :)\n. Thanks for your comments\nFixed and amended the commit\n. Sorry, false alarm, I forgot to fix resources and I need to fix some tests. \n. Ok, I think I'm ready now \nWhat have been done:\n- Check if caret position is on initializer\n- Check if property is not an extension one\n- Check if property is not a local variable or top level declaration\n- Registered in plugin.xml\n- Added resources to idea/resources/intentionDescriptions directory\n. @yole fixed, I've made an additional commit, it should be easier to review \nI can melt them into one if everything ok\n. @yole, ok, done\n. @yole, yay! :tada:\nI've joined #kontributors a while ago\n. Checks for primitives were added because of SAM conversions tests were failing. Code without checks tries to cast box to kotlin.jvm.functions.Function0\nI was not sure that there were no more cases that my code could break. So I added strict checks that covered implicit number conversions only.\nI can go another way and check only for SAM. Something like this:\nif (codegen.bindingContext.get(SAM_VALUE, argumentExpression) != null) {\n    value.put(parameterType, codegen.v)\n}\nelse {\n    value.put(parameterDescriptorType, codegen.v)\n    StackValue.coerce(parameterDescriptorType, parameterType, codegen.v)\n}\nWill it be correct?\n. Wow :confused: \nOK, please give me some time to grasp your comment and figure out what I can do.\n. Okay, so...\nI extracted compile time constant in both ExpressionCodegen#visitBinaryExpression and ExpressionCodegen#visitPrefixExpression. I saw that compiler generated LDC instruction and correct Long boxing instruction. That's great.\nAbout inlining of Kotlin const's: it's worse :) \nThe compiler inlines even non-const reference expressions. Consider example:\nval a = false\nval b = false\nval c = false\nif (!(a && b && c)) {\n    \"then\"\n} else {\n    \"else\"\n}\nIt generates this:\nL0\n  LINENUMBER 2 L0\n  ICONST_0\n  ISTORE 0\nL1\n  LINENUMBER 3 L1\n  ICONST_0\n  ISTORE 1\nL2\n  LINENUMBER 4 L2\n  ICONST_0\n  ISTORE 2\nL3\n  LINENUMBER 5 L3\nL4\n  LINENUMBER 6 L4\n  LDC \"then\"\n  POP\nSo it seems to be sensible to make custom visitor that looks for property references. Thus I am trying to figure out how to write it for now. \nHowever, may be there is a simpler way. Front-end somehow knows that foo<Long>(1 + 2) should pass typecheck and foo<Long>(1 + x) shouldn't. May it be possible to use the same mechanism in backend instead of custom visitor? \n. Anyway, even if I implement looking for any reference visitor the problem with too aggressive inlining still exists. Consider example:\nif (!(1 < 2)) {\n    val p = 1\n}\nCompiler produces following code:\nL0\n  LINENUMBER 2 L0\nL1\n  LINENUMBER 3 L1\nL2\n  LINENUMBER 5 L2\n  RETURN\n:neutral_face: \n. Yes, I would like to continue\n. @udalov As far as I understand the issue about inlining of\nif (!(1 < 2)) {\n    val p = 1\n}\nwasn't fixed. Test negateConstantCompare.kt still fails. I've committed my changes, you can check that I've done as you suggested.\n. @max-kammerer, I merged upstream/master to my branch before. But it's okay, I've rebased now to be 100% sure. The second case (negateConstantCompare.kt) still fails, I'm sorry. You can see my changes\n. @max-kammerer, thanks for your comments. I've fixed them\nHowever I still have the problem with 4 failing tests (including negateConstantCompare.kt). Moreover, I think it is pretty logical that !(1 < 2) is inlined. To be honest, I don't see the reason why it should not be inlined. Could you explain me that?\n. @max-kammerer, another 3 are \nbytecodeText/contains/byte.kt:\n```\nval a: Byte = 1 + 1\n// 1 I2B\n```\nbytecodeText/contains/short.kt:\n```\nval a: Short = 1 + 1\n// 1 I2S\n```\nbytecodeText/contains/nullableByteAndShort.kt:\n```\nval a: Byte? = -1\nval b: Short? = -1\n// 1 I2B\n// 1 I2S\n```\nAm I right that this 3 also could be resolved by const vals?\n. Ahh, sorry, that won't compile \n. @max-kammerer, I've fixed your comment, thanks for good advice!\n. @max-kammerer, thanks for your patience\n. @yole, thanks for your comments, all of them have been fixed in additional commit\n. Sorry, I amended the commit you've commented because the commit message contained incorrect issue number (it was https://github.com/mcgee/kotlin/commit/72287df557de2eb8da7922c015bbe90a7edac5ec)\n. Thanks for comment. Tests are generated now.\n. Okay, fixed.\n. ",
    "DanielThomas": "Great, thanks.\n. Re: imports - I just organized them w/ IntelliJ. Is that not desirable?\n. @h0tk3y That's awesome! Would love to do away with https://github.com/nebula-plugins/nebula-kotlin-plugin completely - I'll have to PR the other features (setting jvm target version and adding the right version of stdlib implicitly based on the Java target version).. @runningcode I was taken by surprise by the change in Kotlin 1.1.2 to require JDK 1.8 without also also addressing this, and requiring that the older JDK classes be available for compilation to avoid JDK 8 classes leaking into compiled classes.\nMy suggestion would be that if the current JDK differs from the jvmTarget, the build should fail unless compatible classes are provided via an environment variable, or explicit configuration.. Our solution for targetCompatibility was a plugin that configures jvmTarget automatically:\nhttps://github.com/nebula-plugins/gradle-java-cross-compile-plugin. Oh right, so it does. I'll improve that.\n. I just copied the kotlinProject test so there's something meaningful in there.\n. I just followed the existing convention for the variable name - can change it to kotlinVersion if you prefer?\n. ",
    "h0tk3y": "Closing this PR as obsolete: the way the kotlinPluginVersion() is determined has been changed long ago, and now it doesn't cause the publishing { ... } extension configuration.. @DanielThomas Thanks for the pull request! We've manually taken the changes you propose, therefore I'm closing the PR.. Closing because it has been merged manually. Thanks!. The suggested fix doesn't work with Gradle 2.14.1 and below, failing with an exception.\nI will probably add a version check to fall back to the original behavior with older versions.\norg.gradle.internal.typeconversion.UnsupportedNotationException: Cannot convert the provided notation to a File or URI: task ':generateSources'.\nThe following types/formats are supported:\n  - A String or CharSequence path, for example 'src/main/java' or '/usr/include'.\n  - A String or CharSequence URI, for example 'file:/usr/include'.\n  - A File instance.\n  - A URI or URL instance.\n    at org.gradle.internal.typeconversion.ErrorHandlingNotationParser.parseNotation(ErrorHandlingNotationParser.java:56)\n    at org.gradle.api.internal.file.AbstractFileResolver.convertObjectToFile(AbstractFileResolver.java:118)\n    at org.gradle.api.internal.file.BaseDirFileResolver.doResolve(BaseDirFileResolver.java:71)\n        ...\n        at org.gradle.api.internal.file.DefaultSourceDirectorySet.getSrcDirTrees(DefaultSourceDirectorySet.java:147)\n    at org.gradle.api.internal.file.DefaultSourceDirectorySet.getSrcDirs(DefaultSourceDirectorySet.java:76)\n    at org.jetbrains.kotlin.gradle.tasks.FilteringSourceRootsContainer.add(SourceRoots.kt:80)\n    at org.jetbrains.kotlin.gradle.tasks.KotlinCompile.source(Tasks.kt:313)\n    at org.jetbrains.kotlin.gradle.plugin.Kotlin2JvmSourceSetProcessor$doTargetSpecificProcessing$1.execute(KotlinPlugin.kt:150). @Minecrell \nThanks for your contribution!\nThe change you proposed is going to be included in 1.1.60 along with another improvement in source directories configuration (commit). \nI've slightly reworked the test case from this PR, because in general we try to avoid creating additional test projects when there's already a similar one and a minor customization is enough.. Merged manually (commit). Thanks!. We did not add the name to the existing kotlin2js plugin intentionally: we planned to make some breaking changes to the JS plugin, so we may later release the updated plugin as org.jetbrains.kotlin.js (and short name kotlin-js), and deprecate kotlin2js, leaving it as it is. Therefore closing the request.. LGTM, and it has now passed the remote run. Merging.. Thanks for your contribution!. This change is not binary compatible. Changing the return type of a function has the same effect on binary compatibility as combined removing an existing function and adding a new one with the new return type. This will break compatibility of existing binaries compiled against current or older versions of kotlin-stdlib with the newer stdlib versions. Such a change contradicts the backward compatibility guarantees that Kotlin provides: http://kotlinlang.org/docs/reference/compatibility.html. See also #1532 . Thanks for the fixups! I've merged the PR, and the change is going to be included into the Kotlin 1.2.70 release.. @SUPERCILEX Since the Kotlin Gradle plugins targets a range of Gradle versions starting from as early as 3.5, the calls to the new API need compatibility wrappers that fall back to the old behavior with older Gradle versions. Also, the new API is not going to be available in the plugin sources at compile time until we migrate our build to at least Gradle 4.9. Until then, the new API should be called with reflection.. Thanks! Sorry for taking so long.. Thanks!. Thanks!. Pushed for remote run https://teamcity.jetbrains.com/viewQueued.html?itemId=1746965. If the tests pass, I'll fix the issue I mentioned above and merge the PR.. @Slvin Thanks for your contribution!. @Slvin 1.3.20, which is the first 1.3.x tooling update that is not a bugfix release. . Thanks!. Thanks!. If we rewrite the interfaces in Kotlin, we might get much cleaner implementations, e.g.\n```kotlin\ninterface SourceSet {\n    val name: String\n    / ... /\n}\ndata class SourceSetImpl(\n    override val name: String\n    / ... /\n) : SourceSet\n``. I'm not sure we need tests forequalsof thedataclasses as the implementations are generated by the compiler, not even by the IDE, and therefore they get automatically updated on changes.. We'd like to keep the visibility of thisvalrestricted, maybe useinternalif it is not needed outside the module.. We'd like to keep the visibility of thisvalrestricted, maybe useinternalif it is not needed outside the module.. On a Windows machine, these assertions fail due to the` used as the separator. Consider checking the File instances rather than checking the paths. Use project.projectDir.resolve(\"...\") to get the file in the project's temporary directory. The same failures happen in org.jetbrains.kotlin.gradle.model.KotlinProjectIT#testMultiplatformProject and org.jetbrains.kotlin.gradle.model.KotlinProjectIT#testKotlinProject as well.. It looks like options.androidHome should be passed here as well (using the ANDROID_HOME environment variable), otherwise the test project builds fail on a machine without system-wide ANDROID_HOME.. I believe bringing the Kotlin standard library as a dependency along with Kotlin-related API is completely acceptable. Most of the other modules in the Kotlin project do that, and so do lots of third-party Kotlin-related libraries. Most likely, the consumers of such an API will already have the kotlin-stdlib dependency this way or that way.. Check the value that TC sets, possibly handle -Pteamcity=false. Consider restricting access. Maybe a better naming scheme would provide more concrete understanding that this publication comes from the maven-publish plugin, like mavenPublication { ... } (probably not the best option, since there's also the older maven plugin).. Can these be passed in a single -Xcommon-sources=<path> argument?. The control flow based on nullability seems to be wrong here, as it says: regardless of whether the <...>?.invoke(...) result is null or not, run the let's { taskProvider -> ... } block, possibly with null as taskProvider. Should it be ?.let { taskProvider -> ... }?. Use allKotlinSourceSets instead. The difference between them is that kotlinSourceSets only contains the source sets added directly to the compilation, while allKotlinSourceSets also includes source sets that are transitively added to the compilation through the dependsOn relation.. In a single project, source set names are unique. Using the name as a key would be sufficient. Why a separate id is needed?. ",
    "HaasJona": ":-1: This implementation results in overflows for large doubles and floats.  Either restrict this function to integer types (would be preferred by me) or do something like this for doubles and floats:\npublic fun Number.toBigInteger() = BigDecimal(doubleValue).toBigInteger()\nAlso you need to be careful that bigInteger.toBigInteger() doesn't convert to a Long in between which would result in overflow again (ideally just should return this).\n. That was just a question. I think the new solution is also bad because now you are rounding down because of the Integer division when the count is uneven. . Radix parameter seems to be unused\n. Radix parameter seems to be unused\n. \"than\", also is 0 itself valid or not?\n. Is this as overflow safe as the old approach? (this.first + this.last) * this.count() might overflow when (this.first + this.last) * (this.count() / 2) wouldn't.. Rounding down always may add a systematic error here, that isn't present when simply using millisecond resolution.. characters? Or are longer Strings supported?. No, I mean if you measure something that takes 10.5 millis, with currentTimeMillis() you'd probably measure 11ms about half the time and 10ms otherwise. If you add the times of multiple measurements together, you would get about the right result.\nIf you use nanoTime(), that will (ideally) return 10,500,000 every measurement, which will always be rounded down to 10ms, which will return a too low value, especially when adding multiple measurements together.. The alternative solution would be to divide both nano values by 1000000 (normal long division, so rounding down) and then computing the difference between that. That wouldn't have a bias, but it would be slower (double the divisions) and you'd need to deal with wrong results in case the long value overflows between start and stop of the measurement.\nI'm not sure what the best solution is, using nanoTime is certainly the right idea, especially as it's unrelated to changes of the system clock. Just showing potential problems.. ",
    "borgesgabriel": "@ilya-g, would you like me to break this down into smaller commits -- one for each of the functions proposed along with their test cases?\n. ",
    "NeQuissimus": "NixOS is very much usable :) You should check it out ;)\nAnd you are right, I was not anticipating somebody sourcing the file.\nThis is the correct way of doing it, I believe:\nNew paths.sh\n``` bash\necho $0\necho \"$(dirname \"$(which \"$0\")\")\" # Current version\necho \"${0%/*}\" # Won't work with sourcing\nDIR=\"${BASH_SOURCE[0]%/*}\"\n: ${DIR:=\".\"}\necho \"${DIR}\" # Equivalent to current version\n```\nOutput\nbash\n~> ./paths.sh\n./paths.sh\n.\n.\n.\n~> source paths.sh\npaths.sh\n.\npaths.sh\n.\n~> . paths.sh\npaths.sh\n.\npaths.sh\n.\n~> ~/Desktop/paths.sh #symlink\n/Users/tsteinbach/Desktop/paths.sh\n/Users/tsteinbach/Desktop\n/Users/tsteinbach/Desktop\n/Users/tsteinbach/Desktop\n. ",
    "lukaseder": "Thanks for the feedback, I wasn't aware of this dependency.\n. ",
    "vsch": "@yole, I started to write almost identical wording on the PR comment but what had me stumped is that the call is coming in from IDE projectView ClassesTreeStructureProvider on the EDT thread. So delaying the return until the indexes are computed is not really an improvement, neither is re-throwing the exception or leaving it as is, because it generates exceptions with frequent regularity.\nI would check if we are in the EDT thread and ignore the exception, since the UI will be updated when indexing is complete and if not then rethrow the exception so the caller can properly handle the index not ready exception. \nIs this the accepted practice for these types of issues in the IDE?\n. Thanks, I'll do that.\n. @yole, ClassesTreeStructureProvider is DumbAware but not checking if indexes are ready at that point in the code.\nIs an acceptable solution to catch the IndexNotReadyException and throw a ProcessCanceledException so the tree updater can properly handle it?\n. ",
    "cypressious": "I have been able to compile this branch on my machine and got it to work for my project. However the build failed trying to load org.iq80.snappy.SlowMemory. I fixed this by adding classpath 'org.iq80.snappy:snappy:0.4' to my build.gradle.\n. Now I'm getting \nCaused by: java.lang.NoClassDefFoundError: Could not initialize class org.iq80.snappy.SnappyInternalUtils\n    at org.iq80.snappy.SnappyCompressor.findCandidate(SnappyCompressor.java:201)\n    at org.iq80.snappy.SnappyCompressor.compressFragment(SnappyCompressor.java:158)\n    at org.iq80.snappy.SnappyCompressor.compress(SnappyCompressor.java:90)\n    at org.iq80.snappy.Snappy.compress(Snappy.java:58)\n    at com.intellij.util.CompressionUtil.writeCompressedWithoutOriginalBufferLength(CompressionUtil.java:69)\n    at com.intellij.util.io.CompressedAppendableFile.compress(CompressedAppendableFile.java:366)\n    at com.intellij.util.io.CompressedAppendableFile.saveNextChunkIfNeeded(CompressedAppendableFile.java:329)\n    at com.intellij.util.io.CompressedAppendableFile.append(CompressedAppendableFile.java:285)\n    at com.intellij.util.io.PersistentHashMapValueStorage.appendBytes(PersistentHashMapValueStorage.java:152)\n    at com.intellij.util.io.PersistentHashMap.doPut(PersistentHashMap.java:345)\n    at com.intellij.util.io.PersistentHashMap.put(PersistentHashMap.java:332)\n    at org.jetbrains.kotlin.incremental.storage.LazyStorage.set(LazyStorage.kt:70)\n    at org.jetbrains.kotlin.incremental.IncrementalCacheImpl$ProtoMap.put(IncrementalCacheImpl.kt:376)\n    at org.jetbrains.kotlin.incremental.IncrementalCacheImpl$ProtoMap.process(IncrementalCacheImpl.kt:357)\n    at org.jetbrains.kotlin.incremental.IncrementalCacheImpl.saveFileToCache(IncrementalCacheImpl.kt:193)\n    at org.jetbrains.kotlin.gradle.tasks.GradleIncrementalCacheImpl.saveFileToCache(GradleIncrementalCacheImpl.kt:46)\n    at org.jetbrains.kotlin.incremental.BuildUtilKt.updateIncrementalCaches(buildUtil.kt:127)\n    at org.jetbrains.kotlin.gradle.tasks.KotlinCompile.callCompiler(Tasks.kt:397)\n    at org.jetbrains.kotlin.gradle.tasks.KotlinCompile.callCompiler(Tasks.kt:138)\n    at org.jetbrains.kotlin.gradle.tasks.AbstractKotlinCompile.execute(Tasks.kt:101)\n    at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:75)\n    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.doExecute(AnnotationProcessingTaskFactory.java:244)\n    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:220)\n    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.execute(AnnotationProcessingTaskFactory.java:231)\n    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:209)\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)\n. Thanks, I rebuilt it and the plugin works now.\nApart from that, I'm often getting a lot of cannot find symbol related to generated classes from Dagger 2 in my mixed Java Kotlin project. Not sure if that's a known issue at that point.\n. The issue only happens when I use incremental compilation with my self-built gradle plugin. Should I file it on YouTrack? I wasn't sure if you want feedback and bug reports at all since this is a development branch.\n. Done: https://youtrack.jetbrains.com/issue/KT-11138 \n. Updated according to comments.\n. Unfortunately, I haven't figured out how to make the unit tests work. I suspect it has to do with previous fixers only working on the syntax level so the call resolution stuff is broken in the test environment.\n. Tests work after all if you use your own function instead of stdlib ones like with.\n. Parameter names are not set anymore. Also the lambda is now in the same line.\n. I simplified the whole logic. The caret is now set directly in the first pass so there is no need for a second pass anymore.\n. Great. I think I get the hang of the smart enter logic now. When I understood the multi-pass logic, everything became much more clearer.\n. Implemented feedback\n. Whoops, broke the tests. Now they pass again.\n. @yole Done\n. @mglukhikh Any feedback? :)\n. Rebased, removed reference to type, fixed the logic to consider all indirect supertypes, grouped tests and added one\n. @mglukhikh The problem arrises when you expect generic type A<Y> but the type already indirectly implements A<X>. Here's a demonstration:\n``` kotlin\nfun main(args: Array) {\n    foo(B())\n}\nfun foo(a: A) {\n}\ninterface A\nopen class C : A\nclass B : C()\nclass X\nclass Y\n``\n. Related: https://youtrack.jetbrains.com/issue/KT-11781\n. Constructor test already exists incompiler\\testData\\codegen\\box\\reflection\\constructors\\constructorName.kt. I'll remove the tests. Any feedback on the implementation?\n. I think it should be correct now.\n. @goodwinnk looks good!\n. @yole I implemented the feedback and squashed the commits.\n. Rewrote the fix and disabled the.toX()fix when the new is active. Also added some tests.\n. @yole fixed the style issue\n. @yole fixed\n. Great, thanks.\n. Done\n. I handle it for return but forgot to copy it over for assignments.\n. I'll fix it later today.\n. Done\n. What would you suggest regarding the Java problem?\n. @yole I've decided to remove the renaming part (maybe until later) and also disable the intention if it has non-Kotlin usages. On the one hand this is a bit lazy, on the other hand it can make sense because the usefulness of the intention comes from the fact that it only simplifies the declaration site but doesn't change the call sites, but this is only true for Kotlin code, not Java.. @valentinkip Could you tell me which bug you've spotted?\n. @valentinkip I've unified the code and rebased onto master.\n. @valentinkip I rebased on master. Do you have time to review the changes?. @shiraji You remove the mutable collections alltogether. KT-14570 is about platform types only. Sorry, if that wasn't clear from the slack discussion.\n. Take a look attype.isFlexible()andtype.asFlexibleType(). I thought of it when I sawtoMutableList()` in my code being flagged and I knew that I wanted to make a defensive copy in this case.\n. That was just a remark regarding my project's codebase, it had nothing to do with your code.\n. Maybe all the quick fixes are a bit to speculative and not really\nnecessary. Having the warning is the most important thing.\nKirill Rakhman\nAm 23.12.2016 12:27 nachm. schrieb \"Roman Elizarov\" \nnotifications@github.com:\n\nI'd suggest that in cases like \"a == something\" where a is some modifiable\nthing the most likely explanation is that it was a typo and a fix is to\nremove an extra =\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/1000#issuecomment-268976702,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABIviM4OHql8yueo0UXTPGLBt0L_00fCks5rK7ArgaJpZM4LUgZi\n.\n. @yole I reworked the code and added some more tests. I think it's cleaner now.. @4u7 done. @goodwinnk I commented on your review. I think this PR shouldn't be closed yet, should it?. @goodwinnk I have updated the PR.. Ok, I'll take another look.. @mglukhikh I've added checks for val, nullable and primitive types.. @mglukhikh I haven't found a solution for hiding the duplicate intention without using IntentionBasedInspection, yet. . Why not also unary plus? It could be overloaded. . @t-kameyama While you're at it, you could also fix https://youtrack.jetbrains.com/issue/KT-18425. I have no idea, why the added test is failing.. @mglukhikh thanks, fixed the tests and rebased onto master.. If you rename the intention, you should also rename the description files in https://github.com/JetBrains/kotlin/tree/master/idea/resources/intentionDescriptions/ConvertNegatedExpressionWithDemorgansLawIntention. @yole fixed after review and rebased. @yole, I'll be on vacation for a week. I can fix it next week, or you can\napply the changes yourself, whatever is more convenient for you.\n\nKirill Rakhman\nAm 24.07.2017 2:44 nachm. schrieb \"Dmitry Jemerov\" <notifications@github.com\n\n:\nBasically same comments as for #1206\nhttps://github.com/JetBrains/kotlin/pull/1206\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/1207#issuecomment-317410992,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABIviNqvZKRi9YWr3hsA6gOoJQrx3_1lks5sRJG1gaJpZM4OgMje\n.\n. @yole fixed after review and rebased. @piotrek1543 I've already commented with the link to the PR on the youtrack issue, so the PR shouldn't go unnoticed, but I've also changed the name.. @goodwinnk I made some changes in response to your review. could a take another lok?. @goodwinnk I wasn't able to amend to this PR because it's closed, so I created #1290. @mglukhikh fixed. I was unable to actually run the test, please tell me if it fails.. @mglukhikh I'm never sure about the difference between the two. Maybe someone should document this for external kontributers.. @udalov thx for the heads-up. Any tips on how to bulk-fix it? Or is there only the manual way?. I fixed ~100 tests. I piggybacked the fix for https://youtrack.jetbrains.com/issue/KT-22200 on this PR as well.\n  . Shouldn't this be an inspection rather than an intention?. Alright, closing this then.. Do you check anywhere that the expression is actually of type Closeable?. @DeFuex What I mean is, nowhere in your code is there a check that the expression is of type Closeable.\n\nHow do you distinguish between \nkotlin\nval stream = FileOutputStream(\"\")\nstream.write(\"\")\nand \nkotlin\nval string = String()\nstring.toUpperCase()\n?. If I understand correctly, Mikhail is merging this manually in https://github.com/JetBrains/kotlin/tree/rr/let_implement\n. Anyway, fixed it.\n. @yole \nRegarding your first comment: \nThere is a certain logic behind the two loops. The first one never enters nested loops and collects all the unqualified continues while the second one also enters nested loops. If I merged the two, how would I know whether to collect an unqualified continue?\nRegarding your second comment:\nCan you show me a code snippet that would be broken by the current implementation? In my understanding a continue inside a lambda/function/class would need to be inside a separate loop in which case the it !is KtLoopExpression check would prevent me from collecting them.\n. Added checks.\n. It seems classes are indeed generated. Where should I look to prevent that?\n. Should I hook into ExpressionCodegen#visitSimpleNameExpression and prevent the anonymous class from being generated or is there an approach where I can remove the generated class afterwards?\n. I got it working by modifying visitSimpleNameExpression.\n. Done\n. My motivation to make this method public was that there's another quickfix, that adds a constructor parameter with the same name that could be deactivated when this method returns a non-null value.\n. Ok\n. Done\n. What would be a good name for this sequence method? getNonStaticOuterClassSequence()?\n. Done\n. Done\n. Done\n. You're right. I should have thought of that. The logic I have now is plain wrong for methods and secondary constructors, too. Now it disables the quickfix for methods with one default argument although it would make perfect sense to add the annotation. Don't know what I was thinking.\n. What about other usages of  PrintStream.println outside of System.out, e.g. System.err? This will produce a lot of false positives.\n. I moved the line and squashed the commits.\n. Why limit to HashMap?\n. You can use findOriginalTopMostOverriddenDescriptors e.g. to to get MutableMap.put instead of HashMap.put\n. You have the same method in ReplaceMathMinWithCoerceAtMostIntention. It would make more sense to pull it out in a Utils class.\n. Agreed.\n. Won't\nobject Foo {\n    class Bar {}\n}\ncause a false negative here?\n. Sorry, my concern was only whether getStrictParentOfType will return indirect parents or only the direct one. In the former case, you could construct a false negative by nesting class/objects.\n. Is \nkotlin\nval foo = object {\n    class Foo {}\n}\nvalid?\n. Can you point me to how I start an inline renaming? All I could find was the one with the dialog.\n. I can't unify the check because while the intention is simply not available, the join handler still has to go into this branch.\n. expressions. I agree this isn't pretty. Currently, the formatter allows both, getters on the same line and on the next line. Forcing one of them could be to strict.\nMaybe the KtPsiFactory could get an option to create a property with the getter on the same line. What do you think @yole?\nEdit: Maybe that's already possible and we should just use the PsiFactory to create the whole thing instead of reconstructing the KtNamedFunction part by part?. I think the reason for the current way is because it preserves annotations, modifiers, receiver type and other things I probably forgot. If we redid it, we would have to manually take care of it.. The reason I used startsWith() is that some keywords insert more than a single character, e.g. init where beforeCaret.trimStart() will be equal to \"{\\n\".\nSee https://github.com/JetBrains/kotlin/blob/b5db50f42996c09de12a1bddb98adb960a32bc01/idea/idea-completion/src/org/jetbrains/kotlin/idea/completion/KeywordCompletion.kt#L72-L72. @goodwinnk Thanks for the review.\ngetNextSiblingIgnoringWhitespaceAndComments() is needed because otherwise the following case will be handled wrongly:\nkotlin\nclass Foo cons<caret> () //note the space before the primary constructor\nI agree that comments shouldn't be skipped. For that I could introduce a new extension function getNextSiblingIgnoringWhitespace() and use it instead.\nRegarding your examples where my logic would lead to arguably wrong behavior: How about I restrict my logic to cases where there isn't a line break between the keyword and the brace/paran?\nSo this \nkotlin\nfun other(a: Any) {\n  if<caret>\n  (a as Int).let { println(a + 12) }\n}\nwill become\nkotlin\nfun other(a: Any) {\n  if (<caret>)\n  (a as Int).let { println(a + 12) }\n}\nbut this\nkotlin\nfun other(a: Any) {\n  whil<caret> ()\n}\nwill become\nkotlin\nfun other(a: Any) {\n  while (<caret>)\n}\n. You could use singleOrNull() ?: return here.. You can simplify this to return MODIFIER_EXCLUDE_OVERRIDE.any { hasModifier(it) }. Done. fixed. fixed. I refactored the inheritance chain since your comment. Is it still relevant?. I now have a base class KotlinControlFlowExpressionSurrounderBase for both try and if expressions. I think the cost of analyze shouldn't be too bad because it is only called when the user invokes the \"Sourround with\" action, not on every key stroke.. fixed. can be shortened to if (primaryConstructorParameterList?.parameters?.isEmpty() == true). You are analyzing the same code twice. You should reuse the context from above.. includeAdditionalModifiers implies includeSuspendModifier. If I left out the else, suspend would be rendered twice.. I'm not sure, to be honest. OverridesCompletion.PRESENTATION_RENDERER used to omit suspend but that's what the PR fixes. I could render suspend unconditionally if you think that's the correct behavior.. I removed the property so that suspend is always rendered when applicable.. the the is actually redundant \ud83d\ude06 . ",
    "alexey-tsvetkov": "The PR is closed, the branch was merged manually.\n. I've made a minor fix to the test and merged the PR manually.\nThanks for the contribution!\n. Thanks for your contribution!\nMerged manually. @JLLeitschuh thank you for your contribution! \nThe change is going to be included in 1.1.3.\nThe PR is merged manually, so I'm closing it now.. The changes themselves look good to me. Meged manually into master and 1.2.50 branches. Thanks for the contribution!. @gavra0 we cannot use configuration avoidance API to be compatible with older versions of Gradle. At least without checking Gradle version first. Besides the usage of Lazy Task API, the fix looks good to me.. @gavra0 if making the task lazy is not critical for you now, I've reverted that part of your commit and pushed the branch for remote run rr/gradle/avoid-script-conf-resolution\nWill merge after RR.. Merged manually.\n@gavra0 thanks for your contribution!. Merged manually.\n@ting-yuan thanks for the contribution!. As far as I understand these functions are copies of functions at KotlinBuilder. Why not to reuse them at KotlinBuilder? I mean, these functions are in build common, so their originals from KotlinBuilder can be removed.\n. 1. Formatting is unusual to our codebase (surrounding \"->\" with spaces).\n2. logAction is the same for both call-sites\n3. filesFiler is almost the same for call-sites. Could be replaced with excludedFiles: Set\n. It seems more like just \"createIncrementalCache\"\n. I don't think these lookups can useful: \n- for JPS a processing of removed classes is done in clearCacheForRemovedClasses; that method uses proto from caches for dirty fqnames;\n- current implementation can only return lookups of classes.\nSo I suggest to remove this function.\n. What's the point in using named arguments here?\n. I believe saving versions should be after the loop.\n. Minor: filter returns list\n. Minor: formatting\n. Minor: formatting\n. I think you should also include kapt1 annotations file:\nhttps://github.com/JetBrains/kotlin/blob/master/libraries/tools/kotlin-gradle-plugin/src/main/kotlin/org/jetbrains/kotlin/gradle/internal/AnnotationProcessingManager.kt#L139\nIn kapt1 AP is performed by java task, so if this file is not included, AP may be skipped when only source annotations are modified.\nKapt3 should probably work as intended.\nI think the test should be added for this case (Java IC + Kapt 1/3 + change only Kotlin source annotations).. I think that version checking should be performed before upToDateWhen callback is added. What about newer Gradle versions?\nBtw, it would be interesting to test if Java compile avoidance works in this case with the Gradle 3.4 (in other words that Java is not compiled if Kotlin public API is not changed). . I wonder why the tools.jar is not found?\nIt should be present in workers classpath.. Both cached classloaders lack up-to-date checks. \nGradle probably reuses workers only when a workers' classpaths are the same, so we might assume that rootClassLoader is immutable.\nHowever, I'm not sure that caching kaptClassLoader is safe without checking whether kaptClasspathUrls are up-to-date.. I have an alternative idea. tools.jar should actually be present in a worker's classpath (maybe it's not added now, I don't see if a worker's classpath is modified).\nIt is not reused probably because of findRootClassloader implementation:\nprivate fun findRootClassLoader(): ClassLoader {\n    tailrec fun parentOrSelf(classLoader: ClassLoader): ClassLoader {\n        val parent = classLoader.parent ?: return classLoader\n        return parentOrSelf(parent)\n    }\n    return parentOrSelf(KaptExecution::class.java.classLoader)\n}\nSo now the rootClassLoader is probably the bootstrap classloader, that does not contain anything besides rt.jar classes.\n@yanex says that the reasoning behind this was that he was not sure if it's safe to execute KAPT in context of Gradle worker's classloader, because it also contains some Gradle internals, such as Groovy or Guava (see https://github.com/gradle/gradle/issues/3698). However I think it should not be a problem, since KAPT does not use a compiler when running annotation processors.\nSo I think we should ensure that tools.jar and kapt jars are present in a worker's classpath and use a worker's classloader, so up-to-date checks and caching would be effectively handled by Gradle.\nIf this works, it would be a simpler implementation.\nExample implementation: https://github.com/JetBrains/kotlin/commit/2ee483724ea3b108b5e8a58a5126782c34a8a8c7. @ting-yuan thanks for investigating! I think current solution is good enough. We can improve later, when/if Gradle fixes worker's classpath. I'll run tests on CI and merge your commit.. ",
    "manas-chaudhari": "Have taken care of above scenarios. Can proceed to review.\nAnother issue which bothers me:\n- main gets highlighted for Missing Documentation. I am not sure if it is a good idea to make it an exception. If exceptions need to be made, are there other such keywords?\n. Thanks. Will send over an update asap.\n. Updated. Please check\n. Have fixed the duplicate method issue. Also added a test for quickfix.\n. ",
    "JakeWharton": "Oops! You're right. Will do soon. Thanks.\n. Updated!\n. Friendly (non-weekend) ping!\n. Had a hell of a time trying to get this to compile let alone test locally. Going to rely on your CI here.\n. Got it. Thanks for the info.\nOn Thu, Jun 22, 2017, 6:44 AM Sergey Igushkin notifications@github.com\nwrote:\n\nWe did not add the name to the existing kotlin2js plugin intentionally:\nwe planned to make some breaking changes to the JS plugin, so we may later\nrelease the updated plugin as org.jetbrains.kotlin.js (and short name\nkotlin-js), and deprecate kotlin2js, leaving it as it is. Therefore\nclosing the request.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/1152#issuecomment-310384134,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEfxNf3VEgurrsfTerRwPrTzU8NEXks5sGm--gaJpZM4OBfhO\n.\n. @ilya-g . Thanks!\n\nOn Fri, Oct 13, 2017, 8:32 PM ilya-g notifications@github.com wrote:\n\nI've merged it with minor edits: 485ca10~2...485ca10\nhttps://github.com/JetBrains/kotlin/compare/485ca10~2...485ca10\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/1230#issuecomment-336596188,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEZ_CD28ctnvLrkp_lzEqftwhqSAyks5ssAEJgaJpZM4OuUIH\n.\n. This PR conflicts with the @Ignore that was added directly to the js/ module instead of being put in the common/ one. @Before and @After were also added to js/ but should have been added to common/ as well.\n\nI can update this PR to include @Before and @After, although it will suffer the same problems as commented above.. Yep! Happy to see forward progress no matter how it gets done.. Yeah sorry I've been meaning to get back to this.. The language provides adequate facilities for handling this case in a way which is far more clear and doesn't have surprising (and borderline illogical) behavior in the null case.. Well not only are those not equivalent but you're not even playing fair. The comparison is\nkotlin\nSystem.getenv(\"foo\").toBoolean()\nto\nkotlin\nSystem.getenv(\"foo\")?.toBoolean() ?: false. Some reading about this with a result you might not expect: https://shipilev.net/blog/2016/arrays-wisdom-ancients/. We already have these extensions in the form isVisible, isInvisible, and isGone in core-ktx.. Whoops sent this a bit early. Just wanted to see the diff on GitHub on my fork. Anyway early comments welcome. There's still bits in the tests and IDEA plugin to take a look at.. See also #1964. Returning null on something that returns a collection. Those developers should have their programming license revoked.\nGood catch, will update tomorrow.\n. Updated!\n. I suppose this isn't strictly needed since the plugin is looked up by name.\n. I'm working on not needing this.... I think this is blocked by https://youtrack.jetbrains.com/issue/KT-19656.\nI can't create @Ignore and alias to org.junit.Ignore without mirroring its full set of properties, despite the fact that on the JVM they all have defaults.. And I don't want to \"simply\" mirror the properties because honoring them in the JS runners is a non-trivial task that I don't want to scope as part of this PR.. This should be replaced with a proper assertion and failure. If the message doesn't match you'll get a cryptic failure saying \"Expected an exception of type RuntimeException to be thrown, but was RuntimeException\".. You should assert on the message here actually indicating a mis-matched message. This also obviates the need for the dummy assertTrue.. Fixed. And yes, it does solve those TODOs!. Makes sense. Added this check. Had to use ApiVersion.parse(KotlinVersion.CURRENT.toString()) since those were of different types. Let me know if there's some other way to compare these two.. Open to different/better names for this.. ",
    "asarazan": "Is there an ETA on when this will make it into a release? I've got a couple pain points that this will help with.\n. ",
    "cbruegg": "There's this one: assertEquals(\"Abaabaaababac\".occurrencesOf(\"abaa\", ignoreCase = true).toList(), listOf(0, 3))\nI'll add some more though. Good suggestion for the early return as well, I'll change it and update this PR. Thanks for the feedback!\n. I've just added tests for two greek unicode characters and added more tests for the ignoreCase condition.\n. What do you mean? If you take a look at the tests, \"abaabaaababac\".occurrencesOf(\"abaa\") returns 0 and 3, so it does match every position. I haven't run the regex you've posted, but it should have the same result.\n. Nevermind, I see what you mean. I'll change the PR. \n. I could probably add an additional parameter for that. Its default value\nshould be to find all occurrences in my opinion.\nSergey Mashkov notifications@github.com schrieb am Mi., 17. Feb. 2016\n11:47:\n\nShould we return all occurrences or only non-overlapping? eg\nAAA.occurrencesOf(AA) = 0, 1 or 0 ?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/821#issuecomment-185149648.\n. The equivalent regex does not return overlapping occurrences. I'll set the\ndefault parameter value to non-overlapping.\n\nSergey Mashkov notifications@github.com schrieb am Mi., 17. Feb. 2016\n12:35:\n\n@ilya-g https://github.com/ilya-g what do you think? what behaviour is\nbetter by default? as far as I understand all our api doesn't return\noverlapping occurrences, isn't it?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/821#issuecomment-185163117.\n. Just checking you've noticed the commit - not sure if GitHub sends notifications for commits in PRs or only for comments. If you saw the commit already, please disregard this comment.\n. Thanks for the suggestions, I've incorporated them.\n. I've fixed the infinite loop, the prefix function algorithm missed a subtraction that wasn't caught by a test yet, so I've also added a test case for that.\n\nI've never seen -1 in the table before, so KMP as described in the Wikipedia article seems to be a slightly different variation of KMP. My implementation is based on the pseudocode we were given in a lecture on Fundamental Algorithms at the University of Paderborn and it was also proven to be working correct by the lecturer, so this should be fine.\nIf you need them, I can send you the corresponding slides in private.\n. Fixed, thanks.\n. Actually yes, it should. Learning the hard way that even with tests such things can easily be missed, sorry. I've just pushed a fix with another test case as well.\n. Done.\n. ",
    "inorichi": "I think methods should also use referential equality, because there can be methods with the same name and different arguments.\n```\nclass SomeClass {\n@MyAnnotation\nfun onEvent(event: A) {}\n\n@MyAnnotation\nfun onEvent(event: B) {}\n\n}\n```\nWith this example, kapt will process only one of these methods.\n. ",
    "hansenji": "@abreslav https://youtrack.jetbrains.com/issue/KT-9183\n. ",
    "MarcinMoskala": "There is no conflict in java \nhttp://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2.5\n. More like:\noperator fun  List.get(indexesRange: IntRange): List = subList(indexesRange.first, indexesRange.last)\n?\n. Let's do it then\n. I correct it. Could You take a look on that? :)\n. I also added list multiplication. Also usefull feature\n. Fixed\n. Can do it. And wanted to do it. Just don't know if rest agree with that. That is why I prefer to close it like that right now (because it is my first pull request and I care a lot) and add this funcionality in next pull request.\n. That is why \noperator fun  List.get(indexesRange: IntRange): List = indexesRange.toList().map { get(it) }\nwas perfect xP\n. With - values:\nList.get(indexesRange: IntRange): List = indexesRange.toList().map {if(i<0) i-size else i}. map { get(it) }\n. Hey, is function placed correctly? Do you want me to also add Byte.toHex extension function?. Done\n. Done\n. Done\n. Done\n. This is controversive. I was thinking about it and I check how it works in Python ant there for minus factors there is no error but empyt list. But I will change it If you prefer this way.\n. Done\n. Done\n. Done\n. Done\n. Ow, sorry. Should be listOf(1, 1) OR listOf(1, 1, 1) == listOf(1, 1, 1) in comment. Ill change it when I will be able to.\n. ",
    "HappyEmu": "I'd like to throw in the idea to support negative upper range limits as well. The negative upper limit would represent the offset from the size of the list. Example:\nlist[2..-1] would return all elements starting from index 2 until the end (list.size - 1) of the list.\nlist[3..-2] would return all elements starting from index 3 until index list.size - 2\n. ",
    "robfletcher": "I did find some differences in behavior between JetBrains @NotNull annotation and @Nonnull. See this spek: https://gist.github.com/robfletcher/fe1591ddbc8144289fdf#file-interopnullabilityspec-kt-L21-L51\n. ",
    "NitroG42": "They are only available in the kotlin context, will the conflict still risk to occurs ?\n. Hello, I'm sorry for the lack of news, I planned to make the modifications (I updated the code), but wanted to learn how to make test for macro, and I just didn't have the time to do that right now.\nThank you for the rewriting, I'm glad it could be merged to the project though. \n. ",
    "svetlyak40wt": "I've just used git-blame to see the date, when header 1.0.2 was added. If you know the real date or it is not released yet, then put correct date. This will help community to keep on track and learn the history of the language.\n. ",
    "VladRassokhin": "@goodwinnk Forgot to test that. Actually there no effect in editor.\nSeems something is wrong inside IntelliJ :disappointed: \n. ",
    "yingzhuo": "Nice!  String.toXxxOrNull is very handy.\n. ",
    "yarulan": "https://youtrack.jetbrains.com/issue/KT-11839\n. ",
    "yaroslav-ulanovych": "@cy6erGn0m No problem! Happy to see it merged.\n. ",
    "erokhins": "I've merged your changes manually. Thank you!\n. Merged manually. Thank you for contribution! \nI updated and merged it manually:\nhttps://github.com/JetBrains/kotlin/commit/923d9f03fcc52076957a524d0d14155f794d8fdd. We will discuss this PR internally. \nMy opinion here is the following: LazyClassContext is too powerful for extension point and allowed compiler plugin do whatever hacks it wants and I'm not sure that it is a good idea.. Manually merged into master: https://github.com/JetBrains/kotlin/commit/cebee7b5e1be5d283d5c7e31d9383804f50e38ce. Manually merged: https://github.com/JetBrains/kotlin/commit/d63a2462ef80e6aff1e30ed39dffee6b77069e3e. Thank you for contribution! \nMerged manually: https://github.com/JetBrains/kotlin/commit/b1ef670818dea6112a422d0a987fb55dfe59c911. I will rename it.\n. ",
    "geoand": "Sorry about that, the IDE seems to have done that automatically (because I  didn't un-check various options)!\nI'll fix it immediately\n. If you decide to merge this, let me know if you want me to the rebase the branch so that only one (or possibly two) commits will appear in the log instead of three (where the third one corrects the erroneous removal of the public modifiers)\n. @ilya-g All set :)\n. My understanding is that \"Documentation\" in this sense is a single entity, and therefore should be \"is\"\n. Ok, thanks!\nOn 8 Jun 2016 21:54, \"ilya-g\" notifications@github.com wrote:\n\nClosed #878 https://github.com/JetBrains/kotlin/pull/878.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/878#event-686284222, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AELBv5XjHwXjoIuxKEHc7mxHxWiGsCVIks5qJw_mgaJpZM4IuuYC\n.\n. \n",
    "soywiz": "Woops. Didn't know this was investigated and fixed already. The issues was from last year, and since it still happened on master/1.1 I though that no one investigated it yet. And I finally was able to compile and run master by myself so I decided to look at it.\nCool. Feel free to grab what you need :+1: and to close this when done.\nAnd thank you for looking at this!\n. Sure. I did this optimization after profiling using chrome a proof of concept of a 2d game that has a render tree of nodes. Not remember exactly where I had instance checking or pattern matching, but happens per frame. Also not sure if I was later able to remove those checks with inheritance. But in fact instance checking is costly on JS where on JVM is pretty cheap, so this patch amends it a bit by flattening the structure and memoizing the results but might require a bit more of refining.\nI was dirty applying that patch here when combining and serving the client: https://github.com/mmo-poc/mmo-poc/blob/eedbb437c96d84cb5358b49113e963da2a064715/mmo/jvm/src/mmo/server/Backend.kt#L309-L346\nWithout the patch isInheritanceFromInterface takes 4.4% of the time:\n\nWith the patch isInheritanceFromInterface cost doesn't appear at all (Kotlin.isType still appears):\n\nI guess this optimization would help in other use cases too.. Set is defined in ES6: http://kangax.github.io/compat-table/es6/#test-Set\nIt is possible to polyfill it using arrays, but that would require additional code with the polyfill.\nI'm not sure if browsers optimize indexOf === but probably optimize >= 0 or != -1.\nI added the comment there to discuss that.\nI wanted something that worked without adding additional code at that time. Since this was computed once per type, was not critical for me. But large type hierarchies might benefit from optimizing this.. I wrote this code sometime ago. so don't remember the full details and maybe I'm wrong, but I guess that isInheritanceFromInterface is called with a constructor that already is an interface since there is already an instanceof part of Kotlin.isType that would deal with plain inheritance checks.\nWhat about changing it to thisAndAncestorInterfaces or ancestorInterfacesIncludingThis if allInterfaces result confusing?\nIf I remember it wrong, maybe it could be changed to allSuperTypesAndThis and the function getAllSuperTypesAndThis.. I don't remember the details. But maybe to not fail on non-kotlin types? But maybe that's handled in the functions calling this one so if that's the case, that line could be removed.\n\nTo prevent changing the shape of the objects, maybe in the type declaration at the code generation phase, _allInterfaces could be set to null so the property at least exists even if computed lazily, or even to an empty array having a boolean elsewhere to determine if it was computed if changing a null still changes the shape.\nIn a full AOT would be possible to assign numbers to each type beforehand and make a much faster lookup, but having separate modules and being able to depend on super types defined in other module, the lazy option is the best option I thought at that time.\n. Makes sense.. ",
    "shiraji": "NP! Thanks for merging this pull request.\n. I agree with you. When i first tried to use KtAnnotatedExpression, no events occur. Maybe some settings were wrong. Let me fix this up. \n. Could you review again @mglukhikh ? Now use KtAnnotatedExpression. Let me know if you want me to squash the commit.\n. > files like IntentionTestGenerated.java (to be precise, *TestGenerated.java) should never be changed manually. To regenerate them, please use \"Generate Tests\" run configuration (I've already done it for your changes).\ni didn't know that. i will run it in next time. Thanks!\n. Thanks!\n. @yole Do you want me to squash the commits? I rebased commits since it is no longer merge-able\n. For local variables, val foo: String = \"\", developers want to omit \": String\" using expand selection.\nFor parameters, you are right. I will fix this.\nI understand you are busy. I had no idea what was going on. I thought I was doing something wrong. Thanks for your response!\n. I found another issue for this PR\nkotlin\n    fun foo(): String {\n        foo2(object : <caret>DocumentAdapter(){\n        })\n        return \"\"\n    }\nHighlight like this.\nkotlin\n    fun foo()<select>: String {\n        foo2(object : DocumentAdapter()</select>{\n        })\n        return \"\"\n    }\nLooks not good...\n. Do you have suggestion for how to resolve secondary constructors?\n. > You forgot to add RemoveUnnecessaryLateinit.html into idea/resources/inspectionDescriptions\n~~oops...now I found a big problem with previous PR. I don't remember adding .html for https://github.com/JetBrains/kotlin/pull/895 . Do you want me to send another PR for adding RemoveAtmarkUsedAsAnnotationArgumentInspection.html ?~~\nNever mind. You added that for me. Thanks. I will do that for this pull request.\n. Thanks!\n. > intention was suggested on simple strings, like \"Hello\", I've fixed it\nOops. I should have had test cases for that. Thanks anyway!\n. Ah! Didn't know there is such thing. I will fix this.\n. Implemented.\n. Thanks\n. Thanks!\n. Nice. Thanks!\n. That's quick. Thanks!\n. Thanks for reviewing this pull request\n. I didn't know such tool. \nMaybe I used the tool a wrong way but I could not find the difference of PSI structure.\nHere is the code I checked it.\nkotlin\nfun foo(text: String?) {\n    text?.to(\"\").to(\"\")\n}\nWhen there is error, PSI structure looks the following\nJetFile: Dummy.kt(0,51)\n  PACKAGE_DIRECTIVE(0,0)\n    <empty list>\n  IMPORT_LIST(0,0)\n    <empty list>\n  FUN(0,50)\n    PsiElement(fun)('fun')(0,3)\n    PsiWhiteSpace(' ')(3,4)\n    PsiElement(IDENTIFIER)('foo')(4,7)\n    VALUE_PARAMETER_LIST(7,22)\n      PsiElement(LPAR)('(')(7,8)\n      VALUE_PARAMETER(8,21)\n        PsiElement(IDENTIFIER)('text')(8,12)\n        PsiElement(COLON)(':')(12,13)\n        PsiWhiteSpace(' ')(13,14)\n        TYPE_REFERENCE(14,21)\n          NULLABLE_TYPE(14,21)\n            USER_TYPE(14,20)\n              REFERENCE_EXPRESSION(14,20)\n                PsiElement(IDENTIFIER)('String')(14,20)\n            PsiElement(QUEST)('?')(20,21)\n      PsiElement(RPAR)(')')(21,22)\n    PsiWhiteSpace(' ')(22,23)\n    BLOCK(23,50)\n      PsiElement(LBRACE)('{')(23,24)\n      PsiWhiteSpace('\\n    ')(24,29)\n      DOT_QUALIFIED_EXPRESSION(29,48)\n        SAFE_ACCESS_EXPRESSION(29,41)\n          REFERENCE_EXPRESSION(29,33)\n            PsiElement(IDENTIFIER)('text')(29,33)\n          PsiElement(SAFE_ACCESS)('?.')(33,35)\n          CALL_EXPRESSION(35,41)\n            REFERENCE_EXPRESSION(35,37)\n              PsiElement(IDENTIFIER)('to')(35,37)\n            VALUE_ARGUMENT_LIST(37,41)\n              PsiElement(LPAR)('(')(37,38)\n              VALUE_ARGUMENT(38,40)\n                STRING_TEMPLATE(38,40)\n                  PsiElement(OPEN_QUOTE)('\"')(38,39)\n                  PsiElement(CLOSING_QUOTE)('\"')(39,40)\n              PsiElement(RPAR)(')')(40,41)\n        PsiElement(DOT)('.')(41,42)\n        CALL_EXPRESSION(42,48)\n          REFERENCE_EXPRESSION(42,44)\n            PsiElement(IDENTIFIER)('to')(42,44)\n          VALUE_ARGUMENT_LIST(44,48)\n            PsiElement(LPAR)('(')(44,45)\n            VALUE_ARGUMENT(45,47)\n              STRING_TEMPLATE(45,47)\n                PsiElement(OPEN_QUOTE)('\"')(45,46)\n                PsiElement(CLOSING_QUOTE)('\"')(46,47)\n            PsiElement(RPAR)(')')(47,48)\n      PsiWhiteSpace('\\n')(48,49)\n      PsiElement(RBRACE)('}')(49,50)\n  PsiWhiteSpace('\\n')(50,51)\nAfter typing space and delete the space to remove the error. The result is following which is the same result\nJetFile: Dummy.kt(0,51)\n  PACKAGE_DIRECTIVE(0,0)\n    <empty list>\n  IMPORT_LIST(0,0)\n    <empty list>\n  FUN(0,50)\n    PsiElement(fun)('fun')(0,3)\n    PsiWhiteSpace(' ')(3,4)\n    PsiElement(IDENTIFIER)('foo')(4,7)\n    VALUE_PARAMETER_LIST(7,22)\n      PsiElement(LPAR)('(')(7,8)\n      VALUE_PARAMETER(8,21)\n        PsiElement(IDENTIFIER)('text')(8,12)\n        PsiElement(COLON)(':')(12,13)\n        PsiWhiteSpace(' ')(13,14)\n        TYPE_REFERENCE(14,21)\n          NULLABLE_TYPE(14,21)\n            USER_TYPE(14,20)\n              REFERENCE_EXPRESSION(14,20)\n                PsiElement(IDENTIFIER)('String')(14,20)\n            PsiElement(QUEST)('?')(20,21)\n      PsiElement(RPAR)(')')(21,22)\n    PsiWhiteSpace(' ')(22,23)\n    BLOCK(23,50)\n      PsiElement(LBRACE)('{')(23,24)\n      PsiWhiteSpace('\\n    ')(24,29)\n      DOT_QUALIFIED_EXPRESSION(29,48)\n        SAFE_ACCESS_EXPRESSION(29,41)\n          REFERENCE_EXPRESSION(29,33)\n            PsiElement(IDENTIFIER)('text')(29,33)\n          PsiElement(SAFE_ACCESS)('?.')(33,35)\n          CALL_EXPRESSION(35,41)\n            REFERENCE_EXPRESSION(35,37)\n              PsiElement(IDENTIFIER)('to')(35,37)\n            VALUE_ARGUMENT_LIST(37,41)\n              PsiElement(LPAR)('(')(37,38)\n              VALUE_ARGUMENT(38,40)\n                STRING_TEMPLATE(38,40)\n                  PsiElement(OPEN_QUOTE)('\"')(38,39)\n                  PsiElement(CLOSING_QUOTE)('\"')(39,40)\n              PsiElement(RPAR)(')')(40,41)\n        PsiElement(DOT)('.')(41,42)\n        CALL_EXPRESSION(42,48)\n          REFERENCE_EXPRESSION(42,44)\n            PsiElement(IDENTIFIER)('to')(42,44)\n          VALUE_ARGUMENT_LIST(44,48)\n            PsiElement(LPAR)('(')(44,45)\n            VALUE_ARGUMENT(45,47)\n              STRING_TEMPLATE(45,47)\n                PsiElement(OPEN_QUOTE)('\"')(45,46)\n                PsiElement(CLOSING_QUOTE)('\"')(46,47)\n            PsiElement(RPAR)(')')(47,48)\n      PsiWhiteSpace('\\n')(48,49)\n      PsiElement(RBRACE)('}')(49,50)\n  PsiWhiteSpace('\\n')(50,51)\n. Fix it but it seems not best idea. Could you give me suggestion how to resolve this issue?\n. Sorry accidentally hit close button.\n. Thanks. I will take a look.\n. What would be the expected solution for this issue?\n. Thanks. I misunderstand the word \"bound\".\ndata class DC<T : Int>(val x: T, val y: String)\ndata class DC<T>(val x: T, val y: String)\nLet me work on this, too.\n. Do you think idea/testData/stringgenerator is good name of test data\ndirectory? I could not come up better name for this new unit test.\n2016\u5e749\u670822\u65e5(\u6728) 20:03 Mikhail Glukhikh notifications@github.com:\n\nMostly everything is Ok, so thank you. I added some notes into your code.\nPlease do the requested changes, and I integrate them into master.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/958#issuecomment-248871076, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ADgVQsOm_UBtXu5YC1RKLF2rm6ZRKNrCks5qsmB2gaJpZM4KDpxV\n.\n. OK, I will fix these asap.\n\n2016\u5e749\u670822\u65e5(\u6728) 20:32 Mikhail Glukhikh notifications@github.com:\n\nMay be concatenatedStringGenerator would be a bit better.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/958#issuecomment-248877898, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ADgVQkxtppG12YFmSH84mhc8cX_yXlVNks5qsmdpgaJpZM4KDpxV\n.\n. OK, Thanks. If you don't mind I can squash the commits?\n. testNewLine's .result file has space after 1. The auto code format trims the space.\n. Thanks both of you guys, @mglukhikh and @cypressious \n. Could you explain why I could not create Intention's test cases for Maps?\n. Got it. Thanks for explanation! \n. Implemented it.\n. @yole \n\nDo you think other surrounding functions can be kotlin-style? If so, I will do what you suggested. I wasn't too sure that they can be kotlin-style or not.\nAt this point, if, if/else, { }, and try's, are the one that can use the new helper. If the following code is the target codes\nkotlin\n        val foo = bar()\n        println(foo)\nthen, new helper will generate\nif\nkotlin\n        val foo = if (<caret>) {\n            bar()\n        }\n        println(foo)\nif/else\nkotlin\n        val foo = if (<caret>) {\n            bar()\n        } else {\n        }\n        println(foo)\n{ }\nkotlin\n        val foo = run {\n            bar()\n        }\n        println(foo)\nIs this sounds good for you?\n. Implemented it. Could you review this PR, again?\n. Sorry not to mention this but I think this pull request is ready for re-review.\n. Thanks for reviewing. I fixed them.\n. Oh...I see. I thought you guys want to remove all mutable collections for platform types.\nLet me figure out how to fix this.\n. Here is the line that detects Collections.unmodifiableList(listOf(1)) is MutableList.\nhttps://github.com/shiraji/kotlin/blob/a77b9747c228183c197506744bbf9b4effeac4c6/idea/src/org/jetbrains/kotlin/idea/intentions/RemoveRedundantCallsOfConversionMethodsIntention.kt#L74\nI have no idea how to figure out if the element is platform type or not. Do you have any suggestion?\n. Thanks!\n. By the way, how did you find this problem? I don't even notice this until I write Collections.unmodifiableList(listOf(1))\n. Good catch. Thanks a lot of your help! Your contribution amazes me a lot.\n. I think I fixed the code for platform type. I'm not sure for \"defensive copy\" part.\n. Thanks!\n. Yea, but it's still easy to add it back.. Nice. I really wanna know how you can do that. I'll take a look the code. Thanks!. Thanks. I checked your code. It's very nice. No worry for late. I know these days are busiest days in the year. . Done. Thanks for pointing them. \nAt the first I was thinking a quick fix (removing the whole expression) and notice there are so many ways to fix the expressions. As @cypressious https://github.com/JetBrains/kotlin/pull/1000#issuecomment-268977235, I decided not to provide them.. Done for the case that the binary expression is used as an expression.. Thanks and happy new year! . OK, then I would remove the intention for apply(). Then later, we can make it back if someone find a way to implement what @cypressious said https://youtrack.jetbrains.com/issue/KT-12183#comment=27-1866609 . What do you think?\nI mean it could be simple since most check have been done. Just add another check that the first statement is assignment of the receiver.. I have done a lot of changes here. Could you review this PR again, please?. Of course!. Let me work on that.\nAre you suggesting they should all have the same base element type, or create a Util class for delegation?. OK, now ConvertToScopeIntention is the parent of all 3 intentions. . Thanks! And congra to releasing 1.1!!!. Could you check this again please?. I was thinking MakeVisibleFactory is already used for INVISIBLE_MEMBER. https://github.com/shiraji/kotlin/blob/da720bcfc416e31d5286157d93ff109f1197fe42/idea/src/org/jetbrains/kotlin/idea/quickfix/QuickFixRegistrar.kt#L173-L175\nThanks for your help.. Could you review this PR, again?. Got it. Thanks! I will use AbstractKotlinInspection in next time. . Good point. I will add that.. done. Your welcome!. Good catch. Thank a lot! Here is the PR\nhttps://github.com/JetBrains/kotlin/pull/1367. There you go. Thanks!. @mglukhikh Could you review this, again? Thanks. I don't mind closing this PR, however, the word \"It is modifier\" is place holder not actual one. \nAs @semoro and I discussed in slack, the doc will come from other resources and I was told to wait until you guys provide the documentation.. OK, sure. I can do that. Which modifiers do you think reasonable to add descriptions? \nIn the issue https://youtrack.jetbrains.com/issue/KT-9934, someone suggested me use this link http://kotlinlang.org/docs/reference/keyword-reference.html. If this description is good enough, I can add description in the code. But I totally forgot about what I did for this PR. So, give me some time to remember what I did. I believe what I will need to do is adding cases to this line https://github.com/JetBrains/kotlin/pull/1435/files#diff-d9206ebe78be3db8c8e3f9ac8aaac3c0R230 . > leave other keywords for future contributions\nThat's good idea.\n\ndefined in\n\nOK. I will do that.. Hi, @goodwinnk \nNow, I remember what I did. \nDo you really want to remove defined in https://github.com/JetBrains/kotlin/pull/1435/files#diff-63ffa34b0bc6b249f69826b481717bd9R5 ?\nThis is the test case for quick doc of the variable name lateinit, not keyword.. Updated it!. @goodwinnk could you review this PR?. Nice. Thanks for the refactoring!. Thanks! \nCould you create an issue that adds other keywords for future contributors? Like what you guys are doing for adding documentation of standard libraries. https://youtrack.jetbrains.com/issue/KT-20357 ?. @ilya-g Updated it. . Sorry about that. I didn't know how the template works. Let me fix that.\nI'm not going to add more samples in this pull request.\nI think this issue is for new kontributors. I have contributed kotlin a lot. So, if you really want me to add sample code, I would do that in other pull requests. But I really want new kontributors to implement other samples. What do you think?\n  . Sure. Then, let me add coerceAtMost and coerceIn\n. @mglukhikh Finally, it's ready now. Could you review this PR? Thanks. (I squashed the commits). @ilya-g I changed the text. Could you review this again? Thanks in advance.. I changed to use CharArrayUtil\n. I didn't know much about PSI class. I will study more about PSI.\n. This makes code simpler! Thanks.\n. How about trimming both of spaces here and add one leading/trailing space at https://github.com/JetBrains/kotlin/pull/928/files#diff-e4fc5e886f7f1903e7f5f67545e46564R110\n. But then if the string or the comment is empty, user will get \"\"\"  ...\"\"\"\n. Make sense. I will fix this.\n. Ah! That's what I need it. Thanks.\n. I am still not used to use \"extension method\". Thanks for pointing this and giving me a chance to learn this!\n. OK, I will remove both inspections\n. I may misunderstand the role of inspection/intention...Thanks.\n. Thanks! I will refactor them.\n. Could you suggest me the name of abstract class? ReplaceMathMethodsWithCoerceAt? uh...doesn't make sense...\n. Make sense. I will fix these.\n. Ahhh!!! I accidentally paste the test code...I will remove this.\n. Could you explain more detail about unsafe ones?\n. This intention only detects targetClassMap's Type. I don't think the custom toType() is detected by this intention. I don't think this intention should detects custom ones. Do you think this intention find custom one as well?\n. Let me clarify what you suggested here. \nYou say if there is following code\nkotlin\nbar().toCustomType()\nIf bar() return type name is package.name.CustomType and toCustomType()'s return type name is also package.name.CustomType, this inspection detect it as redundant.\nI made targetClassMap because I want this inspection to work for only toType() method we know about. \nYes it actually is much easier to implement that but does it lead false positive?\n. Make sense! Thanks.\n. Let me fix this\n. Let me fix this\n. Make sense. I will change it to INFO\n. OK. I didn't know that. I will add it.\n. Thanks. i will take care of KtSafeQualifiedExpression\n. Isn't this the case that isObjectLiteral() returns false? Anyway, I will add this test case for sure.\n. Added test cases for following cases\n``` kotlin\n// IS_APPLICABLE: false\nobject Foo {\n    fun test() {\n        object {}\n    }\n}\n```\n``` kotlin\n// IS_APPLICABLE: true\nobject Foo {\n    class Bar {}\n}\n. @cypressious do you think this is enough for this inspection/intention?\n. kotlin\nobject Foo {\n    object {}\n}\n```\nThis one is compile error. Should this inspection/intention take care of this case?\n. While it is compile error (Nested class is not allowed here, use 'inner' keyword to make the class inner), it does report as \"Remove empty class body\"\nkotlin\nval foo = object {\n    inner class Foo {}\n}\nThis one without compile error, also report as \"Remove empty class body\"\nI think it should, right?\n. I expected to generate following code\nkotlin\n    class A {\n        fun test() {}\n    }\n    val d = if () {\n        A()\n    }\nI don't think this new line is the problem with this pull request.\nIf I have following case\n``` kotlin\nfun foo() {\n    class A {\n        fun test() {}\n    }\nval d: A = A()</selection>\n\nd.test()\nA()\n\n}\n```\nFor current kotlin plugin converts them into \n``` kotlin\n    class A {\n        fun test() {\n        }\n    }\nval d: A\n\n\nif () {\n    d = A()\n}\n\n```\n. Fixed it\n. Fixed it\n. Split them into 2 methods.\n. Right. I think if there is type declaration, this intention should keep them there.\nkotlin\nval a: kotlin.test.Asserter? = if (<caret>) {\n    null\n}\nThis should be the expected result. I will work on that.\n. Removed this line.\n. Implemented it\n. I think this is quite hard to fix...it's problem with locating dummyFirstStatement and inserting generated statement. I'm not even sure that it is possible to fix this.\n. OK. I will use createExpressionByPattern next time.\n. Typo! Fix this\n. Ah...that seems much simpler to read. Thanks.\n. One thing I wasn't sure about this is the extension method is the only time this happens? I was afraid that there might be other cases that use the receiver\n. Moved type check inside the method.. I could not come up with better solution...do you have any suggestion?. How about this?\nkotlin\nit.annotation.fqName?.let { append(\"@${it.shortName().asString()} \") }. I wasn't too sure which case can be like this format.\nExpression BinaryOperator KtBinaryExpression\nIn case, if there is unexpected syntax, it would break this intention.\n\nI found the current implementation cannot catch this \nlistOf(1,2,3).filter { it.let { it in IntRange(1, 10) } }\nLet me fix this.. > I don't expect there will be distinct samples for each primitive type\nOK, then for the class name, how about ComparableOps? In that case we could add samples that are not coercion (e.g. minOf, maxOf)\nI'm not sure for the package name. Could you add the sample code under sample package? I thought I need to have at least one package. . Do you want to add more sample code for other primitives in this method? @ilya-g . Wow. I didn't know there is such syntax in Kotlin. Let me think about this.. I don't want to add return@forEach in the following case.\nlist(1,2).forEach {\n    <caret>1\n}\nlist(1,2).forEach {\n    return@forEach 1 // this would be compile error\n}\n. @mglukhikh what should I do for this case? Do you want to add return@forEach at the end of lambda or ignore the case?. I'll ping you as soon as this PR is ready.. ",
    "okkero": "Can you elaborate on 'all required declarations'?\n. Alright. So that means this pull request won't be going anywhere until that change is made?\n. Alright. That makes sense. Thank you.\n. ",
    "Gulshan-Professional": "\n. # \n. ",
    "semoro": "There is no existing tests for auto import quick fix, so how I should test it?\n. Resolved testing problems, ready for review\n. @valentinkip Last commit contains bugfix and tests for it.\nPlease check if you covered this scenario, otherwise it will result in ide internal errors\n. Found breaking test, work in progress to fix this problem\n. Fixed all problems, ready for review\n. Working on complex test, to cover possible aspects of KotlinShortNamesCache \n. @mglukhikh \nyou've forgotten to add 'inline' modifier to a function;\nI'am not forgotten, this is an intentional solution, cause we already has quickfix which add inline if reified are present, but it you think that it should add both reified and inline, than ok)\n. Why we must initialize val with external get?\n. This branch contains commits from another PR, please fix it. Merged manually. 5edb872224f9d31d7d379b7504f9e5a9d508ff12\nThanks for your contribution! :blush: . It is possible to check if Java class has mapping to Kotlin using JavaToKotlinClassMap.INSTANCE.mapJavaToKotlin(fqName), and then check if it has similar constant, with such value, then preform conversion. Thank you for the contribution a lot! :slightly_smiling_face: . Thank you for the contribution!. Merged manually, and cherry-picked to 1.1.3\nThank you for the contribution! :slightly_smiling_face: . Thank you for the contribution! :slightly_smiling_face: . Thank you for the contribution!. Merged manually. Thank you!. Merged manually. \nThanks! \ud83d\ude42 \n. Fixed more correctly in #1238. Thank you anyway! \ud83d\ude42 . Thanks! \ud83d\ude42 \n. Sorry for delay. Thanks! \ud83d\ude42 \n. Thank you! \ud83d\ude42 \n. Merged manually. Thanks! \ud83d\ude42 . Thanks! \ud83d\ude42 \n. Thanks! \ud83d\ude42 \n. Sorry for delays. \ud83d\ude42 . Thanks! \ud83d\ude42 \n. Thanks! \ud83d\ude42 Merged manually. . Merged manually. Thanks! \ud83d\ude42 . Such cases can be resolved with something like that: \nkotlin\nwhile (nextLine().also { str = it } != null)\nkotlin\nif (false && 5.also { a = it } == 5). Thanks! \ud83d\ude42 . Accepted manually https://github.com/JetBrains/kotlin/commit/b7fa06cca44a0379e2456dad00236dad8b418aab\nThanks! \ud83d\ude42 \n. @mglukhikh It is required to standardize resolve for different analysis modes in Dokka. Already merged manually: 7e49005bab86ef85ed515d5f6c46ec71d8aaac5c. Thank you for your contribution! \ud83d\ude42 . It is used in if check\nWhich better\nif(x.let{ it != null && ........................long_check.....................................})\nor\nif(x?.let{  ........................long_check..................................... } ?: false)\n. I should use PsiVariable to cover fields and local variables?\n. SpecialField\n. You should not hard-code all possible constants.\n. Better not to hack this check, but fix problem with operandConverted.isNullable == false for null literal  . It's better to calculate ordinal with val ordinal = element.containingClassOrObject?.run { getChildrenOfType<KtEnumEntry>().indexOf(element) }. Please extract variable to deduplicate this code. I'd use when for readability . I'd extracted selector to a variable, then smart-cast on line 54 will calculate properly.. Please, write out these numbers in hex, if input in hex. . I'd named this function isKeepBinaryExpressionParenthesized. I'd used let here. Will be \nString a = b + \n           c;\nparenthesized then? \nPlease add such test anyway. . L is missing after conversion, so result type of l4 would be Int instead of Long. Not sure that it nice to silently drop the comment. \nIt's better to place it after comment for declaration where default parameters inferred now.. I think that's here should be a better way. \nBetter to move such code may be to type converter or so. \nBecause it looks like something similar required here #1200. It will not work when there are some operators around the expression.\nboolean isA();\nvoid foo() {\n foo(!isA())\n}\nvoid foo(boolean isA);\nAnd when property used not in default value for clash position\nboolean isA();\nvoid foo() {\n foo(false, isA())\n}\nvoid foo(boolean isA, boolean isB);\n. Please fix it and add to test case \ud83d\ude42 . Please, extract fqName to variable to reduce safe-call count. Cool!. This toInt calls are redundant. \nIt should be possible to not generate it after 2be27d53800c56e2555d75420336904fe02161a8\nPlease, merge the latest master, and try to work around it.. Is it possible to check if cast required in getOperandExpectedType? \nAnd pass correct expected type, to let CodeConverter.convertExpression handle type conversions. Yep, Now toInt added only while converting literal, but it's not sufficient:\npublic class TestArithmWithChars {\n    public int foo(char x) {\n        return '0' >> x;\n    }\n}\nConverted to: \nclass TestArithmWithChars {\n    fun foo(x: Char): Int {\n        return '0'.toInt() shr x //.toInt missing\n    }\n}\nThis problem caused by incorrect type passed to CodeConverter.convertExpresionCodeConverter.kt:97\nThis type incorrectly computed in ExpressionConverter.visitBinaryExpression ExpressionConverter.kt:113\nIf you fix it, literal case will fix automatically. I'll rebase it myself on merging, thanks! Will review again on days . [http://kotlinlang.org] is not a link according to Markdown spec\nBut [Kotlin](http://kotlinlang.org) is actually an inline link . Isn't it better to create valid AST here? Via MethodCallExpression, TypeCastExpression and so on?. Looks like prototype should be assigned here, instead of type-cast . ",
    "grandstaish": "Actually I'm wrong about this, so closing the PR for now. \n. Closing as this appears to have been fixed. @yanex Removing this offset fixes https://youtrack.jetbrains.com/issue/KT-15024, but I'm not sure exactly what the offset was for in the first place. Could you let me know what it's for and I can update this PR if needed. I have included a static method in the test and it still works fine. . ",
    "dnpetrov": "Please, provide some tests\nSimple functional tests for JVM code generation are added as files under compiler/testData/codegen/box. \"Box\" test should define fun box(): String that should return \"OK\" if everything is correct (or return any other value / throw an exception otherwise).\nAfter that, use \"Generate Tests\" run configuration in Kotlin project.\nFor example, the following test fails after your changes:\n```\n// WITH_RUNTIME\nfun box(): String {\n    var x = 0\n    assert(++x in 1 .. 1)\n    return \"OK\"\n}\n```\n. > Can such expressions (reference/constants wrapped in StackValue$Expression) actually have side effects or it's safe to check for it in StackValue$Expression constructor when deciding if it can have side effects? Should it be supported in StackValue$Expression then?\nYes, but, frankly speaking, it is legacy code.\nOur current plan for JVM back-end is to build a new version on top of the IR-based infrastructure. This resolves most of our current architectural issues: very limited code reuse between back-ends, poor separation of concerns leading to leaking abstractions (such as StackValues with possible side effects), and so on. We want to develop some more back-ends for Kotlin (native comes first, Jack and Web Assembly are close candidates for the next), and the existing framework is not well-suited for this.\nBoth IR and new JVM BE are currently in active development and are about to appear in 1.2 and, most likely, replace existing JVM BE in 1.3.\n. Pushed to master. Thanks!\n. This test fails:\n```\n// WITH_RUNTIME\nfun useBoxedChar(ch: Char?) = ch!!\nfun box(): String {\n    var s = \"\"\n    for (ch: Char? in \"OK\") {\n        s += useBoxedChar(ch)\n    }\nreturn s\n\n}\n```\n. Yes, that would do the trick.\n. This test fails:\n```\n// WITH_RUNTIME\nfun box(): String {\n    var clist = listOf('1', '2', '3', '4')\n    var res1 = \"\"\n    for (ch in clist) {\n        res1 += ch\n        clist = listOf()\n    }\nvar s = \"1234\"\nvar res2 = \"\"\nfor (ch in s) {\n    res2 += ch\n    s = \"\"\n}\n\nreturn if (res1 == res2) \"OK\" else \"'$res1' != '$res2'\"\n\n}\n```\nException:\njava.lang.StringIndexOutOfBoundsException: String index out of range: 1\n    at java.lang.String.charAt(String.java:686)\n    at ForInStringLocalVarKt.box(forInStringLocalVar.kt:13)\n. Looks almost ok. I'll make some order in RangeCodegenUtil functions and push it to master.\n. Pushed to master, backported to 1.0.5.\n. Closing as obsolete.. Note that lack of until in indices doesn't really cause much hassle, because indices itself is treated as a compiler intrinsic where appropriate. Still, yes, it's a good idea to run ReplaceRangeToWithUntil on stdlib sources.. Rebased & pushed manually. Thanks!. Merged manually, thanks!. Pushed to master.. I think it should be ok in short-term. \nIdeally this should be done as an IR lowering pass, somewhat similar to BridgeLowering in org.jetbrains.kotlin.backend.jvm.lower, with CollectionStubMethodGenerator#computeTasksToGenerate logic reimplemented using IR declarations instead of descriptors.. We are going to rework origin to make it more suitable for actual use-cases.\nOther than that, it's Ok to make the property mutable for now.. LHS should also be non-null. Use TypeUtils.isNullableType to check that type is (non-)nullable (it implements detailed check for a possibly parameterized type).\nThe following test should pass:\n```\nenum class Test { A, B }\nfun eq(x: Test?, y: Test) = x == y\nfun box() = if (!eq(null, A)) \"OK\" else \"Fail\"\n``.labelsToReplacecan be aval..insnsToRemovecan be aval.. UsefilterIsInstance.. Minor: I'd rather just useif. I findtakeIf+?.leta bit more convoluted way to say basically the same thing: do something with a value if condition is met.. Minor (code style): replace if-else if-... withwhen`.. Were there any issues with this tests involving constant folding?. This lowering pass adds quite some functionality to the JVM_IR back-end. I'd like to see some test for that.\nIdeally, this should include two kinds of tests:\n1. Box tests - to make sure everything works as expected;\n2. Bytecode tests - to make sure that constant expressions are, indeed, folded.\nLook into compiler/testData/codegen/box and compiler/testData/codegen/bytecodeText.\nPay attention to tests that can cause exceptions - e.g., division by zero.\nfun test1() = 1 / 0 // ArithmeticException at run-time\nfun test2() = 1.0 / 0.0 // Infinity\nAlso make sure that floating-point number comparisons work fine with respect to IEEE754 vs total order (various \"special\" numbers such as -0.0 and java.lang.Double.NaN).\n. BlackBoxCodegenTestGenerated$PrimitiveTypes.testKt2269 fails: \nUnresolved reference: toInt (4,27) in /kt2269.kt. ",
    "qwwdfsad": "I will add tests, thank you for spotting the problem and for explanation how to test code generation!\nI've found the root cause: it's not always possible to just load value from StackValue twice as it can have side effects~~, so maybe it's worth trying to have two paths for code generation~~.\nSadly, for expression x in 1..2 x is StackValue$Expression (REFERENCE_EXPRESSION), which always has canHaveSideEffects=true. Moreover, even for 1 in 1..2 literal 1 is StackValue$Expression (INTEGER_CONSTANT)!\nAnyway, I've end up with implementation of contains which is still as compact as x >= 239 && x <= 250 (and recognized by decompiler as java version) with respect to side effects: I will finish writing tests and verifying that everything is fine and contribute it soon.\nQuestion out of scope of this fix:\nCan such expressions (reference/constants wrapped in StackValue$Expression) actually have side effects or it's safe to check for it in StackValue$Expression constructor when deciding if it can have side effects? Should it be supported in StackValue$Expression then?\n. Thank you for detailed answer!\nTo sum up:\nI've fixed issue with side-effects and also added proper support of !in operator.\nNow both in and !in have smaller byte-code size and are consistent with javac version:\nx in 239..250 and x !in 239..250 are translated to 239 <= x && x <= 250 and 239 > x || x > 250 respectively instead of \nboolean result = true;\nif (x < 239) {\n  result = false;\n}\nboolean result2 = true;\nif (x > 250) {\n  result2 = false;\n}\nreturn result & result2;\nand xoring results with true.\nI've also written JMH benchmark: new versions have the same score as old ones for both C2 and C1 (to somehow 'emulate' android) compilers (but I haven't checked generated assembly).\n. Eh, same problem as in KT-12582, shame to miss it :(\nDon't you mind if I extract logic about loopParameter() from AbstractForInProgressionOrRangeLoopGenerator to AbstractForLoopGenerator? I will not try to refactor ForInArrayLoopGenerator  to use it, but at least will reuse it in StringForLoopGenerator\n. Fixed\n. Fixed. This problem also uncovered KT-14589, but it will be fixed separately\n. Whoa, looks like I've messed with branch, will reopen properly\n. Yup, this one looks better, thanks. By the way, same thing can be done for indexOfAny/lastIndexOfAny which receives array of strings as well. >Would you mind if I squash some commits?\nSure, I don't mind\n\nCould you also share the code of benchmarks?\n\nI was playing with parameters in this one\n```\n@Fork(value = 1)//, jvmArgsAppend = arrayOf(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+DebugNonSafepoints\"))  //, jvmArgsAppend = arrayOf(\"-XX:TieredStopAtLevel=1\"))\n@Measurement(iterations = 10)\n@Warmup(iterations = 10)\n@State(Scope.Benchmark)\n@BenchmarkMode(Mode.Throughput)\n@OutputTimeUnit(TimeUnit.MICROSECONDS)\nopen class SplitBenchmark {\n@Param(\"haystack\")\nlateinit private var haystack: String\n\n@Param(\"a\", \",\")\nlateinit private var needle: String\n\n@Benchmark\nfun splitJava(): List<String> {\n    return (haystack as java.lang.String).split(needle).toList()\n}\n\n@Benchmark\nfun splitKt(): List<String> {\n    return haystack.split(needle)\n}\n\n@Benchmark\nfun splitKtLimit(): List<String> {\n    return haystack.split(needle, limit = 2)\n}\n\n}\n``\n. This test in not related to Range#contains, but at some point I had implementation which passed all tests (without this one), but ant build was failed.\n. note: probably it makes sense to replace it withArrayList(min(limit, 16))`. Why not in both cases?\n10 (not 16 actually) is default array list size in both openjdk and android.\nresult = ArrayList<String>(minOf(limit, 10)) looks simpler than result = if (isLimited) ... else .... Yes. \"0\" indicates that default size should be used. Yes, you're right. Simplified it a bit more, though nextIndex is still unused. It doesn't make any difference (in my small-medium string size benchmarks, though I'm sure it's still possible to show the opposite), but makes code less readable. Point taken, fixed (and simplified again). ",
    "gitreelike": "Thanks, will do that tonight.\n. I had been thinking about the back slash and the dollar and wasn't quite sure how to handle them. Thank you for your input on this. I will change the back slash behaviour and document both with a test. I will also address the familyName.\n. ",
    "takahirom": "@yole Thanks. I will change.\n. @yole \nDone. Please check.\n. I reconsider. If you might want to teach that it is Primitive types of Java to the user, This changes is not good.\n. @mglukhikh \nDone!\n```\nAlso, please add test when super function is called in expression body format:\noverride fun foo() = super.foo()\n```\nProbably test of expression body format is already contained.\nhttps://github.com/JetBrains/kotlin/pull/1242/files#diff-9a733327a84bcf25fd5047bae854a384R7. I fixed conflicts.. Thank you for comments. I can learn it.. I fixed it. But I have a little problem that test failed.\nhttps://github.com/takahirom/kotlin/blob/145ee2c92f909706272922e2f3eab03d64d853ec/idea/testData/intentions/conventionNameCalls/replaceContains/withoutOperatorModifier.kt\nResult:\njava.lang.RuntimeException: java.lang.AssertionError: isAvailable() for class org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention should return false\n\nSo I delete IS_APPLICABLE: false comment. And I created withoutOperatorModifier.kt.after.\nResult:\njava.lang.RuntimeException: org.junit.ComparisonFailure: All actual errors should be mentioned in test data with // ERROR: directive. But no unnecessary errors should be me mentioned \nExpected :<empty>\nActual   :'operator' modifier is required on 'contains' in 'test.Test'\n\nSo I added  // ERROR: 'operator' modifier is required on 'contains' in 'test.Test' to withoutOperatorModifier.kt\nResult:\njava.lang.RuntimeException: org.junit.ComparisonFailure: All actual errors should be mentioned in test data with // ERROR: directive. But no unnecessary errors should be me mentioned \nExpected :'operator' modifier is required on 'contains' in 'test.Test'\nActual   :<empty>\n\nProbably Because of  'operator' modifier is required on 'contains' in 'test.Test' Error is  transformed syntax error by intention.\nDo you have any idea to solve this?\n. I'm thinking about removing test.\n. I removed this test.\nhttps://github.com/takahirom/kotlin/blob/145ee2c92f909706272922e2f3eab03d64d853ec/idea/testData/intentions/conventionNameCalls/replaceContains/withoutOperatorModifier.kt\nPlease check .\n. Done!\n. I don't know it! Thanks :). I can use superCallElement for the argument. I will fix it.. Thanks! I fixed it.. ",
    "miensol": "Is there anything I can do to help resolving the linked issue? I'd love to use the new kapt but this is the first problem I've encountered in one of the projects I'm working on.\n. The 1.0.6 works fine for me. Thanks a lot.. ",
    "nd": "Noticed some failed tests, will fix them and recreate a PR.\n. Thanks, I've updated the patch. Without rules for comment cases \nlabel@    /*comment*/ {\n  ...\n}\ntransformed into\nlabel@ /*comment*/ {\n  ...\n}\nOther tests seem to care about this case.\n. @zarechenskiy please take a look, I hope I got the dataflow/platform types right. Updated it, please take a look. . @mglukhikh sure, will try writing one.. Thanks, updated it, please take a look.. What is easier to review, new commits to this branch or a squashed force-pushed commit with new implementation?. Updated it, please take a look. Thanks! fixed. Reworked it so that RemoveExplicitTypeIntention also handles Unit return type in function with body. Thanks, fixed. Thanks, will try implementing the non-constant case. I should have noticed the formatting issue: in this case it is obviously different from the surrounding code, but in code written from scratch it might be not so obvious. Maybe it is worth suggesting to run 'Reformat code' in the README contributing section... Kotlin plugin started from Idea works correctly, but for some reason test fails to resolve the 'kotlin.jvm.JvmField' class and fails. @mglukhikh do you know why it might happen?. The class defines compareTo(Int), so the code is green, but intention makes it red. Is it too esoteric to detect?. Actually with changed KotlinType.isComparable() test still works. Right, it should be unsafeCallWithImplicitReceiver.kt... I've replaced the RBRACE check as you suggested. Looks like the LBRACE check is still needed: without it the inspection treats all semicolons in enum with no entries as non-redundant, instead of only the first one. Maybe there is a better way to check that there is no declarations before the semicolon?\n. ",
    "keyoffecka": "As the comment to the pull request says, this will make the Kotlin Ant task more flexible, meaning that you will be able to support custom project layouts. Please consider our project layout:\next - bootstrap jars which we cannot fetch automatically from common repositories (this is where your ant jar and preloader are located)\ntool - external tools we run to build the project, this may be pre-processors, source code generators or what so ever (this is where your compiler and reflect jars are located, hopefully we can fetch them from the Net)\nruntime - jars not needed at the compile time but needed at runtime, used to run the application or system\nprovided - jars needed at both compile and runtime but are considered to be a part of a runtime environment or container\ncompile - jars needed at both compile and runtime but are considered to be a part of the application or  system  itself\nYou may consider this project layout good or bad, but this is just one of millions and millions examples of custom layouts that projects other than yours may use.\nThere are more things in heaven and earth, Horatio, \nThan are dreamt of in your philosophy. \n- Hamlet (1.5.167-8), Hamlet to Horatio\n. Don't worry. You may spend another million years discussing whether you need it or not, meanwhile it has already been deployed.\nhttp://search.maven.org/#search%7Cga%7C1%7Ca%3A%22kotlin-ant%22\nBut yes, you are totally right, after the truth about Kotlin comes out, unfortunately, all the made efforts just make no sense any more.\n. ",
    "06needhamt": "@ilya-g I didn't notice it was done already it was marked as unassigned on the issue tracker\n. ",
    "oshai": "Maybe it is just my mistake. I thought that when you added \"by lazy\" it made the comment not relevant. maybe it was just confusing me so you are welcome to just close the PR if its not the case.. ",
    "elizarov": "I'd suggest that in cases like \"a == something\" where a is some modifiable thing the most likely explanation is that it was a typo and a fix is to remove an extra =. Good point. . ",
    "AlexTrask": "Apply your comments, but commit it as 'push -f'. @semoro Thx for your help comment. It will help me apply your review notes. okey, understood your idea. I will apply your comment. ",
    "lukaszwojtow": "Actually, it turns out we need this 'stdin' wrapper as it causes some funny errors otherwise. readLine() needs just read():Int from InputStream but I left others untouched for now.. ",
    "4u7": "@cypressious Thank you, I'll run all tests and merge it.. Thank you! I'll run integration tests and merge your changes. Merged manually. Sorry for late responce.\nCould you please add tests with import import java.lang.String.format? . Thanks for the contribution!. Thanks for the contribution!. Thanks for the contribution!. Merged manually. Thank you!\n\nLooks like now it's better to show warning on the shadowing it reference. \nIt's a bit odd that quickfix tries to rename only it corresponding to enclosing lambda. May be it is \nbetter to rename shadowing it, or even have both quickfixes, what do you think?\nIt would be great to reduce severity of the inspection to weak warning.. Thank you, just a couple of minor notes:\nIf there is more than one it we should highlight all of them, not just the first one\nIt is better to reuse ReplaceItWithExplicitFunctionLiteralParamIntention with IntentionWrapper, it will prevent the second intention which is already there from showing. You may just pass it to registerProblem call like IntentionWrapper(ReplaceItWithExplicitFunctionLiteralParamIntention(), it.containingFile)\n\nAnd a side note, you may test your inspections on Kotlin project itself with Analyze -> Inspect Code, there are lots of interesting cases to check if everything looks good.. Thank you!. i think ?: return will be better. primaryConstructor.valueParameterList?.apply { ShortenReferences.DEFAULT.process(this) }. I think we may check only for a presence of the third one \"android.content.Context\", \"android.util.AttributeSet\", \"int\", since we are using only it, if I understood correctly. I think it could be implemented without light classes, they are pretty heavy and should be avoided if possible \nTry to get everything you need from descriptor\nKotlin\nval classDescriptor = type.constructor.declarationDescriptor as? ClassDescriptor ?: return null\nval constructorParameters = classDescriptor.constructors.forEach {\n    it.valueParameters... // some checking stuff\n}. Try to avoid light classes, some explanation below. I suggest minor refactoring\n```kotlin\nprivate fun KotlinType.getFqNameAsString() = constructor.declarationDescriptor?.fqNameUnsafe?.asString()\nprivate fun KotlinType.isAndroidView() = getFqNameAsString() == \"android.view.View\"\n// and we can avoid IdeDescriptorRenderers\n// ...\n    it.valueParameters.map { it.type.getFqNameAsString() }\n// ...\n}\n```\n. Maybe it is worth to make this message more specific, something like \"Implicit parameter 'it' of enclosing lambda is shadowed\" . ",
    "raulraja": "Is this still happening or has this effort been abandoned? \nWe are having issues with the current Script engine impl where it just hangs forever trying to resolve scoped variables.. ",
    "JLLeitschuh": "This looks good. Thanks for updating this @h0tk3y.. Woot!!!!!. All of your comments should be resolved except for the one regarding workspace.xml which I'm not really sure how to solve.. I have no idea about test.ranges.RangeTest. Maybe you have to open that project from within the embedded version of IntelliJ that the project ships with?\nThen you can test it? Not sure.. Thank you all. Great work!. What happened to the Unit test you had before?. @andreyfomenkov Don't coroutines generate methods as well. Do you want to add the @kotlin.Generated annotations to those as well?. Is this PR considered \"complete\".\nReally hoping to see this in a release of Kotlin soon.. > does compiler have a flag for producing debug information so we can disable / enable adding kotlin.Generated?\nPersonally, I think this is a bad idea, but I'm not a Jetbrains dev, so feel free to ignore me.\nAm I correct in reading that you change adds an annotation that is purely a bytecode annotation and doesn't have  a strongly typed representation backing it?. Thanks, will fix those. I knew what I had written didn't sound quite right. COMMAS! . I'm not sure. Do you have a suggestion?. This sound better?\n/*\n * Unfortunately, the FileNotFoundException will only show the relative path in it's exception message.\n * This clarifies the exception by showing the full path.\n */. I would also suggest that you have a check that makes sure that the method hashCode does not have the annotation on it.. > so descriptor retrieved from compiled code are equivalent to descriptors before compilation.\nCan you explain that in a bit more detail?\nAlso, @goodwinnk, wouldn't this information be good to have on the FunctionDescriptor interface to prevent future developers from making the same mistake?. @goodwinnk I agree with your comment, but I'm not sure what the implications are with respect to what you expect @andreyfomenkov to change in this PR.. Kotlin doc? Probably pretty simple. Might be useful information though.. If you want to use the new lazy configuration API, this needs to be configureEach.\nAlso, forEach won't configure new AbstractKotlinCompile tasks that are added later in the build. Is this intentional?. Same problem here as above.. ",
    "Minecrell": "@h0tk3y The error looks like you are attempting to use my test code on Gradle 2.14.1. Defining a task as source directory only works in Gradle 3.2+. For older versions, only regular string/file instances can be used.. @h0tk3y I've checked again and I'm quite sure everything is working as intended on Gradle 2, otherwise the testKotlinExtraJavaSrc integration test wouldn't complete successfully with my changes using Gradle 2.10.\nAs said above, the task dependency as a Java source directory is only supported in Gradle 3.2+ (and doesn't work with only Gradle in older versions either). This PR will only fix the Kotlin tasks to respect the task dependency in newer Gradle versions.. Fixed the conflicts, no functional change otherwise.\n@h0tk3y Any news here? KT-16764 is still broken with Kotlin 1.1.4-3 and Gradle 4.1. The single line change in this PR fixes it and still maintains compatibility with older Gradle versions. What's preventing it from getting merged? Thanks!. @pTalanov Thank you for your comment. Please let me know when there is a patch I can test.. ",
    "fitermay": "@yole Please review at your convinience. Thanks for the review. All of these are indeed problems except for \"getTemplateIfAtLiteral\". I'm pretty sure I'm doing the correct thing there. . That was not the final push. I just pushed it so I could work off another machine. Just finished now, with a few more changes.. @yole Some umerged commits from KT-7848 (Tests for the  TemplateTokenSequence and a fix). A sealed class is a type of enumeration: an enumeration of types. I'm surprised it is controversial. I will convert to intention.. Hi,\nI made the changes but in a slightly different way than suggested. Hope it's ok. @semoro I think this may also impact 1.1.3. This one is intentional.  If the cursor is inside a long entry or short entry we don't want to consider it..  >ok. Good point. Actually, after giving it some thought I don't think it will be a problem because in this case we only care about escape sequences which apply to escaping '$'. ",
    "akkatracker": "@udalov , thanks. I ran a quick search however I find github search is rather ineffective for these kinds of cases. . ",
    "runningcode": "On Android or on projects which require backward compatibility with older sdks, sourceCompatibility is set to 1.7 or 1.8 but the compiled source must not use JDK 1.8 classes. This would cause a runtime crash on older devices on android.. ",
    "sithsupersu": "Couldn't  you also flag compatable classes??... ",
    "uujava": "feature request in youtrack: KT-17637\n. ",
    "jonnyzzz": "My logic was to mimic same behavior as in Java API. I'll update javadoc to\nstate that explicitly.\nDo you think it worth to add the second method or default parameter to\ncontrol interruptability explicitly?\nOn May 2, 2017 18:21, \"ilya-g\" notifications@github.com wrote:\n\nIt's interesting that Lock.withLock() acquires the lock uninterruptibly\nand on the other hand Semaphore.withAcquired acquires the semaphore\ninterruptibly. Is there a reason for this difference besides the default\nmethod is used in each case?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/1062#issuecomment-298685516,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAPpr9ExUdu0MSO49M6_0-M2Kxc6U7Bsks5r11gPgaJpZM4NL-eM\n.\n. \n",
    "zarechenskiy": "Thanks for your PR!\nPlease correct comments and add test to check that there aren't any warnings for error types:\nfun foo() = unresolved\nfun test() {\n  foo() is Any?\n}. LGTM, thanks for your contribution! I'll merge it soon manually.. After internal discussion with @PetukhovVictor, we decided to close this PR.\nFirst, it's a controversial fix as it doesn't fix the actual problem: an intersection of diagnostics. \nSecond, most likely this problem will be revisited soon with upcoming changes of @PetukhovVictor . @dsavvinov I don't have objections too. I'd propose to use one diagnosti\u0441: \nDiagnosticFactory1<KtElement, Boolean> USELESS_IS_CHECK = DiagnosticFactory1.create(WARNING);. Then here:\nMAP.put(USELESS_IS_CHECK, \"Check for instance is always ''{0}''\", TO_STRING);. Note that this isn't correct for platform types (see https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types)\nCurrently there will be warning for case like this:\n// Java\nclass A {\n  static A create() { return null; }\n}\n--\n// Kotlin\nfun test() {\n  A.create() is A // false warning \n}. Also this check doesn't use data flow info:\nfun test(x: Any) {\n  x as String\n  x is String // no warning\n}. Please check method castIsUseless or isKnownToBeNotNull for an example of DataFlowAnalyzer. Maybe method castIsUseless can be expanded to detect redundant is. Can we use here directories/jars/individual files? \nMaybe it's worth to document it somewhere. Maybe it's better to use strong warning here? See CompilerMessageSeverity.STRONG_WARNING. ",
    "jankotek": "I tried again, it builds without / at end.. ",
    "geralt-encore": "Yeah, I know it just didn't update after I amended my commit and I thought that it would be easier just to create a new one.. Thank you for your explanation! I just wasn't sure if it is safe to remove existing intention or not. Let me know if I can add something to the PR.. ",
    "mithunsasidharan": "I've deleted the feature branch/fork but request the change to be considered for review/merge. Thanks!. ",
    "neworld": "Fixed. KEEP_LINE_BREAKS works. Sorry for being late. Please review.. I fixed. Please review.. Updated. I noticed that spaceIf doesn't join lines and other tests start failing, like this one\noutput is:\n```kotlin\n    when\n    (true) {\n}\n\n```\nexpected:\n```kotlin\n    when (true) {\n}\n\n. Make sense. I make `spaceIf()`. Later I will test and fix if needed \"Keep when formatting -> Line breaks\". I would like to try by myself :) But I have bad feeling. For `if` case we are modifying only condition. Likediff\n-if (1 is Boolean) { print() }\n+if (false) { print() }\nbut not whole branch:diff\n-if (1 is Boolean) { print() }\n+\n```\nWhat are you asking is to change whole when. It could be optimized totally:\ndiff\n-when (1) {\n-  is Boolean -> print()\n-}\n+\nand \ndiff\n-when (1) {\n-  is Int -> print()\n-}\n+ print(). ",
    "t-kameyama": "@yole \nI added fix for the original issue.. rebase master. I fixed to check type parameter.. I changed to check type parameters in SpecifyTypeExplicitlyIntention.\nPlease review again.. I will resolve a merge conflict.. I resolved confilicts. Please review.. I fixed. Please review.. I fixed. Please review.. I fixed. Please review.. Fixed. Please review.. Is it not necessary to remove not allowed getter or setter?\nclass Foo {\n    lateinit var str: String\n        get() = \"foo\"\n        set(value) {}\n}. Fixed. Fixed. Added \"Add remaining branches with import\" quick fix. Fixed. @shiraji \nThere is no intention desctiption:\nidea/resources/intentionDescriptions/MoveMemberToTopLevelIntention\nIDE error occured\uff1a\nIntention Description Dir URL is null: Move to top level; MoveMemberToTopLevelIntention [Plugin: org.jetbrains.kotlin]\ncom.intellij.diagnostic.PluginException: Intention Description Dir URL is null: Move to top level; MoveMemberToTopLevelIntention [Plugin: org.jetbrains.kotlin]\n    at com.intellij.codeInsight.intention.impl.config.IntentionActionMetaData.getDirURL(IntentionActionMetaData.java:114)\n    at com.intellij.codeInsight.intention.impl.config.BeforeAfterActionMetaData.getDescription(BeforeAfterActionMetaData.java:151)\n    at com.intellij.codeInsight.intention.impl.config.IntentionManagerSettings.processMetaData(IntentionManagerSettings.java:156)\n    at com.intellij.codeInsight.intention.impl.config.IntentionManagerSettings.registerMetaData(IntentionManagerSettings.java:147)\n    at com.intellij.codeInsight.intention.impl.config.IntentionManagerSettings.registerIntentionMetaData(IntentionManagerSettings.java:65)\n    at com.intellij.codeInsight.intention.impl.config.IntentionManagerImpl.registerIntentionAndMetaData(IntentionManagerImpl.java:145)\n    at com.intellij.codeInsight.intention.impl.config.IntentionManagerImpl.registerIntentionAndMetaData(IntentionManagerImpl.java:122)\n    at com.intellij.codeInsight.intention.impl.config.IntentionManagerImpl.lambda$registerIntentionFromBean$0(IntentionManagerImpl.java:95)\n    at com.intellij.util.concurrency.QueueProcessor.runSafely(QueueProcessor.java:246)\n    at com.intellij.util.Alarm$Request.runSafely(Alarm.java:417)\n    at com.intellij.util.Alarm$Request.access$700(Alarm.java:344)\n    at com.intellij.util.Alarm$Request$1.run(Alarm.java:384)\n    at com.intellij.util.Alarm$Request.run(Alarm.java:395)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at com.intellij.util.concurrency.SchedulingWrapper$MyScheduledFutureTask.run(SchedulingWrapper.java:237)\n    at com.intellij.util.concurrency.BoundedTaskExecutor$2.run(BoundedTaskExecutor.java:212)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n    at java.lang.Thread.run(Thread.java:748)\n. Fixed\n```kotlin\nvar topVar = null\nval topVal = null // no warning\nfun topFun() = null // no warning\nfun test() {\n    var localVar = null\n    val localVal = null // no warning\n    fun localFun() = null // no warning\n}\nopen class OpenTest {\n    open var overridableVar = null\n    open val overridableVal = null\n    open fun overridableFun() = null\nvar notOverridableVar = null\nval notOverridableVal = null // no warning\nfun notOverridableFun() = null // no warning\n\n}\n``. Fixed. Fixed. Please review again.. Fixed. Please review.. Fixed. Please review.. Removed it.. @yole Fixed. Please review.. Fixed. Fixed. Fixed. Fixed. Fixed. Fixed. Fixed. Added test and fixed.. Added fix for https://youtrack.jetbrains.com/issue/KT-24066. Fixed. Fixed. Please take a look.. Added test and fixed description.. @asedunov \nClosed because this issue has already been fixed in #1620. Added test. Fixed. Fixed. Fixed. This PR was merged as a621171.. Fixed. Fixed. Sorry my mistake. This is \"false negative\".. @mglukhikh I replied. Thank you.. Fixed. No, it should be converted. Because it can be reduced unuseless intermediate list creation and looping bymap`. I will fix.\n. Fixed. Fixed. Fixed. Fixed. Fixed. Fixed. There is b0c3461 in master, so I closed this PR. . > Looks like now it's better to show warning on the shadowing it reference.\nOK, I'll fix it.\n\nIt's a bit odd that quickfix tries to rename only it corresponding to enclosing lambda. May be it is\nbetter to rename shadowing it, or even have both quickfixes, what do you think?\n\nI think it's better to have both fixes.\n\nIt would be great to reduce severity of the inspection to weak warning.\n\nOK.\n. I'll try to do.. 3040a2b14597453820f5cce6fd1bd3c264820dfa. I fixed and ran IntentionTestGenerated$ChangeVisibility test.. Fixed. https://github.com/JetBrains/kotlin/commit/8cdf9015387100003d1920bfaf86a40f8a333e8c. I think 0e6cf05 resolves caret issue.. I will send another PR.. Fixed. Fixed. I think the getter and setter checks are needed. This quickfix apply to only lateinit property because the element is got from INAPPLICABLE_LATEINIT_MODIFIER.. Fixed. Fixed. Fixed. Fixed. I think property used in initializer needs to be defined before initializer.\n. Fixed. Fixed. Fixed. Fixed. Fixed. Fixed. Thank you, fixed\n. Stopping condition is line 348. Fixed. Fixed. Fixed. Fixed. Fixed. Fixed. Thank you, I will fix. Fixed. Fixed. Fixed. Also added a fix for property defined in primary constructor.\nkotlin\nclass Test(var foo: Int) {\n    fun test(foo: Int) {\n        <caret>foo = foo\n    }\n}. I will fix.. I think that checking super classes is unnecessary. A class delegation can only use interface and an interface can not inherit from a class.. I fixed and added a test case.. This is not redundant. entries.any {} returns false if entries is empty.. Fixed. Fixed. Please review again.. Fixed. Please review.. [http://kotlinlang.org] is not parsed as MARKDOWN_LINK, but [Kotlin](http://kotlinlang.org) is parsed as MARKDOWN_INLINE_LINK. I think that [Kotlin](http://kotlinlang.org) does not need to be parsed as MARKDOWN_INLINE_LINK like [http://kotlinlang.org].. Fixed. Fixed. If use expression.mainReference.handleElementRename(\"\"), directCompanion.kt test fails.. It is for lambda parameter. If remove || descriptor is ValueParameterDescriptor, following tests fail.\n- defaultParameter.kt\n- it.kt\n- parameter.kt\n- parameter2.kt\n. I added docComment.kt test. isBlockComment() function returns false, if element is KDoc.. CallableBuilder will break format:\nidea/testData/intentions/lambdaToAnonymousFunction/argument.kt\n// expected\nfun test() {\n    foo(fun(it: Int): String { return \"\" })\n}\n// actual\nfun test() {\n    foo(fun(it: Int): String {\n        return \"\"\n    })\n}\nidea/testData/intentions/lambdaToAnonymousFunction/hasComment.kt\n// expected\nfun test() {\n    foo(fun(it: Int): String {\n        // comment1\n        return \"\"\n        // comment2\n    })\n}\n// actual\nfun test() {\n    foo(fun(it: Int): String {\n// comment1\n        return \"\"\n        // comment2\n    })\n}. Deleted this check.. Fixed. Fixed. Added test. I think it can't move. This check returns true if annotation is absent.. I'd add RuntimeException, not java.lang.RuntimeException.. I added check in isApplicableTo(). If type isHashMap, type.isSubtype (map) returns false, so I think that recursive checks is necessary.\n. It also returns false if type isMutableMap.. Why should we not suggest in the avobe case?. Created: https://youtrack.jetbrains.com/issue/KT-26236. It is not necessary, I will remove it.. I think we should not also report when it is assigned by other assignment operators.\nAnd this case too:\nhttps://kotlinlang.org/docs/reference/properties.html#getters-and-setters\nvar stringRepresentation: String\n    get() = this.toString()\n    set(value) {\n        setDataFromString(value) // parses the string and assigns values to other properties\n    }. I will do.. I would like to indent after deleting else block. Without this code, it looks like this:\nbefore\nfun test(x: Boolean) {\n    if (x) {\n        return\n    } else<caret> {\n        foo()\n        bar()\n    }\n}\nafter\nfun test(x: Boolean) {\n    if (x) {\n        return\n    }\n    foo()\n        bar()\n}. I don't understand how to use JavaToKotlinClassMap.isMutable(type: KotlinType). JavaToKotlinClassMap.isMutable(type: KotlinType) returns false when type is ArrayList, HashMap, HashSet.\n. I want to convert \nkotlin\nfun test(list: List<Int>) {\n    list.map { it * 2 }.map { it * 3 }.map { it * 4 }.groupingBy { it }\n}\nto\nkotlin\nfun test(list: List<Int>) {\n    list.asSequence().map { it * 2 }.map { it * 3 }.map { it * 4 }.groupingBy { it }\n}\nnot\nkotlin\nfun test(list: List<Int>) {\n    list.asSequence().map { it * 2 }.map { it * 3 }.map { it * 4 }.toList().groupingBy { it }\n}. context[BindingContext.BACKING_FIELD_REQUIRED, propertyDescriptor] returns true in this case:\nkotlin\nclass Test {\n    var foo = 1\n        get() = 1\n}. I want to report in following case:\nkotlin\n    var foo = 1\n        get() = 1\nI don't want to report in following case:\nkotlin\n    var foo: Int = 1\n        get() = field\nBindingContext.BACKING_FIELD_REQUIRED returns true in both cases, so I do not know how to check property that has backing field reference using BindingContext.BACKING_FIELD_REQUIRED.. Please review https://github.com/JetBrains/kotlin/pull/1784. I'll close this PR.. In ProtectedInFinalInspection, it's called without argument. I want to avoid to generate unnecessary descriptor.. ",
    "vasily-kirichenko": "I cannot run the tests locally, JB rejected my issue on their you track.. I see, thanks.. @yole done.. ",
    "pavlospt": "I see that some have been assigned to it! Should I close this PR or there is a chance it will be merged?. @Alefas thanks for updating! Please take your time :) Appreciate the info!. @Alefas is there any update with this :) ?\n. @Alefas What is weird though is that since Kotlin can support many different types of classes (e.g.: enum sealed data) why have that dialog only support the classic class and enum for example? :) . But you can also write the initial letters of the menu item you want and not just use your mouse or down key.. ",
    "Alefas": "There are lots of chances to have it merged. Sorry for delays, just give me a bit more time before I start working on bunch of pull requests we have now in repo. It's wrong to have so much open PRs, so I'm really sorry and we will try to fix it more or less soon.. > @Alefas is there any update with this :) ?\nOh, sorry, I completely missed it among lots of GitHub notifications (good reason for me to finally read https://blog.github.com/2017-07-18-managing-large-numbers-of-github-notifications/ and fix it). We are debating on it if we want one more item in this dialog, it's already too much and big question if we have a way to solve this usability problem differently. We'll try to solve it somehow before 1.3.20, or accept this PR.. > @Alefas What is weird though is that since Kotlin can support many different types of classes (e.g.: enum sealed data) why have that dialog only support the classic class and enum for example? :)\nTo select right thing in dialog you have to use mouse or press 'down' too many times in some cases. Most common case could be to create just plain file and then to add what you actually need like \"data class\" and so on.\nI have idea to support \"data class Foo\" in name field, that would choose data class template, but it's hardly discoverable to people. Anyway, we will try to investigate it a bit to find proper UX for lots of cases.. > But you can also write the initial letters of the menu item you want and not just use your mouse or down key.\nIn any case I initiated consultation with our UX team, probably they will give us better solution, I just don't know. As a last resort, we can actually add data class, it's not a big deal. I just want to be sure, that we don't have better way to do it.. Merged manually. It's cool, but very hard to maintain (for example, I did yesterday commit to readme.md file). How we can solve it?. Another thing is that for us it's hard to verify change (of course, I can check with google translate, but is it enough?).. @EherSenaw, unfortunately, in any case, we will reject this PR.\nThis work is very valuable and it would be great to find a solution where to put it. I can suggest creating a separate repository, where you will be able to have a synchronous translation with some possible automation with alerts, when some md file is changed in Kotlin repo. Then we can put into our Readme file link to \"Unofficial translation to the Korean language\". \nPlease contact me directly by e-mail (Alexander.Podkhalyuzin@jetbrains.com) to discuss possible solutions. I only want to warn, I'll be on vacation until 2 July.. @EherSenaw I still think it would be good to advertise somehow this work. It can't be official as I said already, however, it can be \"unofficial\" with the possibility for you and others to maintain this work. . Merged manually.. Merged manually. This PR is rejected as people have to use groovyScript to join to String as the actually need. Similar to methodParameters() in java.. Merged for now, thanks for the PR.\nActual fix will be added a bit later. I hope we would better to properly fix it by removing copy/paste rather than copypasting fix from the platform. The reason was in cutting dependencies for CLion. We need to refactor things in the platform to be able to reach this code.. Merged manually.. Please remove changes in non-md files.. Please remove changes in non-md files.. ",
    "khud": "Found a suitable way to get expression from psiFile. It looks strait-forward, but correct. Any other suggestions?. What is wrong with KotlinType::toString()? Do we really need all machinery with DescriptorRenderer.renderType?. @udalov good point.  @ligee Done. FQ_NAMES_IN_TYPES seems to be more robust solution. I believe that to pass an instance of DescriptorRenderer as argument (with default value) is too much for any reasonable case.  Isn't it? I didn't try to implement simple code completion in my shell (like Scala REPL/Spark Shell can do) yet.. Partially done, but not yet. Need some time to check.. ",
    "MRohit": "Accidentally created a pull request. ",
    "Dimach": "Done. I also merge with latest changes from repo.. Done.. I improved new lines recognition (diff you can see in orWithNewLine.kt) but i not fix problem with \"end of line comments\" that produce spare newlines in this PR, its different task as i think.. Done.. I dont know  how to write tests in this case because if i run test on code with unstable chain like this \n```\nfun main(args: Array) {\n    val a: Testtt? = Testtt()\n    if (a?.a != null && a?.a.a != null) {\n}\n\n}\nclass Testtt {\n    val a: Testtt? = null\n        get() = field\n}\n``\ncompiler throws a error\n\"Smart cast to Testtt is impossible, because 'a.a' is a property that has open or custom \n getter\".\n  What i must do in this case?. If i modify last check toa?.a?.a != nullcode will compile, yes, but it didnt test code that checking stability of expression because i explicitly check that is right part of expression is dot, safecall and !! makes intention applicablegetDuplicates(lte, rte)?.parent as? KtDotQualifiedExpression != null`. Ok, thanks for tip.. I use reformat code action (alt+shift+l) so idea format my changes and all file. I can remove all format changes from PR if you want.. You write comment to proper file? I dont see any problem here. Maybe you mean kt-17379.kt?. ",
    "MGaetan89": "Right. I just quickly read the notification, without thinking too much about it.\nI'll check this as soon as I can.. I'm using the same sample for every kind of Array. Do you prefer a dedicated sample for each kind? Or would it be too much?. @ilya-g I've remove all this == null checks, and made nullIfEmpty() extension available only on non-nullable CharSequence and String.. Is there something else to do for this to get merged?. You're right. I mixed it with the String/CharSequence implementation.\nShould I unify both to apply on non-nullable type?\nI will also revert the formatting changes.. Nice catch. I updated the code.. ",
    "pun-ky": "Adding these methods is surprising for me because Kotlin rather encourages to use non-null types so that having that methods seems for me a little bit not a way to go \ud83d\ude09. Seems legit \ud83d\udc4d especially when ifEmpty is accepting value provider / lambda. Cool! . waiting for release. looks good \ud83d\udc4d \nfor me it is a showstopper. without it I cannot apply task configuration avoidance in my builds having Kotlin code being compiled.. ",
    "eskatos": "Closing in favor of: https://github.com/gradle/gradle/issues/2382. ",
    "tommykw": "Sorry, I mistook the operation of rebase. I will remake a PR. PR: https://github.com/JetBrains/kotlin/pull/1256. Fixed. Please review.. Thanks! Could you check this PR, again?. Thank you for the review. I will try to fix samples.. Please take another look.. Thank you for the review, please take a look.. Done. Thank you for the review, please take a look.. Thank you for your review. Could you review this, again?. Thank you for the review, please take a look.. Sorry for the late, it seems difficult for me to convert it to inspection.. Thank you for your review. Could you review this, again?. Thank you for your review. Could you review this, again?. Done. Thank you for pointing them.. @mglukhikh Sorry for the late reply. I'm going to fix it.. Thank you for your review. Could you review this, again?\n. Thank you for your review. Could you review this, again?. Thank you for the review. Could you review this PR, again?. Fixed. Fixed. Fixed. I will fix about this comment. I will fix about this comment. Fixed about this comment. Fixed about this comment. Fixed about this comment. Thanks! I will try it. I'm sure. Fixed. > Backticks can also be used to enclose identifiers containing spaces and other characters not allowed in Java identifiers. In this case they must not be highlighted as redundant.\nI fixed about identifiers containing spaces, but I'm not sure that how to fix about other characters not allowed in Java identifiers. Please help me how can i fix it?\n@yole . Fixed. Fixed. Fixed. Thanks, will fix.. Thanks, fixed.. Really sorry!! I will try to fix samples.. Thanks, fixed.. Fixed.. Fixed.. I added tests.. I fixed it.. Thanks for your comments and suggestions. It's fixed now. How can I handle the following cases?\nkotlin\nfun test(a: Any, b: Any) =\n        a is Double && b is Double &&\n                a.equals(b) // Here a and b are statically known to be Double.. Fixed.. Thank you.\nI have confirmed that only isEmpty reference is highlighted.\n\n. ",
    "koral--": "In Android Studio it is rendered without any spacing:\n\n. OK, here is the issue: https://youtrack.jetbrains.com/issue/KT-19153. \nHowever, two little questions:\n1. On the page you linked, the 1st overload (using newline in sources) looks like that:\n\nWhile the last one (using space):\n\nIt seems that explicit newline breaks formatting.\nIs it another bug? if so where should it be reported/fixed?\n\nAll other overloads use spaces, shouldn't style be unified?. >  I don't see a newline in the limit parameter in the sources of the first overload (they could be navigated to right from the docs page). Do you?\n\nIndeed there is no newline, sorry, those 2 overloads confused me.\nSo to sum up:\nHere: https://github.com/JetBrains/kotlin/blob/1.1.3/libraries/stdlib/src/kotlin/text/Strings.kt#L1180 is the newline which is stripped in IDE but looks OK on the page: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/split.html#split (the last overload). It is reported as KT-19153.\nHere: https://github.com/JetBrains/kotlin/blob/1.1.3/libraries/stdlib/src/kotlin/text/Strings.kt#L1147 is the space which looks OK in IDE but on the page (first overload), it causes unneeded extra line break: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/split.html#split\nNote that the line above problematic one: https://github.com/JetBrains/kotlin/blob/1.1.3/libraries/stdlib/src/kotlin/text/Strings.kt#L1146 has one more character and is displayed without issues. So the line length seems to be unrelated.\nOn the other hand, only that one overload broken on the page has a blank line and additional text below the last parameter: https://github.com/JetBrains/kotlin/blob/1.1.3/libraries/stdlib/src/kotlin/text/Strings.kt#L1149 may this is the cause?\nBTW shouldn't that text https://github.com/JetBrains/kotlin/blob/1.1.3/libraries/stdlib/src/kotlin/text/Strings.kt#L1149-L1151 be located above parameters?. ",
    "devulex": "Hi! Why is this commit not included in release 1.2.0?\nNow in the release there is only a getTime() method.\npublic external class Date() {\n    public fun getTime(): Double\n}. Thanks!. ",
    "marcphilipp": "Using 2.5 does not help after all.. ",
    "jaredsburrows": "LGTM.. @ilya-g Ah, ok. Thanks for sharing the issue. It will be almost 2 years this month. It has no priority. How can we bump the priority?. @ilya-g I added a vote. I will close for now.. \ud83d\udc4d . ",
    "xiexed": "Optimization now looks better but will not work without appropriate changes in the Platform which are not yet in master (. No more actual. It will be a new version of this change soon.. Actually same things done in 85254838f66d3787d4be93fe9206aeedfa955b70. Pushed into master manually. Should target master branch. Sorry, It was me, I've posted a comment about some similar work done towards this and then I've deleted it.\nYes, this issue is kind of fixed in idea 173, but probably you PR still will be merged in some way. There are some concerns about automatic injections of all java-patterns into Kotlin because there are some known issues about it. So we need some time to decide what is better to do. But anyway thank you for your contribution. \nAnd yes Github is quite ok for discussions.. Merged manually. check  spread operators call *\narrays as single vararg parameter (if it could be distinguished on user side)\ncheck varargs on Java api and probably introduce UVarargExpression. https://github.com/JetBrains/kotlin/commit/f92f85cf3fa12ca542ae882d7c5c5daffc195dfe for more simple changes viewing. merged manually. Merged manually. Merged manually. Updated. But such a strange thing this CallableBuilder, why not convert to string only in asString method to not depend on builder functions call order? And...  hm... what do you think, does it have sense to make a similar language independent builder, and make it a createAddMethodAction parameter?. Probably with when it will be more readable. It is not an easy task, because it uses ChangeMethodSignatureFromUsageFix from Java, which is hardcoded to \"method\". It is possible to extend it of course in Kotlin and reimplement functionality. But it sounds like another task.. Ok. So could I now cherry-pick it to 1.1.4_172-branch? Or what are the relationships between master_172 and 1.1.4_172 now?. Is there a simple way to get FQN of annotation without getResolvedCall() then ?. And what about import aliases then?. Ok. so there is no simple way )). Probably should be unwrapped also as in secondary ones. initializers should be here only for primary constructors. but then there is an ambiguity on who will be the parent of these elements when building tree from down-to-top. and also if in init block there will be something to report then it will be reported number of secondary constructors times. So it is not a good idea to copy initializer blocks.. it will go against the truth, but I agree maybe it is better than just skip it... Ok lets go this way. But can @param:Foo be used anywhere else except primary constructor? for @receiver fixed. But we don't annotate methods nullability... but probably we should of course. > '@param:' annotations could be applied only to primary constructor parameters\nIdea says to me. reformat reverts it back to current state. it is already let with if, isnt?). you mean?\n(uastParent as? UQualifiedReferenceExpression)?.let { if (it.selector == this) return it.receiver }. Updated. actually it has changed behaviour a bit... but probably it is ok. ",
    "paplorinc": "Hey @semoro, would you like me to change anything for this to become accepted?. Sure :). Thanks!. Hey @ilya-g, would you like me to change anything for this to becomes accepted?. @ilya-g, do you need me to change anything else?. > generated test ensure that\n\ngenerated test, ensure that\n\n\nyou have the `Working directory` your IntellJ\n\n\nyou have the `Working directory` in your IntelliJ\n\n\nIf you don't every test\n\nIf you don't, every test. You're explaining the code behavior in a comment.\nThe code you wrote is clear enough in that regard, no need for the comment :). Basically change the test run config from $MODULE_DIR$ to $PROJECT_DIR$, right?\nCould we maybe fix that, instead of explaining, i.e. by setting the JUnit default run config to it?. Hmm, the default seems to be stored in the workspace.xml, as\nxml\n<option name=\"WORKING_DIRECTORY\" value=\"%MODULE_WORKING_DIR%\" />\nChanging that to\nxml\n<option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\nalso solves the problem.\nIs there a way to fix that automatically?. Couldn't find any way to make Random customizable in JavaScript, therefore that variant is left out.. Minor note: the second parameter could probably be generalized to document.charsSequence. Question: how exhaustive is the stopping condition here, i.e. can you imagine a scenario where this would cause a stack overflow or a NPE at line 350?. No, just questions :)\nMaybe we can ask someone from the IntelliJ team on whether it can be fixed properly.. A lot better, you're explaining the reason for the change, not the code itself! :). asserts are usually disabled in production. But even if they are not, this will throw an exception, if not met, so it's basically the same as a stack overflow, right?\njava\n/**\n * Throws an [AssertionError] if the [value] is false\n * and runtime assertions have been enabled on the JVM using the *-ea* JVM option.\n */\n@kotlin.internal.InlineOnly\npublic inline fun assert(value: Boolean) {\n    assert(value) { \"Assertion failed\" }\n}. you may want to put this assertion inside the method, to make it self-validating. Some questions:\n does this work for more than 2 lines, e.g. \nkotlin\nval s = \"one\"\n+ \", two\"\n+ \", three\"\n does it work for non-strings, e.g.\njava\nval s = \"x=\" +\n0. should the caret maybe placed to the same place, i.e.\nkotlin\n\"foo<caret>bar\". Thanks. should I eliminate the ending cast also?. Thanks, done.\nNot sure how to test this exactly, any help would be appreciated! :). Sure, thanks!. Thanks, changed it to 0..array.lastIndex. Fixed with a private method instead, thanks!. Thanks @konsoletyper, that's exactly what I changed it to :). Sure thing @semoro, doing it now! :)\nHow do I know where the toInt is needed currently, as it seems the comparisons and the minus method don't need it, the rest does?\n. Done. Thanks @semoro for your patience, was very busy lately.\nLet me see what I can do here :). Hey @semoro, I'm not exactly sure what you're requesting, could you help me out?. @semoro, excellent finding, you're right, I didn't consider all permutations.\nThe same applies for non-literals on the left side.. Fixed, you were right, the fix should have been in getOperandExpectedType instead.\nI like this version a lot better than the original, thanks again for the hints @semoro! :)\nI pushed the new version, would you like me to rebase the changes so that it doesn't contain the wrong modifications?. should I make them inline, too?. duck typing would be nice here, since Sequence is not Iterable. This is what I meant:\nprintln(Int.MIN_VALUE == -Int.MIN_VALUE)\ntrue. I think it was needed a year ago, when I did the PR. ",
    "gildor": "Additional note. I didn't update README of the project, because not sure that Kotlin team wants to push such approach to contributors, but it should be useful in some cases.\nBut I would happy to add note to readme about alternative way to set JDKs. Autodetection doesn't work for my JDKs installed through sdkman on Mac\nOkay, I will update Readme. Added Readme note and rebased. Why is this annotation is a part of runtime.jvm? And if it supposed to be Jvm only, according to existing naming convention it should be JvmGenerated instead. Huh, you right, interesting.. ",
    "dgrachev28": "I tried to do this in more general way than it had been done before for multiple assignments.\nBut there are still some problems, which I haven't solve yet:\n1. assignments in loops:\njava\nwhile ((str = nextLine()) != null) {}\n2. assignments which shouldn't be executed:\njava\nif (false && (a = 5) == 5) {}\nThe second one is really subtle because it changes semantics without failing compilation. ",
    "fvasco": "RegExp is your friend ;)\n0\\.\\.\\w+ - 1\n\nYou can find something like:\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\nand many others. Hi @ilya-g\nI found the same issue in 1.1.60, a slightly different version.\nMethods are:\n\nIterable.drop(Int)\nList.takeLast(Int)\n\nUpdated regexp: \\w+\\s*\\.\\.\\s*\\w+\\s*-\\s*1. ",
    "nguyenhuy": "@yayaa  Thanks for submitting this! We're hitting the same problems described above. In our case, the only strategy that works is \"out-of-process\". Thus, our CI gradle command includes --no-daemon -Dkotlin.compiler.execution.strategy=\"out-of-process\" -Dorg.gradle.daemon=true. \nPer the code here, both-Dkotlin.compiler.execution.strategy=\"out-of-process\" and -Dorg.gradle.daemon=true are needed to force Kapt to compile in a separate process. \nAs mentioned in Gradle documentation here, --no-daemon has a higher precedence over org.gradle.daemon, so the gradle daemon is not used, which is recommended for CI environments. (Well, to be 100% correct, a daemon's started at the beginning of the build but stopped at the end)\nAnyways, I generally agree with your fix but have one small question. Is there a better way to detect if the gradle daemon is running? As you can see above, --no-daemon and --daemon options can actually defeat the check for org.gradle.daemon system property in Kapt.. ",
    "yayaa": "Hey @nguyenhuy, \nFrom --no-daemon and org.gradle.daemon clash perspective i totally agree, and i don't know what would be the better way to find it out instead of reading org.gradle.daemon directly. Maybe there is another way to read also --no-daemon request and combine those 2. But again, right now, i don't know.\nThis fix actually in order to cover the loophole caused by default value and fallback value being different. So with this fix, problem might be more visible. And i hope it might take more attention then, because right now, since this loophole exists people might even ignore the real problem by thinking they found a solution. \nI hope we get a quick action on this so we can move further and found a real solution.. Looks like \"ClassLoader\" problem is solved -> https://youtrack.jetbrains.com/issue/KT-20233\nSo it's perfect time to merge this! \ud83d\ude0a Then we can benefit it properly! . ",
    "bamboo": "\\o/. ",
    "jerodsanto": "All good! \u270a. ",
    "abelkov": "@ilya-g Thanks, all fixed. Please have another look.\nIn addition, I removed the inverted insertion point from the last three binary search samples to keep them simple. Also I made the comparator in binarySearchByKeyWithComparator() more interesting to make it sufficiently different from binarySearchBySelector() sample.. @ilya-g Thanks, fixed.\nAlso we forgot to show usage of binary search with boundaries, so I added a separate sample for that.. @ilya-g \n\nGeneral notes:\n\nThis is useful, thanks. Maybe we should put this text inside libraries/stdlib/samples/test/samples/README.md ?. No, I was just browsing through the code :). I'm not an expert, but this is definitely a typo. It's still an UNRESOLVED_REFERENCE, but for a different reason :). @dzharkov Can you please take a look at this?. Thanks! Subsystem owner is currently on vacation, we'll review this soon.. https://youtrack.jetbrains.com/issue/KT-30343. I hope this is what you had in mind for this overload. I had a hard time coming up with an example for some reason :). ",
    "sckm": "Thank you for the review, I'll try to improve samples.. @ilya-g sorry for the late, please take a look.\nIn addition, at some samples like thenBy, a sorting result with comparator before applying the function is added. I hope this helps to understand functions. What do you think about this?. ",
    "Megamiun": "Hello,\nI made the necessary corrections, now I am just rerunning the tests. to verify if everything is alright. When I am certain about my changes, should I create a new PR or is there any way to reopen this one?\nPS: Unfortunately, I am having some problems with running the tests, probably some environment problem, but I am very secure that until this weekend I will probably have already corrected my  environment problems and validated my changes.\nPSS: Sorry for the wait, I put this contribution aside for some time.. You can leave the changes to me, @mglukhikh. No worries. Probably it is best this way, so I can get used more to the IDEA particularities.. Hello,\nTried to do it now. Now the tests don't work anymore because it seems that problems that extends LocalQuickFix doesn't appears on the actions list on tests. My test returned:\njunit.framework.AssertionFailedError: Action with text 'Convert Sealed Sub-class 'SubSeal' to Object' is not available in test InterLanguage\nAvailable actions (12): \nCreate test\nEdit intention settings\nDisable 'Create test'\nMake internal\nEdit intention settings\nDisable 'Make internal'\nMake private\nEdit intention settings\nDisable 'Make private'\nMove 'SubSeal' to separate file\nEdit intention settings\nDisable 'Move declaration to separate file'\nOn my tests on the IDE they all appear:\n\nBut it seems that the tests in the quickfix folder don't take them in consideration. Is there any simple way for me to test this?. Sorry, but I didn't find how to do multifile tests at inspectionLocal. I think there is no way to do that, is there?\nI need to test changes in Kotlin files that caused changes in Java files. I think this is an important test.. If I don't use INFORMATION,  the tests go red saying that only INFORMATION problems can have the word can inside their descriptions. Changed to should.. ",
    "anton-bannykh": "Merged as https://github.com/JetBrains/kotlin/commit/715d5e90ba406d83708fc7ef694e6b9acec30ecc\nSorry for the wait - couldn't merge, because those tests were still being used with TypedArray's disabled up until  https://github.com/JetBrains/kotlin/commit/4a5e9bbc7f2a91f9c1cfb130ba61a6c6d69b6d56. Thanks!. @t-kameyama Thanks!. @t-kameyama Thanks!. Thanks! Will merge manually. Merged as https://github.com/JetBrains/kotlin/commit/f2fec6b07815f9474241fc2588fa08e5d77bc0a1. @soywiz Could you share the use case where the instance check performance was significant (just curious)? :-) Also did you stumble upon any other performance issues? Thanks =). @soywiz Thanks for the info!. @mpetrov Sorry, missed the original notification.  =(\nThank you for the PR, it looks interesting. =) Adding a new module kind requires consideration and might yield some amount of debate, so it might take some time still.. It seems to me that the message is a bit misleading. The important part here is that the code might fail at run time, because the programmer doesn't realize the asDynamic is a member, not the extension function from stdlib s/he might be thinking of.\nSo maybe it should be something along the lines of \"Suspicious 'asDynamic' member invocation\" ? \"Possibly eroneous\"? Something else?\nIn any case I don't think the word \"redundant\" conveys the actual problem properly.. How does this affect unsupported platform users? Will they be unable to run tests? Will they be able to run unrelated tasks, or will Gradle be unable to configure?. It seems to me this won't work in case if a nested package, say package foo.bar\nBefore: testModule.foo.bar, now: testModule[\"foo.bar\"].. If I recall correctly removing globals doesn't really work with Nashorn. At least that was the case at some point and that's why it was being set to undefined instead of being removed.\nAlso does removing globals work correctly in v8? (Just wondering, it probably does, but that's worth checking =)). Also shouldn't it be \"[\\\"$testPackageName\\\"]\" for a simple package (e.g. foo)?. :+1: . ",
    "colriot": "Thanks for the link to the whole strategy.\nI understand that this is a binary incompatible change, but can't this fix be considered for inclusion in a major version change to 2.0?. Got it. Is there any issue tracking this compiler behavior?. Let's leave outputStream as is for now - I don't have a strong need myself, appendText and appendBytes cover my use cases.\nAbout other changes: I wanted to make the code that doesn't repeat itself and uses provided functions instead of explicit Java constructors. Because now different parts of the code that works with streams look inconsistent to each other. Let's clean it up :). Sure thing! Should I squash commits?. Done. I got it. Removed this because use was changed to useLines and the latter has the proper annotation on itself.. Will change it to input.. ",
    "sashache": "Ref: https://youtrack.jetbrains.com/issue/KT-15254. Just for reference: https://youtrack.jetbrains.com/issue/KT-10608#focus=streamItem-27-2861779-0-0. ",
    "sandwwraith": "@alexey-tsvetkov commit message itself tells about \"entry points for compiler plugins\", I've just changed PR title to be more precise. Sorry for misleading. . The reason generateSyntheticClasses uses LazyClassContext is that SyntheticClassOrObjectDescriptor needs it as a constructor argument. Since you don't have to create synthetic classes (I suppose) in generateSyntheticMethods, etc imho it is okay to pass only context to them and there will be no inconsistency.. I've experimented with this some time ago in my branch and this is a valid solution, so I'm ok with this PR. . @Prototik What do you mean under 'full reworking'? In which direction are you trying to move?. In JVM, they are used to generate annotation interfaces synthetic implementation. In JS, they're currently not used (because annotations translated to usual class), but I've made this call to extension for consistency, because it's possible for any extension to declare such classes.. Some errors reported in loadPluginsSafe function:\nhttps://github.com/JetBrains/kotlin/blob/master/compiler/cli/src/org/jetbrains/kotlin/cli/jvm/plugins/PluginCliParser.kt#L43. In most cases, emptyList() is a reasonable default and allows to use existent code without modifications. Personally, I think that such init methods are error-prone because it's easy to forget them. \nHowever, I can see that a lot of descriptor entities in compiler have initialize method so I think it's a preferred code style and your comment is fair.. I wonder if it was tested on strings with non-ASCII characters and surrogate pairs. KOutput does not have type parameters, so I have no idea why it helps here. In general, this seems to be the right approach to fix issue, because KSerializer indeed has type arguments. However, you've created here one typearg T, and if your class will have more than one typearg, e.g. Data<T0, T1>, signature should look like write$Self(KOutput, KSerialClassDesc, KSerializer<T0>, KSerializer<T1>, not ...KSerializer<T>, KSerializer<T>). You can take a look at how createSerializerGetterDescriptor implemented, since it should has almost same signature.. It would be perfect to take type arguments from thisClass instead of creating them in-place, because they should match \u2013 to operate on Data<E,V> we need KSerializer<E> and KSerializer<V>. \nHowever, this might be tricky and requires knowledge of compiler API; to bypass annotation processors/bytecode validators, AFAIK, it is sufficient just to declare them in-place.. From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values : \n\nAlthough most common Unicode values can be represented with one 16-bit number (as expected early on during JavaScript standardization) and fromCharCode() can be used to return a single character for the most common values (i.e., UCS-2 values which are the subset of UTF-16 with the most common characters), in order to deal with ALL legal Unicode values (up to 21 bits), fromCharCode() alone is inadequate. Since the higher code point characters use two (lower value) \"surrogate\" numbers to form a single character, String.fromCodePoint() (part of the ES2015 standard) can be used to return such a pair and thus adequately represent these higher valued characters.\n\nSo I suppose you should use fromCodePoint instead. In Java, as I remember, char code represents also a whole complete char, while code point can be a part of surrogate pair.. However, I just looked up java.lang.String documentation and found that it has separate special constructor for working with code points array. To preserve this semantic in multiplatform code, it's better to leave things without surrogate pairs support. However, we probably need special function for handling code points. @ilya-g what do you think?. OK, than it's better to revert last commit and stick with previously tested version. Sorry for inconvenience.. ",
    "LouisCAD": "@ilya-g Could as well be just a String wrapper that prints its value in toString(), which could be reused in all parts of the stdlib. Cleaner than the enum IMO because the purpose of each object stays where it's used, and not in a god-like place.\n  . ",
    "bendowski": "I'm sorry for being a bit confused by the process :) I got the email below\nbut can't see the comment in neither GitHub nor UpSource. I'm also not sure\nwhere I should leave my comments...\nAnyway: so it seems this has been fixed in in September. Does it mean we\ncan close the bug and count on this change shipping in the next Kotlin\nversion for Android Studio?\nOn 30 November 2017 at 16:10, xiexed notifications@github.com wrote:\n\nalready done. but only for IDEA 173 and should already work with\nreleased Kotlin plugins https://github.com/JetBrains/\nkotlin/pull/1254/files\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/JetBrains/kotlin/pull/1408#issuecomment-348235816,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAD9v442zvYOBvxLzZ9dwI3oM_Wii1-yks5s7tNjgaJpZM4Qtl_6\n.\n. Please let me know if this is the best branch to create a PR against.. \n",
    "devbridie": "Okay! I will convert it to an inspection.. I have converted it to an inspection. This PR should be squashed before merging.. Please see the improvements.. Maybe enabledByDefault=\"false\" should be true? Leaving it up to you.. Related commit: 2a940f5b0a7979d8d0a02a61fc7e620e4a9d9cd8. Updated.. ",
    "keijidosha": "Thanks for your reply.\nI couldn't considered about problems you shown.\nI have created new issue.\nhttps://youtrack.jetbrains.com/issue/KT-21613\nregards,. ",
    "cpovirk": "Thanks! I've updated the generated tests.. We have a version of Guava coming out that uses the Checker Framework declaration annotations, so we're eager to see this go in. Let me know if there's anything else I can do to help things along.. Thanks. I've filed KT-21982.. And thank you!. ",
    "joshfriend": "This is amazing, thank you!. ",
    "Samaritan1011001": "Any update on this pull request? \n. @ilya-g I have made the changes asked for. Please do check it. Also sorry for the late reply. . Done. @ilya-g . @ilya-g Do I need to make other changes?. Are we done here? @ilya-g . ",
    "joscha-alisch": "Thanks for reviewing and happy holidays @goodwinnk, I squashed both commits into one :). Are you sure about that? If I remember correctly from debugging this in the beginning, the behaviour is as follows:\nIf a lambda is inside the brackets, it's part of valueArgumentList:\nfoo( { \"my lambda\" } )\nIf it's outside, it's not in valueArgumentList:\nfoo {\n    \"my lambda\"\n}\nMight be wrong about this though, can't check it right now.. Ah, got it.. Makes perfect sense, thanks :). Nice, makes the whole thing way cleaner :). ",
    "Flamenco": "\nThis is inconsistent with how backspace works\n\nI thought that was fixed in the latest PR.  It works exactly like the single quote case.. When I refactored the code, I narrowed down the parentOfType logic.. I'm not really sure how the import was removed, but I added it back in.. @yole I understand the issue now.  Please let me know if I need to do anything else.. @yole Are we all set with this?  I thought https://github.com/JetBrains/kotlin/pull/1462/commits/4f9af87a28027672302c2ae7a6be98ce12865c33 addressed the remaining issues.. @yole Any chance you can take a look at my last update?. @goodwinnk Thanks.  I look forward to checking out your modifications.  It ended up being more work than I estimated, but I learned much in the process!. Nice to know!  At least I learned about smart pointers... \ud83e\udd47 . I did not see tests for the single quote to base this off of.  My project is not building so I can't run the tests on my end.  Specifically, should the delete test just return:\n<caret> \n  . ",
    "cuihtlauac": "Implemented as requested. FIX https://youtrack.jetbrains.com/issue/KT-22241. Thanks for merging!. Recreated as: https://github.com/JetBrains/kotlin/pull/1489. FIX: KT-22363. Created an issue in jcabi-aether requesting a stable release with proxy support: https://github.com/jcabi/jcabi-aether/issues/101. Recreated as https://github.com/JetBrains/kotlin/pull/1488. FIX: https://youtrack.jetbrains.com/issue/KT-22369. FIX: https://youtrack.jetbrains.com/issue/KT-21047. Replace: https://github.com/JetBrains/kotlin/pull/1481\nFIX: https://youtrack.jetbrains.com/issue/KT-22363. @ligee implemented as requested. Now, the https://oss.sonatype.org/content/repositories/snapshots repository only appears in tools/kotlin-script-util/build.gradle.kts. Replace: https://github.com/JetBrains/kotlin/pull/1478\nFIX: https://youtrack.jetbrains.com/issue/KT-22340. Up to my limited knowledge, the code I'm proposing to replace does not contradict any guideline I'm aware of. To some extend, this is a purely cosmetic change. However, IMHO there's some rationale in making such a change, I've included it in the commit message. Obviously, it was missing.\n. You're absolutely right, updated commit message as requested.. I initially wanted to avoid passing useless parameters at the instantiation call site: dynamicScope, syntheticScope and location do not depend from runResolution(). This makes it explicit that scopeTower functionally depends on each context of resolution.\nOnce done, turning the implementation class into a nameless one seemed a way to stress ImplicitScopeTower is the important thing and actually just a stateless bundle.\nArguably, this is a cosmetic change. Do you think I should reflect this in the commit message?. No problem, this actually make a lot of sense, and helps understanding your approach towards your code base. I will refrain from making such kind of commits in the future. Thanks for taking the time to review my code and provide this kind explanation.. Regarding f, since receiver has a nullable type (i.e. ReceiverValueWithSmartCastInfo?), is it safe to assume receiver != null is equivalent to candidate.requiresExtensionReceiver true?\nIs candidate.requiresExtensionReceiver && receiver != null acceptable ?\n. Gotcha, pushed as requested.. ",
    "sschuberth": "Well, I believe the naming to be good and telling, esp. since I personally have a few other File-related \"safe\" functions. But of course I'm open to suggestions.. @JakeWharton Any rationale for the downvote? Can I improve something?\nEdit: I get the point that mapping null to false is somewhat arbitrary. null is neither false nor true. But in reality mapping null to false is what's needed in most cases and is simply convenient.. Like what? I find\nSystem.getenv(\"foo\").toBoolean()\n\nto be far more readable than e.g.\nSystem.getenv(\"foo\")?.let { it.equals(\"true\", true) } ?: false. True, that's better. Let's see how others think about this.\n\nEdit: After some re-thinking I was tempted to agree with @JakeWharton, but then it occurred to me that the current implementation already maps e.g. the string \"correct\" to false, which seems just as arbitrary as mapping null to false.. I'm withdrawing my proposal in favor of writing the expression as System.getenv(\"foo\")?.toBoolean() == true.. Wouldn't the more appropriate fix be to change the implementation to match the documentation? As I believe the documented behavior also is the behavior most developers would expect.. In this case, I wouldn't regard it as a breaking change (i.e. you're not changing docs & implementation to behave differently than before), but a bug fix to make the implementation match the documentation (and desired behavior).. ",
    "Kerooker": "The project simply doesn't work on my machine, so I gave up. The last error was \"Unexpected lock protocol found in lock file. Expected 1, found 0.\", but previously I had a problem for it being windows with a WindowsRegistry exception of some sort.\nI spent over 6 hours trying to just build the project, so I just gave up helping in any way\n. @pakoito im trying to. :P. I opened another pull request to take care of this.\nhttps://github.com/JetBrains/kotlin/pull/1761. Should be OK now. @udalov \nIs there anything else I should do? :). Should I commit the sources from templates too? I thought that the build process would do it, so I didn't commit the files\n. Maybe create a test that uses Boolean companion object? You could write a failing test right now and see if it works when you make the changes.. Hey, @ilya-g ! I'm trying to make the changes suggested, but I'm having troubles getting Kotlin to compile. Some tests are failing, and I'm unsure on how to test them. Would you mind running tests on my branch? https://github.com/Kerooker/kotlin/tree/companion-object\nI'm having troubles to compile the classes and use them in the tests. @ilya-g I'm digging for the implementatioons, and I found this commit:\nhttps://github.com/JetBrains/kotlin/commit/1f79e0905f3a5bffa6100ac4079f08fc3f1a1098\nI'm going to try to replicate some of that behaviour. Tell me if I'm on the wrong path. Done. I wanted to do that, but it's not possible.\nIn the JVM, both checkRangeBounds(long, long) and checkRangeBounds(ULong, ULong) have the same signature. They'll both have the same name in JVM, and the compiler didn't allow me to do that. I liked your approach more, I'll see if it works. Done.. ",
    "aerovulpe": "@ilya-g Yeah, I think so. I've added the specialized overloads. Thanks :). Thanks Nikolay! I've taken a look at your commit - a lot to learn from there. \nYeah, the single-parameter vararg approach seems ideal and I had considered it; but wasn't sure what performance cost it might have had. I'll also keep an eye out on YouTrack for further requests.\nI'm happy to contribute. Thank you for all the hard work you and your team puts into making Kotlin such an awesome language! . ",
    "neonailol": "realized i attached wrong issue to PR, and did not find something similar in youtrack, created new issue KT-22620 for this pr. @ilya-g thanks for review, changed code accordingly. \nshould i create new PR without merge commit?\nand what about @Ignore annotation, is something wrong here?. @ilya-g i implemented suggested changes\n. @ilya-g is everything ok, or more changes needed?. @ilya-g yes indeed, forgot about this part, in maven it's automatically picked up, but in gradle we need to specify this explicitly . @ilya-g Implemented all requested changes. @ilya-g moved tests to a common module and took implementation from the provided article. Although the article is old, and API for text manipulation no longer in draft state.. @ilya-g made requested changes, removed inline from common expectations, and used copyOfRange. \nNot sure why String(chars: CharArray, offset: Int, length: Int) does not benefit from inlining, but removed this part from declaration. @ilya-g failed to notice the comment about how its generated so I did this by hand.\nAlso, I have troubles with the generator (idl2k)\nmvn exec:java says 'mainClass' is not valid\nAnd code generated by antler missing class WebIDLBaseVisitor. @Schahen I'll try to figure out how to make an idl definitions. I suppose you talking about @Ignore, i believe it was added in latest version 6.13. yes it is. i run ./gradlew kotlin-test:kotlin-test-testng:test and ./gradlew kotlin-test:kotlin-test-testng:test before committing, everything was good. How about this?\nkotlin\nreturn chars.sliceArray(offset until offset + length).joinToString(separator = \"\"). About text specialization, I am not sure how to approach this without coping description, the only thing I found is textWhen method, but with it description looks messy.\n```\n            \"\"\"\n            Returns new array which is a copy of the original array, resized to the given [newSize],\n            truncating or padding with ${textWhen(family == ArraysOfPrimitives) { \"primitive default\" }}${textWhen(family == InvariantArraysOfObjects) { \"null\" }} values if necessary.\n        For all indices that are valid in both the original array and the copy, the two arrays contents will be identical.\n        For all indices that are valid in the copy, but not in the original, the copy will contain ${textWhen(family == ArraysOfPrimitives) { \"primitive default\" }}${textWhen(family == InvariantArraysOfObjects) { \"null\" }} value.\n        \"\"\"\n\n. Ok, I'll add more tests. @sandwwraith well String.fromCharCode does not support surrogate pairs, what can be done then?. I tried that, the following code works for utf8 but not on pairs, seems like I missing something obvious\npublic actual inline fun String(chars: CharArray): String {\n    var result = \"\"\n    var position = 0\n    while (position < chars.size) {\n        if (chars[position].isHighSurrogate() && chars[position + 1].isLowSurrogate()) {\n            result += js(\"String.fromCharCode(chars[position], chars[position + 1])\")\n            position += 2\n        } else {\n            result += js(\"String.fromCharCode(chars[position])\")\n            position += 1\n        }\n    }\n    return result\n}\n```\n@Test fun unicodeCharArrayToString() {\n        val chars: CharArray = charArrayOf('\u0426', '\u5358', '\u8a9e', '\\u016C', '\\uD83C', '\\uDC3A')\n        assertEquals(\"\u0426\u5358\u8a9e\u016c\u138d\ud83c\udc3a\", String(chars))\n        assertEquals(\"\u5358\", String(chars, 1, 1))\n        assertEquals(\"\u016c\u138d\\uD83C\\uDC3A\", String(chars, 3, 3))\n    }. Side note, I tested this code at try.kotlinlang.org with js backend and it works, but when I run tests from gradle it fails, can understand why this is happening \n```\nfun main(args: Array) {\n    println(\"Hello, world!\")\n    val chars: CharArray = charArrayOf('\u0426', '\u5358', '\u8a9e', '\\u016C', '\\uD83C', '\\uDC3A')\n    val c = String1(chars)\n    println(c)\n    println(c == \"\u0426\u5358\u8a9e\u016c\ud83c\udc3a\")\n}\npublic fun String1(chars: CharArray): String {\n    var result = \"\"\n    var position = 0\n    while (position < chars.size) {\n        if (chars.size > position + 1 && chars[position].isHighSurrogate() && chars[position + 1].isLowSurrogate()) {\n            result += js(\"String.fromCharCode(chars[position], chars[position + 1])\")\n            position += 2\n        } else {\n            result += js(\"String.fromCharCode(chars[position])\")\n            position += 1\n        }\n    }\n    return result\n}\n```. @ilya-g Yes, just got lost with these surrogate pairs, reverted last changes, and updated tests. ",
    "mikaelpeltier": "Sorry, I forgot to commit some modified files, I will add them.. This PR was tested by:\n./gradlew dist\n./gradlew jvmCompilerTest\nThe following test failed with my PR but also without, thus it seems not related to my change.\norg.jetbrains.kotlin.jvm.compiler.CompileKotlinAgainstJavaTestGenerated.testListImpl. This PR was tested by:\n./gradlew dist\n./gradlew jvmCompilerTest\nThe following test failed with my PR but also without, thus it seems not related to my change.\norg.jetbrains.kotlin.jvm.compiler.CompileKotlinAgainstJavaTestGenerated.testListImpl. Pushed to master by dnpetrov. This PR was tested by:\n./gradlew dist\n./gradlew jvmCompilerTest. It is perhaps not mandatory, following a discussion with @dnpetrov, I used JVM_TARGET 1.8 to check that my change does not break something with the stack frame generation. Nevertheless, if you estimate that it is not needed, I can move my test into codegen/box and codegen/bytecodeText. \nTell me what you prefer.. Tests moved and PR tested by:\n./gradlew dist\n./gradlew jvmCompilerTest. This PR was tested by:\n./gradlew dist\n./gradlew jvmCompilerTest. Pushed to master by dnpetrov.. This PR was tested by:\n./gradlew dist\n./gradlew jvmCompilerTest. Done, I reformatted the test. Done, I reformatted the test. Done. Done. Done. Done. Indeed it is not needed, removed.. Done. Done. It is mandatory otherwise test testReferToPropertyInCompanionObjectOfInlineClass will failed\nbecause when couldUseDirectAccessToProperty is used all conditions are satisfied but later the code accessing the private property into this test is moved into a class suffixed by $Erased and it is not longer legal to use a direct access if the access is move into another context.. I removed the code and update isCallInsideSameClassAsDeclared which seems a better way to solve the problem.. I removed the code and update isCallInsideSameClassAsDeclared which seems a better way to solve the problem.. 1. Because propertyContainingDeclaration is ClassDescriptor and context.getContextDescriptor() is a FunctionDescriptor and what I want to do is to check if the access is done into the same class than the owner of the property. Moreover propertyContainingDeclaration is the class containing the declaration but not the outer class containing the backed field.\n2. isCallInsideSameClassAsDeclared does not take into account property with backed field into the outer class, the check is done with where the property is declared and not where the property is generated, which is not the same place for a property that has a backed field into the outer class.\nThanks to your comments, I think that the cleaner way is to remove code that I added and to update isCallInsideSameClassAsDeclared to take into account property with backed field.\n. Done. Done. Remove, you are right, the runtime behavior is already check by others tests.. Yes, the test was too complicated as your recommend I split it into several.. fun box() removed. I added the check on GETSTATIC instructions. They are two GETSTATIC, one into the foo method to access LOCAL_PRIVATE and one into the accessors to access OUTER_PRIVATE.. Test deleted. Totally agree with you, it was my first attempt but solving this problem seems intrusive into the compiler, thus I go back to concentrate on the fix for KT-14258. \nMy plan is to file another bug because as you mentioned, I think that the compiler can do again a better job by separating what is did for getter and setter, but it seems easier to work on it in a separate way to avoid to block the resolution of all cases without custom getter and setter.\nOne of the problem comes from the fact that the access to a property will not be always do in the same way, it depends on the context, nevertheless this behavior is not compliant with the usage of accessors map into CodegenContext indeed the key does not take into account if getter or setter accessors are required. . Done. Done. Done. Done. Done. Done. Done. Done. Done. Done. Done. It does not represent the same thing, Type.VOID_Type represents void but this type represent java.lang.Void. I renamed it to VOID_WRAPPER_TYPE to avoid ambiguity as it is done for Boolean and Character.. Support for the Ir backend is removed, due to another bug. It will be add into another PR.. Support for the Ir backend is removed, due to another bug. It will be add into another PR.. Use == as recommended previously, but uses AsmTypes.VOID_WRAPPER_TYPE instead of Type.VOID_TYPE because type that I want to check is java.lang.Void and not void. Done. Done, I only replace 86 by 84 which seems to be the expected number.. Done. Done. Done. Done. Done.. Done. Done. Remove. ",
    "Inego": "How ironic! Done.. ",
    "stigger": "@goodwinnk Done.. @goodwinnk Done. I don't think these changes should be committed.. Is this method still needed?. At this point libraryDescriptors should already contain a descriptor for stdlib.. ",
    "yusaka39": "@ilya-g\nThank you for your review. I updated and squashed the branch.. ",
    "Josh-Allen-ConnectedLab": "@yanex While I can sympathize with why some developers requested that NOTE level messages be logged as WARNINGS, this is not something that should have been done. \nAlthough it may be more convenient for some developers, it is incorrect for the system to do it. For example, turn on  \"treat warnings as errors\", and you will suddenly see red lines that show up in your build output because of NOTE messages from third party libraries. \nAs you mentioned there is already a well documented way to see info level messages: use the --info flag.  Please revert your commit.. Awesome, thanks.\n. @yanex Is there any documentation on the toggle or how to set it? \nNothing is mentioned on the kapt page.\nhttps://kotlinlang.org/docs/reference/kapt.html. @yanex Bump ^^ Is there any documentation on the toggle or how to set it?\nNothing is mentioned on the kapt page or in issue KT-24985. ",
    "KirillMakarov": "I think blank line between true and false statements in output will help, because samples are grouped by true/false. How we can add blank line in samples? Maybe we should add assertPrints(\"\",\"\") between true and false statements? What do you think? . It is easy to fix, but we should choose the best option. Ok, great idea, I will change. ",
    "gzoritchak": "Ok. \nWhen there is quite a lot of functions I tend to keep them in a alphabetic order but as drop and last are so close in their role it make sense to keep them next to the the other.. Yes, it's maybe more clean that way:\nval lotOfNumbers: Iterable<Int> = 1..100. ",
    "GrahamLea": "Note that the @SinceKotlin(\"1.2\") annotations probably need modification, but 1.3 didn't work so looking for advice on what to do there...?. ",
    "elifarley": "I'll change method Int.toBigDecimal() as well, if the current change looks ok.. There's no change in bytecode size, even though they are different.\nHere's the bytecode diff for the getOrPut function:\npatch\n--- getOrPut (Original)\n+++ getOrPut (PR)\n@@ -14,45 +14,45 @@\n     LDC \"defaultValue\"\n     INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V\n    L1\n-    LINENUMBER 279 L1\n+    LINENUMBER 278 L1\n     ALOAD 0\n     ALOAD 1\n     INVOKEINTERFACE java/util/Map.get (Ljava/lang/Object;)Ljava/lang/Object;\n-    ASTORE 4\n+    DUP\n+    IFNULL L2\n+    GOTO L3\n    L2\n-    LINENUMBER 280 L2\n-    ALOAD 4\n-    IFNONNULL L3\n-   L4\n-    LINENUMBER 281 L4\n+    POP\n     ALOAD 2\n     INVOKEINTERFACE kotlin/jvm/functions/Function0.invoke ()Ljava/lang/Object;\n+    ASTORE 4\n+   L4\n+   L5\n+   L6\n+    ALOAD 4\n     ASTORE 5\n-   L5\n-    LINENUMBER 282 L5\n+   L7\n+    LINENUMBER 278 L7\n     ALOAD 0\n     ALOAD 1\n     ALOAD 5\n     INVOKEINTERFACE java/util/Map.put (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n     POP\n-   L6\n-    LINENUMBER 283 L6\n-    ALOAD 5\n-   L7\n-    GOTO L8\n+   L8\n+   L9\n+   L10\n+    LINENUMBER 278 L10\n+   L11\n+    ALOAD 4\n    L3\n-    LINENUMBER 285 L3\n-    ALOAD 4\n-   L9\n-    LINENUMBER 280 L9\n-   L8\n+    LINENUMBER 278 L3\n     ARETURN\n-   L10\n-    LOCALVARIABLE answer Ljava/lang/Object; L5 L7 5\n-    LOCALVARIABLE value Ljava/lang/Object; L2 L10 4\n-    LOCALVARIABLE $receiver Ljava/util/Map; L0 L10 0\n-    LOCALVARIABLE key Ljava/lang/Object; L0 L10 1\n-    LOCALVARIABLE defaultValue Lkotlin/jvm/functions/Function0; L0 L10 2\n-    LOCALVARIABLE $i$f$getOrPut I L0 L10 3\n+   L12\n+    LOCALVARIABLE it Ljava/lang/Object; L7 L9 5\n+    LOCALVARIABLE $i$a$1$also I L7 L9 6\n+    LOCALVARIABLE $receiver Ljava/util/Map; L0 L12 0\n+    LOCALVARIABLE key Ljava/lang/Object; L0 L12 1\n+    LOCALVARIABLE defaultValue Lkotlin/jvm/functions/Function0; L0 L12 2\n+    LOCALVARIABLE $i$f$getOrPut I L0 L12 3\n     MAXSTACK = 3\n-    MAXLOCALS = 6\n+    MAXLOCALS = 7. My conclusion came from these observations from the diff shown on my previous message (which could be wrong, of course).\nPlease note that I decompiled the getOrPut function itself, not a call site of it.\nA) The hunk range information indicates that 45 contextual and deletion hunk lines were present on the original file, and 45 contextual and addition hunk lines are present on the new file:\ndiff\n@@ -14,45 +14,45 @@\nB) The count of added lines (prefixed with +) is the same as the count of deleted lines (prefixed with -):\nbash\ncat /tmp/getorput.diff | grep -o '^+' | wc -l\n27\ncat /tmp/getorput.diff | grep -o '^-' | wc -l\n27\nI can't see a flaw on this reasoning. Can you help me understand where it could be?\nMaybe I should have taken in consideration a call site instead of the function itself, but why?\nThanks!. Sorry, fixed that.. ",
    "fg123": "@mglukhikh I will keep those points in mind for the future, thanks so much for your help! :+1: . @mglukhikh Very sorry, I will be more careful with that next time. I see you already pushed a fix for the newline issue; why is it that running the intention in my runIde editor produces different result from the test? . So I took a look at how other intentions behave, and for class Foo private constructor(x: Int), if you do Make public, it becomes class Foo (x: Int). If I remove the space for this intention, should I do the same on that one too to stay consistent? . Looks like the other intention's issue is in KtPrimaryConstructor.addModifier and KtPrimaryConstructor.removeModifier where they remove the constructor keyword. I added a function instead that will remove keyword and space (and I call that in my intention), but I have not changed the behavior in the other intention because that would require updating a lot of other tests. I will file an bug to the tracker in the meantime (https://youtrack.jetbrains.com/issue/KT-29444).. ",
    "jeis2497052": "Thanks, it didn't look correct to me.\nHTH. ",
    "Miha-x64": "Ideas:\n First part. 'expected' and 'can be' are both not very strong, we may omit one:\n  * Expected performance impact of inlining ''{0}'' is insignificant.\n  * Expecting insignificant performance impact of inlining ''{0}''.\n  * Performance impact of inlining ''{0}'' can be insignificant.\n Second part.\n    * Inlining works best for higher-order functions. \u2014 minimalistic\n    * Inlining works best for functions with functional parameters. (like () -> Unit). \u2014 exemplified\n    * Inlining works best for functions which accept/take/consume functions. \u2014 humanistic, not technical, not sure in terminology. Interesting point...\nUnfortunately, you're right, this doesn't work as I expect:\n```kt\ninline fun eval(func: () -> Unit) {\n    contract {\n        callsInPlace(func, InvocationKind.EXACTLY_ONCE)\n    }\n}\nfun x() {\n    eval(fun() { error(\"\") })\n    println(\"yay!\")\n}\n```. ",
    "katsutomu": "@ilya-g \nFixed review.\nI would appreciate it if you could review again.\n. @ilya-g \nThank you for review.\nI understood that the following is unnecessary.\nAfter excluding the following points,I will request a review again.\n\nassertPrints(\"Hello\".toUpperCase(Locale.ENGLISH), \"HELLO\")\n. \n",
    "jimgoog": "Yep, makes sense.  My original draft actually passed in BindingContext (which is substantially less powerful than LazyClassContext), but then I realized that generateSyntheticClasses was passing in LazyClassContext, so I did the same for consistency.  BindingContext would be perfectly adequate for my use case, as the only thing I do with LazyClassContext is pull off the BindingContext.. Just let me know what you guys decide; I'm happy to update accordingly.. Ok, sounds like you guys are leaning in favor of BindingContext.  PR has been updated accordingly.. cc @erokhins @max-kammerer @romanart . Not sure if this is related (ie. should be in this PR or a followup), but this still fails AFAIK:\nfun Foo(children: () -> Unit) {}\nfun Bar(children: () -> Unit) {\n    Foo {\n        val c = true\n        if (c) {\n            throw RuntimeException()\n        } else {\n            children()\n        }\n    }\n}\n. ",
    "JonahStarling": "Got it. That makes sense. I feel like it should be obvious that it is isNot(NullOrEmpty) but I can see where the confusion would arise.. ",
    "Monchi": "Mistaken. close.. https://youtrack.jetbrains.com/issue/KT-23559. I'm sorry for late reply. I was too busy to work on this.\nWhat should be happen when element.right !as ktBinaryExpression?\nAnd I can't use Generate All Tests due to the bug with Windows. What should I do?. Thank you for your support. I've updated.. Updated. Is this alright?. @mglukhikh I'm sorry i tested without \"Generate All Tests\". Should I fix tests and commit that?. I'm sorry that I mistook the branch. I'm gonna reopen.. Created: https://github.com/JetBrains/kotlin/pull/1888. Updated. I copied that method from AddFunctionToSupertypeFix.kt, so I fixed it too.. ",
    "patrickcousins": "Sounds good @ilya-g Thank you, apologies for jumping the gun, I just wanted to have this is a way to generate the discussion.  Thanks for considering it!. ",
    "kakueki61": "@ilya-g Thank you for your review!\nI changed the templates and generates the code. . ",
    "demiurg906": "sorry, missclick. ",
    "jt-gilkeson": "Test Case:\nval trimmed = SpannableStringBuilder().append(\"SomeText\").append(\"    \").trimEnd()\nsubstring method trimmed is converted to String \nsubSequence preserves trimmed as a Spannable . I think I may have found a bug in this new warning: https://youtrack.jetbrains.com/issue/KT-26027. ",
    "denisvnukov": "Rolled back three lines and rebased. The build seems to be still stable (checked with ~20 iterations). Rolled back. Rolled back. Rolled back. Fixed. OK. Done, also changed the name of the method to getNameForDestructuredParameterOrNull. done. done. done. done. Makes sense, done. Done. Old compare logic relies on the order of the variables which is not guaranteed in the two backends. I rolled back changes in non-ir tests and moved them to ir part as suggested above.. The errors I am getting during compilation look like:\nUNRESOLVED_REFERENCE: Unresolved reference: lineNumber (2,21) in /class.kt\njava.lang.IllegalStateException: UNRESOLVED_REFERENCE: Unresolved reference: lineNumber (2,21) in /class.kt\nI read it as: currently ir backend does not generate kotlin.Metadata annotation and the generated class is not properly loaded. . Done. Right, I thought the common approach is to use automatic disabling tests. \nIf the test gets enabled automatically, It's going to remove this line anyways, right?\nDone. . In implementation method \nprivate fun IrElement.markLineNumber(startOffset: Boolean) {\n        val lineNumber = fileEntry.getLineNumber(if (startOffset) this.startOffset else endOffset) + 1\n        if (lastLineNumber == lineNumber) {\n            return\n        }\n        lastLineNumber = lineNumber\n        mv.visitLineNumber(lineNumber, markNewLabel())\n    }\navoids emitting same line numbers as old backend does, which leads to not all labels getting properly labeled with the line numbers (I am getting \"No line number found for a label\" assertion in readTestFunLineNumbers method).\nThe way I understand debugging information works, all instructions get the last line number introduced in the bytecode. If this is not the case, please suggest how to fix this problem other way.\nNote that removing if (lastLineNumber == lineNumber) { return } leands to too many duplicated line numbers and probably is not the right thing to do.. Done. Done. Done. Noted. Right, it is gone after rebase. Moved. I tried to match the current behavior, but was not able to do so precisely since some code is not exactly relevant to IR (see for example markLineNumberForConstructor). As a result I decided to make sure we match what is reflected in tests and them fix the rest of the cases when we find them.\nIn line #146, for example, primary constructor end offset location location is taken from the class at least in some cases, which leads to weird breakpoints.. Sure, done. Added this to match genFinallyBlockOrGoto(), (see old ExpressionCodegen.java#1537.). I am not sure this is actually hit by any tests. Feel free to remove.. ",
    "FSteitz": "Done... and I broke my branch while doing so. I created a new one and a new PR accordingly: #1654.\nI will close this PR and update the link in the issue tracker.. ",
    "andreyfomenkov": "@sashache just added link to this issue. @JLLeitschuh I found the existing test that perfectly fits into my requirement (only need to add expected annotation). That's why the old one was removed.. @JLLeitschuh Yes, it would be great to add this annotation for other places like coroutines and generated get/set methods for lateinit properties, but in a separate PR. Have plans for that.. @goodwinnk I made some changes:\n- method isGenerated() removed from FunctionDescriptor. Instead added boolean flag argument for FunctionCodegen.generateMethod(...);\n- we should keep kotlin.Generated class because without it annotation processor gives NoClassDefFoundError when running tests on Android;\n- new annotation descriptor added to JvmAnnotationNames in the same way like kotlin.Metadata;\n- added util method WriteAnnotationUtil.writeGeneratedAnnotation(MethodVisitor) to use it here and for similar PRs.\nRegarding disadvantage with bytecode increase - does compiler have a flag for producing debug information so we can disable / enable adding kotlin.Generated? In that case we will not get bytecode increase for release builds when feature is disabled.. @JLLeitschuh yes, now just adding bytecode descriptor. As @goodwinnk mentioned it's enough. But at the same time we're keeping kotlin.Generated class for library to work correctly with annotation processors.. It already has. The test iterates over all methods (even setters/getters) and if method name contains inside Set<> we assume that this method was annotated, otherwise - asserting that method doesn't have kotlin.Generated annotation. This new annotation is consistent with @kotlin.Metadata. You may find it together in the same package.. Good point :+1: Added small comment. ",
    "dschaller": "PTAL @4u7 . PTAL @goodwinnk . PTAL @4u7 . PTAL @goodwinnk . PTAL @4u7 @goodwinnk. PTAL @ligee . PTAL @alexey-tsvetkov @t-kameyama. ",
    "evgzakharov": "Ok.  I've downgraded version of junit to 5.0.0.. So, does it better to move concrete version to library project? \nI have just take the latest version of junit, and forgot to remove versions.junit-platform(it's not longer needed because gradle 4.6 now has native support of junit5). ",
    "Schahen": "@neonailol  as it've been told, this file is generated from and there are some reasons why it's not autocommited. From here we can do one of two things:\n\nYou create *.idl definition and add it to this PR, I'll  explain what would be the next step if we move in this direction.\nIn case you don't have time or interest in supporting this PR further, I'll just create new  one for supporting SVGMaskElement.\n\nBoth of options are totally fine, just let me know which one works for you. . This commit made this PR obsolete. Following commit made this PR irrelevant - https://github.com/JetBrains/kotlin/commit/44da3c89b7047fe65824f91933b05397c3c6670d. I actually agree, so if  @alexander-gorshenev won't have objections - I'll remove pom.xml completely. As of now the only thing that is done there and can not be done in gradle - is exactly invoking\nmaven-deploy-plugin. Removed maven build, made idl2k part of default build lifecycle. @ilya-g  I've finally update this PR with the last thing we've discussed we want to have in it - that is - reading all test data from resources.. Merged as squashed and cherry-picked commit. This will be solved more generally and slightly differently so I'm closing this one. . reviewed by @cy6erGn0m, so I'm merging it.. Hi Martin! Thank you for your PR. Just like it goes with every promising proposal, some things needs to be clarified so that we can move further and see what step makes sense to take next.\nWhen talking of integrating \"with existing codebases using closure libraries and the closure compiler\" can you come up with some example of such integration. It would also be helpful if we can discuss how such integration is achievable with the current state of tools (if it is achievable at all). . @ilya-g  I agree, inverted boolean logic can be confusing. @ilya-g @alexander-gorshenev  should this new property idl2k.deploy be true by default (is not set? ). I suggest to have this step after the code will be refactored so  that there will be no two new lines. The thing is in file it's less obvious that there are two empty lines. . Here are some alternative definitions used in Chromium  and Gecko compared to this PR\nAttribute | Gecko  |Chromium | This PR\n------------ | ------------- | ------------- | -------------\npointerId | long | long | Int\nwidth | long | double | Int\nheight | long | double | Int\npressure | float | float | Double\ntangentialPressure | float | float | Double\ntiltX | long | long | Int \ntiltY | long | long | Int\ntwist | long | long | Int\npointerType | DOMString | DOMString | String (that's fine)\nisPrimary | boolean | boolean | Boolean\n getCoalescedEvents() |  sequence |  sequence | Array\nRegarding this table, I think it worth to discuss following issues:\n\n\nWhere is *.idl definition. Here's how it works - a corresponding idl-definition is created somewhere in libraries/stdlib/js/idl, then you can run gradle idl2k in libraries/tools/idl2k and commit generated files - there's some reasoning behind not having autcommited them. We can discuss step 1b more specifically later, however, the first step is still having idl definitions. \n\n\nI see no reason why we should be more demanding than browser engines, so I suggest to keep float for both pressure and tangentialPressure (as of width and height I think it's fair thing to keep them Int)\n. @ilya-g introduced this change as well. @romanart in that case I'll  have to make it (unlike other flags declared there) public or come up with some contrived  way to pass it to InteropJsTestChecker (who we'll call it btw - I mean ScriptEngineTestChecker sounds slightly off).\n\n\nIf we are ok with this - sure - let me do it. . now it's:\nif (testPackageName !== null) {\n        script += \".$testPackageName\"\n    }. ",
    "pdvrieze": "You are right. I guess it \"works\" because of the way generics works and because the parameters to the serializers are unconstrained.. I have changed the code to take into account your suggestions. It now takes the type parameters of the class and passes them as type parameters for the serializer references for each of the class type parameters. The generated code now actually is conceptually correct, not just \"working\". Probably by accident. I didn't look carefully at koutput. ",
    "lsmaira": "One initial thing I'm not sure about is how to configure the build to publish a new artifact (jar) with the models (kotlin-gradle-plugin-model) so it can be consumed by IDEs, etc. Could you please point me to how to do that?. Rebased PR to fix merge conflicts. Rebased PR on top of master again to resolve import conflicts.. Sure:\n018-06-15 16:33:50,597 [e-1136-b04]  DEBUG - tion.impl.ExecutionManagerImpl -\ncom.intellij.execution.CantRunException: Class 'com.example.lsmaira.myapplication.MainActivity' not found in module 'app'\n    at com.intellij.execution.CantRunException.classNotFound(CantRunException.java:37)\n    at org.jetbrains.kotlin.idea.run.KotlinRunConfiguration$MyJavaCommandLineState.getClasspathType(KotlinRunConfiguration.java:357)\n    at org.jetbrains.kotlin.idea.run.KotlinRunConfiguration$MyJavaCommandLineState.createJavaParameters(KotlinRunConfiguration.java:337)\n    at com.intellij.execution.configurations.JavaCommandLineState.getJavaParameters(JavaCommandLineState.java:33)\n    at com.intellij.execution.impl.DefaultJavaProgramRunner.doExecute(DefaultJavaProgramRunner.java:90)\n    at com.intellij.execution.runners.GenericProgramRunner$execute$$inlined$runProfileStarter$1.executeAsync(GenericProgramRunner.kt:69)\n    at com.intellij.execution.runners.GenericProgramRunnerKt$startRunProfile$$inlined$runProfileStarter$1.executeAsync(GenericProgramRunner.kt:69)\n    at com.intellij.execution.impl.ExecutionManagerKtImpl$startRunProfile$startRunnable$1.run(ExecutionManagerKtImpl.kt:75)\n    at com.intellij.openapi.application.TransactionGuardImpl.runSyncTransaction(TransactionGuardImpl.java:88)\n    at com.intellij.openapi.application.TransactionGuardImpl.lambda$pollQueueLater$0(TransactionGuardImpl.java:74)\n    at com.intellij.openapi.application.impl.LaterInvocator$FlushQueue.doRun$$$capture(LaterInvocator.java:447)\n    at com.intellij.openapi.application.impl.LaterInvocator$FlushQueue.doRun(LaterInvocator.java)\n    at com.intellij.openapi.application.impl.LaterInvocator$FlushQueue.runNextEvent(LaterInvocator.java:431)\n    at com.intellij.openapi.application.impl.LaterInvocator$FlushQueue.run(LaterInvocator.java:415)\n    at java.awt.event.InvocationEvent.dispatch$$$capture(InvocationEvent.java:311)\n    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java)\n    at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:762)\n    at java.awt.EventQueue.access$500(EventQueue.java:98)\n    at java.awt.EventQueue$3.run(EventQueue.java:715)\n    at java.awt.EventQueue$3.run(EventQueue.java:709)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:80)\n    at java.awt.EventQueue.dispatchEvent(EventQueue.java:732)\n    at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.java:815)\n    at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:756)\n    at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:407)\n    at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:201)\n    at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)\n    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)\n    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)\n    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)\n    at java.awt.EventDispatchThread.run(EventDispatchThread.java:82\n. Awesome, thank you!. Cool, thank you. I removed all the *ImplTest which were just testing equality. Done. done. I wrote the interfaces in Java so clients not using Kotlin could still consume the models with no need to add Kotlin-runtime to the classpath (does that make sense?).\nI actually prefer write them in Kotlin as well if you think that is not a problem. Please let me know and I can send a commit refactoring.. Thank you for catching this. Fixed. Done. Thank you for catching this. Cool! Done. ",
    "mnonnenmacher": "@sschuberth: Yes, fixing the implementation would be my preferred fix, too, but I had doubts if it would be accepted as it is a potentially breaking change.. Remove \"the\" from \"if the this string\".. ",
    "juan-chen": "Thanks Nikolay! I've added a commit to fix the minor exception handling issues. Please take a look. . If someone from the JetBrains team could take a look at the PR, that would be appreciated!. Changed to use the elvis operator.Thanks!. Please let me know if more changes are needed. Thanks!. Closing this PR as a84948269c0fe65ceaf7bc48fb190979e560767b fixed the parent class.. Sounds good. I'll make the change.. Sure, I'll handle different kinds of exceptions separately. Thanks!. The separation of reasoning makes sense. Thanks!. ",
    "EherSenaw": "@Alefas ,Thanks for your kind review.\nI and my team had some concerns about that problem.\nWe are also aware of that: your team might not be able to check whether our translation is appropriate or not.\nSo we are going to ask for help in our Korean programmer community group, \"\uc0dd\ud65c\ucf54\ub529\", etc., to get advanced contribute for translating Kotlin readme.md files.\nIn that way, Korean developers' interest would get much higher, and therefore we are visualizing Kotlin's development will go much faster.. Thanks for your review, I will remove changes of non-md files. Thanks.. Thanks, removed non-md changes.. ",
    "akozlova": "@goodwinnk looks feasible. ",
    "vladad": "Thanks Jake for your feedback. I didn't know that and I remember warnings from IntelliJ when zero-length array was used.\nSo I will close this PR.. ",
    "pakoito": "Move the party to #1761. Will I need to write that support myself, or will you take care of it? If it's the former, can you please at least provide some pointers of where to look.. Perfect! And how can I test if the changes have been applied correctly afterwards?. @Kerooker are you working in it? That'd be great and it'll free me up to focus on adding parallelism to arrow-effects :D. ",
    "PetukhovVictor": "Regression testing on all diagnostic tests was successful. The run time is approximately the same.. @dsavvinov, answers to this:\n\n\ud83d\udc4d, in this portion of the tests descriptors are not needed. Fixed. See this comment.\nYes, it's a good idea. I wrote it down, a little later I implement a library with these and other functions and classes for spec tests.\nYes, we thought about it. Later I'll try to add the ability to write related sentences (or paragraphs, or maybe subsections) in the tests meta-information parser. This will allow us to collect test lists even with an indirect relation of language features.\n\nThe remaining suggestions, I will comment a little later.\nThanks for the valuable suggestions!. @dsavvinov, I implement helper files with template functions and classes for diagnostic spec tests. The needed file is included using the corresponding directive (as well as CHECK_TYPE, EXPLICIT_FLEXIBLE_TYPES, etc).\nI implement following helpers:\n- basicTypes.kt\n- classes.kt\n- enumClasses.kt\n- sealedClasses.kt\n- funs.kt\n- objects.kt\n- typeAliases.kt\nCorresponding directives: !WITH_BASIC_TYPES, !WITH_SEALED_CLASSES, etc.\nSee b4049c6f4a9c4c6e29e4ba03f551c1fdcd788bc6 + 4091f4746e387e51c24fad533a4d0b3e0b266cc8.\n. Done!\nSee 7dd0a0fb3566698f9de35bf4f9c29114d38f450b. Good idea.\nIn AbstractDiagnosticsTest already exist similar abstract method \u2014 skipDescriptorsValidation. I just used it in AbstractDiagnosticsTestSpec.\nSee 8dcbd8074d6814218e1e16c373cb41e552a5942a + fd2d78247dbcdeb4ca333129acf6a52be4f3488b (old solution). Exactly! Thanks. aa16d88693d212e37782c138601e3c78e1ad23a2. ",
    "takattata": "What should I do?. @ilya-g Thank you for your reply. I tried to change it, is this correct?. @ilya-g Sorry to bother you again. Did this fix code differ from what you intended?. @ilya-g Could you review this PR? Thanks.. ",
    "NKb03": "Yeah that's right. Throwing the exception is necessary because otherwise the sequence would be infinite. And that's not what we want. It's just a notification that the iterator is exhausted. When I call cycle on a three-element-list with cycleCount = 3 the resulting sequence should have 9 elements. When somebody calls calls iterator.next() 10 times, the last time ignoring that iterator.hasNext() returned false, it's completely normal that the last call fails. It's just an assurance that no-one iterates through the sequence to often. If only the for-loop is used then it's not necessary to throw the exception, but who can assure that. I think you're right that the documentation should not mention that and maybe the NoSuchElementException should have the standard message.. Could be factored out as private companion object constant. Probably performance and space cost is negligible but it would look a bit cleaner for me.. Maybe replace with !in operator. Lines 63-75 could be factored out to private method replacingAssertionMethod with the reference name and the operator token as parameters. Always null, why not simply return null? This could also eliminate the result variable . Same as above, simply return null. Replace with \nreturn assertionMap[Pair(referenceName, operationToken)]. ",
    "dsavvinov": "A couple of suggestions:\n Successors of BaseDiagnosticTest generate txt file with descriptors dump. It is useful if we're interested in declarations*: types, overrides, fake overrides from inheritance, etc. If there's no need in checking declarations (as in tests on when), generation of .txt-files can be omitted by adding // SKIP_TXT to the beginning of .kt-file.\n\n\nProbably it's worth to implement some library \"for spec tests\", with template functions and classes, like getInt/getString/etc., and compile spec tests against that \"library\" instead of copy-pasting such functions in each test. \n\n\nWild idea: allow spec tests to reference not only corresponding sentence, but other related sentences. E.g. if sentence says something like: \"A when expression is called exhaustive if ... he bound expression is of type kotlin.Boolean and the conditions contain ... a constant expression evaluating to value true\", then it would be great to reference part of spec about what is \"constant expression\" (because tests, most likely, will replicate tests on constant expression in context of when). \n  I don't know how it should be implemented (and if it should be at all) so it is \"a wild idea\" :)\n\n\nAs have been discussed, we need to reduce volume of testdata. I propose to start with simple fix: do not try to extensively check all possible types in position of expression (like here). There is no type inference involved, and in most cases, when doesn't add any context, so it's quite unlikely that when will work with Byte but fail with Int or Char :) \n  Note that it still makes sense to check how compiler works with types when inference is involved, i.e. in tests on when-expression type inference\n\n\nInstead of trying various calls with various types, it may be worthwhile to give more attention to language constructs: if-expression, nested when, elvis, nullability assertions, as-casts, etc. -- in other words, everything which is declared by language rather than user. \n  Example: it may be surprising, but it's actually OK (currently, at least) to write return as when-entry condition:\nwhen {\n    return -> println(\"WAT\")\n}\n. Again, can you please elaborate, why do you think such a change is necessary? Does it contradict some explicit guidelines? If so, it'd be nice to mention them somewhere in the commit message. Sorry, I don't think that this cosmetic change improves readability, as it essentially repeats the old code, but also adds one extra call and unnamed parameter it. \n\n\nThanks for the PR, nevertheless!\n. Thanks for your contribution!. @cuihtlauac  can you please elaborate on the rationale of a such change?\nI can possibly see a value in an opposite conversion: from anonymous object to named one, for the sake of debuggability (and, maybe, a readability, though the latter is the matter of taste)\n. Well, I get where you're coming from, but I don't think that it's the undeniably best way to convey that meaning. Which is an issue -- Kotlin is a big public project, and we'd like to change things only if they are completely non-controversial (otherwise it may be impossible to maintain stable code base, as there are a lot of people with different mindsets/tastes/coding habits)\nSo, unfortunately, I have to reject your pull request -- hope that's understandable. Thanks for your willingness to contribute, though!. I don't have an objections, but maybe @zarechenskiy knows if there are some arguments for leaving this as is?. Thank you for your contribution!. So, I think we can leave it as is, at least until other function constructions won't be supported in contracts. Thanks for your willingness to contribute, nevertheless! :) . Sorry, that's erroneous overwrite of previous commit, i.e. this test data is wrong and test fails. UNREACHABLE_CODE is indeed reported here, and this change shouldn't be committed at all.\n~~As for type mismatch, we currently have the same behavior for ordinary lambdas.~~\nUPD. Whoops, myRun missing generic return type (so x is Unit here :) ). . Introduction of separate language features required some refactoring of EffectSystem endpoints to make them more granular (previously, lambdas invocations were written during inference of resulting data flow info), thus requiring users of Effect System now ask for recording of definite invocations explicitly. Probably, commit message needs a bit of rewording.. The intent is to abstract effect system away from PSI, so that we could transparently change one wrapper into another as soon as we will have IR. . Potentially, this can be fixed by using visitor with data and passing around boolean flag isInverted as this data.. I think, everything is working correctly now, but only due to the very limited amount of cases where equality actually supported (only Boolean to true/false and comparisons with null). Still, it can potentially backfire if we will decide to cover more cases, so I think you're right, we should treat identity comparison more carefully (with separate functor, probably). Language features checks are executed in Effect System endpoints. Is it better to lift them to call-sites?. In the current implementation, we don't have a way to express that function always throws (mainly because we were focused on practical applications). This is actually reachable during resolution of calls with callable references. Though, it currently reachable only with EMPTY info, so it can be fixed with additional check in CallCompleter.updateResultDataFlowInfoUsingEffects. Nevertheless, I want to discuss this with @erokhins later.. Currently, we don't have a way to express that function always throws.. We've discussed internally this change: it's OK, but could you please also change Severity to INFO for: IMPLICIT_RECEIVER_SMARTCAST,  CONSTANT and DYNAMIC. File says that it is autogenerated file; is it really OK to fix this typo? I mean, if this is how generator generates this code, then change will be overwritten as soon as anyone will re-generate this file. \n@semoro probably knows this part of code better. The same concern as for _KDocLexer. Here and below: this change affects descriptors-dump (corresponding .txt-files). I think, the easiest way to check that nothing else is affected is to launch all tests. . Excuse me? This test is about typos, you shouldn't change it.. It certainly should be \"diagnostics\". I'm not sure what it can affect. I mean, initially it was a compile-time error; changing that may have some unintended consequences.\n@semoro . Isn't this a part of our testdata markup? @mglukhikh . This is some strange change. Even though I don't know much about JS backend, I'm pretty sure that this change will break test. ",
    "bloderxd": "@ilya-g Could you review again, please?. @ilya-g What do you think now?. @ilya-g Is there any kind of feed back about this PR?. @ilya-g Thank you about feed back, now I tried to implement like forEach was implemented.. ",
    "cornwe19": "@mglukhikh Should be all set for another look. Thanks for the feedback.. Thanks!. @mglukhikh no problem, I can get those issues patched up a little later today. Thanks for the detailed feedback and good call about the performance issue.. Good catch. I'll include that with the other fixes you mentioned yesterday. Thanks for the continued testing.. Awesome! Credit really goes to Christoffer for requesting the inspection. Seems to be a fairly common source of bugs.\nI'll have to do a deeper dive on some of the false positives that are cropping up. There are a few scenarios here I don't use in my day to day development that I didn't think of.. Almost! I'm still working on detecting the invokable reference properly. Everything else should be all set through.. @mglukhikh I think this is all set now. Thanks for all the feedback.. Awesome! Happy to help. Validated this with the declaration's FqName. Highlighting only the calleeExpression now.. Validated nested calls. No logic needed to change to support this, it looks like the scope was already being handled properly.. ",
    "Redrield": "@abreslav Would it be possible to reopen this PR if I were to open an equivalent KEEP for the language changes that are being introduced, and that is accepted by the language designers?\nP.S. lexing for generics was fixed through commits fc49a45 and d83b045. ",
    "mmdango": "@yanex Any chance you could take a look at this soon?. @yanex @hsyed any movement on this on your ends?. @yanex Would you be able to comment if a fix for this was made in 1.3.20?. @hsyed Does this fix the scenario described in https://github.com/felipecsl/kapt-classloader-bug?\nThe cause of that bug is that classes from tools.jar get loaded from two independent classloaders, wouldn't creating a new classloader with no parent cause the same error?. ",
    "AdamMc331": "@ilya-g Following up on this to see if you have any questions. Let me know if there are changes that should be made. :) . Thanks for the update! Will follow that conversation. . Added this in throwVetoableDelegate() sample.. ",
    "gen0083": "Thank you for reviewing.\nI updated to wrap single quotes before printing, is this ok?. ok, done it \ud83d\udc4d . hi, this pr seems to be already merged. so what should I do? should i close this?. ",
    "seratch": "@dsavvinov \n\nMay be if we'll limit changes only to comments (excluding testdata, because here comments may matter too), it'll be OK, but once again, I'm not sure if it really worth the effort (both contributor's and reviewer's).\n\nThank you for your suggestion. I totally agree with you. I will revert all the changes except for the comments in Kotlin source code.. @dsavvinov I was going to revert changes but, if we go with it, the remaining changes will be quite limited. Therefore, I came to the conclusion that I should close this PR. Thank you for your time.. ",
    "ilmat192": "Closed since the same changes are included in https://github.com/JetBrains/kotlin/pull/1811. Included in #1878. Package names are still konan and I'll rename a project directory (native -> konan). But what about the output jar? It will be published, and an artifctId kotlin-native-utils seems less confusing than konan-utils. What do you think?. Renamed in https://github.com/JetBrains/kotlin/pull/1811. ",
    "SUPERCILEX": "Of note, any APIs that somehow uses the TaskCollection iterable forces everything to be evaluated.. Please look at the diff. \ud83d\ude43 I'm not using the new APIs yet, just removing calls that force all tasks to be configured.. @abelkov @h0tk3y Merged, PTAL. No problem, glad to see it go through!. ",
    "ma2gedev": "Thank you for your feedback. \ud83d\ude04 \nMy sample was completely wrong, so I modified it!. I rebased latest master branch because of conflicts. And squashed my commits. . @ilya-g Thanks for your response. I just added elementAtOrNull sample too. \ud83d\ude04 . ",
    "isopov": "Really lastIndexOf that I used for reference is not inline function. I started playing with Kotlin 2 days ago (maybe PR-ing stdlib is not the right game) and don't know how to deal with that problem and if it serious enough to not make such a change.. @ilya-g so how about making these functions noinline (for Iterables only)? Updated PR with it. Reverted to not inline versions that should not break things.\nSo should we close this PR or inlining predicate two time is acceptable price?. ",
    "bradynpoulsen": "@ilya-g good catch! I didn't realize I had copied another issue number before starting my work. I updated the commit, let me know if you'd like me to re-open this with a corrected branch name as well. Provided by Sequence<T>.chunked(Int). Perhaps a more appropriate name would be scope?\n```kotlin\nfun foo(): Unit = listOf(\"one\", \"two\", \"three\").scope {\n    forEach {\n        println(\"item: $it\")\n    }\nmap(String::capitalize).forEach(::println)\n\n...\n\n}\n```. ",
    "mirromutth": "I try support EnumSet on JS platform, use enumSetOf and enumSetAllOf to replace EnumSet.of and EnumSet.allOf (it support only JVM), their relationship looks like XxxxEnum.values and enumValues<XxxxEnum>. I should check my commits and make sure it have no merge commit and make a YouTrack before PR :-|. @ilya-g Thx, I solved this problem with your help :-)\nThis PR recreate to https://github.com/JetBrains/kotlin/pull/1990. ",
    "rsauciuc": "PS. Alternatively, I could explicitly match androidx.databinding... in the class name. Let me know which one you prefer.. ",
    "DeFuex": "Oh, alright, thanks for leading me in the right direction. I'll try again. i agree, it's a little messy, but it's the first possible solution i came up with.. I tried adding a check to be sure that there's a comment underneath a single expression. Doesn't seem to work quite right. Could be that i didn't fully understand the PSI system. Maybe you'll have a look at it.\nEDIT: works now. @cypressious I actually added a lambda expression check, which should be comparable to a closeable type in that regard? Maybe i didn't understand the context of your question, but i hope that this check solves it.\n@mglukhikh i added tests, but i'm not sure what i'm doing wrong. the two tests fail atm, due to some range error. Looking closely i think there are problems with the TextRange class used for highlighting maybe? i tried several different approaches though.. @cypressious oh, ups, you are right. I will work on this now. Do you know if there is already a given functionality to find out if an expression type is comparable to a non psi system class type (in this case Closeable)? cc @mglukhikh . @cypressious @mglukhikh Just added a check for expressions containing Closeable as superclass. What's not that nice about this solution is the direct descriptor name check !(descriptor?.name.toString() == \"Closeable\") ...i tried using ?as Closeable to cast and return if it's not containing superclass Closeable, but it didn't work as expected. Any suggestions?. First of all, thanks for the review \ud83d\udc4d , but\n1) some of the answers given i asked early on, like which highlighting (wasn't really clear to me)\n2) ConvertTryFinallyToUseCallIntention isn't written with AbstractKotlinInspection and only the actual quickfix work was reuseable.\n3) My comparison of descriptor name with Closable works, since it's practical testable without writing tests.\n4) My tests are strange because i didn't come around making them work properly yet.\n5) Due to the latest kotlin version and the merge (i know, i didn't use rebase) involved i had to refactor some of the code to work again. hence, duplication, but it works.\n6) i'll gladly squash all commits and create a new PR \ud83d\ude03 . i tried to rebase, but if it's too much i can reopen another PR again or resolve the conflicting files.. i created a new pr, since i had some issues with rebasing -> #2082 . > \n\nThank you for this amazing contribution. I see that a lot of work has been done but unfortunately a lot of corner cases are left. This is a hard inspection to implement and probably it should not have been marked with Up For Grabs tag.\nI have commented the original request at https://youtrack.jetbrains.com/issue/KT-19762 and think that we need to discuss the corner cases there before putting additional efforts to the implementation.\nIf you're going to continue working on this inspection I suggest to wait for discussion end and divide the task to sub tasks. For example you could start from inspection only for some particular scenario. After that's is done and approved we could gradually add quick fixes. Also it probably should be two different inspections for the code that has an explicit close() and for code that doesn't.\n\nI understand that it needs to be more defined and wasn't expecting it to be in the previous Kotlin release :smile: ...i think it just would be a waste of effort if i would stop now. Just let me know when you guys think that things are ready. In the meanwhile i'll try to improve the code and add more test cases when i got time. \nIn any case, currently it should be testable from a perspective that it inspects every function call from an instance, assigned to variables (also non-assigned) and when it is derived from a Closeable. And of course the convertion works too...a lot of rough testing went into this... but i see what you mean with instances that shouldn't be leaked and close(), referring to your youtrack comment.. So, what is your suggestion? that i chain every filtering and avoid the declaration of allElements? Don't i need a Sequence of PsiElements?. ",
    "Mishkun": "@ilya-g Yeah, it was really confusing at first. Also, kotlinlang.org samples use 1.2.71 kotlin and these samples crashed no matter what. If you want to discourage using experimental builders, then it is probably better to remove samples entirely and leave a link to stable ones instead, also mentioning that buildSequence and buildIterator will be deprecated in 1.3 in their docs. @ilya-g I removed the SequenceBuilder samples and provided notes about it being deprecated in favor of SequenceScope in v1.3.. ",
    "svitalsky": "I've just created an issue regarding this: https://youtrack.jetbrains.com/issue/KT-27880. ",
    "negator": "This is a great point. AQS uses an internal queue of waiting threads, which will impact the memory footprint as the number of threads grows. However, AQS is the basis for most Java synchronization primitives so I would assume it is implemented optimally for the common use cases. Although, if the goal is to minimize the footprint to greatest extent, this is probably not appropriate.\nI does occur to me now that we can simplify this greatly, using a global AtomicReferenceUpdater to simulate an exclusive write lock, and a volatile boolean to simulate the latch. This would impose a small constant amount of memory of an object and a volatile boolean for every lazy val. I\u2019ll update the PR shortly.. ",
    "gavra0": "That sound good. Thanks for the review, and for fixing the backwards compatibility. We can ignore the lazy tasks for now.. Thanks for spotting this. It's fixed now.. Thanks for the comment, it does make it more readable. . ",
    "Slvin": "I'm also currently working on a way to correctly fill the missing fields while constructing the SourceSetImpl so that in Android Studio we can correctly handle Kotlin srcDirs.. > Pushed for remote run https://teamcity.jetbrains.com/viewQueued.html?itemId=1746965. If the tests pass, I'll fix the issue I mentioned above and merge the PR.\nThanks! I've made the change you mentioned above as I noticed that the method comment was out of date, I hope this doesn't mess up anything.. @h0tk3y Do you know what will be the earliest version to include these changes?. @h0tk3y Great, thanks again :). Changed to allKotlinSourceSets. ",
    "jmslau": "Thank you both!. ",
    "rpuxa": "\nWhy would you like to contribute this change? Does it solve any problem you met?\n\nI edited part of code that not match coding conventions. ",
    "oy-paddy": "\u96f7\u7334. ",
    "Bluexin": "This definitely looks interesting, however I think https://github.com/Kotlin/KEEP would be a better place to post it, as that's where new language features are discussed (or the issue tracker if a full Keep is too much for you).\nI saw something similar briefly mentioned in https://github.com/Kotlin/KEEP/pull/87#issuecomment-428045651 btw.. > \n\nPlease make sure this cannot be applied to local variables\n\nActually, you can have lateinit local variables as long as they're not of primitive types and it'd be weird not to have the intention in this case.. ",
    "fkorotkov": "@ilya-g yes, but one module can be added multiple times sin\u0441e it can be already in toProcess but not yet marked as processed. Imagine a complete dependency graph {1, 2, 3, ..., n} where each node is connected to each other:\n\nWe pick the node 1 and add it to processed.\nAdd all children to toProcess which are equal to {2, ..., n}\nLet say we'll pick node 2 from toProcess.\nWe add 2 to processed which now consists of {1, 2}.\nWe will add again all nodes but {1, 2} to toProcess. Now there are duplicates in toProcess! {3, ..., n, 3, ..., n}\ncontinue...\n\nIt will mean for a case of a complete dependency graph that on each step i we will add n-i nodes to toProcess which means in the end we'll add O(n!) nodes to it. Exponential!. @ausatiy sounds good! I initially though in KT-27832 that the slowness is because of O(n^2) but it appeared it was because of O(n!) \ud83d\ude05 Will be great to get it even faster but I had issues with setting up Kotlin project in IntelliJ.. Wow! Big win! Thanks!. ",
    "ausatiy": "@fkorotkov, thank you for your contribution. Your fix is elegant but the import still has complexity n^2 because dependency resolution (up to O(n)) is performed multiple times for each module (n).\nI'll take a look whether any other improvements in KT-27832  could be done.. @fkorotkov , I forgot to write a summary. Your fix improves performance of dependency resolution up to 2 times (here and later the test case I've mentioned in the issue). Adding caches gives additional speedup approx. 5 times (already done too) giving total speedup approx 10 times!\nAs result the whole import process becomes up to 2 times faster.\n. ",
    "KotlinBuild": "Thank you! \nThis PR is merged manually as https://github.com/JetBrains/kotlin/commit/e6713186530b2e0a883b6de5722da0a57974c4b5.. ",
    "Prototik": "Closing as I'm working on full reworking on serialization plugin.\nAnyway this patch just dumb hack for special case, that's not I'm want to.. ",
    "quasilyte": "@goodwinnk, OK, you can fix them all if you wish.\nI'm not motivated to perform more work on this, since it requires some manual work and it can't be done \"perfectly\" (or completely) since there is always a chance that the tool you're using is not good enough.\nBut keep in mind that you have to check the diff anyway, since some things look like a typo for a tool but they're not.\nI've used very simple misspell tool that finds few typos, but the false positive rate is low.. ",
    "Davio": "I think this can be merged now, @ilya-g . Okay, I will amend it. A very simple solution could be to add 500,000 before dividing by 1,000,000.\nAnything that has a remainder lower than 500,000 gets floored. (0-4.999... + 5 < 10)\nAnything that has a remainder equal to or higher than 500,000 gets ceiled. (5-9.999... + 5 >= 10). ",
    "goodsauce": "Requested changes were made,\n\"Reformat Code\" didn't change anything\nConfirmed it was the right button by applying \"Reformat Code\" to:\nfun thisStyle()\n{\n}\nFirst commit did actually check for nullability, \"makeNotNullable\" now allows hint to be shown regardless of nullability. ",
    "madsager": "This adds a call from compiler/ir/backend.jvm to code in compiler/backend. Not sure if such dependencies should exist? . Thanks Dmitry, I'll be happy to look into doing this as a lowering pass. That should be a good exercise. Let me know if you think we should land this as a step in the right direction or if we should wait until we have it reimplemented as a lowering pass.. Thanks Mikhail! I updated the code following your suggestion.\nLooks like my original code would work, but it would only cover some of the cases. Your suggestion extends it to cover the cases based on the 'not' symbol coming from psi2ir as well. Does that sounds correct to you?\nRegarding testing: there are a lot of tests that hit this path and therefore the correctness of this seems to be covered by other tests. Would you like to have a specific test checking that branching on a negated value does not lead to materialization of the negated boolean? If so, is there a preferred way of adding such tests?. Quick update: there is one test failure with the new code. I'll dig into that and report back when I know what is going on.. Thanks! Removing the intrinsic method call removed the conversion of the argument to the right asmType which is done as part of the invocation of the intrinsic. That was causing the errors. That has been fixed and the current code passes all tests. I'll get started on bytecodeText tests next. I will leave it up to you whether to land this change as is or wait for the testing changes.. Rebased on top of master with the bytecode text tests enabled. There is one very local test that tests for exactly this patter which now passes. Next steps: make more of these branching tests generate reasonable java bytecode so that more of these tests pass.\nMike, can you take another look?\nThanks!. Thanks Mike, I updated the pull request to do this as a simple lowering. Is something like this what you had in mind?. Thanks! Shared 'isNegation' and 'negationArgument' between ExpressionCodegen and this new lowering as top-level functions in ExpressionCodegen. . @max-kammerer agreed and done! :). As discussed offline, I updated this to avoid the change to Psi2Ir translation. Instead I have integrated the removal of immutable IrTemporary variables in the lowering phase. What do you think?. Thanks for the comments Mike. I had a closer look and it seems like my current patch is working properly and that it will not immediately work to push the coercions into the branch results.\nHere is what is happening in my current patch for the double/int mix: the type of the when expression becomes Object and therefore, there will be boxing of the int and the double and therefore one pop instruction is enough to get rid of that object. In the low level bytecode optimizer this case is then recognized and the boxing to an object that is then immediately popped is replace with a pop of the right type. Therefore, the correct code which uses the right pop instruction pop2 for the double and pop for the int, is generated.\nIf we push the unit coercion into the branches we still get unbalanced stacks unless we also add an else branch as done in the current patch. The reason is that the unit coercion puts a unit instance on the stack in both branches. However, when none of the branches are taking we don't get a value on the stack and therefore we get flow to a pop instruction with nothing on the stack.\nTherefore, it seems to me that the current patch is the simplest to make this work. Also, it doesn't lead to pop instructions in all the branches when one pop at the end is enough.\nWhat do you think? . @max-kammerer Minor follow-up to previous change dealing with blocks with Nothing type.. @max-kammerer . @max-kammerer . This is the only special handling. As this test relies on line numbers the suppression line cannot be above the code.. This test is now failing because it contain an IFNULL instruction. However, it only passed before because the IFNULL was an IFEQ comparing to the null constant. . Thanks for catching that Mike! I have updated the code to only allow the elimination of null checks for primitive type constants and for primitive type values loaded from a local variable. It is OK to eliminate the local variable load of a simple type value - even if it is changed during debugging it still cannot be updated to a null value. What do you think?. Done, thanks.. As we discussed offline, in order to get rid of all null comparisons with primitive type arguments, we now transform the potentially side-effecting cases:\nif (side-effecting-expr-with-primitive-type == null) ...\n--->\nside-effecting-expr-with-primitive-type\npop\nif (false) .... Good idea. Done.. I'm unsure if this has consequences for non-jvm backends? On the JVM, introducing a temporary for constants makes little sense as the constant can just be reloaded. Is that a reasonable assumption for the other backends as well?. Done.. Done, thanks!. Neat! Done. :). That is correct. I have added fairly large comments to explain what is going on. Let me know what you think. . Thanks Mike, I agree. Ting-Yuan, we should work together on finding a way to fix that.. Done, thanks!. They can. Done.. ",
    "NikitaKatkov": "@mglukhikh , it would be very nice to merge commit so that it appears in Kotlin 1.3.20 . @ilmirus , so I'll change the error message, but leave map key name as it is now, right?\nNaming is one of the worst things in programming -_-. replaced error name and description with more general wording. ",
    "BernhardPosselt": "Updated. ",
    "denisgaebler": "One more comment on IBM JDKs, usually the path is lib//default. So maybe instead of hard coding the directorys for the IBM JDK, you might want do search all directories in the Java home. However, I don't know which IBM JDK uses bin/default.\nThanks, Denis.. ",
    "StefMa": "It's only a test, but I would recommend to use the new lazy methods 'tasks.register' and 'tasks.named' instead of the \"old\" 'tasks.create' and 'tasks.getByName' methods...\nSee https://docs.gradle.org/5.0/userguide/task_configuration_avoidance.html. ",
    "akhaku": "Absolutely, thanks for the tip!. ",
    "tvierling": "Never mind, going to have to submit separate project pull requests with \"actual\" declarations, closing this for now.. ",
    "tnorbye": "Filed https://youtrack.jetbrains.net/issue/KT-29586 for the compatibility impact of this. (I don't have permission to tag the issue with \"for-language-committee\" as instructed in https://kotlinlang.org/foundation/submitting-incompatible-changes.html). Accidentally closed, oops!. ",
    "ting-yuan": "Thanks for the pointers! kaptClasspath is added in the check, as well as a new test which would fail if annotation processing isn't skipped correctly.\nThe updated PR is tested locally with the command below in Linux. There are 6 tests from 2 classes failed but none of them seem related. They also failed without this patch.\n$ ./gradlew -Pteamcity=true :kotlin-gradle-plugin-integration-tests:test. Looks like this was already merged. Closing manually.. Hi @max-kammerer @udalov @dnpetrov,\nBesides the changes to\n1. tests.\n2. factoring out operator names \n3. reuse OperationMapGenerated,\nI also tried to get rid of descriptors. Please take a look again.. Thanks for the review! @max-kammerer. Please take a look at the updated PR again.\nI'm going to resolve the comments about the tests and will remove // IGNORE_BACKEND: JVM_IR for the 2 lineNumber tests once https://github.com/JetBrains/kotlin/pull/2153 is merged.. @max-kammerer Thanks, I've rebased and removed // IGNORE_BACKEND: JVM_IR from the 2 line number tests, which are fixed in #2153. Also verified again with compiler:test.. @max-kammerer Sorry, I missed that. Please take a look again.. Yes. I'm trying to see how enum is implemented in the current backend. String looks easier, although slightly different than the integers (jump v.s. hash -> jump -> compare).. There seems to be no way to disable a single test for the JVM backend in BytecodeTextTestGenerated. I tried IGNORE_BACKEND and TARGET_BACKEND and neither of them work. After tracing the code a little bit, it looks like that the default target backend ANY keeps those 2 flags from working.. In the first commit, only BranchingExpressionGenerator.kt and ExpressionHelpers.kt contain \"real\" changes. The remainings are just corresponding changes in the expected outputs.. Hi @max-kammerer , please take a look again. Changes are:\n1. handled if (false) as well and added test cases.\n2. refactored genIfWithBranches a little bit.\n3. renamed the tests for true.\n4. removed println from the tests. In fact, I copied them from existing tests: ifElse.kt and singleThen.kt. I'm not sure why they use println so I didn't touch them. Let me know if you'd like them be replaced, too.\n. Thanks for reviewing this! I got a similar implementation as your example. Unfortunately, some projects don't build with it. For example, while building CatchUp, antlr throws this:\nCaused by: java.lang.UnsupportedOperationException: java.io.InvalidClassException: org.antlr.v4.runtime.atn.ATN; Could not deserialize ATN with UUID 59627784-3be5-417a-b9eb-8131a7286089 (expected aadb8d7e-aeef-4415-ad2b-8204d6cf042e or a legacy UUID).\nat org.antlr.v4.runtime.atn.ATNDeserializer.deserialize(ATNDeserializer.java:153)\nat androidx.room.parser.SQLiteLexer.(SQLiteLexer.java:777)\nI didn't spend much time investigating why it fails and was guessing that the URLClassLoader is a workaround to the problem. Allow me take a deeper look at it.\nIf the solution to the above turns out to be unfeasible, caching seems to be the way to go. The first implementation I proposed uses HashMap / WeakHashMap. Yan suggested (and I checked with a few projects) that the classloaders created in currently implementation never change (w.r.t. URL and parent). That's why this PR is written. Let me switch back to that implementation, as I also feel it safer, and without measurable performance change compared to this.. The assumption that it's safe to execute KAPT in context of Gradle worker's classloader isn't true. There are class name clashes in Gradle Worker's classpath and AP's. In the above case, there are two jars providing antlr, which later finds that the loaded one (from Gradle) is too old.\nIt's probably better to be resolved in Gradle if that's unwanted behavior (it should, because another worker isolation model CLASSLOADER works just fine). However, that could potentially take a few more weeks and also creates compatibility issues between versions of gradle and kapt. For the time being, caching is probably the way to go?. Done. Thanks for the review!. It looks like that most of the box tests are already there in the code base? Although only either constant folding or generated bytecode will be tested, but not both; If an expression is folded, the bytecode generated won't be tested, and vice versa.\nSince this is constant folding, the result should be a constant stored in the text. I'll start by adding bytecode tests and check whether there are box tests which are folded/optimized away.. With this pass and some branch optimizations by Mads, the test simply returns OK :) The conditions are optimized away:\n...\nLDC \"OK\"\nARETURN. Done. Please take a look again :). Done. Done. Please take a look at the new commit. They are added but not enabled yet; Because the current backed doesn't fold those comparisons, the new tests would fail on it. This PR tries to fix that.. Thanks for the pointers! I've been wondering where those IrBuiltins are used :) Please take a look at the new commit, where the support of folding some IrBuiltins, mainly for those comparisons, are added.. Updated with another approach so that  runtime isn't required. Also verified with :compiler:tests. Similar to changes in concat.kt and primitiveToString.kt, this prevents the relevant part of the test being optimized away. Without this change, it would be:\nexpected:\n<0 IFNULL\n[1 IFNONNULL\n1] throwNpe\n0 ATHROW\n\nbut was:\n<0 IFNULL\n[0 IFNONNULL\n0] throwNpe\n0 ATHROW\n\nNamely, the check and potential throw for z!! would be optimized away.. Similarly, the check and throw for y!! would be optimized away without this..  @max-kammerer The test in concat.kt has a flew IMHO. Because the constants get folded into one, there is only one concatenation after constant folding (in both backends): \"12345.06.07\" + A(). Because the test looks for exactly 1 StringBuilder, it does not test whether the unnecessary StringBuilders are eliminated or not.. @max-kammerer I touched kt2269.kt because :compiler:test fails and complains that kt2269.kt is a passing test disabled. So I have either to:\n1. remove // IGNORE_BACKEND: JVM_IR so that it can pass falsely. I'll add kt2269-jvm-ir.kt\n2. change the test as in PR to make it test what it meant to test.\nShould I just go for 1, or other recommendations?. I've disabled these 2 tests and let's address it in another PR. This one is probably too large already.. Thanks for the pointer! I updated the PR quite a bit to reuse OperationsMapGenerated.kt. Please take a look again.. @max-kammerer I've forked those tests with proposed changes and disabled the original tests for JVM_IR, if they fail. Basically testABC.kt is forked into testABCNotOptimizable.kt.. Done.. Done.. Done.. Done. matchConditions now only get a list of IrCall without having side effects. The result can also be reused, e.g., for String and Enum.. Done.. Yes. I've updated the comments in it.. Didn't add it because it is exactly the same to the existing test. Will update after the tests finished.. Done. areConstComparisons are hoisted out of areConst[type]Comparisons to guard the shared operations, which are moved before areConst[type]Comparisons.. Looks better, thanks!. Thanks for catching this!. Done!. ",
    "mpetrov": "Just synced to handle some merge conflicts that arose while this PR was out. Please take a look.. Thanks @anton-bannykh,\nFor some prior art, here are some other relevant tools that emit closure modules: \nTypeScript: https://github.com/angular/tsickle\nJava: https://github.com/google/j2cl\nA big benefit here is one could do something like have a mixed TS and Kotlin codebase, have both emit closurized output, and have a single tool responsible for linking and optimizing the mixed language codebase.\nSince the Kotlin output isn't type annotated, the number of optimizations that can be reliably performed is still limited. This is more of a first step to allow easy integration into existing closure projects and build systems (more specifically bazel in Google's case). Type annotated output could let you do interesting things like leverage clutz (https://github.com/angular/clutz) to emit .d.ts files (see KT-16604).. ",
    "ansman": "Ah, nice catch!. ",
    "Tiltorito": "\nThank you for the contribution!\nI did only a quick overview, but as decapitalizeSmart is used from compiler, it means this might be a breaking change. Can KT-28485 be resolved for IDE only?\n\nIt can be moved on KotlinNameSuggester in org.jetbrains.kotlin.idea.core package. Shall I move it there and leave capitalizeDecapitalize.kt untouched?\n\nAlso some tests are expected. Do you need help with writing them?\n\nYes, please. Sorry about that, it is my first time contributing.. Yeah, your code seems better :). ",
    "igorwojda": "@goodwinnk what do you think?. I think this implementation can be simplified.\nWe can also postpone StringBuilder creation, so it is only created when the input meets \"const criteria\"\n```\nprivate fun decapitalizeConst(str: String): String? {\n    val words = str.split(\"_\").filter { it.isNotEmpty() }\nif(words.size <= 1) return null\n\nval builder = StringBuilder()\n\nwords.forEachIndexed { index, word ->\n    if(index == 0) {\n        builder.append(word.toLowerCase())\n    } else {\n        builder.append(word.first().toUpperCase())\n        builder.append(word.drop(1).toLowerCase())\n    }\n}\n\nreturn builder.toString()\n\n}\n```. ",
    "kevpeek": "@ilya-g I combined the two map operations and changed to the default separator value in joinToString.. ",
    "punzki": "@max-kammerer I somehow messed up this PR and couldn't fix it. Created a new one. @max-kammerer Messed up the previous PR, but I've addressed your comments from https://github.com/JetBrains/kotlin/pull/2090 here.. The most notable difference in the port is the use of SimpleType instead of IrClassSymbol when matching iterables to support (e.g., checking for supported array type).\nI couldn't figure out why, but currently the symbol table contains duplicate symbols for the same class, which seems to be a difference in behavior from K/N. For example, I've seen multiple symbols in the table for kotlin.Int, therefore the array element types wouldn't match.. > @punzki You have several TODOs in codes, it would be best to implement them before this pr would be merged in master (so K/N could migrate to common lower).\n\nIt also worth to await JVM integration to check correctness at least in one of backend\n\n@max-kammerer The 2 major TODOs are to use getProgressionLast and checkProgressionStep. (Both functions are only present in some internal package in K/N and I would have to port it.)  My intention is to diverge a little from how the lowering is implemented in K/N, and do it more similar to how it's done in the current, non-IR JVM backend.\nMy understanding of the code is this: ForLoopsLowering from K/N elides the instantiation of the Progression objects with step > 0 (e.g., if it sees something like for (i in 1..10 step 2)). This is why it has to insert calls to assert the provided step is > 0 (checkProgressionStep) and compute the \"actual\" last value (getProgressionLast, the actual last in the above example would be 9).\nThe current JVM backend does not do this. It simply gets the first/last/step properties when it sees a non-standard step. It can do this because the step() extension function on Progressions asserts the provided step, and the Progression constructor computes the actual last value (by calling getProgressionLastElement which is internal only).\nMy intention is to make ForLoopsLowering use the properties for non-trivial Progressions. This would greatly simplify the lowering logic at the cost of creating the Progression object. What are your thoughts on this?\nAnother difference is that the current JVM backend uses while loops instead of do-while where possible and it is safe to do so (for Progressions), but the ForLoopsLowering always uses do-while for Progressions. I do not plan to implement this decision logic in ForLoopsLowering, also to simplify the lowering logic (I might have to fork the bytecode text tests).\nP.S. I'll do better in the future in communicating my intentions, when submitting the PR. \n\nYes, we have such problem and @udalov working on it.\nMigration to irTypes looks good, but seems you will get same instance duplication even with irTypes, but AbstractTypeChecker.equalTypes should help (https://upsource.jetbrains.com/kotlin/review/KOTLIN-CR-2795)\n\nSounds good. Note that I'm using KotlinType/SimpleType as well to match the progression types. Should we avoid using KotlinType in the future?. > > My intention is to make ForLoopsLowering use the properties for non-trivial Progressions. This would greatly simplify the lowering logic at the cost of creating the Progression object. What are your thoughts on this?\n\nYes, it would as same as old backend works (seems you already made investigation in ForLoopGenerator/AbstractForInRangeLoopGenerator/AbstractForInProgressionLoopGenerator hierarchy in old backed).\n\n@max-kammerer Do you have any objection to doing the lowering that way? I.e. simplify the logic by using the Progression properties.\n. > @punzki Just to clarify your original point\n\n\n... use the properties for non-trivial Progressions\n\nDid you mean that trivial progression wouldn't be constructed at all?\n\n@max-kammerer Correct, but to clarify what are \"trivial\" vs \"non-trivial\": Trivial would be any Progression expression that are any of:\n1. From a call to rangeTo / ..\n2. From a call to until\n3. From a call to downTo\n4. From a call to step with 1 or -1 on a trivial Progression, so something like 1..10 step 2 step 1 or someProgression step 1 is not trivial.\nCurrently the old JVM backend removes the construction of those Progressions and we can do the same for the IR backend.\n\"Non-trivial\" would be Progression expressions that are any from a call to step with a value that's not 1 or -1, e.g., 1..10 step 2.\nThe current JVM backend allows the construction of the non-trivial Progressions (as described above), and the ForLoopsLowering from K/N attempts to remove its construction. To be clear, my proposal is to port ForLoopsLowering but instead allow the construction, and read the Progression's first/last/step properties in the same way we would for a Progression that's already constructed.. > @punzki Please rebase on master: there is conflict after #2153\n@max-kammerer Done!. > @punzki Please split all new/affected tests in more granular files, e.g. if/while/doWhile:\n\nso negatedNonZeroCompare.kt ->\nnegatedNonZeroCompareInIf.kt\nnegatedNonZeroCompareInWhile.kt\nnegatedNonZeroCompareInDoWhile.kt\n\n@max-kammerer Done!. Actually this works out fine because value is of type Number and therefore value == 0.0 invokes Number.equals. But to be explicit, changed to value.toDouble().equals(0.0) and added tests.\nTangentially related: When I copy pasted code from https://github.com/JetBrains/kotlin/blob/8eeb9d4faab68b4821bbad62ae38a59b03f16930/compiler/backend/src/org/jetbrains/kotlin/codegen/MemberCodegen.java#L569, I had the Kotlin plugin convert the code as a starting point, and it used == instead of .equals. Bug in the converter (at least for doubles and floats)? So the simplest repro of this bug is something like this:\nDouble posZero = 0.0;\n        Double negZero = -0.0;\n        if (posZero.equals(negZero)) System.out.println(\"EQUAL\");\n        else System.out.println(\"NOT EQUAL\");\ngets converted to\nval posZero = 0.0\n        val negZero = -0.0\n        if (posZero == negZero)\n            println(\"EQUAL\")\n        else\n            println(\"NOT EQUAL\")\n...which aren't the same. And the editor gives a warning that if (posZero == negZero) is always false, which isn't correct either.. I figured that I covered both by having the \"my*\" fields pointing to the constants in the companion object. Anyway to be explicit, I added fields directly initialized to literal constants.\nI also added tests for fields.. Purpose of this change: LocalDeclarationsLowering uses sanitizeAsJavaIdentifier when naming the \"lifted\" local functions. The generated synthetic function for local function bar inside function foo is named bar$default. When lifted, the name should be foo$bar$default but without this change, bar$default is incorrectly sanitized and the lifted function name becomes foo$bar_default. This change ensures that $ is not sanitized into _. ExpressionCodegen assumes that the names of the generated function end with $default.. Purpose of this change: Without this, the generated functions are not invoked with the correct descriptor; the enclosing class is included in the descriptor as the dispatch receiver parameter. This causes a stack underflow error during verification.. I'm not sure if this change is safe to make since this affects the current non-IR backend, but all the tests are passing.. I'm not sure if this change is safe to make since this affects the current non-IR backend, but all the tests are passing. There doesn't seem to be any code within the compiler relying on $ being sanitized into _, but it's possible there's some code out there that does.. @max-kammerer Got it! Will hold off on this PR for now, and revisit it after that change is landed, and new type mapper is available. Is the type mapper in a different change under review, or still not in progress yet?. Thanks for the review! Done.. I think you mean @ting-yuan :-). ",
    "dimonchik0036": "Thanks!. Should we change also ReplaceNegatedIsEmptyWithIsNotEmpty.html?. Thanks!. Thank you! Your commit in master  4156a76.. Oh, my mistake. Thanks!. Not the best description, something like \"Could be replaced with `size`\" looks better.. Redundant argument, because the level is already WEAK WARNING. Just to have more clear code, I'd write valueArguments.isEmpty(). I think it's more effective to check arguments first. 2019. It should be a description of the inspection. Example: ReplaceCallWithBinaryOperator . KotlinSingleIntentionActionFactory is better for this case. Can you give an example where this check is needed? Looks redundant. Same as above. ",
    "wcarmon": "thanks for a great programming language :-). ",
    "sfs": "On it!\nLooks like this test was actually broken before (it didn't use the default arguments). The test doesn't actually check for this though and thus didn't fail.\nExpect a fix soon.. @max-kammerer I added the tests and confirmed that they succeed.. I got rid of the default argument to areCompatibleCallables, since it uses the wrong ModuleDescriptor when called on a resolved class descriptor for a type alias.\nTo avoid more bugs in the future it's probably better to be explicit here.. @max-kammerer the platformModule parameter is used in areCompatibleTypes to compare two types up to expansion of type aliases for expected and actual type constructors. The commonModule contains both declarations, since otherwise you wouldn't have found the expected declaration in the first place.\nHowever, if you expand a typealias, the module for the expanded declaration contains only its own dependencies and in particular might not contain the expected/actual declarations at all. This happens in the annotationsViaActualTypeAliasFromBinary.kt test case, where the module for Jnno doesn't contain either declaration of Anno.. @max-kammerer If I understand you correctly I could simply change commonModule to actual.module, right?\nI'm not sure I understand what you mean though - is there supposed to be only a single module which is the same for all declarations? This is not what I'm seeing; the declaration for Jnno points to a different module (\"dependencies for test[...]\").. @max-kammerer I switched it back to using a default argument. Should be fine now.. @max-kammerer \nNo, this is the one that's required. In the annotationsViaActualTypeAliasFromBinary test case the function findNamesakesFromModule resolves the constructor of Anno to the constructor of Jnno.  This constructor is assigned to actual here.\nCalling actual.module yields the module for the Java annotation which doesn't contain Anno and causes the test to fail.. ",
    "alexander-gorshenev": "For reference, the corresponding native PR is here: https://github.com/JetBrains/kotlin-native/pull/2769. I made mdnCache by lazy.. We're fine with that, I suppose.. Should be enough, I suppose. Thanks.. Moved to use Name.guessByFirstCharacter().. ",
    "romanart": "@udalov Yes, in upsource. Why do we need this check? . I agree with @bashor, it would be better just return [] because empty $metadata$ means the type is not Kotlin type and could not be an interface for sure.. JDK uses ScriptEngine for such things. I'd rather keep this name. Maybe one of KotlinScriptEngine or TestScriptEngine . Could you please move this flag into KotlinTestUtil.java? I think keeping such flags in one specific place is good.. Shouldn't it be get(testModuleName)? . It is also possible to pass engine type as parameter from outside . My point is to keep all flags in one place. ",
    "pyos": "Yeah, I've already noticed that in the local build as well. All of them could indeed be unmuted, although I'm not sure why this change would affect them at all, as none of them use inner classes.... Haven't noticed that IrDeclarationOriginImpl has an additional argument for syntheticness, thanks.. Probably not, as these are not IR objects, I see no obvious way to use them to obtain an IrFunction referencing the constructor, and there's also the factory method anyway.. Can you clarify, please? Do you mean I should replace \"kotlin.jvm.internal.Reflection\" with AsmTypes.REFLECTION.replace(\"/\", \".\")?. That makes sense, but I don't understand why not do that for delegated references as well? Also, it seems like an optimization, so maybe we could do that as a follow up commit?. As I understand it, a delegated property\nclass C {\n    val x by Delegate()\n}\nis simply transformed into something that resembles this:\nclass C {\n    val x$delegate = Delegate()\n    val x\n        get() = x$delegate.getValue(this, C::x)\n        set(val: T) = x$delegate.setValue(this, C::x, val)\n}\nand the code in this lowering is required to generate an appropriate KProperty in place of C::x. So my question is, why handle C::x here and a reference to a non-delegated property elsewhere differently? Seems to me like both can use a subclass of KProperty in which overrides get and set call C::getX and C::setX directly instead of going through reflection. (Of course, calling get/set on a KProperty passed to getValue/setValue is of rather limited usefulness, so the performance of that might not matter, but still.). Seems like the type is the only place where the frontend records mutability, which is not exactly convenient as the information about subtyping is not available afterwards, and checking against specific types seems like a hack anyway. Would it be ok to modify the frontend to also set isVar of the synthetic local variable accordingly?. The frontend doesn't generate fake variables for references used in delegated properties' accessors, so getOrFail fails on those.. Right now I've placed it before PropertiesToFieldsLowering because otherwise support for Java fields would also be a requirement for some Kotlin properties. Once that's implemented, maybe there's a more optimal place in the pipeline.. Added a TODO about that.. The problem is that for reflection to work correctly, getSignature should return the signature of a property's getter, even if it does not actually exist (because the property is a Java field or the getter has been removed by PropertiesToFieldsLowering). I don't see an obvious way to do that using the current type mapper.. @max-kammerer done, added the second TODO and a bunch of other comments.. ",
    "petertseng": "Possible NullPointerException if superClass has no previous sibling??? But will it ever have no previous sibling?\n. ",
    "mikehearn": "Why only the JetBrains versions and not also javax.annotations versions? My own code won't benefit if this is the complete list.\n. This description seems duplicated?\n. Is there some subtle difference in the meaning of Nullable in the javax.annotations package that I'm not aware of? How many definitions can there be?\n. ",
    "sindrenm": "Haha, agreed, @JakeWharton. :stuck_out_tongue: \n. ",
    "naixx": "Is it the best way to combine hashcodes?\n. ",
    "wontondon": "Probably not. Thanks for pointing this out. \n. ",
    "pmwmedia": "listOf(1, 1) OR listOf(1, 1, 1) == listOf(1, 1, 1) !?\n. ",
    "zeesh49": "should I create a complete java file with main method etc? like  kotlin/j2k/testData/fileOrElement/switch/comlicatedFallDown.java?\nI did not do so because there are other .java files in the folder with similar structure to the one I created, because I followed that structure, like:\n kotlin/j2k/testData/fileOrElement/switch/caseWithBlock.java \n. ok, just to confirm, below file right?\n kotlin/j2k/tests/org/jetbrains/kotlin/j2k/JavaToKotlinConverterSingleFileTestGenerated.java \n. ",
    "baratynskiy": "It cannot be done because environment is used in this if / else statement.. In this case contains function just checks a file extension. This is why we can use this mock object here.. PrimitiveType includes boolean, byte, short, int, long, char, float, and double.. For example, List<String> and just List. The first is JCTree.JCTypeApply, while the second is JCTree.JCExpression.. It cannot be done because JCMember type parameter is <out T : JCTree>. JCTree doesn't have a name field. At the same time JCTree.JCMethodDecl and JCTree.JCVariableDecl don't have a common ancestor class except for JCTree.. There is no mistake here. Maybe there is a mistake in the NetBeans plugin itself.. We don't need these methods to be overridden because we inherit them from JavacElement. In NB plugin we should do it because there is no ElementHandle for type parameters.. There is another property for interfaces called isInterface.. It will return false for an interface method.. ",
    "mg6maciej": ".all { it.isNamed() } is easier to read.. I'd add an example that clearly shows all should be named, like this:\ndata class SomeName(a: Int, b: Int, c: String)\nf.copy(2, c = \"\"). And maybe another where copy is called on this:\nfun SomeName.func() = copy(0). ",
    "Sweetnesss1": "Lenor . ",
    "stephanienobles": "y :-*. sufjfubi. ",
    "rostopira": "Returns cannot be Int because, according to docs, all returns is a timestamp since 1970 in milliseconds. Also, it's bad to treat it is as Double, because you can't than convert it to Date without ugly cast .toLong(). Same thing with Number, ugly casts all over the code. ",
    "piotrek1543": "There is a lot of unnecessary code formatting, which make harder to find what exactly author of PR changed. @Dimach, did was intentional and done by you or automatically changed by IntelliJ?. I agree @yole. This part is really good example what should be extracted to method.. @Dimach I just wondered the reason of this changes. Now, it's ok.;-). If I were you, I would reduce space from 2 to 1 line. I think one is enough to make this object readable.. After changes TODO comment above your code should be removed. You've already fixed it.. test prefix reminds me old days of JUnit, where it was obligatory to run any test :-)\nCould you tell me why there is doubled kotlin and test packages in path: kotlin/libraries/kotlin.test/common/src/test/kotlin/kotlin/test/tests/? Just wondering.. Please restore previous code formatting - actual if-else statements and spaces are against accepted conceptions.. I am not a decisive person, not Kotlin team member, but I think that you should follow an example above - I believe that was made for a specific purpose - and add commented parameter to KotlinIfElseExpressionSurrounder callings.\nSo your code would be:\n``\n            new KotlinWithIfExpressionSurrounder(/* withElse = */false),\n            new KotlinWithIfExpressionSurrounder(/* withElse = */true),\n            new KotlinTryCatchExpressionSurrounder(),\n            new KotlinTryCatchFinallyExpressionSurrounder(),\n            new KotlinIfElseExpressionSurrounder(/* withBraces = */false),\n            new KotlinIfElseExpressionSurrounder(/* withBraces = */true). InstringMethodsclass constructor you usedString(\"original\"), here you put only its parameter. I am not sure if putting directly\"original\"here is a proper thing.. @yole yes, you're right. Saying that I'm not sure about a provided solution without providing any helpful suggestions was inappropriate; I won't. . Agree with @ilya-g, but also wonder if it would be better when we would use in line 56lengthor eventuallysizeinstead of mysticalit`.. ",
    "lynnfield": "It is wrong according to Java Code Conventions. ",
    "konsoletyper": "for (i in lastIndex downTo 1) { ... } is already supported by optimizer. ",
    "Meztihn": "It won't break anything because readLine is the only place where it is used. But leaving it can be useful in future, considering KT-11207. Anyway I should try to simplify this declaration.. @ilya-g Thanks!\nDefault Charset in InputStreamReader is platform dependent but InputStream.reader() in Kotlin uses Charsets.UTF_8 as default. For using platform dependent charset much more complicated algorithm is needed. I'm not sure it's worth it so I'll use UTF-8 for now.\nI don't think it's necessary to read chars right away. We always can translate needed chars to bytes and work with them. Especially considering that we always have to check read() output for -1.\n@cy6erGn0m If I understand UTF-8 encoding correctly no other char can contain \\r or \\n chars. Their binary representations are 0000 1101 and 0000 1010 respectively and any bytes in multi byte char should start with at least one 1.\nThe site with examples is down so I can't check them for now.. ",
    "vlad-kasatkin": "Thank you for your feedback! I have updated samples. Will add a couple of more samples if I have some free time next week :). ",
    "jshvarts": "here and in other functions below, add space before Boolean return type (fun checkByteArray(): Boolean). spacing fun box(): String. ",
    "Hiosdra": "Is it good now?. ",
    "ddolovov": "OK. reverted back. dropped. rewritten in another way. Lets double check if we are going to keep K/N stuff in \"native\" or \"konan\" folder.. I would suggest to keep konan for uniformity. @olonho what's your opinion?. I know how to do it. Will try to.. OK.. ",
    "olonho": "Package names in compiler to be konan.. ",
    "bibaev": "Fixed. Replaced with KotlinLanguage.INSTANCE.id. Indeed, it's redundant. Removed. Thanks. Fixed. Fixed, thank you. I'm not sure about my implementation. callUtil.kt looks like an API. I'd prefer fix issues with it at first, then move it to another place :). Done. Done, thank you. Replaced some of these constants. It seems not critical since unsigned types are in boxed form in a Sequence. Yes, we can. Will be fixed later.. Here's just a type of a counter to link a unique integer value with each item appeared in the stream/sequence. We need an ability to increment the counter from the lambdas, therefore simple Int variable is not suitable. . Yes. We reuse code for java streams and implementation for java knows nothing about immutable collections and modify them.. ",
    "hho": "Since the other variants are all called checkRangeBounds, I would prefer that name for the unsigned variants as well.\nOr, because there are so many of them now, just replace all of them with the single\ninternal fun <T : Comparable<T>> checkRangeBounds(origin: T, bound: T) = require(bound > origin) { \"Random range is empty: [$origin, $bound).\" }. Interesting. I tried it on try.kotlinlang.org and it compiled fine... But you're of course right, it doesn't work on runtime (`ClassFormatError`).\n\nI'd say, that's a compiler bug though - it should never create invalid .class files\u2026. ",
    "hsyed": "Yes javaClass.classloader is probably the same as Classloader.getSystemClassloader (or a superset ? ) \nTo ensure a pristine classpath. I think the parent class loader should be null on jdk8 (boot classpath) and use Classloader.getPlatformClassloader on jdk9. \nI don't know if the boot classpath has tools.jar loaded though, if it doesn't I think a compat classloader should be created for jdk8.. @yanex could we prioritise a fix for this -- it's quite problematic. What about using this to select the default ? \n```\nimport java.net.URLClassLoader\nimport java.nio.file.Paths\n/\n * Select a clean parent classloader containing the java compiler. The classloader must not descend from the system classpath. [candidate]\n * should generally be set to some class from the compiler distribution (for example kotlin-compiler.jar or kotlin-annotation-processing.jar)\n * to enable efficient use of a user prepared classloader.\n \n * @param candidate an optional context classloader. If this is provided then it is first checked to see if it contains the compiler\n *  classes.\n * @throws IllegalStateException if [candidate] descends from the system classloader.\n /\n@Throws(IllegalStateException::class)\nfun selectJavacClassloader(candidate: ClassLoader? = null): ClassLoader {\n    fun ClassLoader.descendsFromSystemClassloader(): Boolean =\n        when (this.parent) {\n            null -> false\n            ClassLoader.getSystemClassLoader() -> true\n            else -> this.parent.descendsFromSystemClassloader()\n        }\nif(candidate != null) {\n    try {\n        candidate.loadClass(\"com.sun.tools.javac.Main\")\n        check(!candidate.descendsFromSystemClassloader()) {\n            \"compiler context classloader descends from the system classloader\"\n        }\n        return candidate\n    } catch (ex: ClassNotFoundException) {\n    }\n}\n\n// If jdk9 the platform classloader should provide access to the compiler classes.\ntry {\n    return ClassLoader::class.java.getMethod(\"getPlatformClassLoader\").invoke(null) as ClassLoader\n} catch (t: NoSuchElementException) {\n}\n\n// Not on JDK9 so create a pristine classloader descending from the boot classloader.\nreturn URLClassLoader(\n    arrayOf(\n        Paths.get(System.getProperty(\"java.home\")).let { path ->\n            path.takeIf { !it.endsWith(Paths.get(\"jre\")) } ?: path.parent\n        }.resolve(Paths.get(\"lib\", \"tools.jar\"))\n            .toFile().also { f -> check(f.exists()) }.toURI().toURL()\n    ),\n    null\n)\n\n}\n```\nThe bazel worker currently loads kotlin-compiler.jar and kotlin-annotation-processing.jar into a Preloaded classloader along with tools.jar (if not jdk9).. I haven't tested the code -- I don't generally develop with gradle or build the kotlin compiler jar (yet). The solution I presented is to prevent the system classloader being a descendant of the kapt classloader -- which is needed to prevent collisions with the kotlin bazel builder classpath.\nI've done a once over for your problem statement. I'll commnet on this part now:\n\nThe project is built with Buck and uses Butterknife which depends on tools.jar. In this case, the ClassLoader that Kapt creates doesn't have tools.jar at all, causing a ClassNotFoundException.\n\nThe kotlin builder:\n\nloads kotlin-compiler.jar and tools.jar into a disjoint classloader on jdk8.\nloads kotlin-compiler.jar and inherits from platformClassloader on jdk9.\n\nThe buck kotlin integration might need to be updated similarly ? . ",
    "inktomi": "I didn't notice this! Adjusting, thanks for looking this over!. I was trying to find a better way to do this using the PSI elements, but nothing seemed to work. I am relatively new at PSI though, so I'm very much aware that I could be missing something obvious. Please point it out if you know!\nI need to handle things like @Retention(RetentionPolicy.SOURCE) but also @Target(CLASS, PACKAGE, METHOD) in a way that lets me know the type of the arguments, so that I can map the old Java arguments to their Kotlin versions. . ",
    "karen-sch": "Space added :). ",
    "TWiStErRob": "This is a valid warning, E.Companion.foo is being referenced as Companion.foo, which is redundant since the companion object is in scope. This should be E1(foo) in .after.kt.. Self-referencing our own companion object is always redundant, similar to how we never qualify static methods when inside the class that declares it.. ",
    "xaviarias": "OK done. ",
    "ivanpopelyshev": "I don't know where to put it :) Which global namespace do you recommend?. ",
    "0legg": "I guess all these call are intentionally alphabetically ordered, thus sumByLong should go below sumByDouble. ",
    "ilmirus": "The wording here suggest that mutex is being held in synchronized block, which is not the case.\nIt should be either more general ... suspension point is inside a critical section or just two different error messages.\nAdditionally, can lead to runtime exceptions part shall be omitted, since this is an error, not a warning. The code does not compile and thus cannot lead to runtime exceptions.\nThe rest is OK.. Well, ideally, name should be kind of similar to the message.. ",
    "MicleBrick": "Do you mean it could be e.g 0 as the result when less than a ms has passed? That does still happen with System.currentTimeMillis().. I see what you mean, but I'm not sure if using currentTimeMillis is a better solution than just rounding it properly, since on some machines that's actually a 1/64 of a second instead of 1/1000. Would dividing it by a double and using roundToInt be a better solution?. ",
    "burakeregar": "You are right, I missed that. Fixed and pushed. Thanks @mglukhikh . ",
    "DennisHartrampf": "I'd rather use contains, because it is more consise:\nsuggestion\nprivate fun String.hasUnderscore(): Boolean = contains('_'). ",
    "morj": "Well, I am not a domain expert, but I can easily change this to maps of String.. Fixed. "
}