{
    "mitsuhiko": "Damn. Will fix that somehow.\n. Fixed in 2.5.5\n. This was never supposed to work though. The correct syntax for this case would always have been this:\n{{ (someobj|string)[:16] }}\nNow I might finally properly support that in a new patch release, but there is a reason why subscriptions are not supposed on filters: they are confusing.  Because filter names can contain dots, this for instance would not be valid at all:\n{{ soneobj|string.upper() }}\nThis will give an exception that there is no filter named upper. Again, I am fine changing so that foo|filter[foo] works, but I think it's not a bad idea to change this behavior. I agree that this should not have been done on a patchlevel release, but this was caused by a bugfix for another syntax problem with priorities.\nThe core issue is that filters have completely different binding rules and are designed to support filter chaining. However there is actually currently one expression that can be applied after filters: calls. This is also was not a very clever design principle, but it was tested and supported earlier on.\nI suppose a possible fix would be fixing this in 2.5.6 and then introducing a deprecation warning in 2.6 for both function calls after filters that are not using parentheses and {{ foo|string[42] }} instead of {{ (foo|string)[42] }}.\nWould this be a possible upgrade path?\n. Generally that problem arises because foo.bar is supposed to be mostly equivalent to foo['bar'] and that cannot be achieved for filters due to their ability to have dotted names. And I don't want to introduce context-sensitive exceptions.\n. Actually, one might solve that ambiguity also by using explicit parentheses on the filter if I would make it possible to use [...] after filters:\n{{ foo|string().upper() }}\nNot sure how nice this looks on the eyes though. What would be the use case for subscribing after the filter in your case? If it's common enough I see no reason in deprecating that functionality in general.\n. Another usecase that came up is this:\n{%- for c in current_category.fullpath|list[:-1] -%}\n. For of all, I would not use a tag for \"url\" but instead just put a function into the context. Reasoning: can be used in expressions which makes i18n support easier etc.\nSecondly I am for improving the extension mechanism there, but I am not sure yet how that is supposed to look like. Ideally there would be a way for a template to dynamically load an extension if necessary, but the current extension interface is not flexible enough for that. This would requite some refactoring of the Jinja2 internals but it might be worth it.\nNot convinced that changing the extensions dict into an ordered directory is a good idea. You actually can already provide a priority for extensions, not sure if that is taken into account for registering tags though. In case it does not, supporting that for tags might be a quickfix.\n. The template is not complete. Please provide a full testcase.\n. That problem might be caused by having leftovers from Python 2.6 in your cache and now Python barks on broken bytecodes. You seem to have fixed it by changing the timestamp of the templates. To fix this you might just have to flush your cache.\n. Can you confirm if this fixes the problem? If yes I will close the ticket.\n. The proper solution would be detecting that. I will try to see if that can be accomplished.\n. Jinja 2.6 will detect that. For earlier versions I added a note to the changelog, I hope that Google picks it up.\n. Thanks. Pulled.\n. Undefineds now support attribute errors for special attributes.  This closed by 6a3e95d008ac1e3cc893a949ac94ec4ba9c63d7d\n. Fixed.  But only for \"__\" and I had to adapt a testcase to that changed behavior too.  This will be in 2.6 and not in a bugfix release of 2.5 if there is another one.\n. This is fixed now.\n. What exactly is this supposed to fix? Attributes are already looked up and for chaining attribute lookups you must call this function for each dot. Otherwise sub attributes could not be items.\n. Can you open an issue for groupby not supporting more than one dot? That should be fixed there, not in the getattr function on the environment. Reasoning: this has specific requirements and must not change in a backwards incompatible way because people subclass this. Jinja2 already has the sandbox which also subclasses this.\n. groupby now supports attributes of attributes.  This closed by 9573b663d5327bcb644f6776082c832ec0f49b44\n. Invalid use of slice() as discussed in IRC :)\n. Thanks.\n. How do you know you are affected by this issue? You get something along the lines of \"Unbound variable l_SOMETHING\" found.\n. This is finally done.. Thanks. Pulled.\n. Thanks.\n. Thanks.\n. Looks good.\n. Thanks.\n. Makes sense. Implemented.\n. Thanks.\n. Thanks a lot.\n. This is unlikely to change.. Looks good.\n. I will keep it in mind for the new compiler backend, but in the current one that is not possible to achieve for performance reasons.\n. I'm going to close this.  This cannot work in all cases in Jinja2 and I do not really wish on supporting it.\n. Yeah. Those examples got never updated. I fixed that particular one, but I might just remove or replace them at one point.\n. Thanks.\n. Thanks.\n. Nope, that's perfectly fine.\n. I am not quite sure where the confusion is. The blocks of the inner child just replace the blocks of the parent template. Let me know if you have a better example for the docs that is less confusing.\n. Blocks are indeed globally unique. From the layout template inwards each block overrides each other with the same name. In this case base.html is taken, that head is replaced with a new head that supers into the old one and the new title is placed in the layout template's head which is supered.\n\nAnd why even make this possible?\n\nThe behavior is sound and compatible with Django. It works very well in practice and allows a variety of idioms and never caused any troubles as far as I know. You're the first person that ever filed a ticket for that :)\n. Consider it being a class. Each block is a method. When you declare a new block you will not only declare the method, but also call it at the same time. That's pretty much how it works.\nDon't spent too much time thinking about it really, it works best if you just give it a try :)\n. > I think what you're saying is that you're not really sure what the rules are yourself\nHeh. No, the rules are actually quite simple internally and clear defined. If you really want to understand the implications entirely, here you go:\nEvery block in the template is hoisted out of the toplevel template code. It's then given an entirely separate scope and registered on the template runtime context. If you extend another template the current execution context is used as the basis for the template you are extending from and that will then use your blocks over the one from the other template. Additionally from that point onwards (after {% extends %}) the template you were just executing continues to execute but will no longer output anything. This is documented behavior and can be neatly abused:\nhtml+jinja\n{% if parent_template %}{% extends parent_template %}{% endif %}\n<!doctype html>\n<title>{% block title %}{% endblock %}</title>\nAll this here will be entirely ignored if the parent_template variable is not falsy\nand the blocks will be shifted to the template we then extend from.  If however\nparent_template is not defined we will use this instead.\n{% block body %}And this block again is hoisted{% endblock %}\nThe problem is that this is quite confusing behavior most people have not use for and is pointless to show in the documentation. It's however defined behavior and an implementation detail.\n. I actually spend a lot time figuring out useful semantics for the inheritance because Jinja2 supports dynamic inheritance which was not in Django at the time and still is not to that extend and Django's semantics for template inheritance appeared to have happened by accident.\n. > That's good to hear. So can you answer my questions?\nSee comment before that.\nAbout the block defined twice per template on different levels: Jinja2 will not compile that and complain about the block being defined twice.\n. Indeed :D\n. Thanks a bunch.\n. You can customize how Environment.getitem works by overriding it.  I would do that instead of changing the semantics of the template engine for everybody :)\n. It also seems to be pretty good at trashing newlines. Have to check what the actual changes are :)\n. Appreciated :-)\n. Duplicate, already implemented.\n. The filter thing is pretty neat. What concerns me a bit is that it does not support arguments for the tests which might be a problem. For instance divisibleby is not useable with filter. Maybe have a filtertest() that forwards all arguments to the test function. Generally however that looks pretty cool and I would be happy pulling something like that.\nI will play a bit around with how it works and how it could be improved.\n. Another thing is that i want to slowly deprecated 2.4 so that hack won't be necessary for 2.4. If 2.4 is detected just raise a runtime error if the key parameter is used.\n. Generally that looks all pretty good. For the filter i would also forward the kwargs to the test and only pop attribute if test is not passed and prefix invert with an underscore:\nhtml+jinja\n{{ foo|filter(test='my_test') }}\n{{ foo|filter(test='my_test', these, are='args') }}\n{{ foo|filter(attribute='my_test', _invert=true) }}\nThe reason for prefixing _invert would be that this way clashes with a test having an keyword argument named _invert is less likely.\nThe groupby change I think makes sense. I think it should not cause any problems in practice.\nRegarding TypeError vs FilterArgumentError I think it would make sense to have a helper that asserts the type and otherwise raises the FilterArgumentError. Reasoning for that: if filters raise a FitlerArgumentError you can catch that down easily and do something else. This makes it possible to better try something and if it fails, attempt something else instead without hiding errors.\n. Something else that I think would be cool to have is a map function that works like filter but does what python's map does and uses filters instead of tests:\n``` html+jinja\n{% for username in users|map(attribute='username') %}\n  {{ username }}\n{% endfor %}\n{% for username in users|map(attribute='username')|map(filter='upper') %}\n  {{ username }}\n{% endfor %}\n```\netc.\n. I don't like deprecating things in the template language aspect of Jinja2. There is not much value in that. Also the way that join and sum work is that they don't have to buffer up things if they take the attribute directly and it's more expressive. I don't mind having more than one way to do things in the template aspect of things if this means that I don't break backwards compat.\nRegarding the FitlerArgumentError the usecase is that if you know that an invalid argument to the filter raises that exception instead of type error you can catch down an invalid invocation separately from something inside the filter breaking because of a bug in the filter. Especially in combination with the sandboxed execution that is a nice feature to have.\n. Instead of the invert I would add a filterfalse in that case.\n. A small version of this is now implemented in a different form.\n. Not sure what the reason for the metaclass is exactly. Why does it have to be an ABC?\n. Ideally this can just stay in user's code.\n. Fixed.\n. This is done now.\n. I am closing this issue. For reusable macros you really should move them into separate templates.\n. Is there any chance that this is not necessary with the new lstrip changes?\n. Can be controlled now.\n. That already exists. Use {% else %} on a for loop. Unfortunately we had else before Django created empty and renaming it now to match Django semantics is kinda weird.\n. The else block in Jinja works like the empty block in Django already. No change is necessary here.. Not a fan of it for the time being, might need another name.\n. Can you provide a testcase for this?\n. This changes behavior and was never intended to be supported. However since the whole scoping is something I want to overhaul I will decide in neither way right now and try to find a solution that is compatible with the current behavior and would support blocks be defined in included templates.\n. I merged this now.  I don't see how this breaks anything currently.\n. For a long time I was against url encode filters since they are encoding specific but now that everybody agrees on utf-8 as URLs it's probably fine. However I would love to see the filter accept dictionaries as well and automatically encoding them correctly.  Also one name for the filter is enough :-)\nLastly: needs tests.\n. > It has tests! What's wrong with them?\nNot sure how I missed them. Never mind then, but improved tests are always awesome :-)\n\nWhat's wrong with having multiple names, especially when the function-name is so hard to remember like this one? It just makes it easier to use.\n\nBecause filters are intended to be sensible defaults to hook others in and especially with urlencode it would be awful if someone who wants a different encoding behavior would have to override all the aliases for it as well. Especially if new aliases are introduced later.  We only use aliases for core functionality that you don't want to change or is changeable from a separate API hook (for instance the autoescaping mirrors to the |safe, |e and |escape filters).\nIt is encouraged to alias filters as necessary in your own application.\n\nIt feels a bit like a trial by fire.\n\nI'd rather have my contributors go the extra mile for a better final result than to pull things I regret later. Learned that the hard way.\n\nHow's it look now?\n\nI pulled it but had to rework the implementation for Python 3 compatibility.\n. > def datetimeformat(value, format='%d %B %Y %H:%M'):\nIn theory I'm all for that but the problem is that strftime on Python 2.x is not unicode safe. Also it does not work for dates before 1900. That's the reason why this was never added and we documented the use of babel instead.\n\ndef skip(s, skip):\n\nWhat's the use case for this? Not that I'm against such a filter but it seems fairly specific.\n. Fixed in #637. In jinja2 this also gives you nothing. The second level of nothingness gives you exceptions:\n{{ missing_variable }}\nThat's perfectly fine\n{{ missing_variable.attribute }}\nThat will give you an exception taht missing_variable does not exist.\nThis behavior is customizable: http://jinja.pocoo.org/docs/api/#undefined-types\n. You will need to create an assignment to a temporary variable before that. Or use the stack to your advantage and call back to a function on the extension.\n. Why can't you use a extension method callback?\n. Not a bad idea. Though the default should probably be undefined for consistency with the inline if expression.\n. For just renaming purposes I don't want to break backwards compat.\n. Fixed.\n. Jinja paths are always slash separated. They are translated to backslashes by the filesystem loader automatically.\n. Why? The whole purpose of the templates is that they are os agnostic. -1 on this. The templates already load flawlessly on windows with \"/\" which is translated to a backslash when loading from the fs on the fly.\n. This issue tracker is not for help requests. See docs/irc channel/mailinglist.\n. This will destroy different kinds of whitespace. This is better solved with unicode regular expressions.\n. Eg:\npython\nfor item in re.compile(r'(\\s+)(?u)').split(...):\n  #item is either whitespace or item\n  ...\n. No, no, no, no. That interface is horribly broken. We ripped this out for good when we went to Jinja2 and I don't want to see this coming back. Jinja1 was one of the first template engines that supported that endpoint and it just caused a ton of problems. All modern webframeworks stopped supporting that.\n. This is fixed with #637. Since Jinja2 has no break that would be quite useless. I know there is a break extension but I have never ever seen anyone using it. :-)\n. I don't think this is the only problem with the docs on 3.x. I don't really have plans to make them compatible with 3.x at the moment, but feel free to provide patches.\n. Removed because people might already use the error message somewhere in UI but don't want to show the search path to users.  Have seen that before :(\n. Traceback annotation can be disabled by overriding the handle_exception method:\npython\nclass SimpleEnvironment(Environment):\n    def handle_exception(self, exc_info=None, rendered=False, source_hint=None):\n        if exc_info is None:\n            exc_info = sys.exc_info()\n        raise exc_info[0], exc_info[1], exc_info[2]\nThe real solution here however would be to force the import of jinja2.debug ahead of time I guess.\n. Fixed by #637. Yeah, I wanted to fix this a long time ago but I'm afraid of breaking templates that rely on that by accident :(\n. Closing this for the time being since I have not processed it in a long time.  Do you still think it's useful?\n. This is done now.\n. Can someone send a pull request for this?\n. Thanks. applied.\n. This is done now.\n. Outside of the scope, Use babel and register the functions from there :)\n. Yeah, closing this.  Accepting a patch for making the target a keyword argument however.\n. Closing this for the time being.  This would require some iteration in a separate package first and then we can bundle it.  Not sold on the exact behavior of it.\n. This is in 2.7 now.\n. That's a very inefficient way to do this.  That's why it was removed :)\n. I like that, thanks a lot.  Merged.\n. This is currently a technical limitation.  Your testsuite should catch that for the time being.\n. Closing this since I am not sure if people care much about IronPython ay more. The last comment here is unrelated.. Dictionaries do not have iteritem methods in 3.x.  You will need to change to .items().  Nothing I can do about that.\n. This is not a jinja2 problem, file that against setuptools.\n. That's not supposed to happen.  Why are you passing bytestrings to Markup?\n. How does this fix anything? (I don't use IronPython)\n. The file object comes from babel. I would expect it to give me one in bytes. I would file that bug against babel and not Jinja.\n. That is intentional.\n. We can't do that nicely, indeed would require moving that into a separate process and timing that out.  I think that's out of the scope of Jinja.\n. This is documented behavior.\n. All loaders accept a charset argument.  Just change the default from utf-8 to utf-8-sig or fix your editor :)\n. Duplicate.\n. You only have the extensions enabled for *.txt not for *.html.\n. I think this is a bit too specific.  You can already do my_obj.x.y.z anyways.\n. That can be easily implemented yourself in your project.  It's too specific for Jinja itself.\n. Never, ever use bare excepts.  Use except Exception instead.\n. Changed.\n. This is possible in a way in 2.7 now:\n``` python\n\n\n\nTemplate('{{ foo.items()|sum(attribute=\"1\") }}').render(foo={'a': 1, 'b': 2, 'c': 3})\nu'6'\n`\n. Why is that necessary?\n. Closing this for the time being until a patch lands that depends on it.\n. Always use whitespaces after `{{` and before`}} as per styleguide to avoid such cases.\n. Outside of the scope of Jinja. That's a Python problem in 2.x.  Register a time formatting filter from Babel to fix it.\n. That does not work.  The context is a data source, not a data store.  They are not supposed to be in the context.\n. That bug report is just odd, regression testcase not needed.\n. That sounds like an internal bug in Python.  File it against that.\n. That should not change anything.\n. Merged into the sprint branch.\n. Applied.\n. Merged.\n. Merged against the sprint branch (it's really only one commit).\n. Fixed.\n. Fixed now though.\n. Sorry for that. Merged :)\n. This is implemented now.  I think it's useful.\n. There is a bug most likely. I'm looking into that currently.\n. Thanks, fixed in 2.7-maintenance and master.\n. Reverted, going to be in next maintenance release.\n. Do you have an exact testcase to reproduce?\n. Just to confirm: I cannot reproduce this currently.\n. Just two quick things:\n\n\n\nUndefined objects have the \"_undefined_name\" attribute which is the name of the variable that does not exist.  So that might already help you.  Aside from that there is the meta api: http://jinja.pocoo.org/docs/api/#the-meta-api\nThat one might help as well until I change anything.\n. Too specific.  Salt should rather implement that itself.  Also this pull would not work on Python 3.\n. Bitwise ops should not be used in templates. Expose functions if you need to.\n. This is fixed in maintenance now.\n. Why is this useful?\n. I see what the original bug was now and corrected that in a better way.\n. The problem is that imports are cached but not tracked. I'm not sure sure what the best way to deal with this would be.\n. Considering you get two lists and not a list with two items I assume you are running your code twice.  Cannot reproduce myself.\n. I like keeping that unclear at the moment because there has never been a decision on what they are.  Right now the naming rules are platform specific but the Python 2.x subset always works.\n. That looks incorrect.  The |format is inside the dict, not outside.\n. I am torn on that.  If it should come, then as a command line tool that installs through setuptools.  But I am not sure on what features it should have and how to load the context etc.\n. Not sure if this would come up in practice. Closing this down unless reopened with some reasons about why this comes up.. @ThiefMaster however why is there stuff in the first place. I mean undefines are clearly not the only issue there :). That's intentionally not supported though. You cannot import from files that also have other shit going on.. I mean, if we want to support that we need a complete new compiler mode that also has some other potential disadvantages: eg: conditional macro defines.. I can see that this is frustrating but I will not \"patch\" a broken system.  This whole context system needs revisiting.  Changing this now could wreck even more havok.  Instead of using includes you should be using imports to macros and pass the things you need to pass.  More predictable.\n. I'm trying to figure out at the moment what I can do.  The best thing would be if I would sit down and take my time to fix the scoping.  But I don't have the time right now for doing it.  I just don't want to break it any further.\n. Fixed in #637. Jinja2 is for more projects than just Flask so I do not want to add that to the docs :)\n. That sounds like a good idea for the new filter support.\n. Sorry for not handling this for so long.  I'm trying to fix this.  For the time being, send me an email if you have any more requests that need proper review to jump ahead of the github notification list.\n. I don't want to change this as this would cause performance of these functions to do down which normally are only used with iteration.  |list fixes it.\n. Not going to happen.  This is a crude hack that's too easy to break :)  If you want that a new filter would be required but why not use .format() then directly?\n. Will come with next release.\n. Yes.  This is currently the case.  This is related to the general problems with scoping in Jinja2 that need to be tackled.  Unfortunately that is a very big change and I am not sure how to fix this without spending a lot of time on it.\n. Fixed.\n. Sorry for the lack of feedback on this.  I completely lost track of this issue and I did not subscribe to the red hat ticket so i failed to see the continued discussion.\n. 2.7.3 has just this fix in now.\n. This is tricky to do because of how the loaders work.  For development purposes I would recommend disabling the template cache until this is properly fixed.\n. Merged but 2.5 is no longer supported.\n. Please, please, please, please do not use setdefaultencoding.  There is a workaround for this in Jinja now but please do not use it.  Use unicode strings correctly.\n. Unfortunately not fixing see #269.\n. There are a bunch of problems with this: first it changes behavior, secondly it does not work on any platform other than windows (because os.altsep is None).  Also I do not see what this fixes.  You should always be using / in templates no matter what OS.\n. Why would yu use os.getcwd() for loading templates though?  File system paths have nothing to do with jinja template paths.  Not even close :)\n. But the template name is always slash separated, no matter the loader.  It was never supposed to accept file system paths and I am pretty sure it's not documented anywhere to support it.\n. Oh god. Do people really do this? This is just terrible. For that alone I should probably not fix it :)\nOn a more serious note though: Jinja2 will break in other mysterious ways if the default encoding changes I'm pretty sure.  I can fix this particular instance but I doubt that this will be the end of the pain.\n. I will be fixing it, but i need to go through all cases now where this happens\n. Looks like the other cases it makes sense to not fix.\n. Not going to merge this, see other comment.\n. This was a regression from the python 3 port.  Fixed.\n. This is a restriction of the parser.  I don't think this can be fixed.\n. This is a Python 3 bug.  There is a workaround for this in place now but please file this against Python itself.\n. I don't think this can be improved.\n. This cannot be changed without breaking stuff.  You can easily customize this however yourself by making the getattr on the environment less \"clever\".\n. Closing this as I have no idea how to deal with this issue :)\n. There are versions of Jinja2 that support 3.2 and older.  They are just not the latest release versions.\n. There was a length calculation mistake.\n. There is a |reverse filter.\n. Na, that behavior was just crap and broke with the Python 3 port.  Fixed now.\n. Fixed.\n. This can be easily implemented as a function.  I do not want this in the core to be honest.\n. This would require patches as I'm not using pgettext myself.\n. New release soon, then you will have that function.\n. The try except is fine.  I think this patch can be used.\n. Please do not add detailed classifiers.\n. I implemented this now through a factory function but not by changing the behavior of the default undefined type.\n. It's out of the scope for this filter as there are too many edge cases.  You can register a different filter that works for your rules.  I cannot change it now without potentially breaking people's stuff.\n. This won't happen because there is no set literal for an empty set.. I do not see the value of this pull request.  What is the problem with the escaping that markupsafe provides?\n. I'm going to close this issue.  Using the escape filter without quotation marks is not supported for a good reason.  There is nothing wrong with the escaping provided if you enclose your attributes in standard conformant quotes.  If you do not do this, there is no escaping in the world that's going to help you.\n. The original issues is fixed in 2.9 with the new identifier tracking. The block issue is unrelated and tracked in #603 now.. I'm going to close this issue. This happens if the i18n extension is installed but no gettext function is provided. This is a configuration problem of whatever integrated Jinja into a project.. This is sort of intentional as it always scopes to the closest macro. Closing as wontfix.. Yeah, we might want to put that into the docs.. Also for future reference: Jinja can iteratively render templates with the stream system.\n. This is actually a \"bug\" with .format which does not support string coercion on Python 2.  We intentionally do not issue string literals as unicode literals on python 2 if they are in the ASCII range as APIs traditionally use coercion on it.  I would file this as a bug against Python and not Jinja :)\nWhen they introduced .format in Python 2 they applied Python 3 semantics on it. This does not work well with how Jinja is structured.  I don't think I can do anything about this without breaking other code that requires bytestrings.\nTraditionally datetime.strftime could not at all work with unicode strings for instance.  Maybe we can slowly relax that requirement but there are still lots of apis that break when unicode data is passed on 2.x\n. ``` python\n\n\n\n'%s' % u'\\N{SNOWMAN}'\nu'\\u2603'\n'{}'.format(u'\\N{SNOWMAN}')\nTraceback (most recent call last):\n  File \"\", line 1, in \nUnicodeEncodeError: 'ascii' codec can't encode character u'\\u2603' in position 0: ordinal not in range(128)\n``\n. @jeffwidman note that%` does the same thing anyways.\n. This turns out to be priorities in Jinja2.\n\n\n\nCurrently\n'us-west-1' is matching '(us-east-1|ap-northeast-1)' or 'stage' is matching '(dev|stage)'\nMeans\n'us-west-1' is matching ('(us-east-1|ap-northeast-1)' or ('stage' is matching '(dev|stage)'))\nInstead of what makes more sense\n('us-west-1' is matching '(us-east-1|ap-northeast-1)') or ('stage' is matching '(dev|stage)')\nNeed to figure out how to improve this.. This has nothing to do with Jinja but the configuration of the autoescape settings you have configured (or the framework where JInja is included).. It has been like this for years now, it's kinda late to rename it ;(. The docs are generally in Python 2 syntax.  We might change that once more people start using Python 3, but for the moment we stick with where the user base is.\n. Implemented in a slightly different way.\n. Not a bug, you need to open the file in binary mode.\n. Not going to happen for a wide variety of reasons, the biggest one being that it cannot actually be done in a sane way because of jinja being based on generators.  I also would like to see first how the uptake on this is before committing on supporting something I'm not using myself.\n. Yeah, we can't change that sadly. Closing here.. This is a usage error. It should be undefined = StrictUndefined.. It's not the function that is failing but the way you invoke it. The function cannot escape Jinja semantics. This cannot be changed.\n. That is not supposed to work with the default Undefined object.  You can make one that propagates undefineds further if you want.\n. I will close this because I can't reproduce it at all. If someone has more information please make a new ticket with more information.. If the environment is None the only real explanation I have is that the interpreter initiated a module shutdown which means that the last reference to the module was cleared. I am not sure what would cause this.. I assume this always happens with Environment.compile_templates?. So just looking at the code the module package reference in sys.modules is a weak reference. If for whatever reason the Environment (or the attached loader) would get garbage collected then modules would also tear down which can cause this.\nI imagine that this could happen if you have an application that shuts down execution but outstanding HTTP requests are still in the air.. To investigate if this is the case you could do this:\npython\nimport sys\nenv = Environment(loader=ModuleLoader(...))\nsys.modules[env.loader.package_name] = env.loader.module\nThis changes the weak reference to a strong reference. If that stops the problem then your issue is that requests are in flight while the environment was already collected.. @squfrans which feature are you referring to here? The compiled template loader is working just fine for the vast majority of users from what I can tell. I assume this is most likely in combination with a specific setup.. For what it's worth the X becomes None behavior is not at all unique to Jinja. This is a core Python problem for many years related to module shutdown.. This won't change because it would require special casing floats. I'm happy to accept filters to improve float rendering in general for specific cases.. I agree it would be reasonable to change this. I think this might have been the result of an optimization.\n. This is not supported and will unlikely to be supported.  We already have a very complex call code generation to cover different Python versions and I'm not super happy changing this now.. This filter really does not work on html input and Jinja2 will not gain an HTML parser.  I'm going to close this issue against Jinja2 here.\nHowever maybe someone wants to make a pypi package that implements this.\n. Why not use {{ users|rejectattr(\"email\", \"equalto\", \"foo@bar.valid\") }}?\n. No, I don't think that works still.  However it now explicitly only does some of it's behavior in the ascii range instead of relying on str() working in ascii only.  Jinja requires unicode strings and assumes the default encoding ascii in Python 2 for coercion. Everything outside of that is unsupported. I am not sure what this change means with regards to what roundup does.\n. The issue in question is #304 btw.\n. > I wonder if it is possible to subclass unicode object that Jinja2 uses, to override concatenation and addition methods to get control over encoding conversion back to Jinja2?\nThe main issue that jinja encounters there is that it uses different tricks for unicode conversion.  For instance it uses u''.join((a, b, c)) and u'%s%s' % (a, b).  Those should use the default encoding so it's just a question to align the others.  But as I do not really care that much about this it would need patches and I would only accept them if it does not degrade performance too much.\n. There used to be tests but because those internals have not been touched in ages it no longer exists.  There are some manual tests you can run though in the examples folder I think.\n. I really hate the include tag and wish I would never have added it. Because of that I'm not so sure if I want to extend it at this point. It's so buggy :(\n. Fixed in d5077a0b148d52572d886726bef7647b51978d95\n. Because the urlencode filter does not escape slashes. Is there a specific reason why it has to?  To clarify this: it only encodes slashes in the value position of passed key/value pairs.\n. Slashes are reserved characters in the path component and the more common behavior is to encode everything but slashes there when forcing things to url encoded behavior.  The alternative (to encode slashes to %2f) does not even make sense as most servers outright reject those requests due to security problems as backend servers typically cannot distinguish %2f and / in the path component as they operate on decoded octets.\nSo the only part where a slash actually makes sense encoding is in query strings and this is where the dict based encoder that urlencode has works like that.  However even there a slash does not have to be encoded, so there is no reason to force it to be encoded.\nThe urlencode function should use for most people by default that's why it does not encode a slash.  If you have custom requirements then you can override the function in your filter registration. \n. That's fair enough but in practice it's not necessary there either and included credentials are deprecated anyways. Since those are unlikely to be produced within templates it's an edge case that is not really worth considering.. @danielkza what stops saltstack from providing a filter that does that?. Jinja attempts to provide some commonly used functionality. We have two modes for urlencoding which gets you about 95% there. You can encode entire querystrings by encoding a dict and you can encode to a common set which is valid for paths through urlencode on strings.\nWe don't do anything other than utf-8 or that. Because where would it stop. There are too many parts of a url, there are iris and they all have their own kinks. When we are there, why not just also provide a punycode encoder for the netloc?. Not sure what exactly you mean with \"additional nodes into the AST at compile time\". Obviously you can return as many nodes as you want for as long as the nodes are statically determined.\nIn particular \"I would like to change xx in the previous examples based on the context\" does not work as the context is not available at compile time.. I think this should no longer happen with the cleaned up identifier tracking.. This is no longer used now.. We can't turn this off now without breaking everybody's code. I am however happy to update the docs accordingly. I will close this as a wontfix but feel free to open a PR for documentation updates.. Going to close this.  This will not happen in core Jinja2.. Closing this because I am not sure what this issue is describing. Feel free to reopen with more information.. This does not appear to be a jinja2 related issue. Neither is there enough information available, now is the error message one that comes from jinja.. Duplicate of #603. This is part of the stable API but intentionally not documented.. This is very hard to answer. Jinja itself should not exhaust the memory here. You would have to run some testing here to see what is actually at fault. My guess is that whatever objects is, is actually not an iterator but something that buffers internally all the objects.\n. This is unlikely to happen. You can already use ${variable} if you want. The problem is that variable delimiter parsing is pretty tricky because once we add $foo the topic will come up about $foo[0] at which point the can is open for $foo[expression + here] etc.\n. This might be a problem with the optimization code in the compiler.\n. This actually is intentional now that I look at it. The autoescaping code is disabled if set to False. You can however set it to a function that returns False: autoescape=lambda x: False and the initial value of the autoescape flag is set accordingly.. This has actually nothing to do with macros. This is an unfortunate effect of how auto escaping is implemented.\nThe autoescape flag does not just enable the default setting of the value but also enables the feature in the first place.  The jinja2.ext.autoescape extension which changes the value of the autoescape flag requires autoescape to be enabled.\nautoescape can be enabled in two ways: It can be set to true which enables the autoescape feature and sets it to \"perform autoescaping\". It can be set to false which disables auto escape mode and disables autoescaping entirely. Unfortunately this does not block the use of the jinja2.ext.autoescape extension which will perform incorrectly in this case.\nThe third mode is to set autoescape to a callable. Then autoescaping is enabled as a feature and the initial value of autoescaping for a template is decided by the return value of the function. So the correct behavior to enable the autoescape feature but disable it by default for a template is to set autoescape=lambda x: False.\nI hope that explains the feature better.. This btw has nothing to do with macros. This would come up in other situations as well.. I can see that behavior being confusing however. I will investigate if I can improve on it so that the compiler support for autoescape does not depend on the initial flag.. Going to reopen this and investigate if we can improve here.. Turns out this is actually not even the case I had in mind and you are right that this makes no sense. I fixed that now. This actually turns out to be an issue with the macro deciding at compile time what the autoescape flag will be which is changed at the time the call happens.\nThe code already dealt with autoescape being flipped at a later point through the volatile flag which seems to work from what I can tell.. I would just remove it from the docs but keep it the code. People can already overwrite it if they want by that name and it's easy to support.\n. As it stands if you want to support 2.x and 3.x, % is saner to use. .format introduces various problems with unicode handling in 2.x.\n\nPython 3.1.5's docs explicitly suggested it might be removed:\n\nThey just added % formatting back for bytes so I doubt this will be going anywhere. If it is, we can retrofit it.\n. It's tricky to change this now, so I will close this.. We recently added a policy configuration. I'm happy to accept a policy for the url schemes supported. I'm not super happy with the urlize filter as it stands right now because it's not super correct. Instead of piling up on it i rather accept a more generalized PR that improves on it (eg: tld handling etc.).. This is the intended behavior. Jinja has no inline comments.. The with statement is not supposed to work that way, so that's intentional. I cannot reproduce the set issue however independently of this in master.. Nevermind, I see what this issue is about.. Changed in 45b59b522a542c21611214b352df049a3b6dbcb4. Not sure what you are trying to do here. finalize is used on variable expression results and as such  {{ will never be contained in the value in those examples.. It's definitely intentional but I'm not sure what happens now if we change it. Will investigate as part of #637. I'm super undecided on what to do with this. If we want to change this then I'm all for deriving a context for blocks the same way as we do for includes and imports.. Related issue is #546 where variables do not propagate to include because derived contexts are based on the parent and not local scope.. There is sadly not really anything we can do about this.. Relative paths are not supported by Jinja2 out of the box so that's expected.. Thanks!. I added a filter policy for this so you can reconfigure the default.. This basically breaks the test. Not pulling.. Basically needs tests.. I want to revisit this after #637 lands. This will allow us to do a lot of those things.. This is now the default with with context.. Which of the many caches is returning the wrong template?. What's the usecase for this? Would it not make more sense to go through a loader then? The reason is that right now there are some assumptions made about name (can be loaded from a loader) and filename (can be found on the file system).. That does not sound like a terrific idea because it also means that this will be incredibly slow as the parser and compiler kicks in constantly which is very slow. If you have a pattern like this it makes more sense to make a custom loader that uses data encoded in the template name to pick up the correct template.\nIf you can further outline your setup I can help you find a better solution.. @AlJohri so why not do this?\njinja\n{% extends ['lede.html', 'lede-%s.html' % story.id] %}. I don't know what t.lede is but you can make that an attribute that is that list. So just do something like this:\n```python\nclass Story(object):\n    @property\n    def layout_template(self):\n        return ['lede-%d.html' % self.id, 'lede.html']\nrender_template('whatever.html', story=Story(42))\n```\nand then\njinja\n{% extends story.layout_template %}\n{% block body %}\n    ...\n{% endblock %}\nOr whatever else you feel like.. Also not sure why you use includes instead of extends but it works with extends and include.. Correct, that will work.. The main reason I do not want to do this is that it introduces the idea that a template with a name can exist that does not have a loader. I would be willing to add a \"debug name hint\" or something though if that makes things easier but it will not be visible to loaders for template loading then.. This is intended behavior.. Pulling this if you add a test for it and remove the changes to setup.cfg.. That is intentional but you can override the undefined object to change the behavior.. I'm unhappy with the entire urlize filter. I rather have it follow some security policy that you configure with the environment.. With 2.9 this can be configured with policies now.. I want to also push this into a maintenance release because of the security implications.. Released this in 2.8.1.. Open TODOs:\n\n[ ] we use the same scope for the normal loop bodies and else blocks. This generates non optimal resolves\n[ ] we generate some resolves that are strictly unnecessary. Maybe we can do some dead code detection here\n[ ] The logic for undefines changed so that undefined checks are now generated constantly on value use instead of on resolve. This changes Context.resolve to be an API that is no longer used by Jinja internally and might be less efficient. Requires some testing.. Bonus feature: no longer uses locals() which should greatly help pypy.. This should be able to fix #110 now. Still failing but easy to fix.. That might actually not be necessary since we only fold filters anyways. The risk there is lower.. While the current behavior is incorrect, the old behavior is definitely incorrect as well. The {% set %} tag was never intended to override outer scopes. I'm surprised it did in some cases. Not sure what to do here.. The behavior I would assume were correct is an output like [-1:0] [-1:1] [-1:2] [-1:3] [-1:4] -1. . I'm shocked this worked before. Did this always work?. Great. Because the issue here is that this is absolutely not sound. Which variable is it supposed to override? What if there is a function scope in between. eg: a macro or something like that. I have no idea how to support this now.. Apparently before this was caught down with a template assertion error:\n\n```pycon\n\n\n\nTemplate('{% set x = 0 %}{% for y in [1, 2, 3] recursive %}{{ x }}{% set x = y %}{% endfor %}').render()\nTraceback (most recent call last):\n  File \"\", line 1, in \njinja2.exceptions.TemplateAssertionError: It's not possible to set and access variables derived from an outer scope! (affects: x (line 1)\n```. The unbound local error should be resolved on master.. I'm not sure how to progress here. I really dislike that it was apparently possible to do this sort of thing.. With the last changes I'm going to close this as \"works as intended\". If there is further fallout from this we can investigate alternatives again.. I was not aware this is so widely abused :-/ Annoyingly there is really no way to make this work in any reliable way. However I wonder if we can isolate the common use cases here and introduce a nicer api.\n\n\n\nIn particular maybe we want to add something like this (loop.changed_from_last):\nhtml+jinja\n{% for article in dates %}\n    <div class=\"archives-date\">\n        {%- if loop.changed_from_last(article.date.day) %}\n            {{ article.date | strftime('%a %-d') }}\n        {% else -%}\n            &mdash;\n        {%- endif -%}\n    </div>\n{% endfor %}. i was thinking this:\n```python\nclass LoopContextBase(object):\ndef __init__(self, recurse=None, depth0=0):\n    ...\n    self._last_iteration = missing\n\ndef changed(self, *value):\n    if self._last_iteration != value:\n        self._last_iteration = value\n        return True\n    return False\n\n``. @davidism we cannot doset_outer` without breaking the entire scoping system. This would majorly screw up the entire thing.. @roganov a few notes on this:\n\nCould someone please clarify why jinja2 scopes cannot work exactly as python works\n\nBecause Python's scoping is in my opinion really bad, particularly in templates because you can easily accidentally override important information.\n\nWhile @mitsuhiko says jinja 2.8 and below had lots of scoping bugs, it was more intuitive for me to understand how scoping works.\n\nNote that this was the an exception due to a bug and it only worked in some limited situations and purely by accident. Jinja had always the same documented scoping rules and this behavior was never documented. At all times it was said that variables do not propagate to outer scopes. You can easily see this because after the end of the loop the variable was never set.\n\nAlternatively, there should be a document which describes how scoping in jinja works so that we don't have to guess.\n\nI improved the docs already a few days back for this. No syntax will change this because it would still subvert the scoping rules. You cannot do that with either the current compilation or id tracking system. Even if it works for that simple case, what happens if one has a for loop that is recursive. What if someone defines a macro in a for loop. What if a call block appears in a for loop.\nI think it would make more sense to introduce a global object that acts as a storage namespace and can then be modified with . Eg:\njinja\n{% set foo = namespace() %}\n{% set foo.iterated = false %}\n{% for item in seq %}\n  {% set foo.iterated = true %}\n{% endfor %}\nHowever this would require the set tag to fundamentally change.. > could you please advise how to increment a variable on a for loop in jinja template in elegant/right way?\nYou were never supposed to do (or be able to do) this at all. So the answer is don't do that. We are however interested why template authors seem to have the need to do that.. @Molodax you can do this:\nhtml+jinja\n{{ states.sensor|selectattr('state', 'equalto', 'online')|sum }}. Sorry yes, count.. Yeah that sounds like an idea.. @davidism @ThiefMaster i was thinking of just having a storage object available. Like this:\nhtml+jinja\n{% set ns = namespace() %}\n{% set ns.value = 42 %}\n...{% set ns.value = 23 %}\nObviously set can't set attributes at the moment but this could easily be extended. Since no reassignment to the namespace itself happens this is quite safe to implement.. @ThiefMaster it would not work. The way I would see this working is that attribute assignments go through a callback on the environment which would only permit modifications to namespace objects.. Would it be possible to get a minimal repro case for this?. Found a minimal repo. Interesting that this worked before:\n```jinja\n{% macro x(caller=none) -%}\n    [{% if caller %}{{ caller() }}{% endif %}]\n{%- endmacro %}\n{{ x() }}\n{% call x() %}aha!{% endcall %}\n```\nGoing to investigate what this did.. @ThiefMaster it's undefined and yes. I assume the correct behavior will be to just silently ignore caller here. However I wonder if you could set it to a different default before.. Eg. Could you do {% macro x(caller=42) %}...{% endmacro %}.. So you could define a default in the past but only if caller was the last argument I think. If you did {% macro x(caller, foo, bar) %} then it would fail when used with {% call %}.. So turns out this is common. https://github.com/search?q=%22%7B%25+macro+%22+%22caller%3Dnone%22&type=Code&utf8=%E2%9C%93. Not sure if that change is good enough to cover all cases but this is a change I am willing to make. This at least gives it a clear behavior now.. What triggers this compilation?. @djc are you aware of any workarounds for this?. BTW. There are two annoying regressions in 2.9.1 that I will fix now which will most likely mean a 2.9.2 in the next hour or so.. K, will take longer than an hour.. pip explicitly silences this in recent versions: https://github.com/pypa/pip/issues/1873\nGoing to just ignore this then.. I don't even know what this is supposed to do. It sets the arguments to the call block to context store as name context. That seems wrong.. From what I can tell this is an issue in webassets. I left a comment here: https://github.com/miracle2k/webassets/issues/477\nClosing there here until someone proves this wrong :). What does it even mean to have a {% block %} inside a macro O_O.. It does the same now it did in earlier versions however I'm surprised this does something useful.. Yes, there will be another one tonight. I just want to see if there is not anything else creeping up.. Release is out now.. You can use {% for el in data['items'] %} to prioritize the item. This is also covered in the documentation. http://jinja.pocoo.org/docs/2.9/templates/#variables. Why would the JSON response not include items? I'm not entirely sure I see the problem here. Surely you know ahead of time what your data is. You can also in templates check for keys with the in operator on dictionaries already.\nChanging this behavior is completely out of the question because thousands of templates would break if we remove this attribute/item support.. @slisznia you are essentially asking for Jinja2 to completely change the attribute lookup system which has been in place for about 7 years at this point.. Indeed this is a scoping bug that regressed.\nNote to self: this is caused by the filter expression being scoped to the same scope. This needs to be changed to be an independent scope.. Second note to self: the old and new compilation for loop filters is unsound. It compiles to two different modes depending on the extended loop flag but which on the generated code side produces different scoping rules. In extended loops a new frame is needed according to the generated code, in non extended looping the scope can be reused.\nHowever if the latter compilation mode is actually valid is unclear and needs to be investigated.. At least fixing those bugs is easy now but man those regressions suck. Needs better test coverage :(. That's indeed an oversight.. @ThiefMaster not on generated syntax errors.. I assume that might happen if an if-block is completely empty.. Minimal repo\nhtml+jinja\n{% extends \"base.html\" %}\n{% if expr %}{% block wah %}stuff{% endblock %}{% endif %}. For what it's worth I ran into the same issue in Jinja2 on the way to fixing the contant folding. I explicitly had to disable tuple subclasses because of this change. I would be willing to back this out and convert it back to whatever object it was before. I can imagine this causing troubles.. Actually looking at it closer it used to be a plain tuple so reverting to that would definitely remove a valuable feature. I don't think we can back this out now.. One option would be to put it behind a policy but even then it requires a change in ansible to the Jinja config.. Nevermind, we can back this out. It was a tuple subclass already just not a named tuple one. The issue is effectively that this changes repr and a few more things. We could back this out but I would like to have a dialog with ansible people about what behavior one would expect from changes in Jinja in general for this sort of thing.. This was never intended to work and if variables reset or not depended on various factors and it always reset at the end of the loop. This is considered a bug and it's unlikely the bug will be reintroduced.\nSee #641 for an ongoing conversation about it.. Annoyingly this is actually the root of a pretty severe scoping bug which is why I had to change it. IF you did for instance {% with a=b, b=42 %} unclear things would happen under the new scoping rules. This definitely was not intended behavior.\nI'm willing to just define the new behavior the intended one going forward with 2.9.. I agree with @ThiefMaster here. I really would just call the filter in since it mirrors the in operator. Also means that {% if a in b %} is the same as {% if a is in b %} and {% if a not in b %} the same as {% if a is not in b %} which reads well.. I cannot reproduce this at all in Jinja2.  Added this regression test in 3e9937c but it passes.. There must be more to this story. I'm going to close this bug however I will monitor the mentioned issue over here: https://github.com/ansible/ansible/issues/20063. Variables cannot be set in loops and that is intentional. It was never documented that you can override variables from higher scopes and that was considered a bug. See also #641 . You can still do the same as before but you need to give them different names:\nhtml+jinja\n{% set global_x = 1 %}\n{% macro show_x(x=global_x) %}{{ x }}{% endmacro %}\n{{ show_x() }}\nThis is a side effect of making clear behavior for defaults which before was very buggy. This is the same behavior now that you also have in JavaScript with defaults.\nIt's fairly unlikely that this will be reverted. For instance what should a=b, b=a mean?. @roganov you have to consider all cases. Python's default variables are in my mind a huge design mistake because they cause this behavior:\n```pycon\n\n\n\ndef foo(a=[]):\n...  a.append(len(a))\n...  return a\n...\nfoo()\n[0]\nfoo()\n[0, 1]\n```\n\n\n\nWhy do they do that? Because the default is resolved a function definition time and not at function declaration time. If we want to fix this we need to find a new system so I was looking around and decided to align it with JavaScript which has much saner semantics there. And in that case bindings are always referring to the same scope:\n```js\nlet x = 1;\nfunction showX(x=x, y=x) {\n  console.log([x, y]);\n}\nshowX();\nshowX(1);\n```\nThat logs [undefined, undefined] and [1, 1] which is consistent with what Jinja2 does. If you permit a variable to both refer to the same scope binding and a higher scope you end up with loads of scoping issues.. @thmo you will need to file this against your build tool. This was fixed in pip.. @thmo these files are not imported so that is not an issue. Bytecompilation is supposed to skip over files it cannot byte compile as a result of this. pip does this correctly.. Probably makes sense changing, I wonder how an empty template can fail execution though.. Same as with the other PR #673 I do not quite comprehend why this is considered a bug. Under which circumstance would a yield statement for template data fail?. To make this more concrete: get_corresponding_lineno is only used for tracebacks. No error can be generated in the line you're referring to.. I should probably point out that get_corresponding_lineno is not a public API. I am not entirely sure what you are attempting to do but there has never been a commitment from out side to support get_corresponding_lineno.. Maybe previtem and nextitem?. Works for me!. I will have a look in a bit.. Namespaces should use __setitem__ and __getitem__ rather than real attributes. Otherwise we run at risk of letting users set special attributes which can cause security issues.. I think I'm generally in favour of adding that. In the past I used similar things. I will have a look at this.. I'm surprised this happens. I thought the optimizer already rejects this.. In particular this has traditionally been used to avoid this: https://github.com/pallets/jinja/blob/c7dfa21a2b05ffbe440196880fe6a097b95c89da/jinja2/compiler.py#L87-L105. I'm still surprised it even gets to the point where it reprs out an unsafe repr. Do you know which branch causes that?. So this is the better fix but I wonder why we do not check this directly in as_const. I need to see why that was not an issue before:\n```diff\ndiff --git a/jinja2/nativetypes.py b/jinja2/nativetypes.py\nindex 3aca683..fe17e41 100644\n--- a/jinja2/nativetypes.py\n+++ b/jinja2/nativetypes.py\n@@ -3,7 +3,7 @@ from ast import literal_eval\n from itertools import islice, chain\n from jinja2 import nodes\n from jinja2._compat import text_type\n-from jinja2.compiler import CodeGenerator\n+from jinja2.compiler import CodeGenerator, has_safe_repr\n from jinja2.environment import Environment, Template\n from jinja2.utils import concat, escape\n@@ -78,6 +78,8 @@ class NativeCodeGenerator(CodeGenerator):\n                     raise nodes.Impossible()\n             const = child.as_const(frame.eval_ctx)\n\n\nif not has_safe_repr(const):\nraise nodes.Impossible()\n             except nodes.Impossible:\n                 body.append(child)\n                 continue\ndiff --git a/tests/test_nativetypes.py b/tests/test_nativetypes.py\nindex d295466..8bff503 100644\n--- a/tests/test_nativetypes.py\n+++ b/tests/test_nativetypes.py\n@@ -92,3 +92,19 @@ class TestNativeEnvironment(object):\n         result = t.render()\n         assert isinstance(result, bool)\n         assert result is False\n+\ndef test_variable_dunder(self, env):\nt = env.from_string(\"{{ x.class }}\")\nresult = t.render(x=True)\nassert isinstance(result, type)\n+\ndef test_constant_dunder(self, env):\nt = env.from_string(\"{{ true.class }}\")\nresult = t.render()\nassert isinstance(result, type)\n+\ndef test_constant_dunder_to_string(self, env):\nt = env.from_string(\"{{ true.class|string }}\")\nresult = t.render()\nassert not isinstance(result, type)\nassert result == \"\"\n```. Yeah, makes sense to put this in place. I would add the diff at least that I pasted above as a fix for that issue. Worst case this feature goes in slightly broken and we can improve on it.. If someone sends a PR with a better solution I'm happy to merge. But it needs to still match the Python 3 identifiers.. It means the lexer must still support Unicode identifiers on Python 3. I don't really care about how :). Pretty sure this just generates bad Python code and then when you get a syntax error it does not tell where and why. I don't really like this solution because it destroys debug information.\n\nI would rather match on \\w_ or what it is and then check the result for foo. isidentifier(). That way it would not regress. However I'm not sure if \\w is actually a superset of the xid groups.. Seems like tokenize matches on \\w and then checks with .isidentifier(). > The issue with isidentifier is that it's python 3 only\nIt's trivial to only execute that piece of code on Python 3 then.\n\nInterestingly enough there appears to be some sort of checking of characters that raises TemplateSyntaxError in python 2 vs just generating bad code in python 3.\n\nJinja2 should not generate bad code in Python 3. Do you have an example where it does?. I think I can't exactly follow your reasoning here but I think it does not matter anyways. I will close the PR here and instead just implement what I proposed above.. Need to add a test to this one but I fixed the reverse thing and added characters missing. Oddly enough I can only reproduce \\w not matching on the latter two but not the mongolian characters.. I wonder if that was not already broken before.. That sounds good. Ideally we can reuse the same thing as we had before to regenerate the regex though we need to make sure we hit the set that is missing in all versions of Python 3.. It looks sane but I'm not quite sure if there are some unintended consequences to this. As far as I know it should not break anything or it was not sound before either.. I think we can do that but I would personally propose to align the 3.0 release with that.. In a way the last major release of Jinja2 was a massive change in the engine. Not even sure if there is more stuff we need to break :D. This is cherry-picked now into 2.9-maintenance.. Meh. Travis is broken. In case this passes it looks good to me though.. This sounds like it runs into ulimits. This seems to be a configuration error. Disabling autoreload should also work around this.. I cannot tell. I assume the likely reason one might see this is some server doing weird things with fork. You would need to describe your setup but generally unlikely to be jinja related. You might just see it there because in reload mode (which you can just turn off) jinja will stat a lot.. The syntax error is not a syntax error, it's a module that only contains code relevant for Python 3. Old pip versions will misreport this as a syntax error. This is definitely not causing a segfault.\nNot sure what causes the segfault but I can't see how Jinja would do that.. I suppose the better fix would be to use auto_await which internally uses coroutine.isawaitable which is how the compiler makes a similar decision.. Looks like this was an oversight on my part when I pulled in some Python 3 changes. This should be changed to use xrange again on 2.x. This should go into 2.10. Not sure if this properly handles the new identifier tracking. This needs some tests what happens if you combine it with set and referring to variables in weird ways.. No, we do not want to exhaust the iterator unless we absolutely have to.. ",
    "florentx": "I'm ok with using the syntax (foo|string)[:16]\nThe deprecation path through 2.5.6 / 2.6 may be safer probably.\n. I agree :+1: \nA bit of history might be added somewhere, if it does not exist.\n. ",
    "miracle2k": "\nYou actually can already provide a priority for extensions, not sure if that is taken into \naccount for registering tags though. In case it does not, supporting that for tags might \nbe a quickfix.\n\nI wasn't aware that there there were priorities, or I forgot about it.\nIt appears that the priority does affect tags - fwiw, the test case I used to try this is here:\nhttp://github.com/miracle2k/jinja2/commit/c7ca7fc1698f8a9be3447e9b137da73381f9e836\nBasically, that's good enough for me.\n. Which value specifically do you suggest should default to undefined?\nI have implemented the code as-is here:\nhttps://github.com/miracle2k/jinja2/compare/90-matcher\n. It strikes me that this could possible be implemented by an Extension that generates with and incude nodes.\n. ",
    "scyclops": "The template code doesn't seem to be displaying properly above so I've put it here instead:\nhttp://gist.github.com/645489\n. Ahhh, that makes sense, because the memory cache never got flushed.\n. Yep, I cleared the cache and now it works with the old template.\n. ",
    "themartorana": "I'd like to make a suggestion that clearing the byte code cache after installing a new version of Python be made part of the documentation. I spent a half-day pulling my hair out on this one (not your fault) until I fell upon this posting.\nThanks!\n. ",
    "jvs": "[Markdown messed up my report.  Let me try again.]\nI think the LRUCache class in Jinja2 has a bug.  The problem is that the \"getitem\" method may mutate the cache, but that method does not acquire the write lock, \"_wlock\".\nFor example, here's one scenario:\n- Thread A calls \"getitem\" with the key \"K\".\n- \"K\" is not the last element of the queue, so Thread A removes it.\n- Thread A is suspended before it appends \"K\" to the queue.\n- Thread B calls \"setitem\" with the key \"K\".\n- Thread B finds \"K\" in the \"mapping\" dictionary.\n- Thread B tries to remove \"K\" from the queue.\n- The queue raises an exception, because it does not contain \"K\".\nIn my project I've seen the \"setitem\" method raise a KeyError.  I assume that there's a similar execution scenario behind those exceptions, but I could be wrong.\nIn any case, I think \"getitem\" clearly needs to acquire \"_wlock\" before it removes and appends keys.\n. ",
    "tonytargonski": "To add to this 2 year old ticket... I have also observed the same exception in my system.\n[Tue Feb 12 19:48:16 2013] [error]   File \"/local/python_envs/www/local/lib/python2.7/site-packages/jinja2/utils.py\", line 473, in __setitem__\n[Tue Feb 12 19:48:16 2013] [error]     del self._mapping[self._popleft()]\n[Tue Feb 12 19:48:16 2013] [error] KeyError: '_breadcrumbs.html\n. ",
    "almet": "This is supposed to allow the groupby to group by more precisely. \nFor instance, if I have articles that I want to group by year, I need to access item.date.year in the groupby filter.\nMaybe that's not the way to go, and if not, please tell me what's the right way :)\nWhen you're saying this function should be called for each dot, maybe can I split on . then and call this function recursively ?\nPlease let me know, this is a bit obscure by now.\n. okay, sure, thanks.\n. ",
    "rralian": "Sorry, user-error. #rtfm\n. ",
    "xolvo": "YES. This bug is very annoying. Fix it please\n. ",
    "Trii": "Was this issue ever solved? I have the same issue while trying to implement themes with the FileSystemLoader. In my use case, a theme may override a default template but does not need to so my files must be named the same but live in different paths. The paths change per request so a cached home.html in /theme1/ might be valid for User 1 but User 2 should see /theme2/home.html\n. ",
    "chrislawlor": "This issue thread is pretty old, but in case someone is looking for a solution, it looks like 'ChoiceLoader' addresses this use case:\nhttps://github.com/mitsuhiko/jinja2/blob/master/jinja2/loaders.py#L366\n``\nclass ChoiceLoader(BaseLoader):\n    \"\"\"This loader works like thePrefixLoader` just that no prefix is\n    specified.  If a template could not be found by one loader the next one\n    is tried.\n>>> loader = ChoiceLoader([\n...     FileSystemLoader('/path/to/user/templates'),\n...     FileSystemLoader('/path/to/system/templates')\n... ])\n\nThis is useful if you want to allow users to override builtin templates\nfrom a different location.\n\"\"\"\n\n```\nDocumented here: http://jinja.pocoo.org/docs/api/#jinja2.ChoiceLoader\n. ",
    "razamatan": "why not make your own?  while making it, take care to understand how urllib.urlencode, urllib.quote and urllib.quote_plus are related.\nfor me, i ended up making a function that can be used as both a filter and callable function (done for a flask app):\npython\n@app.template_filter('urlencode')\ndef urlencode(uri, **query):\n   parts = list(urlparse.urlparse(uri))\n   q = urlparse.parse_qs(parts[4])\n   q.update(query)\n   parts[4] = urllib.urlencode(q)\n   return urlparse.urlunparse(parts)\napp.jinja_env.globals['urlencode'] = urlencode\nused in a template as a function:\njinja\n{% set vendor_url = urlencode('http://www.google.com/search', q=adset.keyword.text) %}\nused in a template as a filter:\njinja\n{% set vendor_url = 'http://www.google.com/search?q=%s' % querytext %}\n{{ vendor_url|urlencode }}\n. ",
    "harobed": "\nwhy not make your own ?\n\nBecause jinja2 have already many buildin filters (http://jinja.pocoo.org/docs/templates/#builtin-filters) and urlencode is a classic feature whose can be appended in builin filters.\nRegards,\nStephane\n. ",
    "radekstepan": "urllib.quote_plus(uri)\n. ",
    "marians": "Would be nice if this could be committed to the main release. It's something one would expect in a template system as complete as jinja2.\n. @radekstepan @gfuchedzhy I have the impression that it's not as simple as passing the string/Markup through quote or quote plus. In my case, this caused unicode problems in quote_plus. It seems as if unicode has to be encoded to utf-8 to work well with quote_plus(). Here is my solution:\npython\n@app.template_filter('urlencode')\ndef urlencode_filter(s):\n    if type(s) == 'Markup':\n        s = s.unescape()\n    s = s.encode('utf8')\n    s = urllib.quote_plus(s)\n    return Markup(s)\n. I might be able to deal with it in Python. But I'd rather not have to care about it.\nWhen I write\n{{ mydate.strftime('%d.%m.%Y') }}\nI don't have to care about the output encoding. The same should apply for this:\n{{ mydate.strftime('%B') }}\nIn many other cases, Jinja helps me to not think about matters like these, so it would be great if this case would be included.\n. Couldn't Jinja2 figure out the encoding via locale.getlocale, in the same way I am?\nIn the short run I will create a custom filter. Still feel, from an API user perspective, it would be better if I didn't have to.\n. ",
    "jace": "For anyone who stumbles on this looking for a urlencode filter, it was added back in 2012 in 06a8b1c02b2091b31ef4f39ddde3184f25f58260 and 5145401fe5f9995a32757f34359623b87048ab8b. Discussion in #85.\nIt's called urlencode and not urlquote, urlquoteplus, urlquote_plus or urlescape (adding these for anyone else landing via search).\n. ",
    "jab": "From #pocoo just now:\nmagicbronson: hey mitsuhiko et al., trying to render a Jinja template in a Flask app and getting a very mysterious message: \"global name 'l_config' is not defined\"\nmagicbronson: l_config appears nowhere in my code or libraries'\nmitsuhiko: magicbronson: that's the scoping bug that i will fix over this summer \nmitsuhiko: {% macro foo() %}{{ config }}{% for config in something_else %}{{config}}{% endfor %}{% endmacro %}\nmitsuhiko: something like this triggers the bug currently\nmitsuhiko: magicbronson: rename the variable inside of the macro to something else\nmitsuhiko: {% set cfg = config %}\nmitsuhiko: outside the macro\nmitsuhiko: or something\nArmin's suggestion worked around the issue.\n. Nevermind, it's working after all. Sorry for the noise.\n. Here's an example from a codebase that's actually in use: http://paste.pocoo.org/show/489070/\n(This was a first pass, the implementation has since improved a little.)\nFortunately I had the luxury of being able to move the dump() calls to the end of my base template because otherwise the register() calls were happening after (so dump() would output nothing). But having to worry about the order of these calls is a flaw of this solution.\nPerhaps a built-in facility for this could guarantee the dump calls being evaluated last.\n. Here is the error I get when I take out Exceptional: http://paste.pocoo.org/show/476000/\n. Setting\napp.jinja_options = dict(app.jinja_options,\n    loader=ModuleLoader(join(app.template_folder, ZTMPL)),\n    )\nbefore first access to app.jinja_env seems to do the trick.\n. Btw, glad I finally figured out that this is the way to customize the default jinja_options. Maybe worth documenting in case it's not obvious to others too?\n. > Calling do_truncate function like this:\n\njinja2.filters.do_truncate(\"1234567890asd\", 10)\nreturns 11 characters\n'1234567 ...'\n\nLooks like this has been fixed:\n\nIn [6]: filters.do_truncate('1234567890asd', 10)\nOut[6]: '1234567...'\n. Thanks for merging!. Is there any backwards compatibility requirement given that this landed in 2.9, which had other backwards-incompatible changes? It's possible more users are happy to get the new behavior for free just by upgrading Jinja (without having to change their code). Change 3 above is also backwards incompatible; are you suggesting reverting that too? If it should have worked this way by default from the beginning, it'd be good to at least make it the default behavior at some point.. apparently . \n",
    "snoack": "The groupby filter, sorts the iterable always by the given grouper. That is required by Python's itertools.groupby function, which is used under the hood.\n. In my opinion that use case is not common enough that it is worth to get merged into upstream. A more flexible solution that can satisfy that use case among others, is the filter filter, I have added in my branch better-filters.\njinja\n{{ [0, False, foo]|filter|first }}\n. That absolutely makes sense, in my opinion. The dot notation and the fact that filters like groupby and sort call the argument used for the lookup attribute implies that Environment.getattr() is used instead of Environment.getitem(). I am totally surprised that this is not the case, right now.\n. Unfortunately, I just discovered a problem with using getattr() instead of getitem(). If you use a value for the lookup, that isn't a string, a TypeError is raised and no item lookup is done. That's probably the reason why getitem() is used, here.\n. I have updated my better-filters branch. Now tests, taking arguments are supported. All positional arguments are passed to the test, while attribute and invert are required to be keyword arguments if given. I am quiet satisfied with that implementation. What do you think?\n. By the way, I noticed an inconsistency on filters expecting iterables. Most filters leave the TypeError raised by the underlying built-in function (iter, reversed, list, sum, etc.), if the given value isn't an iterable, unhandled. But the reverse filter catches that TypeError and raises his own FilterArgumentError instead.\nIn my opinion, all filters should deal with iterables in the same way. So in favor of less and simpler code, I would suggest to always let the underlying TypeError raise to the top instead of putting it into a FilterArgumentError, in the case of the reverse filter. Would you agree on that?\n. I have got another question. Is it a bug or the intended behavior that the groupby filter does not normalize the case of strings as the sort and dictsort filter does?\nThat way it seems some kind of inconsistent to me. But on the other hand if we would just do make_sort_func(make_attrgetter(...), case_sensitive) for the groupby filter, it would convert each returned grouper to lowercase (if case_sensitive=False), which might confuse the template authors.\n. My latest commit made the groupby filter case insensitive by default, just like the sort and dictsort filter, but does not convert the returned groupers to lowercase. That fixes the inconsistency without confusing template authors or breaking existing code (too much). What do you think?\n. I don't like the idea of adding an underscore as prefix to the invert keyword argument of the filter filter, because of prefixed arguments look ugly and an underscore as prefix often means that it is an internal argument that should not be used. Also passing the attribute argument to the test if given, but giving an other meaning to that argument if no test was given, might confuse template authors and feels inconsistent to me. I think passing positional arguments to the test, while interpreting keyword arguments by the filter itself is straightforward and easy to understand for template authors. Most built-in tests don't take additional arguments, anyway.\nHow do you mean that a FilterArgumentError can be catched in order to try something else, in a way that you can't do with a TypeError? However preemptive type or constraint checks are anything but pythonic. Have a look at the reversed and last filter for example. If the object processed by those filters, implements __reversed__ it doesn't matter whether the object itself is iterable, but instead the object returned by __reversed__ must be an iterator. So you see that the correct type/constraint check strongly depends on what exactly the filter does and can become very complex. Also that check is redundant, because of in the case it fails, a TypeError is raised anyway. I don't care much whether a FilterArgumentError or TypeError is raised in that case, as far as it is consistent among all filters. So what do you think?\nI already thought, about adding a map filter that works exactly the same. But when adding the map filter I would like to deprecate the attribute argument for the join and sum filter. In my opinion there is no reason that each filter that takes an iterable, must support attribute lookups anymore, when you can just use the map filter like below:\njinja\n{{ foo|map(attribute='bar')|join(',') }}\n{{ foo|map(attribute='bar')|sum }}\nDo you agree on that and if so how should we deprecate it? Of course we could just call warnings.warn(..., DeprecationWarning), if the attribute argument is given. But dependant on how people use jinja2 in their applications that warning might stay invisible to template authors. But if you don't have a better idea, that might be still reasonable.\n. Sorry, for accidentally closing the pull request.\nYou might also have a look at Pull Request #57. It suggests using getattr() instead of getitem() in make_attrgetter(), which absolutely makes sense, in my opinion. There is also Pull Request #42, which I recommend to reject in favor of the filter filter.\n. I have submitted new pull requests for adding the unique filter (#469) and the min/max filters (#475).\n. The abc module was added in Python 2.6. But jinja2 is compatible with Python 2.4. So you have to add a fallback for the case that importing abc fails.\n. The format filter as implemented in jinja2 is redundant anyway. If I could, I would deprecate and finally remove it, but mitsuhiko would not let me break backwards compatibility. Whenever I have to format a string in a template, I use the modulo operator inline.\njinja\n{{ '%d' % x }}\n{{ '%s:%d' % (x, y) }}\n{{ '%(foo)s' % {'foo': 'bar'} }}\nWritten that way, the code is less, simpler and more readable. Also note that using the modulo operator instead of the format filter results in more efficient Python code, when the template is compiled.\n``` python\n\n\n\nprint env.compile(\"{{ '%d'|format(x) }}\", raw=True)\nfrom future import division\nfrom jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound\nname = None\n\n\n\ndef root(context, environment=environment):\n    l_x = context.resolve('x')\n    t_1 = environment.filters['format']\n    if 0: yield None\n    yield to_string(t_1('%d', l_x))\nblocks = {}\ndebug_info = '1=9'\n```\n``` python\n\n\n\nprint env.compile(\"{{ '%d' % x }}\", raw=True)\nfrom future import division\nfrom jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound\nname = None\n\n\n\ndef root(context, environment=environment):\n    l_x = context.resolve('x')\n    if 0: yield None\n    yield to_string(('%d' % l_x))\nblocks = {}\ndebug_info = '1=8'\n```\nTherefor I don't like the idea of adding another useless filter for formatting values, as that can also be accomplished the same, more elegant way by using the modulo operator.\n. jinja\n{{ '%0.2f' % vvv|float }}\n... or if you prefer the format filter syntax  ...\njinja\n{{ '%0.2f'|format(vvv|float) }}\n. In my opinion the modulo operator variant is more readable than using the built-in format or your pyformat filter. That's because of it requires less code to read (and write). Also imagine a more sophisticated example, where you need to format a string with multiple values:\njinja\n{{ '%i points (%0.2f%%)' % (points, total / points * 100) }}\nUsing pyformat that code would look like that:\njinja\n{{ points|pyformat('i') + 'points (' + (total / points * 100)|pyformat('0.2f') + '%)' }}\nDo you still think that this it more readable?\nI agree that the built-in format filter breaks the information flow concept of filters. And also it is less efficient and requires more code to write compared to the module operator. But the modulo operator is not a filter, but an operator. So nobody expects that the information flow works like it does for filters.\nThe problems with adding another filter for string formatting, that works like your pyformat filter, are:\n- It is less flexible than the built-in format filter and the modulo operator.\n- It is just as inefficient as the built-in format filter.\n- Having three ways (pyformat, format, modulo operator) to do the same thing is even worth than having two ways.\n- Users might be confused about the presence of two filters for string formatting, in particular because of the name \"pyformat\" is anything but self-explanatory, in my opinion. Also note that a lot of template authors, don't know anything about Python.\n. When loading templates the FileSystemLoader follows symlinks. So that its list_templates() method don't follow symlinks, is  definitely a bug. However just calling os.walk(..., followlinks=True) when using Python >=2.6, won't fix that bug for people using jinja2 with older versions of Python.\n. For me that behavior looks quite expected. Look at following statement:\njinja\n{% from \"macro\" import y %}\nHere you are loading the template \"macro\" and add the macro called \"y\" to the current context. Therefore the code of the template \"macro\" is executed. However that template does not only contain macros, but also a block called \"x\", that is executed as the template is loaded. And the code in that block tries to access the variable \"z\" which is not defined.\nIf you wonder why \"z\" is not defined, even though you have passed it to the context, when rendering the template called \"test\", that is because of the context used to render the template \"test\" is not passed to templates you import macros from, unless you specifiy with context, like below:\njinja\n{% from \"macro\" import y with context %}\n. Yes, that is correct. Actually the block is not rendered when the template module is loaded, but when the root render function is called. But when using the import tag, the module is loaded just before the root render function is called. Then the root render function defines the macros in its local scope and adds them to the context. However the root render function also renders the block \"x\" as defined in the parent template \"base\" and overridden in the template \"macros\".\n. I don't agree on that. Jinja2 works much like Python itself does. When you import a module in Python all code that is not wrapped into a function/method, is executed (doesn't matter whether you use the import keyword, the from ... import ... syntax or the execfile() built-in function). So importing macros from a template in jinja2, works the same way as importing functions from a module in Python. That means that all code from the template that is not wrapped into a macro is executed.\nIf you want to use macros defined in template \"A\" also in template \"B\", just move all macros from template \"A\" into a new  template, that is not rendered, but only used to import macros from. Using the same template as reusable macro library and for directly rendering a certain page, sounds like a bad idea anyway.\n. You don't need bitwise operators for that. Just use string formatting:\n{{ '0x{r:02X}{g:02X}{b:02X}'.format(**color) }}\n. Using the format filter would also be possible:\n{{ '0x%(r)02X%(g)02X%(b)02X'|format(**color) }}\nThe format filter basically just wraps the modulo-operator, enabling Python's old string formatting mechanism. The format method, on the other hand, doesn't even come from jinja2, but is a built-in method of str and unicode objects in Python, and used for the new string formatting mechanism.\nIn Python, the new mechanism is preferred over the old one, but in jinja2 we like to maintain a stable API. If it wouldn't be for backwards compatibility, I think we might have removed or changed the format filter. I'm not sure what to suggest here, I guess, just use whichever you prefer.\nBut yeah, this discussion is becoming off-topic, and this probably isn't the right place to continue it.\n. Here is the responsible code from jinja2/ext.py causing this:\ndef _make_new_gettext(func):\n    @contextfunction\n    def gettext(__context, __string, **variables):\n        rv = __context.call(func, __string)\n        if __context.eval_ctx.autoescape:\n            rv = Markup(rv)\n        return rv % variables\n    return gettext\nJinja2 wraps the external gettext function inserting placeholders using the %-string-formatting. So if any placeholder value is absent in the keyword arguments rv % variables throws a KeyError of cause.\nIMO this is fine. But I agree that the documentation needs to be corrected.\n. I still disagree. It's anything but obvious that firstof(..) will return the first argument that evaluates to True. Therefore [..]|select|first is actually more readable IMO, since readability isn't about the length of code, but about whether it's understandable what it does. Beside being more in line with best practices (and in particular the UNIX philosophy) of having each piece of code doing only one thing.\nAnd frankly, I cannot think of many use cases where a firstof function would be useful anyway. If you are migrating from django, chances are that you used {% firstof %} to work around django's limitations, while a different data structure would actually make more sense anyway.\nI understand that you don't want, and probably shouldn't, change the logic and data structures while migrating your templates to jinja2. But it doesn't matter whether to replace django's {% firstof %} tag with {{ [..]|select|first }} or {{ firstof(..) }} as long as you have to change the code anyway. And when you prefer the \"django way\", I wonder why you switch to jinja2 in the first place.\n. Please note that calling itertools.groupby() on an unordered sequence will only group adjacent items with the same key. I couldn't come up with a use case where this behavior would be intended/useful. AFAIK, the only reason Python's itertools module doesn't automatically sort the input, is performance when grouping huge sequences that are already ordered. I don't think this is an issue in templates usually. On the other hand only grouping adjacent items, would be rather confusing for many template authors. I know, this PR wouldn't change the default behavior, but it might be still a confusing and rather useless feature IMO, unless I missed the point.\n. I'd agree that a built-in way to eliminate duplicates from a sequence would be desirable. In fact, I ended up implementing a unique filter myself for a couple of projects, and already asked to have it added to upstream jinja2, 4 years ago as part of #66, see snoack/jinja2@2d9a896. But I think it should be a separate filter for larger flexibility. So one can eliminate duplicates from a sequence while preserving order.\n. I have just rebased and improved my old patch, and submitted a new pull request, see #469.\n. Sorry, I wasn't aware of this pull request when I created #468, also see my comment here.\nI called the filter simply json however. This better fits the naming convention of filters like int and list. Also I pass additionally keywords arguments through to json.dumps.\n. My pull request adds a filter called json which effectively just calls json.dumps(). I think it make sense to have this in upstream jinja2, as every other project using jinja2 I've seen adds a filter like this.\nI went for jsonrather than tojson, to match the naming convention of other filters like list and int.\nAdditional, keyword arguments are passed through to json.dumps(). However, I made ensure_ascii default to False. So pretty printing is as simple as {{ obj|json(indent=4) }}\n. I cannot reproduce this on 6bf78bc (current master/HEAD). Following code works just fine for me:\npython\nenv = jinja2.Environment()\ntmpl = env.from_string(\"{% set my_var = my_func('Some string', named_param='Another string') %}\")\ntmpl.render(my_func=lambda *args, **kw: None)\npython\nenv = jinja2.Environment()\nenv.globals['my_func'] = lambda *args, **kw: None\ntmpl = env.from_string(\"{% set my_var = my_func('Some string', named_param='Another string') %}\")\ntmpl.render()\nWhich version of jinja2 are you using? Where does my_func come from (context, globals, etc.)? Do you use any extensions? Ideally, can you provide a piece of Python code (like my snippets above) to reproduce the issue?\n. Reproduced ..and fixed. That was because int() always fails with a TypeError when an explicit base is specified, but the value isn't a string. Hence this regression were introduced by adding the optional base argument to the int filter.\n. I updated the pull request, to only pass the base to int() if we have a string, ignoring the base otherwise. As opposed to my initial patch, I use the fallback, casting the value to float and that result to int, regardless of the base, now. So this only fixes the regression, without changing any other behavior.\nThe inconsistency when parsing floating points with non-decimal bases, isn't probably too important. On second thought, string representations of floating point numbers are also called decimal numbers, implying a base of 10. So ignoring the base for these would be similar to ignoring the base for non-string values. Yeah, I know, I presented two different ways to view it, before. But there doesn't seem to be an obvious single correct way, and this one seems to be simplest solution and it is backwards compatible.\n. Since I'm not a committer, and you seem to approve this change, mind merging it? (Same for my other PRs where you gave LGTM)\n. Fine with me. I didn't meant to urge you. It just wondered why a maintainer gives LGTM, without merging the change or any further comment. Anyway, thanks for moving things forward here.\n. Not that I'm a particular fan of six. But out of curiosity, why isn't\nWerkzeug/Jinja2/Flask using six?\n. Sorry, misread your comment above. Deleted my comment. I agree that having vendored _compat modules in the respective projects is a reasonable approach, given that they are fairly trivial and tooled towards the project-specific needs. So I suppose there is no objection merging this pull request?\n. We forgot to update the classifiers in setup.py as well. I submitted another PR: #500.\n. LGTM. Thanks!\n. Note that I moved this line while changing it above the from jinja2 .. imports for compliance with PEP-8, where corelib imports should go first.\n. I realized this, and considered it a bug as well. Treating strings representing a floating point number as decimal, when hexadecimal was specified, while respecting the base when the string represents an integer, is inconsistent and certainly wrong.\nYou could either say that floating point semantics aren't specified for non-decimal numbers. Then my code would behave correctly and as expected by returning the default.\nOr one could insist that floating points should be supported consistently for all bases. This could be implemented like below. Let me know what you think.\n``` python\ntry:\n        if isinstance(value, string_types):\n            return [int(x, base) for x in value.split('.', 1)][0]\n    try:\n        return int(value)\n    except (TypeError, ValueError):\n        return int(float(value))\nexcept (TypeError, ValueError):\n    return default\n\n``\n. I think you should usetemplate.generate()here, writing chunk by chunk to the file. This will improve performance and keeps memory usage low in case the output is huge.\n. Why do you enforce this non-standard behavior? If anything this should be an option.\n. I think this should be a standalone script rather than amainmodule.\n. This should probably be integrated in the pytest suite located in thetestsfolder.\n. On first though this is inconsistent, as we return thedefaultin all other scenarios where the input cannot be parsed. But on the other hand there doesn't seem to be one particular expected way to handle explicit bases in these corner cases. So I'm fine with not catching the exception there. I've updated the PR.\n. Yes,sorted()creates a new list, the items aren't copied however but passed by reference. But indeed the outer sort seems to be unneeded. Anyway, that logic doesn't change with this pull request. I am going to file a new pull request to get rid of the redundant sorting here.\n. The problem is that Travis CI currently doesn't have an alias for3.5.0->3.5. Hence you need to request3.5.0explicitly, for the time being. However, in order to support the longer version number I had to improve the conversion below. Which I agree, is cleaner that way, anyway.\n. Alright. It seems they just fixed it, see travis-ci/travis-ci#4788.\n. It seems that jinja2 doesn't support any Python version which does not havestr.format()/unicode.format()`, hence this check seems redundant.. ",
    "yawor": "@wallunit what if I already have a collection sorted by the key, but in a very specific order and I just want to group items in the collection without loosing the order? I'm using itertools.groupby a lot and I very much like that it doesn't do the sorting for me and does only what it should do.\nI've used Jinja2's groupby for the first time today and I was very surprised that I've lost my sort order.\n. I've done some additional research and I've found that the problem is caused by LoopContext returning wrong length when iterating over a list iterator.\nHere is an example:\n{% for item in menu('main') %}\n<li{% if loop.revindex0 == 0 or loop.revindex0 == 1 %} class=\"extra\"{% endif %}><a href=\"{{ item.url }}\">{{ item.title }}</a></li>\n{% endfor %}\nWhere menu('main') returns an object with __iter__ method which returns a new list iterator. In Jinja2 2.6 it works like it should.\nI can (and will) update my code to work with 2.7, but this is still a regression.\n. Hi,\nI think the problem is caused by accessing item from iterator before getting the length of it. In my example I've already retrieved first item from iterator before checking revindex0 so iterator has now 1 element less and length is smaller by 1.\nI've fixed my problem by adding __len__ method to object returned by menu('main') so loop context doesn't need to get the length from the iterator, as it knows how many items are there to display.\nI'll try to reproduce this later (I've already modified my testcase) and I'll post it.\n. I would also like to see a groupby filter do only what it should do because now it does to much. The collection can already be sorted by the key but in some specific order (for example the can may not be in alphabetical order) and current functionality breaks that order.\ngroupby should only be a simple wrapper over itertools.groupby and current functionality can be achieved by stacking sort and groupby filters:\n{% for grouper, items in collection|sort(attribute='foo.bar')|groupby('foo.bar') %}\n{% endfor %}\n. ",
    "untitaker": "Sorting before calling groupby covers the majority of cases... if it doesn't fit yours, you can always register the original itertools function as a global.\n. @techtonik Actually, this is a different issue. This is about building the docs under Py3, not the content itself. https://github.com/mitsuhiko/jinja2/issues/416\n. I don't think this is a bug. Wordwrap just seems to assume that your text is not wrapped yet.\n. Couldn't you use the stdlib email module for this?\n. I can't reproduce this.\n. number_of_stuff.values()|sum i think.\n. Please ask on StackOverflow\nOn 21 May 2016 00:57:11 CEST, gabriel duncan notifications@github.com wrote:\n\nis there any way to handle None type objects gracefully in sum?\n\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub:\nhttps://github.com/pallets/jinja/issues/192#issuecomment-220737518\n\n\nSent from my Android device with K-9 Mail. Please excuse my brevity.\n. Same as https://github.com/mitsuhiko/jinja2/pull/240 ?\n. I am typing this from mobile, so I don't really know why you e.g. removed some filters. Will take a closer look this evening.\n. I've applied the most important stuff to master.\n. Fixed in master, apparently.\n. Thanks!\n. @jeffwidman The current behavior is not consistent with itertools.\n. OTOH this does make sense: https://github.com/pallets/jinja/pull/430#issuecomment-127755500\n. Makes sense, thanks!\n. @tebeka How to load variables (the \"context\") into the template. In your CLI tool that would be from a JSON or YAML file.\n. But obviously there are more object types than the ones that can be decoded from such files. Flask has several options to load data into a config file (from_envvar, from_object, ...). I think it's a good idea to move these functions to a new package and use them in a CLI tool to load template variables.\nAlthough the name of such a package would be a bit tricky. configutils sounds good for Flask's usecase, but it sounds absolutely ridiculous for Jinja's. OTOH dictloader would be nondescriptive, but it makes sense.\n. Of course creating a new package could be avoided by moving that functionality into Jinja (on which Flask depends anyway) but that seems very unelegant to me.\n. ...or just copy the code.\n. Thanks, fixed!\n@mindw If you want to get this PR merged to a different branch, you have to refile it.\n. I think {% include %} does what you want.\n. I don't think that answers Aur\u00e9lien's question...\n~~ Aur\u00e9lien, i'd just add an issue to the bugtracker, though i don't know \nif that behavior might be intended. ~~ Huh, i thought this was a mailinglist.\nOn 2013-10-04 18:39, Juan-Pablo Scaletti wrote:\n\nhttp://jinja.pocoo.org/docs/templates/#import-context-behavior\n\"Per default included templates are passed the current context and\nimported templates not. [\u2026] This however can be changed of course\nexplicitly. By adding with context or without context to the\nimport/include directive\"\nOn Oct 4, 2013, at 11:24 AM, Aur\u00e9lien Scoubeau\nnotifications@github.com wrote:\n\nHi,\nI'm using the jinja-atoms\n(https://github.com/semirook/jinja-atoms) extension and run into a\nnaughty problem: the atoms used inside an included template are\nundefined.\nI dove in jinja sources and found the culprit: include with\ncontext creates a new shared context, which doesn't get the globals.\nAs the atoms are put in the environment globals dictionary, the\nare not available in the included template.\nThe behavior seems to be intentional though, so I get 2 questions:\n1. Why would a shared context not get the globals?\n2. Where else could the atoms be stored to be available in all \ntemplates?\nThanks for your time.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHub [1].\nLinks:\n[1] \nhttps://github.com/mitsuhiko/jinja2/issues/269#issuecomment-25712696\n. Can you please provide an example template, enclosed by `` for proper styling?\n. Yeah, this might seem like a bug, but since we don't do any parsing within comment blocks we also can't balance opening/closing braces.\n. Oh dear, thanks!\n. I think you should catch marshalling errors explicitly.\n. No, it's just becausecontents.rst.incandindex.rstin/docs/both have the same statement, andindex.rstincludescontents.rst.inc. This is not a bug. Are you trying to output JSON?\n. You shouldn't just print out thereprof arbitrary Python objects to feed directly into Javascript. In your case you seemed to have luck, depending on the content, however, you might actually get invalid JSON, and it also might be a huge security flaw. Append thelistandtojsonfilters to get valid JSON, or an exception when the object is not encodable to JSON.\n. The fact that thereprof most Python builtins is JSON-ish is not a coincidence, but the repr is never something one should rely on for actual program logic.\n. Also, i don't see anywhere in the [Jinja docs](http://jinja.pocoo.org/docs/templates/#map) which implies thatmapwould return anything more specific than a sequence.\n. Please provide a test case so we can provide a \"Fix\".\n. Also, keep in mind that this is the least appropriate place for support requests. Use the#pocoo` IRC channel for things of which you're not sure that they're a bug.\n. I don't think so. Since it isn't a valid Jinja block, Jinja should simply ignore it.\n\nNot to peck at your error, but i think it's also not a very common error, as the per thousand sign is not really easy to have as a typo when writing %?\n. Invalid blocks are IMO just not blocks, which means (to me) they probably are text.\nThis is also an invalid Jinja block:\n<p>\n</p>\n. > With your reasoning my code should have simply ignored the broken line but still print the things inside the if/endif-block and I'd be fine with that.\nThat's exactly the behavior i would expect. :)\n\nBut in this case the entire if/endif-block got ignored even though the block itself was correct, it just contained \"bad\" code.\n\nThat is weird, it just works fine for me:\n```\ncoding=utf-8\nfrom jinja2 import Template\ntemplate = Template(u'''\n1\n{% if condition %}\n2\n{\u2030 else \u2030}\n3\n{% endif %}\n4\n''')\nprint template.render(condition=True)\n```\nGives:\n```\n1\n2\n{\u2030 else \u2030}\n3\n4\n```\n. Can you try the git version? Because that's what i am using.\n. Okay, feel free to comment on this if you find more information about this issue.\n. You can already do that.\nhttp://jinja.pocoo.org/docs/api/#jinja2.StrictUndefined\n```\nimport flask\nimport jinja2\napp = flask.Flask(name)\napp.jinja_env.undefined = jinja2.StrictUndefined\n```\n. It already raises an error for me if i try to output an undefined attribute of something.\nIf you're in doubt, just test it. :-) \n. > Sorry about the separate issue\nNo, it's supposed to work like that.\n. I agree that the current docs situation is less than ideal, but there is a warning on top of each page saying that this is a development version.\n. Good catch!\n. Thanks!\n. Finally accepted, thanks!\n. Thanks!\n. This is the wrong fix for a valid problem. Changing it to __next__ is ugly I think.\n. Probably... Could you add tests?\n. Thanks!\n. No, the release you mean was released from the maintenance branch for 2.7.\n2.8 will include the commit you see.\n. Thanks!\n. :+1:\n. You can add custom filters yourself by modifying the Jinja environment, available in Flask via app.jinja_env.\n. Yeah as @patrakov said DoS attacks are still possible, and it is IMO technically out of scope for Jinja to detect such operations. I'd recommend rendering these user-provided templates under a separate process so you can limit the resources the rendering process has available.\n. The Python implementation of mustache doesn't seem to provide any sandboxing features at all. I assume you're talking about running it on the clientside then?\n. I fully agree with documenting the current behavior better, however, any changes to this behavior won't be possible anytime soon due to backwards compat concerns.\nThe latest talk at PiterPy by @mitsuhiko clarified that things like this were a mistake.\n. :+1:\n. :cake:\n. Already fixed by only using dict. Thanks though!\n. Thanks!\n. Wow that are a lot of changes and improvements!\nI applied them after changing a few things:\n- https://github.com/mitsuhiko/jinja2/commit/7ecfbe8b76800d3b57d30c9f7b05d56f4127662e\n- https://github.com/mitsuhiko/jinja2/commit/0ce1bca4a770e36dfe19ebe5fba5da8015b902c4\n- https://github.com/mitsuhiko/jinja2/commit/459b908bff120af9c3268c4e462b05f08cdedcb8\nAs a whole your changes were great. (thanks!) I am shocked that Jinja's docs are so badly phrased. Please avoid using GitHub's text editor though -- it seems to screw up the line wrapping.\nThanks again!\n. - Included templates: passed context\n- Imported templates: no passed context\nAt first I read this the same way as you, but I am not sure how to improve the sentence.\n. Since you explicitly asked for feedback: Your PR seems fine to me :+1:\n. Thanks again!\n. This is the first time I hear of such a bug. How can you be sure that this is Jinja's problem?\n. Thanks!\n. Thanks!\n. Seems sensible. Thanks!\n. Good catch, thanks!\n. Yup, thanks!\n. I'm really confused by your commit referencing the PR itself but the diff checks out.\n. I see, I thought that functionality has been removed from Github.\n. Thanks, merged!\n. Regarding that hub feature: https://github.com/github/hub/commit/4f70dd126f46dec14fc341c97c18efae417743c7\n. There's a header at the top telling you that this is for the dev version. See https://github.com/pocoo/metaflask/issues/7\n. Yeah, 2.8 is the dev version. I am not sure if it could be fixed in the docs... otherwise we'd have to change all version numbers in the docs before release.\nThe real problem here is that the dev version shouldn't be displayed (see my concerns in the linked issue).\n. Thanks!\n. This is very unlikely to be an issue with Jinja... please use the #python IRC channel on freenode, Stackoverflow or Reddit for support.\n. Could you use git rebase -i master to produce just one commit?\n. Ok, applied as https://github.com/mitsuhiko/jinja2/commit/cdeaa33d0f049641b2b0af108593449842a8d238. Thanks!\n. I think gettext is trying to resolve the formatting string itself.\n. Yeah, this is definetly planned. Pull requests welcome!\n. Well, to be honest, there is no real plan. But I'd definetly merge a PR in the style of https://github.com/mitsuhiko/flask/pull/1165\n. Thanks!\nNote that the checklist there is just a milestone-ish thing I was following... on the way I also converted multiple helper methods/functions to fixtures, whatever looked better.\n. Not sure. Just start somewhere... if you get tired of it, I'm sure me or somebody else could continue.\n. It seems that this has been suddenly tackled by @lkarthee: https://github.com/mitsuhiko/jinja2/pull/426\n@lkarthee In the future, please leave a quick note if you're going to start on this, otherwise effort is duplicated.\n. Fixed by #426.\n. Wow, great! Could you move the testsuite to the repo root too (like in Flask)?\n. I don't think the doctests are intended to be run.\n. Could you rename the testsuite dir to tests too?\n. I'd also like to add a toxfile, like in Flask (just copy from there). Tox provides some isolation from the OS and environment. So:\n- ~~add a toxfile (copy from Flask)~~ Missed that we already have one.\n- run travis tests through tox (copy from Flask)\n- but still have the Makefile invoke pytest directly (since tox runs the tests for all Python versions).\n. Thanks!\n. I applied your commit as https://github.com/mitsuhiko/jinja2/commit/29b08c85a206199094070205383e44e690ec44cf, though Travis doesn't run those anymore (it doesn't make sense, they just print to stdout).\n. > PS Yes, I've seen #42\nAnd what is your response to the comment there?\n. I agree with Sebastian. A migration like this is reasonably easy to do with sed, or you register this filter yourself.\nOn 4 August 2015 20:15:59 CEST, Sebastian Noack notifications@github.com wrote:\n\nI still disagree. It's anything but obvious that firstof(..) will\nreturn the first argument that evaluates to True. Therefore\n[..]|select|first is actually more readable IMO, since readability\nisn't about the length of code, but about whether it's understandable\nwhat it does. Beside being more in line with best practices (and in\nparticular the UNIX philosophy) of having each piece of code doing only\none thing.\nAnd frankly, I cannot think of many use cases where a firstof\nfunction would be useful anyway. If you are migrating from django\nchances are that you used {% firstof %} to work around django's\nlimitation, while a different data structure would actually make more\nsense anyway.\nI understand that you don't want, and probably shouldn't, change the\nlogic and data structures while migrating your templates to jinja2. But\nit doesn't matter whether to replace django's {% firstof %} tag with\n{{ [..]|select|first }} or {{ firstof(..) }} as long as you have to\nchange the code anyway. And when you prefer the \"django way\", I wonder\nwhy you switch to jinja2 in the first place.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mitsuhiko/jinja2/pull/429#issuecomment-127697774\n\n\nSent from my phone. Please excuse my brevity.\n. FWIW you can add any Python function to the template globals. This new parameter seems harmless IMO, but changing the current behavior has been historically rejected (IKR, this one doesn't change the defaults)\n. I agree that opt. 2 is the most flexible and your PR seems reasonable, but what are you doing in finalize that requires the context?\n. LGTM but this is out of my league, please make sb. else review this.\n. Fixed by moving the whole type finding into a temporary function. Thanks!\n. That is not true. \"Test\" has a special meaning in Jinja.\n. Thanks!\n. I think this is a performance optimization.\n. I think the original code tried to avoid a float call by first trying a simple int(value).\n. I think what Armin wanted to say in this issue is that patches are welcome.\n. - This should probably document that the items must be hashable.\n- I'm not sure there's a good enough usecase for this. What about {{ set(x)|sort }}?\n- It'd probably make sense to implement this as separate filter.\n. Re 2: I'm not so sure anymore if that builtin is actually available in Jinja. I think it's not.\nRe 3: On the CLI there's also uniq available.\nFWIW you can add your own filters and globals to Jinja, and since Python doesn't have a comparable function, I am not sure if this might not be out of scope -- even if only slightly. You're the first one to request this, so I'd like to just keep this open and see how many people +1 this.\n. The PR was closed through https://github.com/mitsuhiko/jinja2/commit/46acbf02ed9ab58c7a92553c95790e75bdc3c930, closing this too.\n. Thanks!\n. Seems fine, thanks!\n. @davidism I've applied your changes too, thanks!\n. Thanks!\n. Thanks!\n. I've melded your commits into a single one under your name, so the ones in your branch are technically unmerged. You can ignore that msg by github\n. Thanks!\n. I need to think about this more, I'm still not sure what the API should look like. Perhaps @mitsuhiko should decide on this.\n. Release is blocked on https://github.com/pallets/meta/issues/8, feel free to ping me about additional things in Flask/Jinja/Werkzeug that need attention.\n. We do, it's called six. I don't recall talking about moving compat into an external lib.\nOn 5 August 2015 18:40:31 CEST, David Lord notifications@github.com wrote:\n\nWe should really have a common library for this stuff.  I know\n@untitaker has been talking about that with Werkzeug in the past.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mitsuhiko/jinja2/pull/471#issuecomment-128065797\n\n\nSent from my phone. Please excuse my brevity.\n. The current compat module is reasonably small to be vendored. We'd use very little of six, and afaik it does a lot of magical stuff.\nOn 5 August 2015 19:13:11 CEST, Sebastian Noack notifications@github.com wrote:\n\nNot that I'm a particular fan of six. But out of curiosity, why isn't\nWerkzeug/Jinja2/Flask using six?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mitsuhiko/jinja2/pull/471#issuecomment-128077158\n\n\nSent from my phone. Please excuse my brevity.\n. Yeah, but I didn't really mean compat, but contrib.\nOn 5 August 2015 19:20:09 CEST, David Lord notifications@github.com wrote:\n\n@untitaker I didn't mean move to six, I just remembered you talking\nabout extracting common stuff from Werkzeug, not specifically compat. \nMy point was that it's the same code in each project.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mitsuhiko/jinja2/pull/471#issuecomment-128081932\n\n\nSent from my phone. Please excuse my brevity.\n. There is no dependency on six.\nOn 5 August 2015 19:39:52 CEST, Sebastian Noack notifications@github.com wrote:\n\nWell, its actually not the same code except for some particular\nimplementations like metaclasses and a few trivial declarations. Most\ncode\nin the specific _compat modules however is tooled towards the project\nspecific needs. Which I'd agree is a reasonable approach.\nHowever, if there is a dependency on six anyway, I wonder why we don't\nuse\ntheir with_metaclass function. On the other hand I'd personally would\nrather get rid of six completely.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mitsuhiko/jinja2/pull/471#issuecomment-128086577\n\n\nSent from my phone. Please excuse my brevity.\n. Thanks!\n. I'm not really familiar with Django, but it seems that ifequal is still there. So perhaps it makes more sense to rewrite this section to point out that Jinja doesn't have it.\n. Makes sense, thanks!\n. Thanks!\n. Thanks!\n. Enabling sandboxing by default is not possible due to backwards compat, and also not reasonable because most templates (in Flask) are trusted.\n. With this we would break cases where somebody sets env.cache to something that stores data outside of the current Python process. I don't know if that makes sense at all (given that the external support for bytecode_cache already exists), and if it's something we want to support. If not, I don't understand why env.cache is a public attribute and not preceded by a underscore.\n. @mitsuhiko confirmed in IRC that cache should not be overridden in such a way.\nHowever, he voiced the concern that a reference to the loader is now always kept. He suggests replacing loader with id(loader) for the cache key.\n. Thanks!\n. @iceboy-sjtu You may be right, please open a PR.\n. Please merge stuff like this into 2.9-maintenance, and that branch into master. Confirmed regression!. Full disclaimer, I'm relatively unfamiliar with Jinja internals.. @davidism I am not familiar enough with the codebase to review this. I think the addition to the language makes sense, in principle.. Yes, lgtm\nOn 5 April 2017 19:59:53 CEST, David Lord notifications@github.com wrote:\n\n@untitaker I'm learning as I go too :-) but everything here seems fine.\n@ThiefMaster given that @mitsuhiko suggested this in the first place, I\nthink it's ok to merge. Same with #676.\n-- \nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub:\nhttps://github.com/pallets/jinja/pull/684#issuecomment-291944877\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. Is this really necessary? How about \"Why is there no support for Python X.X?\"\n. That phrasing is actually incorrect... every Python version has some form of byte and unicode literals, but in the versions supported by Jinja, the syntax overlaps.\n. I see, could you sort this dict to detect similar mistakes?\n. Right, ok.\n. A word is missing here.\n. Couldn't we just move this file to conftest? I get it that you're trying to add some form of separation, but since conftest is empty otherwise...\n. Just run py.test, so the example tests are run too (these need some Python 3 fixes)\n. This makes py.test a dependency when only installing Jinja2 (even in production). Just remove it, it should be fine.\n. To be clear, test dependencies can be listed in the toxfile (and tox will take care of installing these dependencies).\n. env fixture is not necessary here\n. fixture not necessary\n. also here\n. and here\n. \"recieves... passed\" still sounds kind of weird.\n. {{ \"42.3\"|int(0, 16) }} -- this used to return 42.\n. I kind of understand that rationale but changing the API is inappropriate for a bugfix (and more so if we include that PR in a bugfix release), so I'd like to keep the previous behavior ({{ \"42.3\" | int(0, 16) }} is 42). Feel free to open an issue about this though.\n. I'm not opposed to changing behavior, but it should happen in a noticeable way (unlike the regression itself), e.g. raise an exception if a base is given and the value is unparseable with int(..., base).\n. You can just use \"3.5\" here, technically no need to fix the regex. Still like your version better though.\n. I don't see how that's true. https://travis-ci.org/mitsuhiko/jinja2/builds/81271984\n. Why put this into a bugfix release though? This is not acceptable according to semver.. Is that now the solution to #641 or are we following the idea from Armin there?. ",
    "jeffwidman": "https://github.com/pallets/jinja/issues/250#issuecomment-209304291\n. Looks like this is fixed:\n```\n(test_jinja) ~/C/ \u276f\u276f\u276f easy_install \"Jinja2 == 2.6\"                              \nSearching for Jinja2==2.6\nReading https://pypi.python.org/simple/Jinja2/\nBest match: Jinja2 2.6\nDownloading https://pypi.python.org/packages/source/J/Jinja2/Jinja2-2.6.tar.gz#md5=1c49a8825c993bfdcf55bb36897d28a2\nProcessing Jinja2-2.6.tar.gz\nWriting /var/folders/w0/bv62gp0n1d9c3_wdvc1q7v7w0000gn/T/easy_install-pvWzrw/Jinja2-2.6/setup.cfg\nRunning Jinja2-2.6/setup.py -q bdist_egg --dist-dir /var/folders/w0/bv62gp0n1d9c3_wdvc1q7v7w0000gn/T/easy_install-pvWzrw/Jinja2-2.6/egg-dist-tmp-po7Z5e\nwarning: no previously-included files matching '' found under directory 'docs/_build'\nwarning: no previously-included files matching '.pyc' found under directory 'jinja2'\nwarning: no previously-included files matching '.pyc' found under directory 'docs'\nwarning: no previously-included files matching '.pyo' found under directory 'jinja2'\nwarning: no previously-included files matching '*.pyo' found under directory 'docs'\ncreating /Users/jeffwidman/.virtualenvs/test_jinja/lib/python2.7/site-packages/Jinja2-2.6-py2.7.egg\nExtracting Jinja2-2.6-py2.7.egg to /Users/jeffwidman/.virtualenvs/test_jinja/lib/python2.7/site-packages\nAdding Jinja2 2.6 to easy-install.pth file\nInstalled /Users/jeffwidman/.virtualenvs/test_jinja/lib/python2.7/site-packages/Jinja2-2.6-py2.7.egg\nProcessing dependencies for Jinja2==2.6\nFinished processing dependencies for Jinja2==2.6\n(test_jinja) ~/C/ \u276f\u276f\u276f pip list | grep Jinja2                                  \nJinja2 (2.6)\n``\n. Since we're now on Jinja 2.8, I'm going to close this. If you still experience these issues with the latest version, please comment and we can reopen. \n. I think thepyformatfilter is unlikely to get implemented/merged.\n. That sounds reasonable to me.\n. I can't find anelif` on that page. I assume it's been updated but nobody closed this issue. \n. I'm not seeing a typo that needs fixing? If it's still there, can you rebase?\n. > My additional note (or something similar) to each of the four filters on how they behave if no test is given \nYeah, I think this is worth including. Rebase appreciated.\n. Is this still an issue? I don't have Win32 around to test... \n. Thanks for rebasing! \nAfraid I'm not very familiar with Windows programming, so I'm not able to judge the correctness of this PR. Hopefully @DasIch can take another look. \nI asked the question because I was closing old PRs that were no longer relevant, and I hoped this fit in that category. \n. I agree that this is unintuitive and on the surface seems like something that should get fixed.\nHowever, itertools.groupby requires that the data be sorted first:\n\nThe operation of groupby() is similar to the uniq filter in Unix. It generates a break or new group every time the value of the key function changes (which is why it is usually necessary to have sorted the data using the same key function). That behavior differs from SQL\u2019s GROUP BY which aggregates common elements regardless of their input order.\n\nSo while this behavior is unintuitive on the surface, it is inline with the underlying Python behavior and not something that is likely to get changed. \n. I'm not at all opposed to switching to an unsorted groupby, as long as it behaved more like SQL's GROUP BY rather than itertools.groupby. I think that's the most intuitive solution to someone using Jinja without a Python background.\n. I'm not sure I see enough value here to add this to the jinja repo versus just letting you maintain it in your own repo. It feels like a helper script that won't get used a lot, and those who really want it are somewhat likely to google and stumble across your repo. I could be wrong, maybe it will get used a lot, I've just never personally felt a need for something like this. \n\nFlask has several options to load data into a config file (from_envvar, from_object, ...). I think it's a good idea to move these functions to a new package and use them in a CLI tool to load template variables.\n\nMaybe I'm misunderstanding, but didn't we reject a similar idea over on Flask? https://github.com/pallets/flask/issues/1706\n. This sounds like a question rather than a bug report. Please ask questions like this on StackOverflow. If you think you're hitting a bug, then feel free to open an issue here. \n. @pas256 Mind submitting a PR with your suggested improvements?\n. This issue is old enough that I'm not sure it's still valid, and since it only shows up when the PO file is missing the UTF-8 header, I think it can safely be closed. If someone runs across it in the future, feel free to comment and we can re-open and take a closer look. \n. Fixed in #282 \n. I agree @ThiefMaster, doesn't make sense to be able to compare two dicts. If anything, the desired result is raising an exception on Py2 as well. But I'm not really a fan of overriding upstream behavior like that, I'd rather just let Py2 do it's thing. \n. PRs clarifying the docs are always welcome.\n. See also #119 which mentions a very similar issue.\n. So should this be closed as a \"can't fix\"? Or does a note need to be added to the docs somewhere about this?\n\nAs a workaround you can use the format filter instead. However, it seems that it only supports the old (Python 2) string formatting syntax.\n\nFYI--the current plan (open to input) is to deprecate the format filter, see: https://github.com/pallets/jinja/issues/566\n. Direct link to relevant code: \nhttps://github.com/pallets/jinja/blob/master/jinja2/loaders.py#L27\nwhich is used in the FileSystemLoader here: https://github.com/pallets/jinja/blob/master/jinja2/loaders.py#L168\nI'm not familiar enough with the original intent to know whether this is bug or works-as-designed. I suspect a works-as-designed based on https://github.com/pallets/jinja/pull/303#issuecomment-45667917\n. As well as https://github.com/pallets/jinja/pull/303#issuecomment-45543460:\n\nFile system paths have nothing to do with jinja template paths. Not even close :)\n\nand https://github.com/pallets/jinja/pull/303#issuecomment-45667917:\n\nBut the template name is always slash separated, no matter the loader. It was never supposed to accept file system paths and I am pretty sure it's not documented anywhere to support it.\n. https://github.com/pallets/jinja/pull/430#issuecomment-127755500 makes sense to me. \n. Thanks!\n. LGTM\n. I'm not against adding a filter like unique or set, but like @untitaker I'd rather see it as a separate filter (as implemented in #469) rather than as a param on sort. \n. :+1: \n. Appreciate you putting this together, but closing in favor of #468 as I agree with simply calling it json and passing kwargs. Normally I wouldn't do this, but since the other PR already ready to be reviewed it seems simplest to just go with that.\n. It looks fine to me, but I'd rather another committer took a look as well to make sure I'm not missing something. @snoack has commit rights, not sure if he's holding off for some reason...\n. LGTM\n. LGTM. While I'm not sure this is useful for Flask (I'd suggest marshmallow instead), I do think it makes sense for the Ansible project and probably a few others. \n\nThanks for adding a test. \nAlso need to add a note to the docs (including an example of how to pretty print the json) as well as the changelog. However, might wait for another maintainer or two to chime in whether they're on board with adding this filter. They may have objections that I haven't thought about. \n. LGTM\n. I'm the least-experienced maintainer on the team, so if I review a PR and think it looks good but that there's a chance I might be unaware of why something is the way it is, I refrain from merging and just give a LGTM.\nSo far that's worked pretty well, sometimes it gets merged directly by one of the other maintainers, sometimes someone chimes in with more background on why something is a particular way. But generally those PRs get a second look. \nBTW, I know many of these PRs/issues just sat for a while, but we're making consistent progress on the backlog now that we moved to pallets. If you're still interested in helping out on the project, we'd certainly appreciate your help tackling some of the thornier issues like #19, #298, and #295 \n. https://github.com/pallets/meta/issues/14 :wink: \n. I'm going to go ahead and merge this. \n. LGTM. Actually it looks fantastic, you did a great job. \nIt does touch just enough internal stuff that I'm not comfortable merging until another maintainer takes a look as well, just in case I missed something.\n. Took another look at it, and think it's fine to merge.\n. I suspect you haven't gotten much feedback simply because there's a lot going on here. I don't have the time to review it in depth either right now. \nSince none of these change external APIs (other than fixing bugs), then if you are confident that these are still good, I'd say go ahead and merge it, along with #478 and #479 since they all seem to be related.\n. Looks like this just got fixed in d760b78a2f74156f6db85f5f50304b906f3f5d6b. Sorry for missing this earlier PR. \n. Thanks!\n. Dupe of #119 \n. @ThiefMaster are we good to merge this as well as close the other linked PRs? \nI started to dig into this, but looking at the linked issues it seems you already understand what's going on here.\n. @ThiefMaster did you get a chance to review?\n. I'm sorry, but I've never used Grunt/Gulp, so I'm not really sure how this helps. \nCan you explain a little more about why it's useful?\n. Shouldn't you catch only the specific exception mentioned in #516 and not blindly swallow everything?\n. > I would be happy to put together a small pull request for the documentation recommending this approach (while still making it clear that Jinja2 itself enforces no such convention), if the concept is accepted.\nI'm okay with this, as long as it was a docs recommendation that wasn't enforced at the code level. The Ansible project already uses the .j2 convention in their docs: http://docs.ansible.com/ansible/template_module.html\nAlso, having a convention might make it easier for linters/syntax highlighters to auto-pickup on the file type, I'd be curious to hear from @danielchatfield if this would have made it easier to write https://github.com/danielchatfield/atom-jinja2\nThat said, this is just my personal opinion. Other maintainers may think differently.\n. Thanks! \nWould you mind submitting your patch as a PR? \n. Thanks! Fix landed in e2eab553f42d6ad388740b92856e7cd4d8e0f719\n. Do you know if this change affects any other vim/neovim plugin managers? \nI'm not sure if the vim/syntax directory is a common idiom in that world... or if it'd break any of the others. \n. I just looked at the Plug docs a little more, and it doesn't require the plugin to be in syntax directory... see also examples: \nhttp://vi.stackexchange.com/questions/5393/whats-the-correct-way-to-install-youcomplete-using-vim-plug-in-vim-nvim\nhttp://www.adamwadeharris.com/how-to-switch-from-vundle-to-vim-plug/\nSo I don't really see the point of this. \n. LGTM\n. What do you think about also tidying up the instructions here? \nhttp://jinja.pocoo.org/docs/dev/intro/#as-a-python-egg-via-easy-install\nI think it's waayyyy too verbose. I think we should just say pip install jinja2 and leave it at that... No need for the instructions on installing from tarball or development version. Anyone who needs to compile from source for some reason will already know how to do it (or google \"compile python package from source\"). \nThe one part I'm not sure of is the note about the C extensions being compiled if you install via distribute. I'm not familiar enough with python packaging... Do the more recent versions of Pip handle that? \n. Do you have a concrete example where this would be especially convenient? Generally the title filter works fine for country names and it's not difficult to add custom filters.\nPersonally, this feels like too much magic, I'd rather have casing changes handled through explicit filters, rather than leave room for ambiguity.\n. Agreed that the error should be more clear. \nYour suggested solution sounds good to me. Are there any other functions beyond do_map where it would also make sense to check for this?\nThis isn't a promise to merge it as I'm not very familiar with that section of code, so would prefer that another maintainer was able to review as well.\n. Thanks!\n. Thanks for catching that. I wasn't aware of that til now. \n. I agree with @ThiefMaster, this is less explicit and opens a can of worms around potential edge cases.\n. Thanks for putting this together, it's definitely something that needs to get fixed. Your suggested solution makes sense to me.\nLooks like some tests are failing though?\n. LGTM, but I'd like another maintainer to take a look as well before merging just in case I missed any edge cases. Especially since the last time someone tried to improve this section of code it introduced this bug... Definitely would like this to land in the next release though given the problems it's causing for folks in production environments.\ncc @davidism @untitaker @ThiefMaster \n. Good idea; PR welcome...\n. Thanks!\n. So do you think something should be added to the Jinja docs or are we good here?\n. Thanks!\n. I'm in favor of this.. If this does end up being \"worksasdesigned\", then @brookskindle do you mind filing a bug against flask_bootstrap?\nI use flask_bootstrap myself on a few projects, so trying to avoid the inevitability that I will forget about this issue when upgrading dependencies.. @ThiefMaster @mitsuhiko @untitaker do you guys have opinions?. What is the timeline for 3.0 release?\nThe sooner we start giving folks a heads up the better, so what about adding a deprecation warning now on jinja2 imports and a warning on jinja imports that we will soon be pushing v3 out to the jinja namespace?\n. @davidism are you able to move the RTD namespace over to jinja? Per my comment above, it's currently under jinja2, and IIRC, you were driving the cleanup/ownership migration of the RTD namespaces for other projects?. nudge @davidism - per my comment above, are you able to modify the RTD namespace from jinja2 to jinja?. Thanks!. I just merged https://github.com/pallets/jinja/pull/470 which affects some of the next behavior in _compat.py. I haven't looked closely enough at this PR to understand if it was affected, just noticed you mentioned next/__next__ and thought I'd mention the merge.\n. What's the best way to mark as deprecated so they can be removed in the future?. ",
    "berkerpeksag": "This is already fixed in https://github.com/mitsuhiko/jinja2/commit/012d0170c4481f8441a6a330d9c9625c4f886190. See also https://github.com/mitsuhiko/jinja2/blob/master/jinja2/filters.py#L494.\nCan this be closed?\n. There is a more up-to-date information at http://jinja.pocoo.org/docs/intro/#prerequisites\n. Jinja2 2.7+ does not support Python 2.5. You can download Jinja2 2.6 instead: https://github.com/mitsuhiko/jinja2/releases/tag/2.6\nSee for more information:\n- https://github.com/mitsuhiko/jinja2/blob/2.6/docs/intro.rst\n- http://jinja.pocoo.org/docs/intro/#prerequisites\n. It would be good to add a test to jinja2/testsuite/tests.py.\n. I can't reproduce the bug on Python 3.3:\n``` sh\n$ . venv3/bin/activate\n$ python -V\nPython 3.3.0\n$ pip install jinja2\nDownloading/unpacking jinja2\n  Using download cache from /home/berker/.pip-cache/https%3A%2F%2Fpypi.python.org%2Fpackages%2Fsource%2FJ%2FJinja2%2FJinja2-2.7.1.tar.gz\n  Running setup.py egg_info for package jinja2\n[snip]\nDownloading/unpacking markupsafe (from jinja2)\n  Using download cache from /home/berker/.pip-cache/https%3A%2F%2Fpypi.python.org%2Fpackages%2Fsource%2FM%2FMarkupSafe%2FMarkupSafe-0.18.tar.gz\n  Running setup.py egg_info for package markupsafe\nInstalling collected packages: jinja2, markupsafe\n  Running setup.py install for jinja2\n[snip]\nRunning setup.py install for markupsafe\nbuilding 'markupsafe._speedups' extension\ngcc -pthread -Wno-unused-result -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/usr/local/include/python3.3m -c markupsafe/_speedups.c -o build/temp.linux-x86_64-3.3/markupsafe/_speedups.o\ngcc -pthread -shared build/temp.linux-x86_64-3.3/markupsafe/_speedups.o -o build/lib.linux-x86_64-3.3/markupsafe/_speedups.cpython-33m.so\n\nSuccessfully installed jinja2 markupsafe\nCleaning up...\n```\nI also tried with empty ~/.pip-cache dir:\n``` sh\n$ pip install jinja2\nDownloading/unpacking jinja2\nCreating supposed download cache at /home/berker/.pip-cache\n  Downloading Jinja2-2.7.1.tar.gz (377kB): 377kB downloaded\n  Storing download in cache at /home/berker/.pip-cache/https%3A%2F%2Fpypi.python.org%2Fpackages%2Fsource%2FJ%2FJinja2%2FJinja2-2.7.1.tar.gz\n  Running setup.py egg_info for package jinja2\n[snip]\nDownloading/unpacking markupsafe (from jinja2)\n  Downloading MarkupSafe-0.18.tar.gz\n  Storing download in cache at /home/berker/.pip-cache/https%3A%2F%2Fpypi.python.org%2Fpackages%2Fsource%2FM%2FMarkupSafe%2FMarkupSafe-0.18.tar.gz\n  Running setup.py egg_info for package markupsafe\nInstalling collected packages: jinja2, markupsafe\n  Running setup.py install for jinja2\n[snip]\nRunning setup.py install for markupsafe\nbuilding 'markupsafe._speedups' extension\ngcc -pthread -Wno-unused-result -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I/usr/local/include/python3.3m -c markupsafe/_speedups.c -o build/temp.linux-x86_64-3.3/markupsafe/_speedups.o\ngcc -pthread -shared build/temp.linux-x86_64-3.3/markupsafe/_speedups.o -o build/lib.linux-x86_64-3.3/markupsafe/_speedups.cpython-33m.so\n\nSuccessfully installed jinja2 markupsafe\nCleaning up...\n```\nMy Jinja2 and MarkupSafe versions:\n- Jinja2==2.7.1\n- MarkupSafe==0.18\n. What is your Jinja2 version? I can't reproduce this with Python 3.3.4 and Jinja2 2.8-dev.\n``` py\n\n\n\nfrom jinja2 import Template\nt = Template('{{s}}')\nt.stream(s='\u00eb').dump('testfile2')\nopen('testfile2').read()\n'\u00eb'\n```\n\n\n\nYou can also the optional encoding parameter of the dump method:\npy\nt.stream(s='\u00eb').dump('testfile2', encoding='utf-8')\n. Could try with Git master? Jinja2 2.8 is not released yet.\nsh\n$ pip install -U git+https://github.com/mitsuhiko/jinja2.git\n. Jinja2 2.7 only supports Python 3.3+. See http://jinja.pocoo.org/docs/intro/#experimental-python-3-support\n. target was added in 2.8 which is not released yet.\n. The release script has been already updated to use wheel: https://github.com/mitsuhiko/jinja2/blob/master/scripts/make-release.py#L94\n. Please use TypeError as e here (and use Exception as e in line 563). This brakes build on Python 3: https://travis-ci.org/mitsuhiko/jinja2/jobs/16600505\n. ",
    "danofames": "we're interested in something very similar, has any more thought been given toward how this could happen?\nthe end result I'd look for is a base template that looks like:\n{% import 'dateselector.tpl' as dateselector %}\n<html>\n    <head>\n        <link href=\"base.css\">\n        {{ some_extension_function_to_write_out_macro_set_links() }}\n        {# or #}\n        {% for link in some_extension_function_that_yields_macro_set_links() %}\n        <link href=\"{{ link }}\">\n        {% endfor %}\n    </head>\n    <body>\n    content\n    {{ dateselector.single() }}\n    </body>\n</html>\nand dateselector.tpl is:\n{% macro single() %}\n{% some_extension_function_to_add_specified_link_to_head 'dateselector.css' %}\n<input type=\"text\" name=\"thisdate\" />\n{% endmacro %}\na few questions as I'm getting started looking at how to do this in more depth:\n- does the template parsing and rendering procedure allow for this approach?\n- it's not clear how one would add a set style tag like the some_extension_function_to_add_specified_link_to_head above. there seems to be support for custom tags that have the endtag and the block body, but not a custom tag in that manner.\n- if those two questions are resolved, where would the list of files used in some_extension_function_to_write_out_macro_set_links and built through some_extension_function_to_add_specified_link_to_head be stored. there are some examples that set a variable on environment, but that doesn't seem quite right.\nthis proposal on stack exchange achieves this in a way:\nhttp://stackoverflow.com/questions/4292630/insert-javascript-at-top-of-including-file-in-jinja-2\nbut I'm not sure about the use of self.environment.globals[name] to store the output (just a hunch, that may actually be recommended). and I'd rather store a list of files that needed to be added as links (so a function could remove duplicates, for example).\nI guess what I'm saying is, we'd love to put in some work on writing such an extension, and a nudge in the right direction would be helpful.\nthanks.\n. ",
    "amj": "great, thanks!\n. ",
    "medwards": "I'd like to see this too.\n. ",
    "palmkevin": "+1\n. ",
    "smatthews1999": "I would like to see this too.\nI'm trying to perform simple running totals in some generated data..and that functionality is what I need.\n. ",
    "smeggingsmegger": "+1\n. ",
    "alexcasalboni": "+1\n. ",
    "ruiposse": "+1\nI also think that this behaviour should be unacceptable:\n\n  {% set first_run = True %}\n  {% for i in range(3) %}\n  \n    {% for j in range(3) %}\n    {% if first_run %}\n    {% set first_run = False %}\n    {{ i }}, {{ j }}\n    {% endif %}\n    {% endfor %}\n  \n  {% endfor %}\n\nThis will output 3  tags, but it should output only one.\nThe variable resets after each outer loop run, even though it was declared OUTSIDE of all loops.\nI can't see how this would be expected behaviour. Is this a bug ?\n. +1\nI also think that this behaviour should be unacceptable:\n<ul>\n  {% set first_run = True %}\n  {% for i in range(3) %}\n  <ul>\n    {% for j in range(3) %}\n    {% if first_run %}\n    {% set first_run = False %}\n    <li>{{ i }}, {{ j }}</li>\n    {% endif %}\n    {% endfor %}\n  </ul>\n  {% endfor %}\n</ul>\nThis will output 3 <li> tags, but it should output only one.\nThe variable resets after each outer loop run, even though it was declared OUTSIDE of all loops.\nI can't see how this would be expected behaviour. Is this a bug ?\n. ",
    "skuda": "+1\n. ",
    "thaddeusmt": "This would very useful when templating JSON files. +1\n. ",
    "dpgaspar": "+1\n. ",
    "dlenski": "Me too, could really use an override and it'd be great if the template designer docs explicitly mentioned this behavior!\nI had to work with some data in an (admittedly horrible) format and was puzzled at why the followed pre-pass didn't work...\n{% set last_one = none %}\n{% for row in rows %}\n    {% set last_one = row.field %}\n{% endfor %}\nI agree with @ruiposse's comment that having a variable first set outside all loops reset itself inside them is very unexpected.\n. ",
    "t2y": "+1\n. ",
    "johannesloetzsch": "Thank you!\nIn my opinion the examples are quite useful for beginners (to have something working as starting point is never wrong) \u2014 It would be sad to remove them without substitution\u2026\nWhat do you think about having a set of examples used for documentation and regression-testing (for guaranteeing a stable api / documenting changes of api)?\nIf you have an good idea how to solve this issue and a suggestion how I can help, I would like to do so\u2026\n. ",
    "dnjackson": "So (a) what's the semantics of overriding in this way? and (b) why does the documentation not do the simpler thing and use the same structure in the child?\n. On Jul 15, 2011, at 1:00 PM, mitsuhiko wrote:\n\nI am not quite sure where the confusion is. The blocks of the inner child just replace the blocks of the parent template. Let me know if you have a better example for the docs that is less confusing.\n\nHere's your example:\nParent:\n\n    {% block head %}\n    \n{% block title %}{% endblock %} - My Webpage\n    {% endblock %}\n\nChild:\n{% extends \"base.html\" %}\n{% block title %}Index{% endblock %}\n{% block head %}\n    {{ super() }}\n    \n        .important { color: #336699; }\n    \n{% endblock %}\nThis bothers me for several reasons. First, you might have thought that blocks create local namespaces, so I could name blocks like this:\nemployee\n   name\ndepartment\n   name\nBut if you can override without respecting the structure, this must mean that block names are global and unique. OK, so now if we go with that, I now wonder what something like this would do\n{% extends \"base.html\" %}\n{% block title %}Index{% endblock %}\n{% block head %}\n    {{ super() }}\n    {% block title %}Foo{% endblock %}\n    \n        .important { color: #336699; }\n    \n{% endblock %}\nSo, guessing again, I'll say that you can only declare one instance of each block so this is an illegal usage.\nBut then I still don't see why you would want to allow the inheriting template to change the structure.\nIf you do, and the structure matters (as it would in the body of the HTML), would overriding block b result in block b appearing in the place at which it is overridden, or the place it occupies in the parent template? And why even make this possible?\nDaniel\n. so the new block replaces the one in the parent template, whereever the new block is declared -- before, inside, or after the parent block?\nOn Jul 15, 2011, at 1:12 PM, mitsuhiko wrote:\n\nBlocks are indeed globally unique. From the layout template inwards each block overrides each other with the same name. In this case base.html is taken, that head is replaced with a new head that supers into the old one and the new title is placed in the layout template's head which is supered.\n\nAnd why even make this possible?\n\nThe behavior is sound and compatible with Django. It works very well in practice and allows a variety of idioms and never caused any troubles as far as I know. You're the first person that ever filed a ticket for that :)\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mitsuhiko/jinja2/issues/49#issuecomment-1581237\n. On Jul 15, 2011, at 1:26 PM, mitsuhiko wrote:\nConsider it being a class. Each block is a method. When you declare a new block you will not only declare the method, but also call it at the same time. That's pretty much how it works.\n\nYes, I understand that. It just doesn't address the questions I asked.\n\nDon't spent too much time thinking about it really, it works best if you just give it a try :)\n\nI'm sure I can make it work -- that's not my concern. But I'm considering teaching this in a software engineering class this fall, and I like to have a complete understanding of what's going on. One of the things I try and do is explain fundamental notions such as namespaces, and then I illustrate that by showing how different languages have different kinds of namespaces -- basically teaching them how to be informed critics. \nI think what you're saying is that you're not really sure what the rules are yourself -- that they're defined by the implementation. In my opinion, even though it might not matter here, it's a disastrous way to go in general -- look at function decls in Javascript for example, and how broken the scoping rules are. \nDespite this, I do think Flask and Jinja are quite nice :-)\nDaniel\n. That's good to hear. So can you answer my questions?\nOn Jul 15, 2011, at 1:40 PM, mitsuhiko wrote:\n\nI actually spend a lot time figuring out useful semantics for the inheritance because Jinja2 supports dynamic inheritance which was not in Django at the time and still is not to that extend and Django's semantics for template inheritance appeared to have happened by accident.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mitsuhiko/jinja2/issues/49#issuecomment-1581496\n. I vaguely understand that. It would be good to express it in a declarative way, rather than talking about what happens at runtime.\n\n--Daniel\nOn Jul 15, 2011, at 1:39 PM, mitsuhiko wrote:\n\n\nI think what you're saying is that you're not really sure what the rules are yourself\n\nHeh. No, the rules are actually quite simple internally and clear defined. If you really want to understand the implications entirely, here you go:\nEvery block in the template is hoisted out of the toplevel template code. It's then given an entirely separate scope and registered on the template runtime context. If you extend another template the current execution context is used as the basis for the template you are extending from and that will then use your blocks over the one from the other template. Additionally from that point onwards (after {% extends %}) the template you were just executing continues to execute but will no longer output anything. This is documented behavior and can be neatly abused:\nhtml+jinja\n{% if parent_template %}{% extends parent_template %}{% endif %}\n<!doctype html>\n<title>{% block title %}{% endblock %}</title>\nAll this here will be entirely ignored if the parent_template variable is not falsy\nand the blocks will be shifted to the template we then extend from.  If however\nparent_template is not defined we will use this instead.\n{% block body %}And this block again is hoisted{% endblock %}\nThe problem is that this is quite confusing behavior most people have not use for and is pointless to show in the documentation. It's however defined behavior and an implementation detail.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/mitsuhiko/jinja2/issues/49#issuecomment-1581485\n. \n",
    "kschuetz": "No problem.\n. ",
    "gavento": "Can be fixed in lexer.py:200 by changing the regex from r'^\\s*' to r'^[ \\t\\v]*'. This makes the whitespace list limited, but that should not be an issue without re.UNICODE or re.LOCALE\n. ",
    "aspiers": "Hmm.  There still needs to be a way of including blank lines in the code which do not get rendered in the output, but are only there for legibility.  I propose that lines containing line_statement_prefix (or line_comment_prefix) and nothing else be the mechanism for this.  Currently they are not handled in a helpful way (filed as #204 and #205).\n. Just discovered that {##} is a tolerable workaround.\n. See also #52.\n. ",
    "lajarre": "Newlines after a end control bloc (endif, endfor) are still eaten up:\n```\n%% for i in range(2)\nhello\n%% endfor\nI want to be alone\n```\nrenders as =>\nhello\nhello\nI want to be alone\nIs this expected behavior? This doesn't make sense to me regarding the documentation.\n. Ok, then why not write precisely that sentence in the documentation?\n. ",
    "ThomasWaldmann": "more as a general comment than relating to this pull request:\nmaybe the code could be made much easier if the prefixes list would also contain \"B\" (abbreviation for \"Byte\") as first entry (at index 0), which directly corresponds to 1000^0 and 1024^0.\nThen,  \"1B\" as well as \"2B\" works out of the box, no need for specialcasing the singular/plural of the long form (\"1 Byte\", \"2 Bytes\").\nAlso, unit should be renamed to bigger_unit or next_unit, to make the code more clear.\n. ping\n. sounds better, but is not the whole reason.\nsix.u() is also consistent, but ugly and not easy.\n. ok, guess we need \"in a common and pretty way\".\n. how about just taking this PR as is and then doing minor additional fixes on your own?\n. ",
    "curio77": "My fault; I hadn't realized that the with extension needs to be specified in mappings.cfg as well.  Sorry about the noise.\n. ",
    "brianray": "nevermind, it seems to be up again. If you continue running into problems you may want to consider an alternate host of mirror.\n. ",
    "kilink": "See pull request #57\n. As I said, the directory name could be cached on the class to preserve it across instances of  FileSystemBytecodeCache objects.  I can change the PR, but first I'd like to get feedback from a Jinja2 committer.\nThe existing implementation doesn't clean up the directory it creates either, so I think that is a separate issue.\n. ",
    "EnTeQuAk": "Actually the unittest itself is wrong, I compared the implementation with the Django one and found that the binary calculation was indeed wrong.  This was what I came up with: http://paste.pocoo.org/show/489117/\nThis actually is a mix with https://github.com/mitsuhiko/jinja2/pull/53\n@mitsuhiko - would like to get some feedback :)\n. And actually pushed it to my own fork ;)\n. Implemented now by @mitsuhiko in 1161915fd7673275f77560ab110963c85cbda676\n. ",
    "lgautier": "Is there a bugfix release to Jinga2 planned ? Fixes such as this one would be neat to have in a released version.\n. ",
    "mcilrain": "Why is this still broken?\n. ",
    "quasipedia": "Indeed. Jinja 2.6 still fails at this:\n{{ extra.feed_size | filesizeformat }} [{{ '%d' | format(extra.feed_size) }} bytes]\nresults in:\n0.0 kB [28227 bytes]\n. ",
    "soulseekah": "It's been fixed in 7d268bef0e8f3f12c0acb90f30d67726a3e3f261 but there hasn't been any maintenance release for Jinja 2 that included the fix; there hasn't been any sort of release - the tarball at http://pypi.python.org/pypi/Jinja2 is more than 14 months old. Only solution for now is to patch the function manually (to avoid running unstable master branches).\n. Are you trying to use the PackageLoader class?\n. This is critical to provide the functionality offered by PackageLoader, otherwise it wouldn't be there. Would you like to make this requirement clearer in the documentation?\n. Allow me to take a simpler case (without imports, etc.):\n``` python\ntemplate = \"\"\"\n{% macro add_list( list ) %}\n    {% do my_list.append( 3 ) %}\n    {{ list }}\n{% endmacro %}\n{% set my_list = [ 1 ] %}\n{{ my_list }}\n{{ add_list( my_list ) }}\n{{ add_list( my_list ) }}\n{{ add_list( my_list ) }}\n\"\"\"\n```\nThe above template is tokenized top-to-bottom.\npython\ne = Environment( extensions=['jinja2.ext.do'] )\ntokens = e._tokenize( template, None, None )\nwhile tokens.current[1] != 'eof':\n    print repr( tokens.current )\n    tokens.next()\n\nToken(1, 'data', u'\\n')\nToken(2, 'block_begin', u'{%')\nToken(2, 'name', 'macro')\nToken(2, 'name', 'add_list')\nToken(2, 'lparen', u'(')\n--- snip ---\nToken(11, 'rparen', u')')\nToken(11, 'variable_end', u'}}')\nToken(11, 'data', u'\\n')\n\nThese tokens are parsed one by one inside here https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/parser.py#L844\nYou can see there that variables are added as data https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/parser.py#L859\nYou can look at what subparse returns (especially in what order) by doing this:\npython\np = Parser( e, template )\nb = p.subparse()\nprint repr( b )\nThis then gets passed to https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/nodes.py#L252 nodes.Template, where the whole node list is wrapped into one Template node. Then it's maybe optimized https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/environment.py#L476 and finally compiled https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/environment.py#L902 by https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/compiler.py#L57\nYou can look at what Python source code the compiler produced by doing this:\n``` python\nfrom jinja2 import Environment\nfrom jinja2.parser import Parser\nfrom jinja2.compiler import generate\ne = Environment( extensions=['jinja2.ext.do'] )\ns = Parser( e, template ).parse()\nprint generate( p, e, None, None )\n```\nYou can also view it by calling Environment.compile with the raw argument set to True. The is then compiled with the standard built-in function to bytecode, which is then executed by https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/environment.py#L834 when the Environment returns a Template.from_string. You can do this by repeating that code and doing something like:\npython\nc = generate( p, e, None, None )\nnamespace = { 'environment': e, '__file__': '<template>' }\nexec c in namespace\nWhere namespace will contain the root function and the other variables available locally. The Template then does this https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/environment.py#L857 with the new namespace, setting the root_render_func to the root function in the render code. And then it all gets executed nicely when you render your template, https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/environment.py#L891 and by passing it a new Context https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/runtime.py#L50 you can make it run in isolation and step through it as needed.\npython\nfrom jinja2.runtime import new_context\nnew_context( e, '<template>', {} )\nnamespace['root']( ctx )\nTL;DR a.k.a The Important Bits\nThis is the code generated:\n``` python\nfrom future import division\nfrom jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound\nname = None\ndef root(context, environment=environment):\n    if 0: yield None\n    yield u'\\n'\n    def macro(l_list):\n        t_1 = []\n        l_my_list = context.resolve('my_list')\n        pass\n        t_1.append(\n            u'\\n\\t',\n        )\n        context.call(environment.getattr(l_my_list, 'append'), 3)\n        t_1.extend((\n            u'\\n\\t',\n            to_string(l_list),\n            u'\\n',\n        ))\n        return concat(t_1)\n    context.exported_vars.add('add_list')\n    context.vars['add_list'] = l_add_list = Macro(environment, macro, 'add_list', ('list',), (), False, False, False)\n    yield u'\\n\\n'\n    l_my_list = [1]\n    context.vars['my_list'] = l_my_list\n    context.exported_vars.add('my_list')\n    yield u'\\n%s\\n%s\\n%s\\n%s\\n' % (\n        l_my_list,\n        context.call(l_add_list, l_my_list),\n        context.call(l_add_list, l_my_list),\n        context.call(l_add_list, l_my_list),\n    )\nblocks = {}\ndebug_info = '2=8&3=15&4=18&7=25&8=29&9=30&10=31&11=32'\n```\nAs you can see it's pretty much \"serial\", apart from one bit: the string placeholders. Try the following:\n``` python\ndef a( l ):\n    l.append( 4 )\n    return l\nl = list()\nprint '%s %s %s' % ( a( l ), a( l ), a( l ) )\nOutput: [4, 4, 4, 4, 4] [4, 4, 4, 4, 4] [4, 4, 4, 4, 4]\n```\nSo that's pretty much where the issue lies. That's how string formatting works in Python (both % formatting and format), the l is shared and the string is baked only after all functons have been evaluating. But each function (macro) alters the result of the previous one.\nNow that we know what goes where, it has to be decided whether this is a popular-enough edge case or not for a patch to be written and eventually accepted. Hope this helps and makes sense.\nOn another note, templates shouldn't really be doing all this macro-dancing around, should they? Keep them as straight-forward as possible and keep all logic in the view code. At least that's what I heard they do.\n. Could you please describe your particular setup/environment? How are users limited? What are users permitted to do? How does Jinja let them to do things that they are not permitted to do in your environment? How are users limited from running arbitrary code in Python directly, do they only have access to Jinja templates only?\nSorry for so many questions, but it seems that \"systems that let users write their own code\" are generally vulnerable; do you have any sort of system in place to limit execution time of any Python piece code? Why would rendering timeout in Jinja be the solution to your specific issue? It seems to be more of a global requirement. For example, WSGI containers usually have global timeouts per worker (like the harakiri setting for uWSGI), mod_wsgi surely has something similar.\nThe more information (including examples), the better. Thanks.\n. Interesting, thanks for sharing. Jinja2 was never ever meant for this, it's a templating engine and should never ever have to do any considerable amount of work/processing/logic other than loops and conditional branches. But that aside, the XMPP bot has to have timeouts when invoking any long-running functions, is it written in Python? If it is look into http://stackoverflow.com/questions/2281850/timeout-function-if-it-takes-too-long-to-finish which would be a fantastic way to limit Jinja rendering time without imposing any additional responsibility on Jinja itself.\n. It's hard to say without looking at your actual code. There are many different way to deal with threading and killing long-running threads, but there's many different ways to manage threads as well, so not sure what to suggest. Easiest may be setting the timeout argument to join http://docs.python.org/2/library/threading.html#threading.Thread.join perhaps.\nThe second SO answer refers to http://docs.python.org/2/library/threading.html#event-objects\nhttp://code.activestate.com/recipes/473878-timeout-function-using-threading/\nhttp://www.unixunion.org/index.php/component/content/article/5-general/4-python-threading-timers\nhttp://code.activestate.com/recipes/576780-timeout-for-nearly-any-callable/\nYou can see how complex some of the solutions are, and you wouldn't want Jinja to even start thinking about managing its own rendering timeouts, it's not meant for this.\n. By the way, this is where the generated Jinja code gets executed https://github.com/mitsuhiko/jinja2/blob/2.6/jinja2/environment.py#L834 exec code in namespace is where it all happens.\nMore ideas:\nhttp://www.velocityreviews.com/forums/t322179-exec-code-with-timeout.html\nswitch to multiprocessing perhaps\nhttp://code.activestate.com/recipes/496746-restricted-safe-eval/ (look at exec_timed)\n. One would not expect Jinja2 to have \"this\" as part of its core, right?\n. Chipping in with some more details. This is what the code above looks like to get a feeling for what's happening inside:\n``` python\nfrom jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound\nname = None\ndef root(context, environment=environment):\n   ...\n    l_foo = 'bar'\n    context.vars['foo'] = l_foo\n    context.exported_vars.add('foo')\n    yield u'\\nfoo - %s\\n\\n' % (\n        l_foo,\n    )\n    t_1 = l_foo\n    l_i = missing\n    for l_i in context.call(l_range, 2):\n        if 0: yield None\n        yield u'\\n     for:foo - %s\\n     ' % (\n            l_foo,\n        )\n        l_foo = l_i\n        yield u'\\n     for:foo - %s\\n ' % (\n            l_foo,\n        )\n    l_foo = t_1\n    l_i = missing\n    yield u'\\n\\n'\n    for event in context.blocks['test']0:\n        yield event\n    yield u'\\n\\nfoo - '\n    yield to_string(l_foo)\ndef block_test(context, environment=environment):\n    l_foo = context.resolve('foo')\n    if 0: yield None\n    yield u'\\n    block:foo - %s\\n    ' % (\n        l_foo,\n    )\n    l_foo = 'baz'\n    yield u'\\n    block:foo - %s\\n' % (\n        l_foo,\n    )\nblocks = {'test': block_test}\ndebug_info = '2=8&3=12&5=16&6=19&7=21&8=23&11=28&17=31&11=33&12=37&13=39&14=41'\n```\nMore details:\nGlobals: http://jinja.pocoo.org/docs/api/#global-namespace\nGeneral: http://jinja.pocoo.org/docs/templates/#assignments\nImplementation: http://jinja.pocoo.org/docs/api/#jinja2.runtime.Context \nAnother good explanation: http://stackoverflow.com/a/3355029/482864\nAny ideas?\n. ",
    "yole": "Oh, sorry. I'll re-commit these properly.\nArmin Ronacher wrote:\n\nIt also seems to be pretty good at trashing newlines. Have to check what the actual changes are :)\n\n\nDmitry Jemerov\nDevelopment Lead\nJetBrains, Inc.\nhttp://www.jetbrains.com/\n\"Develop with Pleasure!\"\n. Untrashed newlines.\n. ",
    "jturmel": "Any input on this, we're running into the same thing?\nWe like to look at the variable expressions and modify them based on different criteria but returning the entire template makes this impossible.\n. ",
    "ntrepid8": "I'm seeing this too.  It seems like finalize should run only on expressions evaluated during render, but it runs when the template is constructed also.\n. ",
    "godsarmy": "is this fixed? i still see it in the latest version (2.8).\n```\nrom jinja2 import Environment, Template\ncontext = {'k': 'v'}\ntemplate = \"\"\"\nabc\n{{ k }}\ndef\n\"\"\"\ndef fin(data):\n    return 'replaced'\nenv = Environment(finalize=fin)\ntpl = env.from_string(template, template_class=Template)\nprint tpl.render(**context)\n```\nIt displayed 'replacedreplacedreplaced', we want this to be fixed as we need this feature very explicitly\n. ",
    "johnmcdonnell": "Cleaned up as its own branch\n. ",
    "renierdbruyn": "Sorry for posting on an old issue, but why did you not add the min and max filters? I am in need of such a filter...  How can I do this without the filters?\n. ",
    "mythmon": "The 2to3 tool that comes with Python3 will automatically convert xrange to range, Python2's xrange is equivalent to Python3's range.\n. ",
    "pakula": "But it did not. Distutuls installed jinja2 from the net and left xrange in place. May be 2to3 is was not launched\n. ",
    "oconnore": "I can confirm this. 2to3 does not fix the issue.\n. ",
    "rduplain": "\nNote that the else part works differently in ordinary Python where it\nis executed when a break happened, which is not possible here.\n\n@mitsuhiko Can you confirm this? If true, will pull.\n. I pulled in the typo fixes, now a21f2edfc9536c918bae0ef654f9f3ffb1c2b508. Thanks.\n. Thanks for following up.  The documentation currently reads:\n\"If no iteration took place because the sequence was empty or the filtering removed all the items from the sequence you can render a replacement block by using else:\"\nIs this not enough?\n. I'll find a place for this, unless you'd like to submit another pull request.\n. Thanks.\n. Thanks.\n. Looks good, thanks.\n. Thanks for sprinting!\n. I'll add a big +1 for this.  Should this patch no longer apply, the ext.py is simply moved to __init__.py in the new ext package.  @mitsuhiko I'd like to pull this, but want to give you a chance to comment.\n. ",
    "njl": "This is not the case.\nhttp://docs.python.org/tutorial/controlflow.html\n\"Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of the list (with for) or when the condition becomes false (with while), but not when the loop is terminated by a break statement.\"\n. Closed, separate, cleaner pull is #103\n. ",
    "Cito": "Sorry, in that note above I wanted to say \"where it is executed when a break did not happen\", not \"where it is executed when a break happened\", so it is good that you didn't pull it.\nBut the main point here that the for statement behaves differently from ordinary Python is still correct and should still be mentioned. In ordinary Python, the else part would always be executed when there is no break, while in Jinja it is only executed when no iteration took place. Since in Jinja breaks are not possible, the else part would be always executed, so it makes sense that the behavior was changed. However, readers should be made aware of that different behavior.\n. There's nothing wrong with the documentation.\nI just think it deserves special mention when the behavior is different from ordinary Python, because you usually expect Jinja2 keywords to operate in the same way as the corresponding Python keywords. However, this is not the case for else. For instance, the Jinja2 template\nxml\n{% for i in range(3) %} {{i}} {% else %} nothing {% endfor %}\nwill just output \"0 1 2\" while the Python code\npython\nfor i in range (3): print i,\nelse: print \"nothing\"\nwill output \"0 1 2 nothing\".\n. Ok, this is now pull request #112.\n. ",
    "mfrasca": "imagine the situation:\na value that I hope it's a number, but it could be None.\nvvv | float | pyformat(\"0.2f\")\nhow would you do this, using the modulo operator?\n. but this way the flow of information goes less linearly, instead of left to right (1, 2, 3) it goes middle to right to left (2, 3, 1).  I understand your argument for speed, but readability is also worth considering...\n. well, I would write it like this:\njinja\n... {{ points|pyformat('i') }} points ({{ total / points * 100)|pyformat('0.2f')}}%) ...\nbut I agree, in this case the single use of % operator makes it more readable.\n. ",
    "chris-hailstorm": "Here's a simple approach with a user-defined filter.  If the overall filter behavior of this appeals to you, one of us could easily add to Jinja standard filters and make a pull request.  Your thoughts on this?\n(1) example of a message to be interpolated -- a custom flask-security error message:\nSECURITY_MSG_CONFIRMATION_REQUIRED = ('This email address has not been confirmed. '\\\n    'Please click on the link in the email we sent you. To receive the confirmation '\\\n    'email again, <a href=\"{0.url_root}confirm\">click here</a>.', 'error')\n(2) custom filter defined in a flask app, for example:\n```\ndef _jinja_interp(text, obj):\n    return text.format(obj)\napp.jinja_env.filters['interp'] = _jinja_interp\n```\n(3) filter as used used in a Jinja template:\n{% for error in field.errors %}\n    ... other stuff ....\n    {{ error | interp(request) | safe }}\n{% endfor %}\nThis allows string interpolation via a filter, given a dictionary to interpolate from -- exact analog of 'string {placeholder}'.format(**some_dict) in typical Python.  Can be filter-piped on to subsequent filters.\n. ",
    "djc": "Here's a test case for what I'm seeing:\n```\nimport jinja2\nTEMPLATES = {\n    'base': '{% block x %}{% endblock %}',\n    'macro': '{% extends \"base\" %}{% macro y() %}{% endmacro %}{% block x %}{{ z[:2] }}{% endblock %}',\n    'test': '{% extends \"base\" %}{% from \"macro\" import y %}{% block x %}{% if z is none %}foo{% endif %}{% endblock %}',\n'test': '{% extends \"base\" %}{% block x %}{% if z is none %}foo{% endif %}{% endblock %}',\n}\nenv = jinja2.Environment(loader=jinja2.DictLoader(TEMPLATES))\nprint env.get_template('test').render(z=None)\n```\nFails thusly:\nTraceback (most recent call last):\n  File \"test.py\", line 11, in <module>\n    print env.get_template('test').render(z=None)\n  File \"/usr/lib64/python2.7/site-packages/jinja2/environment.py\", line 894, in render\n    return self.environment.handle_exception(exc_info, True)\n  File \"<template>\", line 1, in top-level template code\n  File \"/usr/lib64/python2.7/site-packages/jinja2/environment.py\", line 954, in module\n    self._module = rv = self.make_module()\n  File \"/usr/lib64/python2.7/site-packages/jinja2/environment.py\", line 938, in make_module\n    return TemplateModule(self, self.new_context(vars, shared, locals))\n  File \"/usr/lib64/python2.7/site-packages/jinja2/environment.py\", line 994, in __init__\n    self._body_stream = list(template.root_render_func(context))\n  File \"<template>\", line 1, in top-level template code\n  File \"<template>\", line 1, in top-level template code\n  File \"<template>\", line 1, in block \"x\"\njinja2.exceptions.UndefinedError: 'z' is undefined\n. Also I should note that this seems to have worked fine, but it broke sometime recently. Perhaps it's the difference of Python 2.7.1 and 2.7.2, which we recently upgraded to.\n. I've always seen \"block\" expressions as a kind of function that gets called after the template has been loaded, not something that gets executed as part of loading the template.\n. It seems to me like the root render function in an imported template shouldn't be rendering blocks, particularly if the import came with a specific list of macros to import.\n. I think this is triggered when installing with install.compile set to True in distutils.. ",
    "flying-sheep": "\nI am closing this issue. For reusable macros you really should move them into separate templates.\n\nhmm, i don\u2019t know: what I\u2019d like to see is a template which defines a reusable building block, and, upon being rendered, embeds this building block once into the base template.\ni\u2019ll give you an example, a simple blog:\nentry.jinja2\n``` jinja\n{% extends \"_base.jinja2\" %}\n{% macro render_entry(entry, link=True) %}\n    \n\n        {% if link -%} {# we only need a link if we\u2019e not already there #}\n            \n        {%- endif -%}\n            {{ entry.title }}\n        {%- if link -%}\n            \n        {%- endif %}\n        \n    {{ entry.text | markdown | safe }}\n</article>\n\n{% endmacro %}\n{% block body %}\n    {{ render_entry(entry) }}\n{% endblock %}\n```\npage.jinja2\njinja\n{% extends \"_base.jinja2\" %}\n{% from 'entry.jinja2' import render_entry %}\n{% block body %}\n{% for entry in entries %}\n    {{ render_entry(entry) }}\n{% endfor %}\n{% endblock %}\nthis is a pretty logical placement of the macro, and results in one less import than if the macro would be defined in a third template.\nhowever, it doesn\u2019t work, as somehow the entry macro\u2019s body block is executed. i\u2019d expect the import not to execute the whole entry macro.\n. ",
    "opoplawski": "@mitsuhiko Is there any chance of this being accepted?  Looks like otf2 is now shipping a bundled version of jinja2 with this applied.  It would be nice to not have forked versions out in the wild if it could be avoided.\n. ",
    "akheron": "I find this annoying, too. If it's not going to be fixed, at least document it.\n. ",
    "priestc": "oh, i see. Maybe put a note of that in the  \"Switching from other Template Engines\" under then django section?\n. ",
    "inactivist": "I don't see this in the switching documentation.  It is mentioned in the control structures:for documentation but it would be helpful to have it in the switching doc...\n. ",
    "WloHu": "If list in code is a generator and for and if blocks work in the same way as in Python then the if-for construct doesn't solve the problem because generators are always truthy, plus such construct is less idiomatic than empty block.\nI don't know if you can add a flag to check if loop has run, check for NameError: name 'item' is not defined or add helper variable to list(generator) at Jinja level. If not, then the only solutions is to add the empty block or convince Python devs that empty generators should be falsy (to avoid ugly checking by handling StopIteration and \"pushing back\" popped item).. ",
    "paradoxxxzero": "This is due to this code being generated:\n```\ndef root(context, environment=environment):\n    parent_template = None\n    if 0: yield None\n    if parent_template is None:\n        yield u'Before include\\n'\n    parent_template = environment.get_template('i.jinja2', 'a')\n    for name, parent_block in parent_template.blocks.iteritems():\n        context.blocks.setdefault(name, []).append(parent_block)\n    raise TemplateRuntimeError('extended multiple times')\nfor event in parent_template.root_render_func(context):\n    yield event\nblocks = {}\ndebug_info = '2=10'\n```\n. Sure\n. ",
    "SimonSapin": "How is the proposed patch not compatible with the current behavior?\n. ",
    "equake": "I would love to be able to override blocks like this.\nIn my case, i have a base template that is extended by a lot of templates. \nSometimes those templates have to include \"components\" (for example: an slideshow). \nThis include need to add some <script> tag in the page header to work properly. It would be nice if it could override/extends the \"scripts\" block defined in the base template.\nIs there any alternative way to accomplish this with jinja?\n. ",
    "navilan": "@mitsuhiko - This change breaks a few websites that use hyde. Here is a simple demo:\nhttps://github.com/hyde/j2includebug.\n\nPushing parent blocks along with other context variables is surprising IMO. I'd like to propose:\n{% include \"xxx\" with context and blocks %}\nor something similar instead if its not too late.\nEdit:\nHere is (hopefully) a better statement of the bug:\nGiven a container C and an include I, this patch really includes container C with the include I injected at the top of the extension hierarchy of C. As long as I and C have completely different set of blocks this is okay. However, when there is an overlap between the blocks of I and C, the results will likely be surprising(bad).\n. I think its safer to completely pull this change out and reintroduce it only if a block resolution order can be provided alongside.\n. ",
    "ripperdoc": "To add to this, this update seem to break my site badly (unless I'm doing something else wrong of course...)\nI have three template files, A, B and Base.\n```\nBase\n{% block content %}{% endblock}\nA\n{% extends Base %}\n{% block content %}\nlorem ipsum {% include B %}\n{% endblock}\nB\n{% block content %}\ndolor sit\n{% enblock %}\n```\nThis throws me in maximum recursion, as (if I understand it correctly), in A.content we include B.content which was defined in A.content and so on? I had the same structure which was not an issue before, I presume before this update the block content in the included template was simply ignored?\nI can include without context but that will break other things, e.g. not being able to pass my model objects down to the included templates.\n. Just to add, the documentation lists both methods as OK, but only the second one works for me. http://jinja.pocoo.org/docs/dev/templates/#i18n\n. ",
    "SuryaSankar": "Will this feature be revived? Would be very happy to see this. The lack of this feature is the only issue I have had so far with Jinja2.. ",
    "aaronsw": "If you like this, I can also add:\ndef datetimeformat(value, format='%d %B %Y %H:%M'):\n    return value.strftime(format)\nand\ndef skip(s, skip):\n    return (k for k in s if k != skip)\nLet me know if it's worth writing pull requests for them.\n. It has tests! What's wrong with them?\n. What's wrong with having multiple names, especially when the function-name is so hard to remember like this one? It just makes it easier to use.\nNonetheless, I have removed them and implemented your other difficult requests. It feels a bit like a trial by fire. How's it look now?\n. Sorry about the Python 3 issues -- didn't think to test. And will try\nto be better about style next time. Do you just run through pep8?\nYour babel point makes sense and I'll submit skip if I find myself\nusing it a few more times.\n. ",
    "kjagiello": "Sorry, I wasn't clear enough. In my example, userprofile attribute contains a UserProfile object related to the given user. If no record is found in database, DoesNotExist exception is raised and this isn't handled by jinja2. Such a way of accessing related records is quite common in the Django world.\n{% if user.userprofile %}\n    {{ user.userprofile.something }}\n{% endif %}\n. I'm happy to hear that! :) \n. ",
    "mvantellingen": "@Balon: i've just discussed this with Armin on IRC. His solution was the to overrule Environment.getattr() and Envioronment.getitem().\nSee https://github.com/mvantellingen/django-cofingo/commit/75e7f8f4ee7d395dd1ef3bf7f658c397f3f13b24\n. ",
    "apollo13": "Arg that doesn't do what it should :/\n. Jupp already trying that\n. Okay, seems to be working now, but '_trans' get's set in the context, not sure how I can prevent that. (There is really no point in setting it in the context since it's passed via 'l__trans' into ngettext)\n. Cause you said \"Or use the stack to your advantage and call back to a function on the extension.\" (Note the or there ;)) Either way, can you get a bit more specific; eg any existing extension I could look at?\n. ",
    "liZe": "The new implementation doesn't lower the other letters : \"ABC\" | title gives \"ABC\" (it was \"Abc\" before).\n. ",
    "Anomareh": "Is there a specific reason the filesystem loader shouldn't accept a path returned by the os.path module?\nFor example, on a Windows box, FileSystemLoader(os.path.abspath('.')).\n. I believe this was in response to issue #98 which was in turn in response to an issue with a static site generator I wrote.\nIn my situation do you recommend I convert all paths that don't use a forward slash as a delimiter before feeding them to Jinja?\n. ",
    "ralphbean": "Thanks for your input, Armin.  We'll look into more modern ways to discover template engines.\n. Just posting here for posterity, tw2 supports jinja2 (without the buffet interface) as of tw2-2.1.0.\n. The associated issue has been closed.\nhttps://github.com/mitsuhiko/jinja2/issues/108\nClosing this Pull Request as well.\n. Just posting here for posterity, tw2 supports jinja2 (without the buffet interface) as of tw2-2.1.0.\n. ",
    "ento": "One workaround is to assign the default value to a top-level variable:\n``` python\nfrom jinja2 import Environment, FileSystemLoader\nenv = Environment(loader=FileSystemLoader(''))\nenv.globals.update({'get_int' : lambda: 42})\nt = env.from_string(\"\"\"\n{%-set test_arg1_default = get_int() %}\n{%-macro test(arg1=test_arg1_default) %}\n     {{-arg1-}}\n{%-endmacro-%}\n{{ test() }}\n{{ test(1) }}\n\"\"\")\nprint t.render()\n```\nOutput:\n42\n1\n. ",
    "Arfrever": "Please apply this patch:\n```\n--- docs/jinjaext.py\n+++ docs/jinjaext.py\n@@ -8,6 +8,7 @@\n     :copyright: Copyright 2008 by Armin Ronacher.\n     :license: BSD.\n \"\"\"\n+import collections\n import os\n import re\n import inspect\n@@ -22,6 +23,7 @@ from pygments.style import Style\n from pygments.token import Keyword, Name, Comment, String, Error, \\\n      Number, Operator, Generic\n from jinja2 import Environment, FileSystemLoader\n+from jinja2.utils import next\ndef parse_rst(state, content_offset, doc):\n@@ -110,10 +112,10 @@ def dump_functions(mapping):\n     def directive(dirname, arguments, options, content, lineno,\n                       content_offset, block_text, state, state_machine):\n         reverse_mapping = {}\n-        for name, func in mapping.iteritems():\n+        for name, func in mapping.items():\n             reverse_mapping.setdefault(func, []).append(name)\n         filters = []\n-        for func, names in reverse_mapping.iteritems():\n+        for func, names in reverse_mapping.items():\n             aliases = sorted(names, key=lambda x: len(x))\n             name = aliases.pop()\n             filters.append((name, aliases, func))\n@@ -145,9 +147,9 @@ def jinja_nodes(dirname, arguments, options, content, lineno,\n         doc.append(p + '.. autoclass:: %s(%s)' % (node.name, sig), '')\n         if node.abstract:\n             members = []\n-            for key, name in node.dict.iteritems():\n+            for key, name in node.dict.items():\n                 if not key.startswith('_') and \\\n-                   not hasattr(node.base, key) and callable(name):\n+                   not hasattr(node.base, key) and isinstance(name, collections.Callable):\n                     members.append(key)\n             if members:\n                 members.sort()\n@@ -169,10 +171,10 @@ def inject_toc(app, doctree, docname):\n     titleiter = iter(doctree.traverse(nodes.title))\n     try:\n         # skip first title, we are not interested in that one\n-        titleiter.next()\n-        title = titleiter.next()\n+        next(titleiter)\n+        title = next(titleiter)\n         # and check if there is at least another title\n-        titleiter.next()\n+        next(titleiter)\n     except StopIteration:\n         return\n     tocnode = nodes.section('')\n```\n. ",
    "techtonik": "Another problematic code http://jinja.pocoo.org/docs/dev/templates/#for\n. @westurner, so does it work? I am unable to check it right now, but it looks to me that {{ locals() }} should fail if it contains non-convertible bytes.\n. @ShaheedHaque any screens?. @ShaheedHaque screen would be really nice to compare with Smarty output from the first post.. Looks useful. So why not to fill a PR?. Me neither, but https://github.com/pallets/jinja/blob/master/jinja2/ext.py seems like a good start.. Wheel is there at https://pypi.python.org/pypi/Jinja2 so this issue can be closed.\n. 2.8 is released. Should be closed now.\n. http://jinja.pocoo.org/docs/dev/templates/#for - uses iteritems() (missing from Python 3)\n. One of the ways to fix this is to make examples run as a part of test suite.. It is more about memory consumption than efficiency. I wonder if Jinja2 preprocesses template exceptions and can convert iteritems() to items() in Python 3 on the fly?\n. @mitsuhiko thanks for the quick reply. The Roundup does nothing except that is passes 'utf-8' encoded string to Jinja2. The traceback is in the 2nd message here - http://issues.roundup-tracker.org/issue2550811\nI wonder if it is possible to subclass unicode object that Jinja2 uses, to override concatenation and addition methods to get control over encoding conversion back to Jinja2?\n. u''.join((a, b, c)) is the same as '' + a + b +c, and internally it should be handled by the same unicode.__add__ method. The only problem is that I do not see where is the source code for this class in Python.\n\nI would only accept them if it does not degrade performance too much.\n\nHow do you validate the performance? Are there some CI tests for that?\n. ",
    "hivre": "most likely a duplicate of #278 \n. ",
    "luc-j-bourhis": "Reading through jinja2.parser, if I understand correctly, the precedences of operators *, /, // and % does not follow Python: in jinja2, they are strictly in that order, from lowest to highest precedence, whereas in Python they all have the same precedence. This does not matter for * and / as they commute (baring floating-point round-off) but it does matter for // and %. Which means that expression involving // are \"wrong\" as well: 2 * 6 // 12 = 0 as per jinja2 but = 1 as per Python. \n. ",
    "ngaya-ll": "Maybe this could be configurable?  That way it wouldn't break backward compatibility, but the old precedence could be deprecated and eventually removed completely.\n. @candlerb This is not a correct supposition.  Jinja2 has its own built-in parser, so precedence is independent of Python.\n@pfalcon Filters and tests have higher precedence than binary operators.  For example {{ [3] + [2,1] | sort }} yields [3, 1, 2], not [1, 2, 3].\n. ",
    "ricky-undeadcoders": "I can't recreate this in Jinja 2.10, I'm pretty sure this was fixed in the following commit:\nhttps://github.com/pallets/jinja/commit/4fa37123b93c25de6f6596825df8b297a0433eee. I'm unable to recreate this in Jinja 2.10 (it works again as it did in 2.6).\nThis can be closed.. This is not reproducible in version 2.10. It looks to have been solved with #619. \nCan this be closed?. The space following the ellipsis has been removed as of 2.10. This can be closed.. I can't reproduce this in version 2.10. It looks to have been solved with #619. \nCan this be closed?. The issue here just appears to be that when lstrip_blocks = False, the syntax \"{%+ statement %}\" fails with error message \"jinja2.exceptions.TemplateSyntaxError: tag name expected\".\nThis is more or less expected behavior because there's nothing to disable if lstrip_blocks is already disabled, but it could fail a little more elegantly. \nExample:\nThis works:\nfrom jinja2 import Environment\nenv = Environment(lstrip_blocks=True, trim_blocks=False)\nstr7481 = '''\n    <!-- 1 -->\n    {%+ if True %}<!-- 2 -->\n    foo<!-- 3 -->\n    {% endif %}<!-- 4 -->\n    <!-- 5 -->'''\nstr7482 = '''\n    <!-- 1 -->\n    {% if True %}<!-- 2 -->\n    foo<!-- 3 -->\n    {%+ endif %}<!-- 4 -->\n    <!-- 5 -->'''\nprint(env.from_string(str7481).render())\nprint(env.from_string(str7482).render())\nThis does not:\nfrom jinja2 import Environment\nenv = Environment(lstrip_blocks=False, trim_blocks=False)\nstr7481 = '''\n    <!-- 1 -->\n    {%+ if True %}<!-- 2 -->\n    foo<!-- 3 -->\n    {% endif %}<!-- 4 -->\n    <!-- 5 -->'''\nstr7482 = '''\n    <!-- 1 -->\n    {% if True %}<!-- 2 -->\n    foo<!-- 3 -->\n    {%+ endif %}<!-- 4 -->\n    <!-- 5 -->'''\nprint(env.from_string(str7481).render())\nprint(env.from_string(str7482).render())\n. I spent some time looking at this, and I don't think a plus sign at the close of a statement tag is allowed.\nFrom the documentation http://jinja.pocoo.org/docs/2.10/templates/#line-statements you can see that the plus sign at the start of a statement tag will disable lstrip_blocks if lstrip_blocks is set to True. You can also see that a minus sign at the start or end of the statement tag will strip white space, but there's no mention of a plus sign to at the end of a statement tag.\nSo in other words, \nthis is okay: {%+ statement %}\nand these are okay: {%- statement %}, {% statement -%}, {%- statement -%}\nbut this is not: {% statement +%}\nI think this issue and issue 750 can be closed, while issue 748 needs further investigation.\nPlease let me know if I'm misreading something here.. I spent some time looking at this, and I don't think a plus sign at the close of a statement tag is allowed.\nFrom the documentation http://jinja.pocoo.org/docs/2.10/templates/#line-statements you can see that the plus sign at the start of a statement tag will disable lstrip_blocks if lstrip_blocks is set to True. You can also see that a minus sign at the start or end of the statement tag will strip white space, but there's no mention of a plus sign to at the end of a statement tag.\nSo in other words, \nthis is okay: {%+ statement %}\nand these are okay: {%- statement %}, {% statement -%}, {%- statement -%}\nbut this is not: {% statement +%}\nI think this issue and issue 750 can be closed, while issue 748 needs further investigation.\nPlease let me know if I'm misreading something here.. So, I agree with the assessment made here, but if you use the \"sameas\" function this all works exactly as expected.\nExamples:\n```\nfrom jinja2 import Template\nthis = Template('{% set x = \"bar\" %}{{ 2 * (x is sameas \"foo\") }}')\nprint(this.render())  # correctly prints 0\nthis = Template('{% set x = \"foo\" %}{{ 2 * (x is sameas \"foo\") }}')\nprint(this.render())  # correctly prints 2\nthis = Template('{% set x = \"foo\" %}{{ (x is sameas \"foo\") }}')\nprint(this.render())  # correctly prints True\nthis = Template('{{ 2 * True }}')\nprint(this.render()) # correctly prints 2\n```\nLikewise, both \"is eq\" and \"is equalto\" work as expected.  It's just the double equals that returns the wrong value. \nThis doesn't fix this ticket, but if anyone is stuck, a good workaround is to use any of the comparison functions except \"==\".\n. I daresay this is the same issue as #755, and can be closed as a duplicate.. I don't agree that the documentation needs updating.  The truncate function actually does default leeway=None, but then overrides it using env.policies to be 5.  However, this is clearly documented here http://jinja.pocoo.org/docs/2.10/templates/#list-of-builtin-filters with the following statement:\n\"The default leeway on newer Jinja2 versions is 5 and was 0 before but can be reconfigured globally.\"\nI'm not a maintainer, but I wouldn't support falsely stating that leeway defaults to 5 when it actually defaults to None, and then is overridden to be 5; especially since this is already explicitly stated in the documentation that default leeway is 5.\nFrom the code (version 2.10):\ndef do_truncate(env, s, length=255, killwords=False, end='...', leeway=None):\n    if leeway is None:\n        leeway = env.policies['truncate.leeway']. ",
    "metamatt": "Try mitsuhiko/jinja2-tmbundle (https://github.com/mitsuhiko/jinja2-tmbundle)\n. ",
    "FractalizeR": "It seems, like docs saying, that it is available from ext folder needs to be corrected.\n. ",
    "ioab": "The file is still missing. It would be better to link to the bundle repository.\n. You're welcome.\n. Sorry, link was broken :( \nCorrected it in the new PR.\n. ",
    "rbu": "I need this too, see #128 for a pull request\n. I would prefer the API to be more flexible here, how about a urlize(target='_blank') which would allow for generic user agent contexts and literals (_self, _parent, _top).\n. of?\nEdit: Which issue is this a duplicate of?. Any news on this one? We have plain text emails where we need to ensure paragraphs are wrapped at the end, but want lines within the paragraph to be wrapped automatically. This seems to be a common use case. In fact, this comment box I am typing this message in does the same. These lines are wrapped automatically, but when I hit double enter\na new paragraph starts.\n. At which point would you insert this?\nWe're using Jinja2 to generate and localize mails and after compiling the template, hand the resulting string over to pyramid_mailer/repoze_sendmail.\nA plain-text email template looks something like this:\n```\n{%- filter wordwrap(width=72, break_long_words=False) -%}\n{% block greeting -%}\n{% trans full_name = _(user.full_name) %}Hello {{ full_name }},{% endtrans %}\n{% endblock -%}\n{% block message_intro %}\n{% endblock -%}\n{% trans -%}\nThis may be a very long text in another language, depending on what a translator put into the gettext localization. It may even have its own paragraphs.\n{%- endtrans %}\n...\n```\n. Input to trans from the template (such as 'bar') as well as translations for this input (from gettext po files) are already \"safe\", as in not part of escaping. So I'd assume jinja2's translation mechanism escapes the unsafe strings before splicing them into translated template strings. It seems that's where this bug should be fixed.\n. I would seriously advise against writing your own HTML parser. If you need motivation: What about tags that do not need closing? What about script tags?\n. Thanks for the quick fix!. ",
    "awebdeveloper": "Is this in jinja .... and if it did it took 2 years to add a target. Not blaming but 2 years for this is too much for such a gr8 library \n. ",
    "heat": "I think should be better put only one way to show the seconds \"00:00:00\". The two ways confuse me.\n. The meaning \"1:20\" can be: 1 hour, 20 minutes.\nIf show only \"0:01:20\" you guarantee the real meaning.\n123 > \"0:02:03\"\n. I agree. a \"optional switch\" fit the need.\n. I like it. Thank mattrobenolt, This is very useful for me.\n. ",
    "cenkalti": "I did not understand your concern. There is only one way to convert. I just don't show hour part if it is zero. Can you explain in detail? Give an example please.\n. Yes, you are right. It does not confuse me, knowing that the last part always shows seconds but, it may confuse other people. Do you have a suggestion? Maybe an optional switch can be added to hide hour part if it is zero.\n. ",
    "mattrobenolt": "Also to note, I added in quickly Python 3 support, but I haven't tested that yet.\n. @mitsuhiko FWIW, a long time ago, I did pull this out into it's own package. :)\nhttps://github.com/mattrobenolt/jinja2-cli\nWhat about the behavior were you not a fan of?\n. ",
    "msabramo": "Bump.\n. Why was this issue closed? It's still a problem as far as I can tell. Possible fixes are #228 and #240 (almost identical).\n. :+1: \n. Ping\n. You're welcome! Thanks for maintaining Jinja2!\n. Oops. I just noticed that this is almost identical to PR #228.\nThis also fixes  issue #227, which I don't think should've been closed.\n. ",
    "jheasly": "@mitsuhiko Could you point to an efficient example of how to achieve this? A function or macro or somesuch? Thanks for any help you can provide!\n. To answer my own question, discovered Jinja2 Assignments, so if you want to ifchanged on baz.category:\n``` jinja\n{$ for baz in foo %}\n{% if baz.category != variable_watcher %}\n\n    {# Do whatever when there's been a change here. #}\n    {% baz.category %}\n    {% set variable_watcher = baz.category %}\n\n{% else %}\n\n    {# Do whatever when there's no change here. #}\n    {% baz.category %}\n\n{% endif %}\n\n{% endfor %}\n```\n. ",
    "lydell": "Here is a hack I used when migrating an older site until we could refactor the template properly:\njinja\n{% from 'macros/ifchanged.html' import ifchanged %}\n{% for num in [1,2,2,3,2,3,3] %}\n    {% call ifchanged() %}\n        {{ num }}\n    {% endcall %}\n{% endfor %}\n``` jinja\n{#- macros/ifchanged.html -#}\n{%- set last=[] -%}\n{%- macro ifchanged() -%}\n  {%- set next=caller() -%}\n  {%- if last|length == 0 -%}\n    {{- next -}}\n  {%- else -%}\n    {%- set prev=last.pop() -%}\n    {%- if next != prev -%}\n      {{- next -}}\n    {%- endif -%}\n  {%- endif -%}\n  {%- do last.append(next) -%}\n{%- endmacro -%}\n```\nResult:\n1 2 3 2 3\n(Hope this helps desperate googlers ending up here! ;) )\n. ",
    "ghost": "Moving the {{ negasonic }} into the content block results in the expected output, so surely this must be a case of me completely misunderstanding how the rendering contexts are scoped in cases where inheritance is involved. \n. Moved to #185.\n. @masklinn You're right - I've updated my branch to reflect that. Thanks!\n. I dunno if this is still relevant or not, so it should just be closed or marked unfixable/can't recreate.\n. > ```\n\nRunning MarkupSafe-0.18/setup.py -q bdist_egg --dist-dir /var/folders/03/d04nfpns45n7wr4m82nps7v40000gn/T/easy_install-njvdah/MarkupSafe-0.18/egg-dist-tmp-63z8qk\n```\n\nThis appears to be an issue with MarkupSafe and not Jinja2.\n. You could always do something like this:\napp.py\n@app.template_filter('debug')\ndef print_debug(message):\n    print message\n    return \"\"\nindex.html\n<html>\n<head>\n    <title>Testing</title>\n</head>\n<body>\n    {{ var1 }}\n    <br>\n    {% if not var2 %}\n        {{ 'var2 is null'|debug }}\n    {% else %}\n        {{ var2 }}\n    {% endif %}\n</body>\n</html>\nEven better put something next to it:\nindex.html\n<html>\n<head>\n    <title>Testing</title>\n</head>\n<body>\n    Var 1: {{ var1 }}\n    <br>\n    Var 2: {{ var2 }}\n</body>\n</html>\n. Think first you need to deserialize the json data into a python object:\nimport json\npython_data = json.loads(your_json_data_string)\nAfterwards you can iterate over these dicts. Bellow two different ways for the outer and inner loop:\n```\nfrom jinja2 import Template\ntemplate = Template('''\n    {% for mainkey in data %}\n    {{ mainkey }}\n{% for key, value in data[mainkey].items() %}\n<p><strong>{{ key }}</strong><span>{{ value }}</span></p>\n{% endfor %}\n\n{% endfor %}\n\n''')\n```\nAnd finally render your template:\ntemplate.render(data=python_data)\nThat's now for python 3.x - for 2.x you need to replace items() with iteritems(). Should work.\n@satyanani40 is this what you're looking for?\n. I have the same bug.\n```\n\n    {% set owl_count=0 %}\n    {% set owl_all = channels | length %}\n    {% for owl_channel in channels %}\n    {% set owl_count=owl_count+1 %}\n\n    {% if owl_all<14 or owl_count % 2 != 0 %}\n        <div class=\"item\">\n    {% endif %}\n\n<div class=\"ps-bl\">\n    <img src=\"{{ owl_channel.image }}\" style=\"cursor: pointer;\"\n         onclick=\"goChannel('{{ owl_channel.url }}')\"/>\n    <div class=\"tit-chanel\" style=\"cursor: pointer;\">{{ owl_channel.name }}</div>\n    <div class=\"flg j1 ato-flag\"><img src=\"{{ owl_channel.flag }}\" alt=\"\"></div>\n    <a class=\"love\" href=\"#\" data-id=\"{{ owl_channel.id }}\"></a>\n</div>\n\n{% if owl_all < 14 or owl_count %2 == 0 or owl_count == owl_all %}\n    </div>\n    <!-- .item-->\n{% endif %}\n\n{% endfor %}\n\n\n```\nThe problem with owl_count. It always equals 1. \nWith Jinja2 2.8 it works fine.\n. ",
    "rmadsen": "This would be a very useful for ASCII output, where whitespace is significant (for table alignment, etc).\n. ",
    "mchesnut": "I'm still having issues with this--is it a bug that I should expect to be fixed, or designed functionality that I need to work around?  Any input would be greatly appreciated...\n. Yes, that's the issue.  If you use PackageLoader, it requires distribute (setuptools) at run time due to the import line shown above.  I'm wondering if this is intentional (setuptools/distribute don't seem like they should ever be runtime dependencies in most circumstances).\n. Okay thanks for the clarification.  I've opened a pull request (#168) to add a mention of this to the documentation.\nReally I think we should also update setup.py to make distribute a requires, but I'm not sure if there's a way to do \"or\" in there (distribute or setuptools would be the requirement).\n. ",
    "nuald": "You can use compile_templates() method and ModuleLoader: http://jinja.pocoo.org/docs/api/#jinja2.Environment.compile_templates\nHowever, looks like bytecode cache is still faster.\n. ",
    "shackra": "I'm having this problem too but in Pelican, which uses Jinja2 for rendering html from markdown text. Here is the debug output:\n``` python\n-> writing /home/jorge/Documentos/SWEETGEEKLIFELOVEBLOG/output/2010/04/juan-el-sabio-de-la-taza.html\nCRITICAL: 'utf8' codec can't decode byte 0xed in position 140: invalid continuation byte\nTraceback (most recent call last):\n[...]\nFile \"/usr/lib/python2.7/site-packages/pelican-2.8.0-py2.7.egg/pelican/generators.py\", line 59, in get_template\n    self._templates[name] = self._env.get_template(name + '.html')\n  File \"/usr/lib/python2.7/site-packages/Jinja2-2.6-py2.7.egg/jinja2/environment.py\", line 719, in get_template\n    return self._load_template(name, self.make_globals(globals))\n  File \"/usr/lib/python2.7/site-packages/Jinja2-2.6-py2.7.egg/jinja2/environment.py\", line 693, in _load_template\n    template = self.loader.load(self, name, globals)\n  File \"/usr/lib/python2.7/site-packages/Jinja2-2.6-py2.7.egg/jinja2/loaders.py\", line 115, in load\n    source, filename, uptodate = self.get_source(environment, name)\n  File \"/usr/lib/python2.7/site-packages/Jinja2-2.6-py2.7.egg/jinja2/loaders.py\", line 374, in get_source\n    return loader.get_source(environment, template)\n  File \"/usr/lib/python2.7/site-packages/Jinja2-2.6-py2.7.egg/jinja2/loaders.py\", line 169, in get_source\n    contents = f.read().decode(self.encoding)\n  File \"/usr/lib/python2.7/encodings/utf_8.py\", line 16, in decode\n    return codecs.utf_8_decode(input, errors, True)\nUnicodeDecodeError: 'utf8' codec can't decode byte 0xed in position 140: invalid continuation byte\n```\nMaybe one solution is to bypass this error by catching the exception on line 169 in /jinja2/loaders.py because the text is already in UTF-8. However, I opened the file as in such line \"contents = f.read().decode(self.encoding)\" but instead I use \"utf-8\" and \"latin-1\" for the self.encoding argument and any exception was raised!\nactually I'm very confusing, I expected an error with my test...\n. ",
    "wulfraem": "Hm,\nI tried to add a catch block for this and even to set the encoding to 'utf-8' (hardcoded, switched self.encoding with 'utf-8') but to no prevail.\nI'm still having the same error... :/\nps: Sorry about closing and reopenening the issue. I hit the wrong button while submitting my post. Can someone undo this?\n. ",
    "WillSams": "http://ironpython.codeplex.com/workitem/29505\nIts an old issue related to the IronPython.  As Jeff Hardy pointed out, replace to_string = unicode with to_string = lambda x: unicode(x) near line 28 of runtime.py in jinja2.\n. ",
    "ael-code": "working with falsk-babel extension I encountered a similar issue:\nhttps://github.com/mitsuhiko/flask-babel/issues/48\n. ",
    "wryfi": "It would be nice if there were a built-in filter for this and other python 2to3 oddities. . ",
    "ThiefMaster": "Unless you have huge dicts, using .items() is not /that/ bad. Sounds like they should expose a custom test such as state(sensor.with_bitmaskvalue) is bitmask 1. I usually use a separate _foo.html file that contains only macros to avoid executing \"out-of-macro\" code when building a template module to call a macro from Python code.\nHowever, it would be nice if tpl.module simply ignored anything outside macros. Doing so would also avoid any issues with whatever Undefined implementation is used (unless the macro itself is trying to use something undefined, which usually shouldn't be the case).. With the separate html file there isn't - but for the simplest (and probably most common) case for .module where you just want to re-render something via AJAX it would often be nicer to have it in the same template, e.g. something like this:\n```\n{% macro row(item) %}\n    ...\n{% endmacro %}\n\n    {% for x in items %}{{ row(x) }}{% endfor %}\n\n``. Could you please provide an [SSCCE](http://sscce.org/) that shows the error?\n. Kind of obsolete. The current test doesn't check forlonganymore. However, that means it checks for different values in Python 2 and Python 3 which is probably not very good...\n. Just for reference, this is fixed by #406 / c6c6ea14375db6fb6a23a8bca533a6e388356422\n. Makes sense in my opinion. Trying to sort a dict, which gives you just its keys when iterating it, doesn't make lots of sense. Why not get its.items()or use|dictsortinstead?\n. That can be easily added by creating a [custom test](http://jinja.pocoo.org/docs/dev/api/#custom-tests) and adding it to your template context. Afterwards you could e.g. use{% if foo is type Bar %}(maybe aninstanceof` test would make more sense).\nHowever, I'd say it's much cleaner if you expose the \"type\" of your object via an attribute. After all, they'll be somehow similar, maybe even of a common base class? Based on your form field example, {% if field.type == 'password' %} would be better than {% if field is instanceof PasswordField %} - the latter would be much closer to code (which is something you want to avoid in a template) and also require you to expose the actual class PasswordField to your template.\n. FYI, {% set caller_ = caller %} also works fine, then it can be called whenever it's needed.\nAnyway, this might be worth a FAQ entry. I remember a colleague having the exact same problem some time ago until we figured out that {% set caller_ = caller %} before going into another call block helps.. ```\n\n\n\nenv = Environment()\nenv.from_string('{% set foo %}bar{% endset -%} foo={{ foo }}').render()\n'foo=bar'\n```\n\n\n\nWorks fine for me with the current Git version; there's even a testcase for it.\nDo you have any code reproducing the issue?\n. I think it would make much more sense to expose the dict constructor itself.\n. Looking at how ['mytemplate.html'] is printed twice, too, it looks a lot like your script contains two print statements of each type... I've tried it on both Linux and Windows and can't reproduce it.\nIf you can reproduce it, please create a full testcase showing the issue (and put it e.g. in a Git repo).\n. Umm jinja is unicode based so if operations involving unicode strings fail that's a bug. Having two types of strings in jinja makes no sense.\n. @jacebrowning  As the creator of the issue you should be able to close it on your own.\n. Which exception are you getting? I just tested it with a missing file in the first search path on Windows and the FileNotFoundError is a subclass of IOError and properly caught.\nWas it a folder you didn't have access to by any chance? In that case I'd actually expect an exception because unlike a template not being found in one of the search paths, an inaccessible search path is most likely not intended.\n. Initially I was going to open a separate PR, then I remembered that the hub util can convert an existing issue in a PR. I've updated the commits to remove the unneeded reference.\n. It's deprecated (not sure why, seems to be useful) according to the output of the command:\n\nWarning: Issue to pull request conversion is deprecated and might not work in the future.\n. FileSystemLoader loads the templates from a file system, but template paths within Jinja are not filesystems paths even if they end up getting mapped to one.\n. Please rewrite your issue using the provided template. It's there for a \nreason...\n. doesn't {{ foo or bar or baz }} do what you want?. But that's not what this suggestion is about. It's about picking the first non-falsy value, not going along a chain of attributes.. Besides json vs tojson (the latter is already used e.g. in Flask) I think it would also make this an environmentfilter and allow the environment to specify another json encoder.\n. Could you create a PR (including a testcase that fails in Python 3 without the fix)? Seems to be pretty straightforward.\n. I'm suggesting you to create a pull request to fix the bug - and such a PR should go along with a testcase so if the bug is ever re-introduced for some reason the test would fail.\n. ~~Actually... maybe renaming __next__ to next would be more appropriate? I don't think cycler objects are ever meant to be used as an actual iterator or with next(cycler).~~ Damn that testcase which uses next(cycler) instead of cycler.next()!\n\nAnyway, to preserve backward compatibility in case someone did that, maybe the best version would be simply adding add next = __next__ (or vice versa and renaming the method, since next is part of the public API of that object) to the class itself instead of using the decorator.\nIn any case, I think the textcase should cover both ways to get the next item \n. How is this a jinja issue? You have {{ in your string (I think you wanted { instead) which has a special meaning in Jinja.\n. That macro solution looks really strange. IMHO my arg idea is prettier. ;)\n. caller.something() sounds good; it makes a clearer difference between normal arguments and \"block-like\" arguments. Not a big fan of a macro-ish name though. Seems confusing to me.\n. {% call form(...) %}\n    normal caller() stuff\n    {% as footer %}\n        caller.footer() stuff\n    {% endas %}\n{% endcall %}\nThat wouldn't look too bad IMO - you are already inside the caller, so you'd use the new block as the contents for caller.footer\n. ping @mitsuhiko\n. :+1:\nYou could use {% filter safe %}...{% endfilter %} inside the set block though. But of course it's not as pretty.\n. Actually, the fact that you need to filter your set block as safe feels more like a bug to me since it results in double-escaped data very easily (which is something Jinja is usually pretty good at avoiding!).\nOpened another issue about this: #490\n. The example is perfectly correct. It shows users and then adds empty items to have 10 items in the list.\n. When fixing this let's make sure that in case of something like this, unsafe is still properly escaped:\n{% set foo %}<div>{{ unsafe }}</div>{% endset %}\n. You need to provide much more context/code.\n. That doesn't seem to be a Jinja problem. form.name (a BoundField instance) doesn't seem to be callable.\n. You should probably ask this in a Django place. It's most likely not a Jinja issue...\n. s/Standart/Standard/ but I think you could easily squash those three commits into a single one.\n. Is there any real gain from being able to use foo/../bar.html in a template path? This seems more like something that would just encourage some people to write less readable code.\n. It also seems very confusing when you have more complex loader setups where you don't simply load templates from a certain filesystem location.\nImagine you have a loader that takes care of /foo/* and one that loads everything else. Would /foo/../bar.html be /bar.html for the foo loader, an invalid path (trying to go above the root of /foo/) or /bar.html in the other loader?\n. why not just s/him/them/?\n. just a small heads-up: you can use fenced code blocks (triple backticks before and after) to format something as code on github. right now your demo code in the PR's description is not very readable\n. Not sure if autoescaping is a proper way to do this.\nI'd rather use a filter. tojson seems a good candidate since yaml is a superset of json,.\n\nBesides that: Any reason why you string-based templates to build YAML? Serializing a Python dictionary as YAML seems much cleaner. The only case I can see where this might not be sufficient is when you want to include comments. But in that case you could use a YAML engine that handles non-destructive reading/writing so you'd simply load a YAML template with your comments and empty items and then update the data and re-serialize it as YAML.\n. You could use a jinja plugin to apply the filter to all variables. It's not too hard as long as you don't have to use i18n blocks. Maybe you can take some ideas from something I've written some time ago: https://github.com/indico/indico/blob/master/indico/web/flask/templating.py#L187\n. Using Jinja templates or any other string-based template language or string operations at all to generate JSON is just wrong. I can see why you would do this for YAML since it is meant to be human-friendly, too, but JSON should be generated from e.g. a Python dict and not from a Jinja template.\n(that said, I am curious why you want to do that and what you are trying to do :p)\n. :+1: - would be very useful. Possibly a good opportunity to also add context support\nThe syntax could be this for example:\n{% trans [trimmed] [with context 'context'] [variables...] %}\ne.g.\n{% trans foo=bar, some=variable %}\n{% trans trimmed foo=bar, some=variable %}\n{% trans with context 'something' foo=bar, some=variable %}\n{% trans trimmed with context 'something' foo=bar, some=variable %}\n. https://www.gnu.org/software/gettext/manual/html_node/Contexts.html\n. it'd not specific to this.. but trans is also used for short strings..\n. I think the context stuff I initially suggested should be ignored for now, it's unrelated to this PR.\nHaving trimming would be very useful. I'd even go as far and make this configurable through a policy so it can be enabled by default! I think there are fewer cases where one does not want trimming than vice versa, but the default should remain without trimming for backwards compatibility.. Why not simply add another filter that tidies/sanitizes html (e.g. by closing unclosed tags)?\n. It sounds like something useful but personally I think it's not a good idea to include it in Jinja (I'm not a maintainer though) - you'd most likely use an existing library to cleanup the HTML and adding a new dependency for a rather specific filter (you only need it if you truncate strings containing HTML or deal with crappy HTML for some other reason) seems to be overkill.\n. You can already use is not equalto something:\n```\n\n\n\nTemplate('{{ foo is not equalto \"bar\" }}').render(foo=\"xxx\")\nu'True'\n```\n\n\n\nIf you want the negation of select or selectattr use reject or rejectattr instead.\n. ```\n\n\n\nimport jinja2\njinja2.Template(\"{{ disks|reject('sameas', '/')|list }}\").render(disks=[\"/\", \"/mnt/disk0\", \"/mnt/disk1\"])\nu\"['/mnt/disk0', '/mnt/disk1']\"\njinja2.version\nOut[3]: '2.8'\n```\n\n\n\nWorks for me.\n. Oh.. sameas uses is (and you cannot expect 'foo' is 'foo' to work). You want equalto which uses ==.\n. Ansible could do that. There is no need for such a change to be in Jinja itself - it is extensible enough to add custom filters or even replace builtin ones.. Why not use {% trans %}Get 50% off your first purchase{% endtrans %}?\n. I guess that shouldn't happen..\n. Use lowercase none.\nJinja's is is different from Python's is. It invokes functions registered as \"tests\". And while there's a none test, there's no test named None.\n\nUseful side-note: Jinja also uses lowercase for true and false, even though the python-cased True and False work too.\n. dup of #474 and there's a PR #493 but the author apparently never updated it with my suggestions...\n. Looks good for me\n. Seems fine, but I'll have another look in the evening when I'm back from work\n. Maybe it would be a good idea to remove @implements_iterator since it doesn't do anything now?\n. Jinja is not only for HTML but a general-purpose template engine. I think most people use Jinja in Flask, which enables autoescape by default for HTML templates. If you integrate a template engine in your own framework, you are supposed to read the documentation on how to use it safely.\nThat said, I think being very clear in the docs that you should probably use autoescape when generating HTML is a good suggestion.\n. Sounds like a good candidate for a pull request :)\n. Could you please describe what you are actually asking for? Just a title as vague as this one is not a proper issue.\nAlso, search the docs for \"stream\". Jinja might already have what you are looking for.\n. http://jinja.pocoo.org/docs/dev/api/#jinja2.Template.stream\n. What would be the benefit of a Jinja REPL? I can't imagine any use case where this would be more useful than just reading a template from stdin in one go and then rendering it.. I think it is a good recommendation to \"allow\" any extensions. Frameworks like Flask determine whether to auto-escape data for HTML based on the extension for example. And at least IDEs usually let you select which template engine you use so html files will be highlighted accordingly (at least that's the case with PyCharm).\n. You should not execute untrusted templates in a non-sandboxed environment. That's exactly why the sandbox exists (and to be honest, even with a sandbox I would not let users provide arbitrary Jinja templates)\n. Why would you want to use the sandbox by default? In most cases templates cannot be changed by untrusted people who don't have access to the code anyway.\n. Might want to add a testcase (that also ensures you can use forward slashes even if os.path.sep is a backslash, e.g. on windows). Many people do not want to use backslashes in paths in their code (and template paths are more often than not static strings, i.e. do not use os.path.join)\n. Not a bug, self._uptodate is supposed to be a callable. See e.g. https://github.com/mitsuhiko/jinja2/blob/master/jinja2/loaders.py#L285\n. Which loader are you using?\n. Then you should return lambda: whatever for uptodate ;)\n. Also, just as a heads-up: Make sure you trust whatever API you get the template from. Being able to control the contents of a template gives you the ability to execute arbitrary pthon code unless you use a sandboxed environment!\n. IMHO the whole idea of line statements is questionable. But maybe I misunderstood your question and you are asking for something unrelated? Maybe make an actual example of what you're suggesting.\n. You mean inside normal {{ ... }} blocks etc? I think that's an awful idea. Few template engines outside the PHP world use prefixes for variables...\n. Ah, I see. That would possibly break existing templates (since there's suddenly \"active\" content outside {{ ... }} and {% ... %}.\nIt would also only work for plain variables with no filters applied etc\n. strong :+1:, easy_install is awful\n. I'm pretty sure pip install compiles extensions. But it should be pretty easy to test it yourself ;)\n. Python 3.5.1 is the latest version; does it also coredump with that?\nAnyway, if python crashes it's more likely a broken installation or a bug in Python than a Flask issue. How did you install Python? Using your distro's package manager?\n. I don't think that's a jinja question. Better ask it on IRC or Stack Overflow.\n. I dislike this idea a lot. \"Explicit is better than implicit\" and considering that the file extension can control features like autoescape this is even worse.\nBesides that, you could implement this easily using a custom loader if you wanted such behavior. But I'd recommend against it.\n. In python that only works because jinja2/__init__.py imports Something and unliky Jinja Python files have only on extension.\nYou are right about the autoescape part, but it's still confusing as soon as you end up with more than one candidate in the same folder.\n. import jinja will just let you access things defined in its __init__.py and possibly modules inside the package (but I'd have to test that to be 100% sure).\nNo, you cannot import non-.py files in Python since the dot is already the package/module separate so you cannot put file extensions there.\n. I think the current behavior makes more sense. Using an undefined tag is like a syntax error and such errors should always cause an error, even if that part of the template is not executed.\nBesides that: loops, if, etc. are evaluated when the template is rendered but it's compiled to Python code first. For an undefined tag no code can be generated since Jinja cannot know what code to generate for that tag.\n. For your specific usecase you could probably put the code in a separate template and conditionally {% include %} the template only if you want to use assets.\nFailing silently seems like a great way to end up with buggy template.\n. Commit messages should use present tense / command style, e.g,. \"Add ftp urls ...\" instead of \"Added ...\". Also, you could squash the second commit into the first one - the fact that you fixed the tests in the first commit is not really something useful in the project history in case the PR gets merged.\n. Would it make sense to have only http/https by default and add an extra_schemes argument if you want to include stuff like ftp? I think ftp URLs are not that common after all.\n. memory != mem_limit\n. I don't think Jinja supports comments within statements - while most of the statements inside Jinja look like Python and are very python-ish, they are not actually python (they just compile to Python). For the same reason you cannot use a list comprehension in a Jinja template for example.\n. Not a good idea since you consume the iterable that way, meaning you cannot use it anymore afterwards. It might not be an issue in your case but what if you pass an iterable from outside?\nI'd rather add a custom filter (in the application, not jinja itself) like this:\npython\ndef itercount(iterable):\n    return sum(1 for _ in iterable)\n. Yes, but len() in python also fails when called on an generator, probably to make it clear that you cannot get the length of a generator without consuming it.\n. This sounds like an awful idea to be honest. Maybe you could explain your use-case for this?\n. A string-based templating language doesn't sound like a particularly good idea for this - any reason why you don't build Python dictionaries and then serialize them as YAML?\n. Check https://github.com/indico/indico/blob/master/indico/web/flask/templating.py#L196 - this is an extension I wrote a long time ago that adds a filter to basically everything. You could easily adapt this to apply a custom filter that does what you need.\n. look-see is an actual word. https://en.wiktionary.org/wiki/look-see\n. Why not simply escape the backslashes? 'E:\\\\project_test\\\\....'\n. Some of your changes are useful (e.g. the actual fixes), but others seem rather pointless. \"bytecode\" is actually more correct than \"byte-code\" according to google and \"autoescaping\" makes more sense than \"auto escaping\" since the Jinja feature this is about is called \"autoescape\". \"runtime\" is also more common than \"run-time\"...\n. Also, your git is misconfigured. You seem to be committing as None <none>...\n. As much as I think Python 2.6 needs to die, there is absolutely no gain from doing this except locking out users.\n. @jackwilsdon  are you still interested in your PR and willing to provide tests?. I don't think this is that useful in the core of Jinja...\nAlso, general advice for PRs and feature branches in general: Rebase them to upstream instead of merging upstream. Having merge commits in a PR's branch is rather ugly.\n. Also, please do not perform formatting cleanups in unrelated PRs. As nice as having no trailing whitespace etc. is, it just adds noise to a PR whose objective is to add a new feature.\n. > AbstractGeneric-factory   \u27a1\ufe0f  GenericAbstractFactory\nDid you mean AbstractGeneric-factory   \u27a1\ufe0f  AbstractGenericFactory?\n. You can add it in your application. It does not need to be part of Jinja itself.\nhttp://jinja.pocoo.org/docs/dev/api/#writing-filters\n. It still sounds very code generation specific so me so it's something I'd rather to inside cookiecutter's code (i.e. do a PR against cookiecutter to add this, and possibly also the reverse, i.e. snakify)\n. Does it happen with a minimal test case like this one?\npython\nimport flask\napp = flask.Flask(__name__)\nwith app.app_context():\n    print(flask.render_template_string('text: {{ text }}', text='hi'))\nBecause for me that one works.\n$ python --version\nPython 3.5.2\n$ python test.py\ntext: hi\n. I didn't spot one. If you have the flask debugger enabled check what args and kwargs contains in the last stack frame (vars = dict(*args, **kwargs))\n. http://serverfault.com/questions/762079/how-to-loop-through-interface-facts\nSounds like you can do this:\n{{ hostvars[inventory_hostname]['ansible_%s' | format(interface)].ipv4.address }}\n\n\nI'm very strong :-1: on variable variable names. It's usually a sign of bad architecture if an application doesn't provide a proper dict/list of data if you need to access it by dynamic key or iterate over it. FWIW, I think this hostvars dict is somewhat ugly compared to a proper dict mapping interface names to interface data. I'd open an issue with Ansible, suggesting to change that list to a dict. Since iterating over a dict yields you its keys it might not even be backwards incompatible if they changed it to a dict.... {{ form.playername(value=currentname) }} does it. but fyi, you should pass the current data to the form constructor and not bother with it in the templates at all. Pass by in #pocoo on IRC and ping me there (it's very much offtopic here) and I can tell you how to do it correctly.. thanks!. While this looks a lot like a bug that should be fixed, is it really a good idea to write such code? Especially considering that while Jinja (probably) gets the scoping right, Python itself doesn't (since it has no block scope):\n```\n\n\n\nfoo = [1, 2, 3]\nfor foo in foo:\n...     print foo\n...\n1\n2\n3\nfoo\n3\n```\n\n\n\n. I have the feeling this is a somewhat common use case - also stuff like {% set found = true %} in a loop and then checking it afterwards. It's surely likely to break things for people when this stops working.... apparently yes:\n```\n\n\n\nimport jinja2\njinja2.version\n'2.0'\njinja2.Template('{% for x in range(5) %}[{{ a }}:{% set a = x %}{{ a }}] {% endfor %}{{ a }}').render()\nu'[:0] [0:1] [1:2] [2:3] [3:4] '\n``. hmm maybe similar to python's scoping  assuming nononlocalwas used)? ie don't allow overriding something defined in an outer scope (ie if there's a macro inbetween) but do allow overriding it otherise?. the behavior seems to be different with/without recursive (2.8.1 gives me an UnboundLocalError error with recursive and '012' without).changed_from_lastsounds good - at least functionality-wise, the name itself is a bit awkward IMO. Maybe justchanged` would be clear enough?\n\n\n\nI guess the first element would always be considered \"changed\" no matter what it is? If that behavior is not OK for someone they could always add a not loop.first check anyway.. just previous or prev? \"context\" sounds rather confusing in this context (no pun intended)\n.....and now I can already imagine someone asking for a next :/. Filter syntax would not be possible here since filters are already possible on the iterable.\nA possible syntax for this that wouldn't look to bad could be this:\n{% for article in dates with last_day %}\n\nEspecially since with already does scoping stuff in Jinja when used e.g. as {% with %}. OTOH, here it would be the opposite since with blocks open a new scope, not make outer scope vars accessible..\nNot sure though if that's a feature Jinja needs or not.. FWIW, the solution with do is extremely awful. Just like the workaround people use in Python 2 when they'd need nonlocal.... Why do you need to do it at all? Also, please include your code.. didn't you mean |count?. Use loop.index instead.. I think providing access to the previous loop value through an attribute of the loop object is the only good solution for this.  I just discovered this snippet in our project which couldn't be solved by just checking if the last object is different than the current one and groupby also doesn't work there since it's more than just a trivial item/attribute access to get the key:\njinja\n{% set previous_date = none %}\n{% for item in entries -%}\n    {% set date = item.start_dt.astimezone(tz_object).date() %}\n    {% if previous_date and previous_date != date -%}\n        ...\n    {% endif %}\n    {% set previous_date = date %}\n{%- endfor %}. Had the same idea, but then couldn't find any non-ugly cases where this would be needed. And I could already see someone asking for setdefault, pop and other dict-like methods.. What I dislike with the namespace is that it'll feel very tempting to do {% set obj.attr = 42 %} with obj being something that is not a namespace() - something that I think shouldn't work.\nOtherwise it looks like an interesting idea, even though I think previtem / nextitem / changed() cover \"simple\" cases nicely without the \"noise\" of having to define a new object in the template.. ok, so at least no risk of templates causing unexpected side-effects on objects passed to them.\nstill a bit wary of the things people might do...\n```\n{% macro do_stuff(ns) %}\n    {% set ns.foo %}bar{% endset %}\n    {% set ns.bar %}foobar{% endset %}\n{% endmacro %}\n{% set ns = namespace() %}\n{{ do_stuff(ns) }}\n```\nActually, I think a new block like {% namespace ns %} would be better to define one than a callable - a variable named namespace doesn't sound like something very unlikely to be passed to a template, and while it would probably simply prevent you from using the namespace feature in that template (just like shadowing a builtin in Python) it feels a bit dirty.... Looks like a regression. Until it's fixed I'd recommend requiring jinja2<2.9 in your package requirements. isn't that caller=none arg pointless anyway? caller is already none (or undefined?) when calling a macro without {% call %}. sounds like something that should at least trigger a warning. asyncsupport.py and asyncfilters.py can only be import3d on Python 3.5+ - there is simply no way around this since it uses syntax not available in older versions. The jinja2 code only imports them if jinja2.utils.have_async_gen is True so I guess when you want to precompile all files unconditionally you need to skip those two for older Python versions. It would be helpful if you included information on how exactly that test fails.. I wonder if https://github.com/miracle2k/webassets/blob/master/src/webassets/ext/jinja2.py#L87 is using any undocumented APIs and/or relying on Jinja internals that changed with @mitsuhiko's recent scoping changes.... I think those strings should be r'...' raw strings to avoid exactly such warnings. FWIW, I don't think any \\ is needed for the - - outside [] the dash has no special meaning.. pytest is really weird with errors during test collection time. Having a look at this again in the future when I can test with 3.6 on a decent system (ie not windows) without spending time compiling python myself. Not sure if it would be very clear to special-case dict.items there. Especially since it'd still fail for custom dict-like types or maybe even OrderedDict. I think it's better to foo['items'] in those cases. It's not super pretty but consistent behavior.\nThe only possible \"fix/hack\" I could imagine to hancle this in a nicer way is checking whether a plain attribute (i.e. not a function call) is used in an iteration and you are trying to iterate over something that is not iterable but callable. In this case trying the item would be very unlikely to break any existing code. However, the implementation for such behavior in Jinja would probably be extremely awful ;). The Jinja logic for both ['x'] and .x is this:\n\nCheck if the item/attr (whatever your syntax gets in Python) exists, if yes use that\nCheck if the attr/item (the \"opposite\" of what your syntax would do in Python) exists, if yes use that\nFail if neither exist\n\nSo x.items checks for the attribute and since one exists it uses that. This logic works like this no matter the contest. Improving this would require the attribute lookup logic to change depending on its context. And even then it would result in awkward situations like this code that would work:\n{% for x in mydict.items %}\n\nvs this code which would not work\n{% set items = mydict.items %}\n{% for x in items %}\n\nAnd keeping special handling in this case would simply be impossible without keeping track of where a variable came from.. Ah, I didn't even see the suggestion of foo['bar'] not doing an attribute lookup. That's a bad idea for sure! What's wrong with you simply using for item in data.get('items', []) ?. Can you please post the relevant code from the template too? Ideally a minimal case reproducing it.. @mitsuhiko: The last traceback line looks broken - shouldn't it include the actual code from the template instead of the generated Python code?. Unrelated recommendation: You can simplify {%- if \"csss\" in assets and assets[\"csss\"] -%} to this:\n{%- if assets.get(\"csss\") -%}\n\nor even (if you do not use StrictUndefined):\n{%- if assets[\"csss\"] -%}. It's a bug in 2.9. Wrapping a block inside `if` is perfectly fine.. Looks a lot like a duplicate of #643. Can you skip compilation for certain files? These two files are never imported in python<3.6. This looks more like a bug or a bad type check in Ansible. A namedtuple is actually a subclass of tuple so code that can handle a tuple is supposed to handle a namedtuple just fine.. hrm, looks like they actually check for a tuple ast node... https://github.com/ansible/ansible/blob/devel/lib/ansible/template/safe_eval.py#L73. No, it doesn't require 3.6. It only fails when you try to compile all files - including files that would never be imported in older Python versions. Duplicate of #643. Also see #653. Assuming you are building a .deb, you could probably simply remove these two files prior to compiling, assuming the package will never be installed for 3.6 (not sure how exactly Python packages are handled on Debian). Actually, it seems that compilation of all other files still succeeds, so you can silently ignore these errors.. hm.. why not call the test `in`? sounds more natural to me for what it does. This looks a lot like something that could be done much cleaner with the [`batch`](http://jinja.pocoo.org/docs/dev/templates/#batch) filter. Also, check out the various attributes exposed on the `loop` object.. Maybe it'd be worth raising an exception when trying to do this in a way that worked in 2.8 but breaks in 2.9 to make it very clear that something is going wrong (except for weird behavior one might not notice immediately)?. Related: #643, #655, #653. https://github.com/pallets/jinja/issues/653#issuecomment-271647267 should avoid failing. Is it really a good idea to allow symbol operators in \"normal\" tests, i.e. for stuff like `foo is == 'bar'`? That looks completely awful to me to be honest. I'd rather allow an \"extended set of tests\" for the places where you use them as strings, i.e. `select`, `reject` and their `...attr` variants.\n\nThis would also add the advantage that editors and IDEs won't have to deal with new syntax when highlighting/checking Jinja code - I'm quite quire that PyCharm is not the only IDE that currently shows {% if foo is == 'bar' %} as a syntax error.. 100kb is not really \"much ram\". However, the module could probably be removed from sys.modules and the lexer.py module scope after this code has been executed so it can be garbage-collected...\npython\ntry:\n    compile('f\u00f6\u00f6', '<unknown>', 'eval')\nexcept SyntaxError:\n    name_re = re.compile(r'\\b[a-zA-Z_][a-zA-Z0-9_]*\\b')\nelse:\n    from jinja2 import _stringdefs\n    name_re = re.compile(r'[%s][%s]*' % (_stringdefs.xid_start,\n                                         _stringdefs.xid_continue))\nEither way, the regex probably uses not much less memory since it contains all these chars.\n\nIMO using non-ascii chars in identifiers is an awful idea, but I guess you can always find someone who doesn't code in english and Jinja is too mature to remove something like this anyway.... Does that happen very often? There's no clean way to implement such modifiers since it's a generic function handling the attribute lookup from a string (remember, you can do stuff like attribute='1.name' which is useful when dealing with dict items for example) - and that function is not only used for sorting.. Knowing your usecase for having more detailed debug info would indeed be useful. Any better suggestions for the names of these attributes?\nMy first thought was prev and next, but that could be confusing since there are already first and last which are booleans.. Maybe we should move this to 2.10 too... doesn't make much sense to have #684 in 2.10 and this one in 2.9. Yes, it will be in 2.10. Possible duplicate of #675.\nAlso, if you provided details on what exactly fails for you (and what you are doing with the custom context class) this issue would actually be helpful instead of being just a rant.. {% call %} doesn't seem to work with a template that doesn't use caller(). So your template is wrong, but Jinja should raise a meaningful error instead.. That was never possible. For anything but plain vars you need {% trans foo=obj.attr %}. I don't think the would be a good idea. If I iterate over something in Jinja I don't expect any automated recursion in case one of the items is also a generator / iterable / list / .... Have you tried it? That should work.. Could you please rebase the PR? Generally it's a good idea to use separate branches based off upstream/master for PRs instead of doing the changes in your own master branch.\nWhile this can be done when merging a PR, sometimes people merge using a merge commit instead of rebase/squash and in that case the extra noise would remain in the upstream history forever.. Could you add an entry to the changelog file? The PR looks good so far (not a fan of the all-lowercase-no-underscore naming of the argument but the existing one uses the same scheme it's consistent).. There is absolutely no way for Jinja to know whether it is dealing with HTML or not.\nIs there any reason why you have HTML entities in your text? In the era of Unicode there's rarely a good reason for this. Assuming you have proper (ie unescaped) data in your DB you should truncate it while it's still unescaped unicode and only then perform HTML escaping and similar processing.\n. This sounds like a change that would break many use cases. If I have something that looks like entities in my template I surely do not want Jinja to convert them to anything else.\nAnd if they are just used for lexing it'd probably break something like this:\n{{ foo(bar=\"foo&quot;bar\") }}\n\nAlso, when you use Jinja rules inside an XML file, why do you want to XML-escape jinja constructs? Your application that expects XML isn't even supposed to see the template before passing through Jinja so except that validation of the template as XML may succeed (which seems pointless to me) there doesn't seem to be any benefit.\nIf I'm completely misunderstanding your usecase, please provide a sample template that would not work without your change but works after applying your change.. That doesn't seem like something for the Jinja core. Maybe you can use a Jinja extension to preprocess your templates and do this conversion?. Let's add a test for this in test_dictsort. It's just two lines :p\nAlso, mention it in CHANGES.\nOh, and it'd be great if you could rebase against the latest master and squash the commits into a single one. While this can be done while merging it's easy to forget, which results in a somewhat ugly git log.. Jinja uses the normal % formatting of Python in the format filter - and that format syntax does not support converting to binary.\nHowever, you can use '{:b}'.format(12).. Does using render_async() directly do what you want? I think render is always supposed to be sync.. Duplicate of #641. Check whether this is caused by the leeway argument. The default value for it changed recently.\nhttps://github.com/pallets/jinja/blob/master/jinja2/filters.py#L467. Maybe we should extract the version from jinja2/__init__.py like it's done e.g. in flask...\nhttps://github.com/pallets/flask/blob/master/setup.py#L52-L56. This would be quite different from what list() in python does so I think it would be rather misleading. If you want to convert a string to a list simply use [....]. Why would the filter work on something that's not a string? Doesn't make much sense IMO.... IMO an exception makes it clear that something is going wrong. Since this is import-time behavior a setting would be hard to implement. However, you could probably add a custom sys.modules['jinja2._stringdefs'] before importing jinja.... Not sure if this really its in the Jinja core. Any chance this would be possible fully on the Ansible side by using a custom Environment/CodeGenerator/Runtime (I made the last two overridable on the Environment level some time ago). This sounds like a backwards-incompatible change to me (just like it was in Flask, but at least Flask is pre-1.0).\nIf Jinja itself used to autoescape json data changing it means people need to add |forceescape whenever it's used outside script tags (e.g. in data attributes) or they'll be prone to XSS.. Template paths are not necessarily filesystem paths and thus always use forward slashes. If you need to join these paths use string concatenation or posixpath.join(). you should not used that at all in the template path. use it on the base \ndirectory of the FileSystemLoader instead and then specify a template path \nrelative to that.\n. If you generate C++ (or really almost any other language that does not have significant whitespace) code from templates, the best solution is to not care about whitespace/indentation at all. Instead, focus on keeping the templates readable. Then, after rendering the template, run it to a reformatting tool tailored towards the code's language and let it reformat everything nicely.. But the include tag DOES take a string:\n{% include 'state' %} includes the template with the name state, without looking at any variables.\nActually, {% include state %} should fail unless state is a variable containing the name of a valid template.. no. i believe it's impossible to get back the exact template since whitespace stripping happens in the lexer. comments are probably discarded at this point too.. You'd probably still need to write a custom code generation that builds jinja code from the AST.. asyncsupport.py requires Python 3.5 and is not imported unless async features are used in Jinja.\nIf bbfreeze imports all modules in a package, even if they are not referenced from anything the package imports when used in your application, it's a bug in bbfreeze.. Also, the last release of bbfreeze was more than three years ago and their repo claims it's unmaintained. You should probably not use it at all and find an alternative to it :). No idea, try them out ;)\nAnd better use IRC or Stack Overflow if you have specific questions about these tools - this issue tracker is not the right place for sure.. > Aside: I also think case_sensitive should default to true\nNot for sorting for sure. In templates you almost never want a case-sensitive sort, it's not very human-friendly and that's what sorting in templates is usually used for.. While I think people should be using a kwarg for case_sensitive since |sort(true) is not very clear, we can't expect everyone to have done that. So I'd prefer to not break people's templates.... I'd rather keep the same order in the new filters to avoid this kind of confusion. I think using kwargs for any of these arguments is clearer anyway. > * Jinja version: 2\nThat's not a jinja version.... I just checked the code and it uses a template name. This does not mean file name. Can you shown an example where the problem you describe supposedly happens?. No, it shouldn't. Because to Jinja it doesn't matter where a template comes from - it could be the file system, a dict, or anything else. The template path (or \"template name\") in the environment, on the other hand, is something that does uniquely identify a template.\nRight now it sounds like something like env.get_template('foo') may reference different templates depending on some other criteria. Sorry to say, but if that's what you are doing it's just wrong! Ping me in #pocoo on IRC if you want a suggestion on how to do something like this in a much saner way.. OK, now I understand. I don't think that's really a supported usecase...\nWhy not use a custom loader based on PrefixLoader that gets the prefix to use from whatever code you have to determine the active module? Then it'd just dispatch to FileSystemLoaders pointing to the various module template folders.. Duplicate of #253?. Shouldn't this whole file be excluded from flake8 tests?. why are there 3 issues for this?. :+1: on waiting for 3.0.\n\n\nThe Stack Overflow tag is \"jinja2\", \"jinja\" is a synonym that gets invisbly converted. Despite my efforts towards the opposite. (This happened a year or so ago.)\n\nI may be able to fix that.\nEdit: Yes, I can\n\nRename preview\njinja2 will be removed from 3486 questions\njinja will be added to 3486 questions\n5 commitments to jinja2 Documentation proposal will be moved to the jinja proposal\nA tag synonym mapping jinja2 \u2192 jinja will be created.\n(these counts include deleted questions and exclude overlapping tags). Which you will quickly gain by trying to implement it yourself by subclassing the existing SandboxedEnvironment ;). Look at the docs and the code of the sandboxed environment. That's pretty helpful. And you can always ask on IRC if needed.\n\nBTW, while I'm not your boss, you should be allowed to to this on company time if you need this functionality for a work project. This is basically using a - very flexible - feature of Jinja to make it work the way you need it. But of course you'd then need to check with your superiors about contributing it back upstream if you want to do that.... It's not very clear what you are trying to do/achieve.\nAnyway, this is not the right place for this kind of question - use IRC or Stack Overflow instead.. This happens because elif actually compiles to else: if ...:. Not sure what's the reason for that (probably there is one though).\nEither way, I would recommend you to refactor your code to not have that many elifs - that sounds rather awful to have in the first place (but at least it seems to be generated code, so maybe not that bad). I might have a fix for it - see the referenced PR. However, your Jinja version is ancient. This fix would go into 2.9.5. Sounds like an (overly complicated ;)) case of #641.\nThere are a bunch of workarounds in that issue's thread and the next Jinja version will also contain some sugar to make it even easier to handle the case of \"did something change since the last loop\".. Like I already said in your other issue: This happens because you store data on the extension instance which is shared within all templates in the environment.. Jinja template names are not fileystem paths (even though they map to filesystem paths when using just a FileSystemLoader). They always use forward slashes so this is working as intended.. this is not the right place for support questions. use IRC or stack overflow.. Please provide a snippet to reproduce this. Right now it looks like a problem that could even be caused by pytest's rewriting. Or does running the Jinja tests fail for you?. If it works outside what appears to be a script that's run by pytest, it might be a pytest problem.\nOtherwise it sounds more like something is wrong with your Python installation or environment.\n```\n[adrian@pluto:~]> docker run -it --rm python:3.6 /bin/bash\nroot@4e19d0f3867f:/# python -m venv env\nroot@4e19d0f3867f:/# source env/bin/activate\n(env) root@4e19d0f3867f:/# pip install jinja2\nCollecting jinja2\n  Downloading Jinja2-2.9.6-py2.py3-none-any.whl (340kB)\n    100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 348kB 3.5MB/s\nCollecting MarkupSafe>=0.23 (from jinja2)\n  Downloading MarkupSafe-1.0.tar.gz\nInstalling collected packages: MarkupSafe, jinja2\n  Running setup.py install for MarkupSafe ... done\nSuccessfully installed MarkupSafe-1.0 jinja2-2.9.6\n(env) root@4e19d0f3867f:/# python\nPython 3.6.3 (default, Oct 10 2017, 02:29:16)\n[GCC 4.9.2] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nimport jinja2\njinja2.Template('foo').render()\n'foo'\n``. The docs for the latest release are here: http://jinja2.readthedocs.io/en/stable/templates.html#for\nThelatest` docs are based on git master.\n\n\n\nAnyway, I think we should release a 2.10 soon. ping @mitsuhiko . Please use IRC or Stack Overflow for support questions. Also, what you are trying to do is impossible. If you want to do this, then pass an object or dict containing an attribute/item named user.. I really don't think that exposing the whole python library via a template loader is even close to a good idea, even less something that should be in the Jinja core.\nBut I'm curious: What's your usecase for this?. I think it makes more sense to add this loader in your application then. While Jinja2 itself does not do any sandboxing (unless you use the sandboxed environment), I would not expect python imports to work in a template.\nFYI, if you want to expose modules, you can pass e.g. itertools=itertools as a kwarg when rendering the template.. The old behavior was the bug. See #641; 2.10 actually added various features to let you fix your templates that were relying on the old behavior.. The | and & operators are not supported in Jinja and most likele never will be, since | is actually used for filters.\nAs a workaround, you could expose the operator module to Jinja and then use or_(a, b) and and_(a, b) from that module instead of a | b or a & b.. Probably pandas does something custom when using the bitwise operators?. Jinja falls back to attributes in case of a KeyError when using [] and vice versa for an AttributeError when using . - both are intended behavior, e.g. to allow you to use foo.bar for dicts (much more readable in templates).\nIf you are accessing dict keys which may not exist but have the same name as an attribute of the dict, either do an explicit in check first or use .get() to avoid the fallback.. Only recent Python 3 versions allow this natively. Jinja templates should work regardless of the Python version they are used in, so I don't think such a change makes any sense before Python 2 is EOL and support for it is dropped in Jinja - emulating it would just be lots of work for little gain.\nEdit: Nevermind, just noticed that you did not use any of the Python3-only argument unpacking styles.. What is your actual issue?. I have no idea what you are trying to do there (you should not have to copy around files from Jinja manually). If Ansible is broken, ask the ansible developers.\nAlso, you are misreading the error. There is no template.py in Jinja, the Template class is imported in __init__.py which is why you can do from jinja2 import Template, but something is broken in your environment (maybe a custom jinja2.py in your PYTHONPATH?).\nAnyway, not a Jinja issue, the packages work fine, if you mess around with files manually like in your example you will run into problems. Python has a package manager for a reason (and so do linux distributions, if you install ansible using your distro's package manager it will automatically install the correct Jinja version in the correct place).. You do not need to git clone this repo. You need to install ansible properly.\nWhy are you even trying to install Ansible from a Fedora repo if you are on RHEL? Also, don't install random RPMs manually, use yum instead. See http://docs.ansible.com/ansible/latest/intro_installation.html#latest-release-via-yum which is what you can find very easily if you just google on how to install ansible...\nIn any case, this is not the right place for this. Please ask in a place related to Ansible or Fedora if you still can't solve this.. Of course. Jinja doesn't care about anything but the Jinja syntax. Wrap the JS blocks in {% raw %}...{% endraw %} or even better, don't inline JS in your templates.... Thanks! But could you rebase this against 2.10-maintenance as it's a bugfix? You can change the target branch of the PR using the \"Edit\" button on top of this page.. Thanks. I don't really care  about an 80 char line limit in a config file :) Especially if it has even longer lines already.. You cannot use a tag written for Django templates in Jinja - look at its code what it does, maybe you can re-implement it as a Jinja extension. If all it does is rendering a form, maybe Jinja macros are enough to do what you need. That's at least what people often do when using Flask and WTForms and render these forms in Jinja.. Interesting.. seems like open_if_exists should check for ENOTDIR as well.. Sounds like a good candidate for a PR to fix it (against 2.10-maintenance). Check if there's a testcase for the other error cases; if there is one add one for this one as well, otherwise I think it's not needed (unless you want to cover it of course). Sounds like something that should be covered with unit tests that run in different autoescape modes, and with both normal and Markup strings.. IMO such a feature is pretty nasty. \"How to get you data leaked\"-nasty. I can already see something calling this on a user-provided string with all the implications that come with it.... Exposing e.g. a User model instance to a template that shows user information is perfectly normal. But you wouldn't want to expose e.g. user.password (even if that's just a hash) or user.is_hiv_positive ;)\nAlso, Jinja code can call methods on the objects in the context, so unless you use the sandboxed environment, your templates must be about as trustworthy as your Python code.\nFYI: You could always add a function that renders a string as a template as a filter from your application code. No need to have something like this in the Jinja core.. To me it sounds like undefined filters/tests should behave likes undefined function calls: i.e. fail when they are actually executed, but not when they are skipped by an if block around them.\nMight actually be a bug that this is not the case already.... The first two failing make sense - invalid nesting is an obvious syntax error, and since {% foo %} can affect the generated code that needs to be evaluated at compile time as well.\nBut for a filter this doesn't seem to be needed, since foo|bar is pretty much the same as bar(foo) (except that bar is looked up in the filter list instead of the normal scope). What I mean is that the Python code for {% foo %} needs to be generated before the template gets rendered - so it's impossible to know whether it's needed or not. ({% if false %} is an obvious exception since for that the outcome is known ;)). Use a PrefixLoader or ChoiceLoader to expose hat directory to Jinja. Also, please use Stack Overflow or IRC for questions like this in the future.\nhttp://jinja.pocoo.org/docs/2.10/api/#loaders. While it looks pretty, it's going to be an absolute pain in the ass to add a new test/filter to that table.\n(also, from a semantic point of view, this isn't data that belongs in a table since the rows/cols are meaningless). Yeah, swallowing AttributeErrors originating from inside other code bit me in the ass in the past as well. I also don't see a decent solution for it. Inspecting the traceback would be an option, but the overhead would probably still be too big since handling and catching AttributeErrors is very common in Jinja - people generally use foo.bar to access dict elements in Jinja, so the first AttributeError would always result in this code to run.. You need to use a FileSystemLoader (or any other loader that actually knows how to load a template given a name) if you want to reference other templates.\nAlso, please use IRC or Stack Overflow for this kind of question.. Why do you open an issue like this?. Are python libraries supposed to accept pathlib Path objects in places where usually a string path is provided? If yes, a pull request (that does not break Python 2 compatibility!) would be appreciated.. Just reopen this one after forcepushing to your branch.. Ah, it's one of your first contributions in general? Don't worry then.. Just thinking.. would it make more sense to check for:\n\nis a string type (like before)\nhas a PEP519-style __fspath__ method\notherwise assume iterable, and use fspath if available or the plain value\n\nLike this it would not only support pathlib paths / objects whose __str__ is a path, but any object that represents a filesystem path.\nSince pathlib support is a new feature in general I don't think the fact that __fspath__ is Python3.6-only (probably one could use a pathlib backport for any older Python version) is a problem.. Jinja template paths/names are not file system paths; they only map to a file system path when a FileSystemLoader is being used. They always use forward slashes.\nFWIW, even when dealing with the actual filesystem in Python you can safely use forward slashes on Windows, since all the internal Windows APIs support them just fine, and so does Python.. Can you provide a minimal runnable example that triggers the other issue?. try (6>0)|... or even better, a literal boolean such as true|... or false|.... Because it's not a bug, but simply operator precedence. Without parentheses your code was probably running as 6 > (0|string) which obviously makes no sense, but in other operations such as 6 > '5'|int it makes lots of sense, so this is neither a bug nor unintended behavior.. I disagree, and this would also be a massively breaking change..     {{ (some_var|length > 0) | string | lower }}\nMore readable, and much clearer what it does. Ansible can add this. Just like they did with |bool which is not part of Jinja itself either.\n\nI know Python is happy with that but do you think is it a good idea to issue a warning when using > between int and string in Jinja templates?\n\nHaven't tested it, but probably it does fail in Python 3 where such comparisons fail loudly instead of silently succeeding with a somewhat useless result. Jinja does not do type checks, so it just passes the two operands to Python (didn't check the code, probably it calls operator.gt(a, b) for it). Sounds like a good candidate for a pull request!. That error means res_detail_interface['+tmp_cnt'] doesn't exist, so it's Undefined, which cannot be jsonified. My guess is that the + shouldn't be there.\nNext time don't post code as screenshots but rather as code. Also, errors with your own code should go on Stack Overflow, not this issue tracker.. 2 and '2' are different things. Use foo|int to convert a variable foo to an integer in case it's a string.. var tmp_cnt = Number($(\"tr:eq(\" + trSeq + \")>td:eq(0)\").text());\n{% set debug_cnt = \"+tmp_cnt\" %}\nUnless you define tmp_cnt in Jinja as well,, this obviously cannot work BTW. Jinja runs on the server, JavaScript on the client.. I don't think you are supposed to use _() for html snippets but rather {% trans %}\nAnyway, try this:\n<p>{{ _(\"Cost is %(price) per <b>month</b>\", price=get_price()|safe) |safe }}</p>.     {% trans price=get_price()|safe %}Cost is {{ price }} per <b>month</b>{% endtrans %}. Duplicate of #641 - setting variables inside loops that persist outside a single iteration was never supposed to be a feature and just worked by accident. Since 2.10 there are a few enhancements (#676 and #684) that should provide workarounds for all cases that previously relied on this behavior.. I don't see any real advantage from this. Usually people pass kwargs as actual kawrgs and don't unpack a dict there.. Look carefully, the repetition is not a mistake (albeit it does sound a bit strange). does `self.lineno` exist at all? *if* not, *and* if it's really hard to reproduce in a unit test, i don't really see much benefit in a test for this. #867. Why are you using `easy_install`? `pip` is the way to go. Also, don't use it with `sudo`, use a virtualenv or `--user` instead.\n\nAnyway, those errors can be ignored; they are not related to the install failing. See below, your downloads of the dependency are failing. Maybe because of the chinese firewall? In any case, it's not related to Jinja itself.. Like I said, this is not related to Jinja. Please read about the ways to properly install a Python package without sudo.. That sounds like sample is not a dict but a string. So, no problem with jinja but rather with the environment where the value is not what you expect it to be. Maybe you need to tell ansible to actually parse the file as YAML instead of just loading it as a string?. if python segfaults it might be a bug in markupsafe. > As you can see the item we\u2019re grouping by is stored in the grouper attribute and the list contains all the objects that have this grouper in common.\nHowever, for the second example there I think renaming grouper to gender would make more sense:\ndiff\n-{% for grouper, list in persons|groupby('gender') %}\n+{% for gender, list in persons|groupby('gender') %}. :bomb: Trailing whitespace is a bad idea :)\n. Both next(c) and c.next() should be tested\n. I'd do it the other way round and rename the method since a method named next() is part of the public API while __next__ is just a nice extra.\n. if not pieces[0]:\n    raise ...\n. PEP8 - there should be a space after ,\n. same\n. schemes?\n. domains?\n. Why not make those two lists tuples here instead of converting them later?\n. you removed the file's trailing linebreak\n. Not a big fan of this. Now you have a json filter that always uses the stdlib json module with the default settings and absolutely no way (except defining your own filter) to override this.\n. What's the advantage of disabling ensure_ascii? In Flask it defaults to True...\n. Is is_* really a good name for a function not returning a boolean?. ah, didn't notice you released 2.9 the last time i rebased. Do you mean something like what I added in the latest commit?. updated it. I wouldn't use custom functions but operator.eq etc. - they do the same in the end but are faster.. Were these functions ever documented as a public API?. no yoda conditions please :). Does this really fit in this function? I'd rather have the option to pass an arbitrary postprocess callable that'll be applied before returning the attribute's value.. Considering that it fixes a usecase that was broken in 2.9 it seems somewhat appropriate. Just an idea which I think would provide a nice solution to that problem. lowercase-L is not a good choice (and actually disallowed as per PEP8, just like uppercase-i). the [] isn't needed since there's only one argument to join(). true. ping @mitsuhiko . :monkey: . I don't like this. I'd rather add a native_code_generator_class class attribute and pick this one here. Otherwise there's no way of using a custom native code generator class without setting it after instantiating the environment (instead of setting it on the class level on a subclass). there shouldn't be an empty line here (only after a docstring). same. looks like a copy&paste mistake. the package name is wrong. this pun does not apply here, it was for the testcase that actually tests the jinja \"tests\". I think this function might easily get outdated if someone changes something in the main one. Can we somehow keep the code duplication here lower without making too much of a mess in the core?. Do we really want to exhaust the iterable immediately on creation? Not sure if there are cases where this may be problematic.\ncc @mitsuhiko . missing default value, this will break e.g. with StrictUndefined and even with the default Undefined it will most likely not strip anything when called without arguments.. please don't add commented-out code. args = args[::-1] + (value,)?. avoids converting to a list - you don't need the mutability so no reason to not stay with tuples. Do we even need both options? What's the benefit of a macro name instead of passing a macro? If you want to pick the macro dynamically in the code you can always use {% set macro = foo if x else bar %} with foo/bar being macros.. There's a double space after \"or\".\nDoes it even make sense to mention the tarball at all?. ",
    "bkruger99": "Here's a way to get around it: \nimport six\nenv = jinja2.Environment(loader=jinja2.FileSystemLoader('your_dir'))\nenv.globals['six_iteritems'] = six.iteritems\ntemplate = env.get_template('your_template')\n\nThen in your template:\nuse:\n{% for key, value in six_iteritems(your var) %}\nIt's kinda ugly, but it does work.. ",
    "catdkny": "using .items() instead .iteritems() worked . ",
    "plaes": "I also ran into following issue:\nFile .../lib/python2.7/site-packages/jinja2/_markupsafe/_native.py\", line 21, in escape\n    return Markup(unicode(s)\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 9: ordinal not in range(128)\n. \"...support byte and unicode literals in a consistent way.\"\n. ",
    "marco-bruggmann": "Solved. My class declaration was wrong. \nhttp://stackoverflow.com/questions/12738338/attribute-error-using-jinja2-grouby-filter/12738407\n. ",
    "karlw00t": "Doing a little research on how this can be fixed in py3.  It looks like python 3 needs to specify the encoding when you open the file (http://getpython3.com/diveintopython3/files.html):\n\n\n\na_file = open('examples/chinese.txt', encoding='utf-8')\n\n\n\nBut the issue is that in the file specified in this bug, the fileobj is passed into the babel extract function.  It would be awesome to get a trace back or even better, a code block that causes the error, or even more better, a unit test.  I don't know enough about this toolchain to reproduce this bug with the provided info.\n. ",
    "Zortaniac": "The error causes in the extract_messages command of setup.py in my pyramid project. I have work around the error by commenting out the decode function after read(), but I think its required for python 2 and only correct as long as the decoding is utf-8.\nI hope this traceback helps:\nextracting messages from backend/templates/dashboard.jinja2 (encoding=\"utf-8\")\nTraceback (most recent call last):\n  File \"setup.py\", line 45, in \n    ('**.py',   'chameleon_python', None ),\n  File \"/usr/lib/python3.2/distutils/core.py\", line 148, in setup\n    dist.run_commands()\n  File \"/usr/lib/python3.2/distutils/dist.py\", line 917, in run_commands\n    self.run_command(cmd)\n  File \"/usr/lib/python3.2/distutils/dist.py\", line 936, in run_command\n    cmd_obj.run()\n  File \"/venv/lib/python3.2/site-packages/Babel-1.0dev-py3.2.egg/babel/messages/frontend.py\", line 314, in run\n    for filename, lineno, message, comments, context in extracted:\n  File \"/venv/lib/python3.2/site-packages/Babel-1.0dev-py3.2.egg/babel/messages/extract.py\", line 171, in extract_from_dir\n    strip_comment_tags):\n  File \"/venv/lib/python3.2/site-packages/Babel-1.0dev-py3.2.egg/babel/messages/extract.py\", line 201, in extract_from_file\n    strip_comment_tags))\n  File \"/venv/lib/python3.2/site-packages/Babel-1.0dev-py3.2.egg/babel/messages/extract.py\", line 281, in extract\n    for lineno, funcname, messages, comments in results:\n  File \"/venv/lib/python3.2/site-packages/jinja2/ext.py\", line 593, in babel_extract\n    source = fileobj.read().decode(options.get('encoding', 'utf-8'))\nAttributeError: 'str' object has no attribute 'decode'\n. ",
    "SiDChik": "same\n. ",
    "dkrnl": "why did not think of at the beginning of start project\n. ",
    "ntrrgc": "Well, is not mine, but friend's system which has this problem:\nMy friend has an XMPP chat bot. The bot enters into a series of chat rooms, and stays there waiting for messages.\nThis bot has a popular module, usercommands. This module allows users writing and installing 'commands' in the bot. This commands are small programs written is Jinja, which have limited access to a set of variables (these variables store the nick of the user who runs the command, the arguments the command is invoked with, the list of currently connected users in the room, the name of the room, and little more).\nWith this, users can write small safe programs which do things like throwing virtual dices, attacking other users with random virtual weapons, storing funny quotes, and so. They're mostly for fun (although they can be used for many things, like storing frequently answered questions and answers, like bots of many programming chat rooms do).\nUsers are allowed to write and run commands once they are known, regular users of the chat room (they are granted by moderators of the room, which are known by the bot).\nAlthough funny, and mostly secure (the commands run in an isolated environment, as Jinja2 with controlled context variables is), this system has a flaw because we can't set a timeout to commands nor stop them. If an user writes and runs a buggy command which enters into a quasi-infinite loop*, Jinja2 does not provide a method to stop the processing of that template. Once this happens, the bot keeps working, cause it's multi-threaded, but it keeps hogging 100% CPU, at least on a core.\n*Last time I put it into that state by telling it to calculate China population factorial.\n. Yes, the bot is entirely written in python.\nThe approach of the first SO answer won't work, because SIGALRM is not thread-safe, and our bot is multi-threaded. \nThe other guy tells us to set a timer thread to send 'an interrupt' to the worker if it's still running, and points us to the threading API documentation.\nLooking at those docs, I only find a function for sending an interrupt (^C) to the main thread. May I being missing something?\n. It seems the only reliable solutions need polling.\n. Why not? Jinja is doing something different to what it states in the docs, so what's wrong with fixing it?\n. ",
    "agoma8": "mitsuhiko,\nWe have the same problem as DriverX.\nYes, the use of \"set\" is documented, but, is it working?\nOur example:\n\n    {% set the_var = 'foo' %}\n    {% for e in elements %}\n        {% set the_var = 'YES' %}                           \n        the var: {{ the_var }}\n    {%- endfor %}\n    the_var: {{ the_var }}\n\nResult:\n\n  the_var: YES\n  the_var: YES\n  the_var: foo\n\nCan you help us? Thanks\n. ",
    "i5513": "http://stackoverflow.com/questions/4870346/can-a-jinja-variables-scope-extend-beyond-in-an-inner-block and http://stackoverflow.com/questions/9486393/jinja2-change-the-value-of-a-variable-inside-a-loop\nI really don't understand why those hacks are neccesary, should be \"local var\" syntax or similar \nRegards\n. Ok,\nI have just open an pull request to ansible [1]\nThank you very much\n[1] https://github.com/ansible/ansible/pull/9213\n. ",
    "michilu": "I think should correspond by jinja2.\nI am using jinja2 with compass about building AMP-HTML.\nThe AMP-HTML must include a style section without another CSS files.\nMy case is written style by SASS then compiling by compass.\nThe CSS file has BOM that is the specification of the compass.\nhttps://github.com/sass/sass/blob/d26e6fa17f55d64278c9f09b5ace5e256e363e3f/lib/sass/util.rb#L833-L838\nOtherwise, we must continue to define a filter to remove the BOM, like this:\n``` python\nUTF8_BOM = bytearray([0xEF, 0XBB, 0XBF])\ndef strip_utf8_bom(s):\n    if not isinstance(s, basestring):\n        s = s.str()\n    if s.startswith(UTF8_BOM):\n        s = s[len(UTF8_BOM):]\n    if not isinstance(s, unicode):\n        s = s.decode('utf-8')\n    return s\n```\nthen use it:\njinja2\n{% import 'style.min.css' as style %}{{ style|strip_utf8_bom }}\n. ",
    "tony": "ugh, to make matters worse, Django templates don't do it either (see note at the end: https://docs.djangoproject.com/en/1.11/ref/templates/builtins/#include)\ni thought maybe jinja2 would, it'd save me a heck of a lot of duplication >_<\nanyway, I guess I'll just have to find a way to simplify stuff down :(. ",
    "gforcada": "a :+1: I'm also interested in that.\n. ",
    "wking": "Since there's a lot of Jinja work going on at the moment, maybe someone can merge this?  :D.\n. ",
    "dpursehouse": "Is it intentional/expected that keep_trailing_newline is only effective when passed into the constructor, and not when invoking render()?\nFor example, I have a template file that has a trailing newline:\n```\n\n\n\nfrom jinja2 import Template\nfrom os.path import abspath, expanduser\ndata = open(abspath(expanduser(\"~/jinjatest.txt\"))).read()\nprint \"[%s]\" % data\n[line 1\nline 2\n]\n```\n\n\n\nWhen it gets rendered, the newline is removed:\n```\n\n\n\ntemplate = Template(data)\nprint \"[%s]\" % template.render()\n[line 1\nline 2]\n```\n\n\n\nWhen rendering with keep_trailing_newline=True it is also removed:\n```\n\n\n\nprint \"[%s]\" % template.render(keep_trailing_newline=True)\n[line 1\nline 2]\n```\n\n\n\nBut if I pass keep_trailing_newline=True when constructing the Template, it works as expected:\n```\n\n\n\ntemplate = Template(data, keep_trailing_newline=True)\nprint \"[%s]\" % template.render()\n[line 1\nline 2\n]\n```\n. \n\n\n",
    "thmo": "The patch adds this code:\nfrom jinja2.utils import next\nwhich doesn't work in jinja2 version 2.7+ anymore, because this code\n```\nfor python 2.x we create outselves a next() function that does the\nbasics without exception catching.\ntry:\n    next = next\nexcept NameError:\n    def next(x):\n        return x.next()\n```\nhas been removed.\n. Already present in https://github.com/mitsuhiko/jinja2/commit/da94a8b504d981cb5f877219811d169823a2095e, and superseded by https://github.com/mitsuhiko/jinja2/commit/b89d1a8fe3fcbd73a8f4cebd4358eadebc2d8a9d.\nIt should however be ported to the 2.7-maintenance branch, because the docs do not build in 2.7.1.\n. I meant setup.py install, not sdist.. Not sure I understand. I'm simply calling setup.py install and that installs .py files into standard Python locations, which are not valid Python files, at least for Python < 3.6. That's got nothing to do with RPM. \nAdding workarounds to hide the fact that theses files cannot be byte-compiled is imho sweeping the original problem under the carpet. (How does pip differentiate between \"valid\" byte-compilation errors, and real ones?). ",
    "westurner": "I'd have to check, but I think this should work:\n<h2>locals()</h2>\n<pre>{{ locals() }}</pre>\n<h2>globals()</h2>\n... https://stackoverflow.com/questions/3398850/how-to-get-a-list-of-current-variables-from-jinja-2-template\n@mitsuhiko from https://stackoverflow.com/a/13757358/188833 : \n```\nimport jinja2\n@jinja2.contextfunction\ndef get_context(c):\n return c\napp.jinja_env.globals['context'] = get_context\napp.jinja_env.globals['callable'] = callable\n```\nfor debugging, e.g. pyramid_debugtoolbar can show the template context if the view function -- appropriately abstracted IMHO -- just returns a context object (e.g. dict, OrderedDict)\n- https://github.com/Pylons/pyramid_debugtoolbar\n- https://westurner.org/wiki/awesome-python-testing#pyramid\nuse case\nMy use case here is passing a few args from a CLI utility through to a jinja2 template (where I'd like to define defaults within the template (e.g. for Dockerfiles (without autoescape, of all things))\nWhat I'd like to do is\njinja\n{% set ENVVAR=context.get('ENVVAR', 'DEFAULT') %}\nbut, alas, the actual context object is [...]\n. - json.dumps(locals()) won't work without a custom JSONEncoder (with eg repr() for [code objects,])\n- maybe pprint.pformat(locals())? (this would be a convenient builtin)\n. - ... autoescape=True would then prevent XSS \n. Thanks!!\nOn Mar 11, 2015 3:15 PM, \"Markus Unterwaditzer\" notifications@github.com\nwrote:\n\nWow that are a lot of changes and improvements, thanks!\nI applied them after changing a few things:\n- 7ecfbe8\n  https://github.com/mitsuhiko/jinja2/commit/7ecfbe8b76800d3b57d30c9f7b05d56f4127662e\n- 0ce1bca\n  https://github.com/mitsuhiko/jinja2/commit/0ce1bca4a770e36dfe19ebe5fba5da8015b902c4\n- 459b908\n  https://github.com/mitsuhiko/jinja2/commit/459b908bff120af9c3268c4e462b05f08cdedcb8\nAs a whole your changes were great. (thanks!) I am shocked that Jinja's\ndocs are so badly phrased. Please avoid using GitHub's text editor though\n-- it seems to screw up the line wrapping.\nThanks again!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mitsuhiko/jinja2/pull/389#issuecomment-78361456.\n. \n",
    "exhuma": "This would be a boon to have when extending templates of a third-party app. I am currently using hieroglyph to create slide-shows, which builds on sphinx, and thus Jinja2.\nI've extended the default hieroglyph theme, and what I would like to find out is if the template contains some variable which tells me if I'm on a slide or not. Maybe the variable is there, maybe it isn't. So I am currently poking inside the hieroglyph source-code to find what I need.\nBeing able to simply dump all the available variables directly from within the template (that is, without modifying any Python code) would make this so much quicker and easier. So, let's say being able to do something like this would be nice:\n```\n{% extends \"!layout.html %}\n{# ... or any other sensible name #}\n{% dump_variables() %}\n{% block body %}\nHello World!\nsuper()\nGoodbye World\n{% endblock %}\n```\nThis way, I could introspect whatever hieroglyph offers me while developing the new theme.. ",
    "ShaheedHaque": "I created an extension for this purpose, it can be found at https://github.com/niwinz/django-jinja/files/1607805/jinja_extensions.py.txt. If you open the file, the comments have an example of the output. If\nneeded, I can provide an actual screenshot when I get home tonight...\nOn 6 Jan 2018 02:23, \"anatoly techtonik\" notifications@github.com wrote:\n\n@ShaheedHaque https://github.com/shaheedhaque any screens?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/pallets/jinja/issues/174#issuecomment-355716273, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AEp7KdBBslHJPIGp5VliuF74bxSZTk-wks5tHtkEgaJpZM4AXefd\n.\n. \n\nAs requested. You'll see that the contents are organised (and sorted) by context variables, filters and tests. Also, here is a zoomed-in view on a screen with a few more \"interesting\" context variables. See how the limit to depth=3 is enough to show a bit of detail, without incurring the possibility of overly nested output since, I believe, the most requested thing is to know exactly what (top level) context variables are present and not the full depth of any structures:\n\nYou'll also likely see that it is trivial to change/extend the details of what is shown (or it will be, for somebody who knows how the parser works...I'm not in that blessed circle :-)). . I'd be happy to do that given some guidance on where in the ninja codebase the new code should live (I'm not familiar with this project).. See PR #798.. To be honest, that seems like overkill given that this is a debug facility intended to efficiently serve the all-too-common scenario of \"Hmmm, I'm not quite sure what all the context variables are\" using built-in Python string formatting. If table support was needed, perhaps it would be better to introduce some kind of a magic {{ debug }} which returned the equivalent dict, and allowed the user to select what was needed and how it should be styled?. True, but that sounds like a whole different thing: its not a tag for the reason you suggest, nor is the idea of a \"magic\" context variable that contains all other context variables/filters/tests a \"nice\" thing. That all but calls for new syntax {{ %reserved-thing% }}, for example. I believe the requirement being addressed here is much simpler than full scale access to that data.. If you'd prefer not to accept this PR, please do let me know (the downstream project I'd originally submitted this to might be an alternative home).. Of course, it is completely reasonable that you and the community must feel comfortable with what is proposed. If its not the right thing for Jinja, so be it. In the meantime, thanks for the excellent feedback, I will address the points noted.\nOn the general comments...\n\nabout this being an extension. Yes, I packaged it that way because I thought that seemed like a plausible approach. I'm fine if you prefer to make it part of the default tag set.\nabout the output not being JSON, I should just point out that the data exposed is commonly not vanilla data, at least in the Django context. There are ellipses present, but that's only because I specifically limited the output depth. If you prefer, I could remove that limit. Barring that, it looks like JSON to me...though I've not reviewed how pprint works..is there some case you have in mind?\nabout the output not being interactive. I'm not sure quite what you had in mind, but interaction was not something I think belongs in this context. \nabout alternate debug facilities. I use PyCharm too, but it turns out that at least for Django-users, breakpoints are not supported with Jinja...~~only DTL is supported~~. There are also plenty of scenarios where I think a simple dump is useful.\n\nEdit It turns out that the docs are wrong, as you say provided the file type association is set correctly, Django with Jinja can be debugged just fine under PyCharm. I'll look to file an upstream doc bug.\n. I think I've addressed the comments, but it is not clear to me how to verify the markup-related suggestions (I had to work around an unrelated doc build failure locally, but the Travis build fails in some way that seems likely related to my change...I'll have to experiment to fix it).\n\nOn the JSON format. I'm happy to look at that if that becomes the blocking issue.\nOn the interactive thing. I have no idea how to implement that and it is not of interest to me.\nOn the PyCharm support. The link I provided is to the official PyCharm docs: the combination of Django and Jinja is not expected to work.. I've no idea why the doc build is failing under Travis:\n\n\nWarning, treated as error:\n/home/travis/build/pallets/jinja/docs/templates.rst:1314:Could not lex literal_block as \"jinja\". Highlighting skipped.\nERROR: InvocationError: '/home/travis/build/pallets/jinja/.tox/docs-html/bin/sphinx-build -W -b html -d /home/travis/build/pallets/jinja/.tox/docs-html/tmp/doctrees docs docs/_build/html'\n\nI do get a different error locally, but if I make this change on about line 307 of docs/extensions.rst:\n\n-   \\:members\\: push, look, eos, skip, __next__, next_if, skip_if, expect\n+   \\:members\\: push, look, eos, skip, next_if, skip_if, expect\n\nthen I get a clean local build. I don't see how this can be related to my changes, so I fear I'm a bit stuck.. I note that PR #802 has the same doc build failure.. Ack.. Ack.. I had not appreciated the code was being processed for markup. I will look into this.. Duh.. If an assert fails, the debug output is much easier to read, and so the tests are easier to maintain.. Thanks for the tip. I'll look into it.. OK. Can you educate me on where to look to see what is produced? I've tried running sphinx by hand, and searched in vain for where this stuff ends up under the docs/_build tree. (I'm a sphinx newb).. ",
    "dwt": "\nI don't think this is a bug. Wordwrap just seems to assume that your text is not wrapped yet.\n\nWell, obviously. But it makes it really hard to use in an environment where you need the wrapping but the text you want to wrap already contains Some form of formatting (to separate Paragraphs for example).\n. I like it. @maintainers - is there any reason not to include this change?. ",
    "fossilet": "I also encountered this problem and a Google search led me here. Using the patch from @dwt works for me. I also vote for this change to be incorporated in the code base.\n. ",
    "p2": "Same here, would be great to incorporate the fix into master!\n\nNote that wrapstring disappeared in the patch\n. \n",
    "fheinle": "I submitted a pull requests that works around this somewhat unexpected behaviour of textwrap.wrap() when dealing with multiple paragraphs.\nwrapstring and empty lines are preserved.\nWe're using this functionality for generating email bodies as part of another application and want to wrap input at 80 columns.\n. ",
    "t-makaro": "I'm encountering this issue as well in my nbconvert template. It'd be super nice to have #766 merged since if I have to write my own filter, I believe that I'll have to write a custom exporter for nbconvert, which for ease of use I'm trying to avoid.. ",
    "jpfarias": "Maybe I wasn't clear enough on my description. That filter would be applied when you have an object and a string with dotted notation on how to get to an element of that object.\nI use that on my projects specially when writing macros where I can pass the macro the root object and a string on how to get the attribute.\nSo if you have a root object my_obj and a string path with 'x.y.z' you can't really do my_obj.path.\n. Yes, I've written that in a different way on my first post. I just thought it would be useful enough to other people that it could be included with the standard filters, seems that is not the case though.\n. Thanks for the input, I didn't know that could be done already. :)\n. ",
    "Naddiseo": "@jpfarias \n``` python\n@environmentfilter\ndef jinja_getattr(env, obj, attr_string):\n    if attr_string == '':\n        return obj\n    for attr in attr_string.split('.'):\n        obj = env.getattr(obj, attr)\n    return obj\njinja_env.filters.update({ 'navigate' : jinja_getattr })\n``\n. The one you gave in your first post doesn't work when mixing objects and dictionaries, what I meant to point out was that jinja already has this functionality. If you know you're just going to be using one or the other you can use the jinja functions directly (in a loop), or even useoperator.{attrgetter, itemgetter}` in which case the filters become simpler:\n``` python\nimport operator\njinja_env.globals.update({ 'getattr' : lambda obj, attr: operator.attrgetter(attr)(obj) })\nyour implementation is equivalent to the following:\njinja_env.globals.update({ 'getitem' : lambda obj, attr: operator.itemgetter(attr)(obj) })\n```\n. In case anyone else runs into this before it's fixed I've come up with a work around:\n``` python\ndef context_class_hack(klass):\n    def inner(*args, kwargs):\n        instance = klass(*args, kwargs)\n    @contextfunction\n    def klass_wrapper(context, *args, **kwargs):\n        return instance(context, *args, **kwargs)\n    return klass_wrapper\n\nreturn inner\n\nUsage:\n@context_class_hack\nclass Klass(object):\n    def call(self, context, args, *kwargs):\n        return\n``\n. This works for me.\n. This bug closes #180 \n. If youdel self.mod_envwhere it is placed, the rest of the method is dead code.\n. It made the rest of the method dead code because the check immediately after ishasattr(self, 'mod_env')` which would always return False.\n``` python\n\n\n\nclass Foo(object):\n...   def init(self):\n...     self.bar = 1\n... \na = Foo()\nhasattr(a, 'bar')\nTrue\ndel a.bar\nhasattr(a, 'bar')\nFalse\n\n\n\n``\n. What's wrong with{{ '1  2  \\t\\n 3'.split() }}`  ?\n. I use something like this:\n``` python\nclass UndefinedVar(jinja2.Undefined):\n    def getattribute(self, name, args, *kwargs):\n    try:\n        return super(UndefinedVar, self).__getattribute__(name, *args, **kwargs)\n    except AttributeError:\n        if settings.TEMPLATE_DEBUG:\n            import inspect\n            f = inspect.currentframe().f_back.f_back.f_code\n            file_name = f.co_filename\n            lineno = f.co_firstlineno\n            warnings.warn(\"[{}:{}] Trying to access attribute '{}' on undefined variable '{}'\".format(file_name, lineno, name, self._undefined_name))\n        return UndefinedVar()\n\n    return None\n\n``\n. The reason this issue is so hard to fix is because jinja compiles the templates to python code, so when there's an exception you get the traceback of the compiled code. One (ugly) approach I can think of is to use the backtrace data to get the python line number, then use the linemapping data that jinja puts in the same file to try and calculate what the template line number would be.\n. My guess would be operator precedence.x/2 | roundis parsed asx / (2 | round). My guess would be to start with the BinOp node https://github.com/mitsuhiko/jinja2/blob/master/jinja2/nodes.py#L372\n. Try usingfrom_stringinstead oftemplate_class` \n``` python\n\n\n\nimport jinja2 as jj\ne = jj.Environment()\ne.filters['f1'] = lambda x : \"[{}]\".format(x)\ne.from_string(\"{{value|f1}}\")\n\ne.from_string(\"{{value|f1}}\").render(value='Hello World')\nu'[Hello World]'\n```\n. To answer your question: there's no built-in filter.\n\n\n\nThere are two ways I can think of doing this\n- First would be to create a filter with os.path.join, something like: jinja_env.filters['path_join'] = os.path.join\n- The second would be to always use just use '/'.join() which afaik works on windows too.\n. You can use plain python methods in jinja templates:\n``` html\nPath: {{ '/'.join(path_parts) }}\n```\nAnd as far as I know (and wikipedia seems to agree), windows allows the use of forward slashes, so the use of os.path.join is moot in a lot of cases.\n. Filters only accept a single argument (ignoring context), which is the left-hand side of the filter expression.\n\nIs Jinja2's filters method unable to accept whole functions/methods directly to use them as filters?\n\nIt can take plain functions as long as they only need a single argument. \na|b is converted into b(a) so using your first approach would only work if os.path.join took an iterable as its only argument, instead it takes an *args argument, and so you, correctly, specified the filter with a lambda.\n. I think you could use the reverse filter for that.\n. This line sounds weird with two \"the templates\". Probably should be phrased something like:\nYou can mess around with variables in the templates provided they are passed by the application.\n. This sentence is ambiguous, does \"heavily\" apply to \"looks\" or \"depends\"? You need the comma after \"looks,\" otherwise you're saying that the variable looks heavy.\n. ",
    "jgehrcke": "I am interested in basically the same thing. The issue has also come up at stackoverflow: http://stackoverflow.com/questions/10821539/jinja-keep-indentation-on-include-or-macro\n+1\n. ",
    "maxime-esa": "Also true when using the form:\n{{linesGlobal|join('\\n')}}\nThis form does not behave as one would expect - since jinja2 is the one emmitting the newlines, it should make sure that they remain aligned with the last indentation level.\n. ",
    "fmarczin": "This would be very nice to have! It would lead to much nicer templates and rendered output at the same time. \nWhy not create another whitespace option similar to {%+ and {%- that prepends the current indentation on whatever it evaluates to? Could be {%= or {%|\n+1\n. ",
    "mpaolini": "+1\nneeded here for templating API blueprint documentation:\n```\n{% macro entity_one() -%}\n{\n    \"one\": 1,\n    \"two\": 2\n}\n{% endmacro -%}\n\nResponse 200 (application/json):{\n    \"entity\": [\n        {{ entity_one() }}\n    ]\n}\n\n```\n\n\nis  rendered now :\n```\n+ Response 200 (application/json):\n    {\n        \"entity\": [\n            {\n\"one\": 1,\n\"two\": 2\n\n}\n        ]\n    }\n\n```\n. ",
    "inducer": "When emitting YAML or Python, this becomes pretty crucial.\n. ",
    "DataGreed": "Ran into the same problem. \nIs there a workaround for now other than defining a macro for every included tempkate and manually entering the indentation?\n. ",
    "kaikuchn": "Sorry for reviving this old issue, I just came across the same problem and googling brought me here. After some more looking around I found that by now there is a nice way to achieve this through the indent filter. ",
    "Cigizmoond-Vyhuholev": "@kaikuchn Thank you, dude! It works.. ",
    "ttsiodras": "@kaikuchn , @Cigizmoond-Vyhuholev  Guys, I am not sure I follow... as you can see in my original report at the top, I do mention a workaround with the indent filter - but also clearly state that it doesn't address the issue in the simple and powerful way that e.g. StringTemplate does, because it forces you to count indentation spaces every time you need to emit a block of lines... If you have to do that and you are generating code of any form (C, Python, whatever) you'll very quickly just abandon the process altogether...\nThen again, I may have misunderstood what you meant... Can you share exactly how you'd implement my original requirement shown at the top? i.e. generate the same kind of output with Jinja2 syntax? This is what I don't like... \nif (someRuntimeFlag) {\n    {{linesGlobal|indent(8)}}\n    if (anotherRuntimeFlag) {\n        {{linesLocal|indent(12)}}\n    }\n}\n...because I need to count the \"8\" and \"12\" in each and every template where I emit code. In comparison, in StringTemplate...\n```\nPrintCFunction(linesGlobal, linesLocal) ::= <<\nvoid foo() {\n    if (someRuntimeFlag) {\n        \n        if (anotherRuntimeFlag) {\n            \n        }\n    }\n}\n\n\n```\n\n\n. ",
    "masklinn": "For the octal, in order to keep 2.5 compat' wouldn't it be better to parse it as an octal string if you want to keep octal? int('755', 8) should work in all Python versions\n. ",
    "mwcz": "I tried again on a different Internet connection and in a fresh virtualenv and it installed successfully.  The attempt above was from my phone's wifi tether.  False alarm.\nStill weird though, since I ran pip install with --ignore-installed, which presumably ignores any cached packages.  Yet each time I ran it, the MD5 sum was exactly the same.  Wonky Internet doesn't explain that.\nMysteries like this course through the currents and eddies of the universe.\n. ",
    "gad2103": "is there any way to handle None type objects gracefully in sum?\n. ",
    "Kronuz": "For one thing, although this is arguable, it's cleaner to have a rewind method in a lexer. For the more practical answer, the django <-> jinja2 compatibility layer I'm working on, and which I will soon make available, needs rewind for the template tags part, to compile Extensions out of simple_tag, inclusion_tag and other template-sugar-like helper function decorators that work both in jinja2 and django.\nAbout that, by the way, I now have the exact same unmodified (really big) templates codebase working in both jinja2 and django (with my compatibility layer) and I can easily measure the benefits of using jinja2 vs django in the exact same page by swapping engines: 4697ms (django) vs 468ms (jinja2)\n. ",
    "rpuntaie": "Whoops, white space stripping = {{- for {{}}, too. What I intended to have is the negative of g.a, and that didn't come, I realize now, because of the white space stripping. Ok, but then the behavior of {{-g.a}} and {{-g['a']}} are different (g is a dict), and that's not supposed to be so, right? A dict entry is supposed to be addressable in both ways, isn't it?\n. ",
    "mgax": "Most likely strftime returns a str object. Depending on the locale it can be encoded as utf-8, iso-8859-1 or iso-8859-15. It's up to you to figure out the encoding (see locale.getlocale) and decode the bytestring to a unicode object before passing it to Jinja.\n. Jinja can't possibly guess the correct encoding. The problem is in strftime which should return a unicode value.\n. > Couldn't Jinja2 figure out the encoding via locale.getlocale, in the same way I am?\nNo, since Jinja doesn't know where the string comes from. It could be from a file on disk, or from the network, and there's no way to be sure about the encoding. This is a general problem when passing around bytestrings; that's why you should convert them to unicode as soon as you can (because it's more likely that you know the correct encoding), and pass around unicode strings.\n. Looks like it.\n. ",
    "foxx": "Fixed in the above pull request, should merge cleanly, any problems let me know.\n. Please accept my apologies, this was a mistake on my part.. I was using Django rather than Jinja2 and forgot.. doh\n. Please accept my apologies, this was a mistake on my part.. I was using Django rather than Jinja2 and forgot.. doh\n. ",
    "DasIch": "Jinja2 does not support 3.2 anymore. You need to upgrade Python or downgrade Jinja2.\n. This does not close the file, it just deletes the mod_env reference preventing the file from ever being deleted in teardown.\n. This still doesn't ensure that the file will be closed (before it is removed.)\n. The entire section could probably be deleted.\n. 3.2 and lower is not supported because we don't want to introduce these functions. \n. ",
    "yaroshevych": "Thanks, Daniel!\n. ",
    "mw44118": "This is preventing us from using jinja 2.7\n. No, I didn't apply it, but I did the exact same thing to fix the bug\nlocally, so I'm confident your patch is legit :)\nOn Wed, Jul 24, 2013 at 10:54 AM, Morris Jobke notifications@github.comwrote:\n\n@mw44118 https://github.com/mw44118 Have you tested my open pull\nrequest?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mitsuhiko/jinja2/issues/225#issuecomment-21490460\n.\n\n\nW. Matthew Wilson\nmatt@tplus1.com\nhttp://tplus1.com\n. ",
    "MorrisJobke": "@mw44118 Have you tested my open pull request?\n. ",
    "notnami": "I just realised that it has indeed not been fixed yet. I used a custom fix and forgot to check the code from the branch. Reopening.\n. ",
    "davidism": "Thanks for the interest, but I don't feel that this changes the clarity of those sections.\n. All tests pass on Windows 10 for me, for Py 3.6 and 2.7.. Please open a new issue to track this.. Please use IRC or the mailing list for this sort of discussion.\n. #129 is closed as well.  I'd rather go the route that @mitsuhiko suggests and @kblomqvist took: build the tool you need separately.  There's so much in Jinja that any official cli would either be massive or would be underpowered.  Instead, focus on the exact use case you need and build it with Jinja and Click.\n. https://github.com/pallets/jinja/issues/258#issuecomment-239675504\n. This should be on StackOverflow or IRC.\nSounds like PyPI timed out, how is that a Flask error?  Works fine for me right now.\n. Although not very clear, see the following docs:\n-    http://jinja.pocoo.org/docs/templates/#block-nesting-and-scope\n-   http://jinja.pocoo.org/docs/faq/#why-is-the-context-immutable\n-   http://jinja.pocoo.org/docs/faq/#my-macros-are-overridden-by-something\nWhile Jinja templates look somewhat like Python, their scoping rules are not the same.  {% set %} will not overwrite an outer scope.  So {{ total_qty }} is always 0 in the outside scope.\nGetting this \"bug\" is annoying, but is usually indicative of doing too much in the templates.  Move the total calculation outside of the template.\n. Well, both your examples are wrong.  The first one will read from the outer scope, which already works.  The second one doesn't define scope_test until after the loop runs, which is wrong.  What won't work is reading a variable from an outer scope that was set in an inner scope, or writing to one defined in an outer scope.\n. Fixed in #525 . http://jinja.pocoo.org/docs/dev/api/#jinja2.StrictUndefined\n. If you want to use Jinja directives, you need to use render_template.  Static files are just served, they aren't rendered.  You can of course write your own view to render \"static\" files.\nThis isn't a bug.  You should probably close this and take it to IRC, the mailing list, or Stack Overflow.\n. continued in #596 \n. The original definitely sounds wrong.  @The-Compiler's is better, but still sounds off.  Changing the subject and order sounds better:\n\nBy default the current context is passed to included templates but not to imported templates.\n. This was fixed in #389. I closed the PR linked above because the case was invalid.\n\nGiven that there haven't been any other examples of this failing, I'm closing this.. Python 3.4 is supported now, 2.8 shouldn't effect that one way or another.\n. Jinja template paths are not filesystem paths.  They just happen to mirror them in some cases.  #412 \nThe instantiation of a FileSystemLoader is unrelated to loading templates with it.  Additionally, assuming you're consistent, Python itself will do the right thing on Windows if you only use forward slash separators in file paths.\n. The second example is invalid syntax.  What made you think that was possible?\n. A conditional expression must contain an else; you've only written two thirds of the expression.\n. I would happily accept PRs that make examples work in 2 and 3. It doesn't have to be everything in one go.. http://jinja.pocoo.org/docs/dev/templates/#import-context-behavior\n. What about the other brackets? { [ <\n. This still sounds awkward.  The point of the sentence is to succinctly state what Jinja's philosophy is.  If you're going to change it, make it flow better, don't just fix the grammar.\n\nApplication logic belongs in the controller, but don't make the template designer's life difficult by restricting functionality too  much.\n. Needs a changelog entry.. Continued in #735. We should really have a common compat library for this stuff.  I know @untitaker has been talking about at least pulling contrib out of Werkzeug in the past.\n. Continued in #737. I'm having trouble merging and evaluating this. The first commit is already applied in master, and no tests fail, or appear to have been changed along with that commit.  While keeping the context during optimization seems correct, I don't know the original intention for not doing this. I cannot get Optimizer.visit_EvalContextModifier to trigger, so I don't know if this is needed. The final commit also does not appear to be necessary.\n\n@snoack if you can submit a new PR that merges and has tests, that would be appreciated.. New test doesn't fail when run on master.. Continued in #734.. Continued in #740 . Yeah, looks like this should already be caught by __debug__.\n. I don't like that this changes how template paths are split, see my comments on #558.  Template paths are not filesystem paths, they just happen to look similar.\n. @mitsuhiko checking if the callable object is a FunctionType or MethodType seems unnecessary. Removing it doesn't break any tests and allows callable C objects to mark themselves as context functions too by setting a class attribute instead of a function attribute.\nIs there a reason not to remove the isinstance(obj, _context_function_types) check?. Target doesn't really seem like the kind of thing a user would be entering for you, but ok, this seems fine.\n. Thanks, but I'd rather keep this separate from Jinja core. If you or others would find this useful, please consider starting an extension package, such as jinja-gulp-loader.. This is not a bug in Jinja or in Python.  There is no guarantee when or if __del__ will run.  Not clear why you're reporting this, since even you agree it's not a bug.\n. I agree. raw means the content will be rendered as-is.. Shouldn't the string returned use %% if it needs the symbol itself?\nJust catching TypeError will mask legitimate issues where the number of substitutions does not match the number of vars.. You should never be installing Python packages as root unless you are using the system's package manager to do it.  Use a virtualenv.  The fix here is to remove the \"omit sudo\" comment, not to add it in the commands.\n. At least with Flask, I view the fact that the templates are in a folder called \"templates\" to be signal enough, without requiring an extra extension.  PyCharm does understand the \".jinja2\" extension, but normally you just mark a directory as containing templates.\n. I'm not clear why this is needed in templates.  Just iterating over the dictionaries and using the attributes you need will accomplish the same thing.  If you need different data, it's probably a better idea to do that manipulation in Python before rendering.  I could maybe see a use for it returning tuples.\n. This is intended behavior.  The only path separator is / because template paths are not filesystem paths, although they do look similar.  Use '/'.join(path, values) to build a template path.\nThe current logic about path.sep is there to error out if the user did confuse a template path with a filesystem path.  If after splitting there are still path separators, then it's not a valid path.\n. This change would break paths working across systems, devs on Windows wouldn't be able to find templates paths written by devs on Linux.\n. It's old in the sense that it came first, not that it's deprecated or discouraged.\n. Rendering a template could produce an unsafe string, we don't know how it's going to be used after rendering.  Seems better to be explicit about it.  On the other hand, the policy from other issues seems to be that we assume the environment / templates are trusted by default, so this seems in line with that.\n. For future reference, rst uses double ticks for code, single ticks are for references.  I committed a fix for this in a few spots  around the area you edited.\n``True``\n. > If I change the parameter in my template everything works as expected.\nWhat parameter do you change?  What do you expect?  What is extensionControl?\n. > using this template:\nWhat follows is not a template.  It looks like inconsistently formatted YAML data.  Dictionaries are not ordered, if that's your question.\n. > Dictionaries are not ordered, if that's your question.\nIf you want keys in a certain order, you need to impose that order.\n. You have a dictionary of data that you're looping over.  Since dictionaries are unordered, there's no guarantee that the name key will be the first item.  In this case, it is not, it's the second.  If you want the name key first, then print it first and skip it in the loop.  This is not an issue with Jinja.\n. You can always write a listlength filter to do this, but length should behave similarly to the built-in.\n. Defining custom filters, macros, etc. is global.  Providing functions your users should use in the templates is standard practice.  Nothing needs to be done here.\n. You can do it with an extension.\n- http://jinja.pocoo.org/docs/dev/api/#low-level-api\n- http://jinja.pocoo.org/docs/dev/extensions/#writing-extensions\n- https://github.com/pallets/jinja/blob/master/ext/inlinegettext.py\nPlease use Stack Overflow or IRC for questions about your own code, the issue tracker is for Jinja issues.\n. ~~~python\nfrom jinja2 import Environment\nfrom jinja2.meta import find_undeclared_variables\ne = Environment()\ns = '{{ a }}'\nwhile True:\n    p = e.parse(s)\nif not find_undeclared_variables(p):\n    break\n\nt = e.from_string(p)\ns = t.render(a='{{ b }}', b='done')\n\nprint(s)\n~~~. http://jinja.pocoo.org/docs/dev/templates/#whitespace-control\n. The version information is for users who are upgrading from previous versions.  The current usage is most important, followed by any notable changes.  Reading through a changelog before getting to the actual docs each time is counterproductive in the vast majority of cases.\n. There should be builds for other versions of the docs, but that's not solved here, it's a matter of enabling the builds.  There is a meta issue tracking doc builds.\n. NotADirectoryError is a subclass of IOError (which is an alias for OSError) in Python 3. The correct change would be to add errno.ENOTDIR to the list of ignored errors.\nHowever, the error you linked to is due to you installing your package as an egg when the loader being used expects a filesystem. So the file does exist, but the path is invalid for the loader, in which case I wouldn't want to silence the error. All that would lead to would be getting TemplateNotFound instead, which would be even more confusing since the template definitely exists, it's just not installed in a way that can be loaded with the given configuration.. @roba91 you can test that against the latest code to find out if it's fixed. Either way, that seems like a different issue. Please make a different post if there isn't one already.\nActually, I don't think that's even an issue, did extended templates ever see included blocks in parent templates?. That's just not how strings work in Python. Escape characters are going to escape things.. @NormanDenayer thanks for checking this. @GitProBo if you're still having this issue, please post a minimal example that reproduces it.\n. As you've already done, please use Stack Overflow for questions about your own code.  This tracker is for issues with Jinja's code.  While I agree whitespace control can get confusing when precise output matters, it's not a bug in Jinja.\n. It's no longer testing what it was testing before. All tests pass locally for me as well as on Travis, so this is an issue with your specific setup that you'll need to debug.. http://stackoverflow.com/questions/30362950/is-it-possible-to-use-angular-with-the-jinja2-template-engine\n. After #618, the example already fails, removing this doesn't change anything. However, since it seems redundant, I'll still remove it and add a test.. Why not make with context always send the local context?\nI'm hesitant to add more \"obscure\" syntax, I'd at least be better using with local context instead, if we need separate behaviors.\nDoes this address #596?\n. I'll wait to hear from any other maintainers, but I'm ok with just passing local context, especially if the existing tests pass.\n. Thanks for the pr, but I agree, adding this to your own app is straightforward. Install inflection, add relevant function to filters.\n. I can't reproduce your issue.  Please include a test that demonstrates the issue.\n. Please see http://stackoverflow.com/q/1373164/400617.. All that should be required is modifying jinja2.tests.TESTS, which is used by the jinjatests directive, which you did. If rebuilding the docs doesn't render the new sections, then try wiping the docs/_build directory to do a clean build.. So the docs are building correctly for you?. Please include a self-contained example that produces this error.. Maybe previous_context just holds the entire previous context, rather than trying to decide what the users will do with it.. Or maybe an explicit statement for writing outside scope: set_outer or something.. Yeah, figured that would be the case. I'm anticipating \"what if I want to know if the current value is greater than the previous\", or something similar. But I like the changed method too.. @mitsuhiko and that sort of pattern is already in use with the do tag: http://stackoverflow.com/a/4880398/400617. I completely agree, just pointing out that it's out there. And like Alex pointed out, a lot of these problems can be rewritten, either with filters or by putting some of the logic in Python.. @pujan14\n{{ names|map(attribute=\"last\")|select|unique }}\nAlthough since unique isn't a built-in filter, you could always just add another filter that does the whole thing, since you're already adding the unique filter.. Jinja already enumerates the loop. {{ loop.index0 }}. Write a filter that yields devnum, sensor tuples exactly the way you need them. Or calculate it in Python and pass it to the template. Or use the example below. This goes for every other example I've seen.. @pujan14 @aabdnn @Molodax did this pattern come from official Ansible documentation, or is it something you came up with or found elsewhere? Either way, it might be easier to report this to Ansible, since they understand how their product should be used and could possibly come up with more relevant solutions.. If it's not officially documented then I'm more inclined to close this as it was originally. I'll reiterate that Ansible may be able to help you more in this regard.. What about adding set(key, value) and get(key) methods to the loop object? Then people can store whatever they want across the loop.. Seems fine to me, it's the same solution as nonlocal for Py 2. Alternatively, automatically set up loop.ns, although that wouldn't be available outside the loop.. As has been demonstrated to varying degrees above, you might not even need to do what you're doing. Otherwise, yes, you need to wait if you want to use 2.9. It was never supported before, it just happened to work.. We will not be reverting to the old behavior. While it worked in simple cases, it was not correct and was never documented as supported. While I understand that it is a breaking change, it occurred in a feature release (second number change) which is how we've always managed these changes. Pin the version until a fix is released if you need to keep relying on the old behavior.\nLocking this because everything that needs to be said has been said. See #676 and #684 for the fixes that are currently being considered.. Please include a self-contained example that reproduces the issue.. If there's an advantage to using namedtuple over a basic tuple subclass, and the repr is what causes the issue, we could just fix the repr.\n~~~python\nclass _GroupTuple(namedtuple('_GTBase', 'key value')):\n    slots = ()\ndef __repr__(self):\n    return super(self.__class__, self).__repr__()\n\n__str__ = __repr__\n\n~~~. You can force push, or we can squash, whatever you're comfortable with.. @ThiefMaster I thought it was a bit weird too, but I figured people would get confused by the inconsistency between is and select otherwise. The docs already call out equalto as being useless in is.\nSince there was no expectation before that symbols could be used, we could just document them as a special case in the select docs, rather than in the general test docs.\nOr we could still allow them in both locations, but only document them in select. I can open a PyCharm issue for the syntax, although we both know it could take a while to get in.. Going to take out the is <= support, since I agree it looks weird. Here's the patch if we decide we need this later.\ndiff\ndiff --git a/jinja2/parser.py b/jinja2/parser.py\nindex 6d1fff6a..8741520a 100644\n--- a/jinja2/parser.py\n+++ b/jinja2/parser.py\n@@ -825,10 +825,19 @@ def parse_test(self, node):\n             negated = True\n         else:\n             negated = False\n-        name = self.stream.expect('name').value\n-        while self.stream.current.type == 'dot':\n-            next(self.stream)\n-            name += '.' + self.stream.expect('name').value\n+\n+        # If the next token is a comparison operator, treat it as a name.\n+        # This allows using the operator symbols in the select filter without\n+        # breaking unexpectedly when used in a test node.\n+        if self.stream.current.type in _compare_operators:\n+            name = next(self.stream).value\n+        else:\n+            name = self.stream.expect('name').value\n+\n+            while self.stream.current.type == 'dot':\n+                next(self.stream)\n+                name += '.' + self.stream.expect('name').value\n+\n         dyn_args = dyn_kwargs = None\n         kwargs = []\n         if self.stream.current.type == 'lparen':. Solved more by #731.. Would it be useful to support something like name,-id to mean \"name ascending, id descending\"? Otherwise you'd still have to chain sorts if the directions were different.. Thanks for getting this started. I rebased and fixed your email on your commits. I ended up rewriting the tests to try to match how the cache was actually used, since it was hard to figure out what parts of the code the initial tests were hitting.. This should still go in even if we go ahead with the namespace idea too. It's a simpler solution to probably the majority of cases. The two aren't mutually exclusive.. I'm fine with that. Can we just release 2.10 now? Not sure if there was anything else planned.. {{ google_analytics() }}. @untitaker I'm learning as I go too :-) but everything here seems fine.\n@ThiefMaster given that @mitsuhiko suggested this in the first place, I think it's ok to merge. Same with #676.. The release will happen when we have time. Sorry we can't be more specific than that, the maintainers do not have a lot of free time. As a workaround, you can do essentially the same thing as here by injecting a custom object with a function to set attributes.. You can always write your own truncate and replace the filter.. I'd like to get #665 cleaned up and merged so that we can show < and == (or lt and eq) instead of the long names. But I do like this overall, so I'll merge it now.. The version should be 2.10.dev on master, 2.9.7.dev on 2.9-maintenance.. #469. You're describing a pretty specialized case, I'd just do what Thief suggested or what you're doing.\nWe could move the import and regex generation into the Lexer, then allow overriding the regex with an Environment attr used in get_lexer, but I'm not really sure it's worth the effort and added complexity.\nSomething like:\n~~~python\nLexer.init\nif environment.name_pattern is None:\n    if Lexer._name_re is None:\n        from jinja2._stringdefs import ...\n        name_re = Lexer._name_re = ...\n    else:\n        name_re = Lexer._name_re\nelse:\n    name_re = re.compile(name_pattern)\n~~~. Should be solved by #731.. It took me a while to figure out what this was actually doing. Definitely needs some docs, but looks interesting.\nThe term \"native\" is a bit confusing, since I also associate it with discussion about what Python's str is in 2 vs 3.\nHow is Ansible using this? That is, when do users need access to the results of a render and don't have access to the original objects instead?\nDoes this need to be in Jinja, as opposed to a separate package providing a different Environment? Admittedly, there would be a little code duplication since the native checks happen in the middle of a couple methods. It just seems so radically different than what Jinja usually does.. Possible concat implementation:\n~~~python\ndef concat(nodes):\n    head = list(islice(nodes, 2))\nif not head:\n    return None\n\nif len(head) == 1:\n    out = head[0]\nelse:\n    out = u''.join([text_type(v) for v in nodes])\n\ntry:\n    return literal_eval(out)\nexcept (ValueError, SyntaxError, MemoryError):  # possibly RecursionError\n    return out\n\n~~~\n. chain(head, nodes) fixes that.. Needs documentation and changelog. Can be moved to a separate module, like the sandboxed env.\nI still think this needs a clearer name than just \"native\". TypedOutputEnvironment? NativeTypeEnv? PythonTypeEnv? Something else? Or not?. All of it.. Install sphinx, cd to docs, make html, open _build/html/index.html. Don't worry if the theme doesn't look the same. See docs/sandbox.rst as a possible template for your docs.. I'm still hesitant to add this to Jinja. It's such a standalone thing that it would make sense as a Jinja-NativeEnv package.\nOur philosophy is to avoid adding more features unless they're absolutely necessary, since we have limited resources and want to keep the packages focused on one obvious use case. \"Render to Python types\" is not an obvious use case, given the features in the rest of the library.\nWill you be willing to monitor this repository and keep this feature in sync with the rest of the code? Is there a plan within Ansible to provide maintenance for this?\n@untitaker @ThiefMaster can you help make a decision about this?. Thief re-commented some of my earlier review comments. It looks like a lot of them got dismissed when you pushed a big change that didn't actually address all of them. Most are minor, would you go through and review them again.. You're still missing a lot of mine, un-collapse the review I did here: https://github.com/pallets/jinja/pull/708#pullrequestreview-36381167.. Did some more cleanup and docs, squashed, rebased against current master. You'll need to drop your local branch, fetch from your remote, and checkout a new copy of the branch.. Cool thing that we should add an example for: you can combine SandboxedEnvironment and NativeEnvironment.\n```python\nclass SandboxedNativeEnvironment(SandboxedEnvironment, NativeEnvironment):\n    pass\nenv = SandboxedNativeEnvironment()\nenv.from_string('{{ x.init(2) }}').render(x=Magic(1))\nraises SecurityError\n```. This error happens with constants in the template but not with objects passed in.\npython\nenv = NativeEnvironment()\nenv.from_string('{{ x.__class__ }}').render(x=True)\nenv.from_string('{{ true.__class__ }}').render()  # raises SyntaxError\npytb\nTraceback (most recent call last):\n  File \"/home/david/Projects/jinja/example.py\", line 16, in <module>\n    print(env.from_string('{{ True.__class__ }}').render(x=Magic(1)))\n  File \"/home/david/Projects/jinja/jinja2/environment.py\", line 880, in from_string\n    return cls.from_code(self, self.compile(source), globals, None)\n  File \"/home/david/Projects/jinja/jinja2/environment.py\", line 588, in compile\n    return self._compile(source, filename)\n  File \"/home/david/Projects/jinja/jinja2/environment.py\", line 551, in _compile\n    return compile(source, filename, 'exec')\n  File \"<template>\", line 10\n    yield <class 'bool'>\n          ^\nSyntaxError: invalid syntax. I couldn't reproduce it in a basic Environment, so something about NativeEnvironment changed that. I did notice a few places that use repr(concat()) in visit_Output and were changed to use native_concat, that's probably where to start looking.. @jctanner I'd like to make this part of the next release if possible. Will you have time to finish this?\nPing @mitsuhiko.. If you have the time, it would definitely be appreciated, as I don't think maintainers will be able to get to that any time soon. But it's not required for this PR.\nAs I commented earlier, it might be good to look at the places you replaced concat with native_concat, as it was after that change that I noticed the issue.. It's been a while (sorry!) and there was some confusion over what we were waiting on here. https://botbot.me/freenode/pocoo/2017-10-31/?msg=92959650&page=3 Our conclusion was that adding has_safe_repr there was appropriate and fixed the issue I came up with.. @jctanner I just released Jinja 2.10 with this included. I tried to ping you on Twitter but couldn't find your username. \ud83d\ude04 . This seems like an easy fix, if you'd like to submit a pull request.. Don't worry, it's not that bad! Adding Markup around it, then making sure the existing test doesn't escape something since it should be safe now, should be fine.. It was also introduced very recently in 2.9, so it feels ok to fix this to match the documented behavior in 2.9-maintenance.. * I don't find - difficult to read.\n What blank lines are not \"solved\" by it?\n What cases is it worse?\n* What are \"all cases\"? How would they be \"properly\" handled?\nThis issue is too broad and vague. If you have specific issues, open issues about them with specific examples.. The loader API doesn't take a context, that's part of the render process after you already have a template.\nYou can already pass a template object or path to extends with a variable.\n{% extends other_template %}. I don't understand what you mean. You can name variables whatever you want, independent of the strings they hold or other values in the template. Import can take variables just like extends.. There is something wrong with your MarkupSafe install.. I don't use vim. If you want this fixed, you're going to need to contribute a patch.. Looks like you forgot to configure your name and email in git. Do you want to re-commit?. `map('replace', 'a', some_var)`, you don't use Jinja expression syntax when you're already in an expression, you use the variable directly.. Yes, the rounding behavior was changed in Python 3. https://stackoverflow.com/questions/10825926/python-3-x-rounding-behavior. The filter just passes to the Python function.. This had come up a few times. I wonder if there's a better way to validate names?. ping @mitsuhiko. I'm not very familiar with this code, I'd need to review when I have more time. I'm not sure exactly where this is used, but if it's really just for validating names, maybe something in the standard library can validate names. Assuming we follow the same naming rules in Jinja. For example:\n\npython\ntry:\n    compile(\n        source='{name} = 1'.format(name=name),\n        filename='<input>',\n        mode='single'\n    )\nexcept SyntaxError:\n    # not a valid name\nNot 100% sure about 'single' there, or if parser would/should work instead. . ~Need to also check not keyword.iskeyword(value) to catch things like True and class which str.isidentifier returns true for.~\nOr maybe not, since they'll raise SyntaxError later if used improperly.. env.from_string('{{ \u212e }}') (or any of the four special case characters) raises TemplateSyntaxError: unexpected char '\u212e' at 3. Other Unicode characters work as expected.. Pushed a simple test, currently fails for the four special case characters.. The regex is specifically failing on the \\b boundaries, if they are removed the special cases work. This is because \\b means \"transition from \\w to \\W\", and the special cases are not in \\w.. Just checked, e.from_string('{{ \u212e }}') works on master.. I don't think the \\b is necessary, it's not present in the previous stringdef regex. All tests still pass with the boundaries removed.\nThere were boundaries on the Python 2 regex, but they don't seem necessary either.. I reported the \\w issue to Python: http://bugs.python.org/issue30838\n@lf- thanks for helping figure this out.. Writing more tests based on the previous stringdef, https://raw.githubusercontent.com/pallets/jinja/2.9.5/jinja2/_stringdefs.py, turns up some invalid characters in the previous regex. The following start characters were matched but were not valid as start or continue characters:\n\\u309B KATAKANA-HIRAGANA VOICED SOUND MARK\n\\u309C KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK\nThe following were matched and are valid continue characters, but are no longer matched by \\w:\n\\u309B MIDDLE DOT\n\\u309C GREEK ANO TELEIA. Then I realized we were missing a test in that script: ('a' + c).isidentifier() for characters that are valid for continue but not start. That reveals a lot more that aren't matched by \\w.\n2097 characters not matched. \ud83d\ude1e . Going to have to bring back _stringdefs, but still simplified.. Original _stringdefs:\nlen   sizeof\nstart    48194 96462\ncontinue 49826 99726\ntotal    98020 196188\nNew _identifier:\nlen: 635\nsizeof: 2616\nTiming is hard to test, but on my machine re.purge(); re.compile(...) is down from ~100 ms to ~840 \u00b5s.\nStrategy was to collapse contiguous ranges and rely on str.isidentifier to validate so that the regex is simpler.. At the cost of about twice as much space, the regex could be made more accurate by omitting \\w and generating the full range of valid characters. At the cost of twice again as much space, we could remove the need for calling str.isidentifer during lexing by distinguishing start and continue characters in the regex. For now, I'm happy with where we are and will leave \\w and isidentifier in.. Specifically with branch coverage, without --branch it passes.. This test probably belongs in MarkupSafe, not Jinja, but should still be fixed.. Related to #384 . @mitsuhiko thanks, just wanted to check that there weren't any obvious problems or design reasons before going forward.. ~#737 makes the order attribute, case_sensitive for unique, min, and max, but we can change it back if we decide that's what we want.~. Not going to change sort or dictsort, just talking about new filters. Mostly concerned with consistency: if sort is one way and unique is the other, people may be confused.. Yeah, being consistent is probably a better idea here. I'll change the examples to use kwargs consistently too.. Fixed by #734 by making random a context filter. If I have time I'll go back and figure out what changed between 2.8 and 2.9.. Jinja templates are not necessarily files. We can't use the file path because some templates do not have file paths. That's an implementation detail of the individual loaders.. Clear the cache if you want to modify what's available to ChoiceLoader after loading a template.\nIf I'm understanding your description, it would be better to adjust your app to fully enumerate the path while registering blueprints, before any rendering happens. It sounds like right now you're only loading paths on demand, which isn't really going to get you anything.. Duplicate of #298 #153 . Please paste code, not pictures of code.. env = Environment(cache_size=0) or env.cache = None. I don't find the changes here compelling. If other projects want a _compat that passes Flask8, but want to copy this one, they can do that however they desire after the copy.. We would be happy to fix this. Unfortunately, we maintain this as volunteers with limited free time. We rely on the community to contribute analysis and patches to fill in when we can't. If you are affected by this and are interested in fixing it, please submit a PR.. related to #749\nrelated to #750. I agree, thanks for investigating. I don't think it was ever stated that + can be used at the end of a tag.. The Stack Overflow tag is \"jinja2\", \"jinja\" is a synonym that gets invisbly converted. Despite my efforts towards the opposite. (This happened a year or so ago.)\nI really want to drop the \"2\" from the name. Start adding v2 builds to the \"jinja\" PyPI page. Deprecate the \"jinja2\" import and go back to the \"jinja\" namespace.. From your traceback, tpl = Template(content), content is not a string or Template instance. The intro code you linked works fine.. I can't reproduce your issue on Python 3.\nIn Python 3, the string type is string, the bytes type is bytes. Jinja handles this already.. All supported Python 3 versions: 3.3 - 3.6.. Is there something stopping you from implementing such an environment with the existing classes and methods?. This had been discussed multiple times. I'm on my phone, so can't link right now. Our stance is that if a build tool fails on files that won't be imported on unsupported versions, it's the build tool that needs to be fixed.. If this affects you and you can track it down, it would be helpful to see a patch or at least where the behavior is happening. I can't really say if it's intended or not without that, and I'd have to dig through the code myself to see.. Yes, you need to look at the parser/compiler, not the template code. You can ask Jinja to render the Python module instead of the final output and see what's going on.. I can't reproduce your issue. Regardless, this would be an issue with pip, not Jinja. The solution is completely incorrect, taking ownership of system directories is never the right answer.. There's already an option on the environment for this.. c3147611ec6bbfd8b6e42637c73a68e29de1e2e7. Thanks for  looking into this @snordhausen.. This is clever, but it seems way too easy for people to shoot themselves in the foot with it. I'm sure people would take advantage of a jinja-import-loader if you released this separately. It doesn't look like there's anything here that would benefit from being in core.. Yeah, I need to read better. :-). python\nimport operator\napp.add_template_global(operator.and_)\napp.add_template_global(operator.or_). Would you like to fix your commit so it correctly associates with your account? You've used an email that's not associated with your account.. Why did you close this?. Duplicate of #441 . Did you mean to include your other PR in this PR? I don't want to deal with merge conflicts.. You can git rebase -i master then git push -f to clean it up.. I don't think any version of pip that supports python_requires supports 2.6, so you can remove that. Not sure if it supports 3.3, but might as well drop that too since we're going to do that anyway. Can always use --ignore-requires-python if there's an issue.. It would be interesting to support syntax like {% debug html-table %} to produce a table when you know you're in an HTML template.. That's the other thing I was thinking. Using a tag means you can't access the data directly, unless you were to turn it into a block tag like call.. I'd like to hear from @mitsuhiko or @ThiefMaster before merging.\nIn order to use it, you need to know about and enable the extension first, add a tag, and you only get a squashed, non-interactive representation that isn't JSON compatible.\nThere are already things like Flask-DebugToolbar. The user can also set a breakpoint in a debugger and look at the context directly:\n\n. JSON uses double quotes around strings. Values that aren't JSON types should be converted to string (this is not trivial).\nInteractive as in I can access it as a varaible and render it how I want.\nPyCharm says it supports debugging Jinja templates, so if that isn't the case it needs to be reported to PyCharm. Are you sure you selected \"Jinja2\" for the template language in the project? Are you sure that the file is detected as a Jinja template (it can be changed in the file association settings)?. Thanks! I'm not sure exactly when I can make a new release, but let me know if Ansible's timeline is affected by this.. Good catch, thanks.. I don't recall there ever being a favicon for Jinja.. Thanks, but this doesn't seem to improve what's being said, it just moves it around.. http://jinja.pocoo.org/docs/dev/api/#jinja2.meta.find_undeclared_variables. Something got messed up here. You changed the base on GitHub, but you also need to rebase your commits onto that base too, then force push. Or make a new branch and a new PR, might be easier.. You're still pulling in all the commits from the master branch.. Thanks for looking, but we don't plan on expanding the tools we use right now.. Would you add a changelog entry for this?. All of this seems very specific to Ansible. I've never had to do these sorts of type checks in templates, or in most Python code in general. Maybe the issue with inconsistent data that users have to check is something that needs to be addressed by Ansible?. For the boolean, why can't {% if value %} and {% if not value %} be used? In what case do we need to know that it's specifically a boolean, and not just expect to get a boolean for that value?\nFor \"sequence not string\", you can already do this with {% if value is sequence and value is not string %}. If you expect either a string or an iterable, which seems like the most common case, then you can just swap the statement and use\n```\n{% if value is string %}\n  it's one thing\n{% else %}\n  it's many things\n{% endif %}\nor\n{% if value is string %}{% set value = [value] %}{% endif %}\n{% for item in value %}one code path{% endfor %}\n```\nFor int vs float as opposed to \"number\", why does it matter at the template level what type these are? If you absolutely need one or the other, then use |int, |float, or |round.. Testing against strings sounds really error-prone.. If you really want to test based on strings, you can already do that with value.__class__.__name__, or an application can add a test for that. But it's not something I'm willing to add to Jinja.\nThis whole thing seems like something that should not have to be done in templates, but the problem is that there are already some type tests so it's not clear what was intended and if it's ok to keep piling more in.. I'm not saying your use case isn't important, I'm trying to understand where this belongs and why users are trying to do these things in the first place.\nAnd if we add these, why not every type in builtins and every abc in collections? And what about user-provided types? Maybe there's a better solution to checking types instead of adding individual tests for each?. I'm still interested in exploring the last question I asked:\n\nMaybe there's a better solution to checking types instead of adding individual tests for each:\n\nIf we merge this as-is, rather than exploring that, we still need to decide on a name for the list test. I'm thinking it might be easier to add a string=False parameter to the sequence test rather than using imprecise or too-long names. Might make sense to deprecate the current behavior and transition to that as the default, since I think it's what people usually intend with sequence.\nWe should also consider @abadger's point about whether we want to test iterable vs sequence.. I'm fine with it except for the list test, which I'm not completely satisfied with since it doesn't describe the actual test and might cause issues if someone actually wants to test for lists. I haven't done anything with it because I'm currently working on Werkzeug and Flask. Plus one and bump comments just get minimized or deleted though, they're noise.. I mean, I think such a test makes sense, I just want a good name. It's not hijacking the PR, since I'm not planning to merge it right this moment anyway. But we can leave it for another time, that's fine too.. Thanks for looking into this!. Wait, what comment did I delete? GitHub's being weird, my review was at the same time as you pushed another commit.. OK, for some reason GitHub keeps hiding my reviews, so I'm putting this in a comment instead.\nYou've introduced a security issue. Your code unescapes the input then marks it safe, so Jinja will not escape it later. So if I do {{ user_input|indent }} and the user passes <script injection>, now indent undoes any existing escaping and prevents further escaping, thus passing through the injection.. Those aren't valid variable names. Seems reasonable that Jinja fails with a syntax error in that case.. No, you're writing Python identifiers. You can't escape them in Python, you can't escape them in Jinja.. Please use Stack Overflow for questions about your own code. This tracker is for issues related to the project itself. Be sure to include a minimal, complete, and verifiable example.. Looks fine, but needs a test. In what circumstances is _debug_info empty?. See Jinja's documentation on for loops for an explanation and what to do instead.. Try removing cache_folder and starting from a fresh cache.. Thanks. I did this for Flask, but all the other Pallets projects still need to be updated.. Pass keep_trailing_newline=True to the Environment: http://jinja.pocoo.org/docs/api/#jinja2.Environment. This is due to some Sphinx processing that Click adds to its docs. It's picking up the wrong alias / docs for the main name, so it doesn't render the docstring. That's where to start looking.. I think what I should have done is added some versionchanged directives to that section in the page. Would that be enough for your use case?. If the new pallets-sphinx-themes doesn't handle table spacing correctly, it should be easy to fix there. I do like how the layout is used in the Python docs, I agree that it should be automated though.. I'm going to merge this, but it's likely to get removed eventually. I'm working on improving the directives in pallets-sphinx-themes.. list is a filter, not a function. Python buultins are not generally added to the context by default.. Template paths are not filesystem paths. They just happen to seem like that when using the filesystem loader.\nAs a more general note, Python supports / as a separator on Windows, so there's usually no reason to use Windows path separators.. Thanks, I'm not sure when I can get to this, but letting you know I've seen it.. It's just Python indexing, there's no special documentation regarding it for Jinja.. Please include a minimal example in the issue itself. Also, please try to include more of a description, as I'm having a hard time figuring out what the issue is.. I would highly recommend upgrading to Python 3.. Drop 2.6 as well.. PRs for this: #871, #874, #876. Please push new commits rather than new PRs for every review.\nHowever, I don't think we should be converting anything to string. We don't do anything with the paths that requires them to be a string. Python functions already know how to use Path and we're just passing on to them.\nThe original issue was that Path is not string_types, so the loader was incorrectly calling str on it. The solution should be to fix the isinstance check to check that it's not an iterable.. Moved to #873. Most likely False, is being interpreted as a 1-tuple. Tuples of length > 0 are considered True. This doesn't look like a syntax error, just a logic error.. Jinja syntax is close to, but not exactly, Python. There are no colons in block statements in Jinja, so this seems acceptable.\nIf you'd like to investigate a PR for this, I can at least review it, but my assessment boils down to \"this type of error could have happened anywhere else in Python with similar consequences.\" For example:\n```python\nvalue = False,\nif False or value:\n```. It would be cool to see a linter/formatter for Jinja. Looks like there's an experimental one called jinjalint, maybe it's a good place to start.. You're using a defaultdict. All keys exist as soon as they're accessed.. Thanks for working on this. I'm not willing to take on the extra complexity of this. If this is a loader you need, it should be implemented in your code.. Please use Stack Overflow for questions about your own code. This tracker is for issues related to the project itself. Be sure to include a minimal, complete, and verifiable example.. This appears to be an issue with the data, not with Jinja. The list of cities appears to be empty for an item, but you're unconditionally trying to access the first item.\nPlease use Stack Overflow for questions about your own code. This tracker is for issues related to the project itself. Be sure to include a minimal, complete, and verifiable example. (What you've shown here is not enough to fully answer the issue.). You haven't provided a template that demonstrates the issue, nor the error message that's inaccurate, so there's not much we can do here.\nPlease use Stack Overflow for questions about your own code. This tracker is for issues related to the project itself. Be sure to include a minimal, complete, and verifiable example.. Glad you figured out your issue.\nNone of the tools you referred to are official projects. You should take issues with those tools to those authors.. Python 3 is fully supported and has been for years, along with the rest of the Pallets projects. The docs are out of date because I forget that these sections exist. Submit a PR that removes all mentions of Python 3 support being experimental / causing problems and I'd be happy to review.. Not easily, but I guess this will resolve itself once I get Jinja on RTD (just did Click recently). Thanks for finding the duplicate.. Is there a reason beyond \"users could technically filter by them in PyPI\" to use these? I don't use them in any other projects, in Pallets or otherwise.\nBasically, we're not going out of our way to make this a \"cpython library\" or a \"pypy library\", besides maybe a small compat entry here or there. So they don't really seem appropriate.. Pluralization is a hard, locale-dependent problem. There are existing libraries for it, pick one that works for you and add it as a filter. Creating another implementation that we have to maintain would be redundant.. It's hard to tell what you're trying to describe, but it sounds like you're using set in some parent template, then passing the same names to render. But the context passed in is overridden by anything that happens in the template.\nInstead, what you probably want is something like Flask's render_template(template, **context) function, where you register context processors with @app.context_processor to inject defaults, which are overriden by the actual values passed to render.\nPlease use Stack Overflow for questions about your own code. This tracker is for issues related to the project itself. Be sure to include a minimal, complete, and verifiable example.. Fairly sure this is intentional. last would have to convert generators to a list first, which may be dangerous (infinite stream, user intentionally doesn't want to hold everything in memory, etc.).\nTo explicitly accept this risk, convert it to a list manually: qqq | selectattr(...) | list | last. It only has to take the first element, it doesn't need to make any assumptions about the full size of the iterable.. This could be mentioned in the docs, something like:\n\nIf the iterable is a generator, it must be explicitly converted to a list to get the last element. For example, when using selectattr:\ndata | selectattr('name', '==', 'Jinja') | list | last`\n\nOtherwise you'll get the error \"generator object is not reversible\".\n\nMarking this as beginner friendly if you'd like to make PR.. Not sure what the cause is, but this will be addressed as part of larger docs changes being worked on.. See comment on linked issue, this will be addressed as I switch to pallets-sphinx-themes.. The semantics of this are really hard for me to keep straight. What the filter actually produces depends on the filter it's flipping. Would you add a few more examples to demonstrate different uses of this?. Thanks, that's helpful, but I meant add some more short examples to the docs like the one that's there already. I should have been more specific.. if else can already be used inline like in Python: {{ \"disable\" if vlan_entry.stp_disable else \"enable\" }}. I'm not clear why you need this. Don't enable buffering, that's equivalent to buffering one item, except without the overhead of the buffering method.. Iterating over TemplateStream yields one rendered Jinja node at a time by default, buffering is for when you want to yield more than one item. It's not clear why you call enable_buffering if you don't want to use buffering.. @seaders seems reasonable.\nAs with a lot of things in Jinja, I don't know if there's a design reason the map filter doesn't already handle callables. Maybe @mitsuhiko can comment.\nQuick look at jinja2.filters.do_map(), uses context.environment.call_filter(). Might be able to detect if the first argument is a callable instead of a string, and use context.call() to invoke it.\n@flexferrum is there a particular reason you went with a new filter instead of extending the map filter?. Since this deals with callable objects, you also need to update asyncfilters with an async variant.. Thanks for working on this!\n\nI've no experience with asyncfilters\n\nYou now have more experience than I do. :wink: . Jinja only supports decimal notation. The lexer would need to be updated to recognize scientific and other notations. I'm not sure the added complexity is necessary for templates. Is there a specific reason you need this?. That seems like processing that should be done in Python, passing the data to render.. That's not a string, that's a dict. A string would be surrounded by quotes. Remember, the native environment is parsing what it sees as Python literals. Right now you've done the equivalent of writing {\"foo\": \"bar\"} in a Python file, but serialized JSON looks like:\npython\nimport json\ndata = {\"foo\": \"bar\"}\nprint(json.dumps(data))\n'{\"foo\": \"bar\"}'\nSo you would write e.from_string('\\'{\"foo\": \"bar\"}\\'') if you wanted to output string that contained serialized JSON data.. Please add a test that would fail with the previous version to show how this fixes the issue.. You'll need to add a test before I can merge this.. You're right, the rest of the code refers to token.lineno. I thought this was a bigger change since it affected the parser.. There's now no way to trim leading newlines, unless I'm missing that you can combine * and -.. Going to close for the same reasons stated in #602.\nYour comment in #399 indicated you were bundling something a pex file, which sounds exactly like bundling it in an egg file. If you want a Flask app to run from a single archive, you need to configure its Jinja loader appropriately.. We could support the underscore syntax for any version by removing them before calling literal_eval. Seems reasonable enough to do that.. I'll get to this eventually! I'm just focused on Werkzeug right now. :-). The super object has a super attribute which points at the next block up the context. Turns out the docs only mention that you can call super(), not that you can access super.super. Would you be willing to submit a PR to document that?. Thanks! We should probably be advising people to use CSS white-space: pre-line; instead, but we can still fix the filter.. What's the difference between \"pypy3.5-6.0\" and \"pypy3\" on Travis? I've just been using \"pypy3\".. I tried to do dist: xenial globally for Werkzeug a month ago and it didn't work. Guess something changed.. Cool! I need to follow Travis announcements more closely. All the other Pallets projects need updating if you feel like making more PRs.. Duplicate of #823. I do not use the package loader, so I'm not very familiar with the setuptools resource API. What should be used instead? I'm happy to review a PR.. The status of your PR is that it's still open. You'll know when the status changes because you'll get a notification about it. Sorry I can't be more specific, but there's only so much time I can devote as a maintainer, and I'm currently focused on Werkzeug, not Jinja.. The user who created that repo and CVE doesn't know what they're talking about, and unfortunately now we're going to have to keep addressing it since they irresponsibly notified a bunch of people about a non-issue in an official sounding way. See https://github.com/JameelNabbo/Jinja2-Code-execution/issues/1 for a response to them. I've sent in a request to MITRE to have the CVE invalidated.\nSaying Jina has a vulnerability because from_string exists is like saying every dynamic language is vulnerable because eval exists, or every SQL library is vulnerable because they evaluate SQL strings. The issue isn't with those libraries, which all provide proper tools for handling user input. A SQL library doesn't have an injection vulnerability, a project using a SQL library improperly does.\nSandboxedEnvironment should be used if you still want to risk compiling untrusted templates, and autoescape should be used when rendering untrusted variables.. Related to #811, a similar thing needs to be fixed for DebugUndefined.. Sorry, but we'll leave this as-is unless there is an extremely good reason to change the default. When writing a project with Jinja, please use settings appropriate to the output you're trying to produce.. No, you'll need to write those if you need them. All the center filter does is call value.center(width) though, so it's probably more straightforward to call value.ljust(width) or value.rjust(width) rather than writing more filters.. 3.8 isn't released for another year. There will be another release before then.. You can configure your test runner to ignore specific warnings that you know upstream will handle. We do it in Werkzeug, for example.. > please consider changing it in the documentation because it's confusing\nI'm happy to review a PR that makes the docs clearer for you.. I'm sorry, I meant \"I'd be happy to review a PR if someone submitted one.\" Since you probably have a good idea of what's confusing to you, it would be great if you submitted a rewording that is clearer to you.. Your code isn't valid, you should pass keywords to render, not a loaded yaml document.. Please use Stack Overflow for questions about your own code. This tracker is for issues related to the project itself. Be sure to include a minimal, complete, and verifiable example.. It's an interesting idea, but not one that I think belongs in Jinja core. Perhaps you could do this with an extension, but I personally would do this in Python.. The second part of your request, outputting blocks to variables with filters, is already handled by set blocks. Yes, it's feasible. Some combination of the issues you linked would be needed. Closing this as a duplicate of those.. \"bugs with Jinja's code\" and \"for questions about your own code\" might be clearer. Possibly link to SO's MCVE page.. I think this was supposed to be if PY2.. And then this should have a corresponding __unicode__ = __str__ in an else.. I renamed the functions for consistency with Python's names. These three names already existed, so I kept the aliases, even though I couldn't find any direct use of them with GitHub search.. Similarly, I kept the long names for the three tests that already existed, in addition to the operator and short names.. I could make them functions that raise deprecation warnings, but I'm not that concerned. I'll just add a comment to the source.. They weren't. I was considering just removing them, since it's an obvious failure and fix in the off chance someone is actually importing them.. \"is check\" instead of \"is checking\". This adds a trailing newline if there is only one line, unlike indentblanklines=True.. This removes leading and trailing blank lines, unlike indentblanklines=True.. Let's split each case into separate renders rather than separating them with |.. This doesn't cover indent(2, False, True) or indent(2, True, False).. I know @ThiefMaster said it's consistent with indentfirst, but I'd rather just break consistency and use the easier to read indent_blank_lines.. If you want to, also change the signature to do_indent, s, width=4, indent_first=False, indent_blank_lines=False, indentfirst=None) and raise a deprecation warning if indentfirst is not None. Not required though, I can follow up with this after merging.. sort and dictsort use the name case_sensitive.. This should yield item instead of building the full list ahead of time.. Should use pytest.raises.. This will always be True because of the previous line.. Implicit encoding seems dangerous, should use text_type(x, 'utf8') here.. Why do you convert multiple nodes to a string? Wouldn't you want to return the list?. Never mind, I messed up the review for this one. Should use text_type, which is what runtime.to_string is. But don't specify an encoding, since that's only relevant if the object is bytes. Should remove the except Exception block.. Should this be return None? An empty list doesn't make much sense.. I don't like building this list, seems wasteful of memory, although I guess there shouldn't be many nodes for the use case you're solving. Could change this to head = list(islice(invals, 2)) to test the length, then either return head[0] or build a list from invals in join.. Also need a test case for this path.. text_type not unicode. Or just make this a completely separate NativeEnvironment, rather than an option on the base environment.. Yes, I think that would be more clear.. \"Jinja\", without 2, capitalized.. Use double quotes, remove blank first line, for all docstrings..     to_string(). :class:CodeGenerator (linked appropriately).     to_string().     :meth:~jinja2.Enironment.render\n(or whatever the docs link is). \"Python\", capitalized.     from the base :meth:~jinja2.Environment.\n(or whatever the docs link is). This docstring can be clearer about what this function actually does.. If native_concat isn't a documented api, don't mention it in public docs.. Needs to describe what the use case is in more detail. A good start:\n\nThe default Environment renders to a string. With NativeEnvironment, the result of render is a Python type if the result is a single node or can be interpreted as a Python literal. This is useful, for example in Ansible (link to Ansible docs about this), as an intermediate step where the user can use templates to generate variables, which are later passed to a regular template.\n\nDescribe the problem that this solves so that users know if they should use it.. Obsolete comment?. Obsolete comment?. Remove header and encoding.. Clean up unused imports.. TestNativeEnvironment. This makes more sense below sandbox.. Should this text_type be removed?. Should this be replaced with a no-op?. Should this be removed?  Does autoescaping even make sense for native types?. Should this be removed?  Does autoescaping even make sense for native types?. Should this text_type be removed?. Jinja is always capitalized when used as a name.. This incurs except overhead every time the function is called in Python 3.. Use MarkupSafe for this.. collections.Generator is probably more correct here.. Let's keep this in the else block, no need to run the check if len(head) == 1.. Use inline code markup\n``{% debug %}``. No need to mention Django here, this won't mean anything if you haven't used the Django debug tag, and it's not really equivalent anyway.. Code blocks must be preceded with two colons: `::` or (preferably with non-Python) `.. codeblock:: html+jinja`.. `version_info[:2]`. Why replace these?. Pygments recognizes `html+jinja`, use that over `html`.. Use `::` for Python code blocks. Double backticks are only for inline code. See the Sphinx docs, and build Jinja's docs, to see what this looks like.. Is this the correct place to unescape? Calling `Markup` right after `unescape` seems like a no-op, and might fail if `rv` isn't already markup. `s` should probably be unescaped as soon as possible and only if it's `Markup`, then escaped again at the end if it was previously escaped or if autoescape is enabled in the current context.. Why doesn't this need to be done to the `if blank:` case above?. This is incorrect if autoescape is currently disabled.. OK, I think my original statement may be somewhat inaccurate, but there's an even bigger issue here. Now you're unescaping whatever came in and wrapping in in `Markup`, indicating to Jinja's autoescape mechanism that the contents are safe. So for example if I did `{{ user_input|indent }}`, and the user passed in `<big xss injection>`, your code undoes any escaping that was already done to that and tells Jinja not to escape it, so the injection gets through.. `[str(x) for x in searchpath]`. Don't use `_` as a variable name if you're not ignoring the variable.. Seems like this will still fail if searchpath is a single value. It's not `string_types`, so instead you'll try to iterate over a path.. Don't need the inner `list` call.. Write a separate test rather than adding to an existing test. Use `pytest.mark.skipif` to skip the test if pathlib isn't available.. `pathlib = None` rather than a separate flag.. Use ReStructuredText formatting for docstrings. Render the docs with `pip install pallets-sphinx-themes` then `make html` from the docs folder. You can view the build by opening `_build/html/index.html` in a browser.. Let's have one explicit arg and switch on its type automatically.. Is this the correct way to call macros? This probably requires `context.call()` or an equivalent for macros.. Keep list sorted.. Use `context.resolve(name)` to look up a name.. It looks like other filters don't use use it even if they take context, so we can skip that for now.. As I've been updating installation sections in various places, I've only been mentioning pip.. I know all the old tests use this concatenation style, but let's use `pytest.mark.parametrize` for new tests, it's easier to reason about.. Same as the comment below, let's split this out into `pytest.mark.parametrize`.. \"... for the grouper (``gender`` in this example) and...\". Use double backticks to denote code in RST:\n\nrst\nthe ``gender`` attribute\nThis applies to all the places you used that syntax.. Need double backticks on gender and list.. ",
    "woodb": "Looks good to merge, eh? I was going to file this PR myself after noticing the same typos. /cc @mitsuhiko \n. ",
    "p1otr": "ping...\nI'd love to remove this patch from debian/patches dir :)\n. thanks :)\n. ",
    "homeworkprod": "I've corrected four instances of \"appying\" to \"applying\".\nHowever, that typo has been fixed by c251d8a, 21 months after my original PR.\nMy additional note (or something similar) to each of the four filters on how they behave if no test is given has not been added in the meantime, though.\nShould I rebase?\n. I have rebased. Please take a look.\nI think the clarification of the docstring regarding the test being applied to each object of the sequence instead of \"the object\" prevents confusion, so I kept it.\n. ",
    "johnnoone": ":+1: \n. ",
    "Osmose": "A use case for this that I run into all the time is setting a variable to the value of a {% trans %} block. :+1: \n. ",
    "glombard": ":+1: The macro workaround works OK but it can get messy, the set block assignment would be much nicer.\n. ",
    "malthe": "Maintainer?\n. It would be cool to be able to easily wrap the result in Markup such that the variables can immediately be used in babel translations:\n{{ _('Please click %(button)s', button=button) }}\nI currently need to set app.jinja_env.globals['safe'] = Markup and use:\n{{ _('Please click %(button)s', button=safe(button)) }}\nThe syntax might be something like:\n{% set button | safe %}\n. ",
    "rande": "+1 this is annoying\n. duplicate #234 \n. ",
    "mindw": "Which causes mod_env to be destroyed and then the file object in question to be destroyed?\n. Better?\nOtherwise I may be missing something obvious here - is it possible to have a more verbose explanation?\nEA - if self.mod_env is holding the file(s) open why is deleting make the rest of tearDown() dead code?\n. Indeed it is not. I'll keep looking :(\n-gabi\nOn Wed, May 29, 2013 at 12:09 AM, Daniel Neuh\u00e4user <notifications@github.com\n\nwrote:\nThis still doesn't ensure that the file will be closed (before it is\nremoved.)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mitsuhiko/jinja2/pull/235#issuecomment-18580339\n.\n. Fixes submitted as requested - any update?\n. An unfortunate annoyance.\n. updated. You can use vagrant for getting a legit windows10 in virtualbox:\n\nvagrant init Microsoft/EdgeOnWindows10; vagrant up --provider virtualbox\nappveyour is a CI for windows - https://packaging.python.org/en/latest/appveyor/\n. rebased on top of 2.7-maintenance latest.\n. ",
    "danielchatfield": "@mindw notifications aren't sent when commits are added, that might be why it's been pretty silent in here\n. ",
    "dhendo": "@mitsuhiko it looks like this is just in master - any chance it can go into a 2.7 package sometime soon?\nIt currently dies if None is passed through\n. ",
    "teddybear": "Appreciate to your response! Currently i'm rolled back jinja to 2.6.\n. ",
    "extesy": "@mitsuhiko Could you please merge this PR? This bug breaks Jinja2 on Python 3.\n. ",
    "domenkozar": "+1, this breaks pyramid_jinja2\n. ",
    "legutierr": "There are a couple of ways to do this.  \nThe Django style:\n{% include file with key=value %} {# external context is accessible inside included file #}\n{% include file with key=value only %} {# external context is not accessible #}\nThe Twig style (equivalent to the above):\n{% include file with { \"key\" : value } %}\n{% include file with { \"key\" : value } only  %}\nThe Twig style does provide some additional flexibility:\n```\n{% set key = \"key1\" if case else \"key2\" %}\n{% include file with { key : value } %} {# keys can be dynamically determined #}\n{% set args = { \"key1\" : value1, \"key2\" : value2 } %}\n{% include file with args %} {# variable dictionaries can be passed in #}\n```\nNote that this functionality is not achievable using the with tag.\n{% with key=value %}\n{% include file %} {# the external context is accessible inside of the included file #}\n{% include file without context %} {# the value set using with is not accessible #}\n{% endwith %}\nI've implemented the \"Twig style\" of this in a separate Jinja extension library, but in order to avoid branching jinja itself, I've had to subclass Template and Environment, I've had to copy and paste a lot of boilerplate, and I've even had to monkey patch a little.  Adding the functionality directly to jinja would be much cleaner and involve much less code.\nI'd love to put a patch together, if there was some willingness to incorporate the functionality.  Is there any possibility that this feature would be accepted into Jinja?\n. Hi Armin,\nI'm really surprised to hear that you regret adding the include tag!  It has been invaluable for us; I can't imagine living without it.\nWe have found that for designers and CMS users the learning curve for writing macros is quite a bit higher than for writing simple templates.  While there are some advantages to importing macros instead of including templates, in practical situations for us, we have found that for those key users the advantages are outweighed by the additional complexity.  We have also found that composition, re-use and testing are simplified when UI snippets can be written as standalone templates rather than macros that need to be imported and then invoked.\nI have a feeling that our experience in this regard is not uncommon.  I'm confident that the fact that you did add the include tag to jinja is very much appreciated by a large number of people :)\nThis pull-request includes code that we have been using to provide some greater control over what context is accessible within included templates.  In our use case, it allows us to give CMS users access to precisely the data they need for their snippet, and nothing more.  We got the idea from Twig, but as you see, the concept (with a slightly different implementation) is now found in Django as well.\nI'm happy to add documentation for this feature, if you are willing to move forward.  I didn't do that here because I wasn't sure what your preferences were for documentation.\n. Hi @mitsuhiko.  \nCould you provide more explanation of your decision to close this ticket?  I'm finding it difficult to understand why this is desirable behavior with regards to the macro escaping.  Shouldn't macro output always be safe?  \nAnd even if you want macro output to only sometimes be safe, isn't the following behavior the reverse of what you would want in that case?\n>>> env = jinja2.Environment(autoescape=False, extensions=[jinja2.ext.autoescape])                 \n>>> template = \"{% macro m() %}<html>{% endmacro %}\"\n>>> template += \"{% autoescape true %}{{ m() }}{% endautoescape %} {{ m()|e }}\"\n>>> env.from_string(template).render()\nu'&lt;html&gt; &lt;html&gt;'\n\nIf the autoescape global somehow escapes macro output by default, why would turning autoescape on globally cause macros not to be escaped?\n>>> env = jinja2.Environment(autoescape=True, extensions=[jinja2.ext.autoescape])                 \n>>> template = \"{% macro m() %}<html>{% endmacro %}\"\n>>> template += \"{% autoescape true %}{{ m() }}{% endautoescape %} {{ m()|e }}\"\n>>> env.from_string(template).render()\nu'<html> <html>'\n\nCould it not be that there is some bug triggered by global autoescape=False that somehow is marking macros as unsafe when they should simply be safe in all cases?. Hi @mitsuhiko, thank you for the prompt response, and thank you for re-opening.\nWith regards to the feature you describe, I'm not sure if I see it in this particular example.\n>>> env = jinja2.Environment(autoescape=False, extensions=[jinja2.ext.autoescape])                 \n>>> template = \"{% macro m() %}<html>{% endmacro %}\"\n>>> template += \"{% autoescape true %}{{ m() }}{% endautoescape %} {{ m()|e }} {{ m() }}\"\n>>> env.from_string(template).render()\nu'&lt;html&gt; &lt;html&gt; <html>'\n\nIn this example, global autoescape is turned off, but the autoescape tag is doing something anyway.  It doesn't seem to be disabled by the global autoescape being False (which, to me, seems like a good thing, except with regards to this macro issue).  Also, the escape filter is affected by the global autoescape setting, so the underlying issue doesn't seem to be limited to the autoescape extension.\n. Thank you @mitsuhiko!. ",
    "mulllhausen": "in jinja 2.9+ you can just wrap the {% include 'file' %} inside a {% with var=val %}{% endwith %}, like so: https://stackoverflow.com/a/32657364. ",
    "qaisjp": "I've come across this:\n```\n  <!--\n    For some reason, the execution of the following tag: {{ active_page }}\n    causes the active_page to be kept in \"cache\" and sent down to the nav.html.\nWithout the inclusion of active_page above the below nav.html will not receive it.\n\n-->\n  {% include 'nav.html' %}\n```\n. ",
    "milesrichardson": "Was this ever fixed?  I am still experiencing this bug (same as #169 and #84).\n. ",
    "kevinisaac": "The bug still exists.\n. ",
    "ntcong": "This bug was fixed. Originally #84 introduced block overrides in include tags and got merged later, but it has since broke some templates setup (recursion on duplicated block), hence this issue.\nBecause the template behavior should not be changed, @mitsuhiko revert the patch.\nIf you want to support block overrides, please make a new issue, and maybe a proposed working solution.\n. ",
    "Dmitri-Sintsov": "It should be such easy to provide include with block overrides while keeping compatibility of current implementation of include just by using different template tag name:\n{% include 'file.jinja2' %}\ndoes not override included blocks, while:\n{% include_override 'file.jinja2' %}\ndoes the same.\nIt's very strange that such functionality is not implemented for such a long time, knowing how Jinja2 is very powerful in most of features, in fact one of the best template engines around, not just for Python.\nEspecially if there was actual patch done already.\n. I emulate such functionality via supplying more than one call() argument and checking which arguments were passed in caller.arguments. There is the link to the macro which supports three optional (not mandatory) caller blocks:\nhttps://github.com/Dmitri-Sintsov/django-jinja-knockout/blob/master/django_jinja_knockout/jinja2/bs_list.htm\n```\n    {% if caller and 'has_filters' in caller.arguments -%}\n        {{ caller(has_filters=True) }}\n    {% else -%}\n        {% for field in view.allowed_filter_fields -%}\n            {{ bs_breadcrumbs(*view.get_filter_args(field)) }}\n        {% endfor -%}\n    {% endif -%}\n```\nand the call which overrides two of three optional caller blocks:\nhttps://github.com/Dmitri-Sintsov/djk-sample/blob/master/club_app/jinja2/club_list_with_component.htm\n```\n{% call(has_filters, has_pagination) bs_list(view, object_list, is_paginated, page_obj) -%}\n    {% if has_filters -%}\n        {% for field in view.allowed_filter_fields -%}\n            {{ bs_breadcrumbs(view.get_filter_args(field)) }}\n            {{ bs_dropdown(view.get_filter_args(field)) }}\n        {% endfor -%}\n    {% elif has_pagination -%}\n        Sample of pagination override\n        {{ bs_pagination(cbv=view, page_obj=page_obj) }}\n    {% endif -%}\n{% endcall -%}\n```\nIf there is better way to achieve that, let me know. At least it works and is not too much verbose.. ",
    "lazka": "Just had the same problem:\nfrom jinja2 import Environment\nTMPL = \"{% for item in items %}({{ loop.revindex }}, {{ loop.revindex0 }}){% endfor %}\"\nprint Environment().from_string(TMPL).render(items=reversed(range(10)))\n. Are you sure you are using current trunk? I get 3 3 3 for both.\n... but, I just saw that It's wrong for lists of length < 2 :/\n. ",
    "dafrie": "Just had the same problem with an iterator.\n\n{% for i in revisions|reverse %}\n{{ loop.revindex }}\n {% endfor %} \nFor loop.revindex it gives me a list ending with 0, for loop.revindex0 it gives me a list ending with -1 \nUPDATE:\nLooks like its only behaving like that in combination with the |reverse filter. The loop.length is when using |reverse also wrong \n. ",
    "bradjc": "I don't think this is quite right yet. It seems that loop.length is off by one with reversed lists of length > 1. Example:\n``` python\nimport jinja2\nl = [0, 1, 2]\ntemplate_forward = jinja2.Template('{% for i in l %}{{ loop.length }} {% endfor %}')\ntemplate_reverse = jinja2.Template('{% for i in l|reverse %}{{ loop.length }} {% endfor %}')\nprint(template_forward.render(l=l))\nprint(template_reverse.render(l=l))\n```\nprints:\n2 2 2\n3 3 3\nIt should be 3 3 3 both times as the list clearly has three items in it.\n. Ah yes I see this too. I was working from 2.7.3. Haha so my conclusion was correct even if my justification wasn't.\n. ",
    "unusual-thoughts": "This appears to be still wrong when length of the iterator/sequence is 1:\n```python\n\n\n\njinja2.Template(\"{% for i in lst|reverse %}{{ loop.revindex }}:{{ i }}, {% endfor %}\").render(lst=[10,11])\n'2:11, 1:10, '\njinja2.Template(\"{% for i in lst|reverse %}{{ loop.revindex }}:{{ i }}, {% endfor %}\").render(lst=[10])\n'2:10, '\n``\n(Should be1:10, `). Related to https://github.com/pallets/jinja/issues/244 and https://github.com/pallets/jinja/commit/4eb30f1dec22a3f803d910477eead35271b771e0. \n\n\n",
    "gthb": "The foremost problem with that is that I didn't realize plain string methods were made available. Yeah, new to Jinja2. Thanks : )\n. ",
    "pas256": "@Naddiseo The thing that is wrong with your solution is that IT IS NOT IN THE DOCUMENTATION!!!\n@gthb Thanks for trying and going to all that work.\nI have opened a new Issue for the documentation: https://github.com/mitsuhiko/jinja2/issues/273\n. ",
    "jaraco": "and furthermore, the tests fail too.\nHow about a pull request to update the trove classifiers and documentation to indicate that 3.2 will never be supported? I read the docs, which say \"Python 3\" is supported with no caveats.\n. I fixed the failing tests, and now tests pass on the \"supported\" versions. I also now see that the docs were updated to reflect the new limitation - it's just that the docs in the repo are not yet current with http://jinja.pocoo.org/. I guess that'll be up to date soon enough to prevent others from making similar requests to this. Cheers.\n. I reported this issue 9 months ago, yet still the home page advertizes support for Python 3.2 (\"2.4 through current versions\").\n. Sorry for the dupe.  I did search DeprecationWarning in the repo first before filing. Github failed me:\n\n. ",
    "Diaoul": "Wow, that's an opinionated standpoint.\nI find myself using jinja with Home Assistant and manipulating RGB colors. I want to render {'r': 255, 'g': 255, 'b': 255} as 0xRRGGBB format but no luck because jinja doesn't come with those handy features.\nWhat is your suggestion to work around this? Implementing functions would indeed work but what if someone wants 0xBBGGRR? Isn't it jinja's job to let the user decide of the rendering?\nI agree that a feature like this shouldn't be abused but there are use cases for it.\nSorry if you find this comment harsh, this is not my intention. I face true despair :cry: \n. Thank you, I added a way to convert it back to decimal\n{{ '0x{r:02X}{g:02X}{b:02X}'.format(**color) | int(base=16) }}\nI notice you use .format instead of the format filter. I'm a bit confused to know what is allowed and what is not allowed in a jinja template. What is the preferred way to do this? When to use one or the other?\nQuoting the zen of Python: There should be one-- and preferably only one --obvious way to do it.\n. ",
    "da-anda": "I'm also in need of bitwise operations - at least comparisons. I have a sensor in HomeAssistant that uses a bitmask value to represent several states in one value. In HomeAssistant I want to split this bitmask value into individual sensor values which would be easy to do with a simple {{ state(sensor.with_bitmaskvalue) & 1 }} as value template for my sensor. Right now it's nearly impossible to do this via a Jinja template - at least according to my research. sorry for the noise, I just found that they added a custom filter bitwise_and() which does the trick for me. ",
    "jmagnusson": "Is it possible to achieve this today with sort-filter?\n. I get the following in py3.4 when I use .next() on the cycler object. I didn't have it in py2.7.\nUndefinedError: 'jinja2.utils.Cycler object' has no attribute 'next'\nAre you having this problem as well?\nChanging to .__next__() fixes it.\n. ",
    "carljm": "We're running into this as well. (I almost didn't find this bug because you didn't use the term auto_reload -- this is only relevant when auto_reload=True).\nIt looks like this would be quite tricky to fix; ideally you'd want the uptodate method returned from get_source to check not only the source file itself, but also any source file it imports, extends, or includes. But at the point when uptodate is defined, all you have is the raw un-parsed source, so that information isn't available.\nIt might be implementable at a higher level (e.g. in Template.is_up_to_date) but that seems like it would also require significant surgery to get the dependency info back from the compiler.\n. ",
    "k4nar": "I just ran into this as well. This is pretty annoying in development because it means that I have to set cache_size to 0, and then things get very slow (as one could expect).\nI'll try to dig in the internals to see if I come up with something. In the meantime, if someone with more experience could suggest with a solution or even some direction that would be really great!\n. I've encountered this bug with Jinja 2.9.6 and this patch fixes it.\nIf this isn't merged, a workaround is to simply override env.filters['random'] with the do_random function from this patch.. ",
    "red15": "Ok now I see how that example works, might not be the best spot in the documentation to combine with another example demonstrating the |format filter.\n. ",
    "tebeka": "IMO we can go with the minimal features that make it usable (which are the ones I currently have of course :).\nWhat do you mean by \"load the context\"?\n. @untitaker Thanks for the explanation. But please - no cut&paste :) I think your changes are orthogonal to this utility and can be done in a later stage. We can add from_envvar and friends later.\n. @mitsuhiko Should I submit and pull request and we'll go from there?\n. OK, will look and fix.\n. Took a bit, but now passes on 2.6 and 3.3 (at least on my machine :)\n. Another option (that I implemented for an internal tool) is to use py: prefix for values to evaluate them.\nThis was better than -e since then you need to \"'double quote'\" strings.\nWhat do you think?\n. @auvipy Nope :)\n. ",
    "cp10000": "I agree that there should be a command-line interface to use Jinja2.   The command-line should be done in a way that exposes all the features (no loss of features).   Today (2015), there are more reasons than ever to have a command-line interface.\n. ",
    "kblomqvist": "I have made this kind of CLI tool, https://github.com/kblomqvist/yasha. I know there are others as well, but not as complete I think.\n. Duplicate with #641.. In past I also struggled a lot when using my tool called yasha to generate this from this. I think that Jinja's - does not work as expected, but can't remember in which cases.\nHowever, today I kinda agree with ThiefMaster.. I would take advantage of a jinja-import-loader in my project (yasha).. \"is to check\" instead of \"is check\". ",
    "gbach": "If you create a file with this content and import it, it will \"piggy-patch\" your jinja2 that template.module will work also with an StrictUndefined env.\n``` python\nfrom jinja2 import environment\ndef make_module_patch(self, vars=None, shared=False, locals=None):\n    env = self.environment.overlay(undefined = NeverFailUndefined)\n    ctx = environment.new_context(env, self.name, self.blocks, vars, shared, self.globals, locals)\n    return environment.TemplateModule(self, ctx)\nenvironment.Template.make_module = make_module_patch\nclass NeverFailUndefined(environment.Undefined):\n    def call(self, args, *kwargs): return \"\"\n    def getattr(self, key): return self\n```\n. ",
    "nex2hex": "{% include %} return rendered content, {% use %} tag include template with blocks and vars without render\n. ",
    "vreon": "This is because Jinja doesn't know about the semantics of the text it's generating; \"CSS comment\" has no meaning to it.\nDoes folding work if you use Jinja comments instead? They won't appear in the generated CSS, but that may not be a dealbreaker for you...\njinja\n{# General styles {{{ #}\n.foo { ... }\n{# }}} #}\n. ",
    "sscherfke": "Yes, jinja comments work.\n. ",
    "ichuan": "Ok, got it, thanks for the link!\n. ",
    "jpscaletti": "http://jinja.pocoo.org/docs/templates/#import-context-behavior\n\"Per default included templates are passed the current context and imported templates not. [\u2026] This however can be changed of course explicitly. By adding with context or without context to the import/include directive\"\nOn Oct 4, 2013, at 11:24 AM, Aur\u00e9lien Scoubeau notifications@github.com wrote:\n\nHi,\nI'm using the jinja-atoms (https://github.com/semirook/jinja-atoms) extension and run into a naughty problem: the atoms used inside an included template are undefined.\nI dove in jinja sources and found the culprit: include with context creates a new shared context, which doesn't get the globals.\nAs the atoms are put in the environment globals dictionary, the are not available in the included template.\nThe behavior seems to be intentional though, so I get 2 questions:\n1. Why would a shared context not get the globals?\n2. Where else could the atoms be stored to be available in all templates?\nThanks for your time.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "qur2": "@untitaker  @jpscaletti I know the difference between import and include. I'm speaking here about the globals not being passed to include with context because of the shared context. See compiler.py:951, in visit_Include, the shared flag is true. If I set it to false, then it works. But obviously I don't want to modify jinja sources.\n. Oh, ok. Does that mean we should expect a new Jinja version without includes? \n. ",
    "ikudriavtsev": "The same (or kind of the same) issue happens with extends tag.\n. ",
    "doctortoffu": "Yes, it is still relevant!\nThe failing template for me is a child template as well.\nI'm attaching a copy of the problematic one.\n[incident_report.txt]\nThe error message I get ends this way:\n\"templates/incident_report.html\", line 407, in template\n    {% endfor %}\nTemplateSyntaxError: Encountered unknown tag 'endfor'. Jinja was looking for the following tags: 'elif' or 'else' or 'endif'. The innermost block that needs to be closed is 'if'.\"\nThe commented out section starts on line 279.\nHope that helps.\nCheers.\n. This is odd. When I prepared a very simplified version for you it works fine. :-/\nAnyway, this is the idea:\n``\n{% extends \"test_base.txt\" %}\n{% block main %}\n  {% set a_test = {'my_key': 'just testing'} %}\n                        {% if  a_test %}\n                            {% set sorted = a_test | dictsort %}\n                        {{ sorted | safe }}\n```\n                    {#\n                {% for i in a_test %}\n        {{ i }}\n                {% endfor %}\n\n```\n}\n{% endif %}\n{% endblock main %}\n    ``\nIn the original template, it complains about that 'endfor' tag.\nI guess it can't be reproduced, indeed :-(\nThanks anyway for your time! :-)\nP.S.: I tried to make this format the code correctly but it just didn't work.\n. I found the problem!\nThere was another block commented out within the problem block:\n```\n{#\n{% for i in a_test %}\n    {#\n     #}\n{% endfor %}\n}\n```\nMy bad. Sorry about that!\nThanks for your time though!\n. ",
    "thomasballinger": "hm, I rebased to combine these commits, but they're displayed as several here - anyone know if I need to open a new pull request, or might have done this wrong?\n. Closing and opening a new one so it's just one commit\n. reincarnation of Pull #272 \n. ",
    "kojiromike": "It's hard to say what would be a good writeup of the issue. The documentation says things like\n\n\u2026don\u2019t use builtin Python constructs such as str.format or the string modulo operator (%).\n\nThat clearly imply it's possible to use builtin Python constructs (such as the ever popular str.split), but afaict it's never explicitly said anywhere that such Python constructs are allowed.\nThe thing is, if any Python construct is allowed (and it ought to be, given that Jinja falls back to __getitem__) then the documentation should probably just say that.\n. ",
    "edgan": "I was already using python methods in my jinja from having run across examples, but I just realized that it wasn't just the few I was already using. This is huge, and opens doors I didn't know existed. There should be a dedicated section with examples.. ",
    "terminalmage": "Any ideas?\n. @Naddiseo Can you provide a more complete example? I don't see how this fits into my example.\n. Nevermind, after looking at the jinja2 source code it seems like when I instantiate the class I just need to use undefined=UndefinedVar when instantiating a jinja2.Environment class instance.\n. Has there been any progress in resolving this bug?\n. @rbjorklin I think you misread this issue. The problem isn't that jinja doesn't give a line number (a perusal of my original post will show you that it does), the problem is that it gives the wrong line number, for reasons upon which others have elaborated.\n. I am seeing this as well. This is happening because the indent filter was changed in https://github.com/pallets/jinja/commit/bb8ef40#diff-33dcdc15f917259c644200be7d924eb0R552 to concatenate strings to markupsafe.Markup objects. A more concise example can be found here:\n```\n[root@b98126fdc23f /]# pip install jinja2==2.9.6\nCollecting jinja2==2.9.6\n  Using cached Jinja2-2.9.6-py2.py3-none-any.whl\nRequirement already satisfied (use --upgrade to upgrade): MarkupSafe>=0.23 in /usr/lib64/python2.7/site-packages (from jinja2==2.9.6)\nInstalling collected packages: jinja2\n  Found existing installation: Jinja2 2.10\n    Uninstalling Jinja2-2.10:\n      Successfully uninstalled Jinja2-2.10\nSuccessfully installed jinja2-2.9.6\nYou are using pip version 8.1.2, however version 9.0.2 is available.\nYou should consider upgrading via the 'pip install --upgrade pip' command.\n[root@b98126fdc23f /]# python\nPython 2.7.5 (default, Aug  4 2017, 00:39:18)\n[GCC 4.8.5 20150623 (Red Hat 4.8.5-16)] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nfrom markupsafe import Markup\nfrom jinja2.filters import do_indent\ndo_indent(Markup(\"foo\\nbar\\n'baz'\\n\"))\nu\"foo\\n    bar\\n    'baz'\"\n[root@b98126fdc23f /]# pip install jinja2==2.10\nCollecting jinja2==2.10\n  Using cached Jinja2-2.10-py2.py3-none-any.whl\nRequirement already satisfied (use --upgrade to upgrade): MarkupSafe>=0.23 in /usr/lib64/python2.7/site-packages (from jinja2==2.10)\nInstalling collected packages: jinja2\n  Found existing installation: Jinja2 2.9.6\n    Uninstalling Jinja2-2.9.6:\n      Successfully uninstalled Jinja2-2.9.6\nSuccessfully installed jinja2-2.10\nYou are using pip version 8.1.2, however version 9.0.2 is available.\nYou should consider upgrading via the 'pip install --upgrade pip' command.\n[root@b98126fdc23f /]# python\nPython 2.7.5 (default, Aug  4 2017, 00:39:18)\n[GCC 4.8.5 20150623 (Red Hat 4.8.5-16)] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\nfrom markupsafe import Markup\nfrom jinja2.filters import do_indent\ndo_indent(Markup(\"foo\\nbar\\n'baz'\\n\"))\nMarkup(u'foo\\n    bar\\n    'baz'\\n')\n```\n\n\n\nConcatenating strings to markupsafe.Markup objects causes markupsafe.Markup.__add__() to escape the string being concatenated:\n```python\n\n\n\nfrom markupsafe import Markup, escape\nMarkup('foo bar') + \"'baz'\"\nMarkup(u'foo bar'baz'')\nescape(\"'baz'\")\nMarkup(u''baz'')\n```\n\n\n\nI've opened https://github.com/pallets/jinja/pull/826 to fix this.. I'm trying to add a unit test for this case and found a failure, I'm working on it now.. @ThiefMaster I'm adding additional test cases for input that is a Markup instance.. PR updated with a fix and additional test coverage. Travis failure is in the docs build and looks to be unrelated.. @davidism would you mind taking another look?. I pushed a commit to fix a spelling error.. @davidism I've updated the PR to apply the unescape fix in the top half of the if/else block as well. I had one question about your comment here though.. When the code that you've commented on changes, GitHub hides it, you can unhide it by clicking \"Show outdated\".\nSo, how would you suggest fixing this?. I think I have an idea. If we just make sure the values being concatenated are Markup instances (when s is one), then we avoid having the string literal converted to a Markup type, and we don't need the hacky \"unescape\" solution.. Yep, that works, and tests pass with the unescape hack removed.. @davidism Any other concerns?. This bug was introduced in 2.10, and there has been no release since then. You may want to try version 2.9.. @davidism Yeah, I'm fixing now. I wasn't aware that there were cases where a non-Markup type would be passed to the filter, as this is my first time diving into jinja2 code.. The idea to call Markup() again after unescaping is because it will give us a Markup instance with the escaped chars unescaped. My fix will contain this solution instead:\npython\nif lines:\n    rv += u'\\n' + u'\\n'.join(\n        indention + line if line else line for line in lines\n    )\n    try:\n        # Unescape any strings that were escaped due to concatenation\n        rv = Markup(rv.unescape())\n    except AttributeError:\n        # s was not a Markup instance\n        pass\nThis way, if s is not a Markup instance, then the unescape() triggers an AttributeError, and rv will be left unmodified.. Here's another example of what I mean by calling Markup(). This is because .unescape() returns a unicode type.\n```python\n\n\n\nfrom markupsafe import Markup\nx = Markup('foo ') + \"'bar baz'\"\nx\nMarkup(u'foo 'bar baz'')\nMarkup(x.unescape())\nMarkup(u\"foo 'bar baz'\")\n``. Can you explain? I don't see autoescape factoring intodo_indent()anywhere, and like I said, this is my first crack at working with the jinja2 source code. The idea of this try/escape is that we attempt to unescape, and if it's a string type instead of aMarkupthenrv` remains unmodified. EAFP.. You're right, this was just a case of me coding my fix to the use case with which I was familiar.. \n\n\n",
    "rbjorklin": "@terminalmage I'm not sure I understand this issue and actually stumbled over here from this saltstack issue where I seem to get the line number as can be seen in my comment. Is this what you were looking for?\n. ",
    "quantus": "I think I hit this same issue with Raven where the stack information collection fails if the call stack contains jinja templates. The wrong line numbers cause inspect module functions raise unexpected exceptions. I reported the issue there: https://github.com/getsentry/raven-python/issues/1133. ",
    "smari": "Turns out, it was because the MIME header was missing on the relevant PO file, so it never declared its own encoding to be UTF-8, probably pushing back to some default. But as this wasn't a problem for me when I used gettext directly, this might still be a bug that's worth somebody's attention... although probably not a high priority one ;-)\n. ",
    "hvnsweeting": "yes, you are right,\nThanks\n```\nIn [6]: t = jinja2.Template(\"{{ (x/2) | int }}\")\nIn [7]: t.render(x=5)\nOut[7]: u'2'\n```\nSeem it relate to this one https://github.com/mitsuhiko/jinja2/issues/119\n. ",
    "sidharthd": "Just ran into the exact problem!\nThanks @hvnsweeting and @Naddiseo \n. ",
    "Roemer": "Same issue, same solution. In my case, it was in Home Assistant where I ended up with:\n{{ ((states.input_number.guestroom_setpoint_shift.state | float) * 2) | int }}\nThanks!. ",
    "timhanus": "Thanks for getting back to me so fast!\nCatching all exceptions that marshal throws explicitly now.   \nI should note here that the only error I was able to reproduce was the EOFError.   I can just catch this exception explicitly and allow the others to bubble up if you would prefer.  \nMy line of thinking for going ahead and capturing all three marshal exceptions was that any type of error loading cached bytecode should result in the same result:  Invalidate the cache and reload the template from source.  \nThanks again.  I appreciate your time.\n. ",
    "thomasvnoort": "I don't mean to be impatient, but is somebody looking into merging this pull request? To me it seems like a simple yet powerful addition.\n. Wonderful, thanks for your quick reply!\n. ",
    "eugene-eeo": "Maybe @mitsuhiko or someone should fix it. Seems unworthy of a pull request though.\n. ",
    "l1k": "Yes, my expectation was that map() returns a list. And that is not a bug? So that means map() shall only be used as an intermediate function with some other filter like |join or |list appended to it? Hmmm. Maybe that should be stated explicitly in the documentation.\n. ",
    "jaytaylor": "I didn't know about the {{ ... | list }} solution for the ansbile <generator object do_map at 0xdeadbeef> issue.\nThanks for filing this!\n. ",
    "douglarek": "@tebeka please see the errors,  your patch should support 2.6 and 3.3\n. ",
    "half-duplex": "I'd also like to be able to read variables from the environment, for use like eRuby. I had written my own before thinking to search here: https://gist.github.com/mallegonian/09d7e005ddbc225852fc\nThis allows for easier usage from other scripts, eg:\nexport THING_A=\"beep\"\nexport THING_B=\"boop\"\npython -m jinja2 /etc/braap.jinja >/etc/braap.conf\n. Use if not value.startswith(prefix):?\n. ",
    "auvipy": "@tebeka are you still working on it?\n. python 3.4 supported in 2.8? 3.5 is knocking at the door\n. +1\n. for pr and migrating to pytest, prs should be send with converted tests written in pytest? what are the plans?\n. thats a very good reference to follow! would be very helpful! will try to send a PR in WIP mode then!\n. okey. jinja2 have less  tests then flask? I think so\n. https://github.com/django/django/pull/4783 this is something what I actually meant \n. ",
    "thoger": "Similar patch is used in Debian packages too:\nhttp://patch-tracker.debian.org/patch/series/view/jinja2/2.7.2-2/fix_CVE-2014-0012.patch\n\nShould multiple instances of a FileSystemBytecodeCache initialized without the directory argument point to the same directory?\n\nJinja2 documentation says:\n\nBytecode caches make it possible to store the generated bytecode on the file system or a different location to avoid parsing the templates on first use.\nThis is especially useful if you have a web application that is initialized on the first request and Jinja compiles many templates at once which slows down the application.\n\nIt seems re-use of cache across invocation is expected, which makes tempfile.mkdtemp() fix not usable.  I also assume that approach has more issues with cache file clean up because of lack of temporary directory removal.\n. > As I said, the directory name could be cached on the class to preserve it across instances of FileSystemBytecodeCache objects.\nIs that something that should only work for multiple instances created during the one invocation of an application, or something that should work across application invocations?  If I understand your brief hint correctly, that approach would not try to cover multiple invocations.\n\nThe existing implementation doesn't clean up the directory it creates either, so I think that is a separate issue.\n\nThe current implementation doesn't clean up, but there is a fixed limit on the number of cache files created - the number of templates used.  With real temporary directory, it's that number multiplied by number of invocations.\n. ",
    "derekbrown": "OK. I'll refer to the IRC channel first. Thanks.\n. ",
    "niklasl": "Thanks @Naddiseo \u2013 starting from there I finally found the cause. It is only div that causes a problem. In jinja2.compiler, the line from __future__ import division is written into the template code, causing / to mean truediv. Therefore, overloading must be done with __truediv__ and not __div__ (which is rendered meaningless by that import).\nIt's probably unfair to call this a bug in Jinja2 then. It was quite unexpected, but the root of that was the warped meaning of division in Python. Studying how Jinja2 handles division closely and actually grooking div overloading details here finally saved me. For robustness, libraries using operator overloading should take the details around division into account.\nThus, I'll close this issue. It may still be good to document this detail explicitly though.\n. ",
    "jcwilson": "Thanks! I appreciate it since I don't have the luxury of choosing which python version to use. My compliments for having it still work on 2.5 even if it's not officially supported.\n. ",
    "mearns": "Didn't realize os.altsep was None on other systems. Admittedly this was a quick hack to fix an issue I was having, but I still suggest you consider this an open bug: if you want to write system-independent code, then you should accept paths in the native format for the system. Most of the python built in functions that return a file system path use the native format (like os.getcwd for instance), and if you use these to load templates on Windows, it fails.\n. How about FileSystemLoader? That loads templates from a directory on the file system, right? And it uses the altered function split_template_path to do so. This doesn't work correctly on Windows. So perhaps the changes were made in the wrong place, or perhaps were just done incorrectly, but I still suggest that if you have a class that works with file system paths (such as FileSystemLoader) it be able to support file-system paths in the correct format for whatever system its on.\n. Alright, well it's you're project. From a user's perspective, I expect to be able to pass a file-system path to FileSystemLoader. \n. ",
    "mbehrle": "It just took me quite a while to get the right format to call the extension argument. Not knowing which is the expected bahavior I am reopening, because either documentation or behavior could be improved.\nProviding a list of extensions (as understood as a python list) just returns an empty list:\nextensions=['html', 'jinja'] => result []\nwhile a string of comma separated list of extensions works as expected:\nextensions='.html,.jinja' => works as expected\nThanks for jinja2!\n. ",
    "slowkow": "Thanks!\n. ",
    "lipis": "+1\n. ",
    "andreasWallner": "My Jinja2 version is 2.7.\nAs I said in my original message, it works as expected when I execute the code in a normal shell. The problem arises only when there is no environment set up. My script is being executed in a shell that has e.g. no locale set up (and I have no control over it so that I can setup a locale in the shell). But the problem also arises in environments where the locale is set to something else than an unicode encoding.\nIf you want to test it you can just remove your environment variables and try:\n```\nbash\nunset env | awk -F= '/^\\w/ {print $1}' | xargs\n./test.py\nTraceback (most recent call last):\n  File \"./test.py\", line 4, in \n    Template('{{s}}').stream(s='\\xeb').dump('test.file')\n  File \"/usr/lib64/python3.3/site-packages/jinja2/environment.py\", line 1142, in dump\n    fp.writelines(iterable)\nUnicodeEncodeError: 'ascii' codec can't encode character '\\xeb' in position 0: ordinal not in range(128)\n```\nWith test.py being\n``` python\n!/usr/bin/python3\nfrom jinja2 import Template\nTemplate('{{s}}').stream(s='\u00eb').dump('test.file')\n```\nI knew about the encoding parameter, I said that using an explicit encoding it works. That is also why I said that I would not say that this is surely an error. It is just unexpected that the system locale makes the jinja output fail if there is no explicit encoding specified. I interpreted the documentation in a way that it would default to unicode, not to the system locale (which does not make that much sense in the case of python3, because there it will simply not work without the encoding paramter set (since all strings are Unicode anyhow))\nIf this is the intended behavior a short note in the Unicode section of the docs would be nice, otherwise it could be a solution to default to utf-8.\n. @mitsuhiko \nThanks for the fix, I checked up on it since I wanted to file it as a Python bug, and it seems though that this is the intended behaviour.\nFrom the Python 3.3 docs for open() (3.5 is the same):\nIn text mode, if encoding is not specified the encoding used is platform dependent:\nlocale.getpreferredencoding(False) is called to get the current locale encoding.\nFrom the getpreferredencoding() docs:\nReturn the encoding used for text data, according to user preferences.\nSo you basically depend on the users locale to be set to utf-8 (or something that can handle all utf-8 characters). With your fix now this should be OK anyway, I just wanted to respond that I wanted to file this against Python, and that this is the behaviour Python intends.\n. Sorry about the separate issue, couldn't get the pull request to attach to the old issue.\n. ",
    "moodh": "Shouldn't invalid blocks report syntax errors instead of being ignored? The error itself is irrelevant.\n. With your reasoning my code should have simply ignored the broken line but still print the things inside the if/endif-block and I'd be fine with that. But in this case the entire if/endif-block got ignored even though the block itself was correct, it just contained \"bad\" code.\nI think that it should either raise an exception or ignore the broken line (maybe even print it as is), not the parent block. The current behavior is confusing and in my opinion just wrong.\n. I'd be happy if I got that output. :) Maybe it's only inside a block?\n. I tried recreating the problem without my entire codebase but I can't. The bug might be in the boto ses library since i use jinja only in emails. The bug is too small for me to invest more time in it however so feel free to close the issue. :)\n. Will do!\n. ",
    "wosc": "Thanks for the hint, but I think that's not quite what I'm looking for: As far as I understand it, StrictUndefined will only alert me if a template expression is not working, i.e. if I write {{ foo.bar().baz }}, and somewhere inside foo.bar() an AttributeError is raised, this will evaluate to StrictUndefined.baz. What it won't tell me (please correct me if I'm wrong), is where and what inside the foo.bar() call stack the original reason was that caused my getting an undefined in the first place.\n. Herewith a code example to illustrate what I mean. (Note that using StrictUndefined instead of regular Undefined changes nothing about the behaviour.)\n``` python\nclass Foo(object):\n@property\ndef bar(self):\n    return self.broken()\n\nenv = jinja2.Environment(undefined=jinja2.StrictUndefined)\nprint env.from_string('{{ foo.bar.baz }}').render(foo=Foo())\n```\nWhat I get when I run this:\nTraceback (most recent call last):\n  ...\n  File \".../lib/python2.7/site-packages/jinja2/environment.py\", line 397, in getattr\n    return getattr(obj, attribute)\njinja2.exceptions.UndefinedError: '__main__.Foo object' has no attribute 'bar'\nWhat I'd love to get:\nTraceback (most recent call last):\n  ...\n  File \"test.py\", line 8, in bar\n    return self.broken()\nAttributeError: 'Foo' object has no attribute 'broken'\nDoes this make things clearer?\n. One can also see the reason for this behaviour here: https://github.com/mitsuhiko/jinja2/blob/master/jinja2/environment.py#L396\npython\n    def getattr(self, obj, attribute):\n        try:\n            return getattr(obj, attribute)\n        except AttributeError:\n            pass\nThe environment explicitly throws away the original exception information here. That's why I proposed using something like log.debug('AttributeError on %r.%s', obj, attribute, exc_info=True) instead of pass in my original description as the simplest approach. (Although, as I think about it again now, this is probably too simplistic, since the very normal tradeoff between getitem and getattr would cause lots of spurious log output. Hmm.)\n. ",
    "martinth": "As I just spend one hour to find why the heck some parts of a page stop rendering (there was an AttributeError somewhere inside code called by a property) I agree with @wosc that a simple pass is not good enough.\n. I disagree that it can't be changed without breaking stuff. This is the code I'm currently using:\npython\ntry:\n    return getattr(obj, attribute)\nexcept AttributeError:\n    if attribute in dir(obj):\n        # You cannot distinguish between \"attribute not existing\" and \"attribute raised an AttributeError\" (i.e.\n        # when it is a @property and some internal code failed). By calling dir() we can see that obj actually\n        # *has* the attribute in question. In this case we re-raise the AttributeError since it was not caused\n        # by getattr(). Note: You cannot use hasattr() since that will use getattr() internally.\n        raise\ntry:\n    return obj[attribute]\nexcept (TypeError, LookupError, AttributeError):\n    return self.undefined(obj=obj, name=attribute)\nThis should work in any case and will effectively bubble up any exceptions without hiding them, thus giving more information to the user.\n. ",
    "serialine": "-            self._length = len(iterable) + self.index0 + 1\n+            iterations_done = self.index0 + 2\nIs +2 right?\nhas problem with loop.length, it returns +1 \n. ",
    "mchaput": "OK, I finally figured out that the list of exported vars isn't filled until you do list(template.root_render_func(context)). So I tried to hack around this by do that to get a context with exports, pulling the exports out with exports = context.get_exports(), and then doing template.render(..., exports=exports) so that the filter can do context.get(\"exports\"). However, when I try that, the \"exports\" key is empty when I try to call the macros. So presumably they are using the first context object so that won't work.\n. Ha, just realized get_exported() is empty because the \"renderable\" part of the template was before the macros. If I put it after the macros then they're available. Gotta say the whole system is counter-intuitive and hard to understand, but at least I'm making progress...\n. The documentation is not clear that a macro must be before any usages in the template, by the way.\n. ",
    "ifduyue": ":+1: \n. I think the problem is at line 670 in 6671b973e6de5abc46829a27fd3bbb989d68ca3a, where a template file is opened only to get its abspath.\n. ",
    "engstrom": ":+1:\n. ",
    "dnick971": "I had already installed jinja 2.6. The problem came from the markupsafe version (0.21) which don't support anymore python 3.2. With the 0.15 version it works.\nThank you.\n. ",
    "colstrom": "Intended as part of 2.7.3 or coming in 2.7.4?\nBecause looking at jinja2/tests.py in 2.7.3, test_equalto is still not defined.\n. ",
    "deoxxa": "Yep, awesome. Lost a bit of time on this. If it's not available, why is it documented and presented as available?\nEdit: see, here it is.\nDoes the documentation describe an ideal implementation of Jinja2? Like some kind of alternate universe version? If so, you seem to be doing a great job! This actual, concrete implementation is really close to what's documented!\n. ",
    "BillyMorgan": "3 tiny words that would have prevented me wasting the last hour of my life...  \"development version only\"\n. ",
    "steelywing": "Thanks for answer =) , I think this is not scope issue, because I tried\nhtml\n{% block content %}\n<table class=\"table table-striped\">\n    {% set scope_test = 'scope test' %}\n    {% for stock in stocks %}\n        <tr>\n            <td>{{ scope_test }}</td>\n        </tr>\n    {% endfor %}\n</table>\n{% endblock %}\n{{ scope_test }} will output 'scope test', so I think this is rendering order issue, I agree that we should put the calculation in our controller, but this bug really annoying =(\nUPDATE:\nYou should right, this should be scope issue, I try\nhtml\n    {% for stock in stocks %}\n        <tr>\n            <td>{{ scope_test }}</td>\n        </tr>\n    {% endfor %}\n    {% set scope_test = 'scope test' %}\nand scope_test output nothing, the for loop may be create a new runtime.Context scope\n. and if there has better way than using try to check if loader not implement get_source() ? I have tried to use loader.has_source_access but some test (ChoiceLoader, PrefixLoader that have sub-loader) raise error.\n. ",
    "pou-chi": "I'm sorry, my mistake.\nDon't include right encoding files to embeded python\n. ",
    "koddsson": "Ah, I forgot to run the tests before making the PR. Trying to figure out how I can set and check if jinja is running in debug mode to make sure that we don't output to stdout all the time.\n. ",
    "chimeno": "+1 to this, I was confusing at first\n. ",
    "hszcg": "@mitsuhiko would you please accept this PR?\n. ",
    "job": "Can this be merged?. ",
    "mehaase": "Sorry, my mistake. The Chrome inspector tricked me \u2013 I thought I was seeing injection. You're definitely right. I need to go delete my filter now. :)\n. ",
    "adamchainz": ":rainbow: :rainbow: :rainbow: \n. ",
    "Ernest0x": "I can confirm this bug with jinja 2.8, but in my case the suggested workaround above does not work at all. It doesn't matter if the variable is used or not before the include statement. Evenmore, my case is even simpler as I do not use template inheritance. I have just a simple template with a for loop and an include statement inside the loop that includes another simple template that tries to access the variable set with each iteration in the loop. This seems to be a critical regression as things do not work as explained in the Note at http://jinja.pocoo.org/docs/dev/templates/#import-visibility\n. > I can confirm this bug with jinja 2.8, but in my case the suggested workaround above does not work at all. It doesn't matter if the variable is used or not before the include statement. Evenmore, my case is even simpler as I do not use template inheritance. I have just a simple template with a for loop and an include statement inside the loop that includes another simple template that tries to access the variable set with each iteration in the loop. This seems to be a critical regression as things do not work as explained in the Note at http://jinja.pocoo.org/docs/dev/templates/#import-visibility\nFalse alarm. I was using jinja through Ansible and it is Ansible's fault (it uses jinja in a way that included templates are not passed the context). It is fixed for the upcoming version (2.0) of Ansible.\n. ",
    "jackwilsdon": "+1 on this, I'm experiencing the same with a block and an extends:\nlayout.jinja2\ndjango\nHello, {% block world %}{% endblock %}\nmy_page.jinja2\ndjango\n{% set text = 'Pizza' %}\n{% extends \"layout.jinja2\" %}\n{% block world %}\n  {% include \"world_partial.jinja2\" %}\n{% endblock %}\nworld_partial.jinja2\n{{ text }}!\nHere is what I'd expect the output to be upon rendering my_page.jinja2:\nHello, Pizza!\nBut instead I get this:\nHello, {{ text }}!\n\nYou can \"fix\" it using @xen's method of using the variable inside the block:\nmy_page.jinja2\ndjango\n{% set text = 'Pizza' %}\n{% extends \"layout.jinja2\" %}\n{% block world %}\n  <!-- text is {{ text }} -->\n  {% include \"world_partial.jinja2\" %}\n{% endblock %}\nBut this just feels like a hack to me.\n. Oops, I guess that'll teach me to force push!\n. Sounds like this is related to #352? It's kind of a big problem and it would be nice to get it fixed.\n. Oops, I guess that'll teach me to force push!\n. I was considering always passing the local context, but I wasn't sure if it would break anything? I asked in the IRC channel a couple of days ago but didn't get any response. The tests all still run fine so maybe we can just pass the current context instead?\nNot sure if it addresses #596, although it's unlikely as that is to do with block assignment.\n. It looks like this is because it overrides the get_source method of BaseLoader (which it inherits from), and therefore needs the same signature.. That would be more readable as isEnabled={{ ((some_var | length) > 0) | string | lower }} (to me at least), which I believe would work as expected.. ",
    "kooky": "I can't see a problem.\n```\nfrom jinja2 import Template\ntemplate =Template(\"begin {{note|urlize(40, True, '_blank')}} end\")\nprint(template.render(note='http://www.google.com/search=a_very_long_link'))\nprint('-----')\ntemplate =Template(\"begin {{note|urlize(40, target='_blank')}} end\")\nprint(template.render(note='http://www.google.com/search=a_very_long_link'))\n```\nand gives output\n```\ntim@pebbles:~/things/python$ python j.py \nbegin http://www.google.com/search=a_very_long... end\n\nbegin http://www.google.com/search=a_very_long... end\n```\n. Do you really need to know the type?  Are the tests like number and string not enough?\nhttp://jinja.pocoo.org/docs/templates/#list-of-builtin-tests\nI guess you could add type as a customer filter.  But this really doesn't feel very useful.\n```\nimport jinja2\nenv=jinja2.Environment()\nenv.filters['type'] = type\ntemplate =env.from_string(\"\"\"begin {{ note|type }} end\"\"\")\nprint(template.render(note='hello'))\nprint(template.render(note=1))\n```\noutput:\nbegin <type 'str'> end\nbegin <type 'int'> end\n. It works for me.  (Note, I had to change your fancy - sign for a normal one)\n``` python\nfrom jinja2 import Template\ntemplate =Template(\"\"\" {{ '%(foo)s - %(bar)s' | format(foo=1, bar=2) }}  \"\"\")\nprint(template.render())\n```\n$ python j2.py \n 1 - 2\nWhat is the reason for using format, rather than just using the variables directly in {{ }} ?\n. Looks good.\n. https://github.com/kooky/jinja2/commit/8033d4f59e1bae614556b52a63f6ee9ca8529fc8  is one fix.\npull request  https://github.com/mitsuhiko/jinja2/pull/419\n. git rebase -i master has made me lose the will to live.\n. ",
    "BertrandBordage": "This can be closed.\n. ",
    "jpoppe": "I have used a different approach, but I filed the ticket because this raises an exception on Python 3, and not on Python 2. I don't think that is the desired result.\n. ",
    "ragrawal": "This is resolved using macros. Here is an example:\n{% macro parentLoader() %}\n    {% include \"LogEventToFile/HiveToLocal.txt\" %}\n{% endmacro %}\n{\n    \"message\": {{ parentLoader()|trim|jsonify }},\n    \"runtime\": {{runtime}}\n}\n. ",
    "k0ste": "Come here from google.\nCase: if 1 (one) address, then make string, else make array.\nyaml\nstring_address: '10.10.10.10/24'\nlist_adress:\n  - 10.10.10.10/24\n  - 10.10.20.20/24\njinja\n{% if item.address is defined and item.address | ipaddr('host/prefix') %}\n{% if item.address is string %}\nAddress=('{{ item.address }}')\n{% elif item.address %}\nAddress=({% if item.address %}{{ '\\'' + item.address | join('\\' \\'') + '\\'' }}{% endif %})\n{% endif %}\n{% endif %}\nWith jinja we can check type is string. It could be someone will be useful.\n. One year later...\nCheck for the data type can be made even more accurate (for example string or sequence).\n```yaml\nnetwork_scripts_interfaces:\n- interface: 'vlan2'\n  address:\n  - '192.168.1.1/24'\n  - '192.168.2.1/24'\n- interface: 'vlan3'\n  address: '192.168.3.1/24'\n```\njinja\n{% if item.address is defined and item.address != '' %}\n{% if item.address is string and item.address | ipaddr('host/prefix') %}\n{{ 'IPADDR' + '=\\\"' + item.address + '\\\"' }}\n{% elif item.address is sequence %}\n{% for addr in item.address %}\n{% if addr | ipaddr('host/prefix') %}\n{{ 'IPADDR' ~ loop.index ~ '=\\\"' ~ addr ~ '\\\"' }}\n{% endif %}\n{% endfor %}\n{% endif %}\n{% endif %}. ",
    "artheus": "\nOne year later...\nCheck for the data type can be made even more accurate (for example string or sequence).\n```yaml\nnetwork_scripts_interfaces:\n- interface: 'vlan2'\n  address:\n  - '192.168.1.1/24'\n  - '192.168.2.1/24'\n- interface: 'vlan3'\n  address: '192.168.3.1/24'\n```\n{% if item.address is defined and item.address != '' %}\n{% if item.address is string and item.address | ipaddr('host/prefix') %}\n{{ 'IPADDR' + '=\\\"' + item.address + '\\\"' }}\n{% elif item.address is sequence %}\n{% for addr in item.address %}\n{% if addr | ipaddr('host/prefix') %}\n{{ 'IPADDR' ~ loop.index ~ '=\\\"' ~ addr ~ '\\\"' }}\n{% endif %}\n{% endfor %}\n{% endif %}\n{% endif %}\n\nThis is might not work as expected, as string type will also be true if you test with is sequence\nis sequence does only test if the variable is iterable. Which means that array, string and dict will all test True with is sequence.\nSo the only way to test for a list, right now. Is using something like this:\n{% if item.address is sequence and item.address is not string and item.address is not mapping %}\n-- item.address should be a list in here --\n{% endif %}\nTherefore it would be really great to add strict type comparisons. So we could do item.address is dict, item.address is array and item.address is string. Where only the last one is available, right now.. Related to Issue #358 \nThis will be a great feature in jinja.\nI approve \ud83d\udc4d . > list is not a good name as it is not detecting whether the data type is a python list. What's really meant is test_nonstring_sequence but that might be a bit cumbersome to type. In other APIs I've written, I've made selecting whether to exclude string types a parameter of the function but I don't think that jinja tests take parameters from the user so that's not an option here.\nWhat about array? nonstring-sequence would also be true for dicts, which I am guessing is not exactly what we'd want here.. ",
    "mzhang-code": "Oh! I got it. ninja would escape the string by default. \nturn off the escape: {{ content|safe }} and finally got the result as expectation. \n. ",
    "corpix": "I have '%(foo)s \u2014 %(bar)s' in variable and it looks more complex in my template, thats was just example.\nFound the root of a problem, there is another format call without kwargs. Thats causes this issue, sorry it's my fault.\n. ",
    "malthejorgensen": "+1 :+1: This should be noted in the docs (that you cannot define a recursive macro inside a block, for-loop etc.) or fixed.\nI just got caught by this by defining a recursive {% macro %} inside a {% block %}:\n```\n{% block content %}\n{% macro hello(name, counter=3) %}\n  Hello {{name}}!\n  {% if counter > 0 %}\n    {{ hello(name, counter=counter-1) }}\n  {% endif %}\n{% endmacro %}\n{{ hello('Malthe') }}\n{% endblock %}\n```\n. ",
    "ipmcc": "Also doesn't work inside a with block. But does work inside an if.\n. ",
    "topher86": "Per a reddit post yesterday the default cache size was changed to 400 by\nthe author:\nhttps://github.com/mitsuhiko/jinja2/commit/85820fceb83569df62fa5e6b9b0f2f76b7c6a3cf\nWas just proposing this be universally changed in this portion as well for\nconsistency, totally up to the author though ofc\nOn Thu, Aug 28, 2014 at 1:50 PM, Markus Unterwaditzer \nnotifications@github.com wrote:\n\nWhy are you proposing this change?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mitsuhiko/jinja2/pull/362#issuecomment-53765431.\n. \n",
    "njouanin": "Apparently this problem only appears on Mac. Running the same test gist on Linux runs fine.\n. ",
    "delijati": "I get the same error in python3 with this snippet\n``` python\nfrom jinja2 import Environment\nprint(Environment(extensions=['jinja2.ext.i18n']).from_string(\"\"\"\\\n{% trans %}Hello {{ user }}!{% endtrans %}\n{% trans count=users|count %}{{ count }} user{% pluralize %}\n{{ count }} users{% endtrans %}\n\"\"\").render(user=\"someone\")) \n```\n. ",
    "thijstriemstra": "Also running into this using Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) on OSX 10.7.5.\n``` python\n\n\n\nimport gettext\ngettext\n\n```\n\n\n\npython\n  File \"/Users/foo/.virtualenvs/tower-test/lib/python3.4/site-packages/jinja2/environment.py\", line 969, in render\n    return self.environment.handle_exception(exc_info, True)\n  File \"/Users/foo/.virtualenvs/tower-test/lib/python3.4/site-packages/jinja2/environment.py\", line 742, in handle_exception\n    reraise(exc_type, exc_value, tb)\n  File \"/Users/foo/.virtualenvs/tower-test/lib/python3.4/site-packages/jinja2/_compat.py\", line 36, in reraise\n    raise value.with_traceback(tb)\n  File \"<template>\", line 1, in <module>\njinja2.exceptions.UndefinedError: 'gettext' is undefined\n. Getting the same error with Python 3.5.2 and pyqtdeploy (5.7):\npyqtdeploycli: Unable to freeze files: Traceback (most recent call last):\n  File \"/tmp/qt_temp-LVGpmS/freeze.py\", line 104, in <module>\n    freeze_as_data(py_filename, out_filename, embedded_name)\n  File \"/tmp/qt_temp-LVGpmS/freeze.py\", line 36, in freeze_as_data\n    code = _get_marshalled_code(py_filename, embedded_name)\n  File \"/tmp/qt_temp-LVGpmS/freeze.py\", line 77, in _get_marshalled_code\n    co = compile(source, embedded_name, 'exec')\n  File \":/jinja2/asyncfilters.py\", line 24\nSyntaxError: 'yield' inside async function\nWill exclude the files as suggested.. ",
    "fabiankreutz": "The i18n extension of Jinja adds a function install_gettext_translations into the environment: http://jinja.pocoo.org/docs/dev/extensions/#i18n-extension\nThat must be called with the i18n backend that you want to use (python gettext, google app's webapp2_extras.i18n or babel):\n``` python\nfrom jinja2 import Environment\nimport gettext\nenv = Environment(extensions=['jinja2.ext.i18n'])\nenv.install_gettext_translations(gettext.translations(domain, ...))\nprint(env.from_string(...))\n```\n. ",
    "SkyzohKey": "As anyone found an idea for this on Pelican ?\n. ",
    "smartass101": "Not sure if this is related, but maybe jinja2.Environment.install_gettext_callables is required in addition to install_gettext_translations?. ",
    "greyli": "I got the same issue when using Jinja2 2.10 with Python 2.7 on Windows7.. ",
    "jorgesumle": "\nThis happens if the i18n extension is installed but no gettext function is provided\n\nI still didn't solve my issue. How do you provide a gettext function? I mean, what should it cointain?. ",
    "rightfold": "Oh, I had to add the extension to the babel.conf file.\n. ",
    "steph-ben": "For anyone reaching here, the babel.cfg should look like:\n[jinja2: **.html]\nencoding = utf-8\nextensions = jinja2.ext.autoescape,jinja2.ext.with_\n[python: *.py]\n[extractors]\njinja2 = jinja2.ext:babel_extract\nsilent = False\n. ",
    "stonebig": "The commit date is sooner than last release, so I'm surprised not to see it already\n. ",
    "hayd": "Bump! It would be great to push a wheel for the last release (especially if a release is not planned soon).\n. ",
    "kohaugustine": "Dear Naddiseo,\nThank you for your response! Yes the methods you have suggested sound good, especially the first one. However, I'm afraid I dont quite understand what you mean by the seond. Do you mean that I should put '/'.join as a filter in the jinja2 template that I will be rendering from?\nBest,\nAugustine\n. Dear Naddiseo,\nThanks for your suggestion, but we have decided we'd like to go with os.path.join anyways, just to be safe. I think most windows apps still use the \\ even though / is allowed on windows, so it'll still be safer to go with the convention and have os.path.join adapt according to the platform to avoid any issues.\nSomehow jinja_env.filters['path_join'] = os.path.join didn't work; eventually we figured out specifying this custom filter as:\njinja_env.filters['path_join'] = lambda paths: os.path.join(*paths)\nessentially specify a lambda function that serves to invoke the os.path.join. This worked for us. Is Jinja2's filters method unable to accept whole functions/methods directly to use them as filters?\nThank you.\nBest,\nAugustine\n. ",
    "phyng": "``` python\nfrom jinja2 import Template\nd = {\"a\":2, \"d\":1, \"c\":4, \"b\":3}\nprint Template(\"{{ d|dictsort }}\").render(d=d)\nprint Template(\"{{ d|dictsort(false, by='value') }}\").render(d=d)\ns = \"\"\"\n{% for i in d|dictsort(false, by='value')|reverse %}\n{{ i }}\n{% endfor %}\n\"\"\"\nprint Template(s).render(d=d)\noutput:\n[('a', 2), ('b', 3), ('c', 4), ('d', 1)]\n[('d', 1), ('a', 2), ('b', 3), ('c', 4)]\n('c', 4)\n('b', 3)\n('a', 2)\n('d', 1)\n```\n@Naddiseo Thank you! It works.\n. ",
    "benallard": "I'm able to reproduce this with this small example:\n``` jinja\n{% macro a() %}\n  start of a\n  {% call b() %}\n    {{ caller() }}\n  {% endcall %}\n  end of a\n{% endmacro %}\n{% macro b() %}\n  start of b\n  {{ caller() }}\n  end of b\n{% endmacro %}\n{% call b() %}\n inside b only\n{% endcall %}\n{#\n{% call a() %}\n  inside a\n{% endcall %}\n}\n```\nThis works fine as-is, when the last block is uncommented, we get the following traceback:\npytb\nTraceback (most recent call last):\n  ...\n  File \"/usr/lib/python2.7/dist-packages/jinja2/environment.py\", line 894, in render\n    return self.environment.handle_exception(exc_info, True)\n  File \"templates/test.j2\", line 19, in top-level template code\n    {% call a() %}\n  File \"templates/test.j2\", line 3, in template\n    {% call b() %}\n  File \"templates/test.j2\", line 11, in template\n    {{ caller() }}\n  File \"templates/test.j2\", line 4, in template\n    {{ caller() }}\njinja2.exceptions.UndefinedError: No caller defined\n. Small note about the workaround:\nThe new feature of 2.8 is not needed as this is also working fine:\n``` jinja\n{% macro a() %}\n  start of a\n  {% set content=caller() %}\n  {% call b() %}\n    {{ content }}\n  {% endcall %}\n  end of a\n{% endmacro %}\n{% macro b() %}\n  start of b\n  {{ caller() }}\n  end of b\n{% endmacro %}\n{% call b() %}\n inside b only\n{% endcall %}\n{% call a() %}\n  inside a\n{% endcall %}\n```\n. ",
    "manhg": "I think you can work around this, eg by using generator instead of passing a big templateVars.\nAnd instead of looping in the template, you can use Jinja for only HTML inside  tag; do loop in Python. Output to file right after rendering (chunk by chunk); it will help you avoid memory overflow.\n. : ) I'm glad to hear it works.\n. ",
    "vincentping": "@manhg Thank you very much, it works!\n. ",
    "oleksiikholovchuksc": "Cool, thanks.\n. ",
    "pointhi": "oh, i have found out that firebug has reformat the html\n. ",
    "samuelcolvin": "bump, anyone?\n. Thanks for your feedback, perhaps mustache is the safest option.\n. I was intending to use https://github.com/defunkt/pystache\nNo specific sand-boxing but it's not required, mustache is logicless so it can only access the dict you pass it. AFAIK\n. ",
    "patrakov": "In my opinion, jinja sandbox is a joke. Customers will be able to execute non-arbitrary but still harmful code. E.g., {{ 100 ** 1000000 }} is one example of such code. Another example is an infinite loop.\n. ",
    "candlerb": "I am guessing that jinja2 took its operator precedence rules directly from python. This would be reasonable, except that the pipe operator is used to apply a filter, not to do a bitwise-OR of its two operands.\n. ",
    "Digenis": "If it takes the precedence from python,\nthis clarification can fit in a sentence.\nIn my opinion, keeping the documentation shorter by a sentence\ndoesn't justify letting in such an ambiguity.\n. ",
    "djpimp2010": "Fair point, I was under the impression that it was just HTML files that could be served via this function.\nI'm tired, it's been a long day, and I need more redbull !\n. ",
    "Garito": "Sorry, has been kind of 3 month since I publish this issue\nAs you can expect I solve my needs in other ways so I don't have the code\n. Here the template's code stepsForm.html:\n```jinja\n{%- from \"snippets.html\" import metasFacebook with context -%}\n{%- from \"snippets.html\" import metasTwitter with context -%}\n{%- from \"snippets.html\" import cssGenerator with context -%}\n{%- from \"snippets.html\" import jsGenerator with context -%}\n{%- from \"snippets.html\" import formMaker -%}\n{%- from \"snippets.html\" import stepsIndicator -%}\n{%- extends \"base.html\" -%}\n{%- if \"action\" in assets -%}\n  {%- set action = assets[\"action\"] -%}\n{%- endif -%}\n{%- block title %}TimeFounder - {{ form.title }}{% endblock -%}\n{%- if \"metaDescription\" in assets or \"metaFacebook\" in assets or \"metaTwitter\" in assets or \"favicon\" in assets -%}\n  {%- block metas -%}\n    {{ super() }}\n    {%- if \"metaDescription\" in assets and assets[\"metaDescription\"] -%}\n      \n    {%- endif -%}\n    {%- if \"metaFacebook\" in assets and assets[\"metaFacebook\"] -%}\n      {{ metasFacebook(assets[\"metaFacebook\"]) }}\n    {%- endif -%}\n    {%- if \"metaTwitter\" in assets and assets[\"metaTwitter\"] -%}\n      {{ metasTwitter(assets[\"metaTwitter\"]) }}\n    {%- endif -%}\n    {%- if \"favicon\" in assets and assets[\"favicon\"] -%}\n      {{ assets[\"favicon\"] | safe }}\n    {%- endif -%}\n  {%- endblock -%}\n{%- endif -%}\n{%- if \"csss\" in assets and assets[\"csss\"] -%}\n  {%- block styles -%}\n    {{ super() }}\n    {{ cssGenerator(assets[\"csss\"]) }}\n  {%- endblock -%}\n{%- endif -%}\n{%- block content -%}\n  \n\n    {{ stepsIndicator(form.tfGroups) }}\n    {{ form.title }}\n    {{ formMaker(form, tree_dict) }}\n    \n\n{%- endblock -%}\n{%- if \"jss\" in assets and assets[\"jss\"] -%}\n  {%- block scripts -%}\n    {{ super() }}\n    {{ jsGenerator(assets[\"jss\"]) }}\n  {%- endblock -%}\n{%- endif -%}\n```\nThe error is raised on line 57 but the file has only 56. Is this meaning that I can't wrap a block in a if?. @ThiefMaster nice recommendation: THANKS!. ok\nDo you need any other information?\nHow can I help?. @mitsuhiko Thanks: you are so damn fast (and I'm really jealous) :). ",
    "clj": "I have just seen what is perhaps the same oddness that @Garito initially reported.\nAssignments within a single template works as I would expect and as @ThiefMaster showed, however when using template inheritance the block assignments no longer work consistently as they do when not using template inheritance. Testing done using version Jinja2 2.8 from PyPi.\nSingle template\nThis all works:\n``` python\nfrom jinja2 import Environment\nenv = Environment()\nAssignment and block assignment without blocks work as I would expect\nprint(env.from_string(\n    '''1: {% set assignment=\"ASSIGN\" %}{% set block_assignment %}BLOCK{% endset -%}\n       block_assignment={{ block_assignment }},assignment={{ assignment }}\n    ''').render())\nAssignment outisde a block and use inside a block work as I would expect\nprint(env.from_string(\n    '''2: {% set assignment=\"ASSIGN\" %}{% set block_assignment %}BLOCK{% endset -%}\n       {% block a %}block_assignment={{ block_assignment }},assignment={{ assignment }}{% endblock %}\n    ''').render())\nAssingment inside a block and use inside another block, assignments have gone\nout of scope which makes sense\nprint(env.from_string(\n    '''3: {% block a %}{% set assignment=\"ASSIGN\" %}{% set block_assignment %}BLOCK{% endset %}{% endblock -%}\n       {% block b %}block_assignment={{ block_assignment }},assignment={{ assignment }}{% endblock %}\n    ''').render())\n```\nand outputs the following:\n```\n1: block_assignment=BLOCK,assignment=ASSIGN\n2: block_assignment=BLOCK,assignment=ASSIGN\n3: block_assignment=,assignment=\n```\nTemplate inheritance\nWhen using template inheritance however, things change:\npython\nfrom jinja2 import Environment\nfrom jinja2 import DictLoader\nloader = DictLoader({\n    'base': '{% block content %}{% endblock %}',\n    'main': '''{% extends \"base\" -%}\n               {% set assignment=\"ASSIGN\" %}{% set block_assignment %}BLOCK{% endset -%}\n               {% block content %}block_assignment={{ block_assignment }},assignment={{ assignment }}{% endblock %}'})\n            '''})\nenv = Environment(loader=loader)\nprint(env.get_template('main').render())\nwhich produces:\nblock_assignment=,assignment=ASSIGN\nwhich I would expect to produce the same output as case 2 above.\n. ",
    "eshlox": "It works when block assignment is set before extends tag.\n```\nfrom jinja2 import Environment\nfrom jinja2 import DictLoader\nloader = DictLoader({\n    'base': '{% block content %}{% endblock %}',\n    'main': '''\n        {% set assignment=\"ASSIGN\" %}{% set block_assignment %}BLOCK{% endset -%}\n        {% extends \"base\" -%}\n        {% block content %}block_assignment={{ block_assignment }},assignment={{ assignment }}{% endblock %}'})\n    '''\n})\nenv = Environment(loader=loader)\nprint(env.get_template('main').render())\n```\nOutput:\nblock_assignment=BLOCK,assignment=ASSIGN\nOf course it's not a solution for that issue. The extends tag should be the first tag in the template so this is only an example or quick workaround if someone needs that.\n. ",
    "ho-ho-ho": "Had the same issue on arch linux with python 3.4.2\nThe PackageLoader constructor is running the whole script a second time, it's not 2 prints in the script itself.\nUse FileSystemLoader instead and it works fine:\nfrom jinja2 import Environment, FileSystemLoader\nenv = Environment(loader=FileSystemLoader('templates'))\nThe documentation was a little misleading there ;)\n. ",
    "Dotrox": "I have the same issue on Ubuntu 14.04 with Python 2.7.11, Jinja2 2.8  and Flask 0.11.1.\nAnd I am sure that my code runs only once!\nNote: this happens only when I open some page first time after restart of the server! When I update page - templates are loaded once.\n. ",
    "razor-1": "+1\n. @torfsen That sounds reasonable, especially if there is a global way to enable unicodeliterals so that everything is just treated that way.\n. +1 that this should be fixed. If a translator enters an unexpected % you don't want everything failing completely. Pull request created #541 \n. ",
    "torfsen": "I  think the problem here is that the format string itself consists only of ASCII-characters, and such literals are treated by Jinja as (non-Unicode) str instances. But calling .format with Unicode data then fails.\nI can understand the rationale behind using str for pure-ASCII string literals, but it would be nice if there was a way to force string literals to Unicode (like Python's from future import unicode_literals). The syntax could be similar to that of the Autoescape extension:\n```\n{% unicodeliterals true %}\n    {# All string literals are Unicode literals #}\n    {% set foo = \"I'm a unicode literal!\" %}\n{% endunicodeliterals %}\n{% unicodeliterals false %}\n    {# Standard behavior (type depends on content) #}\n    {% set bar = \"I'm a str literal!\" %}\n    {% set baz = \"\u00dcnic\u00f6d\u00eb f\u00f6r th\u00eb w\u00efn!\" %}\n{% endunicodeliterals %}\n```\nAs a workaround you can use the format filter instead. However, it seems that it only supports the old (Python 2) string formatting syntax.\n. ",
    "byoungb": "+1\n. ",
    "The-Compiler": "What about \"Per default included templates are passed the current context, imported templates are not.\"?\n(disclaimer: I'm not a native english speaker either)\n. The Travis failure is unrelated, it happens because Python 3.3 got dropped in wheel (and probably elsewhere too).. Done!. I'm not sure why this ImportError handling was here, seeing that Python 2.6 always has collections.Mapping available. It was added a long time ago (>10 years) in 9bb7e4779182490abc6e1784b0ee63d22b91b11e, so I suppose that was needed for an older Python version but isn't anymore.\n. I'm not sure why this ImportError handling was here, seeing that Python 2.6 always has collections.MutableMapping available. It was added a long time ago (>10 years) in 9bb7e4779182490abc6e1784b0ee63d22b91b11e, so I suppose that was needed for an older Python version but isn't anymore.\n. ",
    "pudo": "Wow, this sentence actually means something different than I thought. I think @davidism's version is very clear. \n. ",
    "ksaylor11": "ditto.\n. ",
    "esonderegger": "I just created a pull request (https://github.com/mitsuhiko/jinja2/pull/395) that should fix this.\nThis is my first time submitting a pull request to a major project. Please let me know if I did everything right.\n. Thanks!\n. ",
    "joshfriend": "I'm experiencing the same error (python 2.7.9 and 3.4.2 with jinja==2.7.3).\n. ",
    "jacebrowning": "@untitaker I'm not certain this is a jinja2 problem, but the exception occurs half a dozen calls into jinja2's stack. I've submitted the same issue to cookiecutter for them to investigate as well. Maybe they're calling an API incorrectly.\n. This was fixed in cookiecutter by casting each object to a string before calling <Environment>.from_string(): \nhttps://github.com/jacebrowning/cookiecutter/blob/05cd9b353793d382bdd1c689f8d705c723352624/cookiecutter/prompt.py#L29-30\nTherefore, this was a cookiecutter bug, but maybe, jinja2 should fail sooner if from_string is passed a non-string.\nFeel free to close if you don't think this is jinja2's problem.\n. ",
    "edouardklein": "Hi !\nThis bug in flask_restplus:\nhttps://github.com/noirbizarre/flask-restplus/issues/187\nis triggered by open_if_exists raising a NotADirectoryError instead of returning None.\nI do not know both codebases enough to have an opinion on whether this is the intended, correct or expected behavior or not, although I lean to the side of this being a bug in Jinja2, as the per the principle of least surprise, I'd have expected the function to return None when the directory that open_if_exists' argument supposedly is in does not exist.\nI will submit a pull request correcting this behavior, If your opinion is that raising the exception is the correct behavior instead, then maybe an update of the documentation is in order, as flask is one non trivial example of client code that expected the 'return None' behavior.\n. It appears that the code I proposed is not python2-compatible, because NotADirectoryError does not exist in python2...\n. OK, so I redefined NotADirectoryError in __compat.py, the travis builds now pass even for Python2. I would be happy if you could consider the pull request.\nThanks :)\n. ",
    "tsopokis": "I had the same issue when bundling the flask app in a pex file. ignoring ENOTDIR works as expected . ",
    "sekimura": "Here's a simplified test to reproduce this case.\ndef test_custom_tests(self):\n        env = Environment()\n        env.tests['more_than'] = lambda x, y: x > y\n        tmpl = env.from_string(\"{{ foo is more_than 1 or bar is more_than 1 }}\")\n        assert tmpl.render(foo=0, bar=2) == 'True'\nThis template will be parsed as:\nTemplate(body=[Output(nodes=[Test(node=Name(name='foo', ctx='load'), name='more_than', args=[Or(left=Const(value=1), right=Test(node=Name(name='bar', ctx='load'), name='more_than', args=[Const(value=1)], kwargs=[], dyn_args=None, dyn_kwargs=None))], kwargs=[], dyn_args=None, dyn_kwargs=None)])])\nNote: the position of \"Or\" and first args param. It's basically a equivalent of {{ foo is more_than(1 or bar is more_than(1)) }}\nIt's fine if tests get args with parenthesis .\ntmpl = env.from_string(\"{{ foo is more_than(1) or bar is more_than(1) }}\")\n        assert tmpl.render(foo=0, bar=2) == 'True'\nwhich generates\nTemplate(body=[Output(nodes=[Or(left=Test(node=Name(name='foo', ctx='load'), name='more_than', args=[Const(value=1)], kwargs=[], dyn_args=None, dyn_kwargs=None), right=Test(node=Name(name='bar', ctx='load'), name='more_than', args=[Const(value=1)], kwargs=[], dyn_args=None, dyn_kwargs=None))])])\n. ",
    "jmedinar": "Might not be the best answer but it worked! \npython\n{% if grains['id'] == 'id1' or\n   grains['id'] == 'id2' or\n   grains['id'] == 'id3'\n%}\nAlthough I was looking for something like \npython\n{% if grains['id'] == 'id*' %}\n. ",
    "codyaray": "Thanks @mitsuhiko!. ",
    "chadwhitacre": ":)\n. ",
    "citizen-stig": "I've tried to use get_corresponding_lineno, but it seems that it doesn't work\nhttp://stackoverflow.com/questions/37032085/jinja2-template-get-corresponding-lineno-doesnt-work\n. ",
    "dongyuwei": "when I Google jinja template source map, I got this issue link :) \nBut my requirement is different: I just wan to know which partial templates rendered the html segments in browser(one to one mapping).  So I ended up hacking the  jinja2/loaders.py source code like this: \nhttps://gist.github.com/dongyuwei/7f80f0589fbafa0706d741370207796b#file-loaders-py-L178\nIt works as expected.\n. ",
    "shawnbot": "Right, but the /docs/ URL just redirects to /docs/dev/, so what's the difference? Are you saying that 2.8 is the development version? Because that could be clearer in the docs.\n. Gotcha, thanks. It's clearly a lot more complicated. :)\n. ",
    "ColdHeat": "I'm also affected by this and it took some time to nail down the issue. \nIt doesn't seem intuitive that FileSystemLoader would not respect the differences in filesystems between operating systems. It makes more sense to use os.path.join (which will result in \\\\ on Windows) instead of \"/\".join(). \nIf this is as intended and is a definite wont fix can we be more clear about what is the actual issue instead of TemplateNotFound since under normal conditions Python would find the template? \n. In that case, it would seem to me that FileSystemLoader should be loading off of a file system path instead of a template path. \nAnd I don't understand how increasing my consistency would help Python do the right thing when the affected code uses os.path.join which will use os.sep which on Windows will output \\\\. \n. ",
    "longfin": "IMHO, using \\ in template path is not intended.\nhttps://github.com/mitsuhiko/jinja2/pull/303#issuecomment-45355697\n\nYou should always be using / in templates no matter what OS.\n. \n",
    "sbdchd": "I thought it might work after looking through if expressions in the docs and seeing the following example.\n{% extends layout_template if layout_template is defined else 'master.html' %}\n. ",
    "cboos": "Note that the Jinja2 docs for if expressions also says:\n\nThe else part is optional. If not provided, the else block implicitly evaluates into an undefined object:\n\nSo the include has to be completed that way, in your original example:\nhtml+jinja\n{% include 'message.html' if self.title() != \"Login\" ignore if missing %}\n. +1, as I also got bitten by this... \nSince the doc gives this example:\n\njinja\n{% set navigation %}\n   <li><a href=\"/\">Index</a>\n   <li><a href=\"/downloads\">Downloads</a>\n{% endset %}\nThe navigation variable then contains the navigation HTML source.\n\nThis really makes you expect that you'll get non-escaped HTML when using it, like you'd get for a macro.\n. ",
    "Cabalist": "I think this should be reevaluated as Python3 has a much higher acceptance rate these days.  Especially for beginners.  The pull request makes sense.. ",
    "RevengeComing": "i noticed i cant use blocks in a file included and expand it in extended file right now ... is it possible to be fixed ?. Its the same issue as DaNNaD's issue .... ",
    "lkarthee": "@untitaker Sorry my mistake.\n. @untitaker I have made changes you have requested \n- move testsuite directory to root\n- merge fixtures and conftest\nTravis is failing while searching for doctests - it is working in my local machine. Can you help ?\n. There was a doctest suite which  used to run only on PY2. https://github.com/mitsuhiko/jinja2/blob/master/jinja2/testsuite/doctests.py\nThats the reason i added --doctest-modules option. I will remove then.\n. Thank you @untitaker reviewing and merging :+1: \n. thank you \n. ",
    "axil": "My response is that {{ firstof(obj1, obj2, obj3) }} is more readable and straightforward than {{ [obj1, obj2, obj3]|select|first }}.\nIn my opinion, templates are just about that. Otherwise we would still use c with sprintf and %s notation :)\nIt's completely upto the author to decide. If he still considers it unnecessary, I'd suggest at least creating somewhere in the docs a table for translation of common django tags into the jinja tags.\n. Another agrument is that both itertools.groupby and django's regroup keep ordering intact, so they don't have such a problem.\n. ",
    "StriveForBest": "Having firstof in jinja2 would be extremely helpful \ud83d\udc4d \nThanks for trying @axil . {{ foo.bar.baz }} raises AttributeError if foo doesn't have bar or bar.baz attribute @ThiefMaster . @ThiefMaster  you are correct, this is not related to this PR. But definitely Django's firstof has chained getattr with fallback built-in and I, personally, find it very handy.\n. ",
    "dstufft": "I went ahead and implemented this in #434 and verified it solves the problem I was having.\n. I have an object that represents a translated string but which requires access to the request in order to actually translate it. So without finalize I need to do something like this:\n<p>{{ translation_string_obj.translate(request.translator) }}</p>\nHowever, if I can access the context from within the finalize function, then I can write a finalize function like this:\n``` python\n@contextfunction\ndef translate_value(ctx, value):\n    if isinstance(value, TranslationString):\n        return value.translate(ctx[\"request\"].translator)\nreturn value\n\n```\nwhich means that my template can be written like:\n<p>{{ my_translate_string_obj }}</p>\nand things will just work. All of the other solutions that I can come up with involve needing to either manually pass the translation string object through a translator filter or function inside of the template, or requires storing the current language inside of a thread local variable so that the finalize function can access it since it cannot access the context to get the request out of it.\n. Thanks a lot @mitsuhiko !\n. ",
    "alvaroaleman": "I do not agree here. Tests and comparisons may differ in how they are declared, but they have the exact same purpose: Be a test in a conditional statement.\nIf someone reads the docs and finds one of either tests or comparisons, he or she will be led to believe there are no other conditional statemens available.\n. Is it expected behaviour to have the default filter crash with a nullpointer exception?\nIsn't it the whole point of that filter to catch such exceptions?\n. ",
    "kunaldeo": "Looks like it was string escape issue at my end. Closing the bug.\n. ",
    "luanfonceca": "Thanks for that @davidism!\no/\n. ",
    "jgmize": "Updated to simplify the code.\n. > What about the other brackets? { [ <\nGood point, @davidism. I've updated the PR to handle those brackets as well, along with some performance optimizations.\n. ",
    "kelvintaywl": "@untitaker i'm not sure how the reason given meant that this PR should be closed. but... no problem\n. ",
    "schmilblick": "I was also looking in to this, I saw that it was mentioned in issue #328 that got closed. \n. ",
    "jespino": "After almost 3 years, and after almost 2 years without feedback, I close the PR.. ",
    "steelman": "Re 1: Indeed, I didn't check the details.\nRe 2: I haven't seen this anywhere in the documentation and I am new to Jinja enough not to know which parts of it are common with Python. Too bad it doesn't work.\nTraceback (most recent call last):\n  File \"foo.py\", line 526, in <module>\n    timeoffs = timeoffs,\n  File \"/usr/lib/python2.7/dist-packages/jinja2/environment.py\", line 894, in render\n    return self.environment.handle_exception(exc_info, True)\n  File \"templates/weekly_for_hq.html.j2\", line 83, in top-level template code\n    {# Staff #}<td>{{ set(engineers)|sort|join(', ') }}</td>\njinja2.exceptions.UndefinedError: 'set' is undefined\nRe 3: I thought about it. However, I prefered sorted output anyway so I came up with something simmilar to sort -u.\n. ",
    "catharsis": "Added a PR with suggestion on doc-change, if that's the way to go.\n. ",
    "bentimms": "Should I close and resubmit this pull request?\n. ",
    "ztane": "I guess a fix for the first case would be:\nif (PY2 and hasattr(ctypes.pythonapi, 'Py_InitModule4_64') or \\\n   (PY3 and ctypes.sizeof(ctypes.c_void_p) == 8):\n    _Py_ssize_t = ctypes.c_int64\nelse:\n    _Py_ssize_t = ctypes.c_int\nsince in Python 3 Pyssize_t should now match sizeof void *.\n. Before applying the pull request, the tracebacks produced would be of type\nFile \"./foo.html\", line 1, in <module>\n    {{ 1 / 0\u00a0}}\nZeroDivisionError: division by zero\nAfter applying the pull request,\nFile \"./foo.html\", line 1, in top-level template code\n    {{ 1 / 0\u00a0}}\nZeroDivisionError: division by zero\nAlso, wrong typing of the reference counter can create hard to catch bugs on 64-bit big endian platforms.\n. ",
    "sametmax": "Generators are compatible with await (https://www.python.org/dev/peps/pep-0492/#id43), you just have to wrap them in @coroutine. Plus, the idea is not to have one render() method doing both sync and async processing, it would mix paradigm and it wouldn't work.\nIt shoudln''t change the API, but add a separate rendering method : \n- a configuration hook to choose an async backend\n- a arender() methode returning the deferred/future/promise implementation for this backend\nI understand that if you don't use asynchronous web framework, it's will not appeal to you.\nHonestly, jinja is fast enought that most of the time you don't need to care if it's blocking the event loop. Right now we by pass the fact it's synchronous by fetching the data asynchronously before, and the pass the result to the renderer.\nThe only time it's a problem is when : \n- you have caching, because you moved the data fetching outside of the template, any template caching solution becomes useless and you are forced to use a data caching solution. For small projects it's a bit overkill.\n- you have very big templates, and you don't want to block the event loop for the whole template generation, but sill wish you could give some CPU time to a chunk or two here and there.\nThere is no hurry for this feature.\nIt's just that Jinja is the best template engine in Python, but we don't have any decent async way to render a template while JS has had it for years.\n. ",
    "amirouche": "\nNot going to happen for a wide variety of reasons\n\nhttp://jinja.pocoo.org/docs/2.9/api/#async-support. ",
    "merwok": "Thanks!  I see \u201cThis pull request is closed, but the merwok:patch-1 branch has unmerged commits.\u201d  I guess I can ignore that?  I see both of my changes in your commit.\n. Right.  Fixed.\n. ",
    "tima": "Ansible also implements a to_json and a to_nice_json (pretty JSON) filter to Jinja2. See around line 64 here: https://github.com/ansible/ansible/blob/e07dde1a3ce88f4ba21f779f4c2cb2d78397f34b/lib/ansible/plugins/filter/core.py#L64\n. ",
    "moigagoo": "What's missing to merge the PR?\n. ",
    "rbflurry": "Is there a workaround for this? It still seems to be broken.. ",
    "hackebrot": "From what I know you pass these settings to the Environment initialization.\nSee https://github.com/mitsuhiko/jinja2/blob/9b4b20aa56fde3a5cd5ac49d4feacd96eacb832d/jinja2/environment.py#L143\nAnd https://github.com/mitsuhiko/jinja2/blob/master/tests/test_lexnparse.py#L444\n. ",
    "sciyoshi": ":+1: for the feature. One note is that any built-in JSON filter should properly handle escaping characters like <, >, and & so that it can safely be used inside <script> tags. (See Flask's code here: https://github.com/pallets/flask/blob/master/flask/json.py#L161)\n. ",
    "Talkless": "@snoack Are you yet interested in fixing this PR?. ",
    "Phlip": "LGTM\n. ",
    "pydanny": "@untitaker As far as I can tell, no modern Django tutorial or reference uses ifequal anymore. No project created in the past two years has used it, and many older ones have converted to the cleaner, jinja2-style dialogue. It's only kept for backwards compatibility and it should arguably be removed from the Django template language.\nIn fact, you inspired me to file https://code.djangoproject.com/ticket/25236 :wink: \n. ",
    "cmacmackin": "I can confirm this bug. \n. ",
    "tark-hidden": "Hey guys. This issue has been opened more than month ago.\nThis can be fixed by adding almost the same function implements_iterator in code block if not PY2 in _compat.py.\ndef implements_iterator(cls):\n        cls.next = cls.__next__\n        return cls\n. Sorry... Seems like I cannot understand what are you talking about. Should I write the test which will fail without this fix? Or should I write some simple use case which raise a error?\nIn a current github release tests_api.py contains the code for testing Cycler a \"right\" iteration way.\ndef test_cycler(self, env):\n    items = 1, 2, 3\n    c = Cycler(*items)\n    for item in items + items:\n        assert c.current == item\n        assert next(c) == item\n    next(c)\n    assert c.current == 2\n    c.reset()\n    assert c.current == 1\nYou see? Here is next(c), not c.next() in http://jinja.pocoo.org/docs/dev/templates/#cycler . This test is passed in both cases.\n. I think, adding next = __next__ is the best choice! :) Sadly but I didn't thought this way.\n. And I'm very sorry, I was wrong. In Python 2.7.3 current release works fine, as expected.\n. In that case test will be failed, there are two iteration ways... I'm sorry, right now I can use only web for pull request and I do not know how to squash commits here.\n. ",
    "scharfmn": "It was my error. (I assume the other fellow who reported the issue made a\nsimilar error.)\nI tried to retract my comment; I guess it stuck.\nThank you very much for checking.\nOn Wed, Sep 9, 2015 at 10:39 AM, Adrian notifications@github.com wrote:\n\nHow is this a jinja issue? You have {{ in your string which has a special\nmeaning in Jinja.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mitsuhiko/jinja2/issues/477#issuecomment-138931445.\n. \n",
    "ashishsingal1": "Weird, but this actually helped me. Thanks for posting it.\n. ",
    "virtuald": "+1, this was unexpected. At the very least, should have a documentation note about this.\n. @mitsuhiko I didn't read his example above, I agree that it should break -- but what about this example?\n{{ missing.subelement|default('no') }}\nThis seems like it should work, and it does not.\n. ",
    "squfrans": "i see the same issue and because of this we cannot use compiled templates\nin production. a fraction of the requests would fail with exceptions about\nnot finding finalize, get_templates and other attributes.\nunfortunately i can reproduce it only in our live environment (maybe because\nof the request volume) and that is not the best debugging environment.\n. i am sorry this is getting closed, but as i am not able to provide more information, can't really complain.\nhowever, as it was 100% reproducible in our live environment, it seems a bit dangerous to keep this feature without any kind of caveat for the users.  it's not big fun to deploy this to 100k live users and start seeing mysterious 500s.. i am referring to the feature of compiled templates (not necessarily the template loader, the errors were runtime errors while the template was being rendered).\njudging by the fact that there is only 2 people experiencing this issue, i am inclined to agree that it must be working for the majority of the users :}  unfortunately i cannot use them, exactly in a high traffic website where the gain would be the biggest.. i can see a lot of extra IO after adding line 175 to loader.py:\npython\n167     def get_source(self, environment, template):\n168         pieces = split_template_path(template)\n169         for searchpath in self.searchpath:\n170             filename = path.join(searchpath, *pieces)\n171             f = open_if_exists(filename)\n172             if f is None:\n173                 continue\n174             try:\n175                 print(\"FileSystemLoader: reading file %s\" % filename)      # <----\n176                 contents = f.read().decode(self.encoding)\n177             finally:\n178                 f.close()\n. ",
    "jkrebs": "@mitsuhiko Can you suggest any debug code I can add to diagnose or create a test case?\nI am lost because it only happens in a fraction of requests and in a way that I have not been able to reproduce.. > I assume this always happens with Environment.compile_templates?\nI have never experienced the problem during Environment.compile_templates.\n\nI imagine that this could happen if you have an application that shuts down execution but outstanding HTTP requests are still in the air.\n\nThis may well be the case. I am deploying to the Google App Engine environment which can shut down application instances at any time.\nI will deploy your suggestion and report back if the exception reoccurs.. ",
    "bool-dev": "Just started seeing this as well. Flask app is deployed through uWSGI. I keep getting this: \nt_1 = environment.filters['int']\nAttributeError: 'NoneType' object has no attribute 'filters'\n\nand always on the same precompiled template.\nUpdate 1:\nDid a fresh pre compile of the templates, and restarted app. Haven't seen the error again since. I will update in another 24 hours again.\nUpdate 2:\nSo, looks like the error is gone. Has not occurred even once since the fresh pre compile.. ",
    "donkopotamus": "I'd be very interested in seeing this implemented ... this is one of the features in mako that I very much miss in jinja2.\nIf we were to translate the equivalent mako implementation to jinja it would appear something like:\n```\n{% macro form(footer) %}\n    \n        {{ caller() }}\n        \n            {{ caller.footer() }}\n        \n\n{% endmacro %}\n{% call form(...) %}\n    ...body...\n    {% macro footer() %}\n       ...footer...\n    {% endmacro %}\n{% endcall %}\n```\nIn mako, it seems that a macro within a call block (a def in mako parlance) gets lifted to become an attribute on the call block.  If my understanding is correct, this would not be appropriate in jinja, which treats the call block effectively as a macro, meaning the embedded macro is part of the local closure. \nWhat if there was some kind of tag, eg submacro or attribute that could be placed within a call (or macro!), and lifted its definition up to become an attribute on its container?\n. I think I'm arguing for almost exactly your syntax, just with an end tag included :-), oh and I guess that it becomes an attribute on caller, rather than another named argument in the macro.  Making it an attribute on caller would help prevent clobbering the local namespace.\n. It feels like we are trying to meet an expected interface from the macro we are calling ... so what about something like implement, or using?\neg\n{% call form(...) %}\n    ...body...\n    {% using footer() %}\n       ...footer...\n    {% endusing %}\n{% endcall %}\n. Good argument, I like as\n. ",
    "fusionbeam": "After some further digging, I found out that this can be achieved by making jq_document_ready a property of flask.g\n. ",
    "urbaniak": "Got the same issue, are we planning to do something with that?\n. ",
    "iceb0y": "Encountered the same problem. The FileSystemLoader is reading disk even if the template is in cache due to some logic error in Environment._load_template() introduced in 6671b9. It is deadly in a purely async web server. Downgrade to 2.7.3 for now.\n. I think this need to be fixed in 2.8.1...\n. It seems that cache key should be some weak reference to the loader. By using id() you have the potential risk that a new cache having a same address gets old content from the cache.\n. @pgjones weakref.ref() seems most suitable for this case. And it's even better to remove the cache entries when a loader is destroyed.\nPersonally I hate using hash() this way, where there will be one in a million case that the hash collides and some mysteries strange behavior appears.\n. What about cache_key = (self.loader, name)?\nThis avoids string conversion and hash collision.\n. ",
    "eli-collins": "490 alone would definitely solve all my use-cases; if that was pushed through, I'd be happy whichever way you end up deciding this issue.  Without the frequent need to use a 'safe' filter, the block filter syntax is probably more than sufficient for the remaining edge cases that I can think of.\n. If/when this does get implemented, I think something deeper is off about the 'block set' implementation that probably needs addressing at the same time...\nOver in issue #486, it was suggested to use a {% filter safe %} block as a workaround, until either support for either 486 or this issue was complete. \nHowever, the {% filter safe %} workaround yielded a surprising (to me) result:\ndef test_set_block(self):\n    env = Environment(extensions=['jinja2.ext.autoescape'],\n                      autoescape=True)\n    tmpl = env.from_string('{% set foo %}{% filter safe %}<br>{% endfilter %}'\n                           '{% endset %}{{ foo }}')\n    result = tmpl.render()\n    assert result == '<br>', result\nAs of v2.8, this renders &lt;br&gt; instead of the expected value... I'm guessing somewhere the input to the block set is being forcably escaped, despite the filter returning an html-safe string?\n. I've tried tracking this down myself, but I'm having difficulty figuring out how to get a dump of the python source generated by the jinja compilation process (if that's in fact where the problem lies).  I'd definitely appreciate any pointers.. ",
    "aartur": "One possibility is that the floats are too big to be accurately represented but Python's repr has no problems with them:\n$ python -c 'print repr(1441712583.216615)'\n1441712583.216615\n. Ok I found the reason: Jinja uses str(float_val) which does the rounding, while repr(float_val) has higher precision by a few digits. And since interactive Python shell uses repr to print values I expected Jinja to have the same precision.\nSo it probably isn't Jinja's bug, but weird Python's discrepancy. Maybe Jinja should use repr, but I see an explicit check for float:\ndef visit_Const(self, node, frame):\n    val = node.value\n    if isinstance(val, float):\n        self.write(str(val))\n    else:\n        self.write(repr(val))\n. Jinja isn't only used to directly produce \"customer facing representations\". Even when it's used to produce HTML, there are major usages (data-* attributes,  elements, Javascript fragments) for which you want a higher precision for floats. it's also advertised as working good not only for HTML, and indeed it's widely used for things like source code or configs (Salt and Ansible).\nFor me the behavior of str(float_val) (using up to exactly 17 digits of representation) is weird and I don't see reasons, other than being easy to implement in CPython, that it was chosen.\n. ",
    "darkryder": "Ping.\nCould someone please tell why float values are being rendered using str and not repr?\n. Review please?\n. ",
    "Skuzzzy": "@darkryder str is more appropriate to use in this case. Typically str is used for customer facing representations of objects while repr is typically used for dev/debugging. str is meant to be human readable, while repr is meant to be unambiguous as possible.\nMaybe this is something that a setting could be set for, but I think that using str is appropriate default behavior.\nedit: Here is a decent discussion of str vs repr http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python\n. https://github.com/mitsuhiko/jinja2/blob/b78f2617b04cc549ed5fea4eca944c4d8054d187/jinja2/utils.py#L187\nComment: The documentation in the code seems to differ from the documentation on the website.\nWould changing the urlize behavior to accept valid urls be something people are interested in?\n. ",
    "micw": "I see, you're right. I just misinterpreted it as \"iterate 10...users|count\" what it does not (and was not meant to do so).\n. ",
    "aaugustin": "I just hit this issue as well.\nMy workaround:\n```\n{% set foo %} ... {% endset %}\n{% set foo = foo | safe %}{# workaround for https://github.com/pallets/jinja/issues/490 #}. Thanks Armin!. Indeed it could produce an unsafe string, all the more since Jinja2 disables autoescaping by default.\nI reversed this default in Django's Jinja2 backend; this could be an argument for making the change only in Django's Jinja2 backend and not in Jinja2 itself.\n. I also brought up the question on the django-developers mailing-list: https://groups.google.com/forum/#!topic/django-developers/UVCc9CyGZaA\n. ",
    "mirzadelic": "I modified post..\nOn this line i get that error:\n{{ form.name(class=\"form-control\") }}\nand view:\n```\ndef cat_filter_form_tag(request, parent_category):\n    form = SimpleCatFilterForm(parent_category, request.GET)\n    return render(request, 'web/category_ads/filter_form.html', {\"form\": form})\n```\nDo you need more info?\n. My form is:\nclass SimpleFilterForm(forms.Form):\n    name = fields.CharField(label=_(Name'), required=False)\ndon't know what is wrong here?\n. Ok, thanks.\n. ",
    "zoidbergwill": "Are you trying to override the class arg and hoping it gets sent to fields.CharField(label=_(Name), required=False)?\nIf you want simple integration with Django and Bootstrap, maybe try using django-crispy-forms.\n. It's probably because {% is ambiguous and could be the beginning of a Jinja2 tag.\nYou probably wanna try look at the Escaping docs.\nYou probably want something like:\n<%for(var system in data){{ '{%' }}>\n        <ul>system: <%=system%></ul>\n    <{{ '%}' }}%>\nBecause then Jinja2 will output the HTML you expect for template.js.\n. ",
    "ughitsaaron": "@ThiefMaster because this is the wording already used in the readme (not to mention that it's less clumsy)\n. ",
    "berrange": "@ThiefMaster all the text in the PR was just automatically included by github from the commit message https://github.com/berrange/jinja2/commit/91255f86f6dc3b828142cc339155bcb5a7797486\n. ",
    "glasserc": "The point of using autoescaping is that I don't want to have to put a filter on every single variable expansion.\nOur use case is to write configuration files for our microservices. We have a \"template\" included with each service and we want to fill it with per-environment configuration which is specific to that template. I agree that using YAML directly is cleaner, but we couldn't find a generic \"engine\" that knows how to replace variables that it doesn't already know the location of. (There are YAML aliases and references, but they're not really a good fit for this -- they're more for serializing cyclic structures.) There are ways I can think of to get this to work using YAML, but they're kind of hacky too. This setup also gives more control to the kinds of substitutions that we can perform, although in practice we don't really use that for anything.\n. This is very helpful, thanks! I feel like autoescaping is still an OK approach to solving this because you can e.g. flag variables as |safe. But I concede that conceptually, this isn't really like autoescaping, because we're not just ensuring that variables are valid YAML, but formatting them in a certain way. I'll write an extension.\n. The first part of my solution was the extension that runs all variable calls through a filter. This is the bare minimum that I needed to get that working.\n``` python\nimport jinja2.ext\nfrom jinja2.lexer import Token\nclass YAMLEverythingExtension(jinja2.ext.Extension):\n    \"\"\"\n    Insert a |yaml filter at the end of every variable substitution.\nThis will ensure that all injected values are converted to YAML.\n\"\"\"\ndef filter_stream(self, stream):\n    # This is based on https://github.com/indico/indico/blob/master/indico/web/flask/templating.py.\n    for token in stream:\n        if token.type == 'variable_end':\n            yield Token(token.lineno, 'pipe', '|')\n            yield Token(token.lineno, 'name', 'yaml')\n        yield token\n\n```\nThis could be smarter, for example it could try to skip inserting the filter if it sees a safe or yaml filter explicitly in the variable block. But I never ended up needing/having time for that.\nThe second part is the filter itself. Just using yaml.dump wasn't sophisticated enough, so I had to poke around the yaml internals a little bit.\n``` python\nimport cStringIO\nimport yaml\ndef yaml_filter(val):\n    \"\"\"Serialize some value in isolation, not as part of any document.\nWe can't just use yaml.dump because that outputs an entire document, including newlines, which isn't helpful for\ninserting into a YAML document.\"\"\"\nif isinstance(val, jinja2.Undefined):\n    val._fail_with_undefined_error()\nstream = cStringIO.StringIO()\ndumper = yaml.dumper.Dumper(stream)\ndumper.open()\nnode = dumper.represent_data(val)\ndumper.serialize(node)\n# The serialized node tends to have a \\n at the end.  The template might not\n# want a \\n inserted here, e.g. if two variables are on the same line, so\n# strip.\nreturn stream.getvalue().strip()\n\n```\nThis ties it all together, including making sure that the filter of the given name is available in the environment:\n``` python\nfrom jinja2 import loaders\nfrom jinja2 import Environment, StrictUndefined\ndef get_environment():\n    \"\"\"Create a standard Jinja environment that has everything in it.\n    \"\"\"\n    jinja_env = Environment(extensions=(YAMLEverythingExtension,),\n                            # some other options that we use at work\n                            loader=loaders.FileSystemLoader(['.', '/']),\n                            undefined=StrictUndefined)\n    jinja_env.filters[\"yaml\"] = yaml_filter\n    return jinja_env\n```\n. ",
    "pigmej": "@glasserc did you succeed with this extension ? I have similar problem, can you point out for solution / share some ideas ?\n. ",
    "calder": "This would still be great for escaping non-HTML templates. I'm using Jinja2 to generate JSON, and want to use JSON escaping instead of HTML escaping.\n. I guess that makes sense. :-) I'll close #571.\n. ",
    "willkg": "What would the behavior of \"with context 'something'\" do here? I don't see any issues in the tracker for that (maybe I searched for the wrong things?) so I'm not sure what it would do or what the use cases for it are.\n. @ThiefMaster ^^^ What would the behavior of \"with context 'something'\" do here?\n. Ahh... ok.\nI haven't experienced a case where I've needed to provide context for a block of text. It's usually only a problem with very short strings. Is there a compelling use case for this?\n. ",
    "thor": "Seeing as this has been a dormant issue for quite some time I'm wondering whether there's anything in particular that makes this a tricky issue, say, if I wanted to give it a go?\nI'm fairly sure willkg's own code he's referring to is puente, which is useful and neat, but hasn't been updated in a while. At the same time there's django_jinja trying to bridge the gap for Django and Jinja2 users, and both do their own monkey-patching to enhance the extraction of messages, both with their own limitations.\nEither way, what I'm trying to get at is: are there elements holding this back as a possibility? Similarly to Django, would a trimmed option be feasible? Are there principles against this?. ",
    "matthewrsj": "@ThiefMaster that is a good solution. Is this a filter you would be interested in for Jinja2?\n. True, but if it is just an autoclose I could just implement a simple version of a stack and shouldn't need any new libraries.\n. ",
    "BradMclain": "Solved: was missing include_package_data=True in the setup.py. This is why this was working when installed locally but not once packaged and moved to another machine.\nSorry to trouble you.\n. ",
    "Raveline": "I'm sorry to anser to this more than one year later, but I also got fooled by this (I had no package_data in my setup.py). It might be a good idea to add a line or two about the fact that package setup must be able to include the templates in the documentation on PackageLoader, since it's quite easy to forget.. ",
    "brmzkw": "I need to use notequalto in a select filter, such astring.split('/') | select('notequalto', ''). In this case, using is not equalto something doesn't seem possible. Is it?\n. You save my day. I didn't know rejectattr (or reject in my case) existed. Thanks a lot :)\n. ",
    "hamishtaplin": "I'd love to see this merged, coming from Twig it would make Jinja so much easier to work with as the current solution of just declaring variables with set outside the include is super clunky.\n. ",
    "chuwy": "Just a heads up @mitsuhiko \nI have no idea why, but  do_urlencode still doesn't escape slashes, while unicode_urlencode works as expected.\n```\nPython 3.4.3 (default, Oct 14 2015, 20:28:29)\n[GCC 4.8.4] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nimport jinja2\njinja2.utils.unicode_urlencode(\"http://url.by\", for_qs=True)\n'http%3A%2F%2Furl.by'\njinja2.filters.do_urlencode(\"http://url.by\")\n'http%3A//url.by'\njinja2.version\n'2.9.dev'\n``\n. I believe this is standard behaviour for function intended for encoding urls. Tools like http://meyerweb.com/eric/tools/dencoder/ behave this way. Also I have at least one tool inside our company which expects URLs being passed inside GET requests with escaped slashes.\nAlso, I don't understand whyunicode_urlencode[called](https://github.com/mitsuhiko/jinja2/commit/46acbf02ed9ab58c7a92553c95790e75bdc3c930#diff-33dcdc15f917259c644200be7d924eb0R97) insidedo_urlencodewithfor_qs=True`.\nMay be I understand something wrong.\n. Ok. Thank you Armin.\n. \n\n\n",
    "linwukang": "Hi, I got a same trouble with reject slash, here is the code:\n\n\n\njinja2.Template(\"{{ disks|reject('sameas', '/')|list }}\").render(disks=[\"/\", \"/mnt/disk0\", \"/mnt/disk1\"])\nu\"['/', '/mnt/disk0', '/mnt/disk1']\"\n\n\n\nI want to reject root disk, but it not work anymore, how to solved it?\n. Still not work for me, @ThiefMaster, would the a python issue? what's the version of python you used.\nPython 2.7.10 (default, May 23 2015, 09:44:00) [MSC v.1500 64 bit (AMD64)] on win32\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    >>> import jinja2\n    >>> jinja2.Template(\"{{ disks|reject('sameas', '/')|list }}\").render(disks=[\"/\", \"/mnt/disk0\", \"/mnt/disk1\"])\n    u\"['/', '/mnt/disk0', '/mnt/disk1']\"\n    >>> jinja2.__version__\n    '2.8'\n. Yes it works, I'm not family with Jinja2. Thanks, @ThiefMaster \n. ",
    "MartinNowak": "\nSo the only part where a slash actually makes sense encoding is in query strings and this is where the dict based encoder that urlencode has works like that. However even there a slash does not have to be encoded, so there is no reason to force it to be encoded.\n\nNo, for example you need to encode / in usernames and passwords as well.\nIt's the reason why JS has encodeURI and encodeURIComponent.. ",
    "danielkza": "Ansible uses Jinja, and it's pretty common to handle security credentials when setting up systems. I just hit a case where an automatically-generated password contained a slash that was not replace by urlencode to generate a database URL, which is pretty unfortunate. While breaking current behavior would be problematic, why not introduce a second filter that does escape the slashes?. @ThiefMaster Are use cases other than constructing HTML templates irrelevant when determining what is useful to be included in Jinja itself? For example, the Saltstack project, with similar purpose to Ansible, also uses Jinja for templating, and would benefit from the same change. . @mitsuhiko Why does Jinja include any built-in filters then? I can only guess it is because they're useful in multiple use cases. I used Ansible and Salt as two examples of where being able to escape slashes in URLs is desired, and hence, it would be valuable to have it available for everyone.\nWhat about adding a safe argument to urlencode, as Python's urllib.url_quote has, so that by default slashes are preserved, but in a way that can be easily overriden?. ",
    "ahuffman": "I hit this issue when trying to create a file in a gitlab repository via API calls.  The gitlab api requires the slashes to be encoded.  To make this work I do:  {{ myvar | urlencode | regex_replace('/','%2F') }}.  I'm working with Ansible and Jinja2 filters in my playbook tasks.  This could be a workaround for those of you hitting this, as I validated it works.. ",
    "eastside": "My understanding was that {% trans %} was a wrapper for gettext. And indeed, the same error results when using {% trans %} tags.\n. ",
    "stevelacey": "More specifically, maybe I am asking, how do I use nodes.Include when I don't have the template or its nodes, it accepts template as its first argument but doesn't seem to want a nodes.Template (or at least the kind I am building).\n. @mitsuhiko any thoughts? Thanks in advance!\n. http://stackoverflow.com/a/34181507/160821\n. ",
    "damz": "@stevelacey Take a look at the example extension in the documentation. I think it will take you 90% of the way there.\nA nice trick of the jinja2 extension API is that nodes.Callblock(self.call_method(...)) which allows the generated code to call back to your extension.\nIn your case you should be able to do just do something like this in your called function:\npython\nreturn self.environment.get_template(template_name).render(content=caller())\nIn any case, when confused, don't hesitate to look at what Jinja2 is seeing:\n- Print the AST of the generated template with ast = env.parse(template_data, name, template_filename); print ast;;\n- Print the generate Python code: code = env.compile(ast, name, template_filename); print code\n(Where name and template_filename can be arbitrary strings.)\n. ",
    "AlJohri": "I'm running into almost exactly the same issue as @stevelacey. In Steve's case, he's trying to return a nodes.Import which can be mocked by returning self.environment.get_template(**).render(**) instead. What I'm trying to do is essentially wrap the import xx as yy and from xx import zz tags into extensions. I would like to change xx in the previous examples based on the context. In other words, I would like to change the name of the template being imported based on the context.\nIt seems like there is no way to modify the AST once it is parsed. What I want to do is when visit_CallBlock is run, modify the AST to return a proper nodes.ImportNode and have the compiler handle it.\nIs there anyway to inject additional nodes into the AST at compile time? cc @mitsuhiko \nThanks!. Ah, okay - that makes sense.\nI'm mocking the functionality of the nodes.IncludeNode via self.environment.get_template(**).render(**) to change functionality at runtime.\nCan you think of a simple way to mock the functionality of the nodes.ImportNode and nodes. FromImport at runtime via a dynamic import?\nI think it would be somehow replicating the logic of the the visit_ImportNode method in the compiler but there's a lot going on so I'm not sure how it would be done. https://github.com/pallets/jinja/blob/fc5be479ddb3ffd2687607aada5a53bd5304f060/jinja2/compiler.py#L944-L963\nI think it would be something like running _get_default_module but I'm not entirely sure.. @mitsuhiko I load templates dynamically based on some data in the context right now so I can't use the template loader. I would however like to know which template is throwing an error via a name parameter.. thanks @mitsuhiko; you're definitely right the system is a bit slow right now because there's no caching of compiled templates/bytecode. I'm working on a system where there are base templates and depending on a story id that's passed through the context those base templates can be overridden. So I may have a base template named lede that works for the generic use case, and for a specific story someone may override the lede. Currently I pass the template objects through the context at time of render by querying the database for templates named lede with the story id, falling back to the template named lede without any story id.. @mitsuhiko oh wow, I didn't think of encoding the story id in the template name before\nthe template looks like this at the moment: \n\nwould there be an easy way to wrap this to be transparent to the user ?\njinja\n{% include ['lede-' % story.id, 'lede'] %}\nI would ideally like it to look like:\njinja\n{% myinclude 'lede' %}\n. Thanks for the help by the way @mitsuhiko! I really appreciate it. I've begin thinking about this issue for a while (https://github.com/pallets/jinja/issues/716).\nt.lede is just a variable in the context that I dynamically inject: {\"t\": {\"lede\": some_template_object}.\nBecause of the nature of my problem, the names of the included templates are dynamic so I can't hardcode lede into the layout_template in the Story class.\nCurrently, before the rendering begins, I parse the ast to find all referenced templates and then inject them into context['t'].\nI could potentially try to set context['t']['lede'] to an array of template names like ['lede-%d.html' % self.id, 'lede.html']. I think that might work and still be able to use the environment's template cache with a proper template loader?\n. @mitsuhiko I'm running into another use case for this same issue. I've transitioned to using the TemplateLoader like you suggested but in my user interface, I need to be able to preview the current template before I save it. So the current template is generated dynamically using env.from_string. I need a name for the template because I'm trying to create a special include extension that gets templates relative to the current one. So I need context.name to not be None for my extension to work. I was able to work around the issue by passing the root_template name in the context like so:\npython\ncurrent_template = context.name or context.get('root_template')\nnamespace, _ = split_full_template_name(current_template)\ntemplate = self.environment.get_template(f\"{namespace}.{template_name}\")\nand this way I can just pass in the template name and have it assume the current template's namespace. It would be much nicer to have a name argument in the Environment.from_string method though.. @mitsuhiko that sounds good to me. I would especially love to see this name propagate to the TemplateSyntaxError and other exceptions. If you decide on a name I'll try to submit a PR with this feature.. @ThiefMaster can this be released with 2.10? I'm really looking forward to this feature in the stable release. thanks!. @davidism, my current issue is naming conflicts between context variable names and template names which is why I like using strings instead. I am considering implementing an alternative template tag, let's call it include2 for the time being, used as {% include2 'asdf' %}, that could serve as a context aware template loader. does this seem like a reasonable approach?\nthanks!. @davidism just to clarify, while I can name variables whatever I want, I'm working in a system where both the context and the template themselves are out of my control. I've run into situations in the past where someone creates a variable named state and adds it to the context and also creates a template named state and intends to include that into their template.\nFor now, I'm namespacing the templates under a variable t to prevent these collisions. So someone can write a template like:\n```\nThis is a state: {{ state }}\nThis is the state template:\n{% include t.state %}\n```\nIf the include (or another template tag include2) was context aware and took a string instead, this conflict would not occur.. Yup! I understand that.\nHowever, it will use the template loader which isn't context aware. I need to load a different template based on some information in the context (i.e. some sort of override id).\nThe error occurs when I do something like:\ncontext_from_user = {'state': 'NJ', story_id: 1}\nadditional_referenced_templates = {'state': sometemp} # queries from a database based on the Include nodes in the template and the story_id from the context\ncontext = {**context_from_user, **additional_referenced_templates}\ntemplate.render(context)\nBasically, it would clean up the logic a lot if I could use a context aware template loader that encapsulated this logic instead of sticking the templates into the context.\nThis might be too much of an edge case, but I've run into this more than a few times.. Is there any way to load templates relative to the caller? I currently namespace each of my templates and I want to be able to load templates relative to the current namespace. So if I'm loading a template with the namespace \"my.current.namespace\" and I try to load template \"lede\", I want it to first search \"my.current.namespace\" for that template.\nSo is there anyway to pass information to the template loader regarding the current namespace / the caller template? If not, I need to resolve the relative template name into an absolute template path and I'm not sure where that code would go either.. ",
    "jakirkham": "Thanks @ThiefMaster. I'm still pretty new to jinja, but it seems pretty cool. Thanks for the pointers too.\n. cc @pelson\n. So, let me explain the use case here. We added a list and we would like to add one element to that list in the future, but we realize it does not work now. How can we leave it in the list, but not include it until we can support it.\n. Whether a bug, feature request, or documentation request, addressing this is very desirable. Any chance this issue can be reopened at a minimum? Alternatively if it is solvable, an answer provided to the SO question would be nice. Also an example in the documentation dealing with this case would be very helpful for others struggling with this problem.. ",
    "iffy": "@ThiefMaster Let me know if I should change anything.\n. In Python 3, implements_iterator does nothing.  But in Python 2, it renames __next__ to next (and deletes __next__).  https://github.com/mitsuhiko/jinja2/blob/master/jinja2/_compat.py#L70\nIf only a __next__ method is explicitly defined, the Python 3 tests fail with:\n```\n    def test_cycler_nextmethod(self, env):\n        items = 1, 2, 3\n        c = Cycler(*items)\n        for item in items + items:\n            assert c.current == item\n\n      assert c.next() == item\n\nE           AttributeError: 'Cycler' object has no attribute 'next'\n```\n\nI think the test's assertion is correct because the docs show that a Cycler has a method named next().\n. ",
    "delroth": "I would assume most major frameworks get this right (more eyes, less bugs, etc.) but there are also a lot of smaller projects integrating Jinja manually that do make this mistake.\nAnd to be frank, Jinja's documentation is really poor on that subject. Here is what you first see when you open Jinja's documentation:\n\nJinja2 is a modern and designer-friendly templating language for Python, modelled after Django\u2019s templates. It is fast, widely used and secure with the optional sandboxed template execution environment:\n\n\"modeled after Django's templates\" and \"secure\" could lead to think it has Django's templates security features such as autoescaping.\nThen, an example, which is HTML. And just after that, in the list of features:\n\npowerful automatic HTML escaping system for XSS prevention\n\nWhich doesn't mention it's optional and not enabled by default.\nThe \"Basic API usage\" docs page doesn't show autoescaping enabled but it doesn't show HTML either, so I guess that's fine. But then when you go to the API \"Basics\" page:\nfrom jinja2 import Environment, PackageLoader\nenv = Environment(loader=PackageLoader('yourapplication', 'templates'))\ntemplate = env.get_template('mytemplate.html')\nprint template.render(the='variables', go='here')\nThe first example is vulnerable to trivial XSSes. People are right to be confused.\n. ",
    "nick-garcia": "Created pull request #530 \n. Fix for #529 \n. ",
    "chaosagent": "While you're at it you might also want to add __rsub__ and everything else listed here.\n. ",
    "gregorysenyshyn": "I'm using Jinja to build static sites. This loader gives me more granular control when selecting files, which makes it much easier for me to have separate development and production build processes. \nThis loader lets me do path expansion using * (you could use \"src//.html\" to select all the html files in the directories one level deep in src/, which helps to keep down the length of my build files, and also helps to keep my line lengths under 80 characters if I have deep directory structure or long directory names).  Python 3.5's glob module (or higher) is needed, though, so that part will only be useful for people who are running a fairly new Python.\nThe most useful thing to me is to be able to exclude files by prepending \"!\".  On builds I don't push to production, I usually exclude analytics code, for example, which is easy to do by just adding \"!src/partials/analytics\". It's nice to be easily able to exclude a handful of files when selecting a lot of directories at once using **. \n\nOn Apr 15, 2016, at 04:43, Jeff Widman notifications@github.com wrote:\nI'm sorry, but I've never used Grunt/Gulp, so I'm not really sure how this helps.\nCan you explain a little more about why it's useful?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\n. \n",
    "LizardM4": "As a side remark, if finalize were not to be called on the template source, this would enable a much higher degree of customization -- one could autoescape the variables for languages other than HTML (see e.g. this question on SO, which originally brought me here).\n. ",
    "and1er": "What the status of this PR? Is the problem with LaTeX autoescape still cannot be solved https://stackoverflow.com/q/8001986/7444782 ?. ",
    "ccorcos": "Well I called render with a function, lol. Now that makes sense\n. ",
    "ondratu": "Ok, so another test:\n``` python\nfrom jinja2 import Environment, FileSystemLoader, DebugUndefined\nfrom time import sleep\nclass Environment2(Environment):\n    def del(self):\n        print(\"del of Environment2\")\ndef get_text():\n    env = Environment2(loader=FileSystemLoader('./'),\n                       undefined=DebugUndefined,\n                       extensions=['jinja2.ext.i18n', 'jinja2.ext.do',\n                                   'jinja2.ext.loopcontrols'])\n    template = env.get_template(file)\n    return template.render()\nfor i in range(10000):   # range for both python versions\n    get_text()\n    sleep(1)\n```\nRun this script, and see, what is doing with memory (in htop for example). Or you can use memory_profiler, when you see how increments memory use:\n``` python\nfrom jinja2 import Environment, FileSystemLoader, DebugUndefined\nfrom time import sleep\nfrom memory_profiler import profile\nclass Environment2(Environment):\n    def del(self):\n        print(\"del of Environment2\")\n@profile\ndef get_text():\n    env = Environment2(loader=FileSystemLoader('./'),\n                       undefined=DebugUndefined,\n                       extensions=['jinja2.ext.i18n', 'jinja2.ext.do',\n                                   'jinja2.ext.loopcontrols'])\n    template = env.get_template(file)\n    return template.render()\nfor i in range(10000):\n    get_text()\n    sleep(1)\n```\nAnd yes, it is memory leak, not in Jinja2 in fact, but actually in python2.x. When you run tests in python3, all work fine, resp. no increment of using memory.\nIn fact, it is possible to write python code with avoiding to this refcount problem in python2, which is known and fixed in python3. May be, it could be good to define, that jinja2 doing memory leaks on pyton2 because there is some problems with references.\n. And...  there is no guarantee if del will run when there exist some reference to it. In other words, when exist reference to object, it couldn't be delete -> sou it couldn't be call del method.\n. Hello one more time,\nI'm so sorry. It's my mistake :-( Problem is in garbage collector in Python 2.x which is better to call directly and no wait for it's automatic run. In addition to Python 3.4, can call del methods whenever call garbage collector very soon.\n. ",
    "ngr": "I believe the behavior is valid.\n{% raw %} opens the block ignored by Jinja and you have a newline char exactly after the {% raw %}.\nIn case you do not need it, try: \ntemplate_str = \"\"\"an awesome template\n{% raw %}   3 spaces\n{% endraw %}\nend of template\"\"\". I think something similar is described in Null-Master Fallback tip.\nUsing if not defined import is the recommended way.\nThere are no autotests for this specific behavior of macros. Should we add?. Can't reproduce with Python 3.6.3 or 3.6.5 (latest stable at the moment). Jinja2 versions:  2.8.1 or 2.10. Tried running up to 100,000 iterations with different pool size (up to 25).. ",
    "praiskup": "Could we consider stream reading of jinja templates to be a valid RFE?  So far, IIUC, jinja template is compiled into monolithic object at once;  and that object can be rendered in a stream fashion.  But reading line-by-line would be neat, too.\nThe use-case would be to use some \"jinja-tool\" in commandline pipeline, e.g. cat template | jinja-tool | sed ....  Similarly we could have \"interactive\" jinja \"shell\", reading stdin from commandline line-by-line and outputting instantiated output as soon as it is possible?:\njinja>{%- if True %}\njinja>something\nsomething\njinja>{%- endif %}\njinja>{%- for something in ['a', 'b', 'c'] %}\njinja>{{ something }}\njinja>{%- endfor %}\na\nb\nc. The same as for m4, etc -> e.g. large but slow jinja2 streams, but also debugging.  E.g.\nin https://github.com/devexp-db/distgen/issues/42 I'd like to experiment like:\n$ dg --template -\n{{ config.os.sth }}\n... traceback for undefined item ...\n{{ config.os.name }}\nfedora. min. example https://github.com/praiskup/jinja-issue-821/blob/master/jinja-test. Testcase is needed? (btw. yes, ignoring ENOTDIR helps..). @ThiefMaster sorry for late reply, no there haven't been tests for open_if_exists yet.  It would be nice if we could merge this as-is; otherwise let me know if something needs to be changed.. Ping, can I help to move this forward?. Done, please take a look.. The CI failure isn't related to this PR, am I right?. @davidism may I do something for this PR?. On Tuesday, March 19, 2019 9:05:14 PM CET David Lord wrote:\n\nSorry, forgot this happens when I rename branches. Can you resubmit this against master?\n\nOf course, I'll take a look at this tomorrow (ooo now).\n. ",
    "avirepo": "I am facing the same issue. Any suggestions?. ",
    "mleger45": "Hello, I am facing the exact same issue.. ",
    "DavidBruchmann": "Sudo is a system command available in some Linux Operating Systems.\nThe impact is the same as \"Run as Administrator\" in Windows.\nOn Mon, Feb 15, 2016 at 12:25 PM, blueboar2 notifications@github.com\nwrote:\n\nFrom Installation part of the documentation:\n(If you are installing from the Windows command line OMIT THE SUDO and\nmake sure to run the command as user with administrator rights)\nBut there is no sudo command, there is only\neasy_install Jinja2\npip install Jinja2\nWhich sudo i need to omit? Can you add it to easy_install and pip?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mitsuhiko/jinja2/issues/543.\n. yes,\nsudo easy_install Jinja2\nsudo pip install Jinja2\n\nbut it might depend on several parameters if you've to execute it as Sudo,\ni.e. if python is installed by sudo too or if it shall be available for all\nusers.\nOn Mon, Feb 15, 2016 at 12:44 PM, blueboar2 notifications@github.com\nwrote:\n\nYes, i know the purpose of the Sudo command.\nBut the 'omit' means that i need to ignore it. Which sudo do i need to\nomit? Thee is no sudo command in the example earlier.\nCan you, for example write\nsudo easy_install Jinja2\nor something like?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mitsuhiko/jinja2/issues/543#issuecomment-184073234.\n. \n",
    "blueboar2": "Yes, i know the purpose of the Sudo command.\nBut the 'omit' means that i need to ignore it. Which sudo do i need to omit? There is no sudo command in the example earlier.\nCan you, for example write\nsudo easy_install Jinja2\nor something like?\n. So, why this is not in the documentation? If you say to omit something, then there must be something to omit.\n. I agree. Remove omit sudo comment.\n. ",
    "rockwelln": "why not {% for n in names %} {{ \"db.%s.dump\"|format(n) }} {% endfor %}?\n. waw, I found this issue a good study case :-).\nActually, it comes from the implementation of the LoopContext(Iterator).\nBecause itertools.groupbyreturn a generator which yield nested generators on the same collection, it needs to be fetched in order (see https://docs.python.org/2/library/itertools.html#itertools.groupby for details).\nBut when you use the 'special variable' loop, the collection is enclosed into a LoopContext instance.\nThe LoopContext class (and LoopContextIterator) try to prefetch the next element in the collection and return the current one. Most of the time it works and it's safe but here it creates the following sequence:\n``` python\nimport operator\nimport itertools\nl = [(1, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]\ni = itertools.groupby(l, lambda e: operator.getitem(e, 0))\n\n\n\ne, e_next = next(i), next(i)\nlist(e[1])\n[]\ne, e_next = e_next, next(i)\nlist(e[1])\n[]\ne, e_next = e_next, next(i)\nTraceback (most recent call last):\n  File \"\", line 1, in \nStopIteration\nlist(e_next[1])  # detects the end of the collection and return the current element.\n[(3, 'd')]\n```\n\n\n\nFor me, it's a bug but this change doesn't seem so trivial to fix.\n. I suspect the problem is not in jinja itself because the following code works well:\n``` bash\n$ python\nPython 2.7.12 (default, Oct 11 2016, 09:23:39)\n[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.38)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nfrom jinja2 import Environment\nrows = {'foo': 'bar', 'foo2': 'bar2'}\nmy_str = Environment().from_string('{% for i, e in rows.items() %}{{i}}={{e}}\\n{%endfor%}').render(rows=rows)\nprint(my_str)\nfoo=bar\nfoo2=bar2\nimport jinja2\njinja2.version\n'2.8'\n```\n\n\n\nmy guess is you should look at rowbase class implementation.\n(indeed dict objects have iteritems and no iteritem) \n. ",
    "krzysztof-magosa": "@NormanDenayer it's fine unless you want to pass it to another filter in map().\n. Is there any plan to create built-in format filter which could be used in map() ?. ",
    "bennettrogers": "I just ran into this issue as well. I'm trying to implement the \"active_page\" setup from the Jinja tips and tricks section, using a nav declared inside my header.html that gets included inside layout.html. The active_page variable is set in a child template. Basically, the setup is exactly what @roba91 describes.\nIs there a reason the variable declared in the child template isn't accessible in the include? The statement that \"assignments outside of blocks in child templates are global and executed before the layout template is evaluated\" would make me think this should work.\nFor now I'm going to hack around it by putting {% if active_page %}{% endif %} in my layout.html (thanks for that tip @roba91).\n. ",
    "DavidRueter": "Just to clarify (after further testing), without the fix described above the arguments to a custom filter are passed in the wrong order when the filter is called on a static string.\nFor example, given a filter named myFilter (that is decorated with @environmentfilter):\n{{ \"someText\"|myFilter }} will cause:\nThe static string \"someText\" to be passed as the first argument to myFilter\nThe Jinja environment to be passed as the second argument to myFilter\nOn the other hand, if the filter is called on Jinja data, the behavior is different / is as documented:\n{{ data.someValue|myFilter }} will cause:\nThe Jinja environment to be passed in as the first argument to myFilter\nThe value of data.someValue to be passed in as the second argument to myFilter\nThe fix described above corrects the behavior when calling the filter on a static string:  the Jinja environment is passed to the filter as the first argument, and the static string is passed as the second argument.\n. ",
    "RickGray": "So, is it necessary to take measures to prevent this case? I think there some specific application would allow users to edit the template content, but there is no practical examples.\n. I think it is necessary to use sandbox by defualt, because flask or another web framework used Jinja2 is not do this.\n. There is a case about remote code execution via Flask/Jinja2 template injection in Uber.\nlink: http://www.tuicool.com/articles/uE3YNjY\n. ",
    "rlam3": "use callback and pass parameters to javascript functions seem to be a workaround for now\n. ",
    "cdman": "Done: #567 \n. ",
    "ssenaria": "Would LOVE this feature.\n. ",
    "esaezgil": "Hi @DanyC97 and @Yannik thanks for raising this! :) it's been so long that the MR has conflicts. I will try to solve them asap . I closed the pull request myself as I do not have any further interest pursuing it. Please feel free to contribute with another PR.. ",
    "wedi": "Are there any news regarding this feature? Why was the pulled request closed? Should someone else take over or is this just undesired?. ",
    "akamac": "I would love to see this implemented. ",
    "masasin": "Understood.\n. ",
    "xavierhardy": "So why is it not a callable in my case? Shouldn't it check that it is a boolean?\n. A custom loader fetching the template from a REST API.\n. OK, I wasn't the one who implemented it, I just checked the FileSystemLoader code. Indeed, you're right. Sorry, for bothering you.\n. Yes, we have already thought about that, we're already using the sandbox, just giving access to a few functions/classes. Thanks\n. By the way, that was pretty fast, thanks ;)\n. ",
    "robsonpeixoto": "I think that it will start to work after this change.\nOther example: https://github.com/docker/docker/tree/master/contrib/syntax/vim\n. ",
    "memeplex": "What I'm asking: to support the syntax <v-prefix><identifier> to expand variables as in $name. Ideally, I would like the more general <e-prefix><expression> as a complement to <b-prefix><block> and <c-prefix><comment>, but maybe the expression parser relies on a final delimiter being there, so I simplified the proposal to simple variables. \n. Maybe it could be extended to simple attribute and item lookup, as in $user.name or $user.names[0], in a way similar to what other templating systems do.\n. No, outside delimiters of any kind, just prefixed by some string. That's a pretty common syntax.\n. I don't think so because:\n1. The syntax would be disabled inside blocks.\n2. The prefix would be configurable and it could be disabled by default.\n3. Common syntax choices as $name are not meaningful as python/jinja expressions.\nThis is not different from the introduction of line blocks and comments AFAICS.\n. Regarding the \"no filters applied\", I'm proposing this as a shortcut for very short substitutions, I see no point extending it to the general case, specially when the expression itself is already of considerable extension. For example, one can configure ${,} as expression delimiters and $ as expression prefix.\n. Here is a fictional example of why I said expression/variable prefixes are a missing piece:\nenvironment = jinja2.Environment(\n    block_start_string='@{',\n    block_end_string='}',\n    line_statement_prefix='@',\n    comment_start_string='#{',\n    comment_end_string='}',\n    line_comment_prefix='#',\n    variable_start_string='${',\n    variable_end_string='}',\n    variable_prefix='$'    # <-- this is not currently valid.\n)\nHere is a rationale for not supporting this, though: the prefixed versions are intended to work at the line level (by default, they trim leading and trailing whitespace, reclaiming the entire line for themselves). Under that interpretation, there is no case for prefixed variables since they are intended to always be embedded in a line. Now, when you set trim_blocks and lstrip_blocks to true, this line-level vs embedded classification is weakened and the prefixed vs delimited one takes relevance.\n. ",
    "bladeoflight16": "I'm not sure about the wisdom of encouraging the use of the old style % formatting mechanism. Python itself is moving away from it and encouraging use of the format method. Here's an example of the Python docs calling it the \"old\" syntax.\n. @davidism No, it is discouraged. See the printf-style String Formatting section of the docs:\n\nNote: The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). Using the newer str.format() interface helps avoid these errors, and also provides a generally more powerful, flexible and extensible approach to formatting text.\n\nPython 3.1.5's docs explicitly suggested it might be removed:\n\nNote: The formatting operations described here are obsolete and may go away in future versions of Python. Use the new String Formatting in new code.\n\nI'm not sure why the warning was toned down in newer versions.\n. @mitsuhiko What problems does format have with Unicode in 2.x? The only thing I can find is stuff about mixing bytes and text, to which the simplest, most well known answer is, \"Don't do that.\" And according to this, the problems of mixing them appear to go both ways; it's only the direction of the problems that changes depending on which you choose.. ",
    "magniff": "Hmm, in Python 3.6.0a0 from semiofficial mirror on github it seems to be working, thus this should be considered cpython`s problem.\n. ",
    "alexjurkiewicz": "My suggestion would be to check the type of the name argument in do_map and raise an exception if it is not a sensible type (eg if not isinstance(name, BaseString)). Would a patch along these lines be accepted?\n. This is the only filter that takes a string argument representing another filter. Lots of filters take an 'attribute' string, but that seems like a different thing.\nI'll go ahead with the work if another maintainer gives the OK \ud83d\udc4d \n. Nice, thanks \ud83d\ude4c\nOn Fri., 6 Jan. 2017, 10:53 pm Armin Ronacher, notifications@github.com\nwrote:\n\nClosed #575 https://github.com/pallets/jinja/issues/575 via d1a32e7\nhttps://github.com/pallets/jinja/commit/d1a32e7502ebd0a0605dba19a49df4cddec601e1\n.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/pallets/jinja/issues/575#event-913949156, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAXKderCS-acUBwOLknIp9dCy1cZJ8Mrks5rPitOgaJpZM4IPnei\n.\n. Either way the iterable is consumed, right? I would just like it to be part of the core filter to simplify the above construction, which I've written a lot lately.\n. I was hoping the explicitly different name of length gave some semantic wriggle room here :)\n. \n",
    "boidolr": "Ok, thanks for the info. I've only noticed the other parts and adapted that part.\n. ",
    "ArmorDarks": "@ThiefMaster Thanks for reply\nMy general idea was to follow pattern, which already occurs in Python import statements:\npython\nfrom jinja2 import Something\nWe do not specify here any extension, since we know, that this import is executed in Python environment and by default it will look for Python files.\nSame is for Jinja2. When we call extend, import or include, it's executed in Jinja2 environment, and it's logical for it to look for default or preconfigurated for that environment extension.\nSo, basically, there is no \"implicity\" issue here.\nPlease, correct me, if I'm wrong. Maybe I'm really missing something obvious.\n\nconsidering that the file extension can control features like autoescape this is even worse.\n\nHm, that is some good thought. But so far I don't see where exactly it is an issue. You are configuring autoescaping for each extension independently. If you don't want Jinja2 to match some extension by default \u2014 just don't put them in configuration. In fact, that addition doesn't make any difference in terms of controlled by extensions autoescaping.\nOnce again, I assume I'm missing something here.\n. > In python that only works because jinja2/init.py imports Something\nIf it won't import something via __init__.py we still will be able to use\npython\nimport jinja2\nto get everything.\nThus for me it still feels somehow alike.\n\nand unliky Jinja Python files have only on extension.\n\nThat is way I proposed to allow specify array of extensions.\nIn case if you importing something non-standard, you always can use explicit extension, same as in Python import:\njinja2\n{% include 'symbol.svg' %}\nBut in all other cases you know that you already told to system your default extension, so you don't need to repeat it everytime in every include, import and extend.\n\nYou are right about the autoescape part, but it's still confusing as soon as you end up with more than one candidate in the same folder.\n\nI think this should be up to developer. If he puts files with same names and different extensions in same directory for purpose, he might opt not to use system.\nHowever, so far I didn't encounter repositories, which will uphold templates with same names, but different extensions, in same directory. Probably because it would seem like an architectural issue.\n. ",
    "atodorov": "@ThiefMaster - are there any alternatives instead of fail? Maybe an option to silently ignore tags which are undefined ? \n. Thanks, the conditional include did work.\n. The second commit appears to make things work, but I have no idea what I'm doing so that may not be the correct solution.. With the proposed patch in the second commit debug_info becomes\ndebug_info = '1=10&1=18&3=19&4=21&4=22&5=25' which maps to all yield statements but doesn't map very well to the line numbers in the HTML template.\n. After the third commit the value is debug_info = '1=10&2=18&3=19&4=22&6=25' and the line numbers for some of the template nodes have been updated.\nNOTE: please review the commits one by one to spot the differences. I'm not convinced this is a proper fix for my issue but being able to properly map between HTML lines in the template the generated Python source will enable proper coverage reporting for Jinja templates.\nI do have a coverage.py Jinja plugin which appears to be working correctly if not for the fact that Jinja doesn't provide all the line numbers information to properly report on the results.\nNote2: Template.get_corresponding_lineno() will not report proper results when lineno (from Python source) > code_line (from debug info mappings). It will just move to the next iteration and report that line as part of the previous line in the HTML. At the moment this makes coverage report zero-length loops as executed.\n. @mitsuhiko correct, no error can be generated here, but I need somehow to be able to map this line of Python code to its corresponding line in the template text. get_corresponding_lineno() sounds like the most obvious way to do this. Do you propose otherwise ?\nI can jump on IRC or email thread if you guys prefer to discuss at length, just let me know.. @ThiefMaster I am working on coverage.py plugin for Jinja templates. It can be found at\nhttps://github.com/MrSenko/coverage-jinja-plugin\nThe detailed debug info helps me get proper measurements as to which lines were actually covered. \nThen \"fixing\" the node line numbers to match the lines in the HTML template will make it very easy to produce coverage reports (e.g. colored HTML or annotated text).\nIf it helps for the loop.html template shown above I get the following node structure (before any of the commits in this PR). Numers are the lineno attribute of the nodes. You see how they don't match the HTML text at all.\n1:nodes.Template([\n    1:nodes.Block('body', [\n        1:nodes.Output([1:nodes.TemplateData('\\n  <ul>\\n ')]),\n        3:nodes.For(3:nodes.Name('user', 'store'),\n                    3:nodes.Name('users', 'load'),\n                    [3:nodes.Output([\n                        3:nodes.TemplateData('\\n <li>Hello '),\n                        4:nodes.Name('user', 'load'),\n                        4:nodes.TemplateData('</li>\\n  ')\n                     ])\n                    ], [], None, False\n                   ),\n        5:nodes.Output([5:nodes.TemplateData('\\n </ul>\\n')])\n    ], False)\n])\n. @jdahlin can you tell me when does the jinja compiler generate debug info at the moment. By which property does the compiler know to generate debug info ? I may be able to use that in my tool to work around current limitations ?. ",
    "pgjones": "Thanks, I've rebased with updates to the tests. I've both fixed the braking test and added one to ensure that the correct template is returned after changing the loader.\n. I've just rebased following @iceboy-sjtu comment. \n. @jeffwidman Anything else I need to do?\n. @untitaker Thanks; I think that it doesn't make sense to change the env.cache given the bytecode_cache. If it does however, a potential issue could be the change from str key to tuple, which I made following a suggestion. \nI'd like to add that the performance regression #485 does break jinja for us, so I'd like to help reach a solution.\n. @untitaker Thanks, change made.\n. Thank you\n. @iceboy-sjtu what about going back to the hash()?\n. Good idea, I've updated.\n. ",
    "raben2": "I change extrensionControl in the template f.e. to test\nthen i get:\n```\ni don't get why this is failing\nupload:\n    extension: csv\n    uploadDir: outbox\n    timestampFormat: yyyyMMdd_hhmmss\n    filename: TRUSTORLIST\n    test: .ctrl\n    archiveDir: outbox/archive\n```\n. No it is not about the ordering. The extensionControl should be within the upload section but somehow it jumps out.\n. Like i said it is NOT about the ordering.\nThis is the result i get:\nextensionControl: .ctrl\nupload:\n    extension: csv\n    uploadDir: outbox\n    timestampFormat: yyyyMMdd_hhmmss\n    filename: TRUSTORLIST\n    archiveDir: outbox/archive\nThis is what should be happening\nupload:\n    extension: csv\n    extensionControl: .ctrl\n    uploadDir: outbox\n    timestampFormat: yyyyMMdd_hhmmss\n    filename: TRUSTORLIST\n    archiveDir: outbox/archive\n. Oh ok i get that. Thank you.\n. ",
    "micahhausler": "Sorry for the noise\n. ",
    "xethorn": "Found the solution for the extraction: for pybabel extract, add: --add-comments=\"tag\".  So if \"tag\" is: \"i18n:\", jinja2 code will look like:\njinja\n{# i18n: your message #}\n{{ _(\"Text to translate\") }}\n. ",
    "jonapich": "I am using jinja solely for the purpose of generating yml files and would like injected dictionaries to render a yml-compatible version of the dict.\n. The project is written in python, but it expects the user to work with YML and Jinja, not python. The user is able to define some metadata in a database that can then be referenced using the {{ }} syntax inside the templates. Because I know i'm always rendering YML files, it's safe for my scenario to render lists and dicts as something YML can parse.\n. @davidism I know, it's easy to provide a filter for that purpose. But then writing the templates is not as natural as it could be.\nI am not familiar with the jinja source code, if I had a pointer or two of where this conversion happens (str), I could probably monkey-patch it for my needs.\n. Thanks guys.\n@davidism I was seeing this as a feature request. Deeply sorry for the clash of opinion.\n. ",
    "zainengineer": "Sorry fixed the issue by \n{{'{{unsecure_base_url}}skin/}}'}}\n. ",
    "arkafon": "Got this problem too. Simple test:\n{% extends \"...\" %}\n...\n{% set aaa = 'test' %}\n{% set bbb %}\n    <a href=\"/\">bar</a>\n{% endset %}\n...\n{% block some_block %}\n {{ aaa }} {# renders 'test' #}\n {{ bbb }} {# renders empty string #}\n{% endblock %}\n. ",
    "charleschen": "I'm getting the same inconsistent behavior with the 'with' statment:\n{% with %}\n{% set something = 'werd' %}\n{% set something_block %}\nwerd werd werd\n{% endset %}\n{% endwith %}\n...\n{{ something }} {# renders empty string #}\n{{ something_block }} {# renders 'werd werd werd' #}\nthese bugs are probably related?\n. ",
    "kaos": "Lets say I have a template:\nfoo = {{foo}}\n\nAnd I render this, with args: { 'foo': '{{bar}}', 'bar': 'baz'}, I would like to get the output:\nfoo = baz\n\nrather than\nfoo = {{bar}}\n\nThat is, I want it to resolve all nested variable expressions before being \"done\".\n. ",
    "zyphlar": "It may be intended for users who are upgrading, but the actual use-case of a newbie trying to write a template without necessarily knowing what Jinja version they have and just wanting to write a damn if statement is probably more common. My point about version info being at the top of the hierarchy not a footnote stands, and moving versioning info to the top does nothing to detract from the upgrading use-case.\nJust because Python does it doesn't mean it's the best way to do it. Most other language docs I can find are either versioned themselves, or have version tags at the top.\n. ",
    "fabioramponi": "Hi guys, will this pull request be considered for future releases? Otherwise, could you suggest some alternative solution to prevent #399?\nThanks!\n. ",
    "robsdedude": "Does this also fix the strange behavior when overwriting a block that the parent template included?\nMinimal example:\ntemplates/\n |--base.html\n |--nav.html\n +--page.html\nbase.html\n<html>\n<head>\n  <title>Title</title>\n</head>\n<body>\n  {% include 'nav.html' %}\n  {% block content %}{% endblock %}\n</body>\n</html>\nnav.html\n<h1>Header 1</h1>\n{% block more_headers %}{% endblock %}\npage.html\n{% extends 'base.html' %}\n{% block more_headers %}<h2>Second header!</h2>{% endblock %}\n{% block content %}\n  Content!\n{% endblock %}\nRendering page.html will not output the h2.. ",
    "berlinsaint": "I use the jinja2 to complete an config  template, the adress that  user extract from  the windows is  not like the way of  \"path\\\\path\\\\\"...\nBecause  user can copy from windows\u2018s explorer, and  not want modify it  by themself. \nNow i use re library to replace them , but i still confused about  how jinja2  deal with it, and what does it do in dealing  wih the  \u2018\\\u2019 character. ",
    "Semprini": "The default leeway of 5 breaks many existing usages of truncate which don't specify the leeway. It should be defaulted to 0 for backwards compatability.. ",
    "Ragsboss": "@davidism thank you for looking into this. I've opened an issue after we've concluded that this is likely a bug in Jinja code. \nFirst issue is call to macro should not result in empty lines, given the use of trim_blocks=true. If we forgo this issue and choose to use a workaround by putting explicit - in the macro call, the spaces in the next line are disappearing. So overall we have no solution here nor do we have a working workaround.\n. Hmm, looks like my previous comment reminding @davidism to respond is not visible anymore. Not sure what went wrong there. @davidism please share your thoughts on this legit (and likely) bug.\n. ",
    "romeojulietthotel": "I can't tell if continuous integration builds the docs. I didn't find anything like that. Did I miss some step or am I looking in the wrong place? I looked here: travis-ci Or do the docs not get built automatically?\n. I did not see any failures. What failures do you see? . Searching on this python problem led me to the fix.. ",
    "htlhenry": "thanks @zoidbergwill\nI know the reason ,{and%  can't together, they must middle left space, right code:\n<script type=\"text/html\" id=\"test-js\">\n    <%  for(var system in data){  %>\n        <ul>system: <%=system%></ul>\n    <%  }  %>\n</script>\n. ",
    "borismod": "@ThiefMaster thanks for your feedback. What alternative do you suggest instead of adding a filter when I need to camelize a string using Jinja?\n. Dear @davidism and @ThiefMaster thank you for your comments. I understand that this filter can be added in application that consumes Jinja. In my case it's Cookiecutter - a command line tool for creating projects based on templates.  At the end we're using Cookiecutter in ShellFoundry - a command line utility for creating CloudShell shells.\nBoth tools are not aware of the set of filters that Jinja provides and use them as a black box. That's the way we consume dependencies. Camelize is a popular string manipulation that may be used by many users of Jinja in creating templates for their project. It converts a snake style string to Camel Case, for example code_generator.py to CodeGenerator, i.e. from file name to class name.\nCan you please reconsider your decision and accept this PR \u2753 \n. ",
    "andreanidouglas": "https://github.com/andreanidouglas/python-blog it works on python 3.4 but not on python 3.5, you can just try to render the echo.html template passing a value from the view module\n. it works, i will close the issue and look further to see if there is any bug in the code.\nthanks\n. ",
    "davidslac": "Thank you for looking at this, I don't know jinjai well enough to answer the question. I am working around the issue by creating the _jenv variable as follows:\n```\njiEnv = ji.Environment(loader=loader,\n                               cache_size=0,\n                               trim_blocks=True,\n                               line_statement_prefix='$',\n                               line_comment_prefix='$$')\n```\nso perhaps I am turning off all caching? \nThe bug I reported is in code I did not develop myself, and it was developed a number of years ago. I think the pattern used, to derive from the FileSystemLoader, is an unusual thing to do today, however when I tried to redo it in a more straightforward way, I still got the same problem. It seems to me that even though the code uses names like\n```\nfilename?templateA\nfilename?templateB\n```\nto distinguish templates, somehow jinja2 2.8 is not caching on those full names, just on the filename, whereas 2.7 worked. \nThis was a really big issue for us. Back in Oct of 2015, I ran into this issue: https://jira.slac.stanford.edu/browse/PSRT-71, I upgraded jinja to 2.8, but a week later we ran into the bug and had to work fast to repair things. I put effort into unraveling our code (a complicated code generation package) to isolate the problem and gave up. A bigger effort more recently allowed me to isolate the problem. Anyways, thanks again for looking at this.  Would you like me to make a more straightforward example, without deriving from FileSystemLoader?. ",
    "7yl4r": "I am 100% in agreement that inside-out rendering to get variable*N variable names is a BAD idea. \nHowever, I got here looking for a solution for outside-in render nesting and ended up exploring the solution myself. Is there support for such a thing? Would addition of a nested_render filter be beneficial or harmful in that it is likely to confuse people?. ",
    "kf106": "Nested variables would solve a problem with WTForms, in which a construct like\n{{ form.playername(value=\"{{ currentname }}\") }} \nwould be a lot clearer than any other solution I've found.. Ah, it's that simple! I ended up using Javascript to set the value from the currentname variable. When I set the default value in the form object in the Python code, it doesn't update.. ",
    "major": "Thanks, @jeffwidman. I couldn't figure out how to make the new tests show up in the documentation, though. Please let me know if I'm missing a step somewhere.. Got it. Thanks, @davidism.. @davidism: I figured out the issue. The jinja2 installation in my virtualenv was interfering with the documentation build. I installed the version of jinja from this PR and the docs built fine with the new tests. :). Thanks, @davidism! :). Thanks for all the effort on this one, folks. ;). ",
    "jfinkels": "FYI This seems to allow all tests to pass with Travis Python versions \"3.6-dev\" and \"nightly\" (3.7).. ",
    "ipmb": "Looks like this is a dupe of #619 . ",
    "ashishpatil-TML": "Was getting the same issue post installation of Airflow.\nBelow is the error,\n/usr/lib64/python2.7/site-packages/flask/exthook.py:71: ExtDeprecationWarning: Importing flask.ext.cache is deprecated, use flask_cache instead.\n  .format(x=modname), ExtDeprecationWarning\nTraceback (most recent call last):\n  File \"/usr/bin/airflow\", line 27, in \n    args.func(args)\n  File \"/usr/lib/python2.7/site-packages/airflow/bin/cli.py\", line 678, in webserver\n    app = cached_app(conf)\n  File \"/usr/lib/python2.7/site-packages/airflow/www/app.py\", line 161, in cached_app\n    app = create_app(config)\n  File \"/usr/lib/python2.7/site-packages/airflow/www/app.py\", line 59, in create_app\n    from airflow.www import views\n  File \"/usr/lib/python2.7/site-packages/airflow/www/views.py\", line 49, in \n    from jinja2.sandbox import ImmutableSandboxedEnvironment\n  File \"/usr/lib64/python2.7/site-packages/jinja2/sandbox.py\", line 25, in \n    from markupsafe import EscapeFormatter\nImportError: cannot import name EscapeFormatter\nWorkaround:\nAs it seems to be python package related issue, tried to check if the package markupsafe exists at path \n/usr/lib64/python2.7/site-packages/\nIt does exists, but while importing it as from markupsafe import EscapeFormatter in python shell, it was giving same error. Looks that files are corrupt may be.\nso , re-installing package and importing again, helped me.\nsudo pip uninstall markupsafe\nsudo pip install markupsafe\nAfter this, from markupsafe import EscapeFormatter worked well in python shell.\nNow start Airflow webserver and it works fine.\nairflow webserver -p 8080. ",
    "timgraham": "Okay, I'm trying to write a test now. Wasn't sure if the bug would be obvious given the traceback.. I think the issue is the construct {% for widget in widget.subwidgets %} -- the widget name is reused.. Here's a test:\n```diff\ndiff --git a/tests/test_core_tags.py b/tests/test_core_tags.py\nindex 0438008..6cc7dac 100644\n--- a/tests/test_core_tags.py\n+++ b/tests/test_core_tags.py\n@@ -22,6 +22,10 @@ def env_trim():\n @pytest.mark.for_loop\n class TestForLoop(object):\n\ndef test_simple_reuse(self, env):\ntmpl = env.from_string('{% for item in item %}{{ item }}{% endfor %}')\nassert tmpl.render(item=list(range(10))) == '0123456789'\n+\n     def test_simple(self, env):\n         tmpl = env.from_string('{% for item in seq %}{{ item }}{% endfor %}')\n         assert tmpl.render(seq=list(range(10))) == '0123456789'\n``\nIt errors out withUnboundLocalError: local variable 'l_1_item' referenced before assignment.. I'm a maintainer of Django and don't have much experience with  Jinja2 (and didn't write the template). In our case, I'm not sure what the alternative is:{% for widget in widget.subwidgets %}{% include widget.template_name %}{% endfor %}the included template relies on the variable being namedwidget`.. \n",
    "alex": "In this specific case I resolved it by rewriting it to use groupby.. ",
    "MinchinWeb": "Got sent to this issue (see #656) after this change blew up my blog template on upgrading from v.2.8.1 to v2.9.4.\nI was using it keep track if various pieces of data were changing between loop iteration. I was able to fix it because I wrote the original template code (see https://github.com/MinchinWeb/seafoam/commit/8eb760816a06e4f0382816f82586204d1e7734fd and https://github.com/MinchinWeb/seafoam/commit/89d555dbd6a2f256471d43e4184f09512694e5f2), but I doubt I would have been able to otherwise. The new code is harder to follow as the comparisons are now done in-line. For example, my old code (v.2.8.1):\n```jinja\n{%- set last_day = None -%}\n{% for article in dates %}\n    {# ... #}\n    \n        {%- if last_day != article.date.day %}\n            {{ article.date | strftime('%a %-d') }}\n        {% else -%}\n            \u2014\n        {%- endif -%}\n    \n    {%- set last_day = article.date.day %}\n{% endfor %}\nand the new code, with in-line comparisons (v2.9.4):jinja\n{% for article in dates %}\n    {# ... #}\n    \n        {%- if ((article.date.day == dates[loop.index0 - 1].date.day) and\n                (article.date.month == dates[loop.index0 - 1].date.month) and \n                (article.date.year == dates[loop.index0 - 1].date.year)) %}\n                    \u2014\n        {% else -%}\n                    {{ article.date | strftime('%a %-d') }}\n        {%- endif -%}\n    \n{% endfor %}\n```\nSo I just wanted to say that the \"feature\" (or \"hack\", if you prefer) is used and is already missed.\nIf the scoping issues are too complex to figure out sensibly at the moment, could something (at a minimum) be added to the changelog so it bites less people unaware?. What if there was a way to explicitly pass a variable into a loop? Perhaps syntax like this (borrowing from text filters):\n```jinja\n{%- set last_day = None -%}\n{% for article in dates | pass_variable ( last_day ) %}\n    {# ... #}\n    \n        {%- if last_day != article.date.day -%}\n            {{ article.date | strftime('%a %-d') }}\n        {%- else %}\n            \u2014\n        {% endif -%}\n    \n    {%- set last_day = article.date.day %}\n{% endfor %}\n```\nOr is there a way to do something similar to scoped as it currently applies to macros?\n\nAnother use case would be maintaining some sort of counter between loops. For example, how many rows total? how many rows meet some criteria? The total of some property for selected rows (to print a total row)?. Another (ugly) hack is to use a list, append, and pop: http://stackoverflow.com/a/32700975/4276230\n. ",
    "foosel": "As an additional data point, it fell on my feet for a case where I need to inject a special class into generated HTML, but only for the first element of the iterated list that does not also have some specific property set. I can't modify the iterated data. I can't use loop.first (as much as I'd love to) or compare with anything from the last element to reliably do what I need to do here, which led to experiment with the evil construct which worked perfectly (and it was not clear to me that it was actually me abusing a bug).\nAdditionally I offer extension capabilities through third party plugins and have no way to police how the authors structure their templates, causing sudden breakage for end users after update to Jinja 2.9+. I've pinned the latest 2.8 version now in my program for that matter to remain backwards compatible (as my versioning scheme promises), until I can find a way to get authors to update their templates.. ",
    "roganov": "Could someone please clarify why jinja2 scopes cannot work exactly as python works? i.e., jinja2 templates correspond to python modules, macros correspond to functions (and have their own scope), for loops don't have their own scope and so forth. While @mitsuhiko says jinja 2.8 and below had lots of scoping bugs, it was more intuitive for me to understand how scoping works.\nFor python programmers, the behavior from first post (Jinja 2.8) is obvious. Same applies to https://github.com/pallets/jinja/issues/660, I don't understand why python library should implement javascript behavior (I understand that python's handling of default args is not ideal, but any python developer is aware of it).\nAlternatively, there should be a document which describes how scoping in jinja works so that we don't have to guess.\nAlso please don't take my comment negatively, I'm very grateful for jinja.. OK, thanks. Frankly it's not quite intuitive (i would expect templates to work as python modules), but if this behavior is intended then please close the issue.. > For instance what should a=b, b=a mean?\nI'm not sure if I understood the question, but I think that if macro parameters and template-level variables have equal names, then template-level variables should be shadowed, just like in python.. ",
    "pujan14": "Hi, I have been using this code since about 2 years, now it breaks and from new documentation and this discussion I don't think there is any other way to do what I am trying to do here. If not please correct me.\njinja\n{% set list = \"\" %}\n{% for name in names %}\n{% if name.last is defined %}\n{% set list = list + name.last + \" \" %}\n{% if loop.last %}\n{{ list.split(' ')|unique }}\n{% endfor %}. @davidism Your solution is great but I am trying to achieve this.\nCreate 2 lists as following\njinja\n{% set list1 = name|default()|map(attribute=\"last\")|select|list %}\n{% set list2 = name|default()|map(attribute=\"age\")|select|list %}\nand then merge them into list3, which should look like following and finally applying unique(ansible filter) on list3\nlast1-age1\nlast2-age2\nlast3-age3\nlast4-age4\nlast5-age5\nlast6-age6\nFrom what I gathered map does not work with multiple attributes #554 \nI am using jinja2 via ansible and so adding doing something in python beforehand is not a good idea for me.. @davidism I played around with loops in new jinja 2.9. with 2.9 even when I create/define a new variable inside a loop it gets cleared/deleted at end of every iteration.\nHere is an example.\njinja\n{% for name in names %}\n{% if loop.first %}\n{% set list = \"\" %}\n{% endif %}\n{% if name.first is defined and name.last is defined and not name.disabled %}\n{% set list = list + name.first|string + \"-\" + name.last|string %}\n{% if loop.last %}\n{% for item in list.split(' ')|unique %}\n{{ item }}\n{% endfor %}\n{% else %}\n{% set list = list + \" \" %}{% endif %}\n{% endif %}\n{% endfor %}\nThis might not be the best way to do this but here from my understanding I am not breaking any scoping rules.. ",
    "Molodax": "Hi,\nI understand that there are a lot of \"ugly\" examples due to this, but could you please advise how to increment a variable on a for loop in jinja template in elegant/right way? Because my code has been broken too.. {% for state in states.sensor -%}\n{% if loop.first %}\n{% set devnum = 0 %}\n{% endif -%}\n{%- if state.state == \"online\" %}\n{% set devnum = devnum + 1 %}\n{%- endif -%}\n{% if loop.last %}\n{{ devnum }}\n{% endif -%}\n{%- endfor -%}\n. @davidism I need only those that meets a condition. @mitsuhiko, thank you for your support, unfortunately, it does not work.\nPerhaps, jinja2 (filters) has been implemented with some limitations in a project that use (Home assistant). But it did work with the code provided by me before. Pity.. ",
    "aabdnn": "Hi folks. You're asking for example code that works under 2.8, so here's mine:\n{% set count = 0 %}\n{% if 'anchors' in group_names %}\nnameserver 127.0.0.1\n{% set count = count+1 %}\n{% endif %}\n{% for resolver in resolvers %}\n{% if count < 3 %}\n{% if resolver|ipv6 and ansible_default_ipv6.address is defined %}\nnameserver {{ resolver }}\n{% set count = count+1 %}\n{% elif resolver|ipv4 and ansible_default_ipv4.address is defined %}\nnameserver {{ resolver }}\n{% set count = count+1 %}\n{% endif %}\n{% endif %}\n{% endfor %}\nI don't know how I would do this without a global \"count\" variable that I can reference in 2 separate loops. Do you have any suggestions that will allow this to work under both 2.8 and 2.9?. @davidism the template I presented above did not come from any Ansible documentation. Ansible doesn't document Jinja2 specifically. I just created this template myself by reading Jinja2 documentation, and it worked, so I put it into production. I assumed that Jinja2 made variables global.. ",
    "Carlos-Descalzi": "Had this issue in 2.8 and superior\nHere goes a test case:\n```\nimport unittest\nfrom jinja2 import Template\nTEMPLATE1 = \"\"\"{% set a = 1 %}{% for i in items %}{{a}},{% set a = a + 1 %}{% endfor %}\"\"\"\nclass TestTemplate(unittest.TestCase):\ndef test_increment(self):\n    items = xrange(1,10)\n    expected='%s,' % ','.join([str(i) for i in items])\n    t = Template(TEMPLATE1)\n    result = t.render(items=items)\n    self.assertEqual(expected,result)\nunittest.main()\n```\n. ",
    "Da-Juan": "Do you have a workaround for this issue or do we have to wait for previtem/nextitem in 2.9.6?\nSome of my saltstack templates are broken now.. ",
    "bolkedebruin": "We are now. Thanks.. That was quick! Thanks, will verify our own code whether we do something \"unexpected\".. ",
    "mohamed-aziz": "    assert t.render() == '/static/file1;/static/file2;'\n\nthe t.render() returns ';;'. @davidism sure\napp.py\nfrom flask import Flask, render_template\nfrom flask_assets import Environment, Bundle\n\n\napp = Flask(__name__)\nassets = Environment(app)\njs = Bundle(\n        'js/app.js',\n        output='gen/app.js'\n        )\nassets.register(\n        'js_all',\n        js\n        )\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\nif __name__ == '__main__':\n    app.run()\n\nindex.html\n<html>\n    {% assets \"js_all\" %}\n    <script src=\"{{ ASSET_URL }}\"></script>\n    {% endassets %}\n</html>\n\nwith jinja2>2.9\n\u03bb ~/ http :5000   \nHTTP/1.0 200 OK\nContent-Length: 49\nContent-Type: text/html; charset=utf-8\nDate: Sat, 07 Jan 2017 22:58:47 GMT\nServer: Werkzeug/0.11.15 Python/3.6.0\n\n    <html>\n\n        <script src=\"\"></script>\n\n    </html>\n\nwith jinja2<2.9\n\u03bb ~/ http :5000   \nHTTP/1.0 200 OK\nContent-Length: 76\nContent-Type: text/html; charset=utf-8\nDate: Sat, 07 Jan 2017 23:00:29 GMT\nServer: Werkzeug/0.11.15 Python/3.6.0\n\n    <html>\n\n        <script src=\"/static/gen/app.js?491dc8f8\"></script>\n\n    </html>\n\n. ",
    "cdeil": "@mitsuhiko - Thanks for fixing it. Could you please make a patch release soon?\nThis issue is affecting other Sphinx projects, e.g. the sidebar from the Astropy docs disappeared recently and it took me some time to find this issue:\nhttps://github.com/astropy/astropy/issues/5679#issuecomment-271175414\nIt's particularly nasty since there's no warning or error from Sphinx, but the generated HTML is corrupted.\n. Great, thank you!. ",
    "tk0miya": "I confirmed it works fine :-)\nThank you for quick fix!. ",
    "MartinThoma": "pip3 install jinja --user --upgrade solved it for me.. ",
    "slisznia": "It will fail if the JSON response occasionally does not include the 'items' (say it was an optional attribute of the response). In that case, {% for el in data['items'] %} will also produce:\nTypeError: 'builtin_function_or_method' object is not iterable\n...since items is always defined (as a builtin function).\nAnd this is a bug, IMO. The data['items'] should never collide with the builtins. In other words, if you want to cleanly iterate an optional \"items\" attribute you are forced to rename it. Ideally, that shouldn't be the case.. I'm not suggesting to drop anything, just to make it more strict.\nThe problem today is that when you use the explicit lookup notation: data['items'] it finds a builtin dictionary function and it shouldn't. Python doesn't do it, nor should jinja. If one needs to call the builtin (or any function for that matter), you have the calling notation for it: data.items()\n. Why is this a special case? I'm asking for Jinja to behave exactly like Python does. Specifically, foo['items'] should yield None if there is no user-inserted key \"items\" in it. Today, Jinja falls back to finding the built in function of the same name. So simply do what Python does:\n```\n\n\n\nprint {}.get('items')\nNone\n``\nBtw, I also believe that the alternative notation \"foo.items\" should be handled just fine as well, since you need to use \"()\" to call a callable, but if you require some backwards compatibility for foo.items to either find a key or call a function automatically, then I guess that's too bad. . @ThiefMaster themydict.get('items', [])` works of course, and thanks for pointing out another method than renaming keys.\n\n\n\n. ",
    "thatrevguy": "Ya looks like so, but with no clear resolution other than a PIP issue ref that has no bearing on RPM build compile. We use RPM for distribution and use compile. Is expectation to skip compile for this package or version lock to 2.8.1?. Checking if I can skip certain files real quick, we are using setup.py to drive build logic.. Looks like I can add _python_bytecompile_errors_terminate_build to spec. This seems like a hack however as this will ignore possible legitimate compile errors we'll want the build to fail on.... ",
    "abadger": "Yeah -- I'm not sure that this is a \"bug\" in jinja but the object of ansible's safe_eval() is to turn strings into python data but only if it is safe.  Since Ansible is using jinja2 for \"variables\" the output of jinja is being passed through safe_eval() in order to turn the strings returned by jinja back into typed data (ints, floats, dicts, lists, etc). \nTuples have a literal representation which can be eval()'ed safely.  NamedTuple does not.  So safe_eval() is able to handle jinja2's old groupby output which returned a string representation of a tuple.  It cannot handle the new groupby output which returns a representation of a NamedTuple.\nMy reading of the jinja2 commit message is that the NamedTuple is an implementation to ease the implementation of sorting the output: https://github.com/pallets/jinja/commit/6d356f1bc318a15e8d28176a0f44fcb2578335c0  So it should be possible to convert the NamedTuples into regular tuples post-sort if jinja2 would care to keep compatibility here.. @ThiefMaster That's not true.  I checked this behaviour on Python-2.6 and Python-2.7 before submitting this PR:\n```\n$ cat test.py\ndef testing(a, b, c=None, d=None):\n    print(a)\n    print(b)\n    print(c)\n    print(d)\nb = [4]\nd = {'d': 6}\ntesting('123', b, c=5, *d)\nimport sys\nprint(sys.version_info)\n$ python2 test.py\n123\n4\n5\n6\n(2, 6, 6, 'final', 0)\n```\nEDIT: Yep, thanks.  I have tripped over Python3-only argument unpacking before so I made sure to check before opening my mouth ;-). list is not a good name as it is not detecting whether the data type is a python list.  What's really meant is test_nonstring_sequence but that might be a bit cumbersome to type.  In other APIs I've written, I've made selecting whether to exclude string types a parameter of the function but I don't think that jinja tests take parameters from the user so that's not an option here.. * array is a better name.  Although strings are arrays, array doesn't clash with the builtin python list type.\n nonstring-sequence would not be true for dicts.  (dicts are iterable but not indexable.  Thus they are not sequences).\n Note that your question as to whether dicts are wanted reminds me that sometimes dicts are wanted and other times they are not.  I almost always check whether an object is \"iterable and not string\" rather than \"sequence and not string\".  However, that is mostly for the following:\n Sequences do not contain sets and frozensets.  To capture those one has to test whether an object is an iterable.\n In most of the instances I need a check for something like this (I actually can't think of a time when I chose to check for a sequence instead of an iterable...), it is because I want to determine if I can loop over the data rather than whether I can reference a specific index in the data.  So I accept that dicts will be included (usually fine, just not the format that I'd expect the user to be sending me) or I check for Mappings before iterability if the particular piece of code cares.. ",
    "brookskindle": "Yeah if it broke when moving from 2.8.x to 2.9.x I probably wouldn't have investigated too deeply, but I tried this out on 2.9.2 and it worked, hence why I put bug in the title.\n@mitsuhiko do you think this is worth documenting / putting a notice somewhere in the documentation that \n\nthe following code does not work\ncode snippet here\n?\n\n@jeffwidman Already ahead of you :) See https://github.com/mbr/flask-bootstrap/pull/149 - The author notes that 3.3.7.1 has a fix for this. None of the other libraries/projects that I use have run into this problem, but that doesn't mean they don't exist (why I'm thinking documenting this is a good idea).. ",
    "dirkd": "Agreed, I was probably trying to mimic equalto a little to much here. Naming the test in is probably for the best for its discovery.\nSince I don't know the your preferences on the organizational side of PRs:\nShall I edit the PR and its OP (annotating the edited passages) by force-pushing or add a rename commit on top?. Force-pushed the commit and edited the PR description to match it.. ",
    "ricard33": "Some packaging tools like PyInstaller need to load every modules to try to find dependencies. This is not a solution for them to ignore loading/parsing error because these errors have to be reported to the user. \nCurrently, I haven't any solution to exclude these incompatible files from PyInstaller analysis. And I think it would be a lot cleaner to not install modules that can't be load by current python interpreter. . ",
    "voussoir": "Hi, sorry for the necro and wall of text but this is something I would be interested in writing a PR for.\nSubsorting is usually done with tuples:\n```Python\n\n\n\ndicts = [\n...     {'name': 'Mike', 'age': 20},\n...     {'name': 'Angela', 'age': 20},\n...     {'name': 'Alice', 'age': 30},\n... ]\nsorted(dicts, key=lambda d: (d['age'], d['name']))\n[{'name': 'Angela', 'age': 20}, {'name': 'Mike', 'age': 20}, {'name': 'Alice', 'age': 30}]\nsorted(dicts, key=lambda d: (d['name'], d['age']))\n[{'name': 'Alice', 'age': 30}, {'name': 'Angela', 'age': 20}, {'name': 'Mike', 'age': 20}]\n```\n\n\n\nAnd jinja evals tuples just fine:\n```Python\n\n\n\nimport jinja2\njinja2.Template('{{ a|sort(attribute=(\"test\",)) }}').render(a=[])\nmake_attrgetter recieved: ('test',)\n'[]'\n```\n\n\n\nThis is good because you don't have to let commas have a special meaning as in the OP.\nmake_attrgetter already has rules on how to prepare its input into a \"parts\" list. It could have a new rule for tuples that recursively prepares the elements:\n```Python\ndef prepare(attribute):\n    if attribute is None:\n        attribute = []\n    elif isinstance(attribute, tuple):\n        attribute = tuple(prepare(part) for part in attribute)\n    elif isinstance(attribute, string_types):\n        attribute = [int(x) if x.isdigit() else x for x in attribute.split('.')]\n    else:\n        attribute = [attribute]\n    return attribute\nattribute = prepare(attribute)\n```\nIf attrgetter detects that a part is a tuple, it can also use recursion to getitem each piece separately. The final results will therefore also be a tuple, so we can return results[0] when there is only 1 item to keep it backwards compatible. You will only receive a tuple out if you put a tuple in.\n\u00a0\nPython itself does not have an answer to the \"one column asc, other column desc\" question other than negating integers or chaining sorts, so if that doesn't make it into Jinja this would still be a net gain.\nThoughts?. ",
    "ryanmerolle": "Would it be possible to also extend this to allow sorting based on an attribute and a filter?. ",
    "alexk307": "@davidism or @ThiefMaster bump when you get a minute. ",
    "jdahlin": "I would also like to point out that, the jinja compiler will attempt to merge multiple TemplateData into one statement in the generated code, eg:\n<div id=\"a\">\n   <div id=b\"></div>\n</div>\nWill end up being compiled into something like this:\nyield '<div id=\"a\">\\n    <div id=b\"></div>\\n</div>'\nThat line requires multiple entries in debug info,  executing it should tell the coverage plugin that 3 different template lines are in fact being covered.\nThis is likely to be more involved as template.get_corresponding_lineno() would actually return more than one line in these cases.\nThere are a few statements like this in jinja, with/endwith for instance, which do not have an obvious line in the compiled output. I wonder if the compiler should start emitting some kind of noop statement just to get better debug info generated.\n. ",
    "nzjrs": "FYI https://github.com/MrSenko/coverage-jinja-plugin has been valuable in my testing and it would only be better if the HTML output could be made correct through the fix this patch provides.. ",
    "s0undt3ch": "We're actually using Jinja to \"templatize\" some yaml files and I was after some way to provide coverage information on those files.\nI'm not saying jinja2 should report all lines, specially if it hurts performance, but maybe optionally provide them?\nAnyway, this coverage approach does sound interesting.. ",
    "alanhamlett": "For an immediate solution, I created two custom Jinja2 template functions to get/set globals on flask.g. It persists variables across loop iterations:\n```python\nGetter for Flask.g request global\ndef get_global(key):\n    return flask.g.get(key)\napp.jinja_env.globals.update(\n    GET_GLOBAL=get_global,\n)\nSetter for Flask.g request global\ndef set_global(key, val):\n    setattr(flask.g, key, val)\n    return ''  # return empty string to prevent modifying template\napp.jinja_env.globals.update(\n    SET_GLOBAL=set_global,\n)\n```\nUse in your template like:\nhtml\n{{ SET_GLOBAL('myvar', 'someval') }}\n{{ GET_GLOBAL('myvar') }}. @mscheper also check out #676#issuecomment-304051565 with a solution using a custom template function to get/set globals if you're using Flask.. ",
    "majkls23": "After upgade to 2.9.5 issue disappeared. Version 2.8 is also ok. I am sending code only for clarification On 2.9.4 i got following backtrace:\npytb\nTraceback (most recent call last):\n  File \"X:\\sw-jachym\\gui\\PrasnostPanel.py\", line 288, in GenerovatReport\n    render(sablona, \"mereniPrasnost_mereni#\"+str(id), dlg2.GetPath())\n  File \"X:\\sw-jachym\\lib\\sablonator.py\", line 332, in render\n    t.render(d, jinja_env)\n  File \"C:\\Python27\\lib\\site-packages\\docxtpl\\__init__.py\", line 123, in render\n    xml = self.build_xml(context,jinja_env)\n  File \"C:\\Python27\\lib\\site-packages\\docxtpl\\__init__.py\", line 88, in build_xml\n    xml = self.render_xml(xml, context, jinja_env)\n  File \"C:\\Python27\\lib\\site-packages\\docxtpl\\__init__.py\", line 81, in render_xml\n    dst_xml = template.render(context)\n  File \"C:\\Python27\\lib\\site-packages\\jinja2\\environment.py\", line 1008, in render\n    return self.environment.handle_exception(exc_info, True)\n  File \"C:\\Python27\\lib\\site-packages\\jinja2\\environment.py\", line 780, in handle_exception\n    reraise(exc_type, exc_value, tb)\n  File \"<template>\", line 1, in top-level template code\n  File \"C:\\Python27\\lib\\site-packages\\jinja2\\environment.py\", line 430, in getattr\n    return getattr(obj, attribute)\njinja2.exceptions.UndefinedError: 'mereniPrasnost_lokace' is undefined\nCode:\n```python\nclass ContextDictator(Context):\n    def init(self, environment, parent, name, blocks):\n        self.debug = False\n        Context.init(self, environment, parent, name, blocks)\n        # soukrome promenne, ktere jsou dynamicky nacitany z DB\n        self.table = None\n        if self.debug: print \"ContextDictator.init()\"\ndef resolve(self, key):\n    if self.debug: print \"resolve()\"\n    if key in self.vars:\n        return self.vars[key]\n    if key in self.parent:\n        return self.parent[key]\n    try:\n        return self.environment.dictator[key]\n    except Exception, e:\n        print e\n        return self.environment.undefined(name=key)\n\ndef get(self, key, default = None):\n    if self.debug: print \"get()\"\n    try:\n        return self[key]\n    except KeyError:\n        try:\n            return self.environment.dictator[key]\n        except Exception, e:\n            if self.debug: print e\n            return default\n\ndef __contains__(self, name):\n    if name in self.vars or name in self.parent:\n        return True\n    else:\n        try:\n            self.environment.dictator[name]\n        except Exception, e:\n            if self.debug: print e\n            return False\n        else:\n            return True\n\ndef render(template, dictator_init_string, output_file):\n    d = Dictator(None, dictator_init_string)\n    t = DocxTemplate(template)\n    f = Filters(conn = d.conn, tmpl = t)\njinja_env = jinja2.Environment()\n# definujeme spojeni pro DB\njinja_env.dictator = d\njinja_env.context_class = ContextDictator\n\nf.apply(jinja_env)\n\nt.render(d, jinja_env)\nt.save(output_file)\n\n. ",
    "nowox": "So could I do something like this instead: \nTemplate(\"{% for i in data() %} {{i}}{% endfor %}\\n\" * 2).render(data = gen10)\n. Yeah it works :) So it could be the answer to my question actually.... ",
    "mscheper": "Sorry to ask this here, but I couldn't find any general Jinja forums. It looks like this feature will be included in Jinja 2.10. Has this been scheduled for release, and is there a way to find out when that's likely?. ",
    "jkfran": "Hello @ThiefMaster thank you!\nI'm sorry for the merge commits. What do you think now?\n. @ThiefMaster well it's Generator Expressions vs. List Comprehension, I was reading and you are right for these case Generator Expression is better.\nhttp://stackoverflow.com/questions/47789/generator-expressions-vs-list-comprehension. ",
    "DennyWeinberg": "OK. Thank you. So you can close this issue.. ",
    "maxrosenblattl": "You are right, use cases like\n{{ foo(bar=\"foo&quot;bar\") }}\nWill break with the current state, this needs some rework.\nThe use case for the request is actually the other way round: it is about creation of templates in the application, not using rendered output.. ",
    "funseiki": "The workaround for this appears to be to do the macro definition check before importing for each macro defined.\nE.g.\n```jinja\nif not Foo\nfrom \"macros\" import Foo\nendif\n```. ",
    "th0mas": "It does, I feel silly now.\nTo avoid this in future could the render_async method be added to the documentation under Async Support? \nIts not immediately obvious you need to call a different method.\nI don't mind filling a PR for this later . ",
    "AMDmi3": "It is. Setting leeway to 0 fixes the issue. I'd say it's POLA violation when using short strings.. ",
    "macropin": "Yeah I agree @AMDmi3 . We just hit this issue as well. \nThe problem is that Jinja has an opinionated implementation which is incompatible with usage as a general purpose templating engine.. ",
    "diego-treitos": "I also found this problem and spend several hours finding the bug. Clearly new options should be backwards compatible and the default should be leeway = 0.\nWhoever starts using the new option leeway they will know it exists and will use the value they please. Those who dont know about the new parameter wont need to change their code.... ",
    "magnetik": "I agree with the confuseness caused by the use of list for this, but this filter would be usefull to have a short way to cast a single item into a list of one item or doing nothing if variable is already a list.. ",
    "xychix": "crashing wouldn't be the best behaviour...\nJust return the input value, or return an empty string, or cast to string... all fine by me but not crashing hard :)\n. my bad, this can be easy solved by changing the template to:\n{% for item in  data.list %}item is{{ item | string | truncate(4) }}{% endfor %}\nI'll close this issue. My apologies. ",
    "mcondarelli": "Thanks for the prompt answer.\nPersonally I edited lexer.py not to include jinja2._stringdefs at all (in a rather brutal way; see patch below), but I still think it would be a nice feature to have in the mainstream version.\nIt seems there's little attention for performance issues (central in the embedded world, but admittedly secondary on a Web Server).\nBTW: I already had to completely ditch Flask/connext because it had a (on another embedded) a startup time >5min.\nAs I'm active in the embedded/Buildroot area I was directed to ask to Jinja2 developers what they think about the issue before considering such a \"solution\" for the issue...\nSo, here I am ;)\nAny comment is very welcome.\nThanks.\n```diff\ndiff -ru a/jinja2/lexer.py b/jinja2/lexer.py\n--- a/jinja2/lexer.py<->2017-04-27 11:45:04.459555267 +0200\n+++ b/jinja2/lexer.py<->2017-04-27 11:46:47.988306713 +0200\n@@ -34,28 +34,29 @@\n                        r'|\"([^\"\\](?:\\.[^\"\\])*)\")', re.S)\n integer_re = re.compile(r'\\d+')\n-def make_name_re():\n-    try:\n-        compile('f\u00f6\u00f6', '', 'eval')\n-    except SyntaxError:\n-        return re.compile(r'\\b[a-zA-Z][a-zA-Z0-9_]\\b')\n-\n-    import jinja2\n-    from jinja2 import _stringdefs\n-    name_re = re.compile(r'[%s][%s]' % (stringdefs.xid_start,\n-                                         _stringdefs.xid_continue))\n-\n-    # Save some memory here\n-    sys.modules.pop('jinja2._stringdefs')\n-    del _stringdefs\n-    del jinja2._stringdefs\n-\n-    return name_re\n-\n-# we use the unicode identifier rule if this python version is able\n-# to handle unicode identifiers, otherwise the standard ASCII one.\n-name_re = _make_name_re()\n-del _make_name_re\n+name_re = re.compile(r'\\b[a-zA-Z][a-zA-Z0-9_]*\\b')\n.\n float_re = re.compile(r'(?<!.)\\d+.\\d+')\n newline_re = re.compile(r'(\\r\\n|\\r|\\n)')\n```\n. Thanks.\nI will see what we can do on our side.\nI would suggest a warning about this in the docs so whoever will need speed could use the same technique, hopefully having less pain to find the \"culprit\".\nThanks and Regards.. ",
    "jctanner": "Hey @davidism \nI'm working on addressing your inline code comments at the moment.\nIn terms of how Ansible will be using this... It's going to be transparent to our users, except that when they have chained template operations inside a playbook, types will be preserved all the way through.\nHere's a basic example:\n- hosts: el6host\n  connection: local\n  gather_facts: False\n  vars:\n      adict:\n          foo: \"1\"\n  tasks:\n    - set_fact:\n        tempres: \"{{ adict.foo|int + 3 }}\"\n    - debug: var=tempres\n    - debug: msg=\"{{ tempres | type_debug }}\"\nThe type for \"tempres\" is -always- unicode in Ansible right now. With this feature, it will be an integer.. @davidism that concat example breaks this test ...\nnative_env = Environment(native=True)\n        native_tmpl = native_env.from_string(\"{% for x in listone %}{{ x }}{% endfor %}\")\n        result = native_tmpl.render(listone=['a', 'b', 'c', 'd'])\n        assert isinstance(result, unicode)\n        assert result == 'abcd'\nThe result is \"cd\", which I presume comes from having iterated over the first two values in the generator and not being able to seek backwards.. @davidism @ThiefMaster I think I've addressed everything suggested up till now. Any further thoughts?. @davidism Would you want just the new code in environment.py moved to a separate file, or should I also move the new code in utils.py as well?. @davidism all code is in a separate \"nativetypes.py\" file now. I honestly don't know what makes sense in terms of naming the classes/files. I chose \"native\" because it espoused how I think about it, but I realize that's not how everyone thinks. If you or the rest of the team want to decide and pick a name, I'll do the renames.\nFor the docs, how much do you want in the docstrings versus in the \"docs\" directory? Is there a make script for the \"docs\" dir ... I didn't see anything obvious. How does the dev team build and examine docs prior to push?. @davidism first pass on webdocs is done. I wasn't sure where to put it in the TOC, so I placed last in the list, beneath tips n tricks.\nHere's a rendered example http://tannerjc.net/tmp/jinja/html/nativetypes.html\n. > Will you be willing to monitor this repository and keep this feature in sync with the rest of the code? Is there a plan within Ansible to provide maintenance for this?\nWe are going to have to \"vendor\" a copy of this code for older versions of jinja that our consumers might have, so yeah we have to keep ourselves in sync with upstream and do everything we can to keep the upstream functional.\nMy eventual goal is to see if the jinja dev team would consider allowing me to break up CodeGenerator.visitOutput into a few smaller functions. If so, the nativetypes code can be drastically smaller and maintenance will be much simpler. I did not want to muddy the waters and confuse that refactor with this feature, so I didn't bring it up yet.\n\nOur philosophy is to avoid adding more features unless they're absolutely necessary, since we have limited resources and want to keep the packages focused on one obvious use case. \"Render to Python types\" is not an obvious use case, given the features in the rest of the library.\n\nI fully understand that mentality. I'm still trying to build a list of useful examples of this feature that make sense outside ansible, but I also think that the community might have some input too.\n. @davidism I removed all of the text_type refs and set the finalize noop per your suggestions. Tests still seem to pass for me.. anything else I can do to help out here?. @davidism @ThiefMaster updated. @davidism @ThiefMaster @mitsuhiko any updates?. Looks like evaluation on the node happened too early ...\n```\n\n/home/jtanner/workspace/github/jctanner/jinja/jinja2/environment.py(555)_compile()->None\n-> import epdb; epdb.st()\n(Epdb) l\n550             \"\"\"\n551             try:\n552                 return compile(source, filename, 'exec')\n553             except Exception as e:\n554                 print(e)\n555  ->             import epdb; epdb.st()\n556\n557         @internalcode\n558         def compile(self, source, name=None, filename=None, raw=False,\n559                     defer_init=False):\n560             \"\"\"Compile a node or template source code.  The name parameter is\n(Epdb) print(source)\nfrom future import division\nfrom jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace\nname = None\n\ndef root(context, missing=missing, environment=environment):\n    resolve = context.resolve_or_missing\n    undefined = environment.undefined\n    if 0: yield None\n    pass\n    yield \nblocks = {}\ndebug_info = ''\n```\nI'm guessing we wanted that yield statement to be more like this? ...\nyield True.__class__. @davidism hacky workaround ...\n```diff\ndiff --git a/jinja2/nativetypes.py b/jinja2/nativetypes.py\nindex 3aca683..ade2982 100644\n--- a/jinja2/nativetypes.py\n+++ b/jinja2/nativetypes.py\n@@ -82,6 +82,10 @@ class NativeCodeGenerator(CodeGenerator):\n                 body.append(child)\n                 continue\n\nif isinstance(child, nodes.Getattr):\nbody.append(child)\ncontinue\n+\n             # the frame can't be volatile here, because otherwise the as_const\n             # function would raise an Impossible exception at that point\n             try:\ndiff --git a/tests/test_nativetypes.py b/tests/test_nativetypes.py\nindex d295466..8bff503 100644\n--- a/tests/test_nativetypes.py\n+++ b/tests/test_nativetypes.py\n@@ -92,3 +92,19 @@ class TestNativeEnvironment(object):\n         result = t.render()\n         assert isinstance(result, bool)\n         assert result is False\n+\ndef test_variable_dunder(self, env):\nt = env.from_string(\"{{ x.class }}\")\nresult = t.render(x=True)\nassert isinstance(result, type)\n+\ndef test_constant_dunder(self, env):\nt = env.from_string(\"{{ true.class }}\")\nresult = t.render()\nassert isinstance(result, type)\n+\ndef test_constant_dunder_to_string(self, env):\nt = env.from_string(\"{{ true.class|string }}\")\nresult = t.render()\nassert not isinstance(result, type)\nassert result == \"\"\n```\n\nThoughts?. @davidism do you want me to dig deeper on the constants issue or are we good for now?. An ugly way to \"fix\" the issue ...\n```diff\ndiff --git a/jinja2/nativetypes.py b/jinja2/nativetypes.py\nindex fe17e41..851c202 100644\n--- a/jinja2/nativetypes.py\n+++ b/jinja2/nativetypes.py\n@@ -78,8 +78,8 @@ class NativeCodeGenerator(CodeGenerator):\n                     raise nodes.Impossible()\n             const = child.as_const(frame.eval_ctx)\n\n\nif not has_safe_repr(const):\nraise nodes.Impossible()\n\nif not has_safe_repr(const):\n\n\nraise nodes.Impossible()\n     except nodes.Impossible:\n         body.append(child)\n         continue\n\n@@ -119,6 +119,8 @@ class NativeCodeGenerator(CodeGenerator):\n         for item in body:\n             if isinstance(item, list):\n                 val = repr(native_concat(item))\n\nif isinstance(val, (str, unicode)) and ' ' in val:\nval = '\"' + val + '\"'             if frame.buffer is None:\n                 self.writeline('yield ' + val)\n\n```\n\n\n@davidism is this a case where you would expect native_concat to return the quoted string?. @davidism thank you so much! You've made many ansible devs happy today!. @davidism I do all my microblogging in github comments =)\nNew downstream patch for ansible https://github.com/ansible/ansible/pull/32738. @arodier we're going to merge https://github.com/ansible/ansible/pull/32738 at the very beginning of the ansible 2.7 development cycle.. Fixed. Fixed. Does that mean you'd prefer a subclassed Environment?. \"My eventual goal is to see if the jinja dev team would consider allowing me to break up CodeGenerator.visitOutput into a few smaller functions. \". ",
    "sivel": "Speaking from my POV, and not on behalf of @jctanner \nI had initially voiced concern about this living outside of jinja, as the likelihood for a change to crop up in jinja, that impacts this code could be pretty high.\nMy initial recommendation was to get buy in from the authors of jinja, to keep this in mind, and perform external validation to ensure they were not breaking the code in Ansible to perform this, and potentially keeping us informed of such changes.  Obviously, this route has some problems.\nIncluding in jinja helps us ensure that they code is functional.  However at some level I do imagine we would need to vendor this code as well, to support older versions of jinja, such as those an OS packaging system would provide.\nWe already have some of this problem currently. An example was the 2.9 release, where changes broke some things for our users, that we had to deal with it, because we aren't tightly integrated from a community perspective.\nI'm not necessarily recommending a particular solution, just voicing some concerns.. It appears the actual issue is related to dropping test_equalto and adding operator tests in https://github.com/pallets/jinja/commit/d62f0500a70aaab5762691d4feb6b9bb2724a1ba. This results in no longer having a docstring for the method being used in the test, and thus no .. versionadded:: 2.8 spec.\nI'm not sure how we want to approach this.  Maybe a wrapper/closure that adds a docstring?. The overhead of addressing this is not worth solving.\nThanks for the response, I'll go ahead and close.. @davidism I think it probably makes sense to just handle that in the sphinx template.  I think any change could be helpful for historical context of these features.. ",
    "arodier": "Hello,\nThank for your hard work. In which version of Ansible this has been fixed?. Thank you!. ",
    "pleasantone": "I think it just requires a Markup() around the results before returning, but I'm afraid to submit the request because I don't know all the comprehensive test cases you'd want to run it through, and I'd feel negligent submitting without fully testing.  Sorry.. I totally agree, it would make a great beginner fix for someone. Best!\n\nOn May 1, 2017, at 10:52 AM, David Lord notifications@github.com wrote:\nDon't worry, it's not that bad! Adding Markup around it, then making sure the existing test doesn't escape something, should be fine.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. The documentation says it's only safe inside of scripts.  So either it's a bug that it's not surrounded by Markup() and you have to deal with people who were misusing it, or it's a feature, in which case, when you folks do eventually make autoescape the default (which is a very sane thing to do, and will squash more XSS bugs), you're going to have to deal with every place tojson is used, in a script, which is now going to need an explicit \"|safe\".\n\nThere's no perfect answer, but I'd lean towards following what the documentation always claimed it did, and save yourself the huge breakage you're going to experience any time someone runs with autoescape enabled (which is your stated future default).. ",
    "ayalash": "@davidism Can you please close this issue?   You merged my PR for fixing it (#718). ",
    "sidhujasminder": "@ThiefMaster Thankyou for your information. But if I use posixpath.join(os.path.dirname(file), 'content.html') it shows same error with c:\\python27\\lib\\site-packages\\jnpr\\jsnapy/content.html. How the path os.path.dirname(file) will have slashes changed to forward slash. Any idea?. Thanks @ThiefMaster.. ",
    "ben-whale": "I have encountered this problem also. As I understand it I should be passing the base path into the FileSystemLoader and then the name of the template file into the get_template() function? This isn't made clear documentation?\nAs a side point why is a distinction between template paths and system paths made? Is there some documentation I could read about this? . ",
    "icfly2": "I've had this problem too, but found that it has nothing to do with the backslashes \\.\nInstead it is just very intuitive where it looks for templates. I used env.list_templates() for my environment env to figure out where it was looking and them moved from there. \nin the get_template part you do need forward slashes, but the output of list_templates makes that pretty clear.. ",
    "FabriceSalvaire": "I filled this issue to open discussion on this topic, since a template engine can be used for code generation as well as for web (where cosmetic is not really a matter).\nIt could be it is more a matter of documentation, tips and examples.\nI don't have problem with indentation, but remaining blank lines and over complicated templates.\nAfter new investigations, it seems I have to set trim_blocks and lstrip_blocks to remove line containing jinja directives and fix remaining blank line with \"-\". Thus use both at same time.\nAlso note, I am not aware of the existence of  a compliant C++ indenter similar to C indent.\ni feel there is clever strategies to write template for code generation and a tutorial on this topic could help. I found https://www.chromium.org/developers/jinja which gives many advices.\n. I managed to improve my templates and I found one issue. I open new issue about this.. ",
    "jrschneider": "+1\nJinja: 2.10\nPython: 3.5.2 (Ubuntu 16.04.5 LTS). ",
    "dek-odoo": "@ThiefMaster \nIts no problem if comments are discarded, but not even any bad solution ?\nAnd what if I make changes in AST ?\nThanks for the quick reply.. @davidism @mitsuhiko . ",
    "jpassaro": "Sure, I only raised the issue to document the problem while I was working on it.\nHowever as I was working on one I found that a different one is available that doesn't have this issue.\nMaybe worthwhile to at least mention this defect and/or @mitsuhiko's alternative in the provided syntax file? Or just replace the broken syntax file with a copy from that repo? I'm happy to create a patch based on your preferences. Otherwise please feel free to close.. whoops thanks for noticing! fixed.. ",
    "shawnsi": "Thanks @davidism.  The jinja2 documentation doesn't reflect this though and I'm consuming that filter rather than the python method.  Shouldn't the project address this more clearly?. You know that but your users may not.  Just trying to help other people save time debugging this and avoid a similar issue being reported in the future.. ",
    "wanghaiqing2015": "jinja2 not support python 2.7 ?\nremove the below file, it can work. \nc:\\python27\\lib\\site-packages\\jinja2\\asyncsupport.py. alternative ?\ncx_freeze or  pyinstaller?. pyinstaller is ok, thanks. ",
    "lf-": "Probably. It looks like the regex is basically just testing if a character is in a certain range (which someone wrote a script to automatically generate that range). There already is a script that generates this range which needs reading.\nI think we can actually reduce the time this takes considerably at runtime as well since it can most likely be reduced to character code (read: integer) comparisons.. I'm poking around in the source for that particular module. It's evident that the author was likely going to do something sensible, but then realized that there were combining characters.\nIt seems that the code actually has a bug in it: Take for example \\u0327. That's a combining cedilla, which puts a cedilla on a character before it. That means that c\\u0327 will look like \u00e7. On normalization, it is turned into \u00e7. The current code normalizes just the characters in the list it pulls from unicodedata. That means that \\u0327 normalizes to \\u0327 and thus names with combining characters may behave weirdly.\nWhat I'm planning to do and submit as a patch, is to move all this into runtime since it takes microseconds to find unicode character categories, which should be a hell of a lot faster than regexes.. Hm. I can check if a string is a valid name, but I don't know how to integrate it into the parser. Can you (or anyone else) provide some assistance on that front?. Well, in writing property-based tests for my checking code, I broke the old one several times:\n\ud803\udc9f\u03a5\ud835\udc7c\u1efa\ud835\udda5\u042e\u042f\u04f8\ua762\u13d7\n\ud809\udc67\ud800\udd48\ud809\udc4c\ud800\udd6f\ud809\udc40\ud809\udc24\ud809\udc25\ud800\udfd3\ud809\udc01\u217c\n\ud800\udd67\ud800\udd67\u216c\ud809\udc06\ud809\udc1d\ud809\udc1e\ud800\udd49\ud800\udd56\ud809\udc08\ud800\udd46\nAccording to the categories, these should be legit names. They're not according to the old name checker.\nInitial code is up on lf-/jinja, branch fix-name-checking. It has tests. Still need help integrating it into the rest of the codebase however (given that it appears that the parser just uses regex for everything).\nLinky: https://github.com/lf-/jinja/tree/fix-name-checking\nEdit: the first one when assigned to 1 in my python terminal works just fine, so the old code is actually bugged.. Please clarify what you mean by \"match the python 3 identifiers\". Do you mean the solution needs to use compile? Or that it still falls back to ASCII?. @mitsuhiko my PR should definitely do that.. The issue with isidentifier is that it's python 3 only. I guess it doesn't matter though because \\w should include any ascii identifier characters, so just check for its existence before trying anything.\nAgreed on the debug info. This was done because I don't know enough about the parser or parsers in general to mess with it, so allowing it to blow up is fine with me.\nInterestingly enough there appears to be some sort of checking of characters that raises TemplateSyntaxError in python 2 vs just generating bad code in python 3. Perhaps this could be modified?. Some of the examples in my test case produce that effect in python 2 vs python 3.\nI found that for the most part, \\w includes all the identifiers. I wrote a quick script to find out:\npython\ncre = re.compile(r'\\w')\nfor cp in range(sys.maxunicode + 1):\n    s = chr(cp)\n    if s.isidentifier() and not re.match(cre, s):\n        print(hex(cp))\nOutput:\n0x1885\n0x1886\n0x2118\n0x212e\nThese are:\nMONGOLIAN LETTER ALI GALI BALUDA\nMONGOLIAN LETTER ALI GALI THREE BALUDA\nSCRIPT CAPITAL P\nESTIMATED SYMBOL\nTo be honest, this seems like a python bug. Regardless, I doubt anyone is using these.. I confirmed that \\w matches all meaningful identifiers:\n```python\nimport re\nimport sys\nimport unicodedata\ncre = re.compile(r'\\w')\nfor cp in range(sys.maxunicode + 1):\n    s = chr(cp)\n    if s.isidentifier() and not re.match(cre, s):\n        print(hex(cp), unicodedata.name(s))\n```\nValid identifiers not matched by \\w:\n0x1885 MONGOLIAN LETTER ALI GALI BALUDA\n0x1886 MONGOLIAN LETTER ALI GALI THREE BALUDA\n0x2118 SCRIPT CAPITAL P\n0x212e ESTIMATED SYMBOL\nBeyond that, it appears that the clauses for the try-except at the start are backwards, causing python 2 to raise and python 3 to not have unicode identifier support.. ",
    "radiantone": "Hi,\n  Thank you for quick response. So in my system, I have modules that I load at runtime. Each module is a directory with  module/view.html (template), module/view.json, module/view.js etc.\nWhen the system loads all the modules, it updates the template path to the directory of each module and the rendering module puts itself first. This may seem out of the ordinary, but it allows me to do inheritance of views. Anyway, it used to work fine. but now whenever the first view.html is rendered, then that becomes the template returned regardless of the jinja path pointing to a different view.html in a different directory.. Regardless of my system design, Jinja should know the different between somedirA/view.html and somedirB/view.html. Currently, it does not.. No. That's not the case. Let me clarify.\nLet's say jinja.path is set to ['moduleA/','moduleB/'] directories.\nmoduleA/\n    view.html\nmoduleB/\n    view.html\nI then ask jinja to render_template('view.html'). It renders moduleA/view.html\nIf later I want it to render moduleB/view.html, I always get back moduleA/view.html because it only sees \"view.html\" in the cache. Again, this worked as I expected it to before recent (month or so) releases.\nDoes this make more sense?\nThe reason I have to jump through these path hoops is because jinja doesn't let me simply do:\nrender_template(\"moduleB/view.html\") which would be the most sane thing to do.. The way my system is setup is that I am loading modules of my application using Flask blueprints. At load time, I don't know where or what templates those loaded blueprint modules might define. They are defined in a json descriptor, including the directory where these templates reside. Thus my app rebuilds the jinja paths on the fly to render views as layers. It's a beautiful system and worked fine before recent jinja changes. I would consider this use case in your future code updates. It's quite powerful.\nFor now, I just rename all my templates:\nmoduleA/moduleA.html\nmoduleB/moduleB.html\nwhich breaks the \"pattern\" a bit but is not too cumbersome.\nIf at least jinja uses the path to the template (which it must have under the covers) in the cache id, then this problem goes away and jinja is a little smarter for it.. Ok, I see that templates are sometimes not files, but given whatever kind of template is being accessed the cache can choose the most unique possible key for it. IF its a file, then the absolute path is easily had.\nIs there a way to disable the cache? I already use a decorated cache on my flask routes. I don't need jinja also doing it. In fact, it creates a problem.. So is there a work around? I think those other tickets are related but not duplicates. This behavior changed recently. So my ticket was created due to this change. I will revert to older version of Jinja and document the change. But I think the general problem here is that template names do not uniquely define the template. That would force a single template namespace which is a bad design on systems. It would be similar to have one directory only in a filesystem and having to name every file different. . ",
    "RichardCochrane": "@ThiefMaster I think you're right. I did search the repo for dups and although that issue relates to imports and includes, the symptoms (and probable cause) of both do appear to be the same. Do I just close this off or should I add a reference to this issue on that issue (so that macros are specifically included in the problem definition)?. ",
    "Jossnaz": "it would be awesome to see some progress, this bug has been lying around for 5 years, and it affects everyone developing with nested macros, which basically should be everyone developing with jinja.. actually found issues here\nhttps://github.com/pallets/jinja/issues/742\nand here\nhttps://github.com/pallets/jinja/issues/253\n5 years anniversary of the bug...\nat least you now have a great minimal project to run the tests and fix the issue https://github.com/Jossnaz/lektor_issue_411. ",
    "vlad1777d": "@davidism , ok. I made some example.\nAlso I figured out, that such bug appears only when templates, that include other templates, extend some other template.\nTemplate base.html:\n```\n\n\n{{ SITENAME }}\n\n{% block body %}\n{% endblock body %}\n\n```\nTemplate a.html:\n```\n{% extends \"base.html\" %}\n{% set var_a = \"variable_text\" %}\n{% block body %}\n\n{% include \"c.html\" %}\n{{ var_a }}\n\n\n{% endblock body %}\n```\nTemplate b.html:\n```\n{% extends \"base.html\" %}\n{% set var_a = \"variable_text\" %}\n{% block body %}\n\n{% include \"c.html\" %}\n\n\n{% endblock body %}\n```\nTemplate c.html:\nThis is template c.html. Here must be variable: {{ var_a }}. Template finished.\nOutput a.html:\n```\n\n\nBug example\n\n\nThis is template c.html. Here must be variable: variable_text. Template finished.   variable_text\n\n\n```\nOutput b.html:\n```\n\n\nBug example\n\n\nThis is template c.html. Here must be variable: . Template finished.\n\n\n```\nHere is pelican's project archive:\njinja-bug-example.tar.gz\nSource templates are located in ./sources/theme_general/templates\nOutput templates are located in ./output\nTo build project you need pelican package (apt install pelican).\nThen open root folder of a project in terminal and write \"pelican\".. @davidism , sorry for disturbing, had you seen my additions to related to this bug ?. ",
    "cclauss": "Flake8 can catch issues that are useful to know about when submitting pull requests.  Taking the blanket approach hides those issues from the contributor.  Taking the targeted approach (noqa: F821) is more verbose but it signals a conscious choice (\"Kinda like: Yes, I am over 18, I know what I am doing...\"). ",
    "lhoss": "Why no motivation to fix this?\nRef: https://stackoverflow.com/questions/35775207/remove-unnecessary-whitespace-from-jinja-rendered-template#35777386\nIn our case, using a '-+' combo would have been useful in an ansible (jinja2-)template to avoid spaces before {%...  (to keep same indenting for intermixed lines of logic and contents ):\n```\n\n  {%- if ... +%}\n  \n\n  {%- if ... +%}\n strips before\n```. ",
    "sunqingyao": "I'm getting different error messages for different template code (I've edited the issues' titles to make this clearer), so I think it might be better to open separate issues for them.. ",
    "FreddieChopin": "Also the loop.length goes crazy in case of generators.\nTemplate:\nBegin\n{% for v in [0, 1, 2] | select('odd') %}\nv {{ v }}\nloop.length {{ loop.length }}\n{% endfor %}\nEnd\nOutput when rendered:\nBegin\nv 1\nloop.length 2\nEnd\nPython 3.6.5, Jinja 2.10. You don't need filters to trigger this behaviour - a {% for ... if ... %} construct has it too.\nTemplate:\nBegin\n{% for v in [0, 1, 2] if v // 2 != 0 %}\nv {{ v }}\nloop.length {{ loop.length }}\n{% endfor %}\nEnd\nOutput:\nBegin\nv 2\nloop.length 2\nEnd. I think this information should be explicitly stated in the documentation with bold font if you don't intend to fix it. It's not that I have purposefully used backslashes - when generating the filename using some other python code (for example by searching the folders for appropriate extensions), the string has system's native slashes (so backslashes on Windows). In that case you have to explicitly replace the slashes...\nBTW - I'm not using Windows, but I'm writing a script which should work on all platforms.. Also related to #751. ",
    "nixjdm": "Saving breaking changes and name consolidation for a Jinja v3 sounds great to me. We might as well try to find what breaking changes we can slate for it.\nI'd like to remind everyone of a potential one - allowing included block overrides. That issue doesn't have to mean a breaking change, but if that's the route you all want to go, remaking/opening that issue with a v3 milestone is how I'd do it. Sorry for the tangent. :) Perhaps we can make another ticket for discussing what to break / milestone for Jinja v3.. Regardless of whether it's considered a feature or bug I guess, in 2.10 and master I also get TemplateSyntaxErrors easily. If I put many things that shouldn't work inside {% if false%}{%  endif %}, it breaks, which is conceptually similar to just using a non-existent filter. Jinja is trying to interpret everything, in order to find the next else or endif I think, instead of literally matching against those special strings and skipping whatever is in between.\nExamples of things that fail right now:\n\n{% if false %}{% if foo bar %}{% endif %}; TemplateSyntaxError: expected token 'end of statement block', got 'bar'\n{% if false %}{% foo %}{% endif %}; TemplateSyntaxError: Encountered unknown tag 'foo'.\n{% if false %}{{ 'foo'|bar }}{% endif %}; TemplateAssertionError: no filter named 'bar'\n\nAn argument against changing this behavior is that the errors may be useful for debugging during normal template development, i.e., not when taking advantage of ignoring things inside an if block.\nPersonally, unless there's a good reason I haven't thought of yet, I'm in favor of changing the behavior. I'd say skip the execution of the if blocks when the test fails.. > since {% foo %} can affect the generated code that needs to be evaluated at compile time as well.\nShould that be the case though, if it's within a failing test block like {% if false %}?  I may be missing something, but I don't think I understand that. Is there a use case you have in mind?\nI don't mean to belabor this point; it's fine if that shouldn't change. I may just misunderstand.. ",
    "umrashrf": "@davidism the same code works when I switch to PY2.\nIn PY3 the string type is actually bytes (b\"\") so that could be the issue.. @davidism what is your PY3 version?. @davidism Okay the issue was I was encoding content to utf-8 before passing it to Template(). Now I am encoding the result of tpl.render(**kwargs).encode(\"utf-8\") and it works.. ",
    "KevinMGranger": "I think this might be the cause of the strange behavior I've found here.\n```python\nfrom jinja2 import Environment\nexpr = Environment().compile_expression\nctx = dict(foo=\"baz\", bar=\"\")\nRecreating bool(string) behaves as you expect.\nexpr(\"(foo | length) != 0\")(ctx) # True\nexpr(\"(bar | length) != 0\")(ctx) # False\nComparing them, however...\nexpr(\"((foo | length) != 0) != ((bar | length) != 0)\")(ctx) # False\nHuh? Do I not remember how boolean logic works?\nexpr(\"foo != bar\")(foo=True, bar=False) # True\nLet's try another syntax, which should be equivalent:\nexpr(\"((foo | length) != 0) is not eq((bar | length) != 0)\")(ctx) # True\nStrange. Let's also try the ruby/js style of casting to a boolean:\nexpr(\"(not not foo) != (not not bar)\")(ctx) # True\nAnd just out of curiosity, what if we applied the non-operator way to the length tests themselves?\nexpr(\"((foo | length) is not eq(0)) != ((bar | length) is not eq(0))\")(ctx) # True\n``sameas` is the only workaround that worked aside from adding more indirection in Ansible (due to the version of jinja used). Thank you!. ",
    "stevenorum": "I did a bit of investigation.  It appears that somewhere in the process of converting a statement containing one or more boolean comparisons between a variable and another object into the underlying bytecode, it drops the parens around the comparisons, but it keeps them for entirely numeric operations.  For example, it considers the first two equations below identical, but considers the third different (which at least is correct):\n```\n(i+1)*(j>3)\nends up with the same bytecode, stack, etc. as\n(i+1)*j>3\nbut not the same as\ni+1*j>3\n```\nIt works correctly if the comparison is between two predefined constants.\nHere's an incredibly simple test that should probably be added to the unit tests somewhere:\nfrom jinja2.nativetypes import NativeEnvironment\nassert 2 == NativeEnvironment().compile_expression(\"i*(j<5)\")({\"i\":2,\"j\":3})\n(I can do this later, but I have to get back to my actual job so I can't do that now.)\nIf the expression is too complicated to just break out to not use parentheses, you can get around this by breaking the boolean part into a separate variable (set temp=boolean result, then use temp in the larger equation).\nBelow is the script I used to determine this, if anyone who knows more about the parsing stack wants to dig further.  (I'll try to look into it more later but I've never touched the internals of Jinja2 so I'll probably get bogged down before finding anything.)\n```\n!/usr/bin/env python3\nfrom jinja2 import Environment, BaseLoader\nimport inspect\ndef printmembers(x):\n    members = inspect.getmembers(x)\n    members.sort(key=lambda a: a[0])\n    for m in members:\n        print(m[0])\n        print(m[1])\n        print(\"\")\ndef compare(expr, variables={}):\n    variables = dict(variables)\n    print(\"===============\")\n    print(\"VARS: {}\".format(variables))\n    print(\"EXPR: '{}'\".format(expr))\n    print(\"PYVAL: '{}'\".format(eval(expr, variables)))\n    print(\"J2VAL: '{}'\".format(Environment(loader=BaseLoader()).from_string(\"{{{{{}}}}}\".format(expr)).render(**variables)))\n    new_expr = \"qwer = ({})\".format(expr)\n    exec(new_expr, variables)\n    print(\"PEXEC: '{}'\".format(variables['qwer']))\nexprs = [\"t\",\"f\",\"i\",\"ti\",\"it\",\"fi\",\"if\",\"j<3\",\"j>3\",\"(j<3)i\",\"i(j<3)\",\"(j>3)i\",\"j>3i\",\"i(j>3)\",\"ij>3\"]\nvariables = {\"t\":True,\"f\":False,\"i\":5,\"j\":2, \"x\":None}\nfor expr in exprs:\n    compare(expr, variables)\ncomp = Environment().compile_expression\nw_parens = comp(\"(i+1)(j>3)\")\nwo_parens = comp(\"(i+1)j>3\")\nmembers_w = inspect.getmembers(w_parens._template.root_render_func.code)\nmembers_wo = inspect.getmembers(wo_parens._template.root_render_func.code)\nmembers_w = {x[0]:x[1] for x in members_w}\nmembers_wo = {x[0]:x[1] for x in members_wo}\nfor x in members_w:\n    if x.startswith(\"co\"):\n        print(\"{} : {}\".format(x, members_w[x] == members_wo[x]))\n```. Did some more debugging, ending up with the following script showing that it lies in the compilation of the parser syntax tree into the underlying code to be executed.\nChecked the code, looks like the compiler isn't adding parens when it generates that code in visit_Compare.\nCreated pull request https://github.com/pallets/jinja/pull/938 with the fix.\n(first blob is script, second is its output)\n```\n!/usr/bin/env python3\nfrom jinja2 import Environment\nfrom jinja2.parser import Parser\nfrom jinja2.compiler import generate\ndef indentprint(s, openers=\"[{(\", closers=\")}]\", newliners=\",\"):\n    indent = \"  \"\n    depth = 0\n    output = \"\"\n    for c in s:\n        if c == \"\\n\":\n            output += c + indentdepth\n        elif c in newliners:\n            output += c + \"\\n\" + indentdepth\n        elif c in openers:\n            depth += 1\n            output += c + \"\\n\" + indentdepth\n        elif c in closers:\n            depth -= 1\n            output += \"\\n\" + indentdepth + c\n        else:\n            if c in \" \\t\" and output[-1] in \" \\t\\n\":\n                continue\n            else:\n                output += c\n    output += \"\\n\"\n    print(output)\ndef print_resulting_src(src):\n    e = Environment()\n    print(\"EXPRESSION: '{}'\".format(src))\n    parser = Parser(e, \"{{\" + src + \"}}\").parse()\n    print(\"Parsed syntax tree:\")\n    indentprint(parser.dump())\n    print(\"Generated source:\")\n    print(\"=\"20)\n    print(generate(parser, e, None, None))\n    print(\"=\"20)\ns1 = \"(i+1)*(j>3)\"\nParser.parse will turn s1 into the correct syntax tree\n(with j>3 inside a Compare node)\ncompiler.generate will turn that into (a longer form of): ((i + 1) * j > 3)\ns2 = \"(i+1)*j>3\"\nParser.parse will turn s2 into the correct syntax tree\n(with (i+1)*j inside a Mul node, which is then inside a Compare node)\ncompiler.generate will turn that into (a longer form of): ((i + 1) * j) > 3\nprint_resulting_src(s1)\nprint_resulting_src(s2)\n```\n```\nEXPRESSION: '(i+1)*(j>3)'\nParsed syntax tree:\nnodes.Template(\n  [\n    nodes.Output(\n      [\n        nodes.Mul(\n          nodes.Add(\n            nodes.Name(\n              'i',\n              'load'\n            ),\n            nodes.Const(\n              1\n            )\n          ),\n          nodes.Compare(\n            nodes.Name(\n              'j',\n              'load'\n            ),\n            [\n              nodes.Operand(\n                'gt',\n                nodes.Const(\n                  3\n                )\n              )\n            ]\n          )\n        )\n      ]\n    )\n  ]\n)\nGenerated source:\nfrom future import division, generator_stop\nfrom jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace\nname = None\ndef root(context, missing=missing, environment=environment):\n    resolve = context.resolve_or_missing\n    undefined = environment.undefined\n    if 0: yield None\n    l_0_i = resolve('i')\n    l_0_j = resolve('j')\n    pass\n    yield to_string((((undefined(name='i') if l_0_i is missing else l_0_i) + 1) * (undefined(name='j') if l_0_j is missing else l_0_j) > 3))\nblocks = {}\ndebug_info = '1=12'\n====================\nEXPRESSION: '(i+1)*j>3'\nParsed syntax tree:\nnodes.Template(\n  [\n    nodes.Output(\n      [\n        nodes.Compare(\n          nodes.Mul(\n            nodes.Add(\n              nodes.Name(\n                'i',\n                'load'\n              ),\n              nodes.Const(\n                1\n              )\n            ),\n            nodes.Name(\n              'j',\n              'load'\n            )\n          ),\n          [\n            nodes.Operand(\n              'gt',\n              nodes.Const(\n                3\n              )\n            )\n          ]\n        )\n      ]\n    )\n  ]\n)\nGenerated source:\nfrom future import division, generator_stop\nfrom jinja2.runtime import LoopContext, TemplateReference, Macro, Markup, TemplateRuntimeError, missing, concat, escape, markup_join, unicode_join, to_string, identity, TemplateNotFound, Namespace\nname = None\ndef root(context, missing=missing, environment=environment):\n    resolve = context.resolve_or_missing\n    undefined = environment.undefined\n    if 0: yield None\n    l_0_i = resolve('i')\n    l_0_j = resolve('j')\n    pass\n    yield to_string((((undefined(name='i') if l_0_i is missing else l_0_i) + 1) * (undefined(name='j') if l_0_j is missing else l_0_j)) > 3)\nblocks = {}\ndebug_info = '1=12'\n====================\n```. ",
    "estianross": "Experience. I will be attempting this in my spare time not on company time. Care to share a few pointers on where to even start? The sphinx generated documentation is.. quite unfriendly. ",
    "RutujaWanjari": "Ok, Thankyou.. ",
    "OddBloke": "Playing around with this, the following seems to work in trivial cases:\n```diff\ndiff --git a/jinja2/environment.py b/jinja2/environment.py\nindex 2a4d3d7..1f8f309 100644\n--- a/jinja2/environment.py\n+++ b/jinja2/environment.py\n@@ -11,6 +11,7 @@\n import os\n import sys\n import weakref\n+from copy import deepcopy\n from functools import reduce, partial\n from jinja2 import nodes\n from jinja2.defaults import BLOCK_START_STRING, \\\n@@ -944,6 +954,18 @@ class Template(object):\n             None, 0, False, None, enable_async)\n         return env.from_string(source, template_class=cls)\n\ndef deepcopy(self, memo):\ncopy_namespace = {\n'name': self.name,\n'file': self.filename,\n'blocks': self.blocks,\n'root': self.root_render_func,\n'debug_info': self._debug_info,\n}\nreturn self._from_namespace(\ndeepcopy(self.environment), deepcopy(copy_namespace),\ndeepcopy(self.globals))\n+\n     @classmethod\n     def from_code(cls, environment, code, globals, uptodate=None):\n         \"\"\"Creates a template object from compiled code and the globals.  This\n```\n\nHowever, root_render_func is generated with a hard-coded reference to the environment that is generating it which means that copied templates will still contain a reference to the environment of the source template.\nThis means that the following code doesn't error with an UndefinedError on the last line:\n```py\nfrom copy import deepcopy\nfrom jinja2 import StrictUndefined, Template\nt1 = Template(\"{{ foo }} {{ bar }}\")\nt2 = deepcopy(t1)\nt2.environment.undefined = StrictUndefined\nkwargs = {'foo': 'bar'}\nprint(t1.render(kwargs))\nprint(t2.render(kwargs))\n``. For including of templates, the local variables are available because the return value ofself.dump_local_context(frame)is passed in toroot_render_funcwhenwith_contextisTrue` (around https://github.com/pallets/jinja/blob/master/jinja2/compiler.py#L918).. One solution would be to extend ContextReference to allow locals to be included (whilst still defaulting to the existing behaviour):\n```diff\ndiff --git a/jinja2/compiler.py b/jinja2/compiler.py\nindex 5135a77..6cfe750 100644\n--- a/jinja2/compiler.py\n+++ b/jinja2/compiler.py\n@@ -1670,7 +1670,10 @@ class CodeGenerator(NodeVisitor):\n         self.write(node.name)\n def visit_ContextReference(self, node, frame):\n\n\nself.write('context')\nif node.include_locals:\nself.write(self.derive_context(frame))\nelse:\n\nself.write('context')\ndef visit_Continue(self, node, frame):\n     self.writeline('continue', node)\ndiff --git a/jinja2/nodes.py b/jinja2/nodes.py\nindex 5ab2b31..61f2dd6 100644\n--- a/jinja2/nodes.py\n+++ b/jinja2/nodes.py\n@@ -943,6 +943,7 @@ class ContextReference(Expr):\n     Assign(Name('foo', ctx='store'),\n            Getattr(ContextReference(), 'name'))\n \"\"\"\n+    attributes = ('include_locals',)\n\n\nclass Continue(Stmt):\n```. An alternative would be to use a separate node type to provide the locals, but playing with that locally I just ended up doing the context.derive(locals) call myself; I don't know if there are many cases where extension authors would want the locals without the rest of the context, which is (I think) the only use case that approach would enable that the above diff doesn't.. Oh, just noticed that I should be using fields, not attributes on the ContextReference node.. Hey folks, this is blocking me from doing some Jinja extension work elsewhere, and is a fairly self-contained change. Is there anything I can do to help get some eyeballs on it?. I've rebased this on to master, so now I have a passing Travis build.. Thanks for letting me know!. ",
    "dseira": "The thing is that I've found this bug using salt configuration management (that uses jinja templating for the states), not writing a python program directly. But of course, a state can be splitted in several files.\nThanks @ThiefMaster . ",
    "hyperking": "@ThiefMaster Where should I properly store data extracted from the blocks?\n. @ThiefMaster I resolved my issue on stack overflow. Apparently it was rather simple but took us some time.\nHere is the link if any one has similar issue.\nhttps://stackoverflow.com/questions/46075071/flask-custom-jinja2-extension-caching-template-states-after-new-request. ",
    "cooperlees": "Can we also look at exempting the Py3 only .py files from the Py2 wheel?\nWhen I build pex's I also compile all .py files into .pycs and even tho 'async.*.py' files are not imported in Python2 I have issues due to the Py3 only source file existing in the Py2 wheel and trying to be compiled with 2.7.\nI can have a go at a PR - Anyone got good ideas about how to do this?. ",
    "methane": "Including Py3 only source in universal wheel or source package is very common.\nI think pex must fix it.  I don't think every package should change their package for pex.\nAnyway, it's not relating to this issue. . ",
    "pannal": "I have a similar problem. Not with looping the variable but simply with accessing the variable set in the template inside the contextfunction's passed context.. ",
    "bignose-debian": "This problem still occurs with Jinja 2.10:\n```\n\n\n\npprint.pprint(template_content)\n('Lorem ipsum, dolor sit amet, consectetur adipiscing elit.\\n'\n '\\x0c'\n '\\n'\n 'Pellentesque maximus a ligula ut vehicula.\\n')\nimport jinja2\njinja2.version\n'2.10'\ntemplate = jinja2.Template(template_content)\npprint.pprint(template.render())\n('Lorem ipsum, dolor sit amet, consectetur adipiscing elit.\\n'\n '\\n'\n '\\n'\n 'Pellentesque maximus a ligula ut vehicula.')\n```\n. > If this affects you and you can track it down [\u2026]\n\n\n\nMy attempts to track it down in a debugger session lead to code I can't inspect. The \u2018Template.root_render_func\u2019 turns out to not exist in the Jinja source code; maybe it's compiled from text at run time? I don't know how to track it further than that.. ",
    "mvolfik": "Oops, I've got Jinja 2.8, but 2.9 is the latest release and it's okay there. I'm sorry for confusing everyone with this issue.. ",
    "hugovk": "Well, that didn't help. Sorry for the noise, I should have made another temp branch and deleted this so I could test the feature branch first:\nyml\nbranches:\n  only:\n    - master\n    - /^.*-maintenance$/. ",
    "niklasp": "It is not even loading any snippet but fails when importing jinja in my script. updated the error log above with full trace.\nSeems like that:\nfrom jinja2 import Environment, contextfunction\nis failing. yes it was related to having a numbers.py in my unittest dir.. ",
    "wjdp": "Ah, couldn't find the docs for stable, the domain redirects to /latest by default. Perhaps /stable should be the default?. ",
    "snordhausen": "I was able to reproduce the segfault with the following code:\n```\nfrom jinja2 import Environment\nRANGE = 27000\ndata = {i: 2*i for i in range(RANGE)}\ntemplate_string = \"\".join('{{ data.%s }} ' % i for i in range(RANGE))\nprint(\"length of template string: %s\" % len(template_string))\nenvironment = Environment()\ntemplate = environment.from_string(template_string)\nrendered = template.render(data=data)\nprint(\"length of rendered string: %s\" % len(rendered))\n``\nThis template has a length of only ~450kB and still segfaults. After loweringRANGEto 26,000, the code works.\nNote that this is NOT an out of memory error. Viadmesg, I can see that the kernel did not report an OOM situation, it reportedpython[9163]: segfault at 7ffe8c282ff8.....`.\nEnvironment for me is Python 3.6.3 on Ubuntu 17.04 64bit with Jinja version 2.10.0.. Further investigation shows that this is a bug in CPython, not a bug in Jinja.\nThe code I provided above works fine (and produces the expected result) when I run it with Pypy instead of CPython. After noticing that, I found that the segfault is triggered by this line in Jinja. So it is Python's builtin compile function that segfaults.\nAfter noticing that, I was able to reproduce the segfault with this code:\nargs = \"42 if True else 43,\" * 270000\ncode = \"(%s)\" % args\ncompile(code, \"foobar\", \"exec\")\nThis produces a simplified version of the code that was auto-generated for my previous example. I can reproduce the segfault with Python version 2.7.13, version 3.6.3 and also the current git master of CPython. There's now an open ticket in CPython's bugtracker.. This issue will be gone in Python 3.7 because https://github.com/python/cpython/pull/3015 got merged. Since the original bug report is already closed, it seems like there will be no backport to Python 3.6 or 2.7.. For the record: This issue is fixed with CPython version 3.7.0.\nBoth of my previous code snippets work now. Python 3.6.6 does not have the fix, though, and still segfaults.. ",
    "TomekTrzeciak": "The main motivation is to be able to easily import additional functionality from Python modules using the same interface as for importing variables/macros from other templates, e.g.:\n{% from \"itertools\" import izip %}\nMy particular use case is templating configuration files of Cylc workflow engine. To use Cylc users are generally assumed to already have full shell access, so exposing whole Python library is really of no concern. Cylc already exposes adding user defined Jinja2 filters, but it's tedious to write filter wrappers for every little scrap of functionality.\nFrom your comment it's quite clear that you're not very keen on the idea, so arguing my point is most likely moot. But let me just point out that Jinja is used also in systems, where tight control over exposed functionality is not required, so I think this PR could be of broader appeal than my particular use case. Anyway, I rest my case ;-) Feel free to reject this PR if you think it's a bad idea.. ",
    "Matew92": "Hi thanks for the answers. I'm new on flask. How I can expose those operators to my flask view and then actually use them as operator in a pandas data frame ?. ",
    "tagirb": "Thanks! Helped me to understand Jinja better and to solve my issue.. ",
    "cbcoutinho": "Oops sorry, committed on my work account. Should be fixed. ",
    "bitsofdave": "I'm also unable to reproduce this now. Thanks for looking into it.. ",
    "strigazi": "@mitsuhiko I'm not sure how to fix this, can you elaborate a bit. Thanks!. ",
    "sampablokuper": "@mitsuhiko , thanks for taking a look. Seems to be related to my having used --user, as I did not receive the \"Segmentation fault\" message when using virtualenv instead.. ",
    "captainmalloc": "I didn't mean to add those commits. I am sorry about that, I'll clean it on a new commit.. Done. Sorry for the inconvenience.. This happened when the exception was on python callback in a custom extension. I'll try to build a simple test case.. ",
    "jdufresne": "In that case, shall I remove Python 2.6 & 3.3 from the trove classifiers and the testing matrix? That would signal to users that 2.6 & 3.3 are not intentionally or directly supported by the Jinja2 project. What do you think?\nHere are the pip downloads from Jinja2 over the last 30 days:\n$ pypinfo --percent --pip jinja2 pyversion\n| python_version | percent | download_count |\n| -------------- | ------- | -------------- |\n| 2.7            |   58.7% |      2,109,719 |\n| 3.6            |   18.9% |        679,141 |\n| 3.5            |   14.0% |        504,670 |\n| 3.4            |    7.5% |        270,369 |\n| 2.6            |    0.6% |         20,313 |\n| 3.3            |    0.2% |          6,765 |\n| 3.7            |    0.1% |          5,322 |\n| 3.2            |    0.0% |            289 |\n| None           |    0.0% |             26 |. I've made the requested change.. Removing 2.6 & 3.3 caused the tests to fail. Both in tox and Travis. It failed to install the Jinja package with \nJinja2 requires Python '>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*' but the running Python is 2.6.9\nUntil Jinja officially drops support for 2.6 & 3.3. This line should allow them. I've updated the PR to include them again.. I have rebased this on the latest master. Now that Python 2.6 and 3.3 have been dropped, I think this should be reconsidered.\n\nDropped 2.6: 5425921899f7c84b3a08e2dd06610beacb2fc20e\nDropped 3.3: d1fb22fd45ad6d0caa314fe373a377fbbf82ba08. I find them useful because they allow potential users to know -- at a quick glance -- what Pythons are supported by a library. Sometimes when integrating a library with my own projects, I'll use this information to help decide if it is good for integration.\n\nAs the trove classifiers have a consistent form, they are also used by sites and offline scripts to analyze the changes in the Python community. Some examples:\n\nhttps://python3wos.appspot.com/\nhttps://hugovk.github.io/drop-python/\n\nIf you don't support PyPy as a platform, then I don't think you should add it. But PyPy is included in CI, so it appears that compatibility is desired. I think adding CPython is only useful in contrast to PyPy so as not to give the impression that the library is PyPy only.\nUp to you.. - Updated to remove the tarball section\n- Also removed mentioning easy_install from the \"MarkupSafe Dependency\" section. To get Python 3.7, I switched the dist to xenial. Details on the release here: https://blog.travis-ci.com/2018-11-08-xenial-release\nUnlike trusty, xenial requires an explicit version for pypy. See the issue report here: https://travis-ci.community/t/pypy-2-7-on-xenial/889\nOn trusty, pypy3 is just an alias.. > I tried to do dist: xenial globally for Werkzeug a month ago and it didn't work. Guess something changed.\nPrior to the release, projects were required to add sudo: required to get xenial to work. But this has been resolved. Details here: https://github.com/travis-ci/travis-ci/issues/9815. ",
    "mkrizek": "@davidism anything else you want me to change here?. Looks like collections.abc.Generator [1] is new in Python 3.5 though. We'd need to use types.GeneratorType for previous versions?\n[1] https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator. :+1: . ",
    "PikachuEXE": "@davidism \nHi, I raised an issue https://github.com/ansible/ansible/issues/49012\nAnd it seems that I am supposed to use master of the repo\nWill there be a release soon?. ",
    "FKLC": "Thats an issue from my text editor I've fixed it.. ",
    "zubchick": "anyone?. ",
    "chamini2": "@davidism, what do you think?. ",
    "pravin123456": "Template.py file is not present under jinja2 package.\n[root@emp]# cp ../jinja2/jinja2/* .\n[root@emp]# ls\nasyncfilters.py  bccache.py  compiler.py   debug.py     environment.py  ext.py      _identifier.py  __init__.py  loaders.py  nativetypes.py  optimizer.py  runtime.py  tests.py  visitor.py\nasyncsupport.py  _compat.py  constants.py  defaults.py  exceptions.py   filters.py  idtracking.py   lexer.py     meta.py     nodes.py        parser.py     sandbox.py  utils.py\nAnd getting below error-\nTraceback (most recent call last):\n  File \"/usr/bin/ansible-playbook\", line 40, in <module>\n    import ansible.constants as C\n  File \"/usr/local/lib/python3.5/site-packages/ansible/constants.py\", line 12, in <module>\n    from jinja2 import Template\nImportError: cannot import name 'Template'\nCan you pl help me with above issue?\n. Okay, but i had downloaded the jinja2 from github also installed rpm for ansible using:\npm -ivh https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/a/ansible-2.4.2.0-1.el7.noarch.rpm\non Rhel7.\ngit clone http://github.com/mitsuhiko/jinja2.git\nStill not able to run the playbook due to Template module dependancy.\nCan you pl guide me with the exact workaround soln or steps to avoid this problem for rhel7.4 version?\nThanks,\n-Pravin.. ",
    "MrBillium": "Understood \u2013 thanks for the quick reply.\nSince this is counter intuitive, consider adding a tip/warning to the documentation \u2013 something like this:\nNote:  Jinja2 always parses the entire page for valid syntax including any commented out HTML or javascript.\nIf you want jija2 to ignore the commented code then look at {# comment } or simply remove the opening { to break the Jinja in your commented out section.. ",
    "tblanarik": "Taken from the Template Designer docs:\n\nImplementation\nFor the sake of convenience, foo.bar in Jinja2 does the following things on the Python layer:\n\ncheck for an attribute called bar on foo (getattr(foo, 'bar'))\nif there is not, check for an item 'bar' in foo (foo.getitem('bar'))\nif there is not, return an undefined object.\n\n\nI think I was imagining a step before these 3, which is:\n\n\nCheck that foo actually exists. If not, return an undefined object.. \n\n",
    "asenov": "This PR can be closed, I just created new one with the correct base branch. Wrong base branch . This is a fixable issue, but quick workaround is the following code:\nfrom jinja2 import Template\ntemplate = Template('{{ status == status }}, {{ (status == status) and constant}}, {{ (status == status) and true}}, {{ (status == status) == (status == status)}}')\ntemplate.render(status=\"a\", constant=True)\nIt gives: \nTrue, True, True, True\nRegards. So, any comments? . Hi, can you confirm that you have got an issue with that code: \n``\nfrom jinja2 import Template\ntpl = Template('''{{data['foo-bar']}}''')\ndata = {'foo-bar': 'Foo Bar'}\nassert tpl.render(data=data) == data['foo-bar']\n``. But as I can see exhaust of the iterable was done in filters.do_reverse. Do you think that here need changes?\n. Maybe this one can be moved to the base class? Since there in the parent class dependencies of this property?. ",
    "pcahyna": "This workaround works only in my artificial example, where the LHS was given as (status == status) and so always true. If we have a more realistic expression as the LHS, whose value can be either true or false, \"==\" is not equivalent to \"and\" anymore.. ",
    "danielmotaleite": "i forgot where i'm checking the documentation: http://jinja.pocoo.org/docs/2.10/templates/#list-of-builtin-filters. ",
    "ishakir": "Given that #839 has been closed, is there anything blocking this one being merged?. CI failure definitely not related to this change. Only failing on Python 3.3 with some venv error. I believe the build failure to be related to existing issues. This is a duplicate of the following:\nhttps://github.com/pallets/jinja/pull/822\nwhich fixes #821 as well.\nI have, however, gone through to check that there are no tests for open_if_exists. ",
    "flexferrum": "Why not to add type_id virtual field to each value? This field can represent the type name of the value and can be tested in the way most suitable for template author. . From the one side 'yes'. From the other... According this discussion current set of type testers can't guarantee the strong types distinguishing from each other. Another point: this feature will allow to authors decribe theirs own types came outside of template engine. Personally I have faced with the problem: I reflect variant type into Jinja template but haven't got the \"standard\" way to describe the currently reflected particular type from the variant cases. . > If you really want to test based on strings, you can already do that with value.class.name, or an application can add a test for that. But it's not something I'm willing to add to Jinja.\nYes. You right. It's better to implement via extension/application-specific test.. > if a value is an int or a float in the context of a template\nI suppose, arithmetic operations on ints and floats will have different results. Formatting of big numbers as well.\n\nAnd if we add these, why not every type in builtins and every abc in collections? And what about user-provided types? Maybe there's a better solution to checking types instead of adding individual tests for each?\n\nMay be extra 'universal' tester could help? Something like: true is typeof(boolean) or true is typeof(name='boolean') ? . > Fairly sure this is intentional. last would have to convert generators to a list first, which may be dangerous (infinite stream, user intentionally doesn't want to hold everything in memory, etc.).\nActually, the same issue could be addressed to the loop.length (and all related) loop property. Currently, it silently converts any arbitrary sequence to the list and then returns the length.. Had the same request in C++ implementation: https://github.com/flexferrum/Jinja2Cpp/issues/50\nImplemented it as a dedicated applymacro(value, name, *args, **kwargs) filter which can be called from map like this: {{ events|map('applymacro' name='event_detail')|join(', ') }}. @davidism, I see at least two such reasons:\n\nYou can apply macro as a filter for the single arbitrary value (not only for list/tuple)\nYou can keep the current semantic of the map filter which can apply only filters, but not any callable. \n\nAs explanation of the clause 2:\n\nQuick look at jinja2.filters.do_map(), uses context.environment.call_filter(). Might be able to detect if the first argument is a callable instead of a string, and use context.call() to invoke it.\n\nFrom my point of view, such modification could be dangerous. As far as I can understand there are a lot of callable objects in Jinja2. For instance: loop.loop(), super(), blockName() (where blockName is a name of some block), global functions etc. If you extend map semantic for any arbitrary callable you will be able to 'call' stuff like this. The result could be at least strange.. Can the actual macro name come from the outside (as the template param)? I suppose, yes.. ",
    "dagwieers": "\nAll of this seems very specific to Ansible. I've never had to do these sorts of type checks in templates, or in most Python code in general. Maybe the issue with inconsistent data that users have to check is something that needs to be addressed by Ansible?\n\nWell, since we need this as part of generating documentation, I don't think this really is an Ansible-specific issue. And I have proposed this for Ansible specifically, but IMO proper type-checking for all types is something the language could help with.\nI understand that if you are using Jinja for web-based templating and you have control over the data, this may be less of an issue, but Jinja is not (no longer) used as a one-purpose template engine.\nAnd yes, we are using constructions like {% if value is sequence and value is not string %}, which I'd rather not use if I didn't have to.\n@davidism So despite the naming of non-string sequences, you object to everything else too ? Testing for booleans is a dangerous thing too if there's no 'boolean' test. Without some of these tests Jinja is a minefield to most non-experts.. Some real-life advice on forums:\n- Checking if a value is an integer: {% if variable|int(-1) != -1 %}\n  https://stackoverflow.com/questions/41743796/how-to-check-if-a-variable-is-an-integer-in-jinja2\n- Checking if a value is a boolean: {% if variable is not sameas true and variable is not sameas false %}\n  https://stackoverflow.com/questions/46664127/how-do-i-fail-a-task-in-ansible-if-the-variable-contains-a-boolean-value-i-want\n- Checking if a value is true/false\n    https://stackoverflow.com/questions/8433450/why-doesnt-my-condition-logic-work-as-expected-in-jinja2-cherrypy\n  - Wrong advice has the highest score! {% if variable == true %}\n  - Second advice is casting variable to a string {% if variable == 'True' %}\n- Advice for testing if something is a list: %{ if variable is iterable %}\n  https://stackoverflow.com/questions/46664127/how-do-i-fail-a-task-in-ansible-if-the-variable-contains-a-boolean-value-i-want\nIf you don't think there's a problem in Jinja (beyond your use-cases), StackOverflow is a good reality check IMO. And I had some of the same issues before I decided we could do better and created the PR in Ansible and upstreamed it here.. In our case the documentation is generated from contributed YAML files, so we do want to ensure that we handle user-contributed input correctly and produce correct output regardless of the input type.\nHere is one of the use-cases where we added the list-test ourselves: https://github.com/ansible/ansible/pull/37514/files\nSo we have cases where the data provided could be a string or a list, and depending on which we also have to check if a value is the same as the string, or is included in the lists.. If we would go to a hand-off type of test, I'd rather have a 'type' test in the same light as 'sameas', rather than having switches to existing tests. (typeof doesn't sound right, oftype doesn't look right...)\njinja\n{% if variable is type boolean %}\n{% if variable is type integer %}\n{% if variable is type float %}\n{% if variable is type string %}\n{% if variable is type list %}\n{% if variable is type mapping %}\nShould we be testing for python types, or rather switch to Jinja naming above ?\nAnd this does not bring us any closer to naming the tests for non-string sequences :-/. Can someone make a (design) decision on this topic?\nSo that we can move forward with an implementation.. I will remove the list type checking from this PR as to not hijack everything else..  Please review!. I updated the tests, add a changelog entry and updated the docs.. Agreed. Fixed.. Agreed. Fixed.. ",
    "giovanniborella": "+1 for this feature. ",
    "unix196": "in which version Jinja2 it was fixed? Now in pip last version 2.10 and bug is still exist.. ",
    "norela": "In the utils.py, this issue is solved if you remove ')' from the 24th line:\n```\n_punctuation_re = re.compile(\n    '^(?P(?:%s))(?P.?)(?P(?:%s)*)$' % (\n        '|'.join(map(re.escape, ('(', '<', '<'))),\n        '|'.join(map(re.escape, ('.', ',', ')', '>', '\\n', '>')))\n    )\n)\n```\nto:\n_punctuation_re = re.compile(\n    '^(?P<lead>(?:%s)*)(?P<middle>.*?)(?P<trail>(?:%s)*)$' % (\n        '|'.join(map(re.escape, ('(', '<', '&lt;'))),\n        '|'.join(map(re.escape, ('.', ',', '>', '\\n', '&gt;')))\n    )\n)\nThe ')' is added to the 'trail'-group instead of the 'middle'-group at line 213.\nI don't know what impact/consequences this has on other inputs for the urlize function.. What about something like this.\n```\nimport re\nregex = r'((?:(https?|s?ftp):\\/\\/)?(?:www.)?((?:(?:[A-Z0-9][A-Z0-9-]{0,61}[A-Z0-9].)+)([A-Z]{2,6})\\\n|(?:\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}))(?::(\\d{1,5}))?(?:(\\/\\S+)*))'\nfind_url_in_string = re.compile(regex, re.IGNORECASE)\ndef urlize(string):\n    url = find_url_in_string.search(string)\n    if url is not None and url.group(0) is not None:\n        return(\"{} {} {}\".format(string.split(url.group(0).strip())[0], \n                                                url.group(0).strip(), url.group(0).strip(),\n                                                string.split(url.group(0).strip())[1]))\nstring = \"This is a link http://de.wikipedia.org/wiki/Agilit%C3%A4t_(Management) awesome\"\nurlize(string)\n``\nreturns:\"This is a link  http://de.wikipedia.org/wiki/Agilit%C3%A4t_(Management)  awesome\"`\nfound a regex to extract the url from a string on stackoverflow:\nhttps://stackoverflow.com/questions/9760588/how-do-you-extract-a-url-from-a-string-using-python#9760660\n. I see, thanks.\nMaybe it helps to check if there have been more occurrences of '(' as there are ')' in the part before the url, like so:\ndef urlize(string):\n    url = find_url_in_string.search(string)\n    if url is not None and url.group(0) is not None:\n        if string.split(url.group(0).strip())[0].count('(') > string.split(url.group(0).strip())[0].count(')') and \\\n                        url.group(0).strip().endswith(')'):\n            return(\"{} <a href='{}'>{}</a>) {}\".format(string.split(url.group(0).strip())[0], \n                                    url.group(0).strip().rstrip(')'), url.group(0).strip().rstrip(')'),\n                                    string.split(url.group(0).strip())[1]))\n        else:\n            return(\"{} <a href='{}'>{}</a> {}\".format(string.split(url.group(0).strip())[0], \n                                                url.group(0).strip(), url.group(0).strip(),\n                                                string.split(url.group(0).strip())[1])). Thanks for the feedback. Furthermore, I think the check should be recursive too.\nFor inputs like: \"This is a link (http://de.wikipedia.org/wiki/Agilit%C3%A4t_(Management)), awesome\"\nWhat do you think of the following:\n```\nimport re\nregex = r'((?:(https?|s?ftp):\\/\\/)?(?:www.)?((?:(?:[A-Z0-9][A-Z0-9-]{0,61}[A-Z0-9].)+)([A-Z]{2,6})\\\n|(?:\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3}))(?::(\\d{1,5}))?(?:(\\/\\S+)*))'\nfind_url_in_string = re.compile(regex, re.IGNORECASE)\ndef urlize(string):\n    url = find_url_in_string.search(string)\n    if url is not None and url.group(0) is not None:\n        url = url.group(0).strip()\n        pre_url = string.split(url)[0]\n        post_url = string.split(url)[1]\n        result = \"{} {} {}\"\n        escapechar1, escapechar2 = ['(', '<', '<']2, [')', '>','>']2\n    for _ in range(len(escapechar1)):\n        if (url[-1] in ['.', ',', '\\n']*2) or (pre_url.count(escapechar1[_]) > pre_url.count(escapechar2[_]) \\\n        and url.endswith(escapechar2[_])):\n            post_url = url[-1]+post_url\n            url = url[:-1]\n\n    return result.format(pre_url, url, url, post_url)\n\n``` . ",
    "mrecachinas": "@norela The consequence will be on inputs like the following that wrap an entire URL in parentheses (i.e., the parentheses are not part of the URL).\n```python\n\n\n\nurl_text = \"Hello world (http://www.foo.org).\"\nurlize(url_text) # with regex suggestion above by @norela\n'Hello world (http://www.foo.org).'\n```\n\n\n\nThis issue is trickier than it seems. \nIf we assume that if a URL contains parentheses, they must be balanced and cannot contain nested parentheses, we could add a quick fix after line 213 that looks something like:\n```python\n...\nlead, middle, trail = match.groups()\nnaive check for balanced parens\nif len(middle) > 0 and '(' in middle and len(trail) > 0 and trail[0] == \")\":\n    middle = middle + trail[0]\n    trail = trail[1:]\nif middle.startswith('www.') or (\n...\n```\nUnfortunately, the URL standard doesn't require parentheses be balanced and does not disallow nested parentheses, so this solution would be temporary and not robust.\nIf we instead assume that non-URL text should contain balanced parentheses, then an alternative potential solution may be to check lead and trail for balanced parentheses. If they are balanced, we keep the right-parenthesis in trail; if they are unbalanced, we append the right-parenthesis onto middle. This has the benefit of making no assumption about whether the URL's parentheses are balanced.. How does it perform with the following input?\npython\nstring = \"Foo (See http://de.wikipedia.org/wiki/Agilit%C3%A4t_(Management)) Bar\". Also, check out this Article by Jeff Atwood on this very issue. I think you're on the right track. Still seeing it fail on this case:\n```python\n\n\n\nstring = \"Foo (See http://de.wikipedia.org/wiki/Agilit%C3%A4t_(Management)) Bar\"\nurlize(string) # includes your proposed fix\nFoo (See  http://de.wikipedia.org/wiki/Agilit%C3%A4t_(Management)  Bar\n```\n\n\n\nYou'll notice it omitted the closing parenthesis in the URL -- i.e.,\nhttp://de.wikipedia.org/wiki/Agilit%C3%A4t_(Management\ninstead of\nhttp://de.wikipedia.org/wiki/Agilit%C3%A4t_(Management). Sorry for the delay. It seems reasonable. What do @mitsuhiko and @davidism think about this and the underlying assumptions?. ",
    "jkryanchou": "@davidism Any helper methods to solve this issue? escape/unescape keys to make it work?. ",
    "valtido": "(on the risk of sounding totally mad) IMO if you are already exposing that data to the template it does not really matter what's leaked, From nunjucks perspective (not familiar with jinja) the data is contained by the context anyways any sensitive data does not even get to pass through the template.\n. ",
    "patrickelectric": "Ty @davidism, After reading about 2.10 I got the correct solution for my problem.\nI added here if someone want to follow.. ",
    "Kwpolska": "Okay, that\u2019s embarrassing. The cache seems to be the culprit, removing it fixes everything.\nThat said, how is that cache invalidated? Or is it not touched ever?. ",
    "memotype": "Ok, thanks for the response, I wasn't aware that was an option, but it seems like this should be the default. It seems odd to assume the user wants to modify the input in unexpected ways that have nothing to do with the template language. In fact, the reason I'm even opening this issue is because I'm using shinto-cli (https://github.com/istrategylabs/shinto-cli) to parameterize some files in a build job, and I noticed that it was outputting files without newlines, so when I append to them I have lines squished together on one line. At first I was going to open an issue with shinto-cli until I glanced through the source, and then tried a basic jinja2 template from the python REPL myself and realized this is just default jinja2 behavior.\nI can open an issue with shinto-cli to ask that they add the keep_trailing_newline=True option to all of their Environment calls.. ",
    "doobeh": "I'll look into constructing something more automated-- similar to how the table directive for jinja_filters is built.  Can you think of a more semantic layout (py3 docs use the table layout for similar overviews).  Columns of lists I guess would be best and degrade well.. ",
    "cfrademan": "@ThiefMaster I am not alone :-) Well it seems, I am yet to confirm that given the above scenario, I didnt see the source of the problem in the trackback. I am guessing, yet to look deeper, that that error is raised from None or something. I guess I will look into this more myself. . ",
    "petee-d": "Note the build failed on something unrelated to my changes (Python 3.3.6 environment creation and it passes locally for me), could someone with repo access try to restart it or fix the underlying issue?. ",
    "thany": "For those who aren't familiar with python?\nI for one, just have to use this template syntax to build up websites. I don't write the python code behind it. I have no way of knowing what I can do if it isn't documented.. ",
    "agowa338": "This fixes\n515\n444 .",
    "myst404": "Hey,\nSorry, I think it actually falls into the following case in you documentation:\n\"Another important thing is how Jinja2 is handling string literals in templates. A naive implementation would be using Unicode strings for all string literals but it turned out in the past that this is problematic as some libraries are typechecking against str explicitly. For example datetime.strftime does not accept Unicode arguments. To not break it completely Jinja2 is returning str for strings that fit into ASCII and for everything else unicode:\"\nRegards.. ",
    "OzuYatamutsu": "Sorry about that -- by an amazing coincidence, I had the wrong window in focus and managed to type something which opened an issue on this page. ",
    "reinout": "Looking at the changelog: this fix doesn't seem to be released yet, right?\nIf so, will there be a release fairly soon? My project's pytest output is showing quite a number of these deprecation warnings :-). ",
    "breisfeld": "I don't know about 'supposed to', but pathlib seems to be picking up steam as an alternative to os.path. I will take a look to see if this change could be made without affecting Python 2 compatibility. . Will submit a new pull request after testing. I am really trying to make a positive contribution to jinja. \nI am a competent programmer in python, but the various git/github peculiarities have me stymied. \nMy latest pull request is here: https://github.com/pallets/jinja/pull/876. Revised logic and tests per review comments. I was not aware of the fspath method. Because PEP 519 was accepted, your idea makes a lot of sense and would be more forward-thinking than my implementation.. Thank you for the tip.. ",
    "Kellel": "I noticed the same thing, but I do think that this is a parsing error.\nFor instance in just vanilla python\nif False or False , :\n    print(\"fail\")\nWill result in a syntax error\n. Ok. I see what you are saying. I guess that makes sense. I think our team is going to try and make a linting script to try and catch this kind of bug in our production code.\nThanks for the fast response!. ",
    "ssato": "why?. ",
    "eran-pinhas": "OK, thanks\nBut that resolves the only first issue, it will still raise an error when including another inner template even though the reference path is plain (innerTemplate.xml) or forward slashed (./innerTemplate.xml) because the template variable will be .\\innerTemplate.xml or .\\./innerTemplate.xml respectively. . You were right, the backslash problem came from library that was not using jinja2 properly.\nBR. ",
    "alchris": "Sorry, that was my fault, I add one comma too many in the template string.. ",
    "pkrasimirov": "Yes, (6>0)|... works.  Why is this bug report closed?. Coming from the Unix/Linux world where | denotes a pipeline delimiter this is unexpected.\nI think it should be 6 > ('5'|int) insteads when needing such casts.\n. Can we have a warning at least?. Real-world use-case for this is Ansible templating Java boolean properties:\nisEnabled={{ some_var | length > 0 | string | lower }}\nbecause I want isEnabled=true/false instead of isEnabled=True/False.. Well, I see we read it differently and Jinja currently reads it as you do.  But the worst part of the above non-working example is it always silently gives False.\nI know Python is happy with that but do you think is it a good idea to issue a warning when using > between int and string in Jinja templates?. Also please share your opinion on an |is_empty filter to use instead of |lenght > 0.. Anyway, thank you for your quick responses.  Have a nice week.. Nice to know, thank you.. ",
    "keydaimon": "Sorry for the late reply.\nI confirmed the code you provided and there are no errors.\nThe bottom line is that the code \"data['foo-bar']\" works fine in Jinja template.\nI am still wondering there must be the unacceptable characters in Jinja2 specification, but I don't have the reproducible code so far.\nSo please let me close the issue this time.\nThank you so much for your response, asenov.. ",
    "PadamSethia": "The same code works perfectly in the python shell. I still can't figure it out where I'm messing it up\nAlso I'm using the same method else where , and over there it works fine.. ",
    "zhanghang06": "OK.next time,i'll post the actual code.\nthe above question: \n```\n\u53bb\u8c03\u8bd5\n\n                                    function test(obj) {\n                                        var trSeq = $(obj).parent().parent().find(\"tr\").index($(obj).parent()[0]) + 1;\n                                        var tmp_cnt = Number($(\"tr:eq(\" + trSeq + \")&gt;td:eq(0)\").text());\n                                        {% set debug_cnt = \"+tmp_cnt\" %}\n                                        {% set tmpres = res_detail_interface[debug_cnt] %}\n                                        console.log('bb:', tmp_cnt, {{ debug_cnt }}, 'cc:', tmpres}});\n                                    }</p>\n<p>```\n                                \nquestion:\nI got the {{debug_cnt }} .it's a Number\uff0cas 2\u3002\nbut when i try to print the  {{res_detail_interface[debug_cnt]}} .it's empty.\nprint {{res_detail_interface[2]}}, the result is right. ",
    "pillarsdotnet": "Wasn't a question about my own code; it was a question about how to debug it (other than by posting it on a public forum, which is inadvisable because of the nature of my employment).\nI finally figured out how to render my template directly from python, and the offending line-number DID appear.  Don't know why that information gets stripped by every jinja-related CLI on the market.. ",
    "Lucid-Network": "would also like to know, how about future plans?. ",
    "guettli": "I think docs are even more important than code. That's why the real experts (not me) should do it.. ",
    "Gamrix": "This was done in #803 , can we update what version of the docs is on the website?. ",
    "qlands": "This is not necessary anymore. I realized (late) that jinja2 has include thus my extension called snippet is not necessary. The include clause does not generate the said behavior.. ",
    "dspeyer": "{% trans %} doesn't interpolate named arguments. ",
    "tterranigma": "What is different about first?. OK! Thanks for the insight!. ",
    "Ublimjo": "Sorry. #903 . ",
    "deoren": "It's not pretty, but this quick hack let me build the docs in epub format a few minutes ago:\n```diff\ndiff --git a/docs/jinjaext.py b/docs/jinjaext.py\nindex fd38ee8..10a495e 100644\n--- a/docs/jinjaext.py\n+++ b/docs/jinjaext.py\n@@ -25,7 +25,7 @@ from pygments.style import Style\n from pygments.token import Keyword, Name, Comment, String, Error, \\\n      Number, Operator, Generic\n from jinja2 import Environment, FileSystemLoader\n-from jinja2._compat import abc\n+#from jinja2._compat import abc\ndef parse_rst(state, content_offset, doc):\n@@ -160,7 +160,7 @@ def jinja_nodes(dirname, arguments, options, content, lineno,\n             members = []\n             for key, name in node.dict.items():\n                 if not key.startswith('_') and \\\n-                   not hasattr(node.base, key) and isinstance(name, abc.Callable):\n+                   not hasattr(node.base, key):\n                     members.append(key)\n             if members:\n                 members.sort()\n```\nFWIW, Google Play Books seems OK with the resulting epub (so far at least).. ",
    "liwt31": "Just for your information, the situation I posted here is a simplified version, what I really do is that I'm using context processor in Flask in which I have to return a dict.. ",
    "mattiasb": "@davidism I think the best example is in the original Ansible PR.\nBut in short, this is what made me want this:\nIn Ansible we have a custom-filter combine that you can use to merge two objects. It has override-semantics by default so for example:\n{{ {'a':'upstream', 'b':'upstream'} | combine({'b':'overridden'}) == {'a':'upstream', 'b':'overridden'} }}\nSo if you want to apply default values from the defaults object and override from the overrides object on an unknown single object upstream you can do it like this:\n{{ defaults | combine(upstream) | combine(overrides) }}\nThis all works good until you want to apply defaults and overrides to all elements in a list of objects with the map filter. You can apply overrides easily like this:\n{{ upstream_objs | map('combine', overrides) | list }}\nIf you want to apply defaults you'll have to resort to the statement-language like so (in ansible):\nobjects_with_defaults_applied: >-\n  {%- result=[] -%}\n  {%- for obj in upstream_objs -%}\n  {%-     do result.append(defaults | combine(obj)) -%}\n  {%- endfor -%}\n  {{ result | to_json | from_json }}\nMy immediate thought was to implement a version of combine that took arguments in reverse order. See Ansible #46255, but that PR got rejected (and rightly so) since it was too specific. This issue apparently comes up in more places.\nSo that led me to think about the problem at hand. The Jinja expression language really is a small functional programming language. So my thought was \"How does the FP community handle this?\" and the answer usually is \"with lambdas or the flip-function\". See here for context.\nSo I implemented this for Ansible here: Ansible #46340. But I thought that it might be better to get this upstream and @bcoca seemed to agree. So that's where I am now. :)\nOne issue I see with this approach is that it won't work with select since there's a distinction between filters and tests and select specifically takes tests as input. But other than that it seems to work fine for me and my little use case. I'm hoping that the idea has more general value though.\nEDIT\nFor reference, here's how you'd apply both defaults and overrides to a list of objects using flip, map and combine:\n{{ upstream_objs\n | map('flip', 'combine', defaults)\n | map('combine', overrides)\n | list\n}}. Ah of course! I need to remove the one that's there actually, since it won't work with select.. Added a fixup commit (that I will squash later if it looks good). It's a bit hard to produce good examples with the few filters that take more than 1 parameter in just bare Jinja but I tried as good as I could. \nThere's a very convoluted test that I didn't expose in the docs too for an example of how to go over the top with this.. I don't understand. :). Ah! I didn't know *args was a tuple.. Fixed!. ",
    "tonyfast": "The use case I have is a for loop that returns large slices of pandas.DataFrame as html tables during each iteration.  Sometimes, the DataFrame nodes in the loop will perform some statistical aggregations at each iteration.  With the current settings I have to receive 2 or more tables at a time or all at once.  \nPerhaps I am using the wrong approach.  If so I am sorry for the noise.. @davidism Thank you for taking the time to help me here; I was clearly using the wrong approach. . ",
    "seaders": "@davidism I've no experience with asyncfilters, can you give some pointers as to what I'd need to provide for the async version?. Hey @davidism I've added a best effort async version - https://github.com/pallets/jinja/pull/911/files#diff-c8e259013541ba9ee7ef783bed930fc3R115\nBut as I said, I've no experience with the async stuff, and from the other async filters,\n@asyncfiltervariant(filters.do_groupby)\nasync def do_groupby(environment, value, attribute):\n    expr = filters.make_attrgetter(environment, attribute)\n    return [filters._GroupTuple(key, await auto_to_seq(values))\n            for key, values in filters.groupby(sorted(\n                await auto_to_seq(value), key=expr), expr)]\n\n\n@asyncfiltervariant(filters.do_join)\nasync def do_join(eval_ctx, value, d=u'', attribute=None):\n    return filters.do_join(eval_ctx, await auto_to_seq(value), d, attribute)\n\n\n@asyncfiltervariant(filters.do_list)\nasync def do_list(value):\n    return await auto_to_seq(value)\n\n\n@asyncfiltervariant(filters.do_reject)\nasync def do_reject(*args, **kwargs):\n    return async_select_or_reject(args, kwargs, lambda x: not x, False)\n\nI get that they're await-iterating lists, but I'm not sure exactly what I should be doing for applymacro.\nI've added 2 async tests, 1, which is passing, which is just like that regular filter, but just using the async env, and a 2nd, which is failing, which is the map + applymacro test, https://travis-ci.org/pallets/jinja/jobs/442615314#L507\nI've tried debugging through it, but I'm just not 100% understanding what's going on, nor what's trying to be achieved.\nIt's definitely about the warning(s),\nlocally I get,\n\\jinja\\jinja2\\filters.py:405: RuntimeWarning: coroutine 'wrap_macro_invoke.<locals>.async_invoke' was never awaited\n   return text_type(d).join(imap(text_type, value))\n\nand on travis,\n/jinja/jinja2/asyncfilters.py:79: RuntimeWarning: coroutine 'do_applymacro' was never awaited\n    return filters.do_join(eval_ctx, await auto_to_seq(value), d, attribute)\n\nI don't know why they're different, from the same code & tests, and I don't know how to resolve them without a bit of help.  . Looks like it's a bug with asyncfilter's do_map already present. \nIn Environment call_filter,\nhttps://github.com/pallets/jinja/blob/master/jinja2/environment.py#L440\nNote that on Python 3 this might return a coroutine in case the\n    filter is running from an environment in async mode and the filter\n    supports async execution.  It's your responsibility to await this\n    if needed.\n\nBoth do_maps use the \"regular\" prepare_map, https://github.com/pallets/jinja/blob/master/jinja2/asyncfilters.py#L108 which doesn't respect ^^^ from call_filter, and simply returns it (now a coroutine) in a lambda.\nYou can test this by adding the below test in test_asyncfilters,\ndef test_map_join(env_async):\n    tmpl = env_async.from_string('{{ [[1,2], [3], [4,5,6]]|map(\"sum\")|list }}')\n    assert tmpl.render() == '[3, 3, 15]'\n\n\n================================== FAILURES ===================================\n________________________________ test_map_join ________________________________\n\nenv_async = <jinja2.environment.Environment object at 0x0000021D8D21A470>\n\n    def test_map_join(env_async):\n        tmpl = env_async.from_string('{{ [[1,2], [3], [4,5,6]]|map(\"sum\")|list }}')\n>       assert tmpl.render() == '[3, 3, 15]'\nE       AssertionError: assert '[<coroutine ...21D8D284048>]' == '[3, 3, 15]'\nE         - [<coroutine object do_sum at 0x0000021D8D0E9EB8>, <coroutine object do_sum at 0x0000021D8D0E9FC0>, <coroutine object do_sum at 0x0000021D8D284048>]\nE         + [3, 3, 15]\n\ntest_asyncfilters.py:180: AssertionError\n============================== warnings summary ===============================\n<template>:13: RuntimeWarning: coroutine 'do_sum' was never awaited\n\nFrom looking at the history, it was done at https://github.com/pallets/jinja/commit/f7bb60af00e7c76243c7b4409c3acf1c19c510a7, the async do_map was added, but doesn't check whether needs to check whether what's returned is a coroutine, but doesn't.   I'll open another issue for this.. > Thanks for working on this!\nAppreciated, but no thanks needed, I'll be dead proud to get some of my crappy code into the jinja repo!\n\nYou now have more experience than I do. \ud83d\ude09\n\nHaha!  'Tis so often the way in open-source country!. So @davidism (and/or @mitsuhiko ) now that https://github.com/pallets/jinja/pull/911 has gone through, this has been unblocked, and with the changes already approved, can this get in too?. @mitsuhiko changed to use that (when I PR'd this initially, I wasn't even aware that that function was in the project).. Sorry to bump, but any chance some movement can be made on this? @mitsuhiko . Do you mean one explicit arg, as in macro as opposed to a change to the signature of the function, def do_map(macro, *args, **kwargs)?\n\nswitch on it's type automatically\n\nI.E. check if it's a str and if so look for it in context.vars?. I'm not sure.  It works...  I'd need a pointer to the correct way, if there is one.. If we allow strings, we need to do,\nmacro = kwargs.pop('macro')\nif isinstance(macro, str):\n    if '.' in macro:\n        templatemod, _, mname = macro.partition('.')\n        macro = getattr(context.resolve(templatemod), mname)\n\n    else:\n        macro = context.resolve(macro)\n\nSo let strings be passed, or just allow the macro to be passed in directly, and not mess around with that?. I'm more than happy to pull out the option of passing by string, I mainly added it due to the suggestion from @flexferrum who added applymacro on Jinja2Cpp.  If we don't want that optionality here, just say so and I'll just pull it (or any of you can do it).. Without feedback, I'm marking this as resolved.  If you guys want this removed just say, and I'll pull it, but if you're okay with it, we'll leave it as is.. ",
    "jason-s": "I'm doing some log plots in HTML (base64 small png files, with a Python class LinePlotter I wrote to do the plots using matplotlib). Existing Jinja restrictions force me to use this in decimal notation, which suffers in readability for large magnitude values. Here's some sample content from a template I have:\n{% set lineplotter = LinePlotter(width=7, dpi=90, xlimits=[0.01, 10000]) %}\n{% for k,title,units,scaling in [\n    ('R','Resistance (R)','ohms (line-line)',2.0),\n    ('Lq','Inductance, q-axis (Lq)','mH (line-line)',2000.0),\n    ('Ld','Inductance, d-axis (Ld)','mH (line-line)',2000.0),\n    ('Ke','Back-emf (Ke)','Vrms/KRPM (line-line)',1.0/0.007797),\n    ('Tf','Friction (Tf)','mNm',1000.0),\n    ('B','Viscous damping (B)','uNm/(rad/s)',1000000.0),\n    ('J','Inertia (J)','uNm/(rad/s<sup>2</sup>)',1000000.0),\n    ('tau_e','Electrical time constant L/R','ms',1000.0),\n    ('tau_m1','Mechanical time constant 2/3 JR/Ke<sup>2</sup>','ms',1000.0)\n] %}\n{% set values = sample_motors['parameters'][k] * scaling %}\nIt would be more readable, and easier to avoid future errors during maintenance, for me to use 1.0e6 than 1000000.0, or to use xlimits=[1.0e-2, 1.0e4] than xlimits=[0.01, 10000.0].\nThese values aren't that large in magnitude, but in the engineering world we occasionally get into the 1e-12 range (pico) or the 1e9/1e12 (giga/tera) range. Decimal literals are prone to misreading/human error in that range.. I expected you to comment that.\nNo, it doesn't make sense, because I have parameters that are configured in the template for various situations. Other templates look at other aspects of the data model in different ways that are customizable by using different templates. My Python script is responsible for setting up the data model, and different templates show different views of it. Configuring the range of values shown on a log plot is well within the range of responsibility for the template. Yes, I could move it to a config file, and then have Python handle that part, but I use Jinja all the time for quick little scripting tasks like this, and it seems odd that I can do all these amazing things in Jinja templates (like the for loop in my example) but I can't use scientific notation. \nI have workarounds, so it's not blocking me from getting things done, but they're ugly. I'm an engineer; scientific notation is one of my basic tools and I can't use it here.. ",
    "ozychhi": "It was meant to be part of https://github.com/pallets/jinja/commit/ee2d3c43 I guess. There is no trivial case when this code will fail, I was adding custom parser features and this issue came up. . ",
    "tomas-mazak": "This actually only supports blocks now, but if the idea is generally accepted, I am happy to extend support to variables as well. I've updated the PR with variable support, so now {{* ... }} syntax is supported as well. @davidism yeah, I only implemented the feature I immediately needed for now... I am happy to look into extensions if required to get this merged. @davidism Please let me know if you require any amendments to this PR, I am happy to do some extra work on it, but would really like to see this merged.. @stan1y I haven't tested it with extend, but it should work with any kind of block (as it wraps the whole block in a indent filter under the hood). ",
    "Ashish-Bansal": "@davidism Any update on this ? I would love to have this feature merged.. ",
    "stan1y": "Does it support extends syntax as well?. I can confirm that it worked with extends as expected. Very useful.. ",
    "mildmelon": "I would love to have this feature as well, looks great!. ",
    "thirtytwobits": "I pulled this into a fork I'm using to generate source code. It's an essential feature in some regards unless someone else knows a better way to do this?. ",
    "CleoQc": "@davidism  : how would you prefer to handle this? This feature is limited to Python 3..6 and up. Currently it doesn't degrade nicely but I could fix that. Or ignore it. \nDo you still want to support versions older than 3.6? I'm guessing yes. \nI could make the regex dependent on the python version.  I'm open to suggestions but I won't put any more work into this one until I get your feedback.. Good point and should be simple enough to do. . Also of note, this PR contains the changes to https://github.com/pallets/jinja/pull/922 as they are literally on the same lines.\n. Finally passes all tests.  Let me know if it's acceptable, please.. I've changed test_float and test_int but I'm thinking we should probably have a test_template that actually tests the regex. . Yes, those are now valid in Python. \nhttps://www.python.org/dev/peps/pep-0515/. env.from_string(str) didn't check the regex. So if the user were to use an older version of Python, env.from_string() was failing. . Good idea. I'll see if I have time to revisit this one. Not this weekend though.. ",
    "eteq": "Oh, fantastic! Yes I'll do a PR to clarify that (may be a few weeks before I get to it though). ",
    "alekseyev": "Oops, wrong formula. ",
    "ZhangKuixun": "``\n pip install Jinja2\nRequirement already satisfied: Jinja2 in /Library/Python/2.7/site-packages/Jinja2-2.10-py2.7.egg (2.10)\nCollecting MarkupSafe>=0.23 (from Jinja2)\n  Using cached https://files.pythonhosted.org/packages/cd/52/927263d9cf66a12e05c5caef43ee203bd92355e9a321552d2b8c4aee5f1e/MarkupSafe-1.1.0-cp27-cp27m-macosx_10_6_intel.whl\nInstalling collected packages: MarkupSafe\nCould not install packages due to an EnvironmentError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/markupsafe'\nConsider using the--user` option or check the permissions.\n.\npip install /Users/zhangkuixun/Downloads/Jinja2-2.10.tar.gz \nProcessing ./Jinja2-2.10.tar.gz\nCollecting MarkupSafe>=0.23 (from Jinja2==2.10)\n  Using cached https://files.pythonhosted.org/packages/cd/52/927263d9cf66a12e05c5caef43ee203bd92355e9a321552d2b8c4aee5f1e/MarkupSafe-1.1.0-cp27-cp27m-macosx_10_6_intel.whl\nInstalling collected packages: MarkupSafe, Jinja2\nCould not install packages due to an EnvironmentError: [Errno 13] Permission denied: '/Library/Python/2.7/site-packages/markupsafe'\nConsider using the --user option or check the permissions.\n$ cd /Users/zhangkuixun/Downloads/\n$ ls\nJinja2-2.10.tar.gz\nyihuyang:Downloads zhangkuixun$ \n```. It really bothers me.. ",
    "vpriyada": "If I put the value of value.alias as hi-vl in the {%set } command it is able to iterate.\nWhere should I mention to parse it as YAML in ansible?\nI am using ansible-galaxy template where the yml.j2 templates inside template folder are resolved and put inside generated folder\n. ",
    "leamingrad": "Just realized I forgot to say in the above: the example is obviously stupid, but this actually occurred when trying to render a WTForms form that had a broken custom field widget in a flask app - I don't think that jinja2 should be able to handle errors in __html__ methods but it would be helpful to get the stacktrace.. It appears that it is Markupsafe that is at fault. Just running jinja2.runtime.escape(test) also segfaults.\nLooks like this has already been reported: https://github.com/pallets/markupsafe/issues/108 so I'll close this. ",
    "jakul": "I think it's just a case of replacing p = '/'.join((self.package_path,) + tuple(pieces)) with p = '/'.join((self.package_path,) + tuple(pieces))[1:] so that the output doesn't start with a slash. I'm getting a leading / because the package_path argument I send is ''. This is because my templates are not located under any particular directory and are spread across my entire codebase, so there's no single \"top level\" prefix I can give here. ",
    "bwulff": "Well, I solved the issue by changing\n{extends base.html}\nin the template to \n{extends \"base.html\"}\nSo i was asking for a template object base all the time and not asking for the file base.html.. ",
    "LiuHongtao": "In our case, one data with multiple templates, one of templates need\nrjust, while others not. So it's better to handle this data in template.\nOr maybe custom filter can be supported.\nDavid Lord notifications@github.com \u4e8e2019\u5e742\u670819\u65e5\u5468\u4e8c \u4e0b\u534810:45\u5199\u9053\uff1a\n\nClosed #950 https://github.com/pallets/jinja/issues/950.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/pallets/jinja/issues/950#event-2149072735, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AEw5_Tyigk1G5NCKA_t0zg5AUwjrK-Ucks5vPA3ygaJpZM4bCmLE\n.\n\n\n-- \n\u5218\u5b8f\u97ec\n. ",
    "luckydonald": "In fact I was in the impression that would only copy the already rendered code, and not try to re-render it.\nAnyway, while I can set scoped to the {% block %} element, it doesn't seem to be possible with self.the_block().. Workaround:\nSplit it in two files, and use {% include %} for the inner part of the {% for %} loop:\nThe old minimal_bug_example.template becomes: \n```jinja2\n{% set foobars = [\"example text\", \"4458\"] %}\n{% for foobar in foobars %}\n{% include \"minimal_bug_example_inner.template\"}\n{% endfor %}\nAnd a new `minimal_bug_example_inner.template` becomes:jinja2\n    {% block test_block %}\n    A single bar contains: {{ foobar.upper() }} {# <- simulate accessing a object variable or something #}\n    {% endblock %}\nLet's keep it DRY, output that another time:\n{{ self.test_block() }}\n\n```. ",
    "cepbrian": "But it's making all of my pytests give LOTS of warnings... . ",
    "revelt": "Aha! Thank you for quick response. Let's update it then.. > I'm happy to review a PR\nPlease do.\nThank you. \ud83d\udc4d . @davidism OK, I'll have a look. I'll try to compile Adrian's suggestion for second example and expand a bit on grouper.. ",
    "jccardonar": "So, without understanding much, I see two approaches: Using get_corresponding_lineno, which from #673 seems to be a no go, but who knows the state now. The other is  using the debug approach mentioned in #674 . Which one makes more sense?. ",
    "d1ffuz0r": "not sure about memory consumption. Will sorted every time create a copy of value?\n. ",
    "kevinchevalier": "This is done automatically with the implements_iterator decorator.\n. ",
    "hroncok": "I've noticed a name collision here. Fix in https://github.com/pallets/jinja/pull/636. ",
    "michaeljoseph": "attr. ",
    "davidbgk": "Typo: should. ",
    "drewja": "I think so too but it is still not necessarily, unicode(_GroupTuple('test', ('foo', 'bar'))) is still calling the overloaded repr.. also niether 'tuple' nor 'namedtuple' has attribute __unicode__  by default. ",
    "luzpaz": "needed to improvise here to meet the 80 character line limit.  . ",
    "PinkFloyded": "Seems very unreadable. I think it makes sense to remove each component into a variable and format it using re.VERBOSE flag.. Any reason to use Template(str) instead of env.from_string(str)?. ``_``?. ``100_000_000_000``?. "
}