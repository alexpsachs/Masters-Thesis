{
    "sagivo": "@tschmuecker - why do you want to delete it?\n. ok. good luck\n. the whole idea is to show the algorithm, not to use built in functions. in job interviews they will ask you to implement sort for example, not to use a built in method.. \n. @iMerica - about the small bug, see latest commit - https://github.com/sagivo/algorithms/commit/5b6be6aa175376095921398737aa01fd4d013d97\n. already did. make sure you get the latest version. \nyou're welcome :)\n. i'm not sure it's efficent enough. why not using simple 2d array? this will make neighbours_among, find_cell_by_x_and_y and all the cells select run much faster instead of scanning all the cells. keep in mind that this algorithm meant to deal with large dataset. \n. closing for now. try again when you're ready. don't forget - KISS :)\n. those are some of the questions i needed to face. \nfeel free to contribute your own as long as they are challenging. \n. nice improvement. sometimes small algo changes can make huge impact on performance. \n. a small refactor - try to use it without the extra matrix  using native 2d array only\n. thank @nateberkopec, looks like you build a robust framework here. \ni intentionally tried to keep it as simple as i can. \nonly methods, no classes, no framework, no extra logistics. the fewer code possible in order to focus on the algorithm alone. \nto me it's the easiest way to quickly understand what it's about. \ni know it's not the 'proper ruby' way but it's the closest i can get from pseudo-code. \ni didn't decide about tests yet because they are always \"good practice\" but then again since it's a pure algorithm method (that already been tasted and researched) i don't see any real use for them. \nwhat do you think?\n. unlike tests in 'real world' - algorithm tests are tricker since you can't really test any array to test quicksort for example and see if it runs on o(lgN). it's more just to make sure nothing breaks.\ninteresting approach. i like the simplicity and the fact that it doesn't take focus from the algorithm itself with extra classes and layers. we can try this with some of the methods. \n. tl;dr: \ntesting to see you dind't break anything while playing is ok, as long as you know it doesn't guarantee your algorithm is correct and most efficient. \nwe can keep all the tests in one folder and the algorithms in another as long as we don't build a giant new framework monster (AKA new rails) just to show people a simple way to implement algorithms :)\n. cool. thanks for keeping it lean\n. nice catch! fixed here: https://github.com/sagivo/algorithms/commit/85c92703165dba12be656aa4e9cac667efd8d384\n. looks good. can you remove all the extra comments? the code is simple enough to understand. also take a look at the way we do tests now\n. i refactored it. take a look here: https://github.com/sagivo/algorithms/blob/master/lib/binary_search.rb\n. it's not a standard binary search. it should return the index of the founded element (or -1 if not). also it's usually better to do it iterative over recursion. \n. cool. the benchmark can be removed from the main file. the fewer code the better. \n. also - we moved to new format of testing (take a look at the samples)\n. let's keep refactoring. \n- cell does not need these attributes: column, row. you don't use it anywhere and it depends on the matrix anyway. all cell should have is info if it's live or not so we don't even need this class since it can be a 2d array of bool (the matrix).\n- the method neighbours should be in the matrix level and should get row and column as parameter. \n. great. the fewer code the better. \n. nice catch but apga should be 1 since you can do agpga.\ni refactored it a bit to make it simplier. now it's ok. \nhttps://github.com/sagivo/algorithms/commit/de652561af4f44325f1b0c6cc7b9914831943dc5\n. since the tests are all the same and look like \"check if foo() == value\" we can simpy use plain ruby. no need for extra testing library. i prefer to keep it as simple as we can. no need for classes or extra code other than the algorithm itself. \n. i need to find an old nokia to make sure you're correct :)\n. Beautiful. Good job. \n. can you explain why it's more efficient (space/running time)?\n. your algorithm is not correct. it's fundamentally wrong to store only one path since there can be couple paths with better result. \ntry:\np lis_dp [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 6, 7, 15, 8, 9]\nyour algo will return:\n[0, 4, 6, 9, 11]\nwhile the right answer is (in my solution):\n[0, 4, 5, 6, 7, 8, 9]\nplease have a look at the wikipedia link to learn more about how to solve it. \n. added nlgn algo. \nhttps://github.com/sagivo/algorithms/commit/500123bfe7b58249ef2d3193de9073abee05847f\n. thanks, please update the readme file as well (with links to relevant info).\n. I would use iterative merge instead\n. added merge sort. \nhttps://github.com/sagivo/algorithms/commit/5736a662d99dc8d493348cfbb2c08392df33ee32\n. it's ok, that's the result my algo returns as well. updated the file. \nthanks for the new algo\n. it's a ruby implementation so i'm not sure this is the right place\n. this library contains the code, not just a reference to other sources. maybe we'll add this option too later. \n. please add reference to the readme with link to source. \n. good job\n. please update readme as well. \n. can you explain what is it about? \nif it's 2 different algos - put them in separate files. \nalso - i would like refactor the whole naming (both methods and variables) \n. ok cool. can you update the readme as well?\nalso - please change the variable names to something else than aa and bb ..\n. loved the ? suggestion. left the test simple. \nhttps://github.com/sagivo/algorithms/commit/6083a741f0a91d273f69fe8377e2612e8cb6dd80\n. thanks but cross-promotions is not my thing. i really like what you did but it's less relevant for ruby developers. \n. will have a look. thanks. \n. thanks\n. thanks @carlxshen . thanks @bryant1410 . @tschmuecker - why do you want to delete it?\n. ok. good luck\n. the whole idea is to show the algorithm, not to use built in functions. in job interviews they will ask you to implement sort for example, not to use a built in method.. \n. @iMerica - about the small bug, see latest commit - https://github.com/sagivo/algorithms/commit/5b6be6aa175376095921398737aa01fd4d013d97\n. already did. make sure you get the latest version. \nyou're welcome :)\n. i'm not sure it's efficent enough. why not using simple 2d array? this will make neighbours_among, find_cell_by_x_and_y and all the cells select run much faster instead of scanning all the cells. keep in mind that this algorithm meant to deal with large dataset. \n. closing for now. try again when you're ready. don't forget - KISS :)\n. those are some of the questions i needed to face. \nfeel free to contribute your own as long as they are challenging. \n. nice improvement. sometimes small algo changes can make huge impact on performance. \n. a small refactor - try to use it without the extra matrix  using native 2d array only\n. thank @nateberkopec, looks like you build a robust framework here. \ni intentionally tried to keep it as simple as i can. \nonly methods, no classes, no framework, no extra logistics. the fewer code possible in order to focus on the algorithm alone. \nto me it's the easiest way to quickly understand what it's about. \ni know it's not the 'proper ruby' way but it's the closest i can get from pseudo-code. \ni didn't decide about tests yet because they are always \"good practice\" but then again since it's a pure algorithm method (that already been tasted and researched) i don't see any real use for them. \nwhat do you think?\n. unlike tests in 'real world' - algorithm tests are tricker since you can't really test any array to test quicksort for example and see if it runs on o(lgN). it's more just to make sure nothing breaks.\ninteresting approach. i like the simplicity and the fact that it doesn't take focus from the algorithm itself with extra classes and layers. we can try this with some of the methods. \n. tl;dr: \ntesting to see you dind't break anything while playing is ok, as long as you know it doesn't guarantee your algorithm is correct and most efficient. \nwe can keep all the tests in one folder and the algorithms in another as long as we don't build a giant new framework monster (AKA new rails) just to show people a simple way to implement algorithms :)\n. cool. thanks for keeping it lean\n. nice catch! fixed here: https://github.com/sagivo/algorithms/commit/85c92703165dba12be656aa4e9cac667efd8d384\n. looks good. can you remove all the extra comments? the code is simple enough to understand. also take a look at the way we do tests now\n. i refactored it. take a look here: https://github.com/sagivo/algorithms/blob/master/lib/binary_search.rb\n. it's not a standard binary search. it should return the index of the founded element (or -1 if not). also it's usually better to do it iterative over recursion. \n. cool. the benchmark can be removed from the main file. the fewer code the better. \n. also - we moved to new format of testing (take a look at the samples)\n. let's keep refactoring. \n- cell does not need these attributes: column, row. you don't use it anywhere and it depends on the matrix anyway. all cell should have is info if it's live or not so we don't even need this class since it can be a 2d array of bool (the matrix).\n- the method neighbours should be in the matrix level and should get row and column as parameter. \n. great. the fewer code the better. \n. nice catch but apga should be 1 since you can do agpga.\ni refactored it a bit to make it simplier. now it's ok. \nhttps://github.com/sagivo/algorithms/commit/de652561af4f44325f1b0c6cc7b9914831943dc5\n. since the tests are all the same and look like \"check if foo() == value\" we can simpy use plain ruby. no need for extra testing library. i prefer to keep it as simple as we can. no need for classes or extra code other than the algorithm itself. \n. i need to find an old nokia to make sure you're correct :)\n. Beautiful. Good job. \n. can you explain why it's more efficient (space/running time)?\n. your algorithm is not correct. it's fundamentally wrong to store only one path since there can be couple paths with better result. \ntry:\np lis_dp [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 6, 7, 15, 8, 9]\nyour algo will return:\n[0, 4, 6, 9, 11]\nwhile the right answer is (in my solution):\n[0, 4, 5, 6, 7, 8, 9]\nplease have a look at the wikipedia link to learn more about how to solve it. \n. added nlgn algo. \nhttps://github.com/sagivo/algorithms/commit/500123bfe7b58249ef2d3193de9073abee05847f\n. thanks, please update the readme file as well (with links to relevant info).\n. I would use iterative merge instead\n. added merge sort. \nhttps://github.com/sagivo/algorithms/commit/5736a662d99dc8d493348cfbb2c08392df33ee32\n. it's ok, that's the result my algo returns as well. updated the file. \nthanks for the new algo\n. it's a ruby implementation so i'm not sure this is the right place\n. this library contains the code, not just a reference to other sources. maybe we'll add this option too later. \n. please add reference to the readme with link to source. \n. good job\n. please update readme as well. \n. can you explain what is it about? \nif it's 2 different algos - put them in separate files. \nalso - i would like refactor the whole naming (both methods and variables) \n. ok cool. can you update the readme as well?\nalso - please change the variable names to something else than aa and bb ..\n. loved the ? suggestion. left the test simple. \nhttps://github.com/sagivo/algorithms/commit/6083a741f0a91d273f69fe8377e2612e8cb6dd80\n. thanks but cross-promotions is not my thing. i really like what you did but it's less relevant for ruby developers. \n. will have a look. thanks. \n. thanks\n. thanks @carlxshen . thanks @bryant1410 . ",
    "ghost": "Sorry man, I currently try to figure out git/github and thought it would only appear in my cloned repo. Please ignore.\n. Sorry man, I currently try to figure out git/github and thought it would only appear in my cloned repo. Please ignore.\n. ",
    "iMerica": "Sure. In that case, you might consider fixing the method so that it's return value is an array of permutations. Currently doing x = perm \"ABC\" yields incorrect results. Interviewees could get deducted on that - just a thought. \nThanks for setting up the repo! I had fun reading this code :smiley: \n. Sure. In that case, you might consider fixing the method so that it's return value is an array of permutations. Currently doing x = perm \"ABC\" yields incorrect results. Interviewees could get deducted on that - just a thought. \nThanks for setting up the repo! I had fun reading this code :smiley: \n. ",
    "emelie12": "I need PASIS\n. OASIS\n. I need PASIS\n. OASIS\n. ",
    "kevivmatrix": "Cool, wanted to get to a green build. Will start with refactoring. Thanks.\n. Sure :+1: \n. Cool, Thanks.\n. ok, will work on that.\n. done.\n. cool, I have removed the rspec tests. will add minitest test for the algo soon. you can merge this one, I will open a new PR once it is ready.\n. cool, I can see what you want. I will try to remove the classes and make it more algo centric.\n. @sagivo Hey, please check this out once. I have removed the Cell class and made it much more simpler.\n. Cool, wanted to get to a green build. Will start with refactoring. Thanks.\n. Sure :+1: \n. Cool, Thanks.\n. ok, will work on that.\n. done.\n. cool, I have removed the rspec tests. will add minitest test for the algo soon. you can merge this one, I will open a new PR once it is ready.\n. cool, I can see what you want. I will try to remove the classes and make it more algo centric.\n. @sagivo Hey, please check this out once. I have removed the Cell class and made it much more simpler.\n. ",
    "nateberkopec": "@sagivo You could also just do tests at the bottom of the file - that would be super easy to understand. Something like:\n``` ruby\ndef my_sweet_algo\nputs \"oh yeah\"\nend\nclass TestMySweetAlgo < Test::Unit::TestCase\ndef test_sweet_algo\n  assert true # or whatever\nend\nend\n```\nI'm not sure what the settings are off the top of my head, but you can make that test run automatically when you run ruby my_sweet_algo.rb.\nI think tests could be useful for two reasons:\n- When you modify the algorithm, you want to be sure it's still correct. When learning how algorithms work, I'm always modifying the code for a bunch of different reasons.\n- When you modify the algorithm, you want to ensure that it's performant. Minitest has several assertions that help you figure this out. I think this is very relevant to the purpose of this repo (preparation for interview questions).\n. > algorithm tests are tricker since you can't really test any array to test quicksort for example and see if it runs on o(lgN). it's more just to make sure nothing breaks.\nActually, minitest/benchmark does do this! It basically runs your code a bunch of times and plots the performance, and checks to see if you pass a statistical regression test.\nIt's not a formal proof, of course, but I do find it valuable.\n\nwe can keep all the tests in one folder and the algorithms in another as long as we don't build a giant new framework monster (AKA new rails) just to show people a simple way to implement algorithms :)\n\nI actually kind of like the tests-at-the-bottom-of-the-file approach. I'll change this PR to do that instead.\n. > since the tests are all the same and look like \"check if foo() == value\" \nmost tests look like that :grin: \n. @sagivo You could also just do tests at the bottom of the file - that would be super easy to understand. Something like:\n``` ruby\ndef my_sweet_algo\nputs \"oh yeah\"\nend\nclass TestMySweetAlgo < Test::Unit::TestCase\ndef test_sweet_algo\n  assert true # or whatever\nend\nend\n```\nI'm not sure what the settings are off the top of my head, but you can make that test run automatically when you run ruby my_sweet_algo.rb.\nI think tests could be useful for two reasons:\n- When you modify the algorithm, you want to be sure it's still correct. When learning how algorithms work, I'm always modifying the code for a bunch of different reasons.\n- When you modify the algorithm, you want to ensure that it's performant. Minitest has several assertions that help you figure this out. I think this is very relevant to the purpose of this repo (preparation for interview questions).\n. > algorithm tests are tricker since you can't really test any array to test quicksort for example and see if it runs on o(lgN). it's more just to make sure nothing breaks.\nActually, minitest/benchmark does do this! It basically runs your code a bunch of times and plots the performance, and checks to see if you pass a statistical regression test.\nIt's not a formal proof, of course, but I do find it valuable.\n\nwe can keep all the tests in one folder and the algorithms in another as long as we don't build a giant new framework monster (AKA new rails) just to show people a simple way to implement algorithms :)\n\nI actually kind of like the tests-at-the-bottom-of-the-file approach. I'll change this PR to do that instead.\n. > since the tests are all the same and look like \"check if foo() == value\" \nmost tests look like that :grin: \n. ",
    "naimrajib07": "sure. I am doing it now and then push it again.\n. @sagivo  why the previous one not considered? could you explain it please? \n. @sagivo Ok. BTW, you always prefer iterative manner rather than recursion? Also could we use a task list. I mean in PM tool with item list that should we will target to implement. Actually i want to more focus on algorithms and populate these stuff in this repository.\n. sure. I am doing it now and then push it again.\n. @sagivo  why the previous one not considered? could you explain it please? \n. @sagivo Ok. BTW, you always prefer iterative manner rather than recursion? Also could we use a task list. I mean in PM tool with item list that should we will target to implement. Actually i want to more focus on algorithms and populate these stuff in this repository.\n. ",
    "st0le": "The space required is O(n). I believe in your method you store the elements involved in every longest increasing subsequence starting at arr[i]. The first method is kind of storing a matrix. Here the dp array only stores the length (single value). The pi array is also used for backtracking. It will also be of length O(n).\nThe time complexity is still the same. O(n^2)\n. Apologies, there's a typho in there. |i,v| should be |v,i|. Let me fix it. The algorithm is correct though. I urge you look for this variant in textbooks.\n. The space required is O(n). I believe in your method you store the elements involved in every longest increasing subsequence starting at arr[i]. The first method is kind of storing a matrix. Here the dp array only stores the length (single value). The pi array is also used for backtracking. It will also be of length O(n).\nThe time complexity is still the same. O(n^2)\n. Apologies, there's a typho in there. |i,v| should be |v,i|. Let me fix it. The algorithm is correct though. I urge you look for this variant in textbooks.\n. ",
    "kiloreux": "Is everything fine now or i need to do something else ?\n. For demonstration purposes and this is just a demonstration , not an actual software running . anyway feel free to do whatever you want :+1: \n. Is everything fine now or i need to do something else ?\n. For demonstration purposes and this is just a demonstration , not an actual software running . anyway feel free to do whatever you want :+1: \n. ",
    "rinoreji": "Couldn't we make it a place for algorithms in all popular languages.\n. Couldn't we make it a place for algorithms in all popular languages.\n. ",
    "vivekimsit": "We can create a diff branch though.\n. We can create a diff branch though.\n. ",
    "lexruee": "@sagivo Is done.\n. @sagivo Is done.\n. ",
    "rauljordan": "Updated!\n. Updated!\n. ",
    "delta4d": "the first is euclidean algorithm to calc gcd.\nthe extened euclidean algorithm is to calc a,b s.t ax+by=gcd(x,y), it is often used to calc the modular inverse. for example, if gcd(x,m)=1, then the inverse of x modular m is a where ax+bm=1. it is also used for solving linear equation or linear congruences.\n. the first is euclidean algorithm to calc gcd.\nthe extened euclidean algorithm is to calc a,b s.t ax+by=gcd(x,y), it is often used to calc the modular inverse. for example, if gcd(x,m)=1, then the inverse of x modular m is a where ax+bm=1. it is also used for solving linear equation or linear congruences.\n. ",
    "nick1123": "rfc @sagivo \n. rfc @sagivo \n. ",
    "EvgenyKarkan": ":+1: \n. :+1: \n. ",
    "stanislaw": "Ok, I got it. It was clear from your silence on this one while you was working actively on other tickets. \nThe whole thing is not about \"cross-promotions\" since both repos are already promoted enough but about sharing of relevant code base - if I am a developer who is looking for some algorithms - for me it would be good to know that there are additional sources where I can find what I am looking for. I think many developers think about code sharing this way and also pretty lot of projects here at Github contain sections like: \"Similar projects\", \"Alternatives\" etc.\nI hope this makes sense :)\nThanks for feedback.\n. Ok, I got it. It was clear from your silence on this one while you was working actively on other tickets. \nThe whole thing is not about \"cross-promotions\" since both repos are already promoted enough but about sharing of relevant code base - if I am a developer who is looking for some algorithms - for me it would be good to know that there are additional sources where I can find what I am looking for. I think many developers think about code sharing this way and also pretty lot of projects here at Github contain sections like: \"Similar projects\", \"Alternatives\" etc.\nI hope this makes sense :)\nThanks for feedback.\n. ",
    "carlxshen": "@sagivo \ud83d\udc4d . @sagivo \ud83d\udc4d . "
}