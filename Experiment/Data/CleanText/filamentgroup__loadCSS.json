{
    "adammcarth": "+1\n. Hey @rolfvandekrol,\nIndeed it is! I somehow got into a false state of mind as I was checking out my new branch, and, as I was writing about my changes too. My bad. The code I changed however uses the correct media=\"print\", instead of the screen=\"print\" in my example.\nI've updated the change summary - but unfortunately the incorrect branch and commit names will remain. The code changes work correctly.\n. Think of a website that submits a contact form through AJAX. If the server comes back with 200 (successful request) - we might want to show a giant message on the screen saying that their message has been sent. If the request fails (eg - validation didn't check out), we want to show a giant error message telling them they suck. Assume that there is a stylesheet with 200 lines of CSS for the success message, and 200 lines for the error message. That's 400 lines all up.\nHere's how we'd go about it:\nThe non-asynchronous way:\n- Link both the stylesheets \"manually\" in the HTML.\nCONS: The user might not even send a message - that's 400 lines of wasted loading time. Also, if the message sends successfully - we have the error message styles loaded for no reason? Etc...\nAsynchronously:\n- Load the appropriate CSS stylesheet when it's required (in this example, it would be loaded when the server response comes in from submitting the contact form).\nCONS: May be a very slight delay for the styles to load (purely internet speed related). You could always use a delay to wait until the stylesheet has loaded - but we're talking a matter of unnoticeable milliseconds.\nThis wasn't a perfect example (400 lines is not too bad), but if you scaled it up - there are big, big advantages here. I think you get the point by now.\nYou wouldn't however, as @keberox stated above, use this to load base css styles - there could be a substantial hang time (> 1 second).\n. Sure :smile: \nSo let's say you have a form that submits though ajax and you want to load a new stylesheet asynchronously if the server hits back with a 200 OK (perhaps some css to format a success message). If the form is submitted twice or more (very feasible in some scenarios) - the stylesheet will be appended to the DOM more than once. Although this shouldn't make a difference to the rendering of the css, appending the same stylesheet to the document more than once seems very wrong.\nSo no, you'd be out of your mind to add the stylesheet twice like I did in my example above - I just wanted to show that it will be added again without removing the old one first.\nThe changes I made check each stylesheet's href=\"\" attribute, and if it matches the one specified in the loadCSS() function - it will be removed before it is added again. I was doing some deeper thinking whilst running this morning, perhaps it should check that the media=\"\" attribute is the same too before removing it?\n. Checking the media attribute would get very messy since ss.media = media || \"all\" was used in a setTimeout() function. You'd have to set something like data-real-media to access the real media value (instead of \"only x\"), but I don't want to overcomplicate things at this stage. If we were to do that I think it should be a separate PR.\n. How are we feeling @scottjehl?\n. @Benjamin-K @inta I thought for quite a long time about that. Reload the stylesheet or prevent it from adding again?\nI settled on reloading it - what if the stylesheet was dynamically modified by an external process? The changes wouldn't be applied if we ignored the request. Whilst most adding it again would probably result in an unnecessary http request most of the time, you have to cater for all scenarios.\n. True. I'll probably update my branch with that functionality in that case - but I still don't think it will change Scott's mind.\n. Mhmm. There's definitely a use for it, regardless of whether it's merged into the main project or maintained as a separate branch.\nAny ideas on how you would check if the styles have been loaded properly? Checking for the existence of the <link> tag won't cut it I'm afraid.\n. I think adding a unique identifier is part of the equation. Perhaps something that we can leave in the tag forever and pass it as a variable to the callback function (if it needs to be removed/changed/reset later)?\njavascript\n// generate a random 5 character id for the stylesheet\nss.id = \"loadCSS-\" + Math.random().toString(36).substr(2, 5);\nBut it should also check if the css file exists, shouldn't it? As far as I'm concerned, loadCSS(\"////dfsdsfsdfjkbnkjdnfgv\"); should make the callback return false, not true (doesn't exist)\n. What do you think @scottjehl?\n. @zachleat \n. Google Page speed is still showing it because you're still loading the css files on page load with loadCSS. It's still creating a request.\nDoesn't really sound like loadCSS will fix this though. Just get your styles into page specific css files (besides core ones). Also look into minifying the CSS or merging it into one file if you use a web framework like Rails, Node or Zend.\n. Seems to work alright on 4G ;)\n. ",
    "shshaw": "Merged in @adammcarthur's media argument changes.\n. Thanks for reviewing the pull.\nThe benefit here is you don't have to reference your stylesheets with separate syntaxes in separate places or across separate files, making maintenance and fallbacks much easier, which IMO keeps things simpler :-)\nThe <noscript> isn't dependent on this script to work for non-Javascript users, obviously, which is a win for graceful degradation. And if someone decides they don't want to use this script or method anymore, all they have to do is remove the <noscript> wrapper and their stylesheets will work by default since it's using standard <link> elements.\nHeck, the script could easily be set up to run the <noscript> routine when the script is loaded to make it even more of a drop in solution. Since it's lightweight (still under 1kb!), it won't be a bother if they don't have any <noscript class=\"loadCSS\"> containers, and makes it easy to just drop in the async CSS files in their HTML without adjusting their Javascript.\nBut those are just my thoughts on it and my ideas about use cases. Maybe the concept is separate enough to be stand alone.\n. Another nice benefit of the <noscript> method, based on some discussion on your original gist.\nIf you're loading in CSS based on a specific module that's added to the page, you could easily include a <noscript class=\"loadCSS\"> with a <link> to the specific styles for that module within the module's template code, keeping everything tied together and with a built in fallback.\n. ",
    "scottjehl": "Thanks. This is a clever idea, but I'm not sure about pulling it in.\nI'll leave it open for discussion, but I'm thinking developers can pretty easily reference the CSS file in an unrelated noscript element without tying it to this script. And it'd keep things simpler that way, which is nice.\nOn Jun 12, 2014, at 9:42 AM, Shaw notifications@github.com wrote:\n\nMerged in @adammcarthur's media argument changes.\n\u2014\nReply to this email directly or view it on GitHub.\n. I totally agree on the benefits of including the CSS for noscript users. But I think the amount of complexity this commit adds to the script isn't worth working around the small inconvenience of listing a CSS url more than once in the page. \n\nThe existing script doesn't prevent anyone from listing noscript fallbacks if they desire to do so, so I think we'll keep it as-is. I appreciate the PR, though. Feel free to maintain a fork if this change is useful to you!\n. Simple enough. This looks great. Thanks!\n. Sorry - just saw this. Good answers. The main use case I needed this script to support was loading non-critical CSS, which is basically any CSS that isn't required to paint the top portion of a particular layout. What's critical is tough to figure out, but the idea is to inline the critical stuff and fetch the rest in a non-blocking manner. Here's more info https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent\n. Hey, thanks. Can you explain the issue this change addresses? I'm not sure why you're trying to load the same file twice.\n. Thanks for checking in, @adammcarth. We talked it over internally and we don\u2019t feel that this addition meets a common enough use case to include in this simple script. That said, I\u2019d encourage you to keep the fork open if you find it useful! Thanks again for the PR.\n. I'm not sure if this is a bug report or not but there are ways to use loadCSS in combination with inlined code in the head to satisfy the recommendation you're referring to. FilamentGroup.com is one example that doesn't get this recommendation in Pagespeed. Thanks.\n. Any part in particular?\n. Thanks. I'll give a look, but at a glance it looks like it aims to do more than this project, and looks like it lacks a workaround or two for ensuring a non-blocking load at any time in the page load process (and in any browser - appendChild can be very problematic in old IE). \n. thanks!\n. thx!\n. Thanks @leecade - if you have a specific code suggestion let us know.\nThe goal of this function is to do as little as necessary to load a CSS file asynchronously. But you're welcome to fork the project and add logic of your own to do more if you need more.\n. Issue's closed out. Thanks for the feedback.\n. thanks!\n. Been a little while since last test but it used to work in IE, with the exception that it may not load async in those versions (at least you get a stylesheet though). Worth getting this tested and documented.\n. Tested in IE 6-8 and a CSS file loads at least, though whether or not it loads async may vary on the version and what else is going on in the DOM. Noted here for further study: https://github.com/filamentgroup/loadCSS/issues/64#issuecomment-125633790\n. Thanks. I like the strict check, but is this addressing a common issue that occurs for you? We typically just make sure we pass an element in when we call it, saving the check. Open to your thoughts on it though. Thanks\n. Closing for now in favor of leaving this to the end developer's responsibility. Appreciate the idea though! Thanks.\n. thanks addy!\n. Well, if it was as easy as it is in JS, I\u2019d certainly be all for it. Last I read, it\u2019s pretty complicated to do reliably. This post is a bit outdated, mind http://www.phpied.com/when-is-a-stylesheet-really-loaded/\nOn Oct 3, 2014, at 1:39 AM, Adam McArthur notifications@github.com wrote:\n\nWhat do you think @scottjehl?\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks @decrek. I like that, though I'd prefer something that came earlier than when the CSS finishes loading, since that'd be a great deal of polling. Regardless, I like the idea and will be poking at it a bit today.\n. Hi all.\nI've posted a proposed approach to the issue-19 branch and I wouldn't mind some feedback on it. It basically polls document.styleSheets until the sheet we want is defined in there by its href property. It has a similar result to @decrek's proposal above, but hopefully without the workarounds that the sheet property would have required (I'm testing this now).\n\nhttps://github.com/filamentgroup/loadCSS/commit/29ea3d79512680953b4b8c457b5f5e389ebc5e72\n. @decrek yes, that's the case (a non-applicable media type will be downloaded at a lower priority, async, in modern browsers). It seems that the href property is populated when a stylesheet finishes loading, rather than when it is first requested, which is unfortunate since it will mean more polling. The only approach that I've found so far that allows us to detect the moment the request is made is to check stylesheets.length for an increment, but then we run into issues with multiple loadCSS calls.\nThis approach seems to work most broadly of those I've tested so far.\n. yeah, that\u2019s what I\u2019m thinking at least.\nOn Oct 24, 2014, at 1:07 PM, Declan Rek notifications@github.com wrote:\n\n@scottjehl Ah ok, that means the same amount of polling as in my proposal but better support than the sheet property.\n\u2014\nReply to this email directly or view it on GitHub.\n. This is merged now. @addyosmani I'd be interested in your thoughts on any better approach now that we have something workable at least.\n. Thanks. Can you clarify the issue that this PR addresses? Thanks\n. @argunner I'm curious what bug you are fixing with this commit. thanks.\n. It looks good, but we may not merge it for sake of keeping things simple and easy to debug. We'll think it over though, thanks!\n. thanks!\n. Thanks for the PR. This is exactly the sort of conflict case for which we offer the before argument. To address your case, just pass the appropriate element to the second (before) argument, for example:\n\nloadCSS( '/path/to/my.css', window.document.body.getElementsByTagName( \"script\" )[ 0 ] );\n. Hmm. well, I get the concern, but document.body isn't even guaranteed to exist when this script runs inline from head so I think a more reliable solution would have to poll for existence when targeting stuff that comes after the first script in the page.\n. Ah, yes I'd recommend using loadCSS with absolute paths so that it can be called the same way across templates of any directory depth. Maybe that's worth adding to the readme?\n. Good points, thanks everyone. \nIndeed, I've seen stylesheet links at the end of the body block render just like they do from the head. My assumption is that it's more about the timing of the request going out than where it happens to be in the source order.\nAnd agreed: the only x trick is basically what loadCSS does internally, so you could toggle an existing link if you prefer. loadCSS might be more convenient but it's up to you.\nI do wish we had an async attr for CSS. But even in the case of script, where we do have async and defer availabile, I find it's often very useful to use a script loader anyway to qualify the conditions at which the request is made in the first place (based on feature support and other conditions).\nAnyway! I'm going to close this out. Thanks.\n. woops - let this one get away from us, sorry. I'll still take a look at the proposed changes. Sorry/Thanks!\n. So, again, a late review of this one. We really appreciate it, and the changes look solid.\nThat said, they don't jive with a couple of goals for this project that we should do a better job of stating in the readme, mainly that the JS for this should be minimal as we can get away with, mostly because the primary use case for this library is to include it inline in the head of a page.\nI'd be interested in a module wrapper approach that could be optional though, say, generated in a build process or something. Hmm... \n. Thanks @jakearchibald \nWell... that's not good. I'll give this a look today. Maybe we could try other things like adding rel=alternate stylesheet or even... prefetch? Maybe not. :) \nAnyway... time for some tinkering I think.\n. Hey again, @jakearchibald \nOkay, quick update. I'm having no luck reproducing this issue, which of course is encouraging but I'm wondering if I might just be doing it wrong. :)\nHere's what I did to test it:\nStep 1. I created a CSS file that takes 5 seconds to respond and dropped it on my server. It's here http://scottjehl.com/css-temp/slow.php and its source reads:\nphp\n<?php\nsleep(5);\nheader(\"Content-Type: text/css\");\necho \"body { background: green; color: #fff; }\";\n?>\nStep 2. I created a control.html page to verify that an ordinary link to that CSS file will block render as expected. The stylesheet will style the background green and text white when it loads. Verified that it works as expected in IE11:\n\nStep 3. I created a test.html page and loaded the same stylesheet using loadCSS instead. My expectation is to see unstyled text immediately, and white-on-green whenever the stylesheet loads. Verified that it works as expected in IE11:\n\nAny tips on how to reproduce the issue would be great. \n. Thanks Jake!\nOn Feb 16, 2015, at 4:05 PM, Jake Archibald notifications@github.com wrote:\n\nHm, I wonder what else was at play. I saw it on webpagetest but also a VM,\nso I don't think it was a quirk in one system. Will try and reduce.\nOn Mon, 16 Feb 2015 20:15 Scott Jehl notifications@github.com wrote:\n\nHey again, @jakearchibald https://github.com/jakearchibald\nOkay, quick update. I'm having no luck reproducing this issue, which of\ncourse is encouraging but I'm wondering if I might just be doing it wrong.\n:)\nHere's what I did to test it:\nStep 1. I created a CSS file that takes 5 seconds to respond and dropped\nit on my server. It's here http://scottjehl.com/css-temp/slow.php and its\nsource reads:\n<?phpsleep(5);header(\"Content-Type: text/css\");echo \"body { background: green; color: #fff; }\";?>\nStep 2. I created a control.html page\nhttp://filamentgroup.github.io/loadCSS/control.html to verify that an\nordinary link to that CSS file will block render as expected. The\nstylesheet will style the background green and text white when it loads.\nVerified that it works as expected in IE11:\n[image: control]\nhttps://cloud.githubusercontent.com/assets/214783/6218617/88b8ab8c-b5e5-11e4-8895-25854925603d.gif\nStep 3. I created a test.html page\nhttp://filamentgroup.github.io/loadCSS/test.html and loaded the same\nstylesheet using loadCSS instead. My expectation is to see unstyled text\nimmediately, and white-on-green whenever the stylesheet loads. Verified\nthat it works as expected in IE11:\n[image: test]\nhttps://cloud.githubusercontent.com/assets/214783/6218641/d6dd9c5a-b5e5-11e4-8dd5-ce1d88a66d84.gif\nAny tips on how to reproduce the issue would be great.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/filamentgroup/loadCSS/issues/36#issuecomment-74566021\n.\n\u2014\nReply to this email directly or view it on GitHub.\n. We haven\u2019t been able to reproduce a bug showing that the version in master has problems running in IE 11. \n\n\nMy last message shows that it does appear to function as expected there, so I was leaving this open to see if @jakearchibald found a way to reproduce the issue.\nOn Feb 23, 2015, at 2:43 PM, Matijs Brinkhuis notifications@github.com wrote:\n\nI created a PR (#37) that I tested on IE11. Worked as expected in IE11 in a (modern.ie) VM. Instead of polling, it relies on the load event of the stylesheet. Curious if that makes a difference.\n\u2014\nReply to this email directly or view it on GitHub.\n. I just tested this again and can't seem to reproduce a problem in IE11 with the latest loadCSS. If anyone is able to create a demo that reproduces the issue, we're more than happy to check it out. Thanks!\n. Thanks @ausi\n. Hi @ausi \n\nDoes that empty script tag in your example have any bearing on whether the request blocks in IE11?\n. @ausi interesting. Hey @jakearchibald is that similar to your example perhaps? Maybe there's a script element after the one containing loadCSS in head?\n. Hmm... after a quick check, looks like svgomg might just be waiting for request animation frame before requesting CSS now, so loadCSS isn't in play there. \n. @ausi thanks. Would you be able to update your loadCSS and see if the issue persists? I'm curious if the new default insertion point (which is after the last style/link/script in the DOM) affects this bug?\n. @ausi thanks!\n. Back to prioritizing this one now that the Chrome issue and polyfill is resolved.\nWe should test the latest script now in master, and probably the pattern using a polyfill of rel=preload as well:\nhttp://filamentgroup.github.io/loadCSS/test/preload.html\n. I did some testing on this today. Inserting an empty (or populated) script tag after the one that contains loadCSS will cause a render-blocking CSS load in IE11, as well as Edge, IE10, and probably older IEs as well but I didn't test.\nSo! Two approaches come to mind:\nA. We could just add a recommendation to the README saying that the script tag that calls loadCSS should be at the end of the head, with no scripts or external stylesheets following it in the source.\nB. We could add a workaround to make sure it works anyway.\nIf we want to go with B, I've got a workaround ready and it tests out fine in Edge, IE11, and IE10. The change involves waiting until the body element is defined before inserting the CSS link. This means a request could possible go out milliseconds later than it otherwise would, but that's likely not a problem considering this script is used to purposely allow a page to render while lower-priority css loads.\nPR coming for approach B...\n. I agree that this would be better. I'm not sure that I agree it's worth breaking compatibility for it, unless we needed to add yet another argument anyway. Thoughts?\n. Closing out but open to further discussion. Thanks.\n. oh! yeah I like that.\n. Good coverage on ownerNode? Looks good. Opposite of sheet I guess? :) https://github.com/filamentgroup/grunticon/blob/master/tasks/grunticon/static/grunticon.embed.js#L36\n. confirmed. that sure seems browser-buggy to me. It even says the source of the second request is the toggle media function, which does nothing but just that...\n\n. I added gh-pages recently to run the test/ files for another issue, that\u2019s all it\u2019s there for so far.\nOn Feb 24, 2015, at 6:26 PM, Zach Leatherman notifications@github.com wrote:\n\nTODO: make sure what\u2019s in github pages matches what\u2019s on the master branch. I didn\u2019t test to see if they were different.\n\u2014\nReply to this email directly or view it on GitHub.\n. devtools say that the toggleMedia function triggers the request, yet all that function does is switch the stylesheet's media attribute value, which seems like it really should not affect network activity.\n\nIs this issue reproducible in any other browsers? Think it's maybe a Chrome bug? Seems this just started happening too... at least per my recollection.\n- @jakearchibald \n. For what it's worth, with a fresh cache and cookie bin, this issue is not reproducible on our site: http://www.filamentgroup.com/\nI wonder if it has to do with gh-pages and/or cross domain css\n. Part of me says... 'this is okay, as long as it loads the css in IE8 at all.' But I do wonder if other attribute variations might keep our async request working in all browsers while bringing IE8 in as well. For example, maybe media=print doesn't block render in IE8, or maybe adding the disabled attribute during load would help. Worth testing.\n. This is documented now.\n. I'd be open to this, but I'm not sure I'm convinced on the value of a CDN for this particular script. It's entire value rests on the JS being \"inlined\" in the page, rather than requested externally. So in that way, something like Bower or NPM makes good sense to me, but I'm not sure about a CDN.\nI'm happy to reopen this if you think it warrants further discussion, or if I missed the point, which is entirely likely :) Thanks\n. Thanks but I think we're going to pass on this change. The array length change could make a small difference in some older browsers but the var style changes are something we'd probably just leave to a minifier these days. Thanks so much though!\n. I agree that this probably won't be quite enough. Amongst other concerns mentioned, I think it could potentially report false results when stylesheet files of the same name, yet in different directories, are in play at once on a page. While that's likely rare, I'd still rather have a more reliable fix.\nProposing this fix instead, which compares the resolved link href to the stylesheet href directly. Thoughts?\nhttps://github.com/filamentgroup/loadCSS/commit/1f97ab05ea1742b51f80c9cd397ff026c6e6bf3d\n. I've seen this from time to time as well (not on any sites I've developed but others have mentioned it before). \nCan you paste the entire head to make sure there's nothing else in play?\nI suspect it is a bug in PSI. It doesn't happen with many sites that use loadCSS, for example here:\nhttps://developers.google.com/speed/pagespeed/insights/?url=filamentgroup.com&tab=mobile\n. I've been talking to the PSI team and it does seem that these are bugs in their service. They don't show up in all cases where loadCSS is in play, and in every case that I've investigated, a webpagetest timeline will show that the named resources are indeed non-blocking.\nSo, I'm not sure what to recommend other than testing  to be make things are working right if PSI's recommendations seem fishy. Thanks!\n. Thanks for the discussion, folks. Just to chime in as a maintainer on this project: we think PSI is a great and useful tool, but the ultimate goal of this script is to provide a better experience for users. It's always hard to tell from the thread here, but it sounds like PSI sometimes has trouble identifying whether a loading sequence is actually render-blocking or not, which would be unfortunate, but unrelated to loadCSS or real-world users. Alternatively, perhaps PSI is properly identifying a blocking sequence, and you may need to use other tools to find a remedy. \nAs @fatjester mentioned, there are some good tools out there to independently verify and examine that your loading process is working as expected, and that can tell you if PSI's warning is worth worrying about or not. Chrome's devtools are certainly handy. We would also recommend using webpagetest.org and its timeline view for validation in this regard, as you can break things down to see a nice stepped keyframe view of the page loading process, and the waterfall views can help you identify problematic loading sequences. \nSince this one has seemed to be a PSI issue all along, I'm inclined to lock down comments, assuming it does not appear that any action is required on our end. But if I'm missing something particular to loadCSS, we'd want to address it. . Note: this does appear to be a loadCSS bug, not a chrome bug. This reduced demo does not make 2 requests:\nhttp://output.jsbin.com/legefitaha/1/\n. never mind! there was no expires header on the css file. yay no bug :)\n. thanks @igrigorik :) \n...was there an alternative way you were thinking it could be enabled if not the rel toggle?\n. @jakearchibald I think that approach is a really interesting idea but it leaves me with some questions about how it would work:\n1.  Based on the sites I've built with inline+async CSS loading so far, I think I'm of the opinion that it's preferable to allow the lower region of a page (below the \"fold\") to render immediately while the full CSS is loading asynchronously, even if the inline CSS doesn't contain all of the styles that region needs to render to its intended state. At least in the layouts I've worked with, the inline CSS tends to carry CSS for the overall page layout that frames page content both above and below \"the fold,\" and a great deal of styles typically cascade through both. Have you found cases where this doesn't happen? Might you have an example of a layout where the below-the-fold region is unusable enough to warrant hiding it while additional CSS is loading?\n2. If this behavior for link in body lands in Chrome, do you think there will be a render-blocking time limit for those links in the body, similar to how browsers are handling their behavior of hiding text while custom fonts are loading? I worry the blocking behavior will make for yet a potential single point of failure for a portion of the page content.\n3. How do you envision this working in a template setting? My initial impression is that in order to pull this off in a large-scale site, you'd need to evaluate the template's \"critical\" css with a tool like the ones we use today, and then return to the HTML template to insert the link(s) throughout the body of the page, just after the portion of content that was deemed critical in the visual layout?\n4. We typically pair the inline CSS + async full.css approach in such a way that we only need to embed inline CSS for the first page someone visits on a site. After that, the full CSS can be assumed to be cached in the browser and other templates on the site can reference it directly instead of including inline CSS at all. We do this by setting a cookie once the full css has loaded, which is somewhat of an inference but seems to work well. That said, it rests on the idea that the inline CSS for a template is a subset of the full CSS for all templates. Any thoughts on how the body links approach would take advantage of caching in a similar way?\n5. Where can I post these questions instead? :)\nThanks @jakearchibald !\n. Thanks @igrigorik. \nAllowing link in body from a validation perspective seems reasonable enough. \nMaybe my questions can be summarized with this: In what conditions would it make sense for a developer to place blockinglinks throughout the body if they could instead load the full CSS without blocking render, like the demo page above does? For example, the following image compares a page on Filament's site when fully rendered, to that same page with only its inlined \"critical\" styles. It seems like the layout on the right is usable enough to show immediately, even if some inner elements will repaint when the full css arrives. Is this the situation the link in body approach aims to avoid?\n\n. Hey @jakearchibald. Thanks for the feedback :)\nI definitely agree with you that the layout on the right is incomplete. I just think it's preferable to show content that isn't fully rendered instead of showing nothing at all. If there's a short time after which a browser will stop blocking rendering and show the content following a link, this might be less of a problem I suppose. But without that, it could leave portions of a content (that have already been downloaded) inaccessible for a long period of time. We started inlining CSS to avoid that problem\nAs a parallel example, it seems like folks have come to an agreement that hiding text for more than a few seconds while custom fonts load is not in our users' best interests. A progressive render in that case, and I think maybe in this case too, seems preferable to showing nothing. \nAll that said, I'm starting to wonder if an ideal first-approach to \"critical css\" inlining is to try to capture all CSS necessary for a view, rather than just for the \"above fold\" portion. Then the async fetch is merely for caching CSS for the next view. Mileage would vary though...\n. Oh - your points about the transition to http2 are great. And the part about the cookie & cache: yeah... hrm. I love the idea about improving that with service worker. In absense of that, it has seemed like a worthwhile assumption, since it often works as we'd prefer, and in the case that it doesn't, the user ends up with a blocking CSS reference, which I'd consider more \"unoptimized\" than \"broken\" at least.\n. > Btw, I haven't done a test to see how inlining compares to HTTP/2 push\nYeah. We've been going under the assumption that a lot of these workarounds will be unnecessary with Push, but I guess as long as we're serving HTTP1, it's nice to make it as fast as we can.\nthanks!\n. @igrigorik is there an updated approach to detecting link[rel=preload] that we should be aware of at this time? Thanks.\n. ah yes, sorry. thanks @yoavweiss \n. Looks like this will be relevant to our interests here https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/xEoWkGEd_g4/Pkn_o92EAwAJ\n. Now that Canary's support is testable, there's a workflow script and example for this in master now. \nWill tag for release soon.\n. I\u2019ve seen this happen when the CSS file does not have future expires headers set, for caching . Is that the case for you?\n. cool - ok to close out then? lmk if not :) \n. Yes. We often do set a cookie when using loadCSS to load our full stylesheet so that future page visits can reference that stylesheet directly. It works great, and in the worst case where someone clears their cache but not their cookies, they'll just load the CSS like most every site on the web, missing out on the rendering performance but probably not causing much trouble beyond that.\nSo I'd recommend trying that for sure, and we maintain Enhance to combine similar scripts that work towards that goal. Here's an example workflow: https://github.com/filamentgroup/enhance#a-fully-configured-head-setup-for-enhancejs\nThat said, I don't think it'd be ideal to combine loadCSS with our cookie script so that it could always set a cookie. Sometimes we don't want to set one, and of course cookies bring liabilities in some countries (you have to let the user know when you set them). Anyway, that's how we use it!\n. I agree it'd be good to document any known browser limitations.\nInstead of using a jsfiddle or similar service, you can test the following link, which references a file that takes about 5 seconds to load. If loadCSS is working the page text will appear immediately and later change to white text on a green background:\nhttp://filamentgroup.github.io/loadCSS/test/test.html\n. Thanks folks\nShall we update the readme with a support section and close this one out?\n. I think the proposed fix in https://github.com/filamentgroup/loadCSS/commit/1f97ab05ea1742b51f80c9cd397ff026c6e6bf3d will be a bit more reliable. Thoughts?\n. Hey @zachleat - mind giving this a look?\n. Can you post a little of the code you're using to call loadCSS?\n. I've set up a test directory to try to reproduce this. https://github.com/filamentgroup/loadCSS/tree/71/test/71\nThere are 2 pages, one.html, and two.html. One.html uses loadCSS to load a CSS file, test.css, which styles the body element's background color green. The screencast below shows me:\n1. opening one.html (green background means loadCSS worked properly), \n2. clicking a link to two.html\n3. clicking the back button to return to one.html (again, green background means loadCSS worked properly)\nBased on this, I'm thinking you may be seeing an implementation-specific issue. Closing out because I can't reproduce it, but please let me know if I can change anything with this test to make it reproduce the bug.\n\n. Merged. Thanks!\n. Good question, @zachleat. \nWorth noting here that the onloadCSS extension binds directly to the onload event, just like it would if you use the now-deprecated callback argument. There are a few exception cases (android native browser) that don't support onload natively for CSS, so it attempts to patch support for those, but that's it.\nOne thing that might be happening here is that onload perhaps works better when bound before the link is inserted into the page. If so, that'd be a good argument for un-deprecating the callback argument and bringing the onloadCSS workaround into the core function.\n. Thanks @Krinkle \nOne more that'd be helpful to see is the first demo with the callback argument used, and whether that indeed avoids the bug too. Easy to make?\n. Marked for 1.0.0 milestone\n. A couple things to try:\n- toggle [rel=alternate stylesheet] or [disabled] attributes instead of messing with media, to see if they deprioritize the fetch in a similar way\n- add a check for the stylesheet node's cssRules array length (just rules) in some browsers before calling defined true\n. Updated pen with latest loadCSS. Issue persists: http://codepen.io/scottjehl/pen/MagqqJ\n. @Krinkle \nThanks. I think we've got this in good shape now. This PR has the edits and the codepen is working as expected with the new code. Let us know if you find any problems after the merge\n. Notes as i'm working through this:\nOur onloadcssdefined callback does appear to still serve as a fine onload fallback for browsers that do not support link.onload. Using this test (which loads a slow-loading css file to test timing), I can confirm that the onload and cssom test messages append at about the same time in the browsers we know lack onload support.\nThat said, our notes said that android 4.3 lacked onload support and I've found here that it does seem to support it (4.2 does not however), so we should make sure we aren't polyfilling there.\n. Okay, progress. Here is a basic test that shows an onload handler will fire before our CSSOM check is able to flip the media type to all. http://codepen.io/scottjehl/pen/medGXj?editors=001\nThe solution will likely be to flip the media type to all using an internal onload handler of our own, in addition to the CSSOM check (whichever fires first is fine).\n. And this test shows the workflow I think we'll want... though it's firing more often than necessary in firefox, so that may need a look. saving here for later http://codepen.io/scottjehl/pen/YyzObO?editors=001\n. Now that we use onload to switch the media type (or a fallback if not supported), this should be fixed. Testing now!\n. okay, I think I have a fix ready for testing. \nThe new test page is the same as the original test posted in this issue, except that it uses loadCSS.js from master, and onloadCSS.js from branch 126 (which is tweaked a bit to play nicely with loadCSS's onload event handler). Also, the test's own scripting is moved to the end to work now that loadCSS is defined via an iife.\nOriginal Failing Test: http://codepen.io/Krinkle/pen/qdjVJV\nNew Passing Test: http://codepen.io/scottjehl/pen/eJrBQw\nScripts involved: \nloadcss.js from master: https://github.com/filamentgroup/loadCSS/blob/126/src/loadCSS.js\nonloadcss.js from branch 126: https://github.com/filamentgroup/loadCSS/blob/126/src/onloadCSS.js\nIf this tests out well across browsers, we'll just want to include a unit test before merging and closing out. Feedback appreciated, thanks!\n. Thanks @rupl \nJust to clarify: are you saying the failing case was just the original test case, as expected? Thanks\n. ah. weird ok. Will test! Thanks\n. Thanks @rupl \nWe're seeing the new test pass in iOS 9.2 in both Safari and Chrome. Same version of iOS that you noted, and we tested on two phones. Tried incognito/private mode as well in both and still got good results.\nCould you tell me which version of Chrome you have? \nWe're on 48.0.2564.87 here.\n. More browser tests I just ran, all passing:\n:+1: Windows 10 Edge (12)\n:+1: Windows 8.1 IE 11\n:+1: Windows 8 IE 10\n:+1: Windows 8 Firefox 44.0\n:+1: Windows 8 Chrome 47\n:+1: Windows 7 IE 10\n:+1: Windows 7 IE 9\n:+1: Windows 7 IE 8\n:+1: Windows XP IE 8\n:+1: Windows XP IE 7\n:+1: Windows XP IE 6\n:+1: OSX Chrome 48.0.2564.82 (64-bit)\n:+1: OSX Chrome Canary 50.0.2632.0 canary (64-bit)\n:+1: OSX Opera 30.0.1835.59\n:+1: OSX Opera 34.0.2036.50\n:+1: OSX Firefox 44.0\n:+1: iOS 9.2 Safari \n:+1: iOS 9.2 Chrome \n:+1: Windows Phone 8.1 (Lumia 930) IE \n:+1: Android 6 Nexus 6 Chrome \n:+1: Android 5 Galaxy s6 Chrome \n:+1: Android 4.4 Galaxy s5 Chrome \n:+1: Android 2.3 Browser \n. wow. Still weird to know that one didn't work though... other chrome 47s tested fine (Win 7 above, notably).\nwell, okay I guess! Thanks again @rupl \n. In many modern browsers (particularly anything webkit or blink based), any CSS referenced in the page source via a link or import, no matter where it is (even at the end of the page), will cause rendering to stop as soon as the HTML parser encounters it (and not, as many expect, after the browser renders the elements that come before it in the source order). Firefox is an exception here (last I checked) - it'll render elements that precede the link before stopping rendering while it finishes fetching/parsing its stylesheet. Now, that's true of link and import. Here's a test page that verifies that the example above will block rendering of content that comes before it. \nhttp://filamentgroup.github.io/loadCSS/test/import.html\nThis page simply references a CSS file that takes 5 seconds to respond (we use this for all tests in the repo to test for blocking.) The gif below shows a blank screen while the css is loading, even though it comes last in the source.\n\nI'll add a note to the readme. Thanks\n. If anything, the more assets you can safely move to async loading, the faster the page will render, and speed is now a primary factor in search engine listings. Keep your HTML content accessible to crawlers and you'll be good to go\n. thanks. you can call loadCSS multiple times and the css files will be referenced in the order you called them. That said, there's no guarantees on the order they'll arrive.\n. Thanks for the feedback.\nWe're currently discussing whether or not it makes sense to continue to cater to Bower or solely maintain an NPM package, since the latter comes with better dependency management and such. This is also more of a question across all FG repos, since we love working with NPM. \nThoughts on that are welcome\n. I think we'll keep bower in here for those who find it useful but reserve minification to the end-developer's build. Thanks for the suggestions.\n. Depends who you ask at Google I suppose, but @jakearchibald recommends loadCSS in his latest google developers video: https://www.youtube.com/watch?v=d5_6yHixpsQ\nThat said, at a glance, I believe the code shown above will start the request when the first paint occurs (the first animation frame), whereas loadCSS will start the request immediately upon execution.\n. Per the docs, we'd highly recommend placing the loadCSS inline script after your inline CSS style element, and specifying its own script element via the before argument, so that it is injected in a consistent place regardless of your users' extensions and such (which can mess with dom order):\nSee here for configuring the after arg:\nhttps://github.com/filamentgroup/loadCSS#optional-arguments\n. Debating this addition... \nThe primary use of loadCSS is to be inlined in the head of the html file, so it wouldn't be required by other scripts, typically. But, it's very concise if this is really all we need to play nicely with modules. Hmm. \n. Thanks!\n. I\u2019ve seen this happen when you don\u2019t have future expires headers set properly - is that possible?\n\nOn Aug 21, 2015, at 6:45 AM, Kushagra Gour notifications@github.com wrote:\nFirst calls goes normally on insertBefore. But when the function sets media attribute to all, it triggers another call for the CSS file.\nWhy could that be happening?\nBrowser: Chrome 44\nOS: Max OSX 10.9.2\n\u2014\nReply to this email directly or view it on GitHub https://github.com/filamentgroup/loadCSS/issues/84.\n. Hey @paulirish \n\nThanks for the detailed writeup. Sounds reasonable to me for the default. That said, we've been recommending the use of the before argument in loadCSS to specify a particular element to insert the CSS before, and we recommend passing in the script element that holds the loadCSS function as one easy way to do that (since it's in a dependable place in the head.\nHere's an example of that usage: https://github.com/filamentgroup/loadCSS#optional-arguments\nIt comes with the benefit of knowing that browser extensions can't make your inject location inconsistent too, which is nice.\nGiven that that option is there and recommended, would you say we should keep that recommendation in place or just go with this new default you've recommended above?\nThanks\n. Fair point, @whjvenyl, even if that's a rare case. \nIncluding script in that lookup should cover most cases I'd think.\nSpeaking of rare cases, we'll want this script to continue working in browsers that don't have querySelector support too, so the actual lookup for this will be a little more verbose...\nWhich leads me back to wondering if it might be best to simply start requiring the before argument and letting folks define their insertion point specifically. This can be done pretty easily by adding an ID to the script element that contains loadCSS, as our docs show, or by adding a meta tag or some other element as a placeholder reference for insertion.\nThoughts on requiring that arg instead of making the script cleverer, @paulirish ?\n. Okay, @paulirish : how's this PR look? \nhttps://github.com/filamentgroup/loadCSS/pull/87\n. @paulirish sounds reasonable, and I like the idea of keeping the 2nd arg optional. Cool, cool.\n. @paulirish any pro/con to the item() method in your example over say, [] reference syntax? That one's actually new to me (thanks! :) )\n. @paulirish I was looking to pack this up for 0.2 and had a quick question. The QSA check is a small bummer to me because it leaves the potential for a busted CSS cascade in non-qsa browsers, unless the before argument is there to specify a specific placement.\nOf course, non-qsa browsers are rarer now, but I think as a bare minimum, loadCSS should still try to preserve cascade order in a browser that doesn't have qsa, which means before is still needed with the current code.\nThat got me thinking that maybe there is a non-qsa approach to what we're trying to do. For example, something like this could give us an acceptable node to append after... basically, the last node in the body or head.\nvar scope = document.body || document.getElementsByTagName( \"head\" )[ 0 ];\nvar lastElement = scope.childNodes[ scope.childNodes.length - 1 ];\nAlternatively, a lookup like document.getElementsByTagName('*'); could get us to the last element node too (but I dunno if that lookup is slow or perhaps aliased internally).\nAnyway, have any thoughts on the snippet above in place of the qsa usage?\n. new related issue https://github.com/filamentgroup/loadCSS/issues/100\n. Okay @paulirish your change is in version 0.2.0, along with that newer fallback so that it'll inject after all scripts and styles even if qsa is not supported. thanks\n. - @paulirish \n. maybe just go for an iffe approach here instead.\n. Tests are passing in browsers, yet failing in phantom. Standby :/\n. Fixed in firefox but tests are still failing only in Phantom.js\n. Just so I'm clear, are you trying to run this script via our onloadCSS callback function? Thanks.\n. Closing this out as a dupe of #74 \n.  I suppose a script can have good reason to include loadCSS for loading files later on, but yes, inlining this in head is the primary use case.\nWe have npm and bower in here because it's common to include this file via a build process and to include the latest version of the file in head\nDoes adding it to CDNs address anything these other package managers do not? Thanks\n. Latest release has a minified version of all three scripts. Thanks for the push. As for CDNs, I think we're going to stick with just here and NPM as distribution options, but end users are welcome to put loadCSS on a CDN with attribution. . @rsteinwand glad the version you need is available now. If you have a test case for us to look at with the IE issue you mentioned, please file a new issue and we'll take a look. Thanks again.. Thanks for this. Good ideas. Let's pull it in!\nOne question we have is whether the following is split for any particular reason. Otherwise, looks great!\n\n. weird, I\u2019m seeing tests pass just fine with this combined. I tried it minified too, to be sure. I\u2019m not sure I understand why it\u2019d be any different one way or the other?\n\nOn Sep 29, 2015, at 4:38 PM, Dirk Lemstra notifications@github.com wrote:\nYou need this split because the method calls itself recursively. Without this (dlemstra@88c133c https://github.com/dlemstra/loadCSS/commit/88c133c543332b23881117941dabdc66050dbbff) it failed to pass the unit tests.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/filamentgroup/loadCSS/pull/98#issuecomment-144198782.\n. thanks again!\nOn Sep 29, 2015, at 4:56 PM, Dirk Lemstra notifications@github.com wrote:\nI updated my comment. I thought that piece of code was causing the tests to fail but it passes them perfectly now. Sorry for the confusion.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/filamentgroup/loadCSS/pull/98#issuecomment-144202750.\n. the latter, which was a recent update. we\u2019ll update the readme thanks!\nOn Sep 26, 2015, at 1:33 PM, superpoincare notifications@github.com wrote:\nYour README.md https://github.com/filamentgroup/loadCSS/blob/master/README.md#optional-arguments https://github.com/filamentgroup/loadCSS/blob/master/README.md#optional-arguments says:\n\"By default, your stylesheet will be inserted before the first script tag in the DOM (which may be the one shown above).\"\nThe file loadCSS.js https://github.com/filamentgroup/loadCSS/blob/master/loadCSS.js#L13 https://github.com/filamentgroup/loadCSS/blob/master/loadCSS.js#L13 says:\n\"By default, loadCSS attempts to inject the link after the last stylesheet or script in the DOM.\"\nSo which one is it?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/filamentgroup/loadCSS/issues/99.\n. @superpoincare interesting questions. mind posting a link to the page in question?\n\nOne thing that could be happening is the script is running before later elements in source have been parsed, so the last script or style in the page happens to be the one that loadCSS is running from. \nExpected cascade is for new stylesheets to land after old ones in source order.\n. not yet but I will! Btw: we're considering moving to one approach for insert location: after the last node in the body or head. https://github.com/filamentgroup/loadCSS/issues/102\nBut regardless, I think that this script runs early enough that we're not seeing all possible insert locations. Makes me wonder if waiting for domready or even first paint would make more sense.\n. Sort of. We might need to wait for something like RAF or domready before actually inserting the link in the dom.\n\nOn Oct 1, 2015, at 12:05 PM, superpoincare notifications@github.com wrote:\nI see. Something like fetch the css file(s) with media set to \"only x\" and use something like requestAnimationFrame to set it to \"all\" (with different code for old browsers)?.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/filamentgroup/loadCSS/issues/99#issuecomment-144787846.\n. PR here. Tested in some non-QSA browsers like IE6 and 7:\nhttps://github.com/filamentgroup/loadCSS/pull/101/files\n. cc @paulirish\n. nice service! \nHowever, I think if we offer a minified version, we may want to add a grunt task to run uglify ourself, and decide whether to keep it in a dist folder here, or just document the task for folks to run locally. Maybe the dist option would be most convenient for people grabbing the script, so we should include both JS files, unminified and minified, I think.\n. @MarcoHengstenberg yeah, that may be the best route if we do it. Thanks\n. Nice idea. +1\n. As mentioned in #204, I'm not sure how this would work if the attribute is only allowed with link[rel=stylesheet]. We could polyfill it but that wouldn't help native support.. I'm not sure that specifying both values would behave as one would want... would it block or fetch async? I've not seen this spec'd or tested.. So @sideshowbarker it seems that folks want to allow SRI to work with preload alone, but it currently does not, and specifying rel=\"stylesheet preload\" will currently block rendering. Is that correct? If so, should we wait on this one? We can polyfill it but we'd want native support to work as expected first.... This is supported now in 2.1.0! See the attributes argument if you want to use it. Thanks!. This looks really great!\nThanks so much. We're pretty swamped this week with project work but we'll try to get this tested and in soon\n. So, I just reviewed this and we really appreciate it. Unfortunately, while it does prevent the double request in Chrome, it comes at a couple of costs we don't want to introduce. Triggering layout is one of those costs, and while it may not visibly do anything undesirable, setting a link to display: block, even temporarily is at least unusual, and may be wise to avoid. Also, there may be cases where folks do actually want to load the same url more than once, such as when caching headers are set to expire immediately. \n\nFortunately, I've got a simple workaround on the way that addresses this bug in a simple manner. Will post today. Thanks again!\n. Closing per zach's comment, and also because the code is out of date. Happy to look at the issue again if needed though\n. When this issue comes up, it's almost always due to the CSS file not having a future-dated expires header, so it doesn't get cached.  Can you check if you have your caching headers set on your CSS file? Thanks\n. Update: I read that header date wrong. Okay... yeah that looks configured fine.\nI'll see what else it could be\n. updated ^\n. Just making notes. I only see one request when calling the following from filamentgroup.com:\nloadCSS(\" //cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css\")\n(removed http: prefix for our site since it's https)\n. Okay, and running that again with the latest version of loadCSS (same version you're using) does in fact produce 2 requests. Thanks. Verified, we'll dig in.\n. well, a temporary workaround should be to downgrade to version 0.1.7\nhttps://github.com/filamentgroup/loadCSS/releases/tag/0.1.7 https://github.com/filamentgroup/loadCSS/releases/tag/0.1.7\n\nOn Nov 17, 2015, at 6:05 AM, Robin Drexler notifications@github.com wrote:\n+1 We're also experiencing this issue. Are there any updates or known workarounds? Thanks. :)\n\u2014\nReply to this email directly or view it on GitHub https://github.com/filamentgroup/loadCSS/issues/110#issuecomment-157351072.\n. I haven\u2019t gotten to the bottom of it yet, but I\u2019d seen that the issue was introduced since that version, so that\u2019s all I could recommend at the moment. Sorry\nOn Nov 17, 2015, at 9:16 AM, Robin Drexler notifications@github.com wrote:\n@scottjehl https://github.com/scottjehl thanks for the fast reply. :)\nCould you please elaborate on why the older version does not cause the multiple requests? As far as I understood, it's caused by the switch of the media attribute. This is done in the older version as well.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/filamentgroup/loadCSS/issues/110#issuecomment-157399995.\n. Sounds like https://github.com/filamentgroup/loadCSS/issues/108 is promising. We'll be taking a look as time allows\n. After some tinkering this morning, I found that if the media toggle takes place via the link's onload event handler, that does not cause a double request in Chrome. Since the current callback is basically an onload workaround anyway, it won't hurt to bind to both and keep whichever applies the toggle first (onload comes before our simulated onloadcssdefined in Chrome). \n\nSeems to do the trick. I'll push a PR shortly for review.\n. Hi all. A PR is submitted for this. Comments on the code changes and whether or not it fixes the issue for you are very welcome. Thanks!\n. @skyl got an example? Looks okay here to me:\n\n. I think your cache control header is causing the browser to request a new version because the file expires on delivery. Seem accurate?\n. if you can reproduce in a live demo url I'll be happy to take a look. Thanks\n. At a glance, \n1. In iOS and Chrome, and IE and Firefox too (I think, but can't recall without testing), your dynamically inserted link will block page rendering until it finishes loading. It's essentially the same as having a link in the head of your source to begin with. This behavior is changing in browsers like Chrome currently, but it's still all over the place across browsers.\n2. In older IE, appending to head like that can cause it to crash if head hasn't fully loaded yet. InsertBefore is considered the safer approach.\nThe purpose of loadCSS's logic is to insert the link in a way that it'll fetch asynchronously, yet still apply when it's loaded. Modern browsers will fetch any stylesheet in a non-blocking manner if its media type does not match (for example, media=print doesn't block rendering), so that's why loadCSS starts with a non-applicable media attribute, then toggles it to the one you want after the request is at least in flight (or fully loaded).\n. Reopening this as it is still not fixed in latest, contrary to earlier test results.\nA reduced test case demonstrating the behavior in Chrome is here: http://filamentgroup.github.io/loadCSS/test/110-reducedexample.html\n\nIt sometimes takes a few refreshes to see the behavior, as it's inconsistent.\n. @mjau-mjau thanks. it's a hard one to reproduce, I agree. The chrome team has verified a reduced test case today here: https://bugs.chromium.org/p/chromium/issues/detail?id=591654\n. just to reiterate from above, this is a chrome bug in their tracker. I'll close it out once it's fixed there, but we won't be addressing it here. Thanks\nhttps://bugs.chromium.org/p/chromium/issues/detail?id=591654\n. The chrome bug causing this issue has been assigned to a developer so it should be fixed soon. Keep ya posted.\n. @sschengyf thanks. Just repeating from above, but it's a Chrome bug that the Chrome team has accepted in their tracker. We won't be fixing it here.\n. Hi folks. Just so I can confirm: are we now referring to the pagespeed insights warning or the double css loading bug? \nAs mentioned in the issue description, the 2-requests issue is a Chrome bug that may be fixed now, though probably not as it's still open: https://bugs.chromium.org/p/chromium/issues/detail?id=591654\n. Sounds like the same Chrome Bug causing both, is that correct?\n\nOn Dec 15, 2016, at 10:27 AM, Philipp Winterle notifications@github.com wrote:\nI referring both.\nStill got the double chome request and so does the PSI -> double PSI Chrome request\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/filamentgroup/loadCSS/issues/110#issuecomment-267372550, or mute the thread https://github.com/notifications/unsubscribe-auth/AANG_wCdR1p-1JHG9DbMkcuMHWD-UckJks5rIWqAgaJpZM4GZGfL.\n\n\n. Hi folks. Just a note from the maintainers. \nThis project aims to produce the desired result of asynchronous CSS loading. We test in various browser dev tools to verify that it's working as expected, and we're certainly open to any fixes that improve the loading behavior. \nWe've noticed inconsistent reporting from Pagespeed Insights for years with regards to whether asynchronous assets were indeed loaded that way. In cases when that particular tool throws a warning about the CSS blocking render, we have not usually been able to reproduce the problem manually. We'd love to see more consistent reporting from PSI, but we don't plan to change this script just to please the quirks of any one tool, unless it is actually a problem occurring in browsers.\nAlso, now that our recommended approach is to simply piggyback on link[rel=preload], chrome (and I assume PSI too) will not receive any behavior from this script anyway. So, if PSI is reporting issues on a page that uses link[rel=preload], it won't be a loadCSS issue.\nAnyway, let's keep tracking this bug here and if you can reproduce issues for us to look at, we're always happy to look. Thanks.. I'm unsure if this is fixed in latest, but the issue will not occur in Chrome if you're using link[rel=preload], which is our recommended workflow now for this project. The issue occurs when toggling the media attribute, which would never happen in a preload-supporting browser when using cssrelpreload.js (it only happens when we need to polyfill preload). \nTo test if the issue is still present for script-driven CSS loading, we can test this page I think, which calls loadCSS() and toggles the media attribute: https://master-origin-loadcss.fgview.com/test/test.html\n. @odahcam Thanks. Still an open chrome bug. There's no plan to address this in loadCSS but we'll keep this open for info purposes.. The latest readme recommends onload=\"this.onload=null; this.rel='stylesheet'\", which makes the onload handler apply once. I think that covers what you're asking?. It doesn't change any. But it does add a data-loadcss attribute after polyfilling a link so that it knows not to touch the same link twice. Does that answer your question?. Thanks for this, but the code is a bit outdated at this point and I'm not sure the project is ready to move to es6 yet as well. Once we do, we'd really love your help though. Thanks.\n. reopened. So this issue occurs when the loaded stylesheet contains a @media print block?. I'll take a look. In the meantime, you can always pass an identifier for a particular location in the DOM to ensure it'll insert just before that node. See the before argument here: https://github.com/filamentgroup/loadCSS/blob/master/README.md#optional-arguments\n. Can you test the latest script in Master and see if this is still an issue? I made this page to test now in iOS Chrome, and will close it out if the background goes from gray to green.\nhttp://filamentgroup.github.io/loadCSS/test/test.html\n. Tested and confirming it works as expected in iOS Chrome. Try the latest in master and you should be good to go!\n. Looks good thank you. \nThat said, I think the fix for #126 will address the scope issue similarly, so I'm going to close it out but I'd appreciate if you could verify that it does. \nhttps://github.com/filamentgroup/loadCSS/blob/126/src/onloadCSS.js\nAlso, the version of loadcss in master exports using exports.loadCSS, which also avoided the collision with the test suite. Does that look ok?\nhttps://github.com/filamentgroup/loadCSS/blob/master/src/loadCSS.js#L67\nClosing for now but I'm happy to reopen for either point.\nThanks!\n. Thanks for the suggestion. Currently, you can call loadCSS multiple times and files will be referenced in the order they're called (preserving cascade). Passing more than one file is beyond the scope that the project intends, but thank you for the suggestion.\n. @bramstein not sure but I suspect it has to do with switching the media type before the stylesheet is parsed to CSSOM, since onload catches it then, before the href property is exposed along with the rest of CSSOM properties. I was able to reproduce it using a timeout as well, so I think it's more about catching it as early as possible, rather than any time later  than that. But... it's indeed a little mysterious still.\nOne thing I like about this fix is onload is what I'd prefer to use anyway, if it worked more broadly, so the change feels right, even if it's still unclear why its specific timing seems to help.\n. Mostly though, it'd be great to get some folks testing this on different sites to see how it holds up beyond the few tests I ran. But it seems to cover a few different stylesheet sizes at least (including the one from issue #110 and a much slower 5 second loading time file).\n. Merging to master!\n. @jakearchibald got a sec for a quick review?\n. Good question. It's already working in Canary, which supports these apis, for what it's worth.\nAs for that method vs contains, maybe @yoavweiss would have info...?\n. @vijayaraghavanramanan that's a good question. I was trying to make the polyfill line up with how it'd behave in a supported environment, so that's why it injects in-place. For example, in Chrome Canary, this script won't do anything because the link rel=preload feature is supported. So in that browser the stylesheet will load using the same link tag. \nI think the best approach may be to place your link after your inline styles, even if that means the fetch leaves later than it would during preparse. I'm guessing it won't make too big of a difference but I can't say.\nClosing out as wontfix but happy to reopen and discuss further. Thanks!\n. Good to know.  Thanks for the report @giratikanon @yoyurec \nMaybe it's stuck in some sort of onload handler loop. Let us know if you see anything... we'll get on it.\n. Thanks @vijayaraghavanramanan \nThat approach, while very concise, only works in browsers that have onload support for links. Unfortunately, that's not the case for whole lot of modern androids out there. \n. @giratikanon also, just anecdotally, we were curious if you ran into this through user reports or just lab testing? Just wondering how prevalent these versions are since FF is evergreen, by default at least. \nIf there's something we can do to fix it though, I'm into it.\n. Thanks, Tom.\n. well that is helpful and unfortunate! Thanks Mike. \nMoving the media toggle to onload really helped us with a few issues in other browsers, like preventing occasional double-requests in Chrome. \nWe'll give this some thought now. Thanks again\n. Quick update: looks like toggling media via a setTimeout lets the stack clear or whatever and prevents this bug in 41 and 38. I'll post a PR shortly. Testing for any regressions elsewhere first (double-downloads in Chrome could be one thing to watch out for).\n. Another update!\nSo it turns out that a workaround we added last release, as an attempt to stop Chrome from occasionally requesting a CSS file twice, is not working 100% of the time in further testing. This workaround also happens to be what introduced this old-firefox crash: we started using an onload handler (where supported) to toggle the link's media type. \nI've reopened the bug for the double-request in Chrome https://github.com/filamentgroup/loadCSS/issues/110#issuecomment-191464973 and since I'm able to reproduce it with a few simple steps independent of loadCSS, I made a reduced test case (linked in that comment) to see if the Chrome team thinks its worth fixing or if perhaps there's a workaround we can try.\nFor loadCSS, I think we should remove the onload handler in loadcss.js and go back to toggling the media via our original check (which didn't require onload and thus didn't crash old Firefox).\nAs for Chrome, I think we're in good shape there anyway because the momentum of this project is very much heading in the direction of using loadCSS merely as a polyfill for browsers that don't understand link[rel=preload], which brings us native asynchronous CSS loading. Chrome will soon have preload support in stable, so loadCSS won't need to run in that browser anyway, and this bug won't matter much. If you're interested, here's a demo of that pattern, which we'll be recommending as the primary means of loading async CSS: http://filamentgroup.github.io/loadCSS/test/preload.html\nA caveat: after we remove onload for the toggle, we'll be re-introducing an issue with our onloadCSS.js extension, fixed with last release, which could cause it to fire its \"onload\" callback before the media attribute was toggled. To retain the fix, I think we'll need to poll the media attribute in that handler and make sure it has been toggled before allowing the onload callback to fire.\nFor anyone affected by this bug right now, I'd recommend rolling back to loadCSS 0.2.2 if you aren't relying on the onloadCSS handler. \nWe'll get this settled in the next release. + @giratikanon \n. @giratikanon turns out the fix was simpler than it seemed.\nMind testing this? https://github.com/filamentgroup/loadCSS/pull/143\nWe may merge it sooner... I've got FF 41 running tests without crashing now. Thanks!\n. I'm getting that now too. Thanks. On it...\n. Okay, all tests are passing and FF 41's no longer crashing.\nI'll merge this in a few. https://github.com/filamentgroup/loadCSS/pull/143\n. Yes but I'm not sure we want this script to manipulate storage or cookies itself. \nYou could, for example, try something like this in the head of your page:\nif( localStorage.fullcssloaded ){\ndocument.write( '<link href=\"...\" rel=\"stylesheet\">' );\n} else {\nloadCSS( \"...\" );\nlocalStorage.fullcssloaded = \"true\";\n}\nStill... localStorage lookups are synchronous and measurable in delaying rendering time. It'd be faster to set a cookie or session var and use that in your server templating for logic like shown above. We do that typically and find it works well.\n. Sure. The polyfill executes very early in page-parsing, often before all links are reachable in the DOM. This part runs the polyfill immediately, but also repeatedly on an interval until the onload event fires. \n. @vijayaraghavanramanan this line sets the link's rel to null so that it won't be found again.\n. Er, sorry this line! :) \nhttps://github.com/filamentgroup/loadCSS/blob/master/src/cssrelpreload.js#L23\n. is this still valid in the latest version of phantom? Thanks. This seems like a handy fix. I'm just curious if we can support it without adding anything specific for phantom in this clientside library, since it's not a user-facing browser. \nWould it be possible instead, for example, to put something like this early in your own app JS?\nif ( /PhantomJS/.test(window.navigator.userAgent) ) {\n        // if in phantomjs, set this property to trick the onloadCSS inference test \n        navigator.isApplicationInstalled = true;\n}\n. Closing this based on my last comment/question, but I'll reopen if folks still feel this workaround should be in loadcss and not in the end codebase. Thanks. Seems fixed now in master. Thanks and sorry - late with the triage here.. fixed in master\n. Thanks!\n. hmm. okay I'm confused. This change reflects what the spec says, which is good. But it also seems to work fine in Canary with `as=\"style\". Any ideas why that'd be?\n. okay. I updated the polyfill too. Does that cover everything? If so we can bump the version...\n. I don't think so, no. Since this is a spec polyfill, it's a bug. Make sense?\n. Thanks. I think since the bug is in the polyfill, and it's only been out for a couple hours at this point, it's probably the right call to fix the bug to match the spec and tag as 1.1.\nHope that works for folks.\n. I think we're all good. Thanks so much for catching the bug!\n. Thanks @HugoGiraudel \nDoes that version of chrome support rel=preload yet? I thought it was just canary still...\n. Hmm. I enabled Experimental Web Platform features in chrome://flags in Chrome 49.0.2623.75 (latest, not Canary), and now I'm getting that warning for as=\"stylesheet\"! Pretty confused now...\n\n. - @igrigorik\n. Yoav's article has it listed as style here, but it's my code so it could be a mistake... https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/#markup-based-async-loader\nspec says stylesheet here: https://www.w3.org/TR/2015/WD-preload-20150721/\n. Chromium bug filed:\nhttps://bugs.chromium.org/p/chromium/issues/detail?id=592139&q=preload%20style%20stylesheet&colspec=ID%20Pri%20M%20Stars%20ReleaseBlock%20Component%20Status%20Owner%20Summary%20OS%20Modified\n. fair enough! Thanks for the feedback. I'll get that rolled back again. :)\n. 1.2 is out, matching the state of the 1.0 release. All's well. Thanks for the quick feedback and have a nice weekend.\n. it's as=style in master. old PR, closing late. Thanks @HugoGiraudel . Hmm. If this is desirable, we might consider running the link[rel=preload] element's onload attribute value through onloadCSS.. Master appears fixed already here but thank you!. I think this looks great, thanks. I'd like to avoid dataset in favor of getAttribute though, since this lib supports IE before 11.. Late here but this is nice, thanks. Merging.. Hmm. Seems okay for me. Chrome 49 does not pass the feature test so the css is still fetched via JS. Image verifies:\n\nDo you have experimental flags enabled perhaps? I do believe there's a bug with the experimental preload handling (it looks for stylesheet rather than style) but it is fixed in Canary, so that'll land without a problem when it makes it into stable.\nClosing as can't reproduce but... let me know what you find!\n. thanks!\n. Yes, it's that flag. Not much we can do but it'll fix itself and won't show up for non-developers, in the meantime. Thanks!\n. I think this is fixed here on github now. Correct? https://github.com/filamentgroup/loadCSS\nThat said, we probably haven't pushed the readme update over to npm. Is that where you saw the bad link? Thanks\n. okay yep. I'll get a patch release up there to fix that. sorry for the trouble!\n. been fixed for a bit. closing.. seems reasonable. We'll take a look, thanks\n. Please see the latest readme. Should be clearer now, thanks\nhttps://github.com/filamentgroup/loadCSS/blob/master/README.md. reopened #112 . @StevenFlecha can you post an example? That'd represent a big change in those releases if that's true, but we do test this regularly and latest FF and IE were covered at release time. Thanks.\n. Thanks. Chiming in now a bit late.\nso, it's expected that behavior will vary in Firefox and Chrome. The script will in fact do nothing in Chrome because rel=preload is natively supported there. In non-supported browsers like Firefox, you'll get the polyfill behavior. Support is still not wide: http://caniuse.com/#feat=link-rel-preload\nAs for the order of the markup, that situation may now be less particular as of a commit that landed on Dec 19 that should ensure the polyfill is called with one late check. https://github.com/filamentgroup/loadCSS/commit/c04222b888f49127eaf7c437926d5689de1fe785\nThat said, we do recommend listing the link first, then the script that polyfills it. I'll test this on Monday a bit more thoroughly, but if anyone has time to test the order of the markup both ways, that'd be really helpful. We'll want to test a few common browsers that do not support link rel preload. \n. updated the title of issue.... Does not seem to matter anymore. Switched order demo for testing purposes: https://master-origin-loadcss.fgview.com/test/preload-switch.html. Thanks. We offer this lib on NPM but not on CDNs, as it's intended to be inlined (though h2 push is fine as well). We'll be updating our releases with dist files soon though.. @rsteinwand  are you unable to link to your print stylesheet ordinarily? I'd recommend doing that instead of using loadCSS. It'll load without blocking due to the print media type.\n. Hi! Could I ask for a brief recap on the issue we need to address here? I'm trying to triage the issue tracker and some of these are hard to tell if they're still an issue we need to fix.. The readme table is gone now, replaced with a note that the CSS will block rendering like in IE8 and older as if it was a normal stylesheet link. The PSI example is hard to reproduce, but with our test page it seems to report as expected. I suspect PSI uses chrome, which does not receive a loadCSS polyfill anyway since it supports rel=preload. https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fmaster-origin-loadcss.fgview.com%2Ftest%2Fpreload-switch.html. Latest works well in Firefox, but does have an occasional double load issue. Tracking that here: https://github.com/filamentgroup/loadCSS/issues/189. I'm confused about this issue so maybe it'd help if you could describe the issue a little more, or why the current preload polyfill doesn't cover this situation. \nThe way the script is written currently, it starts running immediately and continues to look for preload links until the onload event fires. \n. Sounds like a bug. The \u201cload\u201d event isn\u2019t listening for the link to load, it\u2019s listening for a reasonable time to stop polling the page for links (window unload).\n\nOn Jun 21, 2016, at 11:53 AM, fatjester notifications@github.com wrote:\nSure.\nIn your demo here: http://filamentgroup.github.io/loadCSS/test/preload.html http://filamentgroup.github.io/loadCSS/test/preload.html\nthe link tag for the stylesheet appears before the polyfil script.\nIf you were move it to after the polyfill script (see the top codepen example), the polyfill doesn't work in most browsers (firefox, edge, ie) because the link tag didn't exist at the time of the script execution. The change I suggested calls the script again when the DOM is loaded (not the most elegant solution, but fixes the issue, see second codepen example in firefox or ie/edge).\nI didn't notice the event listener when I suggested the change, but it doesn't work properly in many browsers (firefox, ie, edge) - I'm guessing because \"preload\" isn't supported, and thus there is no \"load\" event for the listener to hear, and the script doesn't fire loading the styles.\nA true polyfill should work no matter where the link tag is placed, and thus the suggested change, but I'm sure there is a better way than what I'm suggesting.\nAre you seeing this script work when link tags appear after the polyfill in firefox and ie/edge? I'm testing on a mac, and in VM's from Modern.ie\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub https://github.com/filamentgroup/loadCSS/pull/178#issuecomment-227502086, or mute the thread https://github.com/notifications/unsubscribe/AANG__ufwxLjdwebMSg6VgHd9bdsL-FJks5qOBcYgaJpZM4I2WFB.\n. The PR will delay the polyfill from running until DOM ready, but I'm not sure that's desirable or expected. I suspect this issue is resolved now though, as we have two functional tests that show the script before and after link elements. Let me know if there's still an issue and we'll be happy to look again. Thanks.. Thanks - I like the caniuse link.\n\nThe second condition doesn't match the expected behavior of the preload script. Source order shouldn't matter, and if it does it's a bug we should address in the js.\nThe way the script is written currently, it starts running immediately and continues to look for preload links until the onload event fires. Are you finding that that isn't working in certain places?\n. great, thank you!\n. Thanks again for this. With the landing of the fall2017 branch, we've cleaned up the Readme a bit and some of these changes won't line up now. I'm thinking that the caniuse support link is still a great thing to add in there, but otherwise I'm pretty sure the instructions are good now. I'm going to close this out but add the link over in the readme before we package up 2.0. Thank you for that idea.. I've tested the following page (which has scripts before link) in FF, Edge, and IE latest. Confirming this now works.. Huh, interesting! Thanks. This does sound promising. I'll take a look.\n. This makes sense as a catchall for sure. thanks for the reminder. Merging. tagged here and on npm. thanks for the followup.. @vlrprbttst We don't tend to do a lot of JS-based layout calculation but I can understand the use case I think. \nIf particular CSS rules are \"critical\" to be present when your JS kicks in, you might decide to force those rules to be included in your critical css. I can't speak to the critical script you linked, but in the critical css task we maintain, we have an option to \"forceInclude\" selectors that contain a particular string. I'm pretty sure Addy's does too (we might have even gotten the idea from him!).\nAlternatively, you might consider listening for either a load event or presence of your stylesheet in the DOM to kick off your JS execution. \n. This seems to be fixed now but please let us know if not.\nExample here: https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fmaster-origin-loadcss.fgview.com%2Ftest%2Fpreload-switch.html. We have these separated out so that they can be included or not, optionally. Thanks for the suggestion though!. Thanks for the nudge. I think the docs need to be cleaned up to clarify that loadCSS is primarily recommended now as a polyfill for rel=preload. You can bundle it and call the function manually when needed of course, but we think that's going to be more of a secondary use case now.\n. The recommended use pattern is called out first thing in the readme, so I think it's clear enough to close out this issue. We'll try and improve the wording though, thanks for that. As for the pagespeed part, I noted in the specific issue from @fabioformosa that PSI's had trouble with this blocking recommendation for a while. We'd recommend testing and verifying with webpagetest and devtools if it gives you this warning. Thanks!. @MarcoHengstenberg covered this well. The polyfill will call loadCSS for you (if preload isn't supported natively) by simply including the script. So, no need to call loadCSS() yourself. Thanks. Latest demo link is here for testing this issue: https://master-origin-loadcss.fgview.com/test/preload.html. I'm seeing double-loading in Firefox. . I'll be looking at this today.. @MarcoHengstenberg I'm not seeing this issue today in Firefox, same version and platform. \nCan you double check this https://master-origin-loadcss.fgview.com/test/preload.html\nHere's what I see every time:\n\n. Hmm. I can't seem to reproduce the problem anymore.  It's just one request every time I try now.\n@MarcoHengstenberg can you hover hover the Cause column to see the trace for which JS lines trigger the second request? For example:\n\n. Interesting. I'm not sure what to make of that trace.\n@miketaylr might you have a moment to try and reproduce this one? This test page uses link[rel=preload] to reference a stylesheet, and in Firefox our loadCSS script polyfills support for that attribute by fetching the stylesheet with loadCSS(). It should only make one request, but some folks are seeing two. I can't reproduce, as shown here https://github.com/filamentgroup/loadCSS/issues/189#issuecomment-279778498. Thanks folks. Closing out!. Just getting to this now, sorry. Looks great, thanks. Merging!. Hi folks. RAF is a fine way to do it too. Google folks tend to recommend loadCSS's approach often as well, and it's async too. The way it works is the link is inserted immediately but its media type is set to a value that will not match, which triggers the browser to fetch at a low-priority, async manner, and once it loads the media is set to an applicable type (all or any custom value). This is the same behavior as how print media links are fetched. \nIt's true that Pagespeed Insights has had trouble identifying loadCSS as async in some implementations. In the past, the team flagged this as a PSI bug, but you can verify that it does indeed request asynchronously when tested.\nI'd say the advantages with the plain loadCSS() method over RAF are 1) loadCSS starts loading immediately, as opposed to after the first frame renders, and 2) broader compatibility (loadCSS is reliable in older non-RAF browsers). \nAll that said, now that standards have caught up, I'd recommend using loadCSS purely as a polyfill for  the new link[rel=preload] instead of calling it loadCSS manually. I'll be restructuring the Readme to make this clearer but it's in there now as the primary recommended workflow: https://github.com/filamentgroup/loadCSS#recommended-usage-pattern\nThe linked demo in that section includes the pattern as recommended.\n. We tested http://filamentgroup.github.io/loadCSS/test/preload.html in Safari and can't reproduce a problem. Please provide a link if you need help and we'll take a look.. hmm. I don't think it's in the enhancejs readme still. TODO! Would love the help though. It's referencing a different project's readme, which doesn't cover this update yet. I've been behind but it's on my list to update the Enhance repo with our latest workflow.. We rewrote the readme and I think this is better now. I hope! Thanks.. We've seen this issue for a while, and the PSI team has in the past acknowledged that the tool is imperfect at detecting whether some CSS blocks or not. I'd treat it as a tool for noting things you should look into further and verify yourself. \nIf you can inspect your page and verify that your CSS file is loading asynchronously (the page should be able to render before the CSS arrives), then you should go good to go. WebPageTest.org is a great tool to test if assets block or not. I'd recommend it!. For discussion, the script in question is here: https://github.com/filamentgroup/loadCSS/blob/master/src/cssrelpreload.js. If you can access the head section of templates in your Magento site, then that should be all you need to add this. We'd recommend including the loadCSS function(s) in a script tag in the page rather than requesting them externally.. Closing as dupe of #106 . We've been talking this over internally. I think we'll aim to offer some dist files with each release, but not not in branches. Keep you posted.. Min files in latest release.\nhttps://github.com/filamentgroup/loadCSS/releases/tag/v1.3.0. Thanks.\n\n\nMinified versions are included in the latest release:\nhttps://github.com/filamentgroup/loadCSS/releases\n\n\nAppreciate the suggestion. For code distribution, we currently distribute loadCSS on GH and NPM. You're of course welcome to host loadCSS on a CDN if it's helpful to you, but we don't currently distribute our code to CDNs ourselves. \n\n\nWe currently have versioned releases here and on NPM. https://github.com/filamentgroup/loadCSS/releases Do you mean version numbers written into the script? \n\n\nSRI is being discussed here. It's a good idea, thanks. Feel free to chime in https://github.com/filamentgroup/loadCSS/issues/106. Thanks for this, but the changes are too varied in scope for us to review as a whole. We'd love if you would like to re-submit some of the more important changes individually. Thanks so much.. Looks great. We'll need to add documentation is all.. With Zach's suggestion above included, I think this looks good, but it makes me wonder if there are additional standard attributes we should support via the loadCSS function as well, and if so, if we should move to an object argument for those attributes. For example, integrity seems to be growing in popularity. Others here https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link\n\n\nThoughts?. I think that's a good idea too, @philsawicki . It seems important to support, and also I'm less concerned about the API of loadcss.js growing a little bit anyway as we're mostly advocating cssrelpreload.js in its place for most use cases.. Closing this one out now that the attributes argument is available in loadCSS. It'll be in the next release. Thank you!. fixed via other PRs but thanks much!. Hi @t-kelly. Good question. Yes, that is the way that we ensure that the media query does not match when the request is made, which makes the browser request it at a low, and asynchronous, priority. Recently, browsers have been working to improve this behavior and it has always varied. I believe this toggle is still needed for webkit/safari to request without blocking render, but we're always open to suggestions. \nSince you mentioned Chrome though, I should note that we now recommend using loadCSS primarily as a polyfill for link[rel=preload], which chrome natively supports. If you're using this markup pattern, which is recommended first thing in the readme, loadCSS won't actually run at all in Chrome, because it'll detect the preload feature and exit. So, if you're running that markup pattern and see 2 requests in chrome, that is probably a rel=preload bug in chrome.\nI'll close this out but if you happen to find that the media toggle is not needed across modern versions of each major browser, we'd look into whether we want to deprecate it.. This is great thanks - but another PR added it already it seems. Thanks again!. I think this is covered in https://github.com/filamentgroup/loadCSS/pull/240. Can you confirm that it looks good to you? Thanks. hmm. yeah I can confirm. It's seemingly not a loadCSS issue so much as a media attribute toggling issue. Edge reports a new css fetch if you toggle the media attribute. This is a common scenario we've also seen in Chrome (before preload was implemented) and sometimes in Firefox too.\nHere's a simple test page that shows the two requests just from a link element that starts as media=none and becomes media=all when it loads:\nhttps://basic-onload-toggle-origin-loadcss.fgview.com/test/basiconloadtoggle.html\nIn my opinion, the best way to mitigate this problem is to ensure you have good expires and caching settings on your CSS so that when it's fetched again, it 304s instead of making a network request.\nSince we've tried to fix this one for other browsers in the past and eventually filed bugs with the browsers themselves instead of addressing it here, I'm going to close this out as wont-fix. \nThanks!\n. Yes. The aim is to load the stylesheet as late in the DOM as possible, unless there's an explicit placement specified.. Yes, possibly. If you want a more specific place, you can specify one though.\nMore on stylesheets in body: https://jakearchibald.com/2016/link-in-body/. This is interesting. So does pagespeed replace the link with a rel=\"stylesheet\" link so that it will end up applying to the page?. Seems like a good idea Thanks.. @cadencelabs-master could you post a link to that issue? That'd be helpful to track. thx!. Is this still an issue you're experiencing? I could not reproduce it in Safari. I'll reopen if so, thanks!. Thank you @rasenplanscher. I agree it sounds like it'd be outdated by now. Happy to reopen if anyone still runs into this. More detail will be appreciated if so. Thanks!. This is nice, thanks for the idea. We've been working on a refactor of cssrelpreload.js that reuses the existing link element in the page. In that refactor, loadCSS will no longer be called as a dependency, so the dom order concern here wouldn't apply. Would you be interested in looking it over and seeing what you think? https://github.com/filamentgroup/loadCSS/pull/240\nThanks again.. Thanks for commenting, folks. Good stuff all around. I think we can set up the releases so that the npm repository gets min files. I need to see how we've done that in other projects. fixed in version 2.0.0-4. Please test if you can - we'll be rolling out 2.0.0 soon \ud83d\udc4d. Hi, thanks for the tip but we don't included minified files in the repo, and we generally don't recommend using a CDN for loadCSS, since we recommend inlining it in the page. (I understand some commenters include it server-side, which is great, but still). We'd recommend using the NPM package, Thanks!. Hi there. \nYes, you can reference loadCSS externally, and there are some situations where that is useful. However, in the example you've shown, the value of inlining any code (for both CSS and JS) is that it makes the code immediately available to execute when the HTML arrives. Files referenced externally, in contrast, introduce additional round trips to the server, which can add to the time it takes to display the page. Inlining of course conflicts with the goals of making external, cacheable files, so we'd typically only recommend doing it for small files and when the performance benefits are worth the tradeoff.\nIn modern server environments where http/2 is available, you can opt to try using server push to get the benefits of external referencing while still delivering files alongside the HTML as if they were inline. Doing this effectively can require a little bit of configuration on the server side, but we recommend this approach if you can do it. \nThanks!. It's an interesting issue. But I'm not sure if the fix should be in loadCSS or in Airbnb's code. It seems like this same problem could happen similarly without loadCSS, if say, your app was appending the same stylesheet link element via its clientside routing instead of calling loadCSS. \nGiven the seemingly unique use case, I'm inclined to think that your app's JS should have a check for the stylesheet URL's presence in the DOM before trying to load it. To avoid the DOM crawl, you might instead do this with some sort of state check, through localstorage, sessionstorage, cookies, etc. \nDoes that make sense? If not, I'm happy to reopen and discuss further. Thanks!\n. Couple updates here: first, from Mozilla:\n\nThis feature was available in Firefox 56, but only for cacheable resources. It has been disabled in Firefox 57 because of various web compatibility issues (e.g. bug 1405761). An improved version that works for non-cacheable resources is expected to land in Firefox 58.\n\nAnd second, to repeat above, if FF 56 deems a CSS file as non-cacheable, it will never fire the onload handler so the stylesheet will never be enabled. The ideal fix that will work right now is to set caching headers on the stylesheet so that Firefox deems it cacheable. Even a very short expiration appears to work. \nif you can't control the caching, the onerror solution could work temporarily, and there's not much of a downside since it's just toggling the rel attr to stylesheet, and that wouldn't do harm even if the onerror case happened to be legit for other reasons. \n. Nice tip. Does this.onload=null work as well? \nThis seems concise: onload=\"this.onload=null;this.rel='stylesheet'\". Thanks for this tip. Branch fall2017 has the null addition discussed above in its docs and example pages. FWIW, I wasn't able to reproduce the chrome issue when I removed it, but I agree that I've seen it before at least. No harm keeping it I suppose. Cheers!. Thanks for the work on this PR, folks. \nI'm unsure that this would be desirable to include as a default. For example, a developer might intentionally re-request a stylesheet of the same URL several times in the course of a session knowing that its caching headers are such that a subsequent request will bring updated rules.. The related issue is closed for now, with a recommendation to somehow avoid making duplicate calls to loadCSS in that particular codebase, but I left an open question to see further discussion is warranted. Thanks everyone.. Hi! Google's PSI tool is improved now and should be better about how it analyzes pages that use loadCSS. Closing this out but feel free to ask further questions. To answer the original question: for CSS that doesn't need to load in a hurry, the code example above will work fine. It will start downloading CSS later than the loadCSS recommended workflow (which uses rel=preload) for two reasons:\n\nThe CSS in the snippet above is not referenced using a standard HTML link element, so it is not exposed to the browser's early parsing steps which would make the request very early in page processing. In particular, link[rel=preload], which is now our recommended starting point for loading asynchronous CSS, will start downloading very early in the parsing steps.\nGoogle's script approach waits for requestAnimationFrame before starting its request for the CSS. That is one way to safely ensure that the stylesheet will load without blocking rendering, but the first RAF callback can potentially happen late in the loading process depending on how many synchronous steps take place before the first animation frame renders.\n\nSo, in short, the starting HTML above is less optimal now that we can use rel=preload, and the request starts late due to different event listeners. (Comparing this directly to loadCSS.js, it still will start the download later, as loadCSS tries to start loading immediately rather than waiting for RAF).. fixed in master. thanks!. fixed in version 2.0.0-4 also, that is. \ud83d\udc4d . So, the issue with this is, I believe, the same as reported in other issues: Firefox 56 will not fire an onload event on a rel=preload link if the requested resource is not deemed \"cacheable\" by Firefox. \nOur test page's stylesheet has cache-control headers set so that the cache expires immediately, so it is hit by this Firefox bug, which will be gone (by way of disabling preload support entirely) in Firefox 57.\n\nHere's an example of a site where preload still works in Firefox because its CSS is cacheable: https://www.filamentgroup.com/ \nThe options I know of for this are to a) configure you headers to allow caching in Firefox, or b) add an onerror=\"this.rel='stylesheet'\" attribute to the link, since Firefox will still call the onerror event. I'd recommend a if possible.\nIf your issue appears to be different from this, let me know! Thanks.\nClosing as a duplicate of https://github.com/filamentgroup/loadCSS/issues/237 . @thealkimist hey no prob. I thought it was a new bug when I read it. This stuff is complicated! . This looks good, I want to get this change in, but it makes me wonder if there are additional standard attributes we should support via the loadCSS function as well, and if so, if we should move to an object argument for those attributes. For example, integrity seems to be growing in popularity. Others here https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link\nThoughts?. Closing as duplicate of #212 - where I'll re-add my comment above. Thx!. Thanks. The version in master (soon to be 2.0) is 6.x, so I think we're comfortable with that for now at least. If there are good reasons to use later versions for this, we'd love to know! Thanks.. Late to this sorry, and coincidentally it's 3 now. :) Thanks anyway. Glad for pre-releases. I used link there to be able to reuse the function in both the event handlers and also the setTimeout, the latter of which has this referring to window. But you're right - the loop isn't going to enclose the variable scope as it is here. I'll fix it up and 2.0.0-3 up asap.\nThanks. @robertomatute if you get a chance, please let us know if 2.0.0-3 fixes this for you. Thanks for reporting!. Thanks for the report. Can you verify that the issue only exists with the minified version or is the issue present with either? Thanks again. Okay, verified that this is a bad bug. We see what it is now so we'll get a fix out asap and see what to do about hotfixing or patching. Thanks again.. Hi @rsteinwand \nWe've made a patch prerelease and published it to 2.0.1-0. It seems to test well across all the IEs, Edge, Firefox, Safari, etc. We'll likely merge it right away here but if you get a chance, let us know if 2.0.1-0 fixes your issues.  Thanks. This one's interesting. It appears to be a Chrome bug with stylesheet links that begin as preload, and since it's not in the tracker, I'll file it \nAs for how to work around this in your own code, I'd suggest you either:\na) Use media=all (or omit media entirely) for your rel=preload stylesheet(s) and instead move the @media qualifiers inside the stylesheets rather than on the media attribute. Each link is going to download a stylesheet regardless of whether the media attribute matches or not, so the difference here is minor: it's just another means of having styles apply or not when they match. You might go further and combine the styles into one sheet as well, as I'm not sure there's much to gain in breaking up the styles into many requests.\nb) Since your CSS is cleanly separated out into breakpoints already, you might just use rel=stylesheet from the start and avoid preload. Like preload, every rel=stylesheet link will download a file, but the links with media types that do not match will at least download in an async, non-blocking manner, like preload would. The drawback here is potentially having several blocking CSS requests.\nI think I'd go with A if it were my project. \nSince this is a chrome bug, and loadCSS's preload polyfill actually does nothing in Chrome because it supports the feature natively, I'll close this out. I'll link the chromium bug when it's up.. Since the readme recommends setting it to null and the script does so too as backup. I think we're good now yes. Thanks.. Nice one, thanks. Thanks for the suggestion. We don't include minified files in our source repos, but we appreciate the idea, thanks.. Thanks but we generally don't recommend using this from a remote url, but rather inline instead. So a CDN isn't a great fit for how we'd recommend using it. Thanks anyway!. good to know thanks!. Thanks. Just so I can narrow this down, is the link transformed into a stylesheet properly, and the script's interval continues to run looking for links in the DOM? \nI'm assuming what's happening here is the onload event is firing before your async script begins running its loop, and because of that, its onload handler will never stop the loop, as it would otherwise do if say, the preload script was inlined.\nSounds like we need a timeout or fallback to stop the loop at a late time in case onload already fired.. Oh I see. So it seems this is actually an onload handler issue and not just a loop that keeps running (without finding links)?\nFor what it's worth, did you happen to try the markup we recommend in the readme?\nWe include a null setter in the onload now, for the recommended markup:\n<link rel=\"preload\" href=\"path/to/mystylesheet.css\" as=\"style\" onload=\"this.onload=null;this.rel='stylesheet'\">\n<noscript><link rel=\"stylesheet\" href=\"path/to/mystylesheet.css\"></noscript>\n<script>\n/*! loadCSS rel=preload polyfill. [c]2017 Filament Group, Inc. MIT License */\n(function(){ ... }());\n</script>\nI suppose we could have the script do that too, but the nice thing here is it nulls the onload handler even in browsers that support rel=preload, which loadCSS will ignore.\n. So this is an idea to test out. \nhttps://github.com/filamentgroup/loadCSS/commit/918a3318f055002b4bee729840e420e057637c7a\nIt should effectively do what the comments above suggest, but I'm unsure if the script should manipulate (null out) the link's onload attr or not. I think it's safe because the scripts handler will run after the attribute handler has run. Thoughts welcome.. Test page for that branch is here https://262-origin-loadcss.fgview.com/test/preload.html. @sithmel would you be able to confirm for us if the issue goes away by updating your onload attribute to include this? onload=\"this.onload=null;this.rel='stylesheet'\"\nI think that's best since it'll cover supported browsers too, and not just those the polyfill runs in.\nBeyond that, we're open to removing the event listener too. Not sure if we need to though... Open to ideas.. Closed. Version 2.1.0 of loadCSS is out with this fix.. Hey folks. @rabas007 Would you mind rephrasing the question? I'm not sure I understand the issue you're running into. Thanks. Sounds like this issue was worked out in the comments. I'll close it but feel free to ask again if you need anything. Great point, @futtta. I bet you're right about that. I wonder if we should change the demo page to avoid a more major design shift.... Note: this issue appears even if loadCSS is not in the page at all. I've filed an issue here, but it's more about Lighthouse and onload=this.rel=stylesheet than anything this script is doing, since Chrome supports it natively.  \nhttps://github.com/GoogleChrome/lighthouse/issues/4702. seems helpful. ok! thanks. Thank you! Reviewing now... Hmm. Good point zach. I think that would be a little neater. But I don't know if I'd consider it a blocker to get this landed. Either way, I suppose we could pull this in and make that mod ourselves before releasing it.... Late coming back to this but I think it looks great. Thank you. . This looks good thanks. . Hmm. I can't seem to reproduce this in Firefox 59 here. Loads as expected for me with the link above.. @caub I think the before argument should do what you're looking for? \nFrom the readme: \n\nbefore: By default, loadCSS attempts to inject the stylesheet link after all CSS and JS in the page. However, if you desire a more specific location in your document, such as before a particular stylesheet link, you can use the before argument to specify a particular element to use as an insertion point. Your stylesheet will be inserted before the element you specify. For example, here's how that can be done by simply applying an id attribute to your script.\n\nhttps://github.com/filamentgroup/loadCSS#function-api . Hmm, actually after a second read it looks like you were already using that. Sorry!. PSI has updated recently to run on lighthouse. i think you'll find its recommendations have improved. Thanks. Sounds like this one is worked out now, so I'll close but feel free to comment if it's still unresolved.. thanks!. Great question. Sorry for the long delay, we're doing triage in here now. Good news is you don't need the onloadcss.js script: the preload polyfill has a 3 second fallback to apply the stylesheet https://github.com/filamentgroup/loadCSS/blob/master/src/cssrelpreload.js#L59\nthanks!. Thanks for this. Historically, we have tried not to include minified scripts in our repos, instead encouraging end users to run that step in their own projects. Thanks anyway though!. so, this looks okay to me but I'm not sure why you'd want to preload a print stylesheet. Is there a reason you don't want to reference it with an ordinary rel=stylesheet link? That will still load asynchronously in all browsers, since its media won't match.. I'm going to close this, but we appreciate the idea. Feel free to comment again if there's anything I'm missing!. Some good thoughts on this, thanks. It's a good point that sometimes, often even, we may not want to preload non-critical CSS, but load it later instead to free up early delivery for other things that are more important. Ultimately, I think it depends on the site and its assets, but it also depends on how you're determining which CSS is deemed critical. We typically inline or push the styles that are necessary to render a reasonable portion of the top of the page, but you won't need to scroll far to see elements that are outside of that rendering window. For that reason, I like to load the full stylesheet at a high priority if possible so it applies early. If there are other assets more critical to your delivery than that full stylesheet, you might choose to take another approach.\nIt's for this reason that we've kept loadCSS.js in the codebase here. You can still choose to call loadCSS( url ) if you'd rather and the stylesheet will load at a lower priority than preload typically will. You can also call loadCSS at any later time that makes sense to your page, such as after a particular event. Onload for example. \nI'd love if we had a link[async] and link[defer] but until then we at least have options like this. I hope that helps?\n. Right - in the case of onload='this.rel=\"stylesheet\"' the load is referring to the sheet itself and not the window/page.. Good question. It depends on what you're using loadCSS to do. If you want loadCSS to load a CSS file that is pretty important to the initial page rendering, then yeah inlining it or pushing it is best. The reason we recommend inlining or pushing loadCSS is because we want the loadCSS to be available to the browser as soon as it encounters the script tag that references it. Without the server pushing the file along with the HTML response, the browser will need to start a new request to the server to get the script after the HTML arrives. Further, if that script tag is not async, it'll stop browser rendering until that script loads, which multiplies the delay before the page can render and be used. That said, if you're only looking to use loadCSS for lesser priority stylesheets that can load later, you could load it asynchronously along with other scripts that your page needs and still use loadCSS whenever it loads. So, inlining or push is mostly for cases where you want to use it very early in page load, and without blocking render. \nI hope that helps. Here's a post that gets into how we use it (or rather, the other loadCSS script that polyfills rel=preload) typically: https://www.filamentgroup.com/lab/async-css.html. This looks great to me, thanks. \nOne question though: I pulled your branch, npm installed and ran npm start as noted.\nI see an error: Cannot find module 'fs-extra'\nThoughts?. Okay great. And yeah pre-commit linting sounds like a good idea. Thanks!. Seems to do the trick now! I think we'll want to clean up some links to the test pages here since they seem to use absolute references but I can get those after landing.. cheers thanks!. Thanks @odahcam I'd say that's a good idea.. just api compat. it\u2019s been a function for a while \nI figured since it runs a few times though, I\u2019d have it return a static function after running once\nfwiw, the bug was not related to rp.support but since I added a call to it, it seemed a good time to make that edit. ",
    "rolfvandekrol": "\nAllows users to set a custom screen=\"\" for the stylesheet tag (eg - \"print\")\n\nIsn't this attribute called media (<link media=\"print\" />)? Relevant reading: https://github.com/filamentgroup/loadCSS/blob/master/loadCSS.js#L19-L26\n. ",
    "keberox": "I think the point may be that this is a good way to load non-critical CSS only.\nThinking I could use it to load CSS for modules and components that get loaded on demand, if I load the JS for a component Async, may be good to load the CSS in the same way.\n. ",
    "vohof": "Holy shit, thanks.\n. Looks like a good match with https://github.com/pocketjoso/penthouse\n. ",
    "Benjamin-K": "Why not just cancelling the second request/change?\n. ",
    "inta": "Great point Benjamin. I think it would be better not to reload already loaded files, that would result in unnecessary HTTP requests.\n. Yeah, I thought about that, but came to the conclusion that this is a rare use case. In production environments I do not change my stylesheets anyway, as they should be cached. I think this is out of the scope of this script, because you need to clear the cache either if you really want to force reload of a CSS file.\n. ",
    "pwFoo": "It's an closed and old issue, but maybe there is a simple solution instead of change the loadCSS script.\nShould that jQuery example work? \n\"this\" is the css file to load.  If it exists loadCSS isn't executed.\nif ($('link[href=\"' + this + '\"]').length < 1) {\n                loadCSS(this);\n            }\n. ",
    "balupton": "Seems like it does the exact same thing, but with support for completion callbacks and duplicate prevention.\n. ",
    "Wilto": "\n. ",
    "melnikovkolya": "Could anyone please tell me why the issue is closed? Is it because the original code of loadCSS has been changed or because there is no way of supporting it in IE versions: 6-8\n. Works for me on Win 8...\n. I created this plunk [http://plnkr.co/edit/LjksZH0CWtQ8huQ0kM1B?p=preview] and it seems to work on the native Windows 8, IE11 v 11.0.19\n. My bad for not realizing the real issue. I just tried the link you provided and I do not notice any black text - the page loaded.\n. I just tried your example on plunker and it Works as expected, e.g.: text in black is loaded first, once the timeout expires ' a new style is applied: [http://plnkr.co/edit/cBOLboPLIiK7jNek1iat?p=preview]. The only thing I changed from your original code is: shifted the loadCSS call into the body.\nThe weird part is: I reran/reloaded this example a couple of times and not it doesn\u00b4t behave the same way any more. I tried Ctrl+F5, still not the same as the init behaviour (the expected one)... this is weird\n. now there is even no 5 sec blocking\n. I am doing this sort of an evaluation with IE versions (only IE 11 tested so far, and works). Once complete, I will post the results here. Please remind if I forget to do it over the next 24 hours. Please share if there are any tests that you have carried out already.\n. Hi, so, I have evaluated IE vv. 6-11 and all of them supported async loading via loadCSS. For testing, I used a combination of VMWare and VirtualBox machines provided by modern.ie.\nFor versions < 9. the testing has become more difficult using tools like jsfiddle, plunker, codepen, etc., (none of them really fully support these browser versions), so I reverted to using the example provided by  @ausi in this issue thread: https://github.com/filamentgroup/loadCSS/issues/36\n. ",
    "sogen": "I closed it since it got no answers.\nReopening\n. ",
    "larsbo": "awesome :smile: \n. ",
    "astrotim": "+1\nIt would be good be able to apply some temporary styles on selected components, such as display: none or background fill color, which are specific to a body class that is then removed by a callback function once the stylesheet has loaded.\n. I managed to do this by adding an id attribute to the loadCSS function, eg:\nss.id = \"stylescss\";\nthen using setInterval to check for the element with this id, which removes the class when the element has loaded, like so:\njavascript\nfunction hasCssLoaded() {\n  var stylecss = document.getElementById(\"stylecss\");\n   if(stylecss !== null) {\n    clearInterval(cssTest);\n    document.documentElement.className = document.documentElement.className.replace(\"precss\",\"\");\n  } else {\n  }\n}\nvar cssTest = window.setInterval(hasCssLoaded, 100);\nI haven't used this in production, or tested it very extensively, but it might point you in the right direction.\n. ",
    "achalv": "+1\nSounds like a good idea. I was recently working on a project where I would've loved to use a success callback for the exact same use-case that @astrotim mentioned above.\n. ",
    "DesignByOnyx": "I have found a simple solution to this, but I have not done extensive testing... so some feedback would be great.  \nThe only requirement is that you can't use this on the <body> tag.  No big deal if you ask me.\nYou keep your same Usage code you're already familiar with. In place of any opening tag, you do the following:\nhtml\n<script>document.write('<div class=\"page-wrapper\" style=\"visibility: hidden;\">');</script>\n<noscript><div class=\"page-wrapper\"></noscript>\nand make sure this css is in your lazy loaded CSS file:\ncss\n.page-wrapper {\n    visibility: visible !important;\n}\nThis can be used anywhere on the page, so long as you can target the node with some sort of CSS selector.  I tried to dynamically write the <body> tag with no success - so I would avoid using this on tags the browser will insert automatically: <html>, <body>, <tbody> ... etc.  You could even embed some transition styles in the dynamic tag and have a nice fade in effect:\nhtml\n<script>document.write('<div class=\"page-wrapper\" style=\"visibility: hidden; zoom: 1; filter: alpha(opacity=0); opacity: 0; -webkit-transition: opacity 0.3s; transition: opacity 0.3s;\">');</script>\n<noscript><div class=\"page-wrapper\"></noscript>\ncss\n.page-wrapper {\n    visibility: visible !important;\n    filter: alpha(opacity=100) !important;\n    opacity: 1 !important;\n}\n. ",
    "zachleat": "Fixed by https://github.com/filamentgroup/loadCSS/issues/47\n. Yeah, this is something we\u2019ve talked about specifically with fonts a couple of times. I believe @scottjehl did some WebPageTest runs showing that localStorage caused a much slower initial render time, so we usually just rely on web browser cache for this.\nAlso, keep in mind that this utility is a complement to <link> based stylesheet loading, so it will work cross domain out of the box. A change to using an XHR based approach would require additional CORS configuration and probably more overhead than we\u2019d want compared to what we have currently.\nDoes that make sense?\nI\u2019m going to close this for now, please reopen if you have additional comments or questions!\n. For posterity, the document.styleSheets addition after load is a WebKit/Blink behavior. In Gecko the document.styleSheets addition happens immediately after the stylesheet node is appended to the document.\nProbably worth testing on a Firefox phone, if anyone has one.\n. Hey all? What exactly are you trying to do here? If you want to do multiple loadCSS calls you should be able to just list them in order.\njs\nloadCSS( \"first-stylesheet.css\" );\nloadCSS( \"second-stylesheet.css\" );\nloadCSS( \"third-stylesheet.css\" );\nOf course, because it\u2019s all asynchronous there is no guarantee of the order in which they\u2019ll return and apply, but that\u2019s should be ok.\nMore importantly, I should also mention that you should probably concatenate your stylesheets so that you don\u2019t have to do multiple loadCSS calls.\n. Closing. Please reopen if needed!\n. Saved here for posterity: http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n. Fixed by #32 \n. Verified working on Chrome 40, Firefox 35, Safari 8, iOS 6, Android 2.3, Internet Explorer 8.\nThis is a great PR, thank you! \n. Just as information, this is not a loadCSS issue. This is https://github.com/filamentgroup/woff2-feature-test/issues/4\nThanks, we\u2019ll get the demo site updated!\n. Demo site updated! Thanks!\n. I like this approach\u2014I had similar thoughts! Unfortunately as mentioned in #40, this doesn\u2019t work in Android <4.4.\n. Closing this in lieu of #47. Thanks!\n. I think for this particular issue, rather than wrap all the different things you can add to the node we\u2019ll encourage people to use the node returned from loadCSS to add an error callback.\njs\nvar el = loadCSS( \"/my/url/stylesheet.css\" );\nel.onerror = function() {};\nI think in retrospect we\u2019ll probably wish we had done this for onload as well. But we appreciate your efforts here! Sorry!\n. Of note, ownerNode does not work in IE8. So maybe hold off on merging this until the other stuff surrounding onload settles.\n. @matijs The media attribute toggle has to take place after the request has been initiated and is in flight. WebKit adds the stylesheet to document.styleSheets when it\u2019s finished loading. We could use onload for this but browser support on Android WebKit (anything less than 4.4) is not there.\nSee also the discussion on https://github.com/filamentgroup/loadCSS/issues/19\n. Due to IE8 incompat and #29 fixed elegantly by another PR, we can close this.\n. Update: this comment was filed separately as #42.\nOf note: even without an onload callback, there are duplicate requests happening in Chrome (not Firefox or Safari)\nTest url: http://filamentgroup.github.io/loadCSS/test.html\n\n. TODO: make sure what\u2019s in github pages matches what\u2019s on the master branch. I didn\u2019t test to see if they were different.\n. Well, the good news is that this is solely from the onload addition. Specifically, even when a callback is not specified, it was adding an empty function() {}. So, this issue is easily fixed on our end.\nBut https://github.com/filamentgroup/loadCSS/issues/41 still stands as something that is kinda broken upstream in the browser.\n. Specifically, these are the offending commits: https://github.com/filamentgroup/loadCSS/commit/e36535a3a3e92b7a5db1723e096435770466c81c https://github.com/filamentgroup/loadCSS/commit/e36535a3a3e92b7a5db1723e096435770466c81c\nWalks away in shame.\n. So, after a little more research, onload wasn\u2019t the only variable here.\nHere is a reduced test case showing duplicate requests in Chrome 40: http://filamentgroup.github.io/loadCSS/test-chromebug.html\n. The only variable between the php sleep delayed source and the static file was whether or not the resource had a valid Last-Modified header.\nIf the file had a Last-Modified header value that was in the past (or a valid Expires header), there were no duplicate requests.\nIf the file did not have a Last-Modified or Expires header or its Last-Modified header value was in the future, Chrome 40 exhibited duplicate requests.\nSo, yes it looks like a Chrome bug, but it does not look like a very common/problematic one.\nAlso of note, Safari 8 did not exhibit these issues. \n. Duplicate requests (no caching headers): http://jsbin.com/zeqopa\nNo duplicate requests (includes caching headers): http://jsbin.com/dasiri\n. Any complaints if I close this one @scottjehl? I feel like it\u2019s just a little too esoteric to be worth going upstream with it?\n. Closing.\n. For completeness, I think this is happening also in Android 2.3. Works fine in Android 4.\n. Closing this for now per discussions with @scottjehl. Going to attempt a slightly different approach.\n. We purposely don\u2019t offer minified code primarily to encourage developers to use their own build process for production code.\nPlease reopen if you have any questions/concerns!\n. Hey @marcobiedermann, at Filament Group our standard is to use double quotes for strings. Thanks!\n. Thanks!\n. LGTM!\n. What browser is exhibiting this behavior?\n. LGTM!\n. Ooh yes I like this.\n. Looks like some of this code is outdated. What\u2019s the issue you\u2019re trying to fix here?\n. Hm, I can reproduce this successfully in Browserstack on Firefox 41 using jsbin. Here\u2019s the test case:\nhttp://output.jsbin.com/yugame\n. Thanks!\n. Do you have a test case?\n. Do you mean a Flash of Invisible Text (FOIT)?\nJust a reminder that web font loading is a separate loading cycle from the CSS. Using loadCSS to load the Google web font stylesheets will load only the stylesheet asynchronously. The web font probably downloads after the stylesheet has loaded.\nI wrote an article about why this happens here: https://www.zachleat.com/web/lazy-loading-webfonts/\nPlease reopen if you have more questions!. Yeah, as @MarcoHengstenberg linked up on https://www.zachleat.com/web/lazy-loading-webfonts/ you\u2019re asynchronously loading the CSS file, not the web fonts. The web fonts will still FOIT as normal with your loadCSS approach. Now, if the web fonts were inlined as Data URIs in the CSS, that would be a little different (see https://www.zachleat.com/web/comprehensive-webfonts/#async-data-uri)\nPlease reopen if you have additional questions!. @monolux thanks for your comment!\n\n@zachleat How did you make the optimized lato? Like this?\n\nLove that @roeln blog post, too! He actually helped me super-optimize the version of Lato that I have embedded in my first stage.\n\nIs there a tool or package one could run over a font to just get the basic bits of the font, the critical part of the font if you like, when wanting to use the preload approach with an optimized single web font alongside FontFaceObserver?\n\nHave you seen https://github.com/filamentgroup/glyphhanger ? It might help you optimize your fonts. I put some installation instructions in the readme there to help get the proper dependencies installed.\n\nIf there is not such a thing then compressing fonts is recommended, right?\n\nThe Glyphhanger readme has instructions on how to use pyftsubset to output WOFF2 compressed with zopfli.\n\nCould this perhaps prove useful for font loading? Putting the FontFaceObserver script into that would only cause harm, right, meaning FontFaceObserver has to be inline to not cause render blocking?\n\nJust keep in mind that if you asynchronously load your CSS, it\u2019s not the same as asynchronously loading the web font. Check this out: https://www.zachleat.com/web/lazy-loading-webfonts/\n\nRelated, there is no closing strong tag here. Is that wanted?\n\nHmm, yeah there are a couple of those missing\u2014I fixed them up, thanks!. I would discourage this approach. You want the text to be readable to a user as soon as possible, which means showing a fallback font while the web font is loading. There are techniques to reduce the reflow between your fallback font and web font. Check this out: https://meowni.ca/font-style-matcher/\nGood luck!. Yes\u2014Robin\u2019s article is great!\nBut saying you have to choose between FOIT and FOUT is not quite true @monolux. If you want to eliminate both FOUT and FOIT, you can do that with an Inline Data URI approach:\nhttps://www.zachleat.com/web/comprehensive-webfonts/#inline-data-uri\nNot an ideal approach, but the option is there. I\u2019d recommend reading that entire guide, if you get a chance. There are a couple of good approaches there to mitigate FOUT issues.. Hey @jovinbm, this looks great. I think there\u2019s one edge case you\u2019re not handling, with <link crossorigin=\"\"> or <link crossorigin>.\nThe valid values of anonymous or use-credentials will work fine as is here. Note that \u201can invalid keyword and an empty string will be handled as the anonymous keyword.\u201d (via https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes)\nSo maybe something like\nif( crossorigin || crossorigin === \"\" ){. Hey, nice PR\u2014thanks!\nI\u2019m curious if it would be worthwhile to modify the 3rd argument to be a generic media string or attributes object, since they both perform a similar function.. @scottjehl sounds good to me!. Yeah it looks like something went wrong here\u2014investigating.. Okay, sorry about that\u2014it should be undeprecated now. Thanks!. works for me on 59.0.1 Mac OS (Low) Sierra. Hmm, interesting that the release notes would include that! Does the provided demo work for you? https://master-origin-loadcss.fgview.com/test/preload.html\nIt seems to operate fine for me on an iPhone X and iPhone 8 Plus running iOS 11.\nAre you saying this is only limited to stylesheets that are using font-display: swap?. See my comment here: https://github.com/filamentgroup/loadCSS/pull/212#issuecomment-307139416. using tabs here. Is there a benefit to having this be a function instead of just a boolean?. (per your comment in Slack, for API compatibility). ",
    "jefflembeck": "Hi, FOIT refers to flash of invisible text, the phenomenon you get when the text is invisible while waiting for the font to load. This leaves the page unusable, as you can't read/access the text.\nhttps://github.com/filamentgroup/loadCSS/blame/master/README.md#L38\n. Thanks @adammcarth !\n. Given the nature of loadCSS, I think we'll close this one. I love error handling, but I think this addresses it the wrong way - we're adding an optional onload to loadcss, I think an optional onerror callback could work as well, and keep our code simple.\n. Same as before.\n. This was already fixed.\nThanks!\n. Hi @activenode we just haven't had a chance to create a test case where this breaks and to confirm that this fix would fix the broken test case across several browsers.\nHopefully we'll get to it soon, but if you can help, that would be really great.\n. ",
    "alecsgone": "Oh got it thanks for the answer \n. ",
    "marcel555": "adammcarth, thank you for pointing this out for me.\n(minifying+combining already done)\n. ",
    "MattWilcox": "There's an approach that does this: http://bdadam.com/blog/loading-webfonts-with-high-performance.html\nBut it'd be sweet to merge these two scripts together.\n. ",
    "decrek": "I suggested earlier in the mail I send you yesterday the xhr method. I understand that we come across  browser support complexities. So I understand the polling approach as well. I started thinking and came across http://stackoverflow.com/q/2635814.\nSo how about polling ss.sheet? Once it is not null anymore the stylesheet is loaded and it should be safe to toggle the media back. Tested it and worked on Chrome. With 2 css calls, one for main.css and one for the font.css. Something like below:\n`` js\nfunction loadCSS( href, before, media ){\n    \"use strict\";\n    // Arguments explained:\n    //hrefis the URL for your CSS file.\n    //beforeoptionally defines the element we'll use as a reference for injecting our <link>\n    // By default,beforeuses the first <script> element in the page.\n    // However, since the order in which stylesheets are referenced matters, you might need a more specific location in your document.\n    // If so, pass a different reference element to thebeforeargument and it'll insert before that instead\n    // note:insertBeforeis used instead ofappendChild, for safety re: http://www.paulirish.com/2011/surefire-dom-element-insertion/\n    var ss = window.document.createElement( \"link\" );\n    var ref = before || window.document.getElementsByTagName( \"script\" )[ 0 ];\n    var ssLength = window.document.styleSheets.length;\n    ss.rel = \"stylesheet\";\n    ss.href = href;\n    // temporarily, set media to something non-matching to ensure it'll fetch without blocking render\n    ss.media = \"only x\";\n    // inject link\n    ref.parentNode.insertBefore( ss, ref );\n    // This function sets the link's media back toall` so that the stylesheet applies once it loads\n    // It is designed to loop until document.styleSheets includes\n    function toggleMedia(){\n        if(ss.sheet ){\n            ss.media = media || \"all\";\n        }\n        else {\n            setTimeout( toggleMedia );\n        }\n    }\ntoggleMedia();\nreturn ss;\n\n}\n```\nIn the link I pasted I see some if else, probably because ss.sheet is not supported everywhere. What do you think?\n. I tested this again with my insanely throttled connection and works(tested in Chrome) Btw I use Charles for that. Seriously I never been so deep into that cssom thing, so really don't know how that sheet property is supported. So I am curious about your testing results. AFAIK the href property is supported everywhere. I also see that in my proposal I poll until the stylesheet is loaded like you said in your reply and in your latest proposal you poll until it is present in the DOM (and started downloading?). That would be better.\nJust for my understanding, the CSS request will not be blocking when it's started and has a non matching media property, right? That would mean that the moment the request is started you can toggle the media property back?\n. @scottjehl Ah ok, that means the same amount of polling as in my proposal but better support than the sheet property.\n. ",
    "flouthoc": "Can You Please elaborate about what is \"PR addresses\"?I am new so I dont Know about it\n. Not a Bug Its a new feature which i'm trying to add . As loadCSS is Generating The HTML Code for supplied argument like loadCSS(\"style.css\");  respectively in Main HTML so I thought Why Not Add only the HTML Code if the argument is valid (\"Do not populate main HTML without any meaning\") If loadCSS(\"style_2.css\"); is made and FILE \"style_2.css\" is not present at specified URL loadCSS will not Generate Its Equivalent Code (with this patch) in Main HTML Keeping it HTML Clean and cool . In Short it make a asynchronous check for the specified \"URL\" given if it is valid or not  If it is valid it will add its equivalent code in HTML otherwise Not . Sorry if it sounds Too Newbie or PurposeLess\n. @scottjehl Is There Any Fault in the patch above ?\n. Ok Thanks.\n. @dylang So  we will invoke ifFound() in main.html rather than calling in our loadCSS ? I mean user is Free To choose wheather File Exists or Not ?\n. ",
    "gf3": ":+1:\n. ",
    "dylang": "I hope this isn't added.\nThis will cause issues when the css assets are on a different domain than the web page, like when using a CDN and CORS is not available.\nThe cost of this extra connection is also going to slow down adding CSS.\n@argunner If this is something you need you can put your code in a separate function that you can call before calling loadCSS. This separation can help make sure each module is just doing one thing well and make it easier to follow your code.\nFor example\njs\nfunction ifFound(url, cb) {\n     // your ajax code\n       // File was found\n       cb(url)\n}\njs\nifFound(cssUrl, loadCSS);\n. That looks better but I still don't think this belongs in loadCSS.js. It would be better as a separate project that calls loadCSS. This way people who use loadCSS and don't need this functionality don't have that extra code to worry about. \nhttp://blog.izs.me/post/48281998870/unix-philosophy-and-node-js\n. ",
    "abensur": "Aww, didn't see that! Thanks for the reply!\nBut I still think this should be the standard case scenario.\nIsn't this more secure?\nSo many browsers extensions nowadays and all of them trying to get inside our html!\n. ",
    "artoric": "+1\n. ",
    "machal": "Yes, that would solve the problem. Thanks Scott.\n. ",
    "Ianfeather": "\nputting the CSS file link at the bottom of the page to avoid blocking\n\nThis is likely to be a little unpredictable. The browser is going to do a look-ahead and block render as soon as it spots a css link. I've seen quite large performance hits when trying it out myself where the user sees a frozen, semi-rendered page until the last request finishes.\nBehaviour of the \"browser\" I mentioned there is likely to be widely variable so you might see good results somewhere. I think this solutions depends on the resource priorities spec landing before you could rely on it consistently. \n. ",
    "kevinSuttle": "Very good point. Thanks @Ianfeather. \n. Thanks @scottjehl, @jakearchibald.\n. ",
    "jakearchibald": "You could put the CSS in the head but with media=\"only x\". That'll stop the blocking, but you'll still need JS to switch it to all.\n. Hm, I wonder what else was at play. I saw it on webpagetest but also a VM,\nso I don't think it was a quirk in one system. Will try and reduce.\nOn Mon, 16 Feb 2015 20:15 Scott Jehl notifications@github.com wrote:\n\nHey again, @jakearchibald https://github.com/jakearchibald\nOkay, quick update. I'm having no luck reproducing this issue, which of\ncourse is encouraging but I'm wondering if I might just be doing it wrong.\n:)\nHere's what I did to test it:\nStep 1. I created a CSS file that takes 5 seconds to respond and dropped\nit on my server. It's here http://scottjehl.com/css-temp/slow.php and its\nsource reads:\n<?phpsleep(5);header(\"Content-Type: text/css\");echo \"body { background: green; color: #fff; }\";?>\nStep 2. I created a control.html page\nhttp://filamentgroup.github.io/loadCSS/control.html to verify that an\nordinary link to that CSS file will block render as expected. The\nstylesheet will style the background green and text white when it loads.\nVerified that it works as expected in IE11:\n[image: control]\nhttps://cloud.githubusercontent.com/assets/214783/6218617/88b8ab8c-b5e5-11e4-8895-25854925603d.gif\nStep 3. I created a test.html page\nhttp://filamentgroup.github.io/loadCSS/test.html and loaded the same\nstylesheet using loadCSS instead. My expectation is to see unstyled text\nimmediately, and white-on-green whenever the stylesheet loads. Verified\nthat it works as expected in IE11:\n[image: test]\nhttps://cloud.githubusercontent.com/assets/214783/6218641/d6dd9c5a-b5e5-11e4-8dd5-ce1d88a66d84.gif\nAny tips on how to reproduce the issue would be great.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/filamentgroup/loadCSS/issues/36#issuecomment-74566021\n.\n. Yeah, sorry I haven't done this yet, will hopefully get to it tomorrow\n\nOn Mon, 23 Feb 2015 21:05 Scott Jehl notifications@github.com wrote:\n\nWe haven\u2019t been able to reproduce a bug showing that the version in master\nhas problems running in IE 11.\nMy last message shows that it does appear to function as expected there,\nso I was leaving this open to see if @jakearchibald found a way to\nreproduce the issue.\nOn Feb 23, 2015, at 2:43 PM, Matijs Brinkhuis notifications@github.com\nwrote:\n\nI created a PR (#37) that I tested on IE11. Worked as expected in IE11\nin a (modern.ie) VM. Instead of polling, it relies on the load event of\nthe stylesheet. Curious if that makes a difference.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/filamentgroup/loadCSS/issues/36#issuecomment-75631438\n.\n. That's pretty cool. Although I'd still like the blocking solution so I can do something like:\n\nhtml\n<style>/* inlined css */</style>\ncontent content content\n<link rel=\"stylesheet\" href=\"css-for-next-bit-of-content\">\ncontent content content\n<link rel=\"stylesheet\" href=\"more-css-for-next-bit-of-content\">\ncontent content content\nfooter\nAnd have the browser take care of render-blocking for me.\n. > Based on the sites I've built with inline+async CSS loading so far, I think I'm of the opinion that it's preferable to allow the lower region of a page (below the \"fold\") to render immediately while the full CSS is loading asynchronously, even if the inline CSS doesn't contain all of the styles that region needs to render to its intended state.\nCan you provide some examples? My feeling was, although the inlined CSS may be able to render parts of below-the-fold, it'll often lead to the page jumping around as the additional CSS loads. You can avoid this by guarding against it with extra CSS, and you should be able to do that with a truly async stylesheet, but I figured it'd be too complex for the default.\n\nI worry the blocking behavior will make for yet another potential single point of failure for a portion of the page content.\n\nI don't think it's \"another\" point of failure, as it already is. The current state for <link> in body is to block until the CSS loads or fails to load. However, at the moment we block as soon as the <link> is discovered, which can result in blocking content before it.\n\nHow do you envision this working in a template setting?\n\nIt's down to the page to decide what's first-render critical, rather than a page module. A single page module may be critical on one page, but secondary on another. Does a fully async stylesheet change the pattern here?\n\nWe typically pair the inline CSS + async full.css approach in such a way that we only need to embed inline CSS for the first page someone visits on a site. After that, the full CSS can be assumed to be cached in the browser\n\nI don't think that's a great assumption unless you're in full control of the cache (eg ServiceWorker). Stuff falls out of the cache all the time, way more frequently than cookies for instance.\nCan you talk me a bit more through what you load inline and what you load async, and what the rendering looks like in between? I don't think I've got the right mental model of the problem.\nI saw it like this:\nhtml\n<style>/* inlined css */</style>\nCONTENT SET 1\n<link rel=\"stylesheet\" href=\"css-for-next-bit-of-content\">\nCONTENT SET 2\n<link rel=\"stylesheet\" href=\"more-css-for-next-bit-of-content\">\nCONTENT SET 3\nfooter\nFor the uncached load, you'd inline the CSS for CONTENT SET 1, getting a quick first render. This would be the site header, and at least content title & first few paragraphs. This CSS should aim to be < 20k, meaning it doesn't matter so much if it's delivered with every page. You'd be blocked on the additional stylesheets as they download. With a fully cached load, the block would be less.\nTransitioning to HTTP/2, you'd switch the inline css for a normal <link>, then push that along with the page response. You may push other sheets and prioritise accordingly.\nFor a social media stream, it may be more like this:\nhtml\n<style>/* inlined css */</style>\n<link rel=\"stylesheet\" href=\"feed-extras\" async>\n<div class=\"main-feed\">\n  <article>\n    CONTENT\n    <div class=\"buttons-etc\"></div>\n  </article>\n</div>\n<link rel=\"stylesheet\" href=\"secondary\">\n<div class=\"secondary\"></div>\n<link rel=\"stylesheet\" href=\"tertiary\">\n<div class=\"tertiary\"></div>\nOn desktop, secondary & tertiary may be left & right columns. So the inline CSS would get you the content of the feed. feed-extras would bring in buttons-etc, but the inlined CSS would have reserved space for them, so there's no jumping around when this loads (it may even use transitions to fade in).\nI guess the pattern here is that particular modules have the capability to fast-load, meaning they inline the essentials, but it's down to the parent module (or page) to decide if they should use that mode for that layout.\n. > It seems like the layout on the right is usable enough to show immediately\nHmm, maybe I'm wrong, but I feel that the rendering on the right is broken and should be avoided. If the user sees it jump from that to the correct rendering, that further confirms to them that the initial render was broken.\n. > I just think it's preferable to show content that isn't fully rendered instead of showing nothing at all\nI'm not so sure, but I don't have any evidence. I take your point about fonts, but I still think a late font switch is a poor experience. I really like the font rendering proposal, as I can have an early fallback, but disable a switch after that.\n\nasync fetch is merely for caching CSS for the next view\n\nThat's what I did for SVGOMG, I think it works well for low-content \"apps\" that have most of their complexity an interaction away. With https://wiki-offline.herokuapp.com/wiki/Hulk_Hogan I load the CSS for the article async, but hide the article element until it loads. Can't decide if this is the right approach though (in this case the CSS tends to load before the article content).\n. Btw, I haven't done a test to see how inlining compares to HTTP/2 push. A lot of assumption on my part.\n. Sorry for the delay. This looks good to me, although the \"0\" polling interval for checking for body might be CPU intensive.\n. ",
    "arnog": "Hi there. I have a fix for an issue where the loading would sometimes fail depending on where the link was inserted (i.e. if it was inserted as the last link in the document). Please review.\n. ",
    "aFarkas": "neat  +1\n. @scottjehl \nThe following pattern:\nhtml\n<link rel=\"preload\" href=\"asnyc.css\" as=\"stylesheet\" onload=\"this.rel='stylesheet'\">\nDoes not work in Chrome canary (49.0.2623.0 canary (64-bit)), although it supports preloadaccording to the relList.supports method, because the link never fires an onload event. I think (not sure) this is a bug.\n@jakearchibald \nI actually very like the idea of blocking below the link/script element content and have all content above visible. Something that would be even more convenient, if we would have an attribute, that allows us to include a link/script only once:\n``` html\n\n\n .... \n\n\n\n\n .... \n\n\n\n .... \n\n\n\n\n .... \n\n``\n. @yoavweiss \nTHX!\n. The issue here is actually a little bit bigger. Normal blocking stylesheets do block under normal circumstances the \"creation\" ofdocument.body` (this is true for Chrome, but false for IE). Which basically means, if you had the following structure to load styles async, but as fast as possible:\nhtml\n<html>\n    <head>\n        <script> \n            //inlined loadCSS\n            loadCSS('styles-async.css');\n        </script>\n        <link href=\"normal-styles.css\" rel=\"stylesheet\" />\n        <script src=\"behavior.js\" async=\"\"></script>\n    </head>\n    <body>\n    </body>\n</html>\nThe stylesheet now gets only added to the DOM after the normal-styles.css is downloaded and parsed...\nMaybe you can do a check like this?:\njs\n!document.msElementsFromPoint || document.body\n. @vijayaraghavanramanan \nThis doesn't solve the underlying problem. Waiting for document.body in all browsers means, that there can be a long time between calling loadCSS and starting the actual download.\nYour workaround only works for you because you don't use loadCSS in cached situations anymore. If you would check a network waterfall in empty cache situations you will see download of the async CSS is not only async it is heavily delayed (delayed until normal CSS is fully downloaded).\n. ",
    "jacobbuck": ":+1: \n. Cool great feedback guys :neutral_face: \n. @scottjehl Yeah I came to a similar conclusion myself, as for the reason of closing this pull-requst. \nThanks for the feedback (albeit late) anyway.\nI've seen other projects which add module wrappers in a build process, would be worth doing. Then you could provide multiple distributions or allow custom builds with/without module loading, and extra features like onloadCSS.js.\n. ",
    "matijs": "I created a PR (https://github.com/filamentgroup/loadCSS/pull/37) that I tested on IE11. Worked as expected in IE11 in a (modern.ie) VM. Instead of polling, it relies on the load event of the stylesheet. Curious if that makes a difference.\n. What is the rationale for polling using setTimeout in toggleMedia like this?\n. ",
    "ausi": "I had the same issue and was able to reproduce it in a small test case: http://madeyourday.net/load-css-test/load-css.html\nIt\u2019s basically the same setup as @scottjehl\u2019s test, but I added a <link> to a fast stylesheet after the loadCSS-script:\nhtml\n<head>\n    <script>\n        function loadCSS(){...}\n        loadCSS('slow-style.php');\n    </script>\n    <link rel=\"stylesheet\" href=\"fast-style.php\">\n</head>\n<body>\n    <p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam.</p>\n</body>\nI tested it with version 0.1.6 and the one from the master branch, both have the same issue.\n. I reduced it a little bit more by replacing the fast <link> with an empty script tag: http://madeyourday.net/load-css-test/load-css-2.html\nhtml\n<head>\n    <script>\n        function loadCSS(){...}\n        loadCSS('slow-style.php');\n    </script>\n    <script></script>\n</head>\n<body>\n    <p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam.</p>\n</body>\nThis blocks the rendering of the whole page in IE11 until slow-style.php is loaded. If I remove the second <script> tag it doesn\u2019t block.\n. It still doesn\u2019t work in my IE downloaded from modern.ie (Version 11.0.9600.17031 on Windows 8.1).\n@melnikovkolya Did you see black text on a white background for about five seconds before it switched to white text on a green background?\n. @melnikovkolya Your code is completely different, please take a look at the example i posted in https://github.com/filamentgroup/loadCSS/issues/36#issuecomment-89058404 or just click the link madeyourday.net/load-css-test/load-css-2.html and check if you can see black text before the background is green.\n. > I do not notice any black text\nExactly that is the problem this issue is all about. Take a look at the animated GIFs in https://github.com/filamentgroup/loadCSS/issues/36#issuecomment-74566021\n. > The only thing I changed from your original code is: shifted the loadCSS call into the body.\nThis is the workaround @jakearchibald pointed out in https://github.com/filamentgroup/loadCSS/issues/36#issue-57735160, but this issue isn\u2019t about a workaround but to find out why IE11 does block rendering in certain cases.\n\nThe weird part is: I reran/reloaded this example a couple of times and not it doesn\u00b4t behave the same way any more. I tried Ctrl+F5, still not the same as the init behaviour (the expected one)... this is weird\n\nIt isn\u2019t easy to debug, try the following:\n1. open a new empty tab\n2. clear the browser cache\n3. open the URL\n. @scottjehl I updated my test case to the latest version of loadCSS: madeyourday.net/load-css-test/load-css-3.html and it is still blocking rendering in IE11.\n\n. @scottjehl Yes, if you remove the empty <script> tag it doesn\u2019t block.\n. As you can see in my first example (https://github.com/filamentgroup/loadCSS/issues/36#issuecomment-88412666) it also blocks if you use a fast stylesheet via <link> after the loadCSS script. So it seems that if there is a <script> or <link> in the <head> after the loadCSS script, the rendering is blocked in IE11.\n. @scottjehl I still get the same results with the newest version from the master branch:\n- load-css-4.html: loadCSS with empty <script> tag following it blocks rendering in IE11\n- load-css-5.html: loadCSS without <script> tag following it doesn\u2019t block  rendering in IE11\n. ",
    "DmitriyTrt": "Just to clarify, processing and rendering of the document freezes on any <script> or <link rel=\"stylesheet\"> found in the document after the script calling loadCSS() on IE 11. It has to be a separate <script> tag to trigger it, code on the same <script> tag executes before the freeze. So moving code to the body is only a partial solution, unless it's really in the end of all body scripts.\nTested on IE v11.0.8 Windows Server 2012 R2, sorry don't have anything more fresh at the moment.\n. ",
    "marcobiedermann": "Same issue on my end. I've tried your test.htmlas well as my own setup\ntest.html\n\nmy setup:\n``` html\n<!DOCTYPE html>\n\n\n\nWebsite\ncritical css\u2026\n\n\n<pre><code>function loadCSS( href, before, media, callback ){\u2026};\nloadCSS('css/style.css');\n</code></pre>\n\n\n\n\n\n```\n\nDevTools points to: index.html:142\njavascript\nref.parentNode.insertBefore( ss, ref );\nand index.html:161\njavascript\nss.onloadcssdefined(function() {\n  ss.media = media || \"all\";\n});\nI've also tested it in Firefox and Safari. Firefox works fine, Safari same results like in Chrome\n. Alright! I changed it because of my warnings in JSHint\n. ",
    "activenode": "Is there a problem with this commit/fix or why is it that it takes so long?\n. url: http://localhost:3000/templates/TEST.html\n<script>loadCSS('../assets/css/TEST.css');</script>\nThis will NOT work with your current release. Simple as that. The callback wont fire.\nThe problem is because HREF will contain the absolute url.\n. Are you still not able to reproduce?  Sorry bugging you but I feel like this takes way to long for such a small thing. In case my fix causes any other issues I would be glad to know.\n. ",
    "nhoizey": "This is not enough, it still doesn't work if the href starts with ./ (current folder) instead of ../\n. Ok, I just saw there's already a pull request for that: https://github.com/filamentgroup/loadCSS/pull/52\n. I think so indeed!\n. ",
    "rarkins": "Here is an example:\nhtml\n<head><meta charset=\"utf-8\"><title>Aalto - Singapore condo review</title><meta property=\"og:title\" content=\"Aalto - Singapore condo review\"><meta name=\"twitter:title\" content=\"Aalto - Singapore condo review\"><meta name=\"description\" content=\"Aalto is a mid-sized condo in Singapore's Marine Parade area. It was built in 2010 and is well known for ...\"><meta property=\"og:description\" content=\"Aalto is a mid-sized condo in Singapore's Marine Parade area. It was built in 2010 and is well known for ...\"><meta name=\"twitter:description\" content=\"Aalto is a mid-sized condo in Singapore's Marine Parade area. It was built in 2010 and is well known for ...\"><meta name=\"keywords\" content=\"Aalto, condo rent history, Singapore condo, condominium, Rent in Singapore\"><meta name=\"title\" data-type=\"string\" content=\"Aalto\" class=\"swiftype\"><meta name=\"image\" data-type=\"enum\" content=\"https://images.keylocation.sg/condo/120x120/aalto.jpg\" class=\"swiftype\"><link rel=\"shortcut icon\" href=\"/public/assets/images/favicon/favicon-1bf5130.ico\"><link rel=\"apple-touch-icon-precomposed\" href=\"/public/assets/images/favicon/apple-touch-icon-precomposed-c3706db.png\"><link rel=\"apple-touch-icon\" href=\"/public/assets/images/favicon/apple-touch-icon-4b946bd.png\"><link rel=\"apple-touch-icon\" sizes=\"57x57\" href=\"/public/assets/images/favicon/apple-touch-icon-57x57-0b9b6a6.png\"><link rel=\"apple-touch-icon\" sizes=\"114x114\" href=\"/public/assets/images/favicon/apple-touch-icon-114x114-9545b7b.png\"><link rel=\"apple-touch-icon\" sizes=\"60x60\" href=\"/public/assets/images/favicon/apple-touch-icon-60x60-972778b.png\"><link rel=\"apple-touch-icon\" sizes=\"120x120\" href=\"/public/assets/images/favicon/apple-touch-icon-120x120-c3766ac.png\"><link rel=\"apple-touch-icon\" sizes=\"72x72\" href=\"/public/assets/images/favicon/apple-touch-icon-72x72-344c7b4.png\"><link rel=\"apple-touch-icon\" sizes=\"144x144\" href=\"/public/assets/images/favicon/apple-touch-icon-144x144-212091e.png\"><link rel=\"apple-touch-icon\" sizes=\"76x76\" href=\"/public/assets/images/favicon/apple-touch-icon-76x76-89b25f7.png\"><link rel=\"apple-touch-icon\" sizes=\"152x152\" href=\"/public/assets/images/favicon/apple-touch-icon-152x152-4b946bd.png\"><link rel=\"icon\" type=\"image/png\" sizes=\"192x192\" href=\"/public/assets/images/favicon/favicon-192x192-cecb769.png\"><link rel=\"icon\" type=\"image/png\" sizes=\"160x160\" href=\"/public/assets/images/favicon/favicon-160x160-8749b27.png\"><link rel=\"icon\" type=\"image/png\" sizes=\"96x96\" href=\"/public/assets/images/favicon/favicon-96x96-326c776.png\"><link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/public/assets/images/favicon/favicon-16x16-a22ebb2.png\"><link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/public/assets/images/favicon/favicon-32x32-bd9509f.png\"><meta name=\"msapplication-TileColor\" content=\"#00a300\"><meta name=\"msapplication-TileImage\" content=\"/public/assets/images/favicon/mstile-144x144-66aff9d.png\"><meta name=\"msapplication-config\" content=\"/public/assets/images/favicon/browserconfig-254bf08.xml\"><link rel=\"canonical\" href=\"https://keylocation.sg/condos/aalto\"><meta property=\"og:image\" content=\"/public/assets/images/favicon/apple-touch-icon-4b946bd.png\"><meta name=\"twitter:image:src\" content=\"/public/assets/images/favicon/apple-touch-icon-4b946bd.png\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"><meta property=\"og:type\" content=\"website\"><meta property=\"og:url\" content=\"https://keylocation.sg/condos/aalto\"><meta property=\"og:site_name\" content=\"Key Location\"><meta property=\"og:locale\" content=\"en_US\"><meta name=\"twitter:card\" content=\"summary\"><meta name=\"twitter:site\" content=\"@keylocation\"><meta name=\"twitter:domain\" content=\"keylocation.sg\"><meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"><script>window._trackJs = {enabled: true, token: 'fdbfb05c50514b0bbd34ee206c9c911e', userId: ''};var heapToken = 579102418;var FHChat = {product_id: '892e264bd1c7'};var hotjarToken = 10361;</script><!-- - loadCSS--><script>function loadCSS(a,b,c){\"use strict\";function g(){for(var b,e=0;e<f.length;e++)f[e].href&&f[e].href.indexOf(a)>-1&&(b=!0);b?d.media=c||\"all\":setTimeout(g)}var d=window.document.createElement(\"link\"),e=b||window.document.getElementsByTagName(\"script\")[0],f=window.document.styleSheets;return d.rel=\"stylesheet\",d.href=a,d.media=\"only x\",e.parentNode.insertBefore(d,e),g(),d}\nloadCSS(\"/public/fontface-1f24f01.css\");\n</script><script async src=\"/public/condo-1bd7f9f.js\"></script><script>loadCSS(\"/public/bootstrap-ebf66f6.css\");\nloadCSS(\"/public/global-e4c2321.css\");\nloadCSS(\"/public/condo-01c4f25.css\");\n</script><style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}header,main,nav{display:block}a{background-color:transparent}strong{font-weight:700}h1{margin:.67em 0}img{border:0}svg:not(:root){overflow:hidden}hr{box-sizing:content-box;height:0}button,input{color:inherit;font:inherit;margin:0}button{overflow:visible;text-transform:none;-webkit-appearance:button;cursor:pointer}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}*{box-sizing:border-box}*:before,*:after{box-sizing:border-box}html{-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:'Open Sans',sans-serif;font-size:16px;line-height:1.42857143;color:#777;background-color:#fff}input,button{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}img{vertical-align:middle}hr{margin-top:22px;margin-bottom:22px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;clip:rect(0,0,0,0);border:0}h1,h2,h3{font-family:inherit;font-weight:500;line-height:1.1;color:inherit;margin-top:22px;margin-bottom:11px}h1{font-size:41px}h2{font-size:34px}h3{font-size:28px}p{margin:0 0 11px}ul{margin-top:0;margin-bottom:11px}.container{margin-right:auto;margin-left:auto;padding-left:15px;padding-right:15px}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{margin-right:auto;margin-left:auto;padding-left:15px;padding-right:15px}.row{margin-left:-15px;margin-right:-15px}.col-sm-4,.col-sm-6,.col-lg-10,.col-xs-12,.col-sm-12{position:relative;min-height:1px;padding-left:15px;padding-right:15px}.col-xs-12{float:left;width:100%}@media (min-width:768px){.col-sm-4,.col-sm-6{float:left}.col-sm-12{float:left;width:100%}.col-sm-6{width:50%}.col-sm-4{width:33.33333333%}}@media (min-width:1200px){.col-lg-10{float:left;width:83.33333333%}.col-lg-offset-1{margin-left:8.33333333%}}label{max-width:100%;margin-bottom:5px;font-weight:700}label,.btn{display:inline-block}.btn{margin-bottom:0;font-weight:400;text-align:center;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;padding:6px 12px;font-size:16px;line-height:1.42857143;border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-lg{padding:10px 16px;font-size:20px;line-height:1.3333333;border-radius:6px}.btn-xs{padding:1px 5px;font-size:14px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.fade{opacity:0;transition:opacity .15s linear}.collapse{display:none;visibility:hidden}.btn-group{position:relative;display:inline-block;vertical-align:middle}.btn-group>.btn{float:left;position:relative}.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn-group{float:none;display:table-cell;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.nav{margin-bottom:0;padding-left:0;list-style:none}.nav>li,.nav>li>a{position:relative;display:block}.nav>li>a{padding:10px 15px}.navbar{position:relative;min-height:50px;margin-bottom:22px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{overflow-x:visible;padding-right:15px;padding-left:15px;border-top:1px solid transparent;box-shadow:inset 0 1px 0 rgba(255,255,255,.1);-webkit-overflow-scrolling:touch}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;box-shadow:none}.navbar-collapse.collapse{display:block!important;visibility:visible!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-fixed-top .navbar-collapse{padding-left:0;padding-right:0}}.navbar-fixed-top .navbar-collapse{max-height:340px}@media (max-device-width:480px) and (orientation:landscape){.navbar-fixed-top .navbar-collapse{max-height:200px}}.container-fluid>.navbar-collapse{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-collapse{margin-right:0;margin-left:0}}.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030}@media (min-width:768px){.navbar-fixed-top{border-radius:0}}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-brand{float:left;padding:14px 15px;font-size:20px;line-height:22px;height:50px}.navbar-brand>img{display:block}@media (min-width:768px){.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-toggle{position:relative;float:right;margin-right:15px;padding:9px 10px;margin-top:8px;margin-bottom:8px;background-color:transparent;background-image:none;border:1px solid transparent;border-radius:4px}@media (min-width:768px){.navbar-toggle{display:none}}.navbar-nav{margin:7px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:22px}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:14px;padding-bottom:14px}}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand,.navbar-default .navbar-nav>li>a{color:#777}.navbar-default .navbar-toggle{border-color:#ddd}.navbar-default .navbar-collapse{border-color:#e7e7e7}.modal{overflow:hidden;display:none;position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transform:translate(0,-25%);-ms-transform:translate(0,-25%);transform:translate(0,-25%);transition:-webkit-transform .3s ease-out;transition:transform .3s ease-out}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;box-shadow:0 3px 9px rgba(0,0,0,.5);background-clip:padding-box;outline:0}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5;min-height:16.42857143px}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}@media (min-width:768px){.modal-dialog{width:600px;margin:30px auto}.modal-content{box-shadow:0 5px 15px rgba(0,0,0,.5)}}.container:before,.container:after,.container-fluid:before,.container-fluid:after,.row:before,.row:after,.nav:before,.nav:after,.navbar:before,.navbar:after,.navbar-header:before,.navbar-header:after,.navbar-collapse:before,.navbar-collapse:after,.modal-footer:before,.modal-footer:after{content:\" \";display:table}.container:after,.container-fluid:after,.row:after,.nav:after,.navbar:after,.navbar-header:after,.navbar-collapse:after,.modal-footer:after{clear:both}.hidden{visibility:hidden!important}.hidden,.visible-xs{display:none!important}@media (max-width:767px){.visible-xs{display:block!important}}header .header__default{background:#fff;border:none;min-height:45px;z-index:1030;box-shadow:0 1px 10px rgba(0,0,0,.1);transition:.4s margin-top}header .header__toggle{border:0;width:35px;height:35px;margin:5px 0}header .header__toggle .hamburger{position:absolute;top:0;left:0}header .header__brand{padding:0;position:absolute;margin-top:5px}header .header__logo{height:35px;width:188px}header .header__nav{float:right;margin-right:70px}header .header__nav li a{font-size:17px;height:45px;line-height:45px;text-transform:uppercase;text-align:center;padding-top:0;padding-bottom:0}header .header__nav .user{margin:10px 5px 0 0}.morph{width:36px;height:36px;position:absolute;overflow:hidden;right:30px;top:5px;z-index:2;background:#fff;border:2px solid #7dc24f;box-sizing:border-box;-webkit-transform-origin:100% 0;-ms-transform-origin:100% 0;transform-origin:100% 0;transition:.5s width,.5s height,.5s right,.5s top,.1s border ease-in-out}.header-search{margin:0 auto;width:80%;height:40px;position:relative;transition:.5s}.morph__results{width:80%;text-align:center;margin:25px auto 45px;opacity:0}.header-search__close{position:absolute;top:20px;right:40px;width:36px;height:36px;cursor:pointer;-webkit-transform:scale3d(0,0,1);transform:scale3d(0,0,1)}.header-search__close:before,.header-search__close:after{content:'';position:absolute;width:2px;top:0;left:50%;height:100%;background:#80b83d;opacity:.4;transition:.3s ease-in-out}.header-search__close:before{-webkit-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg)}.header-search__close:after{-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg)}.morph--overlay{position:fixed;top:0;left:0;width:100%;height:0;background:rgba(0,0,0,.5);opacity:0;transition:opacity .5s}.header-search__icon{cursor:pointer;position:absolute;top:1px;right:2px;z-index:100;padding:0;width:25px;height:25px;margin-top:3px;margin-right:-1px;transition:width .5s,height .5s,top .5s,margin .5s,fill .5s,opacity .3s}.header-search__input{width:100%;height:100%;font-size:5.5em;color:#80b83d;background:0 0;border:0;outline:0;opacity:0;padding:0 20% 0 0;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform:rotateX(-90deg);transform:rotateX(-90deg)}.header-search__input::-webkit-input-placeholder{color:gray}.header-search__input::-moz-placeholder{color:gray}.header-search__input:-ms-input-placeholder{color:gray}@media (min-width:768px){header .header__brand{margin-left:15px!important}}@media (max-width:767px){header .header__collapse{position:absolute;background:#fff;width:190px;padding:0;right:0;box-shadow:0 6px 12px rgba(0,0,0,.175)}header .header__nav{float:none;margin:0}header .nav-container{padding:0 5px}.morph{right:55px;border:2px solid #fff}.header-search__input{font-size:2.5em!important}.header-search__close{top:5px;right:15px;width:25px;height:25px}}@media (max-width:480px){.morph__results{margin:0 auto}}.icon--16{height:16px;width:16px}.icon--25{height:25px;width:25px}.icon--36{height:36px;width:36px}.icon--white{fill:#fff}.icon--darkgray{fill:#616161}.icon--green{fill:#80b83d}html{-webkit-font-smoothing:antialiased;height:100%;font-size:18px!important}body{padding-top:88px;height:100%}body h1{font-size:3em;color:#000;font-style:normal;letter-spacing:.1em}body h2{color:gray;font-size:1.5rem}body h3{color:#000;font-size:1.2rem}.wrapper{height:100%;width:100%;position:relative;display:table;table-layout:fixed}@media (max-width:767px){body{padding-top:65px}}body{background:#c9edec!important}.condo-detail{background:#fff}.condo-detail .condo-detail__header{-webkit-perspective:1100;perspective:1100;margin-top:-45px;padding:0}.condo-detail .header__cityscape{background:url(/public/assets/images/condo/cityscape-header-afdcd4c.svg) no-repeat center,radial-gradient(#fff,#c9edec 70%),#c9edec;background-size:cover;height:300px}.condo-detail .header__description{background:#6bb83b;color:#fff;text-align:center;padding:40px 40px 20px}.condo-detail .description__polaroid{background:#fff;width:320px;padding:10px;position:absolute;left:50%;margin:-315px 0 0 -160px;transition:-webkit-transform 1.2s cubic-bezier(.65,1.85,.03,.8);transition:transform 1.2s cubic-bezier(.65,1.85,.03,.8);-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform:rotateY(0);transform:rotateY(0);z-index:3}.condo-detail .polaroid__condo-name{font-size:1.5em;background:#00551a;color:#fff;font-weight:700;text-transform:uppercase;margin:0}.condo-detail .polaroid__condo-name .name{display:block}.condo-detail .polaroid__condo-name .name__1{padding:25px 0;min-height:76px}.condo-detail .polaroid__condo-name .name__2{background:#6bb83b;padding:35px 0;height:97px;line-height:27px}.condo-detail .polaroid__condo-name .name__3{padding:25px 5px 90px;min-height:141px}.condo-detail .polaroid__condo-thumbnail{width:120px;height:120px;margin:-65px auto -2px;border-radius:10px;background:#6bb83b;border:2px solid #fff}.condo-detail .description__social{margin-top:87px;margin-bottom:10px}.condo-detail .social__icon{border:2px solid #fff;border-radius:10px;width:35px;height:35px;display:inline-block;margin:0 10px;line-height:44px}@media (max-width:767px){.condo-detail .condo-detail__header{margin-top:-19px}.condo-detail .header__description{padding-left:20px;padding-right:20px}}@media (max-width:320px){.condo-detail .description__polaroid{margin-top:-340px;margin-bottom:60px}.condo-detail .polaroid__condo-thumbnail{position:absolute;left:50%;margin-left:-60px}}.condo-detail .condo-detail__block{background-color:#ececec;padding:15px}.condo-detail .block__header,.condo-detail .block__subheader{color:#fff;text-align:center;text-transform:uppercase;margin:0}.condo-detail .block__header{font-size:38px;background-color:#616161;padding:22px 0}.condo-detail .block__subheader{background-color:#6bb83b;padding:10px 0}.condo-detail .block__property{margin:15px 0;padding:15px;border:1px solid silver;border-top-left-radius:25px}.condo-detail .block__property span{font-weight:700}.condo-detail .location__map{padding:0}.condo-detail .map{width:100%;height:290.674173px}.condo-detail .map__dot{position:absolute;top:0;left:0}.condo-detail .schools__scenery{background:radial-gradient(#fff,#c9edec 70%),#c9edec;width:100%}#redirect-modal .btn-block{margin-top:8px;color:#fff;background:#80b83d;font-size:19px}#redirect-modal p{margin:0 0 15px;text-align:center;line-height:25px}</style></head>\nExcerpt from https://keylocation.sg/condos/aalto\nI noticed that Google now have their own code snippet here: https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery\nIn it they do the style insertion using either requestAnimationFrame or on load.\n. Something strange is that when I attempt to use Google's snippet, it blocks rendering every time. e.g. I modified the above to load just the bootstrap CSS file using Google's script:\nhtml\n<script>var cb = function () {\n  var l = document.createElement('link');\n  l.rel = 'stylesheet';\n  l.href = '/public/bootstrap-82c23a0.css';\n  var h = document.getElementsByTagName('script')[0];\n  h.parentNode.insertBefore(l, h);\n};\nvar raf = requestAnimationFrame || mozRequestAnimationFrame ||\n  webkitRequestAnimationFrame || msRequestAnimationFrame;\nif (raf) raf(cb);\nelse window.addEventListener('load', cb);\nloadCSS(\"/public/global-55c4862.css\");\nloadCSS(\"/public/condo-7b43541.css\");\nChrome and Chrome Canary both block rendering on this, although in slightly different ways.\n. Back to PSI and LoadCSS - I'm beginning to suspect a bug in PSI. Observed today:\n1. Home page (https://keylocation.sg) does not get blocking CSS warning but condo pages (e.g. https://keylocation.sg/condos/aalto) do. The exact same loadCSS approach is used in both.\n2. Sometimes when running PSI the blocking CSS warning is made for mobile and not desktop. e.g.\n   \n. @renettarenula it seems like there's probably \"something\" about ordering that might fix PageSpeed scores, but it doesn't seem to be as deterministic as \"critical CSS styles after loadCSS JS\". My critical CSS styes are placed immediately before </head> and all loadCSS JS is before it, and I still get blocking CSS warnings from PageSpeed Insights.\n. @rsteinwand could you confirm if you're using both loadcss + preload Polyfill, and also where exactly those scripts are relative to the other code you mention?\n. Specifically, I'm a little confused by your code description when combined with this earlier statement:\n\nThis happens to me when I add loadCSS inline JS code AFTER my inline critical CSS code. The warning on PSI went away when I move it before the inline CSS. \n\nI had assumed you invoked loadCSS() before critical CSS. But did you mean you inlined the loadCSS code before critical but only invoked it later?\n. ",
    "dereckmartin": "Thank you for this insight! As of today, this is still buggy in PSI.  It has really been bugging me why PSI is reporting it as blocking.  \nI only have two files loaded a JS and a CSS file for a meteor app.  I was able to async the JS, and use loadCSS for the css file.  Both end up at the bottom of the page, and there is nothing in the title except a meta tag and a title tag.\nPSI still reports the css as blocking on mobile.\n. ",
    "juliandormon": "I can confirm as of today that it still is buggy. I was not having issues last week and now all of sudden, PSI does not like our css files loaded using loadCSS().  Thanks so much for this great code by the way!\n. ",
    "renettarenula": "This happens to me when I add loadCSS inline JS code AFTER my inline critical CSS code. The warning on PSI went away when I move it before the inline CSS. \nPutting a small inline JS code before the CSS style tag is better as well since it doesn't block CSSOM. For those interested, you can read about it more here: https://www.igvita.com/2014/05/20/script-injected-async-scripts-considered-harmful/\n. ",
    "rsteinwand": "My setup is:\n<head>\n<link rel=preload to postloaded css>\nCriticalCSS\nAsync Defer scripts\n</head><body>\nScript to load css at the bottom.\n</body>\nPSI Score: 99% (-1% for Google Analytics).\nhttp://www.intercepteft.com/searchsite.aspx\n. Sorry, ignore my comments. The preload css link is there, but a different css loader is used on that page (like the rest of the site). Apparently the page got clobbered and the script is no longer there.\n. @rarkins: file has been updated. I have two files with similar names and referred to the wrong one. Both have been updated to use loadCSS.\nYes, loadCSS + polyfill is inlined at the bottom of the page, before </body>\nCritical css is inlined after the rel=preloaded post-loaded css.\nThese are the only two files on this site with loadCSS. Neither has blocking issue.\nhttp://www.intercepteft.com/searchsite.aspx\nhttp://www.intercepteft.com/searchsite.html\n. No blocking on any of my pages that I know of, but I'm only loading one stylesheet. https://www.intercepteft.com/searchsite.html\nThe only way I know of to determine if it's a false positive is to inline your entire stylesheet, then postload it. \nThose of you with blocking, how many stylesheets are you loading?. Can we get minified versions for version 2.x? \nPossibly due to the new logic, The new rel-preload code doesn't work when minified.. Thanks for the link.\nActually this is what I wanted: https://unpkg.com/fg-loadcss@2.0.0/dist/cssrelpreload.min.js\nSame problem, IE uses a lot of CPU.. PSI just recently updated to their Blink engine, which has been in browsers for a couple years now. To say they haven't updated their tools is an understatement.. I'm seeing the same behavior, and only in IE8. IE9 and other browsers work just fine so had to quickly roll back to my previous script, which doesn't seem to work as well.\nI don't need or use Modernizr so would like to see this fixed properly. \n. I can confirm this is still an issue with v2, but only if there's a @media print block in the post-loaded css.\nThe problem is the post-loaded print section is applied to screen. \nSince IE9 and below don't support TLS1.2 and we block everything else, this isn't an issue for us and I'm unable to post a test case. (ie9 and below can't access our site)\nConsidering how IE8 doesn't natively offer good support for media queries in the first place, I doubt this will ever be fixed. . That said, this is also an issue if compatibility mode is enabled, which I'll bug separately.. I wonder if this fixes the issue for ie8 https://github.com/filamentgroup/loadCSS/issues/112\nI'll have to check on Tuesday.\n. No this does not fix #112 in IE8.\n. There was a little discussion about this issue here: https://github.com/filamentgroup/loadCSS/issues/175\nRemoving the @print block from the postloaded style sheet (using an external print style sheet) does fix this issue until you don't have to worry about IE8.\n. Are you using the recommended install? https://github.com/filamentgroup/loadCSS\n\nWith that markup in the head of your page, include the loadCSS script, as well as the loadCSS rel=preload polyfill script in your page (inline to run right away, or in an external file if the CSS is low-priority).\nWhen I check mine with Firefox, the css is in the head, right where I put it.\n. Drop:loadCSS(\"css/main.css\")\nAdd cssrelpreload script.\nOr use mine:\n<script type=text/javascript>!function(e){\"use strict\";var t=function(t,n,r){function o(e){return i.body?e():void setTimeout(function(){o(e)})}function a(){d.addEventListener&&d.removeEventListener(\"load\",a),d.media=r||\"all\"}var l,i=e.document,d=i.createElement(\"link\");if(n)l=n;else{var s=(i.body||i.getElementsByTagName(\"head\")[0]).childNodes;l=s[s.length-1]}var u=i.styleSheets;d.rel=\"stylesheet\",d.href=t,d.media=\"only x\",o(function(){l.parentNode.insertBefore(d,n?l:l.nextSibling)});var f=function(e){for(var t=d.href,n=u.length;n--;)if(u[n].href===t)return e();setTimeout(function(){f(e)})};return d.addEventListener&&d.addEventListener(\"load\",a),d.onloadcssdefined=f,f(a),d};\"undefined\"!=typeof exports?exports.loadCSS=t:e.loadCSS=t}(\"undefined\"!=typeof global?global:this),function(e){if(e.loadCSS){var t=loadCSS.relpreload={};if(t.support=function(){try{return e.document.createElement(\"link\").relList.supports(\"preload\")}catch(t){return!1}},t.poly=function(){for(var t=e.document.getElementsByTagName(\"link\"),n=0;n<t.length;n++){var r=t[n];\"preload\"===r.rel&&\"style\"===r.getAttribute(\"as\")&&(e.loadCSS(r.href,r,r.getAttribute(\"media\")),r.rel=null)}},!t.support()){t.poly();var n=e.setInterval(t.poly,300);e.addEventListener&&e.addEventListener(\"load\",function(){e.clearInterval(n)}),e.attachEvent&&e.attachEvent(\"onload\",function(){e.clearInterval(n)})}}}(this);</script>\n. You need the loadCSS and cssrelpreload.js scripts. \nFor Chrome (or Opera), all you need is this for it to work:\n<link rel=\"preload\" href=\"css/main.css\" as=\"style\" onload=\"this.rel='stylesheet'\">\nSo to test your script, you need to use a different browser. http://caniuse.com/#feat=link-rel-preload\n. Chrome Windows and Edge both work. The only issue I have is IE7/8 deliver a print style sheet.\nThis site has 1.2.0 installed if you want to test: http://www.tpppa.org/\n. I only have one external style sheet and the print section is the last dozen lines preceded with:\n@media print{}\nI have critical css inlined with the page and use LoadCSS to load the remaining css.\n. I see the TPPPA site I linked above doesn't have a problem with the print style sheet, but the only print code there is one line:\n@media print{.nav{display:none}.pagetop{margin-top:0}}\nI'll play with it more and see what I can figure out.\nTHANKS.\n. The W3 validation issue is covered here: https://github.com/filamentgroup/loadCSS/issues/162\nI suspect you should try testing with a simpler page.\n. So is it working now in Firefox with the polyfill script? Because I have two websites that work just fine with Firefox or Chrome.\nIf it's not working, do you have a link to a page that isn't working for you?\nI agree the examples could be better, it took me awhile to figure out what I needed as well.\nYou only need the loadCSS script if you load the style sheet with the script. That's the original way of using loadCSS. example: loadCSS( \"path/to/mystylesheet.css\" );\nYou need both scripts if you use the \"Recommended Usage Pattern\". example: <link rel=\"preload\" href=\"path/to/mystylesheet.css\" as=\"style\" onload=\"this.rel='stylesheet'\">\n. See this issue: https://github.com/filamentgroup/loadCSS/issues/180\nIt's possible your problem was due to the script before the stylesheets.\n. Try moving your stylesheets BEFORE LoadCSS scripts.\nAlso, you should add critical css to your head if you're going to use this loadCSS OR just load non-critical css with loadCSS. https://jonassebastianohlsson.com/criticalpathcssgenerator/\n. Is this the issue you're seeing: https://github.com/filamentgroup/loadCSS/issues/110\n. Is this your problem? https://github.com/filamentgroup/loadCSS/issues/110\n. You should be able to test here, using Chrome and other browsers, then check waterfall: https://www.webpagetest.org/\n. If you want to use LoadCSS you need to create the critical CSS and inline it in your head, potentially a lot of work considering this is the critical css for one page and other pages may differ. Here's the tool I used: https://jonassebastianohlsson.com/criticalpathcssgenerator/\nOtherwise, like Johanson said, simply go back to the traditional way of loading style sheets.\n. Link?. Sounds like it should be bugged with mod_pagespeed.\nhttps://groups.google.com/forum/#!forum/mod-pagespeed-discuss. I don't have this issue but didn't have it with Google's script either.\nI inline my critical css in the head, followed by my postloaded style sheet. My external script loads deferred just before the closing head tag.\nMy CssRelPreload script is with the rest of my inlined scripts just before my closing body tag.. I still use Google's deferred CSS code on our public website. \nGoogle's code is a lot smaller, but LoadCSS knocks a second, maybe two off the page load time for heavy page, if implemented correctly. I'm still testing the pre-2.0 code, but have it on our home page and it's looking promising (and it's not blocking according to PSI).. Yes, much better. Problem resolved.\nThanks.. This is a regression. Surprisingly, V1 did not have this problem.\nhttps://www.intercepteft.com/test2.html. I can confirm it's a problem for my website as well.\nBut I have no clue if any of our customers use FF 41.. Easy: Combine your 3 stylesheets into one file. Use LoadCSS code to load your only file. \nDone.\nThis is not an issue that LoadCSS devs need to fix.. rabas007: loadCSS is designed to help load CSS files that are not critical to the initial rendering of the page, and instead desirable to load in an asynchronous manner. (For including critical CSS in a page without blocking rendering, we recommend either inlining that CSS in a style element, or referencing it externally and server-pushing it using http/2.). What makes you think it's not working? \nThere are minor, unresolved issues with Pagespeed Insights and LoadCSS.. ",
    "wilcoverhoeven": "I had the same problem. It was driving me nuts all morning, but I managed to fix it\nFor me it was the critical css that was causing the problem. The critical css did not contain the background image for the header of the site, so it was missing some styles for the \"above the fold\" html.\nI guess that pagespeed considers this blocking because the \"above the fold\" html could only be completely styled by loading the css file.\nI'm using both loadCSS and the polyfill.\n. ",
    "hummal": "Had the same problem with PSI and loadCSS. After putting the whole code (Inlined loadCSS base code and the call to loadCSS(PATHTOCSSFILE) before the inlined CSS in the head the pagespeed comes back to 88 from 69. \nI made some thoughts about that. Is it possible that the inlined atf css (if it is very much of it) could not be rendered/painted completely by the browser before it comes to the end of body tag where the loadCSS call loads the asyn css. After this css is completely loaded it forces a redraw which blocks the rendering again. \nIn short: the inline CSS rendering was not completed while the async CSS was loaded and forced a redraw which causes the blocking. \n. Can not confirm that workaround working on Google Pagespeed Insights. I referring both. \nStill got the double chome request and so does the PSI -> double PSI Chrome request. Agree!. ",
    "malcocerGit": "@hummal You're right, I remove my background from the critical css and leave on the loadCSS, wins 2-6 points.\n. @fatjester Thanks for the advice, I will try it that and share my result. Since 2016 the things on Google tester aren't changed much, even we implemented the critical css, requirejs, preloadCss, loadFont.. ",
    "fatjester": "@hummal and @malcocerGit - Additional thanks for that info.  I was also having issues with Page Insights and loadCSS thinking it was a google bug.  I also had some elements that were causing a redraw and google was penalizing for that.  Your comments helped me solve a number of my PSI issues.. @uspriya2006 - do you have a url to look at?. @uspriya2006, you might want to take a close look at the expedia-responsive.css stylesheet, particularly at the elements in your media queries - since that's that's the stylesheet flagged only in mobile view.  The fact your other styles aren't flagged (or even this one in desktop view) shows that the script is working, and it's another element likely triggering this.\n@hummal and @malcocerGit 's comments above clued me into that Google will flag an async stylesheet if it triggers a redraw that is dependent on loading something in above-the-fold content - particularly if it happens before the entire page has been rendered (and this all happens in microseconds, so it can be tricky to debug). \nIn my case, it was items that referenced a custom font family - and once the async style noted I needed a font - the browser had to pause, download the font, then redraw.  I ended up using fontfaceobserver to load the fonts behind the scenes, then changing the body class to a fonts-loaded, so the fonts were there at the time the items needed them.  I don't think its the redraw entirely that triggers this warning, but a redraw that is dependent on downloading something.\nYou might want to make a very simple version of this page - with the same content source code, but only loading this one stylesheet.  It might be easier to debug that way.\nGood luck!\n. You are calling fonts that you don't have loaded yet (specifically: font-family: 'Oleo Script',Impact).  Render blocking means that you doing something that pauses the rendering of the page while the browser waits for items to download - that can be loading css (which this library addresses), but it can also be loading javascript, or referencing a font that doesn't exist.\nBy referencing a font that isn't loaded yet - the browser waits for a bit for the font to load (and triggers the warning in google pagespeed), then if it gets the font, continues rendering, and if not continues with the fallback.\nTo address it, you'd need to set the fonts for items to use system fonts (like serif or sans-serif), then use something like https://github.com/bramstein/fontfaceobserver to change those to your custom fonts once loaded.\nMany people don't like doing this because it cases FOUT (https://css-tricks.com/fout-foit-foft/).\nThere may be other issues in addition to this, but this one being referenced specifically by Google in the Optimize CSS.\nGood luck!\n. I don't know, no one said it was easy ;)\nIf you use chrome dev tools, you can throttle your load speed to to \"slow 3g\", and see how your page renders in a very slow environment (which is what google pagespeed is partially grading).\nIt still appears tied to how you are loading and displaying the Oleo Script items as at very slow speeds they don't render until the font has loaded (and it's still specifically referenced by the test).  I do note that you intentionally have those items hidden until that point, and that may still be what they are dinging you on.\nImagine if you were on a train, and your slow internet started to download this page, but then lost it's connection before it completed.  Some text would never render for people (because rendering was \"blocked\"), and that's how google is judging you on this.\n. Still sounds like a font issue.\nLikely icon fonts (Glyphicons), are at least one of these\n. Agreed.  I think it's been fully verified that loadCSS is working properly, and it's other issues triggering PSI.  It's almost always a font issue triggering PSI, so maybe some additions to the documentation and samples will help keep the issues down.. I think the advantage is this starts loading a css file without blocking the rendering of the page.\nIn the 'at the bottom' approach, the css wouldn't start downloading until all assets referenced in the html page have downloaded (for example, several 200kb+ images - which would delay the css loading far more than one might like).\nmaintainer's note: this is not quite accurate. see next comment. thanks!\n. I noticed in the newest Firefox and Edge that if the <link rel=\"preload\"... is coded after the <script... block (instead of before as it is in the test/preload.html example), then the polyfill does not work.\nI can't verify that it worked on earlier versions, but even though this ordering of tags might not be optimal, it is acceptable and it would be better if the polyfill worked regardless of order.\nThat said, still amazing and thanks for making it :)\n. This main example is working for me in in both Firefox, and Firefox dev - there is an intentional 5 second delay to show that it doesn't block rendering while waiting.  You might be having a different issue than the other people in the thread.. I refreshed example you listed several times with both FF, and FF dev and each time the css loads about 5 seconds later.  However, main.css isn't a stylesheet in the example, it should be \"slow.php\".\nIf you are having an issue with your implementation as you described it above - with your css called after the script, then you might be having the same issue discussed in the thread, but that issue doesn't affect the http://filamentgroup.github.io/loadCSS/test/preload.html example because it's css is called before the script.\nThere was an pull request from a while back committed yesterday that addresses the firefox issues, so if you are testing your own site, you may want to try the updated code.\n. Sure.\nIn your demo here: http://filamentgroup.github.io/loadCSS/test/preload.html\nthe link tag for the stylesheet appears before the polyfil script.\nIf you were move it to after the polyfill script (see the top codepen example), the polyfill doesn't work in most browsers (firefox, edge, ie) because the link tag didn't exist at the time of the script execution.  The change I suggested calls the script again when the DOM is loaded (not the most elegant solution, but fixes the issue, see second codepen example in firefox or ie/edge).\nI didn't notice the event listener when I suggested the change, but it doesn't work properly in many browsers (firefox, ie, edge) - I'm guessing because \"preload\" isn't supported, and thus there is no \"load\" event for the listener to hear, and the script doesn't fire loading the styles.\nA true polyfill should work no matter where the link tag is placed, and thus the suggested change, but I'm sure there is a better way than what I'm suggesting.\nAre you seeing this script work when link tags appear after the polyfill in firefox and ie/edge?  I'm testing on a mac, and in VM's from Modern.ie\n. Cool, I can create an issue instead.\nThanks!\n180\n. Created a new pull request that I think resolves the actual bug.\n180\n. Sorry, #180 referenced earlier had replaced this - if I was better with github, I'm sure I could have closed this out ;)\nThanks,\n-Chris. ",
    "uspriya2006": "Even after reordering the loadCss and criticalCss I am still seeing this issue. There are 4 css resources on our page, PSI was showing 3 as render blocking, even though all 4 are loaded using loadCSS. After reordering (loadCss first, followed by inlined critical css) it is now showing 1 render blocking css resource and only on mobile. Is this an issue in page speed insights or something I could do to fix this in my code?  . This is the url of the page www.expedia.co.uk . ",
    "Paul424": "Sorry for reopening this issue again but i'm struggling with a same issue; PSI tells me that my main css bundle; which i try to lazy load using LoadCSS is still blocking rendering above the fold. I expect LoadCSS is actually working but there may be some styles missing from the criticalcss? Already tried to reorder the criticalcss / loadcss but that did not help.\nHow would i approach this issue?\nSite: https://www.hellolodge.net\nAnother question is that the webpage referred in this thread (https://developers.google.com/speed/pagespeed/insights/?url=filamentgroup.com&tab=mobile) does not seem to inline the LoadCSS, how is that? What better on that solution?\nThanks for advise!\nPaul. Hi, I removed the css refering to that webfont however i still have PSI conplaining about javascipr & css above the fold. That question that i have is actually how i can see \"what\" is blocking the rendering? I'm using typekit for async loading of the webfonts and these are referred only in the non-critical css (loaded by loadcss).\nPaul\n. But that would mean that you can never pass the render blocking test when using webfonts above the fold? (unless obviously you would inline the font). Some working examples would help here, i'll try to search for those.... just to give some more information/progress:\n- I was able to get rid of the font issue (Oleo Script being mentioned as blocking page render) by replacing the solution from Typekit (webfontloader) with fontfaceobserver, and in addition i'm not hiding that font initially, but found Arial/Bold an acceptable fallback (for now).\n- Also i was hiding the css rules for the webfont from the criticalcss even when it's only used below the font-event classes as set by .js but that is not required appearently.\n- I'm still having an issue with the main css bundle being mentioned to block rendering, no idea what is missing from the criticalcss...\nI expect the PSI somehow compares \"screenshots\" after each resource is loaded/rendered, when the difference exceeds a certain threshold then that resource is mentioned as blocking, can someone confirm this? It would make sense giving the results i'm seeing, for instance i have a lazy background and select2.js showing placeholder and icons that only becomes visible after... well.... after the bundle css and .js. So the difference is pretty large there...\nPaul\n. @scottjehl I agree with you, and in fact i didn't want to hijack this issue to start a PSI knowledge thread but thing is that solutions such as loadcss, criticalcss, fontfaceobserver are so very close related that i'm having trouble identifying the boundaries between them... It would help (if i may suggest) to add a paragraph to the documentation how you can verify that loadcss is working properly.\nPaul. ",
    "Littlemad": "@scottjehl I am sorry to say that PSI is an issue for my company where they want to get high value in PSI to get a better ranking value in the Google search results. If there was a way to communicate with people at Google with your contacts trough the filmanet group about the issue would be great. As well I agree that we need a tool indipendent from PSI to verify 100% of time that loadCSS is working. At the moment I don't find it personally clear on how to test it on the network speed on google developer tool.. ",
    "developer-lindner": "That's what PSI shows me right now:\n\nIt even duplicates although there are no duplicate includes?!. Got it... just answered myself. critical css must be first in place.... ",
    "nurtureJamesTan": "we have the same duplicate issue, is this got to do with page insight bug?. ",
    "jan-dh": "+1, getting false positives duplicates from PSI. ",
    "igrigorik": "onload=\"this.rel='stylesheet'\" - ha, clever :)\nOn first pass, yeah, I think that looks correct. \n/cc @yoavweiss\n. Assuming that works, what you have is much better (terser) than I had in mind for this particular case. So, no.. That said, for more complicated cases, where you may want to delay the stylesheet until later, or block it on other fetches, you'd probably want to use an external function, etc.\n. @scottjehl @jakearchibald fwiw, see: https://www.w3.org/Bugs/Public/show_bug.cgi?id=27303\n. @scottjehl @jakearchibald note that the \"scenario on the right\" (https://github.com/filamentgroup/loadCSS/issues/59#issuecomment-99926906) is the behavior you get today in FF and IE: https://www.w3.org/Bugs/Public/show_bug.cgi?id=27303#c27 - not saying it's correct though.. I agree with Jake, I'd prefer to avoid flashing unstyled content. The proposal in the linked bug is to have a safe(r) in-between. That said, if we can't get agreement on that, I'm wondering if we should change Chrome to use FF/IE's strategy.  /cc @pmeenan \n. http://w3c.github.io/preload/#attributes.. as=style, not stylesheet. This is due to a recent refactoring in Fetch.\n. ",
    "addyosmani": "What you have now LGTM.\n. ",
    "yoavweiss": "Still open: https://github.com/w3c/preload/issues/7\n. Regarding preload's onload event, it is a bug. Fix is at https://codereview.chromium.org/1586563014/ and I hope to land it very soon\n. > (I don't know if there was an issue in reusing a sans integrity preloaded resource as an integrity stylesheet... @yoavweiss?)\nI wouldn't expect that to work, at least not with current code. I think handling of integrity and preloaded resources (link preload or otherwise) needs some work. See https://bugs.chromium.org/p/chromium/issues/detail?id=677022. https://dom.spec.whatwg.org/#dom-domtokenlist-supports is where supports() is defined.\ncontains(\"foobar\") will return true if your element's rel attribute contains a \"foobar\" relation.\n. Yeah, the spec refers to fetch and it was recently changed (and the implementation changed with it).\nAlso, that spec is an obsolete snapshot :/ Where did you find it?\n. ",
    "MarcoHengstenberg": "Uuuuh nice. Can't wait!\nCurrently working on a test-case to use preload with webfonts and some delayed CSS (in combination) and I have a few headaches with the way it turns out currently. =)\n. Isn't this something related to what a specific project/webiste needs?\nI mean, sometimes you would want the stylesheet to be there as soon as possible, whereas in other cases it's just like you're pointing out here.\nImho this should be kept as an option \u2013 or it should be possible to opt out. Whatever makes more sense. :smiley: \n. I had this issue as well. What solved it for me is the following pattern of loading stylesheets:\n<head>\n    <link rel=\"preload\" onload=\"this.rel='stylesheet'\" as=\"style\" href=\"foo.css\" />\n    <noscript><link rel=\"stylesheet\" media=\"all\" href=\"foo.css\" /></noscript>\n</head>\n<body>\n    \u2026\n    <script>\n    /* loadCSS script */\n    /* preloadPolyfill script */\n    </script>\n</body>\nWhat's important is to dismiss the extra call via loadCSS('.foo.css'); because that adds a second instance of the <link rel=\"stylesheet\" media=\"all\" href=\"foo.css\" /> to the DOM on top of the one in the <head> where on the onload event the rel attribute of preload will be switched out against stylesheet.\nSo, when only using loadCSS you need the call loadCSS('foo.css'); but with the polyfill that's superflous.. On the latest demo slow.css.php is requested four times in Firefox (Mac OSX El Capitan, Firefox 51.0.1). \ud83d\ude28 . @scottjehl Just fired up the page again and lo and behold: there are only two requests for the file now, the second starting right after the first has completed.\n\nEdit: I tested it several times in a row now and it's always two requests. Dunno why there were four this morning.. Morning @scottjehl Find attached a screenshot of the issue :)\nThe screenshot is made from hovering over the cause column of the second request.\n\nHope this helps.\n. @miketaylr Firefox (Mac OSX El Capitan, Firefox 51.0.1)\nRetesting now\u2026 same result.\n\n. I'll try tomorrow. =) Family-time now.. Now, this is getting weird.\nFirefox Nightly 54.0a1 is behaving the exact same way. I guess I'll try and mute a few add-ons and see whether there's something going on here.\n\n. Alright then. I think I found the issue and it's with my setup.\nI had the \"HTTP-Cache disabled when devTools is open\" flag enabled and as I went and unticked it the behaviour of the preload testpage's been as expected.\nI re-disabled the HTTP-Cache then and reloaded the page and it's still working. No second request. Goes for Firefox Nightly and current (51.0.1).. Sure @miketaylr \nI'm using loadCSS in almost every project currently, so contributing (in whatever way) seems natural to me. =). @monolux Maybe these two articles by @zachleat will help you:\n\nhttps://www.zachleat.com/web/lazy-loading-webfonts/\n\nhttps://www.zachleat.com/web/comprehensive-webfonts/. I'm in no way connected to Filament or this repo but from what I understand you could:\n\n\nnpm install loadCSS\n\nimport it into a javascript file of your liking\nminify it during your build-process\n(4. you may or may not want to concatenate the minfied script with others depending on a ton of factors)\n\nIf loadCSS indeed is your only dependency, then it sure might make sense to simply download it and keep an eye out for version updates (Watch the repository here).. Had the same problem (Firefox Nightly) today with local static HTML files.\nAs soon as I fired up the localhost and visited the static file it worked somehow.\nYet, this isn't a problem with loadCSS as far as I'm concerned as it also didn't work for Webfonts I was using preload for and referenced in my CSS.\nSo, my bet is, that this is most probably related to Firefox's implementation of preload.. Question: wouldn't it make more sense to use sessionStorage?\nI can see the benefits of using localStorage (persistence) but the broader the approach is being used, the more information would end up in the localStorage, which shares the available space with the CacheStorage of ServiceWorker and sessionStorage and browser cache. Especially on devices where the available space for cachable data is low, this concerns me (only a little but yeah).. \u2764\ufe0f Thanks for this!. Had the exact same issue with a project and it ranges from IE10 up to Microsoft Edge 16!. We built the project according to the recommended pattern in this repository. The only thing we didn't do is nulling the onload handler.\nApart from that we had the following markup in our head just after the <title>:\nhtml\n<link rel=\"preload\" as=\"style\" href=\"stylesheet.css\" onload=\"this.rel='stylesheet'\" />\n<noscript><link rel=\"stylesheet\" href=\"stylesheet.css\" /></noscript>\n<script>/* New Preload Polyfill */</script>\nThe rel value had changed to stylesheet as expected but still IE and Edge kept re-requesting the entire HTML, then the stylesheet, then the webfonts, then the page again and never quit.. I set \u201cNetwork.Preload\u201d in my Firefox about:config to true/enabled. -.- Somehow this prevented stylesheets from the same source to fire an onload event.\nSorry for the fuzz.\nNow, after re-setting it to false/disabled all works as expected.. ",
    "lili21": "the demo is broken. I am using chrome 56.\n\n. ",
    "bsed": "onload=\"this.rel='stylesheet'\" good ~. ",
    "vince844": "Hi tanks for your work, It works great on Pagespeed desktop but it doesn't seem to work for mobile as i still get the error message on PageSpeed Insight, is is a google bug?. ",
    "jeromystewart": "That is the case as I was using my nginx test environment when I discovered this. Great script thanks for sharing it and thank you for the response.\n. Absolutely\n. ",
    "noahgrant": "just wanted to ping someone on this.  Anyone have any opinions/solutions or am I thinking about this wrong?  I'm thinking for now I'm going to inline the entire homepage styles to avoid the Flash Of Unstyled Below Fold Content.  Uh...yeah.  FOUBFC.\n. thank you, @scottjehl!\n. ",
    "mrmartineau": "Tested and working on:\n- IE6\n- IE7\n- IE8 (so I'm guessing its fine for later versions of internet explorer)\n- iOS 4.3\n:smiley:\n. yeah, good idea. \n. ",
    "nakoo": "I'm just using loadCSS.js which be minified. loadCSS function are called to be in js file for asynchronous.\nIt's same as follow unless some of them above. Here is my code. I hope this will help.\nhttps://github.com/nakoo/nakoo.github.io/blob/master/assets/js/loadCSS.min.js \n. ",
    "Krinkle": "See also http://www.phpied.com/when-is-a-stylesheet-really-loaded/ for some relevant research done in 2011 by @stoyan.\n. @zachleat wrote\n\nWhat browser is exhibiting this behavior?\n\nChrome latest stable.\n@scottjehl wrote\n\nWorth noting here that the onloadCSS extension binds directly to the onload event, just like it would if you use the now-deprecated callback argument. There are a few exception cases (android native browser) that don't support onload natively for CSS, so it attempts to patch support for those, but that's it.\n\nIt does indeed use onload where possible. However that has no relation right now with the media attribute. As such it's probably firing that when the media is still set to something that doesn't apply.\nReproduction test case exposing the bug:\nhttp://codepen.io/Krinkle/pen/qdjVJV\nA fork of that pen with the media trick commented out \u2013 not exhibiting the bug:\nhttp://codepen.io/Krinkle/pen/ZGyaVp\n. ",
    "rupl": "I tested both the Original and New codepens @scottjehl posted:\nDesktop\n:+1: OSX Chrome 48.0.2564.82 (64-bit)\n:+1: OSX Chrome Canary 50.0.2632.0 canary (64-bit)\n:+1: OSX Opera 30.0.1835.59\n:+1: OSX Opera 34.0.2036.50\n:+1: OSX Firefox 44.0\nMobile\n:+1: iOS 9.2 (13C75) Safari\n:x: iOS 9.2 (13C75) Chrome \u2014 Original failed as expected, New produced an alert() with \"callback too early\" and red section reporting same outcome:\n\n. @scottjehl using the labels you provided above, both the Original Failing Test and New Passing Test failed on iOS Chrome. You can see the first couple letters of the \"New Passing Test\" codepen in the screenshot I provided, just to verify.\nEvery browser I tested failed the Original Failing Test, as expected.\n. I tested with 47.0.2526.107 \u2014 I will update the app and give it another go.\n. Hey, what do you know! Updating Chrome caused New test to pass. I noticed\nin the release notes that Chrome 48.0.2564.87 uses an entirely different\nrendering engine called WKWebView.\nOn Friday, January 29, 2016, Chris Ruppel chris.ruppel@gmail.com wrote:\n\nI tested with 47.0.2526.107 \u2014 I will update the app and give it another\ngo.\n. \n",
    "abrambailey": "I am using the following code to show some stuff after css has loaded:\njavascript\nonloadCSS(stylesheet, function() {\n    var myClasses = document.querySelectorAll('.after_css_load'),\n        i = 0,\n        l = myClasses.length;\n    for (i; i < l; i++) {\n        myClasses[i].style.display = myClasses[i].getAttribute(\"data-display\");\n    }\n});\nHowever, sometimes elements marked with the following are not appearing:\nhtml\n<div class=\"panel-group filter-form-styles after_css_load\" data-display=\"block\" style=\"display:none;\" id=\"accordionNo\">\nIt seems to be a browser thing. Works intermittently in Safari Version 9.0.3 (11601.4.4) and consistently in Chrome Version 49.0.2623.87 (64-bit)\n. ",
    "srcspider": "Thanks @scottjehl\nAre there any search engine considerations btw? I believe google removed their search preview thingy so fortunately that's no longer an issue; it was also, according to google, low usage so probably not a big deal. Not sure about other search engines.\n. ",
    "coolwebs": "Cool, thanks for letting us know. I aim to combine and minify them first so there is only one call in the function but sometimes CSS is a funny thing and there are dependancies that must be loaded first.\n. ",
    "akkumar": "For now, used the minifier above to add to jsdelivr cdn. \nIssue here at: https://github.com/jsdelivr/jsdelivr/pull/5105 . \nActual artifact available at: http://www.jsdelivr.com/#!loadcss . \n. @scottjehl  - I can see the dilemma (between npm vs bower ).  \nMy $0.02 - \n1) given this is about 2 competing build systems  (ok - not exactly ,  but close enough), I believe it will help to be published at both the places, to increase adoption of this lib. \n2) Independent of point 1 above, it would be very useful to have a minified version published as well. (should we go with only 1 or both). \n. ",
    "anroots": "Being a lazy end-developer as I am, I decided to\n- inline the loadCSS script with an include statement into my HTML\n- minify the HTML before it's sent to the browser\nIf worked fine in my localhost, as I was testing with a non-minified version... but in production... as the non-minified source contains comments, it commented out the entire inlined library (and I didn't even notice).\nNow, this was totally my \"oops\", but... :) Just saying - not all lazy front-end developers have a \"minify libraries\" step.\n. ",
    "zbeekman": "Playing around with this I have found that the inline style always takes precedence over the deferred load. Also, I put it after and Google PageSpeed seemed to be satisfied with that. Right now, I can't quite figure out how to automatically extract above the fold critical css accurately so using inline and defer loading is not an acceptable solution for me, because the inline css is not accurate, and won't even be corrected when loading the actual css.\n. ",
    "vijayaraghavanramanan": "Thanks Scott. \n. @bramstein I have seen this happening with Typekit. Difficult to repeat, I think it has something to do with CDN Hit/Miss too. \n. Why do you want it external? I think the code has to go inline for its objective to be met. \nOtherwise it is render blocking. \nAnd in case you load it async, you have to worry about dependency when you load your CSS with loadCSS(...). \n. Saw the readme update. Thanks. \nI have a basic question. The location of the default script with loadCSS( \"path/to/mystylesheet.css\" ) shouldn't matter right? (Since it's anyway inserted at the end)?\nIn my case I have inline/critical css, and an aggregated js in the end and the aggregated css loaded using loadCSS. However it seems to matter if I put this inline script on top or below the inline css. \nI can see this in Chrome DevTools. With loadCSS before inline css, I see above the fold elements are using inline and the rest use the stylesheet. However if I put the loadCSS script below inline, inline styles are striked out in DevTools. \nNo need to reopen the topic, as this question is slightly different than the first. \nAlso another question I have is: what is the expected cascade? The cascade which was present without asynchronous loading?\nThanks again. \n. Hi Scott,\nHere it is: www.concertedaction.com\nRight now I have put the loadCSS function and loadCSS(file) on top. You can see the inline being used \n\neven though one would expect the external CSS to have overwritten it. \nProbably what you say is what's happening. \n. Did you get a chance to look at it @scottjehl ?\n. I see. Something like fetch the css file(s) with media set to \"only x\" and use something like requestAnimationFrame to set it to \"all\" (with different code for old browsers)?. \n. I solved this by using Modernir's CSS media queries build and also modifying loadCSS a bit: I set media to all and inject css if Modernizr.mq('only all') is false. Else I let loadCSS behave as usual. It's fine because old browsers render block anyway. Ideally I need something small (and no conditional IE comments). If someone knows a simple media query JS smaller than Modernizr's CSS media queries please let me know. My aim was to simplify everything and just have inline css and loadCSS(...) which I achieved. \n. Hi @scottjehl \nYes, it occurs when it contains a @media print block and the browser (IE8 and less) uses the styles from this. . I am getting this. I have all your latest files but it seems the link is loaded before inline. \nPossibly it's because the preload syntax \nonload=\"this.rel='stylesheet'\"\ninserts the stylesheet at the same location?\n. @scottjehl Isn't this a bonus in your latest version?. If I use your preload code+polyfill, doesn't this automatically load all css \n. Hi Scott, \nYeah that makes sense. Agree fetch leaving later won't make much difference. \nThere's one more thing. I hope it's okay for me to ask here and not open another issue. \nI have observed that on second load, IE8 and below paint using the styles within @media print {...} rules. I modified your code at my end and blocked render by checking for media query feature detection. i,e, I use a condition like \nvar matchMedia = window.matchMedia || window.msMatchMedia;\n    if (matchMedia) { ...\nand then set media to media || \"all\" and immediately inject the sheets if the condition is false.  \nWhen I do that, IE8 and below work fine. \nSo I guess older browsers might need to be explicitly render blocking in loadCSS? (ie by not setting media to \"only x\")?\n. Hi @aFarkas ,\nI was able to solve this issue by modifying Scott's trick here: \nhttps://github.com/filamentgroup/loadCSS/issues/135#issuecomment-180774393\nWhat I do is, I  run rp.poly \nhttps://github.com/filamentgroup/loadCSS/blob/master/src/cssrelpreload.js#L30\nif sessionStorage.fullcssloaded is false and do document.write if true. \n. @aFarkas \nMaybe that's because when used with the polyfill, the output doesn't have something like loadCSS(\"http://www.example.com/all.css\") and instead gets the links by a loop finding all link tags and this runs only after CSSOM is ready? Without using the code as a polyfill, when we do a loadCSS( ...) directly, the browser starts to download even if JS has not started to run. But now JS running is more important to start the fetch. (?)\n. Maybe not related, but this site says that the trick \n<link rel=\"stylesheet\" href=\"css.css\" media=\"none\" onload=\"if(media!='all')media='all'\">\ncrashes on Firefox. \nThe latest code does something with link, setting rel to null, so maybe there's some connection. \n. @giratikanon that's because Firefox supports 38 ESR for organizations. \nhttps://www.mozilla.org/en-US/firefox/organizations/faq/\n. @scottjehl  this chart explains 38's prevalence (from Mozilla's site)\n\n. I am getting a cannot change media of undefined error. \nSorry no test site as I rolled back. \n. Thanks Scott. That code is really useful. \nThere are some EU cookie laws, so I wanted to keep site cookie free. \n. I have another question on this. \nWon't the repeated running keep adding the same links because it runs rp.poly a few times and each time some links (such as the first one above the javascript). So while it is discovering links it is also running it for links already being fetched and so insertion is happening multiple times for some?\n. There's something interesting benefit of that line I observed. Inserting a link before the preload/link is a slightly dangerous thing. So even if one doesn't care for waiting for preload links to be discovered, setting link.rel = null is crucial, else the browser hangs. \n. One reason I can think of is that Chrome 49 only supports it with Experimental Web Platform features turned on but that it returns a true on feature detection. So it probably does nothing. I however don't see it happening in my tests. \n. @dylanh724\nYou don't need script src as @vlrprbttst said. \nAlso you are missing the closing </script> tag. \nAbout placement: you first insert the inline styles and then loadcss. \n<style>\n/* inline css here */\n</style>\n<script>\n//loadcss + cssrelpreload inlined here.\n</script>\nGoogle Chrome has preload now, so you should not just use loadCSS but use it as a polyfill. See readme. \n. ",
    "montyanderson": "Did you merge it? Awesome!\n. ",
    "chinchang": "Indeed, that was the issue. Thanks for replying.\n. ",
    "whjvenyl": "\nSo I'd go for something like this:\nvar elems = document.querySelectorAll('style,link[rel=stylesheet]');\nvar ref = elems.item(elems.length - 1);\nref.parentNode.insertBefore(ss, ref.nextSibling);\nIt finds all external stylesheets and inline styles, gets the last one (in DOM order), then adds our ss right after it.\n\nNot having any other style-definitions on a page beside the web-font we try to load, this code would fail.\n. ",
    "paulirish": "hey scott, thanks.\nI think we could do slightly better. I'm concerned that just requiring before won't reduce the chance that browser styles are recalculated. Plus requiring the insertion point kinda sucks for users.\nHow about... \n- attempt to place after last stylesheet. \n- If no results or no qSA, fall back to before last script.\n- if before provided, place before given element\n. This looks beautiful, including the description and plan.\nCheers!\n. seems cool. basically kill the first if branch and always after the last node in the DOM.\nseems good!\n. ",
    "mikeytown2": "Totally agree that hosting local is ideal. Hosting on a CDN allows for easy testing of the script before copying it locally.\nProviding a loadCSS.min.js would be a nice to have.\n. If you commit the .min files then they will be available like so \nhttps://cdn.rawgit.com/filamentgroup/loadCSS/master/src/loadCSS.js\nhttps://cdn.rawgit.com/filamentgroup/loadCSS/v1.3.1/src/loadCSS.js. Also happens with IE11 on windows 7. ",
    "odahcam": "Take a look: https://unpkg.com/fg-loadcss@2.0.0/dist/loadCSS.min.js. Does #240 fixes this?. In the version the page is using, looks like the issue stills alive:\n\n. We had that case of onload=do something where some duplicated load occours, isn't there a probabillity of this issue being triggered like that?. does loadCSS source code changes any attributes after the file is loaded?\n. @scottjehl yes, I was thinking that maybe by changing the link element the browser could atempt to load it again.. If you want, you could use the loadCSS('my-styles-01.css'); JavaScript function to avoid this.. @jhabdas In this context, preload should means async. In HTML you need to use <link rel=\"preload\" /> for native async CSS loading support.. Minify a file is very simple, you just need to keep the author's credits when you do this.. For loading fonts you should consider https://github.com/typekit/webfontloader. All NPM packages are automatically included in some CDNs, like UNPKG. \nExample:\n - https://unpkg.com/fg-loadcss@2.0.1/src/loadCSS.js \n - https://unpkg.com/fg-loadcss@2.0.1/src/cssrelpreload.js\n - or simply: https://unpkg.com/fg-loadcss\nMy opinion: this implementation shouldn't be a critical thing and if anyone wants to use the lib from a CDN this person can use, but also should know (maybe a note in the readme could do this) the colateral effects pointed by @csswizardry.. @scottjehl also we could add that minified version people are asking for, once for all. \ud83d\ude03 \n. Much needed functionality! Awesome!. Why reload a stylesheet to update CSS rules when you can update all the DOM with JavaScript, that is such a bad practice, right?\nAlso, you can always put a query string with a version at the end of the url: <url>/stylesheet.css?v=1.0.0.. Someone please add these files once for all \ud83d\ude4f , there's no good reason for not including them and people will keep asking for them, as you can see.. See #232 \n. I think that there's should be an else here, cause in browsers that support both addEventListener and attachEvent, the listener will be registered twice. . ",
    "dlemstra": "After the fixes the result is this:\nUgly version:\nOld version: 2415 characters\nNew version: 566 characters\nSaved: 1849 (result is 23.4% of original)\n. I added this split because I thought that was failing the test because of the recursive call. But that must have been the other part of the code that I fixed. Good catch, saves us some more bytes :)\n. I updated my comment. I thought that piece of code was causing the tests to fail but it passes them perfectly now. Sorry for the confusion and thanks for merging my changes.\n. This would help @mikeytown2 that requested this in issue #97.\n. ",
    "XhmikosR": "I've opened #204 the other day without noticing this issue. I guess it's the same issue after all.. @sideshowbarker : @scottjehl is right. If we use rel=\"stylesheet preload\" this would not work in Chrome, would it?. @scottjehl: in theory if we changed the check in preload to link.rel.indexOf(\"preload\") !== -1 should work.\nCan you verify?. Please wait a few minutes so that @sideshowbarker explains the situation as discussed on IRC.. >Waiting for this to be figured out in browser implementation first seems very reasonable to me. Meanwhile you can use rel=\"preload\" data-integrity=\"...\" and add the integrity attribute at the same time as adding the stylesheet relation.\nThat is a cleaver workaround! Have you tried it in action?. This is no longer an issue.. @scottjehl: can you close/delete branches of all the dep bump PRs? I have a working branch which I can split and submit a single PR for this.. @scottjehl; don't forget to delete the branches too. I'm cleaning up my branch and I'll make a PR soon.. @scottjehl: updated. Keep in mind this PR fixes testing on Windows. Is there something you'd want different?\nYou can also close #211.. @scottjehl: updated to the latest versions.. @scottjehl: just check each individual patach with ?w=1. They are pretty straightforward to me.. The version is wrong.. ?type=dev. ",
    "sideshowbarker": "\nIf we use rel=\"stylesheet preload\" this would not work in Chrome, would it?\n\nWhy would it not work? Neither the Preload spec nor the HTML spec prohibits it.\nOr am I misunderstanding something?\nWhat I do know is that the HTML spec defines the value of the rel attribute as a set of space-separated tokens and the HTML spec requires it to be parsed that way and for UAs to process it based on what the value contains, not on an exact match against the entire value.. > As mentioned in #204, I'm not sure how this would work if the attribute is only allowed with link[rel=stylesheet].\nPer https://html.spec.whatwg.org/multipage/semantics.html#attr-link-integrity it\u2019s allowed if the rel value contains stylesheet (not just is stylesheet). Since the rel attribute can contain a set of values, it can contain both stylesheet and preload and still conform to that requirement.\n. My previous comments were mostly just about the context document-conformance requirements. I guess https://github.com/w3c/webappsec-subresource-integrity/issues/26 is more relevant as far as the UA requirements.. > I'm not sure that specifying both values would behave as one would want... would it block or fetch async? I've not seen this spec'd or tested.\nYeah, see related discussion at http://logs.glob.uno/?c=freenode%23whatwg&s=14%20Feb%202017&e=14%20Feb%202017#c1020544 among @yoavweiss and @zcorpan and @annevk. ",
    "zcorpan": "Waiting for this to be figured out in browser implementation first seems very reasonable to me. Meanwhile you can use rel=\"preload\" data-integrity=\"...\" and add the integrity attribute at the same time as adding the stylesheet relation.. (I don't know if there was an issue in reusing a sans integrity preloaded resource as an integrity stylesheet... @yoavweiss?). ",
    "kellerkichel": "I have make some improvements... \nthe reflow part is useless... and the check need another check for src:\nvar ss_loaded = document.styleSheets;\nfor (var i = ss_loaded.length - 1; i >= 0; i--) {\n    if (ss_loaded[i].href) {\n        if (ss_loaded[i].href.indexOf(href) > -1) return false;\n    }\n}\nI dont know if is the better way.. but works :+1: \n. ",
    "wouterbulten": "@kellerkichel Your new snippet solved the double load problem for me (related to #110). Thanks :+1: \n. ",
    "HouCoder": "@scottjehl Thanks for your response, I'm requesting this css file: http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css\nIt has the caching setting in the response header.\nAnd here is the HTTP request&response detail:\n\nThanks ;-)\n. @scottjehl I did some tests in my local too, seems Chrome creates a new request when you changing the  media attribute. \n\nThanks.\n. HTML code error:\n\n. @scottjehl I updated the description for this issue, I hope it will reduce the notifications from this issue.\n. ",
    "mjau-mjau": "+1. CSS files get called twice:\n\n. Just reference, I can't reproduce this issue in mac-chrome, no matter how many times I refresh or hard-refresh:\n\nLatest release definitely fixes the issue for us, as opposed to my post in this thread on Nov 3, 2015.\n\n. ",
    "robin-drexler": "+1 We're also experiencing this issue. Are there any updates or known workarounds? Thanks. :)\n. @scottjehl thanks for the fast reply. :)\nCould you please elaborate on why the older version does not cause the multiple requests? As far as I understood, it's caused by the switch of the media attribute. This is done in the older version as well. \n. ",
    "bramstein": "For what it's worth: I spent some time debugging this, and it turns out loadCSS only loads a stylesheet twice if the \"Disable cache\" button in the network panel is checked (at least in my case). Once that is disabled, the stylesheet is loaded twice, but the second request is from the cache.\n. This change looks good. Do you know why the old behaviour triggered a second (cached) request, and this new code doesn't?\n. ",
    "romuloinnocencio": "this works fine for me, https://github.com/filamentgroup/loadCSS/issues/108\n. ",
    "skyl": "Still the same problem on master as of right now.\n. The second fire comes from the ss.media = media || \"all\" line:\n// once loaded, set link's media back to `all` so that the stylesheet applies once it loads\n        ss.onloadcssdefined = onloadcssdefined;\n        onloadcssdefined(function() {\n            ss.media = media || \"all\";\n        });\n        return ss;\nLet me double check and make sure I'm not experiencing PEBKAC.\n. I can't make a public example at the moment. But, I've definitely got \"version\": \"1.0.0-0\", everywhere and am experiencing this. Local development server with node ...\nResponse headers look like this FWIW:\nHTTP/1.1 200 OK\nAccept-Ranges: bytes\nDate: Tue, 02 Feb 2016 23:08:31 GMT\nCache-Control: public, max-age=0\nLast-Modified: Tue, 02 Feb 2016 21:52:35 GMT\nETag: W/\"7e25f-391209796\"\nContent-Type: text/css; charset=UTF-8\nVary: Accept-Encoding\nContent-Encoding: gzip\nConnection: keep-alive\nTransfer-Encoding: chunked\n. Tried changing the headers. Same with these:\nHTTP/1.1 200 OK\nExpires: Wed, 01 Feb 2017 22:58:43 GMT\nAccept-Ranges: bytes\nDate: Wed, 03 Feb 2016 00:22:29 GMT\nCache-Control: public, max-age=31536000\nLast-Modified: Tue, 02 Feb 2016 21:52:35 GMT\nETag: W/\"7e25f-391209796\"\nContent-Type: text/css; charset=UTF-8\nVary: Accept-Encoding\nContent-Encoding: gzip\nConnection: keep-alive\nTransfer-Encoding: chunked\n. I wonder what I'm losing if I go with this...\nfunction loadCSS(path) {\n    var link = document.createElement('link');\n    link.type = 'text/css';\n    link.rel = 'stylesheet';\n    link.href = path;\n    document.getElementsByTagName('head')[0].appendChild(link);\n}\n. ",
    "kofifus": "I'm seeing this as well. Is there any thoughts on resolving this ?\n. ",
    "tarranjones": "Quick question why do you have to wait until onload to change the media attribute? wouldn't this still be non-blocking? \nready( function(){\n    //inserted with media=\"only x\"\n    ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );\n    // stylesheet starts to download\n    // now change media attr\n     ss.media = media || \"all\";\n});\n. Yep its in there! I obviously didn't look hard enough, I only found an old W3C working draft which didn't mention it. Thanks for the link.\n. ",
    "englishextra": "https://developers.google.com/speed/pagespeed/insights/\nSays\n```\nOptimize CSS Delivery of the following:\nhttps://englishextra.github.io/libs/englishextra-ui/css/bundle.min.css\nhttps://englishextra.github.io/libs/englishextra-ui/css/bundle.min.css\n\n```\nSo I rolled back to https://github.com/filamentgroup/loadCSS/releases/tag/0.1.7 \nAnd by the way, had to move callback as a second arg not the fourth for compatibility reasons.\nBTW having a separate onloadcss plugin seems to pile up the whole story. Thanks for your work.\n. @sschengyf  That been discussed long ago. Yeah, Google https://developers.google.com/speed/pagespeed/insights/ seems to use and old lib, though latest Chrome Browser (51.0.2704.106 m (64-bit) in my case) loads only once. Correct me if I missed smth here. So the he.. with the Pagespeed.\n. Using loading particular polyfill for each device/browser I figured out that Pagespeed loads the following dependencies (my use case, certainly):\n\u2026romise/3.2.2/js/es6-promise.fixed.min.js\ncdn/fetch/1.0.0/js/fetch.fixed.min.js\ncdn/polyfill/0.1.27/js/url.fixed.min.js\n\u2026diate/1.0.5/js/setImmediate.fixed.min.js\n\u2026l/2.0.0/js/weakmap-polyfill.fixed.min.js \nSo now using caniuse \nhttp://caniuse.com/#search=promise\nyou can calculate which android browser/chrome it is. \n4.4.3-4.4.4 \nSo not the latest one, where the bug is to be fixed. Correct me if missed smth here.\n. Gents, stop bothering. Css/js exceeding 40 kb might be the cause. Also pretty sure the algorithm hasnt updated for long. Are you dependent on customers that require PS green results? I'm sure you dont. Double requests of CSS is not the loadCss/loadJS lib bug.\n\nUPD the more than 3 requests suggestion doesn't matter, by the way. Just been testing for years since 2009. Sometime I'm pretty sure that I've been fooling around. Think what was the goal of creating that tool like PS.\n@jhabdas I'm afraid that you overestimate the PS tool. You say established things. By the way your implementation/workaround/tool sounds fresh. and I'm quite sure I would inherit something from it, so thanks for that.\nI would strongly recommend to webdevs (as a webdev since 2006) not to listen to PS results - yes. optimize minify gzip spritify async and so forth but think why does this tool exist.\n. @jhabdas >>That's why PageSpeed Insights exists.\nIt exists not for you, because you think of UX. It does for shitty SEO sites producers \u2014\u2018their name is legion\u2019 (\u0421) MIT license. @scottjeh Let Google Page Speed devs disclose their algorithm of testing webpages for quality optimisation. But they dont, and they wont. It's useless investment. Remember the Googles's suggestion on how to workaround css loading with animation frame, how many devs rushed on to write their own implementations of RAF, or let's remeber the AMP pages initiative which is ugly from the start...\nWhat do I use (comments can be outdated):\nmy loadjs/loadcss:\n;(function(){var loadJS=function(_src,callback){\"use strict\";var ref=document.getElementsByTagName(\"script\")[0];var script=document.createElement(\"script\");script.src=_src;script.async=true;ref.parentNode.insertBefore(script,ref);if(callback&&\"function\"===typeof callback){script.onload=callback;}return script;};(\"undefined\"!==typeof window?window:this).loadJS=loadJS;}());\n            ;(function(){var loadCSS=function(_href,callback,media,before){\"use strict\";var doc=document;var ss=doc.createElement(\"link\");var ref;if(before){ref=before;}else{var refs=(doc.body||doc.getElementsByTagName(\"head\")[0]).childNodes;ref=refs[refs.length-1];}var sheets=doc.styleSheets;ss.rel=\"stylesheet\";ss.href=_href;ss.media=\"only x\";if(callback&&\"function\"===typeof callback){ss.onload=callback;}function ready(cb){if(doc.body){return cb();}setTimeout(function(){ready(cb);});}ready(function(){ref.parentNode.insertBefore(ss,(before?ref:ref.nextSibling));});var onloadcssdefined=function(cb){var resolvedHref=ss.href;var i=sheets.length;while(i--){if(sheets[i].href===resolvedHref){return cb();}}setTimeout(function(){onloadcssdefined(cb);});};function loadCB(){if(ss.addEventListener){ss.removeEventListener(\"load\",loadCB);}ss.media=media||\"all\";}if(ss.addEventListener){ss.addEventListener(\"load\",loadCB);}ss.onloadcssdefined=onloadcssdefined;onloadcssdefined(loadCB);return ss;};(\"undefined\"!==typeof window?window:this).loadCSS=loadCSS;}());\nload script that wont appear in the DOM:\n/*!\n * Promise based script loader for the browser using script tags\n * github.com/MiguelCastillo/load-js\n * type: defaults to text/javascript\n * async: defaults to false\n * charset: defaults to utf-8\n * id: no default value\n * url: required if no text is provided\n * text: required if no url is provided\n * promiseLoadJS([\"https://code.jquery.com/jquery-2.2.1.js\",\n * \"https://unpkg.com/react@15.3.1/dist/react.min.js\"])\n * .then(function(){console.log(\"jQuery and react are loaded\");});\n * promiseLoadJS([{async:true,url:\"https://code.jquery.com/jquery-2.2.1.js\"},\n * {async:true,url:\"https://unpkg.com/react@15.3.1/dist/react.min.js\"}])\n * .then(()=>{console.log(\"all done!\");});\n * source: gist.github.com/pranksinatra/a4e57e586249dc3833e4\n * passes jshint\n */\n;(function(){function exec(options){if(\"string\"===typeof options){options={url:options};}if(!options.url&&!options.text){throw new Error(\"must provide a url or text to load\");}var head=document.getElementsByTagName(\"head\")[0]||document.documentElement;var script=document.createElement(\"script\");script.charset=options.charset||\"utf-8\";script.type=options.type||\"text/javascript\";script.async=!!options.async;if(options.hasOwnProperty(\"id\")){script.id=options.id;}if(options.url){script.src=options.url;return loadScript(head,script);}else{script.text=options.text;return runScript(head,script);}}function runScript(head,script){head.appendChild(script);return Promise.resolve(script);}function loadScript(head,script){return new Promise(function(resolve){var done=false;script.onload=script.onreadystatechange=function(){if(!done&&(!this.readyState||this.readyState===\"loaded\"||this.readyState===\"complete\")){done=true;script.onload=script.onreadystatechange=null;if(head&&script.parentNode){head.removeChild(script);}resolve(script);}};head.appendChild(script);});}var promiseLoadJS=function(items){return items instanceof Array?Promise.all(items.map(exec)):exec(items);};(\"undefined\"!==typeof window?window:this).promiseLoadJS=promiseLoadJS;}());\nload js and eval it (yeah-yeah-yeah):\n/*!\n * Load and execute JS via AJAX\n * gist.github.com/englishextra/8dc9fe7b6ff8bdf5f9b483bf772b9e1c\n * IE 5.5+, Firefox, Opera, Chrome, Safari XHR object\n * gist.github.com/Xeoncross/7663273\n * modified callback(x.responseText,x); to callback(eval(x.responseText),x);\n * stackoverflow.com/questions/3728798/running-javascript-downloaded-with-xmlhttprequest\n * @param {String} u path string\n * @param {Object} [f] callback function\n * @param {Object} [e] on error callback function\n * ajaxLoadTriggerJS(u,f,e)\n */\n;(function(){var ajaxLoadTriggerJS=function(u,f,e){var w=window,x=w.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject(\"Microsoft.XMLHTTP\");x.overrideMimeType(\"application/javascript;charset=utf-8\");x.open(\"GET\",u,!0);x.withCredentials=!1;x.onreadystatechange=function(){if(x.status==\"404\"){if(e&&\"function\"===typeof e){e();}console.log(\"Error XMLHttpRequest-ing file\",x.status);return!1;}else if(x.readyState==4&&x.status==200&&x.responseText){try{var Fn=Function;new Fn(\"\"+x.responseText).call(\"undefined\"===typeof window?\"undefined\"===typeof self?\"undefined\"===typeof global?this:global:self:window);}catch(m){throw new Error(\"Error evaluating file. \"+m);}if(f&&\"function\"===typeof f){f(x.responseText);}}};x.send(null);};(\"undefined\"!==typeof window?window:this).ajaxLoadTriggerJS=ajaxLoadTriggerJS;}());\n@zachleat that's too simple.. @jhabdas I am afraid this library is about link tag CSS loading - fetch is not suported by ie11 and edge13. Besides you can't control easily if the style is loaded, and by the way you have to manipulate the response. ",
    "rjsworking": "Hi\nI've got the the same problem: two requests for the css file but only in Chrome. Firefox Dev Edition only shows one request. The headers shows a future expiration date there's must be another problem. A Chtome bug? \nThere's also the Pagespeed Insights issue: One CSS blocker resource.\n\n\n. @scottjehl \nThank you very much.\n. ",
    "JustFly1984": "I'v dig a lot around async assets loading, and I have something to give to community, based on this loadSCC module. It still has a bug with double css loading, which is not bad if you have client caching.\nIf you have client caching, you need cache invalidation. And here is there everything goes much more complicated. My module works with 3 breaking points (could be extended by fork) -  < 767 || 768 <1199 || 1200 <\nIt takes an Object, parsed from manifest.json buy your build system, detects client browser for a proper font extension, and runs single callbacks after each css file has been loaded.\nIt applies a proper css file for each breakpoint, and proper font files to the browser. Now you can forget about huge @fontface rules. - Just provide separate css file for woff || woff2 || svg fonts in base64.\nI made this script for my project, and I use Webpack without react.\nI found out, that the best way to provide CSS to client - it is separate it to 4 delivery parts.\n1st part - is critical CSS or Above the fold CSS and reset.css. Here should be everything to build a layout, and hide everything else, until everything is rendered, fonts applied and so on.\nAlso this is a great plase to set all your responsive breakpoints for html, like font-size - to set responsive rem sizing.\n2nd part - component CSS - BEM like CSS for all your components, either React, either any other inlined, or just required by Webpack., except @media CSS.\n3rd part - is responsive @media CSS, which is way overhead to send all in one time. So build a separate css file for each breakpoint, and load it async according to the browser.\n4th part - is fonts.\nWell, 1st part is covered by you, 2nd part by Webpack, or any other build system, and 3rd and 4th - covered by my extension to loadCSS module.\nPlease do not judge strong - this is my first give back to community based on this loadCSS module, but with callback, strippers and blackjack.\nhttps://gist.github.com/JustFly1984/8420b137721b76be8f304b3ab43f2dec.\n. ",
    "sschengyf": "I also encountered this situation, seems only happens on Chrome. I have tested Safari, FF, IE, all fine. \n. ",
    "artursopelnik": "Nice workaround, if you have to optimize \"google\" pagespeed:\nhttp://keithclark.co.uk/articles/loading-css-without-blocking-render/\n. ",
    "Fjonan": "I could circumvent the issue by wrapping the loadCSS(...) call into a setTimout that waits 100 ms. Maybe that is a worthwhile workaround until this is fixed.. ",
    "adiie9": "Hi,\nI have read the details on this page and seems like it is not Chrome issue.\nCheck this: https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fwww.legalinz.com%2Femployment-law-uae-fixed-fee-services%2F\nIf you look at \"Eliminate render-blocking JavaScript and CSS in above-the-fold content\"\nYou will see only one CSS blocking. (actually there are total 3x requests for CSS files)\nBut check this page: https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fwww.legalinz.com%2Fsharia-compliant-will%2F\nYou will see 6x CSS files. 3x CSS files are being repeated.\nOn both pages, JS files (combined into 1) are different and I am not able to detect either any JS file is creating the issue, or it is loadCSS function or Chrome (I guess it is not chrome because results on Firefox are also the same.)\nPS: Let me know if I did miss something in above conversation.. ",
    "davidhellmann": "Pagespeed also said it loads the css file twice. Interesting is that on my other website it's all fine. hm :) And Pagespeed said also I've blocking CSS. meh! :D . For me I fixed the problem.\nThis one makes two requests:\n<link rel=\"preload\" href=\"{{ cacheBuster( '/assets/css/app.min.css') }}\" as=\"style\" onload=\"this.rel='stylesheet'\">\n    <noscript>\n      <link rel=\"stylesheet\" href=\"{{ cacheBuster( '/assets/css/app.min.css') }}\">\n    </noscript>\nthis one is fine:\n```\n<script>\n    loadCSS(\"{{ cacheBuster( '/assets/css/app.min.css') }}\");\n  </script>\n<noscript>\n    <link rel=\"stylesheet\" href=\"{{ cacheBuster( '/assets/css/app.min.css') }}\">\n  </noscript>\n\n```. ",
    "ghost": "Here's a workaround which may help those trying to fine-tune PageSpeed scores for modern browsers only: https://github.com/jhabdas/fetch-inject. Isn't the point of this library to get down to the bare metal of performance and UX? IMO it's not about the customers, it's about the users. That's why PageSpeed Insights exists.. Thanks for the detailed response @scottjehl. FWIW I used this library to hit PS100 for both desktop and mobile, open sourced the work and shared how to do it with Jekyll on my blog: https://habd.as/pagespeed-100-with-jekyll-s3-and-cloudfront/. Happy optimizing!. I was able to resolve the issue in a single request using fetch-inject, a library I authored. Here's how it can be used to load CSS and loading font icons simultaneously:\nhtml\n<style>/*! bulma.io v0.4.0 ... */</style>\n<script>\nfetchInject([\n  '/css/non-critical.css',\n  'https://cdn.jsdelivr.net/fontawesome/4.7.0/css/font-awesome.min.css'\n])\n</script>\nFetch is a Web standard and a modern replacement for AJAX. The Fetch Inject library is a small wrapper for Fetch to make loading non-critical CSS easier and loads JavaScript in addition to CSS.. You're a genius @englishextra. I've opened an issue against fetch-inject to help meet this end, whereby manual PE for older browsers is no longer necessary. Cheers to you for the idea.. @SirRawlins Have you considered shimming in your own wrapper?. I believe UMD is compatible with CJS. If so, perhaps this will work:\nhttps://cdn.jsdelivr.net/fetch-inject/latest/fetch-inject.umd.min.js\nAnd as a fallback for older browsers, you can skip the need to polyfill fetch:\nhttps://github.com/jhabdas/fetch-inject#progressive-enhancement. head\njavascript\n<script>\n      (function() {\n      'use strict';\n      var head = document.getElementsByTagName('head')[0];\n      var bootnap = document.createElement('link');\n      bootnap.rel = 'stylesheet';\n      bootnap.href = './css/bootstrap-theme1.min.css';\n      head.appendChild(bootnap);\n      }());\n</script>\nBefore </body>\nhtml\n<link href='https://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>\nResult:\n\n\n\nhead\njavascript\n<script>\n// notice the difference between this one and the first one\n      (function() {\n          'use strict';\n          var head = document.getElementsByTagName('script')[0];\n          var bootnap = document.createElement('link');\n          bootnap.rel = 'stylesheet';\n          bootnap.href = './css/bootstrap-theme1.min.css';\n          bootnap.media = 'only x';\n          head.parentNode.insertBefore(bootnap, head);\n          setTimeout(function() {\n            bootnap.media = 'all';\n          });\n      }());\n</script\nBefore </body>\nhtml\n<link href='https://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>\nResult:\n\n\n\nIn the head\njavascript\n<script>\n      (function() {\n          'use strict';\n          var head = document.getElementsByTagName('script')[0];\n          var bootnap = document.createElement('link');\n          bootnap.rel = 'stylesheet';\n          bootnap.href = './css/bootstrap-theme1.min.css';\n          bootnap.media = 'only x';\n          head.parentNode.insertBefore(bootnap, head);\n          setTimeout(function() {\n            bootnap.media = 'all';\n          });\n      }());\n</script>\nBefore </body>\njavascript\n<script>\n      (function() {\n          'use strict';\n          var xhr = new XMLHttpRequest();\n          xhr.timeout = 4000;\n          xhr.overrideMimeType('text/css; charset=UTF-8');\n          xhr.onreadystatechange = function() {\n              if (xhr.readyState === 4 && xhr.status === 200) {\n                  var style = document.createElement('style'),\n                      lastJS = document.getElementsByTagName('script')[2];\n                  style.appendChild(document.createTextNode(xhr.responseText));\n                  lastJS.appendChild(style);\n              }\n          };\n          xhr.open('GET', 'https://fonts.googleapis.com/css?family=Roboto:400,700', true);\n          xhr.send(null);\n      }());\n</script>\nResult:\n\n\n\nThe sweet spot (inlined critical above-the-fold css into the page itself):\nBefore </body>\njavascript\n<script>\n    (function() {\n        'use strict';\n        var getAsyncFile = function(fileStr) {\n            var xhr = new XMLHttpRequest();\n            xhr.timeout = 4000;\n            xhr.overrideMimeType('text/css; charset=UTF-8');\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4 && xhr.status === 200) {\n                    var style = document.createElement('style'),\n                        head = document.getElementsByTagName('head')[0];\n                    style.appendChild(document.createTextNode(xhr.responseText));\n                    head.appendChild(style);\n                }\n            };\n            xhr.open('GET', fileStr, true);\n            xhr.send(null);\n        };\n        getAsyncFile('./css/bootstrap-theme1.min.css');\n        getAsyncFile('https://fonts.googleapis.com/css?family=Roboto:400,700');\n</script>\nResult:\n\nThe Desktop score went from 94 to 96 using the last example.\n\nThe browser is now fetching the bootstrap theme at 180ms, instead 220ms:\nIn the head\njavascript\n<script>\n    (function(w) {\n        'use strict';\n        var xhrRunner = {\n            firstRun: true\n        };\n        xhrRunner.getAsyncFile = function(fileStr) {\n            var xhr = new XMLHttpRequest();\n            xhr.timeout = 4000;\n            xhr.overrideMimeType('text/css; charset=UTF-8');\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4 && xhr.status === 200) {\n                    var style = document.createElement('style'),\n                        head = document.getElementsByTagName('head')[0];\n                    style.appendChild(document.createTextNode(xhr.responseText));\n                    head.appendChild(style);\n                }\n            };\n            xhr.open('GET', fileStr, true);\n            xhr.send(null);\n        };\n        if (xhrRunner.firstRun) {\n            xhrRunner.getAsyncFile('./css/bootstrap-theme1.min.css');\n            xhrRunner.firstRun = false;\n        }\n        w.xhrRunner = xhrRunner;\n    }(window));\n</script>\nBefore </body>\njavascript\n<script>\n    (function() {\n        'use strict';\n        xhrRunner.getAsyncFile(\n        'https://fonts.googleapis.com/css?family=Roboto:400,700'\n        );\n    }());\n</script>\nResult:\n\n\nFour days later (but edited in GitHub 11 days later):\nReplaced the Roboto fonts with Helvetica which most browsers are shipping out-of-the-box.\nMade seperate page that includes all the classes that my blog is using thankfully to grunt-uncss. It looks like I've been using only 10% (13KB out of 126KB) of the bootstrap framework. The 13kb css is inlined into the page itself. My blog engine is separated on two parts, blog-engine 7.8kb and post-engine 75.5kb, instead serving one gigantic 90kb\n\n\n. @Kilbourne Have you considered shimming in your own wrapper?. Someone must've made a fork by now. What is preloaded CSS anyway? I've never heard of such a thing. In my websites I have:\n\nInline CSS (sometimes critical)\nAsync CSS using Fetch API (non-critical)\nPush State CSS (same as external). Ah. Preload related to Push State, yeah? I see native preload support levels at ~50% with Safari in hot persuit and Edge under consideration. Would preload then presumably be used for critical CSS not inlined in the document with this library perchance? I imagine there's a FOUC if loaded async with JS.. @rsteinwand - all files are external files on a CDN. So how?. \n",
    "liltinkerer": "@scottjehl It's being asked over and over again, maybe you could add it to wiki/readme?\nThe whole discussion is absurd, the point of this small lib is to optimize user experience, not some arbitrary number that Google makes up and is often wrong, because they haven't updated their tools.. It doesn't matter what Google's pagespeed think or says, use your console to check if everything works and indeed is async.. @shrpne why would loadCSS need to have to workaround for a speed test? If it does load async for browser clients the everything is fine. . \"Official\" minified file would be nice.\nI use:\n//* loadCSS.js *//\n!function(e){\"use strict\";var t=function(t,n,r){function o(e){return i.body?e():void setTimeout(function(){o(e)})}function l(){d.addEventListener&&d.removeEventListener(\"load\",l),d.media=r||\"all\"}var a,i=e.document,d=i.createElement(\"link\");if(n)a=n;else{var s=(i.body||i.getElementsByTagName(\"head\")[0]).childNodes;a=s[s.length-1]}var u=i.styleSheets;d.rel=\"stylesheet\",d.href=t,d.media=\"only x\",o(function(){a.parentNode.insertBefore(d,n?a:a.nextSibling)});var f=function(e){for(var t=d.href,n=u.length;n--;)if(u[n].href===t)return e();setTimeout(function(){f(e)})};return d.addEventListener&&d.addEventListener(\"load\",l),d.onloadcssdefined=f,f(l),d};\"undefined\"!=typeof exports?exports.loadCSS=t:e.loadCSS=t}(\"undefined\"!=typeof global?global:this),\n//* cssrelpreload.js *//\n!function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement(\"link\").relList.supports(\"preload\")}catch(a){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName(\"link\"),c=0;c<b.length;c++){var d=b[c];\"preload\"===d.rel&&\"style\"===d.getAttribute(\"as\")&&(a.loadCSS(d.href,d),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener(\"load\",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent(\"onload\",function(){a.clearInterval(c)})}}}(this);. ",
    "web-worddoc": "Have you resolved the problem regarding double request?. ",
    "MartyD23": "I'm also having the issue of duplicate css. Seems to happen in all browsers. GTmetrix also shows the duplicates, as does Pingdom, but WebPageTest does not show the duplicates.. ",
    "7iomka": "problem regarding double request isn't resolved. ",
    "larslevie": "FWIW, I cannot reproduce this in Chrome 64.0.3282.140 (macOS) or Firefox 58.0.1 (macOS), but I can reproduce using Safari 11.0.3 (macOS) and Mobile Safari (iOS 11.2.2).\nWith the following in head:\n<link rel=\"preload\" id=\"dynamic-style\" type=\"text/css\" as=\"style\" onload=\"this.onload=null;this.rel='stylesheet'\" href=\"https://style.realgeeks.media/templates/molly.css\">\n<noscript><link rel=\"stylesheet\" id=\"dynamic-style\" type=\"text/css\" href=\"http://style.realgeeks.media/templates/molly.css\"></noscript>\n<script type=\"text/javascript\">!function(t){\"use strict\";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement(\"link\").relList.supports(\"preload\")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){function e(){t.media=a}var a=t.media||\"all\";t.addEventListener?t.addEventListener(\"load\",e):t.attachEvent&&t.attachEvent(\"onload\",e),setTimeout(function(){t.rel=\"stylesheet\",t.media=\"only x\"}),setTimeout(e,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName(\"link\"),n=0;n<a.length;n++){var o=a[n];\"preload\"!==o.rel||\"style\"!==o.getAttribute(\"as\")||o.getAttribute(\"data-loadcss\")||(o.setAttribute(\"data-loadcss\",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener(\"load\",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent(\"onload\",function(){e.poly(),t.clearInterval(a)})}\"undefined\"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}(\"undefined\"!=typeof global?global:this);</script>. ",
    "ensemblebd": "For me it only happened when mediatype was not all or screen (print mediatype). Perhaps not specifying mediatype leads to the same issue for all of the above cases?\nLast I recall, loadCSS only replaces the rel and onload attributes. \nBut if in fact it replaces mediatype, then that would equate to a duplicate request. It's the same for the rel attribute. Change it's value, and the network tab shows a new request for it instantly.\nPretty sure if we dig into the loadCSS source, we will find our culprit w/ relation to mediatype. . Very difficult to troubleshoot, as it completely tanks the browser dev tools.\nGetting the breakpoint in the right spot has not been easy... Am having same problem. \nWorks fine in chrome/safari. . Test case for your experimentation follows....\n\nRemove loadCss lib from resources in page\nOpen IE Edge , F12 key\nPaste into console...\n```\nvar link=0;\nvar links = window.document.getElementsByTagName( \"link\" );\nfor( var i = 0; i < links.length; i++ ){\n    link = links[ i ];\n    if( link.rel === \"preload\" && link.getAttribute( \"as\" ) === \"style\" && !link.getAttribute( \"data-loadcss\" ) ){\n        break;\n    }\n}\nfunction enableStylesheet() {\n    // infinite loop right here.\n    console.log(\"loaded\"); \n    link.media = finalMedia; \n}\n\nvar finalMedia = link.media || \"all\";\nlink.addEventListener( \"load\", enableStylesheet);\nlink.media = \"only x\";\nlink.rel = \"stylesheet\";    // calling this triggers the infinite loop of downloading\nsetTimeout(function() {\n    console.log('forcing loaded');\n    enableStylesheet();\n},3000);\n```\nCode is straight from the sources. \n\nlink.setAttribute('onload','');\nseems to correct the issue. Strange that it downloads it twice though. Perhaps that is reasoning for the loop. If it downloads twice and fires two events (or four, considering the link.addEventListener) , it would be a race condition for which one sets the attribute first right?\nAnd IE apparently redownloads anytime the attribute for [rel] is changed, even if it's the same value. \nSo that explains the explosion of browser internals. It's exponential. \nUntil someone wiser than I on the best approach for this comes along and comments, here's the adjustment to get it to work, per my testing.\nRecommend pasting directly below definition of loadCSS. \n// bindMediaToggle runs from the poly() which only runs when browser doesn't support preload attrib.\n// tested on IE11, IE Edge, and Safari (mac, iphone, ipad). \nloadCSS.relpreload.orig_bindMediaToggle=loadCSS.relpreload.bindMediaToggle;\nloadCSS.relpreload.bindMediaToggle=function(link){\n    link.setAttribute('onload','');\n    loadCSS.relpreload.orig_bindMediaToggle(link);\n};. Excellent! I'll give that a try, definitely didn't see that in the updated readme. I can confirm this is a valid solution for Edge and IE11. Likely all others as well. \nMucho gracias!\nMay want to wait for OP response, but figured I'd share my results. . ",
    "rasenplanscher": "@ensemblebd \nloadCSS does change the media property:\nhttps://github.com/filamentgroup/loadCSS/blob/1b0b1054492dc48ee076af998d6bb5fc84e3a034/src/loadCSS.js#L35\nhttps://github.com/filamentgroup/loadCSS/blob/1b0b1054492dc48ee076af998d6bb5fc84e3a034/src/loadCSS.js#L70. I could not reproduce this in Microsoft's IE8-VM with preload.html from this repository.\nTherefore, I recommend closing this @scottjehl . @scottjehl Since the polyfill is standalone by now, this issue seems obsolete and can be closed, right?. @Kilbourne What is the point, exactly?\nIf you import 'fg-loadcss/dist/cssrelpreload';, at least with webpack, you're good to go. Polyfills usually don't export stuff, by their very nature.. @scottjehl \nMaybe close this? It's pre-v2, lacks detail, and is likely too old to be relevant. I looked into this for a few minutes: according to autoptimize, this is connected to Cloudflare Rocket Loader. I couldn't find out what version they are currently using, but v2 is probable.. @scottjehl Maybe close this as obsolete?\nThis is old, the posted code does not seem to indicate a problem with loadCSS as per the current docs, and Edge is at version 44 by now.. @u007 @JMPerez \nCan you verify please? As far as I can tell, the issue does not show up anymore.. @JMPerez\nThank you for checking again \ud83d\ude04 \n\nIt doesn't happen anymore. However, I just browses the initial payload for nurture.ai and can't see the loadCSS function anymore.\n\nThey have it in their application.[hash].js.\n\nI know https://www.smashingmagazine.com/ uses a similar function and PageSpeed Insights doesn't report render-blocking issues on that site.\n\nThey use this package, this is copied verbatim from their homepage:\n```\n</p>\n<p>(function(w){\"use strict\";var loadCSS=function(href,before,media){var doc=w.document;var ss=doc.createElement(\"link\");var newMedia=media||\"all\";var ref;if(before){ref=before}else{var refs=(doc.body||doc.getElementsByTagName(\"head\")[0]).childNodes;ref=refs[refs.length-1]}var sheets=doc.styleSheets;ss.rel=\"stylesheet\";ss.href=href;ss.media=\"only x\";function ready(cb){if(doc.body){return cb()}setTimeout(function(){ready(cb)})}ready(function(){ref.parentNode.insertBefore(ss,before?ref:ref.nextSibling)});var onloadcssdefined=function(cb){var resolvedHref=ss.href;var i=sheets.length;while(i--){if(sheets[i].href===resolvedHref){return cb()}}setTimeout(function(){onloadcssdefined(cb)})};if(ss.addEventListener){ss.addEventListener(\"load\",function(){this.media=newMedia})}ss.onloadcssdefined=onloadcssdefined;onloadcssdefined(function(){if(ss.media!==newMedia){ss.media=newMedia}});return ss};if(typeof exports!==\"undefined\"){exports.loadCSS=loadCSS}else{w.loadCSS=loadCSS}})(typeof global!==\"undefined\"?global:this);\n  loadCSS('/css/main.css');\n\n```\n@u007 @scottjehl \nPlease close this issue, it seems to be resolved.. @scottjehl Can this be closed? The commit in question should be in the 2.1.0 release.\nMaybe @duply or @rsteinwand can confirm it's fixed?. @caub \nThe warning indicates http://fonts.googleapis.com/css?family=Roboto:300,400,500, while your code sample requires https://fonts.googleapis.com/icon?family=Material+Icons. Are you sure, you don't have another <link rel=\"preload\" ... tag somewhere on your page? Can you reproduce the issue in a codepen?\n\nnote: would be great to have an option to make the above simpler\nCare to elaborate? What do you envision?. @MatTeague \nCan you share your setup code?. If you output the contents of the file, you do not need to link it.\n\n@kylescousin  Is that what you wanted to know? If not, please give more detail. Yes, I had used fs-extra during development, but found that it wasn't necessary, so I removed it from package.json. I forgot to remove the reference to it. That's fixed now \ud83d\udc4d . I was also lacking a semicolon \ud83e\udd14 how do you think about linting as a pre-commit-hook?. Here you go \ud83d\ude04\ud83c\udf89\nGotta love husky \ud83d\ude43. > \n\nSeems to do the trick now! I think we'll want to clean up some links to the test pages here since they seem to use absolute references but I can get those after landing.\n\nOh yeah, didn't check all those \ud83e\udd14\nThanks for taking care of them \ud83d\ude42. Do you get an error from link.setAttribute( \"onload\", null );?\nIt should just do nothing in your case, right?\n\nwe can hash null and add it to our CSP\n\nIf you can do that, why is onload=... a problem for you?\nAlso, what would be the point with null?. Ok, I think, I understand now. And as I see it, this is really nothing that can be changed inside the polyfill to enable the recommended usage with CSP.\nThe safety issue regarding event-handling attributes is about executing code in an unintended context. I cannot see any adverse effect from executing null in any context. What could happen is that an intended event-handler gets removed. That, however, won't be prevented by CSP anyway, because, as I understand it, it will only check the respective script when it is to be executed.\nIf null is effectively hashed, onload=null becomes valid, so if hashing attribute scripts were available cross-browser, that would be a valid strategy.\nThe main obstacle, however, is that this capability is not available cross-browser, and there's nothing a script can do, as far as I can tell. Which is as it should be, I think. The implications of a script, even a white-listed one, changing the behaviour of your CSP are very far-reaching, and I do not expect that feature to have a high priority.\nFinally: At present, only Chrome/Chromium supports rel=preload natively, so that's where the onload attribute is actually most important.. Regarding the suggested path of attaching event handler programmatically: at that point, I see no advantage over using the loadCSS funtion. Do you? I mean, you're scripting your styles anyway \ud83e\udd37\u200d\u2642\ufe0f \nYou might want to go with an in-between solution: <link rel=preload> in <head>, and a corresponding <link rel=stylesheet> at the end of <body>, with event handlers attached by script.\nA discussion of the relative merits seems out of scope here, but I think both strategies are better than trying to force the polyfill together with CSP under the circumstances.. > There was an attempt to attach onload programmatically but the user claims the approach has issues.\n\nif the CSS is already cached, say, it looks like it is possible for the link's onload event to trigger before the handler is attached\n\nYes, that is a very real obstacle. It is, however, overcome by onloadCSS because that polls for the stylesheet in the available sheets instead of listening for the load event.\n\nreplacing setAttribute will solve a minor inconvenience\nAs far as I'm aware, this is functionally equivalent and no hashing is required.\n\nYes, it is functionally equivalent, because in the end, it's the property that counts, not the attribute.\nJust to be sure we're on the same page: As far as I'm aware only extends to this is functionally equivalent, but you have verified that no hashing is required with it?\nIf so, I'm with you on the replacement.\n@scottjehl Do you have any thoughts to the contrary?. ",
    "yoyurec": "+1\n. BTW, 0.2.4 works ok\n. maybe this can help https://www.mozilla.org/en-US/security/advisories/mfsa2015-135/\n. > we were curious if you ran into this through user reports\nuser reports, lot of people are using 38 here ))\n. sorry, no logs ((\nusing Browserstack, so it crashes and new instance is empty\n. ",
    "giratikanon": "User reports. Roughly 20% of our Firefox users are at least two versions behind the latest, with version 38 being the most common, for some reason.\n. ",
    "miketaylr": "Has anyone successfully submitted a crash report after reproducing the bug?\nIf you can give the me the crash IDs, that would be helpful (check about:crashes)\n. > sorry, no logs ((\nNo worries, I'm trying to bisect this with http://mozilla.github.io/mozregression/, let's see if I can find something.\n. OK, using mozregression --find-fix -b 38 -g 46, I got it down to https://hg.mozilla.org/integration/mozilla-inbound/pushloghtml?fromchange=c25738e63a8214a44628df16f1c406eff9d8824c&tochange=e4f18dacf879ddce2043f9dca77af3d39c968f23.\nThat's from https://bugzilla.mozilla.org/show_bug.cgi?id=1203973, which given the title of \"Changing media in onload= in  hangs Firefox\" feels like the right bug fix. \nWhat that does mean is before Firefox 42, this probably will hang or crash browsers, probably going back before 38 :(\nedit: (this was fixed in 42, I had accidentally written 44)\n. I only see the single request... testing in 53 (DevEdition) and 54 (Nightly).\n\n@MarcoHengstenberg which platform are you on, and which version are you seeing the double request in?\n. Thanks for re-testing @MarcoHengstenberg! \nDoes the same bug reproduce in Nightly or Dev Edition (downloads here: https://www.mozilla.org/en-US/firefox/channel/desktop/). > Alright then. I think I found the issue and it's with my setup.\nThanks for taking the time to figure this out, @MarcoHengstenberg!. ",
    "bzbarsky": "The simplest thing to do is probably to just set a flag on your element when changing the media value so you don't respond to the load event the media change will end up firing...\n. ",
    "ryuran": "2.1.x still has the issue apparently\nWe are blocked by an issue only on our automated test with phantomjs and travis.. @scottjehl some news ?. @jhabdas it's not really easy. ",
    "HugoGiraudel": "I\u2019d say this is an implementation mistake in Canary, because in Chrome Version 48.0.2564.116 (64-bit), using rel=\"style\" reports the following in the console:\n\n<link rel=preload> must have a valid as value\n. I don\u2019t have the project locally, I\u2019m just browsing the files on GitHub, so I hope I did not miss one.\n. Missing this one: https://github.com/filamentgroup/loadCSS/blob/ae14a8bb2b2ed86bf547515a800e049029c82498/test/qunit/index.html#L9.\n. Done in https://github.com/filamentgroup/loadCSS/pull/147.\n. Missing this condition in the script: https://github.com/filamentgroup/loadCSS/blob/2f778f07dd490467d7735fe21593b0aea043c471/test/preload.html#L112. Do you want to still allow style? \n. If you only intend to polyfill the spec, then stylesheet should be enough. However, you started with style in the first place and apparently it used to work somewhere (at least for a time), so I don\u2019t know. Your call here.\n. Should be good. Are you taking over on this or shall I do anything else?\n. No worries. I\u2019ll probably ping you in a GitHub issue over the week-end or next week though because I cannot seem to make v1.0.0 work properly on Sass Guidelines. For some reason, the stylesheet is never being applied. I must be doing something wrong, but can\u2019t put my finger on what. :(\n. On topic, Chrome Version 48.0.2564.116 (64-bit) reports the following in the console when using as=\"style\":\n<link rel=preload> must have a valid as value\n. As far as I can tell, it does not. However given the warning, I\u2019m not sure\u2026\n. What the actual fuck? :(\n. Damn\u2026 So 1.1 is incorrect. :(\n. And Chrome 48 is wrong.\n. Thanks for your input @yoavweiss and @igrigorik. \n\nNow I guess we should release 1.2 to revert 1.1 change, @scottjehl. Sucks, I\u2019m very sorry. :(\nMaybe we should document this a bit also.\nAdressed in https://github.com/filamentgroup/loadCSS/pull/149.\n. ",
    "NekR": "Why not merged if as=\"style\" is the correct one?. Use import { loadCSS } from 'fg-loadcss'. Module uses what it uses, but you just should import it correctly.. ",
    "akrawchyk": "The onloadCSS function works by passing in the preloading stylesheet elem returned from the manual call to the loadCSS function. However, the polyfill calls loadCSS automatically here https://github.com/filamentgroup/loadCSS/blob/f9ca33054d77c99cb146c4a48e43139a10194e16/src/cssrelpreload.js#L22.\nTherefore, you can't get direct access to the stylesheets from loadCSS with the polyfill.\n. ",
    "lydell": "If you look at the source code of onloadCSS.js, all it does is adding support for IE8 and Android < 4.4. If you don\u2019t need to support those, the onload attribute is all you need.\nI defined a function window.__onloadCSS (in an inline script) that I want to be called when the CSS has loaded. I simply added window.__onloadCSS() at the end of the onload attribute:\nhtml\n<link rel=\"preload\" href=\"/foo.css\" as=\"style\"\n    onload=\"this.onload=null; this.rel='stylesheet'; window.__onloadCSS();\">\nThat seems to work fine for me both in browsers that support rel=preload on those that don\u2019t (that the polyfill takes care of).\nNote: This assumes using cssrelpreload.js 2.0.1.\n. ",
    "tophmey": "Removed changes included from another branch\n. ",
    "clambelet": "Thanks, it was indeed a flag :)\n. ",
    "frxnz": "I can confirm this is an issue in Chrome 49. cssrelpreload.js:10 returns a false positive.\n. Just noticed this is a dupe of #154. Resetting experimental flags solved the problem.\n. ",
    "iLaurens": "The preload attribute specification is still a Working Draft from the Web Performance Working Group. So only when it gets accepted by W3C it would make sense to update the validator.\nIt's not a standard yet so the validator is right. It is up to you if you already want to adopt it this way and accept the warning from the validator.\n. ",
    "fabioformosa": "@Bernardus  W3C accepted preload attribute, but there was a bug in validator. A W3C developer read my stackoverflow question and he's just fixed the validator!. I get a warning of blocking resources by Google Page Insight if I put polyfill CSSrelpreload.js after loadCSS.js like loadCSS demo  shows.\n@johanson I agree with about the right order. I recap: \n\n\nCSS link with rel=\"preload\"\n\n\njs inline script: first polyfill  CSSrelpreload.js and after loadCSS.js (both minified)\n\n\n@scottjehl I'd ask you to confirm me if my reported order of CSSrelpreload/loadCSSs inclusion is right also if it's inverted than loadCSS demo.\nUPDATE:  unfortunately, if I invert CSSrelpreload and loadCSS inclusion, it doesn't work on Firefox and IE11 :(. If everything works it's enough if you run webapps in localhost, otherwise let me say,  what Google thinks or says it's as holy as holy bible.. ",
    "raglannyc": "I downloaded loadCSS-1.2.0.zip from https://github.com/filamentgroup/loadCSS/releases\n. ",
    "Kravimir": "Fortunately this is easy to add, but it is a strange omission from the script,\nTaking into account the goal of keeping the script as short as possible, I suggest using \"link.media\" instead of \"link.getAttribute('media')\".\n. ",
    "larssn": "Weird omission indeed, easy fix. Thanks for posting this.\n. I'd say its probably the last part here. You want the script to be just before the closing head tag.\n. ",
    "vlrprbttst": "you don't need <script src='js/loadCSS.js' type='text/javascript'></script> to be included.\nanother dumb question: my stylesheet appends to <body> instead of <head>, is this normal?\n. @dylanh724 what about my stylesheet appending to <body> instead of <head>? \ud83d\ude04 \n. would this work then?\n<head>\n<link rel=\"preload\" href=\"css/main.css\" as=\"style\" onload=\"this.rel='stylesheet'\">\n<noscript><link rel=\"stylesheet\" href=\"css/main.css\"></noscript>\n</head>\n<body>\nstuff\n<script charset=\"utf-8\">\n      function loadCSS( href, before, media ){\n          \"use strict\";\n          var ss = window.document.createElement( \"link\" );\n          var ref = before || window.document.getElementsByTagName( \"script\" )[ 0 ];\n          var sheets = window.document.styleSheets;\n          ss.rel = \"stylesheet\";\n          ss.href = href;\n          ss.media = \"only x\";\n          ref.parentNode.insertBefore( ss, ref );\n          function toggleMedia(){\n              var defined;\n              for( var i = 0; i < sheets.length; i++ ){\n                  if( sheets[ i ].href && sheets[ i ].href.indexOf( href ) > -1 ){\n                      defined = true;\n                  }\n              }\n              if( defined ){\n                  ss.media = media || \"all\";\n              }\n              else {\n                  setTimeout( toggleMedia );\n              }\n          }\n          toggleMedia();\n          return ss;\n      }\n      loadCSS( \"css/main.css\" );\n</script>\n</body>\n. no it doesn't, here's the output :)\n\nwhat am i missing?\n. i now have this:\n```\n\n\n\n\n\nstuff\n\n(function( w ){\n// rel=preload support test\nif( !w.loadCSS ){\nreturn;\n}\nvar rp = loadCSS.relpreload = {};\nrp.support = function(){\ntry {\n  return w.document.createElement( \"link\" ).relList.supports( \"preload\" );\n} catch (e) {\n  return false;\n}\n};</p>\n<p>// loop preload links and fetch using loadCSS\nrp.poly = function(){\nvar links = w.document.getElementsByTagName( \"link\" );\nfor( var i = 0; i &lt; links.length; i++ ){\n  var link = links[ i ];\n  if( link.rel === \"preload\" &amp;&amp; link.getAttribute( \"as\" ) === \"style\" ){\n    w.loadCSS( link.href, link );\n    link.rel = null;\n  }\n}\n};</p>\n<p>// if link[rel=preload] is not supported, we must fetch the CSS manually using loadCSS\nif( !rp.support() ){\nrp.poly();\nvar run = w.setInterval( rp.poly, 300 );\nif( w.addEventListener ){\n  w.addEventListener( \"load\", function(){\n    w.clearInterval( run );\n  } );\n}\nif( w.attachEvent ){\n  w.attachEvent( \"onload\", function(){\n    w.clearInterval( run );\n  } )\n}\n}\n}( this ));\n\n\n```\nand i get this output:\n\nwould this be ok?\nclicking on <link rel=\"stylesheet\" href=\"css/main.css\" as=\"style\" onload=\"this.rel='stylesheet'\"> goes to the correct css file and i have no errors in the console but this doesn't look right.\ni get the same output using your function\n. > you might consider listening for either a load event or presence of your stylesheet in the DOM to kick off your JS execution.\nany hint on this? \ud83d\ude04  because now that I think of it, it's actually not only a css issue, butmore of a js one. one clear issue is with the match Height plugin for example (http://brm.io/jquery-match-height/). this one in particular kicks in too early, setting wrong heights because the page didn't fully render when it starts calculating.\nif you have any suggestion on how to implement a load event to check if the stylesheet is in the DOM it would be much appreciated \ud83d\udc4d \n. i tried it this way:\nin <head> i have this:\n```\n      function loadCSS( href, before, media ){\n          \"use strict\";\n          var ss = window.document.createElement( \"link\" );\n          var ref = before || window.document.getElementsByTagName( \"script\" )[ 0 ];\n          var sheets = window.document.styleSheets;\n          ss.rel = \"stylesheet\";\n          ss.href = href;\n          ss.media = \"only x\";\n          ref.parentNode.insertBefore( ss, ref );\n          function toggleMedia(){\n              var defined;\n              for( var i = 0; i < sheets.length; i++ ){\n                  if( sheets[ i ].href && sheets[ i ].href.indexOf( href ) > -1 ){\n                      defined = true;\n                  }\n              }\n              if( defined ){\n                  ss.media = media || \"all\";\n              }\n              else {\n                  setTimeout( toggleMedia );\n              }\n          }\n          toggleMedia();\n          return ss;\n      }\n      loadCSS( \"css/main.css\" );\n  function onloadCSS( ss, callback ) {\nvar called;\nfunction newcb(){\n        if( !called && callback ){\n            called = true;\n            callback.call( ss );\n        }\n}\nif( ss.addEventListener ){\n    ss.addEventListener( \"load\", newcb );\n}\nif( ss.attachEvent ){\n    ss.attachEvent( \"onload\", newcb );\n}\nif( \"isApplicationInstalled\" in navigator && \"onloadcssdefined\" in ss ) {\n    ss.onloadcssdefined( newcb );\n}\n\n}\n```\nand at the bottom of the page I have, near the body closing, in a main.js file:\n```\nvar stylesheet = loadCSS(\"css/main.css\");\nonloadCSS(stylesheet, function() {\n// my problematic functions\nbgSize();\nstickyNav();\n$('.header > div').matchHeight();\n\n}); // stylesheet has loaded\n```\nsome issues are solved, one other not (on firefox).. but that must be something else.\nis this the right implementation? thanks for the heads up\n. ",
    "SirRawlins": "@yoyurec I think your issue is different to mine (unless I've misunderstood what you're saying)\n. Been a while since I looked at it Josh, but may well back back on this\nproject before long and can take another look.\nOn 9 Mar 2017 6:28 pm, \"Josh Habdas\" notifications@github.com wrote:\n\n@SirRawlins https://github.com/SirRawlins Have you considered shimming\nin your own wrapper?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/filamentgroup/loadCSS/issues/171#issuecomment-285437454,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAtiK_4LfdNC5OrIqaeNyBQP_z8qkih1ks5rkETDgaJpZM4Ib-PU\n.\n. \n",
    "Kilbourne": "Same problem for preload poly.. ",
    "StevenFlecha": "sorry, I already completely removed it.. I did put it rather hastily to test out so maybe I did something wrong.. when I have some more time to test I'll report. But result was that css was just completely not loading (and it did on chrome)\n. ",
    "neuropass": "Yes you need 3 scripts so the polyfil can run, see here: \nhttps://github.com/filamentgroup/loadCSS/issues/177\nif someone can update the readme file that would be great. not sure hwo it was missed in the first place. \n. ",
    "kwoxer": "I have the same issue. I'm using Firefox on Ubuntu. Both are latest.\nAlso I'm using Firefox and also Firefox Dev. I have the same issue in both browser.\nThis is what my html.tpl looks like:\n<script>\n    /*! loadCSS: ... */\n...\n    /*! preoadCSS: ... */\n...\n  </script>\n  <link rel=\"preload\" href=\"/sites/all/themes/.../css/main.css\" as=\"style\" onload=\"this.rel='stylesheet'\">\n  <noscript><link rel=\"stylesheet\" href=\"/sites/all/themes/.../css/main.css\"></noscript>\n  <style>\nthis works great in Chrome, IE11 and Edge. It is loading the main.css via lazy loading. And also after a reload the main.css is still cached.\nThis issue is with Firefox/Dev. Here the main.css is somehow loaded 2 times but with a different size (unzipped). Here is a pic: http://i.imgur.com/7MDcpAM.png\nSo why is Firefox not loading the main.css from the Cache after the first visit? And why Firefox is loading the main.css 2 times?\nThis makes no sense for me because in Chrome it works perfectly well!\nBtw the example here http://filamentgroup.github.io/loadCSS/test/preload.html is also not working in both Firefox Browsers. So it's not an issue with my site ;)\nThanks for any idea.. Sure, sure. It works in Firefox. And main.css is loaded 5 sec later.\nBut! If you reload the page it happens again and again and again! This shouldn't! \nAnd yes in all other browser, this is working. Even in Internet Explorer!\nCould you recheck this on your Firefox? Thank you.. Somehow it seems that Firefox is kind of strange. Sometimes it behaves as expected, but often it reloads the main.css. It also has to be simething with an open toolbox. Although I didn't check the checkbox to disable Cache. Very sad, that this just happens in Firefox. :(\nHard to find this issue for that. But I think it's a bug in Firefox. Maybe I should post it as Firefox issue? WDYT?. I have the same issue. I'm using Firefox on Ubuntu. Both are latest.\nAlso I'm using Firefox and also Firefox Dev. I have the same issue in both browser.\nThis is what my html.tpl looks like:\n<script>\n    /*! loadCSS: ... */\n...\n    /*! preoadCSS: ... */\n...\n  </script>\n  <link rel=\"preload\" href=\"/sites/all/themes/.../css/main.css\" as=\"style\" onload=\"this.rel='stylesheet'\">\n  <noscript><link rel=\"stylesheet\" href=\"/sites/all/themes/.../css/main.css\"></noscript>\n  <style>\nthis works great in Chrome, IE11 and Edge. It is loading the main.css via lazy loading. And also after a reload the main.css is still cached.\nThis issue is with Firefox/Dev. Here the main.css is somehow loaded 2 times but with a different size (unzipped). Here is a pic: http://i.imgur.com/7MDcpAM.png\nSo why is Firefox not loading the main.css from the Cache after the first visit? And why Firefox is loading the main.css 2 times?\nThis makes no sense for me because in Chrome it works perfectly well!\nBtw the example here http://filamentgroup.github.io/loadCSS/test/preload.html is also not working in both Firefox Browsers. So it's not an issue with my site ;)\nThanks for any idea.. I have a kind of similar issue. I'm using Firefox on Ubuntu. Both are latest.\nAlso I'm using Firefox and also Firefox Dev. I have the same issue in both browser.\nThis is what my html.tpl looks like:\n<script>\n    /*! loadCSS: ... */\n...\n    /*! preoadCSS: ... */\n...\n  </script>\n  <link rel=\"preload\" href=\"/sites/all/themes/.../css/main.css\" as=\"style\" onload=\"this.rel='stylesheet'\">\n  <noscript><link rel=\"stylesheet\" href=\"/sites/all/themes/.../css/main.css\"></noscript>\n  <style>\nthis works great in Chrome, IE11 and Edge. It is loading the main.css via lazy loading. And also after a reload the main.css is still cached.\nThis issue is with Firefox/Dev. Here the main.css is somehow loaded 2 times but with a different size (unzipped). Here is a pic: http://i.imgur.com/7MDcpAM.png\nSo why is Firefox not loading the main.css from the Cache after the first visit? And why Firefox is loading the main.css 2 times?\nThis makes no sense for me because in Chrome it works perfectly well!\nBtw the example here http://filamentgroup.github.io/loadCSS/test/preload.html is also not working in both Firefox Browsers. So it's not an issue with my site ;)\nThanks for any idea.. Yes @odahcam I know it's easy to minify. But to have it officially it's way better.. ",
    "pothi": "That would be kind of you to host loadCSS using a CDN. However, I wouldn't recommend loading it from a CDN, as loadCSS is not a big file. The un-minified file is already too small (at around 2.4k). If minified, it comes to less than 800 bytes. Having it gzipped would make it even lesser.\n. ",
    "monolux": "Perhaps this Firefox Bug is the cause for the stylesheet loading twice?\nIf the example link is supposed to be \n\nwhite text on green background\n\nthen I can confirm the example does work on Firefox 49.0.2. desktop version, though only after allowing to load mixed content. Same thing in Chrome Version 55.0.2883.87 m.\nIn both cases this can be overcome by loading slow.php from https. Though this is just for the demo purpose I assume so slow.php is not really needed I think.. @zachleat How did you make the optimized lato? Like this?\nIs there a tool or package one could run over a font to just get the basic bits of the font, the critical part of the font if you like, when wanting to use the preload approach with an optimized single web font alongside FontFaceObserver?\nIf there is not such a thing then compressing fonts is recommended, right?\nCould this perhaps prove useful for font loading? Putting the FontFaceObserver script into that would only cause harm, right, meaning FontFaceObserver has to be inline to not cause render blocking?\nTrying to learn and use a future friendly way/method with the current best practices and tools while showing the user no or minimal FOUT and FOIT.\nRelated, there is no closing strong tag here. Is that wanted?. @zachleat Thank you for your swift reply & help.\nThat glyphhanger sounds great already, will have a look right now alongside pyftsubset, thank you for the info.\nYes, won't be going down the lazy loading webfonts route due to FOIT occurring.\nIn order to get completely rid of FOUT and FOUIT, one possible approach (is there a way actually?) I am thinking of not showing any font at the beginning and then fading in web fonts as they become available after loading them with a font loader. Good idea at all?\nI am also thinking, for above the fold content use glyphhanger and pyftsubset alongside a font loader, show those ASAP via fade in when these critical/optimized font/glyphs are done loading and have below the fold showing text once the entire rest of the web font(s) finished loading, so later fade in. Possibly overkill though I am interested in the experience one could provide doing this. Have you tried something like that?\nYou wrote fontfaceonload and there is fontfaceobserver as well as webfontloader. Which one of the font loaders would best support having a loading-fonts event?\nYes webfontloader has this already, though perhaps your lighter fontfaceonload or fontfaceobserver could be used and changed a bit to support the time from the request of the web font until it has finished loading?\nSomething like this?\n```\nvar html = document.body.parentNode;\n// if html tag does not have fonts-loaded class add it\n// run this check every few milliseconds?\nif (!(html.classList.contains('fonts-loaded'))){\n  html.classList.add('fonts-loading');\n}\nelse {\n  html.classList.remove('fonts-loading');\n}\n``\nThat means I would have to check on the existence of thefonts-loadedclass on thehtml` tag every few milliseconds, (so do polling basically? - and that is generally not good advice I learned recently) or could this be done better? (I'll also try this bare-bone approach and see where I get.)\nSince I am beginner not seeing the closing tag did confuse me a bit, not nit-picking here but learning.\nFind all this quite interesting and exciting, will make a few test-cases to compare, your feedback is invaluable, thank you (and I'll try hard to keep these message to a minimum size, thx 4 ur time)!. @zachleat Keeping the advice about not using such an approach in mind, thanks! Yes, seen font style matcher before, hmm so it really is about bringing text as soon as possible, meaning super fast.\nI would image this so not to loose the 1000ms attention span Google talks about. \"A white screen during this is going to be jarring.\" Ref. .. So no fading from white to site.. but the fading would indicate activity and create curiousness, similar to blur up technique used for images, no? Come on.. :(\nSomething like this, this or this is possibly asking too much waiting time from the user, right? Done properly it is what I am thinking of trying with web fonts. Oh well..\n@johanson Checked fontfaceobserver today and saw that also in Edge it does not work, it is not adding the fonts-loaded class. Nonetheless I will give it and webfontloader a try.. For anyone interested and following this here is a good write up on FOUT and FOIT and why one actually and still today has to choose between the two instead of trying to get rid of both. For me it was tough to understand that, besides using system fonts, there is no way of eliminating FOUT and FOIT altogether unless having the user experience suffer greatly.\nInterestingly enough there is a comment about what I am trying to do, fading fonts.. ",
    "Marabyte": "I stand corrected. The issue I was having was not because the order I load the scripts and the link but the scripts it self.\nI was loading the polyfill first and then the loadCSS function. In the polyfill code is explicit that it requires the loadCSS function but not on the documentation.\nI'll update my request.\n. ",
    "nigrosimone": "@scottjehl Any news on this PR?. same for me... . ",
    "janjaap": "@scottjehl Can this merge be tagged?. Anyone?. @scottjehl @zachleat ?. ",
    "johanson": "@vlrprbttst This is what onloadCSS.js is for? Make the plugin kick in after your CSS is fetched.\nAlso in the docs.\n. Check out the recommended usage pattern. This is probably the way to do it.\nThe documentation really is a bit sparse and difficult to understand at first.\nFrom my understanding and the way it works for me: \n- First the CSS file(s) you want to load <link rel=\"preload\" href=\"file.css\">\n- Then CSSrelpreload.js and after that loadCSS.js. Both inline to not make blocking, additional requests , and minified.\nCSS file needs to be before because calling CSSrelpreload and loadCSS, since there are some reported bugs if it is the other way around and it doesn't look like it has been fixed yet.\n. Print is non-blocking by default. I don't think you should use it with loadCSS.\nBut I it is useful if want to use media queries.\n. Print stylesheets are non-blocking by default. Include a stylesheet like you would normally do.\n. @diniscorreia Is there a reason you're not using the recommended method of using loadCSS?\nAny why are you then using rel=preload polyfill?\nWhat happens if you use fontfaceobserver after all the inline CSS?\n. @diniscorreia You have the timeout for fontfaceobserver 3000ms.\nMost likely, when testing on mobile (different network? slower?), it is not enough time (since the fonts are loaded async).\nrel=\"preload\" is not supported on iOS natively, hence it takes even more time compared to native support.\nUse Chrome dev console and emulate slow network and you can reproduce the bug. I don't think it has anything to do with loadCSS besides the fact it takes more time because you're not waiting for the fonts to load before rendering the page.\n. But the purpose of this project is to load CSS asynchronously.\nYou should inline your critical CSS for everything critical, above-the-fold content first. Everything that doesn't cause repaints. You can hide the elements you don't show in your inline CSS.\nBy the look of it, you don't need this project and you would be better off by loading your CSS in traditional (blocking) way.\n. @monolux You are over complicating things.\nfontfaceobserver will return a Promise that resolves when the font is available.\nvar lato = new FontFaceObserver('Lato');\nlato.load().then(function () {\n    document.documentElement.className += \" fonts-loaded\";\n});. Then what is the point of using this library?.\n",
    "chrisvanpatten": "I'm having some issues w/ this too. The onloadCSS method is a start, but not perfect. There seem to be a few milliseconds between when the callback is triggered and when the browser actually repaints the screen\u00a0(possibly also a delay in the initial CSS download too; I seem to have fewer issues when the CSS files are cached).\nA setTimeout delay is the easy way to fix this, but it's definitely not ideal. Obviously moving CSS that influences the JS calculations into your critical file is the best way to go, but that's not always possible.\nOne option I'm considering is setting a listener on a specific element and waiting for it to match specific CSS conditions that are included in the non-critical CSS file, then triggering an event when those conditions are met (e.g. every 10ms, check to see if div#check's offsetHeight is greater than 100px; if true, trigger event X; if false, keep checking). Not sure what the effect on performance would be, but it would work at least in theory.\n. ",
    "dep": "Thank you for the info. :)\n. Thanks for the reply. I saw that thread as well. I don't think so, as I think that thread was more related to two separate network requests happening for the same file. For this, there's only one network request.\n. ",
    "palma78": "Hi, \ni've resolv this problem white a changes of the link css mobile;\ni've adding  and the error is resolv.\nthanks for the script, works very well :)\nSalvatore\n. ",
    "ivnmaksimovic": "@dep Are the rules coming from the same file? Maybe the first set of rules is from critical css that you are inlining? Just a guess.. ",
    "marcelgwerder": "Had to move the loadCSS script before the link tags.\n. ",
    "yohannprigent": "Would it be possible to have a new release including this fix ?. ",
    "rkedde": "Thank's for your quick response. \n. ",
    "diniscorreia": "@zachleat \nApologies for the huge chunk of inline CSS and the mess with the JS, been trying everything for the last couple of hours: http://diniscorreia.com/debug/fontface.html\nIf I open it on iOS the fontfaceobserver Promise won't resolve (but the fonts do show up in the network tab); works fine on other browser. If don't call loadCSS, it works. \n. Quick update: weirdly enough, it almost seems like a race condition. If I test it locally with a local css file, it works most of the times (it still fails sometimes, but not as often).\n. @johanson I was, actually. I though it could be caused by it so I tried calling the function directly. \nJust updated the test case with the recommended method - same problem. \nThe order is now:\n- inline css\n- stylesheet link with rel=preload\n- scripts\n. @johanson tried that already - throttling set to 2G or GPRS and it stills works. Also tried on Safari (same wireless network than the iOS devices), which also doesn't support rel preload, and it works.\nAlso tried increasing timeout - no luck.\nBy the way, my font-face declarations are inlined on the critical css, so fontfaceobserver doesn't have to wait for the linked css to load. \n. Somehow this seems to be related to two Safari 10 font loading API bugs. \nfontfaceobserver was updated to disable native font loading on Safari 10.. ",
    "zenderol": "I can also confirm this issue. It happens only when using the included polyfil (cssrelpreload.js)\n. ",
    "zwacky": "I also implemented the loadCSS approach, but the pagespeed reporting (https://testmysite.withgoogle.com/intl/de-de) still said, I had blocking CSS.\nYou mentioned requestAnimationFrame, which was used in this approach that I used, and was successful with it:\n<script>\n        var cb = function() {\n            var l = document.createElement('link'); l.rel = 'stylesheet';\n            l.href = 'https://static.justwatch.com/static/compile_jw/assets/jw-webapp-0.11.112.css';\n            var h = document.getElementsByTagName('head')[0]; h.parentNode.insertBefore(l, h);\n        };\n        var raf = requestAnimationFrame || mozRequestAnimationFrame || webkitRequestAnimationFrame || msRequestAnimationFrame;\n        if (raf) {\n            raf(cb);\n        } else {\n            window.addEventListener('load', cb);\n        }\n    </script>\n. ",
    "shrpne": "@scottjehl \n\nIt's true that Pagespeed Insights has had trouble identifying loadCSS as async in some implementations. In the past, the team flagged this as a PSI bug, but you can verify that it does indeed request asynchronously when tested.\n\nLooks like Pagespeed still have this problem. Could you specify link to the issue please. And may be loadCSS can introduce some workaround to it?. @liltinkerer as I know, pagespeed result affects Google search position. > Pagespeed Insights has had trouble identifying loadCSS as async in some implementations.\nAccording to https://github.com/filamentgroup/loadCSS/issues/193#issuecomment-257614725\nBTW, I'm experiencing same issue and wonder if it can be fixed. ",
    "sscho": "Thanks, makes sense. I'll go back to using CSS the pleb way. \n. ",
    "gravyraveydavey": "It sounds like you were missing the polyfill, which just caught me out also. If you're using bower to include loadcss be sure to also include the polyfill adding it to your bower overrides.\n\"loadcss\": {\n      \"main\": [\n        \"./src/loadCSS.js\",\n        \"./src/cssrelpreload.js\"\n      ]\n    }, . ",
    "aastik1208": "loadCSS(\"<%= stylesheet_path('application') %>\");\nThis code is not interpreted in safari, how to write this.. ",
    "inoas": "So you expose cssrelpreload / preloadCSS? and onloadCSS.\nAt least for me the docs where not lacking so I was wondering why the note was there?!. ",
    "TimJans": "update: not a loadCSS but a critical css issue. google page score improved once i optimized the critical path inline css. . ",
    "robertfausk": "Are there any updates on this?. Tests should pass after #248 is merged.. ",
    "philsawicki": "@scottjehl As a frequent user of the crossorigin and integrity attributes for security considerations, I would vote in favor of supporting an object argument, as you mention. \nThis would offer support for attributes already in the specification while also making it possible to support additional ones in the future without needing to update the implementation of the loadCSS function.\nFor an example of the growing popularity of these, Bootstrap uses both the crossorigin and integrity attributes in their samples.:\nhtml\n<link\n  rel=\"stylesheet\"\n  href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\"\n  integrity=\"sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm\"\n  crossorigin=\"anonymous\">. Great!. ",
    "t-kelly": "Thanks for the confirmation, Scott!. ",
    "reepush": "@scottjehl yes, good work!. ",
    "Loque-": "Where?. ",
    "szepeviktor": "Thanks.\nSo you are adding the link element to <body>?. Thank you very much for this blog post!. ",
    "cadencelabs-master": "Do you think so? They have explicit notes that this is intended behavior (replacing preload hints with page headers). The problem is that the loadCss recommended implementation uses preload tags in a way which mod_pagespeed doesn't perceive them (mod_pagespeed's opinion is that a preload tag won't later become a stylesheet tag). . It does not -- that's the problem. It thinks rel=\"preload\" is just hinting to the browser to load the resource, but that it will be applied by some user action or javascript code. \nI went ahead and opened a thread on pagespeed -- considering that onload=\"\" is a valid attribute for <link tags I think their engine ought to look at that tag to see if the \"preload\" may become something else once it's loaded. This was the post I made: https://groups.google.com/forum/#!topic/mod-pagespeed-discuss/6_JlG7Q8zO8\nBTW, I've been using the below script as a work around. It allows you to use rel=\"pagespeed-preload\" if using mod_pagespeed\nBelow JS supports link tags like this:\n<link rel=\"pagespeed-preload\" onload=\"this.rel='stylesheet'\" as=\"style\" href=\"/path/to/stylesheet.css\" />\n<script data-pagespeed-no-defer type=\"text/javascript\">\n    !function (t) {\n        if (t.loadCSS) {\n            var e = loadCSS.relpreload = {};\n            e.pagespeed = function () {\n                for (var e = t.document.getElementsByTagName(\"link\"), r = 0; r < e.length; r++) {\n                    var n = e[r];\n                    \"pagespeed-preload\" === n.rel && \"style\" === n.getAttribute(\"as\") && (t.loadCSS(n.href, n, n.getAttribute(\"media\")), n.rel = null)\n                }\n            };\n            e.pagespeed();\n            var pagespeedR = t.setInterval(e.pagespeed, 300);\n            t.addEventListener && t.addEventListener(\"load\", function () {\n                e.pagespeed(), t.clearInterval(pagespeedR)\n            }), t.attachEvent && t.attachEvent(\"onload\", function () {\n                t.clearInterval(pagespeedR)\n            });\n        }\n    }(this);\n</script>. This is a bug in pagespeed, not loadCss\nDo you know where to add that ticket? I started a discussion in the google group to no response from the Pagespeed Team. @Enalmada Use the hack I posted above and change rel=\"preload\" to rel=\"pagespeed-preload\"\nThat will load all the deferred css via javascript (so you do sacrifice the native preload functionality) but it's the only way to make it work with Mod Pagespeed -- you'd need to disable any filter that affects CSS resources which would be way more harmful to performance. ",
    "kwisatz": "I ran into this issue, but luckily found your thread.. ",
    "Enalmada": "I just ran into this too.  Is this a bug in pagespeed or loadCSS?  Should we make sure mod-pagespeed has a ticket?\n. I assume here: https://github.com/pagespeed/mod_pagespeed/issues.  . @cadencelabs-master You mentioned in your first post that you can disable this pagespeed feature.  Do you remember how?  I'm trying to figure out what filters cause it and while testing...it seems like lots of important filters trigger it.   \n. @cadencelabs-master Ok well that hack seems to work, so +1Billion to you for posting that here for all us loadCSS pagespeeders.  . @cadencelabs-master I think you are the expert on this, can you comment on the question of performance vs breaking?  My use case is a bit nonstandard...I was testing turbolinks plugin locally and found that it loads \"rel=preload onload=...\" css out of order with inlined css in the head.  But I couldn't create a public test case for turbolinks (https://www.gell.com/turbolinks) because this pagespeed issue didn't allow me to reproduce the turbolinks issue on production.  . ",
    "oschaaf": "Hi all - I filed https://github.com/pagespeed/mod_pagespeed/issues/1621 for tracking this on the mod_pagespeed side. ",
    "jmarantz": "Just to clarify: is this a performance issue or does this break observable page behavior?  I'm trying to determine if PageSpeed can resolve the issue by learning whether the preloaded source ever got renamed in the recent past, and storing that in a server-side cache.\nhttps://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content suggests that preload hints must be paired with rel=stylesheet link, and if the preload hint was stripped (eg due to cold server cache) it shouldn't break the page, just make it slower.\nDoes loadCSS do something to make the preload-link functionally required?. ",
    "bekh6ex": "For those who ran into this issue and looking for solution, stripping can be disabled with following Apache config:\n```apache\nModPagespeedPreserveSubresourceHints On\nor\nModPagespeedCssPreserveURLs On\n```. ",
    "kitajchuk": "Ah, thanks @NekR . My bad :/\n\ud83d\udc4d . ",
    "JacobDB": "Quick update: I had to disable this stuff because the site is live, but if you need me to set up a test case, just let me know.. ",
    "erykpiast": "Yeah, I know how to workaround, but I don't think it's the right way, to do workarounds. Many packages I use on daily basis distributes compiled/minified files along sources (I've never been caring about it, but apparently the day came) so I think it's perfectly possible to do it here as well.\nFor me, personally, this package is kind of special. It's not a part of my front-end codebase (so there is no minification/build process for it), but it's just read as a file and injected to HTML on backend side. That's why it's easier for me to keep the file in repository in old-fashioned way than create build pipeline especially for this package. . ",
    "holtkamp": "Maybe the scripts part of this file can help as inspiration? \nhttps://github.com/longbill/jquery-date-range-picker/blob/master/gulpfile.js. ",
    "csswizardry": "Whilst not a bad idea, I worry about putting critical (as in, on the critical path, as opposed to \u2018important\u2019) code on an external domain. The network overhead (DNS, TCP, TLS), particularly on high-latency connections, could introduce a slowdown greater than the one loadCSS is trying to mitigate.\nIt is in my opinion\u2014and past experience\u2014that critical resources such as these should be served from the host domain whose connection is already open. I\u2019d be very interested in the discussion around this, though!. ",
    "evromalarkey": "It's now on jsdelivr or npm https://cdn.jsdelivr.net/npm/fg-loadcss@2.0.1/src/cssrelpreload.js. yeah, I'm using it only to fetch it with php and inline as css (or you can http/2 push it), it's much easier to maintain versions this way.. ",
    "midzer": "I think a better approach is to prefetch a theme stylesheet and apply it to head immediately if necessary. This will prevent any unwanted flashing of your overriden main.css\n<link rel=\"stylesheet\" href=\"/path/to/main.css\">\n<link rel=\"prefetch\" id=\"theme-link\" href=\"/path/to/theme.css\">\n<script>\nif (localStorage.getItem('theme') == 'yourTheme') {\n  document.getElementById('theme-link').rel = 'stylesheet';\n}\n</script>. ",
    "jvilk": "@lencioni See discussion in PR. You may need to fix this issue in your code that uses loadCSS.. The CI failure seems independent of this change. This is ready for review, as far as I can tell.. I have added a test, and modified the tests to clean up the DOM to prevent spurious test failures.. Fair enough. I'll leave this here for you and the community to decide.. ",
    "lencioni": "Yes, that definitely makes sense. Easy enough for us to guard against.\nIt would probably be worth adding a note to the readme, and it might be worth adding a dev-only check in here that gives a console warning to help people notice and avoid this issue.. ",
    "NeoGenet1c": "I'm having a very similar issue (FF56, Mac OS 10.12).\nWhen I clear browser's cache and load all the page for the 'first time', the styles will not load. If I reload, the styles will load properly.. @duply Very good idea, the onerror callback does work.\nI think it's because the 'preload' is enabled in FF, so the execution of loadCSS is completely bypassed and FF triggers 'onerror' callback once it (incorrectly) fails to load the styles.\nNot nice, but does the job for me.. ",
    "duply": "Apparently Firefox currently only supports preload for cachable resources.\nSee: https://caniuse.com/#search=preload https://bugzilla.mozilla.org/show_bug.cgi?id=1222633 \nI think the issues might be related to Firefox trying/failing to determine if the resource is cache-able due to slow response or the resource really not being cache-able.\nIf the resource is determined non-cacheable the onload callback is never fired. In case of loadCSS the rel=\"preload\" will not be switched to \"stylesheet\".\nIf you implement the preload as suggested at https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content you at least have the \"regular\" link element as fallback.\nMaybe for loadCSS some similar fallback needs to be done in such cases? E.g. by adding the onerror trigger? So:\n<link rel=\"preload\" href=\"path/to/mystylesheet.css\" as=\"style\" onload=\"this.rel='stylesheet'\"  onerror=\"this.rel='stylesheet'\">\nSomeone already opened a bug for this on Bugzilla as well:\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=1405761. ",
    "andfinally": "It does! I've amended the change to that.. ",
    "Mike667": "sorry, fixed, before loadcss polyfill need to connect loadcss script.\nsee example https://master-origin-loadcss.fgview.com/test/preload.html. @JMPerez im return old style\n<link rel=\"stylesheet\" href=\"css/style.css\">\nbecause i have issues with JS in old and mobile browsers and styles don't include to page.\nNow i paste <link rel=\"stylesheet\" href=\"css/style.css\"> in head or after body and its okay for me. Google page insigns show 90+ bal.\n  . ",
    "rfgamaral": "I have a feeling that I'm having a similar issue as I posted here: addyosmani/critical#251.. ",
    "JMPerez": "@Mike667 According to pagespeed there are only 2 blocking CSS.\n\nYour page has 2 blocking CSS resources. This causes a delay in rendering your page.\n\nDid you update anything?. @u007 I'm checking and you are right. On the browser and webpagetest the CSS is only requested once.\nI'm not sure if this issue should be kept open, as it seems to be something on pagespeed's side.. It also happens with https://fonts.googleapis.com/css?family=Open+Sans:300,400,600. It actually shows it 3 times.\n\nI tried with the demo page but it doesn't show that section, probably because it needs to request more CSS resources to show up.\n. @rasenplanscher It doesn't happen anymore. However, I just browses the initial payload for nurture.ai and can't see the loadCSS function anymore. \nI know https://www.smashingmagazine.com/ uses a similar function and PageSpeed Insights doesn't report render-blocking issues on that site.. ",
    "Moldjuice": "Hi everyone,\nFollowing the implementation of loadCss on a website, I notice that the PageSpeed Insights test declares twice my CSS as a blocking resource above the flotation line.\nI have two styles sheet loaded in my head.\n\nAn external fontawesome css\nmy style sheet main.min.css\n\n<head>\n<link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.3.1/css/all.css\" integrity=\"sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU\" crossorigin=\"anonymous\">\n<link rel=\"preload\" href=\"<?php echo $baseUrlCss ?>/main.min.css\" as=\"style\" onload=\"this.onload=null;this.rel='stylesheet'\">\n<noscript><link rel=\"stylesheet\" href=\"<?php echo $baseUrlCss ?>/main.min.css\"></noscript>\n<script>!function(t){...}</script>\n<style>body{background-color:#fff;}</style>\n<script></script>\n</head>\nI simulate a critical css (which I have not set up) within style tag.\nPageSpeed Insights returns 3 blocking resources above the float line e (fontawesome css makes sense since I do not include it in my tests) but there are two times my personal style sheet.\nSomeone would have any idea ?\nRegards,. ",
    "thealkimist": "@scottjehl, thanks Scott. Apologies for the dupe.. ",
    "robertomatute": "@scottjehl I try the new version and everything work fine!\nThanks for your fast response!\nDo you have any timeline for make 2.0.0 the latest release?\nBest Regards. ",
    "optimalisatie": "The following may work:\n```javascript\n// add viewport watch to load stylesheet on viewport change\n// Chrome doesn't load rel=\"preload\" when the viewport changes\n// matchMedia support\nvar matchMedia = window.matchMedia || window.msMatchMedia;\n// rel=\"preload\" with media=\"\" that does not match viewport\nif (media && ['all','print'].indexOf(media) === -1 && matchMedia && !matchMedia(media).matches) {\nvar mediaWatcher = function() {\n    // @todo add throttle\n\n    // viewport matches media query\n    if (matchMedia(media).matches) {\n        sheet.rel = 'stylesheet';\n    }\n\n    // also unwatch if already loaded\n    if (sheet.rel === 'stylesheet') {\n        // window.removeEventListener;\n    }\n}\n\n// @todo cross browser\nwindow.addEventListener(\"orientationchange\", mediaWatcher, false); \nwindow.addEventListener(\"resize\", mediaWatcher, false);\n\n}\n``. It appears that Chrome doesn't downloadrel=\"preload\"` resources that do not match a media query, potentially saving traffic. If the preload polyfill would provide a fix then it would provide a significant performance advantage in Chrome and maybe other browsers (60% of all browsers).\nMozilla describes it as following indicating that it's the intended functionality:\n\nOne nice feature of <link> elements is their ability to accept media attributes. These can accept media types or full-blown media queries, allowing you to do responsive preloading!\n\nhttps://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content\nResponsive preloading is an optimization technique with quite some potential for responsive designs that are optimized for every possible device and usage scenario.\nOn mobile the first page load speed is sometimes what matters. An option to save 100kb CSS using a responsive preload is something that could be of significance. It would be nice if loadCSS would be a solution that would make it possible.. Based on this bug report/discovery, we created a solution for responsive CSS loading, rendering and unrendering. It is integrated in our new advanced CSS optimization plugin for WordPress. \nhttps://github.com/o10n-x/wordpress-css-optimization. ",
    "radum": "@scottjehl Did you managed to file a bug for this yet?\n@optimalisatie It can't really be intended functionality, because if you are on a tabled that on portrait loads a CSS file based on the media query and on landscape loads another one, it will fail.\nI also think loadCSS should actually cater for this bug.. ",
    "u007": "but works great on browser\n. nice :),\nthanks for checking it out, yes i suspect its google pagespeed issue.\ni feel the site is fast enough, but somehow it still complaints on pagespeed. ",
    "j-pinder": "The minified file returns an error in the console \"!undefined is not an object(evaluating t.loadcss)  in Safari. The CSS fails to load in Safari, where JS is enabled.\nGoogle Chrome the error reads \"Uncaught TypeError: Cannot read property 'loadCSS' of undefined\n    at load.js:10\n    at load.js:100\". Google Chrome loads the CSS using rel=\"preload\".\nI've minified the code with Codekit and Javascript Minifier online. I've also linked to this CDN link, which the minified code is the same as what I've created from the above-mentioned and also has an error.\nI'm trying to find a way to minify the file while maintaining functionality. If it has worked for you, can you advise, and maybe assist in pointing out what might be the cause.. ",
    "gaaarg": "Hello,\nAny updates about this issue ?\nIs it something the filamentgroup will plan to fix?. FYI\nIt was said in the #262  discussion that the  918a331 resolve also this issue. I test it and it works fine in FF 41. \nSo it seems that using the last version of the master branch (but not tagged) fix this.\nAny reason why this commit has not been tagged ?\nLink to the CSS PreLoad function that I used:\nhttps://github.com/filamentgroup/loadCSS/blob/918a3318f055002b4bee729840e420e057637c7a/src/cssrelpreload.js\n. @rasenplanscher we update to v 2.1.0 and seems to works fine in FF41 & IE 11. ",
    "ryantoft-gm": "Usage on FF 41 and earlier is going to be low. But the fact that it crashes the whole browser is pretty rough.\nFor what it's worth it looks like the issue was introduced in this commit - likely related to the way the load handlers were changed: https://github.com/filamentgroup/loadCSS/commit/afa545b4a0c11bf1b9711b563c7422dfffb74724\n. From my brief testing https://github.com/filamentgroup/loadCSS/commit/918a3318f055002b4bee729840e420e057637c7a appears to also resolve issue #261 - related to older Firefox crashing.. ",
    "sithmel": "Sorry for being disappeared for a while. I am not able to reproduce the issue in exactly the same conditions.\nI trust @ensemblebd test.\nOnly one thing: https://github.com/filamentgroup/loadCSS/commit/918a3318f055002b4bee729840e420e057637c7a looks like a sensible safety net. Why not applying it anyway ?. ",
    "thasmo": "Just for the record, onload=\"this.onload=null;this.rel='stylesheet'\" worked for me too although it would be nice if a safety net would be baked in; maybe #267 is actually about it, so we don't need this.onload=null at all?. ",
    "pldg": "I had the same issue.  An infinite loading loop on Internet Explorer and Edge.\nThe problem was caused by an imported webfont in css.\nThe solution is to remove the import statment from css ~~@import url('https://fonts.googleapis.com/css?family=Montserrat');~~ and use the link tag in html <link href=\"https://fonts.googleapis.com/css?family=Montserrat\" rel=\"stylesheet\">.. ",
    "futtta": "to quote from a response in another issue:\n\nloadCSS is designed to help load CSS files that are not critical to the initial rendering of the page, and instead desirable to load in an asynchronous manner.\n\nThe green background very likely is considered critical by Chrome Lighthouse and hence the (final) rendering of the page requires the (slow loading) CSS-file. You would typically add \"critical CSS\" inline to allow the rendering of the (above the fold part of the) page to fix this.. Tested w. FF 59.0.2 on Ubuntu, but cannot reproduce either.. Over the weekend Google made changes to the GPSI algorithm which resulted in a massive drop in mobile scores and this seemed to be related with above \"defer unused CSS\" issue. The changes seemed to have been rolled back now, but this is likely to remain an issue and the significant score-impact (however un-important in the real world) could obviously come back at some point.\nOne of Autoptimize's users (thanks pratham2003!) linked to this great code snippet in a StackOverflow q/a which at first sight seems a perfect fix to this problem: it does not preload so the CSS loading is really deferred, but listens to load or scroll-events to load CSS and uses requestanimationframe. This technique could be combined with something like <link rel=\"deferload\" iso preload but without the onload attribute to keep it somewhat inline with the current implementation?\nTo what extent are you open to going down that road @scottjehl ?. it does; AO uses loadCSS to load the full aggregated CSS in a non-render blocking manner :-). > It's for this reason that we've kept loadCSS.js in the codebase here. You can still choose to call loadCSS( url ) if you'd rather and the stylesheet will load at a lower priority than preload typically will. You can also call loadCSS at any later time that makes sense to your page, such as after a particular event. Onload for example.\nWell, ideally loadCSS could be called with a parameter to specify the rel on which to act (as 2nd param, used, the first one is for URL would have to remain for backwards-compatibility), in which case we could have rel=\"deferredload\" and loadCSS acts on that as it does not on rel=\"preload\"? . @azhuchkov not really relevant in this issue, but you can change the \"injection point\" for the full CSS with this code snippet that hooks into AO's API;\nphp\nadd_filter('autoptimize_filter_css_replacetag','inject_css_in_footer');\nfunction inject_css_in_footer() {\n  return array('</body>','before');\n}\nThis is very unlikely to make a difference to GPSI though :-). ",
    "zalog": "Great!\nSome plans about bower?. ",
    "thierno2018": "Hello, \nI really appreciate your work on this loadCSS project. Indeed, it will be more interesting to integrate the badges (npm, dependencies, devDependencies) in the Readme.md file, in order to have an overview of the dependencies of the project, the version used and the latest available version.. ",
    "WebSavvyGuy": "Does this thing still work?  why is it deprecated?. ",
    "MatTeague": "I'm getting the same warning when using the 'How To Use loadCSS (Recommended example)' . So I would also like to know the answer to this.. ",
    "caub": "@rasenplanscher seems you're right, I must have messed up, the warning was from another asset, not loaded with loadCSS https://codesandbox.io/s/4w6n35jjjw\nmy note concerns the API, it's pretty hard to insert the CSS at the end of the document head for example\nSomething like:  a loadCSS(url, container, mode) would be useful\njs\nloadCSS('https://fonts.googleapis.com/icon?family=Material+Icons', document.head, 'append');\nwhere mode would be append/prepend/before/after, default to after\n. ",
    "leonmondria": "This apprears to be fixed in Safari release 53:\nhttps://developer.apple.com/safari/technology-preview/release-notes/:\nFixed loading the stylesheet when changing the  element rel attribute from preload to stylesheet. The demo works like a charm, seems that the combination preload + swap is 'fatal' on iphone 6 + ios 11.3. \nIf the stylesheet is included with  it does work (GO APPLE).\nIf you run the css through https://jigsaw.w3.org/css-validator/ that will also fail so maybe the swapping does some sort of validation in that IOS/iphone combo?\nAnyway, now it's a known problem so if i get customer questions, i tell them to update their phone.. ",
    "azhuchkov": "To be honest I was surprised when I enabled above-the-fold feature at Autoptimize plugin and then found link=\"preload\" at stylesheet declaration. And my question was\n\nWhy preload something that proposed to be deferred?\n\nLooking at outdated PSI manual we see this:\n\nThe critical styles needed to style the above-the-fold content are inlined and applied to the document immediately. The full small.css is loaded after initial painting of the page. Its styles are applied to the page once it finishes loading, without blocking the initial render of the critical content.\n\nBut preload spec states that the main preload purpose is not asynchronous loading, but fetching (usually critical) resources as early as possible.\nMaybe this is not a problem on HTTP 1.1 when browser can freely establish up to 6 connections, but HTTP/2 multiplexes all requests into single connection and highly prioritized request of non-critical CSS actually blocks browser from pulling images to complete the first painting. The bigger CSS file, the longer user waits for drawing completion.\nSo, it's not about useless scoring at PSI - non-critical CSS should be definitely deferred instead of being preloaded.. @scottjehl Since I saw the screenshot with autoptimize_***.css at the top, I decided it depends/relates to loadCSS somehow. Now I see it doesn't. My fault, sorry.. > it does; AO uses loadCSS to load the full aggregated CSS in a non-render blocking manner :-)\nOuch... =)\n~~Isn't there some inconsistency between rel='preload'  and onload='this.rel=\"stylesheet\"'? Like, I want to fetch this resource before any others, but will use it after everything else is loaded.~~\n@futtta Have you tried to just add CSS definition to the bottom of the page like Google PSI manual suggests? Frankly speaking, I do not understand all the JS magic they use. Particularly, I wonder why they use load event if browser does not support requestAnimationFrame instead of just loading it immediately and how requestAnimationFrame helps if browser hasn't loaded the stylesheet yet. Anyways, does this way of loading has significant drawbacks?. Sorry, I was wrong about onload in my previous message.. ",
    "snake-345": "I'm not sure could it help with your problem or not. But just read this issue https://github.com/GoogleChrome/lighthouse/issues/6588\nWhen I read this I figured out that problem not in css blocking, but problem with excess styles for certain page.. ",
    "cagross": "OK thanks for that clarification.. ",
    "remyabel": "\nDo you get an error from link.setAttribute( \"onload\", null );?\n\nCorrect. The error is \"Content Security Policy: The page\u2019s settings blocked the loading of a resource at inline (\u201cscript-src\u201d).\" and points to line 85 in the script.\n\nAlso, what would be the point with null?\n\nBecause the attribute becomes onload=null, so you need to hash null. Just as you would need to hash any other value that would go there.\n\nIf you can do that, why is onload=... a problem for you?\n\nAs pointed out above the primary problem is that being able to do this is actually non-standard and so it doesn't work in Chromium (yet). I was wondering if there was any way to workaround this without having to wait a while.. > Finally: At present, only Chrome/Chromium supports rel=preload natively, so that's where the onload attribute is actually most important.\nYou're right, I'm an idiot. I forgot the onload workaround is used for browsers that don't support preload. Thanks for the detailed response.. Sorry, I was confusing myself. So:\nlink.setAttribute( \"onload\", null );\ncan be replaced with:\nlink.onload = null;\nAs far as I'm aware, this is functionally equivalent and no hashing is required.\nThe larger problem is that we cannot currently use onload=\"this.onload=null;this.rel='stylesheet'\" with CSP in Chromium until unsafe-hashed-attributes or similar is supported in a non-experimental release. There was an attempt to attach onload programmatically but the user claims the approach has issues. \nSo I agree that loadCSS cannot do anything, but I still think replacing setAttribute will solve a minor inconvenience.. ",
    "dracos": "It is detachEvent, not removeEvent.\nI have included this commit to prevent potential hanging browsers, at least IE8 and 9 \u2013 I do have this.onload=null also, but it wasn't clear whether this completely fixed the hanging or not, I think I had a hang happen anyway, so better safe than sorry. The old version (using loadCSS) that loaded a new <link> never hanged, but did load the styles in the wrong order in IE8/9 (even though it was inserted earlier, the styles loaded as if they were later).\nSadly loading a stylesheet using either method in IE8 applies print-only styles within the stylesheet as if the @media print wasn't there, which was confusing for a while. Sigh. Just going to hide the whole thing from IE8 now.. "
}