{
    "malcommac": "Hi,\nI've fixed the bug and now it should works fine.\nSwiftDate 1.0.3 reference commit is here: cc2432dd0dfa6ddfdf69fa68f61ce922fe7e5ed0\nPlease be sure to check your current system NSLocale format in order to get the correct results (ie. Italy's first weekday is Monday and not Sunday)\n. Great addition Mark, thank you!\n. I've created a per-thread cache for NSDateFormatter.\nIt was published with 5d5f25abf6fda25358bb55fe25fbad316fa6801d and available via cocoapods as 1.0.5.\nBasically I save and retrive the object from inside the NSThread dictionary; this ensure you to get the instance relative to that thread called only once. It should be enough, tell me if you have problems.\n``` swift\nprivate class func cachedObjectInCurrentThread(key: String, create: () -> T) -> T {\n    if let threadDictionary = NSThread.currentThread().threadDictionary as NSMutableDictionary? {\n        if let cachedObject = threadDictionary[key] as! T? {\n            return cachedObject\n        } else {\n            let newObject = create()\n            threadDictionary[key] = newObject\n            return newObject\n        }\n    } else {\n        assert(false, \"Current NSThread dictionary is nil. This should never happens, we will return a new instance of the object on each call\")\n        return create()\n    }\n}\nprivate class func localThreadDateFormatter() -> NSDateFormatter {\n    return NSDate.cachedObjectInCurrentThread(\"com.library.swiftdate.dateformatter\") {\n        let dateFormatter = NSDateFormatter()\n        dateFormatter.dateFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"\n        return dateFormatter\n    }\n}\n```\n. I plan to set the minimum req for SwiftDate to iOS8+, so your fix should be enough.\n. I've declared them as public in 5d5f25abf6fda25358bb55fe25fbad316fa6801d (1.0.5 in cocoapods).\nTell me if it works for you.\n. Okay just merged, thank you\n. yup, pushed 1.0.6 right now\n. Just fixed the issue with operator and calendar types, seems to be an issue related to copy() overrides in CalendarTypes subclasses.\nI'm looking to see for .add() method right now.\n. meanwhile that's the first commit: 08ee60963ce87d056c2de2affa7c68d5c9ef9b21\n. That's the other commit: e184276a5fc895f1837a2204c07b7a1ed10bf38a\n. Sure, 1.0.7. Thank you for your reports, I did not have not enough time right now to make unit tests for this library so your report are really valuable\n. They are now all optionals, thanks.\n. Shame on me, I think you will find several other similar issue around. This is my first attempt to make a Swift lib\n. 1.0.8 just published\n. It should be:\ntoString(format: DateFormat.Custom(\"YYYY\"))\nDateFormat types includes AltRSS,RSS,ISO and Custom format (a string as above).\nFixed ReadMe.\n. Thank you @toriaezunama :)\n. It's the right thing to do ;-)\n. Hi @simonrice,\nThank you for your report and compliments :-) so you are asking about making a public version of the firstWeekDate() method, right? (and add another lastWeekDate())\nnext/last(.DayOfTheWeek) could be a great addition. Have you already some code about that your it's a feature request?\n. Yeah, I think it could be a great addition and if you have time to work on it now I'll be more than happy to merge your work into the main branch of the library. Otherwise I'll need some time to add these features due to some work commitments into the following two weeks.\n. I'm planning to add it later this week. Meanwhile I'll close this issue; discussion can continue here at issue #45 \n. Thank you for your report. Seems to be an issue related to deprecated 'week' property of the NSDateComponent class. I've just made a commit here and tested with iOS 8.3 63bffa881c6c1520522d89209156a100603ea0ec. Can you make another check with your device?\n. Great :) Again, thank you for your bug report\n. Mhhh, sorry I can't understand. Your test example is in english, and it uses the default date formatter so should work even with other langs. Can you provide more infos? thx\n. Thank you^\n. We have a initial pull requested merged in swift-2 branch to test:\nhttps://github.com/malcommac/SwiftDate/tree/swift-2.0\nSend your feedback & reports.\nThanks\n. You need to add import SwiftDate at the top of your implementations \n. Are you using it via CocoaPods?\n. Cannot reproduce the same problem. Here it works fine (added import SwiftDate); can you make a small project?\n. Thank you for your addition\n. Library should not be related to any language, it's a date manipulation library and it must remain independent.\n. Can we merge it in another branch? something like swift-2 branch?\n. I've created a swift2 branch; https://github.com/malcommac/SwiftDate/tree/swift-2.0. You can make a pull request on it.\n(And btw, thank you for your help!)\n. Hi,\nCan you paste here your code? thanks\n. Are you using SwiftDate from CocoaPods?\n. It should be an outdated version compared to the master one and this error should be a duplicate of this: https://github.com/malcommac/SwiftDate/issues/15.\nHowever at this time I can't update cocoapods version with a new 1.0.11 build due to a GitHub's API error (I'll try to do it later today); however if you want to test, try to download the master release package and use it; everything should be ok.\n. Just posted 1.0.11 to cocoapods\n. Thanks for your report\n. Just merged. Thank you :)\nI'm thinking to merge all these comparing methods in a single call.\nCould be something:\nswift\nlet isSameYear = date.compare(\"year\",anotherDate)\nWhat do you think?\n. Well, right, enum is a more robust solution of course.\nAnyway I think you can obtain the same result using date.year == anotherDate.year so I'm really torn about it. Could be more useful when grouping multiple components to compare in a single call.\n. Thanks\n. It's a mistake; day of the month format is dd not DD. Just fixed it into the doc.\nI've also added a summary sheet with all available formats strings into the README.md file.\n(The following table is copied from this original article)\n| Field | Symbol | No | Example | Description |\n| --- | --- | --- | --- | --- |\n| era | G | 1..3 | AD | Era \u0110 Replaced with the Era string for the current date. One to three letters for the abbreviated form, four letters for the long form, five for the narrow form. |\n|  |  | 4 | Anno Domini |  |\n|  |  | 5 | A |  |\n| year | y | 1..n | 1996 | Year. Normally the length specifies the padding, but for two letters it also specifies the maximum length. Example: |\n|  | Y | 1..n | 1997 | Year (in \u0147Week of Year\u00d3 based calendars). This year designation is used in ISO year-week calendar as defined by ISO 8601, but can be used in non-Gregorian based calendar systems where week date processing is desired. May not always be the same value as calendar year. |\n|  | u | 1..n | 4601 | Extended year. This is a single number designating the year of this calendar system, encompassing all supra-year fields. For example, for the Julian calendar system, year numbers are positive, with an era of BCE or CE. An extended year value for the Julian calendar system assigns positive values to CE years and negative values to BCE years, with 1 BCE being year 0. |\n| quarter | Q | 1..2 | 02 | Quarter \u0110 Use one or two for the numerical quarter, three for the abbreviation, or four for the full name. |\n|  |  | 3 | Q2 |  |\n|  |  | 4 | 2nd quarter |  |\n|  | q | 1..2 | 02 | Stand-Alone Quarter \u0110 Use one or two for the numerical quarter, three for the abbreviation, or four for the full name. |\n|  |  | 3 | Q2 |  |\n|  |  | 4 | 2nd quarter |  |\n| month | M | 1..2 | 09 | Month \u0110 Use one or two for the numerical month, three for the abbreviation, or four for the full name, or five for the narrow name. |\n|  |  | 3 | Sept |  |\n|  |  | 4 | September |  |\n|  |  | 5 | S |  |\n|  | L | 1..2 | 09 |  |\n|  |  | 3 | Sept |  |\n|  |  | 4 | September |  |\n|  |  | 5 | S |  |\n|  | l | 1 | * | Special symbol for Chinese leap month, used in combination with M. Only used with the Chinese calendar. |\n| week | w | 1..2 | 27 | Week of Year. |\n|  | W | 1 | 3 | Week of Month |\n| day | d | 1..2 | 1 | Date \u0110 Day of the month |\n|  | D | 1..3 | 345 | Day of year |\n|  | F | 1 | 2 | Day of Week in Month. The example is for the 2nd Wed in July |\n|  | g | 1..n | 2451334 | Modified Julian day. This is different from the conventional Julian day number in two regards. First, it demarcates days at local zone midnight, rather than noon GMT. Second, it is a local number; that is, it depends on the local time zone. It can be thought of as a single number that encompasses all the date-related fields. |\n| week day | E | 1..3 | Tues | Day of week \u0110 Use one through three letters for the short day, or four for the full name, or five for the narrow name. |\n|  |  | 4 | Tuesday |  |\n|  |  | 5 | T |  |\n|  | e | 1..2 | 2 | Local day of week. Same as E except adds a numeric value that will depend on the local starting day of the week, using one or two letters. For this example, Monday is the first day of the week. |\n|  |  | 3 | Tues |  |\n|  |  | 4 | Tuesday |  |\n|  |  | 5 | T |  |\n|  | c | 1 | 2 | Stand-Alone local day of week \u0110 Use one letter for the local numeric value (same as \u00d4e\u0150), three for the short day, or four for the full name, or five for the narrow name. |\n|  |  | 3 | Tues |  |\n|  |  | 4 | Tuesday |  |\n|  |  | 5 | T |  |\n| period | a | 1 | AM | AM or PM |\n| hour | h | 1..2 | 11 | Hour [1-12] |\n|  | H | 1..2 | 13 | Hour [0-23] |\n|  | K | 1..2 | 0 | Hour [0-11] |\n|  | k | 1..2 | 24 | Hour [1-24] |\n|  | j | 1..2 | n/a | This is a special-purpose symbol. It must not occur in pattern or skeleton data. Instead, it is reserved for use in APIs doing flexible date pattern generation. In such a context, it requests the preferred format (12 versus 24 hour) for the language in question, as determined by whether h, H, K, or k is used in the standard short time format for the locale, and should be replaced by h, H, K, or k before beginning a match against availableFormats data. |\n| minute | m | 1..2 | 59 | Minute. Use one or two for zero padding |\n| second | s | 1..2 | 12 | Second. Use one or two for zero padding. |\n|  | S | 1..n | 3456 | Fractional Second \u0110 truncates (like other time fields) to the count of letters. (example shows display using pattern SSSS for seconds value 12.34567) |\n|  | A | 1..n | 69540000 | Milliseconds in day. This field behaves exactly like a composite of all time-related fields, not including the zone fields. As such, it also reflects discontinuities of those fields on DST transition days. On a day of DST onset, it will jump forward. On a day of DST cessation, it will jump backward. This reflects the fact that is must be combined with the offset field to obtain a unique local time value. |\n| zone | z | 1..3 | PDTfallbacks:HPG-8:00GMT-08:00 | Time Zone \u0110 with the specific non-location format. Where that is unavailable, falls back to localized GMT format. Use one to three letters for the short format or four for the full format. In the short format, metazone names are not used unless the commonlyUsed flag is on in the locale.For more information about timezone formats, see Appendix J: Time Zone Display Names. |\n|  |  | 4 | Pacific Daylight Timefallbacks:HPG-8:00GMT-08:00 |  |\n|  | Z | 1..3 | -0800 | Time Zone \u0110 Use one to three letters for RFC 822 format, four letters for the localized GMT format.For more information about timezone formats, see Appendix J: Time Zone Display Names. |\n|  |  | 4 | HPG+8:00fallbacks:GMT-08:00 |  |\n|  | v | 1 | PT | Time Zone \u0110 with the generic non-location format. Where that is unavailable, uses special fallback rules given in Appendix J. Use one letter for short format, four for long format.For more information about timezone formats, see Appendix J: Time Zone Display Names. |\n|  |  | 4 | Pacific Timefallbacks:Pacific Time (Canada)Pacific Time (Whitehorse)United States (Los Angeles) TimeHPG-8:35 - GMT-08:35 |  |\n|  | V | 1 | PSTfallbacks:HPG-8:00GMT-08:00 | Time Zone \u0110 with the same format as z, except that metazone timezone abbreviations are to be displayed if available, regardless of the value of commonlyUsed.For more information about timezone formats, see Appendix J: Time Zone Display Names. |\n|  |  | 4 | United States (Los Angeles) Timefallbacks:HPG-8:35GMT-08:35 | Time Zone \u0110 with the generic location format. Where that is unavailable, falls back to the localized GMT format. (Fallback is only necessary with a GMT-style Time Zone ID, like Etc/GMT-830.)This is especially useful when presenting possible timezone choices for user selection, since the naming is more uniform than the v format.For more information about timezone formats, see Appendix J: Time Zone Display Names. |\n. Accepted, thank you\n. Okay I've temporary disabled it, seems legitimate.\n. First Swift 2 compatible builds is available into the master branch\n. Thank you, great addition\n. Great point, thank you \n. Great; you made me come up with another idea: what about a single function timeDifference which can take an argument (ie. NSCalendarUnit or a custom one) and return the difference?\nSomething like  func timeDifference(unit: NSCalendarUnit, fromDate: NSDate)\n. I think the first one is a more flexible approach. I'll add it to the base case right now, thank you :)\n. Added it to 1.2 release. This is the commit 2ebb8d4fd8ec0bf3fda20efa46e136ec1bca2b51. What do you think?\n. Tag 1.2 https://github.com/malcommac/SwiftDate/releases/tag/1.2\n. :-) Great, thank you very much for this contribution, it's a great addition to have a more compact code.\n. Thank you\n. According to Apple date formatting doc (you can see at the bottom of the readme file) day should be \"dd\" not \"DD\". \n. Just fixed, thank you\n. I'll release it this weekend along some other changes from posted PRs.\n. 1.2 is now available on cocoapods \n. Thank you ^^\n. Great idea, I'll commit it later this week\n. Yeah, put a pull request so I can figure changes better, thanks. Anything can improve the code is welcome :)\n. Just merged your pull request, thank you.\n. Thanks :)\n. Great, thanks\n. Hi @gregorpichler, I've recently removed 'ago'/'since' suffixes from readable date method in order to make something which is not strictly related to any language. It should be a date manipulation library,\nFor the same reason I think it's not correct to accept your request, I'm sorry :)\n. Can you provide an example with results?\n. It should be fixed in https://github.com/malcommac/SwiftDate/pull/66\n. I'll look it this weekend (I was pretty busy this week).\nIs there a conflict in this merge?\n. You have standard methods of NSDate like dateWithTimeIntervalSince1970 or timeIntervalSince1970\n. Fixed in e3035110afae467c05ee588f526eb6f5c951badd\n. I think I've understand your question.\nSuppose to consider only your justDate with the current UTC date.\nHere now are 19:20 (GMT+1) so 18:20 (UTC).\nlet justDate = NSDate()\nprint(\"justDate: \\(justDate) (\\(justDate.hour) : \\(justDate.minute))\")\nResult is:  \"18:20:50\" (from printing justDate) plus \"19\" as hour (from justDate.hour) and \"20\" as minutes (from justDate.minute), while you are expecting 18 as justDate.hour. Right?\n. The problem is with\nprivate var components: NSDateComponents {\n    return  NSCalendar.currentCalendar().components(NSDate.componentFlags(), fromDate: self)\n}\nWe need to set the timezone also in NSCalendar.currentCalendar using calendar.timeZone = ... then you can call time components properties safety.\nIn fact if we set the UTC timezone here the resulting time components are correct (hour return 18 instead of 19 in our previously example)\n. We could store the timezone abbreviation into the NSDate object when it return .toTimezone(\"HKT\")! or .toLocalTime() method and set the calendar timezone according to it.\nI'm not sure about it (store the timezone inside NSData which should be considered time independent).\nAny better idea? @Hout ?\n. In fact Apple allows you to return cal.componentsInTimeZone() while we are using components to simply get components always in UTC (the standard format for NSDate instance).\nI'm not sure what's the best solution.\nWe can emulate the same behaviour of Apple but something like minutes/hours/...InTimezone(...) seems a bit ugly and the alternative of the timezone within the NSDate object is ugly too.\nI need to think about it a while, if anyone has an elegant solution is welcome of course :)\n. I think I'll make another branch to move SwiftDate from a simple NSDate wrapper to a separate class which can store more (including timezone); something like Moment.js or your class.\nWe will lose the ability to work directly with NSDate objects but it should move the project to a whole new level.\n. The new version of SwoftDate introduced the concept of DateInRegion: this class encapsulate an UTC NSDate for a particular world's region (along with locale and calendar settings)z\nTime zone conversion is now easier than ever; thank you for your report and thank you to @Hout for its help making this new revamped version of SwoftDate.\nHope you will like it, feel free to submit your reports or requests.\n. I don't know how it should be done.\nDid you know how to implement this request?\n. Anyway I would to mantain a language independent tool. A better solution is to execute this operation outside the library (See http://stackoverflow.com/questions/15076443/convert-numbers-in-chinese-characters-to-arabic-numbers, it's in objc btw).\nWe could provide a dictionary or a struct which can return seconds/minutes/hours/days/months/years you can convert easily.\n. we can continue this discussion in #79 \n. Cannot reproduce the same error err with XCode 7.1 and iOS 9.1.\nMaybe a problem with ENABLE_BITCODE ?\n. Just fixed doc; you should use dd/MM/yyyy as format (see the doc at the end of the README file)\n. We have fixed it with SwiftDate 2. Thank you for your report.\n. @Hout I'm not satisfied by current function. I think we could explore some alternatives; a very promising one could this: https://github.com/malcommac/SwiftDate/issues/79#issuecomment-164306647.\nThen we could continue discussion in that thread.\n. we will continue discussion about this topic (pretty date formatting) in #79 \n. I'm finishing TimePeriod class; I think we could add a shortcut to manage time-only interval in NSDate/DateInRegion which uses TimePeriod methods. I'll post updated later this week.\n. Scheduled for 4.2.0\n. Fixed since 2.0.0.\nThanks\n. SwftDate 2 now includes the concept of DateInRegion which encapsulate both timezone and calendar; you should create a DateInRegion with your dat by setting your fav calendar and make the same query in order to get the correct result for called method. Thank you for your report.\n. It could be a nice feature to replace the old relative formatting feature and make it more flexible.\nWe could add a mask of units (you can specify both days and hours for example and return values with that precision).\nBut, in fact, this option is very similar to func difference() already implemented in DateInRegion: then we can use it as base and print result in readable localize form.\n. \"Pretty\" date formatting is an interesting feature to implement but I'm not sure the best way is to make some sort of resemble of difference() method we have already.\nThis method takes as argument comparison date, unit flag to compare and return an instance of datecomponents which allows you to return days,months (...) elapsed since the dates.\nI would to take a look around to other frameworks+languages in order to get the most convenient way to implement it.\nOPTION 1\n[NSDate/DateInRegion].prettyDate(fromDate: NSDate/DateInRegion, style: PrettyDateStyle)\nwhere PrettyDateStyle is an enum with the following types:\nPrettyDateFormatWithTime\nEXAMPLE:  if today is September 30, 2012 and the time is 15:30\nToday:        12:58 PM\nTomorrow:     Tomorrow 15:30\nYesterday:    Yesterday 15:30\n2 days ago:   Friday 15:30\n1 week ago:   09/23/12 15:30\n1 week later: 10/07/12 15:30\nPrettyDateFormatNoTime\nEXAMPLE:  if today is September 30, 2012 and the time is 15:30\nToday:        Today\nTomorrow:     Tomorrow\nYesterday:    Yesterday\n2 days ago:   Friday\n1 week ago:   09/23/12\n1 week later: 10/07/12\nPrettyDateFormatTodayTimeOnly\nEXAMPLE:  if today is September 30, 2012 and the time is 15:30\nToday:        15:30\nTomorrow:     Tomorrow\nYesterday:    Yesterday\n2 days ago:   Friday\n1 week ago:   09/23/12\n1 week later: 10/07/12\nPrettyDateLongRelativeTime\nEXAMPLES:\nNow\n15 minutes ago\n59 minutes ago\n1 hour ago\n2 hours ago\nYesterday\n30 days ago\n90 days ago\nPrettyDateShortRelativeTime\nEXAMPLES:\nNow\n15m\n59m\n1h\n23h\n1d\n30d\n90d\n. So something like the NSCalendarUnit (one or more to get granularity of the statement) and another param to get the short/long/medium style?\n. However in order to get a reasonable behavior we should provide an easy to use formatting; while it great to have some sort of granularity of the interval (you would print 24 hours or 1 day) the most common way to format is 1 day. Customization is great but is also good to keep it simple.\nSo we could make a function which takes a list for time granularity (.Day,.Hour etc) and a style (short/normal/full) with default granularity set as auto (auto uses the highest time calculated granularity: 25 hours uses Day granularity and print 1 day; however if you specify [Day,Hour] it print 1 day and 1 hour; if you specify [Hour] you get 25 hours and if you specify [Year] you get nil.\n. Okay this is my proposal.\nWe can have a 'colloquial' style which can print dates in 4 styles (short,medium,long,full).\nThese are the conditions:\nCOLLOQUIAL STYLE\n| CONDITION | SHORT | NORMAL | LONG | FULL |\n| --- | --- | --- | --- | --- |\n| x < 60m | [x]m | [x] mins | [x] mins ago | [x] minutes ago |\n| x < 24h | [x]h | [x] hrs | [x] hrs ago | [x] hours ago |\n| x < 48h | yda | y'day | yesterday | yesterday 15:30 |\n| x < 7days | [x]d | [x] days | [x] days ago | [x] days ago 15:30 |\n| x < 4weeks | [x]w | [x] weeks | [x] weeks ago | [x] weeks ago 15:30 |\n| x < 12 months | [x]m | [x] months | 4/17 | April 17 |\n| other | [x]ys | [x] years | 2015/4/17 | Friday, April 17 2015, 15:30 |\nWe also have another style (name???) which works by using parameters we have specified above:\n- units (NSCalendarUnit mask): the unit of time we want to use in order to compose the final string (an item is ignored when its value is 0).\n- style: SHORT,NORMAL,LONG,FULL (as above)\n- numberOfUnits: number of units to print when different from 0 (nil means 1 unit)\nWhat do you think?\n. I agree! However I don't understand params of these two functions:\n- A) \"colloquial\" output takes a reference date and the style.\n- B) \"....\" output takes reference date, units, number of units and style\nSo something like:\n``` swift\n// Colloquial output\nfunc toRelativeString(fromDate: date, style: Y = .Medium)\n// Standard output \nfunc toRelativeString(fromDate: date, units: NSCalendarUnits, numberOfUnits: Int = 1 style: Y = .Medium) \n```\nAm I missing something?\n. Just added .toNaturalString()  method to generate a colloquial based representation of the difference between two dates. Commit is https://github.com/malcommac/SwiftDate/commit/8f152ae63990a0291322b1e002aeb60a39139d00.\nThis is the logical behind this method:\n| CONDITION | SHORT S. | DEFAULT S. | LONG S. | FULL S. |\n| --- | --- | --- | --- | --- |\n| < 1 minute | now | 2 s | 2 secs | 2 seconds |\n| < 1 hour | 25m | 25 mins | 25 minutes | 25 minutes, 3 secs |\n| < 24 hours | 4h | 4 hrs | 4 hours | 4 hours (15:20) |\n| < 48 hours | yda | yest | yest. (15:20) | yesterday (15:20) |\n| < 7 days | 6d | 6 dys | 6 days (15:20) | 6 days ago (16:20) |\n| < 4 weeks | 3w | 3 wks | 3 weeks | 3 weeks ago (Wed 17:20) |\n| < 12 months | 7m | 7 mnths | 7 months | 7 months ago (March 15, 17:20) |\n| > 1 year | 2ys | 2 years / 1 year | 2 years / last year | 2 years ago (April 15, 2016) |\n. I've also added .toComponentsStrings() method.\nThe signature is:\nswift\nfunc toComponentsStrings(refDate :DateInRegion = DateInRegion(), units :[NSCalendarUnit]? = nil, maxUnits cUnits :Int = 0, style :DateFormatterStyle = .Default) -> [String]?```\nThis method get differences in terms of specified units from a refDate (or new standard DateInRegion() if not specified) and return a readable string for each components.\nSo, just for example, if two dates differ in term of 3 hours, 2 minutes, 5 seconds you will get a localized array with [\"3hrs\",\"2mins\",\"5secs\"] (style attribute specify the abbreviated form for each unit).\nmaxunits specify the max number of non null units to show in resulting array (0 means no limit).\nSupported units are: Nanosecond, Second, Minute, Hour, Day, Month, Year.\nAbbreviated forms are:\n| UNIT (SINGULAR/PLURAL FORM) | SHORT | DEFAULT | LONG | FULL |\n| --- | --- | --- | --- | --- |\n| NANOSECOND | n | ns/ns | ns | nanosecond/nanoseconds |\n| SECOND | s | s/s | sec/secs | second/seconds |\n| MINUTE | m | m/ms | min/mins | minute/minutes |\n| HOUR | h | h/hs | hr/hrs | hour/hours |\n| DAY | d | d/ds | dy/dys | day/days |\n| MONTH | mn | mn/mns | mth/mths | month/months |\n| YEAR | y | y/ys | yr/yrs | year/years |\n. Okay; just a question: this is for English, are we sure we can remove safely singular form from types and make this assumption valid even for other languages? Otherwise we can simply make set the same value for both singular and plural and maintain the distinction inside the code.\n. Damn it seems the solution, I forgot that :|\n. Have you looked at this?\nhttps://github.com/algal/RelativeDatePlayground; NSDateComponentsFormatter does not handle correctly negative time intervals.\nSECONDS |  TTTTimeIntervalFormatter |  NSDateComponentsFormatter\n-----------+---------------------------+---------------------------\n  -1488010 |               2 weeks ago |          -1 week remaining\n  -1468800 |               2 weeks ago |          -1 week remaining\n   -864000 |                1 week ago |        0 seconds remaining\n    -86400 |                 1 day ago |           -1 day remaining\n    -36000 |              10 hours ago |        -10 hours remaining\n     -3600 |                1 hour ago |          -1 hour remaining\n      -600 |            10 minutes ago |      -10 minutes remaining\n       -60 |              1 minute ago |        -1 minute remaining\n       -10 |            10 seconds ago |      -10 seconds remaining\n        -1 |              1 second ago |        -1 second remaining\n        -0 |                  just now |        0 seconds remaining\n         0 |                  just now |        0 seconds remaining\n         1 |         1 second from now |         1 second remaining\n        10 |       10 seconds from now |       10 seconds remaining\n        60 |         1 minute from now |         1 minute remaining\n       600 |       10 minutes from now |       10 minutes remaining\n      3600 |           1 hour from now |           1 hour remaining\n     36000 |         10 hours from now |         10 hours remaining\n     86400 |            1 day from now |            1 day remaining\n    864000 |           1 week from now |           1 week remaining\n   1468800 |          2 weeks from now |          2 weeks remaining\n   1488010 |          2 weeks from now |          2 weeks remaining\nWe can provide a port of TTTTimeIntervalFormatter right now and replace it with NSDateComponentsFormatter when it will be fixed. What do you think?\n. Another referece:\nhttp://www.openradar.appspot.com/17436956:\n\n\"The phrase \"N minutes ago\" does not actually specify the quantity of time, it specifies a moment in time described by an implicit reference to now and a quantity. Formatting moments in time, even if relative like this, would be more appropriate for NSDateFormatter. We can treat this as a request for improving relative date formatting on NSDateFormatter though, which would indeed be a great improvement.\"\n\n[EDITED]\nOkay I think NSDateComponentsFormatter is valid enough to be used without porting an external lib. We can define a set a postifx string to happend in various languages as you said.\n. Added support for NSDateComponentsFormatter. It's a shared instance in each called thread and it's wrapped in FormatterStyle.\nI've used it in toNaturalString(refDate:style:) method of DateInRegion/NSDate (to get a colloquial representation of the difference between two dates) and in toString(style:) of NSTimeInterval (to print time interval in a readable manner).\n. SwiftDate 2 allows to manage easily timezone dates and times.\nYou can learn more on main readme file.\nThank you for your report.\n. I'm working on a new redesigned version of SwiftDate which also have a complete support for timezones. I'll add these methods directly on the new branch.\nJust a question: Why a new ISO8601Date type? ISO8601 variants should be handled automatically by the ISO8601Formatter method.\n. Oh ok ok. Just added :)\n. Hi, Xcode 7 or 7.1? Are you building it for Mac or iOS?\n. It's the same here, I've shared it in scheme. I'm a bit confused, should i look somewhere else?\n. Anyone can try https://github.com/malcommac/SwiftDate/pull/84 ? (I'm out and I can't test it today)\n. Thank you @BernardGatt . Just pushed 2.0.1. Can you check?\n. Thank you again @BernardGatt. Where you set required parameters?\n. Just made thanks.\n. It seems reasonable; I've marked as deprecated (since 2.0.3) Local and added .Current and .AutoUpdatingCurrent into current develop branch (https://github.com/malcommac/SwiftDate/commit/bafe87c350b12c9c3a501641549a446a3d09f548):\nswift\n// get current system calendar (non-updating)\nlet nonUpdatingCalendar = CalendarType.Local\n// get current system calendar (auto-updating)\nlet updatingCalendar = CalendarType.AutoUpdatingLocale\n. Should be fixed in 2.0.2. Let me know if it works for you. https://github.com/malcommac/SwiftDate/commit/7cca2a355650ac6b4924af807463ef0c357ab166\n. No problem, thank you for your report :)\n. Seems to be a bug of Jazzy or CocoaPods. See https://github.com/CocoaPods/cocoadocs.org/issues/411\n. we will continue discussion about this topic (pretty date formatting) in #79 \n. I agree, it's a necessary step to make the lib less confusing\n. yeah it was closed\n. Fixed in https://github.com/malcommac/SwiftDate/commit/d85c3bbbe1cc1e3be32a6a5bdd3f50d92ac2351d\nThanks\n. So should be like current inRegion() function but it takes directly the timezone to create a default region without passing other optional params?\n. Thank you\n. Yeah, I think you have right, absolute time is a better and less confusing wording\n. We should create a develop branch to merge your changes and working to remaining TODO items. What do you think?\nI was wrong releasing early 2.0 directly on master branch but I think we can make a develop branch and merge it in a 2.1 release when remaining changes will be completed. What do you think?\n. You should be able (as collaborator) to create directly a develop branch, don't you? \n. Ehehhe you have my blessing for these changes :) I think they are on the track to put the necessary consistency into the library to mark it \"stable\" and ready for production; so let's go, we will work on develop branch until 2.1 is ready to make it master (well, current 2.0 in master is not ready for prime time but I think with these changes we are near the goal and we are able to finish it during this week...at least I hope)\n. `TimeZoneConvertible is now the main protocol and expose GMT/Default/System/Local at root level.\nFor example you can type TimeZones.GMT.\nFixed in commit https://github.com/malcommac/SwiftDate/commit/15395a429e2901f325a7b0884a91cf1e6af18cac\n. It's okay with SwiftDate4.\nThe new function which accomplish your request is:\nswift\nlet tomorrow = try! Date().add(components: [.day : 1])\n. Just added TvOS, OSX and WatchOS shared scheme frameworks: commit https://github.com/malcommac/SwiftDate/commit/430813365b877a26b12fe2c3067e661736c25feb.\n@cjwirth can you confirm if it works fine for you?\n. @cjwirth, @phimage\n(on develop branch)\nJust fixed the issue with compile files in OSX; it should now compile.\nHowever SwiftDate.xcodeproj now uses CocoaPods and Nimble as framework so when I try to compile it I get: \".... ld: framework not found Nimble\" (and I can't compile the xcworkspace used by cocoa pods to import Nimble).\nI think the solution is to make a single independent xcproj without any reference to CocoaPods, add target to it and make another project with test files and link to nimble and cocoapods.\n@Hout: do you agree?\n. Go for 3.0. I'll investigate further this week to release a minor version update (3.0.1?) which enable this and carthage\n. Just solved in 3.0.1. Thank you for your report.\nIf you have problems make sure to remove Carthage folder in your project in order to do a clean fetch/clone/build.\n. Hi, thank you for your pr. Can you move it from master to develop branch?\n. Yeah seems reasonable; we will label it as 3rd version :)\n. I would tend to discourage the use of several init parameters to express the same concept because it increases the complexity of the library.\nInstead I prefer to set strong constraints into the library: for example in order to specify a calendar in init method you need to pass a single type of object (and to keep the lib flexible you can init this object in different ways).\nLet me show an example:\nFor calendar param we set as constraint CalendarType: you can pass to the function only this type.\nHowever you can create it starting from an enum, a string or an object.\nSo our init will become:\nswift\npublic convenience init?(\n        fromString date: String,\n        format: DateFormat,\n        calendarType: CalendarType? = nil,\n        timeZoneRegion: TimeZoneConvertible? = nil,\n        locale aLocale: NSLocale? = nil,\n        region aRegion: DateRegion? = nil)\nAnd you can specify a CalendarType in 3 different ways:\n- from the enum (example: CalendarType.Gregorian)\n- from an NSCalendar instance (CalendarType.NSCalendar(object: instance-of-nscalendar) )\n- from a specified string (CalendarType.NSCalendar(identifier: String) )\nSo we have a single passed object type without losing the flexibility of the lib.\n(I've used CalendarType and not the NSCalendar object as parameter type because this and TimeZoneConvertible are our main data types and are easy to write using swift's autocompletion).\n. I agree with your proposed init with DateRegion which encapsulate timezone/calendar/locale params; it's really less confusing.\nOnly one remark: what do you think about renaming DateRegion in Region (or another better name)?\nThis because DateRegion will become more visible and I would to avoid confusion between DateInRegion and DateRegion.\nWhat do you think?\n. First one \"exports\", second \"consumes\"; I prefer the first one because it' \"natural\" to think \"I've a date [object] and I want to transform it in a string\" and not \"I've a date and I want a string, so I need to start from a string (destination) and pass the object I want to transform (source)\".\nMoreover, talking about the example you have said we should start from a String as class (static func) and not instance (instance method): another point to prefer the first solution IMHO.\n. Yup\n. Frankly I've not any better idea right now... sic!\n(But if you we stay with DateInRegion and Region encapsulate params for DateInRegion seems natural Region is the name for this struct)\n. Okay with both changes.\nI don't understand your last remark: we have already nested enum; each enum is conform to a protocol that allows easy conversion to NSTImeZone so you can type Europe.Rome.toTimeZone() (or timeZone prop) and you don't need to make an extension of NSTImeZone which add an init with TimeZoneConvertible type to generate a new instance of NSTImeZone. Am I missing the point?\n. I've tried using SwiftLint into the code but 99% of the warnings are related to line length or white lines.\nI'm not sure this could be a bold move.\nHowever I'm okay with the Swift Style Guideline at the top of the issue. I'll check the code for it.\n. Great move!\n. Okay we can merge this feature into develop\n. We can pass another class part of the library if our intent is to get the path inside SwiftDste package itself. Right?\n. Could we consider it closed?\n. Okay I've missed the point with master branch and gitflow. You are absolutely right.\nToday I'll check the code for Swift Guidelines as described in #131.\nWould you check toNaturalString() of DateInRegion and toString() of NSTimeInterval so we can add both to the doc and tests? I've just added it recently but all of these commits were made directly on develop (my fault).\n. Should it work only with NSTimeInterval? So you can pass an arbitrary number of seconds and you get it using specified unit of times.\n. However seems it does not work fine with negative intervals\n. NSTimeInterval now has a toString(style:) function you can use to convert a duration into a readable string.\nExample:\nswift\nlet duration = NSTimeInterval( (60*60*24) ).toString() // print \"1d\"\nYou can also specify the style of the formatted output by passing a FormatterStyle struct:\nswift\nlet duration = NSTimeInterval( (60*60*24) ).toString(FormatterStyle(style: .Full)) // print \"1 day\"\n\nFormatterStyle is a struct where you can set:\nswift\npublic var style :NSDateComponentsFormatterUnitsStyle = .Abbreviated\n\nConfigure the strings to use for unit names such as days, hours, minutes and seconds. Use this property to specify the style of abbreviations used to identify each time component. By default the value of this property is .Abbreviated; so for example, one hour and ten minutes is displayed as \u201c1h 10m\u201d.\n\nswift\npublic var units :NSCalendarUnit\n\nThe bitmask of calendrical units such as day and month to include in the output string. By default all available values are used; this means each unit of time is part of the output string if the relative value is not zero. You can use:\n- Year\n- Month\n- WeekOfMonth\n- Day\n- Hour\n- Minute\n- Second\n  Any other value of the NSCalendarUnit enum will result in an exception.\n\nswift\npublic var maxUnits :Int = 0\n\nThis property can be used to limit the number of units displayed in the resulting string. For example if set to 2, instead of \u201c1h 10m, 30s\u201d the output string will be \u201c1h 10m\u201d. You can use it to provide a round up version of the output when you are constrained.\n\nswift\npublic var approximate :Bool = false\n\nSetting the value of this property to true adds phrasing to output strings to reflect that the given time value is approximate and not exact. Using this property yields more correct phrasing than simply prepending the string \u201cAbout\u201d to an output string. By default is set to false\n\nswift\npublic var approximatePast :Bool = false\n\nSetting this property to true results in output strings like \u201c30 minutes remaining\u201d. The default value of this property is false.\n\nswift\npublic var collapsesLargestUnit :Bool = false\n\nAn example of when this property might apply is when expressing 63 seconds worth of time. When this property is set to true, the formatted value would be \u201c63s\u201d. When the value of this property is false, the formatted value would be \u201c1m 3s\u201d. By default is set to false\n\nswift\npublic var zeroBehavior :NSDateComponentsFormatterZeroFormattingBehavior = .Default\n\nThis specify the behavior of the formatter when it encounter a zero value for a particular unit of time.\n. NSDateComponentsFormatter supports only NSCalendarUnitWeekOfMonth in  allowedUnits property. In fact  FormatterStyle it's just a wrapper around it.\n. I'll finish to update the doc today and try to generate an additional doc using jazzy tool.\nMoreover I would to compact and merge some files which contains a similar context methods.\n. Initialising an NSDateFormatter is a very expensive move. If you have to parse a lot of dates, expect your app to slow down.\nThis is a known performance issue especially when using in a list of dates; Apple's documentation here say:\n\"Creating a date formatter is not a cheap operation. If you are likely to use a formatter frequently, it is typically more efficient to cache a single instance than to create and dispose of multiple instances. One approach is to use a static variable.\"\n\nThere are some other articles you can found by searching on google; all of them end with a cached version of the formatter.\nHowever I'm not sure the same the same issue should be applied to NSDateComponentsFormatter but right now I've followed the same approach.\n. As you said let difference = date1 - date2 returns an NSDateComponents instance; so what's happens when you append .inUnits([.Minute])?\nShould we get the resulting NSDate from  date1 - date2's components and get only a subset of NSDateComponents value?\n. Okay I got it right (but my solution above does not work).\nThe problem is how to convert from a NSDateComponents to another (from a date components where all units are calculated to another where a different set of these should be calculated).\nThis because date2 -  date1 results in a NSDateComponents instance and we have already lost references to both original dates... so how can we get another \"style\" of NSDateComponents with different units without a reference to the original dates?\n. As you said, I think we should move quickly to the next version in order to fix the broken parts of the current available version.\nSo IMHO we should fill the holes for:\n- remaining tests for currently implemented methods (beside formatting is there anything else not covered? can you see this?)\n- update documentation (I would to try to generate a jazzy apple style doc)\nWhat do you think?\n. Implemented since Swift 4.x.\n. I would investigate further before merge it, especially because we have not found an answer for this. I'll look at this the next week and we'll release a minor update to the new 3 branch\n. Just solved in 3.0.1. Thank you for your report.\nIf you have problems make sure to remove Carthage folder in your project in order to do a clean fetch/clone/build.\n. Just looked deeper on Keychain project :) Did you still see xcworkspace files? I've removed it along with cocoapods references.\n. np :+1: thank you!\n. At this time I think the only solution we can provide is to use NSDateComponentsFormatter to get periods strings (months,weeks,minute,seconds...) and use the same logic of the class to get the correct result.  In this way we can provide a workaround which can be removed in a future release.\nWhat do you think?\n. I'll close this. Now we have an initial implementation; we can continue here: #168 \n. Great @Hout. Just made these changes and pushed 3.0.1.\nI'll add jazzy documentation sooon. Meanwhile it now works fine with Carthage (I love it!)\n. Jazzy is now supported. Configuration was added to project's root directory. First docs was generated.\nWe should make it better but it's a start and it now works.\n. Just solved in 3.0.1. Thank you for your report.\nIf you have problems make sure to remove Carthage folder in your project in order to do a clean fetch/clone/build.\n. Meanwhile I've set as public. We should also write tests for it indeed. (https://github.com/malcommac/SwiftDate/commit/671ec6cb549d3078eb67950c1209de4e32b1f381)\n. We could have more different styles for ISO8601 strings; however I think ISO8601 format string is wrong (while the results is in some cases correct).\nCurrently it is ISO8601 format string is:\nswift\nyyyy-MM-dd'T'HH:mm:ssZ // 2015-01-05T22:10:44+0100\nWhile according to Apple docs, ISO8601 timezone support should be handled with ZZZ:\nswift\nyyyy-MM-dd'T'HH:mm:ssZZZ // 2015-01-05T22:10:44+0100 (here it's the same)\nIf we want to add fractional periods we should add:\nswift\nyyyy-MM-dd'T'HH:mm:ss.SSSZ // 2015-01-05T22:10:44.000+0100\nAs with ISO8601Formatter class we use internally, we should provide different sub-versions.\nThis is my proposal, currently on a separate feature branch https://github.com/malcommac/SwiftDate/commit/e0e749a6596f4b34b3e871739e2867bfe9bc28f8\nI've added new style in DateFormat enum, called ISO8601Format which takes one parameter of type ISO8601Style:\nswift\npublic enum ISO8601Style: String {\n    case Year                           = \"yyyy\"\n    case YearAndMonth                   = \"yyyy-MM\"\n    case CompleteDate                   = \"yyyy-MM-dd\"\n    case CompleteDateTime               = \"yyyy-MM-dd'T'HH:mmZ\"\n    case CompleteDateTimeSeconds        = \"yyyy-MM-dd'T'HH:mm:ssZ\"\n    case CompleteDateTimeFractional     = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"\n}\nI would tend to avoid removal of ISO8601 and ISO8601Date DateFormat styles; both of them are the common way in which ISO8601 date is printed.\nThis is an example about how to format ISO8601 strings:\nswift\nlet formattedString = date?.toString(.ISO8601Format(.CompleteDateTimeFractional))\nWhat do you think @Hout . Any way to make it more readable or compact? Is it okay for you?\n. On develop branch.\nDateFormat's IS08601 enum now allows to specify optional ISO8601Format variant: (cannot use ISO8601 right now to allow backwards compatibility)\nswift\npublic enum ISO8601Type: String {\n    case Year // yyyy\n    case YearMonth // yyyy-MM\n    case Date // yyyy-MM-dd\n    case DateTime // yyyy-MM-dd'T'HH:mmZ\n    case Full   // yyyy-MM-dd'T'HH:mm:ssZ\n    case Extended // yyyy-MM-dd'T'HH:mm:ss.SSSZ\n}\nWhen omitted .Full is used.\nUsage example:\nswift\nlet iso8601_str = date.toString(.ISO8601Format())\nlet iso8601_str = date.toString(.ISO8601Format(.Extended))\nlet iso8601_str = date.toString(.ISO8601) // deprecated. Uses .ISO8601Format(.Full)\n. Mmmm what's about 3.0.4? I'll reserve 3.10 when relative date formatting will be done, do you agree?\n. 3.0.2 release is now also available via CocoaPods\n. You have provided the wrong format according to your date string in the comment.\n. I think we should reuse same function to express same features. In this way toISO8601String() is simply a shortcut for toString(.ISO8601).\nSo this commit (now in a separate feature) will accomplish this task: https://github.com/malcommac/SwiftDate/commit/165309fd926fac2574902025bd81343f846574b9.\nAny cons?\n. Totally agree. It now uses toString(.ISO8601) format but it's marked as deprecated. https://github.com/malcommac/SwiftDate/commit/9451ed3fcf3ba996a347ea96ce45694371aa4f3a\n. Yeah ok, can you make a new PR which also modify .podspecs for CocoaPods (your change cover only Carthage right?)\n. Right, done in develop. Thanks\n. Added on track for 3.0.3 (now in develop)\nhttps://github.com/malcommac/SwiftDate/commit/3217f7f6fa79631b44217f97f11523cb84ad1fa1\n. Ehm :-) Can you post in english? \n. Maybe a different locale between simulator and real device?\nCan you post your configuration (locale) on both devices and your source string to parse?\n. In order to parse your string you need provide the right format.\nFor you source string you can accomplish it using \"MMM dd, yyyy K:mm:ss a\" (see http://waracle.net/iphone-nsdateformatter-date-formatting-table/):\nswift\nlet str = \"Feb 12, 2016 5:06:06 PM\"\nlet region = Region(calendarName: CalendarName.Gregorian, timeZoneName: TimeZoneName.Gmt, localeName: LocaleName.EnglishUnitedStates)\nlet dateObj = DateInRegion(fromString: str, format: DateFormat.Custom(\"MMM dd, yyyy K:mm:ss a\"), region: re)\n. fixed in develop https://github.com/malcommac/SwiftDate/commit/0ccc172d506034f1cd1b949100fbfca3f16bf303\nThanks\n. Thank you @twiedow; I've refused pr to add your change in develop instead of master.\n. merged in develop https://github.com/malcommac/SwiftDate/commit/053e4e9e4f5a33c6e3309bda62804c3120149fc0\n. I agree, we could mark it as deprecated\n. I'm working on a new implementation. I'll post more infos during this week.\n. Yup I'll post specs before weekend (hope later today)\n. I'll close this. Now we have an initial implementation; we can continue here: #168 \nI've posted specs about the class and the implementation. We can start working on it.\n. Regarding deserialization from string you should not have problems; for example\nswift\nlet d = \"2016-06-06T08:30:00+02:00\".toDate(DateFormat.ISO8601)\noutput NSDate is \n2016-06-06 06:30:00 +0000\nwhich is correct.\nAbout serialization this is a known issue; it should be fixed in develop branch (https://github.com/malcommac/SwiftDate/blob/develop/Sources/SwiftDate/NSDateFormatter%2BSwiftDate.swift#L78) and soon as we ready with relative date formatting it will be published.\n. Yes we can close it\n. Ehm I didn't know Travis (damn need to learn it...). What should I do? :)\n. Pushed!\n. > Difference between day parts (morning afternoon, night) differs per locale. E.g. in Indonesia day parts exist for sunrise-11 (pagi), 11-14 (siang), sore (14-sunset), malam (night).\nOkay good to know, so there is no reason to increase complexity. So, first of all we can drop \"today's\" variants because they are too locale dependant.\n\nI am not sure about the unit granularity. Depending on circumstances I would mention \"February next year\" or just \"next year\". Or \"tomorrow at 20h15\".\n\nCan you explain cricumstances? We could provide variants of relevant time strings for each unit if needed.\n\nWeeks are not in the allowed units set?\n\nweeks are available with \"w\" and \"ww\" code\n\ncolloquial_f_s is never used in practice. \"Now\" is appropriate.\n\nBasically I agree but it's a param and by removing it we lose unit granularity (seconds) you can omit with using allowsNowOnColloquial = true. Is it a good idea?\n\ncolloquial_thisnight is different for future and past, also in English: \"last night\", if it is the previous night, \"tonight\" if it is the next night (and night is including the evening in the UK), \"this night\" if from within the \"night\" time frame.\n\nWe will remove it according to the first point, okay? any better idea?\n. Yeah, this was my first choice but I've discarded that because it fill only partially our strings needs (colloquial forms still missing, we can have only unit names). So, at least for now, I'll tend to avoid using it because it does not solve the entire problem but create an useless dependency for a fistful of strings. What do you think?\n. @Hout We can use NSDateFormatterStyle for time and date to add relevant time information to the colloquial version of the string. What do you think? It should be easier than maxUnits\n. I've tried with NSDateFormatterStyle but I think it's not the best choice because it's a bit constrained.\nYou can't obviously decide what format of date/time print so for example you can't print Feb 17 or Wen Feb 17 etc.\nA manual pick with a specified date format seems the best reasonable way and it should be customized based upon locale habits.\n. Okay I've moved components based print of DateFormatter to NSDateComponentFormatternot since commit https://github.com/malcommac/SwiftDate/commit/00dd0eae3d6aec7542417d4e436fa5ee60606884\n. Less than 1 minute differences are now simply \"just now\" as you said some time ago :)\n. The most simple way in UTC region is working directly with NSDate:\nvar date = NSDate(fromDate: (NSDate()-1.days), hour: 9, minute: 0, second: 0)\n. Number of days in a weeks are obtained from calendar's locale; in your case the value obtained is 7 days so you have one week plus one day. That's right.\nWhat's your locale? Can you print it?\n. toNaturalString now uses NSDateComponentsFormatter but it will be replaced soon as the new formatter functions will come to a stable release. More info about that are available at this thread: https://github.com/malcommac/SwiftDate/issues/168.\nYou can contribuite with your opinion; we will discuss them. At this time maxUnits only specify the non-zero unit style you want to show in the output string.\n. We would to keep the library consistent so the main way to pass a timezone is to specify it's by TimeZoneName enum (ie. TimeZoneName.AfricaBamako).\nDo you need to pass directly an NSTimeZone instance?\n. Seems reasonable.\nhttps://github.com/malcommac/SwiftDate/commit/befb264587247574b8f350412b363286a6bfce61\n. Can you make a PR to develop (not master)?\nThanks.\n. Cannot reproduce this bug.\nThat's the result of my test:\nswift\nlet date = NSDate() // 2016-03-14 19:30:38 +0000 (UTC)\nlet date5 = (1.years - 2.hours).fromNow() // 2017-03-14 17:30:38 +0000\nlet date6 = (1.years + 2.hours).fromNow() // 2017-03-14 21:30:38 +0000\nWhat's your UTC offset/timezone?\n. closed for now, waiting for more info.\n. Added .startWeek (replacefirstDayOfWeek) and .endWeek (replace lastDayOfWeek) properties both for Date and DateInRegion.\n(https://github.com/malcommac/SwiftDate/commit/a38152e5efd40378c0ddb0cba0872ce82ceab9df). I've added it while working on new release. Thank you.\n. calendar is defined as let and assigned at init time so it cannot be change further.\n. yeah, you are right. So what do you think is the best approach?\nWe can return a copy of the calendar var and keep it private. Any other solution?\n. I'm a bit afraid to make another set of classes where the only scope is to avoid this issue; we will end with a big library of \"non necessary things\".\nWe could hide the calendar inside our region and expose it as a copy; what's wrong with this propose?\n. yeah sure :) btw I can't see benefits; at the start of this project my idea is to completely hide the cocoa framework behind and make something with new structs and classes\nHowever a day you said to me we should keep things simple and in the majority of cases people love to use standard classes, so with SwiftDate you can still use NSDate and move on DateInRegion only if you need to play with a custom configuration. It was enlightening and now I think adding tons of \"fake\" classes only to hide a behaviour is not the best solution. I'm afraid of that.\n. @Hout We are using this for our NSDateFormatter object too!\n. Sorry I don't understand the point. Is there a problem using a common defaultRegion property as static one for Region class? It can be used as fallback when no Region is passed as param for a function.\nCan you refresh my mind?\n(Because some days ago I was working on it and now I think I've made a mistake and need to rollback)\n. ISO8601DateTimeFormatter is now public and port lots of the features that ISO8601Formatter implements in iOS10+.\nIt's available since SwiftDate 4.\n. Thank you. Can you post the same request on develop please?\n. Using S....prints fractional seconds (truncated to the count of letters)\nI think you should use A....to print Milliseconds in day up to 6 digits.\nhttps://github.com/malcommac/SwiftDate/blob/develop/Documentation/1.CreateDates.md\n. Fixed\n. Cannot reproduce this bug.\nWhat's your default NSLocale/NSTimezone?\nHave you tried to use toString() with the additional inRegion parameter by passing something like LocaleName.EnglishUnitedStatesComputer in order to force 12h format?\n. it currently works, just set the locale:\nswift\nlet enRegion = Region(tz: TimeZoneName.europeRome, cal: CalendarName.gregorian, loc: LocaleName.englishUnitedStates)\nlet date = try DateInRegion(components: [.hour: 22], fromRegion: enRegion)\nlet c = date.string(custom: \"hh:mm a\") // print \"10:00 PM\"\n. it's marked as public in develop branch.\nscheduled for 3.0.8\n. I think it is a specific behavior of UIKit and not a bug, if you notice Feb 1986 has 28 days (+3 days) = 03 March. It try to \"fix\" your input date, probability it works only with leap days in feb.\n. I agree but we cannot override the default behavior or UIKit without rewriting the entire logic and this is not in our plan.\nWe have just made a site with examples and docs about SwiftDate; you can found datetime parsing functions here about date time parsing here.\nBasically you can call:\nswift\nlet str = dateString.date(format: DateFormat)\n. In fact we have missed to make public .absoluteDate or .dateproperty. I've scheduled it for the next minor update 4.0.3.\n. Sure.\nJust follow issue #267\n. You can use .withInternetDateTime:\nswift\nlet date4 = DateInRegion(string: \"2001-02-03T15:30:00+01:00\", format: .iso8601(options: .withInternetDateTime), fromRegion: regionRome)\n. Ops my mistake, I did not see seconds.\nLet's try:\nswift\nlet test = \"2016-08-05T18:20:24.388Z\"\ndo {\n  let d = try test.date(format: .custom(\"yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ\"))\n  print(\"Parsed date is: '\\(d)'\")\n} catch let err {\n  print(\"Ops, failed to parse date: \\(err)\")\n}\n. It could be a new option in ISO8601DateTimeFormatter class.\nWe can continue discussion in #293\n. Fixed in develop branch, thank you (scheduled for 3.0.8)\nhttps://github.com/malcommac/SwiftDate/commit/fdc005e3689350434e033c95bd8bb7c900a36aba\n. We have added it for 3.0.8 (need to write some unit tests for it).\nMeanwhile it's available on develop branch since this commit https://github.com/malcommac/SwiftDate/commit/d909c124c0d9ebce97c8b9ced6824574dcbf7c62.\nThank you for your suggestion.\n. Operation with dates:\nhttps://github.com/malcommac/SwiftDate/blob/develop/Documentation/3.OperationsWithDates.md\nDate to string with relative/colloquial formatting:\nhttps://github.com/malcommac/SwiftDate/blob/develop/Documentation/6.DatesToString.md\n. Cannot reproduce this bug event settings my iPhone to Japanese. Should I set something more?\nHave you tried to also set a region toString(..., inRegion:) and using an english locale?\n. You should set your region's locale to english.\n. Fixed, thank you\n. fixed in develop. thanks\n. Fixed in develop. Thank you\nhttps://github.com/malcommac/SwiftDate/commit/ec667aa0b07c1ca3312968105abce8c3fa7d4241\n. You are correct, documentation is outdated. We have refreshed it in develop branch: https://github.com/malcommac/SwiftDate/tree/develop.\nWe will post the new one with 3.0.8 release.\nI don't think TimeZoneName.Custom() is acceptable because the TimeZone should always return a valid object in order to simplify the creation.\n. fixed thanks\n. You are correct.Thank you\nFixed in https://github.com/malcommac/SwiftDate/commit/704c29e678564dc66a7ffd02f157b63a39a32efd and scheduled for 3.0.8.\n. I've just added .localAbsoluteTime in develop branch https://github.com/malcommac/SwiftDate/commit/1d53ffe082dff5d25bca65715f4358bf4677ab2e.\nWe will release it with 3.0.8 but you can use the implementation code as workaround in order to avoid string-date conversions.\nswift\npublic var localAbsoluteDate: NSDate {\n   let seconds = self.timeZone.secondsFromGMTForDate(self.absoluteTime)\n   return NSDate(timeInterval: NSTimeInterval(seconds), sinceDate: self.absoluteTime)\n}\n. It's right, there not an localAbsoluteDate and it does not make sense. You can still get the absolute date by using .absoluteDate property or convert it to a GMT/UTC region using toRegion(Region.GMT()) function.\n. Hi,\nNSDate/Date only represents an absolute point in time. It has no concept of timezone or calendar. When you create a NSDate instance it is just a number of seconds since January 1st 2001 GMT It does not matter if you are in New York, Rome or Barcelona.\nSo when you are asking for absoluteDate (old was localAbsoluteDate) you are asking for the absolute representation of the date in GMT zone.\nIf you need to get a string representation of the date including the timezone you can use string(format: .iso8601Auto) or any other options of the ISO8601 (you will get something like 2017-05-08T09:38:36+02:00)\n. We don't support it yet, but seems a nice addition.\nMeanwhile you can user NSCalendar's nextDateAfterDate() method.\nLet me show to you an example about:\nswift\nlet components = NSDateComponents()\ncomponents.weekday = 1 // in Gregorian 1 is Sunday\nlet nextSunday = self.calendar.nextDateAfterDate(self.absoluteTime, matchingComponents: components, options: [.MatchNextTimePreservingSmallerUnits])\n. I've scheduled it for 4.1.0.\n. Added in 4.0.8 (https://github.com/malcommac/SwiftDate/commit/b9d6cecd2c4ed79fc350e2ef0573396450072356).\nWe have .next() func both for Date and DateInRegion objects.\nExamples:\nswift\nlet now = DateInRegion() // 30 nov 2016, 13:55:04 CET\nlet nextFriday = now.next(day: .friday) // 02 dic 2016, 00:00:00 CET\nlet nextMonday = now.next(day: .monday) // 05 dic 2016, 00:00:00 CET. Thank you for your suggestion :). Great job! Thank you for your improvement. Can you migrate your PR to develop instead of master?\n. Thank you for your contribution! We will add it to 3.0.8 release\n. Since SwiftDate 4 you can init it in a more clean way:\nswift\nlet date = try! DateInRegion(components: [.year: 2015, .month: 12, .day: 25])\n. Can you check with the new build?\n. Fixed in SwiftDate4\n. Fixed in SwiftDate4. Thanks!\n. Yes sure, I'll start working on it very soon \n. Swift_3 branch is now active (https://github.com/malcommac/SwiftDate/tree/feature/swift_3); a first preliminary porting was accomplished.\nTests should be updated and validated.\nAfter that I'll start working on API updating to better match the new Swift3 API guideline\n. I have not enough time to work on both; However I'll be happy to check a PR for Swift 2.3 if you can work on it.\n. On swift-3.0 branch you will found a 3.0 version.\nI'm also working on a major update of the library which will be better suits in Swift 3.0. Hope to post some news in two weeks.\n. Date is parsed from given timezone (-6h) to the absolute datetime format; the timezone of the output (dateInRegion) is defined by passed region parameter (by default, if not specified, as in your case, the timezone is your current locale timezone, so +8h).\n. I've added it as enhancement.\n. Since 4.1.0 ISO8601Parser supports parsing ISO8601 strings by evaluating automatically format's variant. It also take care of the specified timezone by creating Date or DateInRegion instance which reflect the value expressed in string.\nThank you for your request.\nThis is the reference commit: https://github.com/malcommac/SwiftDate/commit/255e90a95b7e31991d77256f98aafe651015ebc9. Thank you @phatmann , just fixed for 4.1.1 in https://github.com/malcommac/SwiftDate/commit/4bcd67ad4d3e0229ac717e1dddd2b5eae6ad3067. Confirmed for v 4.0.\nSee https://github.com/malcommac/SwiftDate/issues/233\n. Just added colloquial functions which should be able to do what are you searching for.\nCheck out it here.\nThanks.\n. Fixed in https://github.com/malcommac/SwiftDate/commit/4f7d5a81bc0c1f09e6ef352e95e679962be15483 (develop, swift 23 and swift 3 branches)\n. It's not part of the unicode specs for date formatting. You should be able to do this things using lowercase function.\n. Thank you, I've integrated your PR manually on develop (and swift 23/3 branches).\nSoon as ready I'll publish it to master with the last update for swift 2\n. Checkout Swift_23 branch\nhttps://github.com/malcommac/SwiftDate/tree/feature/swift_23\n. Fixed in SwiftDate4:\nswift\nprint(Date()) // 2016-09-30 18:47:52 +0000\nprint(Date().startOf(component: .day)) // 2016-09-30 00:00:00 +0000\n. Fixed.\nSince SwiftDate 4 .defaultRegion is a Region which has:\n- GMT as TimeZone\n- Device's locale as Locale\n- Device's calendar as Calendar\nYou can however change it anytime using .setDefaultRegion().\nYou can, for example, use Region.Local() to get a region created using all locale's settings, including timezone.\n. It will be part of the new major update (and it will be reserved to Swift 3).\nBasically you will be able to write:\nswift\nlet date1 = ...\nlet date2 = ...\nlet diff = (date2-date1).in(.seconds) // or .hour, .days etc.\n. added in SwiftDate 4 as TimeInterval extension.\nThanks for your suggestion.\n. Fixed\n. I'm sorry but I don't understand what you try to accomplish with the code below and what you wrote :(\n. checked in SwiftDate4 and it's okay.\n. see https://github.com/malcommac/SwiftDate/issues/238\n. On swift-3.0 branch you will found a 3.0 version.\nI'm also working on a major update of the library which will be better suits in Swift 3.0. Hope to post some news in two weeks.\n. I'm working on it in https://github.com/malcommac/SwiftDate/tree/feature/swift-3.0 but there are tons of different things around here (I've started thinking that we should need a big refactor due to some deep changes).\nActually this branch does not compile, I'm a bit confused by these errors.\nAs far I can see I've dateFormat in DateFormatter...\nAny idea @Hout ?\n\n. On swift-3.0 branch you will found a 3.0 version.\nI'm also working on a major update of the library which will be better suits in Swift 3.0. Hope to post some news in two weeks.\n. PR accepted in Swift 2.3 branch\n. Thank you\n. Thank you very much @uny \n. Fixed in SwiftDate 4. Thanks.\n. Merged, thank you\n. Thank you\n. Fixed in SwiftDate 4\n. Fixed in SwiftDate4. Thanks!\n. Fixed in SwiftDate4\n. In SwiftDate 4 it works fine.\n2016-09-30 18:09:23 +0000\n2016-10-02 18:09:23 +0000\n2016-09-28 18:09:23 +0000\n. Fixed in SwiftDate 4. Thanks!\n. I'm working on a new fully Swift 3 compatible version of swiftdate-4.0 branch. It will takes at least another week so be patient :(\n. We have wrote a new site at http://www.swift-date.com where you can found both examples and docs.\n. Removed in SwiftDate4.\nYou can still use:\nswift\nstring(dateStyle: DateFormatter.Style, timeStyle: DateFormatter.Style)\nby passing .medium style.\n. Removed from swiftDate 4. Use .string() function and pass your favourite style.\n. Check out SwiftDate 4 colloquial functions here\n. Fixed in SwiftDate 4.x\n. Since SwiftDate 4.x you can do:\nswift\nlet intervalInDays = yourDateDiff.in(.days)\nCheck the documentation here\n. We have started rewrote all the tests using XCTest in order to avoid gap in Swift updates (as it happened between Swift 2 and 3).\nThere are about 80 tests right here; we can continue from here. Now all the tests compiles in Swift3 of course.\n. in SwiftDate 4.0.0 you can use colloquialSinceNow() or colloquial() function\n. Check out with 4.0.2 with pod update It should be solved now.\n. You are absolutly right. I've scheduled it for the upcoming 4.0.3 release. See #271 \n. Ready :)\n. you need to specify the component separator.\nCheck out the new SwiftDate 4 functions here.\n. Using math operators:\nlet dateB = dateA - 1.seconds + 2.minutes - 3.weeks + 1.years\n. It was fixed in SwiftDate 4 on master branch.\n. It's welcome :)\n. thanks\n. Seems SwiftDate.bundle was not copied into framework.\nJust pushed 4.0.1,try a pod update and tell me if it works.\nThanks\n. Should be solved in 4.0.2. Make a pod update and tell me if it's okay.\n. The first one should be related to #271 and should be okay for 4.0.3. You can try it in 4.0.3 branch (I'll release it on monday).\nHave you received a .FailedToCalculate exception when both dates are equals? Can you post a snippet of code?\n. Ok reproduced and closed for 4.0.3.\nSee #272\n. Fixed in https://github.com/malcommac/SwiftDate/commit/61739a60d83af2a1d79e2a998e352c3ff98252ad.\nWill be part of the upcoming 4.0.3 release.\n. Closed.\nhttps://github.com/malcommac/SwiftDate/commit/1a563cc96a5c13b85656e448c4b8d4e64af0131c\n. Thank you @hackolein. This new translation will be part of the new upcoming 4.0.3 release.\n. Thank you. It was fixed and will be part of the upcoming 4.0.3 release (see https://github.com/malcommac/SwiftDate/commit/2118282dc505873a1e8ad340805840b3bea797b5)\n. Hi @dhamukrish see #267 \n. Fixed in https://github.com/malcommac/SwiftDate/commit/40fa8c4335f805fd0ea454af0b31a4306e8e1c37.\nPart of the 4.0.3 update.\n. Closed in 08c97fb598164e972d53167228dca98cfcfda717.\nReady for 4.0.3\n. Added and configured in https://github.com/malcommac/SwiftDate/commit/b509c7216463d8b95368efcf74d93668961b0761.\nHowever at this time I cannot find a way to handle copy of SwiftDate.bundle package so it still incomplete.\n. The package manager does not yet have any definition for how resources will be bundled with targets. There is not concrete proposal for it yet.\nThis is a filled bug here: https://bugs.swift.org/browse/SR-2866\n. We'll wait for a major version of SwiftPM which fixes this bug. You are right.\nI've fixed it in https://github.com/malcommac/SwiftDate/commit/6d811aadc47e788cdb0ecb649bbc5c69d64571ed.\nIt will be ready in upcoming 4.0.3 release (I'll release it later tomorrow).\nYour function will become:\nswift\nopen class func secondsToTimeString(_ seconds: TimeInterval) -> String {\n  let refDate = Date()\n  let toDate = refDate + Int(seconds).seconds\n  do {\n    return try (refDate - toDate).string(options: ComponentsFormatterOptions(zero: .pad))\n  } catch {\n    return \"\"\n  }\n}\nThese function are now deprecated:\nin Date:\nswift\nfunc timeComponentsSinceNow(unitStyle:,max:,zero:,separator:) throws -> String\nfunc timeComponents(to:,in:,unitStyle:,max:,zero:,separator:) throws -> String\nreplaced by:\nswift\nfunc timeComponentsSinceNow(options:,shared:) throws -> String\nfunc timeComponents(to:options:shared:) throws -> String\nin DateInRegion:\nswift\nfunc timeComponentsSinceNow(unitStyle:,max:,zero:,separator:) throws -> String\nfunc timeComponents(toDate,unitStyle:,max:,zero:,separator:) throws -> String\nreplaced by:\nswift\nfunc timeComponentsSinceNow(options:) throws -> String\nfunc timeComponents(toDate:,options:) throws -> String\nin TimeInterval:\nswift\nfunc string(unitStyle:,max:,zero:,separator:,locale:) throws -> String?\nreplaced by:\nswift\nfunc string(options:,shared:) throws -> String\n. Right; added in feature branch 4.0.4\n. Thank you\n. Release ad part of 4.04\n. Sorry I've not enough time to support old 2.3 version.\nI'll be happy to integrate any bug fixing related PR.. I've made a mistake. Can you repost this PR into 4.0.5 branch? Thank you very much\n. Ok I've removed the branch. It should now work fine.\n. Is possible to repost a cocoapod tagged release?\n. try to use the branch instead of tagged version on cocoapods:\npod 'SwiftDate', git: 'https://github.com/malcommac/SwiftDate.git', branch: 'feature/swift_23'\n. Closed and scheduled for 4.0.4\n. Thank you! It will be part of the 4.0.5 release\n. Thank you @pierrolivier :)\n. Thank you!\n. Thank you!\n. Yep it was actually fixed in 4.0.4 :)\n. it's a bug, clearly there need to be static methods of Date object.\n. Fixed in https://github.com/malcommac/SwiftDate/commit/73b4b97d9991c7886ec893d80c5c13e215421ba8.\nScheduled for the next minor update 4.0.5.\nThank you for your report.\n. Added in https://github.com/malcommac/SwiftDate/commit/5f4a99f64602238b252ff54fbe423bc43a42ff22.\nWill be part of 4.0.5.\n. It's on 4.0.5. My mistake :)\nI'll release it soon later today.\n. I've tried right now and it works fine.\nMy cartfile:\ngithub \"malcommac/SwiftDate\" ~> 4.0.5\nResult:\n\nAre you sure you have the latest build of carthage which support xcode8?\nIf you have both XCode7 and XCode8 you need to properly set the xcode's toolchain to the v.8; from terminal:\nbash\nsudo xcode-select -s /Applications/Xcode.app // path to your xcode 8\n. np :)\n. Thank you Alex; fell free to submit PR if you want to contribuite \ud83d\udc4d \n. I'm sorry but I think I can't understand what you try to accomplish.\nWant you get the .timeIntervalSince1970 in device's locale? .timeIntervalSince1970 is the absolute number of seconds since 1970 and the value is not related to a specific locale.\nIf you want to get the .timeIntervalSince1970 from a DateInRegion object you can obtain it using \nswift\nlet secs = dateInRegionObj.absoluteDate.timeIntervalSince1970\n. You can allocate a Date object without using DateInRegion via:\nswift\n.init(timeIntervalSince1970: TimeInterval)\n. Thank you!\n. Fixed and ready for 4.0.6 (https://github.com/malcommac/SwiftDate/commit/999498cadc4517b61c130c4f1e641032b6820a8d)\nThank you for your report.\n. Fixed for 4.0.6 in feature/4.0.6 branch https://github.com/malcommac/SwiftDate/commit/e8c019a4d30797e5506a0d475922608d1768b33a\n. Hi, you can use .in() method an specify the .day as parameter.\nswift\nlet D1 = try! \"1/2/2015\".date(format: .custom(\"dd/MM/yyyy\"))\nlet D2 = try! \"1/2/2016\".date(format: .custom(\"dd/MM/yyyy\"))\nlet v = (D2 - D1).in(.day) // 365\n. I've tried it right now; do you encounter a crash?\n. I've tried using DateInRegion instead of Date and it still works fine, in the comments what I get\nswift\nlet today = DateInRegion()\nlet tomorrow = DateInRegion() + 1.days\nlet diffInDays = (tomorrow - today).in(.day) // -> 1\nprint(tomorrow - today) // -> in seconds = 86400.0012260079\nCan you post your crash?\n. Ok should be fixed \ud83d\udc4d \n. I've fixed #306 in feature/4.0.7 branch. Did it work for you?\nI've reverted it because I've made it on master instead of inside the new release.\n. Thank you, it should help readability \ud83d\udc4d \nScheduled for 4.0.7\n. Thank you @rynecheow . Added for 4.0.7\n. I've a problem with readme merging into 4.0.7 branch.\nCan you repost this PR directly in feature/4.0.7 branch? thx\n. Okay I'll close this; you can open a new PR on feature/4.0.7 and I'll merge it.\nThank you again.\n. a sort of enumeration of dates; we could also give the opportunity to set a pre-defined time to apply to each enumerated date (optional maybe)\n. Thank you, I've just added it to 4.0.8 release both for DateInRegion and Date instances.\nhttps://github.com/malcommac/SwiftDate/commit/feddce907187428aa0b5e50ad1d686d433936528\nBelow an example with Date:\nswift\nlet from = Date().startOf(component: .day)\nlet to = from + 30.days\nlet dates = Date.dates(between: from, and: to, increment: 1.day)\nIt's pretty similar with DateInRegion:\nswift\nlet from = DateInRegion().startOf(component: .day)\nlet to = from + 30.days\nlet dates = DateInRegion.dates(between: from, and: to, increment: 1.day). Thank you!\n. it was fixed in 4.0.7. it will be released in some hours. thanks.\n. Fixed. thanks.. Fixed for 4.0.7.\nThank you!\n. Thank you, great fix!\n. I think the best solution is, as you said, to use the collatorIdentifier.\ni've fixed all folders in order to support this.\nAs default fallback we will return to en-US.\n. Duplicate of #317 \n. Just fixed and planned for 4.0.8. Thank you\n. Added in https://github.com/malcommac/SwiftDate/commit/a7c41006ea9425d49f3fa0b0a6a8cbbb266ea77c (4.0.9).\nThanks.. Thank you, it will be part of the 4.0.8 build.\n. Thank you\n. Is this a proposal? Can you explain it in details?\n. I'll close it\n. Thank you!\nIt will be part of the 4.0.8 update.\nFixed ko.lproj to ko-KR.lproj (https://github.com/malcommac/SwiftDate/commit/b8d331d22511f465e8a1ad524356435e5421f699)\n. Here it returns 1 correctly.\nCan you try again with 4.0.8?. Thank you for your contribution :)\n. The equivalent is:\nswift\nlet d = Date().startOf(component: .day) - 20.years. Date objects does not belong any specific timezone.\nIt simply represent the absolute amount of time elapsed since an interval (even if it's not correct you can image it at the UTC timezone).\nWhen you get the .absoluteDate from a DateInRegion object you are asking for the absolute representation of the time.\nYou should always store the timezone-indepentent value (plain Date/TimeInterval) and never the timezone related date.. Thank you!\nFixed sk to sk-SK.lproj (https://github.com/malcommac/SwiftDate/commit/942865dba50eddf36e63d929186a373679536851).\nIt will be part of the 4.0.8 update.\n. Fixed da.proj to da-DK.lproj\nhttps://github.com/malcommac/SwiftDate/commit/ce0d8bd59dee54b9a042459730371494f7f0791c\n. Thank you for your contribution!\n. Example:\nswift\nlet now = Date() // 2016-11-30 10:37:23 +0000\nlet dateInPast = Date() - 3.days // 2016-11-27 10:37:23 +0000\nlet sepreat = (now - dateInPast).in([.day,.hour,.minute]) // -3.days (3 days in the past)\nIt will return -3 for .day component and it's exact because the second date is in the past.\n\u25bf 3 elements\n  \u25bf 0 : 2 elements\n    - .0 : Foundation.Calendar.Component.minute\n    - .1 : 0\n  \u25bf 1 : 2 elements\n    - .0 : Foundation.Calendar.Component.hour\n    - .1 : 0\n  \u25bf 2 : 2 elements\n    - .0 : Foundation.Calendar.Component.day\n    - .1 : -3. We need to better understand this issue https://github.com/malcommac/SwiftDate/issues/317 before merging all the translation posted recently.\n. I've changed cs.lproj to cs-CZ.lproj\nhttps://github.com/malcommac/SwiftDate/commit/1b762cfe7aca80ac4e43ffc757b06855c29c6723\n. it's a typo, %d is enough. Just fixed.\n. Try withInternetDateTimeExtended:\nswift\nlet format = try! str.date(format: .iso8601(options: .withInternetDateTimeExtended))\n. I've made a mistake by merging it into master.\nJust fixed manually by porting your file with the correct collation identifier (tr-TR) into feature 4.0.8 here: https://github.com/malcommac/SwiftDate/commit/956b54b95a374229fbe7511c506595c8dab96625.\nPlanned for 4.0.8.\nThank you very much.. Thank you. I'm sorry but I've not enough time to maintain the old 2.3 branch. I've focused on 3+. However I'll be happy to integrate any sort of PR about bug fixing.\nThanks.. Yeah it will be available since 4.0.8 (this commit https://github.com/malcommac/SwiftDate/commit/6855337fd49792f309a56ab05b45401908593f34):\nThe signature is:\nswift\npublic func `in`(_ component: Calendar.Component, of calendar: CalendarName? = nil) -> Int?\nYour example:\nswift\nlet x = 120.seconds.in(.minute)\n. Thank you!. Thank you @Sepho, just added to 4.0.8 branch. Fixed only the collation identifier to es-ES. Is it okay? (https://github.com/malcommac/SwiftDate/commit/067cc18c70fab099d9373696913ba2bea90bfc57). Hi @cheolee ,\nI've another korean translation planned for 4.0.8 here: https://github.com/malcommac/SwiftDate/tree/feature/4.0.8/Sources/SwiftDate/SwiftDate.bundle\nIs this different from that?. With .startOf() and .endOf() you can get the start and end of any time component from your date.\nIn your case:\nswift\nlet d = try! \"2016-11-18T16:20:12.311Z\".date(format: .iso8601(options: .withInternetDateTimeExtended)) // 18 nov 2016, 17:20:12 CET\nlet firstDay = d.startOf(component: .month) // First day of the month: 01 nov 2016, 00:00:00 CET\nlet lastDay = d.endOf(component: .month) // Last day of the month: 30 nov 2016, 23:59:59 CET. Fixed. Added for 4.0.8. Thanks.. Hi @madsb, it's already planned for 4.0.8 (https://github.com/malcommac/SwiftDate/tree/feature/4.0.8/Sources/SwiftDate/SwiftDate.bundle).\nIs it different from that?. Just for completeness that's the code for SwiftDate:\nswift\nlet date1 = try! \"2016-11-18T16:20:12.311Z\".date(format: .iso8601(options: .withInternetDateTimeExtended))\nlet date2 = try! \"2016-11-18T16:20:12.212Z\".date(format: .iso8601(options: .withInternetDateTimeExtended))\nlet is1After2 = date1.isAfter(date: date2, granularity: .nanosecond) // return false\n```\n(lldb) po date.absoluteDate\n\u25bf 2016-11-18 16:20:12 +0000\n  - timeIntervalSinceReferenceDate : 501178812.21199989\n(lldb) po self.absoluteDate\n\u25bf 2016-11-18 16:20:12 +0000\n  - timeIntervalSinceReferenceDate : 501178812.31100011\n```\nAccording to NSDate documentation:\n\"[NSDate] ... makes possible a wide and fine-grained range of date and time values, giving precision within milliseconds for dates 10,000 years apart [...]\"\nSo I think it's a rounding error (even if comparing two dates using Calendar and nanosecond seems a bit weird).\nI've just added a workaround (planned for 4.0.8) you can found here:\nhttps://github.com/malcommac/SwiftDate/commit/7edca0338fa5948c349e64f63344c8dc6e93fd27. If it's all okay I plan to release it later tomorrow (dec. 1). Hi,\nIn order to parse correctly a 12h clock you need to use hh in place of HH for hour.\nBased upon your string I suggest you to use a custom formatter:\nBelow an example:\nswift\nlet str = \"30.11.2016, 10:00:00 PM GMT\"\nlet date = try! str.date(format: .custom(\"dd.MM.yyyy',' hh:mm:ss a ZZZZ\")) // 30 nov 2016, 23:00:00 CET\nIt will return 30 nov 2016, 23:00:00 CET as you need.\nMore on formatting options are available here. I think you are right, we should set en_US_POSIX manually. Thank you \ud83d\udc4d \nAdded for 4.0.9.. Just for reference, this is the official statement from Apple regarding NSDateFormatter and Internet Date&Time. It will be included in 4.0.9. Thanks. Hi,\nI'm sorry but actually I've not enough time to support old releases (< Swift 3).\nIf you want I'll be happy to integrate any PR which solves this issue.\nThanks.. Looking at Swift foundation library I can see that calendar/locale traking was not implemented yet (see for example here).\nBTW we can use current variant.\nMy only other concern is about localizable strings. As far I know there is not any support for bundles in linux (am I wrong?) so the only alternative I know is to use a classic folder with all variants and read from it based upon locale.\nAny other suggestion?. Since 4.0.12 SwiftDate allows to load a custom localization .strings file in DateInRegionFormatter.\nMore on #380.\nThe next step will include conditional compiling for autoupdating Locale and Calendar and the replacement of NSLocalizableString call on Linux inside Localization.\nI'll do it later the next week.. Follow #568. Yeah you are right.\nAdded here, it will be available since 4.0.9.\nThanks. Hi @solbadguyky,\nYeah you can make a PR with the bundle.\nYou can also paste here the translation of this file in your language (be sure to mantain the format strings %d and translate the month/year/day formats according to your locale). I'll add it for you into the next release.. Added and scheduled for 4.0.9. commit\nThank you!. Thank you @bati668. I've added it to 4.0.9 feature branch.. Hi,\nI've made several test and actually I'm able to reproduce this \"issue\" even with plain DateFormatter:\nswift\nvar str = \"1999-02-31 23:30:00\"\nvar f = DateFormatter()\nf.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\nf.locale = Locale(identifier: \"it\")\n//  f.calendar = Calendar.current // once you set it date is parsed...\nf.timeZone = TimeZone(identifier: \"Europe/Rome\")!\nlet parsedDate = f.date(from: str)\nparsedString is nil if does not set the calendar object; once you have set it the date is 'magically' parsed. . Cool, great find!\nI will add isLenient as settings of the SwiftDate's formatter later into the next minor release.. In order to avoid API breaking changes I've added a new formatter option called strict.\nWhen you use strict instead of custom heuristics guessing of the date is disabled and invalid date still remains invalid.\nswift\nlet regionRome = Region(tz: TimeZoneName.europeRome, cal: CalendarName.gregorian, loc: LocaleName.italian)\ndo { \n  let date1 = try DateInRegion(string: \"1999-02-31 23:30:00\", format: .strict(\"yyyy-MM-dd HH:mm:ss\"),   fromRegion: regionRome) // parser will fails\n} catch {\n  // fail\n}\nThis is the reference commit:\nhttps://github.com/malcommac/SwiftDate/commit/5ede1940500ee3ef89ee5932a369ca569ead9b2e. You're right @adrianodiasx93 . Yeah it could be great as introduction.\nI've scheduled it for 4.0.10. Keep track of this issue to stay update.. Fixed in https://github.com/malcommac/SwiftDate/commit/a7c41006ea9425d49f3fa0b0a6a8cbbb266ea77c.\nPlanned for 4.0.9.. Hi,\nOkay that's clearly a bug; when gap between two dates is expressed in minutes the value in your example is -8 and -8 < 5 minutes, so it's wrong perceived in \"just now\" case.\nI've solved it in this commit https://github.com/malcommac/SwiftDate/commit/88067f1485391558acf5b44a515d568630519703. You will found it in 4.0.9 upcoming release.\nThank you. Thank you, I'll add it for upcoming 4.0.9 release. Thank you!. Thank you very much, tests are always welcomed!. Great! I'll add it to 4.0.9. Thank you!. It should be ja-JP. Fixed in https://github.com/malcommac/SwiftDate/commit/9d72d1072b0e574f74f152db880e1b6d3bc87731\nI'll release it in 4.0.10 right now.. Can you make a test? It should be available on cocoapods. Thank you for your report!. Thank you!\nI've scheduled it for 4.0.11. Cannot use new two equal identifiers:\ncase portuguese = \"pt\"\ncase portugueseBrazil = \"pt_BR\"\nare now the same?. Translation was added in 4.0.11 here. You need to create a DateInRegion for your Canada datetime, then use toRegion() and pass the destination region.\n```swift\nlet absDate = // your NSDate/Date object\nlet canadaRegion = Region(tz: TimeZoneName.americaMontreal, cal: CalendarName.gregorian, loc: LocaleName.current)\nlet indiaRegion = Region(tz: TimeZoneName.asiaBangkok, cal: CalendarName.gregorian, loc: LocaleName.current)\nlet dateInCanada = DateInRegion(absoluteDate: absDate, in: canadaRegion)\nlet dateInIndia = dateInCanada.toRegion(indiaRegion)\n. Hi,\nThere is a problem with that func which prevents settings multiple components by keeping the old values while generating a valid date.\nSince 4.1.0 both in `Date` and `DateInRegion`:swift\n public func at(unitsWithValues dict: [Calendar.Component : Int]) throws -> DateInRegion\n public func at(unitsWithValues dict: [Calendar.Component : Int]) throws -> Date\n```\nare deprecated.\nReplacement functions are:\nswift\npublic func at(values: [Calendar.Component : Int], keep: Set<Calendar.Component>) -> DateInRegion?\npublic func at(values: [Calendar.Component : Int], keep: Set<Calendar.Component>) -> Date?\nBoth of them allows you to specify:\n- a set of components,values which alter the instance of the date\n- a set of components values which must copied from self instance to the new instance\nSo your func become:\n```swift\nlet now = Date() // 2017-03-31 17:32:42 +0000\nlet d1 = DateInRegion(absoluteDate: now, in: Region.GMT())\nprint(\"d1: (d1)\") // Mar 31, 2017, 5:32:42 PM GMT\nlet d2 = d1.at(values: [.year: 1900, .month: 1, .day: 1], keep: [.hour, .minute, .second])!\nprint(\"d2: (d2)\") // Jan 1, 1900, 5:32:42 PM GMT\n// or, if you don't need to keep time values...\nlet d3 = DateInRegion(components: [.year: 1900, .month: 1, .day: 1], fromRegion: Region.GMT())!\nprint(\"d3: (d3)\") // Jan 1, 1900, 12:00:00 AM GMT\n``. Thank you. Thank you for your report.\nThis happens when current evaluated time component's value is zero butallowedComponents` does not contains lower time components than the current. In this case we should have a \"this [component]\" translation.\nI've just commited it in https://github.com/malcommac/SwiftDate/commit/d481882d6328f812ba1cbfe5f4dc9a6a3c7fc76c and scheduled for 4.0.11.\nI've also updated Localizable strings with these variants:\n\"colloquial_n_0y\"                   =   \"this year\";        // this year\n\"colloquial_n_0m\"                   =   \"this month\";       // this month\n\"colloquial_n_0w\"                   =   \"this week\";        // this week\n\"colloquial_n_0d\"                   =   \"today\";            // this day\n\"colloquial_n_0h\"                   =   \"now\";              // this hour\n\"colloquial_n_0M\"                   =   \"now\";              // this minute\n\"colloquial_n_0s\"                   =   \"now\";              // this second. Thank you for your report; it's a bug because it try to unwrap and verify a component that is not part of the allowedComponents property.\nI've just fixed it in this commit https://github.com/malcommac/SwiftDate/commit/94682dbc73f453d20d502f8ecf3e9d549ae73400.\nIt will be part of the 4.0.11 release.\nJust a note:\nWhen you do let from = DateInRegion() + 2.days you are adding 2 days to the current date+time, so unless the current datetime is midnight resulting colloquial string is like \"tomorrow\" (or yesterday, the difference is less than 1 day).. Thanks. It's planned for 4.0.12. You should set allowedComponents to day in order to avoid formatting with lower time components.\nCannot try it right now but it should be:\nswift\nlet fmt = DateInRegionFormatter()\nfmt.allowedComponents = [.day]\nlet formatted = try fmt.colloquial(from: fromDate, to: toDate).colloquial. yup :-) I'll release it with the upcoming 4.0.12.\nthank you for your contribution. Thank you! it will be part of the 4.0.12 release.. If you want to get absolute Date object adjusted to the local region offset you can use .absoluteDate property.\nKeep in mind: .absoluteDate is, as the name says, absolute time interval which is not related to a particular time zone, as like the Date instance.. Thank you, it will be part of the 4.0.12. Actually it's not supported unless you manually modify one of the locales with your own data.\nHowever due to the fact we want also support Linux as target (see #352) we should need to provide an extra layer upon the NSLocalizedString() functions.\nI'm working on a LocalizationHelper class which is able to load a custom file at specified path as translation language; it should be pretty easy to develop and it can also be used to set a custom file as localized .strings file which suits your need.\nI'll post some updates on it in the following days, so keep an eye on this topic.. Added Localization class.\nReplaced locale property of DateInRegion with localization which is of type Localization.\nBy default it's initialized using the same DateInRegion's locale.\nYou can however set it with the absolute path to a valid .strings file:\nswift\nlet formatter = DateInRegionFormatter()\nformatter.localization = Localization(path: [PATH_TO_YOUR_STRINGS_FILE])\n// use the formatter\nIt will be available since 4.0.12.\nThat's the reference to the commit https://github.com/malcommac/SwiftDate/commit/f1f16721f34f36798279012213d25942e60593ee.. Hi,\nGreat addition; I've replaced old useImminentInterval with imminentInterval in DateInRegionFormatter, which defines an optional Int:\n- if imminentInterval = nil fallback is not supported. just now fallback is never printed\n- if imminentInterval = <value> where value must be an Int between 1...60 (not included). if differences between two dates is lower than value then the just now fallback string is printed\nBy default imminentInterval = 5 which means fallback is active with differences lower than 5 minutes.\nChanges will be available in 4.0.12.\nThis is the reference commit: https://github.com/malcommac/SwiftDate/commit/5ad817a5ae0cdf9e71cf599ad96becc1572545b7. Hi @szuniverse,\nYou, it was renamed to date():\n```swift\ndo {\n  let parsedDate = try myString.date(format: .custom(\"yyyy-MM-dd\"))\n} catch {\n  ...\n}\n// or, if you want to force try\nlet parsedDate = try! myString.date(format: .custom(\"yyyy-MM-dd\"))\n``. Right, it's the same property and return the absolute time fromDateInRegion` which is not dependent from the timezone.. Thank you for your contribution! I'll add it to 4.0.13 release. Hi, thank you for your work.\nI'm a bit hesitant because we want to make the lib compatible with Linux where the .strings and bundle does not exist. I think it could be the opportunity to introduce a custom localization schema but I need to think more about it.\nLet me think some days, I'll post discussion on this topic.\n. Thank you. Just fixed it in 4.1.0.\nReference commit is https://github.com/malcommac/SwiftDate/commit/0c23cb8adba2a3c2ef3716b9df8e75533be365de. Thank you.\nAdded in https://github.com/malcommac/SwiftDate/tree/feature/4.0.14.\nWill be available with 4.0.14 update.. Thank you \ud83d\udc4d  Nice addition\nI'll publish it along with 4.0.14 update. I'm not sure to understand your problem.\nIf you want to get the name in the locale you need to set the locale in region.\nThat's an example with GMT region but with locale in Italian and Spanish:\n```swift\nlet region_it = Region(tz: TimeZoneName.gmt, cal: CalendarName.gregorian, loc: LocaleName.italianItaly)\nlet region_es = Region(tz: TimeZoneName.gmt, cal: CalendarName.gregorian, loc: LocaleName.spanishSpain)\nlet d1 = \"26-02-2017\".date(format: .custom(\"dd-MM-yyyy\"), fromRegion: region_it)!\nprint(\"Weekday: (d1.weekday), Name: (d1.weekdayName)\") // Weekday: 1, Name: domenica\nlet d2 = \"26-02-2017\".date(format: .custom(\"dd-MM-yyyy\"), fromRegion: region_es)!\nprint(\"Weekday: (d2.weekday), Name: (d2.weekdayName)\") // Weekday: 1, Name: domingo\n``.2014/12/30 <-> 2015/01/04is week 1 (see https://www.epochconverter.com/weeks/2014)\nAlso2013/12/30<->2015/01/05` is week 1 (see https://www.epochconverter.com/weeks/2013)\nAlso if I try with SwiftDate the result for both of them is 1.\nThat's the code:\n```swift\nlet d1 = \"2014-12-30 23:00:00\".date(format: .custom(\"yyyy-MM-dd HH:mm:ss\"), fromRegion: Region.GMT())!\nprint(d1.weekOfYear) // 1\nlet d2 = \"2013-12-30 23:00:00\".date(format: .custom(\"yyyy-MM-dd HH:mm:ss\"), fromRegion: Region.GMT())!\nprint(d2.weekOfYear) // 1\n``. Yeah that's right; I've fixed it in 4.1.0.\nReference commit is https://github.com/malcommac/SwiftDate/commit/0c23cb8adba2a3c2ef3716b9df8e75533be365de. Hi, can you paste heredateString's value?. I've fixed the bug associated with your issue request: since 4.1.0 SwiftDate evaluates automatically the format used to parse ISO8601 date and generate aDateorDateInRegionby reading the timezone into the string.\nMoreover date parsing does not throws anymore, it just returnnil` if parse fails.\nI'll release it later tomorrow.\nYour parse is then much simpler, that's the code you will can use:\nswift\nlet date = DateInRegion(string: \"2017-03-13T14:00:17.000Z\", format: .iso8601Auto)\nwhich returns:\nMar 13, 2017, 2:00:17 PM GMT. If you need to take care of the timezone you should make this operation using the DateInRegion:\nswift\n let currentMonth = try! DateInRegion(components: cmp)\n let lastMonth = currentMonth - 1.month\nwithout transforming currentMonth in absolute Date.\nIt will output:\ncurrent: Mar 1, 2017, 12:00:00 AM GMT\nlast: Feb 1, 2017, 12:00:00 AM GMT\nA simpler way involve the use of endOf() function starting from a Date or DateInRegion instance:\nswift\nlet lastDayOfMonth = currentMonth.endOf(component: .month)\nso:\nswift\nlet firstDay = DateInRegion(absoluteDate: Date(), in: Region.GMT()).startOf(component: .month)\nlet lastDay = DateInRegion(absoluteDate: Date(), in: Region.GMT()).endOf(component: .month). Thank you for your report. Just fixed in 4.1.0.\nReference commit is https://github.com/malcommac/SwiftDate/commit/0c23cb8adba2a3c2ef3716b9df8e75533be365de. Thank you! I'll integrate it in 4.0.14 \ud83d\udc4d . Hi, you are right; since 4.1.0 both colloquial funcs for Date and DateInRegion accepts style property (DateComponentsFormatter.UnitsStyle) to specify the unit style of the formatter,.\nThank you.\nReference commit:\nhttps://github.com/malcommac/SwiftDate/commit/0c23cb8adba2a3c2ef3716b9df8e75533be365de. DateInRegion now implements a class function called date(string:formats:fromRegion) which can receive multiple formats as input. Each format is evaluated in order until the first one get a valid parsed date.\nReference commit:\nhttps://github.com/malcommac/SwiftDate/commit/255e90a95b7e31991d77256f98aafe651015ebc9. Also String has date(formats:fromRegion) equivalent func.. Hi, you can use absoluteDate to get the absolute Date value.. Added in 4.1.0\nThanks!\n66ab3915 Added greek localization (by @dimmdesign). Fixed in #404 thanks to @frederik-jacques.\nI'll publish 4.0.14 later today.. Thank you \ud83d\udc4d . Thank you! I'll add it in 4.1.0\n. I've added a de-AT.lproj which basically is a clone of de-DE.lproj. Added in 4.1.0 ISS8601Parser.\nThis is the reference commit: https://github.com/malcommac/SwiftDate/commit/255e90a95b7e31991d77256f98aafe651015ebc9. The following variants are supported:\n YYYYMMDD\n YYYY-MM-DD\n YYYY-MM\n YYYY\n YY //century \n  //Implied century: YY is 00-99\n   YYMMDD\n   YY-MM-DD\n  -YYMM\n  -YY-MM\n  -YY\n  //Implied year\n   --MMDD\n   --MM-DD\n   --MM\n  //Implied year and month\n    ---DD\n  //Ordinal dates: DDD is the number of the day in the year (1-366)\n YYYYDDD\n YYYY-DDD\n   YYDDD\n   YY-DDD\n    -DDD\n  //Week-based dates: ww is the number of the week, and d is the number (1-7) of the day in the week\n yyyyWwwd\n yyyy-Www-d\n yyyyWww\n yyyy-Www\n yyWwwd\n yy-Www-d\n yyWww\n yy-Www\n  //Year of the implied decade\n -yWwwd\n -y-Www-d\n -yWww\n -y-Www\n  //Week and day of implied year\n   -Wwwd\n   -Www-d\n  //Week only of implied year\n   -Www\n  //Day only of implied week\n   -W-d. All of the frills of ISO 8601 are supported, except for extended dates (years longer than 4 digits). Specifically, you can use week-based dates (2006-W2 for the second week of 2006), ordinal dates (2006-365 for December 31), decimal minutes (11:30.5 == 11:30:30), and decimal seconds (11:30:10.5). All methods of specifying a time zone are supported.\nISO 8601 leaves quite a bit up to the parties exchanging dates. I hope I've chosen reasonable defaults. For example (note that I'm writing this on 2006-02-24):\n\u2022 If the month or month and date are missing, 1 is assumed. \"2006\" == \"2006-01-01\".\n\u2022 If the year or year and month are missing, the current ones are assumed. \"--02-01\" == \"2006-02-01\". \"---28\" == \"2006-02-28\".\n\u2022 In the case of week-based dates, with  the day missing, this implementation returns the first day of that week: 2006-W1 is 2006-01-01, 2006-W2 is 2006-01-08, etc.\n\u2022 For any date without a time, midnight on that date is used.\n\u2022 ISO 8601 permits the choice of either T0 or T24 for midnight. This implementation uses T0. T24 will get you T0 on the following day.\n\u2022 If no time-zone is specified, local time (as returned by [NSTimeZone localTimeZone]) is used.\nWhen a date is parsed that has a year but no century, this implementation adds the current century.\nThe implementation is tolerant of out-of-range numbers. For example, \"2005-13-40T24:62:89\" == 1:02 AM on 2006-02-10. Notice that the month (13 > 12), date (40 > 31), hour (24 > 23), minute (62 > 59), and second (89 > 59) are all out-of-range.\nAs mentioned above, there is a \"strict\" mode that enforces sanity checks. In particular, the date must be the entire contents of the string, and numbers are range-checked. If you have any suggestions on how to make this mode more strict, contact me.\noriginal objc class by Peter Hosey:  https://bitbucket.org/boredzo/iso-8601-parser-unparser/src/900c739f57eab93f0823a6447613dfc58ed038b3/ISO8601DateFormatter.m?at=default&fileviewer=file-view-default. Nice addition, added in https://github.com/malcommac/SwiftDate/commit/4bcd67ad4d3e0229ac717e1dddd2b5eae6ad3067. It will be available since 4.1.1.\nDate and DateInRegion has now two functions to round a date to certain interval (expressed in seconds or minutes). DateInRegion exposes roundAt() which directly modify the date itself; Date, as immutable object, exposes the same feature in roundedAt() function (which return a new Date instances).. Thank you, just closed for 4.1.1. Fixed in https://github.com/malcommac/SwiftDate/commit/4bcd67ad4d3e0229ac717e1dddd2b5eae6ad3067. Fixed in https://github.com/malcommac/SwiftDate/commit/4bcd67ad4d3e0229ac717e1dddd2b5eae6ad3067 for 4.1.1. Fixed in https://github.com/malcommac/SwiftDate/commit/4bcd67ad4d3e0229ac717e1dddd2b5eae6ad3067. Done in https://github.com/malcommac/SwiftDate/commit/4bcd67ad4d3e0229ac717e1dddd2b5eae6ad3067. Added in https://github.com/malcommac/SwiftDate/commit/8ce71b172bd8f87511b567ffd9043e851296c256. Is there a way to check it in Simulator?\nBoth Locale and TimeZone uses the default autoupdating feature.. Thank you, fixed in https://github.com/malcommac/SwiftDate/commit/2699a1357e6f06da7aabd4dcb94fcc97bb05a4b2.. Just fixed in 4.1.2 alongside new unit tests.\nThank you!. Just fixed in 4.1.2 alongside new unit tests.\nThank you!. New introduced ISO8601 parser assumes current year/month/day if no date portion is specified.\nI've tried with 4.1.2 and it seems to work fine:\n```\n(lldb) po timeStartInRegion\nMay 8, 2017, 3:00:00 PM GMT\n(lldb) po timeEndInRegion\nMay 8, 2017, 10:00:00 PM GMT\n```\nWhile the output is converted in Region.Local() because you are passing a nil timezone. Can you repeat the test with 4.1.2 fork?. Any news?. Have you tried colloquial func and DateInRegionFormatter?. Should accomplish what you are searching for.. Take a look at colloquial functions, it returns what you are searching for. If your language is not part of the current set you may help us to support it. Also take a look at unit tests for concrete examples.\nThank you!. You must modify Calendar's firstWeekday property.\nHowever since 4.1.2 there is a firstWeekday property directly inside the Region struct.\nThat's an example from tests:\nswift\nvar region = Region(tz: TimeZoneName.europeParis, cal: CalendarName.gregorian, loc: LocaleName.frenchFrance)\nregion.firstWeekday = .monday\nlet new_date = DateInRegion(absoluteDate: Date(), in: region)\nXCTAssertEqual(\"lundi\", new_date.startWeek.weekdayName, \"Failed to set the firstWeekday for a Region\")\nThank you for your report!\nD.. Thank you! I'll publish it with 4.1.3. Fixed for 4.1.2. Details in commit alongside tests.\nThank you!. you can use .absoluteDate which return the Date representation of the DateInRegion instance.. Fixed for 4.1.2. Details in commit alongside tests.\nThank you!. Hi, can you tell me more about these results; I've tried both on simulator and device with different timezones and I always get 2 years. Can you also try with 4.1.2? I've just fixed several issues with colloquial functions.. Any news?. Since the last update DateInRegion init functions does not throws anymore. It returns nil value if parsing fails. Seems you are building against an old version or something like that. Have you tried to clean and build?. You will find it in 4.1.6.\nThank you. I've tried with an empty project.\nFirst of all I've created the Cartfile file (touch Cartfile)\nThen I've added the record for SwiftDate (github \"malcommac/SwiftDate\" \"feature/4.1.5\" - I've tried the repo currently in development but it's the same with develop or master).\nThen I've tried to build:\ndiesel-mac:test daniele$ carthage update --platform iOS\n*** Please update to the latest Carthage version: 0.23.0. You currently are on 0.22.0\n*** Cloning SwiftDate\n*** Checking out SwiftDate at \"f8206f5457e773e03df1ad1f8f9587420784f145\"\n*** xcodebuild output can be found in /var/folders/m4/6h1cv6ds2_q18rc_6w5z22dc0000gp/T/carthage-xcodebuild.iopPUg.log\n*** Building scheme \"SwiftDate\" in SwiftDate.xcodeproj\ndiesel-mac:test daniele$\nEverything was okay.\nThen I've added it to my project, added Copy Phase for Framework and tried to run.\nNo problem found.\nCan anyone tell me the exact steps to reproduce the problem?\nThanks. I'll investigate on armv7k, the watchOS architecture.. Tried here with:\n- Locale: UK\n- Language: English\n- Calendar: Buddhist\nand it works fine.\nYou can also try to force the region to your region. If the date represent a date in UK you can do this:\nswift\nlet actualArrivalTimeDate = \"18 May 2017 10:48\"\nlet regionUK = Region(tz: TimeZoneName.europeLondon, cal: CalendarName.gregorian, loc: LocaleName.english)\nlet parsedDate = actualArrivalTimeDate.date(format: .custom(\"dd MMM yyyy HH:mm\"), fromRegion: regionUK). Results depend on your Region settings.\nIf you are using Date objects you can set the defaultRegion and change only the locale parameter.\nFollowing example keeps the current device's calendar + timezone and set only the locale to english (ignoring current device's locale).\nswift\nDate.setDefaultRegion(Region(tz: TimeZoneName.current, cal: CalendarName.current, loc: LocaleName.englishUnitedStates))\nprint(\"Current weekday name is \\(Date().weekdayName)\")  // saturday. Thank you \ud83d\udc4d . Are you building a fat framework for all platforms?. Fat frameworks are libs which includes several platforms.\nI've tried building SwiftDate for iOS using carthage:\ncarthage update --platform iOS\nSwiftDate.framework is 10MB.\nIt includes several architectures: i386 x86_64 armv7 arm64\ndiesel-mac:test daniele$ lipo -info /Users/daniele/Desktop/test/Carthage/Build/iOS/SwiftDate.framework/SwiftDate \nArchitectures in the fat file: /Users/daniele/Desktop/test/Carthage/Build/iOS/SwiftDate.framework/SwiftDate are: i386 x86_64 armv7 arm64\nAppStore's thinning mechanism (bitcode) will exclude non interesting architectures.\nSo, for example, using lipo tool I've tried to keep only armv7:\ncd /Users/daniele/Desktop/test/Carthage/Build/iOS/SwiftDate.framework \nlipo SwiftDate -thin armv7 -output SwiftDate-armv7.a\nWill output a 2.5MB library as you see below\n. No you're welcome :). Hi,\nThere is not any func called Date.dateInRegion.\nCurrent functions return correct values:\nswift\nlet today_dr = DateInRegion()\nlet today_d = Date()\nprint(\"current day from DateInRegion: \\(today_dr.day)\") // current day from DateInRegion: 10\nprint(\"current day from Date: \\(today_d.day)\") // current day from Date: 10\nSame results from debugger.\nAre you sure you have compiled SwiftDate without optimizations? (see GCC_OPTIMIZATION_LEVEL for your current Debug release).. Thank you! I've pushed it in Swift-4 branch. When you play with a Date instance you are working with an absolute amount of time which is not related to any timezone or region in the world. That's how Dates works on iOS.\nYou can get a Date in a particular TimeZone because it simply does not make sense.. Already fixed in swift-4 branch. thanks. Hi, You are attempting to print a Date object using .NET formatter.\nUsing plain Date instances you are referring to an absolute time interval which does not contains informations about the timezone.\nDate/NSDate represent absolute time intervals.\nIn order to correctly print your date as string you may want to print the DateInRegion instance you have created using .date(format: .dotNET function (DateInRegion instances include the Region, a struct with TimeZone, Locale and Calendar in which your date should be represented).\nIn fact printing your date from date var you will get the correct results:\nswift\nlet myDotNetDate = \"/Date(-2208992400000+0100)/\"\nif let date = myDotNetDate.date(format: .dotNET) {\n    print(date(format: .dotNET))\n}\nYou will get\n/Date(-2208992400000+0300)/\n/Date(-2208992400000+0300)/. Thank you for your report. It's not the correct behaviour but I've fixed it inside the new 4.1.6 build and added your as a unit test.\nThis is the reference commit https://github.com/malcommac/SwiftDate/commit/057aafb75b1367b7fb386ff2557fa857418b3a23.\nAgain thank you.. Thank you! I'll add it to the next update. Hi, can you give to me the input string value? thanks. I've tried to reproduce your issue but here it works fine.\nWhat's the TZ of your device?\n\n. No, TZ influence is ignored when you set the default region.\nAnyway defaultRegion\u00a0is used when you are working with plain Date\u00a0objects directly.\nIf you are using DateInRegion you can pass the fromRegion parameter.\nJust to avoid confusion:\nwhen you are parsing an ISO8601 date the timezone is specified by the string; in this case 1995-06-21T00:00:00Z is specified in UTC timezone. fromRegion parameter is used to define the tz (along with calendar and locale) in which the DateInRegion should be treated.\nSo if you set the Rome TZ (now +2) the date will be printed in specified timezone (while the absoluteDate property still expressed in absolute datetime).\n```swift\n// ISO8601 date (expressed in UTC)\nlet str = \"1995-06-21T00:00:00Z\"\n// Parse date and print in UTC TZ (the same of the input)\nlet utcDate = DateInRegion(string: str, format: .iso8601Auto, fromRegion: Region.GMT())\nlet utcDate_str = utcDate!.string(format: .custom(\"dd/MM/YYYY HH:mm:ss\"))\nprint(utcDate_str) // 21/06/1995 00:00:00\n// Parse date and print it in Rome TZ (+02:00 in July)\nlet inRome = DateInRegion(string: str, format: .iso8601Auto, fromRegion: Region(tz: TimeZoneName.europeRome, cal: CalendarName.gregorian, loc: LocaleName.italian))\nlet date_inRome = inRome!.string(format: .custom(\"dd/MM/YYYY HH:mm:ss\"))\nprint(date_inRome) // 21/06/1995 02:00:00 <----- See the difference\n```\nI've also tried to set -3 in my TZ but I still see the correct date and I can't reproduce your issue. If you want you can send to me an empty project with your set so we'll exclude any other issue.. Hi @filipealva ,\nThe new initializer takes Calendar.Component inputs:\nDateInRegion(components: [Calendar.Component : Int])\nSo the following code:\nswift\nlet date2 = DateInRegion(components: [.year: 2016, .month: 6, .day: 1])\nproduce 01 giu 2016, 00:00:00 CEST. Yup.\nYou can get the absolute date from DateInRegion using .absoluteDate. Since 4.1.7 nextMonth and prevMonth properties are deprecated and replaced by:\n(for DateInRegion):\nswift\n- public func prevMonth(at time: TimeReference = .auto) -> DateInRegion\n- public func nextMonth(at time: TimeReference = .auto) -> DateInRegion\nand (for plain Date):\nswift\n- public func prevMonth(at time: TimeReference = .auto) -> Date\n- public func nextMonth(at time: TimeReference = .auto) -> Date\nTimeReference allows you to specify the way in which the date is calculated:\n .auto: evaluated date is calculated by adding one time component (month/week) to the current date.\n .start: result date is the first day of the next time component (month/week) (at 00:00:00).\n* .end: result date is the last day of the next time component (month/week) (at 23:59:59).\nSo, coming back to your issue you can get the first day of each month by using:\nswift\nlet gmt = Region(tz: TimeZoneName.gmt, cal: CalendarName.gregorian, loc: LocaleName.english)\nllet startDate = DateInRegion(string: \"2017-07-16 16:00:00 +0000\", format: .iso8601Auto, fromRegion: gmt)!\nvar nextDate = startDate.prevMonth(at: .start) // move at the start of previous month\nfor _ in 0..<10 {\n  nextDate = nextDate.nextMonth(at: .start) // get the first day of the next month (use .end to get the last day)\n  print(nextDate.string(format: .iso8601Auto))\n}\nI've also added prevWeek() and nextWeek() both to Date and DateInRegion.\nThank you for your report.\nThese fixes will be included in 4.1.7.\n. Reference commits:\n- https://github.com/malcommac/SwiftDate/commit/c500dfa97e2497a0f24cf9ae579deb93dabcfb38 for nextMonth() and prevMonth()\n- https://github.com/malcommac/SwiftDate/commit/4ccc2960caaf86cae96b84c4e9857edd1f017c9c for nextWeek() and prevWeek()\nand finally https://github.com/malcommac/SwiftDate/commit/d6bbfd022c867250176f1b1cf3437741be9bb5cb for unit tests.. Thank you for your report.\nI've fixed it; now when no locale language is defined fallback is to country code (so, for example, with ar-SA it will try to fallback to ar).\nFixes is part of the 4.1.7 release.\nReference commit is: https://github.com/malcommac/SwiftDate/commit/cbd8e4d9bdc725484ef609cf701c5f3e52615dea. Sorry :-). Thank you!. Thank you for your report. I've fixed the ISO8601 Parser and now it works correctly.\nswift\nlet string = \"2017-07-16T03:54:37.800Z\"\nlet date = DateInRegion(string: string, format: .iso8601(options: .withInternetDateTimeExtended),fromRegion: Region.GMT())\nlet str = date!.string(format: .iso8601(options: .withInternetDateTimeExtended))\nCorrectly returns: 2017-07-16T03:54:37.800Z\nFix will be included in 4.1.7.. Reference commit is: 79feaf88. @plm75 can you provide some examples?\nI've tried with three intervals and it works fine:\nswift\nlet ago_now = try! Date().colloquialSinceNow().colloquial // just now\nlet ago_6_minutes = try! (Date() - 6.minute).colloquialSinceNow().colloquial // 6 minutes ago\nlet ago_45_minutes = try! (Date() - 45.minute).colloquialSinceNow().colloquial // 45 minutes ago. @RolandasRazma can you paste the code here? thx. \nMay the dated crosses a day?\n(can you test with 4.1.8?). Thank you @plm75. We have revisited that functions not so long ago so this explain all.\nHave a nice day. Hi,\nyou can use weekdayShortName and weekdayName.\nI'll unify the name of these variable inside the next minor update.\nThanks. Reference: https://github.com/malcommac/SwiftDate/commit/77740d9f40d4df36bc8c7e266b174d5ca2ad7e62. It should be \"on 2016\". what's the equivalent for \"on\"? I see \"in\" in google translate; is this correct?. Can you make a check of the /Sources/SwiftDate/SwiftDate.bundle/nl-NL.lproj/SwiftDate.strings and tell me if there is something else wrong?\nLink to SwiftDate.strings in nl-NL\n. Hi, can you post an example with real data?\nI've tried with the result you have printed, so:\nswift\nlet day_a = DateInRegion(string: \"2017-08-06 11:59:59 +0000\", format: .iso8601Auto)!\nlet day_b = DateInRegion(string: \"2017-08-05 12:00:00 +0000\", format: .iso8601Auto)!\nlet is_the_same_day = day_a.isInSameDayOf(date: day_b) // false\nIt return false.\nI think there is something wrong with TZ of the two dates.\n\n. This because when compared both Date are moved to your defaultRegion() Region.\nThis is the code portion for this func:\nswift\n/// Returns whether the given date is on the same day as the receiver in the time zone and calendar of the receiver.\n/// Calculation is made in the context of `defaultRegion`.\n///\n/// - parameter date: a date to compare against\n///\n/// - returns: a boolean indicating whether the receiver is on the same day as the given date in\n///             the time zone and calendar of the receiver.\npublic func isInSameDayOf(date: Date) -> Bool {\n    return self.inDateDefaultRegion().isInSameDayOf(date: date.inDateDefaultRegion())\n}\nIf not changed Region is the local region (device's timezone, device's calendar and device's locale).\nSo (assuming my region, GMT +2) for your last date you will have:\n- date = 2017-09-09 21:59:59 +0000 -> inDefaultRegion() -> Sep 9, 2017, 12:00:00 AM GMT+2\n- lastDay = 2017-09-09 21:59:59 +0000 -> inDefaultRegion() -> Sep 9, 2017, 11:59:59 PM GMT+2\nand in that timezone they represent the same day.\nA solution is to set the GMT region at startup (or before doing the code you have pasted):\nDate.setDefaultRegion(Region.GMT())\nSo your date will be compared against the GMT (/UTC) timezone.\nor use DateInRegion as you have done.. Thank you. it will be part of 4.1.8 update. Hi,\nas you said colloquial ignore the unitStyle parameter. You should fallback to timeComponents function.\nswift\nlet opts = ComponentsFormatterOptions(style: .abbreviated, zero: .dropLeading)\nlet string = try! date.timeComponentsSinceNow(options: opts) // 1h\nI think we should avoid adding other localizations entries to describe what, in fact, is time component. However the best way is to fallback automatically to timeComponents function when unitStyle is set to an abbreviated form.\nI'll post this fix in 4.1.8 release.\nThank you for your report @daviskoh . Thanks!. Have you tried to set a different locale?\nWhat's your .currentLocale?. I'll close it due to no response received.. I'm not expert about Carthage; can you help me?\nI've found it http://www.mokacoding.com/blog/carthage-no-build/. Thank you, it will be part of 4.1.8 release. I think we have a problem here, I think I've made a mistake; can you explain me why we can't have DateTimeInterval with negative values?\n@hackugyo . @leviathan I've fixed that, there is not any valid reason to keep this condition. Now DateTimeInterval supports negative interval. See the commit above.. Thank you, merged #468. Remove this as duplicate.. Thank you. it will be part of 4.1.8 update. CalendarName now supports RawRepresentable protocol so you can init and extract a String from it.. I've updated swift-4 branch. Thanks \ud83d\udc4d . Is it working fine? From what I know Russian should treat plural form based upon the represented number (so \"in 3 months\" should be different from \"in 5 months\" or something like that).. thank you :). Hi @Kuniwak , unfortunately it was a mistake. Just restored. Please try again.\nD.. Use: \nswift\n guard let betweenDays = (nowDate  - cardDate).in(.day) else {. Updated #480 by adding support for negative intervals in DateTimeInterval struct.\nReady to go live in 4.1.12.. Thank you!. I've added support for negative intervals in DateTimeInterval.\nIs now valid to use which end date occurs earlier in time than the start date (it means negative duration).\nAll comparison and intersects functions adjust the bounds of the interval (by switching them) if needed.\nAlso unit tests are added to validate the behaviour.. Okay fixed.\nNow you a-b remove b absolute time from a (if b is more recent than a you will get negative results).\nAlso fixed unit tests.. Please refer to #480 . Closing it.. I'm a bit perplexed. Your PR has the same content of the DOTNETDateTimeFormatter https://github.com/malcommac/SwiftDate/blob/feature/4.3.1/Sources/SwiftDate/DOTNETDateTimeFormatter.swift with range(at) replaced by rangeAt(). Let's try 4.4.1 and tell me if it's solved.. In Swift 4.x project rangeAt() is renamed range(at:)\nAre you sure you are using it in a Swift 4 project?\n\n. Just a notice:\nSwift 3 and Swift 4 Compatibility\n\nSwift 4.x: >= 4.4.0 - Latest is 4.4.0 Download here.\n\nSwift 3.x: Latest compatible version is 4.3.0 Download here. If you are using CocoaPods be sure to fix the release (pod 'SwiftDate', '~> 4.3.0')\n. No problem :). Try 4.4.1 on cocoapods.\nThanks.. Cannot reproduce it. Can you make a new project with SwiftDate pods and import+compile it?\n(You can also try to remove Pods and Pod.lock and update it). Just for reference:\n\n\nSwift 4.x: >= 4.4.0 - Latest is 4.4.0 (pod 'SwiftDate')\n\nSwift 3.x: Latest compatible version is 4.3.0 (pod 'SwiftDate' '~> 4.3.0')\nSwift 2.3: Latest compatible version is 3.0.9 (pod 'SwiftDate' '~> 3.0.9')\n. Are you using Swift 3? You need to block your pod to 4.30 as specified above, otherwise you will get the latest swift 4 version.. Are you using 4.4.0 in a Swift 3.x project?. That's the problem.\n4.4.0 is built for Swift 4\n<= 4.3.0 is built for Swift 3.x\n\nCheck out the README.md file under 'Current Release' Section:\nhttps://github.com/malcommac/SwiftDate/blob/master/README.md\n```\nCurrent Release\nSwift 4.x: >= 4.4.0 - Latest is 4.4.0 Download here.\nSwift 3.x: Latest compatible version is 4.3.0 Download here\nSwift 2.3: Latest compatible version is 3.0.9 on swift_23 branch\n```\nYou must fix your CocoaPods (if you are using it) to use 4.3.0 (pod 'SwiftDate', '~> 4.3.0'). Resolved in 4.4.2.\nhttps://github.com/malcommac/SwiftDate/commit/affe3b5eea8d3604125a71b4875900414269add6. Have you added translations in your project?\nBy default only english is present even if you have multiple localizable files.\n\n. Introduced a new ColloquialDateFormatter class in order to replace the old DateInRegionFormatter (now deprecated).\nThis class is specialized to format dates difference in colloquial format.\nDEPRECATED METHODS\nThe following methods are now deprecated.\nswift\npublic func colloquialSinceNow(in region: Region? = nil, unitStyle: DateComponentsFormatter.UnitsStyle = .short, max: Int? = nil, zero: DateZeroBehaviour? = nil, separator: String? = nil) throws -> (colloquial: String, time: String?)\nis replaced by:\nswift\npublic func colloquialSinceNow(in region: Region? = nil, options: ColloquialDateFormatter.Options? = nil) -> String?\n\nswift\npublic func colloquial(to: Date, in region: Region? = nil, max: Int? = nil, zero: DateZeroBehaviour? = nil, separator: String? = nil) throws -> (colloquial: String, time: String?)\nis replaced by:\nswift\npublic func colloquial(to: Date, in region: Region? = nil, options: ColloquialDateFormatter.Options? = nil) -> String?\n\nswift\npublic func colloquialSinceNow(style: DateComponentsFormatter.UnitsStyle? = nil) throws -> (colloquial: String, time: String?)\nis replaced by:\nswift\npublic func colloquialSinceNow(options: ColloquialDateFormatter.Options? = nil) -> String?\n\nswift\npublic func colloquial(toDate date: DateInRegion, style: DateComponentsFormatter.UnitsStyle? = nil) throws -> (colloquial: String, time: String?)\nis replaced by:\nswift\npublic func colloquial(toDate date: DateInRegion, options: ColloquialDateFormatter.Options? = nil) -> String?\nHOW WORKS NEW CLASS\nColloquialDateFormatter is used automatically from the new functions above (or directly by calling its static functions:\nswift\npublic static func colloquial(from fDate: DateInRegion, to tDate: DateInRegion, options fOpt: ColloquialDateFormatter.Options? = nil) -> String?\nIt takes three arguments: dates to compare and a formatter options struct called ColloquialDateFormatter.Options.\nColloquialDateFormatter.Options define a set of parameters used to get the date using colloquial format:\n\nallowedComponents: Define the list of allowed components used to format a date diff. If you want exclude one or more time unit (ie. you are not interested in printing the weeks but you want to get only the days) you can set a different set of components (ie. [.day]). By default all components are allowed ([.year, .month, .weekOfYear, .day, .hour, .minute, .second]).\nimminentRange: Define the maximum amount of time used to fallback a dates difference to \"just now\" fallback. You need to express it in DateComponents, so if you want a \"just now\" result when difference is less than one hour and 5 minutes you need to set it to 1.hour + 5.minutes. By default this value is set to 5.minutes, so when difference is below five minutes the colloquial result return just now in set locale.\ndistantRange: Define the minimum amount of time used to fallback a colloquial string to an absolute version of the data; for example if you set it to 2.months when date diff is longer than 2 months you will get an absolute value (ie. dd/MM instead of in 3 months). By default this value is set to nil so fallback never occurs.\nlocale: Define the locale used to produce colloquial string representation. If not set (nil) locale is taken from the Region's locale of the first date but if you prefer you can force it to your own settings.\n. Fixed issues:\nFixed an issue where a difference between dates occurs crossing two days it was incorrectly reported (now it returns 'yesterday' or 'tomorrow' instead of the absolute number of hours'\nFixed an issue with the imminent range which causes bad formatted strings with 'just now' when date diff is longer than interval set (old version was 5 minutes, now you can set it via imminentRange).\nFixed an issue reporting the wrong weeks difference when dates diff is longer than 7 days.. @alexanderkhitev \nTo print by excluding the just now fallback you can now remove the imminentRange.\nFor example:\n\nswift\nlet d1 = DateInRegion()\nlet d2 = d1 + 5.minutes\nvar opts = ColloquialDateFormatter.Options()\nopts.imminentRange = nil // remove the fallback to `just now` by setting the imminentRange to nil\nlet colloquial = d2.colloquial(toDate: d1, options: opts)\nprint(colloquial) // in 5 minutes (for en). Just released.\nTell me if it works fine for you so I'll add more unit tests.\nThanks.. @alexanderkhitev fixed and added your case to our unit tests. Please refer to #512 . Thank you. What version are you using? Are you compiling with Swift 4?. Fixed in https://github.com/malcommac/SwiftDate/commit/e993a1b13ea9c9588e29c79b7543c310be88da63\nPlanned release: 4.4.2. Thank you \ud83d\udc4d . Hi @ernestofndz , may I ask to post the code used for these test here so I can make further investigations? Thanks. Thank you for your report.\nFunction return wrong values because conversion take care of the interval starting from a specific date (specifically range used by the function is {Date() - Date() - interval}).\nI've modified the function to allow passing a start reference date.\nIf date is passed conversion take care of this value.\nIf date is not passed conversion is absolute but only a small subset of time components are accepted (.day,.hour,.minute,.second).\n``swift\n/// Express given time interval in other time units.\n/// If a reference date (fromDate) is not specified conversion is aware of day light saving times and other possible nasty things\n/// (only.day,.hour,.minute,.secondare supported as components).\n/// If a reference date is specified conversion is made using the interval from passed reference date and include calendar/date\n/// specific events.\n///\n///\n/// - Parameters:\n///   - components: components to extract\n///   - date: reference date;niluses absolute conversion, valida date to set the interval from a specific date.\n///   - calendar: context calendar;nilusesDate.DefaultRegion.calendarinstead\n/// - Returns: components\npublic funcin`(_ components: [Calendar.Component], fromDate date: Date? = nil, of calendar: Calendar? = nil) -> [Calendar.Component : Int] {\n    guard let refDate = date else {\n            // Absolute conversion, not taking care of specific starting date\n        let days = Int( (components.contains(.day) ? self / (60 * 60 * 24) : 0) )\n        let hours = Int((components.contains(.hour) ? ((self / (60 * 60)) - (Double(days) * 24)) : 0))\n        let minutes = Int( (components.contains(.minute) ? ((self / 60) - (Double(days) * 24 * 60) - (Double(hours) * 60)) : 0))\n        let seconds = Int( (components.contains(.second) ? (self - (Double(days) * 24 * 60) - (Double(hours) * 60 * 60) - Double(minutes) * 60) : 0))\n    var components: [Calendar.Component : Int] = [:]\n    if (days != 0)      { components[.day] = Int(days) }\n    if (hours != 0)     { components[.hour] = Int(hours) }\n    if (minutes != 0)   { components[.minute] = Int(minutes) }\n    if (seconds != 0)   { components[.second] = Int(seconds) }\n    return components\n}\n\nlet cal = calendar ?? Date.defaultRegion.calendar\nlet dateFrom: Date = refDate\nlet dateTo: Date = dateFrom.addingTimeInterval(self)\nlet cmps = cal.dateComponents(componentsToSet(components), from: dateFrom, to: dateTo)\nreturn cmps.toComponentsDict()\n\n}\n``. Thank you, I did not know this param. Will it replace the old.swift-version` file inside the root folder?. There is something wrong because XCode report it as an error:\n\n. Thank you! I'll add it to 4.5.0. Hi,\nFor first question we should move the codebase to stringsdict in order to support these variants; I'll start working on it before 5.x.\nSecond question: replacing %d years ago with the specific year's value is used because in colloquial format you don't say \"5 years ago\" but simply \"2012\". It's just a choice for clarity and nothing more.\nCan I merge your PR into the next release? I don't understand how you have solved the first point.\nThanks for your support.. Can you post an example of code?. The problem here is you can't evaluate calendar specific components (like months) without using a reference date where start the interval.\nThis because months does not always contains the same number of days.\nOld version uses current date minus the interval as reference settings.\nI've restored the old behaviour but I've added an alert in debug using debugPrint().\nswift\n/// Express given time interval in other time units.\n/// Evaluation must use two reference dates to evaluate specific calendar components (like days, months or weeks).\n/// If not specified the end date range is set to now, while starting date is set to (now-interval).\n/// NOTE: calendar specific components (like months) may return altered results if you don't specify a date range.\n///\n///\n/// - Parameters:\n///   - components: components to extract\n///   - date: reference end date; `nil` uses absolute conversion.\n///   - calendar: context calendar; `nil` uses `Date.DefaultRegion.calendar` instead\n/// - Returns: components\npublic func `in`(_ components: [Calendar.Component], toDate date: Date? = nil, of calendar: Calendar? = nil) -> [Calendar.Component : Int] {\n  if date == nil && components.contains(where: { [.day,.month,.weekOfYear,.weekOfMonth,.year].contains($0) }) {\n    debugPrint(\"[SwiftDate] Using .in() to extract calendar specific components without a reference date may return wrong values.\")\n  }\n  let cal = calendar ?? Date.defaultRegion.calendar\n  let dateTo = date ?? Date()\n  let dateFrom: Date = dateTo.addingTimeInterval(-self)\n  let cmps = cal.dateComponents(componentsToSet(components), from: dateFrom, to: dateTo)\n  return cmps.toComponentsDict()\n}. Hi,\ncheck the isBetween(date: Date, and date2: Date, orEqual: Bool = false, in region: Region? = nil, granularity: Calendar.Component = .nanosecond) function.. isInRange() function allows what you need in SwiftDate 5.x. There are several ways to accomplish your task. You can use the standard math operation to get the differences in seconds or you can express it in several other time units using the getInterval() function.\nThe example below show the differences between your dates in minutes:\nswift\nlet requestTimeFromDate = \"13:15:00\".toDate(\"HH:mm:ss\")!\nlet requestTimeToDate = \"13:35:00\".toDate(\"HH:mm:ss\")!\nlet diff = requestTimeFromDate.getInterval(toDate: requestTimeToDate, component: .minute) // 20 minutes\n(code was updated to SwiftDate 5.x). Since SwiftDate 5.x you can use weekDayName function and you can override the current locale of the date (>=5.12):\nswift\nlet region = Region(calendar: Calendars.gregorian, zone: Zones.europeLondon, locale: Locales.chinese)\nlet date = \"2017-12-29\".toDate(\"yyyy-MM-dd\", region: region)\nlet string = date?.weekdayName(.short, locale: Locales.english) // you can specify the output locale directly. Since SwiftDate 5.x TimePeriod,TimePeriodCollection and TimePeriodChain can help you.. You can use toISO() since SwiftDate 5.x:\nswift\nactivityMotion.startDate.inDefaultRegion().toISO(). Thank you! It will be part of 4.5.2. Hi, unfortunately I'm not able to support both 4.x and 5.x branches.\nCarthage works fine in SwiftDate 5.x\ndanielembp15:porva daniele$ carthage update\n*** Cloning SwiftDate\n*** Checking out SwiftDate at \"5.0.12\"\n*** xcodebuild output can be found in /var/folders/bp/7z5xsw313y18psjjv7pk9z880000gp/T/carthage-xcodebuild.fQE7Fd.log\n*** Building scheme \"SwiftDate-macOS\" in SwiftDate.xcodeproj\n*** Building scheme \"SwiftDate-tvOS\" in SwiftDate.xcodeproj\n*** Building scheme \"SwiftDate-watchOS\" in SwiftDate.xcodeproj\n*** Building scheme \"SwiftDate-iOS\" in SwiftDate.xcodeproj. Since SwiftDate 5.x it was fixed; thanks.\n(Updated code)\n```swift\nlet now = DateInRegion()\nprint(\"now = (now)\\n\")\nlet iso8601_string = now.toISO([.withInternetDateTime])\nprint(\"iso8601 string = (iso8601_string)\\n\")\nprint(\"absoluteDateTime UTC = (now.date)\\n\") // UTC format\nlet absoluteDate = now.date\nlet absoluteDate_iso8601_string = absoluteDate.toISO([.withInternetDateTime])\nprint(\"absoluteDate iso8601 string = (absoluteDate_iso8601_string)\\n\")\n``. Cannot support SwiftDate 4.x anymore. Please refer to 5.x branch. SwiftDate 4.x branch is not supported anymore.\nSwiftDate 5.x includes support for Codable yet.\nThanks for your contribution.. Since SwiftDate 5.x you haddateAtEnd()anddateAtStart()`.\nFrom doc:\n\n3.9 - Date at start/end of time component\nTwo functions called .dateAtStartOf() and .dateAtEndOf() allows you to get the related date from a Date/DateInRegion instance moved at the start or end of the specified component.\nYou can, for example, get the date at the start of the week, or the year, or a the end of the quarter.\n\nfunc dateAtStartOf(_ unit: Calendar.Component) -> DateInRegion: return the date at the start of the specified time component.\nfunc dateAtEndOf(_ unit: Calendar.Component) -> DateInRegion: return the date at the end of the specified time component.. SwiftDate 4.x is not supported anymore.. SwiftDate 4.x is not supported anymore.. SwiftDate 5.0 has built-in support for Codable/Decodable both for DateInRegion and Region objects.\nSee documentation.. You can use the formatting options into the TimeInterval extension like toClock() or toString() (it will be renamed since 5.0.13).\n\n\nThis is just a little example\n```swift\nlet d1 = DateInRegion()\nlet d2 = DateInRegion() + 1.hours + 2.minutes + 30.seconds\nlet f1 = (d1 - d2).toClock() // 1:02:30\nlet f2 = (d1 - d2).toIntervalString { // 1hr 2min 30sec\n    $0.unitsStyle = DateComponentsFormatter.UnitsStyle.brief\n}\n```\nSee the relative doc for more infos.. Thank you. 5.0.1 Released. I'll close it.. Thank you. Hi,\nthere is a big difference between SwiftDate 4.x and 5.x and it regards the default region.\nSee the doc about Upgrading from Swift 4.x\n\nIn SwiftDate 4.x the default region is automatically set to local region, where all attributes are set automatically to the current's device's locale, timezone and calendar.\nSince SwiftDate 5, in order to be more comply with Date's default behaviour, the default region's timezone is set to GMT+0 (UTC).\nIf you want to restore the old behaviour just set it to Region.local just after the launch of the app.\n\n\nswift\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {\n    SwiftDate.defaultRegion = Region.local // set region to local device attributes\n    // ... do something else\n    return true\n}. What's happens if you try to replace Codable with Decodable (both in DateInRegion and Region)? I can't reproduce this issue but if it could be a fix I'm ready to publish an hotfix.. Sure it still here, you need to update to 5.0.9, otherwise you still get the same problem :). Fixed in 5.0.3. Thank you for reporting. Fixed in 5.0.5. Comparison methods are now part of the compare() function and listed inside the enum called DateComparisonType.\nSo your function is:\n... = self.compare(.isSameDay(otherDate))\nor one of the shortcuts:\n.isToday\n.isTomorrow\n.isYesterday\nMore on this topic can be found inside the doc:\nhttps://github.com/malcommac/SwiftDate/blob/master/Documentation/4.Compare_Dates.md. You should use toUnits() method.\nswift\nlet date1 = \"2018-08-02T15:45:03+0000\".toISODate()!\nlet date2 = \"2018-06-13T00:00:00+0000\".toISODate()!\nlet diff = date1.timeIntervalSince(date2).toUnits([.month,.day]). Hi,\nThe main reason to rewrite it is to consolidate the API and provide a final naming to all the functions of the library. Unfortunately I don't have enough time and resources to maintain both version and the 5.x branch is well documented, so I hope you will decide to update your code base to it.\nBTW I still accept accept further PRs to fix bugs of the previous version if you want.\nThanks for understanding.. Ok merged #562 thanks. Is there an easy way to test it? A container?. Did you know if this error is referred to the git repository or...what?\ndanielembp15:SwiftDate daniele$ docker run --rm -it -w /app -v `pwd`:/app swift:4.2 swift build\ndocker: invalid reference format: repository name must be lowercase.\nSee 'docker run --help'.\ndanielembp15:SwiftDate daniele$. Yeah it was related to spaces in path. With iCloud it's a damn mess. Thanks.. Related commit: #611 Removed arc4random_uniform to use new Swift 4.2 random APIs.\n. This is the opening issues on Linux, strictly related to CFCalendar and CFCalendarUnit which should be available on CoreFoundation for Linux.\nIt's a bit strange.\ndanielembp15:SwiftDate daniele$ docker run --rm -it -w /app -v `pwd`:/app swift:4.2 swift build\nCompile Swift Module 'SwiftDate' (158 sources)\n/app/Sources/SwiftDate/Supports/Commons.swift:179:21: error: use of undeclared type 'CFCalendar'\n        typealias CFType = CFCalendar\n                           ^~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:226:25: error: use of undeclared type 'CFCalendarUnit'\n        internal var _cfValue: CFCalendarUnit? {\n                               ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:208:14: error: use of undeclared type 'CFAbsoluteTime'\n                var start: CFAbsoluteTime = 0.0\n                           ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:209:11: error: use of undeclared type 'CFTimeInterval'\n                var ti: CFTimeInterval = 0.0\n                        ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:212:12: error: use of unresolved identifier 'CFCalendarGetTimeRangeOfUnit'\n                                return CFCalendarGetTimeRangeOfUnit(_cfObject, cfValue, date.timeIntervalSinceReferenceDate, startp, tip)\n                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:243:24: error: use of unresolved identifier 'CFCalendarUnit'\n                case .day:                              return CFCalendarUnit.day.rawValue\n                                                               ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:244:24: error: use of unresolved identifier 'CFCalendarUnit'\n                case .era:                              return CFCalendarUnit.era.rawValue\n                                                               ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:245:25: error: use of unresolved identifier 'CFCalendarUnit'\n                case .year:                             return CFCalendarUnit.year.rawValue\n                                                               ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:246:25: error: use of unresolved identifier 'CFCalendarUnit'\n                case .month:                    return CFCalendarUnit.month.rawValue\n                                                       ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:247:25: error: use of unresolved identifier 'CFCalendarUnit'\n                case .hour:                             return CFCalendarUnit.hour.rawValue\n                                                               ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:248:26: error: use of unresolved identifier 'CFCalendarUnit'\n                case .minute:                   return CFCalendarUnit.minute.rawValue\n                                                       ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:249:26: error: use of unresolved identifier 'CFCalendarUnit'\n                case .second:                   return CFCalendarUnit.second.rawValue\n                                                       ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:250:27: error: use of unresolved identifier 'CFCalendarUnit'\n                case .weekday:                  return CFCalendarUnit.weekday.rawValue\n                                                       ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:251:32: error: use of unresolved identifier 'CFCalendarUnit'\n                case .weekdayOrdinal:   return CFCalendarUnit.weekdayOrdinal.rawValue\n                                               ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:252:27: error: use of unresolved identifier 'CFCalendarUnit'\n                case .quarter:                  return CFCalendarUnit.quarter.rawValue\n                                                       ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:253:30: error: use of unresolved identifier 'CFCalendarUnit'\n                case .weekOfMonth:              return CFCalendarUnit.weekOfMonth.rawValue\n                                                       ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:254:29: error: use of unresolved identifier 'CFCalendarUnit'\n                case .weekOfYear:               return CFCalendarUnit.weekOfYear.rawValue\n                                                       ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:255:34: error: use of unresolved identifier 'CFCalendarUnit'\n                case .yearForWeekOfYear:return CFCalendarUnit.yearForWeekOfYear.rawValue\n                                               ^~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Date/Date.swift:19:1: error: type 'Date' does not conform to protocol 'DateRepresentable'\nextension Date: DateRepresentable {\n^\n/app/Sources/SwiftDate/DateRepresentable.swift:171:6: note: protocol requires property 'customFormatter' with type 'DateFormatter?'; do you want to add a stub?\n        var customFormatter: DateFormatter? { get set }\n            ^\nerror: terminated(1): /usr/bin/swift-build-tool -f /app/.build/debug.yaml main output:. Still remains only the definitions inside the CFCalendarUnit enum.\ndanielembp15:SwiftDate daniele$ docker run --rm -it -w /app -v `pwd`:/app swift:4.2 swift build\nCompile Swift Module 'SwiftDate' (158 sources)\n/app/Sources/SwiftDate/Supports/Commons.swift:246:24: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'day'\n                case .day:                              return CFCalendarUnit.day.rawValue\n                                                               ^~~~~~~~~~~~~~ ~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:247:24: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'era'\n                case .era:                              return CFCalendarUnit.era.rawValue\n                                                               ^~~~~~~~~~~~~~ ~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:248:25: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'year'\n                case .year:                             return CFCalendarUnit.year.rawValue\n                                                               ^~~~~~~~~~~~~~ ~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:249:25: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'month'\n                case .month:                    return CFCalendarUnit.month.rawValue\n                                                       ^~~~~~~~~~~~~~ ~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:250:25: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'hour'\n                case .hour:                             return CFCalendarUnit.hour.rawValue\n                                                               ^~~~~~~~~~~~~~ ~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:251:26: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'minute'\n                case .minute:                   return CFCalendarUnit.minute.rawValue\n                                                       ^~~~~~~~~~~~~~ ~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:252:26: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'second'\n                case .second:                   return CFCalendarUnit.second.rawValue\n                                                       ^~~~~~~~~~~~~~ ~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:253:27: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'weekday'\n                case .weekday:                  return CFCalendarUnit.weekday.rawValue\n                                                       ^~~~~~~~~~~~~~ ~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:254:32: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'weekdayOrdinal'\n                case .weekdayOrdinal:   return CFCalendarUnit.weekdayOrdinal.rawValue\n                                               ^~~~~~~~~~~~~~ ~~~~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:255:27: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'quarter'\n                case .quarter:                  return CFCalendarUnit.quarter.rawValue\n                                                       ^~~~~~~~~~~~~~ ~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:256:30: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'weekOfMonth'\n                case .weekOfMonth:              return CFCalendarUnit.weekOfMonth.rawValue\n                                                       ^~~~~~~~~~~~~~ ~~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:257:29: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'weekOfYear'\n                case .weekOfYear:               return CFCalendarUnit.weekOfYear.rawValue\n                                                       ^~~~~~~~~~~~~~ ~~~~~~~~~~\n/app/Sources/SwiftDate/Supports/Commons.swift:258:34: error: type 'CFCalendarUnit' (aka 'UInt') has no member 'yearForWeekOfYear'\n                case .yearForWeekOfYear:return CFCalendarUnit.yearForWeekOfYear.rawValue. Okay it now compiles fine. I've switched from old internal implementation taken from CoreFoundation to rangeOfUnit() of NSCalendar (see https://github.com/apple/swift-corelibs-foundation/blob/fa8a1c2afa4c322493a83272758c2e816e3b1b8b/Foundation/NSCalendar.swift#L420).. Is there a way to run unit tests via docker?. commands is\ndocker run --rm -v \"$(pwd):/pkg\" -w \"/pkg\" swift:4.2 /bin/bash -c \"swift test --build-path ./.build/linux\". Finally it compiles successfully.\nLinuxMain.swift file with test can be generated from XCTest of XCode via the script generateLinuxTests.sh (it needs of sourcery tools brew install sourcery):\nbash\nsourcery --sources Tests --templates .sourcery/LinuxMain.stencil --output .sourcery --force-parse generated\nmv .sourcery/LinuxMain.generated.swift Tests/LinuxMain.swift\nHowever there are several failed tests.. I had a strange issue with compare function with granularity inside the NSCalendar object.\nswift\nlet d2 = Date.init(timeIntervalSince1970: 1529431200.0) // 2018-06-19 18:00:00 +0000\nlet d3 = Date.init(timeIntervalSince1970: 1529604000.0) // 2018-06-21 18:00:00 +0000\nprint(\"Data2: \\(d2), Date3: \\(d3)\")\nlet res = Calendar.current.compare(d2, to: d3, toGranularity: .month)\nThe following code return .orderedSame on macOS/iOS (and test succeded), while on Linux it just return .orderedAscending (failing the test).\nI had filled the following radar on Swift forum:\nhttps://bugs.swift.org/browse/SR-9101. Follow #612 . I'm unable to support both the new and old SwiftDate.\nBTW I can merge PRs about the old 4.x branch to publish fix updates.. What\u2019s the main reason to prefer SwiftFormat in you opinion?. Both of these initializer are resembles of the plain Date's init and must be coherent with them (where the seconds is specified to the absolute date - like UTC).\nIf you need of a different behaviour you can still pass another region instead of the default's Region.UTC.. The same method is available under the dateAt() umbrella function.\nMore info in Manipulate Date section of the documentation.\nYour code can be translated to SwiftDate 5 as:\nswift\n self.fromDate = todaysDate.dateAt(at: .prevWeek).toFormat(self.dateFormat)\n self.toDate = todaysDate.dateAt(at: .prevWeek).toFormat(self.dateFormat)\n. My fault sorry:\nswift\nlet todaysDate = Date() // 2018-10-26T21:00:00Z\nlet startOfPrevWeek = todaysDate.dateAt(.prevWeek)\nlet endOfPrevWeek = startOfPrevWeek.dateAt(.endOfWeek)\nprint(startOfPrevWeek.toISO()) // 2018-10-14T00:00:00Z\nprint(endOfPrevWeek.toISO()) // 2018-10-20T23:59:59Z. I'm not sure what are you trying to accomplish.\nLocale in your format cannot affect the results, all of your format params are numeric.\nTry to use a localizable value as the name of the month.\nSee the example below:\nswift\nlet dateStr = Date().toFormat(\"yyyy MMMM dd\", locale: Locales.english) // 2018 August 23\nlet dateStr2 = Date().toFormat(\"yyyy MMMM dd\", locale: Locales.italian) // 2018 Agosto 23\nMore info about format table can be found into the documentation.. You can import it using import SwiftDate.\nThen you can take a look at the Documentation.\nWhat are you trying to accomplish?. What Xcode/Swift version are you using?. Fixed for 5.0.8.\nThank you for your support.. Fixed in #583 and #562.. This is not related to XCode 10 but it's a bug of the parser. Fixed it and added several other unit tests.. 5.0.8 was not released.\n5.0.7 and earlier still have the bug but in develop branch it was fixed (customFormatter has default nil value):\nswift\n/// Formatter used to transform this object in a string. By default is `nil` because SwiftDate\n/// uses the thread shared formatter in order to avoid expensive init of the `DateFormatter` object.\n/// However, if you need of a custom behaviour you can set a valid value.\npublic var customFormatter: DateFormatter? = nil\nwould you try to compile the current develop branch?. Duplicate of #568 \nCurrently I'm working to restore it by disabling the Objective-C Runtime dependency.. Have you tried 5.0.9?. Did you get warnings on 4.2?. Example:\nswift\nlet regionIT = Region(calendar: Calendars.gregorian, zone: Zones.europeRome, locale: Locales.english)\nlet date = DateInRegion(Date(), region: regionIT).toISO([.withoutTZSeparators]). Added in #595 thanks. I had removed old hashValue generator function since it was now managed automatically by Swift 4.2.. Hi,\nYou are right, it was restored to TimeInterval to be consistent with plain Date.\nSince 5.0.11 you will use componentsSince() method in DateInRegion:\nswift\nlet hour = date2.componentsSince(date1).hour. You should use getInterval(toDate:component:) method (documentation)\nswift\nlet fromDate = \"2018-09-20T00:00:00+00:00\".toDate()!\nlet toDate = \"2018-10-05T06:30:00+00:00\".toDate()!\nlet diffDays = b.getInterval(toDate: a, component: .day) // 15 days\nthe difference between two date since 5.0.9 returns an interval like for plain dates.. Have you seen the https://github.com/malcommac/SwiftDate/blob/master/Documentation/5.Date_Formatting.md#colloquial inside the documentation for colloquial formatting options?. Can you help me identify the bug? What locale are you using?. And what's the language of the device, the value of local?. I'm unable to support both the new and old SwiftDate.\nBTW I can merge PRs about the old 4.x branch to publish fix updates.. Hi,\nSince 5.0.11 both Date and DateInRegion dateBySet() function has an extra ms optional parameter you can use to set the milliseconds value of the receiver.\nswift\nlet originalDate = \"2018-10-10T12:02:16.024\".toISODate()!\nlet newDate = originalDate.dateBySet(hour: nil, min: nil, secs: nil, ms: 7)\nprint(newDate.toISO([.withInternetDateTimeExtended])) // 2018-10-10T12:02:16.007Z. Thank you for your contribution. thanks!. Thanks for answering. Thank your for your contribution @oscardemoya . Are you talking about macOS compatibility? What kind of error you got?. Thank you for your feature request.\nSince 5.1.0 you will found two methods both for plain Date and DateInRegion:\n```swift\n// Return the dates for a specific weekday inside given month of specified year.\npublic static func datesForWeekday(_ weekday: WeekDay, inMonth month: Int, ofYear year: Int,\n  region: Region = SwiftDate.defaultRegion) -> [Date]\n// Return the dates for a specific weekday inside specified date range\npublic static func datesForWeekday(_ weekday: WeekDay, from startDate: Date, to endDate: Date,\n  region: Region = SwiftDate.defaultRegion) -> [Date] \n```\nExample:\n```swift\nlet mondaysInJan2019 = Date.datesForWeekday(.monday, inMonth: 1, ofYear: 2019)\n// You will get 4 results\n// - 2019-01-07T00:00:00Z\n// - 2019-01-14T00:00:00Z\n// - 2019-01-21T00:00:00Z\n// - 2019-01-28T00:00:00Z\n```. Accepted, on track for 5.1.0. Thanks. Take a look at the Unicode Table for parsing.\nswift\nlet region = Region(calendar: Calendars.gregorian, zone: TimeZone(secondsFromGMT: 0)!, locale: Locales.english)\nlet dateFormat = \"EEE MMM dd HH:mm:SS ZZZ yyyy\"\nlet y = \"tue jul 30 21:49:40 gmt+01:00 2019\"(dateFormat, region: region). Why?. ",
    "oyalhi": "Works like a charm, thank you.\n. ",
    "bitomule": "I've created a PR\nhttps://github.com/malcommac/SwiftDate/pull/7\n. No problem. Awesome work btw.\n. Oh, can you update the version on cocoapods? :)\n. Wow, that was fast. Thanks! Is it pushed to cocoapods?\n. Thanks! I'l create more issues if I find anything\n. Nice, push cocoapods version when you can :)\n. Great!\n. ",
    "SimonRice": "That would be correct :) in my example, I in fact continued with your naming convention by using beginningOfWeek and endOfWeek.\nI haven't got any example of next/last day of week - but I'm more than happy to have a go.\n. I know that feeling very well - most of my contributions are in my spare time (or in silly hours)!\nI'll see what I can do within the next 2 weeks - I'd be more than happy to chip in with a Swift project**.\n** Besides deleting .DS_Store files ;)\n. ",
    "codegiant": "Having the same issue. The \"toRelativeString\" method works fine on the simulator but fails on my actual device. (iPhone 6, iOS 8)\nInstead of the nicely formatted \"1h\" or \"37s\", I get back what looks like scientific notation. \"9.223372+18w\"\n. You bet. Tested the latest commit on my device and it's working perfectly. \nNailed it!\n. ",
    "iantheparker": "Great! Thank you!\n. +1\n. I'm getting the same error as @hackolein with this code.\nlet date = try! eventDateString.date(format: .iso8601(options: .withInternetDateTime))\nlet (colloquial,_) = try! date.colloquialSinceNow()\nBut it is working for me on a generically created Date object.\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"\nlet sinceDate =  dateFormatter.date(from: published_at)\nlet (colloquial,_) = try! sinceDate.colloquialSinceNow()\n. @malcommac  I'm still getting the same error, but it's breaking on a generic Date init as well.\nIt works fine in my iPhone 7 simulator, but crashes on my iphone 6 (iOS10) and on my 6/6s simulators running 9.3. Not sure if that helps at all.\n. ",
    "ageorgios": "It only works when in english\n. When the iOS Simulator language is changed to Greek for example, it returns nil.\n(Settings->General->Lang&Region->iPhone Language->Greek)\n. ",
    "wangshengjia": "+1 please\n. ",
    "dmyers": "Yeah I am.\n. ",
    "mrichtsfeld": "Sure, you're welcome. Thanks for the great library.\n. ",
    "chenyangcun": "OK\n. ",
    "uny": "I should support Mac, either.\nI will re-submit.\n. Sure! Thank you.\n. ",
    "ghost": "swift\nvar postedOn = post.createdAt!\npost[\"timeAgo\"] = postedOn.toRelativeString(fromDate: NSDate(), abbreviated: true, maxUnits: 1)\npost.createdAt looks like this: 2015-08-07T16:39:44.703Z\n. Top right\n\n. Yes.\n. Will do this later today when I'm off work. Thanks for the response.\n. Works like a charm, thanks!\n\nOn Aug 18, 2015, at 12:53 AM, Daniele Margutti notifications@github.com wrote:\nJust posted 1.0.11 to cocoapods\n\u2014\nReply to this email directly or view it on GitHub https://github.com/malcommac/SwiftDate/issues/28#issuecomment-132109983.\n. \n",
    "MaximusMcCann": "Not unreasonable. I would do like so:\nlet isSameYear = date.isSame(TIME_ENUM.Year, anotherDate)\nthen the shorthand would read let isSameYear = date.isSame(.Year, anotherDate)\nlikewise: date.isAfter(.Year, anotherDate) & date.isBefore(.Year, anotherDate)\nCheers\n. True.  Would be useful when checking a date is after the current date down to hour/min/sec granularity. \nExample: 2015-05-05 9 AM > 2015-05-04 10AM, but date05.hour > date04.hour would return false.\nBut date05.isAfter(.Hour, date04) would return true while ignoring minutes and seconds.\n. ",
    "fhisa": "I sent pull request #37 to support Carthage, today.\n. thanks\n. \ud83d\udc4d\n. thanks\n. ",
    "adwayish": "+1 also get rid of \"ago\". These are application specific so users can add them if they want. \n. ",
    "MarvinNazari": "Are u gonna push to Cocoapods for this?\n. ",
    "evision1": "I can't wait until Swift v2 support.\n. ",
    "Hout": "Good idea! We could create a small wrapper around components(fromDate, toDate) as specified in:\nhttps://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/DatesAndTimes/Articles/dtCalendricalCalculations.html#//apple_ref/doc/uid/TP40007836-SW8\nWith that approach we can express the time difference in a set of time units. I will check it out the next days.\n. This would be a minimal but very functional wrapper:\nswift\n    func difference(toDate: NSDate, unitFlags: NSCalendarUnit) -> NSDateComponents {\n        let calendar = NSCalendar.currentCalendar()\n        let components = calendar.components(unitFlags, fromDate: self, toDate: toDate, options: NSCalendarOptions(rawValue: 0))\n        return components\n    }\nWhere this would be a wrapper for just one unit:\nswift\n    func difference(toDate: NSDate, unit: NSCalendarUnit) -> Int {\n        let calendar = NSCalendar.currentCalendar()\n        let components = calendar.components(unitFlags, fromDate: self, toDate: toDate, options: NSCalendarOptions(rawValue: 0))\n        if unit.contains(.Year) {\n            return components.Year\n        } else\n... etc\n    }\nWhat do you think?\n. Oops accidentally closed this one\n. Woops! Hold horses pls. Ow too late. ;-)\nYep a wrapper around components:fromDate:toDate is probably the wisest\n. Sorry you already have one...  :D\n. Ah no that was the class func, this one stays open\n. Finished it! :-) \nCheck out my development branch!\nhttps://github.com/Hout/SwiftDate/blob/master/SwiftDate/SwiftDate.swift\nI could issue a pull request but I changed quite a lot....\n. I should look better. You readily have one so I will close this one.\nI will open another one for the week, quarter, week in month setters though.\n. Give me some time this weekend and I will merge your latest changes in and smooth out the duplicate code in set and date funcs\n. I added some more test code and the startOf does not work properly with different time zones when it is at midnight: it selects the previous day. Fixing...\n. Yeps, don't worry I will take some time and rebase, merge etc, split up functionality and issue matching pull requests.\nFun project.\n. Actually NSDate is an absolute time. It is the same everywhere around the world. Without Swiftdate you can represent it by calculating a local time through NSCalendar or NSDateFormatter. There you use a calendric system (Georgian, Islamic, Hebrew, Buddhist etc) the time zone and locale.\nThe first line (justDate) is correct. It is the time in UTC (indicated by the +0000). This is the same as GMT which is UK time in winter (in summer it is BST which is summer time). In Hong Kong it is five hours later apparently. With SwiftDate use justDate.toString() to display the date in local time.\n. To keep things pure, I think you should treat NSDate objects as absolute time objects, not as a representation in a certain time zone (or calendar, for the matter). \nI suggest that you determine times based on time zones in string represenations or NSDateComponent elements. Let me see...\n. For .toString, I would add optional calendar and time zone parameters:\nfunc toString(blahblah, calendar: NSCalendar = NSCalendar.currentCalendar,  timeZone: NSTimeZone = NSTimeZone.defaultTimeZone)\nMake sure to add variations of the call to the test class.\n. For components I suggest a func components(blahblah, calendar: etc etc etc (you get the idea?) ;-)\n. Of course you could use the time zone abbreviation as opposed to a tz object.\nOr the calendar identifier for calendar...\n. The charm of your extension is that is can be treated as NSDate. Unfortunately you cannot store vars in an extension, so the time zones and calendars have to come with the call. An alternative would be to subclass NSDate, but that causes all kind of different issues as NSDate is a class cluster. Apple describes how to subclass but when you get further down the road it gets rather complicated.\nI played around with this and came up with a class (yes I gave it a shot with cocoapods), but this class serves another purpose than SwiftDate as it does not have the straight NSDate connection.\n. Agreed. \nI would be happy to rebabtise JHDate to something like a \u00bfDateRepresentation? class smoothly fitting right next to a NSDate extension in the SwiftDate environment. My intention is just to learn Swift, not to start a competition. ;-)\nWe would have to decide what function fits where. I will check out moment.js this weekend but I would suggest some class that can be connected to an NSDate object for a local representation of that NSDate object? The class would contain a calendar, time zone and locale.\n. No need for proprietary code, check the docs and StackOverflow\n. This needs some investigation. It should not be very complicated to create local unit descriptors.\nAlso check out link and search for NSDateComponentsFormatterUnitsStyleSpellOut\n. @malcommac does this fit in v2?\n. isInTimeRange is not currently in the v2 version. We should do something with time intervals alike the NSDateInterval class. Needs further investigation. \nWhat do you think @malcommac \n. @malcommac ?\n. This would be really nice and I think it is feasible. Needs further investigation.\n. I presume the last two lines in PrettyDateShortRelativeTime should be prefixed with a minus?\n. Instead of having all kinds of different names, I prefer one general function with parameters for the units to format and the 'shortness' of the output string\n. To keep it simple we could also do some fuzzy parametering e.g.\nunits: NSCalendarUnit = nil // = auto by default\nnumberOfUnits: Int = 1\nstyle: OurFantasticPrettyFormattingStyle = .Medium\nThus we can issue for 25 hours:\ndateInterval.prettyFormat() // auto, 1 unit, : day (is largest), medium style --> \"1dy\"\ndateInterval.prettyFormat(units: [.hour]) // manual, hour units only, medium style --> \"25hr\"\ndateInterval.prettyFormat(units: [.day, .hour]) // manual, day and hour units, medium style --> \"1dy 1hr\"\ndateInterval.prettyFormat(numberOfUnits: 2) // auto, 2 units (day and hour units), medium style --> \"1dy 1hr\"\ndateInterval.prettyFormat(style: .Long) // auto, 1 unit, : day (is largest), long style --> \"1 day\"\n. Looks good to me! One remark though: following the path from #123 NOT to put redundant parameters in a function I would suggest two functions:\n``` swift\n// Takes the biggest unit of difference and the number of subsequent smaller units\nfunc toRelativeString(fromDate: date, numberOfUnits: Int = 1, style: Y = .Medium)\n// Takes the difference of the specified units\nfunc toRelativeString(fromDate: date, units: NSCalendarUnits, style: Y = .Medium) \n```\nI think more nuances are possible, but I suggest an agile approach: try fast and fail fast (if at all).\n. Remarks:\nLooking at this table, three types of abbreviations seems overkill. \nAbbreviation for \"month\" is \"mo\", \"mon\".\nPlease ignore plurals with one letter abbreviations. It is rarely used, not recognised and it creates confusion (ms = millisecond).\n. Not sure, but still I think three type of abbreviations is overkill in English, Dutch, German, French and Indonesian. Not sure about Italian ;-)\n. BTW have you checked my suggestion in #65 with NSDateComponentFormatter? This seems to give you the names if the units automagically.\n. I am always in favour of using the native libraries. Can't we work around\nthe negative error by first making the time interval positive and creating\na string with ago?\nBesides we could use this for more than just time intervals\nOp do 14 jan. 2016 om 23:24 schreef Daniele Margutti \nnotifications@github.com\n\nHave you looked at this?\nhttps://github.com/algal/RelativeDatePlayground;\nNSDateComponentsFormatter does not handle correctly negative time intervals.\nSECONDS |  TTTTimeIntervalFormatter |  NSDateComponentsFormatter\n-----------+---------------------------+---------------------------\n  -1488010 |               2 weeks ago |          -1 week remaining\n  -1468800 |               2 weeks ago |          -1 week remaining\n   -864000 |                1 week ago |        0 seconds remaining\n    -86400 |                 1 day ago |           -1 day remaining\n    -36000 |              10 hours ago |        -10 hours remaining\n     -3600 |                1 hour ago |          -1 hour remaining\n      -600 |            10 minutes ago |      -10 minutes remaining\n       -60 |              1 minute ago |        -1 minute remaining\n       -10 |            10 seconds ago |      -10 seconds remaining\n        -1 |              1 second ago |        -1 second remaining\n        -0 |                  just now |        0 seconds remaining\n         0 |                  just now |        0 seconds remaining\n         1 |         1 second from now |         1 second remaining\n        10 |       10 seconds from now |       10 seconds remaining\n        60 |         1 minute from now |         1 minute remaining\n       600 |       10 minutes from now |       10 minutes remaining\n      3600 |           1 hour from now |           1 hour remaining\n     36000 |         10 hours from now |         10 hours remaining\n     86400 |            1 day from now |            1 day remaining\n    864000 |           1 week from now |           1 week remaining\n   1468800 |          2 weeks from now |          2 weeks remaining\n   1488010 |          2 weeks from now |          2 weeks remaining\nWe can provide a port of TTTTimeIntervalFormatter right now and replace it\nwith NSDateComponentsFormatter when it will be fixed. What do you think?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/malcommac/SwiftDate/issues/79#issuecomment-171801293.\n. There is no defaultRegion() func anymore.\nYou can use Region() to get the default region but you cannot set it. Rationale is to have just one default region that represents the current calendar, time zone and locale.\n\nIf you want to use alternate regions then you should specify them and not make them the default. Thus preventing misunderstandings. \n. Must be resolved in v2.1. \n. Fixed in v3.0.0\n. I will try to create some with conversion docs this weekend.\n. Before diving into the documentation, we need to get more consistency in the library. I will raise an enhancement issue to extend NSDate with as many as possible features from DateInRegion in such a way that it behaves like the latter in the default region.\n. Fixed in v3.0.0\n. Hmmm IMHO this should be resolved in the library in the future. Pls check out #65. That contains hints that can resolve your requirement.\n. Ratnesh, 1 month is not equal to 4 weeks. If I have a date for 22 November and add one month, I get 22 December. If I add four weeks, I get 20 December...\nYour solution lies in using weeks, not months.\n. Shouldn't this one be closed?\n. Fixed in v3.0.0\n. Indeed! That is superfluous code. Working on it!\n. Fixed in v3.0.0\n. Resolved in ff10e3399f41222ec93d5469ddbb75cc6e54d181\n. Fixed in v3.0.0\n. Correct, as implemented in fd73ef7bb9b28d69859260407acb6c01858b48f2\n. Fixed in v3.0.0\n. Resolved in b49a0f84948486af415f44c9d5b66a9e4936c76c\n. Fixed in v3.0.0\n. Resolved in b49a0f84948486af415f44c9d5b66a9e4936c76c\n. Fixed in v3.0.0\n. Well, I already have but with you being the Godfather of SwiftDate I do not want to merge it into master without your blessing ;-)\n. All included in development branch, no pull necessary.\n. Fixed in LocaleName type.\n68e121438f6934b1a15bf98410c2f85308cecea5\n. Fixed in v3.0.0\n. Fixed in v3.0.0 by introducing a generated enum\n. Fixed in e66f03268fd7c1857ffd3e6f9b89abeda785a288\n. Fixed in v3.0.0\n. Weird! Needs investigation. Thx for the issue.\n. Fixed in the development branch. \nThanks for the pull request! :-)\n. @malcommac Can you answer this one pls?\n. The change is quite big and needs investigation. I find the issue it tries to solve real though. \nWe need time to investigate and we are already in the release of v3.0.0. I will line this one up for v3.1.0\n. Fixed in #115\nThanks fo rthe pull request! :+1: \n. Todo: include in upgrade docs & maintain backward compatibility.\n. Fixed in v3.0.0\n. Good find! I will include this in the current develop branch.\nThx!\n. Although... In the development branch there is no sum function anymore... :-)=)\nI will include this particular circumstance in the unit tests and investigate such that your use case will be honoured.\n. I looked in the wrong place. Working on it!\n. Fixed this one and included test code (see commit above). Can you confirm that this works @TadeasKriz?\n. Check 68e121438f6934b1a15bf98410c2f85308cecea5 (with rename to xxName for calendar, timeZone & locale)\n. Fixed in v3.0.0\n. Hmmm, v2 introduces DateInRegion but was still a bit quirky indeed. v2.1 is the bug fix but introduces no major changes. Check the develop branch.\nA major release should have incompatible API changes link but from a functional perspective. Currently I am working to make v2.1 backward compatible with v2.0.\nThanks for your idea!\n. Aaaah! Correct, I will include a typealias for backward compatibility and deprecate later.\n. Fixed in 416f751be9166ba0da2294f9f47273ed3d5a1114\n. I am convinced.\n@malcommac what is your opinion?\n. Agreed. Closed\n. The rationale is is that a date region should only be created once and to your liking. localRegion as you mention is de default mode if you leave the reference to a region out, so there should be minimal work on this.\nUTCRegion is a region for UTC, UTC is used in airplanes and other global organisations which is rather specific. If you would need it to work with an absolute time, that is encapsulated in NSDate. You should have no need to refer to it as \"UTC\" and use something like \"absoluteTime\" instead. The latter describes the object much better.\nWhat is the underlying issue here?\n. Setting an absolute time  object like NSDate to the start of an hour implies the use of a time zone. Why would you use UTC for that? For Europe that would be ok, but India -for instance- has a time zone that is 30 minutes off the hour for UTC. \nCan you tell me more about your use case?\n. No reaction, closed\n. You are correct! :) I wanted to make it simple to use but you certainly have a point. On the other side it is just handy to be able to initialise with any mix of parameter types as long as it produces a consistent date.\nTo stop confusion between calendars, time zones and locales, a purer version would be:\npublic convenience init?(\n        fromString date: String,\n        format: DateFormat = nil, // nil = medium style\n        region aRegion: DateRegion? = nil) // nil = local\nBetter?\n. The advantage of one big initialiser is that it can be used in various ways. E.g.:\nlet region1 = DateRegion() // returns local region\nlet region2 = DateRegion(tzName: .Asia.Shanghai) // returns time zone for Shanghai\nlet region3 = DateRegion(timeZoneRegion: .America.Santiago) // returns time zone for Santiago\nlet region4 = DateRegion(calendar: ethiopianCalendar, timeZone: ethiopianTimeZone, locale: EthiopianLocale) // an Ethiopia region\nlet region5 = DateRegion(localeID: \"ti_ER\", region: ethiopianRegion) // Eritrea region\nIf we split this up into dedicated initialisers, it is not possible to use default parameters on each as it would create ambiguity. I.e. the compiler would not be able to determine which initialiser DateRegion() would refer to. \nAlternative 1:\nWe could keep one initialiser with the core parameters (NSCalendar, NSTimeZone, NSLocale) and introduce helper functions to fill it up. E.g. \nlet region1 = DateRegion() | \"uk\" | .Europe.Kiev | .Gregorian\nlet region2 = DateRegion() | \"en_UK\" | \"BST\" | .Gregorian\nAlternative 2:\nAs above. But with a string input which is parsed for time zone id's, locale id's and calendar id's:\n```\ninit(idStrings String...) {}\nlet region3 = DateRegion(NSCalendarIdentifierHebrew, \"America/Adak\", \"en_US\")\nlet region4 = DateRegion(timeZone: .Asia.Magadan) // with local calendar & locale\n```\nOther ideas?\n. Or maybe even better: init(initObjects: DateRegionSpecifier...). Where the region is built based on the objects. Objects can be NSCalendar, NSTimeZone, NSLocale, CalendarType, TimeZoneConvertible, String (calendarID, localID, timeZoneAbbreviation, timeZoneName).\n. @malcommac I created a branch. Check this one: 4dc87437c7554876416e8f7558c1439b6a6c0ed7. This keeps things simple and flexible.\n. A best practice question is valid here too. Assume a class Class which contains main properties a, b and c that can be built in a number of ways. Would we prefer:\n- Class(a: b: c:) next to Class(d:e:f:) and Class(g:h:i:) where each of the parameters d..i can be optional, but one should be mentioned to prevent ambiguity. (this applies to DateRegion in the current develop branch.)\n- Class(a: b: c:) next to Class(_ x...) where x is an array of objects that can be anything that conforms to a protocol ClassSpecifier. The latter initialiser constructs Class object from the objects in x.\n- Maybe another solution?\n. Hmmm, I can go with you on this one. My main concern with the TimeZones is that I want to be able to use an abbreviation in a quick way.\nAnyway I would tend to make it even more consistent and leave any duplication out of the parameters to get the required clarity. I.e. remove the calendar, time zone and locale references and do the same thing you mention above into the region and do the same trick there. \nOr the other way around: get rid of the region and make calendar, time zone and locale explicitly defined in all functions. I would be in favour of the former as in the real world we would want the date conversion to be from a specific location (date region) and deal with that level of abstraction as opposed to multiple objects like time zone, calendar and/or locale.\nThe code would become:\nswift\npublic convenience init?(\n        fromString date: String,\n        format: DateFormat,\n        region aRegion: DateRegion? = nil)\nIn case of quick partial regions (e.g. just time zone conversion) the code would become:\nlet str = NSDate().toString(\"dd-MMM-yy\", region: DateRegion(timeZoneRegion: .Europe.Paris))\nDo you agree on this approach?\n. DateRegion naming continued in #127\n. Ok let us proceed with this paradigm then :+1: \n. It should represent the day number in the region mentioned. You have set it to midnight on the 31st in Kaliningrad. If your device local time zone deviates from that, e.g. in London, it could be the 30th.\nWhich version of the library do you use?\n. Hmmm it does not make sense at all to change an absolute time object like NSDate in order to represent it in a different time zone whatsoever.\nIn the new develop branch localDate and UTCDate are canned. They create confusion as NSDate does not have a time zone reference. As such it is not wise to suggest that a date is \"local\" or \"UTC\" and to change it by changing the absolute time. In fact NSDate applies to all time zones, it is just represented differently depending on date region.\nI included these tests that evaluate to true:\n```\nlet utc = DateRegion(tzName: TimeZones.GMT)\nit(\"should have been initialised with the Kaliningrad time zone and calendar in winter\") {\n    let date = NSDate(year: 2015, month: 12, day: 25, hour: 2, calType: .Gregorian, tzName: TimeZones.Europe.Kaliningrad)!\n    expect(date.toString(DateFormat.ISO8601, inRegion: utc)) == \"2015-12-25T00:00:00+0000\"\n}                \nit(\"should have been initialised with the Kaliningrad time zone and calendar in summer\") {\n    let date = NSDate(year: 2015, month: 6, day: 25, hour: 2, calType: .Gregorian, tzName: TimeZones.Europe.Kaliningrad)!\n    expect(date.toString(DateFormat.ISO8601, inRegion: utc)) == \"2015-06-25T00:00:00+0000\"\n}          \n```\n@malcommac can you evaluate #125? Is it worthwhile to implement a hotfix?\n. localDate is canned in v3.0.0.\n. Thanks formyour pull request, but localDate is removed in v3.0.0.\nLocal representation is implemented by default.\n. In an event driven world this would be the way to go indeed. So pushing forward, we would have to make the following changes:\n| Initialiser | becomes function |\n| --- | --- |\n| DateRegion init(components:) | NSDateComponents func toDateRegion()  -> DateRegion |\n| DateInRegion init(components:) | NSDateComponents func toDateInRegion() -> DateInRegion |\n| NSDate init(components:) | NSDateComponents func toDate() -> NSDate |\nWe should also write this down in the design decisions. \nDo you agree?\n. Made init(components) internal as they are still very beneficial internally.\n68e121438f6934b1a15bf98410c2f85308cecea5\n. Realised in v3.0.0. \n. Area?\nHowever: just as generic. \n. Agreed, let's move back to Region\n. Done in 68e121438f6934b1a15bf98410c2f85308cecea5\n. In addition: what is the advantage of the current enum hierarchy compared to nested enums? Can't we just do:\nenum TimeZone {\n  enum America {\n    case NewYork = \"America/New_York\"\n    enum Argentina {\n      case BuenosAires = \"America/Argentina/Buenos_Aires\"\n      // etc\n. Nope I am missing the point ;-)\nI am not that familiar with enums but I kind of cought up today.\n. Hmmm having looked at this for some time there are still two things where I think we can do better:\n- We can set it up simpler: with just one big enum and without the protocol. Easier to understand and I can write a generator for the code (I am working on one for the locale anyway). \n- It does not work without the type name. I.e. we cannot put down .Asia.Jakarta; it should alway be TimeZoneNames.Asia.Jakarta.\nThoughts?\n. In the light of the msg above: what about consistent naming of the way we identify calendars, time zones and locales:\nswift\nenum CalendarName {\n    case Gregorian // etc\nenum TimeZoneName {\n    case EuropeRome // etc\nenum LocaleName {\n    case EnglishGreatBritain // etc\n. Check 68e121438f6934b1a15bf98410c2f85308cecea5\n. Fixed in v3.0.0\n. Created in separate branch\n. Fixed in v3.0.0\n. Ah! I can do it with my own token.\n. Fixed in v3.0.0\n. I do not think that SwiftLint should be prio no 1.\nLet us move towards releasing and move this one forward in time.\n\nOn 17 Jan 2016, at 12:37, Daniele Margutti notifications@github.com wrote:\nI've tried using SwiftLint into the code but 99% of the warnings are related to line length or white lines.\nI'm not sure this could be a bold move.\nHowever I'm okay with the Swift Style Guideline at the top of the issue. I'll check the code for it.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/malcommac/SwiftDate/issues/131#issuecomment-172315757.\n. SwiftLint will not be usable with the full configuration indeed. Part of the code follows the style guide already.\n\nTo do:\n- check swiftlint for usability\n- adjust code\n- include style guide in design guidelines\n. Swiftlint is adhered to except for some complexity issues that need further investigation.\nCode is adjusted\nStyle guide in design guidelines.\nPart of 3.0.4 ahead of the scheduled 3.1.0 milestone!\n. Fixed in e21e81d8a2f9b7a8a05a963b7429e7a9248920c6\n. Apparently not...\n. Improving code coverage...\nI will leave a lot of formatting alone for now knowing that @malcommac is working on it. Next step is NSLocale.\n\n. Not quite: develop branch fails to compile with struct in DateInRegionFormatterPort:\nlet bundle = NSBundle(forClass: DateInRegion.self)\n. Yep, but this is probably trivial if we adopt NSDateComponentsFormatter?\n. I think issues should be closed when the solution branch is merged into the master ;-)\n. My proposal is to round everything up, do a mutual review of code, test code and docs and start the release process as I described in TEAM.md. Good thinking?\n. Feature branches are handy when multiple people are working on the same code. No big deal (yet) ;-)\nI will spend some time this afternoon.\n. Fixed in v3.0.0\n. Can be done with NSDateComponentFormatter too.\n. ```\nlet interval: NSTimeInterval = 63\nlet formatter = NSDateComponentsFormatter()\nformatter.unitsStyle = .Full\nformatter.allowedUnits = [.Hour, .Minute, .Second]\nformatter.stringFromTimeInterval(interval)  // \"1 minute, 3 seconds\"\n``\n. Should notweekOfMonthbeweekOfYear`?\nOtherwise we get into trouble when the time interval crosses into another month.\n. Correct! We are working on this in the develop branch\nOp vr 15 jan. 2016 om 17:41 schreef gloryluu notifications@github.com\n\nSome instruction in doc provided is not right anymore\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/malcommac/SwiftDate/issues/138.\n. Fixed in v3.0.0\n. Clear! Thx.\n. Not quite sure if I understand your question. I do not mean a subset but a different representation in the NSDateComponents object. Let me elaborate: \n\n```\nlet date1 = 18:50:00\nlet date2 = 19:51:03\nlet difference = date2 - date1 \\ = 1 hour, 1 minute, 3 seconds\nlet differenceInMinutes = difference.inUnits(.Minute) \\ = 61 minutes, seconds are ignored\nlet differenceInMinutesAndSeconds = difference.inUnits([.Minute, .Second]) \\ = 61 minutes, 3 seconds\n```\nDoes this answer your question?\n. You are correct! Working on this...\n\nOn 17 Jan 2016, at 20:02, Daniele Margutti notifications@github.com wrote:\nOkay I got it right (but my solution does not work).\nThe problem is how to convert from a NSDateComponents to another (from a date components where all units are calculated to another where a different set of these should be calculated).\nThis because date2 - date1 results in a NSDateComponents instance and we have already lost references to both original dates... so how can we get another \"style\" of NSDateComponents with different units without a reference to the original dates?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/malcommac/SwiftDate/issues/140#issuecomment-172366273.\n. I implemented it with an NSDateInterval, ported to DateInRegion.\nThe NSDateComponentFormatter produces nicely localised strings, but AAAAARGH its bugginess is much worse than you already stated :D\nCheck out feature/stringTests, file DateInIntervalInRegionStringTests.swift and look for \u201c// Bug\u201d.\n\nI have come to a point where indeed I agree that we need to come with our own implementation.\nPossibly port the TTT version. My idea is to somehow extract the formatting from NSLocale and not fill it ourselves.\nSometimes it requires hours and hours of work to come to insight, thanks for this ;-)\nBUT!!! I think that first we need to create v3. We cannot continue with implementing good ideas and leave the library half broken at v2.\nAfter that we can continue with the relativeString feature. Is that alright with you?\n. A few things are not covered, but the library does not need to be perfect. At least the basics are good now.\nI will make a remark in the README that strings are still under construction.\nThe \"release fast, fail fast\" paradigm allows people to test code in ways that we cannot dream of, report the issue and allows us to fix and include it in the test code.\nI will start the release check from the current develop branch.\nWhile it is not merged into master, we can still alter things.\n\nOn 23 Jan 2016, at 20:07, Daniele Margutti notifications@github.com wrote:\nAs you said, I think we should move quickly to the next version in order to fix the broken parts of the current available version.\nSo IMHO we should fill the holes for:\nremaining tests for currently implemented methods (beside formatting is there anything else not covered? can you see this?)\nupdate documentation (I would to try to generate a jazzy apple style doc)\nWhat do you think?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/malcommac/SwiftDate/issues/140#issuecomment-174212968.\n. @malcommac,  should we merge this in for 3.0.0 or 3.1.0?\n. Guys, do not we need to clean the directories and config settings?\nIf I look at the keychain example, I see:\n- neatly divided file groups and directories for source code and tests\n- a configuration file for each platform\n\n\n. The following should produce the same outcome:\nswift\nlet str = date.toString()\nlet str = date.inRegion().toString()\nlet str = date.inRegion(localRegion).toString()\nPls try the develop branch. We are working to publish it soon.\n. Apologies for my ignorance. You are absolutely correct and your remark is appreciated.\nIt is just that Daniele and myself are putting the final bits together for the v3 release and not with our heads in the current v2 release. That is why I asked you to check the develop branch.\nPlease hang on. v3 will be out soon.\n. We could use Carthage to download Quick and Nimble. That should also work with Travis...\nhttps://github.com/Quick/Quick/blob/master/Documentation/InstallingQuick.md#carthage\n. So Carthage is resolved, how do we progress with Jazzy?\n. It should be indeed! And it should be tested also.\n. That should be:\nswift\nlet utcRegion = Region(timeZone: Gmt)\nlet utcString = NSDate().inRegion(utcRegion)..toString(DateFormat.ISO8601)\nOr with the DateInRegion class:\nswift\nlet utcRegion = Region(timeZone: Gmt)\nlet utcDate = DateInRegion(region: utcRegion)\nlet utcString = utcDate.toString(DateFormat.ISO8601)\nDoes this answer your question?\n. @malcommac can you step in here and do your string magic pls?\nThis is tested in RegionStringTests and confirms @berlin2 's findings:\nswift\nlet utcDate = DateInRegion(year: 2015, month: 4, day: 13, hour: 22, minute: 10, region: utc)!\nit(\"should return proper ISO 8601 string\") {\n    expect(utcDate.toString(DateFormat.ISO8601)) == \"2015-04-13T22:10:00+0000\"\n}\nand..\n``` swift\nlet date = NSDate(year: 2015, month: 4, day: 13, hour: 22, minute: 10)!\nlet localDate = date.inRegion()\nit(\"should return proper ISO 8601 string\") {\n    expect(localDate.toString(DateFormat.ISO8601)!.hasPrefix(\"2015-04-13T22:10:00\"))\n    expect(date.toString(DateFormat.ISO8601)!.hasPrefix(\"2015-04-13T22:10:00\"))\n}\n```\n. Thanks for the issue. \n.toISO8601String is replaced by .toString(DateFormat.ISO8601)\nUnfortunately the string functions have not been fully documented yet and should be added to the upgrade guide. Apologies for the time wasted, but Daniele and I decided to publish the v3 library before fully completing the docs as v2 urgently needed an upgrade.\nThis should work for both:\nswift\nlet dateStr1 = DateInRegion().toString(format: DateFormat.ISO8601)\nlet dateStr2 = NSDate().toString(format: DateFormat.ISO8601)\nPlease let us know whether or not this works for you.\n. Francois, merci a votre issue.\nThe documentation is outdated; relative strings are already localized.\nSearch for the toNaturalString function.\nDoes that help?\n. The only reason for using inRegion is if you want to get the string from the date in a different time zone, calendar or locale. For your default region you should not use inRegion.\nAs for the style parameter I would suggest to just try it out with various options and see what satisfies your requirements. \nFor possible values check this link\n. @malcommac Shall I promote develop into master v3.1.0?\n. 3.0.4 it will be. I finished most of the swiftlint and got some bugs out of the code by doing so.\nRelease tonight!\n. That is the correct behaviour.\nTo get the start of the week you should use:\nlet date = xyz\nlet startOfWeek = date.startOf(.WeekOfYear)\nDoes that solve your issue?\n. @Morbix that is what I intended to answer in my previous reaction. Can you elaborate on your issue please as I wonder how you cannot get the first day of the week by using the code above?\n. No problem! If you want to know the rationale behind the apparently confusing name then check out the Apple documentation on weekOfYear, weekOfMonth and yearForWeekOfYear. \n. Good find!\nNSDate and DateInRegion should behave the same in the default region. Hence this is a bug.\n. The toDate function needs a lead to know which characters in the string represent which data. Different countries and different programmers use different date formats. E.g. \"11-12-13\"  could mean 11 December 2013, 13 December 2011 or 12 November 2013...\n. @netgfx coming back to your question: you must know the date format of the string you provide before passing it on. How you obtain that is your challenge.\n. Woops reopened since the original bug with ISO8601 date formatting in the default region is still prevailing.\n. I think we should consolidate to a minimum number of functions that describe the function of the function. In this case I would vote for the toString(style) format and deprecate the toStyleString()  format. The former is more flexible.\n. That will be for 3.0.5 then.\n. Do you have any specs yet so I can write the test code?\n. Is this issue resolved now?\n. This works now\n. @malcommac would you mind to register SwiftDate with Travis CI again?\n. Ow... :smile: Sowwy!\nJust login to travis with your github account and submit the SwiftDate repository.\nThat justifies this badge in the README.md:\n  \n. Woops! And Cocoapods too.\nWorking on this now.\n. This works now\n. @malcommac would you mind to trunk this version with CocoaPods pls?\n. Nice job! :-)\nRemarks:\n- please mention the source date (17-Feb-16) for the examples in the table.\n- I am not sure about the unit granularity. Depending on circumstances I would mention \"February next year\"  or just \"next year\". Or \"tomorrow at 20h15\".\n- Weeks are not in the allowed units set?\n- Difference between day parts (morning afternoon, night) differs per locale. E.g. in Indonesia day parts exist for sunrise-11 (pagi), 11-14 (siang), sore (14-sunset), malam (night).\nDutch strings on their way\n. This is complicated matter. In The Netherlands, days are indicated as (English equivalents):\n- the day after tomorrow (\"overmorgen\")\n- the day before yesterday (\"eergisteren\")\n- day name if within the week or closest weekend\n- \"next week\" day name if in next week e.g. \"Friday next week\" --> \"volgende week vrijdag\"\n- \"last week\" day name if in last week e.g. \"Friday last week\" --> \"vorige week vrijdag\"\n- OR: \"Last Friday\"\nOf course we want to keep things as simple as possible.\n. Also: \n- colloquial_f_s is never used in practice. \"Now\" is appropriate.\n- colloquial_thisnight is different for future and past, also in English: \"last night\", if it is the previous night, \"tonight\" if it is the next night (and night is including the evening in the UK), \"this night\" if from within the \"night\" time frame.\n. > Okay good to know, so there is no reason to increase complexity. So, first of all we can drop \"today's\" variants because they are too locale dependant.\nAgreed\n\nCan you explain cricumstances? We could provide variants of relevant time strings for each unit if needed.\n\nMaybe we should include the number of units? E.g. next year can be \"next year\" (1 unit) \"February next year\" (2 units), 27 February next year (3 units) etc.\n\nweeks are available with \"w\" and \"ww\" code\n\nBecause of this code in DateFormatter?\n/// Tell what kind of time units should be part of the output. Allowed values are a subset of\n    /// the NSCalendarUnit mask\n    /// .Year, .Month, .Day, .Hour, .Minute, .Second are supported (default values enable all of\n    /// them)\n    public var allowedUnits: NSCalendarUnit = [.Year, .Month, .Day, .Hour, .Minute, .Second]\n\nBasically I agree but it's a param and by removing it we lose unit granularity (seconds) you can omit with using allowsNowOnColloquial = true. Is it a good idea?\n\nYep agreed but also depending on circumstances. What about a time interval that can be specified for using \"now\"? With a default on 29 seconds?\n\nWe will remove it according to the first point, okay? any better idea?\n\nOk, but remember it for later. It might be easy to add after all. Let us take small steps. \n. For investigation: maybe we can retrieve some of the strings from NSDateFormatter?\n. E.g. put this in a playground:\n```\nlet f = NSDateComponentsFormatter()\nlet units: NSCalendarUnit = [.Day]\nf.allowedUnits = units\nf.unitsStyle = .Full\nlet components = NSDateComponents()\ncomponents.day = -1\nprint(f.stringFromDateComponents(components)) // \"-1 day\"\ncomponents.day = 1\nprint(f.stringFromDateComponents(components)) // \"1 day\"\ncomponents.day = 2\nprint(f.stringFromDateComponents(components)) // \"2 days\"\n```\nIt should be easy to obtain many strings from this\n. Maybe it is a good fallback for those locales that we do not have all strings for?\n. I made a typo; the strings should be obtained from NSDateComponentFormatternot NSDateFormatter(tongue in cheek) sorry.\n. Absolutely! Publish tomorrow.\n. Done\n. The code above works for me. What is the issue exactly with the inits? \nAnd what documentation are you refering to?\n. No response, case closed. May be reopened when sufficient information is provided.\n. You should try SwiftDate v3 and later.\nDoes that resolve your issue?\n. Just try: pod \"SwiftDate\" without the , \"~> 2.0\"bit.\nDoes that work for you?\n. Fixed in 4994b9f\n. Woops should have pulled this in earlier...\nNow I manually did redundant work and need to finish it off. \nThanks for the pull request anyway.\n. Thanks @lammertw \n@malcommac you are working on the time interval. Will you manage this one?\n. Thx for the PR!\n. let date2 = NSDate(year: 2015, month: 12, day: 25, hour: 14) \nprint(date2)\nShows: 2015-12-25 13:00:00 +0000. (Please note that it runs in the CET time zone, so this is correct)\nI.e. unable to reproduce...\n. Which version of the pod do you use?\n. Thx for the feedback.\nI will correct the version in the installation guide.\n. Fixed in 3.0.9\n. Merged into develop branch with ae8eacaff018e7f2b6dc2a181aae35ea15126ac1\n. Thx for the PR! :-)\n. Time zone evaluation should take place agains the date evaluated, not the current date.\n. Fixed in 979f3ad203dcdc8cbd21183acdb4feeaee952e4c\n. Stale docs. Needs an update.\nWorkaround: use startOf function.\nswift\nlet date = NSDate(blahblah) // initialise as desired\nlet firstDayOfWeek = date.startOf(.WeekOfYear)\nPlease let me know if this works for you.\n. We could create a new struct that mimics the data model of NSCalendar. That would create a dependency from Apple's NSCalendarclass though. Your solution is easier.\n. On the other hand: Apple did the same with NSArray and Array: Swiftifying. Doing that with NSCalendar to a Calendar struct would imply A LOT of work though.\n. Wouldn't that be fun? :smile: \n. NSTimeZone is thread unsafe too...\nSomething like this?\n```\nprotocol Calendarish {\n    public let identifier: String\n    public let locale: Locale\n    public let timeZone: TimeZone\n    ...\n}\nstruct GregorianCalendar : Calendarish {\n    ...\n}\nstruct TimeZone {\n    public let abbreviation String\n    public let GMTOffset NSTimeInterval\n    ...\n}\n```\n. Woops I looked in the wrong list and stand corrected. ;-)\n. @malcommac nothing wrong with your approach. I am just playing with the idea.\n. Is this an idea for making calendars thread safe?\n. @malcommac why aren't we as smart as @ypresto ? ;-)\n. @malcommac I think you are correct about the origins of your project and the decision direction.\nI got carried away; give me a hint and I have a thousand ideas ;-) This Calendar idea originates from the expectation that over time the Cocoa classes will be Swiftified in the swift.org project. A new and open sourced Calendar struct would be an enlightment. It would be a project on its ownthough  and way passed the principles of this project.\nSo how do we progress here? \n. I will take on this one with @ypresto 's idea for defining an immutable Region struct.\n. Great find Sergey! I agree to wait for Swift 3. Do you concur @malcolmmac?\n. defaultRegion was removed in favour of Region() that provides the same functionality in a more intuitive way. \nWhile doing that I did not take thread safety into consideration to this level. However this should be covered in #189.\n. That would be a workaround for an issue with the Wareki calendar in Cocoa. Similar issues exist with other calendars. Even with the Gregorian calendar although to a lesser magnitude than yours. \nAlthough I would like to help you, creating a defaultRegion would create ambiguity in the library. We cannot cover all issues in Cocoa. I would suggest that you create a Wareki Region object.\n@malcommac do you concur? Do you see better options?\n. The idea of a default value is that it is a value without setting the object at hand. The default value is provided by the underlying Cocoa libraries. In the case of date, location and time zone, the default values can change depending on the location & configuration of the device. There is quite some library infrastructure in Cocoa supporting this. It is an intended dependency.\nBy allowing to define a second level default value, the underlying default default values get overwritten and hidden and without the programmer necessarily knowing the effect. Sure this can be documented but it complicates things. That is what I mean with ambiguity.\nBy just creating a Wareki region outside the library, responsibility for resolving the complications above remains with the programmer and not inside the library.\nIf we would choose to service workarounds like this, I would be more in favour of an extension the SwiftDate in which a properly functioning Wareki (or Islamic, or Georgian) calendar is provided.\nPls let me know your thoughts on this\n. So your issue is resolved if we can make the NSCalendar variable completely readonly in the region object?\nIf not, why is it that you cannot construct the proper region yourself and instead of declaring it default, you just use that region? What added benefit comes from making it the default setting?\n. Why wouldn't you use:\n```\nlet region = Region() // default region\nlet georgianRegion = Region(calendar: GeorgianCalendar) // default region with a Georgian calendar\nlet region2 = region.calendar.calendarIdentifier == 'wareki' ? georgianRegion : region\nlet date = NSDate()\nlet dateToWorkWith = date.inRegion(region2)\n// do further calculations here with dateToWorkWith\n// processing should be the same for NSDate objects and DateInRegion objects, \n// that is one of the design principles of the SwiftDate library\n```\n. With the solution above you would be able to do so??? It is just that you have a DateInRegion object instead of an NSDate object. Or is it that you MUST work with an NSDate object?\nAnd do not get me wrong: I appreciate your input in this discussion and maybe I am wrong and preoccupied. I am trying to understand and learn here.\n. It is included in the tests so it works. May I ask the reason why you ask?\n```\n            context(\"weekdayName\") {\n            let date = DateInRegion(year: 2002, month: 3, day: 4, hour: 5, minute: 30, region: newYork)\n\n            it(\"should report the weekday name\") {\n                expect(date.weekdayName) == \"Monday\"\n            }\n\n        }\n\n```\n. No response to question, issue unclear, case closed\n. Resolved in develop branch. Thanks for the find!\n. Thanks for your report!\n. Thanks for your report!\n. Objection your honour! There is no such thing as a local absolute date or time. By introducing this you create ambiguity in the library data model.\n@brokeniceinteractive you are missing the point. The absoluteTime property does not return UTC time; it returns NSDate which is an absolute time independent of location. However it is represented as UTC time in Cocoa but you are free to represent it in any format in any location. \n. If added then please add to docs that next Friday means the first Friday after today.\nNot to be confused with the Friday in next week.\n. Thanks for the feedback. \nStale docs. Nowadays you should initialise with:\nlet date = NSDate(year: 2015, month: 12, day: 25)\n. Nope! Please refer to the docs:\n\nNSDate objects encapsulate a single point in time, independent of any particular calendrical system or time zone. Date objects are immutable, representing an invariant time interval relative to an absolute reference date (00:00:00 UTC on 1 January 2001). \n. Thx! NSDateInterval was added from the Swift.org Foundation library with the intention to merge it once published. I.e. our version should be removed and the Swift 3.0 version used.\n\nThe pull request is a nice workaround for the time being though. \n. I will work on it when I find time. Any help appreciated.\n. I will investigate this tomorrow. \n. @brianmichel yes you can. \nPlease refer to #220 for more information. \n. Fixes #252 \n. Hi Chris, I found this branch does not compile Carthage properly:\n*** Fetching Nimble\n*** Fetching Quick\n*** Checking out Nimble at \"v5.0.0\"\n*** Checking out Quick at \"v0.9.3\"\n*** xcodebuild output can be found in /var/folders/q3/g4ljbw1j1734wbxqc28kx7xr0000gn/T/carthage-xcodebuild.Uu3q7e.log\n*** Building scheme \"Nimble-macOS\" in Nimble.xcodeproj\n*** Building scheme \"Nimble-tvOS\" in Nimble.xcodeproj\n*** Building scheme \"Nimble-iOS\" in Nimble.xcodeproj\n*** Building scheme \"Quick-iOS\" in Quick.xcworkspace\n*** Building scheme \"Quick-tvOS\" in Quick.xcworkspace\n*** Building scheme \"Quick-OSX\" in Quick.xcworkspace\nld: warning: embedded dylibs/frameworks only run on iOS 8 or later\nld: warning: embedded dylibs/frameworks only run on iOS 8 or later\nld: warning: embedded dylibs/frameworks only run on iOS 8 or later\nld: warning: embedded dylibs/frameworks only run on iOS 8 or later\nAm I doing something wrong?\n. Pull request #252 fixes some. Checking...\n. ",
    "harryworld": "I found out already, it should be dd/MM/yyyy in order to parse correctly.\nPlease correct this in README.\nThanks.\n. Thanks, happy to help testing\n. ",
    "abunur": "ah looks like the Unit Tests in the library need updating.  I made a pull request, will update it and submit.\n. also had an issue recently trying to update via pod update: \"Unable to load a podspec from SwiftDate.podspec\".  However updating to latest release of CocoaPods (0.39.0) resolved this.\n. Any plans for intermediary / Swift 2.3 branch?  Otherwise am going to branch my own from v 1.2\n. Can't get this lib to work under Xcode Beta 5.  Which version is currently being supported? (Beta 6 was released today).\n. Yes exactly - was not sure if master was Swift 3 or not, b/c of the existence of separate Swift 3 branch still.  So please remove the branch.\n. ",
    "pratik6554": "print(\"todays date ==\\(NSDate())\")\n    print(\"toLocalTime ==\\(NSDate().toLocalTime())\")\noutput : \ntodays date ==2015-10-19 08:42:45 +0000\ntoLocalTime ==2015-10-19 03:12:45 +0000\nlocal time is not correct as per my time zone(GMT+5:30)\nPlease check http://www.davidbreyer.com/programming/2014/06/10/getting-local-date-and-time-with-swift/\n. Cool..g8 :) \n. ",
    "Fjohn666": "Hello. When I'l looking the toLocalTime function I think there is a problem : \nfunc toLocalTime() -> NSDate {\n        let tz : NSTimeZone = NSTimeZone.localTimeZone()\n        let secs : Int = -tz.secondsFromGMTForDate(self)\n        return NSDate(timeInterval: NSTimeInterval(secs), sinceDate: self)\n    }\nI think the seconds from GMT don't have to be always negative. For example I'm in France and GMT +2 time zone. The ToLocalTime is wrong for me here because it subtract 2hours of UTC and I need to add 2 hours ...\nI'm wrong ?\n. ",
    "roma86": "@Hout thank you for comment. I know about NSDate UTC feature. This topic not about. \nThis topic about SwiftDate api exactly. My example show that toTimezone work not as it name suggests. \nOr i misunderstand how to use it. What i should to do if i want add 4 hours to time in HKT zone?\nIt is very organic to convert date to target zone, increase hours and get result. But But result is not as expected. \n. @malcommac I think you understand me right. One more explanation:\n\nI need this to calculate future date\ni am solving this like so\n/**\n    Return date time of day in minutes\n    */\n    public func timeInMinutesInMoscow() -> Int {\n        let cal = NSCalendar.currentCalendar()\n        let components = cal.componentsInTimeZone(NSTimeZone(abbreviation: \"MSK\")!, fromDate: self)\n        return components.hour * 60 + components.minute\n    }\n. This is link to my playground\n. ",
    "xiajinchun": "@chelsh \nYou can custom an extension for SwiftDate and then copy toRelativeString function, and only one thing you do is implement _sdLocalizeStringForValue function like this:\nswift\n    func _sdLocalizeStringForValue(unit: NSCalendarUnit) -> String {\n        var toTranslate : String = \"\"\n        switch unit { \n        case NSCalendarUnit.Year:       toTranslate = \"\u5e74\"      \n        case NSCalendarUnit.Month:      toTranslate = \"\u6708\"    \n        case NSCalendarUnit.WeekOfYear: toTranslate = \"\u5468\"     \n        case NSCalendarUnit.Day:        toTranslate = \"\u5929\"     \n        case NSCalendarUnit.Hour:       toTranslate = \"\u5c0f\u65f6\"    \n        case NSCalendarUnit.Minute:     toTranslate = \"\u5206\"    \n        case NSCalendarUnit.Second:     toTranslate = \"\u79d2\"     \n        default:                        toTranslate = \"\"\n        }\n        return toTranslate._sdLocalize\n    }\n```\nThis is also my implementation way.\n. ",
    "redent": "To reproduce this issue just change the region to Spain and execute:\nNSDate().dateAtWeekStart()\nIt will always return a date in the future (unless already on Sunday)\n. I agree, but adding inDefaultRegion() to isn't that bad anyway.\n. This bugs a little bit. Had to add these lines to all my projects, where it seemed like the default config:\nlet region = SwiftDate.Region(cal: NSCalendar.currentCalendar(), tz: NSTimeZone.defaultTimeZone(), loc: NSLocale.currentLocale())\nSwiftDate.Region.setDefaultRegion(region)\n. I'm referring to this line of code.\n. Minor update: the solution proposed above doesn't process 2015-11-26T14:21:10.000+01:00 as .Extended as it has 29 characters and it doesn't match any declared ISO8601Format enum.\n. Are you releasing this fix to 4.x or is it a dead branch?. ",
    "MPiccinato": "Awesome, thanks for the info. Keep up the great lib!\n. ",
    "pardel": "ISO8601Date ensures the output using that format doesn't contain the time component\n. ",
    "reallyseth": "Xcode 7.1 building for iOS. \n\nOn Nov 30, 2015, at 12:58 AM, Daniele Margutti notifications@github.com wrote:\nHi, Xcode 7 or 7.1? Are you building it for Mac or iOS?\n\u2014\nReply to this email directly or view it on GitHub.\n. I forked the repo, and tried making the scheme shared, like @alpennec suggested. Noticed that the shared scheme data was ignored by the .gitignore, so I tried adding that back in, and pointing carthage to my forked version of the repo, but still wasn't able to get it working.\n. Hmmmm, looks like I'm still seeing the same issue when I run carthage update. Also tried carthage bootstrap but that didn't work either. Looks like it downloaded version 2.0.1, but I'll double check. I'm on terrible wifi on a train, so it's taking a while to test...\n. @bernardgatt that fixed the issue! Thanks so much!\n. One more note. I'm wondering if the way carthage is building the framework, or something on my end, is not including the DataStructures.swift file. I tried initializing a region and am seeing this error as well.\n\n\n. Fixed. Thank you so much!\n. ",
    "alpennec": "Same for me.\n*** Skipped building SwiftDate due to the error:\nDependency \"SwiftDate\" has no shared framework schemes\nI think Share should be checked in the Schemes management panel.\n\n. It worked for me. No problem to build v2.0.1. Thanks @BernardGatt @malcommac \nI think this thread can be closed.\n. Thanks!\n. ",
    "BernardGatt": "Issue should be fixed now, @malcommac you might need to make a new release (2.0.1)\n. No problem :)\nWhat do you mean by set required parameters? @malcommac \n. @reallyseth can you please go into the checkout folder, delete SwiftDate and try the update command again?\n. Great :+1: \n. ",
    "kohdesmond": "+1\nTo add in @reallyseth 's question, \nlet romeRegion = Region(calType: CalendarType.Gregorian, tzType: TimeZoneNames.Europe.Rome)\nreturn an error of 'Region' cannot be constructed because it has no accessible initializers\n. \"Installing SwiftDate 4.4.2 (was 4.1.10)\"\nStill have the \"Pods/SwiftDate/Sources/SwiftDate/DOTNETDateTimeFormatter.swift:47:85: 'range(at:)' has been renamed to 'rangeAt(_:)'\" error. ",
    "pvels": "same problem in 3.0.8. Or it not problem?\n. Thanks for answer :)\n. ",
    "remotevision": "I have struggled a little with the migration as well. Opted to sift through code commits to see specifically what has changed. Ultimately I have everything working again except for let start = NSDate().startOf(.Day, inRegion: Region.defaultRegion()). The doc suggests you can not provide a Region but it is not optional.  I get an error of Type 'Region' has no member 'defaultRegion' but I don't understand why. Any suggestions?\nFor the others I did this:\nsunrise.inDefaultRegion().toShortString(false, time: true)\nstartDate.toString(DateFormat.ISO8601)\n. ",
    "efremidze": ":+1:\n. \ud83d\udc4d \n. ",
    "AndrewSB": "agree with it being implemented in the future @Hout, I'll try to use #65, but it should definitely be an option customizable through API\n. ",
    "NebulaFox": "Although I am not a developer on this, by the ISO860 standard, +0000 is valid for the timezone.\nBut I want to second the fact that\nNSDate().toString(.ISO8601).toDate(.ISO8601) // nil\n. I have a fix in my fork https://github.com/NebulaFox/SwiftDate and have the pull request https://github.com/malcommac/SwiftDate/pull/100\n. ",
    "danishin": "@NebulaFox Thanks for the pull request! I'm not too familiar with ISO standards so I was hoping someone would do it. Hope it gets merged soon :+1: \n. ",
    "twiedow": "By the way, this is working:\nswift\n    let tomorrow = today.add(days: 1)\n. I just opened a pull request for this issue (Fix month component initialization #162).\n. Any news about a Swift 2.3 / 3 compatible release?\n. ",
    "cjwirth": "When I was doing this yesterday, I realized I had a super old version of Carthage installed. I'll have to try this again with the new version and see if I still have the same problems. :sweat_smile: \n. I just tried it right now, and this is what I got:\n```\n\nmkdir test && cd test\necho 'github \"malcommac/SwiftDate\"' > Cartfile\ncarthage version\n0.11.0\ncarthage update\n Cloning SwiftDate\n Checking out SwiftDate at \"2.0.2\"\n xcodebuild output can be found in /var/folders/2b/j65n_shn79v2m2zb93r6gqcc0000gn/T/carthage-xcodebuild.kBibXZ.log\n Building scheme \"SwiftDate\" in SwiftDate.xcodeproj\n2016-01-06 09:51:50.362 xcodebuild[35941:2131692] ### Failed to load Addressbook class CNContactNameFormatter\n2016-01-06 09:52:02.041 xcodebuild[36005:2132008] ### Failed to load Addressbook class CNContactNameFormatter\nls Carthage/Build\niOS\n```\n\nWhen I added the extra target/scheme and commented out the UIKit things, it did make multiple directories in my Build directory...\n. I made some configuration changes so Quick/Nimble aren't included in the main framework, only the test target. I also got rid of some extraneous targets that didn't have to be there. Take a look at #141 and tell me what you think.\n. Excellent, thanks! :rocket: \nYeah, how you guys ended up fixing it up is probably better than my solution.\nHowever, you might want to get rid of the extraneous SwiftDate.xcodeproj and SwiftDate.xcworspace, etc. files that aren't being used anymore.\n. :no_mouth: \nNope! With a fresh clone, they are all gone! \nSorry about that, it must have just been left over on my side when I switched branches or something.\nNice work :sparkles: \n. I don't think there is a need for separate config setting files if you are satisfied with the way the settings are set up in the project file. It does centralize some of the settings, so it can be easier to change some settings for everything. \nYou probably could move the SwiftDate Tests files into the SwiftDateTests group, and move the SwiftDate Sources files into the SwiftDate group. It might be a little cleaner, but I don't think it really makes much of a difference.\n\n. ",
    "rcdilorenzo": "@malcommac I can't seem to get it to work for the Mac platform.\n. ",
    "phimage": "@rcdilorenzo  (@malcommac) the source are not added into the OSX target \"Build Phase\" \"Compile Sources\"\n@malcommac I think to keep same framework names for Carthage \"product name\" (\"Build Settings\") must be edited in OSX, TVOS, WatchOS targets to replace $(TARGET_NAME) by SwiftDate\n. ",
    "fuji2013": "ok, I move to  develop branch.\n. ",
    "TadeasKriz": "Damn, I didn't check the development branch, sorry :/\n. But it is still there. Just in a different file: https://github.com/malcommac/SwiftDate/blob/develop/SwiftDate/NSDateComponents%2BSwiftDate.swift#L143\n. Awesome, thanks!\n. Yes I will test it and let you know.\n. Seems to work properly now, thanks!\n. Not DateInRegion but DateRegion which was Region in 2.0. And since Region and DateRegion are both public and thus part of the API, renaming the class (and removing functions, renaming input parameters) is breaking the API and is not backward compatible.\n. @Hout I think that there were some more changes, for example the initializer's parameters of the DateRegion are different than Region. Also I think the versioning does not mean what version of the module, but the platform (so in the commit you say it is available since any platform's version 2.1). Also there are removed functions (like the UTCRegion() mentioned in my other ticket) which also break the API compatibility. Easiest would be to make this release 3.0 as there are many changes in the public api.\n. I have added UTCRegion function (I know it would be better for it to be a static constant property, but I already used it on some places when I was using SwiftDate 2.0) to do what I was doing before.\nNSDate().startOf(.Hour, inRegion: DateRegion.UTCRegion()) + 1.days + 1.hours\nI use the UTC, because I need to have some reference independent on user's local timezone. I think we can close this issue, I will just use the extension function. (I realized it after I opened the ticket yesterday)\n. That works well, thanks!\n. Yes, because the only thing I have is an offset in seconds from GMT and I need to use it as a timezone.\n. ",
    "RustamG": "I use pod version 2.0.2. I've set Kaliningrad timezone on my pc and restarted the simulator to have the same timezone in it. I guess the problem is because localDate doesn't consider DST.\nTo reproduce the issue please set your device's timezone to Kaliningrad. Download the attached archive and look at the tests test_dateinregion_localdate_date_considering_dst() and test_dateinregion_localdate_date()\nSwiftDate-master.zip\nIf you change implementation of localDate like here: https://github.com/RustamG/SwiftDate/commit/6a571014165048519da141b09c0a58f5f868bdf0#diff-e37b7fd05b8dead718b22334560ff935 everything should work well.\nI would make a pull request but I realized that in the develop branch there is no such property :smile: \n. It would be great if you release the version with the PR https://github.com/malcommac/SwiftDate/pull/125 before the localDate disappear.\n. Yeah. I understand that NSDate applies to all time zones. I use localDate because it is easy to get components in a specific time zone and to perform calculations on the dates in specific time zone.\n. ",
    "shams-ahmed": "great idea, also look at SwiftLint to help enforce consistency\n. @malcommac use a custom configuration for SwiftLint, most things be can enabled/disabled \n. ",
    "irace": "I think so!\n. > Can be done with NSDateComponentFormatter too.\nCan you provide an example? I was trying to figure out how to do this but could not.\n. Maybe so but this isn\u2019t the case in the latest tagged CocoaPods build. I don't mean to be snarky but it should be expected that bug reports get filed from release versions, right?\nOn the release version, I believe date.inRegion() uses a default region that is not necessarily the local region, and also the most string formatting methods are on DateInRegion but not NSDate.\nThanks!\n. ",
    "morphinewan": "me too.\n. ",
    "SiNBizkit": "Same problem\n. ",
    "AndrewBarba": "Can you release 3.0.9 to Cocoapods so we can get this change?\n. Ah, weekdayName is missing from NSDate+SwiftDate.swift. I think we just need to add:\npublic var weekdayName: String {\n    return self.inRegion().weekdayName\n}\n. Any updates on this now that the GM's are released? Would be really helpful to get this working with Swift 2.3 at the very least\n. Any updates here?\n. Can we get this merged?. Oops, duplicate: https://github.com/malcommac/SwiftDate/pull/471. ",
    "berlin2": "To make this work I changed your response:\nswift\nlet utcRegion = Region(calendarName: nil, timeZoneName: TimeZoneName.Gmt, localeName: nil)\nlet utcString = NSDate().inRegion(utcRegion).toString(DateFormat.ISO8601)\nThis returns a 2016-01-31T12:01:01+0000. I am looking for 2016-01-31T12:01:01.199Z\n. ",
    "lemonlab": "Thank you ! That helps me a lot.\nCan you give me more information or an example to use the \"inRegion\" and \"style\" parameters ?\nitem.date.toNaturalString(NSDate(), inRegion: ?, style: ?)\n. ",
    "gloryluu": "Could you update the library? I get some of confusion of this natural after updating to 3.0.2\n. ",
    "vojto": ":+1: \n. Answersing myself:\nswift\nlet calendar = NSCalendar(calendarIdentifier: .gregorian)!\nfor _ in 0...1000 {\n    var components = DateComponents()\n    components.year = 2017\n    components.month = 1\n    components.day = 1\n    _ = calendar.date(from: components)?.timeIntervalSince1970\n}\nThat takes 0.007 seconds.. ",
    "ricardopereira": "Please create a version to comply this because it is a critical bug!\n. ",
    "Morbix": "@Hout I am trying to get the NSDate equivalent of the firstWeekDay. Do you know how can i do this?\n. I am really sorry @Hout . I didn't even tried to run your code. It worked perfectly. \nJust the name \"weekOfYear\" is a little bit confuse, because suppose that is going to return the first week of the year (like New Year's week). This was the reason that I, unfortunately, didn't tried to run.\nBut whatever, it is returning what I am needing.\n. ",
    "filipejtdias": "Just an update to Swift 3\nlet date = xyz\nlet startOfWeek = date.startOf(component: .weekOfYear)\n;). ",
    "marcbaldwin": "I did a bit of investigation and it appears to be an issue with Region.\nI found that the Region's timeZone is equal to the TimeZoneName's timezone when using the tzType initializer (expected). But when using the tz initializer the timeZone is set to the given NSCalendar's timezone, effectively ignoring the given NSTimeZone.\nI would expect the Region's timeZone to equal the one given in the initializer.\n``` Swift\nlet region1 = Region(calType: CalendarType.Local(true), tzType: TimeZoneNames.America.Los_Angeles, loc: NSLocale.autoupdatingCurrentLocale())\nlet region2 = Region(cal: NSCalendar.autoupdatingCurrentCalendar(), tz: NSTimeZone(name: \"America/Los_Angeles\"), loc: NSLocale.autoupdatingCurrentLocale())\nlet calendar = NSCalendar.autoupdatingCurrentCalendar()\ncalendar.timeZone = NSTimeZone(name: \"America/Los_Angeles\")!\nlet region3 = Region(cal: calendar, tz: NSTimeZone(name: \"America/Los_Angeles\"), loc: NSLocale.autoupdatingCurrentLocale())\nprint(region1.timeZone) // Prints America/Los_Angeles (PST) offset -28800\nprint(region2.timeZone) // Prints Europe/London (GMT) offset 0\nprint(region3.timeZone) // Prints America/Los_Angeles (PST) offset -28800\n```\n. Sorry, turns out I was using SwiftDate 2.0.0.\n. ",
    "netgfx": "let d = data.toDate(DateFormat.Custom(\"MM/dd/yyyy\")) // \"2016-02-02 18:00:29\"\nthis syntax returns nil\nIs this the same bug or related?\n. So to get this straight, the DateFormat should match the date string provided?\nI thought it was the format based on which the Date is returned.\nSo how can I know which dateformat to use?\n. Yes I understand now and I was able to convert the given date to a custom formatted one.\nThanks for clarifying things.\n. nevermind, I figured it out. thanks anyways.\n. ",
    "JeanAzzopardi": "Bump - I'm interested in this primarily as I'm using it on a project where the OSX version is unlikely to be El Capitan, most likely Yosemite. As is, there are no purely El Capitan specific features that are used.\n. I think it's already in the .podspec actually: https://github.com/malcommac/SwiftDate/blob/master/SwiftDate.podspec\nMACOSX_DEPLOYMENT_TARGET = 10.10\n. ",
    "lxkbest": "Real machine environment createTimeDate is nil\nThe simulator createTimeDate is not nil\nWhat's the cause of the\n. this source string \uff1a Feb 12, 2016 5:06:06 PM\n. Chinese\uff1a\n\u6700\u540e \u6211\u67e5\u770b\u4f60\u7684\u6e90\u4ee3\u7801\uff0c\u505a\u4e86\u4ee5\u4e0b\u8c03\u6574\u3002\u5728 DateInRegion.Swift\u4e2d\u7684\u521d\u59cb\u5316\u65b9\u6cd5\u91cc\u7684case .Custom \u4e2d\u6dfb\u52a0\ncFormatter.locale = NSLocale(localeIdentifier: \"en_US\")\nEnglish\uff1a\nFinally I see your source code, do the following adjustments.  DateInRegion.Swift\ncFormatter.locale = NSLocale(localeIdentifier: \"en_US\")\n.Custom case (dateFormat let):\n       cFormatter.dateFormat = dateFormat\n       cFormatter.locale = NSLocale(localeIdentifier: \"en_US\")\n       ParsedDate = cFormatter.dateFromString (date)\n}\n. hi man  thank you\n. ",
    "longxianlin": "woking now, need compile at once after pod install\n. ",
    "callagga": "I get the following error message (below) if I drop the recommended Pod file lines of:\nuse_frameworks!\nplatform :ios, '8.0'\npod \"SwiftDate\", \"~> 2.0\"\nError message\n```\n$ pod install --verbose\n  Preparing\nUpdating local specs repositories\nUpdating spec repo master\n  $ /usr/bin/git pull --ff-only\n  Already up-to-date.\nCocoaPods 1.0.0.beta.4 is available.\nTo update use: gem install cocoapods --pre\n[!] This is a test version we'd love you to try.\nFor more information see http://blog.cocoapods.org\nand the CHANGELOG for this version http://git.io/BaH8pQ.\nAnalyzing dependencies\nInspecting targets to integrate\n  Using ARCHS setting to build architectures of target Pods: (``)\nFinding Podfile changes\n  - SwiftDate\nResolving dependencies of Podfile\n[!] Unable to satisfy the following requirements:\n\nSwiftDate required by Podfile\nSwiftDate (= 2.0.2) required by Podfile.lock\n\nSpecs satisfying the SwiftDate dependency were found, but they required a higher minimum deployment target.\nSpecs satisfying the SwiftDate (= 2.0.2) dependency were found, but they required a higher minimum deployment target.\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/resolver.rb:411:in handle_resolver_error'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/resolver.rb:69:inrescue in resolve'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/resolver.rb:57:in resolve'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/installer/analyzer.rb:539:inblock in resolve_dependencies'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/user_interface.rb:59:in section'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/installer/analyzer.rb:537:inresolve_dependencies'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/installer/analyzer.rb:70:in analyze'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/installer.rb:213:inanalyze'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/installer.rb:136:in block in resolve_dependencies'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/user_interface.rb:59:insection'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/installer.rb:135:in resolve_dependencies'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/installer.rb:105:ininstall!'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/command/project.rb:71:in run_install_with_update'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/command/project.rb:101:inrun'\n/Library/Ruby/Gems/2.0.0/gems/claide-0.9.1/lib/claide/command.rb:312:in run'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/lib/cocoapods/command.rb:47:inrun'\n/Library/Ruby/Gems/2.0.0/gems/cocoapods-0.39.0/bin/pod:44:in <top (required)>'\n/usr/local/bin/pod:22:inload'\n/usr/local/bin/pod:22:in `'\n$ \n```\n. thanks. ",
    "owenbirdsall": "Yes, it should be one week plus one day, but I thought that setting maxUnits to one would restrict the result to be a single value - either 1 week or 8 days... or have I misunderstood this functionality?\nMy region settings are: gregorian; Europe/London:GMT; en_US\n. ",
    "andreichirkunovgoon": "I used v 2.0.2, which was specified in the installation guide. I didn't check for newer versions. I now updated to v3 and it works. Thank you for your hint! You did amazing code!!\n. ",
    "LuoLee": "It does the style of dateString must confirm the dateformatter,\nSwift\n\"2016-03-22T19:55:28.377Z\".toDate(DateFormat.Custom(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"))\n\"2016-03-22T19:55:28\".toDate(DateFormat.Custom(\"yyyy-MM-dd'T'HH:mm:ss\"))\n\"03/22/2016 19:55\".toDate(DateFormat.Custom(\"MM/dd/yyyy HH:mm\"))\nall OK!\n. ",
    "ypresto": "Region is exposing mutable NSCalendar instance to public, so Region is mutable. Is it also expected..?\nswift\n    public let calendar: NSCalendar!\n. I worry about thread and mutability because I want to cache default Region object to memoize NSCalendar object.\nNew Region is created on each nsDateInstance.add(...) and it impacts performance.\n. Yes, let calendar cannot be changed. But NSCalendar itself is mutable class. For example, locale can be changed by region.calendar.locale = ... from outside of the library.\n. > https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html\nNSTimeZone is thread safe according to the document.\n\nstruct that mimics the data model of NSCalendar\n\nI agree with this, because only public constructor Region(calendarName:, timeZoneName:, localeName:) does not depend on NSCalendar instance.\n. I meant like below:\n``` swift\nclass Region {\n    let calendarName: CalendarName\n    let timeZoneName: TimeZoneName\n    let localName: LocaleName\nvar calendar: NSCalendar {\n    // It might be better to cache calendar per Region instance instead of global one.\n    return CalendarCache.sharedCalendarForCurrentThtread(region: self)\n}\n\n...\n\n}\n```\nThis does not create any new abstraction or mimics, and just make Region thread safe and cacheable..!\n\nstruct that mimics the data model of NSCalendar\n\nRegion is already mimics parameter of NSCalendar\n. Note that var calendar is internal access, and cannot be manipulated from outside of ~~instance~~ library.\nCost of copying NSCalendar is not ignorable, so it'd be better to copy it only when necessary (for use from outside of the library).\nswift\npublic func newCalendar() -> NSCalendar {\n    ...\n}\n. wrong branch >_<\n. > move on DateInRegion only if you need to play with a custom configuration (https://github.com/malcommac/SwiftDate/issues/189#issuecomment-207733757)\nI agree that. joda-time (Java) also uses non-standard DateTime class to combine with timezone.\n. I have one more reason to want to set default.\nIn Japan, some iOS user sets its calendar to Japanese calendar (a.k.a. \"Wareki\" (\u548c\u66a6)) and it often causes bug around date calculation.\nWhen user sets to \"wareki\" calendar, dateComponents.year returns \"28\" even when current (gregorian) year is \"2016\" (because last emperor enthroned in 1989; 28th year (2016-1988) from the enthronement).\nWhen server returns \"createdAt: 2016-04-09\" and local NSDateComponents returns \"0028-04-08\" for current date, it is shown as \"commented 1988 years ago\"...\nIt is very headache... Because of this many iOS developer in Japan override default calendar by category.\nobjc\n+ (NSCalendar *)my_calendar\n{\n    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];\n    calendar.locale = [NSLocale currentLocale];\n    return calendar;\n}\nThis might be Japan-specific issue but I think similar issue can happen in islamic regions.\n. Oh sorry... the issue may be different a little. We don't want to create or calculate in Wareki region. We want to use standard Gregorian region as default even if cocoa returns Wareki one (of course when no region is passed).\n\nIs there a problem using a common defaultRegion property as static one for Region class?\n\nIf caching and threading are handled (by #189), there is no reason to use closure and it can be just static var. :)\n. > By allowing to define a second level default value, the underlying default default values get overwritten and hidden and without the programmer necessarily knowing the effect.\nI agree this, but Cocoa's default cannot be overridden although we are eager to do so.\nIn my opinion \"optional\" default value is not harmful so much, because Cocoa's default is hidden only when the developer explicitly sets the second level default.\n\n\nwhy is it that you cannot construct the proper region yourself and instead of declaring it default, you just use that region?\n\nWhile we can construct it, this means we (all Japanese iOS developers) should always pass our \"default\" to every method call to SwiftDate including simple NSDate.add() (except for DateInRegion). It effectively reduces usability of this library.\nAnother developer in our team proposes to create extension methods for every SwiftDate methods, but it looks awful... >_<\n``` swift\nextension NSDate {\n    func my_add(...) -> NSDate {\n        return inRegion(MyRegionManager.defaultRegion).add(...)\n    }\n// Wrap every (necessary) methods.\n...\n\n}\n```\n. Because we feel it's redundant to specify region in everywhere.\nWe just want to calculate always in the standard calendar, not particular one (explicitly specified by inRegion(...)).\n(But the standard differs from Cocoa default...)\n. ",
    "Sega-Zero": "There is an accepted proposal for swift 3 that will make immutable Calendar wrapper over NSCalendar. It is better to wait for it, I think.\n. ",
    "HarriesChen": "@Hout   I'm sorry to ask that is this pull request possible to merge?  because our project use this as a framework by Carthage , and It's not good to see a warning every day.\n. ",
    "cikpis": "The problem is that I should know if the passed string date is valid or not. Return nil should be the logic to let you know that.\nAnyway, I have another question. How come the toDate(_:) method was removed from version 4.x of SwiftDate? Which one should I use now? Thanks in advance for your answer.\nCarmelo\n. Thanks for the code. I've already tried that but I got a DateRegion object instead of NSDate or Date. Any clue?\n. I see. Well, thanks for the info and let me know when that version is out ;)\nCheers!\n. Hi @malcommac, what is the new format of toDate(DateFormat.ISO8601Format(.Extended))?\nMy string is 2016-08-05T18:20:24.388Z and I'm using \ncreatedAt = try json[\"createdAt\"].stringValue.date(format: DateFormat.extended).absoluteDate\nbut always failed. Also, there is some other way to get the date without the try and catch?\n. I tried but always failed.\n. I thought there was some default settings for that format. I knew I could use the custom one :)\nThanks for your time man. Chat to you soon!\n. Cool! You rock!\n. Sounds good!\n. cool! thanks\n. Cool! Thanks man!. BTW, do you know already the date for 4.0.8?. ",
    "canisal": "Thanks.\n. ",
    "leancmscn": "recommend https://github.com/remirobert/Tempo\n. ",
    "cgoldsby": "Sorry, but it looks like this is still not fixed in in the develop branch. #207 will resolve this bug.\n. Looks like the documentation is incorrect. This example date string is using the ISO8601Type.Extended format so the correct code would be:\nswift\nlet date1 = \"2015-01-05T22:10:55.200Z\".toDate(.ISO8601Format(.Extended))\n. Documentation appears to be outdated. Looks like DateRegion only uses the TimeZoneName enum now. There are TimeZoneName.Local and TimeZoneName.Gmt. Hopefully, this may help you.\n```\nlet newYork = DateRegion(timeZoneName: .AmericaNewYork)\nlet utc = DateRegion(timeZoneName: .Gmt) // UTC/GMT\n// Create a date for XMas Day at midnight in New York\nlet date1 = NSDate(year: 2015, month: 12, day: 25, region: newYork) // 2015-12-25 10:00:00 +0000\nlet date2 = NSDate(year: 2015, month: 12, day: 25, hour: 5, region: utc) // 2015-12-25 10:00:00 +0000\nif date1 == date2 {\n    print(\"Dates are equal.\")\n}\n```\nSeems like TimeZoneName.Custom(String) would be a useful enhancement, though...\n. The feature/swift_23 branch did rename this class: 4acda8f5b195f1991d4097ae73994e12a0d83572\n. @brianmichel, imho, I think this PR can be closed.\nThanks for your PR (and reacting to it back in June! \ud83d\udc4f). It was the catalyst to me heading over to the feature/swift_23 branch to see if it had the same issue.\n. Hi Hout,  (I am not sure if this has changed) but Nimble and Quick may not have official Swift 3 releases.\nThe Cartfile should point to the specific Swift 3 branches for Nimble and Quick:\ngithub \"Quick/Quick\" \"swift-3.0\"\ngithub \"Quick/Nimble\" \"master\"\nI noticed in your output, Carthage is using a different version than what I was expecting:\ndiff\n- *** Checking out Nimble at \"v5.0.0\"\n+ *** Checking out Nimble at \"0209419661b6acceff45cd63984596f2e9eea517\"\n- *** Checking out Quick at \"v0.9.3\"\n+ *** Checking out Quick at \"36ebbc75e093c7553a5145ed5dd21484364cd78d\"\nAfter cloning and running Carthage update I get the following output:\nxcodebuild -version\nXcode 8.0\nBuild version 8A218a\ncgoldsby:XCode cgoldsby$ carthage update\n*** Cloning Nimble\n*** Cloning Quick\n*** Checking out Nimble at \"0209419661b6acceff45cd63984596f2e9eea517\"\n*** Checking out Quick at \"36ebbc75e093c7553a5145ed5dd21484364cd78d\"\n*** xcodebuild output can be found in /var/folders/_y/5xvmvfs114g74mfhlkn84fm00000gn/T/carthage-xcodebuild.Z9VtrU.log\n*** Building scheme \"Nimble-macOS\" in Nimble.xcodeproj\n*** Building scheme \"Nimble-tvOS\" in Nimble.xcodeproj\n*** Building scheme \"Nimble-OSX\" in Nimble.xcodeproj\n*** Building scheme \"Nimble-iOS\" in Nimble.xcodeproj\n*** Building scheme \"Quick-OSX\" in Quick.xcworkspace\n*** Building scheme \"Quick-tvOS\" in Quick.xcworkspace\n*** Building scheme \"Quick-iOS\" in Quick.xcworkspace\nHope this info helps.\n. I think this change is related to the fix made for #463.\nThe colloquial formatted string is returned only for unit style .full and .spellOut, else it returns a \"time formatted\" string (which is now the default). L133\nIn the meantime, I've updated my code to use:\ncolloquialSinceNow(unitStyle: .full)\n. The swift version is defined as 4.0 in the podspec.\nA temporary solution to silence the warning would be to update your Podfile and set the Swift version to 4.2. In my case, the post_install for my Podfile looke like this:\n```ruby\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    next unless [\n      'SwiftDate-iOS',\n      'SwiftDate-macOS',\n      'SwiftDate-tvOS'\n    ].include? target.name\ntarget.build_configurations.each do |config|\n  config.build_settings['SWIFT_VERSION'] = '4.2'\nend\n\nend\nend\n```. ",
    "raf66": "Here's my issue: I am reading the timezone name from a Web Service.  Without timeZoneID (or the suggested TimeZoneName.Custom() solution), how can I possibly create a DateRegion from that JSON string?\n. ",
    "lucabecchetti": "i use this now:\n\nlet dt = date.inRegion(DateRegion())\n\nlet dateFormatter = NSDateFormatter()\n    dateFormatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    let dat:String? = dt.toString(DateFormat.Custom(\"yyyy-MM-dd HH:mm:ss\"))\n    return dateFormatter.dateFromString(dat!)!\n. ",
    "samad5353": "I want DateInRegion() as Date?? \nI am using version 4.0.3 and i am not getting localAbsoluteDate. ",
    "GuiAfonso": "Hi, I have a DateInRegion but my function(query pedometer) don't accept DateInRegion type how can I get the Date without missing my region Timezone. \nlet date1 = Date()               2017-05-06 20:22:14 +0000 (Wrong Timezone)\nlet date2 = DateInRegion()       6 May 2017 17:22:14 GMT-3 (Right Timezone but not 'Date' type)\nlet date3 = date1.inRegion()     6 May 2017 17:22:14 GMT-3 (Right Timezone but not 'Date' type)\nlet date4 = date2.absoluteDate   2017-05-06 20:22:14 +0000 (Wrong Timezone)\nI already put Date.setDefaultRegion(Region.Local())  on my  AppDelegate\nSorry if is a noob question, but I'm not found the answer yet.\n. ",
    "otymartin": "@malcommac Thanks\nI had since simplified what i was trying to do however I believe that would be a really handy convenience method to offer. I basically wanted my users to create events. Using UIDatePicker  I wanted to limit the possible options to the following Friday Saturday or Sunday on the condition that those days are atleast 5 days away. (Gives users time to organize themselves, Didn't want next Friday to be tomorrow)\nSo my first time using the library, i was playing around trying to create these objects with this syntax\nvar nextFriday = NSDate().nextFriday I guess it just felt natural even though the method didn't exist.\netc..\n//My simplified solution \ud83d\ude02\nswift\n       let today = NSDate()\n        let day1 = today + 1.days\n        let day2 = today + 2.days\n        let day3 = today + 3.days\n        let day4 = today + 4.days\n        let day5 = today + 5.days\n        let day6 = today + 6.days\n        let day7 = today + 7.days\ne.tc..\n. @malcommac Dope \ud83d\ude4c\n. beautiful thanks @malcommac . ",
    "onekiloparsec": "Hi. Sure, I will move it to 'develop'. Don't know how if I can do it from here, so I'll create a new PR.\n. Great! Thanks\n. ",
    "iandundas": "This is not related to SwiftDate, please see this issue :)\n. bump :) \ud83d\udc68\ud83c\udffc\u200d\ud83c\udf73. \ud83d\ude4f\ud83c\udffc thanks . ",
    "xandros6": "Hi, I have problem with Carthage too.\nSimple github \"malcommac/SwiftDate\" on my Cartfile\ncarthage 0.17.2\nxcode 7.3.1\nWhen I run carthage update --platform iOS --no-use-binaries\nThe output is:\n*** Skipped building SwiftDate due to the error:\nDependency \"SwiftDate\" has no shared framework schemes for any of the platforms: iOS\nOther project in the same Cartfile works.\nThanks.\n. ",
    "ddunbar": "To clarify a bit more, I believe what is going on here is that it has become an error in the updated clang to redeclare an Objective-C class in Swift and then export it.\n. Yes!\n. ",
    "brianmichel": "\nTo clarify a bit more, I believe what is going on here is that it has become an error in the updated clang to redeclare an Objective-C class in Swift and then export it.\n\nEither way, renaming this class should solve the problems.\n. > Thx! NSDateInterval was added from the Swift.org Foundation library with the intention to merge it once published. I.e. our version should be removed and the Swift 3.0 version used.\n\nThe pull request is a nice workaround for the time being though.\n\nWhile I agree wit this (that this class ultimately be removed) I'd be nice to not wait until the finalization of Swift 3.0 to make this library compatible.\n. This change would also likely incur a major version bump as this was part of the public API of the framework.\n. @malcommac anything I should do in order to help this get merged?\n. > The feature/swift_23 branch did rename this class: 4acda8f\nAhh that's cool @cgoldsby, does this still need to be a pull request?\n. ",
    "fabiomassimo": "I agree with @brianmichel that for the time being this fix would help SwiftDate's users to easily integrate it with Swift 2.3 which I believe is going to be used for a while due to major changes that comes with Swift 3.0.\n. ",
    "nabilfreeman": "\ud83d\udc4d please release this for Swift 2.3+ - @brianmichel i'm using your forked repo in an app now, thanks for the changes! I would rather get back to using the official version though @Hout \ud83d\ude09 \n. ",
    "tcurdt": "The carthage build fails with Xcode8 GM\ngithub \"malcommac/SwiftDate\" \"feature/swift_3\"\n```\n Building scheme \"SwiftDate-iOS\" in SwiftDate.xcodeproj\n* CLEAN FAILED \nThe following build commands failed:\n    Check dependencies\n(1 failure)\n BUILD FAILED \nThe following build commands failed:\n    Check dependencies\n(1 failure)\nwarning: no umbrella header found for target 'SwiftDate-iOS', module map will not be generated\nwarning: no umbrella header found for target 'SwiftDate-iOS', module map will not be generated\nA shell task (/usr/bin/xcrun xcodebuild -project /path/to/project/Carthage/Checkouts/SwiftDate/XCode/SwiftDate.xcodeproj -scheme SwiftDate-iOS -configuration Release -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:\n CLEAN FAILED \nThe following build commands failed:\n    Check dependencies\n(1 failure)\n BUILD FAILED \nThe following build commands failed:\n    Check dependencies\n(1 failure)\n```\n. Trying the other branch\ngithub \"malcommac/SwiftDate\" \"feature/swift-3.0\"\ngives\n```\n$ carthage update --platform iOS\n Fetching SwiftDate\n Checking out SwiftDate at \"bbda53afa820dbf26af07a9794fd02a3730fd777\"\n xcodebuild output can be found in /var/folders/pf/7vhqx5bn41qddypw08w9jc4w0000gn/T/carthage-xcodebuild.NGeCSH.log\n Building scheme \"SwiftDate-iOS\" in SwiftDate.xcodeproj\n BUILD FAILED \nThe following build commands failed:\n  CompileSwift normal arm64\n  CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler\n(2 failures)\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:148:44: error: 'Style' is not a member type of 'DateFormatter'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:148:83: error: 'Style' is not a member type of 'DateFormatter'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:149:34: error: 'Style' is not a member type of 'DateFormatter'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:121:4: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:122:4: error: value of type 'DateFormatter' has no member 'timeZone'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:123:4: error: value of type 'DateFormatter' has no member 'calendar'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:126:5: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:128:5: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:130:16: error: value of type 'DateFormatter' has no member 'stringFromDate'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:185:32: error: type 'DateFormatter' has no member 'Style'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:186:32: error: type 'DateFormatter' has no member 'Style'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:204:32: error: 'Style' is not a member type of 'DateFormatter'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:205:32: error: type 'DateFormatter' has no member 'Style'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:222:32: error: type 'DateFormatter' has no member 'Style'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Formatter.swift:223:32: error: type 'DateFormatter' has no member 'Style'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Components.swift:58:21: error: value of type 'DateComponents' has no member 'valueForComponent'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Components.swift:174:4: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Components.swift:175:4: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Components.swift:176:16: error: value of type 'DateFormatter' has no member 'stringFromDate'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Components.swift:211:4: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Components.swift:212:16: error: value of type 'DateFormatter' has no member 'monthSymbols'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Components.swift:221:4: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Components.swift:222:16: error: value of type 'DateFormatter' has no member 'shortMonthSymbols'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/NSCalendar+SwiftDate.swift:81:64: error: 'cfValue' is inaccessible due to 'private' protection level\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/NSCalendar+SwiftDate.swift:73:25: error: 'withUnsafeMutablePointers' is unavailable: use nested withUnsafeMutablePointer(to::) instead\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:312:17: error: value of type 'DateFormatter' has no member 'timeZone'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:313:17: error: value of type 'DateFormatter' has no member 'calendar'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:314:17: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:319:45: error: value of type 'String' has no member 'rangeOfString'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:320:27: error: value of type 'String' has no member 'substringToIndex'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:325:6: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:326:19: error: value of type 'DateFormatter' has no member 'dateFromString'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:328:6: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:329:6: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:330:19: error: value of type 'DateFormatter' has no member 'dateFromString'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:332:6: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:333:6: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:334:19: error: value of type 'DateFormatter' has no member 'dateFromString'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:336:6: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:337:19: error: value of type 'DateFormatter' has no member 'dateFromString'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:339:6: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:340:19: error: value of type 'DateFormatter' has no member 'dateFromString'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:342:6: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:343:19: error: value of type 'DateFormatter' has no member 'dateFromString'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:345:6: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:346:19: error: value of type 'DateFormatter' has no member 'dateFromString'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:383:27: error: type 'DateFormatterComponentsStyle' has no member 'MediumStyle'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:384:27: error: type 'DateFormatterComponentsStyle' has no member 'LongStyle'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:385:3: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:386:3: error: value of type 'DateFormatter' has no member 'calendar'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:387:3: error: value of type 'DateFormatter' has no member 'timeZone'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:388:10: error: value of type 'DateFormatter' has no member 'stringFromDate'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:396:27: error: type 'DateFormatterComponentsStyle' has no member 'LongStyle'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:397:27: error: type 'DateFormatterComponentsStyle' has no member 'LongStyle'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:398:3: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:399:3: error: value of type 'DateFormatter' has no member 'calendar'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:400:3: error: value of type 'DateFormatter' has no member 'timeZone'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion.swift:401:21: error: value of type 'DateFormatter' has no member 'stringFromDate'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Operations.swift:44:19: error: 'components' produces 'DateComponents', not the expected contextual result type 'NSDateComponents'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Operations.swift:63:28: error: argument labels '(:)' do not match any available overloads\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Operations.swift:83:21: error: argument labels '(:)' do not match any available overloads\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Operations.swift:116:16: error: argument labels '(:)' do not match any available overloads\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/Additions.swift:231:17: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/Additions.swift:232:13: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/Additions.swift:233:15: error: value of type 'DateFormatter' has no member 'timeZone'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/Additions.swift:234:15: error: value of type 'DateFormatter' has no member 'doesRelativeDateFormatting'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/Additions.swift:238:4: error: value of type 'DateFormatter' has no member 'dateFormat'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/Additions.swift:239:4: error: value of type 'DateFormatter' has no member 'locale'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/Additions.swift:240:4: error: value of type 'DateFormatter' has no member 'timeZone'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/Additions.swift:241:4: error: value of type 'DateFormatter' has no member 'doesRelativeDateFormatting'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateInRegion+Comparisons.swift:50:25: error: 'compareDate(:toDate:toUnitGranularity:)' has been renamed to 'compare(:to:toUnitGranularity:)'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/NSDate+SwiftDate.swift:311:30: error: 'Style' is not a member type of 'DateFormatter'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/NSDate+SwiftDate.swift:311:69: error: 'Style' is not a member type of 'DateFormatter'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/NSDate+SwiftDate.swift:312:34: error: 'Style' is not a member type of 'DateFormatter'\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/NSDate+SwiftDate.swift:211:36: error: argument labels '(:)' do not match any available overloads\n/path/to/project/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/NSDate+SwiftDate.swift:383:16: error: argument labels '(:)' do not match any available overloads\nA shell task (/usr/bin/xcrun xcodebuild -project /path/to/project/Carthage/Checkouts/SwiftDate/XCode/SwiftDate.xcodeproj -scheme SwiftDate-iOS -configuration Release -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES clean build) failed with exit code 65:\n BUILD FAILED \nThe following build commands failed:\n  CompileSwift normal arm64\n  CompileSwiftSources normal arm64 com.apple.xcode.tools.swift.compiler\n(2 failures)\n```\n. I was also hoping for\nlet a = NSDate(..)\nlet b = NSDate(..)\nlet d: NSTimeInterval = a - b\nbut timeIntervalSinceDate seems still the way to go.\n. ",
    "phatmann": "I understand the behavior and I have looked at the code. My point is that this behavior is unexpected. A string with a timezone should result in a DateInRegion with that same timezone. We should add code to parse the timezone and use that timezone if no region is provided.\n. @malcommac Great to see the new ISO parsing, nice work. However, a DateInRegion created via a ISO8601 string still does not have a region that reflects the timezone from the string. In fact, the region is always forced to GMT. So this issue should be re-opened.\nFrom init?(string: String, format: DateFormat, fromRegion region: Region? = nil):\n...\nlet configuration = ISO8601Configuration(calendar: srcRegion.calendar)\nguard let date = try ISO8601Parser(string, config: configuration).parsedDate else {\n    return nil\n}\nself.absoluteDate = date\nif srcRegion != Region.GMT() { // region is ignored\n    print(\"Region is read from the string when ISO8601 parser is used\")\n}\nsrcRegion = Region.GMT()\n...\nNote that the timezone from the ISO8601Parser is not used to set the region.\n. Any chance this could get merged?\n. Actually, this was manually merged in, at least into Swift 3 branch.\n. ",
    "chrischenyc": "+1\n. ",
    "ilandbt": "Thanks\n. Figured it out.\n```Swift\n    let date = try? date.date(format: .custom(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"), fromRegion: Region.GMT())\n    let localDate = startDate?.toRegion(Region.Local())\n    let formatedDate = localDate?.string(custom: \"EEEE, MMM d, h:mm a\")\n\n```. ",
    "marchy": "Is this already merged to master / a Cocoapods release?\n. ",
    "fphcare": "Do you have a version which support swift 2.3? Thanks \n. ",
    "hackolein": "If I try this: \"2016-09-16T13:13:05+02:00\".date(format: DateFormat.custom(\"yyyy-MM-dd'T'HH:mm:ssZZZZZ\"), fromRegion: Region(tz: TimeZoneName.europeRome, cal: CalendarName.gregorian, loc: LocaleName.germanGermany))\nlet (colloquial,relevantTime) = try! (message?.callEnd)!.colloquialSinceNow()\nI got the error \"fatal error: unexpectedly found nil while unwrapping an Optional value\" in Line 226 in DateInRangeFormatter.\nBut the Date is valid and the absoluteTime is correct.\n. When I used this method i always get the following error: \"fatal error: 'try!' expression unexpectedly raised an error: SwiftDate.DateError.MissingRsrcBundle: file /Library/Caches/com.apple.xbs/Sources/swiftlang/swiftlang-800.0.46.2/src/swift/stdlib/public/core/ErrorType.swift, line 178\"\nI tried the example from here http://malcommac.github.io/SwiftDate/formatters.html#colloquial\nlet dateA = DateInRegion() - 1.months\nlet (colloquial,relevantTime) = try! dateA.colloquialSinceNow()\nThe device is an iPhone5 (iOS9) Simulator.\nI  used SwiftDate 4.0.1 and Swift3. Any idea what's the problem is?\n. @malcommac  I'm still getting the same error. I solved the problem, by adding a new translation for my language. Maybe it makes sense, to have a fallback, if the language not exists.\n. ",
    "RickPasveer": "@malcommac \nThere is a class naming duplication with DateFormatter.\nApple renamed NSDateFormatter to DateFormatter.\nBut SwiftDate also has a class named DateFormatter which doesn't have dateFormat, timeZone variables.\n. ",
    "RamwiseMatt": "Just leaving a note here to say I am experiencing the same problem.\n. ",
    "ClementDurandeau": "Same here with Xcode 8 GM\n. ",
    "plarson": "I made a simple rename pull request, not sure if it's appropriate or not. https://github.com/malcommac/SwiftDate/pull/240\n. ",
    "dhamukrish": "This worked as you advised. Thanks Plarson.\nhttps://github.com/malcommac/SwiftDate/pull/240/commits/4acda8f5b195f1991d4097ae73994e12a0d83572\nHowever, we will wait till the update in codebase and close this issue.\n. Thanks malcommac\n. Great @malcommac. Thanks\n. ",
    "scrainie": "I simply placed a prefix on the DateFormater.swift class for now...\npublic class SCDateFormatter {\n}\n. ",
    "wei": "I'm using fully qualified name SwiftDate.DateFormatter for now. \n. ",
    "balazsnemeth": "Or otherwise you can use this: Foundation.DateFormatter()\n. Any update on this? \n. ",
    "raven": "So I'm not super up to date with unsafeBitCast but I can have a rough guess as to what's gone down.\nPreviously the extension was on NSCalendar, which would require a class pointer, then recently there was the change to make the extension for Calendar instead, which is a struct, which has a different size. \nI was able to successfully carry on by changing the line to:\nreturn unsafeBitCast(self as NSCalendar, to: CFCalendar.self)\n. @abunur master is already Swift 3 / Xcode 8 compatible, so I guess you're asking for the maintainers to remove the branch feature/swift-3.0 to avoid confusion?\n. @Damnum this sounds like a different issue. Could you open a new issue with and supply the output of the following commands:\ncarthage version\nxcode-build -version\ncat Cartfile\nAnd the command you're using to build with Carthage ie carthage update? \nFYI I got both 4.0.4 and master building using carthage 0.18 and Xcode 8.0\n. So this is still occurring in 4.0.4\n. ",
    "oleynikd": "This seems to be deprecated? What's the correct way to do it in v5?. ",
    "tentrr-de": "as a work around, you can add the following in your Podfile to use legacy swift for SwiftDate\npost_install do |installer|\n    installer.pods_project.targets.each do |target|\n        target.build_configurations.each do |config|\n            if [ 'SwiftDate'].include?(target.name)\n                config.build_settings['SWIFT_VERSION'] = \"2.3\"\n            end\n        end\n    end\nend\n. ",
    "jondwillis": "Use the swift-3 branch.\npod 'SwiftDate', :git => 'https://github.com/malcommac/SwiftDate.git', :branch => 'feature/swift-3.0'\n. ",
    "monica18p": "Even if i specify pod 'SwiftDate'\nStill i get the same errors\n. Worked for me. \nThanks.\n. ",
    "rogpfreck": "This worked for me:\n1. remove SwiftDate from pod file\n2. pod install in terminal \n3. add pod 'SwiftDate', :git => 'https://github.com/malcommac/SwiftDate.git', :branch => 'feature/swift_23' to pod file\n4. pod install in terminal\n   good luck\nRoger\n. Same here too.. ",
    "pml2571": "It works on simulator. However, it crashes and gives same error when run on my device. \nAnother error I'm getting is on my simulator for the post that just has been created, I think it cannot correctly calculate colloquialSinceNow for the 'time now' but it works fine after relaunching since the time gets passed some seconds (prints 'just now' as it should, but when the time is same exactly same as colloquialSinceNow it crashes)\nconsole:\n\n. Thank you!\n. ",
    "Damnum": "I can't get the current master to work with Swift 3. I get the same error reported in https://github.com/malcommac/SwiftDate/issues/222#issuecomment-245939262\nOnly branch feature/swift-3.0 works for me with Carthage.\n. @raven sorry my bad, it works now.\nMy mistake was I declared the dependency in the Cartfile like this:\ngithub \"malcommac/SwiftDate\"\nBecause there is an old tag named \"v3.0.0\" in the repository, Carthage thought this was the newest tag and downloaded it.\ngithub \"malcommac/SwiftDate\" ~> 4.0.4\nworks. But it would be helpful to rename this tag to prevent this from happening.\n. ",
    "mn288": "Delete that class, or rename that class to SDDateInterval\n. This is commented on the class when using Swift2.3.\nThis API is from Swift Foundation and it was a duplicate with a class with the SwiftDate Library\n/// Alternative API from swift.org for avoiding AutoreleasingUnsafeMutablePointer usage in\n/// NSCalendar and NSFormatter\n/// - Experiment: This is a draft API currently under consideration for official import into\n///   Foundation as a suitable alternative to the AutoreleasingUnsafeMutablePointer usage case of\n///   returning a NSDate + NSTimeInterval or using a pair of dates representing a range\n/// - Note: Since this API is under consideration it may be either removed or revised in the near\n///   future\n///\n. ",
    "meandkareem": "I have same issue on same line.\nfatal error: unexpectedly found nil while unwrapping an Optional value\n. ",
    "zackz-woolloo": "same issue here, the cmp.weekOfYear is nil\n. ",
    "XBeg9": "+1 this produces crash on my side.\n. ",
    "wsdwsd0829": "may be a fix\nhttps://github.com/wsdwsd0829/SwiftDate/commit/8e5e6b120004d9464a86cc9cf18ce7f97336b3da\nActually fixed on 4.0.4\n. fixed in 4.0.4\n. ",
    "suprie": "Sound good!\n. ",
    "codingrhythm": "@raven I don't think the fix was merged to 4.0.4 when I was looking at the commit history of master branch. It's in 4.0.5 branch as I just confirmed\n. There was a mistake made which reverted the previous commit. So I made this new pull request\n. ",
    "nezhyborets": "I'm sorry, seems that brew update helped. I didn't know it could help\n. ",
    "adrimarti": "I am using a third part library to represent my data on charts and I must provide the dates on the UNIXTimestamp format. \nThen, when I try to represent a date, it is shown as 2 hour before date because it is not taking the time with my current Locale.\n. ",
    "muukii": "\ud83d\udc40\n. I would like to get formats following.\n\nnow\n30s ago\n1m ago\n1years ago\n\nCan I get it?\nI think that would need some localization bundles.. I have the same issue.. ",
    "sigursalt": "Same here - just upgraded to 4.0 and my region default is GMT.  Had to manually set in AppDelegate for the time being.\n. ",
    "afladmark": "However, in your documentation under Default Region you state: \n\nAs you may notice, when you work with plain Date object you are effectively working with a DateInRegion defined in a Date.defaultRegion; initially this a Region which has:\n.timeZone set as GMT (Greenwich Mean Time)\n.locale set as the default device's locale\n.calendar set as the default device's calendar\n\nSo, as long as I've used this library (which admittedly is only since about 4.0.0), the default timezone behaviour has been GMT. In my case this \"fix\" represents a breaking change to my application... buried in a x.x.y pod update which thankfully I spotted.\nI've always had to create DateInRegion objects to work with local times and I've used the default implementation for GMT on the basis of the above documentation. So now all my code is backwards!\nI'm not actually debating whether you should make this change or which behaviour makes more sense -- that's entirely your call. I realise I can set the value back to GMT at app startup and that's what I'll do, but this change may have serious implications for some users as it would have for me. I simply don't believe the consequences or timing of this change was as well considered as it should have been, but please correct me if I've misunderstood something...\n. ",
    "andreyrd": "Prior to version 4.0.0, the default timezone behavior was local, not GMT.\n. I don't think the issue is in supporting negative intervals anymore.\nThe - operator is also implemented backwards. I guess it was working fine before because DateTimeInterval.duration was also backwards before #468.\npublic func - (lhs: Date, rhs: Date) -> TimeInterval {\n    return DateTimeInterval(start: lhs, end: rhs).duration\n}\nThe current implementation is saying that in a - b, a is the start and b is the end time, which is incorrect.. ",
    "hariseldon78": "ah, now i found the \"startOf\" function, so i guess i can just create a DateInRegion from Date() and ask for startOf(.day). That's elegant!\n. ",
    "buribae": "I saw that this issue was resolved with version (4.0.5). Thank you.\nlet daysInWeek = fDate.region.calendar.range(of: .day, in: .weekOfMonth, for: fDate.absoluteDate)!.count\n        if cmp.day! >= daysInWeek {\n            let colloquial_time = try self.colloquial_time(forUnit: .day, withValue: cmp.day!, date: fDate)\n            let weeksNo = (abs(cmp.day!) / daysInWeek)\n            let colloquial_date = try self.localized(unit: .weekOfYear, withValue: weeksNo, asFuture: isFuture, args: weeksNo)\n            return (colloquial_date,colloquial_time)\n        }\n. ",
    "fever324": "I believe this will crash because in here we specifies the lhs is the start of the interval instead of the end of the interval.\nPlease try run the code above and let me know! \n. Hi @malcommac I tested your code and it works fine.\nBut I don't understand why using Date instead of SwiftDate.DateInRegion in the following code crashes\nlet today = Date()\nlet tomorrow = Date() + 1.days\nprint(tomorrow - today) // This crashes here\n. The problem is that I have to use Date(). \nThe crash message is \nfatal error: Reverse intervals are not allowed: file /Users/hongfeili/Documents/GitHub/Just Did It/Carthage/Checkouts/SwiftDate/Sources/SwiftDate/DateTimeInterval.swift, line 69\nI still think the Date+Math order should be reversed or consider absolute like how it is done in DateInRegion+Math\nIs the order of minus between Dates intended?\n. Oh! I didn't know it was in the 4.0.7 branch, sorry about this. :)\n. ",
    "rynecheow": "Sure.\nOn Thu, Oct 20, 2016 at 8:05 PM, Daniele Margutti notifications@github.com\nwrote:\n\nI've a problem with readme merging into 4.0.7 branch.\nCan you repost this PR directly in feature/4.0.7 branch? thx\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/malcommac/SwiftDate/pull/309#issuecomment-255087080,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADCPcVKn-5hufL2THJDLi0NsptYvxvMZks5q11jrgaJpZM4KbJjb\n.\n. Alright.\n. \n",
    "artemkalinovsky": "I guess a pre-defined time to apply should be optional, but with default value\n. At the moment I've implemented it in this way:\n``` swift\nextension Date {\n    static func datesBetween(startDate:Date, endDate: Date, addingDateComponents: DateComponents) -> [Date] {\n        let calendar = NSCalendar.current\n    let normalizedStartDate = calendar.startOfDay(for: startDate)\n    let normalizedEndDate = calendar.startOfDay(for: endDate)\n\n    var dates = [normalizedStartDate]\n    var currentDate = normalizedStartDate\n\n    repeat {\n        currentDate = calendar.date(byAdding: addingDateComponents, to: currentDate)!\n        dates.append(currentDate)\n\n    } while !calendar.isDate(currentDate, inSameDayAs: normalizedEndDate)\n\n    return dates\n}\n\n}\n```\nAnd using it:\nswift\n  months = Date.datesBetween(startDate: startDate,\n                                       endDate: endDate,\n                                       addingDateComponents: 1.months)\n. Awesome!\ud83d\udc4d\ud83d\udc4f. ",
    "jsslai": "See https://github.com/malcommac/SwiftDate/pull/316\n. ",
    "rbukovansky": "Interesting... Following returns nil for all 4 on Linux. Any idea, why?\nswift\nprint(\"Locale.current.languageCode = \\(String(describing: Locale.current.languageCode))\")\nprint(\"Locale.current.collatorIdentifier = \\(String(describing: Locale.current.collatorIdentifier))\")\nprint(\"NSLocale.current.languageCode = \\(String(describing: NSLocale.current.languageCode))\")\nprint(\"NSLocale.current.collatorIdentifier = \\(String(describing: NSLocale.current.collatorIdentifier))\")\n. BTW I believe those folders with translations should be named after collatorIdentifier, like fr-FR.lproj.\nThere is i.e. portugal in Portugal (pt-PT) and portugal in Brasil (pt-BR) which can be different in some words. Chinese are having 2 languages as well, Chinese Traditional and Chinese Simplified (and maybe more).\nHeck, there is even en-GB and en-US (i.e. colour vs. color etc.)...\n. BTW Issue was reported to Swift bugtracking about those nil values: https://bugs.swift.org/browse/SR-3202\n. @archerLj The easiest way: NSDate() or Date() should be per API reference enough to get current date and time (you get: 2016-11-09 08:56:34, but not as string, but (NS)Date).\nLittle bit harder way just to get just current date:\n``` swift\nimport Foundation\nlet dateComponents = Calendar.current.dateComponents([.day, .month, .year], from: Date())\nlet today: Date? = Calendar.current.date(from: dateComponents)\n```\n. @akifumi Are you sure it works? My Xcode says no...\nswift\nPlayground execution failed: error: Test.playground:1:13: error: value of type 'Date' has no member 'startOfDay'\nlet today = Date().startOfDay\n. I see. Sorry! My bad!\n. @malcommac Hi, could you please review and merge if it's OK? Thanks.\n. @malcommac I see... I will try it on my end and report what it is returning for my setup.\nBut could you please answer my question in code-review comment? Thanks.\n. @malcommac OK. Sounds good to me.\nBTW How about that %ld and %d difference, if there is any? Thanks.\n. I see. OK. Thanks.\n. @malcommac They are not (yet). That's one way how to do that, but I don't like it (GoLang is able to have binary with all resources on Linux), so I hope that Swift will be able to do that too.\nI was thinking more about generating .swift file with dictionaries with translations and some function that will replace NSLocalizedString.. Just out of curiosity, why there is %ld, when few lines up is %d? Thanks.\n. ",
    "tdimeco": "Agree, see #317 :)\n. ",
    "janweinkauff": "Missing proposed translations in release 4.0.8. . ",
    "KisukPark": "Thanks!\n. ",
    "akifumi": "@archerLj \nI think the best way to use Date().startOfDay.\n. @rbukovansky \nstartOfDay is defined here.\nhttps://github.com/malcommac/SwiftDate/blob/master/Sources/SwiftDate/Date%2BComponents.swift#L242-L244\n. ",
    "madsb": "I have a few additions to relevant time that isn't there in 4.0.8 :). I created a new pull request: #350 . \nI still get this with 4.4.1. Yeah, sorry - my mistake!. ",
    "OliverZiegler": "Unfortunately this won't solve my problem.\nI need to parse a given date to the right ISO8601 String which won't happen if your device is on 12 hour mode.\nIf I create a Date with Date() or DateInRegion() and current time for example 10:00 PM or 22:00 the resulting ISO8601 string after formatting will be: 2016-11-30T10:00:00Z which is not the correct ISO8601 string.\nUsing following code will give me the right ISO8601 String for my date:\nlet region = Region(tz: TimeZoneName.gmt, cal: CalendarName.current, loc: LocaleName.englishUnitedStatesComputer)\nlet gmtDate = DateInRegion(absoluteDate:Date(), in: region)\nlet gmtTimeDate = try! gmtDate.atTime(hour: newValue.hour, minute: newValue.minute, second: newValue.second)\nlet string = gmtTimeDate.string(format: .iso8601(options: [.withInternetDateTime]))\nprint(string)\n\nSo prints out 2016-11-30T22:00:00Z\nBut trying to parse this string back to a Date or DateInRegion this won't work, so try \"2016-11-30T22:00:00Z\".date(format: .iso8601(options: [.withInternetDateTime])) will raise an exception.\nAs ISO8601 is strictly defined I think this is very unexpected behaviour and should be fixed.\nEdit:\nFYI:\nUsing\nlet region: Region = Region(tz: TimeZoneName.gmt, cal: CalendarName.current, loc: LocaleName.englishUnitedStatesComputer)\nlet date = try \"2016-11-30T22:00:00Z\".date(format: .iso8601(options: [.withInternetDateTime]), fromRegion: region)\n\nwill work and result in the right Date.\nSo for parsing ISO8601 strings there should always be used the \"en_US_POSIX\" Locale I think (and this should be done internally).\n. ",
    "Casperhr": "Dump here! Could be awesome to see this lib work on Linux. ",
    "crarau": "Any news on this. I read this on the main webpage and started implementing it, just to notice that it doesn't work\nIt works on iOS, macOS, watchOS, tvOS and virtually on any Swift compatible platform (yeah Linux too!).. ",
    "solbadguyky": "SwiftDate.strings.zip\nHere my translated SwiftDate.strings file. Thank for your help :). ",
    "JGCR": "Hi, thanks for going to the trouble of following-up on this. The DateFormatter problem can also be solved by using f.isLenient = false. I\u2019m using DatePicker these days for date inputs, BUT I\u2019m using SwiftDate for many other requirements. It\u2019s great.\nThanks again, John Reid.. ",
    "adrianodiasx93": "@malcommac Shouldn't isLenient be set to false to achieve the behaviour mentioned by @JGCR ?\nhttps://github.com/malcommac/SwiftDate/blob/9608361b6a7ee726b12a9d40a29a4614faec12fb/Sources/SwiftDate/Formatters/Formatter%2BProtocols.swift#L120. I have opened a PR. #629. \"pt-BR\". ",
    "timefrancesco": "I realized I might have called colloquial with inverted date, but when calling it this way:  \nlet futureStringTwo = try future.colloquial(to: Date(), max: 1 ).colloquial \nit also returns just now.\nI can't find a way to write future dates if the interval is less than 1 hour.\n. Hey so actually, the issue is with Date, DateInRegion works fine (so I'm using that now).\nHere is how to replicate the issue, you can copy and paste this code:\n```\nlet today =  Date()    \nlet firstDay = today.startWeek\nlet lastDay = today.endWeek\nvar date = firstDay\nwhile !date.isInSameDayOf(date: lastDay) {\n   print(String(describing: date) + \" not same day of \" + String(describing: lastDay))\nlet newDate = date + 1.day\n    date = newDate\n }\nprint (String(describing: date)  + \" same day of \" + String(describing: lastDay))\n```\nIt will output:\n2017-09-02 12:00:00 +0000 not same day of 2017-09-09 11:59:59 +0000\n2017-09-03 12:00:00 +0000 not same day of 2017-09-09 11:59:59 +0000\n2017-09-04 12:00:00 +0000 not same day of 2017-09-09 11:59:59 +0000\n2017-09-05 12:00:00 +0000 not same day of 2017-09-09 11:59:59 +0000\n2017-09-06 12:00:00 +0000 not same day of 2017-09-09 11:59:59 +0000\n2017-09-07 12:00:00 +0000 not same day of 2017-09-09 11:59:59 +0000\n2017-09-08 12:00:00 +0000 same day of 2017-09-09 11:59:59 +0000\nWhile if replacing Date with DateInRegion:\n```\nlet today =  Date()\nlet firstDay = today.startWeek\nlet firstDateInRegion = DateInRegion(absoluteDate: firstDay)\nlet lastDay = today.endWeek\nlet lastDateInRegion = DateInRegion(absoluteDate: lastDay)\nvar date = firstDateInRegion\nwhile !date.isInSameDayOf(date: lastDateInRegion) {\n   print(String(describing: date) + \" not same day of \" + String(describing: lastDay))\nlet newDate = date + 1.day\n   date = newDate          \n}\nprint (String(describing: date)  + \" same day of \" + String(describing: lastDay))\n```\nit will output:\nSep 3, 2017, 12:00:00 AM GMT+12 not same day of 2017-09-09 11:59:59 +0000\nSep 4, 2017, 12:00:00 AM GMT+12 not same day of 2017-09-09 11:59:59 +0000\nSep 5, 2017, 12:00:00 AM GMT+12 not same day of 2017-09-09 11:59:59 +0000\nSep 6, 2017, 12:00:00 AM GMT+12 not same day of 2017-09-09 11:59:59 +0000\nSep 7, 2017, 12:00:00 AM GMT+12 not same day of 2017-09-09 11:59:59 +0000\nSep 8, 2017, 12:00:00 AM GMT+12 not same day of 2017-09-09 11:59:59 +0000\nSep 9, 2017, 12:00:00 AM GMT+12 same day of 2017-09-09 11:59:59 +0000 \nSo DateInRegion seems to work fine while Date seems strange to me.\nI've dug a little bit and it seems the issue is the Swift Calendar comparison, not sure if it's an issue but I suspect I am not smart enough to understand Timezones properly \ud83e\udd37\u200d\u2642\ufe0f!. \ud83d\udc4d . ",
    "darrarski": "\ud83d\udc4d . Looks like problem is solved in 4.0.10. Thanks!. ",
    "adrianocola": "Same thing here:\nswift \nprint(Date.defaultRegion.locale) // pt_BR\nprint(try! (Date() - 3.day).colloquialSinceNow().colloquial) // 3 days ago\n. ",
    "AndreySouza1": "still with problems, pt_BR do not exist. ",
    "lowki93": "this bug appear when my iPhone is in 12h, not in 24h . dateString : \"2017-03-13T14:00:17.000Z\". do you have an idea @malcommac  ?. Thanks, he works perfectly \ud83d\udc4d . I saw many log : Region is read from the string when ISO8601 parser is used\nCan you remove it ;). ",
    "cruisediary": "+1. ",
    "andriichernenko": "Something along these lines: \n``swift\n  /// Print a colloquial representation of the difference between two dates.\n  /// For example \"1 year ago\", \"just now\", \"3s\" etc.\n  ///\n  /// - parameter fDate: date a\n  /// - parameter tDate: date b\n  ///\n  /// - throws: throw.DifferentCalendarif dates are expressed in a different calendar,.MissingRsrcBundle` if\n  ///   required localized string are missing from the SwiftDate bundle\n  ///\n  /// - returns: a colloquial string representing the difference between two dates\n  public func colloquial(from fDate: DateInRegion, to tDate: DateInRegion) throws -> (colloquial: String, time: String?) {\n    guard fDate.region.calendar == tDate.region.calendar else {\n      throw DateError.DifferentCalendar\n    }\nlet cal = fDate.region.calendar\nlet cmp = cal.dateComponents(self.allowedComponents, from: fDate.absoluteDate, to: tDate.absoluteDate)\n\nlet allComponents: [(Calendar.Component, Int?)] = [\n  (.year, cmp.year), (.month, cmp.month), (.weekOfYear, cmp.weekOfYear), (.day, cmp.day),\n  (.hour, cmp.hour), (.minute, cmp.minute), (.second, cmp.second)\n]\n\nlet allowedComponents = allComponents\n  .flatMap({ (unit, value) in value != nil ? (unit, value!) : nil })\n  .filter({ (unit, _) in self.allowedComponents.contains(unit) })\n\nif let leastGranularAllowedNonZeroComponent = allowedComponents.first(where: { _, value in value != 0 }) {\n  let (unit, value) = (leastGranularAllowedNonZeroComponent.0, leastGranularAllowedNonZeroComponent.1)\n  let position: PositionInTime = fDate > tDate ? .future : .past\n\n  let colloquialDate = try self.localized(unit: unit, withValue: value, position: position, args: abs(value))\n  let colloquialTime = try self.colloquial_time(forUnit: unit, withValue: value, date: fDate)\n\n  return (colloquialDate, colloquialTime)\n} else if let leastGranularAllowedComponent = allowedComponents.first {\n  let unit = leastGranularAllowedComponent.0\n\n  let (position, value): (PositionInTime, Int)\n  if fDate.isIn(date: tDate, granularity: unit) {\n    (position, value) = (.now, 0)\n  } else {\n    (position, value) = fDate > tDate ? (.future, 1) : (.past, -1)\n  }\n\n  let colloquialDate = try self.localized(unit: unit, withValue: value, position: position, args: abs(value))\n  let colloquialTime = try self.colloquial_time(forUnit: unit, withValue: value, date: fDate)\n\n  return (colloquialDate, colloquialTime)\n} else {\n  throw DateError.FailedToCalculate\n}\n\n}\n/// Return the colloquial representation of a value for a particular calendar component\n  ///\n  /// - parameter unit:     unit of calendar component\n  /// - parameter value:    the value associated with the unit\n  /// - parameter asFuture: true if  value referred to a future, false if it's a past event\n  /// - parameter args:     variadic arguments to append\n  ///\n  /// - throws: throw .MissingRsrcBundle if required localized string are missing from the SwiftDate bundle\n  ///\n  /// - returns: localized colloquial string with passed unit of time\n  private func localized(unit: Calendar.Component, withValue value: Int, position: PositionInTime, args: CVarArg...) throws -> String {\n    guard let bundle = self.localizedResourceBundle() else {\n      throw DateError.MissingRsrcBundle\n    }\nlet identifier: String\nif unit == .second || (unit == .minute && abs(value) < 5 && self.useImminentInterval) {\n  identifier = \"colloquial_now\"\n} else {\n  let positionKey = position.localizationKey\n  let unitStr = self.localized(unit: unit, value: value, position: position)\n\n  identifier = \"colloquial_\\(positionKey)_\\(unitStr)\"\n}\n\nlet localized_date = withVaList(args) { (pointer: CVaListPointer) -> String in\n  let localized = NSLocalizedString(identifier, tableName: \"SwiftDate\", bundle: bundle, value: \"\", comment: \"\")\n  return NSString(format: localized, arguments: pointer) as String\n}\n\nreturn localized_date\n\n}\nenum PositionInTime: Int {\n  case past, now, future\nvar localizationKey: String {\n    switch self {\n    case .past:   return \"p\"\n    case .now:    return \"n\"\n    case .future: return \"f\"\n    }\n  }\n}\n```\nAnd, of course, localization files will have to be modified:\n\"colloquial_f_d\"    =   \"tomorrow\";        // day,future,singular:    \"tomorrow\"\n\"colloquial_f_dd\"   =   \"in %d days\";      // day,future,plural:      \"in 3 days\"\n\"colloquial_n_d\"    =   \"today\";           // day,now:                \"today\"\n\"colloquial_p_d\"    =   \"yesterday\";       // day,past,singular:      \"yesterday\"\n\"colloquial_p_dd\"   =   \"%d days ago\";     // day,past,plural:        \"3 days ago\"\nThis feature has a lot of edge cases, and I have probably broke some of them. It would be nice to look at the requirements, are they specified somewhere?. ",
    "cdnil": "It works. Thank you so much.. ",
    "danielCarlosCE": "It was actually .withInternetDateTime, the equivalent.\nDateFormat.iso8601(options: .withInternetDateTime)\nMy question remains.\nDoes it make sense to add, on the documentation of .withInternetDateTime, a mention of the old way?\n. ",
    "kevinrenskers": "Awesome! Thanks.. ",
    "szuniverse": "thank you. and after that I have another question the old date() function's return type was Date but now it is DateInRegion. If I use the absoluteDate property is it the same as before?. Thanks a lot! :) . ",
    "AYastrebov": "Great work! Waiting it to be merged. @malcommac any updates on this?. ",
    "TimeDelta": "@malcommac Thanks for the explanation. I ran into this same thing and also thought it was a bug.. ",
    "techno246": "I encountered this issue when running on iOS 9, but not when I ran it on the simulator which runs iOS 10. Can you please confirm which iOS version you are testing this on? \nI have had to use .absoluteDate.timeIntervalSince(....) to maintain compatibility with iOS 9 so far... . ",
    "Nonouf": "Continued to dig into the problem by using plain DateFormatter and realised it came from the Locale. My bad and sorry for false alert.. ",
    "eastsss": "409 .",
    "yosuke1985": "thanks. ",
    "sumowesley": "Same here.. ",
    "frederik-jacques": "Same here. ",
    "vrutberg": "Great!. I'm Swedish, I approve of this. \ud83d\udc4d . ",
    "Dandiccf": "thx - works great . ",
    "ankraft": "Great, thanks a lot!. ",
    "gupta515": "@malcommac \nHi, no there is no way to check on simulator. I tested this scenario on device.. ",
    "y4gamilight": "Dear, I think bug still occur at build 4.5.0 when I change the time zone of my device. Time get time with properties of SwiftDate, it still uses old TimeZone.\nI replace by use DateComponents with TimeZone autoUpdatingCurrent. ",
    "RolandasRazma": "it looks like only hour is returned on purpose, but definitely unexpected...\nswift\nif cmp.day != 0 || !hasLowerAllowedComponents(than: .day) {\n    if cmp.hour == nil {\n        ...\n    } else {\n        // less than 48 hours ago\n        ...\n        let colloquial_date = try self.localized(unit: .hour, withValue: cmp.hour!, asFuture: isFuture, args: abs(cmp.hour!))\n        return ...\n    }\n}. same as https://github.com/malcommac/SwiftDate/issues/419. same as https://github.com/malcommac/SwiftDate/issues/417. @malcommac \n```swift\nlet startTime = Date(timeIntervalSinceReferenceDate: 522324000.0) // 2017-07-21\nlet nowTime = Date(timeIntervalSinceReferenceDate: 522151647.46755201) // 2017-07-19\nlet (colloquial, _) = try! DateInRegion(absoluteDate: startTime).colloquial(toDate: DateInRegion(absoluteDate: nowTime))\nprint(colloquial) // tomorrow\n```\n(lldb) po startTime\n\u25bf 2017-07-21 10:00:00 +0000\n  - timeIntervalSinceReferenceDate : 522324000.0\n(lldb) po nowTime\n\u25bf 2017-07-19 10:07:27 +0000\n  - timeIntervalSinceReferenceDate : 522151647.46755201\n(lldb) po colloquial\n\"tomorrow\". ",
    "paulz": "We have an issue with colloquialSinceNow expressed in this spec:\nlet threeDaysAgo = DateInRegion() - 3.day\n                expect(try! threeDaysAgo.colloquialSinceNow().colloquial) == \"3 days ago\"\nresults in test failure:\nexpected to equal <3 days ago>, got <now>\nThis fails with 4.1.1 and used to work with 4.1.0. Thank you, works for us!\nSent from my iPhone\n\nOn May 8, 2017, at 2:41 PM, Daniele Margutti notifications@github.com wrote:\nClosed #417.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "alexanderkhitev": "@malcommac thank you so much! . I wonder if there is an error or not.. An example of an incorrect display. The time of the event is 1 hour 46 minutes and 16 seconds, and this function displays in an hour.\n\"colloquial\" \"in one hour\" \"nowDate\" 2017-10-10 10:13:44 +0000 \"eventDate\" 2017-10-10 12:00:00 +0000\n. Hi @malcommac! When do you plan to make merge in the master branch?. @malcommac I tried to use the colloquialSinceNow function and it does not work correctly. For example, the event after 2 hours 57 minutes and 30 seconds, and returns just now.\nprivate func colloquial(_ date: Date) -> String? {\n        var opts = ColloquialDateFormatter.Options()\n        opts.imminentRange = 1.minute\n        let colloquial = date.inRegion().colloquialSinceNow(options: opts)\n        debugPrint(\"now date\", Date(), \"date\", date, \"colloquial\", colloquial ?? \"\")\n        return colloquial\n    }\nResult \n\"now date\" 2017-11-27 12:02:30 +0000 \"date\" 2017-11-27 15:00:00 +0000 \"colloquial\" \"just now\"\n. @malcommac any news?. ",
    "wesbillman": "@TrachYuri I think it's still different from the rest of the file. Looks like you're using 2 spaces now rather than what the file is using.. This indenting looks pretty wrong.\n\n. ",
    "matuella": "The .absoluteDate is a representation of the DateInRegion that is outside the region. \nI.e: \nDate() prints 2017-11-23 12:33:41 +0000\nDate().inLocalRegion() prints 23 Nov 2017 10:33:41 GMT-2\nDate().inLocalRegion().absoluteDate prints 2017-11-23 12:33:41 +0000\nThe absoluteDate var says: \"Absolute date represented outside the region\"\nSo I guess the only way is to actually get the pieces of the date you want, and make it on your own, I just thought there would be an easier way to make this, like a toDate of the actual LocalInRegion date.\n. ",
    "jojo91": "Hi, I've tried your fix and it seems that the issue is still here.\nMy test :\nlet myDotNetDate = \"/Date(-2208992400000+0100)/\"\nif let date = myDotNetDate.date(format: .dotNET) {\n    let newDate = date.absoluteDate\n    print(myDotNetDate)\n    print(newDate.string(format: .dotNET))\n}\nThe result : \n/Date(-2208992400000+0100)/\n/Date(-2208992400000+0000)/. I still can have this issue, it's very simple to reproduce. \nPut this line in your Cartfile.\ngithub \"malcommac/SwiftDate\" == 4.1.2\nAnd then just do a carthage update.\nLike @RiverbayChris said when you use \"--platform iOS\" it works. So this issue probably come from an other platform.. ",
    "Nik20112": "Issue resolve by pod uninstall and install again.. ",
    "RichAppz": "Guys do you have an answer for this issue?. Sorry, I never got an email notification, I will relook into this and get back to your shortly, Thanks \ud83d\udc4d . Brilliant all fixed, sorry again for the long delay in answering! Note to self check notification settings. ",
    "etoledom": "I have the same issue where displaying colloquial time less than one hour old says always 'now', instead of i.e.: '45 minutes ago'.\n I saw the code on DateRegionFormatter.swift:185, func coloquial(from...\nIt seems like the line:\nif diff_in_hours < 24 && diff_days == 0 { ... }\nis always handling the colloquial formatting for any time less than one day old, so the string will be like 'now' -> 'one hour ago' -> '2 hours ago' ... etc.\nThe code that handles seconds and minutes differences seems to never be reached.\n\nI had similar problem trying to display the string 'yesterday' instead of '35 hours ago' for time between 48 and 24 hours old\nUpdate: Im using SwiftDate version 4.1.2. ",
    "dbaule": "Can confirm this issue. . ",
    "jeffersonsetiawan": "@malcommac can it merged to fix the issue?\n. ",
    "ladmini": "The same error for me, any update?. ",
    "RiverbayChris": "Same here.. Anyone successful in fixing this?  I tried removing the offending ARCH from the project file in 4.1.2, but then there were more Carthage errors.  The last version I can successfully build with Carthage is 4.0.14.. Good to go now, thanks.  I was running \"carthage update SwiftDate\".  Adding the \"--platform iOS\" fixed  it for master.. ",
    "bkostjens": "Also the same here.. ",
    "emmekappa": "+1. ",
    "hamsternik": "It's such a strange behaviour. I tested your case, but didn't get any problems with a year or another parts of date in string format. You can see this from the screen below.\n\n. ",
    "kidsid-Ixigo": "\n\n\n@hamsternik  Do you have same region settings?. ",
    "Dschee": "As I said, I\u2018m using Carthage which builds the targets as they are. If you habe a target per platform (which mostly is the case) then I will only will be including the iOS platform related framework. If you have one target that\u2018s universal, then maybe yes.\nBut to be honest, I don\u2018t know what you mean by \u201efat framework\u201c.. Ah, by platforms you mean hardware architectures. I see. Okay then with bitcode enabled this should not be a problem. Thanks for the answer!. ",
    "chriswill0w": "@malcommac I have the same issue. I built the framwork via \ncarthage update --platform iOS\nthe framework size is 25.1 MB which seems quite big compared to some other frameworks.\nlipo -info gives me armv7 arm64. \nlipo SwiftDate -thin armv7 -output SwiftDate-armv7.a  gives me an ouput file which is still 11.8 MB \nWhy does this framework seem to be so big? Is there something I can do to improve the size?. getting Ambiguous use of operator '-', too. ",
    "plivesey": "\ud83d\udc4d for this, thanks. I just ran into the same bug.\nIn my fix, I also added a unit test for this which is pretty trivial:\nin public func test_toColloquialString() {\nlet tenMinsAgo = DateInRegion() - 10.minutes\n        let (custom_7,_) = try! tenMinsAgo.colloquialSinceNow()\n        XCTAssertEqual(custom_7, \"10 minutes ago\", \"Failed get colloquial representation of an old date\")\nWould be great to get this merged :D . Thanks!. ",
    "toshi0383": "Thank you for quick fix!\ud83d\ude04. ",
    "victoraugustolls": "Of course:\n1995-06-21T00:00:00Z\nThanks!. My device is: GMT -3\nBut should my device TZ influence in the date even if I set the default region?. Any news here?. I just tried your code and using .iso8601Auto instead of .iso8601(options: [.withInternetDateTime] fixed the issue!!!. ",
    "filipealva": "Hi @malcommac,\nSorry about the late answer. \nI was looking for some alternative that returns Date instead of DateInRegion, but thank you for the answer. I managed to solve it using the native DateAPIs since it was simple.\nThank you! . ",
    "PlayApple": "I want to implement switching time periods. If nextMonth is wrong, I'll have to do it some other way.\n\n. ",
    "xisintag": "Sorry for that, after checking the Pull requests here: https://github.com/malcommac/SwiftDate/pull/443\nI was able to fix the problem. Thanks @ basvankuijck. ",
    "daviskoh": "thank you! \ud83e\udd47 . It seems to be that SwiftDate.strings files do not support abbreviation. Perhaps we can add a new localizedKeys for various DateComponentsFormatter.UnitsStyles though this would obviously increase the sizes of SwiftDate.strings files exponentially...\n. Aligns tests w/ https://github.com/malcommac/SwiftDate/issues/455. ",
    "Snapperfish": "Nevermind. I need import SwiftDate.. ",
    "plm75": "I don't know if this is related, but I'm also having trouble with colloquial dates.\nFor dates that are between now and an hour ago, the colloquial string used to be \"xx minutes ago\".  Now, I'm only getting \"one hour ago\" for all values.. \n\n@malcommac \nSorry for the delay.  I've put together a test app that shows incorrect colloquial strings displayed.\nSwift Date Test.zip\n. @malcommac \nHello, just to let you know that after a pod update, the version fetched is 4.1.7 and it looks like it solves the issue.\nFor reference, the version in the bug demo app is 4.1.2\nCheers!\nps: As far as I'm concerned this issue can be closed now.. ",
    "prakashraman": "Great! Thanks!. ",
    "sumesh1993": "answered on stackoverflow. ",
    "jarosan": "I'm currently setting up fastlane for my project and noticed that SwiftDate takes approx. 5-7 minutes to build. This seems way too long. Could you please point into direction where to investigate?. I thought I'd share a bit more info. Here is the log from fastlane:\n[11:19:19]: \u25b8 Building Pods/SwiftDate [Release]\n[11:19:19]: \u25b8 Check Dependencies\n[11:19:19]: \u25b8 Processing Info.plist\n[11:24:09]: \u25b8 Compiling SwiftDate-dummy.m\n[11:24:09]: \u25b8 Compiling SwiftDate_vers.c\n[11:24:13]: \u25b8 Compiling SwiftDate-dummy.m\n[11:24:14]: \u25b8 Compiling SwiftDate_vers.c\n[11:24:19]: \u25b8 Linking SwiftDate\n[11:24:20]: \u25b8 Linking SwiftDate\n[11:24:39]: \u25b8 Generating 'SwiftDate.framework.dSYM'\n[11:24:49]: \u25b8 Copying SwiftDate/Sources/SwiftDate/SwiftDate.bundle\n[11:25:01]: \u25b8 Copying SwiftDate-umbrella.h\n[11:25:16]: \u25b8 Touching SwiftDate.framework\nI'm using 4.3.0 version.. I still experience the same issue with buddhist calendar. \n```\nlet region = Region(calendar: Calendars.gregorian.toCalendar(),\n         zone: Zones.gmt.toTimezone(),\n         locale: Locales.englishUnitedStatesComputer.toLocale())\nlet date = \"2018-11-08T13:00:00.000+01:00\".toISODate(region: region)\n```\nAnd then when i try to output it in ISO:\nprint(date.toISO()) will produce \"1475-11-08T13:00:00+01:00\"\nUsing 5.1.0 version.. ",
    "hackugyo": "I've checked #480 and now think we can allow DateTimeInterval with negative values!\nThe most reason I made PR #468 is from the inconsistency of DateTimeInterval#end. Your 00f9403c199ddede99a29f889931ddff76e543b1 solves this inconsistency.\n@malcommac . ",
    "leviathan": "```\nlet startDate = \"10:00\"\nlet endDate = \"12:00\"\nlet dateDiff = startDate - endDate\n\n\nraises Exception now in DateTimeInterval #67\nprecondition(end >= start, \"Reverse intervals are not allowed\")\n```\n\n\nwhy should it not be allowed to have a negative time interval ?!. ",
    "Elshad": "Hi @malcommac,\nThere is not az.lproj file in bundle :(. ",
    "kerimovscreations": "@malcommac when will be this version released?. ",
    "umoruj": "Thanks. ",
    "roor": "yes you absolutely right,\nall that bigger then 1 and less then 5 is different from all that bigger then 5\nbut there is even more problems with \n21, 31, 41 etc, they should have same ending as singular\nso it is total mess, thats why i've used short version like \"\u043c\u0435\u0441.\". ",
    "Kuniwak": "I found the tag! Thank you!\nconsole\n$ git pull\nremote: Counting objects: 24, done.\nremote: Compressing objects: 100% (10/10), done.\nremote: Total 24 (delta 14), reused 21 (delta 12), pack-reused 1\nUnpacking objects: 100% (24/24), done.\nFrom github.com:malcommac/SwiftDate\n   d5a8caa..c8d7851  master     -> origin/master\n * [new tag]         4.1.11     -> 4.1.11\n * [new tag]         4.1.7      -> 4.1.7. ",
    "break2k": "We are facing the same crash with this.. ",
    "RamblinWreck77": "I'm not sure why all of the other commits are visible, but unless I messed up somewhere Xcode 9 GM set to Swift 4 would not compile with 4.4.0, saying that range(at:) had been renamed to rangeAt() \nSo I changed it and submitted a PR. Sure! I'm using \nSwiftDate.defaultRegion = Region.local\nIn my app delegate if that's important. \nLocal.current = \"en_US\". en_US\nFull region: Locale: {calendar='gregorian', timezone='America/New_York', locale='en_US'}. Wooo! Thanks for fixing this! Closing :). ",
    "sakshiGoel26": "I have updated my pods to 4.4.1, but still getting the same error.. @malcommac  I removed the SwiftDate pod from my project, & then added it again. Still facing issue in \"DOTNETDateTImeFormatter\" class. Attaching the screenshot\n\n. ",
    "jimsmithm3": "@malcommac I am started seeing this yesterday as well.  Here is a sample project (does nothing but get the compile error).   https://github.com/jimsmithm3/swiftdatetest2\nUsing Xcode Version 8.3.3. ",
    "prasadgau": "Even i am getting same error. Is there any solution for it?. ",
    "jeanmartin": "Ah, looks like we all didn't RTFM: #485 :D. ",
    "AlexGZC": "i have the same issue, can you help me? Please?. ",
    "Gigglesza": "When I try force the pod file to use 4.3.0, I get the following error:\n\"Unable to find a specification for SwiftDate~> 4.3.0\". ",
    "oskarko": "You haven't written correctly. pod 'SwiftDate', '~> 4.3.0'. ",
    "kezcol": "@malcommac why you revert polish language? somothing was wrong?. ",
    "weien": "I'm also curious why polish was reverted.. ",
    "llKoull": "Same here :S. Hi malcommac!\nYes it's a swift 3 project.. Ooooh thanks for your answer Malcolmmac! ^_^. ",
    "mittenimraum": "+1 broken since 4.1.10. ",
    "electic": "That was it. Thank you! . Thanks for the response. I did do that. I have translated the app in Japanese and Chinese already. However, the date (time ago) still appears in english.. Look at this https://github.com/malcommac/SwiftDate/issues/486. Please close this if it fixes your issue.. ",
    "readefries": "@malcommac it would be really nice, if you could do something with this PR....\nThanks!. The PR-487 to fix this, is added to the 4.4.2 release. Hopefully @malcommac will release it soon to Cocoapods.. Hey @malcommac the merging around, reverted this change and now it's still broken :/. ",
    "CocoaPriest": "+1. When using Carthage [building static frameworks], the linker fails. Unchecking Gather Coverage Data in SwiftDate fixes this issue.. ",
    "babuiglesiaskhan": "Hi,\nWhenever I upload my build. It shows \"Processing\" but after 10 mins, I got an message of build \"The build is invalid\" and when i check my mail. I got this message .\nDear Developer,\nWe identified one or more issues with a recent delivery for your app, \"Domino's Pizza Indonesia\". Please correct the following issues, then upload again.\nInvalid Bundle - Disallowed LLVM instrumentation. Do not submit apps with LLVM profiling instrumentation or coverage collection enabled. Turn off LLVM profiling or code coverage, rebuild your app and resubmit the app.\nBest regards,\nThe App Store Team\nHow could i resolve this issue ?. ",
    "atom2ueki": "@electic yep, it works. ",
    "wfilleman": "I'll add too, that the max and separator params in colloquialSinceNow are ignored.. ",
    "jedmund": "I was using this library and ran into this, which forced me to switch away (especially since it never got fixed). Still haven't found a time ago/since now method I like so I might have to write something myself.. ",
    "nguyentrai2011": "@malcommac i'm using version 4.4.1 and have the same issue. ",
    "iKiKi": "I've just seen PR 495. Maybe its a duplicate. Sorry.. ",
    "dcordero": "Closed as duplicate: https://github.com/malcommac/SwiftDate/pull/494. ",
    "ernestofndz": "Hi @malcommac, I just created a sample project: https://github.com/ernestofndz/SDDateDiff.\nThe code in the AppDelegate makes no difference, but just keeping it as I have in the other project. If I get some time this weekend will try to take a look myself. Thanks!. ",
    "grzegorzkrukowski": "Sure you can merge it.\nThe first points was solved, by using kind of written \"or\" statement.\nIt's used in many official papers all around in our language, that it says:\n\"X miesi\u0105ce/-y\", which can become \"2 miesi\u0105ce temu\" or \"5 miesi\u0119cy temu\", so \"e/-y\" means \"e or y\". \nAs I said it's fully legit to go this way as it is how they usually do that in government forms etc...\nIf we get support of stringsdict I can improve there.. ",
    "loryhuz": "After some research I saw it was working with other components like days, hours. Seems legit ! Well done, thanks.. ",
    "hemangshah": "@malcommac Can we have something like this?\nhttps://github.com/melvitax/DateHelper#comparing-dates. We should have simple functions like if it's in the current month, previous month or in next month?. ",
    "archerLj": "Is this a bug???\nThe same problem was asked at #493, and someone said it was fixed at version 4.4.2, but i still got this error.\nSomeone please help me.. ",
    "astrochili": "It seems like a minor syntax bug and reproduces on swift 4 only.\nI use fork with a fix for now (https://github.com/jonicong/SwiftDate), it works fine.. ",
    "bryanbartow": "6+ months and this still hasn't been fixed, @malcommac?. ",
    "ndizazzo": "In your case, to avoid seeing this message, you can write (dateToday - birthDate).in(.day, fromDate: dateToday).\nLooking at TimeInterval+Extensions.swift, it seems that a debugPrint warns you when passing Calendar.Components, while leaving the fromDate parameter empty.\nPersonally, I think this is awkwardly written. Most of the time, somebody will be computing a TimeInterval (as you are) and asking for the delta in a certain unit of time. Why would we need / want to pass a reference date back into the .in() method, when the delta is already computed? Strange.. ",
    "arakweker": "That works, the warning stopped. Thanks for helping out, ndizazzo.. ",
    "phoney": "Did you import the framework in your source file?\nimport SwiftDate. Why do this? Swiflint enforces a coding style and additionally has rules about poor coding practices. Swiftlint is widely used. Why change?. Apparently any deviation from the required ISO format is likely to cause this crash. I had a string in a unit test that was missing the trailing Z and that crashed. Obviously something has changed. These dates were accepted previously. If the intent is for them to not be accepted ISOParser should still not crash. It's supposed to return nil.\nMy workaround for my short dates \"2018-08-01\" has been to use a DateParser with the matching format. . Does this just require a .swift-version file? Or is it something in the podspec that specifies the swift version to CocoaPods when it's building the Pods project?. ",
    "without2002": "The operator of + have been defined in Date of iOS SDK. So it redefine.. I think it can not do like your wish. The description of colloquialSinceNow is \"This method produces a colloquial representation of time elapsed between self and the current date\". And I checked source code. The method will give current date when the different days out ofdistant range.. ",
    "makesource": "I think it's behaviour changed in Swift 4.2 / Xcode 10.0 (or may not worked in other version).\nlet a = Date()\nlet b = Date().timeIntervalSince1970\nlet c = a - b // this line invoke error (Ambiguous use of operator '-'). ",
    "jsouhail": "i am having the same issue, did you find a way to work it out?. ohhh... ok great... it worked... thanks a lot. ",
    "1er4y": "@jsouhail Yes, i founded workaround:\nif let date = DateInRegion(string: \"2018-03-09 18:00:00\", format: .custom(\"yyyy-MM-dd HH:mm:ss\")) { ///24H format\n                          ///do your logic \n                        } else if let date = DateInRegion(string: \"2018-03-09 18:00:00\", format: .custom(\"yyyy-MM-dd **hh**:mm:ss\")) { ///AM/PM format\n                               ///do your logic\n                       }\n }\nDifferent between this two if's is that, in first if we parsing 24H format: \"yyyy-MM-dd **HH:**mm:ss\" and if this failed, we just try parse AM/PM format \"yyyy-MM-dd **hh**:mm:ss\". . ",
    "BilalReffas": "Great I wanted to build this, but I realised there is already a pull request. Thank you ! \ud83d\udc4d\nI think it's great because, if someone want to serialise it and save to user defaults it will work now.. ",
    "aleufms": "I'm getting the same issue. Dates older than a week, go back to today.... It prints today:\nswift\n  var options = ColloquialDateFormatter.Options()\n  options.distantRange = 8.days\n  print(\"Test: \\(12.days.ago()?.colloquialSinceNow(options: options))\")\n. I have managed to fix this replacing tDate to fDate on calls for distant function on ColloquialDateFormatter. I don't know if this break anything else...\n```swift\n        // Months difference\n        if let months = value(for: .month, in: cmps) {\n            if isDistant { return distant(for: .month, in: fDate) }\n            return colloquialString(for: .month, value: months, future: isFuture, args: abs(months))\n        }\n    // Days difference\n    if let days = value(for: .day, in: cmps) {\n        if isDistant { return distant(for: .day, in: fDate) }\n        let isWeekAllowed = options.allowedComponents.contains(.weekOfYear)\n        if days < ColloquialDateFormatter.DAYS_IN_WEEK || !isWeekAllowed { // Less than a week or week representation is not accepted\n            return colloquialString(for: .day, value: days, future: isFuture, args: abs(days))\n        } else { // More than a week\n            if isWeekAllowed == true { // Weeks representation is allowed\n                let weeks = Int(floor(Double(days) / Double(ColloquialDateFormatter.DAYS_IN_WEEK)))\n                return colloquialString(for: .weekOfYear, value: weeks, future: isFuture, args: abs(weeks))\n            }\n        }\n    }\n\n    // Hours difference\n    if let hours = value(for: .hour, in: cmps) {\n        if isDistant { return distant(for: .hour, in: fDate) }\n        let isDifferentDay = (cal.isDate(fDate.absoluteDate, inSameDayAs: tDate.absoluteDate) == false)\n        if isDifferentDay == true { // cross day comparison, return yesterday or tomorrow\n            return options.locale.localizedString(identifier: (isFuture ? \"colloquial_f_d\" : \"colloquial_p_d\"), arguments: [])\n        } else {\n            if isImminentValue(for: .hour, value: hours) { // is imminent\n                return imminentString()\n            }\n            // standard hours difference\n            return colloquialString(for: .hour, value: hours, future: isFuture, args: abs(hours))\n        }\n    }\n\n```\nhttps://github.com/aleufms/SwiftDate/commit/e58796bda2040999036cee652a33870211950f37. ",
    "majid701": "Got the same problem here. Any one who knows how to fix or any workarounds?. ",
    "richardtop": "Due to changes in iOS 12 the bundle couldn't be loaded at the constructed path. The loading process has to be fixed.. ",
    "jweihs": "Not beautiful neither working for non-cocoapods integrations, but it's working for me to continue developing.\nChange Line 103 in file Localization.swift\nprivate class func resourceBundle() -> Bundle? {\n     let framework = Bundle(for: DateInRegion.self)\n     [...]\n}\nto\nprivate class func resourceBundle() -> Bundle? {\n    var framework: Bundle!\n    if #available(iOS 12.0, *) {\n        framework = Bundle(identifier: \"org.cocoapods.SwiftDate\")\n    }\n    else {\n        framework = Bundle(for: DateInRegion.self)\n    }\n    [...]\n}. ",
    "inket": "You can simply replace\nswift\nlet framework = Bundle(for: DateInRegion.self)\nwith \nswift\nlet framework =\n    Bundle(identifier: \"org.cocoapods.SwiftDate\") ??\n    Bundle(identifier: \"com.SwiftDate.SwiftDate-iOS\") ??\n    Bundle(identifier: \"com.SwiftDate.SwiftDate-macOS\") ??\n    // etc.\n    Bundle(for: DateInRegion.self). ",
    "swordray": "~~Still crashed with let framework = ....~~\nWorks. Probably due to caches.. ",
    "steelzeh": "For anyone running into this issue use this \nswift\n.convertTo(region: .local).toString\nor \nswift\n.convertTo(region: .local).toFormat\nI just don't see why it's automatically selecting a different region than the local region.. ",
    "Jan0707": "Kudos for the quick fix !. ",
    "vaibhav-varshaaweblabs": "Same here\n@sedwo Found any fix for that?. Same here\nMacOS Sierra - Version 10.12.6 (16G1036)\nXCode - Version 9.2 (9C40b)\n\n. ",
    "sedwo": "@malcommac Well, it still seems to fail for me in the same way.  Simply using your example app.\nRunning Sierra and Xcode 9.2.\nI'll monitor it.. ",
    "Bawenang": "Hi, I'm using 5.0.7 and this bug is still there.\nMacOS Sierra - Version 10.12.6\nXCode - Version 9.0. ",
    "drekka": "Came across this. Appears that there is an issue with Swiftlint failing the build.. ",
    "thedjinn": "Can confirm that changing -7 and 7 to -1 and 1 respectively works correctly.. ",
    "boardmain": "found : sorry SwiftDate.defaultRegion = . broken :/. ",
    "arkilis": "Still you have to decide by yourself on how many days in year and in month. Would be easy to have some method .diffDays(). ",
    "NduatiK": "Colloquial has been replaced by toRelative\nUpdated documentation can be found here\nYou could also consider sticking to a previous swift date version . ",
    "mikecsh": "Is there any specific version known to compile under Linux?. ",
    "vzsg": "Sure there is. Install Docker for Mac CE, and run this from your project folder:\ndocker run --rm -it -w /app -v `pwd`:/app swift:4.2 swift build\nAfter a cursory look (a friend is looking for working date arithmetics on Linux and found this project, I'm just helping out), the project doesn't build because there are multiple Darwin-only references in it, plus the unit tests are not set up correctly either.\n(Travis can be potentially tamed to do Linux testing too, once the source and the tests are up to speed. As a side note, I've had more luck with CircleCI 2.0 for Swift + Linux.). Do you have any spaces in your current working directory path? My gut feeling says that it might cause trouble with the backticks.. ",
    "bstillitano": "Anything on this?. ",
    "FSMaxB-divae": "Thanks for the explanation. Makes sense, still surprising though.. ",
    "iGranDav": "I have the same issue with french fr_FR and I think identifier used for regions is indeed false due too the locale.collatorIdentifier used.\nIn current code lang_fr_CA uses fr_CA as identifier, it should probably be fr-CA instead.\nBefore falling back to english I propose to try with a locale language code before. For example with locale fr_FR :\n * locale.collatorIdentifier is fr-FR => nothing corresponds\n * locale.languageCode is fr => lang_fr corresponds \ud83c\udf89 \nUsing @Vancion example with locale zh-Hans_US :\n * locale.collatorIdentifier is zh-Hans-US => nothing corresponds\n * locale.languageCode is zh => lang_zh corresponds \ud83c\udf89 \nEnglish should be the latest escape case.. ",
    "avjiang": "Hi how can I get the start and the end of previous week based on your reply? It seems same for both lines. Thanks . ",
    "joeljfischer": "I found this in the update guide\nDateInRegion: startOf() and endOf() are now replaced by dateAtStartOf() and dateAtEndOf()and include support for both single and multiple units.. ",
    "AdieOlami": "how do you use it in your project after installing and import SwiftDate. What is the next step to get SwiftDate working. how do you use it in your project after installing and import SwiftDate. What is the next step to get SwiftDate working. ",
    "JustClear": "\n\n. Thanks Too. \ud83d\ude4f. ",
    "devanshkaloti": "Hi, \nThis is still not working. Running Version 5.0, as stated in the installation docs. \nThanks,\n. Please advice... . ",
    "tkallioras": "@malcommac it is still broken. ",
    "ntokozotep": "Having the same issue on the Xcode 10 GM seed. Does anyone have idea on when this will be resolved?. ",
    "raudabaugh": "Hey @redent, I cherrypicked the fix onto latest 4.x and it fixed my issues. (link to commit above)\n@malcommac would you consider accepting a PR for this? I imagine there are a decent number of us still on Swift 3.x that need iOS 12 support. ",
    "mad102190": "@malcommac Any update on whether or not this change could be PR'd into a 4.x branch? Our project relies heavily on SwiftDate and upgrading to 5.x is not something we can do right now.  . ",
    "grifas": "I opened it in SwiftDate.xcodeproj and no more error. Build SwiftDate-iOS on a device and you'll be able to execute the playground.. ",
    "UNIQUEXJ": "ok! thanks. ",
    "manuelsBTS": "Hello. I would like to know if you are going to release a version for Swift 4.2. \nI got that @malcommac \n. @malcommac The error was fixed. I needed Clean project. Thanks. ",
    "szmokus": "Any chance it will be added soon?. ",
    "MattiaConfalonieri": "We also need this.\n. ",
    "Maxim-Inv": "I'm getting this error too. . ",
    "jessecoding": "+1. ",
    "nickvelloff": "+1. ",
    "nizenyang": "+1. ",
    "paulshapiro": "Same. I upgraded to find this feature missing. It was the only thing I was using from SwiftDate.. ",
    "purkylin": "swift 4.2\nos: Ubuntu\nSwiftDate: 5.0.13. ",
    "hethcox": "This looks like a serious bug to me. Can someone verify the are/aren't seeing this behavior?. Hi mSauvestre,\nI'm not talking about how Swift outputs Optionals. What I'm showing that I created a SwiftDate for the last day of this year, but it printed out the last day of next year.. ",
    "mSauvestre": "Hey hethcox,\nI think you are unaware of the full behavior of print(). If the passed element is an optional, print will let you know so by displaying this \"Optional()\" thing.\nIf you want your date displayed normally in this case, you would have to do:\nswift\nif let aDate = \"2018-12-31\".toDate() {\n    print(aDate.toFormat(\"MMM dd YYYY\"))\n}\nBecause aDate in this case isn't an optional anymore - in opposition to \"2018-12-31\".toDate(), which returns an object of type Date? (you can clearly see it to the ? before your function call toFormat) -, print won't be displaying this \"Optional()\" thingy :)\nHope that helps !\nTLDR: It's normal, SwiftDate is fine, you aren't misusing the API, but you misunderstood a concept of print(). Oh, sorry, you're completely right. I didn't see that element, my bad !\nDefinitively a bug. Seems to come from the formatter rather than the parser. When parsing the date, it's initialised correctly. When formatted, the information on the year gets corrupted.\nReally related to the 31st of December also \ud83d\udc4d . Well spotted \ud83d\ude4f. ",
    "Valpertui": "It's not a bug.\nIt's the difference between YYYY and yyyy.\nYYYY represent the year of the current week (Week based calendar).\nThe 31 december 2018 is a Sunday, which is also the first day of the first week of 2019 for week based calendars.\nyyyy represent the year of the day (Day based calendar).\nSee https://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns for more informations. ",
    "nhatquangz": "For anyone face with same issue:\nFrom SwiftDate 5.0, default timezone is UTC (GMT +0), So everything default is in UTC.\nSwiftDate.defaultRegion = Region.local to set local time zone again.\n. ",
    "jgarciatt": "Having the same issue here. This is the Output of the error:\n*** Building scheme \"SwiftDate-iOS\" in SwiftDate.xcodeproj\nBuild Failed\n    Task failed with exit code 65:\n    /usr/bin/xcrun xcodebuild -project /Users/jenkins/workspace/workspace/folder/Carthage/Checkouts/SwiftDate/SwiftDate.xcodeproj -scheme SwiftDate-iOS -configuration Release -derivedDataPath /Users/jenkins/Library/Caches/org.carthage.CarthageKit/DerivedData/9.4.1_9F2000/SwiftDate/5.0.13 -sdk iphoneos ONLY_ACTIVE_ARCH=NO BITCODE_GENERATION_MODE=bitcode CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= CARTHAGE=YES archive -archivePath /var/folders/13/srjjf2j94t5748mf90sbl70w0000gp/T/SwiftDate SKIP_INSTALL=YES GCC_INSTRUMENT_PROGRAM_FLOW_ARCS=NO CLANG_ENABLE_CODE_COVERAGE=NO STRIP_INSTALLED_PRODUCT=NO (launched in /Users/jenkins/workspace/workspace/folder/Carthage/Checkouts/SwiftDate). @yasuradodo Thanks, but I've done that but it does not works.. I'm using Xcode 9 still, could that affect the compilation process of the library?. It looks like the latest version is not compatible with Xcode 9 and the swift version I have, I', downgrading to 5.0.5 that was the one I used since the beginning and everything works. I will update after we migrate to Xcode 10.. ",
    "yasuradodo": "@peymankh @jgarciatt \nDelete Carthage/Checkouts/SwiftDate and then update carthage.\nI don't know exactly what's wrong, but this should help you. . ",
    "SogoGolf": "BRILLIANT! many thanks.. ",
    "SuhasDPatil": "Hi @malcommac ,\nAny updates on this issue. . ",
    "0xMarK": "@malcommac The fix is available in Pull Request https://github.com/malcommac/SwiftDate/pull/631 Please review and accept it if it is ok.. Hi @malcommac,\nI've made some experiments. It seems that the problem is that I use custom Locale created from currect locale, but it has different collatorIdentifier.\nFor example, if I select language French and region United States:\n```swift\nlet currentLocale = Locale.current // fr_US (current)\nlet currentLocaleCollatorIdentifier = currentLocale.collatorIdentifier // Optional(\"fr\")\nlet customLocale = Locale(identifier: Locale.current.identifier) // fr_US (fixed)\nlet localeCollatorIdentifier = customLocale.collatorIdentifier // Optional(\"fr_US\")\n```\nBut if I select language French (Canada) and region United States:\n```swift\nlet currentLocale = Locale.current // fr-CA_US (current)\nlet currentLocaleCollatorIdentifier = currentLocale.collatorIdentifier // Optional(\"fr-CA\")\nlet customLocale = Locale(identifier: Locale.current.identifier) // fr-CA_US (fixed)\nlet localeCollatorIdentifier = customLocale.collatorIdentifier // Optional(\"fr-CA_US\")\n```\nThe problem is that in the situation when customLocale.collatorIdentifier is equal to \"fr_US\" \u2013 func language(forLocale locale: Locale) falls back to English.\n. ",
    "noppefoxwolf": "should use yyyy incase.. ",
    "clay-mindoula": "me too:\nlog.debug(Date().toFormat(\"hh:mm:ss a\"))\n        log.debug(Date().description(with: .current))\noutput:\n```\n\n09:56:43 PM\nSaturday, January 26, 2019 at 1:56:45 PM Pacific Standard Time\n```\nmy timezone is Pacific. Both Sym and device produce the same results.\n\nI seem to have corrected this by:\nlet currentRegion = Region(calendar: Calendars.gregorian, zone: TimeZone.current, locale: Locale.current)\nSwiftDate.defaultRegion = currentRegion\nIs this correct> Thx\n. ",
    "xmanu": "I can confirm this issue for a standard German iPhone setup.\nCalling until.toRelative(since: from, style: RelativeFormatter.defaultStyle(), locale: Locale.current) will fallback to english, as locale.collatorIdentifier returns de-DE. This seems undesirable. I propose adding another guard fallback to only use the languageCode:\nguard let table = self.languagesCache[localeId] else {\n  guard let tableType = self.languagesMap[localeId] ?? self.languagesMap[locale.languageCode ?? \"en\"] else {\n    return language(forLocale: Locales.english.toLocale())\n  }\n.... ",
    "glennposadas": "Okay. Problem solved. Found one similar question on Stackoverflow (https://stackoverflow.com/a/14804093/3231194), and I did the testing myself.\n```\n    let currentDateString = \"2019-01-23T14:48:56Z\"\n    let startDateString = \"2019-01-23T03:01:00Z\"\n    let endDateString = \"2019-02-15T15:59:00Z\"\n\n    let dateFormatter = DateFormatter()\n    dateFormatter.dateFormat = \"yyyy-MM-dd'T'HH:mm:ssZ\"\n\n    let currentDate = dateFormatter.date(from: currentDateString)!\n    let startDate = dateFormatter.date(from: startDateString)!\n    let endDate = dateFormatter.date(from: endDateString)!\n\n    if startDate.compare(currentDate) == .orderedAscending && endDate.compare(currentDate) == .orderedDescending {\n\n    }\n\n```\nSo my code is correct, using SwiftDate.. ",
    "lekeCoder": "thank you. Quite an eye-opener for me. ",
    "acjh": "remainder, not reminder. - Use guard statements instead of == false.\n- locale?.identifier.hasPrefix(\"ru\") == false evaluates to false if locale is nil.. Mind the indentation.. - There are three types of endings:\n- ... which end with ...\n- (there is an exception for numbers between '10' and '20')\n- ... including those between '10' and '20'). ~As~ However, the Russian language is based on a case system where there are.... When locale is nil (i.e. not false), the function does not enter this scope, so it does not return false here.. ",
    "yurareutskiy": "Thanks for your comments. I agree about guard statements.\nBut I don't understand, what's wrong with case when locale is nil? If it happens, when function return false, framework will use default bundle ('en-US').\nOr I misunderstood you?. I just checked this case\nlocale = nil\nguard locale?.identifier.hasPrefix(\"ru\") == true else {\nreturn false\n}\nWhen this function executes, it enters in else scope and returns false. ",
    "TrachYuri": "Was ok on my laptop. But i've re-ident it using xcode tool. Please check now.. "
}