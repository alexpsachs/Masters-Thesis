{
    "mhagger": "Regarding your other points:\n1. According to PEP 394, there should be an executable called python2 that runs a Python interpreter that is definitely 2.x.  Obviously this newish convention is still far from universal, but I decided to use it as the default for this reason.  I agree with you completely that we would need some kind of build/install procedure that rewrites the script with the correct shebang for the system it is running on.\n2. The test harness is still needed but I think my test-dirs branch is a start towards handling the temporary directory more sanely.\n. I just merged test-dirs to master, as I believe it will cause people less problems than the status quo ante.\nI just opened a new issue #4, \"We need some kind of build/install infrastructure\".\nIf you are satisfied, please close this issue.\n. Good idea (at least until we have a real build/install system).  Thanks!\n. It's great that you found this, because I haven't yet figured out how to test the unexpected failure / unexpected success codepaths.  (I think it might involve some libification and then the use of a mock repo object.)\nI see the cause of the problem in your case.  remove_failure() is not doing the right thing.  If there is a conflict like this:\n```\n\n......\n.....X\n*......\n```\nthen it should attempt to split the conflicting block into two blocks (one of which might be empty) like this:\n*****||\n-----++\n*....|X\n-----+.\nbut instead it is doing this:\n*****|*\n*----+.\n*.....X\n*......\nwhich is nonsense.  In your case the single block that it is producing is empty, so resolving it doesn't make any progress; hence the infinite loop.\nI'll work on this; I think it shouldn't be hard to fix (hopefully within the next hour or so).  Don't throw away your in-progress merge, because it should be possible to continue it with the fixed version of the software.  (And it would be a check that the fix really helped!)\n[Edit: middle diagram just fixed.]\n. I just pushed a change to master that I think will fix your problem.  Please let me know if it works!\n. Thanks for testing!\nI also pushed a change to the error message for \"unexpected failure\".\n. Sorry I see you based your work on some commits that I accidentally created with a bogus author (due to test suite misuse).  I'll rebase your commit on the fixed commit when the time comes.\n. Yes, this sounds like a bug.  But it's not clear what should happen, at least not in all scenarios...\nWhat is the \"original author/committer/date\" of a merge commit?  They have two parents, so it is ambiguous.  AFAIK Git sets the author and committer of a merge commit to the person doing the merging, not to those of either of the parent commits.\nIn the special case that the incremental merge is being simplified into a rebase, then I guess it would be reasonable to take the GIT_AUTHOR_* information from the old version of the commit.  (This must be the case that you are talking about.)  But shouldn't the GIT_COMMITTER_* information be set to the user doing the imerge?\nWhat should happen if you simplify the incremental merge into a simple merge?  Then I think the author and committer should be the person doing the imerging.  Do you agree?\nWhat if you simplify it into a rebase-with-history?  This is kindof a middle ground because the old commits are kept (thus preserving the old author and committer info).  I can see arguments for either approach--copying the original author info vs. setting the new author info to the person doing the imerge.  What do you think?\n. \"git rebase\" uses the author information of the original commit, but sets the committer information to that of the person doing the rebase.  I think we should do the same thing for simplify-to-rebase.\n. I just merged your fix.  Thanks!\nThe behavior of \"--goal=rebase-with-history\" has not been changed--the authorship is assigned to the person running \"git-imerge simplify\".  I can see both sides of the argument on this one.  I think that because rebase-with-history preserves the original author's commits, not copying the authorship info has the effect that the person who did the imerge is also recorded somewhere (assuming it was a single person, that is!).\nIt could be made an option, I suppose...\n. Would --date=raw fix the time zone problem?\n. First of all, this is awesome!  I do have a few nits but the overall idea and implementation are excellent.\n. I made some comments on the individual commits.  Other than those, it looks good.\nAside: I'm not sure that the coloring of \"unblocked\" merges is 100% correct.  But currently git-imerge doesn't let you access these intermediate states, so there's no point worrying about it until it can be tested more easily.\nThe colors really make the diagrams easier to read, and the integer-encoded diagrams will be easy to use for other output purposes.  Thanks!\n. Merged and pushed, thanks!\n. Very cool.\nI'm trying to imagine how the browser would find the CSS file.  Would it be more convenient to (optionally?) embed the CSS in the HTML document?\nYou've also got me thinking about even more hijinx like having Python open a mini webserver that allows the user to click on a blocker to choose which merge conflict to resolve next, mouseovers to show commit messages of the original commits, etc :-)\n. I see that you pushed some fixup commits, but I will still wait for your \"go\" before I do any merging.\n. Merged and pushed.  Thanks!\n. Thanks for the patch!  I just merged it to master, after adding some comments above the lines you changed to prevent somebody with a short memory (e.g., me) from changing the commands back.\nIf you're using git-imerge in real life, please let me know how it is working for you!\n. On 07/14/2013 02:45 PM, Jonathan del Strother wrote:\n\nHi there - I have my git hooks set up to run ctags in the background on\npost-commit, post-checkout, and post-merge. git-imerge causes my\ncomputer to grind to a halt as 30 different ctag processes are kicked off.\nAny thoughts on a better way of handling this sort of behaviour? git\ndoesn't give a builtin way of suppressing hooks, right? Is there any\nprecedent for setting an environment variable along the lines of\n|RUNNING_AUTOMATED_CHECKOUTS=1| that hook scripts should look for?\n\nI don't know of a way to make git skip all hook scripts.  But even if\nthere were, it wouldn't be very flexible; perhaps one would want to run\nsome hook scripts but not others.\nSo it would probably make more sense for git-imerge to record what it is\ndoing in the environment somehow; e.g., set an environment variable\ndescribing what git-imerge is currently doing, like\nGIT_IMERGE_STATE=(automerge|autofill|usermerge|simplify|...)\n(It would take some thought to decide on the exact list of states.)\nThen the hook scripts could test the variable and perhaps decide to just\nexit without doing anything.\nWould that be convenient enough?\nWe should also audit where git-imerge is using plumbing commands (which,\nI think, often do not call hook scripts) vs. porcelain commands (which\ndo).  There might be cases where we should switch the choice plumbing ->\nporcelain or vice versa to get the hook script behavior that we want, or\npossibly execute the hook scripts directly.\nMichael\n\nMichael Haggerty\nmhagger@alum.mit.edu\nhttp://softwareswirl.blogspot.com/\n. As a simple first step, in commit 04419db0fb765eced357f39856bf52666b2c41eb I have git-imerge set environment variable GIT_IMERGE=1 while it is running.  Your hook scripts can interrogate that value to decide whether they should run in \"cheap\" mode.  Someday it would be nice to make the value of GIT_IMERGE reflect exactly what git-imerge is doing at the time (maybe you want to work on this?)\n. python2 is there because git-imerge requires Python version 2.x as opposed to Python 3.x (or, God forbid, Python 1.x).  According to PEP 394, it is recommended that some Python 2.x interpreter be installed in PATH under the name \"python2\".  I understand that this is not yet universal practice, but on the other hand there are already systems where \"python\" is a Python version 3.x interpreter, so that option is also not universally portable.\nBy the way, I think that any Python interpreter version 2.5 <= version < 3.0 should be fine for git-imerge.\n. @myint, that's really cool!  I hadn't yet had the energy to get any of my projects running under Python3.  It's a lot less nasty than I would have feared.\nI just pushed some commits to master that incorporate some of the changes from your first commit. The remainder of your changes (i.e., after the already-merged changes have been removed) are in my repo under branch myint/python3.  But before I merge the rest, I would like to understand the ramifications a little bit better.\nWhat is the situation on the Mac OSX?  (Is that is what you are using?)  Is Python 2.x unavailable, or is it available, but just not under the name python2?  In other words, are these changes needed to make the script usable under Mac OSX at all, or just to avoid having to edit the shebang line?\n(If the latter, then there are other ways to make sure that a Python 2.x interpreter is used to run the script.  Either the script can be given a Shell preamble that chooses the correct Python interpreter, or we could add an install script that overwrites the shebang line with the one correct for the system that it is running on.  Not that python3 compatibility is something bad, but reducing the python2 compatibility might still be inconvenient for some users.)\nBefore these changes, I think that git-imerge would have worked under Python versions 2.5 <= version < 3.0 (though I haven't actually tested it against the older versions).  The changes I just pushed now prevent it from running under 2.5 (because it doesn't have the next() built-in function).  With the rest of your changes, what versions of Python should it run under?  Only 2.7 and 3.3?  Assuming that is the case, we should probably verify that the important recent OSs make one of these Python versions available.\nThanks again for your contribution!\n. @myint: Thanks for the additional info.  I was confused; I thought that \"except E as T\" syntax wasn't added until Python 2.7.  Now I see that it was backported to Python 2.6.1.\nSo if we merge your changes, I think our Python version requirement would become\n(2.6.1 <= version < 3.0) or (3.3 <= version)\n(that is, unless something else that you are using was introduced even later than 2.6.1).  I think we can live with that.  I just merged your change (though the commit identities have changed, so you might want to pull from me again).\nThanks!\n. @myint: I was going by the language reference for 2.6 vs 2.6.1.  The as syntax wasn't mentioned until 2.6.1.  But given that it is mentioned in the changelog for 2.6, I assume that it was implemented then and they just didn't get around to updating the language reference in time for the release.\nI'll fix the README.\n. The issue is more that I haven't had the time to think about the ramifications of merges with multiple merge bases, so I just implemented the case that is relatively obvious.\n\"git merge\" itself, when using the default \"recursive\" strategy does something less trivial than just picking one of the merge bases:\n\nWhen there is more than one common ancestor that can be used for 3-way merge, it creates\na merged tree of the common ancestors and uses that as the reference tree for the 3-way\nmerge.  This has been reported to result in fewer merge conflicts without causing mis-merges\nby tests done on actual merge commits taken from Linux 2.6 kernel development history.\n\nSo, while your approach might work in some cases, I have the feeling that it is not necessarily a good universal policy.  Some experiments and theory are probably in order here.\n. In general, rebasing only part of a branch is not a well-formed operation in a DAG-based history.  However, it just occurred to me that the removal of a commit or sequence of commits from a branch could be framed as an incremental merge.  Suppose you have two commits, A and B, and you want to remove A from the history:\no - A - B\nIt is possible to compute A\u207b\u00b9, the inverse of A, in the context of A (this cannot conflict):\no - A - A\u207b\u00b9\n    |\n    B\nNow if you merge these two \"branches\", you get\no - A - A\u207b\u00b9\n    |   |\n    B - B'\nwhere the merge commit, B' is effectively commit B without commit A.\nThis can be generalized to removing an arbitrary number of contiguous commits followed by an arbitrary number of commits that you want to retain.  I don't see an obvious way to generalize it to removing multiple intervals of unwanted commits except for the trivial approach of removing them one interval at a time.\nBut this workflow is not yet supported by git-imerge, so you would have to do at least part of it manually.  If you would like to work on implementing this in git-imerge, I would be happy to help you get started.\n. @muff1nman: I think that your \"remove commits\" steps can be done as a single incremental merge:\no - A   -   D   -  E   -   F   -   G    -   H\n                           |\n                          F\u207b\u00b9\n                           |\n                          E\u207b\u00b9\n                           |\n                          D\u207b\u00b9\nEach of these three revert commits (since they are applied in reverse order) necessarily applies cleanly.  For example, the state of the tree after D\u207b\u00b9 is exactly the state of the tree after A.\nOnce the incremental merge is done:\no - A   -   D   -  E   -   F   -   G    -   H\n                           |       |        |\n                          F\u207b\u00b9  -   G'   -   H'\n                           |       |        |\n                          E\u207b\u00b9  -   G''  -   H''\n                           |       |        |\n                          D\u207b\u00b9  -   G''' -   H'''\nthen all you have to do is glue together the trees in the order [A, G''', H'''] and you have effectively deleted D, E, and F from this history.\nThe second step, as you describe, is a standard git imerge rebase.\nBut you could even reduce these two steps to a single step, by starting the incremental merge like this:\n```\no - A   -   D   -  E   -   F   -   G    -   H\n                           |\n                          F\u207b\u00b9\n                           |\n                          E\u207b\u00b9\n                           |\n                          D\u207b\u00b9\n                           |\n                           B\n                           |\n                           C\n```\nB and C necessarily apply cleanly on top of D\u207b\u00b9, because D\u207b\u00b9 has the same tree as A.  Once you've filled in the incremental merge\n```\no - A   -   D   -  E   -   F   -   G    -   H\n                           |       |        |\n                          F\u207b\u00b9  -   G\u2081   -   H\u2081\n                           |       |        |\n                          E\u207b\u00b9  -   G\u2082   -   H\u2082\n                           |       |        |\n                          D\u207b\u00b9  -   G\u2083   -   H\u2083\n                           |       |        |\n                           B   -   G\u2084   -   H\u2084\n                           |       |        |\n                           C   -   G\u2085   -   H\u2085\n```\nthe final answer is [A, B, C, G\u2085, H\u2085].\nBut, even in this simple case, there is the question: is it more efficient to do it this way (remove [D, E, F] from the history and then rebase [G\u2083, H\u2083] onto [A, B, C]), or would it be more efficient to rebase [D, E, F, G, H] onto [A, B, C] and then remove [D', E', F'] from the result?  (Actually there are a bunch of other possibilities, too.)  That would be a straight rebase:\no - A - B  - C\n    |   |    |\n    D - D\u2081 - D\u2082\n    |   |    |\n    E - E\u2081 - E\u2082\n    |   |    |\n    F - F\u2081 - F\u2082\n    |   |    |\n    G - G\u2081 - G\u2082\n    |   |    |\n    H - H\u2081 - H\u2082\nfollowed by removal:\no - A - B  - C - D\u2082 - E\u2082 - F\u2082   - G\u2082 - H\u2082\n                           |      |    |\n                           F\u2082\u207b\u00b9 - G\u2083 - H\u2083\n                           |      |    |\n                           E\u2082\u207b\u00b9 - G\u2084 - H\u2084\n                           |      |    |\n                           D\u2082\u207b\u00b9 - G\u2085 - H\u2085\nThen the answer is [A, B, C, G\u2085, H\u2085].\nI don't think that these two methods are equivalent.  Which one is easier probably depends on a case-by-case basis.\n. rerere tucks away information about attempted merges, and uses that information to affect future merge attempts.  This makes the result of a particular merge depend not only on the commits that are being merged, but also on the history of merges that have been done previously.\nSince git-imerge attempts so many similar merges, it is easy to expect that this will confuse git-imerge.  And indeed, during testing, it seemed like rerere in combination with imerge was causing merge conflicts to be resolved incorrectly sometimes.  Therefore, git-imerge explicitly turns rerere off when it shells out to git.\nMeanwhile, I expect that the incremental merges done by git-imerge wouldn't benefit so much from rerere anyway, at least within a single incremental merge.  This is because the micromerges are recorded in the DAG and so their merge resolution is already available to Git without the need for additional rerere data.  Moreover, the fact that rerere data is local would make it more difficult to collaborate on incremental merges.\nWhere rerere might help would be if, for example, an imerge is attempted multiple times, or part of the conflicts involved in the imerge have already been attempted previously as part of a simple merge or rebase.  In that case some of the conflict resolution might be able to be carried across from one merge to another, reducing the number of conflicts that have to be resolved manually.\nSo....\nIt might be advantageous to combine rerere with git-imerge, but it would need some careful testing and thought before I would recommend it.  Maybe one could gain the advantages without suffering from the problems by using rerere more selectively; for example, turning it on for manual merges but turning it off for automatic merges.\n. That's a great idea, and one that somebody else has also wished for.  If you would like to work on it, I would be happy to help you get started.\n. @jrdavid: Cool that you want to work on this; here's some info to get you started:\nThe state of the imerge as a whole is stored in the MergeState object--except for information about the micromerge that is currently in progress.  This is by design, because if the user aborts the merge or manually initiates another merge and then types git-imerge continue, git-imerge has to figure out how to proceed based on the state of the repo at that time, not the state of the repo the last time git-imerge ran.\nSo if you look at the code for 'continue', you will see that it calls incorporate_user_merge(), which is responsible for figuring out which micromerge (if any) was just finished by the user and recording the resolution in the MergeState object.\nincorporate_user_merge() finds the commit pointed at by the reference refs/heads/imerge/NAME and passes it to MergeState.incorporate_manual_merge().  The latter checks that the commit is a merge, and if so looks for its parents among the micromerges that have been recorded previously and converts them into indexes:\n(i1first, i2first) = self.find_index(parents[0])\n(i1second, i2second) = self.find_index(parents[1])\nThis locates where the just-completed merge is located in the merge graph.  From there, it would be easy to output information about the original commits that are being merged, similar to what is done in request_user_merge().\nHowever, the \"status\" command that you want to implement can't start from a merge commit, because the manual merge hasn't been done yet.  Instead it will have to find out, from Git, if a merge is currently in progress and if so, what two commits are being merged.  The first parent of an in-progress merge, of course, is stored in HEAD and can be determined via git rev-parse HEAD.  The second can be determined by reading the file .git/MERGE_HEAD, which, if it exists, lists the second \"HEAD\" of the in-progress merge.  (If the file doesn't exist, then no merge is in progress.  If the file has more than one line, then an octopus merge is in progress, in which case the \"status\" command would have to report that no micromerge is in progress).\nThen stick those two commit SHA-1s into MergeState.find_index(), to deduce which micromerge is in progress, and report the original log message using code like that in request_user_merge().\nI hope that helps!  If you have any questions, don't hesitate to ask.\n. This issue has interesting discussion in it, but is otherwise superseded by issue #33.\n. Yes, I think that should work fine.\nOne obvious approach would be to rebase (or rebase-with-history) the current state of the refactoring branch to the current state of master, and just repeat this step periodically as master progresses.  This would have the benefit that  after you do a rebase, the subsequent work that you do on the branch will be on top of the changes that have been done on trunk between the branch's old branch point and its new branch point, so you will intrinsically have fewer conflicts.\nIf the incremental merge is too much work to do at once, you could also work on the incremental merge across several sittings, simply leaving the in-progress imerge in your repo between attempts.  If work on master or (especially) branch continue during your imerge, you could leave the results of the first incremental merge in your repo and expand the completed part of the incremental merge diagram one rectangle at a time.  So, for example, if the first imerge was \"imerge1\", then you could do\ngit checkout imerge1\ngit imerge start --name=imerge2 --goal=GOAL --first-parent wipbranch\nwhere \"wipbranch\" is the current state of the WIP branch, which includes more commits than the ones that were included in imerge1.  The only thing that might be awkward is simplifying the final imerge into the rebase that you ultimately want.  Given the current state of imerge, you would have to do that by hand using the \"git imerge reparent\" command or other fancy Git trickery.\nCertainly, git-imerge could be made to support this workflow better.  Contributions are welcome.\n. Thanks for your kind words and your offer to port git-imerge to Perl.  I used Perl many years ago and never want to go there again if I can help it, nor to give anybody else a reason that they have to learn Perl.  There are many better alternatives today (Python by no means being the only one).\nYou are of course welcome to write your own Perl version of git-imerge (it's open-source, after all).  I only ask that you name it in such a way as to prevent confusion with this project.\nBut I would encourage you to instead consider investing your time (probably far less time) figuring out a way to make it easy for your colleagues to install Python; that way they can benefit from git-imerge, including all of its future versions, plus lots of other good software that is written in Python, and if you write up how to do that I would be glad to include it in the git-imerge documentation.  I would also be happy to make adjustments to git-imerge to make it work smoothly in that environment.\n. Merged; thanks!\n. This should be fixed by af53d092ba42e38e472fdc88237909be028e22b1:\n$ git imerge start --name=mergebranch --goal=rebase-with-history --first-parent inexistentbranch\nfatal: Not a valid object name inexistentbranch\nCannot compute merge base for 'HEAD' and 'inexistentbranch'\n$\n. This is an interesting idea and I've also thought about something like this.  I got stuck because I don't see an elegant way to generalize it to multiple manual merges; it seems to me that if there are N manual merges then the number of merges that would need to be retained goes something like N\u00b2.  (Though maybe that is acceptable and this type of simplification would be useful anyway.)\nFor concreteness, please draw a bigger diagram, with three or four manual merges scattered about, and suggest how you think the simplification should be done in that case.\n. What is the point of storing more intermediate merges?  Is it so that git has enough history that it can use to do subsequent merges?  Is it so that the whole incremental merge could in principle be reproduced?  Is it so that a human looking at the history can understand it?  Without understanding the purpose, it is hard to reason about what should be retained.\n. I got stuck in approximately the same place when I thought about this possible feature.  My feeling is that all of the commits that you have indicated in your drawing should usually be preserved.  It wouldn't be that hard to implement.  The question is how useful it would be in practice.\n. @eddyp: I just implemented this and pushed the result to branch simplify-to-manual.  Please test it and see if it does what you want; if so, I will merge it to master.\n. @eddyp, I just pushed a rebased version of this feature to the branch \"simplify-to-manual\".  It would be great if you would try it out and let me know if it works for you.\n. My guess is that you are using a version of git from before \"git reset --merge\" was implemented.  What version of git are you using?  (Try \"git --version\".)\n. Hmmm, git reset --merge should be present in that version of git.  What happens if you run that command by hand?  Assuming it fails when run by hand, can you figure out why?\n. @rogerwang, have you followed up on this?  Did you find out what caused the problem?\n. Ahh, that's an interesting problem.  The merge didn't fail because the two commits conflicted, but rather because of other cruft in your working tree.  We'll have to find a way to deal with that.\nThe error occurs because git imerge continue tries to add the merge commit pointed to by reference refs/heads/imerge/$NAME into the incremental merge (where $NAME is the name that you gave this incremental merge).  Since there was no real conflict, I guess you didn't commit a merge commit.  So refs/heads/imerge/$NAME is not a merge between two conflicting parents, and the tool doesn't know how to proceed.  If I understand correctly, there was no conflict at all, and so there is no need for manual merge resolution.  What is your current git status?  Is it still in thinks-it's-conflicted state?  Is the tree clean but still waiting for a merge commit (i.e., is there a .git/MERGE_HEAD)?\nTo solve the problem, simply delete the branch refs/heads/imerge/$NAME, remove the un-checked-in .config file, and then type git imerge continue again.  I think it will then set up the same merge, which this time shouldn't have any conflicts, bit it will nevertheless ask you to resolve the conflicts and commit.  You should just commit a merge commit to appease the tool and then git imerge continue as usual.\nObviously this situation has to be handled better by the tool:\n- Perhaps it should specifically diagnose when a merge failed because of an uncommitted file in the working copy and ask the user to clean up before retrying.\n- Probably if request_user_merge() sets up a merge but the merge doesn't conflict, then the tool should just continue without user input.\n- The documentation should be improved.\nPlease report whether that helps.\n. Thanks!  I just merged your change.\n. Yes, you are right of course.\nBut given that development takes place on master in little bits, can you think of a way of implementing this that doesn't require the manual incrementing of a version number every time I merge something to master?\n. Since the error refers to a date, my first spontaneous guess is that the problem might be related to internationalization.  Does the result change if you run git-imerge with something like LANG=C?\nMichael\nMichael Haggerty\nmhagger@alum.mit.edu\n----- Reply message -----\nFrom: \"Magnus Therning\" notifications@github.com\nTo: \"mhagger/git-imerge\" git-imerge@noreply.github.com\nSubject: [git-imerge] Can&apost finish an imerge :( (#32)\nDate: Fri, Sep 13, 2013 15:04\nI just completed the final manual merge of an 18/6 imerge and now I find I can't finish it.  The result I get is \n% git-imerge finish\nfatal: invalid date format: 2013-07-24 \nTraceback (most recent call last): \nFile \"/usr/bin/git-imerge\", line 2795, in  \nmain(sys.argv[1:]) \nFile \"/usr/bin/git-imerge\", line 222, in wrapper \nreturn f(_args, *_kw) \nFile \"/usr/bin/git-imerge\", line 2743, in main \nmerge_state.simplify(refname, force=options.force) \nFile \"/usr/bin/git-imerge\", line 2209, in simplify \nself.simplify_to_rebase(refname, force=force) \nFile \"/usr/bin/git-imerge\", line 2176, in simplify_to_rebase \ntree, [commit], msg=get_log_message(orig), metadata=authordata, \nFile \"/usr/bin/git-imerge\", line 472, in commit_tree \nraise CalledProcessError(retcode, cmd) \nsubprocess.CalledProcessError: Command '['git', 'commit-tree', '0df2c0115fddd350eee35765283df964eecc7489', '-p', 'bcb4b458973531aa5cb318c600f0431e9aa2f509']' returned non-zero exit status 128 \nI started this imerge on master with \ngit-imerge start --name=foobar --goal=rebase --first-parent devo \nI had a look at the code raising the exception but can't really work out what causes this.  I also printed out the message (msg) and then ran the git commit-tree command manually, with the arguments above and passing the copied message on stdin, that worked just fine. \nAny suggestions on how to finish off the imerge in this case? \n\u2014\nReply to this email directly or view it on GitHub.\n. OK, I had some time to look into this.  The problem is with the metadata that is passed to \"git commit-tree\" via the environment (not the command line), which in turn is determined in MergeState.simplify_to_rebase() by calling get_author_info(orig).  Would you please print the contents of the \"metadata\" variable that is being passed to commit_tree()?  If (as I expect) the GIT_AUTHOR_DATE value is not a valid date, then please print \"orig\" and the output of the following commands:\n```\ngit --no-pager log -n1 --format='%an%x00%ae%x00%ad' $ORIG | hexdump -C\ngit cat-file commit $ORIG\n```\nMy guess is that you have a config setting \"log.date\" that is causing the date to be emitted in a format that git-imerge doesn't expect and (more to the point) that \"git commit-tree\" cannot parse.\nNote to self: we should probably use a plumbing command rather than \"git log\" in get_author_info().\n. On 09/15/2013 07:58 PM, Magnus Therning wrote:\n\nAll right, here's the output I got out... hopefully you can make some\nsense of it :)\n[...]\n\nThanks for the data.\n\nOh, and my |log.date| is set to |short|.\n\nYes, that config setting is what is causing the problem.  I will try to\nfix it, but until then if you temporarily unset log.date before running\ngit-imerge then it will hopefully work correctly.\nMichael\n\nMichael Haggerty\nmhagger@alum.mit.edu\nhttp://softwareswirl.blogspot.com/\n. The above commit should fix this issue.  Please let me know if you continue to have problems.\n. Cool, thanks for working on this!  It will be a nice feature.\nI belatedly realized that I was working on a topic branch that could help you with your \"status\" command (I just merged the topic branch to master): I added fields \"tip1\" and \"tip2\" to MergeState.  These record the names of the branches that are being merged, based on the user's arguments to \"git imerge start\", because I wanted to add that info to the suggested commit message when simplifying to a merge commit.  But you could use these fields instead of your get_refname() method, simplifying the code and potentially giving an answer that is more relevant to the user.  (Instead of computing and using ref1 and ref2, simply use merge_state.tip1 and merge_state.tip2.)\nI also think that the \"status\" command should work even if a conflicting merge is not in progress.  For example, if the user has just run git commit to commit a conflict resolution, or has just run git imerge record to record the last conflict resolution without setting up the next one, then git imerge status could nevertheless say something useful about the current situation rather than just spitting out an error message.  It might even suggest the next command that the user might want to run.\nFinally, it looks like the implementation of \"status\" could share some code with request_user_merge().\nAltogether very nice.  I look forward to the next iteration.  But please be patient; I will have spotty internet for the next week or so and might not be able to reply promptly.\n. @jrdavid, are you working on a new version of your patch?  If so, is there anything I can help with?\n. It's not possible.  Suppose the original diagram is\no - A - B    <- master\nand you want to exchange the order of commits A and B while preserving history.  The resulting diagram would have to look something like this:\no - A - B\n     \\ /\n      X\n     / \\\n    B'- A'   <- master\n(The X simply means that the lines cross, and the dependencies go upwards; e.g., B is a parent of B'.)  But this is incorrect, because A is an ancestor of B' (via B), which implies that the state B' includes the changes that were originally made in commit A.  But in fact, B' does not include those changes; in the rebased commits, the changes originally introduced by A are only introduced in the delta from B' to A'.\nSo there is no way to preserve history when reordering commits while also preserving the correct commit ancestry.\n(It is possible to use incremental-merge tricks to reorder history, and I hope to write that up soon.  But it is impossible to record the result of such a commit-reordering in a history-preserving way.)\n. I hereby conjure @jherland, who wrote this code.\nI did a little bit of googling and found:\n- A stack overflow answer that suggests that ansi.sys has to be enabled for colors to work under Windows.  Perhaps this is why different people are seeing different behavior.\n- A more careful recipe for determining whether stdout supports colors\n- A complicated recipe for doing lightweight colors.  This might be overkill (though it includes a lot of stuff that we wouldn't need and could omit).\nHope that helps!\n. This might have happened because there was already a branch called refs/heads/imerge or perhaps refs/heads/imerge/slaveinfo/FOO, and the reflog file for that branch blocked the creation of the reflog file for branch refs/heads/imerge/slaveinfo. Or perhaps there was a lower-level issue, like a permissions problem within the .git directory.\nEither way, this is unlikely to be a problem in git-imerge -> closing.\n. > I haven't seen this problem myself (but haven't used imerge recently); I wonder if git commit --allow-empty would work as well.\n@jmah: Indeed, that is the workaround that I use. In fact, I don't think that --allow-empty is needed, because merge commits are always allowed to be empty.\nI just implemented #98, which I think should fix this problem for once and for all. It would be great if people who have experienced this problem would test it.\n. @talios: I guess the reason I didn't allow it was just for simplicity.  But I just created a pull request that removes this restriction.  Please test it and let me know how it works: mhagger/git-imerge#45\n. I just merged the branch to master.\n. Thanks for the patch.  I'll wait for @myint's thumbs up before merging, since he contributed the python3 compatibility changes.\n. My struggle to understand #62 brought be back to this issue, and I can't for the life of me figure out why this change helped anything.  Isn't str('GIT_IMERGE') identical to 'GIT_IMERGE' on all Python versions, and the same for '1'?  For example, for Python 2.7 and Python 3.3:\n```\n$ python2\nPython 2.7.6 (default, Mar 22 2014, 15:40:47) \n[GCC 4.8.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nstr('1') is '1', str('GIT_IMERGE') is 'GIT_IMERGE'\n(True, True)\n$ python3\nPython 3.3.5 (default, Mar 22 2014, 13:24:53) \n[GCC 4.8.2] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\nstr('1') is '1', str('GIT_IMERGE') is 'GIT_IMERGE'\n(True, True)\n```\n\n\n\nI don't have a Windows machine for testing, but I can't imagine that the results are different.  If somebody could explain better why this patch helped, I would be thankful.\n. Thanks @KindDragon for your response.\nNow I see the reason:\nfrom __future__ import unicode_literals\nI'd forgotten that setting even exists.  So even under Python 2.x, string literals are treated as Unicode.  Now it makes sense.\nWhy is it that every time I run into a Unicode problem, I waste half a day and don't feel any wiser afterwards? :cry:\n. Looks good, except that I don't want to add .travis.yml to the repo at this time.  Please re-submit without that file.\n. > The .travis.yml doesn't do anything unless you enable Travis CI via the web-based settings.\nThat's the reason.  I don't see the reason to clutter the repo with unused junk.\nIf adding this file would make your life easier somehow, feel free to speak up.\n. Cool, thanks for the fix!  I just merged it.\n. I think this solution doesn't work correctly for Python 2.x; see issue #62.  In that issue is a proposed solution.\n. Why do you set the default prefix to /usr/local?  I think that most packages use /usr as the default.\n. I think it is clear that the choice of prefix depends on the context.  If git-imerge is picked up by any Linux distros, then they will install it to /usr.  If it is installed by a sysadmin for all of the users on a system, then /usr/local.  If it is installed by a single user of a multiuser system, then $HOME.  If Windows then presumably somewhere like\nC:\\My Programs and Viruses and Keyloggers\\Cancer-Like Stuff\\Open Source\\\nAll of these constituencies can be served because they can set PREFIX when installing.  The only question is: what is the conventional default?  I did a little bit of looking around, and it looks like my recollection that /usr is standard was incorrect.\nThe GNU Coding Standards (recommend)[http://www.gnu.org/prep/standards/html_node/Directory-Variables.html] setting the default prefix to /usr/local.  Autoconf (also uses /usr/local)[http://www.gnu.org/software/autoconf/manual/autoconf.html#Default-Prefix] as the default prefix.  I'm inclined to defer to them.\nGit's default install target happens to be $HOME, but I seen no special reason to imitate them.\nSo let's just wait a bit to see if @ralfth has any input, and then I'll merge.\n. Merged.  Thanks everybody!\n. @ralfth: Thanks for the patch.  Just a day earlier @josmo submitted pull request #50, which is very similar.  Could I please ask you to get involved in the discussion over there and all try to come to an agreement about the details?  Then I will be happy to merge the result.  Thanks!\nI'm going to close this pull request simply to centralize the discussion in one place (not because I prefer one version or the other!)\n. Probably if you run\ngit merge-base --all dev_build v3_merge\n(notice the --all option) you will find that it indeed has more than one merge base.\n. No, that's not built into git-imerge right now.  Though I suppose if you are adventurous you could manually edit the line in git-imerge that calls merge-base to have it return whatever SHA-1 you want.  I think that would be enough to let you experiment.\nLet us know what you find out!\n. @scruff311: If you want to submit a change, please use a GitHub pull request: fork the repo, push your change to a branch on the fork, then create a pull request based on the branch that you pushed.\n. Thanks for the contribution.  I just merged it.\n@muff1nman, I have a question: I'm thinking about reorganizing the source code to move most of git-imerge's code into a Python module, probably called something like git_imerge/git_imerge.py.  Would the modeline still be necessary if I make that change, or would vim automatically choose the right mode based on the .py file extension?\n. @muff1nman thanks for the info.  I'll leave the vim line even if I rearrange the source.\n. OK I just pushed a tag 0.7.0.\nSorry I didn't get to this quicker, but really, we need more than just version tags and I was researching how best to do it.  But my research is taking longer than I'd hoped, so here is your tag.\nBeyond a version tag, there should be a mechanism for the script itself to know its version number, so that (for example) we can ask people who file a bug report to run git-imerge --version to be sure which version they were using.  It is a little bit awkward to do so based only on a Git tag.  Because on the one hand if the script is not running from within a Git working copy, then you want it to be able to read the version directly from a file without going to the overhead of running Git.  But on the other hand, if the script is running from within a Git working copy, then you want it to figure out the version of the current HEAD commit rather than use a version number from a file that might be stale.  But I don't want the process to rely on a \"build\" step that people (including me!) might forget.\nI think what I'd like to do is have the working copy version always try to get its version number from Git using something like this.  But at the install step, the version number should be baked into the program somehow.  Maybe it could be as simple as using code like this:\ntry:\n    from version_from_git import __version__\nexcept ImportError:\n    from version import __version__\nThe source tree would have a file version_from_git.py, but that file would never be installed.  Instead, the installation process would generate a file version.py on the fly via something like\nfrom version_from_git import __version__\nwith open('version.py', 'w') as f:\n    f.write('__version__ = %r\\n' % __version__)\nThoughts?\n. This is awesome!  I'd thought about doing this but haven't had time to get to it.  So it's :sparkles:really great:sparkles: that you are working on this.\nI do have one wish: that when you are done, before you ask me to merge you rebase your commits into a logical sequence, such that each commit is self-contained and, for example, commits like \"remove extra newlines\" are squashed into the commit that introduced the extra newlines.  I can help you with this tidying up if you are not into that sort of thing.  (As long as you are working on the PR feel free to commit in whatever order you want and rebase at will.)  I will try to keep an eye on whatever you push and give feedback when I think it might help.\n. A note about version numbers:\nIt's really important that we start defining version numbers for git-imerge.  One reason is because packagers need them (e.g., see #54), and it is in our interests to help packagers.  The other is that it will make it easier to support users if we can ask them \"what version of git-imerge are you using?\"\nsetuptools requires a version number too, doesn't it?\nThe bigger picture of managing version numbers needn't necessarily be part of your project, but in case you had plans in this direction, please see #54, where I wrote down some thoughts about how we could manage version numbers in a sane way.\n. > I think it would be prudent to add more tests. Any thoughts on adding support for a testing framework?\nAbsolutely!  Are you trying to make me fall in love with you or something, because I should warn you that I'm already married :wink:\nBut adding a testing framework should be done as part of a separate PR, right?\n. Cool, thanks for working on this!\nI like the idea a lot, and more than one user has stumbled over this problem so it will be a welcome feature.\nI was a bit surprised that you implemented this by asking the user to choose one of the merge bases interactively.  There are only very few git commands that have an interactive component, so this approach was unexpected.  It would also effectively make git-imerge unusable from a script.\nI think my preference would be for the program to emit an error message listing the merge bases (which you have already implemented) but then just abort.  And for there to be a new command-line option like --merge-base=SHA1 to let the user specify an explicit merge base at his next attempt.  It is a little bit more work for the user, but it is more consistent with the rest of the interface (and with that of Git itself).\n. Yes, you are absolutely right.  I ran into the same problem (and used the same workaround) just yesterday.\nI think the easiest way to implement this would be for git-imerge to create an empty commit by itself, as a placeholder.  Then the simplify/finish commands would have to look for these empty commits and handle them correctly (usually by omitting them from the simplified history).  git imerge continue should also recognize the situation (in-progress merge but clean working copy) and give the user a helpful message.\nIf you'd like to work on this, let me know and I'll help you get started.\n. @dleen: I don't have time this weekend but I'll try to help as soon as I can.\n. @dleen: Let me add some thoughts here, since there is already information here about the hoped-for feature.\nFirst of all, it seems to me that there are two cases where we have to deal with \"empty\" conflict resolutions:\n1.  The user recognizes that he wants to skip a commit and types a special command like git imerge skip.\n2.  The user types git imerge continue with no changes in the working copy but with an in-progress merge that hasn't been committed.  Normally we commit the user's git added changes for him, so in this case we should also commit the NOP merge.  We would have to recognize this situation--the special scratch refname is checked out, a merge is in progress, but there are no staged changes.  (It might be that we don't have to care whether there are staged changes and could just pass the --allow-empty argument all the time.)\nIn either case we would want to create an empty commit for the user as a placeholder in the incremental merge to keep it a nice grid.\nThe next step is that when simplifying such a merge into a rebase, we should also avoid carrying empty commits over into the result.  So there would have to be some logic in the simplify and finish subcommands to decide when one of the commits should be omitted.\n. PR #98 should fix the main part of this problem, though it doesn't also cause the empty commit to be omitted from the final result. (Which would probably be OK, but is not quite a no-brainer because doing so would cause the commit message to be lost.) As a workaround, I run git rebase --interactive after git imerge rebase in this situation if I need to get rid of empty commits.\n. Yes, that would be very nice.  Do you already have some code that you are willing to share with us?\nThe obvious place to wire in a test would be in automerge(), though I haven't thought through whether it is as simple as that.\nBut I think that building and/or running tests will make the test merges so expensive that other inefficiencies will become very annoying (as for example you observed in issue #59).  For example, presumably the build/test would be run during the test merges (e.g., the ones made during bisection), and then when autofilling the same merges are done (albeit from different parents).  But, as long as the tree SHA-1s match, there is no reason to run the same build/tests again.  For example, one could keep a record of trees that have tested OK, and if the same tree reappears, just assume that it is still OK.\n. Thanks for sharing the patch.\n\nI opted to only run make when performing test merges and not for autofilling\n\nInteresting; that was one of the things that I was wondering about.\nAnd if you are only running the build when performing test merges, then probably the same tree is not being tested multiple times (simply because trees shouldn't be seen more than once when testing).\nI don't expect to have time to work on this soon, so if somebody else is interested, by all means step up.  Aside from @johnkeeping's patch (or something like it), I guess we would need a new option for the user to use to specify to the test command.  The test command should probably be stored as a string to the git config and executed using the shell.  And we might want to handle test command failures different than merge conflicts; perhaps there should be two separate exceptions, both derived from AutomaticMergeFailed but that emit different error messages.\n. Yes, I think the command should be stored using git config.  (Of course by that I don't mean the user should have to type git config herself/himself!)\nIt would be wrong to store the command choice in the git repository in the imerge state blob, because (especially when we better support collaborations on imerges) it should not be possible for one user to cause another user to execute an arbitrary command (security risk).  And it could very well be that different users want to run different commands for testing, or that their differing local environments require the commands to be run differently.\nBut we can nevertheless store it in a part of the configuration specific to a particular imerge:\n[imerge \"myname\"]\n        testCommand = \"make -j16 test\"\nWe might also offer a default setting that is used if there is no setting for a particular imerge (because, realistically, the command will probably be the same for different imerge runs within the same repository):\n[imerge]\n        testCommand = \"make -j16 test\"\nIf imerge were the only program involved, I'd stop there.  But I've had a few ideas about how various commands could use tests.  For example, git bisect can use a test, pre-commit hooks might want to run tests, one or two scripts of my own sometimes want to run tests.  So I've been thinking that it would be nice to have a way to specify tests more abstractly within a repository and refer to them from different commands.  Think of something like\n[test \"build\"]\n        command = make -j8\n[test \"fresh\"]\n        # These commands would be run in sequence; all must succeed:\n        command = git clean -dfx\n        command = make configure\n        command = ./configure --prefix=$HOME\n        command = make -j8\n[test \"full\"]\n        command = ionice -c 3 make -j8 test\n[test]\n        default = build\n[imerge \"myname\"]\n        test = full\nMaybe there should even be a new command, git test, that runs tests that are configured in this way and memoizes the results (e.g., in git notes) for trees that have been tested.\n. Sorry for the delay, but these things require a good contiguous block of time to think about and I've been pretty busy with GSoC.\nLet me think out loud about what git-imerge is doing in your case.\nJust after the conflict at 4-2 has been resolved, the diagram looks like this:\n0123456\n0*******\n1*.?..-+\n2*.?.*??\n3*.?.???\n4*.?.???\n5*.?|???\n6*--+???\nThere are two \"blocker blocks\" on the frontier: a two-column block whose upper-left corner is at 3-2, and a two-row block at 4-1.  (Remember: the way a block is defined, its left and top edges must consist of known merges.)\nThe algorithm proceeds by picking one of these blocks and trying to complete its outline (its right and bottom edges).  It always works on the leftmost blocker block first, because that results in less jumping around and is thus hopefully less confusing for the user.  So it tries to fill the two-row block starting at 3-2 using bisection.  It finds that merge 4-5 is the first one in that block (i.e., in column 4) that still fails.  Now we have\n0123456\n0*******\n1*.?..-+\n2*.?.*??\n3*.?.|??\n4*.?.+??\n5*.?|#??\n6*--+???\nThen it proceeds to the other blocking block at 4-1.  You say you wish that it would first try 6-4, because in your scenario that merge would have succeeded.  But what it actually does is bisect column 5, determining that 5-4 is mergeable, and then proceed to 6-4.  So in your mind it should optimistically attempt 6-4, and only if that fails go back to 5-4.  In your case this would save one test merge, namely the one at 5-4.  Correct?\nIf I understand correctly, your suggestion doesn't actually have anything particular to do with filling after a blocker has been manually merged.  It could just as well be applied at the beginning of the incremental merge.  As an example, take the test merge that is run by t/test-unconflicted:\n```\n 012345678\n0*\n1........\n2........\n3........\n4........\n5*........\nAttempting automerge of 1-1...success.\nAttempting automerge of 1-4...success.\nAttempting automerge of 1-5...success.\nAttempting automerge of 8-5...success.\n```\nBy the way, this algorithm is located in MergeFrontier.compute_by_bisection().\nCurrently, git-imerge first tests 1-1 (i.e., on the pessimistic guess that maybe the whole block is unmergeable).  Then it bisects column 1, determining that the whole column is mergeable.  Then it jumps straight to 8-5, and thereby determines that the whole block is mergeable.\nIf you ask me, a better sequence of tests should be:\n1. Check 1-1, to see if the whole block is unmergeable.  If this merge fails, we're done.\n2. Check 8-5, to see if the whole block is mergeable.  If this merge succeeds, we're done.\n3. Check 1-5, to see if the whole first row is mergeable.  If this merge succeeds, then proceed to bisect the fifth row (but remembering that 8-5 is already known to fail).\n4. Otherwise, bisect the first column, remembering that 1-5 fails.\nDo you agree?  It is similar to the optimization that is already done here and here, and it shouldn't be that difficult to implement.\nIt is not certain that it will save work; it depends on how often the optimistic check of the bottom-right corner succeeds.  But I guess that you are right that it will win more often than lose.  And testing the bottom of the first column before starting the bisection of that column is probably also a win.\n. Looks reasonable; thanks!\n. The functions involved here are get_author_info() and commit_tree().\nThe first question is: what Python version is being used?  I assume it must be Python 2.x because otherwise the output of check_output() (which is already unicode) need never be encoded to a byte string.\nI have Python 2.7 and Python 3.3 handy so let's consider those:\n|  | Python 2.7 | Python 3.3 |\n| --- | --- | --- |\n| check_output() | returns unicode | returns unicode |\n| str(a[0]) | returns bytes | returns unicode |\n| env[k] = v on Linux/Mac | k and v must be bytes | k and v must be unicode; encoded/decoded to filesystemencoding using surrogateescape |\n| env[k] = v on Windows | k and v must be bytes | k and v must be unicode; passed directly to putenv as unicode |\nSo str() is failing, because the author name includes Unicode, but str() is only capable of decoding ASCII.  Somewhere between check_output() and os.environ we need an honest-to-goodness encoding of the string to PREFERRED_ENCODING.\nBut we don't want this encoding for Python 3.x, because its os.environ expects to work with Unicode strings.\nI just pushed up a branch issue-62 that I think will fix this problem.  Please test it and let me know if it works for you.\n. First of all, thanks for the patch and I'd like to apologize for not reacting to your old issue #40.\nI like the idea of your change, but I have a couple of comments:\n1.  It is inappropriate for get_boundaries() to call sys.exit().  Instead, it should raise an exception, and the callers should catch the exception and handle it appropriately.  I suggest something like\nclass NothingToDoError(Failure):\n       pass\nand then have those two cases raise this exception instead of a plain-old Failure.  (This change will also make the following change easier.)\n2.  I agree that git imerge merge and git imerge rebase should treat these scenarios as non-errors (essentially mimicking the behavior of git merge and git rebase, respectively).  But I'm less sure about the other callers, namely git imerge init and git imerge start.  If I run one of those commands, then it feels a little bit more like my intent is specifically to start an incremental merge as opposed to accomplish a merge/rebase.  From that point of view, failure to end up in an \"I am now doing an incremental merge\" state could be seen as an error.  So I suggest that you change the git imerge merge and git imerge rebase callers to catch NothingToDoError and ideally to output the exact same diagnostic messages as would git merge and git rebase.  But I would leave the other two callers unchanged, so that they continue to exit with error messages and error status.\nWhat do you think?\n. @dleen, I made a couple of tweaks on top of your commits, rebased to master (because I needed a Unicode fix to be able to test), and pushed the result to my repo as branch exit-code.  Please say if you are happy with the result.  If so, I will squash the commits together and commit the result with you as the author.\n. OK, I smashed a couple commits together with yours and merged the result to master.  Thanks!\n. Awesome that you are working on this!  I'll add some comments and thoughts to the diff.\n. I don't think you should use the word \"build\" in the UI and implementation, because in general people might want to run arbitrary tests before accepting a merge--maybe less than a full build, maybe more.  Why not just call them \"tests\" to preserve generality?\n. Whew, that was a lot of comments.  It's maybe a bit unfair of me to be so detailed after such a long time of inactivity.  That's because I have been wishing for and thinking about this feature even though I haven't gotten around to working on it.  So it's great that you have come along and obviously have more energy than I do :smiley:\nSo anyway, I hope that you find my comments helpful rather than discouraging!  It will be really nice to have this feature in git-imerge!\n. > @mhagger For what's it worth as an idle bystander - I'd love it if anyone gave such a detailed set of review notes on a pull request I made.\n@talios: Find an itch of your own to scratch, and you too can have a turn under the microscope :smiley:\n. @dleen, @talios: I'm really sorry to be such a bottleneck, and given that I'm about to go on vacation for a few weeks I'm afraid things are not likely to get better real soon.\nOne thing that I could suggest is that we try to spread the work around a bit more; for example, if you would each spend some time reviewing the other's PRs that would be really awesome. I'd love to make this more of a community project so that everybody doesn't have to wait on me.\n. Thanks for the nice cleanup!\nI just have a couple of formatting nits for consistency with existing code:\n-   Please use 'single-quotes' for strings (except \"\"\"triple-quoted-strings\"\"\")\n-   Please line up trailing parentheses of all kinds with the contents inside the parentheses; e.g.,\nhelp = (\n      'the name of the branch to which to store the result '\n      '(default is the value provided to \"init\" or \"start\" if any; '\n      'otherwise the name of the merge).   '\n      'If BRANCH already exists then it must be able to be '\n      'fast-forwarded to the result unless the --force option is '\n      'specified.'\n      )\nPlus I added a line comment to the patch.\nFeel free to force push a changed version of this commit rather than adding a fixup commit on top of it.\nThanks!\n. I tested this patch using the output from the following commands:\n./git-imerge --help\n./git-imerge start --help\n./git-imerge merge --help\n./git-imerge rebase --help\n./git-imerge continue --help\n./git-imerge finish --help\n./git-imerge diagram --help\n./git-imerge list --help\n./git-imerge init --help\n./git-imerge record --help\n./git-imerge autofill --help\n./git-imerge simplify --help\n./git-imerge remove --help\n./git-imerge reparent --help\nThere were a couple of discrepancies, so I fixed them with a followup patch.\nThanks for your work!\n. The \"autofilling\" steps correspond to merging single commits into a checked-out version of the working tree.  The merges themselves should be pretty trivial, assuming your project doesn't change the world in each commit.  So if these \"autofills\" take a second each, then it is probably because your source tree is so large that even trivial operations like \"git status\" take a long time.  Am I guessing correctly?\nIt is possible to do such merges directly in the index, which I would expect would speed them up considerably.  It hasn't been a pain point for me yet so I haven't implemented it, but I think it should be pretty straightforward.  I think it would involve the commands git read-tree -i -m --aggressive, git merge-index git-merge-one-file -a, git write-tree, and git commit-tree, but the trick is getting the details right of creating a temporary index (maybe not needed?), handling temporary files, and restoring everything to a sane state when done.\nIt would be helpful to a lot of people if you want to work on this.\n. I doubt that parallelizing the autofilling of a single block would bring more than a factor of two in speed, and even that would usually not be attained. Why?\nAutofilling (or in general the actions that happen when you type git imerge continue) involves two things:\n1. A series of binary searches to find the frontier. A single binary search is not very parallelizable, because you don't know which side to bisect next until you know the result of the current bisection. I suppose you could bisect both sides, basically doing three tests at a time (or more generally n tests at a time) to divide the range into n+1 subranges. But that costs n times as much work and only saves you lg((n+1)/2) bisection steps. So for example it would take 3x as much work at each step to half the bisection time, or 7x as much work to quarter it. So the benefit doesn't scale very well.\nIn fact, we are really doing a kind of 2D bisection, and it might be possible to gain another factor of at most 2 by working on both ends of the merge frontier simultaneously. (See this blog post for a description of the algorithm.)\nBut I don't think the bisection step is usually the bottleneck anyway, because it is typically a few times O(lg max(M,N))\n2. A series of merges to fill in the commits along the frontier. Each edge kindof has to be done one commit at a time, because each commit has its predecessor as parent. You could do the two edges of a block simultaneously then check that the apex commits agree, would gain you a factor of (M + N) / max(M,N), where M and N are the lengths of the two edges of the block. In the best case, this would be a factor of two. But more typically, the blocks are long and skinny, so (M + N) is not much larger than max(M,N).\nYou could compute an arbitrary number of edge merges simultaneously if you assume that merging two distant commits gives the same result as merging incrementally. You would actually compute the trees in parallel, then at the end create commits from the trees, stringing them together in the correct parent-child relationships.\nBut the assumption in the previous paragraph makes me a little bit nervous. It should usually be true (after all, it is the basis of the bisection algorithm that we use). But in practice it could easily be that there are differences. We currently check for these differences by doing the incremental merges along each edge then comparing the trees of the apex commits to make sure they are identical. But if we used this parallelization approach we wouldn't have nearly as strong a consistency check that the merges had mutually-consistent results.\nAnother place that could be parallelized would be when there are multiple blocks that need autofilling at the same time. Usually when there is a conflict, there are two blocks that need autofilling. There might be another factor (of at most two) to be gained by filling the two blocks at the same time. But this is also a bit awkward, because one of the blocks sits on top of the other, like this:\n```\n\n..|.....|\n..|-----+\n..|#?????\n..|??????\n..|??????\n--+??????\n```\nSo the block on the upper-right can't be autofilled until at least the first two commits on the vertical edge of the block on the left are computed. Also, if there is a conflict at the apex of the block on the left, then those two commits are called into question (though this is hopefully a rare occurrence).\nSo all in all I don't think autofilling can be parallized very well (I guess typically by a factor of less than two), unless you are willing to rely for correctness on the assumption written in italics above.\n. Another possible form of parallelism would be to continue autofilling in the background while the user is manually resolving conflicts. In the super slow scenarios described above, how long do the manual merges typically take in comparison to the autofills?\n. For the particular case when the rectangle is very long and narrow, I think we could get far better gains by changing filling strategy. For example, in the diagram below suppose that we are trying to rebase the vertical branch on top of the horizontal branch, and we find the conflict marked with #:\n```\n\n..........................................................................\n..........................................................................\n................#.........................................................\n..........................................................................\n..........................................................................\n..........................................................................\n```\nWe currently autofill two blocks by computing all of the commits shown as x here:\n```\n\n...............x.........................................................x\n...............xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n...............x#.........................................................\n...............x..........................................................\n...............x..........................................................\nxxxxxxxxxxxxxxxx..........................................................\n```\nNote that it is the two long, horizontal edges that are expensive. The vertical edges are relatively cheap because the vertical dimension is so much shorter than the horizontal.\nWhat if, instead, we computed the following:\n```\n\n...............xx.........................................................\n...............xx.........................................................\n...............x#.........................................................\n...............x..........................................................\n...............x..........................................................\n...............x..........................................................\n```\nThis is enough to let the user resolve the conflict at #. Then we could continue autofilling that column in the vertical direction:\n```\n\n...............xx.........................................................\n...............xx.........................................................\n...............x#.........................................................\n...............xx.........................................................\n...............xx.........................................................\n...............xx.........................................................\n```\nWe have effectively rebased the vertical branch over to the right, thereby moving past a commit on the horizontal branch that conflicted with it. We could continue from there by looking for the next conflict.\nThe advantage of this approach is that we only have to compute O(min(M,N)) commits, rather than O(M + N). If M and N have very different sizes, this is a dramatic improvement. A disadvantage is that we lose the apex consistency check that I mentioned earlier, though we could still do a consistency check between the incrementally computed apex commit and the apex commit computed directly.\nOf course this only works if our goal is to merge or to rebase the vertical branch on top of the horizontal branch. If our goal is to rebase the horizontal branch on top of the vertical branch, then there is no way around computing the merges on the bottom edge of the diagram. But even in this case, we could avoid computing additional horizontal lines in the diagram.\nThis approach seems very promising.\n. @kastiglione: the code that defines/implements the filling strategy is a bit scattered around, but there is a precedent for variations in strategy influenced by the --goal=GOAL and --manual options. Let me do a brain dump of code that is related to the strategy:\n- Block.auto_expand_frontier currently is the main point for deciding between strategies for auto-filling and auto-expanding the frontier.\n- MergeFrontier.map_known_frontier only considers a block to be within the frontier if its right and bottom edges are both known. This requirement would have to be relaxed in the case of the new strategy.\n- MergeFrontier.auto_expand probably doesn't care much about strategy itself, though it recurses into Block.auto_expand_frontier.\n- Block.auto_outline fills in the right and bottom edges of the block.\n- Block.auto_outline_frontier implements the usual default strategy.\n- MergeState.auto_complete_frontier probably also doesn't need to care about strategy.\n- MergeState.simplify_to_rebase has a consistency check (the if not force block) that I think would have to be skipped in the case of the new strategy.\nIdeally, as part of this change, the choice of strategy would be more decoupled from the rest of the classes. But that might be overkill.\nLet me know if you have any other questions.\n. @davidchisnall: The complication with your idea is that any skipped merge that supposedly should be conflict-free can actually turn out to conflict (for example, if a commit was reverted on one of the branches). In this case some backtracking is necessary. The backtracking can end up requiring the user to do a manual merge that should really be an ancestor of (A, B). It's not impossible, but the bookkeeping becomes pretty arduous, and it would sometimes require manual merges to be done out of order, which I think would be very confusing to users. Moreover, the details of how the user resolves the \"later\" conflict then later resolves the \"earlier\" conflict might differ in detail, resulting in more confusion.\nIf we were willing to lean more on these assumptions and accept some potentially very awkward effects when the assumptions are violated, then I suppose we could avoid a lot of intermediate commits. The problem would become \"given that we know the results of some set of (automatic and manual) merges, what additional (automatic and manual) merges do we have to do to make more progress toward the end goal?\" The requirements would be:\n\nA manual merge should only be requested after its two direct ancestors are available.\nAutomatic merges should always be done with the benefit of knowledge of any manual conflict resolutions that would be their ancestors. :point_left: This is the requirement that is impossible to fulfill in all backtracking cases without requiring the user to re-do merges that they have already done.\n\nLess ambitiously, it might make sense to omit some of the \"internal\" lines when outlining the merge frontier; e.g., instead of computing\n```\n\n.....|.....|\n.....|.....|\n.....|.....|\n.....|.....|\n.....|-----+\n.....|#?????\n.....|??????\n.....|??????\n*-----+??????\n```\none could save a few explicit merges by computing\n```\n\n...........|\n...........|\n...........|\n...........|\n.....+-----+\n.....|#?????\n.....|??????\n.....|??????\n*-----+??????\n```\nOn other fronts: I did some heavy refactoring over the last couple of days to prepare the ground for the rebase-style strategy described here; see branch polymorphic-frontiers. The new strategy isn't implemented yet but should be pretty easy now. As usual, the biggest hurdle is the lack of automated tests that could give confidence that the big refactoring hasn't broken anything. After the refactoring, it should be easier to play with other merge strategies, like those discussed above\u2014you basically just need to implement a new MergeFrontier class.\n. @BrendanAnnable: I don't have time to implement a --verbose option in the near future. Patches are welcome if you'd like to work on this yourself. Let me know if you need any pointers to get started.\nIf you are using Linux, you could run imerge under strace to see the Git commands that it is invoking and the timestamps when they were called:\nstrace -tt -e execve git imerge [...]\n\nUnder the assumption that git is consuming most of the time (which I think is almost certain), this could give you a good overview of where the time is going.\n. I agree that this is confusing. It is a historical artifact from the way git imerge start was originally implemented. I think the best way to solve this problem would be to add a command git imerge rebase-with-history analogous to git imerge rebase and git imerge merge.\n. Thanks for the patch, @ralfth.  Just last week I was thinking about how interacting with git-imerge feels harder than interacting with git merge because of the lack of completion support.\nWould you mind adding a sentence or two to README.rst advertising the presence of the completions file and maybe saying where to put the file / how to load it into your environment?\nI was surprised that the names of some of the functions in the file do not start with underscores.  I thought that was the convention?\nI'm looking forward to using this :circus_tent:\n. Thanks a lot!  I just merged your changes to master.\n:sparkling_heart:\n. If you continue to do memoization of the class constructor, it might make sense to split that into a separate commit to make each change more self-contained. But see my comment above where I express skepticism about whether this memoization is the correct approach. Another unfortunate side-effect of your memoization approach is that GitConfigStore cannot be used as a normal class; for example, if there were a reason to add static methods to the class, it would be impossible to access them.\nIn summary: I like the idea of having a class for interfacing with git config, but I think that the level of complication could be dialed back a notch or two unless/until we need it.\n. I wonder why git reset --merge didn't work. If anybody sees this again, it would be helpful to see the result of running that command manually, and the result of git status. Otherwise, it's hard to investigate this any further.\n. I sympathize with the problem. But it would be a shame to burden everybody with the cost of running Git three times to get this information, especially under Windows where it is so expensive to start a subprocess.\nSo I propose #73 as an alternative to your approach. Does it work for you?\nBy the way, do you know where this fails when using msysgit? Does their git.exe simply not output data past the first NUL character? (If so, it would be worth reporting a bug to that project, because I presume many scripts rely on this sort of thing.) Or is it that data are lost somewhere between git and subprocess.Popen()? Or is our implementation of check_output() incorrect?\n. Closed in favor of #73.\n. @ggascoigne: I'm sure this response is too late for you :disappointed:, but maybe it will be helpful for other people in the future.\nWhen you run git imerge continue, it looks at the HEAD commit to see if it can be incorporated into the current imerge. It does this by looking at its two parents and checking whether they are two commits that currently need manual merging.\nSo, suppose imerge left the repo in the following state:\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y---?\n    |\n    C\nIt expected you to fill in the merge at ? by merging X and Y directly, but instead (if I understand correctly) you did the merge via a helper commit H, maybe like:\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y-H-M\n    |\n    C\nAt this point git imerge continue fails for you, because one of the parents of your final merge M is the helper commit H, which is unknown to imerge. Therefore it doesn't recognize that M can be used as the merge between X and Y.\nFortunately, the solution isn't that difficult. You need to adjust the parents of M to be X and Y without changing its tree contents. You can do that using a handy-dandy command that I built into imerge even though it doesn't really fit there:\ngit reset --hard $(git imerge reparent X Y)\nThis essentially squashes commit H into M, making the repo look like\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y---M'\n    |\n    C\nNow git imerge continue should work.\nIt would be nice to make this easier. For example, we could check whether the HEAD commit has only two ancestors that are on the frontier of the merge and no ancestors that are not on the frontier. If so, we could check whether the merge of those two parents is needed, and if so, do essentially what I described above. But I would be a little bit worried that we were throwing away useful work done by the user. For example, what if you wrote a careful commit message for commit H explaining what you were changing and why it was necessary? You might be upset to have it discarded.\nOn an even deeper level, I wonder if your commit H would be useful for the continuation of the imerge? For example, when it comes time, in the next row, to fill in this ?:\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y-H-M\n    |   |   |\n    C---T---?\nit might actually be easier to first compute the merge of H and T, and then compute the merge of M and U:\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y-H-M\n    |   | | |\n    C---T-U-?\nI think this is a promising idea, though I'm not sure if it generalizes. It would be quite a lot of work to build it into git imerge, because a lot of the code assumes a \"rectangular grid\" topology of commits and merges.\n. I just added #79 to record the idea of supporting non-rectangular merge diagrams.\n. Fixes #71.\n. Yes, that would be helpful for some people. Is there somebody around who could summarize what would be needed to make git-imerge into a PyPI package (maybe even in the form of a PR)? Do we just need a setup.py file, or would we have to rearrange the sources? Every time I look into Python's packaging tools, it seems like there is no real consensus about best practices and my gumption ebbs away. Maybe that situation has changed.\n. Thanks for the idea. If somebody makes such a presentation, we could consider linking to it.\n. > I'm looking at my .git/config a few days after using git imerge serveral times and sometimes also resetting git-imerge runs. Now my .git/config contains several empty [imerge] sections.\nThis is a weakness of git config itself (which git-imerge uses to read/write configuration values). The extra empty sections don't actually do any harm, except to our sense of neatness.\n\nIs .git/config really the best place for state info?\n\nI don't see why not. Most of the state info is stored as blob objects in the Git repository itself. The only state that is stored in config is the name of the imerge that is currently the one being worked on, which is needed to figure out the name of the reference that contains the rest of the information for that imerge.\nIf you have a concrete idea for improvement, please reopen this bug and let us know.\n. But the user's choice of which imerge to work on is a configuration setting--it's the user's choice of which imerge s/he wants to work on. The fact that this choice is made as a side effect of other commands doesn't change that fact.\nI wouldn't want to invent an extra file just to hold that one little bit of information.\nWhat I can imagine would be not to set imerge.default so eagerly. After all, if there is only a single imerge in progress (by far the most common case), it is not really useful. Even if the user has two imerges going at once, it is often clear which one is intended:\n- From the --name=NAME option\n- From the name of the current branch (if it is one of the temporary names that imerge sets up).\nWe could add a command git imerge set-default NAME to let the user choose a default branch explicitly (or just let the user run git config imerge.default NAME), and otherwise leave that setting alone.\n. Hi @waldyrious!\n\n[...] I was wondering whether creating this kind of helper commits could be automatically managed by git-imerge, i.e.: whenever git-imerge finds a conflict, it could be that the commits aren't modular enough, so what if it tried splitting the involved commits using the same splitting method used in git add -p? Maybe then the merge could proceed automatically, rather than the user explicitly creating commit H as in your example above (unless I misunderstood and you meant the commit would be created automatically?).\n\nIt is approximately true that a merge only fails if there is a conflict within a single hunk of the diff. Since git add -p works hunk by hunk, it wouldn't be able to subdivide the conflict in any useful way.\n\nAnother question I had was whether using a different merge algorithm (Patience, Diff Match and Patch, maybe others?) could be used as an attempt to automatically resolve conflicts that the default diff algorithm fails to deal with. But this is probably worth a separate issue, if at all (let me know).\n\ngit-imerge doesn't actually do any merges or resolve any conflicts itself. It relies on git merge to do so. So to choose a different merge algorithm, we would basically need to pass the corresponding options down to git merge, I think. It seems like a reasonable thing to implement, though it is pretty much unrelated to this issue. The main question is what the user interface should look like. Would the user choose a different merge algorithm as part of their permanent config, or at the start of an imerge session, or for one particular micromerge, or ...?\nI don't use other merge strategies, so this wouldn't be high on my own priority list. But patches are welcome :-)\n. No feedback (@johnkeeping?), but I've been using this version for a while and haven't seen any problems. So I just force-pushed a signed-off version and will merge.\n. Unfortunately I cannot reproduce this error with the current value of the branches that you mentioned. Do you happen to know what the branches' SHA-1s were at the time of the problem? Was the problem repeatable?\n. @Stunner: I am unable to reproduce the problem, even using those exact commits.\nCan you tell me exactly what versions of git-imerge, Git, and what OS you are using? Also the output of running git config --list in that repository (but scrub any passwords if present).\nIf you are not using the most recent version of git-imerge or are using an older Git version, it might be worth an attempt with updated software.\nIt is very curious that the failure point is not reproducible. I don't think that any information should carry over from one attempt to run git imerge merge and the next. Theoretically git rerere could do so, but I think git-imerge always turns it off before running git. (If you haven't disabled rerere, that would be worth an experiment: before running imerge, run\ngit config rerere.enabled false\nand see if the error either goes away or becomes more consistently reproducible.)\nThe commits in question seem to involve a lot of file creation and deletion. Perhaps filename case normalization is turned on and is confusing things (e.g., if you are running this on OSX)?\n. Given that our bash completion relies on Git's bash completion already being installed, I'd worry a little bit that this would install broken software on the user's system. What happens if we go through with this installation but Git's isn't installed? Does it fail gracefully, or (for example) does it make the user's shell unusable?\n@ralfth, do you have an opinion about this PR?\n. The subcommands can all be listed via\ngit-imerge --help\nAnd more help about each subcommand is available via git imerge SUBCOMMAND --help; for example,\n```\n$ git imerge autofill --help\nusage: git-imerge autofill [-h] [--name NAME]\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  name of incremental merge to autofill\n```\nSo I guess you are asking for documentation for these commands in the main README file?\nRegarding testing: there are some crude scripts for creating a test repository and running git-imerge against it:\n- t/create-test-repo -- create a test repository under t/tmp\n- t/test-unconflicted -- run a couple of non-conflicting incremental merges against the temporary repository\n- t/test-conflicted -- run a couple of conflicting incremental merges against the temporary repository\nThese are not automated tests in the sense that they don't check that the results are correct (you need to use your eyeballs for that). But at least they exercise part of the code and often flush out silly programming errors.\n. Thanks! :sparkles: \n. Thanks @SebKuzminsky!\n. @ralfth, could I get your opinion on this? I have no experience writing bash completion scripts.\n. > @mhagger The changes look good to me.\nThanks for the patch @rhunter, and thanks for the review @ralfth :sparkles:\n. Thanks for the bug report.\nDid this happen in a public repository that I could clone to try to reproduce the problem? If so, please let us know exactly what you had to run to trigger the error.\n. @blitz, would you please check whether #91 fixes the problem that you experienced? Thanks!\n. > The last line then repeats a lot of times. I've spent about a week and a half of CPU time on this merge so far [...]\n\nI'm not sure if it's related, but I ran a git gc last night because the individual merges were taking around 20 seconds (now they're down to 1-2 seconds) and at that speed it would have taken about six months to finish the merge.\n\nThat's amazing (and scary!) I'm curious to what extent your merge is so slow simply because it is gigantic, vs. whether you are hitting a pathological case. I suspect the latter.\nThese UnexpectedMergeFailure exceptions are meant to be just that, unexpected. They occur when it is possible to merge a whole series of commits together, but then when it tries to merge the commits one by one, there is a failure somewhere along the way. In other words, your merge is violating this approximate assumption.\nThe backtracking that you see is git-imerge's way of recovering. Because this is expected to be an unusual occurrence, this code path is not written in a way that would be appropriate if it were expected that the assumption would be violated not a few times, but more than ~1000 times.\nThe repeated backtracking that you see, I believe, is the very first step of outlining a block of commits that are all expected to be doable. This is the merge of one commit from one side of the block with all of the commits on the other side of the block. When that merge unexpectedly fails, it takes only one step backwards and tries again. It is quite possible that this is making the overall algorithm regress to O(N\u00b2) or something.\nYour \"ugly\" fix is pretty much what my first impulse would have been (though probably with a custom exception type built for this purpose). Feel free to write it up as a PR. But additionally, I hypothesize that an algorithmic improvement could reduce your pain dramatically. For example, MergeFrontier.remove_failure could do a bisection step to more quickly find a less ambitious merge that succeeds.\nI'm really curious to hear whether your merge was/will be successful eventually.\n. Thanks for the patch! :sparkles:\nI agree that\ngit imerge start --goal=rebase --first-parent BRANCH\nis confusing, because it is backwards to the direction of git rebase; it rebases BRANCH on top of the current branch rather than the other way around.\nBut doesn't\ngit imerge rebase BRANCH\ndo the thing that you want (i.e., equivalent to git rebase BRANCH)? Personally, I always use the latter and never the former. If you help me understand the use case it will be easier to evaluate your PR.\nThanks!\n. @bozzzzo: Thanks for the explanation. That makes sense and I can see that it would be a useful feature.\nRegarding the patch itself:\n1. It is an awful lot of copy-paste. I think it makes sense to extract some functions first to reduce the amount of duplication. I just pushed a branch simplify-to-path in PR #90 that does so. If I then merge that branch into yours, the result is my rebase-reversed branch (though I haven't tested it at all).\n2. The new feature would need documentation in README.rst.\n3. There are some consistency checks done for rebases (for example, here and here which I think would also be needed for rebase-reversed.\n4. Given that --goal=rebase is actually kindof reversed relative to what git rebase does, I wonder whether naming this feature rebase-reversed will introduce even more confusion. I wonder if a better name might make this clearer. At the same time we might even want to deprecate --goal=rebase and give that operation a more intuitive name, too.\n. Note that \"incremental git revert\" is implemented in PR #100. It would be great if people would cautiously test it.\n@waldyrious: I just wrote up the idea \"break off an incremental merge\" in more detail as issue #101.\n. I think this PR was submitted erroneously. It contains nothing that is not already in master.\n. Thanks for the patches. They makes sense.\nBut what about the uninstall rule? Shouldn't that also honor DESTDIR? I understand it's not important for RPMs, which can uninstall themselves, but it seems like it would be important for somebody who ran make install with the DESTDIR option and later wanted to uninstall. Or at least it wouldn't hurt...\n. @RichardsonAlex: Sorry, I didn't notice that you pushed the \"uninstall\" patch to this branch. It looks good, thanks for your work!\n. I'm closing this as redundant with #94. If that is not correct, feel free to reopen.\n. A nice improvement; thanks! :sparkles:\n. Sorry @waldyrious, I missed the notification for your question.\nYou're right; --goal is only needed on the git imerge finish command if you change your mind about the goal while you are working.\nFeel free to reopen this issue if you have any followup questions.\n. > Otherwise, if you'd give me some pointers about which files to edit and how, I could take a stab at doing this.\nThat would be great! The README is in README.rst (in reStructuredText format, but it's pretty self-explanatory). The help text is embedded in git-imerge, for example here, here, and here.\nIf you are ambitious, you might consider providing a little bit more explanation of these operations such as discussed here and here.\n. There is currently no support for redoing a merge that was done incorrectly the first time. I think it should be sufficient to delete any references named refs/imerge/<name>/{auto,manual}/<I>-<J> where I and J are integers greater than or equal to the (I,J) of the commit that you want to redo, then run git imerge continue. But there is also a blockers field in the blob pointed at by refs/imerge/<name>/state that might cause problems in some situations, and there might be other loose ends that I haven't thought of. Try it and see, and let us know what you find out.\nIt would be nice to have a command to do this, but I don't know of anybody working on it.\nThe remove command removes the entire imerge. That's not what you want.\n. Yeah, a release is long overdue. Let me try to get #104 merged and then I'll add a tag. (If you have an idea of how bash completion works internally or even if you don't mind doing some testing, your help reviewing that PR would be welcome since I have no idea what I'm doing in that department :wink:.)\n. I just created a release v1.0.0 (note that the tag has a leading v, unlike the tag for release 0.7.0).\n. Thanks, @ralfth :sparkles:\n. You can kindof tell how big the current autofill will be by looking at the test merges that it did just before it started autofilling. But I agree that it would be nice for imerge to display estimated progress itself.\n. If you check out some other branch, delete imerge's temporary branch (the name looks something like refs/heads/imerge/$NAME), and type git-imerge continue, you should be able to continue where you left off. Be sure to delete the reference under refs/heads/, not any references under refs/imerge/!\nIt would obviously be nice if this were easier.\n. The way I read this issue is that @mulle-nat had a problem with a single micromerge and wanted to start the micromerge over without aborting the overall imerge. Whereas #101 is about aborting the whole imerge while preserving progress that has been made so far in the form of, for example, a rebase of the branch to some commit that is nearer, but not all of the way to, the other branch tip.\n. @USBhost: Thanks for the report. parser.error() simply wasn't being called correctly. I just pushed a fix as #108. Would you be able to check this version in the situation where you experienced the error, just to make sure that I didn't make another boneheaded mistake, before I merge it?\n. @USBhost: thanks for fixing my fix. I just pushed your changes to #108 and merged that PR.\nI misunderstood this bug report to be about the crash due to the problems fixed in #108. In fact, your problem seems to be that git-imerge legitimately can't handle merging/rebasing from one branch point to another if those commits are not connected by a chain of --first-parent ancestry. This is currently a limitation of git-imerge that could probably be relaxed under some circumstances. I'll reopen this issue as an enhancement request.\n. Also, if I understand correctly, this apparently worked in earlier versions of git-imerge.\nI don't have much time to follow up on this now, I'm afraid.\n. There is another good description of this problem, with an ASCII-art diagram even,  in https://github.com/mhagger/git-imerge/issues/110#issue-179482601.\n. I can't stand having users forced to use old versions due to a regression :broken_heart:, so I tried to fix this problem after all. I think that #111 fixes this regression and also makes git-imerge applicable in many more situations that it didn't handle correctly even before e8da000b925562cc34941079cd74fd4a1ae51de1.\nThe problem is that my time is really tight right now, so I'm going to need your help. I did a tiny bit of manual testing, but this is an important spot in the code that is used for all imerges (not only in the case that the merge-base is not a first-parent ancestor of the branch tips). If somebody could do more careful testing that #111 hasn't broken anything, or even better, improve the test suite to verify the current code and catch any similar new regressions in the future, that would be a great help towards getting this fix merged and in general improving the quality of git-imerge. Anyone? :pray:\n. I'm no pygit2 expert, but I don't know of a reason that it couldn't be used instead of the Git command line client. But the installation complications pointed out by orao will certainly be a headache for users, especially Windows users.\nIt might not be crazy to support both backends by creating a virtual interface to the Git repository, and choosing either the Git or the libgit2 version at runtime. That would allow anybody to try out the script easily, then if performance is a problem and the user is competent to do so, they can install libgit2 and the Python bindings to speed things up.\nSuch a virtual interface might also be useful for testing git-imerge. One could create a mock Git repository for git-imerge to interact with. The mock could simulate scenarios that are awkward and fiddly to construct in a real Git repository, such as conflicts in specified patterns, or merges that first appear to succeed, but then conflict when done incrementally.\nBut I don't expect to have time to work on any of this in the near future.\n. Thanks for your clear description (and ASCII-art, my favorite!) of the problem and how it arises in a common workflow. This is a dup of #107, so let's continue discussion there.\n. @orao: I reused the diagram in a confusing way.\nIn the first example, the goal is to merge feature into master, in which case the merge base is indeed E.\nIn the second example, I was referring specifically to calling linear_ancestry(A, Y, \u2026), which might be useful if merging from branch to master in a scenario like this:\no---o---o---o---o---o---o          master\n     \\\n      A---B---C---D---E\n           \\           \\\n            V---W---X---M---Y      branch\nIn this case, linear_ancestry(A, Y, \u2026) is called as part of determining which commits need to appear on the vertical axis of the incremental merge.\nI hope that is clearer!\n. I wish we had automated tests for this stuff, but I've been using this branch for a while, and other people have reported success with it in situations where master fails, so I'm going to merge it.\n. git imerge --help is intercepted by the git executable (i.e., git-imerge itself never runs). I believe that git then looks for and outputs a manpage called git-imerge. Since there is no such manpage, it doesn't work.\ngit-imerge --help invokes the git-imerge script itself, which asks argparse to generate help output based on the command-line options and their help strings, plus the file comment __doc__.\nI don't think this is easy to fix, short of somebody writing a manpage for git-imerge. This, in turn, might be done by getting argparse to emit its output in TROFF format. I did something similar for the cvs2svn project, but haven't had time to do that yet here. Maybe argparse supports a standard way of doing this?\n. > Do you know that -h works even when --help does not?\nI guess the git launcher hijacks --help but not -h.\n. It would be a lot easier to diagnose your problem with access to your repository. Is it publicly available? If not, could you anonymize it using git fast-export --anonymize and make the anonymized repository available? If so, please let us know where to find the repo and exactly what git imerge command line to use to provoke the problem.\nI don't have any idea if it would help, but have you tried running this using branch loosen-first-parent-rule from PR #111?\n. No response \u2192 closing issue. Feel free to reopen if you can provide more information.\n. It sounds like you were using imerge correctly. Yes, there must have been a byte \\xe2 somewhere in the commit that it was trying to process, probably in either the log message or in the author/committer name. It appears that imerge was trying to encode this use the ascii encoding. Since \\xe2 is not a valid ASCII character, :boom:\nSo one question is the one you posed: \"Why doesn't imerge handle data as binary?\" It probably should, though it's a pain to do so in Python, especially while retaining compatibility between Python 2 and Python 3. So that might be a nice long-term goal but is unlikely to happen soon.\nA simpler question, and one that might solve your current difficulties, is \"Why is imerge using the ascii encoding on your system?\" This comes from PREFERRED_ENCODING, which comes from the standard Python library function locale.getpreferredencoding(). This function accesses your environment to guess what locale to use.\nSince the most common encoding used in Git metadata is UTF-8, I suggest that you try running the last command again as follows:\nexport LANG=en_US.utf8\ngit imerge finish\nand see if that helps. (If not, see what you have to do on your system to affect the locale.)\nAlternatively, you can edit the git-imerge script by hand to set PREFERRED_ENCODING near the top of the script manually, for example like\nPREFERRED_ENCODING = 'UTF-8'\nIf none of that helps, please tell us what repository you are working on and what SHA-1 you are trying to merge so that we can reproduce the problem.\n. @GeirGrusom: Could you try your failing merge with the branch from this PR: #111? I think it will fix your problem, but I'm having trouble getting people to test it so that I can merge it confidently.\n. Thanks for pinging me; otherwise it can take a while for me to notice such notifications.\n@greened: Thanks for the contribution! It was not my intention to change the authorship of commits during rebase-with-history simplification; that was an oversight.\nI'd prefer to put in your fix without the new command-line option. Would you mind creating a new PR with only the fix?\n. What do you mean by \"stop the merge where it is right now\"?\nIf you want to put the merge on ice and come back to it later, then you don't have to do anything special. Just switch to another branch, do you work, and whenever you want to continue the imerge, type git imerge continue. (Of course you will lose any unstaged changes on the current micromerge.)\nIf you want to stop the imerge and end up in a state where whatever part of the merge you have done is kept (e.g., the branch merged with only part of master or the branch rebased not all the way to the other branch's tip but rather to some intermediate commit on the other branch), that feature wish is the subject of issue #101, and it is not yet implemented.\nIf your goal is a merge, you could do this manually without a huge amount of difficulty by using git imerge reparent to make the commit whose contents represent the merge you want have the correct parents. You would first switch to the commit with the desired tree, then run something like\ngit checkout -b my-new-merge-commit $(git imerge reparent $PARENT1 $PARENT2)\n\nthen probably adjust the commit message using git commit --amend.\nIf your goal is a rebase, you could still probably finish it manually in its partial state if you are desperate, but it would involve a lot of confusing bookkeeping.\n. > It would be nice to have a git imerge abort command that did this automatically.\nYes, that would be very nice.\n\nI could take a stab at this, but I'd need some pointers first (namely, how to get the branch the user was on before starting git-imerge).\n\n\nThe branch name would have to be determined when the imerge is started by calling get_head_refname(short=True). Note that this function returns None if the user is on a detached HEAD. (What should happen if the user runs git imerge abort after having been on a detached HEAD? Maybe nothing? Maybe restore to the SHA-1 that they were on (if it still exists)?)\nThe branch name would have to be recorded in MergeRecord.\nIt would have to be added to the state dict by MergeRecord.save() so that it can be remembered across invocations, and read back in by MergeRecord.read(). This change should probably be accompanied by an increment of STATE_VERSION[2].\n\ngit imerge abort should only switch back to the starting branch if it still exists, if the working tree is clean, and perhaps only if the temporary branch is currently checked out. The code in MergeState.remove() might give you some ideas about this. For backwards compatibility, the code should deal gracefully with the situation that the starting branch wasn't recorded in the state.\n. Merged. Thanks!\n. The mojibake that you pasted, D\u00c3\u00bcring, looks like the UTF-8 encoding of \u00fc. Can you check somehow exactly what characters are in the commit? For example, run\ngit cat-file commit $SHA1 \n\n\nand view the output in a hex editor or something. Try doing the same for one of the other commits, where your name appears correctly.\nWhat is the preferred encoding on your system? On mine it is UTF-8:\n$ python -c 'import locale; print locale.getpreferredencoding()'\nUTF-8\n. \u00fc in cp1252 is 0xFC; in Unicode it is the same (U+00FC).\nThe UTF-8 encoding of U+00FC is 0xC3 0xBC. In cp1252 those bytes represent \u00c3\u00bc, the characters that you saw.\n\u00c3\u00bc, in turn, are U+00C3 U+00BC in Unicode. Those two characters are encoded in UTF-8 as 0xC3 0x83 0xC2 0xBC, which are the bytes in the faulty commit.\nSo my guess is that Git is respecting the mingw64 configuration and outputting the commit metadata in UTF-8. But Python is reading the data under the assumption that it is cp1252, converting the \u00fc to two Unicode code points internally, and outputting them as four bytes of UTF-8. When you view the commit, Git assumes that the data are already in UTF-8 so it passes it through unchanged.\nI'm not an expert on encoding issues and know even less about encodings on Windows, but it seems to me that you want to tell Python to use UTF-8. One crude way to do this would be to set\nPREFERRED_ENCODING = 'utf8'\n\nnear the top of the git-imerge script. Does that help?\n. Thanks for the suggestion.\nThe main point of the README is to explain git-imerge and teach people how to use it. I don't think the main body of the README is a good place for \"look, somebody mentioned git-imerge\" links. Since this shout-out is not very pedagogical, I don't think it belongs here in the text. I wouldn't want people who are trying to learn about how to use git-imerge to click on it, because it wouldn't have value to them.\nArguably the GitMinutes link falls in the same category. I haven't listened to it for a while, but I don't recall it being a very good resource for learning how to use git-imerge.\nBy contrast, @patrickmckenna's talk from Git Merge 2016 would be a good pedagogical link. But I can't find it online so maybe it wasn't recorded.\nInstead, maybe it would make sense to add a new \"Other git-imerge links\" section where we could collect significant mentions of git-imerge from around the web.\nBy the way, I think the way you have defined the link doesn't actually expose it to the reader unless there is a reference to it from the text.\n. I'm having trouble reading your diagram. Is this equivalent?\nmaster:  0-1-2-3-4-6-7-- 8--9-10---11\n          \\           \\ /       \\ /\nmerge-1    \\           x         y\n            \\         /         /\nrelease-1:   a---b---c---------d\nIf I understand correctly, you want to use imerge to do the merge at y, right?\nThe merge base for this merge is c. (See git-merge-base(1) for the definition of the merge base.) All of the changes that were introduced by a and b are already in 8 via the merge of x into master. So at y there should be no merge conflicts that involve the changes that were made in a and b.\nBut all of the changes made in 0..7 appear to the merge as if they were made in commit x, because that is the first commit that is a descendant of c that includes those changes.\nI think that if you had done a \"merge with history\" (i.e., retained the full incremental merge in your history), then you would have some additional context for the second imerge. Your history would look roughly like (I'm omitting some commits on master):\nmaster:  0------1------2-------7---------------8--9-10---11\n          \\                     \\             /       \\ /\nmerge-1    \\                     a'          /         y\n            \\                     \\         /         /\n             \\                     b'      /         /\n              \\      other          \\     /         /\n               \\                     c'  /         /\n                \\       stuff         \\ /         /\n         \\                 x         /\n                  \\        in         /         /\n                   \\                 7'        /\n                    \\        here   /         /\n                     \\             2'        /\n                      \\           /         /\n                       \\         1'        /\n                        \\       /         /\nrelease-1:               a--b--c---------d\nSo you would have to merge the changes from d with the commits 1', 2', 7', x, 8, 9, and 10, which is more or less the minimum that you could hope for. But retaining all that extra parentage information would be quite cumbersome given the current state of tooling.\nI hope that helps!\n. Yes, it is a very good idea. Are you willing to work on it? I'd be happy to help you get started.\n. Regarding your other points:\n1. According to PEP 394, there should be an executable called python2 that runs a Python interpreter that is definitely 2.x.  Obviously this newish convention is still far from universal, but I decided to use it as the default for this reason.  I agree with you completely that we would need some kind of build/install procedure that rewrites the script with the correct shebang for the system it is running on.\n2. The test harness is still needed but I think my test-dirs branch is a start towards handling the temporary directory more sanely.\n. I just merged test-dirs to master, as I believe it will cause people less problems than the status quo ante.\nI just opened a new issue #4, \"We need some kind of build/install infrastructure\".\nIf you are satisfied, please close this issue.\n. Good idea (at least until we have a real build/install system).  Thanks!\n. It's great that you found this, because I haven't yet figured out how to test the unexpected failure / unexpected success codepaths.  (I think it might involve some libification and then the use of a mock repo object.)\nI see the cause of the problem in your case.  remove_failure() is not doing the right thing.  If there is a conflict like this:\n```\n\n......\n.....X\n*......\n```\nthen it should attempt to split the conflicting block into two blocks (one of which might be empty) like this:\n*****||\n-----++\n*....|X\n-----+.\nbut instead it is doing this:\n*****|*\n*----+.\n*.....X\n*......\nwhich is nonsense.  In your case the single block that it is producing is empty, so resolving it doesn't make any progress; hence the infinite loop.\nI'll work on this; I think it shouldn't be hard to fix (hopefully within the next hour or so).  Don't throw away your in-progress merge, because it should be possible to continue it with the fixed version of the software.  (And it would be a check that the fix really helped!)\n[Edit: middle diagram just fixed.]\n. I just pushed a change to master that I think will fix your problem.  Please let me know if it works!\n. Thanks for testing!\nI also pushed a change to the error message for \"unexpected failure\".\n. Sorry I see you based your work on some commits that I accidentally created with a bogus author (due to test suite misuse).  I'll rebase your commit on the fixed commit when the time comes.\n. Yes, this sounds like a bug.  But it's not clear what should happen, at least not in all scenarios...\nWhat is the \"original author/committer/date\" of a merge commit?  They have two parents, so it is ambiguous.  AFAIK Git sets the author and committer of a merge commit to the person doing the merging, not to those of either of the parent commits.\nIn the special case that the incremental merge is being simplified into a rebase, then I guess it would be reasonable to take the GIT_AUTHOR_* information from the old version of the commit.  (This must be the case that you are talking about.)  But shouldn't the GIT_COMMITTER_* information be set to the user doing the imerge?\nWhat should happen if you simplify the incremental merge into a simple merge?  Then I think the author and committer should be the person doing the imerging.  Do you agree?\nWhat if you simplify it into a rebase-with-history?  This is kindof a middle ground because the old commits are kept (thus preserving the old author and committer info).  I can see arguments for either approach--copying the original author info vs. setting the new author info to the person doing the imerge.  What do you think?\n. \"git rebase\" uses the author information of the original commit, but sets the committer information to that of the person doing the rebase.  I think we should do the same thing for simplify-to-rebase.\n. I just merged your fix.  Thanks!\nThe behavior of \"--goal=rebase-with-history\" has not been changed--the authorship is assigned to the person running \"git-imerge simplify\".  I can see both sides of the argument on this one.  I think that because rebase-with-history preserves the original author's commits, not copying the authorship info has the effect that the person who did the imerge is also recorded somewhere (assuming it was a single person, that is!).\nIt could be made an option, I suppose...\n. Would --date=raw fix the time zone problem?\n. First of all, this is awesome!  I do have a few nits but the overall idea and implementation are excellent.\n. I made some comments on the individual commits.  Other than those, it looks good.\nAside: I'm not sure that the coloring of \"unblocked\" merges is 100% correct.  But currently git-imerge doesn't let you access these intermediate states, so there's no point worrying about it until it can be tested more easily.\nThe colors really make the diagrams easier to read, and the integer-encoded diagrams will be easy to use for other output purposes.  Thanks!\n. Merged and pushed, thanks!\n. Very cool.\nI'm trying to imagine how the browser would find the CSS file.  Would it be more convenient to (optionally?) embed the CSS in the HTML document?\nYou've also got me thinking about even more hijinx like having Python open a mini webserver that allows the user to click on a blocker to choose which merge conflict to resolve next, mouseovers to show commit messages of the original commits, etc :-)\n. I see that you pushed some fixup commits, but I will still wait for your \"go\" before I do any merging.\n. Merged and pushed.  Thanks!\n. Thanks for the patch!  I just merged it to master, after adding some comments above the lines you changed to prevent somebody with a short memory (e.g., me) from changing the commands back.\nIf you're using git-imerge in real life, please let me know how it is working for you!\n. On 07/14/2013 02:45 PM, Jonathan del Strother wrote:\n\nHi there - I have my git hooks set up to run ctags in the background on\npost-commit, post-checkout, and post-merge. git-imerge causes my\ncomputer to grind to a halt as 30 different ctag processes are kicked off.\nAny thoughts on a better way of handling this sort of behaviour? git\ndoesn't give a builtin way of suppressing hooks, right? Is there any\nprecedent for setting an environment variable along the lines of\n|RUNNING_AUTOMATED_CHECKOUTS=1| that hook scripts should look for?\n\nI don't know of a way to make git skip all hook scripts.  But even if\nthere were, it wouldn't be very flexible; perhaps one would want to run\nsome hook scripts but not others.\nSo it would probably make more sense for git-imerge to record what it is\ndoing in the environment somehow; e.g., set an environment variable\ndescribing what git-imerge is currently doing, like\nGIT_IMERGE_STATE=(automerge|autofill|usermerge|simplify|...)\n(It would take some thought to decide on the exact list of states.)\nThen the hook scripts could test the variable and perhaps decide to just\nexit without doing anything.\nWould that be convenient enough?\nWe should also audit where git-imerge is using plumbing commands (which,\nI think, often do not call hook scripts) vs. porcelain commands (which\ndo).  There might be cases where we should switch the choice plumbing ->\nporcelain or vice versa to get the hook script behavior that we want, or\npossibly execute the hook scripts directly.\nMichael\n\nMichael Haggerty\nmhagger@alum.mit.edu\nhttp://softwareswirl.blogspot.com/\n. As a simple first step, in commit 04419db0fb765eced357f39856bf52666b2c41eb I have git-imerge set environment variable GIT_IMERGE=1 while it is running.  Your hook scripts can interrogate that value to decide whether they should run in \"cheap\" mode.  Someday it would be nice to make the value of GIT_IMERGE reflect exactly what git-imerge is doing at the time (maybe you want to work on this?)\n. python2 is there because git-imerge requires Python version 2.x as opposed to Python 3.x (or, God forbid, Python 1.x).  According to PEP 394, it is recommended that some Python 2.x interpreter be installed in PATH under the name \"python2\".  I understand that this is not yet universal practice, but on the other hand there are already systems where \"python\" is a Python version 3.x interpreter, so that option is also not universally portable.\nBy the way, I think that any Python interpreter version 2.5 <= version < 3.0 should be fine for git-imerge.\n. @myint, that's really cool!  I hadn't yet had the energy to get any of my projects running under Python3.  It's a lot less nasty than I would have feared.\nI just pushed some commits to master that incorporate some of the changes from your first commit. The remainder of your changes (i.e., after the already-merged changes have been removed) are in my repo under branch myint/python3.  But before I merge the rest, I would like to understand the ramifications a little bit better.\nWhat is the situation on the Mac OSX?  (Is that is what you are using?)  Is Python 2.x unavailable, or is it available, but just not under the name python2?  In other words, are these changes needed to make the script usable under Mac OSX at all, or just to avoid having to edit the shebang line?\n(If the latter, then there are other ways to make sure that a Python 2.x interpreter is used to run the script.  Either the script can be given a Shell preamble that chooses the correct Python interpreter, or we could add an install script that overwrites the shebang line with the one correct for the system that it is running on.  Not that python3 compatibility is something bad, but reducing the python2 compatibility might still be inconvenient for some users.)\nBefore these changes, I think that git-imerge would have worked under Python versions 2.5 <= version < 3.0 (though I haven't actually tested it against the older versions).  The changes I just pushed now prevent it from running under 2.5 (because it doesn't have the next() built-in function).  With the rest of your changes, what versions of Python should it run under?  Only 2.7 and 3.3?  Assuming that is the case, we should probably verify that the important recent OSs make one of these Python versions available.\nThanks again for your contribution!\n. @myint: Thanks for the additional info.  I was confused; I thought that \"except E as T\" syntax wasn't added until Python 2.7.  Now I see that it was backported to Python 2.6.1.\nSo if we merge your changes, I think our Python version requirement would become\n(2.6.1 <= version < 3.0) or (3.3 <= version)\n(that is, unless something else that you are using was introduced even later than 2.6.1).  I think we can live with that.  I just merged your change (though the commit identities have changed, so you might want to pull from me again).\nThanks!\n. @myint: I was going by the language reference for 2.6 vs 2.6.1.  The as syntax wasn't mentioned until 2.6.1.  But given that it is mentioned in the changelog for 2.6, I assume that it was implemented then and they just didn't get around to updating the language reference in time for the release.\nI'll fix the README.\n. The issue is more that I haven't had the time to think about the ramifications of merges with multiple merge bases, so I just implemented the case that is relatively obvious.\n\"git merge\" itself, when using the default \"recursive\" strategy does something less trivial than just picking one of the merge bases:\n\nWhen there is more than one common ancestor that can be used for 3-way merge, it creates\na merged tree of the common ancestors and uses that as the reference tree for the 3-way\nmerge.  This has been reported to result in fewer merge conflicts without causing mis-merges\nby tests done on actual merge commits taken from Linux 2.6 kernel development history.\n\nSo, while your approach might work in some cases, I have the feeling that it is not necessarily a good universal policy.  Some experiments and theory are probably in order here.\n. In general, rebasing only part of a branch is not a well-formed operation in a DAG-based history.  However, it just occurred to me that the removal of a commit or sequence of commits from a branch could be framed as an incremental merge.  Suppose you have two commits, A and B, and you want to remove A from the history:\no - A - B\nIt is possible to compute A\u207b\u00b9, the inverse of A, in the context of A (this cannot conflict):\no - A - A\u207b\u00b9\n    |\n    B\nNow if you merge these two \"branches\", you get\no - A - A\u207b\u00b9\n    |   |\n    B - B'\nwhere the merge commit, B' is effectively commit B without commit A.\nThis can be generalized to removing an arbitrary number of contiguous commits followed by an arbitrary number of commits that you want to retain.  I don't see an obvious way to generalize it to removing multiple intervals of unwanted commits except for the trivial approach of removing them one interval at a time.\nBut this workflow is not yet supported by git-imerge, so you would have to do at least part of it manually.  If you would like to work on implementing this in git-imerge, I would be happy to help you get started.\n. @muff1nman: I think that your \"remove commits\" steps can be done as a single incremental merge:\no - A   -   D   -  E   -   F   -   G    -   H\n                           |\n                          F\u207b\u00b9\n                           |\n                          E\u207b\u00b9\n                           |\n                          D\u207b\u00b9\nEach of these three revert commits (since they are applied in reverse order) necessarily applies cleanly.  For example, the state of the tree after D\u207b\u00b9 is exactly the state of the tree after A.\nOnce the incremental merge is done:\no - A   -   D   -  E   -   F   -   G    -   H\n                           |       |        |\n                          F\u207b\u00b9  -   G'   -   H'\n                           |       |        |\n                          E\u207b\u00b9  -   G''  -   H''\n                           |       |        |\n                          D\u207b\u00b9  -   G''' -   H'''\nthen all you have to do is glue together the trees in the order [A, G''', H'''] and you have effectively deleted D, E, and F from this history.\nThe second step, as you describe, is a standard git imerge rebase.\nBut you could even reduce these two steps to a single step, by starting the incremental merge like this:\n```\no - A   -   D   -  E   -   F   -   G    -   H\n                           |\n                          F\u207b\u00b9\n                           |\n                          E\u207b\u00b9\n                           |\n                          D\u207b\u00b9\n                           |\n                           B\n                           |\n                           C\n```\nB and C necessarily apply cleanly on top of D\u207b\u00b9, because D\u207b\u00b9 has the same tree as A.  Once you've filled in the incremental merge\n```\no - A   -   D   -  E   -   F   -   G    -   H\n                           |       |        |\n                          F\u207b\u00b9  -   G\u2081   -   H\u2081\n                           |       |        |\n                          E\u207b\u00b9  -   G\u2082   -   H\u2082\n                           |       |        |\n                          D\u207b\u00b9  -   G\u2083   -   H\u2083\n                           |       |        |\n                           B   -   G\u2084   -   H\u2084\n                           |       |        |\n                           C   -   G\u2085   -   H\u2085\n```\nthe final answer is [A, B, C, G\u2085, H\u2085].\nBut, even in this simple case, there is the question: is it more efficient to do it this way (remove [D, E, F] from the history and then rebase [G\u2083, H\u2083] onto [A, B, C]), or would it be more efficient to rebase [D, E, F, G, H] onto [A, B, C] and then remove [D', E', F'] from the result?  (Actually there are a bunch of other possibilities, too.)  That would be a straight rebase:\no - A - B  - C\n    |   |    |\n    D - D\u2081 - D\u2082\n    |   |    |\n    E - E\u2081 - E\u2082\n    |   |    |\n    F - F\u2081 - F\u2082\n    |   |    |\n    G - G\u2081 - G\u2082\n    |   |    |\n    H - H\u2081 - H\u2082\nfollowed by removal:\no - A - B  - C - D\u2082 - E\u2082 - F\u2082   - G\u2082 - H\u2082\n                           |      |    |\n                           F\u2082\u207b\u00b9 - G\u2083 - H\u2083\n                           |      |    |\n                           E\u2082\u207b\u00b9 - G\u2084 - H\u2084\n                           |      |    |\n                           D\u2082\u207b\u00b9 - G\u2085 - H\u2085\nThen the answer is [A, B, C, G\u2085, H\u2085].\nI don't think that these two methods are equivalent.  Which one is easier probably depends on a case-by-case basis.\n. rerere tucks away information about attempted merges, and uses that information to affect future merge attempts.  This makes the result of a particular merge depend not only on the commits that are being merged, but also on the history of merges that have been done previously.\nSince git-imerge attempts so many similar merges, it is easy to expect that this will confuse git-imerge.  And indeed, during testing, it seemed like rerere in combination with imerge was causing merge conflicts to be resolved incorrectly sometimes.  Therefore, git-imerge explicitly turns rerere off when it shells out to git.\nMeanwhile, I expect that the incremental merges done by git-imerge wouldn't benefit so much from rerere anyway, at least within a single incremental merge.  This is because the micromerges are recorded in the DAG and so their merge resolution is already available to Git without the need for additional rerere data.  Moreover, the fact that rerere data is local would make it more difficult to collaborate on incremental merges.\nWhere rerere might help would be if, for example, an imerge is attempted multiple times, or part of the conflicts involved in the imerge have already been attempted previously as part of a simple merge or rebase.  In that case some of the conflict resolution might be able to be carried across from one merge to another, reducing the number of conflicts that have to be resolved manually.\nSo....\nIt might be advantageous to combine rerere with git-imerge, but it would need some careful testing and thought before I would recommend it.  Maybe one could gain the advantages without suffering from the problems by using rerere more selectively; for example, turning it on for manual merges but turning it off for automatic merges.\n. That's a great idea, and one that somebody else has also wished for.  If you would like to work on it, I would be happy to help you get started.\n. @jrdavid: Cool that you want to work on this; here's some info to get you started:\nThe state of the imerge as a whole is stored in the MergeState object--except for information about the micromerge that is currently in progress.  This is by design, because if the user aborts the merge or manually initiates another merge and then types git-imerge continue, git-imerge has to figure out how to proceed based on the state of the repo at that time, not the state of the repo the last time git-imerge ran.\nSo if you look at the code for 'continue', you will see that it calls incorporate_user_merge(), which is responsible for figuring out which micromerge (if any) was just finished by the user and recording the resolution in the MergeState object.\nincorporate_user_merge() finds the commit pointed at by the reference refs/heads/imerge/NAME and passes it to MergeState.incorporate_manual_merge().  The latter checks that the commit is a merge, and if so looks for its parents among the micromerges that have been recorded previously and converts them into indexes:\n(i1first, i2first) = self.find_index(parents[0])\n(i1second, i2second) = self.find_index(parents[1])\nThis locates where the just-completed merge is located in the merge graph.  From there, it would be easy to output information about the original commits that are being merged, similar to what is done in request_user_merge().\nHowever, the \"status\" command that you want to implement can't start from a merge commit, because the manual merge hasn't been done yet.  Instead it will have to find out, from Git, if a merge is currently in progress and if so, what two commits are being merged.  The first parent of an in-progress merge, of course, is stored in HEAD and can be determined via git rev-parse HEAD.  The second can be determined by reading the file .git/MERGE_HEAD, which, if it exists, lists the second \"HEAD\" of the in-progress merge.  (If the file doesn't exist, then no merge is in progress.  If the file has more than one line, then an octopus merge is in progress, in which case the \"status\" command would have to report that no micromerge is in progress).\nThen stick those two commit SHA-1s into MergeState.find_index(), to deduce which micromerge is in progress, and report the original log message using code like that in request_user_merge().\nI hope that helps!  If you have any questions, don't hesitate to ask.\n. This issue has interesting discussion in it, but is otherwise superseded by issue #33.\n. Yes, I think that should work fine.\nOne obvious approach would be to rebase (or rebase-with-history) the current state of the refactoring branch to the current state of master, and just repeat this step periodically as master progresses.  This would have the benefit that  after you do a rebase, the subsequent work that you do on the branch will be on top of the changes that have been done on trunk between the branch's old branch point and its new branch point, so you will intrinsically have fewer conflicts.\nIf the incremental merge is too much work to do at once, you could also work on the incremental merge across several sittings, simply leaving the in-progress imerge in your repo between attempts.  If work on master or (especially) branch continue during your imerge, you could leave the results of the first incremental merge in your repo and expand the completed part of the incremental merge diagram one rectangle at a time.  So, for example, if the first imerge was \"imerge1\", then you could do\ngit checkout imerge1\ngit imerge start --name=imerge2 --goal=GOAL --first-parent wipbranch\nwhere \"wipbranch\" is the current state of the WIP branch, which includes more commits than the ones that were included in imerge1.  The only thing that might be awkward is simplifying the final imerge into the rebase that you ultimately want.  Given the current state of imerge, you would have to do that by hand using the \"git imerge reparent\" command or other fancy Git trickery.\nCertainly, git-imerge could be made to support this workflow better.  Contributions are welcome.\n. Thanks for your kind words and your offer to port git-imerge to Perl.  I used Perl many years ago and never want to go there again if I can help it, nor to give anybody else a reason that they have to learn Perl.  There are many better alternatives today (Python by no means being the only one).\nYou are of course welcome to write your own Perl version of git-imerge (it's open-source, after all).  I only ask that you name it in such a way as to prevent confusion with this project.\nBut I would encourage you to instead consider investing your time (probably far less time) figuring out a way to make it easy for your colleagues to install Python; that way they can benefit from git-imerge, including all of its future versions, plus lots of other good software that is written in Python, and if you write up how to do that I would be glad to include it in the git-imerge documentation.  I would also be happy to make adjustments to git-imerge to make it work smoothly in that environment.\n. Merged; thanks!\n. This should be fixed by af53d092ba42e38e472fdc88237909be028e22b1:\n$ git imerge start --name=mergebranch --goal=rebase-with-history --first-parent inexistentbranch\nfatal: Not a valid object name inexistentbranch\nCannot compute merge base for 'HEAD' and 'inexistentbranch'\n$\n. This is an interesting idea and I've also thought about something like this.  I got stuck because I don't see an elegant way to generalize it to multiple manual merges; it seems to me that if there are N manual merges then the number of merges that would need to be retained goes something like N\u00b2.  (Though maybe that is acceptable and this type of simplification would be useful anyway.)\nFor concreteness, please draw a bigger diagram, with three or four manual merges scattered about, and suggest how you think the simplification should be done in that case.\n. What is the point of storing more intermediate merges?  Is it so that git has enough history that it can use to do subsequent merges?  Is it so that the whole incremental merge could in principle be reproduced?  Is it so that a human looking at the history can understand it?  Without understanding the purpose, it is hard to reason about what should be retained.\n. I got stuck in approximately the same place when I thought about this possible feature.  My feeling is that all of the commits that you have indicated in your drawing should usually be preserved.  It wouldn't be that hard to implement.  The question is how useful it would be in practice.\n. @eddyp: I just implemented this and pushed the result to branch simplify-to-manual.  Please test it and see if it does what you want; if so, I will merge it to master.\n. @eddyp, I just pushed a rebased version of this feature to the branch \"simplify-to-manual\".  It would be great if you would try it out and let me know if it works for you.\n. My guess is that you are using a version of git from before \"git reset --merge\" was implemented.  What version of git are you using?  (Try \"git --version\".)\n. Hmmm, git reset --merge should be present in that version of git.  What happens if you run that command by hand?  Assuming it fails when run by hand, can you figure out why?\n. @rogerwang, have you followed up on this?  Did you find out what caused the problem?\n. Ahh, that's an interesting problem.  The merge didn't fail because the two commits conflicted, but rather because of other cruft in your working tree.  We'll have to find a way to deal with that.\nThe error occurs because git imerge continue tries to add the merge commit pointed to by reference refs/heads/imerge/$NAME into the incremental merge (where $NAME is the name that you gave this incremental merge).  Since there was no real conflict, I guess you didn't commit a merge commit.  So refs/heads/imerge/$NAME is not a merge between two conflicting parents, and the tool doesn't know how to proceed.  If I understand correctly, there was no conflict at all, and so there is no need for manual merge resolution.  What is your current git status?  Is it still in thinks-it's-conflicted state?  Is the tree clean but still waiting for a merge commit (i.e., is there a .git/MERGE_HEAD)?\nTo solve the problem, simply delete the branch refs/heads/imerge/$NAME, remove the un-checked-in .config file, and then type git imerge continue again.  I think it will then set up the same merge, which this time shouldn't have any conflicts, bit it will nevertheless ask you to resolve the conflicts and commit.  You should just commit a merge commit to appease the tool and then git imerge continue as usual.\nObviously this situation has to be handled better by the tool:\n- Perhaps it should specifically diagnose when a merge failed because of an uncommitted file in the working copy and ask the user to clean up before retrying.\n- Probably if request_user_merge() sets up a merge but the merge doesn't conflict, then the tool should just continue without user input.\n- The documentation should be improved.\nPlease report whether that helps.\n. Thanks!  I just merged your change.\n. Yes, you are right of course.\nBut given that development takes place on master in little bits, can you think of a way of implementing this that doesn't require the manual incrementing of a version number every time I merge something to master?\n. Since the error refers to a date, my first spontaneous guess is that the problem might be related to internationalization.  Does the result change if you run git-imerge with something like LANG=C?\nMichael\nMichael Haggerty\nmhagger@alum.mit.edu\n----- Reply message -----\nFrom: \"Magnus Therning\" notifications@github.com\nTo: \"mhagger/git-imerge\" git-imerge@noreply.github.com\nSubject: [git-imerge] Can&apost finish an imerge :( (#32)\nDate: Fri, Sep 13, 2013 15:04\nI just completed the final manual merge of an 18/6 imerge and now I find I can't finish it.  The result I get is \n% git-imerge finish\nfatal: invalid date format: 2013-07-24 \nTraceback (most recent call last): \nFile \"/usr/bin/git-imerge\", line 2795, in  \nmain(sys.argv[1:]) \nFile \"/usr/bin/git-imerge\", line 222, in wrapper \nreturn f(_args, *_kw) \nFile \"/usr/bin/git-imerge\", line 2743, in main \nmerge_state.simplify(refname, force=options.force) \nFile \"/usr/bin/git-imerge\", line 2209, in simplify \nself.simplify_to_rebase(refname, force=force) \nFile \"/usr/bin/git-imerge\", line 2176, in simplify_to_rebase \ntree, [commit], msg=get_log_message(orig), metadata=authordata, \nFile \"/usr/bin/git-imerge\", line 472, in commit_tree \nraise CalledProcessError(retcode, cmd) \nsubprocess.CalledProcessError: Command '['git', 'commit-tree', '0df2c0115fddd350eee35765283df964eecc7489', '-p', 'bcb4b458973531aa5cb318c600f0431e9aa2f509']' returned non-zero exit status 128 \nI started this imerge on master with \ngit-imerge start --name=foobar --goal=rebase --first-parent devo \nI had a look at the code raising the exception but can't really work out what causes this.  I also printed out the message (msg) and then ran the git commit-tree command manually, with the arguments above and passing the copied message on stdin, that worked just fine. \nAny suggestions on how to finish off the imerge in this case? \n\u2014\nReply to this email directly or view it on GitHub.\n. OK, I had some time to look into this.  The problem is with the metadata that is passed to \"git commit-tree\" via the environment (not the command line), which in turn is determined in MergeState.simplify_to_rebase() by calling get_author_info(orig).  Would you please print the contents of the \"metadata\" variable that is being passed to commit_tree()?  If (as I expect) the GIT_AUTHOR_DATE value is not a valid date, then please print \"orig\" and the output of the following commands:\n```\ngit --no-pager log -n1 --format='%an%x00%ae%x00%ad' $ORIG | hexdump -C\ngit cat-file commit $ORIG\n```\nMy guess is that you have a config setting \"log.date\" that is causing the date to be emitted in a format that git-imerge doesn't expect and (more to the point) that \"git commit-tree\" cannot parse.\nNote to self: we should probably use a plumbing command rather than \"git log\" in get_author_info().\n. On 09/15/2013 07:58 PM, Magnus Therning wrote:\n\nAll right, here's the output I got out... hopefully you can make some\nsense of it :)\n[...]\n\nThanks for the data.\n\nOh, and my |log.date| is set to |short|.\n\nYes, that config setting is what is causing the problem.  I will try to\nfix it, but until then if you temporarily unset log.date before running\ngit-imerge then it will hopefully work correctly.\nMichael\n\nMichael Haggerty\nmhagger@alum.mit.edu\nhttp://softwareswirl.blogspot.com/\n. The above commit should fix this issue.  Please let me know if you continue to have problems.\n. Cool, thanks for working on this!  It will be a nice feature.\nI belatedly realized that I was working on a topic branch that could help you with your \"status\" command (I just merged the topic branch to master): I added fields \"tip1\" and \"tip2\" to MergeState.  These record the names of the branches that are being merged, based on the user's arguments to \"git imerge start\", because I wanted to add that info to the suggested commit message when simplifying to a merge commit.  But you could use these fields instead of your get_refname() method, simplifying the code and potentially giving an answer that is more relevant to the user.  (Instead of computing and using ref1 and ref2, simply use merge_state.tip1 and merge_state.tip2.)\nI also think that the \"status\" command should work even if a conflicting merge is not in progress.  For example, if the user has just run git commit to commit a conflict resolution, or has just run git imerge record to record the last conflict resolution without setting up the next one, then git imerge status could nevertheless say something useful about the current situation rather than just spitting out an error message.  It might even suggest the next command that the user might want to run.\nFinally, it looks like the implementation of \"status\" could share some code with request_user_merge().\nAltogether very nice.  I look forward to the next iteration.  But please be patient; I will have spotty internet for the next week or so and might not be able to reply promptly.\n. @jrdavid, are you working on a new version of your patch?  If so, is there anything I can help with?\n. It's not possible.  Suppose the original diagram is\no - A - B    <- master\nand you want to exchange the order of commits A and B while preserving history.  The resulting diagram would have to look something like this:\no - A - B\n     \\ /\n      X\n     / \\\n    B'- A'   <- master\n(The X simply means that the lines cross, and the dependencies go upwards; e.g., B is a parent of B'.)  But this is incorrect, because A is an ancestor of B' (via B), which implies that the state B' includes the changes that were originally made in commit A.  But in fact, B' does not include those changes; in the rebased commits, the changes originally introduced by A are only introduced in the delta from B' to A'.\nSo there is no way to preserve history when reordering commits while also preserving the correct commit ancestry.\n(It is possible to use incremental-merge tricks to reorder history, and I hope to write that up soon.  But it is impossible to record the result of such a commit-reordering in a history-preserving way.)\n. I hereby conjure @jherland, who wrote this code.\nI did a little bit of googling and found:\n- A stack overflow answer that suggests that ansi.sys has to be enabled for colors to work under Windows.  Perhaps this is why different people are seeing different behavior.\n- A more careful recipe for determining whether stdout supports colors\n- A complicated recipe for doing lightweight colors.  This might be overkill (though it includes a lot of stuff that we wouldn't need and could omit).\nHope that helps!\n. This might have happened because there was already a branch called refs/heads/imerge or perhaps refs/heads/imerge/slaveinfo/FOO, and the reflog file for that branch blocked the creation of the reflog file for branch refs/heads/imerge/slaveinfo. Or perhaps there was a lower-level issue, like a permissions problem within the .git directory.\nEither way, this is unlikely to be a problem in git-imerge -> closing.\n. > I haven't seen this problem myself (but haven't used imerge recently); I wonder if git commit --allow-empty would work as well.\n@jmah: Indeed, that is the workaround that I use. In fact, I don't think that --allow-empty is needed, because merge commits are always allowed to be empty.\nI just implemented #98, which I think should fix this problem for once and for all. It would be great if people who have experienced this problem would test it.\n. @talios: I guess the reason I didn't allow it was just for simplicity.  But I just created a pull request that removes this restriction.  Please test it and let me know how it works: mhagger/git-imerge#45\n. I just merged the branch to master.\n. Thanks for the patch.  I'll wait for @myint's thumbs up before merging, since he contributed the python3 compatibility changes.\n. My struggle to understand #62 brought be back to this issue, and I can't for the life of me figure out why this change helped anything.  Isn't str('GIT_IMERGE') identical to 'GIT_IMERGE' on all Python versions, and the same for '1'?  For example, for Python 2.7 and Python 3.3:\n```\n$ python2\nPython 2.7.6 (default, Mar 22 2014, 15:40:47) \n[GCC 4.8.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nstr('1') is '1', str('GIT_IMERGE') is 'GIT_IMERGE'\n(True, True)\n$ python3\nPython 3.3.5 (default, Mar 22 2014, 13:24:53) \n[GCC 4.8.2] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\nstr('1') is '1', str('GIT_IMERGE') is 'GIT_IMERGE'\n(True, True)\n```\n\n\n\nI don't have a Windows machine for testing, but I can't imagine that the results are different.  If somebody could explain better why this patch helped, I would be thankful.\n. Thanks @KindDragon for your response.\nNow I see the reason:\nfrom __future__ import unicode_literals\nI'd forgotten that setting even exists.  So even under Python 2.x, string literals are treated as Unicode.  Now it makes sense.\nWhy is it that every time I run into a Unicode problem, I waste half a day and don't feel any wiser afterwards? :cry:\n. Looks good, except that I don't want to add .travis.yml to the repo at this time.  Please re-submit without that file.\n. > The .travis.yml doesn't do anything unless you enable Travis CI via the web-based settings.\nThat's the reason.  I don't see the reason to clutter the repo with unused junk.\nIf adding this file would make your life easier somehow, feel free to speak up.\n. Cool, thanks for the fix!  I just merged it.\n. I think this solution doesn't work correctly for Python 2.x; see issue #62.  In that issue is a proposed solution.\n. Why do you set the default prefix to /usr/local?  I think that most packages use /usr as the default.\n. I think it is clear that the choice of prefix depends on the context.  If git-imerge is picked up by any Linux distros, then they will install it to /usr.  If it is installed by a sysadmin for all of the users on a system, then /usr/local.  If it is installed by a single user of a multiuser system, then $HOME.  If Windows then presumably somewhere like\nC:\\My Programs and Viruses and Keyloggers\\Cancer-Like Stuff\\Open Source\\\nAll of these constituencies can be served because they can set PREFIX when installing.  The only question is: what is the conventional default?  I did a little bit of looking around, and it looks like my recollection that /usr is standard was incorrect.\nThe GNU Coding Standards (recommend)[http://www.gnu.org/prep/standards/html_node/Directory-Variables.html] setting the default prefix to /usr/local.  Autoconf (also uses /usr/local)[http://www.gnu.org/software/autoconf/manual/autoconf.html#Default-Prefix] as the default prefix.  I'm inclined to defer to them.\nGit's default install target happens to be $HOME, but I seen no special reason to imitate them.\nSo let's just wait a bit to see if @ralfth has any input, and then I'll merge.\n. Merged.  Thanks everybody!\n. @ralfth: Thanks for the patch.  Just a day earlier @josmo submitted pull request #50, which is very similar.  Could I please ask you to get involved in the discussion over there and all try to come to an agreement about the details?  Then I will be happy to merge the result.  Thanks!\nI'm going to close this pull request simply to centralize the discussion in one place (not because I prefer one version or the other!)\n. Probably if you run\ngit merge-base --all dev_build v3_merge\n(notice the --all option) you will find that it indeed has more than one merge base.\n. No, that's not built into git-imerge right now.  Though I suppose if you are adventurous you could manually edit the line in git-imerge that calls merge-base to have it return whatever SHA-1 you want.  I think that would be enough to let you experiment.\nLet us know what you find out!\n. @scruff311: If you want to submit a change, please use a GitHub pull request: fork the repo, push your change to a branch on the fork, then create a pull request based on the branch that you pushed.\n. Thanks for the contribution.  I just merged it.\n@muff1nman, I have a question: I'm thinking about reorganizing the source code to move most of git-imerge's code into a Python module, probably called something like git_imerge/git_imerge.py.  Would the modeline still be necessary if I make that change, or would vim automatically choose the right mode based on the .py file extension?\n. @muff1nman thanks for the info.  I'll leave the vim line even if I rearrange the source.\n. OK I just pushed a tag 0.7.0.\nSorry I didn't get to this quicker, but really, we need more than just version tags and I was researching how best to do it.  But my research is taking longer than I'd hoped, so here is your tag.\nBeyond a version tag, there should be a mechanism for the script itself to know its version number, so that (for example) we can ask people who file a bug report to run git-imerge --version to be sure which version they were using.  It is a little bit awkward to do so based only on a Git tag.  Because on the one hand if the script is not running from within a Git working copy, then you want it to be able to read the version directly from a file without going to the overhead of running Git.  But on the other hand, if the script is running from within a Git working copy, then you want it to figure out the version of the current HEAD commit rather than use a version number from a file that might be stale.  But I don't want the process to rely on a \"build\" step that people (including me!) might forget.\nI think what I'd like to do is have the working copy version always try to get its version number from Git using something like this.  But at the install step, the version number should be baked into the program somehow.  Maybe it could be as simple as using code like this:\ntry:\n    from version_from_git import __version__\nexcept ImportError:\n    from version import __version__\nThe source tree would have a file version_from_git.py, but that file would never be installed.  Instead, the installation process would generate a file version.py on the fly via something like\nfrom version_from_git import __version__\nwith open('version.py', 'w') as f:\n    f.write('__version__ = %r\\n' % __version__)\nThoughts?\n. This is awesome!  I'd thought about doing this but haven't had time to get to it.  So it's :sparkles:really great:sparkles: that you are working on this.\nI do have one wish: that when you are done, before you ask me to merge you rebase your commits into a logical sequence, such that each commit is self-contained and, for example, commits like \"remove extra newlines\" are squashed into the commit that introduced the extra newlines.  I can help you with this tidying up if you are not into that sort of thing.  (As long as you are working on the PR feel free to commit in whatever order you want and rebase at will.)  I will try to keep an eye on whatever you push and give feedback when I think it might help.\n. A note about version numbers:\nIt's really important that we start defining version numbers for git-imerge.  One reason is because packagers need them (e.g., see #54), and it is in our interests to help packagers.  The other is that it will make it easier to support users if we can ask them \"what version of git-imerge are you using?\"\nsetuptools requires a version number too, doesn't it?\nThe bigger picture of managing version numbers needn't necessarily be part of your project, but in case you had plans in this direction, please see #54, where I wrote down some thoughts about how we could manage version numbers in a sane way.\n. > I think it would be prudent to add more tests. Any thoughts on adding support for a testing framework?\nAbsolutely!  Are you trying to make me fall in love with you or something, because I should warn you that I'm already married :wink:\nBut adding a testing framework should be done as part of a separate PR, right?\n. Cool, thanks for working on this!\nI like the idea a lot, and more than one user has stumbled over this problem so it will be a welcome feature.\nI was a bit surprised that you implemented this by asking the user to choose one of the merge bases interactively.  There are only very few git commands that have an interactive component, so this approach was unexpected.  It would also effectively make git-imerge unusable from a script.\nI think my preference would be for the program to emit an error message listing the merge bases (which you have already implemented) but then just abort.  And for there to be a new command-line option like --merge-base=SHA1 to let the user specify an explicit merge base at his next attempt.  It is a little bit more work for the user, but it is more consistent with the rest of the interface (and with that of Git itself).\n. Yes, you are absolutely right.  I ran into the same problem (and used the same workaround) just yesterday.\nI think the easiest way to implement this would be for git-imerge to create an empty commit by itself, as a placeholder.  Then the simplify/finish commands would have to look for these empty commits and handle them correctly (usually by omitting them from the simplified history).  git imerge continue should also recognize the situation (in-progress merge but clean working copy) and give the user a helpful message.\nIf you'd like to work on this, let me know and I'll help you get started.\n. @dleen: I don't have time this weekend but I'll try to help as soon as I can.\n. @dleen: Let me add some thoughts here, since there is already information here about the hoped-for feature.\nFirst of all, it seems to me that there are two cases where we have to deal with \"empty\" conflict resolutions:\n1.  The user recognizes that he wants to skip a commit and types a special command like git imerge skip.\n2.  The user types git imerge continue with no changes in the working copy but with an in-progress merge that hasn't been committed.  Normally we commit the user's git added changes for him, so in this case we should also commit the NOP merge.  We would have to recognize this situation--the special scratch refname is checked out, a merge is in progress, but there are no staged changes.  (It might be that we don't have to care whether there are staged changes and could just pass the --allow-empty argument all the time.)\nIn either case we would want to create an empty commit for the user as a placeholder in the incremental merge to keep it a nice grid.\nThe next step is that when simplifying such a merge into a rebase, we should also avoid carrying empty commits over into the result.  So there would have to be some logic in the simplify and finish subcommands to decide when one of the commits should be omitted.\n. PR #98 should fix the main part of this problem, though it doesn't also cause the empty commit to be omitted from the final result. (Which would probably be OK, but is not quite a no-brainer because doing so would cause the commit message to be lost.) As a workaround, I run git rebase --interactive after git imerge rebase in this situation if I need to get rid of empty commits.\n. Yes, that would be very nice.  Do you already have some code that you are willing to share with us?\nThe obvious place to wire in a test would be in automerge(), though I haven't thought through whether it is as simple as that.\nBut I think that building and/or running tests will make the test merges so expensive that other inefficiencies will become very annoying (as for example you observed in issue #59).  For example, presumably the build/test would be run during the test merges (e.g., the ones made during bisection), and then when autofilling the same merges are done (albeit from different parents).  But, as long as the tree SHA-1s match, there is no reason to run the same build/tests again.  For example, one could keep a record of trees that have tested OK, and if the same tree reappears, just assume that it is still OK.\n. Thanks for sharing the patch.\n\nI opted to only run make when performing test merges and not for autofilling\n\nInteresting; that was one of the things that I was wondering about.\nAnd if you are only running the build when performing test merges, then probably the same tree is not being tested multiple times (simply because trees shouldn't be seen more than once when testing).\nI don't expect to have time to work on this soon, so if somebody else is interested, by all means step up.  Aside from @johnkeeping's patch (or something like it), I guess we would need a new option for the user to use to specify to the test command.  The test command should probably be stored as a string to the git config and executed using the shell.  And we might want to handle test command failures different than merge conflicts; perhaps there should be two separate exceptions, both derived from AutomaticMergeFailed but that emit different error messages.\n. Yes, I think the command should be stored using git config.  (Of course by that I don't mean the user should have to type git config herself/himself!)\nIt would be wrong to store the command choice in the git repository in the imerge state blob, because (especially when we better support collaborations on imerges) it should not be possible for one user to cause another user to execute an arbitrary command (security risk).  And it could very well be that different users want to run different commands for testing, or that their differing local environments require the commands to be run differently.\nBut we can nevertheless store it in a part of the configuration specific to a particular imerge:\n[imerge \"myname\"]\n        testCommand = \"make -j16 test\"\nWe might also offer a default setting that is used if there is no setting for a particular imerge (because, realistically, the command will probably be the same for different imerge runs within the same repository):\n[imerge]\n        testCommand = \"make -j16 test\"\nIf imerge were the only program involved, I'd stop there.  But I've had a few ideas about how various commands could use tests.  For example, git bisect can use a test, pre-commit hooks might want to run tests, one or two scripts of my own sometimes want to run tests.  So I've been thinking that it would be nice to have a way to specify tests more abstractly within a repository and refer to them from different commands.  Think of something like\n[test \"build\"]\n        command = make -j8\n[test \"fresh\"]\n        # These commands would be run in sequence; all must succeed:\n        command = git clean -dfx\n        command = make configure\n        command = ./configure --prefix=$HOME\n        command = make -j8\n[test \"full\"]\n        command = ionice -c 3 make -j8 test\n[test]\n        default = build\n[imerge \"myname\"]\n        test = full\nMaybe there should even be a new command, git test, that runs tests that are configured in this way and memoizes the results (e.g., in git notes) for trees that have been tested.\n. Sorry for the delay, but these things require a good contiguous block of time to think about and I've been pretty busy with GSoC.\nLet me think out loud about what git-imerge is doing in your case.\nJust after the conflict at 4-2 has been resolved, the diagram looks like this:\n0123456\n0*******\n1*.?..-+\n2*.?.*??\n3*.?.???\n4*.?.???\n5*.?|???\n6*--+???\nThere are two \"blocker blocks\" on the frontier: a two-column block whose upper-left corner is at 3-2, and a two-row block at 4-1.  (Remember: the way a block is defined, its left and top edges must consist of known merges.)\nThe algorithm proceeds by picking one of these blocks and trying to complete its outline (its right and bottom edges).  It always works on the leftmost blocker block first, because that results in less jumping around and is thus hopefully less confusing for the user.  So it tries to fill the two-row block starting at 3-2 using bisection.  It finds that merge 4-5 is the first one in that block (i.e., in column 4) that still fails.  Now we have\n0123456\n0*******\n1*.?..-+\n2*.?.*??\n3*.?.|??\n4*.?.+??\n5*.?|#??\n6*--+???\nThen it proceeds to the other blocking block at 4-1.  You say you wish that it would first try 6-4, because in your scenario that merge would have succeeded.  But what it actually does is bisect column 5, determining that 5-4 is mergeable, and then proceed to 6-4.  So in your mind it should optimistically attempt 6-4, and only if that fails go back to 5-4.  In your case this would save one test merge, namely the one at 5-4.  Correct?\nIf I understand correctly, your suggestion doesn't actually have anything particular to do with filling after a blocker has been manually merged.  It could just as well be applied at the beginning of the incremental merge.  As an example, take the test merge that is run by t/test-unconflicted:\n```\n 012345678\n0*\n1........\n2........\n3........\n4........\n5*........\nAttempting automerge of 1-1...success.\nAttempting automerge of 1-4...success.\nAttempting automerge of 1-5...success.\nAttempting automerge of 8-5...success.\n```\nBy the way, this algorithm is located in MergeFrontier.compute_by_bisection().\nCurrently, git-imerge first tests 1-1 (i.e., on the pessimistic guess that maybe the whole block is unmergeable).  Then it bisects column 1, determining that the whole column is mergeable.  Then it jumps straight to 8-5, and thereby determines that the whole block is mergeable.\nIf you ask me, a better sequence of tests should be:\n1. Check 1-1, to see if the whole block is unmergeable.  If this merge fails, we're done.\n2. Check 8-5, to see if the whole block is mergeable.  If this merge succeeds, we're done.\n3. Check 1-5, to see if the whole first row is mergeable.  If this merge succeeds, then proceed to bisect the fifth row (but remembering that 8-5 is already known to fail).\n4. Otherwise, bisect the first column, remembering that 1-5 fails.\nDo you agree?  It is similar to the optimization that is already done here and here, and it shouldn't be that difficult to implement.\nIt is not certain that it will save work; it depends on how often the optimistic check of the bottom-right corner succeeds.  But I guess that you are right that it will win more often than lose.  And testing the bottom of the first column before starting the bisection of that column is probably also a win.\n. Looks reasonable; thanks!\n. The functions involved here are get_author_info() and commit_tree().\nThe first question is: what Python version is being used?  I assume it must be Python 2.x because otherwise the output of check_output() (which is already unicode) need never be encoded to a byte string.\nI have Python 2.7 and Python 3.3 handy so let's consider those:\n|  | Python 2.7 | Python 3.3 |\n| --- | --- | --- |\n| check_output() | returns unicode | returns unicode |\n| str(a[0]) | returns bytes | returns unicode |\n| env[k] = v on Linux/Mac | k and v must be bytes | k and v must be unicode; encoded/decoded to filesystemencoding using surrogateescape |\n| env[k] = v on Windows | k and v must be bytes | k and v must be unicode; passed directly to putenv as unicode |\nSo str() is failing, because the author name includes Unicode, but str() is only capable of decoding ASCII.  Somewhere between check_output() and os.environ we need an honest-to-goodness encoding of the string to PREFERRED_ENCODING.\nBut we don't want this encoding for Python 3.x, because its os.environ expects to work with Unicode strings.\nI just pushed up a branch issue-62 that I think will fix this problem.  Please test it and let me know if it works for you.\n. First of all, thanks for the patch and I'd like to apologize for not reacting to your old issue #40.\nI like the idea of your change, but I have a couple of comments:\n1.  It is inappropriate for get_boundaries() to call sys.exit().  Instead, it should raise an exception, and the callers should catch the exception and handle it appropriately.  I suggest something like\nclass NothingToDoError(Failure):\n       pass\nand then have those two cases raise this exception instead of a plain-old Failure.  (This change will also make the following change easier.)\n2.  I agree that git imerge merge and git imerge rebase should treat these scenarios as non-errors (essentially mimicking the behavior of git merge and git rebase, respectively).  But I'm less sure about the other callers, namely git imerge init and git imerge start.  If I run one of those commands, then it feels a little bit more like my intent is specifically to start an incremental merge as opposed to accomplish a merge/rebase.  From that point of view, failure to end up in an \"I am now doing an incremental merge\" state could be seen as an error.  So I suggest that you change the git imerge merge and git imerge rebase callers to catch NothingToDoError and ideally to output the exact same diagnostic messages as would git merge and git rebase.  But I would leave the other two callers unchanged, so that they continue to exit with error messages and error status.\nWhat do you think?\n. @dleen, I made a couple of tweaks on top of your commits, rebased to master (because I needed a Unicode fix to be able to test), and pushed the result to my repo as branch exit-code.  Please say if you are happy with the result.  If so, I will squash the commits together and commit the result with you as the author.\n. OK, I smashed a couple commits together with yours and merged the result to master.  Thanks!\n. Awesome that you are working on this!  I'll add some comments and thoughts to the diff.\n. I don't think you should use the word \"build\" in the UI and implementation, because in general people might want to run arbitrary tests before accepting a merge--maybe less than a full build, maybe more.  Why not just call them \"tests\" to preserve generality?\n. Whew, that was a lot of comments.  It's maybe a bit unfair of me to be so detailed after such a long time of inactivity.  That's because I have been wishing for and thinking about this feature even though I haven't gotten around to working on it.  So it's great that you have come along and obviously have more energy than I do :smiley:\nSo anyway, I hope that you find my comments helpful rather than discouraging!  It will be really nice to have this feature in git-imerge!\n. > @mhagger For what's it worth as an idle bystander - I'd love it if anyone gave such a detailed set of review notes on a pull request I made.\n@talios: Find an itch of your own to scratch, and you too can have a turn under the microscope :smiley:\n. @dleen, @talios: I'm really sorry to be such a bottleneck, and given that I'm about to go on vacation for a few weeks I'm afraid things are not likely to get better real soon.\nOne thing that I could suggest is that we try to spread the work around a bit more; for example, if you would each spend some time reviewing the other's PRs that would be really awesome. I'd love to make this more of a community project so that everybody doesn't have to wait on me.\n. Thanks for the nice cleanup!\nI just have a couple of formatting nits for consistency with existing code:\n-   Please use 'single-quotes' for strings (except \"\"\"triple-quoted-strings\"\"\")\n-   Please line up trailing parentheses of all kinds with the contents inside the parentheses; e.g.,\nhelp = (\n      'the name of the branch to which to store the result '\n      '(default is the value provided to \"init\" or \"start\" if any; '\n      'otherwise the name of the merge).   '\n      'If BRANCH already exists then it must be able to be '\n      'fast-forwarded to the result unless the --force option is '\n      'specified.'\n      )\nPlus I added a line comment to the patch.\nFeel free to force push a changed version of this commit rather than adding a fixup commit on top of it.\nThanks!\n. I tested this patch using the output from the following commands:\n./git-imerge --help\n./git-imerge start --help\n./git-imerge merge --help\n./git-imerge rebase --help\n./git-imerge continue --help\n./git-imerge finish --help\n./git-imerge diagram --help\n./git-imerge list --help\n./git-imerge init --help\n./git-imerge record --help\n./git-imerge autofill --help\n./git-imerge simplify --help\n./git-imerge remove --help\n./git-imerge reparent --help\nThere were a couple of discrepancies, so I fixed them with a followup patch.\nThanks for your work!\n. The \"autofilling\" steps correspond to merging single commits into a checked-out version of the working tree.  The merges themselves should be pretty trivial, assuming your project doesn't change the world in each commit.  So if these \"autofills\" take a second each, then it is probably because your source tree is so large that even trivial operations like \"git status\" take a long time.  Am I guessing correctly?\nIt is possible to do such merges directly in the index, which I would expect would speed them up considerably.  It hasn't been a pain point for me yet so I haven't implemented it, but I think it should be pretty straightforward.  I think it would involve the commands git read-tree -i -m --aggressive, git merge-index git-merge-one-file -a, git write-tree, and git commit-tree, but the trick is getting the details right of creating a temporary index (maybe not needed?), handling temporary files, and restoring everything to a sane state when done.\nIt would be helpful to a lot of people if you want to work on this.\n. I doubt that parallelizing the autofilling of a single block would bring more than a factor of two in speed, and even that would usually not be attained. Why?\nAutofilling (or in general the actions that happen when you type git imerge continue) involves two things:\n1. A series of binary searches to find the frontier. A single binary search is not very parallelizable, because you don't know which side to bisect next until you know the result of the current bisection. I suppose you could bisect both sides, basically doing three tests at a time (or more generally n tests at a time) to divide the range into n+1 subranges. But that costs n times as much work and only saves you lg((n+1)/2) bisection steps. So for example it would take 3x as much work at each step to half the bisection time, or 7x as much work to quarter it. So the benefit doesn't scale very well.\nIn fact, we are really doing a kind of 2D bisection, and it might be possible to gain another factor of at most 2 by working on both ends of the merge frontier simultaneously. (See this blog post for a description of the algorithm.)\nBut I don't think the bisection step is usually the bottleneck anyway, because it is typically a few times O(lg max(M,N))\n2. A series of merges to fill in the commits along the frontier. Each edge kindof has to be done one commit at a time, because each commit has its predecessor as parent. You could do the two edges of a block simultaneously then check that the apex commits agree, would gain you a factor of (M + N) / max(M,N), where M and N are the lengths of the two edges of the block. In the best case, this would be a factor of two. But more typically, the blocks are long and skinny, so (M + N) is not much larger than max(M,N).\nYou could compute an arbitrary number of edge merges simultaneously if you assume that merging two distant commits gives the same result as merging incrementally. You would actually compute the trees in parallel, then at the end create commits from the trees, stringing them together in the correct parent-child relationships.\nBut the assumption in the previous paragraph makes me a little bit nervous. It should usually be true (after all, it is the basis of the bisection algorithm that we use). But in practice it could easily be that there are differences. We currently check for these differences by doing the incremental merges along each edge then comparing the trees of the apex commits to make sure they are identical. But if we used this parallelization approach we wouldn't have nearly as strong a consistency check that the merges had mutually-consistent results.\nAnother place that could be parallelized would be when there are multiple blocks that need autofilling at the same time. Usually when there is a conflict, there are two blocks that need autofilling. There might be another factor (of at most two) to be gained by filling the two blocks at the same time. But this is also a bit awkward, because one of the blocks sits on top of the other, like this:\n```\n\n..|.....|\n..|-----+\n..|#?????\n..|??????\n..|??????\n--+??????\n```\nSo the block on the upper-right can't be autofilled until at least the first two commits on the vertical edge of the block on the left are computed. Also, if there is a conflict at the apex of the block on the left, then those two commits are called into question (though this is hopefully a rare occurrence).\nSo all in all I don't think autofilling can be parallized very well (I guess typically by a factor of less than two), unless you are willing to rely for correctness on the assumption written in italics above.\n. Another possible form of parallelism would be to continue autofilling in the background while the user is manually resolving conflicts. In the super slow scenarios described above, how long do the manual merges typically take in comparison to the autofills?\n. For the particular case when the rectangle is very long and narrow, I think we could get far better gains by changing filling strategy. For example, in the diagram below suppose that we are trying to rebase the vertical branch on top of the horizontal branch, and we find the conflict marked with #:\n```\n\n..........................................................................\n..........................................................................\n................#.........................................................\n..........................................................................\n..........................................................................\n..........................................................................\n```\nWe currently autofill two blocks by computing all of the commits shown as x here:\n```\n\n...............x.........................................................x\n...............xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n...............x#.........................................................\n...............x..........................................................\n...............x..........................................................\nxxxxxxxxxxxxxxxx..........................................................\n```\nNote that it is the two long, horizontal edges that are expensive. The vertical edges are relatively cheap because the vertical dimension is so much shorter than the horizontal.\nWhat if, instead, we computed the following:\n```\n\n...............xx.........................................................\n...............xx.........................................................\n...............x#.........................................................\n...............x..........................................................\n...............x..........................................................\n...............x..........................................................\n```\nThis is enough to let the user resolve the conflict at #. Then we could continue autofilling that column in the vertical direction:\n```\n\n...............xx.........................................................\n...............xx.........................................................\n...............x#.........................................................\n...............xx.........................................................\n...............xx.........................................................\n...............xx.........................................................\n```\nWe have effectively rebased the vertical branch over to the right, thereby moving past a commit on the horizontal branch that conflicted with it. We could continue from there by looking for the next conflict.\nThe advantage of this approach is that we only have to compute O(min(M,N)) commits, rather than O(M + N). If M and N have very different sizes, this is a dramatic improvement. A disadvantage is that we lose the apex consistency check that I mentioned earlier, though we could still do a consistency check between the incrementally computed apex commit and the apex commit computed directly.\nOf course this only works if our goal is to merge or to rebase the vertical branch on top of the horizontal branch. If our goal is to rebase the horizontal branch on top of the vertical branch, then there is no way around computing the merges on the bottom edge of the diagram. But even in this case, we could avoid computing additional horizontal lines in the diagram.\nThis approach seems very promising.\n. @kastiglione: the code that defines/implements the filling strategy is a bit scattered around, but there is a precedent for variations in strategy influenced by the --goal=GOAL and --manual options. Let me do a brain dump of code that is related to the strategy:\n- Block.auto_expand_frontier currently is the main point for deciding between strategies for auto-filling and auto-expanding the frontier.\n- MergeFrontier.map_known_frontier only considers a block to be within the frontier if its right and bottom edges are both known. This requirement would have to be relaxed in the case of the new strategy.\n- MergeFrontier.auto_expand probably doesn't care much about strategy itself, though it recurses into Block.auto_expand_frontier.\n- Block.auto_outline fills in the right and bottom edges of the block.\n- Block.auto_outline_frontier implements the usual default strategy.\n- MergeState.auto_complete_frontier probably also doesn't need to care about strategy.\n- MergeState.simplify_to_rebase has a consistency check (the if not force block) that I think would have to be skipped in the case of the new strategy.\nIdeally, as part of this change, the choice of strategy would be more decoupled from the rest of the classes. But that might be overkill.\nLet me know if you have any other questions.\n. @davidchisnall: The complication with your idea is that any skipped merge that supposedly should be conflict-free can actually turn out to conflict (for example, if a commit was reverted on one of the branches). In this case some backtracking is necessary. The backtracking can end up requiring the user to do a manual merge that should really be an ancestor of (A, B). It's not impossible, but the bookkeeping becomes pretty arduous, and it would sometimes require manual merges to be done out of order, which I think would be very confusing to users. Moreover, the details of how the user resolves the \"later\" conflict then later resolves the \"earlier\" conflict might differ in detail, resulting in more confusion.\nIf we were willing to lean more on these assumptions and accept some potentially very awkward effects when the assumptions are violated, then I suppose we could avoid a lot of intermediate commits. The problem would become \"given that we know the results of some set of (automatic and manual) merges, what additional (automatic and manual) merges do we have to do to make more progress toward the end goal?\" The requirements would be:\n\nA manual merge should only be requested after its two direct ancestors are available.\nAutomatic merges should always be done with the benefit of knowledge of any manual conflict resolutions that would be their ancestors. :point_left: This is the requirement that is impossible to fulfill in all backtracking cases without requiring the user to re-do merges that they have already done.\n\nLess ambitiously, it might make sense to omit some of the \"internal\" lines when outlining the merge frontier; e.g., instead of computing\n```\n\n.....|.....|\n.....|.....|\n.....|.....|\n.....|.....|\n.....|-----+\n.....|#?????\n.....|??????\n.....|??????\n*-----+??????\n```\none could save a few explicit merges by computing\n```\n\n...........|\n...........|\n...........|\n...........|\n.....+-----+\n.....|#?????\n.....|??????\n.....|??????\n*-----+??????\n```\nOn other fronts: I did some heavy refactoring over the last couple of days to prepare the ground for the rebase-style strategy described here; see branch polymorphic-frontiers. The new strategy isn't implemented yet but should be pretty easy now. As usual, the biggest hurdle is the lack of automated tests that could give confidence that the big refactoring hasn't broken anything. After the refactoring, it should be easier to play with other merge strategies, like those discussed above\u2014you basically just need to implement a new MergeFrontier class.\n. @BrendanAnnable: I don't have time to implement a --verbose option in the near future. Patches are welcome if you'd like to work on this yourself. Let me know if you need any pointers to get started.\nIf you are using Linux, you could run imerge under strace to see the Git commands that it is invoking and the timestamps when they were called:\nstrace -tt -e execve git imerge [...]\n\nUnder the assumption that git is consuming most of the time (which I think is almost certain), this could give you a good overview of where the time is going.\n. I agree that this is confusing. It is a historical artifact from the way git imerge start was originally implemented. I think the best way to solve this problem would be to add a command git imerge rebase-with-history analogous to git imerge rebase and git imerge merge.\n. Thanks for the patch, @ralfth.  Just last week I was thinking about how interacting with git-imerge feels harder than interacting with git merge because of the lack of completion support.\nWould you mind adding a sentence or two to README.rst advertising the presence of the completions file and maybe saying where to put the file / how to load it into your environment?\nI was surprised that the names of some of the functions in the file do not start with underscores.  I thought that was the convention?\nI'm looking forward to using this :circus_tent:\n. Thanks a lot!  I just merged your changes to master.\n:sparkling_heart:\n. If you continue to do memoization of the class constructor, it might make sense to split that into a separate commit to make each change more self-contained. But see my comment above where I express skepticism about whether this memoization is the correct approach. Another unfortunate side-effect of your memoization approach is that GitConfigStore cannot be used as a normal class; for example, if there were a reason to add static methods to the class, it would be impossible to access them.\nIn summary: I like the idea of having a class for interfacing with git config, but I think that the level of complication could be dialed back a notch or two unless/until we need it.\n. I wonder why git reset --merge didn't work. If anybody sees this again, it would be helpful to see the result of running that command manually, and the result of git status. Otherwise, it's hard to investigate this any further.\n. I sympathize with the problem. But it would be a shame to burden everybody with the cost of running Git three times to get this information, especially under Windows where it is so expensive to start a subprocess.\nSo I propose #73 as an alternative to your approach. Does it work for you?\nBy the way, do you know where this fails when using msysgit? Does their git.exe simply not output data past the first NUL character? (If so, it would be worth reporting a bug to that project, because I presume many scripts rely on this sort of thing.) Or is it that data are lost somewhere between git and subprocess.Popen()? Or is our implementation of check_output() incorrect?\n. Closed in favor of #73.\n. @ggascoigne: I'm sure this response is too late for you :disappointed:, but maybe it will be helpful for other people in the future.\nWhen you run git imerge continue, it looks at the HEAD commit to see if it can be incorporated into the current imerge. It does this by looking at its two parents and checking whether they are two commits that currently need manual merging.\nSo, suppose imerge left the repo in the following state:\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y---?\n    |\n    C\nIt expected you to fill in the merge at ? by merging X and Y directly, but instead (if I understand correctly) you did the merge via a helper commit H, maybe like:\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y-H-M\n    |\n    C\nAt this point git imerge continue fails for you, because one of the parents of your final merge M is the helper commit H, which is unknown to imerge. Therefore it doesn't recognize that M can be used as the merge between X and Y.\nFortunately, the solution isn't that difficult. You need to adjust the parents of M to be X and Y without changing its tree contents. You can do that using a handy-dandy command that I built into imerge even though it doesn't really fit there:\ngit reset --hard $(git imerge reparent X Y)\nThis essentially squashes commit H into M, making the repo look like\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y---M'\n    |\n    C\nNow git imerge continue should work.\nIt would be nice to make this easier. For example, we could check whether the HEAD commit has only two ancestors that are on the frontier of the merge and no ancestors that are not on the frontier. If so, we could check whether the merge of those two parents is needed, and if so, do essentially what I described above. But I would be a little bit worried that we were throwing away useful work done by the user. For example, what if you wrote a careful commit message for commit H explaining what you were changing and why it was necessary? You might be upset to have it discarded.\nOn an even deeper level, I wonder if your commit H would be useful for the continuation of the imerge? For example, when it comes time, in the next row, to fill in this ?:\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y-H-M\n    |   |   |\n    C---T---?\nit might actually be easier to first compute the merge of H and T, and then compute the merge of M and U:\no---0---1---2---3\n    |   |   |\n    A---o---X\n    |   |   |\n    B---Y-H-M\n    |   | | |\n    C---T-U-?\nI think this is a promising idea, though I'm not sure if it generalizes. It would be quite a lot of work to build it into git imerge, because a lot of the code assumes a \"rectangular grid\" topology of commits and merges.\n. I just added #79 to record the idea of supporting non-rectangular merge diagrams.\n. Fixes #71.\n. Yes, that would be helpful for some people. Is there somebody around who could summarize what would be needed to make git-imerge into a PyPI package (maybe even in the form of a PR)? Do we just need a setup.py file, or would we have to rearrange the sources? Every time I look into Python's packaging tools, it seems like there is no real consensus about best practices and my gumption ebbs away. Maybe that situation has changed.\n. Thanks for the idea. If somebody makes such a presentation, we could consider linking to it.\n. > I'm looking at my .git/config a few days after using git imerge serveral times and sometimes also resetting git-imerge runs. Now my .git/config contains several empty [imerge] sections.\nThis is a weakness of git config itself (which git-imerge uses to read/write configuration values). The extra empty sections don't actually do any harm, except to our sense of neatness.\n\nIs .git/config really the best place for state info?\n\nI don't see why not. Most of the state info is stored as blob objects in the Git repository itself. The only state that is stored in config is the name of the imerge that is currently the one being worked on, which is needed to figure out the name of the reference that contains the rest of the information for that imerge.\nIf you have a concrete idea for improvement, please reopen this bug and let us know.\n. But the user's choice of which imerge to work on is a configuration setting--it's the user's choice of which imerge s/he wants to work on. The fact that this choice is made as a side effect of other commands doesn't change that fact.\nI wouldn't want to invent an extra file just to hold that one little bit of information.\nWhat I can imagine would be not to set imerge.default so eagerly. After all, if there is only a single imerge in progress (by far the most common case), it is not really useful. Even if the user has two imerges going at once, it is often clear which one is intended:\n- From the --name=NAME option\n- From the name of the current branch (if it is one of the temporary names that imerge sets up).\nWe could add a command git imerge set-default NAME to let the user choose a default branch explicitly (or just let the user run git config imerge.default NAME), and otherwise leave that setting alone.\n. Hi @waldyrious!\n\n[...] I was wondering whether creating this kind of helper commits could be automatically managed by git-imerge, i.e.: whenever git-imerge finds a conflict, it could be that the commits aren't modular enough, so what if it tried splitting the involved commits using the same splitting method used in git add -p? Maybe then the merge could proceed automatically, rather than the user explicitly creating commit H as in your example above (unless I misunderstood and you meant the commit would be created automatically?).\n\nIt is approximately true that a merge only fails if there is a conflict within a single hunk of the diff. Since git add -p works hunk by hunk, it wouldn't be able to subdivide the conflict in any useful way.\n\nAnother question I had was whether using a different merge algorithm (Patience, Diff Match and Patch, maybe others?) could be used as an attempt to automatically resolve conflicts that the default diff algorithm fails to deal with. But this is probably worth a separate issue, if at all (let me know).\n\ngit-imerge doesn't actually do any merges or resolve any conflicts itself. It relies on git merge to do so. So to choose a different merge algorithm, we would basically need to pass the corresponding options down to git merge, I think. It seems like a reasonable thing to implement, though it is pretty much unrelated to this issue. The main question is what the user interface should look like. Would the user choose a different merge algorithm as part of their permanent config, or at the start of an imerge session, or for one particular micromerge, or ...?\nI don't use other merge strategies, so this wouldn't be high on my own priority list. But patches are welcome :-)\n. No feedback (@johnkeeping?), but I've been using this version for a while and haven't seen any problems. So I just force-pushed a signed-off version and will merge.\n. Unfortunately I cannot reproduce this error with the current value of the branches that you mentioned. Do you happen to know what the branches' SHA-1s were at the time of the problem? Was the problem repeatable?\n. @Stunner: I am unable to reproduce the problem, even using those exact commits.\nCan you tell me exactly what versions of git-imerge, Git, and what OS you are using? Also the output of running git config --list in that repository (but scrub any passwords if present).\nIf you are not using the most recent version of git-imerge or are using an older Git version, it might be worth an attempt with updated software.\nIt is very curious that the failure point is not reproducible. I don't think that any information should carry over from one attempt to run git imerge merge and the next. Theoretically git rerere could do so, but I think git-imerge always turns it off before running git. (If you haven't disabled rerere, that would be worth an experiment: before running imerge, run\ngit config rerere.enabled false\nand see if the error either goes away or becomes more consistently reproducible.)\nThe commits in question seem to involve a lot of file creation and deletion. Perhaps filename case normalization is turned on and is confusing things (e.g., if you are running this on OSX)?\n. Given that our bash completion relies on Git's bash completion already being installed, I'd worry a little bit that this would install broken software on the user's system. What happens if we go through with this installation but Git's isn't installed? Does it fail gracefully, or (for example) does it make the user's shell unusable?\n@ralfth, do you have an opinion about this PR?\n. The subcommands can all be listed via\ngit-imerge --help\nAnd more help about each subcommand is available via git imerge SUBCOMMAND --help; for example,\n```\n$ git imerge autofill --help\nusage: git-imerge autofill [-h] [--name NAME]\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  name of incremental merge to autofill\n```\nSo I guess you are asking for documentation for these commands in the main README file?\nRegarding testing: there are some crude scripts for creating a test repository and running git-imerge against it:\n- t/create-test-repo -- create a test repository under t/tmp\n- t/test-unconflicted -- run a couple of non-conflicting incremental merges against the temporary repository\n- t/test-conflicted -- run a couple of conflicting incremental merges against the temporary repository\nThese are not automated tests in the sense that they don't check that the results are correct (you need to use your eyeballs for that). But at least they exercise part of the code and often flush out silly programming errors.\n. Thanks! :sparkles: \n. Thanks @SebKuzminsky!\n. @ralfth, could I get your opinion on this? I have no experience writing bash completion scripts.\n. > @mhagger The changes look good to me.\nThanks for the patch @rhunter, and thanks for the review @ralfth :sparkles:\n. Thanks for the bug report.\nDid this happen in a public repository that I could clone to try to reproduce the problem? If so, please let us know exactly what you had to run to trigger the error.\n. @blitz, would you please check whether #91 fixes the problem that you experienced? Thanks!\n. > The last line then repeats a lot of times. I've spent about a week and a half of CPU time on this merge so far [...]\n\nI'm not sure if it's related, but I ran a git gc last night because the individual merges were taking around 20 seconds (now they're down to 1-2 seconds) and at that speed it would have taken about six months to finish the merge.\n\nThat's amazing (and scary!) I'm curious to what extent your merge is so slow simply because it is gigantic, vs. whether you are hitting a pathological case. I suspect the latter.\nThese UnexpectedMergeFailure exceptions are meant to be just that, unexpected. They occur when it is possible to merge a whole series of commits together, but then when it tries to merge the commits one by one, there is a failure somewhere along the way. In other words, your merge is violating this approximate assumption.\nThe backtracking that you see is git-imerge's way of recovering. Because this is expected to be an unusual occurrence, this code path is not written in a way that would be appropriate if it were expected that the assumption would be violated not a few times, but more than ~1000 times.\nThe repeated backtracking that you see, I believe, is the very first step of outlining a block of commits that are all expected to be doable. This is the merge of one commit from one side of the block with all of the commits on the other side of the block. When that merge unexpectedly fails, it takes only one step backwards and tries again. It is quite possible that this is making the overall algorithm regress to O(N\u00b2) or something.\nYour \"ugly\" fix is pretty much what my first impulse would have been (though probably with a custom exception type built for this purpose). Feel free to write it up as a PR. But additionally, I hypothesize that an algorithmic improvement could reduce your pain dramatically. For example, MergeFrontier.remove_failure could do a bisection step to more quickly find a less ambitious merge that succeeds.\nI'm really curious to hear whether your merge was/will be successful eventually.\n. Thanks for the patch! :sparkles:\nI agree that\ngit imerge start --goal=rebase --first-parent BRANCH\nis confusing, because it is backwards to the direction of git rebase; it rebases BRANCH on top of the current branch rather than the other way around.\nBut doesn't\ngit imerge rebase BRANCH\ndo the thing that you want (i.e., equivalent to git rebase BRANCH)? Personally, I always use the latter and never the former. If you help me understand the use case it will be easier to evaluate your PR.\nThanks!\n. @bozzzzo: Thanks for the explanation. That makes sense and I can see that it would be a useful feature.\nRegarding the patch itself:\n1. It is an awful lot of copy-paste. I think it makes sense to extract some functions first to reduce the amount of duplication. I just pushed a branch simplify-to-path in PR #90 that does so. If I then merge that branch into yours, the result is my rebase-reversed branch (though I haven't tested it at all).\n2. The new feature would need documentation in README.rst.\n3. There are some consistency checks done for rebases (for example, here and here which I think would also be needed for rebase-reversed.\n4. Given that --goal=rebase is actually kindof reversed relative to what git rebase does, I wonder whether naming this feature rebase-reversed will introduce even more confusion. I wonder if a better name might make this clearer. At the same time we might even want to deprecate --goal=rebase and give that operation a more intuitive name, too.\n. Note that \"incremental git revert\" is implemented in PR #100. It would be great if people would cautiously test it.\n@waldyrious: I just wrote up the idea \"break off an incremental merge\" in more detail as issue #101.\n. I think this PR was submitted erroneously. It contains nothing that is not already in master.\n. Thanks for the patches. They makes sense.\nBut what about the uninstall rule? Shouldn't that also honor DESTDIR? I understand it's not important for RPMs, which can uninstall themselves, but it seems like it would be important for somebody who ran make install with the DESTDIR option and later wanted to uninstall. Or at least it wouldn't hurt...\n. @RichardsonAlex: Sorry, I didn't notice that you pushed the \"uninstall\" patch to this branch. It looks good, thanks for your work!\n. I'm closing this as redundant with #94. If that is not correct, feel free to reopen.\n. A nice improvement; thanks! :sparkles:\n. Sorry @waldyrious, I missed the notification for your question.\nYou're right; --goal is only needed on the git imerge finish command if you change your mind about the goal while you are working.\nFeel free to reopen this issue if you have any followup questions.\n. > Otherwise, if you'd give me some pointers about which files to edit and how, I could take a stab at doing this.\nThat would be great! The README is in README.rst (in reStructuredText format, but it's pretty self-explanatory). The help text is embedded in git-imerge, for example here, here, and here.\nIf you are ambitious, you might consider providing a little bit more explanation of these operations such as discussed here and here.\n. There is currently no support for redoing a merge that was done incorrectly the first time. I think it should be sufficient to delete any references named refs/imerge/<name>/{auto,manual}/<I>-<J> where I and J are integers greater than or equal to the (I,J) of the commit that you want to redo, then run git imerge continue. But there is also a blockers field in the blob pointed at by refs/imerge/<name>/state that might cause problems in some situations, and there might be other loose ends that I haven't thought of. Try it and see, and let us know what you find out.\nIt would be nice to have a command to do this, but I don't know of anybody working on it.\nThe remove command removes the entire imerge. That's not what you want.\n. Yeah, a release is long overdue. Let me try to get #104 merged and then I'll add a tag. (If you have an idea of how bash completion works internally or even if you don't mind doing some testing, your help reviewing that PR would be welcome since I have no idea what I'm doing in that department :wink:.)\n. I just created a release v1.0.0 (note that the tag has a leading v, unlike the tag for release 0.7.0).\n. Thanks, @ralfth :sparkles:\n. You can kindof tell how big the current autofill will be by looking at the test merges that it did just before it started autofilling. But I agree that it would be nice for imerge to display estimated progress itself.\n. If you check out some other branch, delete imerge's temporary branch (the name looks something like refs/heads/imerge/$NAME), and type git-imerge continue, you should be able to continue where you left off. Be sure to delete the reference under refs/heads/, not any references under refs/imerge/!\nIt would obviously be nice if this were easier.\n. The way I read this issue is that @mulle-nat had a problem with a single micromerge and wanted to start the micromerge over without aborting the overall imerge. Whereas #101 is about aborting the whole imerge while preserving progress that has been made so far in the form of, for example, a rebase of the branch to some commit that is nearer, but not all of the way to, the other branch tip.\n. @USBhost: Thanks for the report. parser.error() simply wasn't being called correctly. I just pushed a fix as #108. Would you be able to check this version in the situation where you experienced the error, just to make sure that I didn't make another boneheaded mistake, before I merge it?\n. @USBhost: thanks for fixing my fix. I just pushed your changes to #108 and merged that PR.\nI misunderstood this bug report to be about the crash due to the problems fixed in #108. In fact, your problem seems to be that git-imerge legitimately can't handle merging/rebasing from one branch point to another if those commits are not connected by a chain of --first-parent ancestry. This is currently a limitation of git-imerge that could probably be relaxed under some circumstances. I'll reopen this issue as an enhancement request.\n. Also, if I understand correctly, this apparently worked in earlier versions of git-imerge.\nI don't have much time to follow up on this now, I'm afraid.\n. There is another good description of this problem, with an ASCII-art diagram even,  in https://github.com/mhagger/git-imerge/issues/110#issue-179482601.\n. I can't stand having users forced to use old versions due to a regression :broken_heart:, so I tried to fix this problem after all. I think that #111 fixes this regression and also makes git-imerge applicable in many more situations that it didn't handle correctly even before e8da000b925562cc34941079cd74fd4a1ae51de1.\nThe problem is that my time is really tight right now, so I'm going to need your help. I did a tiny bit of manual testing, but this is an important spot in the code that is used for all imerges (not only in the case that the merge-base is not a first-parent ancestor of the branch tips). If somebody could do more careful testing that #111 hasn't broken anything, or even better, improve the test suite to verify the current code and catch any similar new regressions in the future, that would be a great help towards getting this fix merged and in general improving the quality of git-imerge. Anyone? :pray:\n. I'm no pygit2 expert, but I don't know of a reason that it couldn't be used instead of the Git command line client. But the installation complications pointed out by orao will certainly be a headache for users, especially Windows users.\nIt might not be crazy to support both backends by creating a virtual interface to the Git repository, and choosing either the Git or the libgit2 version at runtime. That would allow anybody to try out the script easily, then if performance is a problem and the user is competent to do so, they can install libgit2 and the Python bindings to speed things up.\nSuch a virtual interface might also be useful for testing git-imerge. One could create a mock Git repository for git-imerge to interact with. The mock could simulate scenarios that are awkward and fiddly to construct in a real Git repository, such as conflicts in specified patterns, or merges that first appear to succeed, but then conflict when done incrementally.\nBut I don't expect to have time to work on any of this in the near future.\n. Thanks for your clear description (and ASCII-art, my favorite!) of the problem and how it arises in a common workflow. This is a dup of #107, so let's continue discussion there.\n. @orao: I reused the diagram in a confusing way.\nIn the first example, the goal is to merge feature into master, in which case the merge base is indeed E.\nIn the second example, I was referring specifically to calling linear_ancestry(A, Y, \u2026), which might be useful if merging from branch to master in a scenario like this:\no---o---o---o---o---o---o          master\n     \\\n      A---B---C---D---E\n           \\           \\\n            V---W---X---M---Y      branch\nIn this case, linear_ancestry(A, Y, \u2026) is called as part of determining which commits need to appear on the vertical axis of the incremental merge.\nI hope that is clearer!\n. I wish we had automated tests for this stuff, but I've been using this branch for a while, and other people have reported success with it in situations where master fails, so I'm going to merge it.\n. git imerge --help is intercepted by the git executable (i.e., git-imerge itself never runs). I believe that git then looks for and outputs a manpage called git-imerge. Since there is no such manpage, it doesn't work.\ngit-imerge --help invokes the git-imerge script itself, which asks argparse to generate help output based on the command-line options and their help strings, plus the file comment __doc__.\nI don't think this is easy to fix, short of somebody writing a manpage for git-imerge. This, in turn, might be done by getting argparse to emit its output in TROFF format. I did something similar for the cvs2svn project, but haven't had time to do that yet here. Maybe argparse supports a standard way of doing this?\n. > Do you know that -h works even when --help does not?\nI guess the git launcher hijacks --help but not -h.\n. It would be a lot easier to diagnose your problem with access to your repository. Is it publicly available? If not, could you anonymize it using git fast-export --anonymize and make the anonymized repository available? If so, please let us know where to find the repo and exactly what git imerge command line to use to provoke the problem.\nI don't have any idea if it would help, but have you tried running this using branch loosen-first-parent-rule from PR #111?\n. No response \u2192 closing issue. Feel free to reopen if you can provide more information.\n. It sounds like you were using imerge correctly. Yes, there must have been a byte \\xe2 somewhere in the commit that it was trying to process, probably in either the log message or in the author/committer name. It appears that imerge was trying to encode this use the ascii encoding. Since \\xe2 is not a valid ASCII character, :boom:\nSo one question is the one you posed: \"Why doesn't imerge handle data as binary?\" It probably should, though it's a pain to do so in Python, especially while retaining compatibility between Python 2 and Python 3. So that might be a nice long-term goal but is unlikely to happen soon.\nA simpler question, and one that might solve your current difficulties, is \"Why is imerge using the ascii encoding on your system?\" This comes from PREFERRED_ENCODING, which comes from the standard Python library function locale.getpreferredencoding(). This function accesses your environment to guess what locale to use.\nSince the most common encoding used in Git metadata is UTF-8, I suggest that you try running the last command again as follows:\nexport LANG=en_US.utf8\ngit imerge finish\nand see if that helps. (If not, see what you have to do on your system to affect the locale.)\nAlternatively, you can edit the git-imerge script by hand to set PREFERRED_ENCODING near the top of the script manually, for example like\nPREFERRED_ENCODING = 'UTF-8'\nIf none of that helps, please tell us what repository you are working on and what SHA-1 you are trying to merge so that we can reproduce the problem.\n. @GeirGrusom: Could you try your failing merge with the branch from this PR: #111? I think it will fix your problem, but I'm having trouble getting people to test it so that I can merge it confidently.\n. Thanks for pinging me; otherwise it can take a while for me to notice such notifications.\n@greened: Thanks for the contribution! It was not my intention to change the authorship of commits during rebase-with-history simplification; that was an oversight.\nI'd prefer to put in your fix without the new command-line option. Would you mind creating a new PR with only the fix?\n. What do you mean by \"stop the merge where it is right now\"?\nIf you want to put the merge on ice and come back to it later, then you don't have to do anything special. Just switch to another branch, do you work, and whenever you want to continue the imerge, type git imerge continue. (Of course you will lose any unstaged changes on the current micromerge.)\nIf you want to stop the imerge and end up in a state where whatever part of the merge you have done is kept (e.g., the branch merged with only part of master or the branch rebased not all the way to the other branch's tip but rather to some intermediate commit on the other branch), that feature wish is the subject of issue #101, and it is not yet implemented.\nIf your goal is a merge, you could do this manually without a huge amount of difficulty by using git imerge reparent to make the commit whose contents represent the merge you want have the correct parents. You would first switch to the commit with the desired tree, then run something like\ngit checkout -b my-new-merge-commit $(git imerge reparent $PARENT1 $PARENT2)\n\nthen probably adjust the commit message using git commit --amend.\nIf your goal is a rebase, you could still probably finish it manually in its partial state if you are desperate, but it would involve a lot of confusing bookkeeping.\n. > It would be nice to have a git imerge abort command that did this automatically.\nYes, that would be very nice.\n\nI could take a stab at this, but I'd need some pointers first (namely, how to get the branch the user was on before starting git-imerge).\n\n\nThe branch name would have to be determined when the imerge is started by calling get_head_refname(short=True). Note that this function returns None if the user is on a detached HEAD. (What should happen if the user runs git imerge abort after having been on a detached HEAD? Maybe nothing? Maybe restore to the SHA-1 that they were on (if it still exists)?)\nThe branch name would have to be recorded in MergeRecord.\nIt would have to be added to the state dict by MergeRecord.save() so that it can be remembered across invocations, and read back in by MergeRecord.read(). This change should probably be accompanied by an increment of STATE_VERSION[2].\n\ngit imerge abort should only switch back to the starting branch if it still exists, if the working tree is clean, and perhaps only if the temporary branch is currently checked out. The code in MergeState.remove() might give you some ideas about this. For backwards compatibility, the code should deal gracefully with the situation that the starting branch wasn't recorded in the state.\n. Merged. Thanks!\n. The mojibake that you pasted, D\u00c3\u00bcring, looks like the UTF-8 encoding of \u00fc. Can you check somehow exactly what characters are in the commit? For example, run\ngit cat-file commit $SHA1 \n\n\nand view the output in a hex editor or something. Try doing the same for one of the other commits, where your name appears correctly.\nWhat is the preferred encoding on your system? On mine it is UTF-8:\n$ python -c 'import locale; print locale.getpreferredencoding()'\nUTF-8\n. \u00fc in cp1252 is 0xFC; in Unicode it is the same (U+00FC).\nThe UTF-8 encoding of U+00FC is 0xC3 0xBC. In cp1252 those bytes represent \u00c3\u00bc, the characters that you saw.\n\u00c3\u00bc, in turn, are U+00C3 U+00BC in Unicode. Those two characters are encoded in UTF-8 as 0xC3 0x83 0xC2 0xBC, which are the bytes in the faulty commit.\nSo my guess is that Git is respecting the mingw64 configuration and outputting the commit metadata in UTF-8. But Python is reading the data under the assumption that it is cp1252, converting the \u00fc to two Unicode code points internally, and outputting them as four bytes of UTF-8. When you view the commit, Git assumes that the data are already in UTF-8 so it passes it through unchanged.\nI'm not an expert on encoding issues and know even less about encodings on Windows, but it seems to me that you want to tell Python to use UTF-8. One crude way to do this would be to set\nPREFERRED_ENCODING = 'utf8'\n\nnear the top of the git-imerge script. Does that help?\n. Thanks for the suggestion.\nThe main point of the README is to explain git-imerge and teach people how to use it. I don't think the main body of the README is a good place for \"look, somebody mentioned git-imerge\" links. Since this shout-out is not very pedagogical, I don't think it belongs here in the text. I wouldn't want people who are trying to learn about how to use git-imerge to click on it, because it wouldn't have value to them.\nArguably the GitMinutes link falls in the same category. I haven't listened to it for a while, but I don't recall it being a very good resource for learning how to use git-imerge.\nBy contrast, @patrickmckenna's talk from Git Merge 2016 would be a good pedagogical link. But I can't find it online so maybe it wasn't recorded.\nInstead, maybe it would make sense to add a new \"Other git-imerge links\" section where we could collect significant mentions of git-imerge from around the web.\nBy the way, I think the way you have defined the link doesn't actually expose it to the reader unless there is a reference to it from the text.\n. I'm having trouble reading your diagram. Is this equivalent?\nmaster:  0-1-2-3-4-6-7-- 8--9-10---11\n          \\           \\ /       \\ /\nmerge-1    \\           x         y\n            \\         /         /\nrelease-1:   a---b---c---------d\nIf I understand correctly, you want to use imerge to do the merge at y, right?\nThe merge base for this merge is c. (See git-merge-base(1) for the definition of the merge base.) All of the changes that were introduced by a and b are already in 8 via the merge of x into master. So at y there should be no merge conflicts that involve the changes that were made in a and b.\nBut all of the changes made in 0..7 appear to the merge as if they were made in commit x, because that is the first commit that is a descendant of c that includes those changes.\nI think that if you had done a \"merge with history\" (i.e., retained the full incremental merge in your history), then you would have some additional context for the second imerge. Your history would look roughly like (I'm omitting some commits on master):\nmaster:  0------1------2-------7---------------8--9-10---11\n          \\                     \\             /       \\ /\nmerge-1    \\                     a'          /         y\n            \\                     \\         /         /\n             \\                     b'      /         /\n              \\      other          \\     /         /\n               \\                     c'  /         /\n                \\       stuff         \\ /         /\n         \\                 x         /\n                  \\        in         /         /\n                   \\                 7'        /\n                    \\        here   /         /\n                     \\             2'        /\n                      \\           /         /\n                       \\         1'        /\n                        \\       /         /\nrelease-1:               a--b--c---------d\nSo you would have to merge the changes from d with the commits 1', 2', 7', x, 8, 9, and 10, which is more or less the minimum that you could hope for. But retaining all that extra parentage information would be quite cumbersome given the current state of tooling.\nI hope that helps!\n. Yes, it is a very good idea. Are you willing to work on it? I'd be happy to help you get started.\n. ",
    "peff": "Yeah, the test-dirs branch looks sane. The important thing is sticking everything in tmp, and it looks like you even took some pains to let \"t/foo.sh\" work from the toplevel. Nifty.\n. Yeah, the test-dirs branch looks sane. The important thing is sticking everything in tmp, and it looks like you even took some pains to let \"t/foo.sh\" work from the toplevel. Nifty.\n. ",
    "mindjiver": "Yes, this was just a quick fix for now. I will continue to trial git-imerge at $DAY_JOB for some quite messed up feature branches.\n. Yes, this was just a quick fix for now. I will continue to trial git-imerge at $DAY_JOB for some quite messed up feature branches.\n. ",
    "knirch": "Ah. I was trying to add some debug data to tell you it still got stuck in a loop. It wasn't until I added a print of the arguments for remove_failure I noticed it was going down :)\nYou might want to add something to the unexpected error, or call it differently, because now it's quite scary. And perhaps visualize/tell the user that it's trying a different path.\nRegardless, yes, it works now :) \\o/ Thank you. :+1: \n. Sorry, I was throwing the net way too wide. Of the merge commit, it's ofcourse safe to ignore GIT_* variables and data, what I should have said is that the code in simplify_to_rebase_with_history / simplify_to_rebase should retain the author/committer/date information, just as it retains the original message, (the code right under \"# Create a commit, copying the old log message:\")\nIf there's a problem with --goal=merge I'm not sure, haven't used it, but it feels like it won't be a problem there.\n. Works for me:\n```\nimport os\nenv = dict(os.environ)\na = check_output([\n    'git',\n    'log', '-n1', '--format=%an%x1d%ae%x1d%at%x1d%cn%x1d%ce%x1d%ct',\n    orig\n]).strip().split('\\x1d')\nenv['GIT_AUTHOR_NAME'] = a[0]\nenv['GIT_AUTHOR_EMAIL'] = a[1]\nenv['GIT_AUTHOR_DATE'] = a[2]\nenv['GIT_COMMITTER_NAME'] = a[3]\nenv['GIT_COMMITTER_EMAIL'] = a[4]\nenv['GIT_COMMITTER_DATE'] = a[5]\n```\nand add env=env to the check_output command(s) where applicable (should probably be split out to a separate function etc)\n. Sent a --goal=rebase fix via https://github.com/mhagger/git-imerge/pull/9\n. True, fixed that in https://github.com/mhagger/git-imerge/pull/11\n. I was not entirely sure either, I guess if I started using that goal I'd be able to form an opinion. Thanks for merging.\n. Uhm, don't use this one, it'll clobber DST.\n. No, I just used the wrong % marker, changed it in my branch but forgot to send a new pull request. Fixing that now.\n. Sorry, forgot to add to the file before pushing it :(\n. Ah. I was trying to add some debug data to tell you it still got stuck in a loop. It wasn't until I added a print of the arguments for remove_failure I noticed it was going down :)\nYou might want to add something to the unexpected error, or call it differently, because now it's quite scary. And perhaps visualize/tell the user that it's trying a different path.\nRegardless, yes, it works now :) \\o/ Thank you. :+1: \n. Sorry, I was throwing the net way too wide. Of the merge commit, it's ofcourse safe to ignore GIT_* variables and data, what I should have said is that the code in simplify_to_rebase_with_history / simplify_to_rebase should retain the author/committer/date information, just as it retains the original message, (the code right under \"# Create a commit, copying the old log message:\")\nIf there's a problem with --goal=merge I'm not sure, haven't used it, but it feels like it won't be a problem there.\n. Works for me:\n```\nimport os\nenv = dict(os.environ)\na = check_output([\n    'git',\n    'log', '-n1', '--format=%an%x1d%ae%x1d%at%x1d%cn%x1d%ce%x1d%ct',\n    orig\n]).strip().split('\\x1d')\nenv['GIT_AUTHOR_NAME'] = a[0]\nenv['GIT_AUTHOR_EMAIL'] = a[1]\nenv['GIT_AUTHOR_DATE'] = a[2]\nenv['GIT_COMMITTER_NAME'] = a[3]\nenv['GIT_COMMITTER_EMAIL'] = a[4]\nenv['GIT_COMMITTER_DATE'] = a[5]\n```\nand add env=env to the check_output command(s) where applicable (should probably be split out to a separate function etc)\n. Sent a --goal=rebase fix via https://github.com/mhagger/git-imerge/pull/9\n. True, fixed that in https://github.com/mhagger/git-imerge/pull/11\n. I was not entirely sure either, I guess if I started using that goal I'd be able to form an opinion. Thanks for merging.\n. Uhm, don't use this one, it'll clobber DST.\n. No, I just used the wrong % marker, changed it in my branch but forgot to send a new pull request. Fixing that now.\n. Sorry, forgot to add to the file before pushing it :(\n. ",
    "waldyrious": "For future reference,\n\nI just pushed a change to master that I think will fix your problem.\n\nrefers to 914aa3c32, and \n\nI also pushed a change to the error message for \"unexpected failure\".\n\nrefers to c41fa1805.. @habnabit's trick didn't work for me, but I solved the problem by adding an additional change (just whitespace adjustment) while fixing the conflict, so that there would be something to commit. I just added the file and did git imerge continue as usual.\n. I'm just a curious onlooker, very much a git noob, but I did have a similar idea a while ago, let me know if it's what you're talking about or if it'd be worth opening a separate issue for it: I was wondering whether creating this kind of helper commits could be automatically managed by git-imerge, i.e.: whenever git-imerge finds a conflict, it could be that the commits aren't modular enough, so what if it tried splitting the involved commits using the same splitting method used in git add -p? Maybe then the merge could proceed automatically, rather than the user explicitly creating commit H as in your example above (unless I misunderstood and you meant the commit would be created automatically?).\nAnother question I had was whether using a different merge algorithm (Patience, Diff Match and Patch, maybe others?) could be used as an attempt to automatically resolve conflicts that the default diff algorithm fails to deal with. But this is probably worth a separate issue, if at all (let me know).\n. > It is approximately true that a merge only fails if there is a conflict within a single hunk of the diff. Since git add -p works hunk by hunk, it wouldn't be able to subdivide the conflict in any useful way.\nI see, thanks for clarifying. It makes sense that it works that way already. So the H commit you're talking about would be manually created, and in a non-trivial way, I suppose?\n\nIt seems like a reasonable thing to implement, though it is pretty much unrelated to this issue.\n\nYes, sorry, it was silly of me to tack that into this issue. Anyway, I was thinking about git-imerge automatically trying different options to git-merge in case it finds a conflict with the default option, in the hopes that some of those could solve the issue. I have no idea whether that would be likely to make a difference, though.\nHaving explicit options for the user would be a nice extra, but I'm not sure that would be particularly useful or elegant, unless the user could predict which diffing algorithm would work best for their merge, and I assume most people aren't prepared to do that. Therefore, if there is to be any trial-and-error, I'd rather have the computer do it than myself.\n. @mhagger I'm very interested in the \"break off an incremental merge before all of the conflicts are resolved\" use case. Could you give a few hints in how to do that? Just the basis steps to get started, later I'd gladly contribute something more fleshed out to the readme :)\n. @rulatir Could you submit a PR with instructions on how to do this? I would do it myself but I'm not 100% sure I got exactly what you wrote.\n. I believe I understand, thanks for the detailed explanation. I was indeed referring to an edit to the README, specifically the sequence of commands you'd recommend. Would it then be git-imerge remove then git checkout <original branch>?\nI suppose this should go in the \"Suspending/resuming\" section (whose title could have \"/aborting\" appended), but should that text be reworked as well?\nLast time I tried using this on a huge, nasty conflict (line-ending changes across multiple files interfering with changes on those files), I eventually decided to give up, but the instructions on that section got me into an even worse (so I thought) state. I can't recall the details exactly, but I believe I tried resolving a manual merge, committing (per the instructions git-imerge gave me), then I decided to back off by doing git merge --abort; but then the tree was all messed up, and git imerge continue gave me an error message about commits not having the right parents, IIRC. Of course, this is only tangentially related, and probably my fault, so if the text there looks good and unambiguous to you, let's just add the extra paragraph about completely aborting the incremental merge.\n. That's what I thought, thanks for confirming :)\nFor reference, my question was due to the instructions as written in http://softwareswirl.blogspot.pt/2013/05/git-imerge-practical-introduction.html (which is linked in the README):\n\nWhen you are done, simplify the incremental merge into a simple merge, a simple rebase, or a rebase-with-history:\n$ git imerge finish --goal=merge\n\nIf you'd like, clarifying that section of the post would probably prevent others from having this same question.\n. > These operations can both conflict, so they both can benefit from using the incremental merge approach.\n@mhagger I feel that this point is not clear enough in the documentation (README, and possibly help message of those subcommands). Without this clarification, it feels like the two commands introduced here do not really belong with git-imerge, and make the tool seemingly break the Unix philosophy.\nDo you think you could add that clarification in the relevant places? Otherwise, if you'd give me some pointers about which files to edit and how, I could take a stab at doing this.. Awesome, I'll give it a try sometime soon :). I decided to go ahead with a simple change to the README for now, as the more ambitious approach would likely take quite a bit longer to manifest \ud83d\ude07 . This would be very useful. So far I've been using the git-imerge diagram command every now and then, but a nice progress message would free me of that need (I'd still do it because it's nice to look at the diagram :D)\n. This is related to #101 -- I believe that functionality would work perfectly for this use case. Can you confirm, @mulle-nat?\n. Oh, I see. Sorry for the noise, then.\n. Ah, I see, this is a dupe of #112.. That's very thorough, thanks!\n\nWhat should happen if the user runs git imerge abort after having been on a detached HEAD? Maybe nothing? Maybe restore to the SHA-1 that they were on (if it still exists)?)\n\nAs a user, I'd expect the latter.\n\ngit imerge abort should only switch back to the starting branch if it still exists, if the working tree is clean, and perhaps only if the temporary branch is currently checked out. \n\nSounds reasonable to me.\nI've only dabbled with Python programming with small, one-off scripts, and local fixes to larger programs, so I'll try to set aside some time to attempt an implementation in the next few days, and submit it as a PR for further feedback and refinement.\n. For future reference,\n\nI just pushed a change to master that I think will fix your problem.\n\nrefers to 914aa3c32, and \n\nI also pushed a change to the error message for \"unexpected failure\".\n\nrefers to c41fa1805.. @habnabit's trick didn't work for me, but I solved the problem by adding an additional change (just whitespace adjustment) while fixing the conflict, so that there would be something to commit. I just added the file and did git imerge continue as usual.\n. I'm just a curious onlooker, very much a git noob, but I did have a similar idea a while ago, let me know if it's what you're talking about or if it'd be worth opening a separate issue for it: I was wondering whether creating this kind of helper commits could be automatically managed by git-imerge, i.e.: whenever git-imerge finds a conflict, it could be that the commits aren't modular enough, so what if it tried splitting the involved commits using the same splitting method used in git add -p? Maybe then the merge could proceed automatically, rather than the user explicitly creating commit H as in your example above (unless I misunderstood and you meant the commit would be created automatically?).\nAnother question I had was whether using a different merge algorithm (Patience, Diff Match and Patch, maybe others?) could be used as an attempt to automatically resolve conflicts that the default diff algorithm fails to deal with. But this is probably worth a separate issue, if at all (let me know).\n. > It is approximately true that a merge only fails if there is a conflict within a single hunk of the diff. Since git add -p works hunk by hunk, it wouldn't be able to subdivide the conflict in any useful way.\nI see, thanks for clarifying. It makes sense that it works that way already. So the H commit you're talking about would be manually created, and in a non-trivial way, I suppose?\n\nIt seems like a reasonable thing to implement, though it is pretty much unrelated to this issue.\n\nYes, sorry, it was silly of me to tack that into this issue. Anyway, I was thinking about git-imerge automatically trying different options to git-merge in case it finds a conflict with the default option, in the hopes that some of those could solve the issue. I have no idea whether that would be likely to make a difference, though.\nHaving explicit options for the user would be a nice extra, but I'm not sure that would be particularly useful or elegant, unless the user could predict which diffing algorithm would work best for their merge, and I assume most people aren't prepared to do that. Therefore, if there is to be any trial-and-error, I'd rather have the computer do it than myself.\n. @mhagger I'm very interested in the \"break off an incremental merge before all of the conflicts are resolved\" use case. Could you give a few hints in how to do that? Just the basis steps to get started, later I'd gladly contribute something more fleshed out to the readme :)\n. @rulatir Could you submit a PR with instructions on how to do this? I would do it myself but I'm not 100% sure I got exactly what you wrote.\n. I believe I understand, thanks for the detailed explanation. I was indeed referring to an edit to the README, specifically the sequence of commands you'd recommend. Would it then be git-imerge remove then git checkout <original branch>?\nI suppose this should go in the \"Suspending/resuming\" section (whose title could have \"/aborting\" appended), but should that text be reworked as well?\nLast time I tried using this on a huge, nasty conflict (line-ending changes across multiple files interfering with changes on those files), I eventually decided to give up, but the instructions on that section got me into an even worse (so I thought) state. I can't recall the details exactly, but I believe I tried resolving a manual merge, committing (per the instructions git-imerge gave me), then I decided to back off by doing git merge --abort; but then the tree was all messed up, and git imerge continue gave me an error message about commits not having the right parents, IIRC. Of course, this is only tangentially related, and probably my fault, so if the text there looks good and unambiguous to you, let's just add the extra paragraph about completely aborting the incremental merge.\n. That's what I thought, thanks for confirming :)\nFor reference, my question was due to the instructions as written in http://softwareswirl.blogspot.pt/2013/05/git-imerge-practical-introduction.html (which is linked in the README):\n\nWhen you are done, simplify the incremental merge into a simple merge, a simple rebase, or a rebase-with-history:\n$ git imerge finish --goal=merge\n\nIf you'd like, clarifying that section of the post would probably prevent others from having this same question.\n. > These operations can both conflict, so they both can benefit from using the incremental merge approach.\n@mhagger I feel that this point is not clear enough in the documentation (README, and possibly help message of those subcommands). Without this clarification, it feels like the two commands introduced here do not really belong with git-imerge, and make the tool seemingly break the Unix philosophy.\nDo you think you could add that clarification in the relevant places? Otherwise, if you'd give me some pointers about which files to edit and how, I could take a stab at doing this.. Awesome, I'll give it a try sometime soon :). I decided to go ahead with a simple change to the README for now, as the more ambitious approach would likely take quite a bit longer to manifest \ud83d\ude07 . This would be very useful. So far I've been using the git-imerge diagram command every now and then, but a nice progress message would free me of that need (I'd still do it because it's nice to look at the diagram :D)\n. This is related to #101 -- I believe that functionality would work perfectly for this use case. Can you confirm, @mulle-nat?\n. Oh, I see. Sorry for the noise, then.\n. Ah, I see, this is a dupe of #112.. That's very thorough, thanks!\n\nWhat should happen if the user runs git imerge abort after having been on a detached HEAD? Maybe nothing? Maybe restore to the SHA-1 that they were on (if it still exists)?)\n\nAs a user, I'd expect the latter.\n\ngit imerge abort should only switch back to the starting branch if it still exists, if the working tree is clean, and perhaps only if the temporary branch is currently checked out. \n\nSounds reasonable to me.\nI've only dabbled with Python programming with small, one-off scripts, and local fixes to larger programs, so I'll try to set aside some time to attempt an implementation in the next few days, and submit it as a PR for further feedback and refinement.\n. ",
    "tnaumann": "When the build/install infrastructure has been created, please create a formula for mxcl/hombrew for easy installation on OSX.\n. When the build/install infrastructure has been created, please create a formula for mxcl/hombrew for easy installation on OSX.\n. ",
    "alexgorbatchev": "It would be great to at least have installation instructions for non-python folks.\n. btw, brew install works...\n```\n\u279c  ~ brew install git-imerge\n==> Downloading https://homebrew.bintray.com/bottles/git-imerge-0.7.0.yosemite.bottle.1.tar.gz\n################################################################## 100.0%\n==> Pouring git-imerge-0.7.0.yosemite.bottle.1.tar.gz\n\ud83c\udf7a  /usr/local/Cellar/git-imerge/0.7.0: 5 files, 142.1K\n```\n. It would be great to at least have installation instructions for non-python folks.\n. btw, brew install works...\n```\n\u279c  ~ brew install git-imerge\n==> Downloading https://homebrew.bintray.com/bottles/git-imerge-0.7.0.yosemite.bottle.1.tar.gz\n################################################################## 100.0%\n==> Pouring git-imerge-0.7.0.yosemite.bottle.1.tar.gz\n\ud83c\udf7a  /usr/local/Cellar/git-imerge/0.7.0: 5 files, 142.1K\n```\n. ",
    "jherland": "I force-pushed the new commit (rebased, and with your fix). It seems this pull request now automatically refers to the new commit (fc6575e), so I won't bother opening a new pull request...\n. Superseded by https://github.com/mhagger/git-imerge/pull/12\n. Rebased verision in https://github.com/mhagger/git-imerge/pull/13\n. Yes, embedding CSS is the easiest way to get it there, but (a) I thought the patch was ugly enough as-is, and (b) having it in a separate file separates the semantics from the presentation.\nYes, I've been thinking along the same lines with running the incremental merge from a webserver. That would make it possible to collaborate on a merge without even pushing and pulling between repos. Obviously, that comes at the cost of not (easily) being able to compile and test the code on your own machine, which probably defeats the idea in most use cases (unless if your \"codebase\" is not compilable/testable, e.g. a book or a collection of written prose, etc.)\n. If you have no further issues, I'll rebase to fold in the fixups and you cna merge that. Coming up...\n. Obsoleted by https://github.com/mhagger/git-imerge/pull/15\n. I don't know much about ANSI colors on Windows and under which circumstances they do or do not work...\nIMHO, we should wait for @jakub-g's answer to the above comment from @lucaswerkmeister, to see what exactly causes this to not work for him, while it seems to work for others.\nIf the problem is that @jakub-g's terminal simply does not support colors, we should add another condition to the options.color handling in main(), to detect the lack of color support and disable AnsiColors accordingly.\nOtherwise, if colors are supported with different escapes/logic in @jakub-g's case, then we should add an alternative to the AnsiColors class (with the same interface) and then choose which of them to use in main().\nI've looked at the links given by @mhagger, and  AFAICS we should be able solve this without having to add a dependency on third-party python modules.\n. I force-pushed the new commit (rebased, and with your fix). It seems this pull request now automatically refers to the new commit (fc6575e), so I won't bother opening a new pull request...\n. Superseded by https://github.com/mhagger/git-imerge/pull/12\n. Rebased verision in https://github.com/mhagger/git-imerge/pull/13\n. Yes, embedding CSS is the easiest way to get it there, but (a) I thought the patch was ugly enough as-is, and (b) having it in a separate file separates the semantics from the presentation.\nYes, I've been thinking along the same lines with running the incremental merge from a webserver. That would make it possible to collaborate on a merge without even pushing and pulling between repos. Obviously, that comes at the cost of not (easily) being able to compile and test the code on your own machine, which probably defeats the idea in most use cases (unless if your \"codebase\" is not compilable/testable, e.g. a book or a collection of written prose, etc.)\n. If you have no further issues, I'll rebase to fold in the fixups and you cna merge that. Coming up...\n. Obsoleted by https://github.com/mhagger/git-imerge/pull/15\n. I don't know much about ANSI colors on Windows and under which circumstances they do or do not work...\nIMHO, we should wait for @jakub-g's answer to the above comment from @lucaswerkmeister, to see what exactly causes this to not work for him, while it seems to work for others.\nIf the problem is that @jakub-g's terminal simply does not support colors, we should add another condition to the options.color handling in main(), to detect the lack of color support and disable AnsiColors accordingly.\nOtherwise, if colors are supported with different escapes/logic in @jakub-g's case, then we should add an alternative to the AnsiColors class (with the same interface) and then choose which of them to use in main().\nI've looked at the links given by @mhagger, and  AFAICS we should be able solve this without having to add a dependency on third-party python modules.\n. ",
    "jdelStrother": "Yeah - agreed that it's probably not something you want to be an all-or-nothing thing.  And I guess that you probably want to avoid firing expensive hooks during the automerge, but might want to fire them during the interactive checkouts (eg where you're resolving merge conflicts).\nI was trying to figure out other places in git that might use something similar where imerge could mimic its functionality, but I'm not coming up with much.  I guess git-rebase also suffers from this, though it's less noticeable because it's doing way less work.  It would be nice if the GIT_IMERGE_STATE thing was generic enough to cover rebase use cases as well.\nSeems like a hard problem to solve... maybe I should just make my ctag scripts smarter :)\n. Python 2.x comes installed on OS X, as python.  OS X 10.9 comes with python 2.7.5.  There's no python2 by default\n. Yeah - agreed that it's probably not something you want to be an all-or-nothing thing.  And I guess that you probably want to avoid firing expensive hooks during the automerge, but might want to fire them during the interactive checkouts (eg where you're resolving merge conflicts).\nI was trying to figure out other places in git that might use something similar where imerge could mimic its functionality, but I'm not coming up with much.  I guess git-rebase also suffers from this, though it's less noticeable because it's doing way less work.  It would be nice if the GIT_IMERGE_STATE thing was generic enough to cover rebase use cases as well.\nSeems like a hard problem to solve... maybe I should just make my ctag scripts smarter :)\n. Python 2.x comes installed on OS X, as python.  OS X 10.9 comes with python 2.7.5.  There's no python2 by default\n. ",
    "myint": "I resolved this by supporting both Python 2 and 3. @mhagger, if you are interested, I can either send a pull requests or you can just merge my fork. The continuous integration server shows the test results.\n. Like @jdelStrother mentioned, python2 doesn't exist on OS X. An OS X user could just create a symlink called python2 and point it to /usr/bin/python. I happen to use Python 3 by default so my use case only tangentially relates to this issue (#18).\nI've enabled the Python 2.6 test on Travis CI (450e72831e09ceb4e312d0d07b035d7db870f697). It works. See test results here.\nI could enable Python 2.5 support, but the code will get a bit uglier. (The as exception syntax, which Python 3 requires, isn't supported in Python 2.5 and there are a few other things like what you mentioned.) And I think the trend in Python now is to support Python 2.6, 2.7, and 3.3.\n. Great! By the way, as far as I know the as exception syntax was introduced in Python 2.6 proper. The 2.6.1 change log mentions it too, but only because the change log is cumulative. (I don't think Python developers introduce syntax changes in patch releases.)\n. Looks good to me.\n. Any particular reason why? The .travis.yml doesn't do anything unless you enable Travis CI via the web-based settings.\nIn any case see #48.\n. I resolved this by supporting both Python 2 and 3. @mhagger, if you are interested, I can either send a pull requests or you can just merge my fork. The continuous integration server shows the test results.\n. Like @jdelStrother mentioned, python2 doesn't exist on OS X. An OS X user could just create a symlink called python2 and point it to /usr/bin/python. I happen to use Python 3 by default so my use case only tangentially relates to this issue (#18).\nI've enabled the Python 2.6 test on Travis CI (450e72831e09ceb4e312d0d07b035d7db870f697). It works. See test results here.\nI could enable Python 2.5 support, but the code will get a bit uglier. (The as exception syntax, which Python 3 requires, isn't supported in Python 2.5 and there are a few other things like what you mentioned.) And I think the trend in Python now is to support Python 2.6, 2.7, and 3.3.\n. Great! By the way, as far as I know the as exception syntax was introduced in Python 2.6 proper. The 2.6.1 change log mentions it too, but only because the change log is cumulative. (I don't think Python developers introduce syntax changes in patch releases.)\n. Looks good to me.\n. Any particular reason why? The .travis.yml doesn't do anything unless you enable Travis CI via the web-based settings.\nIn any case see #48.\n. ",
    "mspaulding06": "Thanks for the explanation, that makes sense. I guess I got lucky this time that the merge went well and generated few merge conflicts for such a large project :)\n. Thanks for the explanation, that makes sense. I guess I got lucky this time that the merge went well and generated few merge conflicts for such a large project :)\n. ",
    "muff1nman": "I think this would be a cool feature to have.  Just to make sure Im on the same track.\nSay you have a history like so:\no - A - B - C\n       \\  - D - E  - F - G - H\nAnd I want to rebase G and beyond onto A,B,C:\no - A - B - C - G' - H'\n       \\  - D - E - F\nIn order to do this with git imerge, the following would need to happen:\n1. \"Remove\" commits before the first commit of the rebase but after the first common parent between the branch you are rebasing from and the branch you are rebasing onto, in this case (A).  In order to do this, iterate backwards.\no - A   -   D   -  E   -   F   -   G   -   H\n                           |       |       |\n                           F\u207b\u00b9 -   G'  -   H''\no - A   -   D   -  E   -   F   -   G   -   H\n                   |       |       |       |\n                   |       F\u207b\u00b9 -   G'  -   H''\n                   |               |       | \n                   E\u207b\u00b9   ------    G''  -  H''\no - A   -   D   -  E   -   F   -   G   -   H\n            |      |       |       |       |\n            |      |       F\u207b\u00b9 -   G'  -   H''\n            |      |               |       |\n            |      E\u207b\u00b9 --------   G''  -   H''\n            |                     |        |\n            D\u207b\u00b9 ---------------- G'''  -  H'''\nAnd possibly for completeness sake (although hopefully this last merge is a near noop)\no - A   -   D   -  E   -   F   -   G    -   H\n    |       |      |       |       |        |\n    |       |      |      F\u207b\u00b9  -   G'   -   H''\n    |       |      |               |        |\n    |       |     E\u207b\u00b9   ------     G''  -   H''\n    |       |                      |        |\n    |      D\u207b\u00b9 ----------------    G''' -   H'''\n    |                              |        |\n    +----------------------------  G''''-   H''''\nAt this point, if you ignore the intermediate steps we have\n-  G'''' - H''''\n      /\no - A - B - C\n       \\\n         - D - E - F\nNow, the problem has been reduced to a more simpler rebase at which git-imerge would essentially be rerun.\no  -  A  -  B  -  C\n|                 |\nG''''             G'''''\n|                 |\nH'''' --------    H'''''\nAnd we have our end result.   I suppose I would be interested in the kind of merge conflicts this procedure would uncover or if conflicts would seem redundant (i.e. slowly removing a piece of the code base). But maybe this redundancy is desired to ensure a smooth iterative process?\nAlso, would this same process work if you had merges in your branch to rebase from history?  I'm not sure how well git reverts merges...\nEdit:  Fixed diagrams and note to self to never try type ascii diagrams directly into github's text editor.\n. I do like the simplification you present and it makes sense. However, how would\nthe end history end up?  I think it would be nice if the situation in your\nsecond diagram:\no - A   -   D   -  E   -   F   -   G    -   H\n                           |       |        |\n                          F\u207b\u00b9  -   G'   -   H'\n                           |       |        |\n                          E\u207b\u00b9  -   G''  -   H''\n                           |       |        |\n                          D\u207b\u00b9  -   G''' -   H'''\ncould be simplified like so:\no - A  -  G''' -   H'''\nMy thoughts are that I would like to be able to hide D,E,F from the\nhistory entirely. How is this done in the usual git-imerge case of a merge?  I.e. going from:\nA - B - C\n|   |   |\nD - D'- D''\n|   |   |\nE - E'- E''\nto\nA - B - C\n|       |\nD       |\n|       |\nE - - - M\nThe possiblity for different methods is not something I thought of before and\nideally I think it would be cool for the user to choose a method.  For now, however, I think the first option presents a more logical progression of merging.\n. Ah, I must have overlooked the simplify, remove and finish options.\n. It wouldn't be as necessary with the extension. It would at least be able\nto recognize it as a python file. However the modeline is also nice because\nit keeps contributors on the same page as far as spaces vs tabs or even\nnumber of spaces in a tab. For example, although my global settings are set\nto use tabs instead of spaces, the modeline overrides my settings to use\nspaces instead of tabs for that file. Hope that helps.\nOn Feb 23, 2014 11:36 PM, \"Michael Haggerty\" notifications@github.com\nwrote:\n\nThanks for the contribution. I just merged it.\n@muff1nman https://github.com/muff1nman, I have a question: I'm\nthinking about reorganizing the source code to move most of git-imerge's\ncode into a Python module, probably called something like\ngit_imerge/git_imerge.py. Would the modeline still be necessary if I make\nthat change, or would vim automatically choose the right mode based on the\n.py file extension?\n\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/pull/53#issuecomment-35858990\n.\n. Also, I think converting to a python module is a fantastic idea. I almost\ngave up trying to read the source were it not for vim's folding.\nOn Feb 24, 2014 8:23 AM, \"Andrew DeMaria\" lostonamountain@gmail.com wrote:\nIt wouldn't be as necessary with the extension. It would at least be able\nto recognize it as a python file. However the modeline is also nice because\nit keeps contributors on the same page as far as spaces vs tabs or even\nnumber of spaces in a tab. For example, although my global settings are set\nto use tabs instead of spaces, the modeline overrides my settings to use\nspaces instead of tabs for that file. Hope that helps.\nOn Feb 23, 2014 11:36 PM, \"Michael Haggerty\" notifications@github.com\nwrote:\n\nThanks for the contribution. I just merged it.\n@muff1nman https://github.com/muff1nman, I have a question: I'm\nthinking about reorganizing the source code to move most of git-imerge's\ncode into a Python module, probably called something like\ngit_imerge/git_imerge.py. Would the modeline still be necessary if I\nmake that change, or would vim automatically choose the right mode based on\nthe .py file extension?\n\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/pull/53#issuecomment-35858990\n.\n. I think it would be prudent to add more tests.  Any thoughts on adding support for a testing framework?\n. Absolutely.  Ill try my best to clean up the history every now and then.\n. Ah. I must have skipped that attribute in the setup.py.  Ill add it.\n\n\nI like the link you had in #54 although my thoughts are that we should start simple and only add something like that if we find we need the extra granularity.  I have been looking around at other python projects and here is another idea.\n\nAbsolutely! Are you trying to make me fall in love with you or something, because I should warn you that I'm already married :wink:\n\nHaha.  Frankly Im afraid to start moving code around until I feel like there are some tests that will protect the status quo a bit.\n. Hmm. Yes I would agree that separating out tests into a different PR would be sensible. It should probably be done first. I'll see what I can do.\n. I think this would be a cool feature to have.  Just to make sure Im on the same track.\nSay you have a history like so:\no - A - B - C\n       \\  - D - E  - F - G - H\nAnd I want to rebase G and beyond onto A,B,C:\no - A - B - C - G' - H'\n       \\  - D - E - F\nIn order to do this with git imerge, the following would need to happen:\n1. \"Remove\" commits before the first commit of the rebase but after the first common parent between the branch you are rebasing from and the branch you are rebasing onto, in this case (A).  In order to do this, iterate backwards.\no - A   -   D   -  E   -   F   -   G   -   H\n                           |       |       |\n                           F\u207b\u00b9 -   G'  -   H''\no - A   -   D   -  E   -   F   -   G   -   H\n                   |       |       |       |\n                   |       F\u207b\u00b9 -   G'  -   H''\n                   |               |       | \n                   E\u207b\u00b9   ------    G''  -  H''\no - A   -   D   -  E   -   F   -   G   -   H\n            |      |       |       |       |\n            |      |       F\u207b\u00b9 -   G'  -   H''\n            |      |               |       |\n            |      E\u207b\u00b9 --------   G''  -   H''\n            |                     |        |\n            D\u207b\u00b9 ---------------- G'''  -  H'''\nAnd possibly for completeness sake (although hopefully this last merge is a near noop)\no - A   -   D   -  E   -   F   -   G    -   H\n    |       |      |       |       |        |\n    |       |      |      F\u207b\u00b9  -   G'   -   H''\n    |       |      |               |        |\n    |       |     E\u207b\u00b9   ------     G''  -   H''\n    |       |                      |        |\n    |      D\u207b\u00b9 ----------------    G''' -   H'''\n    |                              |        |\n    +----------------------------  G''''-   H''''\nAt this point, if you ignore the intermediate steps we have\n-  G'''' - H''''\n      /\no - A - B - C\n       \\\n         - D - E - F\nNow, the problem has been reduced to a more simpler rebase at which git-imerge would essentially be rerun.\no  -  A  -  B  -  C\n|                 |\nG''''             G'''''\n|                 |\nH'''' --------    H'''''\nAnd we have our end result.   I suppose I would be interested in the kind of merge conflicts this procedure would uncover or if conflicts would seem redundant (i.e. slowly removing a piece of the code base). But maybe this redundancy is desired to ensure a smooth iterative process?\nAlso, would this same process work if you had merges in your branch to rebase from history?  I'm not sure how well git reverts merges...\nEdit:  Fixed diagrams and note to self to never try type ascii diagrams directly into github's text editor.\n. I do like the simplification you present and it makes sense. However, how would\nthe end history end up?  I think it would be nice if the situation in your\nsecond diagram:\no - A   -   D   -  E   -   F   -   G    -   H\n                           |       |        |\n                          F\u207b\u00b9  -   G'   -   H'\n                           |       |        |\n                          E\u207b\u00b9  -   G''  -   H''\n                           |       |        |\n                          D\u207b\u00b9  -   G''' -   H'''\ncould be simplified like so:\no - A  -  G''' -   H'''\nMy thoughts are that I would like to be able to hide D,E,F from the\nhistory entirely. How is this done in the usual git-imerge case of a merge?  I.e. going from:\nA - B - C\n|   |   |\nD - D'- D''\n|   |   |\nE - E'- E''\nto\nA - B - C\n|       |\nD       |\n|       |\nE - - - M\nThe possiblity for different methods is not something I thought of before and\nideally I think it would be cool for the user to choose a method.  For now, however, I think the first option presents a more logical progression of merging.\n. Ah, I must have overlooked the simplify, remove and finish options.\n. It wouldn't be as necessary with the extension. It would at least be able\nto recognize it as a python file. However the modeline is also nice because\nit keeps contributors on the same page as far as spaces vs tabs or even\nnumber of spaces in a tab. For example, although my global settings are set\nto use tabs instead of spaces, the modeline overrides my settings to use\nspaces instead of tabs for that file. Hope that helps.\nOn Feb 23, 2014 11:36 PM, \"Michael Haggerty\" notifications@github.com\nwrote:\n\nThanks for the contribution. I just merged it.\n@muff1nman https://github.com/muff1nman, I have a question: I'm\nthinking about reorganizing the source code to move most of git-imerge's\ncode into a Python module, probably called something like\ngit_imerge/git_imerge.py. Would the modeline still be necessary if I make\nthat change, or would vim automatically choose the right mode based on the\n.py file extension?\n\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/pull/53#issuecomment-35858990\n.\n. Also, I think converting to a python module is a fantastic idea. I almost\ngave up trying to read the source were it not for vim's folding.\nOn Feb 24, 2014 8:23 AM, \"Andrew DeMaria\" lostonamountain@gmail.com wrote:\nIt wouldn't be as necessary with the extension. It would at least be able\nto recognize it as a python file. However the modeline is also nice because\nit keeps contributors on the same page as far as spaces vs tabs or even\nnumber of spaces in a tab. For example, although my global settings are set\nto use tabs instead of spaces, the modeline overrides my settings to use\nspaces instead of tabs for that file. Hope that helps.\nOn Feb 23, 2014 11:36 PM, \"Michael Haggerty\" notifications@github.com\nwrote:\n\nThanks for the contribution. I just merged it.\n@muff1nman https://github.com/muff1nman, I have a question: I'm\nthinking about reorganizing the source code to move most of git-imerge's\ncode into a Python module, probably called something like\ngit_imerge/git_imerge.py. Would the modeline still be necessary if I\nmake that change, or would vim automatically choose the right mode based on\nthe .py file extension?\n\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/pull/53#issuecomment-35858990\n.\n. I think it would be prudent to add more tests.  Any thoughts on adding support for a testing framework?\n. Absolutely.  Ill try my best to clean up the history every now and then.\n. Ah. I must have skipped that attribute in the setup.py.  Ill add it.\n\n\nI like the link you had in #54 although my thoughts are that we should start simple and only add something like that if we find we need the extra granularity.  I have been looking around at other python projects and here is another idea.\n\nAbsolutely! Are you trying to make me fall in love with you or something, because I should warn you that I'm already married :wink:\n\nHaha.  Frankly Im afraid to start moving code around until I feel like there are some tests that will protect the status quo a bit.\n. Hmm. Yes I would agree that separating out tests into a different PR would be sensible. It should probably be done first. I'll see what I can do.\n. ",
    "dwijnand": "Thanks for all the information.\nI was concerned about my having rerere enabled would cause issues, so I'm\nhappy that you already disable that :) Perhaps that should be added to the\ndocumentation?\nOn 20 July 2013 15:55, Michael Haggerty notifications@github.com wrote:\n\nrerere tucks away information about attempted merges, and uses that\ninformation to affect future merge attempts. This makes the result of a\nparticular merge depend not only on the commits that are being merged, but\nalso on the history of merges that have been done previously.\nSince git-imerge attempts so many similar merges, it is easy to expect\nthat this will confuse git-imerge. And indeed, during testing, it seemed\nlike rerere in combination with imerge was causing merge conflicts to be\nresolved incorrectly sometimes. Therefore, git-imerge explicitly turns\nrerere off when it shells out to git.\nMeanwhile, I expect that the incremental merges done by git-imerge\nwouldn't benefit so much from rerere anyway, at least within a single\nincremental merge. This is because the micromerges are recorded in the\nDAG and so their merge resolution is already available to Git without the\nneed for additional rerere data. Moreover, the fact that rerere data is\nlocal would make it more difficult to collaborate on incremental merges.\nWhere rerere might help would be if, for example, an imerge is\nattempted multiple times, or part of the conflicts involved in the imerge\nhave already been attempted previously as part of a simple merge or rebase.\nIn that case some of the conflict resolution might be able to be carried\nacross from one merge to another, reducing the number of conflicts that\nhave to be resolved manually.\nSo....\nIt might be advantageous to combine rerere with git-imerge, but it would\nneed some careful testing and thought before I would recommend it. Maybe\none could gain the advantages without suffering from the problems by using\nrerere more selectively; for example, turning it on for manual merges but\nturning it off for automatic merges.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/issues/21#issuecomment-21294731\n.\n. I would like to work on it, but have a bit too much on my plate at the\nmoment. :(\n\nOn 20 July 2013 15:58, Michael Haggerty notifications@github.com wrote:\n\nThat's a great idea, and one that somebody else has also wished for. If\nyou would like to work on it, I would be happy to help you get started.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/issues/22#issuecomment-21294770\n.\n. Thanks for all the detail.\n\nThe way I went (which as you said was the obvious solution) was to rebase\nonto master on every master commit.\nThen as I began having \"clients\" of my refactor branch, I went with the\nfollowing setup:\n- develop-wip is the branch I continue to do work on, and rebase at will to\n  the tip of master\n- develop is never rebased and merges in develop-wip constantly, and is the\n  branch that is used by others\nWhen the refactor work is finished and \"signed-off\" then master will be\nfast-forwarded to the tip of develop-wip, and I'll get previous users of\ndevelop to move back to master (and remove develop & develop-wip branches).\nOn 20 July 2013 16:13, Michael Haggerty notifications@github.com wrote:\n\nYes, I think that should work fine.\nOne obvious approach would be to rebase (or rebase-with-history) the\ncurrent state of the refactoring branch to the current state of master, and\njust repeat this step periodically as master progresses. This would have\nthe benefit that after you do a rebase, the subsequent work that you do on\nthe branch will be on top of the changes that have been done on trunk\nbetween the branch's old branch point and its new branch point, so you will\nintrinsically have fewer conflicts.\nIf the incremental merge is too much work to do at once, you could also\nwork on the incremental merge across several sittings, simply leaving the\nin-progress imerge in your repo between attempts. If work on master or\n(especially) branch continue during your imerge, you could leave the\nresults of the first incremental merge in your repo and expand the\ncompleted part of the incremental merge diagram one rectangle at a time.\nSo, for example, if the first imerge was \"imerge1\", then you could do\ngit checkout imerge1\ngit imerge start --name=imerge2 --goal=GOAL --first-parent wipbranch\nwhere \"wipbranch\" is the current state of the WIP branch, which includes\nmore commits than the ones that were included in imerge1. The only thing\nthat might be awkward is simplifying the final imerge into the rebase that\nyou ultimately want. Given the current state of imerge, you would have to\ndo that by hand using the \"git imerge reparent\" command or other fancy Git\ntrickery.\nCertainly, git-imerge could be made to support this workflow better.\nContributions are welcome.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/issues/23#issuecomment-21295019\n.\n. Thanks for all the information.\n\nI was concerned about my having rerere enabled would cause issues, so I'm\nhappy that you already disable that :) Perhaps that should be added to the\ndocumentation?\nOn 20 July 2013 15:55, Michael Haggerty notifications@github.com wrote:\n\nrerere tucks away information about attempted merges, and uses that\ninformation to affect future merge attempts. This makes the result of a\nparticular merge depend not only on the commits that are being merged, but\nalso on the history of merges that have been done previously.\nSince git-imerge attempts so many similar merges, it is easy to expect\nthat this will confuse git-imerge. And indeed, during testing, it seemed\nlike rerere in combination with imerge was causing merge conflicts to be\nresolved incorrectly sometimes. Therefore, git-imerge explicitly turns\nrerere off when it shells out to git.\nMeanwhile, I expect that the incremental merges done by git-imerge\nwouldn't benefit so much from rerere anyway, at least within a single\nincremental merge. This is because the micromerges are recorded in the\nDAG and so their merge resolution is already available to Git without the\nneed for additional rerere data. Moreover, the fact that rerere data is\nlocal would make it more difficult to collaborate on incremental merges.\nWhere rerere might help would be if, for example, an imerge is\nattempted multiple times, or part of the conflicts involved in the imerge\nhave already been attempted previously as part of a simple merge or rebase.\nIn that case some of the conflict resolution might be able to be carried\nacross from one merge to another, reducing the number of conflicts that\nhave to be resolved manually.\nSo....\nIt might be advantageous to combine rerere with git-imerge, but it would\nneed some careful testing and thought before I would recommend it. Maybe\none could gain the advantages without suffering from the problems by using\nrerere more selectively; for example, turning it on for manual merges but\nturning it off for automatic merges.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/issues/21#issuecomment-21294731\n.\n. I would like to work on it, but have a bit too much on my plate at the\nmoment. :(\n\nOn 20 July 2013 15:58, Michael Haggerty notifications@github.com wrote:\n\nThat's a great idea, and one that somebody else has also wished for. If\nyou would like to work on it, I would be happy to help you get started.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/issues/22#issuecomment-21294770\n.\n. Thanks for all the detail.\n\nThe way I went (which as you said was the obvious solution) was to rebase\nonto master on every master commit.\nThen as I began having \"clients\" of my refactor branch, I went with the\nfollowing setup:\n- develop-wip is the branch I continue to do work on, and rebase at will to\n  the tip of master\n- develop is never rebased and merges in develop-wip constantly, and is the\n  branch that is used by others\nWhen the refactor work is finished and \"signed-off\" then master will be\nfast-forwarded to the tip of develop-wip, and I'll get previous users of\ndevelop to move back to master (and remove develop & develop-wip branches).\nOn 20 July 2013 16:13, Michael Haggerty notifications@github.com wrote:\n\nYes, I think that should work fine.\nOne obvious approach would be to rebase (or rebase-with-history) the\ncurrent state of the refactoring branch to the current state of master, and\njust repeat this step periodically as master progresses. This would have\nthe benefit that after you do a rebase, the subsequent work that you do on\nthe branch will be on top of the changes that have been done on trunk\nbetween the branch's old branch point and its new branch point, so you will\nintrinsically have fewer conflicts.\nIf the incremental merge is too much work to do at once, you could also\nwork on the incremental merge across several sittings, simply leaving the\nin-progress imerge in your repo between attempts. If work on master or\n(especially) branch continue during your imerge, you could leave the\nresults of the first incremental merge in your repo and expand the\ncompleted part of the incremental merge diagram one rectangle at a time.\nSo, for example, if the first imerge was \"imerge1\", then you could do\ngit checkout imerge1\ngit imerge start --name=imerge2 --goal=GOAL --first-parent wipbranch\nwhere \"wipbranch\" is the current state of the WIP branch, which includes\nmore commits than the ones that were included in imerge1. The only thing\nthat might be awkward is simplifying the final imerge into the rebase that\nyou ultimately want. Given the current state of imerge, you would have to\ndo that by hand using the \"git imerge reparent\" command or other fancy Git\ntrickery.\nCertainly, git-imerge could be made to support this workflow better.\nContributions are welcome.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/mhagger/git-imerge/issues/23#issuecomment-21295019\n.\n. \n",
    "jrdavid": "I would like that feature as well. I guess that information shouldn't be too hard to extract from MergeState? If you give me a pointer or two I'd be happy to contribute.\n. I'm not currently working on it, no. I still want to do it but I've just been swamped the last few weeks. You've helped quite a bit already. I think I'm good for now, thanks. I just don't know when I'll be able to get around to it.\n. I would like that feature as well. I guess that information shouldn't be too hard to extract from MergeState? If you give me a pointer or two I'd be happy to contribute.\n. I'm not currently working on it, no. I still want to do it but I've just been swamped the last few weeks. You've helped quite a bit already. I think I'm good for now, thanks. I just don't know when I'll be able to get around to it.\n. ",
    "frioux": "Yeah, that's about the response I expected.  Thanks anyway :)\n. Yeah, that's about the response I expected.  Thanks anyway :)\n. ",
    "eddyp": "I see your point about the exponential growth of the commits. I will think about this.\nThe reason I didn't seriously consider this case was that in practice I only had very few commits on the master branch and a lot more on the feature branch, so the actual diagram was 'thin' and 'tall'. I didn't even encounter a case as complex as the one I drew.\nTalking about the diagram I drew, what would you think about retaining from the intermediate merges only the manual one and the final one, with the final one having 3 parents? (The manual merge, the rightmost commit on the destination branch and the bottom most from the source).\nI know is a little complicated for a human to follow more than 2 parents, but I want to get your opinion on this.\n. The reason for me was to be able to later test the correctness of the manual merge. But with more conflicts I am unsure what should be retained. I have an example of a fictional merge on my computer. I'll post or when I'll get home, so we can discuss.\n. Here is the simplified example merge diagram I was talking about.\n* - * - * - * - * - * - * - * - * - * - *\n|           |       |       |           |\n*           |       |       |           |\n|           |       |       |           |\n* --------- m ----- a ----- a --------- b\n|           |       |       |           |\n* --------- a ----- 1 ----- n --------- b\n|           |       |       |           |\n*           |       |       |           |\n|           |       |       |           |\n* --------- a ----- o ----- 2 --------- b\n|           |       |       |           |\n* --------- b ----- b ----- b --------- F\nThe commits marked with m, n, o are the manual merges, the ones marked a or b are automatic merged that seem to be the ones that must be kept if my initial proposal is to be followed, F is the final tree state after all the merges are done. The commits marked with numbers (automatic) are the ones I am not sure about if they should be kept or not.\nThe 'a' merges should be kept because they are the ones generated by the m manual merge.\nThe 'b' merges seem to be necessary because they are outputs of manual merges and are inputs for F (directly on indirectly).\nWhat seems to be unclear to me is if the automatic merges marked with 1 and 2 should be kept as inputs for the manual merges and the final merge, respectively. Should 1 be input for the n and o manual merges? It does contain information as a result of the m merge, but what does make more sense, keeping 1 as parent for n and o, or to drop 1 and have only a nodes as parents for n and o?\nThe node 2 is similar to 1, but it shouldn't be problematic since is automatic.\nI wonder if keeping only the m, n, o commits and their * parents (or previous manual merges as parents) makes more sense, while having the F commit multi-parent, with all the manual merges as parents (except the manual merges which have another manual merge as child).\nWhat do you think?\n. @mhagger : sorry for not replying earlier, I've been busy with other stuff. I'm unsure when I'll have the time to test this, but I'll send a reply with my results when I have the time for it. (Currently I don't remember in which project I used git-imerge, so I'll have to run into a repo that needs a merge, that's why I can't test right away.)\n. @mhagger : I found a repo where I could try imerge and using the simplfy-to-manual branch version I got this weird result:\n```\n(much output before this)\n...|\n...|\n...|\n...|\n...|\n...|\n...|\n..|\n--*+\nKey:\n  |,-,+ = rectangles forming current merge frontier\n  * = merge done manually\n  . = merge done automatically\n  # = conflict that is currently blocking progress\n  @ = merge was blocked but has been resolved\n  ? = no merge recorded\n0 eddy@heidi ~/usr/src/make/make-profiler $ git imerge simplify\nCannot simplify to \"manual\" because merge 2-8 is not yet done\n```\nI'm a little confused. The matrix shows a few '?' at the top, but I don't know why, since I didn't skip any of the manual merges.\n. How about a pre-commit hook that checks that for annotated tag commits the correct information is added? This with a helper script for tagging that automatically computes a timestamp based version number and refreshes the script source?\nFrom what I can see the problem is the lack of 'official' versions, so maybe they should be added :)\n. The helper script is not necessary, there is git describe.\n. I see your point about the exponential growth of the commits. I will think about this.\nThe reason I didn't seriously consider this case was that in practice I only had very few commits on the master branch and a lot more on the feature branch, so the actual diagram was 'thin' and 'tall'. I didn't even encounter a case as complex as the one I drew.\nTalking about the diagram I drew, what would you think about retaining from the intermediate merges only the manual one and the final one, with the final one having 3 parents? (The manual merge, the rightmost commit on the destination branch and the bottom most from the source).\nI know is a little complicated for a human to follow more than 2 parents, but I want to get your opinion on this.\n. The reason for me was to be able to later test the correctness of the manual merge. But with more conflicts I am unsure what should be retained. I have an example of a fictional merge on my computer. I'll post or when I'll get home, so we can discuss.\n. Here is the simplified example merge diagram I was talking about.\n* - * - * - * - * - * - * - * - * - * - *\n|           |       |       |           |\n*           |       |       |           |\n|           |       |       |           |\n* --------- m ----- a ----- a --------- b\n|           |       |       |           |\n* --------- a ----- 1 ----- n --------- b\n|           |       |       |           |\n*           |       |       |           |\n|           |       |       |           |\n* --------- a ----- o ----- 2 --------- b\n|           |       |       |           |\n* --------- b ----- b ----- b --------- F\nThe commits marked with m, n, o are the manual merges, the ones marked a or b are automatic merged that seem to be the ones that must be kept if my initial proposal is to be followed, F is the final tree state after all the merges are done. The commits marked with numbers (automatic) are the ones I am not sure about if they should be kept or not.\nThe 'a' merges should be kept because they are the ones generated by the m manual merge.\nThe 'b' merges seem to be necessary because they are outputs of manual merges and are inputs for F (directly on indirectly).\nWhat seems to be unclear to me is if the automatic merges marked with 1 and 2 should be kept as inputs for the manual merges and the final merge, respectively. Should 1 be input for the n and o manual merges? It does contain information as a result of the m merge, but what does make more sense, keeping 1 as parent for n and o, or to drop 1 and have only a nodes as parents for n and o?\nThe node 2 is similar to 1, but it shouldn't be problematic since is automatic.\nI wonder if keeping only the m, n, o commits and their * parents (or previous manual merges as parents) makes more sense, while having the F commit multi-parent, with all the manual merges as parents (except the manual merges which have another manual merge as child).\nWhat do you think?\n. @mhagger : sorry for not replying earlier, I've been busy with other stuff. I'm unsure when I'll have the time to test this, but I'll send a reply with my results when I have the time for it. (Currently I don't remember in which project I used git-imerge, so I'll have to run into a repo that needs a merge, that's why I can't test right away.)\n. @mhagger : I found a repo where I could try imerge and using the simplfy-to-manual branch version I got this weird result:\n```\n(much output before this)\n...|\n...|\n...|\n...|\n...|\n...|\n...|\n..|\n--*+\nKey:\n  |,-,+ = rectangles forming current merge frontier\n  * = merge done manually\n  . = merge done automatically\n  # = conflict that is currently blocking progress\n  @ = merge was blocked but has been resolved\n  ? = no merge recorded\n0 eddy@heidi ~/usr/src/make/make-profiler $ git imerge simplify\nCannot simplify to \"manual\" because merge 2-8 is not yet done\n```\nI'm a little confused. The matrix shows a few '?' at the top, but I don't know why, since I didn't skip any of the manual merges.\n. How about a pre-commit hook that checks that for annotated tag commits the correct information is added? This with a helper script for tagging that automatically computes a timestamp based version number and refreshes the script source?\nFrom what I can see the problem is the lack of 'official' versions, so maybe they should be added :)\n. The helper script is not necessary, there is git describe.\n. ",
    "rogerwang": "rebase goal failed as well with the same exception.\n. git version 1.8.3.2-1 in Debian sid when I was reporting this.\n. I went on with manual rebase. This can be closed and I'll report followups if I hit it again. Thanks\n. rebase goal failed as well with the same exception.\n. git version 1.8.3.2-1 in Debian sid when I was reporting this.\n. I went on with manual rebase. This can be closed and I'll report followups if I hit it again. Thanks\n. ",
    "jyasskin": "Working on Chromium (jyasskin/chromium@service-worker-apps), I got:\n$ git imerge merge lkgr\nAttempting automerge of 1-1...Traceback (most recent call last):\n  File \"~/bin/git-imerge\", line 3340, in <module>\n    main(sys.argv[1:])\n  File \"~/bin/git-imerge\", line 136, in wrapper\n    return f(*args, **kw)\n  File \"~/bin/git-imerge\", line 3156, in main\n    merge_state.auto_complete_frontier()\n  File \"~/bin/git-imerge\", line 2193, in auto_complete_frontier\n    frontier.auto_expand()\n  File \"~/bin/git-imerge\", line 1348, in auto_expand\n    if block.auto_expand_frontier():\n  File \"~/bin/git-imerge\", line 1646, in auto_expand_frontier\n    return self.auto_outline_frontier()\n  File \"~/bin/git-imerge\", line 1616, in auto_outline_frontier\n    merge_frontier = MergeFrontier.compute_by_bisection(self)\n  File \"~/bin/git-imerge\", line 905, in compute_by_bisection\n    if not block.is_mergeable(1, 1):\n  File \"~/bin/git-imerge\", line 1499, in is_mergeable\n    automerge(self[i1, 0].sha1, self[0, i2].sha1)\n  File \"~/bin/git-imerge\", line 595, in automerge\n    call_silently(['git', 'reset', '--merge'])\n  File \"~/bin/git-imerge\", line 230, in call_silently\n    raise CalledProcessError(retcode, cmd)\nsubprocess.CalledProcessError: Command '[u'git', u'reset', u'--merge']' returned non-zero exit status 128\n$ git reset --merge\nerror: Updating 'third_party/skia/gyp' would lose untracked files in it\nfatal: Could not reset index file to revision 'HEAD'.\n$ git --version\ngit version 1.9.1.423.g4596e3a\nThis is probably running into a change in Chromium where an experimental submodules-based repo arrangement was removed. I'm probably going to try rebasing this tree to get rid of cruft in it and reset its earliest commit, after which maybe this sort of submodule update will handle itself?\n. Yes, time git status says about 0.5s of wall time.\nI don't expect to get a chance to learn git's internals well enough to fix this in the near future, but thanks for pointing out the path forward.\n. Working on Chromium (jyasskin/chromium@service-worker-apps), I got:\n$ git imerge merge lkgr\nAttempting automerge of 1-1...Traceback (most recent call last):\n  File \"~/bin/git-imerge\", line 3340, in <module>\n    main(sys.argv[1:])\n  File \"~/bin/git-imerge\", line 136, in wrapper\n    return f(*args, **kw)\n  File \"~/bin/git-imerge\", line 3156, in main\n    merge_state.auto_complete_frontier()\n  File \"~/bin/git-imerge\", line 2193, in auto_complete_frontier\n    frontier.auto_expand()\n  File \"~/bin/git-imerge\", line 1348, in auto_expand\n    if block.auto_expand_frontier():\n  File \"~/bin/git-imerge\", line 1646, in auto_expand_frontier\n    return self.auto_outline_frontier()\n  File \"~/bin/git-imerge\", line 1616, in auto_outline_frontier\n    merge_frontier = MergeFrontier.compute_by_bisection(self)\n  File \"~/bin/git-imerge\", line 905, in compute_by_bisection\n    if not block.is_mergeable(1, 1):\n  File \"~/bin/git-imerge\", line 1499, in is_mergeable\n    automerge(self[i1, 0].sha1, self[0, i2].sha1)\n  File \"~/bin/git-imerge\", line 595, in automerge\n    call_silently(['git', 'reset', '--merge'])\n  File \"~/bin/git-imerge\", line 230, in call_silently\n    raise CalledProcessError(retcode, cmd)\nsubprocess.CalledProcessError: Command '[u'git', u'reset', u'--merge']' returned non-zero exit status 128\n$ git reset --merge\nerror: Updating 'third_party/skia/gyp' would lose untracked files in it\nfatal: Could not reset index file to revision 'HEAD'.\n$ git --version\ngit version 1.9.1.423.g4596e3a\nThis is probably running into a change in Chromium where an experimental submodules-based repo arrangement was removed. I'm probably going to try rebasing this tree to get rid of cruft in it and reset its earliest commit, after which maybe this sort of submodule update will handle itself?\n. Yes, time git status says about 0.5s of wall time.\nI don't expect to get a chance to learn git's internals well enough to fix this in the near future, but thanks for pointing out the path forward.\n. ",
    "blitz": "git status reported that nothing is conflicted and nothing is to be committed. Before I read your comment, I tried to manually set the imerge/$NAME branch to one of the previous merges. That first triggered a reference to an unbound variable ( which resulted in https://github.com/mhagger/git-imerge/pull/30 ) and after that worked. ;) Anyway, my merge is continuing  :) \nIt seems this problem can also happen when I accidentally change a file and don't commit it. Say I test a merge and leave a debug printf somewhere.\n. Ok, I hit the same issue again. What works to recover from this is:\n- change to some other branch\n- git branch -D imerge/$NAME\n- git imerge continue\n- git commit\n- git imerge continue\n. Unfortunately, this is a private repository. I am happy to use a version that spits out more debug information though.\n. Can't reproduce it any more, but unfortunately I don't have the exact repo around. Will copy it to a safe place next time. Sorry.\n. git status reported that nothing is conflicted and nothing is to be committed. Before I read your comment, I tried to manually set the imerge/$NAME branch to one of the previous merges. That first triggered a reference to an unbound variable ( which resulted in https://github.com/mhagger/git-imerge/pull/30 ) and after that worked. ;) Anyway, my merge is continuing  :) \nIt seems this problem can also happen when I accidentally change a file and don't commit it. Say I test a merge and leave a debug printf somewhere.\n. Ok, I hit the same issue again. What works to recover from this is:\n- change to some other branch\n- git branch -D imerge/$NAME\n- git imerge continue\n- git commit\n- git imerge continue\n. Unfortunately, this is a private repository. I am happy to use a version that spits out more debug information though.\n. Can't reproduce it any more, but unfortunately I don't have the exact repo around. Will copy it to a safe place next time. Sorry.\n. ",
    "magthe": "No, unfortunately that doesn't change the result at all.\n. All right, here's the output I got out... hopefully you can make some sense of it :)\n```\nmetadata = {'GIT_AUTHOR_DATE': '2013-07-24', 'GIT_AUTHOR_EMAIL': 'magnus@therning.org', 'GIT_AUTHOR_NAME': 'Magnus Therning'}\norig = 60d693222e84d5aeaf9eef9e8b2de7d3ca359084\n% git --no-pager log -n1 --format='%an%x00%ae%x00%ad' 60d693222e84d5aeaf9eef9e8b2de7d3ca359084 | hexdump -C\n00000000  4d 61 67 6e 75 73 20 54  68 65 72 6e 69 6e 67 00  |Magnus Therning.|\n00000010  6d 61 67 6e 75 73 40 74  68 65 72 6e 69 6e 67 2e  |magnus@therning.|\n00000020  6f 72 67 00 32 30 31 33  2d 30 37 2d 32 34 0a     |org.2013-07-24.|\n0000002f\n% git cat-file commit 60d693222e84d5aeaf9eef9e8b2de7d3ca359084\ntree 2f86b99a66cd85c1ee0149630b4f2a0eef7cf895\nparent 9ab389365eaac0ddb5639baa02ae6129b8825567\nauthor Magnus Therning magnus@therning.org 1374673091 +0200\ncommitter Magnus Therning magnus@therning.org 1374673091 +0200\nRemove the flickrapi copy.\nIt's better to let the user get it.  There'll be a dependency on the specific\nversion added later on.\nSigned-off-by: Magnus Therning magnus@therning.org\n```\nOh, and my log.date is set to short.\n. Indeed, unsetting log.date allowed me to finish my imerge.  Thanks for your patience and help.\n. No, unfortunately that doesn't change the result at all.\n. All right, here's the output I got out... hopefully you can make some sense of it :)\n```\nmetadata = {'GIT_AUTHOR_DATE': '2013-07-24', 'GIT_AUTHOR_EMAIL': 'magnus@therning.org', 'GIT_AUTHOR_NAME': 'Magnus Therning'}\norig = 60d693222e84d5aeaf9eef9e8b2de7d3ca359084\n% git --no-pager log -n1 --format='%an%x00%ae%x00%ad' 60d693222e84d5aeaf9eef9e8b2de7d3ca359084 | hexdump -C\n00000000  4d 61 67 6e 75 73 20 54  68 65 72 6e 69 6e 67 00  |Magnus Therning.|\n00000010  6d 61 67 6e 75 73 40 74  68 65 72 6e 69 6e 67 2e  |magnus@therning.|\n00000020  6f 72 67 00 32 30 31 33  2d 30 37 2d 32 34 0a     |org.2013-07-24.|\n0000002f\n% git cat-file commit 60d693222e84d5aeaf9eef9e8b2de7d3ca359084\ntree 2f86b99a66cd85c1ee0149630b4f2a0eef7cf895\nparent 9ab389365eaac0ddb5639baa02ae6129b8825567\nauthor Magnus Therning magnus@therning.org 1374673091 +0200\ncommitter Magnus Therning magnus@therning.org 1374673091 +0200\nRemove the flickrapi copy.\nIt's better to let the user get it.  There'll be a dependency on the specific\nversion added later on.\nSigned-off-by: Magnus Therning magnus@therning.org\n```\nOh, and my log.date is set to short.\n. Indeed, unsetting log.date allowed me to finish my imerge.  Thanks for your patience and help.\n. ",
    "nafg": "+10\n. +10\n. ",
    "lucaswerkmeister": "What you\u2019re seeing there are xterm escape sequences to set the color of the text; <ESC>[0m resets the color. Apparently, whatever terminal Git Bash uses under Windows doesn\u2019t use xterm\u2019s escape sequence, but instead other ones.\nIn theory, there\u2019s a really nice mechanism (terminfo) to let applications discover what escape sequences the terminal they\u2019re running in uses. However, git-imerge doesn\u2019t use it, but instead prints hard-coded escape sequences.\n@mhagger I\u2019m no python expert. In bash, I would write something like BLACK = $(tput setaf 0) (\u201cset ascii foreground 0\u201d) \u2013 would that be difficult to do in python?\n. well, I just rebooted into Windows to test this, and it appears Git Bash doesn\u2019t come with tput; however, echo $'\\033[0;33m' hi (the hard-coded escape sequence git-imerge uses) correctly prints \"hi\" in yellow. @jakub-g, could you please post your output for\n- echo $TERM\n- echo $'\\033[0;33m' hi\n- tput setaf 3; echo hi\nalso, are you using MSysGit or Cygwin Git? (I have MSysGit, Git Bash reports a $TERM of \"cygwin\", and Cygwin Terminal reports a $TERM of \"xterm\" \u2013 what?)\n. Isn\u2019t /usr meant for files managed by the package manager, and /usr/local for files installed independently?\n. Here\u2019s what the Filesystem Hierarchy Standard has to say about this:\nSection 4.1, page 18:\n\n/usr is shareable [\u2026] [t]hat means that /usr should be shareable between various FHS-compliant hosts and must not be written to. Any information that is host-specific [\u2026] is stored elsewhere.\n\nSection 4.8.2.1, page 21:\n\nThe /usr/local hierarchy is for use by the system administrator when installing software locally. [\u2026]\nLocally installed software must be placed within /usr/local rather than /usr unless it is being installed to replace or upgrade software in /usr.\n\nI\u2019m not sure where to place git-imerge here. I guess that in a corporate environment, the sysadmin could place it in /usr (shared across all computers), but if a single user wanted it, he\u2019d put it in /usr/local?\n. A cancel option might be useful, I think.\n(Also, for the record, implements #52.)\n. Are you on Windows, Linux, or Mac? Also, what\u2019s your git author name (git config user.name) \u2013 does it include any special characters?\n. What you\u2019re seeing there are xterm escape sequences to set the color of the text; <ESC>[0m resets the color. Apparently, whatever terminal Git Bash uses under Windows doesn\u2019t use xterm\u2019s escape sequence, but instead other ones.\nIn theory, there\u2019s a really nice mechanism (terminfo) to let applications discover what escape sequences the terminal they\u2019re running in uses. However, git-imerge doesn\u2019t use it, but instead prints hard-coded escape sequences.\n@mhagger I\u2019m no python expert. In bash, I would write something like BLACK = $(tput setaf 0) (\u201cset ascii foreground 0\u201d) \u2013 would that be difficult to do in python?\n. well, I just rebooted into Windows to test this, and it appears Git Bash doesn\u2019t come with tput; however, echo $'\\033[0;33m' hi (the hard-coded escape sequence git-imerge uses) correctly prints \"hi\" in yellow. @jakub-g, could you please post your output for\n- echo $TERM\n- echo $'\\033[0;33m' hi\n- tput setaf 3; echo hi\nalso, are you using MSysGit or Cygwin Git? (I have MSysGit, Git Bash reports a $TERM of \"cygwin\", and Cygwin Terminal reports a $TERM of \"xterm\" \u2013 what?)\n. Isn\u2019t /usr meant for files managed by the package manager, and /usr/local for files installed independently?\n. Here\u2019s what the Filesystem Hierarchy Standard has to say about this:\nSection 4.1, page 18:\n\n/usr is shareable [\u2026] [t]hat means that /usr should be shareable between various FHS-compliant hosts and must not be written to. Any information that is host-specific [\u2026] is stored elsewhere.\n\nSection 4.8.2.1, page 21:\n\nThe /usr/local hierarchy is for use by the system administrator when installing software locally. [\u2026]\nLocally installed software must be placed within /usr/local rather than /usr unless it is being installed to replace or upgrade software in /usr.\n\nI\u2019m not sure where to place git-imerge here. I guess that in a corporate environment, the sysadmin could place it in /usr (shared across all computers), but if a single user wanted it, he\u2019d put it in /usr/local?\n. A cancel option might be useful, I think.\n(Also, for the record, implements #52.)\n. Are you on Windows, Linux, or Mac? Also, what\u2019s your git author name (git config user.name) \u2013 does it include any special characters?\n. ",
    "jakub-g": "I'll check things on Monday at work; I use Git Bash 1.8.4 (msysgit)\n. @lucaswerkmeister to sum up:\n- Windows 7, Git Bash 1.8.4, Python 2.7.5\n- echo $'\\033[0;33m' hi prints it in yellow as it should\n- echo $TERM prints cygwin\n- Git Bash doesn't come with tput\n- git-imerge diagram shows unreadable output \n. FWIW this is a JS library I'm using for colored output which works fine in NodeJS:\nhttps://github.com/Marak/colors.js/blob/master/colors.js#L61\n. I'll check things on Monday at work; I use Git Bash 1.8.4 (msysgit)\n. @lucaswerkmeister to sum up:\n- Windows 7, Git Bash 1.8.4, Python 2.7.5\n- echo $'\\033[0;33m' hi prints it in yellow as it should\n- echo $TERM prints cygwin\n- Git Bash doesn't come with tput\n- git-imerge diagram shows unreadable output \n. FWIW this is a JS library I'm using for colored output which works fine in NodeJS:\nhttps://github.com/Marak/colors.js/blob/master/colors.js#L61\n. ",
    "habnabit": "having this same problem. :C\n. seemingly resolved by doing git imerge continue --no-edit instead of git commit && git imerge continue after resolving conflicts.\n. having this same problem. :C\n. seemingly resolved by doing git imerge continue --no-edit instead of git commit && git imerge continue after resolving conflicts.\n. ",
    "jmah": "I haven't seen this problem myself (but haven't used imerge recently); I wonder if git commit --allow-empty would work as well.\n. Author (and author time) should always be preserved, IMO, like other git operations do.. I haven't seen this problem myself (but haven't used imerge recently); I wonder if git commit --allow-empty would work as well.\n. Author (and author time) should always be preserved, IMO, like other git operations do.. ",
    "talios": "+100 Have hit this a few times, sadly if the fix here works - I guess I'll not actually notice ( which is a good thing - just makes testing hard ).\n. Hrm, on second thoughts - maybe this is actually more desirable, at least in the case of rebased-with-history as the original commit is still linked in the hierarchy, and having Gerrit overrite it would be.... nasty.\n. @mhagger Any chance on a comment on this? Is there any specific reason for imerge to disallow using a / in a branch name?\n. @mhagger Right, I wasn't sure if that was the case or there was some subtle way how imerge worked that caused issues.\nJust tried the branch and it worked fine for me using /'s in the new branch name.\n. I just ran into this again and used the git commit --allow-empty trick, did anything come of this change at all?\n. > It's maybe a bit unfair of me to be so detailed after such a long time of inactivity.\n@mhagger For what's it worth as an idle bystander - I'd love it if anyone gave such a detailed set of review notes on a pull request I made. What may seem a small pedantic comment can sometimes turn out to be a critical issue down the path - so any discussion on changes is good IMHO ( especially on something that's going to be modifying a git repository! ).\n. @dleen Any further movement on this PR at all? Would love to see this pulled in.  I have a feeling this might come in useful to me in the near future :)\n. +100 :) I note Github is saying this has PR has merge conflicts? I suspect related to #69?\n. I'd love to help with the reviews on PRs but my Python knowledge these days is sorely lacking ( haven't actually touched it in about 12+ years ) so I suspect my input would be marginal at best.\n. Was there any movement on this PR at all? Had a situation the other day when this could have come in handy.\n. +100 Have hit this a few times, sadly if the fix here works - I guess I'll not actually notice ( which is a good thing - just makes testing hard ).\n. Hrm, on second thoughts - maybe this is actually more desirable, at least in the case of rebased-with-history as the original commit is still linked in the hierarchy, and having Gerrit overrite it would be.... nasty.\n. @mhagger Any chance on a comment on this? Is there any specific reason for imerge to disallow using a / in a branch name?\n. @mhagger Right, I wasn't sure if that was the case or there was some subtle way how imerge worked that caused issues.\nJust tried the branch and it worked fine for me using /'s in the new branch name.\n. I just ran into this again and used the git commit --allow-empty trick, did anything come of this change at all?\n. > It's maybe a bit unfair of me to be so detailed after such a long time of inactivity.\n@mhagger For what's it worth as an idle bystander - I'd love it if anyone gave such a detailed set of review notes on a pull request I made. What may seem a small pedantic comment can sometimes turn out to be a critical issue down the path - so any discussion on changes is good IMHO ( especially on something that's going to be modifying a git repository! ).\n. @dleen Any further movement on this PR at all? Would love to see this pulled in.  I have a feeling this might come in useful to me in the near future :)\n. +100 :) I note Github is saying this has PR has merge conflicts? I suspect related to #69?\n. I'd love to help with the reviews on PRs but my Python knowledge these days is sorely lacking ( haven't actually touched it in about 12+ years ) so I suspect my input would be marginal at best.\n. Was there any movement on this PR at all? Had a situation the other day when this could have come in handy.\n. ",
    "KindDragon": "Same result on Windows\n. I think env can contain only ascii strings on windows\n. Same result on Windows\n. I think env can contain only ascii strings on windows\n. ",
    "josmo": "There really isn't a hard fast rule on it.  Generally /usr is for files that are tied to the system distribution and /usr/local is free for being managed locally.  In reality I'm going to be using bin.install 'git-imerge' in the recipe for homebrew anyways so it will manage where it needs to go. So the only thing we really need is a tag in the repo for it :)\n. @mhagger While were waiting if @ralfth has any input. Any chance you could create a tag for the current version?  I've got a recipe for homebrew that can start working right away and just needs the tag \nThanks\n. There really isn't a hard fast rule on it.  Generally /usr is for files that are tied to the system distribution and /usr/local is free for being managed locally.  In reality I'm going to be using bin.install 'git-imerge' in the recipe for homebrew anyways so it will manage where it needs to go. So the only thing we really need is a tag in the repo for it :)\n. @mhagger While were waiting if @ralfth has any input. Any chance you could create a tag for the current version?  I've got a recipe for homebrew that can start working right away and just needs the tag \nThanks\n. ",
    "ralfth": "@mhagger No input from me. Feel free to merge.\n. I've updated the commit by adding underscores to some of the functions/variables and mentioned\nthe presence of Bash completion in READ.rst with a simple \"How to install\" and its requirements.\n. The function for bash completing imerge is executed by Git's completion script, so I think we're save.\nI tried it out, anyway. I removed Git's completion locally and didn't see any error because functions that are using (missing) functions from Git's completion script weren't executed.\n. @mhagger The changes look good to me.\n. @mhagger The change looks good to me.  I agree with your reasoning for completing with __git-imerge_branches and I can't think of anything better.  Thanks\n. @mhagger No input from me. Feel free to merge.\n. I've updated the commit by adding underscores to some of the functions/variables and mentioned\nthe presence of Bash completion in READ.rst with a simple \"How to install\" and its requirements.\n. The function for bash completing imerge is executed by Git's completion script, so I think we're save.\nI tried it out, anyway. I removed Git's completion locally and didn't see any error because functions that are using (missing) functions from Git's completion script weren't executed.\n. @mhagger The changes look good to me.\n. @mhagger The change looks good to me.  I agree with your reasoning for completing with __git-imerge_branches and I can't think of anything better.  Thanks\n. ",
    "scruff311": "You're right there are 2. Not sure how that happened, but is there any way to cherry-pick which commit to use for the imerge?\n. Using your advice I created the functionality to pick which base to use and it works! Should I push this edit? If so, how should I do it safely?\n. You're right there are 2. Not sure how that happened, but is there any way to cherry-pick which commit to use for the imerge?\n. Using your advice I created the functionality to pick which base to use and it works! Should I push this edit? If so, how should I do it safely?\n. ",
    "doy": "+1\n. +1\n. ",
    "dleen": "I attempted to start on this. I'd love some help :)\n. Yeah no worries, I'll have time again next weekend :)\n. This resolves issue #40 \n. Updated with the NothingToDoError and try ... except on merge and rebase.\n. LGTM!\n. This solves most of issue #58.\nI need to remove some print statements which I was using to see how automerge was called. As discussed in #58 doing a build every auto_outline is very expensive. There's no guarantee however that we're not catching all build failures without doing some sort of bisect on the auto_fills.\nAlso if you can suggest some additional tests than the ones I've added I'd gladly add them!\nI'd love to hear your thoughts!\n. Yeah I agree, the comments were great. I'm still working on them :)\n. Got most of the low hanging fruit. I still need some guidance on how to set the git config values correctly.\n. Finally found some time to work on this!\nI've tried to address storing the test command in git config as best as I could. I'd love to know what you think! I've covered the main points: each imerge stores the test command under imerge.name.testcommand. The test commands are removed upon finishing. git config should be called at most twice: once to get whatever is stored under default and once to get the config for name. I haven't added a default test command yet but that should be easy (and if it isn't then my class isn't working as well as I hoped!)\nI've separated the code for interacting with git config into another PR for easier reviewing: https://github.com/mhagger/git-imerge/pull/69\n. Hey @talios, I think I'm just waiting for a review by @mhagger for this and #69. This was a meaty PR and in the process we've improved imerge a bunch. If @mhagger has no further comments he can merge this in.\n. The merge conflicts shouldn't be an issue, I'll rebase if needed.\n. It was sort of blocked on https://github.com/mhagger/git-imerge/pull/69 which I lost steam on\n. Force pushed new commit with the line comments.\nChanged double quotes to single quotes.\nChanged indentation of parens.\n. Did you get a chance to look at this?\n. I attempted to start on this. I'd love some help :)\n. Yeah no worries, I'll have time again next weekend :)\n. This resolves issue #40 \n. Updated with the NothingToDoError and try ... except on merge and rebase.\n. LGTM!\n. This solves most of issue #58.\nI need to remove some print statements which I was using to see how automerge was called. As discussed in #58 doing a build every auto_outline is very expensive. There's no guarantee however that we're not catching all build failures without doing some sort of bisect on the auto_fills.\nAlso if you can suggest some additional tests than the ones I've added I'd gladly add them!\nI'd love to hear your thoughts!\n. Yeah I agree, the comments were great. I'm still working on them :)\n. Got most of the low hanging fruit. I still need some guidance on how to set the git config values correctly.\n. Finally found some time to work on this!\nI've tried to address storing the test command in git config as best as I could. I'd love to know what you think! I've covered the main points: each imerge stores the test command under imerge.name.testcommand. The test commands are removed upon finishing. git config should be called at most twice: once to get whatever is stored under default and once to get the config for name. I haven't added a default test command yet but that should be easy (and if it isn't then my class isn't working as well as I hoped!)\nI've separated the code for interacting with git config into another PR for easier reviewing: https://github.com/mhagger/git-imerge/pull/69\n. Hey @talios, I think I'm just waiting for a review by @mhagger for this and #69. This was a meaty PR and in the process we've improved imerge a bunch. If @mhagger has no further comments he can merge this in.\n. The merge conflicts shouldn't be an issue, I'll rebase if needed.\n. It was sort of blocked on https://github.com/mhagger/git-imerge/pull/69 which I lost steam on\n. Force pushed new commit with the line comments.\nChanged double quotes to single quotes.\nChanged indentation of parens.\n. Did you get a chance to look at this?\n. ",
    "johnkeeping": "The patch I'm currently using is here.  I opted to only run make when performing test merges and not for autofilling; so far that has always pointed me at the exact upstream commit (more often it's actually merge commit) that introduced the change that breaks my build.\nI don't think I understand enough about autofilling to understand your comment on trees; I agree that if the same tree appears then there should not be a need to run the script again.\n. Are you suggesting the command is configured with git config?  I had assumed that the command would need to be stored in the imerge state so that it can be set differently for different merges, but I can see how putting it in the config is nice and simple.\n. I agree completely with your conclusion.\nFrom my (admittedly limited) experience using git-imerge to forward-port a patch set from an ancient Linux kernel one release at a time, it does generally seem to be the case that the optimistic merges will generally succeed.\n. Do you have git-rerere enabled?  If it has automatically resolved the conflict the file will still be marked as conflicted in the index.\n. The patch I'm currently using is here.  I opted to only run make when performing test merges and not for autofilling; so far that has always pointed me at the exact upstream commit (more often it's actually merge commit) that introduced the change that breaks my build.\nI don't think I understand enough about autofilling to understand your comment on trees; I agree that if the same tree appears then there should not be a need to run the script again.\n. Are you suggesting the command is configured with git config?  I had assumed that the command would need to be stored in the imerge state so that it can be set differently for different merges, but I can see how putting it in the config is nice and simple.\n. I agree completely with your conclusion.\nFrom my (admittedly limited) experience using git-imerge to forward-port a patch set from an ancient Linux kernel one release at a time, it does generally seem to be the case that the optimistic merges will generally succeed.\n. Do you have git-rerere enabled?  If it has automatically resolved the conflict the file will still be marked as conflicted in the index.\n. ",
    "RemiCardona": "The above was on an \"unstable\" (~arch) Gentoo system, but I confirm the exact same behavior on a Debian Wheezy (current stable).\n. Yay, thanks!\n. The above was on an \"unstable\" (~arch) Gentoo system, but I confirm the exact same behavior on a Debian Wheezy (current stable).\n. Yay, thanks!\n. ",
    "gabrielmaldi": "I'm on Mac.\nMy author name is fine, but I found that one of the commits involved in the rebase has an author name that starts with the \u00c1 character, which of course is u'\\xc1' :smiley: \nI tried rebase-with-history on the same branches and imerge doesn't break; guess that the culprit commit doesn't get the same treatment as when just rebasing.\nIs there a way to fix this without modifying the author name?\nThanks!\n. @mhagger yes, branch issue-62 works fine for me with Python 2.7.5 :smiley: \nLet me know if you need me to test anything else.\nThanks for your comprehensive and informative answer!\n. I'm on Mac.\nMy author name is fine, but I found that one of the commits involved in the rebase has an author name that starts with the \u00c1 character, which of course is u'\\xc1' :smiley: \nI tried rebase-with-history on the same branches and imerge doesn't break; guess that the culprit commit doesn't get the same treatment as when just rebasing.\nIs there a way to fix this without modifying the author name?\nThanks!\n. @mhagger yes, branch issue-62 works fine for me with Python 2.7.5 :smiley: \nLet me know if you need me to test anything else.\nThanks for your comprehensive and informative answer!\n. ",
    "Nephyrin": "A somewhat useless +1 here -- I gave this a shot to rebase a large patchset on Gecko that was several months out of date. It worked well, rebasing the branch properly with about 11 conflicts. I ran all the steps with timing, e.g. time git imerge continue, and totaled the result at 7 hours 28 minutes of run time for the 13 commands. This was for a branch that was quite diverged:\n\nYour branch and 'central' have diverged,\nand have 8 and 19901 different commits each, respectively.\n\nThis was with a tree in tmpfs, and the process was pegged at 100% CPU, so it doesn't seem IO bound. git status takes +/- 300ms\n. > I've tried to implement this, and i've pushed my WIP at https://github.com/MrHacky/git-imerge/tree/wip-notree-automerge\nSorry for the delayed response -- I tested this and it does seem to make a large difference, nearly 2x on the gecko repository with an SSD:\nStock\nreal    23m56.903s\nuser    18m40.026s\nsys     5m1.533s\nMrHacky wip-notree-automerge\nreal    12m26.360s\nuser    10m37.810s\nsys     1m38.653s\nTo reproduce the merge I used to test, clone and checkout: https://github.com/Nephyrin/mozilla-dev/tree/imerge-test-rebase-on-a980328 and then time git imerge rebase a980328. The time above is just the time until it presents the first conflict, which involves a few hundred autofills.\nWith both versions it seems most of the process is CPU bound, at least on linux with an SSD. I wonder how difficult parallelizing autofilling with multiple indexes would be\n. A somewhat useless +1 here -- I gave this a shot to rebase a large patchset on Gecko that was several months out of date. It worked well, rebasing the branch properly with about 11 conflicts. I ran all the steps with timing, e.g. time git imerge continue, and totaled the result at 7 hours 28 minutes of run time for the 13 commands. This was for a branch that was quite diverged:\n\nYour branch and 'central' have diverged,\nand have 8 and 19901 different commits each, respectively.\n\nThis was with a tree in tmpfs, and the process was pegged at 100% CPU, so it doesn't seem IO bound. git status takes +/- 300ms\n. > I've tried to implement this, and i've pushed my WIP at https://github.com/MrHacky/git-imerge/tree/wip-notree-automerge\nSorry for the delayed response -- I tested this and it does seem to make a large difference, nearly 2x on the gecko repository with an SSD:\nStock\nreal    23m56.903s\nuser    18m40.026s\nsys     5m1.533s\nMrHacky wip-notree-automerge\nreal    12m26.360s\nuser    10m37.810s\nsys     1m38.653s\nTo reproduce the merge I used to test, clone and checkout: https://github.com/Nephyrin/mozilla-dev/tree/imerge-test-rebase-on-a980328 and then time git imerge rebase a980328. The time above is just the time until it presents the first conflict, which involves a few hundred autofills.\nWith both versions it seems most of the process is CPU bound, at least on linux with an SSD. I wonder how difficult parallelizing autofilling with multiple indexes would be\n. ",
    "MrHacky": "I've tried to implement this, and i've pushed my WIP at https://github.com/MrHacky/git-imerge/tree/wip-notree-automerge\nOne of the problems i ran into is that merge-index/git-merge-one-file has no option to not touch the worktree. I've created a git-imerge-one-file helper for this, but i'm not sure i'm handling all the needed cases. (also you currently have to install git-imerge-one-file manually in a place where git-merge-index can find it)\nI'm not sure when i have time to work on this again, but the next step was going to be redoing one of the large merges in this topic and see if it is any faster and/or has the same result. If someone else wants to try please post your results back here.\n. I've tried to implement this, and i've pushed my WIP at https://github.com/MrHacky/git-imerge/tree/wip-notree-automerge\nOne of the problems i ran into is that merge-index/git-merge-one-file has no option to not touch the worktree. I've created a git-imerge-one-file helper for this, but i'm not sure i'm handling all the needed cases. (also you currently have to install git-imerge-one-file manually in a place where git-merge-index can find it)\nI'm not sure when i have time to work on this again, but the next step was going to be redoing one of the large merges in this topic and see if it is any faster and/or has the same result. If someone else wants to try please post your results back here.\n. ",
    "davidchisnall": "Parallelising would be a huge win, if possible.  Doing merges from LLVM (time git status takes about 0.2 seconds of real time), there are 4000 upstream revisions that I'm trying to merge and at about one second per autofill it takes a very long time (several minutes for each one of my revisions), yet only uses one core.\n. Doing more speculative fills in the background would definitely help if possible, but my understanding is that the process currently only stops because there's a conflict.\nThat said, my last merge took around 4 days, with git-imerge using one core of a quad-core i7 solidly for most of this time and only about two hours being spent doing anything that involved human interaction.  The final step, which autofilled from the last conflict to the merge target, was an overnight job.\nI wonder if another option is to lazily fill some of the autofilled parts.  Are they all actually used?  Can the required ones be created on demand?\n. Is there any progress on this?  git-imerge has taken just over a week of CPU time for me in my most recent merge, and that's getting to the point where it's not a productivity win.  Do all of the NxM merges have to be computed ahead of time, can't we compute them lazily?  Once the bisect has shown that revision A of mine conflicts with B from upstream, we already (via the binary search) know that A-1 merges cleanly with B and B-1 merges cleanly with A, so can't we just do the B-1, A-1 merge, then merge B and A into that and then try to merge those two, rather than computing all of the intermediate steps that are never used?. I've encountered a very similar problem (not sure if it's the same thing or a new issue):\n...\nAutofilling 100-614...success.\nAutofilling 100-615...success.\nAutofilling 100-616...success.\nAutofilling 100-617...success.\nAutofilling 100-618 (first way)...success.\nAutofilling 100-618 (second way)...success.\nThe two ways of autofilling 100-618 agree.\nRecording autofilled block MergeState('upstream', tip1='master', tip2='upstream', goal='merge')[94:101,209:619].\nAttempting automerge of 65-5641...failure.\nAttempting automerge of 58-3294...failure.\nAttempting automerge of 76-3293...failure.\nAttempting automerge of 66-2821...failure.\nAttempting automerge of 94-2820...success.\nAutofilling 77-2820...unexpected conflict.  Backtracking...\nAutofilling 77-2819...unexpected conflict.  Backtracking...\nAutofilling 77-2818...unexpected conflict.  Backtracking...\nAutofilling 77-2817...unexpected conflict.  Backtracking...\nAutofilling 77-2816...unexpected conflict.  Backtracking...\nAutofilling 77-2815...unexpected conflict.  Backtracking...\nAutofilling 77-2814...unexpected conflict.  Backtracking...\nAutofilling 77-2813...unexpected conflict.  Backtracking...\nAutofilling 77-2812...unexpected conflict.  Backtracking...\nAutofilling 77-2811...unexpected conflict.  Backtracking...\nAutofilling 77-2810...unexpected conflict.  Backtracking...\nAutofilling 77-2809...unexpected conflict.  Backtracking...\nAutofilling 77-2808...unexpected conflict.  Backtracking...\n...\nAutofilling 77-1841...unexpected conflict.  Backtracking...\nAutofilling 77-1840...Traceback (most recent call last):\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 3947, in <module>\n    main(sys.argv[1:])\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 3928, in main\n    cmd_continue(parser, options)\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 3499, in cmd_continue\n    merge_state.auto_complete_frontier()\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 2459, in auto_complete_frontier\n    frontier.auto_expand()\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 1603, in auto_expand\n    if block.auto_expand_frontier():\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 1901, in auto_expand_frontier\n    return self.auto_outline_frontier()\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 1885, in auto_outline_frontier\n    return self.auto_outline_frontier(merge_frontier)\nThe last line then repeats a lot of times.  I've spent about a week and a half of CPU time on this merge so far, so if there's a way to recover without starting again then that would be very helpful.\nI'm not sure if it's related, but I ran a git gc last night because the individual merges were taking around 20 seconds (now they're down to 1-2 seconds) and at that speed it would have taken about six months to finish the merge.\nThe upstream repo is:\nhttps://github.com/llvm-mirror/clang\nAnd I'm merging into:\nhttps://github.com/ctSRD-CHERI/clang/\nNote: I'm having to use the loosen-first-parent-rule branch of git-imerge, because master fails to find a common parent.. Actually, my issue might be caused by running out of stack space in the recursive call to auto_outline_frontier: I don't know how big the Python stack can be, but 1000 stack frames might be a few too many.  . It appears that my issue was, indeed, caused by the fact that Python doesn't do tail call optimisation.  The following ugly hack fixed it for me:\n```diff\n--- a/git-imerge\n+++ b/git-imerge\n@@ -1882,7 +1882,7 @@ class Block(object):\n             # One of the merges that we expected to succeed in\n             # fact failed.\n             merge_frontier.remove_failure(e.i1, e.i2)\n-            return self.auto_outline_frontier(merge_frontier)\n+            raise Exception(merge_frontier)\n         else:\n             f1, f2 = merge_frontier.partition(best_block)\n             if f1:\n@@ -1898,7 +1898,17 @@ class Block(object):\n         elif merge_state.goal == 'full':\n             return self.auto_fill_micromerge()\n         else:\n-            return self.auto_outline_frontier()\n+            try:\n+                return self.auto_outline_frontier()\n+            except Exception as mf:\n+                merge_frontier = mf.args[0]\n+                while True:\n+                    try:\n+                        return self.auto_outline_frontier(merge_frontier)\n+                    except Exception as mf:\n+                        merge_frontier = mf.args[0]\n+\n+\n # The codes in the 2D array returned from create_diagram()\n MERGE_UNKNOWN = 0\n\n```\nA similar but less ugly fix is probably required, as backtracking is currently limited to a depth of around 1,000 by the Python default stack size (and can't easily grow larger without running out of C stack space).  . The merge did succeed last night.  It looks as if I'd missed some commit markers in one of the previous merges and so the next one ended up being nonsense and git-imerge gave up because of this.  Backtracking around 2000 upstream revisions undid this error and let me fix it properly (well, in a way that didn't conflict - I need to wait for the LLVM merge to finish before I can tell whether it's actually working).  The backtracking took about 45 minutes, which was not that bad in comparison to a merge that took two and a half weeks overall.  Almost all of this time is spent autofilling, and so anything that could reduce the number of those that are done would help a lot.  It would also possibly help if git-imerge could time the pairwise merges and run git gc periodically if the time has increased a lot.  I've found that it creeps from about 2 seconds to about 30 seconds in the larger merge and then drops down a lot after a gc.  The gc isn't deleting much, but the compression stage appears to dramatically reduce the amount of I/O the git processes do (and means that they're sitting at 100% CPU usage, rather than mostly blocked on I/O, even with a fast SSD).  . Parallelising would be a huge win, if possible.  Doing merges from LLVM (time git status takes about 0.2 seconds of real time), there are 4000 upstream revisions that I'm trying to merge and at about one second per autofill it takes a very long time (several minutes for each one of my revisions), yet only uses one core.\n. Doing more speculative fills in the background would definitely help if possible, but my understanding is that the process currently only stops because there's a conflict.\nThat said, my last merge took around 4 days, with git-imerge using one core of a quad-core i7 solidly for most of this time and only about two hours being spent doing anything that involved human interaction.  The final step, which autofilled from the last conflict to the merge target, was an overnight job.\nI wonder if another option is to lazily fill some of the autofilled parts.  Are they all actually used?  Can the required ones be created on demand?\n. Is there any progress on this?  git-imerge has taken just over a week of CPU time for me in my most recent merge, and that's getting to the point where it's not a productivity win.  Do all of the NxM merges have to be computed ahead of time, can't we compute them lazily?  Once the bisect has shown that revision A of mine conflicts with B from upstream, we already (via the binary search) know that A-1 merges cleanly with B and B-1 merges cleanly with A, so can't we just do the B-1, A-1 merge, then merge B and A into that and then try to merge those two, rather than computing all of the intermediate steps that are never used?. I've encountered a very similar problem (not sure if it's the same thing or a new issue):\n...\nAutofilling 100-614...success.\nAutofilling 100-615...success.\nAutofilling 100-616...success.\nAutofilling 100-617...success.\nAutofilling 100-618 (first way)...success.\nAutofilling 100-618 (second way)...success.\nThe two ways of autofilling 100-618 agree.\nRecording autofilled block MergeState('upstream', tip1='master', tip2='upstream', goal='merge')[94:101,209:619].\nAttempting automerge of 65-5641...failure.\nAttempting automerge of 58-3294...failure.\nAttempting automerge of 76-3293...failure.\nAttempting automerge of 66-2821...failure.\nAttempting automerge of 94-2820...success.\nAutofilling 77-2820...unexpected conflict.  Backtracking...\nAutofilling 77-2819...unexpected conflict.  Backtracking...\nAutofilling 77-2818...unexpected conflict.  Backtracking...\nAutofilling 77-2817...unexpected conflict.  Backtracking...\nAutofilling 77-2816...unexpected conflict.  Backtracking...\nAutofilling 77-2815...unexpected conflict.  Backtracking...\nAutofilling 77-2814...unexpected conflict.  Backtracking...\nAutofilling 77-2813...unexpected conflict.  Backtracking...\nAutofilling 77-2812...unexpected conflict.  Backtracking...\nAutofilling 77-2811...unexpected conflict.  Backtracking...\nAutofilling 77-2810...unexpected conflict.  Backtracking...\nAutofilling 77-2809...unexpected conflict.  Backtracking...\nAutofilling 77-2808...unexpected conflict.  Backtracking...\n...\nAutofilling 77-1841...unexpected conflict.  Backtracking...\nAutofilling 77-1840...Traceback (most recent call last):\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 3947, in <module>\n    main(sys.argv[1:])\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 3928, in main\n    cmd_continue(parser, options)\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 3499, in cmd_continue\n    merge_state.auto_complete_frontier()\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 2459, in auto_complete_frontier\n    frontier.auto_expand()\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 1603, in auto_expand\n    if block.auto_expand_frontier():\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 1901, in auto_expand_frontier\n    return self.auto_outline_frontier()\n  File \"/Users/theraven/tmp/git-imerge/git-imerge\", line 1885, in auto_outline_frontier\n    return self.auto_outline_frontier(merge_frontier)\nThe last line then repeats a lot of times.  I've spent about a week and a half of CPU time on this merge so far, so if there's a way to recover without starting again then that would be very helpful.\nI'm not sure if it's related, but I ran a git gc last night because the individual merges were taking around 20 seconds (now they're down to 1-2 seconds) and at that speed it would have taken about six months to finish the merge.\nThe upstream repo is:\nhttps://github.com/llvm-mirror/clang\nAnd I'm merging into:\nhttps://github.com/ctSRD-CHERI/clang/\nNote: I'm having to use the loosen-first-parent-rule branch of git-imerge, because master fails to find a common parent.. Actually, my issue might be caused by running out of stack space in the recursive call to auto_outline_frontier: I don't know how big the Python stack can be, but 1000 stack frames might be a few too many.  . It appears that my issue was, indeed, caused by the fact that Python doesn't do tail call optimisation.  The following ugly hack fixed it for me:\n```diff\n--- a/git-imerge\n+++ b/git-imerge\n@@ -1882,7 +1882,7 @@ class Block(object):\n             # One of the merges that we expected to succeed in\n             # fact failed.\n             merge_frontier.remove_failure(e.i1, e.i2)\n-            return self.auto_outline_frontier(merge_frontier)\n+            raise Exception(merge_frontier)\n         else:\n             f1, f2 = merge_frontier.partition(best_block)\n             if f1:\n@@ -1898,7 +1898,17 @@ class Block(object):\n         elif merge_state.goal == 'full':\n             return self.auto_fill_micromerge()\n         else:\n-            return self.auto_outline_frontier()\n+            try:\n+                return self.auto_outline_frontier()\n+            except Exception as mf:\n+                merge_frontier = mf.args[0]\n+                while True:\n+                    try:\n+                        return self.auto_outline_frontier(merge_frontier)\n+                    except Exception as mf:\n+                        merge_frontier = mf.args[0]\n+\n+\n # The codes in the 2D array returned from create_diagram()\n MERGE_UNKNOWN = 0\n\n```\nA similar but less ugly fix is probably required, as backtracking is currently limited to a depth of around 1,000 by the Python default stack size (and can't easily grow larger without running out of C stack space).  . The merge did succeed last night.  It looks as if I'd missed some commit markers in one of the previous merges and so the next one ended up being nonsense and git-imerge gave up because of this.  Backtracking around 2000 upstream revisions undid this error and let me fix it properly (well, in a way that didn't conflict - I need to wait for the LLVM merge to finish before I can tell whether it's actually working).  The backtracking took about 45 minutes, which was not that bad in comparison to a merge that took two and a half weeks overall.  Almost all of this time is spent autofilling, and so anything that could reduce the number of those that are done would help a lot.  It would also possibly help if git-imerge could time the pairwise merges and run git gc periodically if the time has increased a lot.  I've found that it creeps from about 2 seconds to about 30 seconds in the larger merge and then drops down a lot after a gc.  The gc isn't deleting much, but the compression stage appears to dramatically reduce the amount of I/O the git processes do (and means that they're sitting at 100% CPU usage, rather than mostly blocked on I/O, even with a fast SSD).  . ",
    "kastiglione": "\nThis approach seems very promising.\n\nIt does sounds promising! I'm using git-imerge for the first time, and the above filling strategy sounds like it would be helpful for my case too. I don't know git internals, nor git-imerge's implementation, how much learning curve is involved in attempting to implement the above strategy?\n. I've never used or turned on rerere.\n. So apparently rerere was previously used in this repo, and apparently that info gets included as part of the clone. TIL.\n. Thanks @johnkeeping :ok_hand: \n. > This approach seems very promising.\nIt does sounds promising! I'm using git-imerge for the first time, and the above filling strategy sounds like it would be helpful for my case too. I don't know git internals, nor git-imerge's implementation, how much learning curve is involved in attempting to implement the above strategy?\n. I've never used or turned on rerere.\n. So apparently rerere was previously used in this repo, and apparently that info gets included as part of the clone. TIL.\n. Thanks @johnkeeping :ok_hand: \n. ",
    "BrendanAnnable": "Just tried imerge out today since I had an old branch that needed a merge from master and can confirm this issue of very slow autofilling. It's been running for a few hours and still going.\nCould we add a --verbose flag which shows all executed git commands to see what commands  are slow?. Just tried imerge out today since I had an old branch that needed a merge from master and can confirm this issue of very slow autofilling. It's been running for a few hours and still going.\nCould we add a --verbose flag which shows all executed git commands to see what commands  are slow?. ",
    "mackross": "just keep running it over and over. thats what i did and eventually it finished.\n. just keep running it over and over. thats what i did and eventually it finished.\n. ",
    "ghost": "I can't reopen the bug, but I have an idea. Don't use a config file for state information. Configuration and state are two very different types of information. I hand edit config files and don't like tools to mess around with my handcrafted config file.\nPlease use a different file than .git/config or maybe a folder .git/imerge with one file per merge?\nPlease reopen this as nice-to-have. Would be an easy target for somebody starting to contribute to git-imerge. - Thank you!\n. I can't reopen the bug, but I have an idea. Don't use a config file for state information. Configuration and state are two very different types of information. I hand edit config files and don't like tools to mess around with my handcrafted config file.\nPlease use a different file than .git/config or maybe a folder .git/imerge with one file per merge?\nPlease reopen this as nice-to-have. Would be an easy target for somebody starting to contribute to git-imerge. - Thank you!\n. ",
    "Stunner": "Sorry about that, looks like someone from the odigeoteam committed within the last 12 days. Should be reproducable with these two commits:\nhttps://github.com/odigeoteam/nui/commit/35391f2f14fe57a55b7b39ce228255b41a859b67\nand \nhttps://github.com/Stunner/nui/commit/a518fab1da88ac0bfba27c4e8402cc27c74c8af6\nI tried it twice and got the same issue, so I assume it is repeatable.\n. Tried again and it appears to be failing earlier than last time:\n$ git-imerge merge odigeoteam/master\nAttempting automerge of 1-1...success.\nAttempting automerge of 1-11...success.\nAttempting automerge of 1-17...Traceback (most recent call last):\n  File \"/usr/local/bin/git-imerge\", line 3316, in <module>\n    main(sys.argv[1:])\n  File \"/usr/local/bin/git-imerge\", line 136, in wrapper\n    return f(*args, **kw)\n  File \"/usr/local/bin/git-imerge\", line 3132, in main\n    merge_state.auto_complete_frontier()\n  File \"/usr/local/bin/git-imerge\", line 2169, in auto_complete_frontier\n    frontier.auto_expand()\n  File \"/usr/local/bin/git-imerge\", line 1324, in auto_expand\n    if block.auto_expand_frontier():\n  File \"/usr/local/bin/git-imerge\", line 1622, in auto_expand_frontier\n    return self.auto_outline_frontier()\n  File \"/usr/local/bin/git-imerge\", line 1592, in auto_outline_frontier\n    merge_frontier = MergeFrontier.compute_by_bisection(self)\n  File \"/usr/local/bin/git-imerge\", line 898, in compute_by_bisection\n    1, block.len2,\n  File \"/usr/local/bin/git-imerge\", line 212, in find_first_false\n    if f(mid):\n  File \"/usr/local/bin/git-imerge\", line 897, in <lambda>\n    lambda i: block.is_mergeable(i1, i),\n  File \"/usr/local/bin/git-imerge\", line 1475, in is_mergeable\n    automerge(self[i1, 0].sha1, self[0, i2].sha1)\n  File \"/usr/local/bin/git-imerge\", line 563, in automerge\n    call_silently(['git', 'checkout', '-f', commit1])\n  File \"/usr/local/bin/git-imerge\", line 230, in call_silently\n    raise CalledProcessError(retcode, cmd)\nsubprocess.CalledProcessError: Command '[u'git', u'checkout', u'-f', u'8ead12a24669dbd96db16a73fd32c72e56223501']' returned non-zero exit status 128\n$ git --version\ngit version 2.1.0\nRan it again after doing git-imerge remove and got a different error:\n$ git-imerge merge odigeoteam/master\nAttempting automerge of 1-1...success.\nAttempting automerge of 1-12...success.\nAttempting automerge of 1-18...success.\nAttempting automerge of 1-21...success.\nAttempting automerge of 1-23...success.\nAttempting automerge of 4-23...failure.\nAttempting automerge of 3-23...Traceback (most recent call last):\n  File \"/usr/local/bin/git-imerge\", line 3316, in <module>\n    main(sys.argv[1:])\n  File \"/usr/local/bin/git-imerge\", line 136, in wrapper\n    return f(*args, **kw)\n  File \"/usr/local/bin/git-imerge\", line 3132, in main\n    merge_state.auto_complete_frontier()\n  File \"/usr/local/bin/git-imerge\", line 2169, in auto_complete_frontier\n    frontier.auto_expand()\n  File \"/usr/local/bin/git-imerge\", line 1324, in auto_expand\n    if block.auto_expand_frontier():\n  File \"/usr/local/bin/git-imerge\", line 1622, in auto_expand_frontier\n    return self.auto_outline_frontier()\n  File \"/usr/local/bin/git-imerge\", line 1592, in auto_outline_frontier\n    merge_frontier = MergeFrontier.compute_by_bisection(self)\n  File \"/usr/local/bin/git-imerge\", line 949, in compute_by_bisection\n    i1 + 1, block.len1 - 1,\n  File \"/usr/local/bin/git-imerge\", line 212, in find_first_false\n    if f(mid):\n  File \"/usr/local/bin/git-imerge\", line 948, in <lambda>\n    lambda i: block.is_mergeable(i, i2 - 1),\n  File \"/usr/local/bin/git-imerge\", line 1475, in is_mergeable\n    automerge(self[i1, 0].sha1, self[0, i2].sha1)\n  File \"/usr/local/bin/git-imerge\", line 573, in automerge\n    call_silently(['git', 'reset', '--merge'])\n  File \"/usr/local/bin/git-imerge\", line 230, in call_silently\n    raise CalledProcessError(retcode, cmd)\nsubprocess.CalledProcessError: Command '[u'git', u'reset', u'--merge']' returned non-zero exit status 128\nReliably crashes but unpredictable as to where it will crash each time...\n. Yes I am running this on OS X. I have never used rerere so I don't think that would be an issue.\nI am on OS X 10.10.3 with git version 2.1.0 and here is the output from git config --list:\n$ git config --list\nuser.email=a****@gmail.com\nuser.name=Aaron Jubbal\ncolor.ui=true\npush.default=simple\ncore.repositoryformatversion=0\ncore.filemode=true\ncore.bare=false\ncore.logallrefupdates=true\ncore.ignorecase=true\ncore.precomposeunicode=true\nremote.origin.url=https://github.com/Stunner/nui.git\nremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\nbranch.master.remote=origin\nbranch.master.merge=refs/heads/master\nbranch.tests.remote=origin\nbranch.tests.merge=refs/heads/tests\nbranch.accomodate-custom-controls.remote=origin\nbranch.accomodate-custom-controls.merge=refs/heads/accomodate-custom-controls\nbranch.all-changes.remote=origin\nbranch.all-changes.merge=refs/heads/all-changes\nremote.odigeoteam.url=https://github.com/odigeoteam/nui.git\nremote.odigeoteam.fetch=+refs/heads/*:refs/remotes/odigeoteam/*\nbranch.develop.remote=origin\nbranch.develop.merge=refs/heads/develop\n. Sorry about that, looks like someone from the odigeoteam committed within the last 12 days. Should be reproducable with these two commits:\nhttps://github.com/odigeoteam/nui/commit/35391f2f14fe57a55b7b39ce228255b41a859b67\nand \nhttps://github.com/Stunner/nui/commit/a518fab1da88ac0bfba27c4e8402cc27c74c8af6\nI tried it twice and got the same issue, so I assume it is repeatable.\n. Tried again and it appears to be failing earlier than last time:\n$ git-imerge merge odigeoteam/master\nAttempting automerge of 1-1...success.\nAttempting automerge of 1-11...success.\nAttempting automerge of 1-17...Traceback (most recent call last):\n  File \"/usr/local/bin/git-imerge\", line 3316, in <module>\n    main(sys.argv[1:])\n  File \"/usr/local/bin/git-imerge\", line 136, in wrapper\n    return f(*args, **kw)\n  File \"/usr/local/bin/git-imerge\", line 3132, in main\n    merge_state.auto_complete_frontier()\n  File \"/usr/local/bin/git-imerge\", line 2169, in auto_complete_frontier\n    frontier.auto_expand()\n  File \"/usr/local/bin/git-imerge\", line 1324, in auto_expand\n    if block.auto_expand_frontier():\n  File \"/usr/local/bin/git-imerge\", line 1622, in auto_expand_frontier\n    return self.auto_outline_frontier()\n  File \"/usr/local/bin/git-imerge\", line 1592, in auto_outline_frontier\n    merge_frontier = MergeFrontier.compute_by_bisection(self)\n  File \"/usr/local/bin/git-imerge\", line 898, in compute_by_bisection\n    1, block.len2,\n  File \"/usr/local/bin/git-imerge\", line 212, in find_first_false\n    if f(mid):\n  File \"/usr/local/bin/git-imerge\", line 897, in <lambda>\n    lambda i: block.is_mergeable(i1, i),\n  File \"/usr/local/bin/git-imerge\", line 1475, in is_mergeable\n    automerge(self[i1, 0].sha1, self[0, i2].sha1)\n  File \"/usr/local/bin/git-imerge\", line 563, in automerge\n    call_silently(['git', 'checkout', '-f', commit1])\n  File \"/usr/local/bin/git-imerge\", line 230, in call_silently\n    raise CalledProcessError(retcode, cmd)\nsubprocess.CalledProcessError: Command '[u'git', u'checkout', u'-f', u'8ead12a24669dbd96db16a73fd32c72e56223501']' returned non-zero exit status 128\n$ git --version\ngit version 2.1.0\nRan it again after doing git-imerge remove and got a different error:\n$ git-imerge merge odigeoteam/master\nAttempting automerge of 1-1...success.\nAttempting automerge of 1-12...success.\nAttempting automerge of 1-18...success.\nAttempting automerge of 1-21...success.\nAttempting automerge of 1-23...success.\nAttempting automerge of 4-23...failure.\nAttempting automerge of 3-23...Traceback (most recent call last):\n  File \"/usr/local/bin/git-imerge\", line 3316, in <module>\n    main(sys.argv[1:])\n  File \"/usr/local/bin/git-imerge\", line 136, in wrapper\n    return f(*args, **kw)\n  File \"/usr/local/bin/git-imerge\", line 3132, in main\n    merge_state.auto_complete_frontier()\n  File \"/usr/local/bin/git-imerge\", line 2169, in auto_complete_frontier\n    frontier.auto_expand()\n  File \"/usr/local/bin/git-imerge\", line 1324, in auto_expand\n    if block.auto_expand_frontier():\n  File \"/usr/local/bin/git-imerge\", line 1622, in auto_expand_frontier\n    return self.auto_outline_frontier()\n  File \"/usr/local/bin/git-imerge\", line 1592, in auto_outline_frontier\n    merge_frontier = MergeFrontier.compute_by_bisection(self)\n  File \"/usr/local/bin/git-imerge\", line 949, in compute_by_bisection\n    i1 + 1, block.len1 - 1,\n  File \"/usr/local/bin/git-imerge\", line 212, in find_first_false\n    if f(mid):\n  File \"/usr/local/bin/git-imerge\", line 948, in <lambda>\n    lambda i: block.is_mergeable(i, i2 - 1),\n  File \"/usr/local/bin/git-imerge\", line 1475, in is_mergeable\n    automerge(self[i1, 0].sha1, self[0, i2].sha1)\n  File \"/usr/local/bin/git-imerge\", line 573, in automerge\n    call_silently(['git', 'reset', '--merge'])\n  File \"/usr/local/bin/git-imerge\", line 230, in call_silently\n    raise CalledProcessError(retcode, cmd)\nsubprocess.CalledProcessError: Command '[u'git', u'reset', u'--merge']' returned non-zero exit status 128\nReliably crashes but unpredictable as to where it will crash each time...\n. Yes I am running this on OS X. I have never used rerere so I don't think that would be an issue.\nI am on OS X 10.10.3 with git version 2.1.0 and here is the output from git config --list:\n$ git config --list\nuser.email=a****@gmail.com\nuser.name=Aaron Jubbal\ncolor.ui=true\npush.default=simple\ncore.repositoryformatversion=0\ncore.filemode=true\ncore.bare=false\ncore.logallrefupdates=true\ncore.ignorecase=true\ncore.precomposeunicode=true\nremote.origin.url=https://github.com/Stunner/nui.git\nremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\nbranch.master.remote=origin\nbranch.master.merge=refs/heads/master\nbranch.tests.remote=origin\nbranch.tests.merge=refs/heads/tests\nbranch.accomodate-custom-controls.remote=origin\nbranch.accomodate-custom-controls.merge=refs/heads/accomodate-custom-controls\nbranch.all-changes.remote=origin\nbranch.all-changes.merge=refs/heads/all-changes\nremote.odigeoteam.url=https://github.com/odigeoteam/nui.git\nremote.odigeoteam.fetch=+refs/heads/*:refs/remotes/odigeoteam/*\nbranch.develop.remote=origin\nbranch.develop.merge=refs/heads/develop\n. ",
    "TimvdLippe": "This issue was already fixed in #87\n. Ah I misunderstood. Maybe it is good to highlight in this issue what is fixed already and what isn't.\n. This issue was already fixed in #87\n. Ah I misunderstood. Maybe it is good to highlight in this issue what is fixed already and what isn't.\n. ",
    "rhunter": "The changes I submitted should have fixed the first part of this\n(end-of-line completion), but I don't think those changes helped the second\npart (mid-line completion).\nOn 13/12/2015 9:49 PM, \"Tim van der Lippe\" notifications@github.com wrote:\n\nThis issue was already fixed in #87\nhttps://github.com/mhagger/git-imerge/pull/87\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mhagger/git-imerge/issues/86#issuecomment-164246901.\n. Good idea. I'll edit the issue next time I get to my computer.\n\n(or if someone beats me to it, that's fine too)\nOn 14/12/2015 9:15 AM, \"Tim van der Lippe\" notifications@github.com wrote:\n\nAh I misunderstood. Maybe it is good to highlight in this issue what is\nfixed already and what isn't.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mhagger/git-imerge/issues/86#issuecomment-164302857.\n. Hm, maybe the changes in #87 did address both problems after all. Although mid-command completion with Bash 3.2 doesn't work perfectly, it works well enough now -- it no longer aborts with an error message.\n\nI'll close this ticket.\n. The changes I submitted should have fixed the first part of this\n(end-of-line completion), but I don't think those changes helped the second\npart (mid-line completion).\nOn 13/12/2015 9:49 PM, \"Tim van der Lippe\" notifications@github.com wrote:\n\nThis issue was already fixed in #87\nhttps://github.com/mhagger/git-imerge/pull/87\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mhagger/git-imerge/issues/86#issuecomment-164246901.\n. Good idea. I'll edit the issue next time I get to my computer.\n\n(or if someone beats me to it, that's fine too)\nOn 14/12/2015 9:15 AM, \"Tim van der Lippe\" notifications@github.com wrote:\n\nAh I misunderstood. Maybe it is good to highlight in this issue what is\nfixed already and what isn't.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/mhagger/git-imerge/issues/86#issuecomment-164302857.\n. Hm, maybe the changes in #87 did address both problems after all. Although mid-command completion with Bash 3.2 doesn't work perfectly, it works well enough now -- it no longer aborts with an error message.\n\nI'll close this ticket.\n. ",
    "bozzzzo": "This patch solves a PEBKAC (me in this case) where I sometimes still get confused by\ngit rebase moving the branch I am on, and not the branch I specify...\nSo I was on master branch and did a git-imerge rebase side-branch. If I were doing a plain\ngit rebase I would just have to do it again. But with git-imerge I had the correct rebase results\nalso done only there was no command to access the other one...\n. This patch solves a PEBKAC (me in this case) where I sometimes still get confused by\ngit rebase moving the branch I am on, and not the branch I specify...\nSo I was on master branch and did a git-imerge rebase side-branch. If I were doing a plain\ngit rebase I would just have to do it again. But with git-imerge I had the correct rebase results\nalso done only there was no command to access the other one...\n. ",
    "rulatir": "Allright, it's git imerge remove followed by checking out the branch I was on before starting the merge. I used gitk --all and still saw lots of imerge commits, but that was just due to the last of them being referenced by HEAD. After checking the original branch they are gone.\n. You mean a PR with appropriate changes to readme?\nAnyways, git-imerge works by creating separate branches for its operation and commits to those. It does not touch the original branches until it is 100% done merging. Apparently git-imerge remove is the command to simply remove the branches created by git-imerge, but if you do it mid-merge, HEAD might remain pointing to some commit created by git-imerge even though that commit is no longer on any branch (i.e. detached HEAD). This is very visible if you use a visual tool that displays the commit graph (because you see the entire \"fan\" of git-imerge's intermediate merge commits leading up to the commit pointed to by HEAD), but once you check out your original branch (the one you were on when you started git-imerge), those commits will likely be gone from the commit graph because they will no longer be referenced by anything.\n. Allright, it's git imerge remove followed by checking out the branch I was on before starting the merge. I used gitk --all and still saw lots of imerge commits, but that was just due to the last of them being referenced by HEAD. After checking the original branch they are gone.\n. You mean a PR with appropriate changes to readme?\nAnyways, git-imerge works by creating separate branches for its operation and commits to those. It does not touch the original branches until it is 100% done merging. Apparently git-imerge remove is the command to simply remove the branches created by git-imerge, but if you do it mid-merge, HEAD might remain pointing to some commit created by git-imerge even though that commit is no longer on any branch (i.e. detached HEAD). This is very visible if you use a visual tool that displays the commit graph (because you see the entire \"fan\" of git-imerge's intermediate merge commits leading up to the commit pointed to by HEAD), but once you check out your original branch (the one you were on when you started git-imerge), those commits will likely be gone from the commit graph because they will no longer be referenced by anything.\n. ",
    "sboukortt": "Oops, I hadn\u2019t noticed the existence of PR #94. My bad.\n. Oops, I hadn\u2019t noticed the existence of PR #94. My bad.\n. ",
    "mulle-nat": "Looks related, that's as much as I can say. :)\n. Looks related, that's as much as I can say. :)\n. ",
    "USBhost": "will do.\nEDIT: 1\n@mhagger it did not work\n~/kernel/FIRE-ICE$ ../git-imerge/git-imerge merge v3.10.102\nCommit \"ca1199fccf14540e86f6da955333e31d6fec5f3e\" is not a first-parent ancestor of \"testing\"\ngit clone https://github.com/USBhost/FIRE-ICE.git\ngit clone https://github.com/mhagger/git-imerge.git \ncd git-imerge \ngit cherry-pick 728e84fc07353a7f4068edbfcfa7cb02ab7a8aa2\ncd ..\ncd FIRE-ICE\ngit remote add upstream https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\ngit remote update\n../git-imerge/git-imerge merge v3.10.102\nhttp://pastebin.com/LBzF5S09\n. ```\ndiff --git a/git-imerge b/git-imerge\nindex 1482310..6afaae0 100755\n--- a/git-imerge\n+++ b/git-imerge\n@@ -3027,7 +3027,7 @@ def cmd_init(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n merge_state = MergeState.initialize(\n     options.name, merge_base,\n\n@@ -3063,7 +3063,7 @@ def cmd_start(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n merge_state = MergeState.initialize(\n     options.name, merge_base,\n\n@@ -3127,7 +3127,7 @@ def cmd_merge(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n     except NothingToDoError as e:\n         sys.stdout.write('Already up-to-date.\\n')\n         sys.exit(0)\n@@ -3197,7 +3197,7 @@ def cmd_rebase(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n     except NothingToDoError as e:\n         sys.stdout.write('Already up-to-date.\\n')\n         sys.exit(0)\n@@ -3242,7 +3242,7 @@ def cmd_drop(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n # Suppose we want to drop commits 2 and 3 in the branch below.\n # Then we set up an imerge as follows:\n\n@@ -3318,7 +3318,7 @@ def cmd_drop(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n     except NothingToDoError as e:\n         sys.stdout.write('Already up-to-date.\\n')\n         sys.exit(0)\n@@ -3364,7 +3364,7 @@ def cmd_revert(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n # Suppose we want to revert commits 2 and 3 in the branch below.\n # Then we set up an imerge as follows:\n\n@@ -3435,7 +3435,7 @@ def cmd_revert(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n     except NothingToDoError as e:\n         sys.stdout.write('Already up-to-date.\\n')\n         sys.exit(0)\n```\nthis only fixes the\nTraceback (most recent call last):\nFile \"../git-imerge/git-imerge\", line 3926, in \nmain(sys.argv[1:])\nFile \"../git-imerge/git-imerge\", line 3895, in main\ncmd_start(parser, options)\nFile \"../git-imerge/git-imerge\", line 3066, in cmd_start\nparser.error('%s\\nPerhaps use \"--first-parent\"?', e)\nTypeError: error() takes exactly 2 arguments (3 given)\nbut i still get \n```\nusbhost@Christina:~/kernel/FIRE-ICE$ ../git-imerge/git-imerge start --name=v3.10.102 --goal=full v3.10.102\nusage: git-imerge [-h]\n                  {start,merge,rebase,drop,revert,continue,finish,diagram,list,init,record,autofill,simplify,remove,reparent}\n                  ...\ngit-imerge: error: The history \"ca1199fccf14540e86f6da955333e31d6fec5f3e..testing\" is not linear\nPerhaps use \"--first-parent\"?\nusbhost@Christina:~/kernel/FIRE-ICE$ ../git-imerge/git-imerge start --name=v3.10.102 --goal=full --first-parent v3.10.102\nCommit \"ca1199fccf14540e86f6da955333e31d6fec5f3e\" is not a first-parent ancestor of \"testing\"\nusbhost@Christina:~/kernel/FIRE-ICE$ \n```\n. Reverting back to e8da000b925562cc34941079cd74fd4a1ae51de1 fixed all My problems.\nBut I did not try anything after it but I expect it would still work until 26d4f9a41ff64183539b1ddc18522bf944e5b2c3\nIt would be nice to ad an force option to make it go anyway.\nAnd git-imerge worked as expected merging tags and Linux kernel branches just fine\nLike merging linux-3.10.y into an Android kernel.\nThat saved me a lot of time!!! Updating from 3.10.40 to 3.10.101\nIn one day!!\nI may try hacking it to work but my Python skills are.... Not the best.\nLooks like I will be staying on the old version for now.\n. @mhagger  will do man \ud83d\ude02 \nYour commit got lost in my email \n. will do.\nEDIT: 1\n@mhagger it did not work\n~/kernel/FIRE-ICE$ ../git-imerge/git-imerge merge v3.10.102\nCommit \"ca1199fccf14540e86f6da955333e31d6fec5f3e\" is not a first-parent ancestor of \"testing\"\ngit clone https://github.com/USBhost/FIRE-ICE.git\ngit clone https://github.com/mhagger/git-imerge.git \ncd git-imerge \ngit cherry-pick 728e84fc07353a7f4068edbfcfa7cb02ab7a8aa2\ncd ..\ncd FIRE-ICE\ngit remote add upstream https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git\ngit remote update\n../git-imerge/git-imerge merge v3.10.102\nhttp://pastebin.com/LBzF5S09\n. ```\ndiff --git a/git-imerge b/git-imerge\nindex 1482310..6afaae0 100755\n--- a/git-imerge\n+++ b/git-imerge\n@@ -3027,7 +3027,7 @@ def cmd_init(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n merge_state = MergeState.initialize(\n     options.name, merge_base,\n\n@@ -3063,7 +3063,7 @@ def cmd_start(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n merge_state = MergeState.initialize(\n     options.name, merge_base,\n\n@@ -3127,7 +3127,7 @@ def cmd_merge(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n     except NothingToDoError as e:\n         sys.stdout.write('Already up-to-date.\\n')\n         sys.exit(0)\n@@ -3197,7 +3197,7 @@ def cmd_rebase(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n     except NothingToDoError as e:\n         sys.stdout.write('Already up-to-date.\\n')\n         sys.exit(0)\n@@ -3242,7 +3242,7 @@ def cmd_drop(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n # Suppose we want to drop commits 2 and 3 in the branch below.\n # Then we set up an imerge as follows:\n\n@@ -3318,7 +3318,7 @@ def cmd_drop(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n     except NothingToDoError as e:\n         sys.stdout.write('Already up-to-date.\\n')\n         sys.exit(0)\n@@ -3364,7 +3364,7 @@ def cmd_revert(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n # Suppose we want to revert commits 2 and 3 in the branch below.\n # Then we set up an imerge as follows:\n\n@@ -3435,7 +3435,7 @@ def cmd_revert(parser, options):\n         if options.first_parent:\n             parser.error(str(e))\n         else:\n-            parser.error('%s\\nPerhaps use \"--first-parent\"?', e)\n+            parser.error('%s\\nPerhaps use \"--first-parent\"?' % (e,))\n     except NothingToDoError as e:\n         sys.stdout.write('Already up-to-date.\\n')\n         sys.exit(0)\n```\nthis only fixes the\nTraceback (most recent call last):\nFile \"../git-imerge/git-imerge\", line 3926, in \nmain(sys.argv[1:])\nFile \"../git-imerge/git-imerge\", line 3895, in main\ncmd_start(parser, options)\nFile \"../git-imerge/git-imerge\", line 3066, in cmd_start\nparser.error('%s\\nPerhaps use \"--first-parent\"?', e)\nTypeError: error() takes exactly 2 arguments (3 given)\nbut i still get \n```\nusbhost@Christina:~/kernel/FIRE-ICE$ ../git-imerge/git-imerge start --name=v3.10.102 --goal=full v3.10.102\nusage: git-imerge [-h]\n                  {start,merge,rebase,drop,revert,continue,finish,diagram,list,init,record,autofill,simplify,remove,reparent}\n                  ...\ngit-imerge: error: The history \"ca1199fccf14540e86f6da955333e31d6fec5f3e..testing\" is not linear\nPerhaps use \"--first-parent\"?\nusbhost@Christina:~/kernel/FIRE-ICE$ ../git-imerge/git-imerge start --name=v3.10.102 --goal=full --first-parent v3.10.102\nCommit \"ca1199fccf14540e86f6da955333e31d6fec5f3e\" is not a first-parent ancestor of \"testing\"\nusbhost@Christina:~/kernel/FIRE-ICE$ \n```\n. Reverting back to e8da000b925562cc34941079cd74fd4a1ae51de1 fixed all My problems.\nBut I did not try anything after it but I expect it would still work until 26d4f9a41ff64183539b1ddc18522bf944e5b2c3\nIt would be nice to ad an force option to make it go anyway.\nAnd git-imerge worked as expected merging tags and Linux kernel branches just fine\nLike merging linux-3.10.y into an Android kernel.\nThat saved me a lot of time!!! Updating from 3.10.40 to 3.10.101\nIn one day!!\nI may try hacking it to work but my Python skills are.... Not the best.\nLooks like I will be staying on the old version for now.\n. @mhagger  will do man \ud83d\ude02 \nYour commit got lost in my email \n. ",
    "kergoth": "I have the same problem. This is a pretty clear regression in functionality, not an enhancement. I'm reverting too.\n. I doubt I'd have time to write unit tests, myself, but as feedback, #111 works for me in the one repo where I use imerge on a regular basis (maintaining long-lived release branches). Thanks much for your work on this. I'll keep using the version from #111 and see if I run into any issues. Hopefully one of the other folks with this issue can do more testing than I.\n. I have the same problem. This is a pretty clear regression in functionality, not an enhancement. I'm reverting too.\n. I doubt I'd have time to write unit tests, myself, but as feedback, #111 works for me in the one repo where I use imerge on a regular basis (maintaining long-lived release branches). Thanks much for your work on this. I'll keep using the version from #111 and see if I run into any issues. Hopefully one of the other folks with this issue can do more testing than I.\n. ",
    "dregad": "For the record, I faced the same issue trying to imerge mantisbt mantisbt/mantisbt@5d2f72a95c0397a2abc936736f0437bc0e553166 (master-1.3.x branch) into mantisbt/mantisbt@67f2bd428af37fd8863c33691b811273ab9f35bb (master branch).\nReverting to 0.7.0 fixed the problem for now; I'll test your proposed fix later as time allows.\n. For the record, I faced the same issue trying to imerge mantisbt mantisbt/mantisbt@5d2f72a95c0397a2abc936736f0437bc0e553166 (master-1.3.x branch) into mantisbt/mantisbt@67f2bd428af37fd8863c33691b811273ab9f35bb (master branch).\nReverting to 0.7.0 fixed the problem for now; I'll test your proposed fix later as time allows.\n. ",
    "cproensa": "I could perform a merge with the #111 code, in the same scenario as @dregad reported. I could perform a merge with the #111 code, in the same scenario as @dregad reported. ",
    "orao": "I'm reasonably new to python but one thing that I would want to be considered is the installation of the dependencies on the machine that is running this script. To get libgit2 going I had to compile libgit2 itself and subsequently use pip to install the python bindings.\nKeeping the dependencies and installation simple should be one of the considerations when making this decision.\n. This seems related to issue #107.\n. Why are we trying to \"redo a merge\" here? If the two branches have already been merged, isn't our new merge base E?\nThis is a feature that allows you to rewrite a merge history another time and as such this merge history should be pre-populated in the matrix.\nB, C, D, E, V, W, X, and M represent an already completed merge matrix with no intermediate merges recorded. E, F, G, M, and Y represent a new matrix. i.e.\nB---C---D---E---F---G\n|           |       |\nV           ?       |\n|           |       |\nW           ?       |\n|           |       |\nX---?---?---M       ?\n            |       |\n            Y---?---X\n. @mhagger ah, sorry, I must have misunderstood. With this case it then becomes more interesting.\nThough flattening the graph is simpler it isn't necessarily representative and I see this merge M potentially introducing another dimension/axis to the matrix in this case. However, this would slow down the algorithm and it would hence be beneficial to attempt to flatten first. Though I understand why, I still suspect that flattening may be the wrong thing to do here...\n. I'm reasonably new to python but one thing that I would want to be considered is the installation of the dependencies on the machine that is running this script. To get libgit2 going I had to compile libgit2 itself and subsequently use pip to install the python bindings.\nKeeping the dependencies and installation simple should be one of the considerations when making this decision.\n. This seems related to issue #107.\n. Why are we trying to \"redo a merge\" here? If the two branches have already been merged, isn't our new merge base E?\nThis is a feature that allows you to rewrite a merge history another time and as such this merge history should be pre-populated in the matrix.\nB, C, D, E, V, W, X, and M represent an already completed merge matrix with no intermediate merges recorded. E, F, G, M, and Y represent a new matrix. i.e.\nB---C---D---E---F---G\n|           |       |\nV           ?       |\n|           |       |\nW           ?       |\n|           |       |\nX---?---?---M       ?\n            |       |\n            Y---?---X\n. @mhagger ah, sorry, I must have misunderstood. With this case it then becomes more interesting.\nThough flattening the graph is simpler it isn't necessarily representative and I see this merge M potentially introducing another dimension/axis to the matrix in this case. However, this would slow down the algorithm and it would hence be beneficial to attempt to flatten first. Though I understand why, I still suspect that flattening may be the wrong thing to do here...\n. ",
    "jasonkarns": "Is there currently a build step? Could run help2man on git-imerge and package the output as the manpage. (First naive attempt failed because git-imerge doesn't yet have --version :) )\n. Looks like no. Doing it in the makefile on install would require help2man on users' machines.\n. Is there currently a build step? Could run help2man on git-imerge and package the output as the manpage. (First naive attempt failed because git-imerge doesn't yet have --version :) )\n. Looks like no. Doing it in the makefile on install would require help2man on users' machines.\n. ",
    "phord": "Do you know that -h works even when --help does not?  Do you know why?  \n\n$ git imerge --help\nNo manual entry for git-imerge\nSee 'man 7 undocumented' for help when manual pages are not available.\n$ git imerge -h\nusage: git-imerge [-h]\n                  {start,merge,rebase,drop,revert,continue,finish,diagram,list,init,record,autofill,simplify,remove,reparent}\n...\n. Do you know that -h works even when --help does not?  Do you know why?  \n$ git imerge --help\nNo manual entry for git-imerge\nSee 'man 7 undocumented' for help when manual pages are not available.\n$ git imerge -h\nusage: git-imerge [-h]\n                  {start,merge,rebase,drop,revert,continue,finish,diagram,list,init,record,autofill,simplify,remove,reparent}\n...\n. \n",
    "mgorovoy": "Here is the error message that I get:\n(development) $git imerge start --name=dev60 --first-parent release/6.0\nThere are no commits on \"development\" that are not already in \"release/6.0\"\n. Here is the error message that I get:\n(development) $git imerge start --name=dev60 --first-parent release/6.0\nThere are no commits on \"development\" that are not already in \"release/6.0\"\n. ",
    "GeirGrusom": "I managed to get around this by producing a new branch which merged early commits past the two different convergent points suggested by git-log and git-imerge.. @mhagger That branch solved my issue! Great work!. I managed to get around this by producing a new branch which merged early commits past the two different convergent points suggested by git-log and git-imerge.. @mhagger That branch solved my issue! Great work!. ",
    "greened": "I generally agree but didn't want to change the current behavior without asking.  It's up to @mhagger what the default should be.. I generally agree but didn't want to change the current behavior without asking.  It's up to @mhagger what the default should be.. ",
    "dcci": "I can probably create a branch, move current head then rebase and squash, but it would be nice if this was handled automatically by a command in git imerge. I mean exactly what's described in #101.. I can probably create a branch, move current head then rebase and squash, but it would be nice if this was handled automatically by a command in git imerge. I mean exactly what's described in #101.. ",
    "dueringa": "Forgot the python version:\n$ python --version\nPython 3.6.0. Maybe this is related to #62 ?. The output of cat-file of the commit is the weird encoding is\n00000000  74 72 65 65 20 62 34 38  65 63 35 62 62 64 61 35  |tree b48ec5bbda5|\n00000010  33 33 63 35 63 66 30 32  36 62 33 64 38 36 33 33  |33c5cf026b3d8633|\n00000020  31 33 32 62 33 63 64 38  39 35 39 34 37 0a 70 61  |132b3cd895947.pa|\n00000030  72 65 6e 74 20 33 32 62  34 32 66 61 32 39 34 39  |rent 32b42fa2949|\n00000040  30 30 36 66 66 38 62 30  32 39 61 30 66 64 63 64  |006ff8b029a0fdcd|\n00000050  62 34 66 35 63 31 63 32  61 33 30 62 39 0a 61 75  |b4f5c1c2a30b9.au|\n00000060  74 68 6f 72 20 41 6e 64  72 65 61 73 20 44 c3 83  |thor Andreas D..|\n00000070  c2 bc 72 69 6e 67 20 3c  41 6e 64 72 65 61 73 2e  |..ring <Andreas.|\n00000080  64 75 65 72 69 6e 67 40  63 6f 6d 70 61 6e 79 3e  |duering@company>|\n00000090  20 31 34 39 34 38 34 36  38 34 34 20 2b 30 32 30  | 1494846844 +020|\n000000a0  30 0a 63 6f 6d 6d 69 74  74 65 72 20 41 6e 64 72  |0.committer Andr|\n000000b0  65 61 73 20 44 c3 bc 72  69 6e 67 20 3c 41 6e 64  |eas D..ring <And|\n000000c0  72 65 61 73 2e 64 75 65  72 69 6e 67 40 63 6f 6d  |reas.duering@com|\n000000d0  70 61 6e 79 3e 20 31 34  39 34 38 36 31 39 38 36  |pany> 1494861986|\n000000e0  20 2b 30 32 30 30 0a 0a  6d 65 73 73 61 67 65 0a  | +0200..message.|\n000000f0\nSo for the author, \u00fc is encoded as c3 83 c2 bc, for the committer as c3 bc (which is the correct UTF-8 encoding of \u00fc).\nAnd the output of the parent commit\n00000000  74 72 65 65 20 61 34 33  39 65 37 34 36 31 66 61  |tree a439e7461fa|\n00000010  64 62 63 64 65 61 30 35  31 34 36 61 61 65 63 64  |dbcdea05146aaecd|\n00000020  35 31 33 63 35 39 34 61  32 36 38 62 30 0a 70 61  |513c594a268b0.pa|\n00000030  72 65 6e 74 20 33 37 31  64 62 65 36 33 63 65 63  |rent 371dbe63cec|\n00000040  36 36 64 63 61 61 33 30  35 38 63 66 35 38 32 35  |66dcaa3058cf5825|\n00000050  32 61 64 35 32 33 64 66  39 36 62 65 64 0a 61 75  |2ad523df96bed.au|\n00000060  74 68 6f 72 20 41 6e 64  72 65 61 73 20 44 c3 bc  |thor Andreas D..|\n00000070  72 69 6e 67 20 3c 41 6e  64 72 65 61 73 2e 64 75  |ring <Andreas.du|\n00000080  65 72 69 6e 67 40 63 6f  6d 70 61 6e 79 3e 20 31  |ering@company> 1|\n00000090  34 39 34 38 34 31 32 31  30 20 2b 30 32 30 30 0a  |494841210 +0200.|\n000000a0  63 6f 6d 6d 69 74 74 65  72 20 41 6e 64 72 65 61  |committer Andrea|\n000000b0  73 20 44 c3 bc 72 69 6e  67 20 3c 41 6e 64 72 65  |s D..ring <Andre|\n000000c0  61 73 2e 64 75 65 72 69  6e 67 40 63 6f 6d 70 61  |as.duering@compa|\n000000d0  6e 79 3e 20 31 34 39 34  38 34 31 32 31 30 20 2b  |ny> 1494841210 +|\n000000e0  30 32 30 30 0a 0a 6d 65  73 73 61 67 65 0a        |0200..message.|\n000000ee\n$ echo $LANG # mingw64 environment\nde_DE.UTF-8\nHowever, python outputs\n$ python -c 'import locale; print(locale.getpreferredencoding())' #python3 syntax\ncp1252\n\u00fc in cp1252 is 0xfc.. I set up a small demo repo:\nhttps://github.com/dueringa/imerge-encoding-demo\nThe problem only arises on a rebase, not on a merge. yes, your solution works fine. The resulting rebase is encoded correctly.\npossibly further related SO questions (for future readers):\n\nhttp://stackoverflow.com/a/27066059/3872702 - probably linux related\nhttp://stackoverflow.com/a/11516682/3872702 - won't work in mingw shell, no chcp\nhttp://stackoverflow.com/q/31469707/3872702. Forgot the python version:\n$ python --version\nPython 3.6.0. Maybe this is related to #62 ?. The output of cat-file of the commit is the weird encoding is\n\n00000000  74 72 65 65 20 62 34 38  65 63 35 62 62 64 61 35  |tree b48ec5bbda5|\n00000010  33 33 63 35 63 66 30 32  36 62 33 64 38 36 33 33  |33c5cf026b3d8633|\n00000020  31 33 32 62 33 63 64 38  39 35 39 34 37 0a 70 61  |132b3cd895947.pa|\n00000030  72 65 6e 74 20 33 32 62  34 32 66 61 32 39 34 39  |rent 32b42fa2949|\n00000040  30 30 36 66 66 38 62 30  32 39 61 30 66 64 63 64  |006ff8b029a0fdcd|\n00000050  62 34 66 35 63 31 63 32  61 33 30 62 39 0a 61 75  |b4f5c1c2a30b9.au|\n00000060  74 68 6f 72 20 41 6e 64  72 65 61 73 20 44 c3 83  |thor Andreas D..|\n00000070  c2 bc 72 69 6e 67 20 3c  41 6e 64 72 65 61 73 2e  |..ring <Andreas.|\n00000080  64 75 65 72 69 6e 67 40  63 6f 6d 70 61 6e 79 3e  |duering@company>|\n00000090  20 31 34 39 34 38 34 36  38 34 34 20 2b 30 32 30  | 1494846844 +020|\n000000a0  30 0a 63 6f 6d 6d 69 74  74 65 72 20 41 6e 64 72  |0.committer Andr|\n000000b0  65 61 73 20 44 c3 bc 72  69 6e 67 20 3c 41 6e 64  |eas D..ring <And|\n000000c0  72 65 61 73 2e 64 75 65  72 69 6e 67 40 63 6f 6d  |reas.duering@com|\n000000d0  70 61 6e 79 3e 20 31 34  39 34 38 36 31 39 38 36  |pany> 1494861986|\n000000e0  20 2b 30 32 30 30 0a 0a  6d 65 73 73 61 67 65 0a  | +0200..message.|\n000000f0\nSo for the author, \u00fc is encoded as c3 83 c2 bc, for the committer as c3 bc (which is the correct UTF-8 encoding of \u00fc).\nAnd the output of the parent commit\n00000000  74 72 65 65 20 61 34 33  39 65 37 34 36 31 66 61  |tree a439e7461fa|\n00000010  64 62 63 64 65 61 30 35  31 34 36 61 61 65 63 64  |dbcdea05146aaecd|\n00000020  35 31 33 63 35 39 34 61  32 36 38 62 30 0a 70 61  |513c594a268b0.pa|\n00000030  72 65 6e 74 20 33 37 31  64 62 65 36 33 63 65 63  |rent 371dbe63cec|\n00000040  36 36 64 63 61 61 33 30  35 38 63 66 35 38 32 35  |66dcaa3058cf5825|\n00000050  32 61 64 35 32 33 64 66  39 36 62 65 64 0a 61 75  |2ad523df96bed.au|\n00000060  74 68 6f 72 20 41 6e 64  72 65 61 73 20 44 c3 bc  |thor Andreas D..|\n00000070  72 69 6e 67 20 3c 41 6e  64 72 65 61 73 2e 64 75  |ring <Andreas.du|\n00000080  65 72 69 6e 67 40 63 6f  6d 70 61 6e 79 3e 20 31  |ering@company> 1|\n00000090  34 39 34 38 34 31 32 31  30 20 2b 30 32 30 30 0a  |494841210 +0200.|\n000000a0  63 6f 6d 6d 69 74 74 65  72 20 41 6e 64 72 65 61  |committer Andrea|\n000000b0  73 20 44 c3 bc 72 69 6e  67 20 3c 41 6e 64 72 65  |s D..ring <Andre|\n000000c0  61 73 2e 64 75 65 72 69  6e 67 40 63 6f 6d 70 61  |as.duering@compa|\n000000d0  6e 79 3e 20 31 34 39 34  38 34 31 32 31 30 20 2b  |ny> 1494841210 +|\n000000e0  30 32 30 30 0a 0a 6d 65  73 73 61 67 65 0a        |0200..message.|\n000000ee\n$ echo $LANG # mingw64 environment\nde_DE.UTF-8\nHowever, python outputs\n$ python -c 'import locale; print(locale.getpreferredencoding())' #python3 syntax\ncp1252\n\u00fc in cp1252 is 0xfc.. I set up a small demo repo:\nhttps://github.com/dueringa/imerge-encoding-demo\nThe problem only arises on a rebase, not on a merge. yes, your solution works fine. The resulting rebase is encoded correctly.\npossibly further related SO questions (for future readers):\n\nhttp://stackoverflow.com/a/27066059/3872702 - probably linux related\nhttp://stackoverflow.com/a/11516682/3872702 - won't work in mingw shell, no chcp\nhttp://stackoverflow.com/q/31469707/3872702. \n",
    "patrickmckenna": "I don't believe we recorded any of the training sessions from Git Merge 2016, unfortunately. However, my talk was essentially an extended version of the one Michael gave in 2013, which is currently linked to in the README. (I did post my slides, but the rendered versions require a remark-based tool that GitHub discontinued building and thus never open-sourced\u2014so I doubt they'd be very useful.). I don't believe we recorded any of the training sessions from Git Merge 2016, unfortunately. However, my talk was essentially an extended version of the one Michael gave in 2013, which is currently linked to in the README. (I did post my slides, but the rendered versions require a remark-based tool that GitHub discontinued building and thus never open-sourced\u2014so I doubt they'd be very useful.). ",
    "pradyunsg": "Hi @mhagger!\n\nAre you willing to work on it?\n\nNo, not in the near future. I've already committed my OSS time to a different project. I might just come around to this issue someday, which is why I opened this.\n. Hi @mhagger!\n\nAre you willing to work on it?\n\nNo, not in the near future. I've already committed my OSS time to a different project. I might just come around to this issue someday, which is why I opened this.\n. "
}